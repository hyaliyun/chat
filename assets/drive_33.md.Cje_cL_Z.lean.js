import{_ as h,o as n,c as i,a as t,m as c,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,m,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=h(k,[["render",A],["__scopeId","data-v-81d116da"]]),S=JSON.parse('[{"question":"Employee Shift Scheduling You are tasked with developing a program to manage the shift schedules for employees at a company. Each employee has a unique ID and can work different shifts. A shift is represented by a time period in the format \\"hh:mm-hh:mm\\". Your goal is to implement functionalities to manage and query employee shift schedules. Requirements: 1. **Class `EmployeeShift`**: - **Attributes**: - `employee_id` (string): Unique identifier for the employee. - `shifts` (list of tuples): Each tuple represents a shift in the form like `(\'09:00\', \'17:00\')`. - **Methods**: - `add_shift(shift: str)`: Parses the input string shift in the \\"hh:mm-hh:mm\\" format and adds it to the employee\'s shift list. - `remove_shift(shift: str)`: Removes the shift from the employee\'s shift list if it exists. - `get_shifts()`: Returns the list of shifts for the employee in the string format \\"hh:mm-hh:mm\\". 2. **Function `allocate_shift(employees: list, employee_id: str, shift: str) -> str`**: - Adds the specified shift to the employee\'s schedule. - Returns `f\\"Shift {shift} allocated to employee {employee_id}\\"` on successful addition. - If the employee does not exist, return `f\\"Employee {employee_id} not found\\"`. 3. **Function `deallocate_shift(employees: list, employee_id: str, shift: str) -> str`**: - Removes the specified shift from the employee\'s schedule. - Returns `f\\"Shift {shift} removed from employee {employee_id}\\"` on successful removal. - If the employee does not exist, return `f\\"Employee {employee_id} not found\\"`. Example: ```python class EmployeeShift: def __init__(self, employee_id: str): self.employee_id = employee_id self.shifts = [] def add_shift(self, shift: str): start, end = shift.split(\'-\') self.shifts.append((start, end)) def remove_shift(self, shift: str): start, end = shift.split(\'-\') if (start, end) in self.shifts: self.shifts.remove((start, end)) def get_shifts(self): return [f\\"{start}-{end}\\" for start, end in self.shifts] def allocate_shift(employees: list, employee_id: str, shift: str) -> str: for employee in employees: if employee.employee_id == employee_id: employee.add_shift(shift) return f\\"Shift {shift} allocated to employee {employee_id}\\" return f\\"Employee {employee_id} not found\\" def deallocate_shift(employees: list, employee_id: str, shift: str) -> str: for employee in employees: if employee.employee_id == employee_id: employee.remove_shift(shift) return f\\"Shift {shift} removed from employee {employee_id}\\" return f\\"Employee {employee_id} not found\\" if __name__ == \\"__main__\\": employees = [EmployeeShift(\\"E001\\"), EmployeeShift(\\"E002\\"), EmployeeShift(\\"E003\\")] print(allocate_shift(employees, \\"E001\\", \\"09:00-17:00\\")) print(allocate_shift(employees, \\"E001\\", \\"18:00-22:00\\")) print(deallocate_shift(employees, \\"E001\\", \\"09:00-17:00\\")) print(deallocate_shift(employees, \\"E004\\", \\"09:00-17:00\\")) for emp in employees: print(f\\"{emp.employee_id}: {emp.get_shifts()}\\") ``` Constraints: - You may assume all input times are in 24-hour format. - Handle edge cases such as invalid shift time formats gracefully.","solution":"class EmployeeShift: def __init__(self, employee_id: str): self.employee_id = employee_id self.shifts = [] def add_shift(self, shift: str): start, end = shift.split(\'-\') self.shifts.append((start, end)) def remove_shift(self, shift: str): start, end = shift.split(\'-\') if (start, end) in self.shifts: self.shifts.remove((start, end)) def get_shifts(self): return [f\\"{start}-{end}\\" for start, end in self.shifts] def allocate_shift(employees: list, employee_id: str, shift: str) -> str: for employee in employees: if employee.employee_id == employee_id: employee.add_shift(shift) return f\\"Shift {shift} allocated to employee {employee_id}\\" return f\\"Employee {employee_id} not found\\" def deallocate_shift(employees: list, employee_id: str, shift: str) -> str: for employee in employees: if employee.employee_id == employee_id: employee.remove_shift(shift) return f\\"Shift {shift} removed from employee {employee_id}\\" return f\\"Employee {employee_id} not found\\""},{"question":"# Scenario You are developing a system that processes requests from multiple clients. Each request has a priority level, and the system needs to handle the highest priority requests first. You need to implement a priority queue to manage these requests efficiently. # Task Implement a class `PriorityQueue` that supports the following operations: 1. **insert(item, priority)**: Insert an item into the queue with an associated priority. 2. **extract_max()**: Remove and return the item with the highest priority from the queue. 3. **peek_max()**: Return (but do not remove) the item with the highest priority. 4. **change_priority(item, new_priority)**: Change the priority of a given item in the queue. 5. **size()**: Return the number of items in the queue. # Constraints - Implement all methods with consideration for efficiency. - When multiple items have the same highest priority, the queue should follow the order of insertion for those items. - If the item is not found in `change_priority`, handle the situation gracefully. # Input and Output - **insert(item, priority)**: Two parameters `item` (can be any type) and `priority` (a numeric value). - **extract_max()**: No parameters, returns the item with the highest priority. - **peek_max()**: No parameters, returns the item with the highest priority. - **change_priority(item, new_priority)**: Two parameters `item` and `new_priority` (both can be any type). - **size()**: No parameters, returns an integer representing the number of elements. # Example ```python pq = PriorityQueue() pq.insert(\\"task1\\", 5) pq.insert(\\"task2\\", 3) pq.insert(\\"task3\\", 7) print(pq.size()) # Output: 3 print(pq.peek_max()) # Output: \\"task3\\" print(pq.extract_max()) # Output: \\"task3\\" print(pq.size()) # Output: 2 pq.change_priority(\\"task2\\", 8) print(pq.peek_max()) # Output: \\"task2\\" ``` # Implementation Challenge Implement the `PriorityQueue` class ensuring each method adheres to the described behaviors efficiently in terms of time complexity. Use appropriate data structures to maintain the priority queue properties.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] self.entry_finder = {} self.counter = 0 def insert(self, item, priority): entry = [-priority, self.counter, item] self.entry_finder[item] = entry heapq.heappush(self.heap, entry) self.counter += 1 def extract_max(self): while self.heap: priority, count, item = heapq.heappop(self.heap) if item is not None: del self.entry_finder[item] return item raise KeyError(\'pop from an empty priority queue\') def peek_max(self): while self.heap: priority, count, item = self.heap[0] if item is not None: return item heapq.heappop(self.heap) # Remove placeholder raise KeyError(\'peek from an empty priority queue\') def change_priority(self, item, new_priority): if item in self.entry_finder: self.remove_item(item) self.insert(item, new_priority) def remove_item(self, item): entry = self.entry_finder.pop(item) entry[-1] = None def size(self): return len(self.entry_finder)"},{"question":"# Problem Statement Create a function that determines the minimum spanning tree (MST) of a given undirected, connected, and weighted graph using Prim\'s Algorithm. The graph is represented using an adjacency list. Your implementation should handle basic edge cases and return an appropriate result or error for invalid inputs. # Function Signature ```python def prim_mst(graph: Dict[Any, List[Tuple[Any, float]]]) -> List[Tuple[Any, Any, float]]: pass ``` # Expected Input and Output Formats - **Input**: - `graph`: A dictionary where keys represent nodes and values are lists of tuples representing the edges. Each tuple contains a neighboring node and the weight of the edge (node, weight). - **Output**: - A list of tuples representing the edges in the MST. Each tuple contains two nodes and the weight of the edge (node1, node2, weight). # Constraints and Limitations 1. The graph is guaranteed to be undirected, connected, and weighted. 2. Each edge\'s weight is a positive float. 3. The input graph will have at least two nodes. 4. Ensure the algorithm processes the minimum spanning tree correctly. 5. If the graph is empty or has only one node, return an empty list. 6. Raise an appropriate exception for invalid inputs (like disconnected graphs). # Example ```python graph = { \'A\': [(\'B\', 1), (\'C\', 3)], \'B\': [(\'A\', 1), (\'C\', 1), (\'D\', 5)], \'C\': [(\'A\', 3), (\'B\', 1), (\'D\', 1)], \'D\': [(\'B\', 5), (\'C\', 1)] } assert prim_mst(graph) == [(\'A\', \'B\', 1), (\'B\', \'C\', 1), (\'C\', \'D\', 1)], \\"Test case failed\\" ``` - In this example, the MST comprises edges with a total weight of 3. The result corresponds to the nodes connected by the edges with the lowest weights to form a spanning tree without any cycles. # Performance Requirements The time complexity should be appropriate for handling graphs of typical size: - Efficiently process graphs with up to a few hundred nodes and edges. - Utilize priority queues for maintaining the lowest edge weights to enhance the performance of Prim\'s Algorithm. # Scenario Imagine you are working on a network design project that requires determining the optimal way to connect various servers in a data center to minimize the total cabling cost. Your implementation of Prim\'s Algorithm will provide the minimum spanning tree necessary to achieve a cost-effective and efficient network layout.","solution":"import heapq from typing import Dict, List, Tuple, Any def prim_mst(graph: Dict[Any, List[Tuple[Any, float]]]) -> List[Tuple[Any, Any, float]]: if not graph: return [] start_node = next(iter(graph)) mst = [] visited = set() min_heap = [(0, start_node, start_node)] while min_heap: weight, start, end = heapq.heappop(min_heap) if end not in visited: visited.add(end) if start != end: mst.append((start, end, weight)) for next_node, next_weight in graph[end]: if next_node not in visited: heapq.heappush(min_heap, (next_weight, end, next_node)) if len(visited) != len(graph): raise ValueError(\\"Graph is disconnected\\") return mst"},{"question":"# Linked List Intersection You are provided with two singly linked lists, and you need to determine if they intersect at any point. Two linked lists are said to intersect if they share at least one node. Note that the intersection is defined by reference, not value, so the exact node must be identical in both lists. Your task is to implement a function `get_intersection_node` that returns the node at which the two lists intersect. If the two linked lists do not intersect, return `None`. Function Signature ```python def get_intersection_node(headA: ListNode, headB: ListNode) -> Optional[ListNode]: ``` Input - `headA` (ListNode): The head of the first linked list. - `headB` (ListNode): The head of the second linked list. Output - Returns the intersecting node, or `None` if the lists do not intersect. Constraints - The number of nodes in the lists is not guaranteed to be equal. - The nodes are instances of the `ListNode` class, which is defined as follows: ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next ``` - Both linked lists are non-empty. Example Consider the following linked lists: ``` List A: 1 -> 9 -> 1 -> 2 -> 4 List B: 3 -> 2 -> 4 ``` The two lists intersect at node with value `2`, as they share the nodes `2 -> 4`. ```python # Creating nodes node1 = ListNode(1) node9 = ListNode(9) node1_2 = ListNode(1) node2 = ListNode(2) node4 = ListNode(4) # Creating first linked list node1.next = node9 node9.next = node1_2 node1_2.next = node2 node2.next = node4 # Creating second linked list node3 = ListNode(3) node3.next = node2 # Intersection results assert get_intersection_node(node1, node3) == node2 ```","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def get_intersection_node(headA: ListNode, headB: ListNode) -> ListNode: Return the node at which the two lists intersect. If the two linked lists do not intersect, return None. if not headA or not headB: return None pointerA, pointerB = headA, headB while pointerA != pointerB: # if either pointer hits the end, reset it to the head of the other list # if they both hit the end, pointerA == pointerB == None and the loop ends pointerA = pointerA.next if pointerA else headB pointerB = pointerB.next if pointerB else headA return pointerA"},{"question":"# Problem Statement You are tasked with writing a function to find the smallest non-negative integer **missing** in a given list of non-negative integers. The missing integer is the smallest number that is not present in the list. # Input - `numbers` (list of integers): A list of non-negative integers containing duplicates. The list can be empty. # Output - Return the smallest non-negative integer that is missing from the list. # Constraints - All integers in the input list are non-negative. - The length of the `numbers` list can be up to 1,000,000. # Examples ```python # Example 1: numbers = [0, 1, 2, 6, 9, 11, 15] # Output: 3 # Example 2: numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # Output: 11 # Example 3: numbers = [] # Output: 0 # Example 4: numbers = [1, 2, 3, 4, 5] # Output: 0 # Example 5: numbers = [0, 0, 1, 1, 2, 2, 3, 3, 5, 6] # Output: 4 ``` # Function Signature ```python def find_missing_integer(numbers: list[int]) -> int: pass ``` # Detailed Explanation 1. **Input Validation**: Ensure the input list contains only non-negative integers. 2. **Set Operation**: Use a set for efficient membership checking. 3. **Finding the Missing Integer**: Iterate through numbers starting from 0 and find the smallest integer not present in the set. 4. **Edge Handling**: Handle edge cases where the list might be empty or contain all consecutive numbers starting from 0. # Assessment Criteria - Correctness of the implementation. - Efficiency in terms of runtime and memory usage, especially given the list size constraint. - Proper handling of various edge cases.","solution":"def find_missing_integer(numbers): Returns the smallest non-negative integer missing from the list. # Convert the list to a set for O(1) lookup times num_set = set(numbers) # Start checking from 0 upwards i = 0 while i in num_set: i += 1 return i"},{"question":"# Coding Question: Implement a Sliding Window Maximum Calculator **Scenario**: You are developing a feature for a data analysis tool that processes large sequences of numeric data. The requirement is to calculate the maximum value within a sliding window of a specified size, as it moves across a given list of integers. **Function Signature**: ```python def sliding_window_max(nums: list[int], k: int) -> list[int]: pass ``` **Expected Input and Output**: * **Input**: - `nums` (list[int]): A list of integers representing the numeric data sequence. - `k` (int): An integer representing the size of the sliding window. * **Output**: - A list of integers where each element is the maximum value within the corresponding sliding window. **Example**: ```python >>> nums = [1, 3, 1, 2, 0, 5] >>> k = 3 >>> result = sliding_window_max(nums, k) >>> print(result) [3, 3, 2, 5] >>> nums = [4, 2, 12, 3, 7] >>> k = 2 >>> result = sliding_window_max(nums, k) >>> print(result) [4, 12, 12, 7] ``` **Constraints**: * (1 leq len(nums) leq 10^5) * (1 leq k leq len(nums)) * The list `nums` can contain negative integers and is not guaranteed to have unique numbers. # Requirements: 1. Implement an efficient solution to handle large input sizes. 2. Calculate the maximum value for each sliding window position. 3. Avoid recalculating the maximum value for overlapping sections of the window. # Tips: * Leverage data structures such as deque to maintain the sliding window efficiently. * Ensure that the implementation has a linear time complexity to handle the upper constraint on input size. * Take care to handle edge cases where the sliding window size equals the length of the list, or the list contains negative values.","solution":"from collections import deque def sliding_window_max(nums: list[int], k: int) -> list[int]: Calculate the maximum value in each sliding window of size k in the given list of integers. Args: nums (list[int]): List of integers. k (int): Size of the sliding window. Returns: list[int]: List of maximum values for each sliding window position. if not nums or k == 0: return [] deq = deque() result = [] for i in range(len(nums)): # Remove the elements which are out of this window if deq and deq[0] < i - k + 1: deq.popleft() # Remove all elements smaller than the currently being added element while deq and nums[deq[-1]] < nums[i]: deq.pop() deq.append(i) # Add the current maximum to the result list if i >= k - 1: result.append(nums[deq[0]]) return result"},{"question":"# Question Title: Word Break Problem **Objective**: Write a function that takes a string and a set of words, and determines if the string can be segmented into a space-separated sequence of one or more dictionary words. Return a boolean indicating the result and one such possible segmentation (if any exists). **Function Signature**: ```python def can_segment_string(s: str, word_dict: Set[str]) -> Tuple[bool, Optional[str]]: pass ``` **Input**: 1. `s` (str): The string to be segmented. 2. `word_dict` (Set[str]): A set of strings representing the dictionary words. **Output**: 1. `(bool, Optional[str])`: A tuple where the first element is a boolean indicating if the string can be segmented into words from the dictionary, and the second element is an example of such a segmentation as a single string with spaces separating the words, or `None` if no segmentation exists. **Constraints**: - 1 <= len(s) <= 1000 - 1 <= len(word_dict) <= 300 - The words in the dictionary and the string `s` consist of lowercase English letters only. **Example**: ```python >>> can_segment_string(\\"leetcode\\", {\\"leet\\", \\"code\\"}) (True, \\"leet code\\") >>> can_segment_string(\\"applepenapple\\", {\\"apple\\", \\"pen\\"}) (True, \\"apple pen apple\\") >>> can_segment_string(\\"catsandog\\", {\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"}) (False, None) >>> can_segment_string(\\"pineapplepenapple\\", {\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"}) (True, \\"pine apple pen apple\\") ``` **Note**: - Utilize dynamic programming to break down the problem into subproblems. - Be careful with edge cases such as the string containing words not in the dictionary. - Ensure the segmentation maintains the original order of characters in the string.","solution":"from typing import Set, Tuple, Optional def can_segment_string(s: str, word_dict: Set[str]) -> Tuple[bool, Optional[str]]: Determines if the string can be segmented into a space-separated sequence of one or more dictionary words. Args: s : str : The string to be segmented. word_dict : Set[str] : A set of dictionary words. Returns: Tuple[bool, Optional[str]] : A tuple where the first element is a boolean indicating if the string can be segmented. If segmentable, the second element is a space-separated string of the segmented words. Otherwise, the second element is None. def backtrack(index, path): if index == len(s): return True, \' \'.join(path) for end in range(index + 1, len(s) + 1): if s[index:end] in word_dict: result, sentence = backtrack(end, path + [s[index:end]]) if result: return True, sentence return False, None return backtrack(0, [])"},{"question":"**Scenario**: A software development company uses a version control system where feature branches are created for new additions and bug fixes. Developers commit changes to these branches, which are recorded as timestamps sorted in ascending order. Your task is to identify the longest period of continuous commits (with no breaks in days) for any given branch. **Task**: Write a Python function to determine the length of the longest streak of consecutive days with commits for a given list of timestamps. **Function Signature**: ```python def longest_commit_streak(timestamps: list[str]) -> int: pass ``` **Input**: - `timestamps` (list[str]): A non-empty list of strings where each string is a timestamp in the format `\'YYYY-MM-DD\'`. **Constraints**: - The list may have up to `10^4` timestamps. - Timestamps are sorted in ascending order. **Output**: - An integer representing the length of the longest streak of consecutive days with commits. **Examples**: ```python >>> longest_commit_streak([\\"2023-01-01\\", \\"2023-01-02\\", \\"2023-01-04\\", \\"2023-01-05\\", \\"2023-01-06\\"]) 3 >>> longest_commit_streak([\\"2023-03-01\\", \\"2023-03-02\\", \\"2023-03-05\\", \\"2023-03-07\\"]) 2 ``` **Hints**: - Investigate how to parse dates and calculate differences between them using Python\'s `datetime` module. - Optimize the solution by considering linear time complexity, O(n). # Solution Template: ```python from datetime import datetime, timedelta def longest_commit_streak(timestamps: list[str]) -> int: # Convert the string timestamps to datetime objects for easier manipulation. dates = [datetime.strptime(date, \'%Y-%m-%d\') for date in timestamps] # Initialize variables for tracking the longest streak. max_streak = 0 current_streak = 1 # Traverse through the list of dates. for i in range(1, len(dates)): # Check if the current date is exactly one day after the previous date. if dates[i] - dates[i - 1] == timedelta(days=1): current_streak += 1 else: # Update the maximum streak and reset the current streak. max_streak = max(max_streak, current_streak) current_streak = 1 # Ensure the last streak is considered. max_streak = max(max_streak, current_streak) return max_streak ```","solution":"from datetime import datetime, timedelta def longest_commit_streak(timestamps: list[str]) -> int: # Convert the string timestamps to datetime objects for easier manipulation. dates = [datetime.strptime(date, \'%Y-%m-%d\') for date in timestamps] # Initialize variables for tracking the longest streak. max_streak = 1 current_streak = 1 # Traverse through the list of dates. for i in range(1, len(dates)): # Check if the current date is exactly one day after the previous date. if dates[i] - dates[i - 1] == timedelta(days=1): current_streak += 1 else: # Update the maximum streak and reset the current streak. max_streak = max(max_streak, current_streak) current_streak = 1 # Ensure the last streak is considered. max_streak = max(max_streak, current_streak) return max_streak"},{"question":"Problem Statement You are given a string `s` representing a sequence of substrings separated by a single space. Each substring consists of lowercase letters from \'a\' to \'z\' and has a numeric suffix (e.g., \\"abc12\\"). Your task is to reorder the substrings based on the numeric suffixes in ascending order and return the new string. # Function Signature ```python def reorder_substrings(s: str) -> str: ``` # Input * A single string `s` containing several substrings separated by spaces. Each substring consists of a lowercase alphabetical prefix and a numeric suffix. # Output * Return a string of the substrings reordered based on their numeric suffixes in ascending order, joined by a single space. # Constraints 1. Each substring contains exactly one numeric suffix and no other numeric characters. 2. Substrings are separated by exactly one space. 3. The total length of the input string `s` is between 1 and 1000 characters. 4. Each suffix is a positive integer. # Examples ```python # Example 1 s = \\"apple1 banana3 cherry2\\" print(reorder_substrings(s)) # Expected output: \\"apple1 cherry2 banana3\\" # Example 2 s = \\"dog20 cat10 hen15\\" print(reorder_substrings(s)) # Expected output: \\"cat10 hen15 dog20\\" # Example 3 s = \\"math32 physics64 chemistry18\\" print(reorder_substrings(s)) # Expected output: \\"chemistry18 math32 physics64\\" ``` # Explanation: * Split the string `s` into individual substrings based on spaces. * Extract numeric suffixes from each substring. * Sort the substrings by their numeric suffixes in ascending order. * Return the sorted substrings as a single string joined by spaces. # Note Ensure to handle cases where the suffixes have different lengths or values appropriately based on integer comparison rules.","solution":"def reorder_substrings(s: str) -> str: def extract_suffix(substring): # Extract the numeric suffix num = \'\' for char in reversed(substring): if char.isdigit(): num = char + num else: break return int(num) substrings = s.split() substrings.sort(key=extract_suffix) return \' \'.join(substrings)"},{"question":"# Coding Assessment Question Objective Implement a function that finds the shortest path in an unweighted graph using Breadth-First Search (BFS). Demonstrate understanding of graph traversal algorithms and the use of data structures such as queues. Problem Statement You are given an unweighted graph represented as an adjacency list and two nodes `start` and `end`. Write a function: ```python def shortest_path(graph: dict[str, list[str]], start: str, end: str) -> int: ... ``` This function should return the length of the shortest path between `start` and `end` in the graph. If there is no path between `start` and `end`, return -1. Input - `graph`: A dictionary representing the adjacency list of the graph where keys are node names (strings) and values are lists of nodes (strings) directly connected to the key node. - `start`: The starting node (string) in the graph. - `end`: The ending node (string) in the graph. Output - An integer representing the length of the shortest path. If no path exists, return -1. Constraints 1. The graph will have a maximum of 1000 nodes. 2. Node names will be unique strings containing only lowercase letters. 3. The graph may be disconnected, and there may be cycles. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } print(shortest_path(graph, \'A\', \'F\')) # 2 print(shortest_path(graph, \'A\', \'E\')) # 2 print(shortest_path(graph, \'A\', \'D\')) # 2 print(shortest_path(graph, \'B\', \'F\')) # 2 print(shortest_path(graph, \'A\', \'G\')) # -1 ``` # Additional Requirements - Ensure to validate the inputs. - Consider edge cases such as non-existent nodes or empty graph. - The implementation should be efficient for the given constraints. This new problem maintains consistency with the original questions in terms of complexity, scope, and style. It introduces a different algorithmic technique (BFS) yet remains within the common domain of fundamental data structures and graph theory.","solution":"from collections import deque def shortest_path(graph: dict[str, list[str]], start: str, end: str) -> int: if start not in graph or end not in graph: return -1 queue = deque([(start, 0)]) visited = set() while queue: node, distance = queue.popleft() if node == end: return distance if node in visited: continue visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: queue.append((neighbor, distance + 1)) return -1"},{"question":"# Context: Tree traversal is a fundamental concept in computer science used in various applications such as searching, sorting, and hierarchical data representation. Among the most common traversal methods are pre-order, in-order, and post-order traversals — each visiting nodes in a specific sequence. # Task: Implement a function `preorder_traversal` that traverses a binary tree in pre-order (root, left, right) and returns a list of node values in the order they are visited. # Input: - `root` (TreeNode): The root node of a binary tree. Each node contains an integer value, and has left and right child nodes which may be `None`. # Output: - A list of integers representing the node values in pre-order traversal. # Constraints: - The tree can be empty (i.e., the root node can be `None`). - Each node value will be a non-negative integer. # Examples: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def preorder_traversal(root: TreeNode) -> list: Implements pre-order traversal of a binary tree. Parameters: - root : TreeNode : The root node of the binary tree Returns: - list : The list of node values in pre-order traversal order if not root: return [] result = [] stack = [root] while stack: current = stack.pop() result.append(current.value) if current.right: stack.append(current.right) if current.left: stack.append(current.left) return result # Example usage: # Constructing the following binary tree: # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2, TreeNode(4), TreeNode(5)) root.right = TreeNode(3) assert preorder_traversal(root) == [1, 2, 4, 5, 3] ``` # Requirements: Implement the function as described to perform the pre-order traversal of a binary tree. Ensure the function handles the edge cases, such as an empty tree, and validate the result with the given example.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def preorder_traversal(root: TreeNode) -> list: Implements pre-order traversal of a binary tree. Parameters: - root : TreeNode : The root node of the binary tree Returns: - list : The list of node values in pre-order traversal order if not root: return [] result = [] stack = [root] while stack: current = stack.pop() result.append(current.value) if current.right: stack.append(current.right) if current.left: stack.append(current.left) return result"},{"question":"# QuickSort Algorithm Implementation Implement the QuickSort algorithm to sort a list of integers in ascending order. The QuickSort algorithm should use the last element as the pivot and follow these steps: 1. **Partitioning**: Rearrange the elements in the array such that all elements less than the pivot are positioned before the pivot, and all elements greater than the pivot are positioned after it. 2. **Recursive Sorting**: Recursively apply the partitioning and sorting to the sub-arrays formed by splitting the array at the pivot position. # Input and Output Input * `arr`: A list of integers to be sorted. Output * Return the sorted list of integers. # Constraints * You can assume all integer elements in the list are unique. * The input list can contain up to 100,000 integers. * The implementation should have an average time complexity of O(n log n). # Example ```python # Input arr = [10, 7, 8, 9, 1, 5] # Output [1, 5, 7, 8, 9, 10] ``` # Function Signature ```python def quicksort(arr: List[int]) -> List[int]: pass ``` # Implementation ```python from typing import List def partition(arr: List[int], low: int, high: int) -> int: pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quicksort_helper(arr: List[int], low: int, high: int) -> None: if low < high: pi = partition(arr, low, high) quicksort_helper(arr, low, pi - 1) quicksort_helper(arr, pi + 1, high) def quicksort(arr: List[int]) -> List[int]: quicksort_helper(arr, 0, len(arr) - 1) return arr ``` This QuickSort implementation follows the guidelines of the original question set in terms of style, length, complexity, and scope, providing a challenging and comprehensive problem for a coding assessment.","solution":"from typing import List def partition(arr: List[int], low: int, high: int) -> int: This function takes last element as pivot, places the pivot element at its correct position in sorted array, and places all smaller (smaller than pivot) to left of pivot and all greater elements to right of pivot. pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quicksort_helper(arr: List[int], low: int, high: int) -> None: The main function that implements QuickSort. arr[] --> Array to be sorted, low --> Starting index, high --> Ending index if low < high: pi = partition(arr, low, high) quicksort_helper(arr, low, pi - 1) quicksort_helper(arr, pi + 1, high) def quicksort(arr: List[int]) -> List[int]: Function to do QuickSort. It initializes the recursive quicksort operation and returns the sorted array. quicksort_helper(arr, 0, len(arr) - 1) return arr"},{"question":"# Merging Sorted Arrays You are a software developer working on a system that needs to handle large datasets. One of the tasks is to merge multiple sorted arrays into one sorted array efficiently. You need to write a function that accomplishes this. Given several lists of sorted integers, write a function `merge_sorted_arrays` that merges them into a single sorted list. # Function Signature ```python def merge_sorted_arrays(arrays: list[list[int]]) -> list[int]: pass ``` # Constraints 1. All input lists are individually sorted in non-decreasing order. 2. The function must handle varying lengths of the input lists, including empty lists. 3. The function should aim for optimal time complexity. # Input * A list of lists, where each list contains sorted integers. # Output * A single list containing all integers from the input lists, sorted in non-decreasing order. # Example ```python assert merge_sorted_arrays([[1, 4, 7], [2, 5, 8], [3, 6, 9]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert merge_sorted_arrays([[10, 12], [5, 6, 7], [], [3, 15]]) == [3, 5, 6, 7, 10, 12, 15] assert merge_sorted_arrays([[], [], []]) == [] # Invalid cases (should raise a TypeError or ValueError) try: merge_sorted_arrays([[1, 2], \\"3, 4\\"]) except TypeError: pass try: merge_sorted_arrays([1, 2, 3]) except TypeError: pass try: merge_sorted_arrays([[1, 2], [3, -5]]) except ValueError: pass ``` # Description Implement the function `merge_sorted_arrays` that: 1. Receives a list containing multiple sorted lists of integers. 2. Merges all the integers from these lists into one sorted list in non-decreasing order. 3. Validates inputs and raises appropriate exceptions for invalid cases. # Hints 1. You can use a min-heap or priority queue to achieve optimal time complexity. 2. Handle edge cases such as empty input lists or lists containing invalid elements. 3. Use appropriate data structures and algorithms to maintain efficiency and readability.","solution":"import heapq from typing import List def merge_sorted_arrays(arrays: List[List[int]]) -> List[int]: Merges multiple sorted lists into a single sorted list. Parameters: arrays (List[List[int]]): A list of lists, where each list contains sorted integers. Returns: List[int]: A single sorted list containing all integers from the input lists. if not all(isinstance(i, list) for i in arrays): raise TypeError(\'Each element in arrays must be of type list.\') for sublist in arrays: if not all(isinstance(x, int) for x in sublist): raise TypeError(\'Each element in sublists must be of type int.\') if sublist != sorted(sublist): raise ValueError(\'Sublists must be sorted.\') min_heap = [] result = [] # Push the first element of each array into the heap for i, array in enumerate(arrays): if array: heapq.heappush(min_heap, (array[0], i, 0)) # Extract the smallest element from the heap and add the next element of the same array to the heap while min_heap: value, array_idx, element_idx = heapq.heappop(min_heap) result.append(value) next_element_idx = element_idx + 1 if next_element_idx < len(arrays[array_idx]): heapq.heappush(min_heap, (arrays[array_idx][next_element_idx], array_idx, next_element_idx)) return result"},{"question":"# Context: Your task is to prepare a library management software\'s backend to efficiently track and update the available copies of books. The system should allow stock to be updated when books are borrowed or returned, and provide the current availability of each book when queried. # Problem Statement: Implement the class `Library` using the given skeleton code. The class should manage an internal collection of books, allow adding new books, borrowing and returning books, and checking the available stock for a given book. # Class Definition: ```python class Library: def __init__(self): : ``` # Methods: 1. `add_book(self, book_title: str, num_copies: int) -> None`: * **book_title**: A string representing the title of the book. * **num_copies**: An integer representing the number of copies to add. - Adds the specified number of copies of the given book to the library. 2. `borrow_book(self, book_title: str) -> bool`: * **book_title**: A string representing the title of the book. - Decreases the stock of the specified book by 1 if available; returns `True` if successful, `False` otherwise. 3. `return_book(self, book_title: str) -> None`: * **book_title**: A string representing the title of the book. - Increases the stock of the specified book by 1. 4. `check_availability(self, book_title: str) -> int`: * **book_title**: A string representing the title of the book. - Returns the number of available copies of the specified book. If the book is not in the collection, return `0`. # Example: ```python library = Library() # Adding books to the library library.add_book(\\"The Great Gatsby\\", 4) library.add_book(\\"1984\\", 2) # Checking availability print(library.check_availability(\\"1984\\")) # Output: 2 # Borrowing a book success = library.borrow_book(\\"1984\\") print(success) # Output: True # Checking availability after borrowing print(library.check_availability(\\"1984\\")) # Output: 1 # Returning a book library.return_book(\\"1984\\") # Checking availability after returning print(library.check_availability(\\"1984\\")) # Output: 2 # Trying to borrow a non-existent book success = library.borrow_book(\\"Moby Dick\\") print(success) # Output: False # Checking availability for a non-existent book print(library.check_availability(\\"Moby Dick\\")) # Output: 0 ``` # Evaluation Criteria: * **Correctness**: The class should manage the book stock accurately. * **Efficiency**: The methods should handle operations efficiently. * **Error Handling**: The class should handle cases where books are not available or are not part of the registered collection. * **Code Quality**: The solution should be clean, readable, and properly commented. # Constraints: 1. You can assume all book titles are unique. 2. You need not handle cases where invalid data types are passed to methods. 3. All operations should complete in O(1) time on average, making use of appropriate data structures to achieve this. # Notes: 1. Ensure the internal data structures provide efficient access and update mechanisms. 2. Properly handle edge cases where books are borrowed or returned more times than available.","solution":"class Library: def __init__(self): self.books = {} def add_book(self, book_title: str, num_copies: int) -> None: if book_title in self.books: self.books[book_title] += num_copies else: self.books[book_title] = num_copies def borrow_book(self, book_title: str) -> bool: if book_title in self.books and self.books[book_title] > 0: self.books[book_title] -= 1 return True return False def return_book(self, book_title: str) -> None: if book_title in self.books: self.books[book_title] += 1 else: self.books[book_title] = 1 def check_availability(self, book_title: str) -> int: if book_title in self.books: return self.books[book_title] return 0"},{"question":"# Coding Assessment Question Context A palindrome is a sequence that reads the same backward as forward. For example, \\"radar\\" and \\"madam\\" are palindromes. We can extend this concept to numbers, where a number reading the same backward and forward is considered a numeric palindrome. Task Write a function `longest_palindromic_subsequence(s: str) -> int` that calculates the length of the longest palindromic subsequence in a given string `s`. A subsequence is a sequence that appears in the same relative order, but not necessarily consecutively. Function Signature ```python def longest_palindromic_subsequence(s: str) -> int: pass ``` Input - A string `s` of length ( n ) where ( 0 leq n leq 1000 ). Output - An integer representing the length of the longest palindromic subsequence. Constraints - The function should return `0` if the input string is empty. - The function should be case-insensitive (treat \'A\' and \'a\' as the same). Performance Requirements - Time Complexity: O(n^2) - Space Complexity: O(n^2) Examples ```python >>> longest_palindromic_subsequence(\\"bbbab\\") 4 >>> longest_palindromic_subsequence(\\"cbbd\\") 2 >>> longest_palindromic_subsequence(\\"a\\") 1 >>> longest_palindromic_subsequence(\\"abcdef\\") 1 >>> longest_palindromic_subsequence(\\"\\") 0 >>> longest_palindromic_subsequence(\\"Aba\\") 3 ``` Hints - You might find dynamic programming useful for solving the problem. - Create a 2D table where `dp[i][j]` represents the length of the longest palindromic subsequence in the substring `s[i:j+1]`. - Use a bottom-up approach to fill in the table and find the solution.","solution":"def longest_palindromic_subsequence(s: str) -> int: s = s.lower() # Make the string case-insensitive n = len(s) if n == 0: return 0 # Initialize DP table dp = [[0] * n for _ in range(n)] # All substrings of length 1 are palindromic for i in range(n): dp[i][i] = 1 # Fill the table for length in range(2, n + 1): # Substring lengths from 2 to n for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = 2 + dp[i + 1][j - 1] if length > 2 else 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"},{"question":"**Question**: You are required to implement a function to check whether a given directed graph contains any cycles. The graph is represented using an adjacency list. # Input - An integer `V` (1 ≤ `V` ≤ 1000) representing the number of vertices. - A list of `V` adjacency lists, where each list contains the indices of vertices that the key vertex has edges to. # Output - A boolean value `True` if the graph contains any cycles, otherwise `False`. # Function Signature ```python def has_cycle(graph: list[list[int]], V: int) -> bool: pass ``` # Constraints - All vertices are numbered from 0 to V-1. - The graph is a directed graph. # Example ```python graph = [ [1], # Edge from vertex 0 to vertex 1 [2], # Edge from vertex 1 to vertex 2 [0, 3], # Edge from vertex 2 to vertex 0 and vertex 3 [4], # Edge from vertex 3 to vertex 4 [] # Vertex 4 has no outgoing edges ] V = 5 result = has_cycle(graph, V) print(result) # Output: True ``` In this example, the function should return `True` because there is a cycle involving vertices 0, 1, and 2.","solution":"def has_cycle(graph: list[list[int]], V: int) -> bool: def dfs(v, visited, rec_stack): visited[v] = True rec_stack[v] = True for neighbor in graph[v]: if not visited[neighbor]: if dfs(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[v] = False return False visited = [False] * V rec_stack = [False] * V for node in range(V): if not visited[node]: if dfs(node, visited, rec_stack): return True return False"},{"question":"**[Question 2]: Implement a function `shortest_path_binary_matrix(grid: List[List[int]]) -> int` that takes a binary matrix `grid` and returns the length of the shortest clear path in the matrix from the top-left corner to the bottom-right corner. A clear path is a path through `1`-valued cells only, and each move must be to an adjacent cell horizontally, vertically, or diagonally. # Input - **List of lists** representing the binary matrix `grid`, where each element is either `0` or `1`. # Output - **Integer** value representing the length of the shortest clear path (number of cells). # Constraints 1. The matrix dimensions are such that `1 ≤ grid.length, grid[0].length ≤ 100`. 2. Each cell in the matrix contains either `0` or `1`. # Example ```python grid_1 = [ [0, 1], [1, 0] ] print(shortest_path_binary_matrix(grid_1)) # Output: 2 grid_2 = [ [0, 0, 0], [1, 1, 0], [1, 1, 0] ] print(shortest_path_binary_matrix(grid_2)) # Output: 4 grid_3 = [ [1, 0, 0], [1, 1, 0], [0, 0, 0] ] print(shortest_path_binary_matrix(grid_3)) # Output: -1 ``` Notes - If there is no clear path from the top-left corner to the bottom-right corner, return `-1`. - Consider implementing Breadth-First Search (BFS) for this problem as it is well-suited to finding the shortest path in an unweighted grid.","solution":"from collections import deque from typing import List def shortest_path_binary_matrix(grid: List[List[int]]) -> int: Finds the shortest path in a binary matrix from top-left to bottom-right cells where path can move horizontally, vertically, or diagonally. Returns length of the shortest path, or -1 if none exists. if grid[0][0] != 0 or grid[-1][-1] != 0: return -1 n = len(grid) directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] queue = deque([(0, 0, 1)]) # (row, col, step_count) grid[0][0] = 1 # Mark as visited while queue: row, col, step = queue.popleft() if row == n - 1 and col == n - 1: return step for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < n and grid[new_row][new_col] == 0: grid[new_row][new_col] = 1 # Mark as visited queue.append((new_row, new_col, step + 1)) return -1"},{"question":"# Problem Statement In the world of competitive programming, sorting algorithms play a crucial role. You are required to implement a custom sorting algorithm that sorts an array of integers based on the frequency of their occurrences. If two numbers have the same frequency, the one which appeared first in the array should come first. # Function Specification `frequency_sort(arr: list[int]) -> list[int]` * **Input**: * `arr`: A list of integers. * **Output**: * A list of integers sorted based on their frequency of occurrences. Numbers with higher frequency come first. If two numbers have the same frequency, the number that appears first in the original array comes first. # Constraints * The length of `arr` is at most `10^6`. * Each element in `arr` is an integer within the range of `[-10^9, 10^9]`. # Examples ```python arr = [4, 2, 2, 4, 5] result = frequency_sort(arr) # Expected Output: [4, 4, 2, 2, 5] arr = [1, 2, 3, 3, 2, 1, 4] result = frequency_sort(arr) # Expected Output: [1, 1, 2, 2, 3, 3, 4] ``` # Notes * You should maintain the original order of appearance for elements with the same frequency. * Use efficient data structures to handle the constraints effectively.","solution":"def frequency_sort(arr: list[int]) -> list[int]: from collections import Counter, defaultdict # Count the frequency of each number freq = Counter(arr) # Use a dict to keep track of the first appearance index of each number first_appearance = {} for i, num in enumerate(arr): if num not in first_appearance: first_appearance[num] = i # Sort the array based on the frequency (descending) and first appearance (ascending) sorted_arr = sorted(arr, key=lambda x: (-freq[x], first_appearance[x])) return sorted_arr"},{"question":"Problem Statement You are given two non-negative integers `x` and `y`. Your task is to implement a function that calculates the greatest common divisor (GCD) of these two numbers using the Euclidean algorithm. Additionally, implement a function that calculates the least common multiple (LCM) of the two numbers using the relationship between GCD and LCM. # Function Signature ```python def gcd(x: int, y: int) -> int: pass def lcm(x: int, y: int) -> int: pass ``` # Input 1. `x` (0 <= x, y <= 10**9): The first non-negative integer. 2. `y` (0 <= x, y <= 10**9): The second non-negative integer. # Output 1. `gcd(x, y)` should return an integer which is the greatest common divisor of `x` and `y`. 2. `lcm(x, y)` should return an integer which is the least common multiple of `x` and `y`. # Examples gcd ```python gcd(8, 12) # Output: 4 gcd(54, 24) # Output: 6 gcd(101, 10) # Output: 1 gcd(0, 5) # Output: 5 gcd(10, 0) # Output: 10 gcd(0, 0) # Output: 0 gcd(9, 9) # Output: 9 ``` lcm ```python lcm(8, 12) # Output: 24 lcm(54, 24) # Output: 216 lcm(101, 10) # Output: 1010 lcm(0, 5) # Output: 0 lcm(10, 0) # Output: 0 ``` # Constraints - The functions must operate within a time complexity of O(log(min(x, y))) for `gcd` and O(log(min(x, y))) for `lcm`. - Handle edge cases such as when `x` or `y` is zero appropriately. # Notes - GCD of two numbers x and y is the largest number that divides both x and y. - LCM of two numbers x and y is the smallest number that is a multiple of both x and y. - The relationship between GCD and LCM is given by lcm(x, y) * gcd(x, y) = x * y. - Ensure to handle the edge cases where one or both values are zero carefully, as these can impact outputs differently.","solution":"def gcd(x: int, y: int) -> int: Calculate the Greatest Common Divisor (GCD) of two non-negative integers using the Euclidean algorithm. while y: x, y = y, x % y return x def lcm(x: int, y: int) -> int: Calculate the Least Common Multiple (LCM) of two non-negative integers using the relationship between GCD and LCM. if x == 0 or y == 0: return 0 return abs(x * y) // gcd(x, y)"},{"question":"# Problem Statement: A sequence is defined such that the first term is 1, the second term is 1, and each subsequent term is the sum of the previous two terms. Given a natural number `n`, write a function to compute the nth term in this sequence. Your task is to implement the following function: ```python def nth_fibonacci(n: int) -> int: pass ``` # Input: - `n` (1 ≤ n ≤ 10^4) - The position in the sequence. # Output: - Return an integer representing the nth term in the sequence. # Example: ```python >>> nth_fibonacci(10) 55 >>> nth_fibonacci(20) 6765 ``` # Explanation: 1. For `n = 10`: - The sequence: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 - 10th term is 55. 2. For `n = 20`: - The sequence: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55,..., 6765 - 20th term is 6765. # Constraints: - Ensure your solution is efficient and handles the upper limit of the input size within a reasonable time frame. Optimized approaches like matrix exponentiation or memoization are recommended to handle large inputs efficiently.","solution":"def nth_fibonacci(n: int) -> int: Returns the nth term in the Fibonacci sequence. if n <= 0: raise ValueError(\\"The position must be a natural number (1 ≤ n).\\") if n == 1 or n == 2: return 1 a, b = 1, 1 for _ in range(3, n + 1): a, b = b, a + b return b"},{"question":"# Problem Statement Create a function that, given an integer array `arr`, finds the smallest positive integer that is missing from the array. The function should operate with a time complexity of O(n) and use constant extra space. # Function Signature ```python def find_missing_positive(arr: list) -> int: pass ``` # Input * A list of integers `arr` where the length of the list `n` will be in the range 1 ≤ n ≤ 100. # Output * The smallest positive integer that is missing from the array. # Constraints * All integers in the array are within the range -10^9 to 10^9. # Example ```python >>> find_missing_positive([3, 4, -1, 1]) 2 >>> find_missing_positive([1, 2, 0]) 3 >>> find_missing_positive([7, 8, 9, 11, 12]) 1 ``` # Detailed Requirements * **In-Place Modification**: Use the input array itself for marking presence of elements. * **Handling Negative Values and Large Numbers**: Efficiently manage non-relevant values (negative and large numbers). * **Edge Case Handling**: Ensure that edge cases such as arrays consisting solely of negative numbers or sequential positive numbers are well-handled. The function should return the smallest positive integer not present in the array `arr`. This problem tests your ability to apply resource optimization techniques, such as in-place array manipulation.","solution":"def find_missing_positive(arr: list) -> int: n = len(arr) for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] for i in range(n): if arr[i] != i + 1: return i + 1 return n + 1"},{"question":"In a social media application, a significant feature is to track and count the interactions between users. Consider a scenario where you need to analyze the number of messages sent between different users and visualize the active connections. This can be represented as a graph where nodes represent users and edges represent the number of messages sent between them. You are provided two functions: `add_connection` which records a message sent between two users, and `get_connections` which retrieves a list of users a specified user has messaged. # Task Complete the implementation of a class `SocialMediaGraph` that records these interactions and provides information on the messaging connections. Class Signature ```python class SocialMediaGraph: def __init__(self): self.graph = {} # Existing setup should be here def add_connection(self, user1: str, user2: str): # Implement this function def get_connections(self, user: str) -> List[str]: # Implement this function ``` Input Format * A call to `add_connection` with two string arguments `user1` and `user2` representing a message sent from `user1` to `user2`. * A call to `get_connections` with a single string argument `user` representing the user for which we want to retrieve the list of connected users. Output Format * `add_connection` should not return anything. * `get_connections` should return a list of users that `user` has messaged. Constraints * Each user will be represented by a unique string identifier. * The number of unique users will not exceed 10^5. * Each user can have multiple connections but each connection is only recorded once. # Additional Problem Develop a method to find the user(s) with the highest number of connections. Additional Function Signature ```python def most_active_users(self) -> List[str]: # Implement this function ``` Additional Output Format * Return a list of user(s) that have sent messages to the highest number of different users. If there are multiple users with the same highest number, include all of them in any order. Example ```python social_graph = SocialMediaGraph() social_graph.add_connection(\'Alice\', \'Bob\') social_graph.add_connection(\'Alice\', \'Charlie\') social_graph.add_connection(\'Bob\', \'Charlie\') print(social_graph.get_connections(\'Alice\')) # Output: [\'Bob\', \'Charlie\'] social_graph.add_connection(\'Alice\', \'David\') print(social_graph.most_active_users()) # Output: [\'Alice\'] ``` Constraints * Ensure that all functionalities are optimized to handle the maximum constraints efficiently. # Notes * Use appropriate data structures to ensure efficient add and retrieval operations. * Consider edge cases such as users with no messages or isolated sections of the graph.","solution":"from typing import List, Dict class SocialMediaGraph: def __init__(self): self.graph = {} def add_connection(self, user1: str, user2: str): Records a message sent between user1 and user2. # Add user2 to the set of connections for user1 if user1 not in self.graph: self.graph[user1] = set() self.graph[user1].add(user2) def get_connections(self, user: str) -> List[str]: Retrieves a list of users user has messaged. if user in self.graph: return list(self.graph[user]) else: return [] def most_active_users(self) -> List[str]: Returns the user(s) with the highest number of connections. most_active = [] max_connections = 0 for user, connections in self.graph.items(): num_connections = len(connections) if num_connections > max_connections: max_connections = num_connections most_active = [user] elif num_connections == max_connections: most_active.append(user) return most_active"},{"question":"# Coding Assessment Question Context You are given a data structure `CircularQueue` implementing a circular buffer, which allows efficient use of fixed-size buffer memory by wrapping around when the end of the buffer is reached. This data structure supports operations such as enqueue, dequeue, and checking the size of the queue. Problem Statement Implement the following function: ```python def is_full(circular_queue: CircularQueue) -> bool: Determines whether the circular queue is full. Args: circular_queue (CircularQueue): The circular queue instance. Returns: bool: True if the circular queue is full, else False. pass ``` Definition A circular queue is considered full if the number of elements currently in the queue equals the maximum capacity. Input - `circular_queue`: An instance of the `CircularQueue` class representing the circular buffer. Output - A boolean indicating if the circular queue is full. Constraints - Assume that the size of the circular queue, its current number of elements, and its capacity can be queried using appropriate methods of the `CircularQueue` class. - The methods you may use are `circular_queue.size()` returning the current number of elements, and `circular_queue.capacity()` returning the maximum capacity. Examples ```python # Example 1 cq1 = CircularQueue(5) cq1.enqueue(1) cq1.enqueue(2) cq1.enqueue(3) cq1.enqueue(4) cq1.enqueue(5) assert is_full(cq1) == True # Example 2 cq2 = CircularQueue(3) cq2.enqueue(1) cq2.enqueue(2) assert is_full(cq2) == False ``` Notes 1. Ensure to handle edge cases where the queue is empty. 2. You do not need to implement the `CircularQueue` class, only the `is_full` function. ```python class CircularQueue: def __init__(self, capacity): self.buffer = [None] * capacity self.capacity = capacity self.size = 0 self.front = 0 self.rear = 0 def enqueue(self, item): if self.size == self.capacity: raise Exception(\\"Queue is full\\") self.buffer[self.rear] = item self.rear = (self.rear + 1) % self.capacity self.size += 1 def dequeue(self): if self.size == 0: raise Exception(\\"Queue is empty\\") item = self.buffer[self.front] self.front = (self.front + 1) % self.capacity self.size -= 1 return item def size(self): return self.size def capacity(self): return self.capacity ``` # Implementation Use the `CircularQueue` class interface methods `size()` and `capacity()` to implement `is_full` effectively: ```python def is_full(circular_queue: CircularQueue) -> bool: return circular_queue.size() == circular_queue.capacity() ```","solution":"def is_full(circular_queue): Determines whether the circular queue is full. Args: circular_queue (CircularQueue): The circular queue instance. Returns: bool: True if the circular queue is full, else False. return circular_queue.size() == circular_queue.capacity()"},{"question":"# Question Objective Implement a function `rotate_matrix` that rotates an n x n matrix by 90 degrees clockwise in place. This rotation should modify the matrix directly without using any extra space for another matrix. Algorithm Explanation To rotate the matrix by 90 degrees: 1. Transpose the matrix. 2. Reverse each row of the transposed matrix. Input and Output * **Input**: A 2D list of integers `matrix` representing an n x n matrix (n >= 1). * **Output**: The rotated matrix in-place. Constraints * You should not use any additional data structures to achieve the result. * The matrix will always be square. * The function signature should be: `def rotate_matrix(matrix: list) -> None`. Scenario Consider an image represented by an n x n pixel matrix that needs to be rotated for correct display on a different orientation device. Rotating the matrix helps in displaying the image correctly. Example ```python >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> rotate_matrix(matrix) >>> matrix [[3, 1], [4, 2]] >>> matrix = [ ... [1] ... ] >>> rotate_matrix(matrix) >>> matrix [[1]] ``` Develop the `rotate_matrix` function to correctly rotate the given square matrix by 90 degrees clockwise.","solution":"def rotate_matrix(matrix): Rotates the n x n matrix by 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Radial Distance Calculation Given the coordinates of two points in a two-dimensional plane, you are to implement a function `radial_distance` to calculate the distance between these two points using the Euclidean distance formula. # Function Signature ```python def radial_distance(x1: float, y1: float, x2: float, y2: float) -> float: ``` # Input * `x1` (float): x-coordinate of the first point. * `y1` (float): y-coordinate of the first point. * `x2` (float): x-coordinate of the second point. * `y2` (float): y-coordinate of the second point. # Output * `float`: The distance between the two points. # Constraints * All input coordinates must be finite values. # Errors * If any of the coordinates provided is not a finite value (e.g., infinity or NaN), raise a `ValueError` with the message \\"Coordinates must be finite numbers\\". # Examples ```python >>> round(radial_distance(0, 0, 3, 4), 2) 5.0 >>> round(radial_distance(-1, -1, 2, 3), 2) 5.0 >>> round(radial_distance(1.5, 3.5, -1.5, -2.5), 2) 6.71 >>> round(radial_distance(0, 0, 0, 0), 2) 0.0 >>> radial_distance(1, 2, float(\'inf\'), 4) Traceback (most recent call last): ... ValueError: Coordinates must be finite numbers >>> radial_distance(float(\'nan\'), 1, 2, 3) Traceback (most recent call last): ... ValueError: Coordinates must be finite numbers ``` # Notes When implementing this function: * Use the `math` module functions such as `sqrt` to compute the Euclidean distance. * Ensure that the inputs are valid and handle any exceptions as specified above.","solution":"import math def radial_distance(x1: float, y1: float, x2: float, y2: float) -> float: Calculate the Euclidean distance between two points (x1, y1) and (x2, y2). # Check if all the coordinates are finite if not all(map(math.isfinite, [x1, y1, x2, y2])): raise ValueError(\\"Coordinates must be finite numbers\\") # Calculate Euclidean distance distance = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) return distance"},{"question":"# Scenario: You are developing an e-commerce application, and one of the features is to calculate the optimal arrangement of items in a shipping box to minimize the number of boxes used, taking into account the weight limit of each box. # Task: Implement a function `min_boxes(weights: List[int], max_weight: int) -> int` to determine the minimum number of boxes required to ship all items. Each box has a maximum weight capacity, and the order of items cannot be changed. # Input: - `weights` (List[int]): A list of integers representing the weights of the items. - `max_weight` (int): An integer representing the maximum weight capacity of a single box. # Output: - `int`: The minimum number of boxes required. # Constraints: - Each weight in weights must be a positive integer and less than or equal to the max_weight. - The max_weight must be a positive integer. # Example: ```plaintext Input: weights = [10, 20, 30, 40, 50], max_weight = 50 Output: 4 Input: weights = [10, 10, 10, 10, 10, 10], max_weight = 50 Output: 2 Input: weights = [5, 5, 5, 5, 5], max_weight = 10 Output: 3 ``` # Explanation: - For the first example, the optimal arrangement is to place the items [10, 20], [30, 40], and [50], resulting in 4 boxes. - For the second example, the optimal arrangement is to place the items in boxes [10, 10, 10, 10] and [10, 10], resulting in 2 boxes. - For the third example, the optimal arrangement is 2 items per box for the first two boxes and the remaining 1 item in the last box, resulting in 3 boxes.","solution":"from typing import List def min_boxes(weights: List[int], max_weight: int) -> int: Determines the minimum number of boxes required to ship all items based on the given weights and the maximum weight capacity of each box. current_weight = 0 box_count = 0 for weight in weights: if current_weight + weight <= max_weight: current_weight += weight else: box_count += 1 current_weight = weight if current_weight > 0: box_count += 1 return box_count"},{"question":"Given a binary tree, implement a function `is_symmetric(root: Optional[TreeNode]) -> bool` that checks if the tree is symmetric around its center. # Input - **Optional[TreeNode]** representing the root of the binary tree. Each node is represented by an instance of a `TreeNode` class. - The `TreeNode` class contains three fields: - `val` (Type: int) - value of the node. - `left` (Type: Optional[TreeNode]) - left child node. - `right` (Type: Optional[TreeNode]) - right child node. # Output - **Boolean** value: - `True` if the tree is symmetric. - `False` if the tree is not symmetric. # Constraints 1. The number of nodes in the tree can be between (0) and (10^4). 2. Node values can be any integer in the range ([-10^4, 10^4]). # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example 1: # 1 # / # 2 2 # / / # 3 4 4 3 root_1 = TreeNode(1) root_1.left = TreeNode(2, TreeNode(3), TreeNode(4)) root_1.right = TreeNode(2, TreeNode(4), TreeNode(3)) print(is_symmetric(root_1)) # Output: True # Example 2: # 1 # / # 2 2 # # 3 3 root_2 = TreeNode(1) root_2.left = TreeNode(2, right=TreeNode(3)) root_2.right = TreeNode(2, right=TreeNode(3)) print(is_symmetric(root_2)) # Output: False ``` Implement the function `is_symmetric(root: Optional[TreeNode]) -> bool` by completing this task. Notes - Consider using recursion to compare the left subtree with the mirrored right subtree. - Ensure to handle edge cases such as an empty tree, which is considered symmetric.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(root: Optional[TreeNode]) -> bool: if not root: return True def is_mirror(left: Optional[TreeNode], right: Optional[TreeNode]) -> bool: if not left and not right: return True if not left or not right: return False if left.val != right.val: return False return is_mirror(left.left, right.right) and is_mirror(left.right, right.left) return is_mirror(root.left, root.right)"},{"question":"# Palindrome Substring Check Objective Write a function to determine whether a given substring of a string can be rearranged to form a palindrome. Function Signature ```python def can_form_palindrome(s: str) -> bool: ``` Input * `s` (str): A string where we check if any of its substrings can be rearranged to form a palindrome. Output * Returns `True` if at least one substring of `s` can be rearranged to form a palindrome. * Returns `False` otherwise. Constraints * The string `s` will contain only lowercase alphabetical characters. * The length of `s` will be between 1 and 1000. # Examples ```python >>> can_form_palindrome(\\"racecar\\") True # \'racecar\' can be rearranged to form \'racecar\' which is a palindrome >>> can_form_palindrome(\\"level\\") True # \'level\' can be rearranged to form \'level\' which is a palindrome >>> can_form_palindrome(\\"abcdef\\") True # \'a\', \'b\', \'c\', \'d\', \'e\', \'f\' are single letters, hence palindromes >>> can_form_palindrome(\\"abac\\") True # \'aba\' can be rearranged to form \'aba\' which is a palindrome >>> can_form_palindrome(\\"abca\\") False # No substring can be rearranged to form a palindrome ``` # Requirements 1. Efficiency should be considered when checking substrings. 2. Consider all possible substrings and evaluate if any can be rearranged to become a palindrome without exceeding time complexity constraints. 3. Focus on character frequency to determine the possibility of palindrome formation. 4. Use hashmaps or counters to track character occurrences efficiently. # Hints - A string can be rearranged to form a palindrome if at most one character has an odd count. - Use a sliding window technique to examine all possible substrings. - Handling strings of length up to 1000 efficiently requires careful implementation of the substring verification logic.","solution":"from collections import Counter def can_form_palindrome(s: str) -> bool: Determine whether a given substring of a string can be rearranged to form a palindrome. Parameters: s (str): Input string Returns: bool: True if any of its substrings can be rearranged to form a palindrome, otherwise False def is_palindrome_permutation(string_fragment): counter = Counter(string_fragment) odd_count = sum(1 for k, v in counter.items() if v % 2 != 0) return odd_count <= 1 n = len(s) if n == 1: return True # Check all possible substrings for length in range(1, n + 1): for i in range(n - length + 1): substring = s[i:i + length] if is_palindrome_permutation(substring): return True return False"},{"question":"# Coding Assessment Question Scenario As part of a data analysis project, you need to process and summarize sales data for a retail store. Each sale is recorded with a timestamp, product ID, and sale amount. Your task is to implement a function that aggregates the sales data by product ID and provides a summary containing the total sales amount and the number of sales for each product ID. Objectives Your task is to implement a function that takes a list of sales records and returns a summary dictionary where the keys are product IDs and the values are dictionaries containing the total sales amount and the number of sales for each product ID. Function Signature ```python from typing import List, Dict, Any def summarize_sales(sales: List[Dict[str, Any]]) -> Dict[int, Dict[str, int]]: pass ``` Input * A list of dictionaries `sales` where each dictionary represents a sale record with the following structure: ```python { \\"timestamp\\": \\"YYYY-MM-DD HH:MM:SS\\", \\"product_id\\": int, \\"sale_amount\\": int } ``` Output * A dictionary where each key is a product ID (integer) and each value is another dictionary with the following structure: ```python { \\"total_sales\\": int, \\"number_of_sales\\": int } ``` Constraints * The input list `sales` will contain up to 100,000 sale records. * The `product_id` will be a positive integer. * The `sale_amount` will be a non-negative integer. Performance Requirements * Your solution should have a time complexity of O(n), where n is the number of sale records. * Space complexity should also be O(n). Example ```python >>> sales = [ ... {\\"timestamp\\": \\"2023-03-01 10:10:10\\", \\"product_id\\": 1, \\"sale_amount\\": 100}, ... {\\"timestamp\\": \\"2023-03-01 10:15:20\\", \\"product_id\\": 2, \\"sale_amount\\": 200}, ... {\\"timestamp\\": \\"2023-03-01 10:20:30\\", \\"product_id\\": 1, \\"sale_amount\\": 300} ... ] >>> summarize_sales(sales) { 1: {\\"total_sales\\": 400, \\"number_of_sales\\": 2}, 2: {\\"total_sales\\": 200, \\"number_of_sales\\": 1} } ``` Instructions 1. Ensure the function adheres to the specified input/output formats. 2. Handle edge cases such as empty input lists. 3. Do not import any additional libraries. Use only standard libraries available in Python.","solution":"from typing import List, Dict, Any def summarize_sales(sales: List[Dict[str, Any]]) -> Dict[int, Dict[str, int]]: summary = {} for sale in sales: product_id = sale[\\"product_id\\"] sale_amount = sale[\\"sale_amount\\"] if product_id not in summary: summary[product_id] = { \\"total_sales\\": 0, \\"number_of_sales\\": 0 } summary[product_id][\\"total_sales\\"] += sale_amount summary[product_id][\\"number_of_sales\\"] += 1 return summary"},{"question":"# Coding Question: Modify String based on Character Frequency Context: Given a string, modify the string such that each character in the resulting string appears the same number of times as it appears in the input string, but without consecutive duplicates. Additionally, return the count of characters removed during this process. Task: 1. Implement the `modify_string` function as defined below. 2. Modify the string based on the criteria mentioned. 3. Return the modified string and the count of characters removed. Function Signature: ```python def modify_string(s: str) -> tuple: Modifies the string to ensure no consecutive duplicate characters and counts removals. Parameters: s (str): The input string. Returns: tuple: A tuple where the first element is the modified string and the second element is the number of characters removed. ``` Example: ```python # Example input input_str = \\"aabbccddeeff\\" # Expected output (\\"abcdef\\", 6) input_str = \\"aaabbbccc\\" # Expected output (\\"abc\\", 6) ``` Constraints: * The input string contains only lowercase alphabets. * The string length does not exceed 10^4.","solution":"def modify_string(s: str) -> tuple: Modifies the string to ensure no consecutive duplicate characters and counts removals. Parameters: s (str): The input string. Returns: tuple: A tuple where the first element is the modified string and the second element is the number of characters removed. if not s: return (\\"\\", 0) modified_string = [] removed_char_count = 0 prev_char = None for char in s: if char != prev_char: modified_string.append(char) prev_char = char else: removed_char_count += 1 return \\"\\".join(modified_string), removed_char_count"},{"question":"# Problem Statement You are tasked with creating a function that generates a numeric pyramid pattern. The function should generate a centered pyramid of numbers with the following properties: - The pyramid has `n` levels. - The numbers in each level start from 1 and increase up to the level number. - Each level\'s numbers are separated by a single space. - The pyramid is centered with spaces to align the numbers properly. # Implementation Details Implement the following function: ```python def number_pyramid(n: int) -> str: Generates a centered numeric pyramid pattern. Args: n (int): Number of levels of the pyramid. Returns: str: A string representation of the centered numeric pyramid. Examples: >>> number_pyramid(3) \' 1 n 1 2 n1 2 3n\' >>> number_pyramid(5) \' 1 n 1 2 n 1 2 3 n 1 2 3 4 n1 2 3 4 5n\' >>> number_pyramid(1) \'1n\' pass ``` Input * `n`: An integer, the number of levels in the pyramid (1 ≤ n ≤ 100) Output * A string, the desired numeric pyramid pattern. Constraints * The size `n` will always be a positive integer. # Points to Consider * Handle edge values such as `n = 1`. * Ensure the proper alignment of numbers to form a visually appealing pyramid. Performance Requirements * The function should complete in a reasonable time for any input size within constraints (1 ≤ n ≤ 100).","solution":"def number_pyramid(n: int) -> str: Generates a centered numeric pyramid pattern. Args: n (int): Number of levels of the pyramid. Returns: str: A string representation of the centered numeric pyramid. pyramid_lines = [] for i in range(1, n+1): # Create the line with numbers nums = \' \'.join(map(str, range(1, i+1))) # Center the line padded_nums = nums.center(n * 2 - 1) pyramid_lines.append(padded_nums) return \'n\'.join(pyramid_lines) + \'n\'"},{"question":"# Problem Statement You are developing a simple in-memory key-value store that supports versioning of values. Each key in the store can have multiple versions, and each version of a key is identified by a numerical version number. Tasks 1. **Implement \'set\' function** Create a method `set(key: str, value: Any, version: int) -> None` that assigns a value to a specific version of a key. If the version specified is already in use, it should overwrite the existing value for that version. 2. **Implement \'get\' function** Implement a method `get(key: str, version: int = None) -> Any`. If a version is specified, return the value for that particular version. If no version is specified, return the most recent value (highest version number) for that key. If the key does not exist, return `None`. 3. **Implement \'delete\' function** Add a method `delete(key: str, version: int = None) -> None`. If a version is specified, delete that particular version of the key. If no version is specified, delete all versions of the key. # Constraints - All key and version inputs are guaranteed to be valid strings and integers, respectively. - The values can be of any data type. - The `version` number is always a positive integer. - Ensure that the key-value store is capable of handling up to 10^5 unique keys. # Function Signatures ```python def set(self, key: str, value: Any, version: int) -> None: pass def get(self, key: str, version: int = None) -> Any: pass def delete(self, key: str, version: int = None) -> None: pass ``` # Example - **Set values** ```python store = VersionedKeyValueStore() store.set(\'foo\', \'bar\', 1) store.set(\'foo\', \'baz\', 2) store.set(\'hello\', \'world\', 1) ``` - **Get values** ```python assert store.get(\'foo\') == \'baz\' # Most recent version, returns \'baz\' assert store.get(\'foo\', 1) == \'bar\' # Specific version, returns \'bar\' assert store.get(\'hello\') == \'world\' # Only one version, returns \'world\' assert store.get(\'nonexistent\') is None # Key does not exist, returns None ``` - **Delete values** ```python store.delete(\'foo\', 1) assert store.get(\'foo\', 1) is None # Version 1 is deleted assert store.get(\'foo\') == \'baz\' # Most recent version is still \'baz\' store.delete(\'foo\') assert store.get(\'foo\') is None # All versions of \'foo\' are deleted assert store.get(\'hello\') == \'world\' # Other keys are unaffected ``` **Note**: The provided VersionedKeyValueStore class structure shall be used and modified according to the task requirements.","solution":"class VersionedKeyValueStore: def __init__(self): self.store = {} def set(self, key: str, value: any, version: int) -> None: if key not in self.store: self.store[key] = {} self.store[key][version] = value def get(self, key: str, version: int = None) -> any: if key not in self.store: return None if version is not None: return self.store[key].get(version, None) # Get the highest version max_version = max(self.store[key].keys()) return self.store[key][max_version] def delete(self, key: str, version: int = None) -> None: if key not in self.store: return if version is not None: if version in self.store[key]: del self.store[key][version] # Clean up empty version dictionary for the key if not self.store[key]: del self.store[key] else: del self.store[key]"},{"question":"# Context You are working with a social networking platform and need to manage a large dataset of users and their connections. You want to implement a system that not only keeps track of direct connections but also can efficiently find if two users are connected indirectly through intermediate connections. # Task Implement a `DisjointSet` class to manage and query connected components. This class should support union and find operations to handle dynamic connectivity queries efficiently. # Specifications: `__init__(self, n: int) -> None` Initializes the disjoint set with `n` elements (from `0` to `n-1`). `find(self, x: int) -> int` Finds and returns the representative (root) of the set containing element `x`. Uses path compression to optimize the find operation. `union(self, x: int, y: int) -> None` Unites the sets containing elements `x` and `y`. Uses union by rank to optimize the union operation. `connected(self, x: int, y: int) -> bool` Checks if elements `x` and `y` are in the same connected component. Input/Output You are provided the number of users `n` at initialization. Implement methods to unite users, find representatives of components, and check connectivity between users. # Example ```python # Example usage: ds = DisjointSet(10) # Initially, each user is in their own component. assert ds.connected(0, 1) == False # Union some pairs of users. ds.union(0, 1) ds.union(2, 3) ds.union(4, 5) ds.union(5, 6) # Check connectivity assert ds.connected(0, 1) == True assert ds.connected(2, 4) == False # Union additional pairs ds.union(1, 2) ds.union(3, 4) # Check connectivity again assert ds.connected(0, 4) == True assert ds.connected(3, 5) == True assert ds.connected(7, 9) == False ``` Ensure your implementation is optimal in terms of time complexity for union and find operations. You can expect to deal with a large number of users and connection updates. # Constraints: - `1 <= n <= 10^5` - The number of union and connected operations will not exceed `10^5`. Implement the `DisjointSet` class and write efficient methods to manage and query connected components.","solution":"class DisjointSet: def __init__(self, n: int) -> None: Initializes the disjoint set with `n` elements (from `0` to `n-1`). self.parent = list(range(n)) self.rank = [0] * n def find(self, x: int) -> int: Finds and returns the representative (root) of the set containing element `x`. Uses path compression to optimize the find operation. if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) # Path compression return self.parent[x] def union(self, x: int, y: int) -> None: Unites the sets containing elements `x` and `y`. Uses union by rank to optimize the union operation. root_x = self.find(x) root_y = self.find(y) if root_x != root_y: if self.rank[root_x] > self.rank[root_y]: self.parent[root_y] = root_x elif self.rank[root_x] < self.rank[root_y]: self.parent[root_x] = root_y else: self.parent[root_y] = root_x self.rank[root_x] += 1 def connected(self, x: int, y: int) -> bool: Checks if elements `x` and `y` are in the same connected component. return self.find(x) == self.find(y)"},{"question":"# Question Description Context String manipulation is a common task in various programming problems and real-world applications. One fundamental operation is reversing the order of words in a given string. Task You are required to design a function to reverse the order of words in a given string while preserving the relative order of the characters within each word. Detailed Instructions * **Function Signature**: ```python def reverse_words(s: str) -> str: Reverse the order of words in a given string. :param s: Input string to reverse words in. :return: String with words in reversed order. ``` * **Expected Input and Output Formats**: * The function accepts a single string `s`. * The function returns a string in which the words are reversed in order. * **Constraints**: * Ensure the input is a string. * Words are defined as sequences of non-space characters. * Multiple spaces between words should be reduced to a single space in the output. * **Performance Requirements**: The function should have a linear time complexity, i.e., O(n), where n is the length of the string. Examples: ```python >>> reverse_words(\\"hello world\\") \\"world hello\\" >>> reverse_words(\\" hello world \\") \\"world hello\\" >>> reverse_words(\\"a quick brown fox\\") \\"fox brown quick a\\" >>> reverse_words(\\"the quick BROWN fox\\") \\"fox BROWN quick the\\" >>> reverse_words(\\"Keep Coding and keep Learning\\") \\"Learning keep and Coding Keep\\" ``` Edge Cases: 1. If the input string is empty, the function should return an empty string. 2. If the input string contains a single word, it should return the same word. 3. The function should correctly handle multiple and leading/trailing spaces by reducing them to a single space between words in the output.","solution":"def reverse_words(s: str) -> str: Reverse the order of words in a given string. :param s: Input string to reverse words in. :return: String with words in reversed order. # Split the string into words, filtering out empty words caused by multiple spaces words = [word for word in s.split() if word] # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words into a single string with a single space separator return \' \'.join(reversed_words)"},{"question":"# Question: Implement LRU (Least Recently Used) Cache You are tasked with implementing an LRU cache. The cache should have a fixed size and follow the LRU eviction policy. This means that when the cache reaches its capacity, it should evict the least recently used item before inserting a new one. Function Specifications: 1. `class LRUCache:` - **Constructor**: It takes `capacity` (an integer) as a parameter to set the cache capacity. - **Methods**: - `put(key: int, value: int) -> None`: Inserts the key-value pair into the cache. If the cache is full, evict the least recently used item before inserting the new one. - `get(key: int) -> int`: Returns the value of the given key if it is present in the cache; otherwise, returns -1. Each `get` operation should mark the used item as most recently used. Example: ```python cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # returns 1 cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1 # returns -1 (not found) cache.put(4, 4) # evicts key 1 assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(3) == 3 # returns 3 assert cache.get(4) == 4 # returns 4 ``` Requirements: - Optimize both `put` and `get` operations to have O(1) time complexity. - Utilize appropriate data structures to maintain the order of usage. Constraints: - The `capacity` will be a positive integer. - Keys and values are integers. - No need to handle negative capacities or non-integer inputs.","solution":"class LRUCache: Implements an LRU (Least Recently Used) cache. def __init__(self, capacity: int): self.capacity = capacity self.cache = {} # stores key-value pairs self.order = [] # keeps track of usage order def get(self, key: int) -> int: if key in self.cache: self.order.remove(key) self.order.append(key) return self.cache[key] return -1 def put(self, key: int, value: int) -> None: if key in self.cache: # Update the value and move the key to the end self.cache[key] = value self.order.remove(key) self.order.append(key) else: if len(self.cache) >= self.capacity: # Evict the least recently used item lru_key = self.order.pop(0) del self.cache[lru_key] # Insert the new key-value pair self.cache[key] = value self.order.append(key)"},{"question":"# Matrix Diagonal Difference Context Diagonal differences in matrices have diverse applications including image processing, where detecting variations between diagonal elements can be essential in edge detection and other analysis. Objective Write a function: 1. `diagonal_difference(matrix: list) -> int`: This function calculates the absolute difference between the sums of the matrix\'s two diagonals. Detailed Requirements - **Input**: A list of lists (2D matrix) representing an `n x n` matrix of integers. - **Output**: An integer representing the absolute difference between the sums of the primary diagonal and the secondary diagonal. - **Constraints**: - The matrix should be square (same number of rows and columns). - Each element in the matrix is an integer. - Raise a `ValueError` if the input matrix is not square or contains non-integer elements. - Handle edge cases where the matrix is empty or has sub-lists of inconsistent lengths. - **Description**: - The primary diagonal is formed by the elements `matrix[i][i]` for `i` from `0` to `n-1`. - The secondary diagonal is formed by the elements `matrix[i][n-1-i]` for `i` from `0` to `n-1`. - The function calculates the sums of these diagonals and returns the absolute difference. Example Usage ```python # Testing diagonal differences print(diagonal_difference([[1, 2, 3], [4, 5, 6], [9, 8, 9]])) # 2 print(diagonal_difference([[1, 2], [3, 4]])) # 0 ``` Constraints - Ensure the input is a proper square matrix and handle invalid matrices gracefully. - Optimize for readability and efficiency. - The solution must not use any additional external libraries. Good luck!","solution":"def diagonal_difference(matrix): Calculate the absolute difference between the sums of the matrix\'s two diagonals. :param matrix: List of equal-sized lists representing an n x n matrix. :return: Absolute difference between primary and secondary diagonal sums. :raises ValueError: If the input matrix is not square or contains non-integer elements. if not matrix or any(len(row) != len(matrix) for row in matrix): raise ValueError(\\"Input matrix must be square and non-empty.\\") primary_diagonal_sum = 0 secondary_diagonal_sum = 0 n = len(matrix) for i in range(n): # Check if elements are integers if not all(isinstance(matrix[i][j], int) for j in range(n)): raise ValueError(\\"Matrix elements must be integers.\\") primary_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][n-1-i] return abs(primary_diagonal_sum - secondary_diagonal_sum)"},{"question":"# Question: Substring Occurrence Counter You are given a string `text` and a list of strings `patterns`. Your task is to implement a function that counts how many times each pattern appears as a substring within `text`. The function should return a dictionary where the keys are the patterns and the values are their respective counts in `text`. Function Signature: ```python def substring_occurrence_counter(text: str, patterns: List[str]) -> Dict[str, int]: ``` Input: - **text**: A string containing the text to search within. - **patterns**: A list of strings where each string is a pattern to search for in the `text`. Output: - **Result**: A dictionary with the patterns as keys and their respective counts as values. Constraints & Notes: - The `text` length will not exceed 10000 characters. - The `patterns` list will contain between 1 and 100 patterns. - Each pattern will be non-empty and contain at most 100 characters. - The search should be case-sensitive. Example: **Input**: ```python text = \\"the quick brown fox jumps over the lazy dog. the fox was very quick.\\" patterns = [\\"the\\", \\"quick\\", \\"fox\\", \\"cat\\"] ``` **Output**: ```python { \\"the\\": 3, \\"quick\\": 2, \\"fox\\": 2, \\"cat\\": 0 } ``` Implementation Details: - Use efficient string search algorithms to count the occurrences of each pattern in the text. - Consider edge cases where patterns might overlap or be part of other words in the text. - Ensure the function handles large texts efficiently to avoid performance bottlenecks.","solution":"from typing import List, Dict def substring_occurrence_counter(text: str, patterns: List[str]) -> Dict[str, int]: Counts the occurrences of each pattern in the text. Parameters: text (str): The text to search within. patterns (List[str]): A list of patterns to search for in the text. Returns: Dict[str, int]: A dictionary with patterns as keys and their respective counts as values. result = {} for pattern in patterns: count = 0 start = 0 while True: start = text.find(pattern, start) if start == -1: break count += 1 start += 1 # Move over to start searching for the next occurrence. result[pattern] = count return result"},{"question":"# Compare Arrays and Find Missing Elements You are given two arrays, `array1` and `array2`, where `array2` is generated by shuffling `array1` and then deleting one random element. Your task is to find the missing element from `array2` and return it. # Requirements: 1. Write a function `find_missing_element(array1: List[int], array2: List[int]) -> int` which takes two lists of integers as input. 2. The function must compare the two arrays and identify the single integer that is missing from the second array. 3. The elements in the arrays are distinct integers. # Input: - `array1`: A list of integers representing the original array. - `array2`: A list of integers which is a shuffled version of `array1` with one element missing. # Output: - An integer representing the missing element from `array2`. # Constraints: - Both arrays will have between 1 and (10^6) integers. - The elements in the arrays are distinct integers. - The arrays will not be sorted initially. # Example: ```python # Example Usage: find_missing_element([4, 12, 9, 5], [12, 4, 9]) # -> 5 find_missing_element([1, 2, 3, 4, 5, 6], [2, 3, 1, 5, 6]) # -> 4 ``` # Additional Information: - You may assume each array element is a unique integer. - The function should efficiently handle large arrays. Complete the function to discover the missing element from the second array and return it. Be sure to consider the constraints and optimize for performance where possible.","solution":"from typing import List def find_missing_element(array1: List[int], array2: List[int]) -> int: Finds the missing element from array2 which is a shuffled version of array1 with one element missing. :param array1: List[int] - The original array :param array2: List[int] - The array with one element missing :return: int - The missing element # Calculate the sum of elements in both arrays sum_array1 = sum(array1) sum_array2 = sum(array2) # The difference will be the missing element return sum_array1 - sum_array2"},{"question":"Coding Assessment Question You are asked to create a log rotation mechanism for a log file that ensures the log file does not grow indefinitely. Instead, the program should keep the log file size within a limit and maintain a specified number of backup files when the size limit is exceeded. # Function Signature ```python def rotate_logs(log_file: str, size_limit: int, backup_count: int) -> None: ``` # Objective Implement the `rotate_logs` function that: 1. Takes `log_file`, `size_limit`, and `backup_count` as parameters. 2. Checks the size of the specified log file, and if it exceeds the `size_limit`, rotates the logs. 3. Moves the current log file to a backup (renaming the existing `.n` backups accordingly). 4. Creates a new empty log file after rotation. # Input/Output Format * **Input**: * `log_file` (str): The path to the log file. * `size_limit` (int): The size limit in bytes after which the log file should be rotated. * `backup_count` (int): The number of backup files to maintain. * **Output**: None (the function handles log rotation internally). # Constraints * Ensure that the size of the log file is checked properly and rotation is triggered only when it exceeds the `size_limit`. * Maintain exactly `backup_count` rotated log files, renaming existing backups to the next number (e.g., `log_file.1`, `log_file.2`, ...). * Remove files that exceed the `backup_count`. # Example - If `log_file` is \\"application.log\\", `size_limit` is 1000 bytes, and `backup_count` is 2: - If \\"application.log\\" exceeds 1000 bytes, it should be renamed to \\"application.log.1\\". - If \\"application.log.1\\" exists, it should be renamed to \\"application.log.2\\". - The oldest file \\"application.log.3\\" if exists, should be removed. - Create a new empty \\"application.log\\". # Context This function will ensure the log files do not consume excessive disk space and help in better log management by retaining a limited number of backup logs, each with a portion of the logging history. # Implementation Notes * Use the `os` module to handle file operations and check the size of files. * Properly handle any edge cases where files may not exist, or other file I/O exceptions. Design and implement the `rotate_logs` function to meet the above requirements.","solution":"import os def rotate_logs(log_file: str, size_limit: int, backup_count: int) -> None: Rotates the logs based on size limit and backup count. if not os.path.exists(log_file): return if os.path.getsize(log_file) <= size_limit: return # Rotate backups for i in range(backup_count, 0, -1): backup_file = f\\"{log_file}.{i}\\" previous_backup = f\\"{log_file}.{i - 1}\\" if i > 1 else log_file if os.path.exists(backup_file): os.remove(backup_file) if os.path.exists(previous_backup): os.rename(previous_backup, backup_file) # Create a new empty log file open(log_file, \'w\').close()"},{"question":"# Logistic Regression Model Enhancement Challenge Objective You are required to enhance the existing logistic regression model implemented in PyTorch. Specifically, you should: 1. Implement L2 regularization to reduce overfitting. 2. Add an option for early stopping based on the validation loss to prevent over-training. Input/Output Format * **Input**: * A 2D NumPy array \'X_train\' with shape (n, p), where n is the number of training samples and p is the number of features for each sample. * A 1D NumPy array \'y_train\' with shape (n,) containing the corresponding binary labels (0 or 1). * Two optional parameters \'alpha\' and \'epochs\' for the regularization strength and the maximum number of training epochs, with default values of 0.01 and 100 respectively. * A float \'tolerance\' (default: 1e-4) and an integer \'patience\' (default: 10) for the early stopping criteria. * **Output**: * The trained model parameters (weights and bias). * The list of loss values for each epoch. Constraints * The number of features in the input data must be positive. * Assume all input data points are valid and not missing. Code Requirements 1. Implement L2 regularization in the loss calculation to prevent overfitting. 2. Implement an early stopping mechanism to terminate training when the validation loss does not improve beyond the specified tolerance for a given number of epochs (patience). Template ```python import torch import torch.nn as nn import torch.optim as optim from numpy import array from sklearn.model_selection import train_test_split class LogisticRegressionModel(nn.Module): def __init__(self, input_dim): super(LogisticRegressionModel, self).__init__() self.linear = nn.Linear(input_dim, 1) def forward(self, x): return torch.sigmoid(self.linear(x)) def train_logistic_regression(X_train, y_train, alpha=0.01, epochs=100, tolerance=1e-4, patience=10): Train a logistic regression model with L2 regularization and early stopping. # Convert numpy arrays to torch tensors X_train = torch.tensor(X_train, dtype=torch.float32) y_train = torch.tensor(y_train, dtype=torch.float32).unsqueeze(1) input_dim = X_train.shape[1] model = LogisticRegressionModel(input_dim) criterion = nn.BCELoss() optimizer = optim.SGD(model.parameters(), lr=0.01, weight_decay=alpha) val_split = 0.2 X_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=val_split) best_loss = float(\'inf\') best_epoch = 0 patience_counter = 0 loss_values = [] for epoch in range(epochs): model.train() optimizer.zero_grad() outputs = model(X_train) loss = criterion(outputs, y_train) loss.backward() optimizer.step() model.eval() val_outputs = model(X_val) val_loss = criterion(val_outputs, y_val) loss_values.append(val_loss.item()) if val_loss.item() < best_loss - tolerance: best_loss = val_loss.item() best_epoch = epoch patience_counter = 0 else: patience_counter += 1 if patience_counter >= patience: print(f\\"Early stopping at epoch {epoch + 1}\\") break return model.linear.weight.data, model.linear.bias.data, loss_values # Example usage X_train = array([[0.5, 1.5], [1.0, 1.0], [1.5, 1.0], [2.0, 0.5], [3.0, 2.5], [2.5, 3.0]]) y_train = array([0, 0, 1, 1, 0, 1]) weights, bias, loss_values = train_logistic_regression(X_train, y_train) print(\\"Model weights:\\", weights) print(\\"Model bias:\\", bias) print(\\"Loss values:\\", loss_values) ```","solution":"import torch import torch.nn as nn import torch.optim as optim from sklearn.model_selection import train_test_split from numpy import array class LogisticRegressionModel(nn.Module): def __init__(self, input_dim): super(LogisticRegressionModel, self).__init__() self.linear = nn.Linear(input_dim, 1) def forward(self, x): return torch.sigmoid(self.linear(x)) def train_logistic_regression(X_train, y_train, alpha=0.01, epochs=100, tolerance=1e-4, patience=10): Train a logistic regression model with L2 regularization and early stopping. # Convert numpy arrays to torch tensors X_train = torch.tensor(X_train, dtype=torch.float32) y_train = torch.tensor(y_train, dtype=torch.float32).unsqueeze(1) input_dim = X_train.shape[1] model = LogisticRegressionModel(input_dim) criterion = nn.BCELoss() optimizer = optim.SGD(model.parameters(), lr=0.01, weight_decay=alpha) val_split = 0.2 X_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=val_split) best_loss = float(\'inf\') best_epoch = 0 patience_counter = 0 loss_values = [] for epoch in range(epochs): model.train() optimizer.zero_grad() outputs = model(X_train) loss = criterion(outputs, y_train) loss.backward() optimizer.step() model.eval() val_outputs = model(X_val) val_loss = criterion(val_outputs, y_val) loss_values.append(val_loss.item()) if val_loss.item() < best_loss - tolerance: best_loss = val_loss.item() best_epoch = epoch patience_counter = 0 else: patience_counter += 1 if patience_counter >= patience: print(f\\"Early stopping at epoch {epoch + 1}\\") break return model.linear.weight.data, model.linear.bias.data, loss_values # Example usage X_train = array([[0.5, 1.5], [1.0, 1.0], [1.5, 1.0], [2.0, 0.5], [3.0, 2.5], [2.5, 3.0]]) y_train = array([0, 0, 1, 1, 0, 1]) weights, bias, loss_values = train_logistic_regression(X_train, y_train) print(\\"Model weights:\\", weights) print(\\"Model bias:\\", bias) print(\\"Loss values:\\", loss_values)"},{"question":"# Prime Number Generator **Background**: Prime numbers are integers greater than 1 that have no divisors other than 1 and themselves. Efficient algorithms for prime number generation are essential in many fields, including cryptography, where large prime numbers are used to secure data. **Task**: You are to implement two main functionalities: generating a list of prime numbers up to a given number `n`, and verifying if a given number `m` is a prime. # Function Specifications 1. **Prime List Generator (generate_primes)** - **Input**: - `n` (int): The upper limit (inclusive) to generate prime numbers. - **Output**: - List of integers representing all prime numbers up to and including `n` (e.g., `[2, 3, 5, 7, 11]`). 2. **Prime Checker (is_prime)** - **Input**: - `m` (int): The number to check for primality. - **Output**: - Boolean indicating whether `m` is a prime number (True) or not (False). # Constraints - The value of `n` for the prime list generator will be between 2 and 10^6. - The value of `m` for the prime checker will be between 2 and 10^6. - Implement the most efficient algorithms possible to handle the upper limits of the input values. **Example**: ```python >>> generate_primes(11) [2, 3, 5, 7, 11] >>> is_prime(29) True >>> is_prime(30) False ``` *To implement prime number generation efficiently, you may consider using the Sieve of Eratosthenes. For primality testing, you can employ trial division, optimized to check only up to the square root of the number.*","solution":"def generate_primes(n): Generates a list of prime numbers up to and including n using the Sieve of Eratosthenes. Parameters: n (int): The upper limit (inclusive) to generate prime numbers. Returns: List[int]: A list of prime numbers up to and including n. if n < 2: return [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not primes for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n+1, start): sieve[multiple] = False return [num for num, is_prime in enumerate(sieve) if is_prime] def is_prime(m): Checks if a number m is a prime number. Parameters: m (int): The number to check for primality. Returns: bool: True if m is a prime number, False otherwise. if m <= 1: return False if m <= 3: return True if m % 2 == 0 or m % 3 == 0: return False i = 5 while i * i <= m: if m % i == 0 or m % (i + 2) == 0: return False i += 6 return True"},{"question":"# Problem Description: Write a function that takes in the head of a singly linked list and returns a new linked list that is a reversed copy of the original list. # Function Signature: ```python def reverse_linked_list(head: ListNode | None) -> ListNode | None: pass ``` # Input: - A single instance of `ListNode` class or `None`. - The `ListNode` class is structured as follows: ```python class ListNode: def __init__(self, value: int = 0, next: \'ListNode\' | None = None): self.value = value self.next = next ``` # Output: - Returns the head of the new reversed linked list if the input list is not `None`. Otherwise, return `None`. # Constraints: - The linked list node values are integers. - The list does not contain any cycles. # Example: ```python # Given the linked list: # 1 -> 2 -> 3 -> 4 # Example node input: node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) node1.next = node2 node2.next = node3 node3.next = node4 # reverse_linked_list(node1) should return a new linked list: # 4 -> 3 -> 2 -> 1 reversed_list = reverse_linked_list(node1) # Verify reversed_list has the reversed structure as input list assert reversed_list.value == 4 assert reversed_list.next.value == 3 assert reversed_list.next.next.value == 2 assert reversed_list.next.next.next.value == 1 assert reversed_list.next.next.next.next is None ``` # Notes: - You should create a new linked list instead of reversing the original list. - Handle edge cases like input being `None` or a single node linked list properly.","solution":"class ListNode: def __init__(self, value: int = 0, next: \'ListNode\' = None): self.value = value self.next = next def reverse_linked_list(head: ListNode | None) -> ListNode | None: if head is None: return None new_head = None current = head while current is not None: new_node = ListNode(current.value) new_node.next = new_head new_head = new_node current = current.next return new_head"},{"question":"# Problem Statement: Find the Second Largest Element in a List Scenario You are asked to design a function that identifies the second largest element in a list of integers. This is a common task in many coding assessments where sorting and comparison operations are essential. Task Implement a function `second_largest` in Python that determines the second largest element in a list of integers without sorting the list. Function Signature ```python def second_largest(nums: list) -> int: Find the second largest element in a list of integers. Args: - nums (list): A list of integers. Returns: - int: The second largest integer in the list. Raises: - ValueError: If the list contains less than two distinct elements. pass ``` # Input * `nums`: A list of integers with a minimum length of 2. # Output * Return the second largest integer in the list. # Constraints * The length of the list will be between 2 and 1000 inclusive. * All elements in the list are integers within the range `-10^6` to `10^6`. # Example ```python lst = [10, 20, 4, 45, 99] print(second_largest(lst)) # Expected output: 45 lst = [3, 1, 4, 4, 5, 5] print(second_largest(lst)) # Expected output: 4 lst = [100, 100, 10, 10] print(second_largest(lst)) # Expected output: 10 ``` # Notes 1. Ensure your function can handle edge cases such as lists with duplicate numbers. 2. The list must contain at least two distinct integers, otherwise, raise a `ValueError`. 3. Optimize your solution to handle the upper limits efficiently.","solution":"def second_largest(nums: list) -> int: Find the second largest element in a list of integers. Args: - nums (list): A list of integers. Returns: - int: The second largest integer in the list. Raises: - ValueError: If the list contains less than two distinct elements. if len(nums) < 2: raise ValueError(\\"The list must contain at least two distinct elements.\\") first = second = float(\'-inf\') for num in nums: if num > first: second = first first = num elif first > num > second: second = num if second == float(\'-inf\'): raise ValueError(\\"The list must contain at least two distinct elements.\\") return second"},{"question":"# Problem Statement Design a function `next_greater_element(nums: List[int]) -> List[int]` where given a list of integers, find the next greater element for each element in the list. The next greater element for a number `x` is the first greater number to its right in the list. If no such number exists, output `-1` for that element. # Input - A list of integers `nums` of length `n`. # Output - A list of integers containing the next greater elements. If there is no greater element, return `-1`. # Constraints - The length `n` of the input list `nums` will be `1 <= n <= 10^5`. - Each element in `nums` will be within the range `-10^9` to `10^9`. # Performance Requirements - The solution should efficiently handle lists up to the maximum constraint. # Example Usage ```python >>> next_greater_element([1, 2, 1]) [2, -1, -1] >>> next_greater_element([4, 5, 2, 25]) [5, 25, 25, -1] >>> next_greater_element([13, 7, 6, 12]) [-1, 12, 12, -1] >>> next_greater_element([10, 9, 8, 7]) [-1, -1, -1, -1] >>> next_greater_element([]) [] ``` # Additional Notes - Think about how a stack can be utilized to keep track of the next greater elements efficiently. - Handle edge cases where the input list might be empty or contain elements that are all in descending order.","solution":"from typing import List def next_greater_element(nums: List[int]) -> List[int]: Finds the next greater element for each element in the list. If no such element exists, returns -1 for that position. stack = [] res = [-1] * len(nums) for i, num in enumerate(nums): while stack and nums[stack[-1]] < num: index = stack.pop() res[index] = num stack.append(i) return res"},{"question":"# Coding Assessment Question You are given a list of student records, where each record contains the student ID and a list of their scores across multiple subjects. Your task is to calculate the average score for each student and then rank the students based on their average scores, with ties broken by their student IDs in ascending order. Input - A list of tuples `student_records` where each tuple contains: - An integer `student_id` - A list of integers `scores` representing the scores of the student in various subjects Output - A list of tuples representing `(student_id, average_score)` for each student, sorted by average score in descending order. In case of ties, sort by student ID in ascending order. - The highest average score. Constraints - Each list of scores will have at least one score. - Student IDs are unique integers. Performance Requirements - The algorithm should run in O(n log n) time complexity where n is the number of student records. Example Input: ```python student_records = [ (101, [75, 80, 85]), (102, [90, 85, 80]), (103, [80, 70, 80]), (104, [65, 70, 60]) ] ``` Output: ```python Ranked Student Score List: [(102, 85.0), (101, 80.0), (103, 76.67), (104, 65.0)] Highest Average Score: 85.0 ``` Requirements Implement the following functions: ```python def rank_students_by_average(student_records: list[tuple[int, list[int]]]) -> tuple[list[tuple[int, float]], float]: This function ranks students based on their average scores. Parameters: student_records (list[tuple[int, list[int]]]): The list of student records. Returns: tuple: A tuple containing: - Ranked list of students with their average score (List[tuple]): - Student ID (int) - Average Score (float) - The highest average score (float) # Your implementation here ``` Ensure your implementation handles the following edge cases: - Multiple students having the same average score. - A single student record. We\'ll use an example function call: ```python student_records = [ (101, [75, 80, 85]), (102, [90, 85, 80]), (103, [80, 70, 80]), (104, [65, 70, 60]) ] rank_students_by_average(student_records) ``` Expected output: ```python ([(102, 85.0), (101, 80.0), (103, 76.67), (104, 65.0)], 85.0) ```","solution":"def calculate_average(scores): return sum(scores) / len(scores) def rank_students_by_average(student_records): # Calculate average scores student_averages = [ (student_id, round(calculate_average(scores), 2)) for student_id, scores in student_records ] # Sort by average score descending, then by student_id ascending sorted_students = sorted( student_averages, key=lambda x: (-x[1], x[0]) ) # Find the highest average score highest_average = sorted_students[0][1] if sorted_students else 0 return sorted_students, highest_average"},{"question":"# Problem Statement You are given a string containing lowercase characters and a dictionary of words. Your task is to implement the function `form_words(string: str, word_dict: List[str]) -> List[str]` that identifies all the words from the given dictionary that can be formed using the characters in the input string. Each character in the string can only be used once per word. # Function Signature ```python def form_words(string: str, word_dict: List[str]) -> List[str]: ``` # Input * `string` (str): A string consisting of lowercase characters. * `word_dict` (List[str]): A list of words composed of lowercase characters. # Output * Return a list of words from the dictionary that can be formed using the given string. # Constraints * `1 <= len(string) <= 100` * `1 <= len(word_dict) <= 1000` * Each word in `word_dict` has a length between 1 and 20. # Examples ```python form_words(\\"abppplee\\", [\\"apple\\", \\"pear\\", \\"plea\\", \\"banana\\"]) # Output: [\'apple\', \'plea\'] form_words(\\"eerekc\\", [\\"tree\\", \\"treehouse\\", \\"reek\\", \\"seek\\"]) # Output: [\'reek\'] form_words(\\"catsanddog\\", [\\"dog\\", \\"cats\\", \\"cat\\", \\"and\\", \\"bat\\"]) # Output: [\'dog\', \'cats\', \'cat\', \'and\'] ``` # Guidelines 1. Each character in the input string can be used only as many times as it appears. 2. The order of words in the output list does not matter as long as all valid words are included. 3. Consider efficient checking mechanisms to validate if a word can be formed from the given characters. # Additional Clarifications * The function should only use the characters available in the input string and no extra characters. * Helper functions can be defined if needed to improve readability and modularity.","solution":"from collections import Counter from typing import List def can_form_word(string_counter, word): word_counter = Counter(word) for char, count in word_counter.items(): if string_counter[char] < count: return False return True def form_words(string: str, word_dict: List[str]) -> List[str]: string_counter = Counter(string) result = [] for word in word_dict: if can_form_word(string_counter, word): result.append(word) return result"},{"question":"# Scenario You have been assigned the task of simplifying and optimizing string manipulations in a text processing application. Part of your task involves removing extra consecutive spaces in sentences without affecting the overall spaces between words. The goal is to ensure that no more than one space separates consecutive words in a string. # Task Write a function `clean_string(input_string: str) -> str`, which removes any extra spaces between words in the given string and ensures that there is only one space separating each pair of words. # Input - `input_string`: A string containing words and spaces. Words are separated by at least one space. The string might start or end with spaces and can contain multiple spaces between words. # Output - A string with extra spaces removed, where only single spaces separate consecutive words. # Constraints - The input string can have a length of up to (10^4) characters. - Words consist of only alphabetic characters. # Example ```python input_string = \\" This is a sample string. \\" # Expected output: \\"This is a sample string.\\" ``` Implement the `clean_string` function: ```python def clean_string(input_string: str) -> str: words = input_string.split() return \' \'.join(words) ```","solution":"def clean_string(input_string: str) -> str: Removes extra spaces between words and trims leading/trailing spaces. Args: input_string (str): Input string containing words and spaces. Returns: str: A string with extra spaces removed and only a single space between words. words = input_string.split() return \' \'.join(words)"},{"question":"# Employee Work Hours Aggregation Scenario You are tasked with creating a program that processes employee work hours recorded in a CSV file. The file contains data for each employee, detailing their daily hours worked over a month. Your goal is to summarize the work hours for each employee, calculate their total hours worked, and identify any discrepancies in their expected vs. actual work time. Problem Statement Implement the function `aggregate_employee_hours` that reads a CSV file containing daily work hours of employees, computes the total hours worked by each employee for the month, and identifies employees who have worked fewer hours than expected. Function Signature ```python def aggregate_employee_hours(file_path: str, expected_hours: int) -> DataFrame: pass ``` Input - `file_path`: A string representing the path to the CSV file containing employee work hours. - `expected_hours`: An integer representing the total number of hours expected for an employee to work in a month. Output - A `DataFrame` containing the following columns: - Employee ID - Total Hours Worked - Hours Difference (expected - actual) CSV File Structure - Each row in the CSV file represents daily work hours for an employee. - Columns include: - `date`: Date of the work entry. - `employee_id`: The unique identifier for the employee. - `hours_worked`: Number of hours worked on that day. Constraints - Handle cases with incomplete data, such as missing work hours for certain days. - Assume each employee works on weekdays only (i.e., Monday to Friday). - Handle exceptions for file reading errors and missing columns. Example ```python # Sample input CSV data content # date,employee_id,hours_worked # 2023-09-01,E001,8 # 2023-09-01,E002,9 # 2023-09-02,E001,7 # 2023-09-02,E002,8 # ... # Calling the function df = aggregate_employee_hours(\\"employee_work_hours.csv\\", 160) print(df) ``` This should display a summary of total hours worked by each employee and the discrepancy from the expected hours. Tips - Use pandas for reading and processing the CSV data. - Aggregate the data by `employee_id` and sum the `hours_worked` for each employee. - Calculate the difference between `expected_hours` and `total_hours_worked`. - Handle exceptions gracefully for file operations and data processing issues.","solution":"import pandas as pd def aggregate_employee_hours(file_path: str, expected_hours: int) -> pd.DataFrame: Reads a CSV file containing employee work hours, computes the total hours worked by each employee for the month, and identifies employees who have worked fewer hours than expected. Parameters: - file_path: str : Path to the CSV containing employee work hours. - expected_hours: int : The total number of hours expected for an employee to work in a month. Returns: - DataFrame : A DataFrame containing columns: Employee ID, Total Hours Worked, Hours Difference. try: # Read the CSV file df = pd.read_csv(file_path) # Check if required columns are present required_columns = [\'date\', \'employee_id\', \'hours_worked\'] if not all(column in df.columns for column in required_columns): raise ValueError(\\"CSV file is missing one or more required columns: \'date\', \'employee_id\', \'hours_worked\'\\") # Aggregate total hours worked for each employee total_hours = df.groupby(\'employee_id\')[\'hours_worked\'].sum().reset_index() total_hours.columns = [\'employee_id\', \'total_hours_worked\'] # Calculate hours difference total_hours[\'hours_difference\'] = expected_hours - total_hours[\'total_hours_worked\'] return total_hours except Exception as e: print(f\\"An error occurred: {e}\\") return pd.DataFrame(columns=[\'employee_id\', \'total_hours_worked\', \'hours_difference\'])"},{"question":"# Task You need to write a function `is_hamiltonian_cycle` that determines if a given sequence of nodes forms a Hamiltonian cycle in an undirected graph. A Hamiltonian cycle is a cycle that visits each node exactly once and returns to the starting node. # Function Signature ```python def is_hamiltonian_cycle(graph: List[List[int]], cycle: List[int]) -> bool: ``` # Input * `graph`: A 2D list of integers representing an undirected graph where `graph[i][j] = 1` indicates an edge between node `i` and node `j`, and `graph[i][j] = 0` otherwise. * `cycle`: A list of integers where each integer represents a node in the order they are visited in the cycle. # Output * Return `True` if the provided sequence forms a Hamiltonian cycle in the graph, otherwise return `False`. # Constraints * Ensure the function handles graphs up to 20 nodes efficiently. * The `graph` list is a square matrix with dimensions `N x N` where 1 <= `N` <= 20. * The `cycle` list will contain exactly `N` integers. # Requirements: - Make sure your function correctly verifies the Hamiltonian cycle conditions. - Edge cases should be handled, including checking erroneous cycles that don\'t visit all nodes or don\'t form cycles. # Examples: ```python assert is_hamiltonian_cycle([[0, 1, 0, 0, 1], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 1, 0, 1], [1, 0, 0, 1, 0]], [0, 1, 2, 3, 4]) == True assert is_hamiltonian_cycle([[0, 1, 0, 0, 1], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 1, 0, 1], [1, 0, 0, 1, 0]], [0, 1, 2, 4, 3]) == False assert is_hamiltonian_cycle([[0, 1, 1, 0], [1, 0, 1, 1], [1, 1, 0, 1], [0, 1, 1, 0]], [0, 2, 1, 3]) == True assert is_hamiltonian_cycle([[0, 1, 1], [1, 0, 1], [1, 1, 0]], [0, 1, 2]) == True assert is_hamiltonian_cycle([[0, 1, 0], [1, 0, 1], [0, 1, 0]], [0, 1, 2]) == False ```","solution":"from typing import List def is_hamiltonian_cycle(graph: List[List[int]], cycle: List[int]) -> bool: n = len(graph) # Check if the cycle visits every node exactly once if len(set(cycle)) != n: return False # Check if it returns to the starting node if cycle[0] != cycle[-1]: return False # Check if there is an edge between each pair of consecutive nodes in the cycle for i in range(n): if graph[cycle[i]][cycle[i + 1]] == 0: return False return True"},{"question":"# Coding Assessment Question Context: Bob is a big fan of number series and loves to find out interesting properties about them. He came across a special type of series called a \\"cumulative prime sum series\\". In this series, each element is the sum of all prime numbers up to and including that position. Your task is to help Bob by writing a function that generates this series up to a specified `n`th position. # Objective: Write a Python function `cumulative_prime_sum(n: int) -> List[int]` that generates a list representing the cumulative sum of prime numbers up to the `n`th position. # Input and Output Formats: - **Input**: An integer `n` which represents the position up to which the series should be generated. - **Output**: A list of integers representing the cumulative sum of prime numbers up to the `n`th position. # Constraints: - `n` will be a positive integer less than or equal to 30. # Example: ```python def cumulative_prime_sum(n: int) -> List[int]: pass # Example usage print(cumulative_prime_sum(1)) # [2] because only the first prime is 2 print(cumulative_prime_sum(3)) # [2, 5, 10] because the primes are 2, 3, 5, and their cumulative sums are 2, 2+3=5, and 2+3+5=10 print(cumulative_prime_sum(5)) # [2, 5, 10, 17, 28] print(cumulative_prime_sum(0)) # [] because there is no 0th prime ``` # Criteria: - The function should correctly identify prime numbers. - The function should handle edge cases such as very small values of `n`. - Aim for efficiency by using optimized methods for prime number detection. # Additional Notes: - Consider using a helper function to check if a number is prime. - Be mindful of optimizing the prime number generation either through direct computation or through the use of a sieve algorithm.","solution":"from typing import List def is_prime(num: int) -> bool: if num <= 1: return False if num == 2: return True if num % 2 == 0: return False p = 3 while p * p <= num: if num % p == 0: return False p += 2 return True def generate_primes(limit: int) -> List[int]: primes = [] candidate = 2 while len(primes) < limit: if is_prime(candidate): primes.append(candidate) candidate += 1 return primes def cumulative_prime_sum(n: int) -> List[int]: if n <= 0: return [] primes = generate_primes(n) cumulative_sum = [] total = 0 for prime in primes: total += prime cumulative_sum.append(total) return cumulative_sum"},{"question":"# Coding Assessment Question Context You are assigned to develop a more robust and dynamic calculation of the total area under a curve using numerical integration. Your task is to implement an adaptive version of the Simpson\'s rule that adjusts its step size based on the local curvature of the function to ensure a specified accuracy is achieved. Requirements Modify the given `adaptive_simpsons_rule` function to: 1. Use an adaptive approach where the step size is dynamically adjusted. 2. Begin with a coarse approximation and iteratively refine the estimate until the desired accuracy is achieved. 3. Handle edge cases where the function might be undefined or exhibit extreme behavior gracefully. 4. Also, calculate and return the total number of function evaluations performed. Constraints * `fnc(x)` will be a real-valued function. * `a` and `b` are real numbers where `a <= b`. * The function may be undefined or exhibit extreme behavior at certain points within the interval. Input & Output # Input * `fnc`: Callable[[float], float] — a function that defines the curve. * `a`: float — start of the interval. * `b`: float — end of the interval. * `accuracy`: float — an optional parameter that defines the desired accuracy (default: `1e-6`). # Output * Returns a tuple (float, int) — The first element is the approximated area under the curve, and the second element is the total number of function evaluations performed during the integration. Example ```python >>> def g(x): >>> return math.exp(-x * x) * math.sin(5 * x) >>> area, func_evals = adaptive_simpsons_rule(g, 0, 2, accuracy=0.001) >>> print(f\\"{area:.6f}, {func_evals}\\") 0.329694, 256 ``` Function Signature ```python def adaptive_simpsons_rule( fnc: Callable[[float], float], a: float, b: float, accuracy: float = 1e-6 ) -> (float, int): pass ```","solution":"from typing import Callable import math def adaptive_simpsons_rule(fnc: Callable[[float], float], a: float, b: float, accuracy: float = 1e-6) -> (float, int): def simpsons(f, a, b): c = (a + b) / 2.0 return (b - a) / 6.0 * (f(a) + 4.0 * f(c) + f(b)) def adaptive_simpson(f, a, b, eps, whole, fa, fb, fc, limit, count): c = (a + b) / 2.0 d = (a + c) / 2.0 e = (c + b) / 2.0 fd = f(d) fe = f(e) count += 2 left = (c - a) / 6.0 * (fa + 4.0 * fd + fc) right = (b - c) / 6.0 * (fc + 4.0 * fe + fb) if limit <= 0 or abs(left + right - whole) <= 15 * eps: return left + right + (left + right - whole) / 15.0, count else: left_result, left_count = adaptive_simpson(f, a, c, eps/2.0, left, fa, fc, fd, limit-1, count) right_result, right_count = adaptive_simpson(f, c, b, eps/2.0, right, fc, fb, fe, limit-1, count) return left_result + right_result, left_count + right_count - count fa = fnc(a) fb = fnc(b) c = (a + b) / 2.0 fc = fnc(c) count = 3 whole = simpsons(fnc, a, b) result, final_count = adaptive_simpson(fnc, a, b, accuracy, whole, fa, fb, fc, 50, count) return result, final_count"},{"question":"Problem Description Design a function that calculates the number of ways to choose `k` offerings from `n` distinct goods. Each good can be chosen any number of times, including zero or more times, up to `k` total selections. Essentially, you need to determine the number of distinct multisets that can be formed by choosing `k` items from `n` types of goods, where the order does not matter. # Function Signature ```python def number_of_multisets(n: int, k: int) -> int: pass ``` # Input * `n` (int): The number of distinct goods, 1 ≤ `n` ≤ 50. * `k` (int): The total number of items to choose, 1 ≤ `k` ≤ 50. # Output * `int`: The number of distinct multisets that can be formed. # Example ```python assert number_of_multisets(3, 2) == 6 assert number_of_multisets(4, 3) == 20 assert number_of_multisets(5, 5) == 126 assert number_of_multisets(2, 10) == 11 ``` # Constraints * The function should be efficient enough to handle the upper limits of `n` and `k`. * Avoid redundant calculations by utilizing mathematical properties of combinations. # Notes: * Utilize the concepts of combinations with repetition, also known as stars and bars theorem. * The formula for the number of ways to choose `k` items from `n` types of goods is given by the binomial coefficient `C(n+k-1, k)`.","solution":"from math import comb def number_of_multisets(n: int, k: int) -> int: Calculates the number of ways to choose k items from n types of goods with repetition allowed. return comb(n + k - 1, k)"},{"question":"# Heap Sort Implementation Write a function `heap_sort(arr: List[int]) -> List[int]` that sorts an array of integers using the Heap Sort algorithm. The function should modify the input list in place and return it sorted in ascending order. Function Signature: ```python def heap_sort(arr: List[int]) -> List[int]: ``` Input: * `arr`: A list of integers where `1 ≤ len(arr) ≤ 10^5` and each integer `-10^5 ≤ arr[i] ≤ 10^5`. Output: * A list of integers, sorted in ascending order. Example: ```python assert heap_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] assert heap_sort([10, 20, 15, 30, 40]) == [10, 15, 20, 30, 40] ``` # Notes: * The function should first build a max-heap from the input list. * It should then repeatedly extract the maximum element from the heap and move it to the end of the sorted section of the array. * Discuss edge cases in your documentation, such as handling an already sorted array, an array with all elements the same, or an empty array. * Ensure that your implementation efficiently handles the time complexity of `O(n log n)`. # Constraints: * Use Python\'s list data structure for implementing the heap. * Do not use any built-in heap functions from libraries.","solution":"from typing import List def heapify(arr: List[int], n: int, i: int): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[i] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest) def heap_sort(arr: List[int]) -> List[int]: n = len(arr) for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0) return arr"},{"question":"# Data Transformation and Filtering Assessment You are required to implement a Python function to process a given dataset and filter it based on specific criteria. The objective is to assess your ability to work with data structures, apply filtering logic, and handle exceptions in Python. Context: You need to process a list of dictionaries representing employee data. Each dictionary contains details of an employee, including their name, department, and salary. Task: 1. Write a function `filter_employees(data: list[dict], department: str, min_salary: float) -> list[dict]` which takes a list of employee data, a department name, and a minimum salary, and returns a list of dictionaries containing only employees who belong to the specified department and have a salary greater than or equal to the specified minimum salary. 2. Write a second function `calculate_average_salary(employees: list[dict]) -> float` that calculates and returns the average salary of the filtered employee list provided by `filter_employees`. Input: - `data`: (list) A list of dictionaries, where each dictionary represents an employee\'s details. - Each dictionary contains: - `name`: (str) The employee\'s name. - `department`: (str) The employee\'s department. - `salary`: (float) The employee\'s salary. - `department`: (str) The department name to filter employees by. - `min_salary`: (float) The minimum salary to filter employees by. - `employees`: (list) A list of dictionary objects representing filtered employee data. Output: - For `filter_employees`: A list of dictionaries containing employee details filtered by the specified department and salary criteria. - For `calculate_average_salary`: A float representing the average salary of the filtered employees. Notes: - Handle potential errors such as missing keys in the dictionaries or non-numeric values for salaries with appropriate exception handling. - Ensure the input list is not modified by the function. - If no employees match the criteria, `filter_employees` should return an empty list. - If the list provided to `calculate_average_salary` is empty, it should return 0. Constraints: - All employee dictionary keys will be strings and all values will be of the correct data type. - The functions should be efficient and capable of handling large datasets. - Code should be written in a modular and readable manner. Example: Here is an example of expected function usage: ```python data = [ {\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\", \\"salary\\": 70000}, {\\"name\\": \\"Bob\\", \\"department\\": \\"Marketing\\", \\"salary\\": 50000}, {\\"name\\": \\"Charlie\\", \\"department\\": \\"Engineering\\", \\"salary\\": 120000}, {\\"name\\": \\"Dana\\", \\"department\\": \\"Engineering\\", \\"salary\\": 90000} ] filtered_employees = filter_employees(data, \\"Engineering\\", 60000) average_salary = calculate_average_salary(filtered_employees) # filtered_employees should be: # [{\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\", \\"salary\\": 70000}, # {\\"name\\": \\"Charlie\\", \\"department\\": \\"Engineering\\", \\"salary\\": 120000}, # {\\"name\\": \\"Dana\\", \\"department\\": \\"Engineering\\", \\"salary\\": 90000}] # average_salary should be 93333.33 ```","solution":"def filter_employees(data, department, min_salary): Filters the employee data based on department and minimum salary. Parameters: data (list): List of dictionaries, each representing an employee. department (str): Department name to filter employees. min_salary (float): Minimum salary to filter employees. Returns: list: List of dictionaries filtered by the specified department and minimum salary. filtered_employees = [ employee for employee in data if employee.get(\\"department\\") == department and employee.get(\\"salary\\", 0) >= min_salary ] return filtered_employees def calculate_average_salary(employees): Calculates the average salary of a list of employees. Parameters: employees (list): List of dictionaries, each representing an employee. Returns: float: The average salary of the given employees. if not employees: return 0.0 total_salary = sum(employee.get(\\"salary\\", 0) for employee in employees) return total_salary / len(employees)"},{"question":"# Calculate Factorial Trailing Zeros Question Given a number `n`, write a function `trailing_zeros_factorial(n: int) -> int` that calculates the number of trailing zeros in the factorial of `n`. Input * `n: int` - A positive integer number. Output * Returns an integer representing the number of trailing zeros in `n!`. Constraints * 1 <= n <= 100000 Example ```python def trailing_zeros_factorial(n: int) -> int: count = 0 power_of_5 = 5 while n >= power_of_5: count += n // power_of_5 power_of_5 *= 5 return count ``` Example Run ```python assert trailing_zeros_factorial(5) == 1 # 5! = 120 has 1 trailing zero assert trailing_zeros_factorial(10) == 2 # 10! = 3628800 has 2 trailing zeros assert trailing_zeros_factorial(25) == 6 # 25! = 15511210043330985984000000 has 6 trailing zeros assert trailing_zeros_factorial(100) == 24 # 100! has 24 trailing zeros assert trailing_zeros_factorial(100000) == 24999 # 100000! has 24999 trailing zeros ```","solution":"def trailing_zeros_factorial(n: int) -> int: Returns the number of trailing zeros in the factorial of n. count = 0 power_of_5 = 5 while n >= power_of_5: count += n // power_of_5 power_of_5 *= 5 return count"},{"question":"# Coding Assessment Question Scenario You have been tasked with developing a function that analyzes a string containing alphanumeric characters and spaces, and identifies all the unique words in it. The function should then return these words sorted in the order of their first occurrence. Problem Statement Implement a function, `unique_words(s: str) -> List[str]`, which takes a string `s` as input and returns a list of unique words from the string in the order they first appear. Words are defined as sequences of alphanumeric characters (both lowercase and uppercase are considered the same word) and are separated by spaces. Constraints * The input string `s` contains only alphanumeric characters and spaces. * The length of the input string `s` is between 1 and 1000, inclusive. Input * A string `s` containing alphanumeric characters and spaces. Output * A list of unique words, in the order of their first appearance in the string. Example ```python from typing import List def unique_words(s: str) -> List[str]: # Your implementation here # Example Usages: print(unique_words(\\"Hello world this is a test Hello world\\")) # Output: [\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\"] print(unique_words(\\"This is a is a trial\\")) # Output: [\\"this\\", \\"is\\", \\"a\\", \\"trial\\"] print(unique_words(\\"Unique Unique Words Words\\")) # Output: [\\"unique\\", \\"words\\"] ``` Requirements Ensure the implementation is efficient and handles both large inputs and repeated words correctly. Consider edge cases such as repeated words with different casing and varying spaces between words.","solution":"from typing import List def unique_words(s: str) -> List[str]: This function takes a string s and returns a list of unique words in the order they first appear in the string. Words are returned in lowercase. words = s.lower().split() unique_words_list = [] seen_words = set() for word in words: if word not in seen_words: seen_words.add(word) unique_words_list.append(word) return unique_words_list"},{"question":"# Task: You are required to implement a class `MaxHeap` which manages a max-heap data structure, allowing for efficient insertion, deletion, and retrieval of the maximum value. The class should provide methods to maintain and manipulate the heap property. # Requirements: - Implement the necessary methods to support heap operations, ensuring the heap property is preserved. - Consider time and space complexity to ensure efficiency. # Detailed Function Requirements: 1. **`insert(item: int) -> None`**: Inserts `item` into the max-heap. * **Input**: `item` - the integer value to be inserted. * **Output**: None. * **Constraints**: Ensures the heap property is preserved after insertion. 2. **`delete_max() -> int`**: Deletes the maximum value (the root) from the max-heap and returns it. * **Input**: None. * **Output**: The maximum value that was removed. * **Constraints**: Returns `None` if the heap is empty. 3. **`max() -> int`**: Returns the maximum value (the root) without removing it. * **Input**: None. * **Output**: The maximum value in the heap. * **Constraints**: Returns `None` if the heap is empty. 4. **`heapify(array: list) -> None`**: Converts a given array into a max-heap. * **Input**: `array` - a list of integers to be turned into a max-heap. * **Output**: None. # Constraints: - Implement the heap operations efficiently to ensure the overall time complexity for heap operations does not exceed `O(log n)` where `n` is the number of elements. - Ensure all edge cases are considered, including handling operations on an empty heap. # Example Usage: ```python heap = MaxHeap() heap.insert(10) heap.insert(20) heap.insert(5) print(heap.max()) # Output: 20 print(heap.delete_max()) # Output: 20 print(heap.max()) # Output: 10 array = [3, 9, 2, 1, 4, 5] heap.heapify(array) print(heap.max()) # Output: 9 ``` # Note: Your implementation should maintain the max-heap property after each operation, ensuring efficient heap manipulation techniques.","solution":"class MaxHeap: def __init__(self): self.heap = [] def _parent(self, index): return (index - 1) // 2 def _left_child(self, index): return 2 * index + 1 def _right_child(self, index): return 2 * index + 2 def _swap(self, i, j): self.heap[i], self.heap[j] = self.heap[j], self.heap[i] def _sift_up(self, index): while index > 0 and self.heap[self._parent(index)] < self.heap[index]: self._swap(self._parent(index), index) index = self._parent(index) def _sift_down(self, index): max_index = index l = self._left_child(index) if l < len(self.heap) and self.heap[l] > self.heap[max_index]: max_index = l r = self._right_child(index) if r < len(self.heap) and self.heap[r] > self.heap[max_index]: max_index = r if index != max_index: self._swap(index, max_index) self._sift_down(max_index) def insert(self, item): self.heap.append(item) self._sift_up(len(self.heap) - 1) def delete_max(self): if not self.heap: return None if len(self.heap) == 1: return self.heap.pop() max_value = self.heap[0] self.heap[0] = self.heap.pop() self._sift_down(0) return max_value def max(self): if not self.heap: return None return self.heap[0] def heapify(self, array): self.heap = array[:] for i in range(len(self.heap) // 2, -1, -1): self._sift_down(i)"},{"question":"# Coding Assessment Question: Scenario: Imagine you are developing a chess game simulation. One of the core features is to determine if a player\'s move is valid. Specifically, you need to implement the move validation for the knight piece, which moves in an \\"L\\" shape. Task: Write the function `is_valid_knight_move(start, end)` to determine if the knight\'s move from `start` to `end` is valid or not. Function Specifications: 1. **Function**: is_valid_knight_move - **Input**: - `start` (str): The starting position on the chessboard (e.g., \\"b1\\"). - `end` (str): The ending position on the chessboard (e.g., \\"c3\\"). - **Output**: - (bool): True if the move is valid, False otherwise. Constraints: - The inputs `start` and `end` will be valid chessboard positions in the form of `[a-h][1-8]`. - The function should account for the valid L-shaped moves of the knight, which are: - Two squares in one direction and one square perpendicular (or vice versa). # Example: ```python print(is_valid_knight_move(\\"b1\\", \\"c3\\")) # Output: True print(is_valid_knight_move(\\"g1\\", \\"e1\\")) # Output: False ``` **Note**: Ensure your function correctly validates moves in all possible directions and handles edge cases involving board boundaries.","solution":"def is_valid_knight_move(start, end): Determines if the move from \'start\' to \'end\' is a valid knight move in chess. Parameters: start (str): The starting position on the chessboard (e.g., \\"b1\\"). end (str): The ending position on the chessboard (e.g., \\"c3\\"). Returns: bool: True if the move is valid, False otherwise. start_col, start_row = start[0], int(start[1]) end_col, end_row = end[0], int(end[1]) # Convert columns from letters to numbers (e.g., \'a\' -> 1, \'b\' -> 2, ..., \'h\' -> 8) start_col = ord(start_col) - ord(\'a\') + 1 end_col = ord(end_col) - ord(\'a\') + 1 # Calculate the differences col_diff = abs(end_col - start_col) row_diff = abs(end_row - start_row) # A valid knight move is two squares in one direction and one square in the perpendicular direction return (col_diff == 2 and row_diff == 1) or (col_diff == 1 and row_diff == 2)"},{"question":"# Vehicle Fleet Management System Context In managing a fleet of vehicles, it\'s essential to track the total distance traveled by each vehicle over time. Typically, a GPS device installed in each vehicle will send periodic updates with the distance covered since the last report. This data is collected in a central system for analysis. Problem Write a Python class `VehicleFleet` to keep track of the total distance traveled by each vehicle using the following methods: 1. `add_vehicle(vehicle_id: str) -> None`: Method to register a new vehicle with a unique `vehicle_id`. 2. `update_distance(vehicle_id: str, distance: float) -> None`: Method to update the distance traveled by a vehicle since the last update. 3. `get_total_distance(vehicle_id: str) -> float`: Method to get the total distance traveled by a specified vehicle. Input & Output - **Vehicle ID** (str): A unique identifier for each vehicle. - **Distance** (float): Distance traveled since the last update in kilometers. - **Result:** For `get_total_distance`, return the total distance in kilometers that the specified vehicle has traveled. Constraints 1. `vehicle_id` should be a non-empty string consisting of alphanumeric characters. 2. `distance` and total distances must be non-negative. 3. If attempting to update or retrieve the distance for a non-registered vehicle, raise a `ValueError` with the message \\"Vehicle not found\\". 4. Each method should have an average time complexity of (O(1)). # Example ```python fleet = VehicleFleet() fleet.add_vehicle(\\"ABC123\\") fleet.update_distance(\\"ABC123\\", 150.75) fleet.update_distance(\\"ABC123\\", 200.25) print(fleet.get_total_distance(\\"ABC123\\")) # Output: 351.0 fleet.add_vehicle(\\"DEF456\\") fleet.update_distance(\\"DEF456\\", 100.0) print(fleet.get_total_distance(\\"DEF456\\")) # Output: 100.0 try: print(fleet.get_total_distance(\\"XYZ999\\")) except ValueError as e: print(e) # Output: Vehicle not found fleet.update_distance(\\"ABC123\\", 50.0) print(fleet.get_total_distance(\\"ABC123\\")) # Output: 401.0 ``` # Note - You can assume that vehicle registrations and updates are made in real-time as the fleet operates. - Vehicle distances will be provided as floating-point values representing kilometers. This problem tests your ability to create and manipulate a class with methods to manage state efficiently. Ensure your implementation adheres to best practices for error handling and data encapsulation.","solution":"class VehicleFleet: def __init__(self): self.vehicles = {} def add_vehicle(self, vehicle_id: str) -> None: if vehicle_id in self.vehicles: raise ValueError(f\\"Vehicle with id {vehicle_id} already exists\\") self.vehicles[vehicle_id] = 0.0 def update_distance(self, vehicle_id: str, distance: float) -> None: if vehicle_id not in self.vehicles: raise ValueError(\\"Vehicle not found\\") if distance < 0: raise ValueError(\\"Distance cannot be negative\\") self.vehicles[vehicle_id] += distance def get_total_distance(self, vehicle_id: str) -> float: if vehicle_id not in self.vehicles: raise ValueError(\\"Vehicle not found\\") return self.vehicles[vehicle_id]"},{"question":"# Right Rotation of an Array **Context**: You are given an integer array and a number of rotations. Your task is to rotate the array to the right a given number of times. Each rotation moves the last element of the array to the front. **Function Specification**: Write a function `rotate_right(arr: list[int], k: int) -> list[int]` that rotates the array to the right `k` times. **Input**: - A list of integers `arr` (0 <= len(arr) <= 10^5) - An integer `k` (0 <= k <= 10^9) **Output**: - A new list of integers that represents the array rotated to the right `k` times. **Constraints**: - The function should handle cases where `arr` is empty gracefully. - Since ( k ) can be much larger than the length of `arr`, optimize the rotations by reducing unnecessary full rotations. **Performance**: - Your solution should be efficient in both time and space. **Sample Input and Output**: ```python assert rotate_right([1, 2, 3, 4, 5], 1) == [5, 1, 2, 3, 4] assert rotate_right([1, 2, 3, 4, 5], 3) == [3, 4, 5, 1, 2] assert rotate_right([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] assert rotate_right([1, 2, 3, 4, 5], 7) == [4, 5, 1, 2, 3] assert rotate_right([], 3) == [] ```","solution":"def rotate_right(arr, k): Rotates the array to the right k times. Args: arr (list of int): The array to rotate. k (int): The number of rotations. Returns: list of int: The rotated array. if not arr: return arr n = len(arr) k = k % n # Optimize the number of rotations if k == 0: return arr # No rotation needed return arr[-k:] + arr[:-k]"},{"question":"# Question **Problem Statement**: You are given a sequence of integers and you need to find the longest subsequence where the difference between consecutive elements is the same. Write a function called `longest_arithmetic_subsequence(arr: list[int]) -> int` that takes a list of integers and returns the length of the longest arithmetic subsequence. An arithmetic subsequence is defined as a sequence where the difference between any two consecutive elements is constant. **Objective**: 1. Implement the `longest_arithmetic_subsequence(arr: list[int]) -> int` function that determines the length of the longest arithmetic subsequence in the input list. - The function should handle both positive and negative differences. **Constraints**: - The length of the input list `arr` will be between 1 and 1000. **Input**: - A list of integers `arr`. **Output**: - An integer representing the length of the longest arithmetic subsequence. **Examples**: 1. `longest_arithmetic_subsequence([3, 6, 9, 12])` should return `4`. - Explanation: The entire list `[3, 6, 9, 12]` is an arithmetic subsequence with a common difference of `3`. 2. `longest_arithmetic_subsequence([9, 4, 7, 2, 10])` should return `3`. - Explanation: The longest arithmetic subsequence is `[4, 7, 10]` with a common difference of `3`. 3. `longest_arithmetic_subsequence([20, 1, 15, 3, 10, 5, 8])` should return `4`. - Explanation: The longest arithmetic subsequence is `[20, 15, 10, 5]` with a common difference of `-5`. This problem tests your ability to understand and implement algorithms for finding patterns in sequences and demonstrates your understanding of arithmetic progressions. Your solution should handle various input scenarios efficiently.","solution":"def longest_arithmetic_subsequence(arr: list[int]) -> int: if len(arr) <= 1: return len(arr) dp = [{} for _ in range(len(arr))] max_length = 1 for i in range(len(arr)): for j in range(i): diff = arr[i] - arr[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 # a new subsequence of length 2 max_length = max(max_length, dp[i][diff]) return max_length"},{"question":"# Problem Statement You are given a `TextEditor` class that simulates basic text editing operations. Your task is to modify this class to add the following features: 1. Implement a function to track and store the history of changes. 2. Add undo and redo functionality to revert and reapply changes made to the text. # Requirements History Tracking - Maintain a list of actions performed on the text. - Each action should capture the operation type, text involved, and position. Undo/Redo Functionality - Implement an `undo` method to revert the most recent change. - Implement a `redo` method to reapply a previously undone action. - An action history limit of 100 should be maintained to manage memory usage efficiently. # Function Signatures You will need to add new methods to the `TextEditor` class and possibly modify existing ones. 1. `type_text(self, text: str, position: int) -> None`: - Types `text` at the given `position`. - Updates the history with this action. 2. `delete_text(self, start: int, end: int) -> None`: - Deletes text from `start` to `end` positions. - Updates the history with this action. 3. `undo(self) -> None`: - Reverts the most recent change. 4. `redo(self) -> None`: - Reapplies the most recently undone change. 5. Implement necessary adjustments to internal representations and add helper methods if needed. # Constraints - Text is managed as a simple string. - Positions are zero-indexed. - Max text size is 10,000 characters. - Max number of undoable actions is 100. # Example Usage ```python editor = TextEditor() editor.type_text(\\"Hello\\", 0) editor.type_text(\\" world\\", 5) assert editor.get_text() == \\"Hello world\\" editor.delete_text(5, 11) assert editor.get_text() == \\"Hello\\" editor.undo() assert editor.get_text() == \\"Hello world\\" editor.redo() assert editor.get_text() == \\"Hello\\" # Add the code for implementing this functionality # Your additional implementation should integrate smoothly with the # existing functionality such as the provided code and test cases. if __name__ == \\"__main__\\": unittest.main() ``` # Notes - Ensure your new methods adhere to and extend the existing class design. - Your changes should not break the existing basic text editing functionality. - Write new tests to cover the added features and ensure comprehensive testing.","solution":"class TextEditor: def __init__(self): self.text = \\"\\" self.history = [] self.redo_stack = [] self.history_limit = 100 def get_text(self): return self.text def type_text(self, text: str, position: int) -> None: if position < 0 or position > len(self.text): raise ValueError(\\"Invalid position\\") self.text = self.text[:position] + text + self.text[position:] self.history.append((\\"type\\", text, position)) if len(self.history) > self.history_limit: self.history.pop(0) self.redo_stack.clear() def delete_text(self, start: int, end: int) -> None: if start < 0 or end > len(self.text) or start > end: raise ValueError(\\"Invalid positions\\") deleted_text = self.text[start:end] self.text = self.text[:start] + self.text[end:] self.history.append((\\"delete\\", deleted_text, start)) if len(self.history) > self.history_limit: self.history.pop(0) self.redo_stack.clear() def undo(self) -> None: if not self.history: raise ValueError(\\"No actions to undo\\") action = self.history.pop() action_type, text, position = action if action_type == \\"type\\": self.text = self.text[:position] + self.text[position + len(text):] elif action_type == \\"delete\\": self.text = self.text[:position] + text + self.text[position:] self.redo_stack.append(action) def redo(self) -> None: if not self.redo_stack: raise ValueError(\\"No actions to redo\\") action = self.redo_stack.pop() action_type, text, position = action if action_type == \\"type\\": self.text = self.text[:position] + text + self.text[position:] elif action_type == \\"delete\\": self.text = self.text[:position] + self.text[position + len(text):] self.history.append(action)"},{"question":"# Matrix Spiral Traversal Objective You are required to implement a function that returns the elements of a given matrix in spiral order. To assess your understanding of matrix manipulation and traversal, ensure your implementation handles different matrix sizes and shapes efficiently. Requirements 1. **Function Signature**: `spiral_order(matrix: list[list[int]]) -> list[int]` 2. **Input**: * `matrix`: A 2D list of integers with dimensions m x n (1 ≤ m, n ≤ 100). * The matrix can contain both positive and negative integers. 3. **Output**: * A list of integers representing the elements of the matrix traversed in spiral order. Constraints * Implement the traversal logic without relying on additional libraries. * Consider edge cases such as single-row or single-column matrices. Performance Requirements * The solution should efficiently handle matrices up to the maximum dimension sizes allowed by the constraints. * Aim for a time complexity of O(m * n), where m is the number of rows and n is the number of columns. Scenario Imagine you have a robot that is programmed to clean a rectangular grid of rooms. The robot follows a spiral pattern to ensure every room is visited. Your task is to simulate this movement pattern by listing the order in which the robot visits each room. Example ```python # Example usage: print(spiral_order([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ])) # Expected Output: [1, 2, 3, 6, 9, 8, 7, 4, 5] print(spiral_order([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ])) # Expected Output: [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] print(spiral_order([ [1] ])) # Expected Output: [1] print(spiral_order([ [1, 2, 3], [4, 5, 6] ])) # Expected Output: [1, 2, 3, 6, 5, 4] ```","solution":"def spiral_order(matrix): Returns the elements of the matrix in spiral order. if not matrix or not matrix[0]: return [] result = [] left, right = 0, len(matrix[0]) - 1 top, bottom = 0, len(matrix) - 1 while left <= right and top <= bottom: # Traverse from left to right along the top row for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 # Traverse from top to bottom along the right column for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: # Traverse from right to left along the bottom row for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: # Traverse from bottom to top along the left column for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"You are developing an application that processes large text files, and you need to count the frequency of each word in a given document while ensuring that the results are case-insensitive. Your task is to implement a function that reads a string and returns a dictionary with each unique word as the key and its corresponding frequency as the value. # Task: Your task is to implement a function `word_frequency_counter` that takes a string `text` as input and returns a dictionary with words as keys and their frequencies as values. The words should be treated in a case-insensitive manner. # Function Signature: ```python def word_frequency_counter(text: str) -> dict[str, int]: pass ``` # Expected Input and Output: * **Input:** A string `text` containing words separated by spaces. Punctuation should be ignored. * **Output:** A dictionary where keys are the unique case-insensitive words and values are their frequencies. # Constraints: * The length of `text` will not exceed ( 10^6 ) characters. * The function should handle the text case-insensitively. * Assume that the text contains only ASCII characters. # Examples: ```python >>> word_frequency_counter(\\"Hello, world! Hello, WORLD.\\") {\'hello\': 2, \'world\': 2} >>> word_frequency_counter(\\"This is a test. This test is only a test.\\") {\'this\': 2, \'is\': 2, \'a\': 2, \'test\': 3, \'only\': 1} >>> word_frequency_counter(\\"Python is great, and Python is fun.\\") {\'python\': 2, \'is\': 2, \'great\': 1, \'and\': 1, \'fun\': 1} ``` # Context: You are working on a text analysis tool used to process and analyze large text files from various sources. The tool needs to quickly compute the frequency of each word in a given text to generate summary statistics and provide insights. The function should be efficient enough to handle large inputs and ensure that the word frequencies are accurate regardless of the case of the words.","solution":"import re from collections import defaultdict def word_frequency_counter(text: str) -> dict: Returns a dictionary with each unique word as the key and its corresponding frequency as the value. The function is case-insensitive and ignores punctuation. :param text: A string containing words separated by spaces. :return: A dictionary with words as keys and their frequencies as values. # Use regex to find all words and ignore punctuation words = re.findall(r\'bw+b\', text.lower()) # Use defaultdict to keep the frequency count frequency = defaultdict(int) for word in words: frequency[word] += 1 return dict(frequency)"},{"question":"# Scenario You are a software developer at a startup company that specializes in real-time data analytics. One of your tasks is to develop a processing pipeline that can handle large datasets efficiently. As a part of this, you need to implement a function that will perform a specific series of transformations on a list of numbers. # Task Write a function `process_data` that takes a list of integers and processes it through a series of operations: filtering, mapping, and reducing. # Function Signature ```python def process_data(data: List[int], threshold: int, factor: int) -> int: ``` # Input - `data` (List[int]): A list of integers representing the dataset. - `threshold` (int): A threshold value for filtering. - `factor` (int): A factor value for mapping. # Output - Returns a single integer, which is the result of applying the following operations in order: 1. **Filter**- Keep only the numbers that are greater than the `threshold`. 2. **Map**- Multiply each remaining number by the `factor`. 3. **Reduce**- Compute the sum of all the mapped numbers. # Constraints - The input list can contain up to 10^5 integers. - Each integer in the list is in the range [-10^4, 10^4]. - `threshold` and `factor` are integers within the same range [-10^4, 10^4]. # Examples ```python # Example 1 print(process_data([1, 2, 3, 4, 5], 2, 3)) # Output: 21 # Explanation: # Filtered list: [3, 4, 5] # Mapped list: [9, 12, 15] # Sum: 36 # Example 2 print(process_data([-1, 0, 1, 2], 0, 10)) # Output: 30 # Explanation: # Filtered list: [1, 2] # Mapped list: [10, 20] # Sum: 30 # Example 3 print(process_data([5, -5, 10, -10, 0], 0, 5)) # Output: 75 # Explanation: # Filtered list: [5, 10] # Mapped list: [25, 50] # Sum: 75 # Example 4 print(process_data([100, 200, -200, -300, 400], 100, 2)) # Output: 1200 # Explanation: # Filtered list: [200, 400] # Mapped list: [400, 800] # Sum: 1200 ``` # Notes - Focus on handling large datasets efficiently using appropriate data structures and functional programming techniques. - Ensure your solution is optimized for performance, considering the constraints and potential size of the input list.","solution":"from typing import List def process_data(data: List[int], threshold: int, factor: int) -> int: Processes the data list through a series of transformations: 1. Filters out the numbers <= threshold 2. Multiplies each remaining number by the factor 3. Sums up all the results :param data: List of integers as the dataset :param threshold: Integer threshold for filtering :param factor: Integer factor for mapping :return: Integer result after filtering, mapping, and reducing return sum(num * factor for num in data if num > threshold)"},{"question":"# Question: Efficient String Permutations Count **Objective**: Write a program to calculate the number of distinct permutations (arrangements) of a given input string considering that the string may contain duplicate characters. **Scenario**: You are developing a feature for a word game that generates all possible unique combinations of letters to form potential words. Given a set of characters (possibly repeating), determine the number of unique permutations possible with those characters. Function Details: Implement the function `count_permutations(s: str) -> int`: 1. **Input**: - `s` (str): A string containing only alphabetical characters (a-z, A-Z). - Constraints: `0 <= len(s) <= 100` 2. **Output**: - Returns an integer representing the number of distinct permutations of the input string. 3. **Error Handling**: - If `s` contains non-alphabetic characters, raise a `ValueError` with the message \\"String must contain only alphabetic characters.\\" - If `s` is not a string, raise a `TypeError` with the message \\"Input must be a string.\\" 4. **Performance Requirements**: - The solution should efficiently compute the result for strings up to the length limit without excessive computation time. Example Usage: ```python >>> count_permutations(\\"abc\\") 6 >>> count_permutations(\\"aab\\") 3 >>> count_permutations(\\"abcabc\\") 720 >>> count_permutations(\\"\\") 1 ``` # Requirements - Write clean and well-documented code. - Ensure the program handles edge cases, including empty strings or strings with all identical characters. **Hints**: - Use mathematical concepts such as factorial and combinations to handle the permutations of strings with repeated characters. - Consider the implications of duplicate elements on the permutation counts and compute accordingly to avoid over-counting. **Note**: Avoid simply generating all permutations and counting them, as it may be computationally prohibitive for larger strings.","solution":"from math import factorial from collections import Counter import string def count_permutations(s: str) -> int: Returns the number of distinct permutations of the input string. if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") if any(char not in string.ascii_letters for char in s): raise ValueError(\\"String must contain only alphabetic characters\\") if len(s) == 0: return 1 char_counts = Counter(s) total_permutations = factorial(len(s)) for count in char_counts.values(): total_permutations //= factorial(count) return total_permutations"},{"question":"# String Compression You are working on a data processing system where the storage space is a crucial resource. To optimize storage, you decide to implement a function that compresses strings using the run-length encoding (RLE) algorithm. Requirements: 1. The function should compress a given string by replacing consecutive identical characters with the character followed by the number of occurrences. 2. If the compressed string is not shorter than the original string, return the original string. 3. Ensure that the function is case-sensitive. Input: * A single string `s`. Output: * A compressed version of the string if it is shorter than the original, otherwise the original string. Function Signature: ```python def compress_string(s: str) -> str: pass ``` Example: ```python # Example usage: assert compress_string(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" assert compress_string(\\"abcdef\\") == \\"abcdef\\" assert compress_string(\\"aabbcc\\") == \\"aabbcc\\" ``` Constraints: * `1 <= len(s) <= 10^5` * The string `s` consists of printable ASCII characters only. Implement the function `compress_string` adhering to the above specifications.","solution":"def compress_string(s: str) -> str: if not s: return s compressed = [] count = 1 length = len(s) for i in range(1, length): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) # Adding the last set of characters compressed_str = \'\'.join(compressed) return compressed_str if len(compressed_str) < length else s"},{"question":"# Maximum Subarray Sum using Divide and Conquer You are required to find the maximum sum of any contiguous subarray within a given list of integers using the Divide and Conquer approach. This problem is a classic example that can be solved efficiently by dividing the array into smaller subarrays and then combining the results. **Function Signature:** ```python def max_subarray_sum(arr: list) -> int: ``` **Input:** * `arr` - A list of integers. **Output:** * An integer representing the maximum sum of the contiguous subarray. **Constraints:** * You must implement the algorithm using the Divide and Conquer approach. * Consider edge cases such as lists with single elements, all negative values, and an empty list. **Scenario:** Your task is to implement the function to help optimize performance in applications where finding maximum spans of positive gain in large datasets is crucial, such as in the stock market analysis. **Example:** ```python >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1, -2, -3]) -1 ``` Here is a starting point for your solution: ```python def max_crossing_sum(arr, left, mid, right): # Include elements on left of mid. sm = 0 left_sum = float(\'-inf\') for i in range(mid, left - 1, -1): sm += arr[i] if sm > left_sum: left_sum = sm # Include elements on right of mid. sm = 0 right_sum = float(\'-inf\') for i in range(mid + 1, right + 1): sm += arr[i] if sm > right_sum: right_sum = sm # Return sum of elements on left and right of mid. return left_sum + right_sum def max_subarray_sum_util(arr, left, right): # Base case: only one element. if left == right: return arr[left] # Find the middle point. mid = (left + right) // 2 return max(max_subarray_sum_util(arr, left, mid), max_subarray_sum_util(arr, mid + 1, right), max_crossing_sum(arr, left, mid, right)) def max_subarray_sum(arr): if not arr: return 0 return max_subarray_sum_util(arr, 0, len(arr) - 1) ``` **Note:** Test your function with various cases to ensure it handles all edge cases correctly and performs efficiently.","solution":"def max_crossing_sum(arr, left, mid, right): Helper function to find the maximum possible sum in arr[] such that the sum includes elements on the left of mid and elements on the right of mid # Include elements on left of mid sm = 0 left_sum = float(\'-inf\') for i in range(mid, left - 1, -1): sm += arr[i] left_sum = max(left_sum, sm) # Include elements on right of mid sm = 0 right_sum = float(\'-inf\') for i in range(mid + 1, right + 1): sm += arr[i] right_sum = max(right_sum, sm) # Return sum of elements on left and right of mid return left_sum + right_sum def max_subarray_sum_util(arr, left, right): # Base case: only one element if left == right: return arr[left] # Find the middle point mid = (left + right) // 2 return max(max_subarray_sum_util(arr, left, mid), max_subarray_sum_util(arr, mid + 1, right), max_crossing_sum(arr, left, mid, right)) def max_subarray_sum(arr): if not arr: return 0 return max_subarray_sum_util(arr, 0, len(arr) - 1)"},{"question":"# Question: T-Shirt Size Classification Problem Statement: You are required to implement a Python function that classifies the size of a t-shirt based on the measurements of its chest (around the fullest part of the chest) and length (from the highest point of the shoulder to the bottom hem). The classification will be done according to the following table: | Size | Chest (cm) | Length (cm) | |------|------------|-------------| | XS | 78 - 82 | 58 - 62 | | S | 83 - 87 | 63 - 67 | | M | 88 - 92 | 68 - 72 | | L | 93 - 97 | 73 - 77 | | XL | 98 - 102 | 78 - 82 | | XXL | 103 - 107 | 83 - 87 | Function Signature: ```python def classify_tshirt_size(chest: float, length: float) -> str: ``` Input: - **chest** (float): The chest measurement of the t-shirt in centimeters (cm). (0 < chest ≤ 120) - **length** (float): The length measurement of the t-shirt in centimeters (cm). (0 < length ≤ 120) Output: - Returns the size (str) of the t-shirt. If the measurements do not fall within any of the given size ranges, return \\"Size not available\\". Constraints: - Both chest and length measurements must be positive. If any of the measurements are non-positive, raise a `ValueError` with the appropriate message: - \\"Chest measurement must be positive\\" for chest. - \\"Length measurement must be positive\\" for length. Examples: ```python >>> classify_tshirt_size(79, 60) \'XS\' >>> classify_tshirt_size(84, 65) \'S\' >>> classify_tshirt_size(89, 70) \'M\' >>> classify_tshirt_size(95, 75) \'L\' >>> classify_tshirt_size(100, 80) \'XL\' >>> classify_tshirt_size(105, 85) \'XXL\' >>> classify_tshirt_size(110, 90) \'Size not available\' >>> classify_tshirt_size(75, 60) \'Size not available\' >>> classify_tshirt_size(85, -5) Traceback (most recent call last): ... ValueError: Length measurement must be positive ``` Implementation: Use Python and ensure that your function handles all edge cases and properly assesses the t-shirt size based on the provided measurements. Note: The problem has clearly defined input ranges for valid chest and length measurements, and proper error handling for invalid cases. Ensure your function adheres to these constraints.","solution":"def classify_tshirt_size(chest: float, length: float) -> str: if chest <= 0: raise ValueError(\\"Chest measurement must be positive\\") if length <= 0: raise ValueError(\\"Length measurement must be positive\\") size_chart = [ (\\"XS\\", 78, 82, 58, 62), (\\"S\\", 83, 87, 63, 67), (\\"M\\", 88, 92, 68, 72), (\\"L\\", 93, 97, 73, 77), (\\"XL\\", 98, 102, 78, 82), (\\"XXL\\", 103, 107, 83, 87), ] for size, chest_min, chest_max, length_min, length_max in size_chart: if chest_min <= chest <= chest_max and length_min <= length <= length_max: return size return \\"Size not available\\""},{"question":"# Word Frequency Analysis You are given a paragraph of text, and your task is to analyze the frequency of each word in the paragraph. You must write a function that returns the count of each unique word. Function Signature ```python def word_frequency(text: str) -> dict: ``` Parameters * **text** (str): A paragraph of text. Returns * **dict**: A dictionary where the keys are unique words (in lowercase) and the values are the frequency of those words in the text. Constraints 1. Words are case-insensitive and should be counted in lowercase. 2. The text can include punctuation marks which should be removed while counting words. 3. The input text will not exceed a length of 1000 characters. Example ```python >>> word_frequency(\\"Hello, hello! How are you? Are you doing fine? Yes, I am fine.\\") {\'hello\': 2, \'how\': 1, \'are\': 2, \'you\': 2, \'doing\': 1, \'fine\': 2, \'yes\': 1, \'i\': 1, \'am\': 1} >>> word_frequency(\\"This is a test. This test is only a test.\\") {\'this\': 2, \'is\': 2, \'a\': 2, \'test\': 3, \'only\': 1} ``` # Additional Notes * You can assume that the input text is non-empty. * Make sure to handle punctuation properly: `Hello,` and `hello!` should both count as the word `hello`. Implement the `word_frequency` function with the provided specifications.","solution":"import re from collections import defaultdict def word_frequency(text: str) -> dict: Analyzes the frequency of each word in the given paragraph of text. Parameters: text (str): A paragraph of text. Returns: dict: A dictionary where the keys are unique words (in lowercase) and the values are the frequency of those words in the text. # Remove punctuation and convert text to lowercase clean_text = re.sub(r\'[^ws]\', \'\', text).lower() # Split the text into words words = clean_text.split() # Use defaultdict to count the frequency of each word frequency = defaultdict(int) for word in words: frequency[word] += 1 return dict(frequency)"},{"question":"# Coding Assessment Question **Scenario**: As a data analyst, you frequently need to parse and analyze streams of data records. One frequent format you come across is JSON. To aid in this task, you have decided to write a utility that extracts specific data from nested JSON objects and presents it in a simplified format. **Problem Statement**: Implement a function `flatten_json()` that takes a nested JSON object and returns a flattened dictionary where nested keys are concatenated into a single key, separated by underscores (`_`). Your task is to ensure that the function can handle arbitrarily nested dictionaries and lists within the JSON objects. Function Signature ```python def flatten_json(json_obj: dict, parent_key: str = \'\', separator: str = \'_\') -> dict: # Implementation here ``` Input & Output Formats - **Input**: A nested JSON object `json_obj` represented as a Python dictionary. - **Output**: A flattened dictionary with keys concatenated by the specified `separator`. Constraints - The function must handle nested dictionaries and lists appropriately. - Consider edge cases such as empty dictionaries and lists. - Maintain good coding practices and handle large nested structures efficiently. Examples ```python >>> flatten_json({\\"name\\": {\\"first\\": \\"John\\", \\"last\\": \\"Doe\\"}, \\"age\\": 30}) {\'name_first\': \'John\', \'name_last\': \'Doe\', \'age\': 30} >>> flatten_json({\\"a\\": {\\"b\\": {\\"c\\": {\\"d\\": \\"e\\"}}}}) {\'a_b_c_d\': \'e\'} >>> flatten_json({\\"name\\": \\"Alice\\", \\"contact\\": [{\\"phone\\": \\"12345\\"}, {\\"email\\": \\"alice@example.com\\"}]}) {\'name\': \'Alice\', \'contact_0_phone\': \'12345\', \'contact_1_email\': \'alice@example.com\'} >>> flatten_json({}) {} >>> flatten_json({\\"list\\": [1, 2, {\\"inner\\": 3}]}) {\'list_0\': 1, \'list_1\': 2, \'list_2_inner\': 3} ``` **Note**: Ensure your implementation correctly handles various levels of nesting and mixed types within JSON structures.","solution":"def flatten_json(json_obj, parent_key=\'\', separator=\'_\'): Flattens a nested JSON object. Nested keys are concatenated into a single key, separated by the specified separator. Args: json_obj (dict): The JSON object to be flattened. parent_key (str): The base key for the current level of recursion; defaults to empty string. separator (str): The string used to separate concatenated keys; defaults to \'_\'. Returns: dict: A flattened dictionary with keys concatenated by the specified separator. items = [] for k, v in json_obj.items(): new_key = f\\"{parent_key}{separator}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_json(v, new_key, separator).items()) elif isinstance(v, list): for i, item in enumerate(v): items.extend(flatten_json({f\\"{i}\\": item}, new_key, separator).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"# Given Context You are developing an e-commerce application and need to implement a feature that tracks the number of times a product has been viewed. This feature should be efficient and scalable as it will be used extensively across the platform. # Task 1. Implement a `ProductViewTracker` class with the following methods: - `view_product(product_id: str) -> None`: This method increments the view count for the given `product_id`. - `get_view_count(product_id: str) -> int`: This method returns the current view count for the given `product_id`. 2. Ensure that the solution properly handles concurrency, as multiple users might view the same product simultaneously. # Input and Output Formats * **Methods to implement**: * `view_product(product_id: str)` - This method takes a `product_id` and increments its view count. * `get_view_count(product_id: str)` - This method takes a `product_id` and returns its current view count. * **Constraints**: * Use a thread-safe mechanism to handle concurrent views. * Use a dictionary to store the view counts. * You may assume `product_id` is a non-empty string. # Example Scenario Assume the product with ID \\"A123\\" is viewed 5 times and the product with ID \\"B456\\" is viewed 3 times. The tracker should accurately maintain these counts regardless of the order or concurrency of the views. # Starter Code ```python import threading from collections import defaultdict from typing import DefaultDict class ProductViewTracker: def __init__(self): self.view_counts: DefaultDict[str, int] = defaultdict(int) self.lock = threading.Lock() def view_product(self, product_id: str) -> None: with self.lock: self.view_counts[product_id] += 1 def get_view_count(self, product_id: str) -> int: with self.lock: return self.view_counts[product_id] # Example usage: tracker = ProductViewTracker() tracker.view_product(\\"A123\\") print(tracker.get_view_count(\\"A123\\")) # Output should be 1 tracker.view_product(\\"A123\\") print(tracker.get_view_count(\\"A123\\")) # Output should be 2 tracker.view_product(\\"B456\\") print(tracker.get_view_count(\\"B456\\")) # Output should be 1 ``` # Note: - Ensure the code handles concurrent increments correctly. - Use appropriate thread synchronization mechanisms to avoid race conditions.","solution":"import threading from collections import defaultdict from typing import DefaultDict class ProductViewTracker: def __init__(self): self.view_counts: DefaultDict[str, int] = defaultdict(int) self.lock = threading.Lock() def view_product(self, product_id: str) -> None: with self.lock: self.view_counts[product_id] += 1 def get_view_count(self, product_id: str) -> int: with self.lock: return self.view_counts[product_id]"},{"question":"# Find Fibonacci Sequence Kth Term Context The Fibonacci sequence is defined as: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n ≥ 2. Given an integer `k`, your task is to write a function that returns the kth term of the Fibonacci sequence. If `k` is not a non-negative integer, the function should raise a `TypeError`. Task Write a function `fibonacci_kth_term(k: int) -> int` that takes an integer `k` as input and returns the kth term in the Fibonacci sequence. The function should raise a `TypeError` if the input is not an integer. Function Signature ```python def fibonacci_kth_term(k: int) -> int: ``` Input * An integer `k` where ( 0 leq k leq 10^5 ). Output * The kth term in the Fibonacci sequence. * Raise `TypeError` if the input is not an integer. Performance Requirements * The function should be efficient and handle large values of `k` within reasonable time limits. Example ```python >>> fibonacci_kth_term(0) 0 >>> fibonacci_kth_term(1) 1 >>> fibonacci_kth_term(7) 13 >>> fibonacci_kth_term(20) 6765 >>> fibonacci_kth_term(100) 354224848179261915075 >>> fibonacci_kth_term(10.5) Traceback (most recent call last): ... TypeError: Input value of [number=10.5] must be an integer ``` Constraints * ( 0 leq k leq 10^5 ) * Function should not take input/output from the user directly; it should be purely functional. Hints * Consider different methods to calculate Fibonacci numbers (e.g., iterative vs. using the formula). * Use memoization or other optimization techniques for efficient computation.","solution":"def fibonacci_kth_term(k: int) -> int: if not isinstance(k, int): raise TypeError(f\\"Input value of [number={k}] must be an integer\\") if k < 0: raise ValueError(\\"Input must be a non-negative integer\\") if k == 0: return 0 elif k == 1: return 1 a, b = 0, 1 for _ in range(2, k + 1): a, b = b, a + b return b"},{"question":"# Context You are developing a messaging application that includes a feature to count the frequency of words in a text message. To efficiently store and retrieve the word counts, you need to implement a system that can handle large volumes of data and frequent updates. # Task Implement a class `WordCounter` that tracks the frequency of words in messages. Your class should allow adding new messages and provide the ability to retrieve the count of any word. # Requirements * Your class should support the following methods: - `__init__(self)`: Initializes the word counter. - `add_message(self, message: str)`: Adds a new message and updates the word counts. - `get_word_count(self, word: str) -> int`: Returns the count of the specified word. If the word is not present, return 0. * Your implementation should efficiently handle large inputs and frequent updates. * Words are case-insensitive and should be normalized to lowercase. * Ignore punctuation and consider only alphabetic characters in words. # Class Signature ```python class WordCounter: def __init__(self): pass def add_message(self, message: str): pass def get_word_count(self, word: str) -> int: pass ``` # Example Usage ```python >>> wc = WordCounter() >>> wc.add_message(\\"Hello world! Hello\\") >>> wc.add_message(\\"Another message, with words: hello, world.\\") >>> wc.get_word_count(\\"hello\\") 3 >>> wc.get_word_count(\\"world\\") 2 >>> wc.get_word_count(\\"another\\") 1 >>> wc.get_word_count(\\"unknown\\") 0 ``` # Constraints and Considerations * Use appropriate data structures to ensure efficient storage and retrieval of word counts. * You may use Python\'s built-in libraries and modules but avoid using ready-made solutions that directly accomplish the task (e.g., collections.Counter for word counting). * Consider edge cases like empty messages, messages with only punctuation, and varying word cases. * Ensure your solution is scalable and performs well with high-frequency updates and queries.","solution":"import re from collections import defaultdict class WordCounter: def __init__(self): self.word_counts = defaultdict(int) def add_message(self, message: str): words = re.findall(r\'b[a-zA-Z]+b\', message.lower()) for word in words: self.word_counts[word] += 1 def get_word_count(self, word: str) -> int: return self.word_counts[word.lower()]"},{"question":"Problem Statement You are required to implement a `QueueUsingStacks` class which simulates the functionalities of a queue but uses two stacks to achieve this. The implemented queue should support standard queue operations: `enqueue`, `dequeue`, `peek`, `is_empty`, and `size`. The goal is to ensure the queue operates efficiently even with the abstractions of underlying stack operations. # Requirements 1. Implement the `QueueUsingStacks` class utilizing two stack instances. 2. Ensure the `enqueue` operation inserts elements into the queue. 3. Ensure the `dequeue` operation removes elements from the queue following the FIFO (first-in, first-out) principle. 4. Implement the `peek` operation to retrieve the front element without removing it. 5. Implement `is_empty` to check if the queue is empty. 6. Implement `size` to return the number of elements in the queue. 7. Proper exception handling for queue underflow (attempting to dequeue or peek from an empty queue). # Input - Standard queue operations (`enqueue`, `dequeue`, `peek`, etc.) inputs. # Output - Return standard queue operation results as defined (e.g., `dequeue` returns the dequeued element). # Constraints - The queue operates using two internal stacks to simulate queue behavior. - All operations should aim for minimal time complexity. # Example ```python >>> q = QueueUsingStacks() >>> q.enqueue(1) >>> q.enqueue(2) >>> q.enqueue(3) >>> q.dequeue() 1 >>> q.peek() 2 >>> q.is_empty() False >>> q.size() 2 >>> q.dequeue() 2 >>> q.dequeue() 3 >>> q.is_empty() True >>> q.dequeue() # This should raise an exception or return an appropriate message as the queue is empty. ``` # Note - Ensure to handle all edge cases, particularly when operating on an empty queue. - Class methods should include proper documentation and necessary exception handling.","solution":"class QueueUsingStacks: def __init__(self): self.stack1 = [] # Stack for enqueue self.stack2 = [] # Stack for dequeue def enqueue(self, item): self.stack1.append(item) def dequeue(self): if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) if not self.stack2: raise IndexError(\\"dequeue from empty queue\\") return self.stack2.pop() def peek(self): if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) if not self.stack2: raise IndexError(\\"peek from empty queue\\") return self.stack2[-1] def is_empty(self): return not self.stack1 and not self.stack2 def size(self): return len(self.stack1) + len(self.stack2)"},{"question":"Given a list of integers `arr`, you need to write a function `longest_increasing_subsequence(arr: List[int]) -> int` that returns the length of the longest increasing subsequence in the list. An increasing subsequence is a subsequence where each element is greater than the preceding one. # Example ```python >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1 ``` # Constraints * The list `arr` will consist of up to 10^3 integers. * Each integer in `arr` will be between -10^6 and 10^6. # Requirements 1. Implement the function using a dynamic programming approach. 2. Optimize for both time and space complexity within reasonable limits for medium-sized inputs. 3. Handle edge cases such as: - An empty list. - Lists with one element. - Lists with all elements the same. # Performance Expectations * The solution should have an average time complexity of O(n log n). * Optimize space complexity to O(n), while maintaining correctness. --- This problem tests your understanding of dynamic programming and the ability to optimize for time and space complexity while handling varied input sizes and edge cases.","solution":"from typing import List import bisect def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in a given list of integers. if not arr: return 0 # The \'sub\' array keeps the smallest possible tail of all increasing subsequences of different lengths sub = [] for num in arr: pos = bisect.bisect_left(sub, num) if pos == len(sub): sub.append(num) else: sub[pos] = num return len(sub)"},{"question":"# URL Shortener In this task, you\'ll implement a simple URL shortener. Your goal is to develop a system that takes a long URL and converts it into a shorter, fixed-length URL. This mimics the functionality of services like bit.ly. The short URL should be a unique code for each long URL. # Function Signature ```python class URLShortener: def __init__(self): # Initialize your data structures pass def encode(self, long_url: str) -> str: # Convert a long URL to a short URL pass def decode(self, short_url: str) -> str: # Convert a short URL back to its original long URL pass ``` # Methods - **`__init__()`**: Constructor to initialize any necessary data structures. - **`encode(long_url: str) -> str`**: Takes a long URL and returns a short URL. It should generate a unique short URL for each long URL. - **`decode(short_url: str) -> str`**: Takes a short URL and returns the original long URL. If the short URL does not exist, return an empty string. # Constraints - The `long_url` and `short_url` will always be non-empty strings. - The `long_url` will be a valid URL. - The system should handle at least 10,000 unique URLs. # Example Usage ```python shortener = URLShortener() url = \\"https://www.example.com\\" short_url = shortener.encode(url) print(short_url) # This should print the short URL corresponding to \\"https://www.example.com\\" original_url = shortener.decode(short_url) print(original_url) # This should print \\"https://www.example.com\\" ``` # Notes - Design your encoding to ensure that the short URL is of fixed length, ideally 6-8 characters. - Ensure that the short URLs do not conflict with each other. - Consider using a combination of hash functions, base conversion, or random generators to create the short URL. - Do not use an existing URL shortener service\'s database; the implementation should be your own. # Hints - One approach could be to use a hash function on the `long_url` to generate a unique ID, then convert that ID to a different base (such as base62) for a shorter representation. - Another approach could be to use a sequential counter to assign IDs, which are then encoded into a short form.","solution":"import hashlib import string class URLShortener: def __init__(self): self.url_map = {} self.counter = 0 self.short_to_long = {} def _generate_short_url(self): # Use base62 encoding base = len(string.ascii_letters + string.digits) characters = string.ascii_letters + string.digits short_url = [] n = self.counter while n > 0: short_url.append(characters[n % base]) n = n // base short_url.reverse() return \'\'.join(short_url).rjust(6, \'0\') def encode(self, long_url: str) -> str: if long_url in self.url_map: return self.url_map[long_url] self.counter += 1 short_url = self._generate_short_url() self.url_map[long_url] = short_url self.short_to_long[short_url] = long_url return short_url def decode(self, short_url: str) -> str: return self.short_to_long.get(short_url, \\"\\")"},{"question":"When performing basic arithmetic operations in a programming environment, it is essential to handle potential overflow errors, especially in languages that do not inherently manage large integer values like some low-level programming languages. However, it can also be useful to simulate overflow behavior in such languages to understand and debug similar applications. In this question, you are required to create functions that simulate 32-bit integer overflow behavior in Python. Python, by default, handles large integers gracefully, but you will implement logic to simulate how a 32-bit signed integer behaves during arithmetic operations. # Task Implement the following functions to simulate 32-bit signed integer addition, subtraction, multiplication, and division in Python. A 32-bit signed integer can range from -2,147,483,648 to 2,147,483,647. Any result out of this range should simulate overflow by wrapping around within these bounds. Function Signature ```python def add_32bit(a: int, b: int) -> int: # Implement this function def sub_32bit(a: int, b: int) -> int: # Implement this function def mul_32bit(a: int, b: int) -> int: # Implement this function def div_32bit(a: int, b: int) -> int: # Implement this function ``` Input Format * Two integers `a` and `b`, where -2^31 ≤ a, b ≤ 2^31 - 1 Output Format * Each function should return an integer result limited within the bounds of a 32-bit signed integer range. Constraints * -2^31 ≤ a, b ≤ 2^31 - 1 * For division, assume b ≠ 0 # Example ```python print(add_32bit(2147483647, 1)) # Output: -2147483648 (Overflow behavior of max int + 1) print(sub_32bit(-2147483648, 1)) # Output: 2147483647 (Overflow behavior of min int - 1) print(mul_32bit(100000, 20000)) # Output: -1474836480 (Overflow within 32-bit integer bounds) print(div_32bit(2147483647, -1)) # Output: -2147483647 ``` # Notes * Ensure all operations strictly follow the 32-bit signed integer limits. * For division, the behavior should mirror integer division in standard 32-bit environments.","solution":"def add_32bit(a: int, b: int) -> int: result = a + b if result > 2**31 - 1: result -= 2**32 elif result < -2**31: result += 2**32 return result def sub_32bit(a: int, b: int) -> int: result = a - b if result > 2**31 - 1: result -= 2**32 elif result < -2**31: result += 2**32 return result def mul_32bit(a: int, b: int) -> int: result = a * b if result > 2**31 - 1: result %= 2**32 if result > 2**31 - 1: result -= 2**32 elif result < -2**31: result %= 2**32 if result < -2**31: result += 2**32 return result def div_32bit(a: int, b: int) -> int: result = int(a / b) if result > 2**31 - 1: result -= 2**32 elif result < -2**31: result += 2**32 return result"},{"question":"# Question: Manipulating LinkedList Data Structure You have been given the class `LinkedList` that represents a singly linked list. Each node in the linked list consists of an integer value and a reference to the next node. Your task is to implement three methods (`size`, `insert`, and `remove`) for this `LinkedList` class. Complete the class `LinkedList` with the following specifications: **Class:** ```python class LinkedList: def __init__(self): self.head = None def size(self) -> int: Calculate the number of nodes in the linked list. :return: the size of the linked list. pass def insert(self, data: int, position: int): Insert a new node with value `data` at the specified `position`. If `position` is greater than the length of the list, append the node at the end. :param data: the integer value to insert. :param position: the position (0-based index) to insert the new node. :raise: ValueError if position is negative. pass def remove(self, position: int) -> int: Remove the node at the specified `position` and return its value. If `position` is out of bounds, raise an `IndexError`. :param position: the position (0-based index) of the node to remove. :raise: IndexError if position is out of bounds. :return: the value of the removed node. pass ``` **Input:** * The class does not take any direct input. **Methods:** * `size`: Returns the number of nodes in the linked list. * `insert`: Adds a new node with the given value at the specified position. If the position is greater than the length of the list, the new node should be inserted at the end. * `remove`: Deletes the node at the specified position and returns its value. If the position is invalid (less than 0 or greater than the length of list minus one), it should raise an `IndexError`. **Node Class:** ```python class Node: def __init__(self, data: int): self.data = data self.next = None ``` **Constraints:** * The `data` of the nodes will be integers. * The positional indices provided in `insert` and `remove` will be non-negative integers. **Examples:** 1. To create a linked list and perform some operations: ```python ll = LinkedList() ll.insert(3, 0) ll.insert(5, 1) print(ll.size()) # Output: 2 print(ll.remove(1)) # Output: 5 print(ll.size()) # Output: 1 ll.insert(7, 2) print(ll.size()) # Output: 2 print(ll.remove(0)) # Output: 3 print(ll.size()) # Output: 1 ``` 2. If attempting to insert at a negative position: ```python ll = LinkedList() try: ll.insert(3, -1) # Should raise ValueError except ValueError as e: print(e) # Output: ValueError: Invalid position ``` 3. If attempting to remove from an invalid position: ```python ll = LinkedList() ll.insert(3, 0) try: ll.remove(2) # Should raise IndexError except IndexError as e: print(e) # Output: IndexError: Remove position out of range ``` Use the provided code snippet as a reference for your solution structure. Ensure your implementation maintains the same level of robustness in handling various edge cases. **Instructions:** 1. Implement the class `LinkedList` with given methods. 2. Include input validation within each method as described. 3. Ensure that operations maintain the integrity of the linked list structure.","solution":"class Node: def __init__(self, data: int): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def size(self) -> int: Calculate the number of nodes in the linked list. :return: the size of the linked list. count = 0 current = self.head while current: count += 1 current = current.next return count def insert(self, data: int, position: int): Insert a new node with value `data` at the specified `position`. If `position` is greater than the length of the list, append the node at the end. :param data: the integer value to insert. :param position: the position (0-based index) to insert the new node. :raise: ValueError if position is negative. if position < 0: raise ValueError(\\"Position must be non-negative\\") new_node = Node(data) if position == 0: new_node.next = self.head self.head = new_node else: current = self.head index = 0 while current is not None and index < position - 1: current = current.next index += 1 if current is None: raise IndexError(\\"Position out of range\\") new_node.next = current.next current.next = new_node def remove(self, position: int) -> int: Remove the node at the specified `position` and return its value. If `position` is out of bounds, raise an `IndexError`. :param position: the position (0-based index) of the node to remove. :raise: IndexError if position is out of bounds. :return: the value of the removed node. if position < 0 or (self.head is None and position >= 0): raise IndexError(\\"Position out of range\\") current = self.head if position == 0: self.head = current.next return current.data else: prev = None index = 0 while current is not None and index < position: prev = current current = current.next index += 1 if current is None: raise IndexError(\\"Position out of range\\") prev.next = current.next return current.data"},{"question":"# Problem Statement A warehouse management system needs to track pallet movements within a large warehouse. Each pallet has a unique ID and can move between different storage locations. You are tasked with implementing a function that computes the shortest path a pallet must take to move from its current location to a new location using the least number of intermediate moves. # Function Signature ```python def shortest_pallet_path(movement_log: list[tuple[int, int]], start: int, end: int) -> int: ``` # Input - `movement_log`: A list of tuples `[(a, b)]` where each tuple represents a move of a pallet from location `a` to location `b`. - `start`: An integer representing the starting location of the pallet. - `end`: An integer representing the target location where the pallet needs to be moved. # Output - An integer representing the minimum number of intermediate moves required to move the pallet from `start` to `end`. Return `-1` if it is not possible to move from the start to the end location. # Constraints - All locations are represented as non-negative integers. - The movement log will contain between 1 to 10^4 moves. - Locations will be represented by integers in the range [0, 10000]. - No move will use non-defined locations outside the given range. # Examples ```python # Example 1 movement_log = [(1, 2), (2, 3), (3, 4)] start = 1 end = 4 print(shortest_pallet_path(movement_log, start, end)) # Output: 3 # Example 2 movement_log = [(1, 2), (2, 3), (3, 4), (4, 5)] start = 1 end = 5 print(shortest_pallet_path(movement_log, start, end)) # Output: 4 # Example 3 movement_log = [(1, 2), (3, 4)] start = 1 end = 4 print(shortest_pallet_path(movement_log, start, end)) # Output: -1 ``` # Notes 1. Assume the pallet can only move sequentially according to the list of defined moves. 2. The function should handle large input sizes efficiently. 3. Some intermediate locations may not be reachable, in which case returning `-1` is appropriate. 4. Consider using graph traversal techniques like BFS to find the shortest path in terms of move counts.","solution":"def shortest_pallet_path(movement_log, start, end): from collections import deque, defaultdict if start == end: return 0 graph = defaultdict(list) for a, b in movement_log: graph[a].append(b) queue = deque([(start, 0)]) visited = set() while queue: current, moves = queue.popleft() if current == end: return moves if current not in visited: visited.add(current) for neighbor in graph[current]: if neighbor not in visited: queue.append((neighbor, moves + 1)) return -1"},{"question":"# Fibonacci Sequence Cumulative Sum Scenario: You are given a problem related to the Fibonacci sequence, which is a series of numbers where each number is the sum of the two preceding ones, typically starting with 0 and 1. The cumulative sum of the Fibonacci series up to a given index is the sum of all Fibonacci numbers from the start to that index. Task: Write a function `fibonacci_cumulative_sum` that calculates the cumulative sum of Fibonacci numbers up to a given index `n`. Function Signature: ```python def fibonacci_cumulative_sum(n: int) -> int: pass ``` Input: - `n` (int): The non-negative index up to which the cumulative sum of Fibonacci numbers is calculated. Output: - Returns the cumulative sum (int) of Fibonacci numbers up to the given index. Constraints: - `n` should be a non-negative integer (0 ≤ n ≤ 20). Performance Requirements: - The function should operate efficiently for the given constraint. Examples: ```python >>> fibonacci_cumulative_sum(0) 0 >>> fibonacci_cumulative_sum(1) 1 >>> fibonacci_cumulative_sum(5) 12 >>> fibonacci_cumulative_sum(10) 143 ``` Explanation: - The Fibonacci series up to index 5 is [0, 1, 1, 2, 3, 5]. The cumulative sum is 0 + 1 + 1 + 2 + 3 + 5 = 12. - The Fibonacci series up to index 10 is [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]. The cumulative sum is 0 + 1 + 1 + 2 + 3 + 5 + 8 + 13 + 21 + 34 + 55 = 143. Ensure your function validates the input and handles errors appropriately.","solution":"def fibonacci_cumulative_sum(n): Calculates the cumulative sum of Fibonacci numbers up to the given index n. :param n: The non-negative index up to which the cumulative sum of Fibonacci numbers is calculated. :return: The cumulative sum of Fibonacci numbers up to index n. if n < 0: raise ValueError(\\"Index must be a non-negative integer.\\") fib_nums = [0, 1] for i in range(2, n + 1): fib_nums.append(fib_nums[-1] + fib_nums[-2]) return sum(fib_nums[:n+1])"},{"question":"# Question As part of a new project, you are required to extract, analyze, and report sales data from a CSV file. Your task is to create a Python function that will parse this CSV data, compute the total sales for each product, and return the result as a dictionary. # Task Write a Python function, `calculate_total_sales`, that reads sales data from a CSV file and computes the total sales for each product. Requirements: - Your function should take one argument, `filename`, which is the path to the CSV file. - The CSV file contains three columns: `Date`, `Product`, and `Sales`. - You need to aggregate the sales for each product and return a dictionary with product names as keys and total sales as values. - You should handle any exceptions that might occur during file I/O operations gracefully. Input and Output: - Input: - The function will receive a single argument, `filename`, which is a string representing the path to the CSV file. - Output: - The function should return a dictionary where each key is a product name (string) and each value is the total sales (float) for that product. Example: Consider the following CSV file, `sales_data.csv`: ``` Date,Product,Sales 2023-01-01,Product A,100.0 2023-01-02,Product B,200.0 2023-01-03,Product A,150.0 2023-01-04,Product C,300.0 2023-01-05,Product B,250.0 ``` The function call `calculate_total_sales(\'sales_data.csv\')` should return: ```python { \\"Product A\\": 250.0, \\"Product B\\": 450.0, \\"Product C\\": 300.0 } ``` Constraints: - You can assume that the CSV file is well-formed (consistent number of columns, correct data types). - The `Sales` column contains float values. # Example Code: ```python import csv def calculate_total_sales(filename): sales_dict = {} try: with open(filename, \'r\') as file: reader = csv.DictReader(file) for row in reader: product = row[\'Product\'] sales = float(row[\'Sales\']) if product in sales_dict: sales_dict[product] += sales else: sales_dict[product] = sales except FileNotFoundError: print(f\\"Error: File \'{filename}\' not found.\\") except Exception as e: print(f\\"An error occurred: {e}\\") return sales_dict # Example usage # print(calculate_total_sales(\'sales_data.csv\')) ``` Create the function `calculate_total_sales` as specified above.","solution":"import csv def calculate_total_sales(filename): sales_dict = {} try: with open(filename, \'r\') as file: reader = csv.DictReader(file) for row in reader: product = row[\'Product\'] sales = float(row[\'Sales\']) if product in sales_dict: sales_dict[product] += sales else: sales_dict[product] = sales except FileNotFoundError: print(f\\"Error: File \'{filename}\' not found.\\") except Exception as e: print(f\\"An error occurred: {e}\\") return sales_dict"},{"question":"# Question: Matrix Multiplication Optimization with Block Matrix Multiplication Your task is to implement a more efficient version of matrix multiplication using the block matrix multiplication approach. This method can help take advantage of CPU cache, thereby optimizing performance, particularly for large matrices. Specifically: 1. **Implement the function `block_matrix_multiplication(A, B, block_size)`** that multiplies two matrices `A` and `B` using the block matrix multiplication method. 2. **Validate your implementation** by comparing it with the standard matrix multiplication method. **Function Signature**: ```python def block_matrix_multiplication(A: List[List[int]], B: List[List[int]], block_size: int) -> List[List[int]]: pass ``` **Input**: - `A`: A 2D list of integers representing matrix A. - `B`: A 2D list of integers representing matrix B. - `block_size`: An integer representing the size of the blocks. **Output**: - A 2D list of integers representing the resulting matrix after multiplying A and B using the block matrix multiplication. **Constraints**: - Ensure that the block size divides evenly into the dimensions of the matrices. - Handle edge cases where the matrices may not be perfectly divisible by the block size by adjusting the block sizes accordingly. - Matrices A and B will be compatible for multiplication in dimensions. Example: ```python def standard_matrix_multiplication(A, B): n = len(A) m = len(A[0]) p = len(B[0]) # Initializing the resultant matrix result = [[0] * p for _ in range(n)] # Performing standard matrix multiplication for i in range(n): for j in range(p): for k in range(m): result[i][j] += A[i][k] * B[k][j] return result A = [ [1, 2], [3, 4] ] B = [ [5, 6], [7, 8] ] # Test with smaller matrices and a block size of 1 result_block = block_matrix_multiplication(A, B, block_size=1) result_standard = standard_matrix_multiplication(A, B) print(result_block) # Should be [[19, 22], [43, 50]] print(result_standard) # Should be [[19, 22], [43, 50]] ``` **Notes**: - The block matrix multiplication should improve performance for large matrices. Test your function with larger matrices to observe the improvements. - Ensure you test edge cases and handle them gracefully. - Document any assumptions or special cases in your implementation to clarify your approach.","solution":"from typing import List def block_matrix_multiplication(A: List[List[int]], B: List[List[int]], block_size: int) -> List[List[int]]: n = len(A) m = len(A[0]) p = len(B[0]) # Initialize resultant matrix with zeros C = [[0 for _ in range(p)] for _ in range(n)] # Iterate over the blocks of the matrices for i0 in range(0, n, block_size): for j0 in range(0, p, block_size): for k0 in range(0, m, block_size): # Define the range of the current block for i in range(i0, min(i0 + block_size, n)): for j in range(j0, min(j0 + block_size, p)): for k in range(k0, min(k0 + block_size, m)): C[i][j] += A[i][k] * B[k][j] return C # Helper function for comparing with standard multiplication method def standard_matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: n = len(A) m = len(A[0]) p = len(B[0]) # Initializing the resultant matrix result = [[0] * p for _ in range(n)] # Performing standard matrix multiplication for i in range(n): for j in range(p): for k in range(m): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"# String Compressor You are given a function `string_compress` that takes a string `s` as input and compresses it using the counts of repeated characters. The function compresses the string such that consecutive repetitions of any character form a single group, and each group is represented by the character followed by the count of its repetitions. However, it’s crucial to handle the edge cases where the compressed string turns out to be of equal or greater length than the original string. In such cases, the function should return the original string itself. Your task is to implement the `string_compress` function that adheres to these specifications. # Specification Method Signature ```python def string_compress(s: str) -> str ``` Input * A string `s` (1 ≤ len(s) ≤ 100). Output * Returns the compressed version of the string if it is shorter than the original string. * Returns the original string if the compressed version is not shorter. Examples: ```python assert string_compress(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" # Compressed string is shorter assert string_compress(\\"abcdef\\") == \\"abcdef\\" # Compressed string is not shorter assert string_compress(\\"aabbccdd\\") == \\"aabbccdd\\" # Compressed string is of the same length ``` Constraints * The function should handle both uppercase and lowercase characters. * The function should be efficient in both time and space complexity. Example: Input: `\\"aabcccccaaa\\"` Output: `\\"a2b1c5a3\\"` In this example, the function compresses the string `\\"aabcccccaaa\\"` into `\\"a2b1c5a3\\"` because consecutive \\"a\\"s are counted as \\"a2\\", \\"b\\" as \\"b1\\", and \\"c\\"s as \\"c5\\". Finally, the compressed string `\\"a2b1c5a3\\"` is shorter than the original, thus it is returned. Input: `\\"aabbccdd\\"` Output: `\\"aabbccdd\\"` In this case, the compressed string would be `\\"a2b2c2d2\\"`, which is of the same length as the original string, so the function returns the original string itself. Use the provided method signature to implement the function `string_compress` and ensure the cases mentioned above are handled correctly.","solution":"def string_compress(s: str) -> str: compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_str = \'\'.join(compressed) return compressed_str if len(compressed_str) < len(s) else s"},{"question":"# Question: K-Nearest Neighbors Implementation In this task, you will implement a K-Nearest Neighbors (KNN) classifier from scratch. The KNN algorithm is a simple, yet powerful, classification method used in various applications, such as pattern recognition and data mining. Objectives: 1. Implement the following functions: 1. **euclidean_distance**: Calculates the Euclidean distance between two points in n-dimensional space. 2. **k_neighbors**: Finds the k-nearest neighbors for a given query point. 3. **predict**: Classifies a set of query points based on their k-nearest neighbors. 2. Your implementations should handle edge cases and raise appropriate errors for invalid inputs. Function Specifications: **Euclidean Distance** ```python def euclidean_distance(point1: np.ndarray, point2: np.ndarray) -> float: Parameters: - point1: A point in n-dimensional space of shape (n,) - point2: Another point in n-dimensional space of shape (n,) Returns: - float: Euclidean distance between point1 and point2 ``` **K-Neighbors** ```python def k_neighbors(X: np.ndarray, y: np.ndarray, query_point: np.ndarray, k: int) -> np.ndarray: Parameters: - X: Training data of shape (n_samples, n_features) - y: Training labels of shape (n_samples,) - query_point: A point in n-dimensional space to find neighbors for, of shape (n_features,) - k: Number of nearest neighbors to find Returns: - np.ndarray: Labels of the k-nearest neighbors ``` **Predict** ```python def predict(X: np.ndarray, y: np.ndarray, query_points: np.ndarray, k: int) -> np.ndarray: Parameters: - X: Training data of shape (n_samples, n_features) - y: Training labels of shape (n_samples,) - query_points: Points to classify, of shape (m_samples, n_features) - k: Number of nearest neighbors to consider Returns: - np.ndarray: Predicted labels for each query point of shape (m_samples,) ``` Constraints: 1. Ensure the input arrays (`X`, `y`, and `query_points`) are numpy arrays. 2. Handle mismatched lengths or shapes of input arrays using appropriate error messages. 3. Ensure values in `k` are positive integers and less than or equal to the number of training samples. Example Usage: ```python X_train = np.array([[1, 2], [2, 3], [3, 4], [4, 5]]) y_train = np.array([0, 1, 0, 1]) query_point = np.array([1.5, 2.5]) print(euclidean_distance(X_train[0], query_point)) # Output: ~0.707 k = 2 print(k_neighbors(X_train, y_train, query_point, k)) # Output: [0, 1] query_points = np.array([[1.5, 2.5], [3.5, 4.5]]) print(predict(X_train, y_train, query_points, k)) # Output: [0, 1] ``` You need to write these functions from scratch. You are encouraged to use vectorized numpy operations for efficient computation. Good luck!","solution":"import numpy as np from collections import Counter def euclidean_distance(point1: np.ndarray, point2: np.ndarray) -> float: Calculates the Euclidean distance between two points in n-dimensional space. if point1.shape != point2.shape: raise ValueError(\\"Both points must have the same dimension.\\") return np.sqrt(np.sum((point1 - point2) ** 2)) def k_neighbors(X: np.ndarray, y: np.ndarray, query_point: np.ndarray, k: int) -> np.ndarray: Finds the k-nearest neighbors for a given query point. if X.shape[0] != y.shape[0]: raise ValueError(\\"The number of samples in X and y should be the same.\\") if k <= 0 or k > X.shape[0]: raise ValueError(\\"k must be a positive integer less than or equal to the number of samples in X.\\") distances = np.array([euclidean_distance(query_point, x) for x in X]) nearest_indices = np.argsort(distances)[:k] return y[nearest_indices] def predict(X: np.ndarray, y: np.ndarray, query_points: np.ndarray, k: int) -> np.ndarray: Classifies a set of query points based on their k-nearest neighbors. predictions = [] for query_point in query_points: neighbors = k_neighbors(X, y, query_point, k) most_common = Counter(neighbors).most_common(1)[0][0] predictions.append(most_common) return np.array(predictions)"},{"question":"# Coding Assessment Question Scenario Suppose you are working on a social media application where you need to sort and manage user posts based on the number of likes they receive. To optimize database efficiency, you are required to implement a function that calculates a moving average of post likes over a specific window size. This will help in presenting a trend analysis of user engagement. Task Write a function named `moving_average` which takes a list of integers `likes` representing the number of likes for a series of posts and an integer `window_size`. Your function should return a new list of floats representing the moving average of the likes over the given window size. # Function Signature ```python def moving_average(likes: list[int], window_size: int) -> list[float]: ``` # Input * `likes` - A list of integers representing post likes (1 <= len(likes) <= 10^5, 0 <= likes[i] <= 10^5). * `window_size` - Integer that denotes the size of the moving window (1 <= window_size <= len(likes)). # Output * A list of floats, each element representing the moving average of the likes over the specified window size. The length of this list should be `len(likes) - window_size + 1`. # Constraints * The window size must be a positive integer and no larger than the length of the `likes` list. * If the window size is less than 1 or larger than the length of the `likes` list, raise the appropriate `ValueError`. # Example ```python >>> moving_average([10, 20, 30, 40, 50, 60, 70], 3) [20.0, 30.0, 40.0, 50.0, 60.0] >>> moving_average([8, 4, 10, 2, 6, 5, 1, 3, 7], 4) [6.0, 5.5, 5.75, 3.5, 3.75, 4.0] >>> moving_average([2, 4, 6, 8, 10], 5) [6.0] ``` Performance Requirements Your implementation should be efficient enough to handle the upper limits of the constraints effectively. Consider edge cases such as minimal or maximal window sizes. Additionally, ensure that invalid inputs are correctly handled by raising appropriate exceptions.","solution":"def moving_average(likes: list[int], window_size: int) -> list[float]: Calculate the moving average of post likes over a specific window size. Parameters: likes (list of int): A list of integers representing post likes. window_size (int): The size of the moving window. Returns: list of float: A list of floats representing the moving average. Raises: ValueError: If window_size is less than 1 or greater than the length of likes. if window_size < 1 or window_size > len(likes): raise ValueError(\\"window_size must be between 1 and the length of likes\\") averages = [] current_sum = sum(likes[:window_size]) averages.append(current_sum / window_size) for i in range(window_size, len(likes)): current_sum += likes[i] - likes[i - window_size] averages.append(current_sum / window_size) return averages"},{"question":"Problem Statement Given an array of integers, determine whether there exists a triplet (i, j, k) such that 0 ≤ i < j < k < n where arr[i] + arr[j] = arr[k]. Implement a function that returns `True` if such a triplet exists, and `False` otherwise. # Function Signature ```python def find_triplet(arr: List[int]) -> bool: :param arr: List of integers. :return: Boolean indicating if there exists a triplet (i, j, k) such that 0 ≤ i < j < k < len(arr) and arr[i] + arr[j] = arr[k] ``` # Input * `arr`: A list of integers. The length of the list will be between 1 and 1000 (inclusive). # Output * A boolean value indicating the presence of a triplet as required. # Constraints * The length of the array `arr` will be between 1 and 1000 (inclusive). * The values in `arr` will be between -10^5 and 10^5. # Example Usage ```python find_triplet([1, 2, 3, 4, 5]) # Returns: True # Explanation: arr[0] + arr[1] = arr[2] or 1 + 2 = 3 find_triplet([1, 1, 2, 5, 3]) # Returns: True # Explanation: arr[0] + arr[1] = arr[2] or 1 + 1 = 2 find_triplet([1, 3, 5, 7]) # Returns: False # Explanation: No such triplet (i, j, k) exists ``` # Hints * Nested loops can be used to check all possible triplets. * Consider using a hash map to store and quickly lookup sums of pairs as potential candidates for `arr[k]`.","solution":"def find_triplet(arr): Returns True if a triplet (i, j, k) exists such that 0 ≤ i < j < k < len(arr) and arr[i] + arr[j] = arr[k], otherwise False. # Create a set to keep track of all elements visited visited = set() # Iterate over the list from the end to the beginning for k in range(len(arr) - 1, -1, -1): for j in range(k): for i in range(j): if arr[i] + arr[j] == arr[k]: return True # Add current element to visited set after checking for triplet visited.add(arr[k]) return False"},{"question":"# Word Frequency Analysis Your task is to implement a function `word_frequency` that analyzes the frequency of words in a given string. The function should return a dictionary where the keys are distinct words, and the values represent their frequency in the string. Ignore case and punctuation to ensure words are counted correctly. Step-by-step Process: 1. **Normalize the String**: - Convert the entire string to lowercase. - Remove punctuation. 2. **Count Words**: - Split the string into words. - Count the frequency of each word. Input: - `text` (string): A sentence or paragraph. Output: - A dictionary where keys are words (lowercased with no punctuation) and values are their frequency. Constraints: - The input string may contain any printable ASCII character. - The function should handle large strings efficiently. Examples: ```python def word_frequency(text): pass # Example usage: print(word_frequency(\\"Hello, world! Hello?\\")) # Expected Output: {\'hello\': 2, \'world\': 1} print(word_frequency(\\"Good morning! Have a good, good day.\\")) # Expected Output: {\'good\': 3, \'morning\': 1, \'have\': 1, \'a\': 1, \'day\': 1} ``` **Hint**: Consider using Python\'s `collections.Counter` to help with counting words after they have been normalized. This question integrates seamlessly with an existing set of coding assessments by exploring string manipulation, regular expressions, and usage of Python\'s collections module, which are common concepts in programming assessments.","solution":"import re from collections import Counter def word_frequency(text): Analyze the frequency of words in a given string. Args: text (str): A sentence or paragraph. Returns: dict: A dictionary where keys are words (lowercased with no punctuation) and values are their frequency. # Normalize the string: convert to lowercase and remove punctuation. text = text.lower() text = re.sub(r\'[^ws]\', \'\', text) # remove punctuation using regex # Split the string into words words = text.split() # Count the frequency of each word word_counts = Counter(words) return dict(word_counts)"},{"question":"# File Processing and Data Transformation You are in charge of developing a function that processes log files generated by a server. Each log file contains records of user transactions in a specific format. Your task is to process these log files to extract valuable information and transform the data into a more usable format. # Objective Write a function `process_log_files(directory_path: str) -> dict` that reads all log files from a given directory, processes the transaction data, and returns a dictionary with summarized insights. # Input * `directory_path` (str): A string representing the path to the directory containing the log files. # Output * `summary` (dict): A dictionary containing the following key insights: - `total_transactions` (int): The total number of transactions recorded in all log files. - `total_amount` (float): The total amount of money processed in all transactions. - `average_transaction_amount` (float): The average amount of money per transaction. - `highest_transaction` (dict): A dictionary with details of the transaction with the highest amount, including `user_id`, `amount`, and `timestamp`. # Constraints * The log files are in plain text format, with each line representing a transaction in the format: `user_id,timestamp,amount` (e.g., `12345,2023-10-15T14:00:00Z,100.50`). * You need to handle edge cases such as missing or malformed data gracefully. * Ensure that the solution is efficient in terms of time and space complexity. * If a log file is empty or contains only malformed data, it should not affect the output. # Example ```python def process_log_files(directory_path: str) -> dict: # Your implementation here pass # Example usage: summary = process_log_files(\\"/path/to/log/files\\") print(summary) # Output: # { # \\"total_transactions\\": 500, # \\"total_amount\\": 125000.0, # \\"average_transaction_amount\\": 250.0, # \\"highest_transaction\\": { # \\"user_id\\": \\"78901\\", # \\"amount\\": 5000.0, # \\"timestamp\\": \\"2023-10-15T10:00:00Z\\" # } # } ``` Ensure your implementation follows the guidelines provided, handles edge cases, and efficiently processes the data.","solution":"import os def process_log_files(directory_path: str) -> dict: total_transactions = 0 total_amount = 0.0 highest_transaction = {\\"user_id\\": \\"\\", \\"amount\\": 0.0, \\"timestamp\\": \\"\\"} if not os.path.exists(directory_path) or not os.path.isdir(directory_path): raise ValueError(\\"Invalid directory path\\") for filename in os.listdir(directory_path): if not filename.endswith(\\".log\\"): continue with open(os.path.join(directory_path, filename), \'r\') as file: for line in file: try: user_id, timestamp, amount = line.strip().split(\',\') amount = float(amount) # Update total transactions and total amount total_transactions += 1 total_amount += amount # Check for highest transaction if amount > highest_transaction[\\"amount\\"]: highest_transaction = {\\"user_id\\": user_id, \\"amount\\": amount, \\"timestamp\\": timestamp} except Exception as e: # Ignoring malformed lines pass # Avoid division by zero average_transaction_amount = total_amount / total_transactions if total_transactions > 0 else 0.0 return { \\"total_transactions\\": total_transactions, \\"total_amount\\": total_amount, \\"average_transaction_amount\\": average_transaction_amount, \\"highest_transaction\\": highest_transaction, }"},{"question":"# Question You have been provided with an implementation of a Stack that supports standard operations such as push, pop, and top. Extend this implementation by adding a new method that returns the smallest element in the Stack at any given point in constant time. Implement the following function: ```python class Stack: ... def get_min(self) -> int: Return the smallest element in the Stack in constant time. :return: the smallest element in the Stack ``` Constraints: * The Stack should support a wide range of input sizes. * All stack operations, including `get_min`, must be performed in constant time. * The stack contains integer values only. Input: * Stack of integers. Output: * The minimum integer in the Stack. Example: Given the following operations on the Stack: ```python s = Stack() s.push(4) s.push(2) s.push(8) s.push(1) s.push(3) print(s.get_min()) # Output: 1 s.pop() s.pop() print(s.get_min()) # Output: 2 s.pop() print(s.get_min()) # Output: 2 s.pop() print(s.get_min()) # Output: 4 ```","solution":"class Stack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, value: int): self.stack.append(value) # Update the min stack if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self) -> int: if not self.stack: raise IndexError(\\"pop from empty stack\\") value = self.stack.pop() if value == self.min_stack[-1]: self.min_stack.pop() return value def top(self) -> int: if not self.stack: raise IndexError(\\"top from empty stack\\") return self.stack[-1] def get_min(self) -> int: if not self.min_stack: raise IndexError(\\"get_min from empty stack\\") return self.min_stack[-1]"},{"question":"# Problem Statement As a software engineer, you are tasked with developing a functionality for an e-commerce platform to manage the coupon distribution for a promotional event. The system needs to process a list of purchased items and calculate the total discount provided by the coupons applied to the items in the cart. Each item is represented by a tuple with the following structure: `(item_id, price)`. The coupon is represented by a dictionary with the item_id as the key and the discount value as the value. Given a list of items and a dictionary of coupons, your task is to calculate the total discount that will be applied to the cart. The coupon discount should not exceed the price of the item, meaning the discount for an item cannot reduce its price below zero. # Task Write a function `calculate_total_discount` that takes a list of tuples representing the items in the cart and a dictionary representing the coupons and returns the total discount amount applied to the cart. # Function Signature ```python def calculate_total_discount(items: List[Tuple[int, float]], coupons: Dict[int, float]) -> float: ``` # Input - `items` (1 ≤ len(items) ≤ 100): A list of tuples where each tuple contains: - `item_id` (int): The unique identifier for the item. - `price` (float): The price of the item. - `coupons` (0 ≤ len(coupons) ≤ 100): A dictionary where the keys are: - `item_id` (int): The unique identifier for the item. - `discount` (float): The discount amount for the item. # Output - Returns a float representing the total discount applied to the items in the cart. # Example ```python items = [(1, 100.0), (2, 200.0), (3, 150.0)] coupons = {1: 50.0, 2: 250.0, 3: 100.0} calculate_total_discount(items, coupons) # Output: 200.0 ``` # Constraints & Considerations - The discount for each item should not exceed its price. - If an item does not have a corresponding coupon, no discount is applied to that item. - Ensure the function efficiently calculates the total discount and handles edge cases where applicable. - The prices and discounts are given as floats and should be compared with appropriate precision. # Scenario Imagine you are building a shopping cart system for an e-commerce website. During a special promotion, the website issues coupons for discounts on selected items. The management needs to know how much discount will be applied when items are added to the cart and this function will be called to calculate the total discount amount efficiently and accurately for the cart\'s summary. Use the provided scenario to implement your solution similarly, ensuring correctness and efficiency.","solution":"from typing import List, Tuple, Dict def calculate_total_discount(items: List[Tuple[int, float]], coupons: Dict[int, float]) -> float: total_discount = 0.0 for item_id, price in items: if item_id in coupons: discount = min(price, coupons[item_id]) total_discount += discount return total_discount"},{"question":"# Optimal Routing in Delivery Network Context: You are working with a delivery service that operates in a city with several delivery stations. Each station is connected to other stations via roads with specific travel times. Given the constraints of travel times and the need to visit every station, you must determine the shortest possible route that starts at a given station, visits every other station exactly once, and returns to the starting station. Problem Statement: Given: - An integer `n` representing the number of stations. - A 2D list `travel_times` where `travel_times[i][j]` is the travel time between station `i` and station `j`. If `i == j`, `travel_times[i][j]` is `0`. Write a function `shortest_route(n: int, travel_times: List[List[int]]) -> int` that returns the minimum travel time required to start at station 0, visit every other station exactly once, and return to station 0. Function Signature: ```python def shortest_route(n: int, travel_times: List[List[int]]) -> int: ``` Input: - `n`: An integer representing the number of delivery stations. - `travel_times`: A 2D list of integers where each element `travel_times[i][j]` indicates the travel time between station `i` and station `j`. Output: - An integer representing the minimum travel time required to visit all stations starting and ending at station 0. Constraints: - 2 ≤ n ≤ 12 - 0 ≤ travel_times[i][j] ≤ 100 - `travel_times[i][j]` is symmetric: `travel_times[i][j] == travel_times[j][i]` - `0 <= i, j < n` Example: Input: ```python n = 4 travel_times = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] ``` Output: ```python 80 ``` Explanation: The optimal route to visit all stations starting and ending at station 0 in this example is 0 -> 1 -> 3 -> 2 -> 0, with a minimum travel time of 80. Consider implementing this algorithm using dynamic programming along with bitmasking to efficiently solve the Traveling Salesman Problem (TSP) for the given constraints. Ensure your solution efficiently handles the range of input scenarios and edge cases.","solution":"def shortest_route(n, travel_times): from functools import lru_cache @lru_cache(None) def dp(mask, i): if mask == (1 << n) - 1: return travel_times[i][0] res = float(\'inf\') for j in range(n): if not mask & (1 << j): res = min(res, travel_times[i][j] + dp(mask | (1 << j), j)) return res return dp(1, 0)"},{"question":"# Context In data structures and algorithms, a common task is manipulating and analyzing data in a sequence that allows both efficient access and modification. One such task involves rotating elements in a sequence by a given number of positions. # Problem Statement You are required to implement a function that rotates the elements of an array to the right by `k` positions. In a single rotation, the last element of the array moves to the first position, and all other elements move one position to the right. # Task Write a function `rotate_array` that efficiently rotates an array to the right by `k` positions. # Function Signature ```python def rotate_array(arr: List[int], k: int) -> List[int]: pass ``` # Input * `arr`: A list of integers (0 ≤ length of arr ≤ 10^5). * `k`: An integer representing the number of positions to rotate the array (0 ≤ k ≤ 10^5). # Output * A list of integers representing the rotated array. # Example Usage ```python # Example Usage arr = [1, 2, 3, 4, 5, 6, 7] k = 3 print(rotate_array(arr, k)) # Should output [5, 6, 7, 1, 2, 3, 4] ``` Example 2 ```python # Example Usage arr = [1, 2, 3] k = 1 print(rotate_array(arr, k)) # Should output [3, 1, 2] ``` # Constraints 1. You should handle cases where `k` is greater than the length of the array. 2. The function should have a time complexity of `O(n)`, where `n` is the length of the array. 3. The function should use O(1) space complexity, excluding the input and output storage. # Notes * If `k` is 0, the array should remain unchanged. * If the array is empty, the result should be an empty array as well.","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the elements of an array to the right by k positions. Parameters: arr (List[int]): The array to be rotated. k (int): The number of positions to rotate the array. Returns: List[int]: The rotated array. n = len(arr) if n == 0: return arr k = k % n # In case k is larger than the size of the array return arr[-k:] + arr[:-k] # Example Usage arr = [1, 2, 3, 4, 5, 6, 7] k = 3 print(rotate_array(arr, k)) # Should output [5, 6, 7, 1, 2, 3, 4] arr = [1, 2, 3] k = 1 print(rotate_array(arr, k)) # Should output [3, 1, 2]"},{"question":"# Problem Statement You are tasked with creating a function to compute the Traveling Salesperson Problem (TSP) for a given set of cities and the distance between each pair of cities. The goal is to find the shortest possible route that visits each city exactly once and returns to the origin city. **Input Format:** - An integer `n` representing the number of cities (2 ≤ `n` ≤ 10). - A 2D list `distances` of size `n x n` where `distances[i][j]` represents the distance between city `i` and city `j`. **Output Format:** - An integer representing the minimum distance required to complete the TSP circuit. # Function Signature ```python def tsp(n: int, distances: List[List[int]]) -> int: pass ``` # Constraints and Points to Consider: - The problem size is small (with `n` up to 10), so an exhaustive search or dynamic programming approach like Held-Karp algorithm is feasible. - The distance between any two cities is a positive integer. - The distance from a city to itself is 0 (i.e., `distances[i][i] = 0` for all `i`). # Example ```python n = 4 distances = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] print(tsp(n, distances)) # Expected output: 80 (The minimum route that visits all cities and returns to the origin) ``` # Notes - Utilize a dynamic programming approach with bit masking to solve the TSP problem efficiently. - Consider memoization techniques to store already computed distances for subsets of cities. - Implementing a recursive function with caching could help in reducing redundant computations and achieving optimal performance. By creating a function to solve the Traveling Salesperson Problem efficiently for a small number of cities, you ensure your solution is both robust and performant within the given constraints.","solution":"from typing import List import functools def tsp(n: int, distances: List[List[int]]) -> int: @functools.lru_cache(None) def visit(city, visited): if visited == (1 << n) - 1: return distances[city][0] min_dist = float(\'inf\') for next_city in range(n): if not visited & (1 << next_city): dist = distances[city][next_city] + visit(next_city, visited | (1 << next_city)) min_dist = min(min_dist, dist) return min_dist return visit(0, 1 << 0)"},{"question":"# Maximal Continuous Subarray Sum Given a list of integers `numbers`, write a function `max_continuous_subarray_sum` that returns the sum of the largest contiguous subarray. The function should handle both positive and negative numbers. # Function Signature ```python def max_continuous_subarray_sum(numbers: list[int]) -> int: pass ``` # Input * `numbers` (list[int]): A list of integers. # Output * Return an integer representing the sum of the largest contiguous subarray. # Constraints * You can assume the list can contain both positive and negative integers. * The size of the array can be large (up to 10^6 elements). # Examples ```python assert max_continuous_subarray_sum([1, -2, 3, 4, -5, 8]) == 10 assert max_continuous_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 assert max_continuous_subarray_sum([1, 2, 3, 4]) == 10 assert max_continuous_subarray_sum([-1, -2, -3, -4]) == -1 assert max_continuous_subarray_sum([5, -9, 6, -2, 3]) == 7 ``` # Constraints * The function should efficiently handle large input sizes and edge cases such as: * Empty list * Extreme integer values (both positive and negative) * Large datasets without compromising performance. # Notes * The solution should leverage efficient algorithms like Kadane\'s algorithm to ensure optimal performance.","solution":"def max_continuous_subarray_sum(numbers: list[int]) -> int: Returns the sum of the largest contiguous subarray. Args: numbers (list[int]): List of integers. Returns: int: Sum of the largest contiguous subarray. if not numbers: return 0 max_sum = current_sum = numbers[0] for num in numbers[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Sorting a List of Tuples by Custom Order Problem Statement You are given a list of tuples, where each tuple contains three integers: (a, b, c). Your task is to sort this list based on the following order: 1. Primarily, sort tuples by the first element `a` in ascending order. 2. If two tuples have the same first element `a`, sort those tuples by the second element `b` in descending order. 3. Finally, if two tuples have the same first and second elements (i.e., the same `a` and `b`), sort those tuples by the third element `c` in ascending order. Requirements Implement the following function: ```python def custom_sort(tuples: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]: Sort a list of tuples by the specified custom order. Args: tuples (List[Tuple[int, int, int]]): A list of tuples to be sorted. Returns: List[Tuple[int, int, int]]: The sorted list of tuples. Example: >>> custom_sort([(1, 2, 3), (1, 1, 3), (2, 2, 2), (1, 2, 2)]) [(1, 2, 2), (1, 2, 3), (1, 1, 3), (2, 2, 2)] >>> custom_sort([(0, 2, 3), (0, 2, 1), (1, 1, 1), (0, 1, 1)]) [(0, 2, 1), (0, 2, 3), (0, 1, 1), (1, 1, 1)] ``` Your implementation must: - Sort the list of tuples according to the described order. - Use Python\'s built-in sorting functionalities to ensure efficiency. Input and Output - **Input**: A list of tuples where each tuple consists of three integers (a, b, c). - **Output**: A list of tuples, sorted according to the specified order. Constraints - The input list will contain no more than 10^4 tuples. - Each tuple’s elements are integers in the range [-10^6, 10^6]. Performance Requirements - Optimize your approach to handle the upper limits efficiently. - Ensure the implementation is robust and can handle edge cases, such as lists with only one tuple or no tuples at all. Example ```python >>> custom_sort([(1, 2, 3), (1, 1, 3), (2, 2, 2), (1, 2, 2)]) [(1, 2, 2), (1, 2, 3), (1, 1, 3), (2, 2, 2)] >>> custom_sort([(0, 2, 3), (0, 2, 1), (1, 1, 1), (0, 1, 1)]) [(0, 2, 1), (0, 2, 3), (0, 1, 1), (1, 1, 1)] ``` # Note - Carefully consider the required sort order and ensure the implementation meets the specified criteria. - You may use Python\'s `sorted` function with a custom key to achieve the desired order succinctly.","solution":"from typing import List, Tuple def custom_sort(tuples: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]: Sort a list of tuples by the specified custom order. Args: tuples (List[Tuple[int, int, int]]): A list of tuples to be sorted. Returns: List[Tuple[int, int, int]]: The sorted list of tuples. return sorted(tuples, key=lambda x: (x[0], -x[1], x[2]))"},{"question":"# Coding Assessment Question: **Scenario**: Jamie, a software engineer, is working on a recommendation system for an online bookstore. To ensure the recommendations are personalized, the system maintains a user interaction log, where each user’s actions (clicks, views, purchases) are recorded. Jamie needs to analyze this log to identify the most popular book for each category. **Task**: Implement a function that processes the user interaction log and finds the most popular book in each category based on the number of interactions. **Function Signature**: ```python def most_popular_books(interaction_log: List[Tuple[str, str]]) -> Dict[str, str]: Args: interaction_log: A list of tuples where each tuple consists of: - A string representing the book title. - A string representing the book category. Returns: A dictionary where: - The key is a string representing the book category. - The value is a string representing the most popular book title in that category. pass ``` **Input**: 1. `interaction_log`: A list of tuples, where each tuple contains: - A string representing the book title. - A string representing the book category. **Output**: * A dictionary where: * The key is a string representing the book category. * The value is a string representing the most popular book title in that category. **Constraints**: * The length of `interaction_log` will not exceed 10^5. * Each book title and category is a non-empty string with a maximum length of 100 characters. * In case of a tie (multiple books with the same highest interaction count), return the book that appears first in the log. **Example:** ``` interaction_log = [ (\\"Book_1\\", \\"Fiction\\"), (\\"Book_2\\", \\"Fiction\\"), (\\"Book_1\\", \\"Fiction\\"), (\\"Book_3\\", \\"Non-Fiction\\"), (\\"Book_4\\", \\"Non-Fiction\\"), (\\"Book_4\\", \\"Non-Fiction\\"), (\\"Book_5\\", \\"Comics\\") ] ``` **Example Call:** ```python result = most_popular_books(interaction_log) print(result) # Expected output: {\'Fiction\': \'Book_1\', \'Non-Fiction\': \'Book_4\', \'Comics\': \'Book_5\'} ``` **Note**: The function should efficiently handle large logs and correctly account for ties based on the order of appearance.","solution":"from collections import defaultdict, Counter from typing import List, Tuple, Dict def most_popular_books(interaction_log: List[Tuple[str, str]]) -> Dict[str, str]: category_counter = defaultdict(Counter) for book, category in interaction_log: category_counter[category][book] += 1 most_popular = {} for category, books_counter in category_counter.items(): most_popular[category] = books_counter.most_common(1)[0][0] return most_popular"},{"question":"# Huffman Encoding Huffman coding is a method of lossless data compression based on the frequency of occurrence of each data item. Your task is to implement the Huffman encoding algorithm to compress a given text file. Input Format: 1. A path to the input text file containing the text to be compressed. 2. A path to the output file where the compressed data along with the Huffman tree (used for decoding) needs to be saved. Output Format: - The output should be a binary file created at the specified path containing the compressed data and the corresponding Huffman tree. Constraints: - Implement the encoding by creating a frequency table, generating the Huffman tree, and then creating the binary encoding for the text. - Serialize the Huffman tree and the encoded text into a binary format in the output file. - Ensure to handle large files efficiently, up to a few megabytes. Performance Requirements: - Your encoding function should be efficient and handle files up to several megabytes without significant performance degradation. Example Assume the input text file `input.txt` contains the following text: ``` this is an example for huffman encoding ``` You should implement the compression such that invoking your function: ```python compress(\\"input.txt\\", \\"compressed_output.huff\\") ``` Produces a `compressed_output.huff` file containing the Huffman tree and the compressed data. **Function Signature:** ```python def compress(src_path: str, dest_path: str) -> None: pass ```","solution":"import heapq import os import pickle class HuffmanNode: def __init__(self, char, freq): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq def build_frequency_table(text): frequency = {} for char in text: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency def build_huffman_tree(frequency): heap = [HuffmanNode(char, freq) for char, freq in frequency.items()] heapq.heapify(heap) while len(heap) > 1: node1 = heapq.heappop(heap) node2 = heapq.heappop(heap) merged = HuffmanNode(None, node1.freq + node2.freq) merged.left = node1 merged.right = node2 heapq.heappush(heap, merged) return heap[0] def build_huffman_codes(tree): codes = {} def traverse(node, current_code): if node is None: return if node.char is not None: codes[node.char] = current_code traverse(node.left, current_code + \\"0\\") traverse(node.right, current_code + \\"1\\") traverse(tree, \\"\\") return codes def compress(src_path, dest_path): with open(src_path, \'r\') as file: text = file.read() frequency = build_frequency_table(text) huffman_tree = build_huffman_tree(frequency) huffman_codes = build_huffman_codes(huffman_tree) encoded_text = \'\'.join(huffman_codes[char] for char in text) extra_padding = 8 - len(encoded_text) % 8 for _ in range(extra_padding): encoded_text += \\"0\\" padded_info = \\"{0:08b}\\".format(extra_padding) encoded_text = padded_info + encoded_text b = bytearray() for i in range(0, len(encoded_text), 8): byte = encoded_text[i:i+8] b.append(int(byte, 2)) with open(dest_path, \'wb\') as output: pickle.dump((huffman_tree, b), output)"},{"question":"# Coding Task In many applications, we need to determine whether a given string (potentially containing a sequence of sub-strings) represents a valid nested structure. A common example of this is ensuring a string of parenthesis is balanced. You are required to implement a function `is_valid_parentheses` that verifies if the given string of parentheses is valid. A valid string must meet the following criteria: 1. Every opening parenthesis \'(\' has a corresponding closing parenthesis \')\'. 2. Parentheses must close in the correct order. Here’s the detailed specification: Function Signature ```python def is_valid_parentheses(s: str) -> bool: ``` # Input * `s` - A string containing only the characters \'(\' and \')\' # Output * A boolean value indicating whether the string is a valid sequence of balanced parentheses. # Constraints * The length of the string `s` will not exceed 1000 characters. # Examples ```python is_valid_parentheses(\\"()\\") # Output: True is_valid_parentheses(\\")(\\") # Output: False is_valid_parentheses(\\"((()))\\") # Output: True is_valid_parentheses(\\"(()))(\\") # Output: False ``` # Explanation 1. The string `\\"()\\"` is valid because each opening parenthesis has a matching closing parenthesis. 2. The string `\\")(\\"` is not valid because the closing parenthesis appears before the opening. 3. The string `\\"((()))\\"` is valid because all parentheses are correctly nested and matched. 4. The string `\\"(()))(\\"` is not valid because there are more closing parentheses than opening ones and the current closing parenthesis does not match the correct opening parenthesis. # Performance Requirements * The solution should handle the edge cases such as an empty string, strings with only one type of parenthesis, and maximal length strings efficiently. Implement the function `is_valid_parentheses` as per the above specifications.","solution":"def is_valid_parentheses(s: str) -> bool: Verifies if the given string of parentheses is valid. Parameters: s (str): The input string containing only \'(\' and \')\' Returns: bool: True if the string is a valid sequence of balanced parentheses, False otherwise. stack = [] for char in s: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"# Fibonacci Sequence Summation You are tasked with implementing a function that calculates the sum of the first ( n ) numbers in the Fibonacci sequence. The Fibonacci sequence is defined as follows: - ( F_0 = 0 ) - ( F_1 = 1 ) - ( F_{n} = F_{n-1} + F_{n-2} ) for ( n geq 2 ) Your task is to compute the sum ( S ) of the first ( n ) Fibonacci numbers, where ( S = F_0 + F_1 + cdots + F_{n-1} ). # Input and Output Format: * You will implement a function `fibonacci_sum` which takes one argument: - `n` : an integer, representing the number of terms to include in the summation. * The function should return an integer representing the sum of the first ( n ) Fibonacci numbers. # Constraints: - ( 0 leq n leq 30 ) # Example: ```python >>> fibonacci_sum(5) 7 >>> fibonacci_sum(10) 88 >>> fibonacci_sum(0) 0 ``` # Error Handling: - Raise a `ValueError` if: - The input `n` is negative or greater than 30. Implement the `fibonacci_sum` function according to the specification provided above.","solution":"def fibonacci_sum(n): Returns the sum of the first n Fibonacci numbers. :param n: Number of Fibonacci terms to sum, must be in the range 0 <= n <= 30. :return: Sum of the first n Fibonacci numbers. :raises ValueError: If n is not within the range 0 <= n <= 30. if not (0 <= n <= 30): raise ValueError(\\"n must be between 0 and 30 (inclusive).\\") if n == 0: return 0 elif n == 1: return 0 # F_0 = 0, sum is 0 fib = [0, 1] # Initial two Fibonacci numbers sum_fib = 1 # Sum of first two Fibonacci numbers (F_0 + F_1 = 0 + 1) for i in range(2, n): next_fib = fib[i-1] + fib[i-2] fib.append(next_fib) sum_fib += next_fib return sum_fib"},{"question":"# Context Building on your ability to manipulate data structures and implement efficient algorithms, we would like you to work with strings and hashmaps. Your task is to determine if two strings are anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, using all the original letters exactly once. # Question Implement a function `are_anagrams(s1: str, s2: str) -> bool` in Python. This function should return `True` if the two given strings are anagrams of each other and `False` otherwise. Ensure to handle edge cases and optimize for performance. Input Format - Two strings, `s1` and `s2`. Output Format - A boolean `True` if `s1` and `s2` are anagrams, `False` otherwise. Example ```python >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"hello\\", \\"billion\\") False >>> are_anagrams(\\"\\", \\"\\") True >>> are_anagrams(\\"a\\", \\"a\\") True >>> are_anagrams(\\"a\\", \\"ab\\") False ``` Constraints - Both `s1` and `s2` are alphanumeric strings and can include both uppercase and lowercase letters. - The comparison should be case-insensitive (e.g., \\"Listen\\" and \\"Silent\\" are considered anagrams). - The function should be able to handle strings of length up to 10^5 efficiently. # Performance Requirements - The solution should aim for an optimal time complexity, ideally O(n) where n is the length of the strings. - The space complexity should be O(1) additional space beyond the input storage requirement, utilizing fixed-size character counting.","solution":"def are_anagrams(s1: str, s2: str) -> bool: Returns True if the two given strings are anagrams of each other, False otherwise. The comparison is case-insensitive. if len(s1) != len(s2): return False # Convert both strings to lower case to handle case insensitivity s1 = s1.lower() s2 = s2.lower() # Create a hashmap for counting characters char_count = [0] * 26 for i in range(len(s1)): char_count[ord(s1[i]) - ord(\'a\')] += 1 char_count[ord(s2[i]) - ord(\'a\')] -= 1 # Check if all counts are zero for count in char_count: if count != 0: return False return True"},{"question":"# Problem Statement You are tasked with implementing a function that sorts an array of integers using a custom comparator. The custom comparator prioritizes numbers in the following order: 1. Even numbers should appear before odd numbers. 2. Within the even numbers, sort them in descending order. 3. Within the odd numbers, sort them in ascending order. Implement the sorting function to arrange the integers as per these rules. Function Signature ```python def custom_sort(arr: List[int]) -> List[int]: ``` # Input - `arr`: A list of integers to be sorted. # Output - A list of integers sorted according to the custom comparator rules described above. # Constraints - The length of `arr` is between 1 and 10^4. - Each integer in `arr` is between -10^4 and 10^4. # Example ```python # Example 1: arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] sorted_arr = custom_sort(arr) assert sorted_arr == [10, 8, 6, 4, 2, 1, 3, 5, 7, 9] # Example 2: arr = [11, 3, -1, 6, 2, -5, -8, 0] sorted_arr = custom_sort(arr) assert sorted_arr == [6, 2, 0, -8, -5, -1, 3, 11] # Example 3: arr = [5, 2, 8, 3, 6, 7, 1] sorted_arr = custom_sort(arr) assert sorted_arr == [8, 6, 2, 1, 3, 5, 7] ``` # Notes 1. Ensure that all integers are considered, including negative integers. 2. Since the list can be quite large (up to 10^4 elements), aim for a solution that efficiently sorts the array respecting the custom comparator rules. 3. Consider edge cases such as: - The list consisting of entirely even or odd numbers. - The list having a mixture of negative and positive integers. By adhering to this problem statement, you would create a question that matches the style, complexity, and domain scope of the provided examples, ensuring it appears seamlessly integrated into the original set of questions.","solution":"from typing import List def custom_sort(arr: List[int]) -> List[int]: def custom_comparator(x): if x % 2 == 0: return (0, -x) else: return (1, x) arr.sort(key=custom_comparator) return arr"},{"question":"# Scenario: You have been given a string containing a mix of alphabetical characters and digits. Your task is to implement a function that sorts the characters such that all alphabetical characters appear before the digits, and within the alphabetical and numeric groups, characters should be sorted in ascending order. # Requirements: 1. Implement a function `sort_string` that takes a string of alphanumeric characters as input and returns a string with sorted characters as specified. 2. Alphabetical characters should be sorted lexicographically and should come before digits in the result. 3. Digits should also be sorted in ascending order. # Function Signature: ```python def sort_string(s: str) -> str: ``` # Input: - `s`: A string `s` consisting of alphanumeric characters where `1 <= len(s) <= 10^4`. # Output: - A string where all alphabetical characters come before the digits and both sets are sorted in ascending order. # Constraints: - The input string will only contain characters from the set a-z, A-Z, and 0-9. - The output should maintain the relative order as described. # Example: ```python assert sort_string(\\"a1b2c3\\") == \\"abc123\\" assert sort_string(\\"Zf3c2A1\\") == \\"AZcf123\\" assert sort_string(\\"4Bacs5d1\\") == \\"Bacds145\\" assert sort_string(\\"123abcDEF\\") == \\"DEFabc123\\" assert sort_string(\\"z9y8x7\\") == \\"xyz789\\" ``` # Hints: - Consider using Python\'s built-in string methods and sorting capabilities. - You may find it useful to separate the characters into two groups first (letters and digits), and then sort each group before concatenating them together. # Performance Requirements: - The sorting operation should be efficient, meeting the constraints for the input size.","solution":"def sort_string(s: str) -> str: Sorts the input string such that all alphabetical characters appear before digits, and within each group, characters are sorted in ascending order. # Separate the characters into letters and digits letters = sorted([char for char in s if char.isalpha()]) digits = sorted([char for char in s if char.isdigit()]) # Concatenate the sorted letters and digits and return the result return \'\'.join(letters + digits)"},{"question":"# Coding Assessment Question Context: You are tasked with simulating the behavior of a food ordering system in a restaurant. The system keeps track of orders and processes them in the order they were placed. Task: 1. Implement a class `OrderQueue` that will simulate a queue system for orders. 2. The class should support adding new orders, processing orders, and checking the next order to be processed. Requirements: 1. **Class `OrderQueue`** - Method `add_order(order: str) -> None` - Add a new order (string) to the queue. - Method `process_order() -> str` - Remove the order that is next in line and return it. If the queue is empty, return `None`. - Method `peek_next_order() -> str` - Return the next order to be processed without removing it from the queue. If the queue is empty, return `None`. - Method `is_empty() -> bool` - Return `True` if the queue is empty, otherwise `False`. 2. **Function `main()`** - Simulate adding several orders to the `OrderQueue`. - Process and print each order until the queue is empty. - Demonstrate the functionality by adding, peeking, and processing orders. Constraints: - You can assume that each order is a non-empty string. - Ensure all methods have a constant time complexity where possible. Example: For example, initializing the queue and adding orders: 1. `add_order(\\"Cheeseburger\\")` 2. `add_order(\\"Fries\\")` 3. `add_order(\\"Cola\\")` 4. `peek_next_order()` should return `\\"Cheeseburger\\"` 5. `process_order()` should return `\\"Cheeseburger\\"` 6. `is_empty()` should return `False` 7. Process the remaining orders until the queue is empty. ```python class OrderQueue: def __init__(self): self.queue = [] def add_order(self, order: str) -> None: self.queue.append(order) def process_order(self) -> str: if self.is_empty(): return None return self.queue.pop(0) def peek_next_order(self) -> str: if self.is_empty(): return None return self.queue[0] def is_empty(self) -> bool: return len(self.queue) == 0 def main(): order_queue = OrderQueue() orders = [\\"Cheeseburger\\", \\"Fries\\", \\"Cola\\"] for order in orders: order_queue.add_order(order) print(f\'Added order: {order}\') print(f\'Next order to process: {order_queue.peek_next_order()}\') while not order_queue.is_empty(): print(f\'Processed order: {order_queue.process_order()}\') print(f\'Queue empty: {order_queue.is_empty()}\') if __name__ == \\"__main__\\": main() ``` This code initializes `OrderQueue` and demonstrates its functionality by adding, peeking, and processing orders in sequence.","solution":"class OrderQueue: def __init__(self): self.queue = [] def add_order(self, order: str) -> None: self.queue.append(order) def process_order(self) -> str: if self.is_empty(): return None return self.queue.pop(0) def peek_next_order(self) -> str: if self.is_empty(): return None return self.queue[0] def is_empty(self) -> bool: return len(self.queue) == 0 def main(): order_queue = OrderQueue() orders = [\\"Cheeseburger\\", \\"Fries\\", \\"Cola\\"] for order in orders: order_queue.add_order(order) print(f\'Added order: {order}\') print(f\'Next order to process: {order_queue.peek_next_order()}\') while not order_queue.is_empty(): print(f\'Processed order: {order_queue.process_order()}\') print(f\'Queue empty: {order_queue.is_empty()}\') if __name__ == \\"__main__\\": main()"},{"question":"# Merge Sort with Custom Comparator Objective: Implement a merge sort function that allows for a custom comparator function to be passed in, enabling the sort order to be specified (e.g., ascending, descending). Problem Statement: Write a function `merge_sort_custom(collection: list, comparator: Callable[[Any, Any], bool]) -> list` that sorts the `collection` of elements according to the custom `comparator` function provided. Your implementation must use the merge sort algorithm. Function Signature: ```python from typing import Callable, Any def merge_sort_custom(collection: list, comparator: Callable[[Any, Any], bool]) -> list: pass ``` Inputs: * `collection` (list): A mutable collection of comparable elements. * `comparator` (Callable[[Any, Any], bool]): A custom comparator function that takes two elements and returns `True` if the first element should come before the second, and `False` otherwise. Output: * The function should return a new list that is sorted in the order defined by the `comparator`. Example: ```python # Example comparator functions def ascending(a, b): return a < b def descending(a, b): return a > b # Example usage col = [3, 1, 4, 1, 5] sorted_col = merge_sort_custom(col, ascending) print(sorted_col) # Output: [1, 1, 3, 4, 5] sorted_col = merge_sort_custom(col, descending) print(sorted_col) # Output: [5, 4, 3, 1, 1] ``` Constraints: * Do not use built-in sorting functions. * Implement the sort using the merge sort algorithm. * Ensure your solution handles edge cases, such as empty lists or single-element lists.","solution":"from typing import Callable, Any, List def merge_sort_custom(collection: List[Any], comparator: Callable[[Any, Any], bool]) -> List[Any]: if len(collection) <= 1: return collection mid = len(collection) // 2 left = merge_sort_custom(collection[:mid], comparator) right = merge_sort_custom(collection[mid:], comparator) return merge(left, right, comparator) def merge(left: List[Any], right: List[Any], comparator: Callable[[Any, Any], bool]) -> List[Any]: merged = [] i = j = 0 while i < len(left) and j < len(right): if comparator(left[i], right[j]): merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 while i < len(left): merged.append(left[i]) i += 1 while j < len(right): merged.append(right[j]) j += 1 return merged"},{"question":"# Question: Generating All Unique Subsequences Problem Statement: Given a string `s`, your task is to write a function `generate_unique_subsequences` that generates all unique non-empty subsequences of the string in sorted order (lexicographically). Function Signature: ```python def generate_unique_subsequences(s: str) -> List[str]: pass ``` Input: - A string `s` (1 ≤ len(`s`) ≤ 15) consisting of lowercase English letters. Output: - A list of strings, each representing a unique non-empty subsequence of the input string `s`. Constraints: - The subsequences should be ordered lexicographically. - Duplicate subsequences should be filtered out. Scenario: For example, for `s = \\"abc\\"`: - The unique non-empty subsequences are: \\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"ac\\", \\"bc\\", \\"abc\\" - These should be returned in a sorted order. Examples: ```python assert generate_unique_subsequences(\\"a\\") == [\\"a\\"] assert generate_unique_subsequences(\\"ab\\") == [\\"a\\", \\"ab\\", \\"b\\"] assert generate_unique_subsequences(\\"aab\\") == [\\"a\\", \\"aa\\", \\"aab\\", \\"ab\\", \\"b\\"] ``` Notes: - Recall that a subsequence is a sequence that can be derived from another sequence by deleting some or none of the elements without changing the order of the remaining elements. - Consider the efficiency of your solution, especially with respect to handling the string\'s length and potential duplicate subsequences. **Good luck! This problem requires understanding of recursive generation of subsequences and handling of duplicates, which is key to maintaining the unique subsequences in lexicographical order.**","solution":"from typing import List def generate_unique_subsequences(s: str) -> List[str]: def backtrack(start, path): if path: result.add(\'\'.join(path)) for i in range(start, len(s)): path.append(s[i]) backtrack(i + 1, path) path.pop() result = set() backtrack(0, []) return sorted(result)"},{"question":"# Question: Implement a Basic Matrix Multiplication Context You are tasked with implementing a function that performs matrix multiplication. Given two matrices, your function should return their product if they can be multiplied as per the rules of linear algebra. Matrix multiplication is defined as follows: If `A` is of size `m x n` and `B` is of size `n x p`, the resulting matrix `C` will be of size `m x p`, where each element `C[i][j]` is the sum of the product of elements from the `i-th` row of `A` and the `j-th` column of `B`. Function Signature ```python def matrix_multiplication(A: list[list[int]], B: list[list[int]]) -> list[list[int]]: # Detailed implementation goes here ``` Input - `A` (list[list[int]]): A 2D list representing the first matrix with dimensions `m x n`. - `B` (list[list[int]]): A 2D list representing the second matrix with dimensions `n x p`. Output - Returns a 2D list representing the product matrix with dimensions `m x p`. Constraints - The number of columns in `A` must be equal to the number of rows in `B`. - Both matrices `A` and `B` can contain only integers. - Ensure that the function handles edge cases such as empty matrices or matrices with zero dimensions properly. Performance Requirements - Time Complexity: O(m * n * p) - Space Complexity: O(m * p) Example Scenarios - Example 1: * Input: `A = [[1, 4], [2, 5], [3, 6]]`, `B = [[1, 2, 3], [4, 5, 6]]` * Output: `[[17, 22, 27], [22, 29, 36], [27, 36, 45]]` - Example 2: * Input: `A = [[2, 3]], B = [[5, 6], [7, 8]]` * Output: `[[31, 36]]` Instructions 1. Write a function `matrix_multiplication` that multiplies two matrices. 2. Validate that the input matrices can be multiplied. 3. Ensure that the function handles edge cases, such as matrices with zeros or empty matrices. 4. Test the function with various inputs to ensure correctness.","solution":"def matrix_multiplication(A: list[list[int]], B: list[list[int]]) -> list[list[int]]: if len(A) == 0 or len(B) == 0 or len(A[0]) == 0 or len(B[0]) == 0: return [] # Number of columns in A should be equal to the number of rows in B n = len(A[0]) # Number of columns in A if n != len(B): raise ValueError(\\"Incompatible dimensions for matrix multiplication\\") m = len(A) p = len(B[0]) # Initialize the resultant matrix with zeros C = [[0] * p for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): C[i][j] += A[i][k] * B[k][j] return C"},{"question":"# Context You are tasked with processing and analyzing large text datasets. In particular, you will be managing chat logs, which are often messy and require filtering and extraction of meaningful information. # Problem Statement You need to create a function that processes a chat log file to extract and summarize user activity. Your function should be able to handle large files efficiently and perform necessary error handling for file operations and data parsing. # Requirements - Implement a function `summarize_chat_log(file_path: str, output_path: str) -> dict:` which: * Reads the chat log from the specified `file_path`. * Extracts user activity, including timestamp, user ID, and message content. * Summarizes activity based on users, including total messages sent and average message length. * Saves a summary report to the specified `output_path`. * Logs errors such as file read issues, parsing errors, and file write failures. * Returns the summary data if successful, otherwise provides a meaningful error message. # Input - `file_path (str)`: Path to the chat log file to be processed. - `output_path (str)`: Path where the summary report will be saved. # Output - Returns a dictionary containing either the summary data or an error message. # Constraints - Ensure file read operations handle large files efficiently (e.g., using generators or reading chunks). - Appropriately handle file I/O errors and data parsing errors. - Validate output paths before attempting to save summary reports. # Example ```python file_path = \\"./chat_logs/log.txt\\" output_path = \\"./chat_summary/summary.json\\" result = summarize_chat_log(file_path, output_path) print(result) ``` Expected output: - On success: Summary data including user activity details. - On failure: An error message specifying the problem (e.g., \\"File not found\\", \\"Invalid data format\\").","solution":"import json import os def summarize_chat_log(file_path: str, output_path: str) -> dict: Processes a chat log file to extract and summarize user activity. Parameters: - file_path (str): The path to the chat log file. - output_path (str): The path where the summary report will be saved. Returns: - dict: A dictionary containing either the summary data or an error message. user_activity = {} try: if not os.path.isfile(file_path): return {\\"error\\": \\"File not found\\"} with open(file_path, \'r\') as file: for line in file: try: timestamp, user_id, message = line.strip().split(\',\', 2) if user_id not in user_activity: user_activity[user_id] = { \\"total_messages\\": 0, \\"total_length\\": 0, } user_activity[user_id][\\"total_messages\\"] += 1 user_activity[user_id][\\"total_length\\"] += len(message) except ValueError: return {\\"error\\": \\"Invalid data format\\"} for user_id in user_activity: user_activity[user_id][\\"average_length\\"] = ( user_activity[user_id][\\"total_length\\"] / user_activity[user_id][\\"total_messages\\"] ) try: if not os.path.exists(os.path.dirname(output_path)): os.makedirs(os.path.dirname(output_path)) with open(output_path, \'w\') as outfile: json.dump(user_activity, outfile, indent=4) return user_activity except OSError as e: return {\\"error\\": f\\"File write error: {str(e)}\\"} except IOError as e: return {\\"error\\": f\\"File read error: {str(e)}\\"}"},{"question":"# Coding Assessment Task Context You are given a list of JSON files containing sales data from multiple stores, with each file representing a day\'s transactions. Your task is to aggregate the data to provide useful insights. Objective Implement a class `SalesAggregator` that reads the JSON files, processes the sales data, and provides methods to retrieve aggregated sales information. Your implementation should include: 1. **Loading JSON Data**: Read multiple JSON files and concatenate their contents into a single dataset. 2. **Aggregating Sales Data**: Provide methods to calculate total sales, average sales per day, and the highest and lowest sales recorded. 3. **Data Filtering**: Implement methods to filter sales data based on date ranges or specific stores. Requirements - Use Python\'s standard libraries for handling files and JSON data. - Implement methods to load JSON files and concatenate their contents. - Implement methods for sales data aggregation and filtering. # Function Specifications `SalesAggregator` * **Attributes**: - `sales_data`: List of dictionaries containing sales information from all the JSON files. * **Methods**: - `__init__(self, json_files)`: Initialize and load data from the provided list of JSON file paths. - `_load_json_files(self, json_files)`: Load and concatenate data from the provided list of JSON file paths. - `total_sales(self)`: Return the total sales amount. - `average_sales_per_day(self)`: Return the average sales amount per day. - `highest_sale(self)`: Return the highest sales amount recorded in a single transaction. - `lowest_sale(self)`: Return the lowest sales amount recorded in a single transaction. - `filter_by_date_range(self, start_date, end_date)`: Return sales data filtered by the specified date range. - `filter_by_store(self, store_id)`: Return sales data filtered by the specified store ID. # Constraints - Each JSON file is structured with a list of sales transactions, where each transaction is a dictionary containing at least `date`, `store_id`, and `amount` fields. - Ensure proper handling of edge cases, such as empty lists or missing data fields. - Efficiently handle a large number of JSON files and sales transactions. Example Usage ```python json_files = [\\"sales_jan_01.json\\", \\"sales_jan_02.json\\", \\"sales_jan_03.json\\"] aggregator = SalesAggregator(json_files) print(aggregator.total_sales()) print(aggregator.average_sales_per_day()) print(aggregator.highest_sale()) print(aggregator.lowest_sale()) filtered_sales = aggregator.filter_by_date_range(\\"2023-01-01\\", \\"2023-01-10\\") store_sales = aggregator.filter_by_store(\\"store_123\\") ``` # Hints - Use `json` module to read and parse JSON files. - Date fields might need to be converted to a datetime object for comparison. - Consider using list comprehensions and generator expressions for efficient data processing.","solution":"import json from datetime import datetime from typing import List, Dict class SalesAggregator: def __init__(self, json_files: List[str]): self.sales_data = self._load_json_files(json_files) def _load_json_files(self, json_files: List[str]) -> List[Dict]: sales_data = [] for file in json_files: with open(file, \'r\') as f: sales_data.extend(json.load(f)) return sales_data def total_sales(self) -> float: return sum(transaction[\'amount\'] for transaction in self.sales_data) def average_sales_per_day(self) -> float: sales_by_day = {} for transaction in self.sales_data: date = transaction[\'date\'] if date not in sales_by_day: sales_by_day[date] = 0 sales_by_day[date] += transaction[\'amount\'] average_sales = sum(sales_by_day.values()) / len(sales_by_day) return average_sales def highest_sale(self) -> float: return max(transaction[\'amount\'] for transaction in self.sales_data) def lowest_sale(self) -> float: return min(transaction[\'amount\'] for transaction in self.sales_data) def filter_by_date_range(self, start_date: str, end_date: str) -> List[Dict]: start_date = datetime.strptime(start_date, \\"%Y-%m-%d\\") end_date = datetime.strptime(end_date, \\"%Y-%m-%d\\") return [transaction for transaction in self.sales_data if start_date <= datetime.strptime(transaction[\'date\'], \\"%Y-%m-%d\\") <= end_date] def filter_by_store(self, store_id: str) -> List[Dict]: return [transaction for transaction in self.sales_data if transaction[\'store_id\'] == store_id]"},{"question":"# Question: You have been given the task to implement a segment tree for range minimum queries along with a functionality to update the values in the array. The segment tree should support efficient range queries and point updates. **Function Signatures**: ```python class SegmentTree: def __init__(self, arr: List[int]): Initializes a SegmentTree object. Parameters: - arr: A list of integers representing the original array. def range_minimum(self, left: int, right: int) -> int: Returns the minimum value in the range [left, right] of the array. Parameters: - left: Starting index of the range (inclusive). - right: Ending index of the range (inclusive). Returns: - The minimum value within the specified range. If the range is invalid, return float(\'inf\'). def update(self, idx: int, value: int): Updates the value at index `idx` in the array to `value`. Parameters: - idx: The index of the element to update. - value: The new value to be placed at index `idx`. ``` # Input: * `arr:` A list of integers to build the segment tree. * `left (int):` The starting index of the range (0-indexed). * `right (int):` The ending index of the range (0-indexed). * `idx (int):` The index of the element to update. * `value (int):` The new value to be placed at index `idx`. # Output: * For the `range_minimum` method: Return the minimum value within the specified range `[left, right]`. If the range is invalid, return `float(\'inf\')`. * For the `update` method: The function should properly update the value at the specified index. # Constraints: * The size of the array will not exceed 100,000 elements. * Ensure that the range queries and updates are efficient, utilizing the properties of the segment tree. * Handle invalid inputs gracefully. # Example: ```python >>> arr = [3, 2, 4, 5, 1, 1, 7, 3, 6] >>> st = SegmentTree(arr) >>> st.range_minimum(1, 3) 2 >>> st.range_minimum(4, 6) 1 >>> st.update(2, 0) >>> st.range_minimum(1, 3) 0 ``` **Notes**: * The segment tree should be constructed efficiently during initialization. * The range queries and updates should leverage the segment tree\'s structure for optimal performance.","solution":"from typing import List class SegmentTree: def __init__(self, arr: List[int]): self.n = len(arr) self.tree = [float(\'inf\')] * (2 * self.n) self._build(arr) def _build(self, arr: List[int]): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[2 * i], self.tree[2 * i + 1]) def range_minimum(self, left: int, right: int) -> int: if left < 0 or right >= self.n or left > right: return float(\'inf\') # Adjust the indices to leaf nodes left += self.n right += self.n + 1 # Make it exclusive min_val = float(\'inf\') while left < right: if left % 2 == 1: # If left pointer is a right child min_val = min(min_val, self.tree[left]) left += 1 if right % 2 == 1: # If right pointer is a left child right -= 1 min_val = min(min_val, self.tree[right]) # Move to the next upper level left //= 2 right //= 2 return min_val def update(self, idx: int, value: int): if idx < 0 or idx >= self.n: return # Update the value at the leaf node idx += self.n self.tree[idx] = value # Update the rest of the tree while idx > 1: idx //= 2 self.tree[idx] = min(self.tree[2 * idx], self.tree[2 * idx + 1])"},{"question":"# Enhanced Currency Converter with Historical Rates Design an enhanced currency converter that not only converts between different currencies but also supports historical conversion rates for various dates. Requirements: 1. **Real-Time Conversion**: Provide current conversions between supported currencies. 2. **Historical Rates**: Allow conversions using historical rates given a specific date. 3. **Supported Currencies**: Extend support for additional currencies: \\"INR\\" (Indian Rupee), \\"CNY\\" (Chinese Yuan), and \\"SGD\\" (Singapore Dollar). 4. **Conversion Rate Details**: Create a function `rate_details(currency: str) -> str` that returns a string description about the currency. For unsupported currencies, raise a ValueError with a descriptive error message. # Input Specifications: 1. `currency_conversion(value: float, from_currency: str, to_currency: str, date: str = None) -> float`: This function converts currency from one type to another, using real-time rates if no date is provided and historical rates if a date is specified. 2. `rate_details(currency: str) -> str`: This function provides details about the given currency. # Output Specifications: 1. `currency_conversion` should return the converted value. 2. `rate_details` should return a string description of the unit. # Constraints: 1. The currencies provided must be valid; otherwise, raise a `ValueError`. 2. Conversion rates will be provided in a dictionary of dictionaries format for both current and historical rates. 3. Ensure the descriptions are clear and informative. # Scenarios and Examples: 1. **Converting Currencies**: - `currency_conversion(100, \\"USD\\", \\"INR\\")` should return the current conversion value of 100 USD to INR. - `currency_conversion(50, \\"EUR\\", \\"SGD\\", \\"2023-01-15\\")` should return the value of 50 EUR converted to SGD using the rate from January 15th, 2023. 2. **Currency Details**: - `rate_details(\\"INR\\")` should return a string like \\"Indian Rupee: The official currency of India.\\" - `rate_details(\\"CNY\\")` should return a string like \\"Chinese Yuan: The official currency of the People\'s Republic of China.\\" # Boilerplate Code ```python from typing import NamedTuple, Dict import datetime class RateDetail(NamedTuple): full_name: str context: str CURRENT_RATES = { \\"USD\\": {\\"INR\\": 74.85, \\"CNY\\": 6.47, \\"SGD\\": 1.35}, \\"EUR\\": {\\"INR\\": 87.79, \\"CNY\\": 7.56, \\"SGD\\": 1.58}, \\"JPY\\": {\\"INR\\": 0.67, \\"CNY\\": 0.059, \\"SGD\\": 0.012}, # extend with more current rates } HISTORICAL_RATES = { \\"2023-01-15\\": { \\"USD\\": {\\"INR\\": 75.22, \\"CNY\\": 6.51, \\"SGD\\": 1.36}, \\"EUR\\": {\\"INR\\": 88.01, \\"CNY\\": 7.62, \\"SGD\\": 1.59}, \\"JPY\\": {\\"INR\\": 0.68, \\"CNY\\": 0.060, \\"SGD\\": 0.013}, # extend with more historical rates for the given date }, # add more dates and rates if needed } CURRENCY_DETAILS = { \\"USD\\": RateDetail(\\"United States Dollar\\", \\"The official currency of the United States of America.\\"), \\"EUR\\": RateDetail(\\"Euro\\", \\"The official currency of the Eurozone countries.\\"), \\"JPY\\": RateDetail(\\"Japanese Yen\\", \\"The official currency of Japan.\\"), # extend with new currencies } def currency_conversion(value: float, from_currency: str, to_currency: str, date: str = None) -> float: if date: rates = HISTORICAL_RATES.get(date) if not rates: raise ValueError(f\\"No historical rates available for the date: {date}\\") else: rates = CURRENT_RATES if from_currency not in rates: raise ValueError(f\\"Invalid \'from_currency\' value: {from_currency!r}. Supported values are:n{\', \'.join(rates)}\\") if to_currency not in rates[from_currency]: raise ValueError(f\\"Invalid \'to_currency\' value: {to_currency!r}. Supported values are:n{\', \'.join(rates[from_currency])}\\") conversion_rate = rates[from_currency][to_currency] return value * conversion_rate def rate_details(currency: str) -> str: detail = CURRENCY_DETAILS.get(currency) if not detail: raise ValueError(f\\"No details available for the currency: {currency}\\") return f\\"{detail.full_name}: {detail.context}\\" if __name__ == \\"__main__\\": import doctest # Write doctests for currency_conversion and rate_details doctest.testmod() ```","solution":"from typing import NamedTuple, Dict import datetime class RateDetail(NamedTuple): full_name: str context: str CURRENT_RATES = { \\"USD\\": {\\"INR\\": 74.85, \\"CNY\\": 6.47, \\"SGD\\": 1.35}, \\"EUR\\": {\\"INR\\": 87.79, \\"CNY\\": 7.56, \\"SGD\\": 1.58}, \\"JPY\\": {\\"INR\\": 0.67, \\"CNY\\": 0.059, \\"SGD\\": 0.012}, # extend with more current rates } HISTORICAL_RATES = { \\"2023-01-15\\": { \\"USD\\": {\\"INR\\": 75.22, \\"CNY\\": 6.51, \\"SGD\\": 1.36}, \\"EUR\\": {\\"INR\\": 88.01, \\"CNY\\": 7.62, \\"SGD\\": 1.59}, \\"JPY\\": {\\"INR\\": 0.68, \\"CNY\\": 0.060, \\"SGD\\": 0.013}, # extend with more historical rates for the given date }, # add more dates and rates if needed } CURRENCY_DETAILS = { \\"USD\\": RateDetail(\\"United States Dollar\\", \\"The official currency of the United States of America.\\"), \\"EUR\\": RateDetail(\\"Euro\\", \\"The official currency of the Eurozone countries.\\"), \\"JPY\\": RateDetail(\\"Japanese Yen\\", \\"The official currency of Japan.\\"), \\"INR\\": RateDetail(\\"Indian Rupee\\", \\"The official currency of India.\\"), \\"CNY\\": RateDetail(\\"Chinese Yuan\\", \\"The official currency of the People\'s Republic of China.\\"), \\"SGD\\": RateDetail(\\"Singapore Dollar\\", \\"The official currency of Singapore.\\"), # extend with new currencies } def currency_conversion(value: float, from_currency: str, to_currency: str, date: str = None) -> float: if date: rates = HISTORICAL_RATES.get(date) if not rates: raise ValueError(f\\"No historical rates available for the date: {date}\\") else: rates = CURRENT_RATES if from_currency not in rates: raise ValueError(f\\"Invalid \'from_currency\' value: {from_currency!r}. Supported values are:n{\', \'.join(rates)}\\") if to_currency not in rates[from_currency]: raise ValueError(f\\"Invalid \'to_currency\' value: {to_currency!r}. Supported values are:n{\', \'.join(rates[from_currency])}\\") conversion_rate = rates[from_currency][to_currency] return value * conversion_rate def rate_details(currency: str) -> str: detail = CURRENCY_DETAILS.get(currency) if not detail: raise ValueError(f\\"No details available for the currency: {currency}\\") return f\\"{detail.full_name}: {detail.context}\\" if __name__ == \\"__main__\\": import doctest # Write doctests for currency_conversion and rate_details doctest.testmod()"},{"question":"# Problem Statement: Design a function that takes an `n x n` binary matrix representing an image, and rotates the image by 90 degrees clockwise. You are required to rotate the image in-place, meaning you are not allowed to use a separate array. # Input: * `List[List[int]] matrix`: The `n x n` binary matrix where `matrix[i][j]` is either 0 or 1. # Output: * The function should modify the input matrix in-place. # Constraints: * The input matrix is guaranteed to be square, i.e., the number of rows and columns is the same. * The size of the input matrix is at least 1x1 and at most 100x100. # Example: ```python # Example 1: # Input: # matrix = [ # [1, 0, 0], # [0, 1, 0], # [0, 0, 1] # ] # Output: # [ # [0, 0, 1], # [0, 1, 0], # [1, 0, 0] # ] # Example 2: # Input: # matrix = [ # [1, 1, 0, 0], # [0, 1, 1, 0], # [0, 0, 1, 1], # [1, 0, 0, 1] # ] # Output: # [ # [1, 0, 0, 1], # [0, 0, 1, 1], # [0, 1, 1, 0], # [1, 1, 0, 0] # ] ``` # Notes: * A 90-degree clockwise rotation involves reassigning element `matrix[i][j]` to `matrix[j][n-1-i]`. * Try to solve this problem step-by-step, first understanding how to swap the elements in groups. # Function Signature: ```python def rotate_matrix(matrix: List[List[int]]) -> None: # Implementation here ```","solution":"def rotate_matrix(matrix): Rotate the n x n binary matrix 90 degrees clockwise in-place. :param matrix: List[List[int]] :return: None n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Problem Statement: # Context: You are working on a text processing utility that needs to perform a padding operation on strings to ensure they all have the same length by prefixing them with leading characters. This is often needed in formatting text for terminal display or preparing data for further processing. **Purpose**: Implement a function that pads strings with a given character so that all strings in a list reach the same specified length. # Task: Write a function `pad_strings(strings: List[str], length: int, pad_char: str) -> List[str]` that takes: 1. A list of strings `strings` that needs to be padded. 2. An integer `length` which signifies the desired uniform length of each padded string. 3. A single character `pad_char` that will be used for padding. The function should return a new list with each string padded to the specified length. If a string is already longer than the specified length, it should remain unchanged. # Input: - A list of strings `strings` (1 <= len(strings) <= 10^5; 0 <= len(strings[i]) <= 10^3 for each string `strings[i]`). - An integer `length` (0 <= length <= 10^3). - A single character string `pad_char`. # Output: - A list of strings where each string is padded with `pad_char` to meet the specified length. # Constraints: - The function should handle large lists of strings efficiently. - The padded character will be a single ASCII character. - Input strings can be empty. # Performance Requirement: - Aim for a linear time complexity based on the number of strings and their lengths. # Example: ```python >>> pad_strings([\\"apple\\", \\"banana\\", \\"pear\\"], 8, \'*\') [\'***apple\', \'**banana\', \'****pear\'] >>> pad_strings([\\"short\\", \\"verylongword\\", \\"tiny\\"], 7, \'-\') [\'--short\', \'verylongword\', \'---tiny\'] ``` **Note**: Ensure your function pads strings only if needed and uses the specified padding character effectively. Optimize for performance given the potential input sizes.","solution":"from typing import List def pad_strings(strings: List[str], length: int, pad_char: str) -> List[str]: Pads a list of strings with a given character to a specified length. Parameters: strings (List[str]): List of strings to pad. length (int): Desired uniform length of each string. pad_char (str): Character used for padding. Returns: List[str]: List of padded strings. padded_strings = [] for s in strings: if len(s) < length: padding = pad_char * (length - len(s)) padded_strings.append(padding + s) else: padded_strings.append(s) return padded_strings"},{"question":"# Problem Statement You are given a list of integers representing the heights of N buildings. The tallest peak in the sequence is defined as the maximum height to which you can move continuously upward and then continuously downward, forming a peak. Write a function `find_tallest_peak(heights: List[int]) -> int` that takes in a list of integers and returns the height of the tallest peak. # Function Signature ```python def find_tallest_peak(heights: List[int]) -> int: ``` # Input * `heights`: A list of integers where each integer represents the height of a building. # Output * An integer representing the height of the tallest peak. # Constraints * 2 ≤ N ≤ 10^5 * 1 ≤ heights[i] ≤ 10^4 for each 0 ≤ i < N # Example ```python heights = [2, 3, 4, 5, 3, 2, 7, 6, 5, 4, 3, 2, 1, 2, 3, 4, 2] print(find_tallest_peak(heights)) # Output: 5 ``` # Requirements * The function should run in O(N) time complexity. * Handle edge cases where the tallest peak is at either the start or the end of the list. * Ensure the implementation does not use extra space beyond O(1) other than the input list.","solution":"from typing import List def find_tallest_peak(heights: List[int]) -> int: n = len(heights) if n < 3: return 0 # A peak requires at least 3 buildings tallest_peak = 0 i = 1 while i < n - 1: # Check if heights[i] is a peak if heights[i-1] < heights[i] > heights[i+1]: left = i - 1 right = i + 1 # Find the maximum peak height while left > 0 and heights[left-1] < heights[left]: left -= 1 while right < n - 1 and heights[right+1] < heights[right]: right += 1 tallest_peak = max(tallest_peak, heights[i]) # Move i to the end of the right slope i = right else: i += 1 return tallest_peak"},{"question":"# Rotate Matrix Layer by Layer Problem Statement You are required to implement a function that rotates an `n x n` matrix 90 degrees clockwise. The rotation must be done in-place, meaning you cannot use any additional 2D array for the transformation. Instead, you should achieve the rotation by moving elements layer by layer (or ring by ring), starting from the outermost layer and working your way towards the center. Function Signature ```python def rotate_matrix(matrix: list[list[int]]) -> None: ``` Input - `matrix: list[list[int]]` - a 2D list representing an `n x n` matrix where `1 <= n <= 1000`. Output - The function does not return anything. Modify the input matrix in-place to achieve the rotation. Example ```plaintext Input: [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] Output: None Modified matrix: [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` Constraints - The matrix will always be a 2D square array (`n x n`). - All elements in the matrix are integers. Note 1. Ensure that the algorithm modifies the matrix in-place. 2. The rotation should involve a sequence of element swaps that follow the pattern of moving layers, maintaining the complexity of O(n^2).","solution":"def rotate_matrix(matrix): Rotates the given n x n matrix 90 degrees clockwise in-place. n = len(matrix) # transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # reverse the rows of the transposed matrix for i in range(n): matrix[i].reverse()"},{"question":"# **Student Grade Management System** # Problem Statement: Develop a student grade management system where you can add students and their grades to various subjects, then compute their average grade status. Using this system, you will track the students, their respective grades, and generate class performance summaries. # Function Definitions: Function 1: `add_student_grade(data: dict, student: str, subject: str, grade: float) -> dict` - **Input**: - A dictionary representing the current student grade data. - A string representing the student\'s name. - A string representing the subject name. - A float representing the grade for the subject. - **Output**: An updated dictionary containing the new student grade data. - **Constraints**: * If the student\'s name or subject is an empty string, the function should raise a `ValueError(\\"Student name and subject cannot be empty\\")`. * If the grade is not between 0.0 and 100.0, the function should raise a `ValueError(\\"Grade must be between 0.0 and 100.0\\")`. Function 2: `compute_average_grade(data: dict) -> dict` - **Input**: A dictionary containing the student grade data. - **Output**: A dictionary containing each student and their average grade. - **Constraints**: * Calculate the average grade for each student based on all their subjects. * Raise a `ZeroDivisionError(\\"No grades to compute average\\")` if a student has no subjects. # Task Instructions: 1. Implement the `add_student_grade` function. 2. Implement the `compute_average_grade` function. 3. Write a main block to demonstrate adding students and their grades, computing averages, and printing a summary of grades. # Examples: Example 1: Given the following input: ```python data = {} student = \'Alice\' subject = \'Math\' grade = 85.5 ``` After calling `add_student_grade(data, student, subject, grade)`, the expected data dictionary is: ```python { \'Alice\': {\'Math\': 85.5} } ``` Example 2: Given the following input: ```python data = { \'Alice\': {\'Math\': 85.5}, \'Bob\': {\'Math\': 78.0, \'Science\': 88.5} } ``` After calling `compute_average_grade(data)`, the expected output is: ```python { \'Alice\': 85.5, \'Bob\': 83.25 } ``` # Constraints: * Ensure the system can handle multiple students and various subjects efficiently. * Make appropriate use of exception handling to guarantee robust inputs.","solution":"def add_student_grade(data, student, subject, grade): Adds a student\'s grade for a specific subject to the data dictionary. Args: data (dict): The dictionary containing the current student grades. student (str): The student\'s name. subject (str): The subject name. grade (float): The grade for the subject. Returns: dict: Updated dictionary containing the new student grade. Raises: ValueError: If the student name or subject is empty or if the grade is not between 0.0 and 100.0. if not student or not subject: raise ValueError(\\"Student name and subject cannot be empty\\") if not (0.0 <= grade <= 100.0): raise ValueError(\\"Grade must be between 0.0 and 100.0\\") if student not in data: data[student] = {} data[student][subject] = grade return data def compute_average_grade(data): Computes the average grade for each student based on their grades. Args: data (dict): The dictionary containing the student grade data. Returns: dict: Dictionary containing each student and their average grade. Raises: ZeroDivisionError: If a student has no subjects. averages = {} for student, subjects in data.items(): if len(subjects) == 0: raise ZeroDivisionError(\\"No grades to compute average\\") total = sum(subjects.values()) average = total / len(subjects) averages[student] = average return averages"},{"question":"# Coding Assessment Question You are given an array of integers and a set of intervals. Your task is to compute the sum of elements in the array for each specified interval. Write a function that, given an integer array and a list of intervals, returns the sum of the elements within each interval, inclusively. # Input and Output Formats - **Input**: A list, `arr`, of integers and a list of tuples, `intervals`, with each tuple containing two integers representing the start and end indices of an interval. - **Output**: A list of integers where each integer represents the sum of the elements in the corresponding interval in the `intervals` list. # Constraints - Indices in the intervals are zero-based. - Start and end indices are inclusive and valid within the array range. - Your function should handle multiple intervals efficiently, especially for large arrays and numerous intervals. # Function Signature ```python def sum_of_intervals(arr: list[int], intervals: list[tuple[int, int]]) -> list[int]: pass ``` # Example ```python >>> sum_of_intervals([1, 2, 3, 4, 5], [(0, 2), (1, 3), (0, 4)]) [6, 9, 15] ``` # Detailed Description - **Edge Cases**: Consider single-element intervals or cases where intervals span the entire array. - **Optimizations**: Pre-computation techniques such as prefix sums can be used to optimize the solution. # Notes - Ensure your function avoids redundant computations by leveraging efficient interval sum techniques. - Each interval is valid and within the bounds of the array. - Handling edge scenarios with precision will be critical for correctness and performance.","solution":"def sum_of_intervals(arr, intervals): Returns the sum of elements in the array for each specified interval. Args: arr: List of integers. intervals: List of tuples, where each tuple contains two integers representing the start and end indices (inclusive) of an interval. Returns: List of integers where each integer represents the sum of the elements within the corresponding interval. # Precompute the prefix sums n = len(arr) prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + arr[i] result = [] for start, end in intervals: result.append(prefix_sums[end + 1] - prefix_sums[start]) return result"},{"question":"# Coding Assessment Question: Optimized Palindrome Pair Detector As a proficient developer, your task is to create an efficient solution to detect palindrome pairs within a list of words using Python. **Context:** Your company is working on a text manipulation project where identifying pairs of words that form palindromes is essential. This has applications in various fields such as cryptography, linguistic research, and algorithmic puzzles. The current brute-force approach checks all possible pairs, which is inefficient for large datasets. You have been assigned to optimize this solution. # Task: Implement a function `find_palindrome_pairs(words: list[str]) -> list[tuple[int, int]]` that takes a list of words and returns a list of index pairs, indicating the positions of words that form palindromes when concatenated in either order. # Specifications: 1. **Function: Detecting Palindrome Pairs** ```python def find_palindrome_pairs(words: list[str]) -> list[tuple[int, int]]: ``` - **Input**: `words` (list[str]) – A list of words. - **Output**: List of tuples, where each tuple contains two indices `(i, j)` such that the concatenation of `words[i] + words[j]` or `words[j] + words[i]` forms a palindrome. - **Constraints**: - Words are case-insensitive (process in lowercase). - Handle large lists efficiently. # Sample Input: ```python words = [\\"bat\\", \\"tab\\", \\"cat\\", \\"tac\\", \\"act\\"] ``` # Sample Output: ```python [(0, 1), (1, 0), (2, 3), (3, 2)] ``` # Explanation: - `\\"bat\\" + \\"tab\\"` and `\\"tab\\" + \\"bat\\"` both form the palindrome `\\"battab\\"` - `\\"cat\\" + \\"tac\\"` and `\\"tac\\" + \\"cat\\"` both form the palindrome `\\"cattac\\"` # Example Usage: ```python words = [\\"bat\\", \\"tab\\", \\"cat\\", \\"tac\\", \\"act\\"] palindrome_pairs = find_palindrome_pairs(words) print(palindrome_pairs) # Output: [(0, 1), (1, 0), (2, 3), (3, 2)] ``` # Performance Requirements: - Solutions should aim to minimize both time and space complexity, ideally better than O(n^2) where n is the number of words. - Consider edge cases, such as empty lists or words with no palindrome pairs. # Testing: - Write unit tests to validate your implementation against edge cases, performance bottlenecks, and typical scenarios. Good luck!","solution":"def find_palindrome_pairs(words: list[str]) -> list[tuple[int, int]]: def is_palindrome(word: str) -> bool: return word == word[::-1] word_map = {word[::-1]: idx for idx, word in enumerate(words)} results = [] for i, word in enumerate(words): for j in range(len(word) + 1): prefix, suffix = word[:j], word[j:] if is_palindrome(prefix) and suffix in word_map and word_map[suffix] != i: results.append((word_map[suffix], i)) if j != len(word) and is_palindrome(suffix) and prefix in word_map and word_map[prefix] != i: results.append((i, word_map[prefix])) return results"},{"question":"**Question: Largest Sum of Non-Adjacent Numbers** Given an array of integers, find the largest sum of non-adjacent numbers. Numbers in the array can be positive or negative, and an empty array should return a sum of 0. **Function Signature:** ```python def largest_sum_non_adjacent(nums: List[int]) -> int: pass ``` **Input:** - `nums`: a list of integers where ( text{len(nums)} leq 10^4 ) and ( -10^3 leq text{nums[i]} leq 10^3 ) **Output:** - Return the largest sum of non-adjacent numbers. **Example:** ```plaintext Input: [3, 2, 5, 10, 7] Output: 15 Input: [-2, 1, 3, -4, 5] Output: 8 ``` **Constraints:** - Ensure to handle negative numbers within the array. - Consider edge cases where the array is empty or contains a single element. **Performance Requirements:** - The solution should be efficient with a time complexity of O(n). **Edge Cases:** - An empty array should return 0. - An array with one element should return that element if it\'s positive (or 0 if it\'s otherwise). - Arrays with all negative numbers should consider not including any numbers for a sum of 0.","solution":"from typing import List def largest_sum_non_adjacent(nums: List[int]) -> int: if not nums: return 0 if len(nums) == 1: return max(0, nums[0]) include = 0 exclude = 0 for num in nums: new_exclude = max(include, exclude) include = exclude + num exclude = new_exclude return max(include, exclude)"},{"question":"# Maximum Subarray Sum with Constraint You are developing a financial analysis tool to help analysts understand the risk and potential gains by examining the maximum possible sum of subarrays within a series of daily stock price changes, given a specific constraint on the subarray length. Task: Write a function `max_subarray_sum` to compute the maximum sum of any subarray with a length equal to or less than a given constraint. ```python def max_subarray_sum(stock_changes: List[int], max_length: int) -> int: # implement the function pass ``` Parameters: * **stock_changes** (List[int]): A list of integers representing daily changes in stock prices. * **max_length** (int): An integer representing the maximum allowed length for the subarrays to be considered (must be greater than 0). Returns: * **int**: The maximum sum of any subarray where the length of the subarray is less than or equal to `max_length`. Details: * Utilize a sliding window technique to efficiently compute the required sum. * If the length of `stock_changes` is less than `max_length`, consider the whole array. Examples: ```python >>> max_subarray_sum([1, -2, 3, -1, 2], 2) 3 # The subarray [3] has the maximum sum among all subarrays of size <= 2 >>> max_subarray_sum([1, -2, 3, -1, 2], 3) 4 # The subarray [3, -1, 2] has the maximum sum among all subarrays of size <= 3 >>> max_subarray_sum([-1, -2, -3, -4], 2) -1 # The subarray [-1] has the maximum sum among all subarrays of size <= 2 ``` Constraints: * The `max_length` must be a positive integer. * The list `stock_changes` has at least one element. Notes: * Ensure the algorithm handles negative values effectively. * Optimize for performance to handle large lists of stock price changes. --- This question integrates seamlessly with the original set by continuing the theme of financial data and providing a computationally interesting problem that requires understanding of subarrays and sliding window techniques.","solution":"from typing import List def max_subarray_sum(stock_changes: List[int], max_length: int) -> int: n = len(stock_changes) max_sum = float(\'-inf\') for length in range(1, max_length + 1): window_sum = sum(stock_changes[:length]) max_sum = max(max_sum, window_sum) for i in range(length, n): window_sum += stock_changes[i] - stock_changes[i - length] max_sum = max(max_sum, window_sum) return max_sum"},{"question":"# Coding Assessment Question Context You are developing a software tool for a local library that tracks the circulation of books. Each book can be checked out, returned, or reserved by users. Your task is to create a class to manage the state of a single book, ensuring it correctly handles various actions and potential edge cases. Task Implement a `Book` class that supports the following operations: check out the book, return the book, and reserve the book. The class should manage the state of the book and handle invalid actions gracefully by raising appropriate exceptions. Use the function signatures and constraints provided to structure your class and methods. Class Signature ```python class Book: def __init__(self, title: str): pass def checkout(self): pass def return_book(self): pass def reserve(self): pass def get_status(self) -> str: pass ``` Methods * `__init__(self, title: str)`: Initializes the book with its title. The initial state of the book is \\"available\\". * `checkout(self)`: Checks out the book if it is currently \\"available\\". Raises a `ValueError` if the book is in any other state. * `return_book(self)`: Returns the book if it is currently \\"checked out\\". Raises a `ValueError` if the book is in any other state. * `reserve(self)`: Reserves the book if it is currently \\"available\\". Raises a `ValueError` if the book is in any other state. * `get_status(self) -> str`: Returns the current status of the book (\\"available\\", \\"checked out\\", or \\"reserved\\"). Constraints * The title must be a non-empty string. * The status of the book must always be valid as one of: \\"available\\", \\"checked out\\", or \\"reserved\\". Example ```python book = Book(\\"The Great Gatsby\\") assert book.get_status() == \\"available\\" book.checkout() assert book.get_status() == \\"checked out\\" book.return_book() assert book.get_status() == \\"available\\" book.reserve() assert book.get_status() == \\"reserved\\" ``` Edge Cases * Attempting to check out an already checked out or reserved book should raise a `ValueError`. * Attempting to return a book that is not checked out should raise a `ValueError`. * Attempting to reserve an already checked out or reserved book should raise a `ValueError`. This question should seamlessly fit into your existing coding assessment set in terms of style, complexity, tone, and length.","solution":"class Book: def __init__(self, title: str): if not title: raise ValueError(\\"Title must be a non-empty string.\\") self.title = title self.status = \\"available\\" def checkout(self): if self.status != \\"available\\": raise ValueError(\\"Book cannot be checked out unless it is available.\\") self.status = \\"checked out\\" def return_book(self): if self.status != \\"checked out\\": raise ValueError(\\"Book cannot be returned unless it is checked out.\\") self.status = \\"available\\" def reserve(self): if self.status != \\"available\\": raise ValueError(\\"Book cannot be reserved unless it is available.\\") self.status = \\"reserved\\" def get_status(self) -> str: return self.status"},{"question":"# Problem Description You are required to implement a function that determines if a given word can be formed from the letters of another string, using each letter only once. This function should account for case sensitivity, whitespace, and special characters. # Function Signature ```python def can_form_word(source: str, target: str) -> bool: Determine if target word can be formed from characters in the source string. ``` # Input * `source` (str): A string containing the letters from which the target word will be formed. * `target` (str): A word to form using the characters from the source string. # Output * A boolean value (`True` or `False`) indicating whether the target word can be formed from the characters of the source string. # Constraints * The `source` and `target` parameters must be non-empty strings. * Both strings may contain any printable ASCII characters. # Performance Requirements * Solutions should be efficient with respect to both time and space complexity. Aim for linear time complexity O(n + m), where n is the length of the source and m is the length of the target. # Errors and Edge Cases * Return `False` if `source` contains fewer letters than required by the `target`. * Return `True` if `target` is an empty string (an empty string can trivially be formed from any source). * Handle cases where the source and target words are equal, different lengths, or completely disjoint. # Example ```python can_form_word(\\"aabbc\\", \\"abc\\") # Returns True can_form_word(\\"aab#bc@1\\", \\"B1\\") # Returns False can_form_word(\\"Example\\", \\"Apple\\") # Returns False can_form_word(\\"s!pec!i@al c#h@ar\\", \\"sp@r!\\") # Returns True ``` # Scenario Consider you are developing a feature for a spell-checking tool where users can create new words by rearranging letters from a given word list. This function will help verify whether new words formed by users are valid by ensuring they can be constructed from the specified character set. This utility needs to be efficient to handle large inputs quickly.","solution":"def can_form_word(source: str, target: str) -> bool: from collections import Counter source_counter = Counter(source) target_counter = Counter(target) for char, count in target_counter.items(): if source_counter[char] < count: return False return True"},{"question":"# Scenario You need to design a utility for managing a to-do list with tasks that have deadlines. This utility should be able to sort tasks based on their priority and then by the nearest deadline. # Problem Statement Write a function `sort_tasks(tasks: List[Dict[str, str]]) -> List[str]` that takes a list of tasks, each represented as a dictionary with the following keys: - \\"task\\": The task description (string) - \\"priority\\": The task priority (string, with values \\"high\\", \\"medium\\", and \\"low\\") - \\"deadline\\": The task deadline (string in the format \\"YYYY-MM-DD\\") The function should return a list of task descriptions sorted by the following rules: 1. Tasks with \\"high\\" priority first, followed by \\"medium\\", and then \\"low\\". 2. Within each priority level, tasks should be sorted by their nearest deadline. Input - `tasks` (List of dictionaries): A list of tasks with task descriptions, priorities, and deadlines. Output - `sorted_tasks` (List of strings): A list of task descriptions sorted based on priority and deadline rules. Function Signature ```python def sort_tasks(tasks: List[Dict[str, str]]) -> List[str]: pass ``` Constraints * The function should handle an empty list of tasks gracefully. * The \\"priority\\" key will always have a valid value (\\"high\\", \\"medium\\", or \\"low\\"). * The \\"deadline\\" key will always have a valid date in the \\"YYYY-MM-DD\\" format. * There should be no two tasks with the same description, priority, and deadline. Example ```python tasks = [ {\\"task\\": \\"Complete report\\", \\"priority\\": \\"high\\", \\"deadline\\": \\"2023-10-01\\"}, {\\"task\\": \\"Buy groceries\\", \\"priority\\": \\"medium\\", \\"deadline\\": \\"2023-10-02\\"}, {\\"task\\": \\"Schedule meeting\\", \\"priority\\": \\"high\\", \\"deadline\\": \\"2023-09-30\\"}, {\\"task\\": \\"Book flight tickets\\", \\"priority\\": \\"low\\", \\"deadline\\": \\"2023-10-01\\"}, {\\"task\\": \\"Go to gym\\", \\"priority\\": \\"medium\\", \\"deadline\\": \\"2023-09-28\\"}, ] expected_output = [ \\"Schedule meeting\\", \\"Complete report\\", \\"Go to gym\\", \\"Buy groceries\\", \\"Book flight tickets\\" ] result = sort_tasks(tasks) assert result == expected_output ``` Note Ensure your solution handles invalid or edge cases, and document any assumptions made.","solution":"from datetime import datetime from typing import List, Dict def sort_tasks(tasks: List[Dict[str, str]]) -> List[str]: def sort_key(task): priority_order = {\\"high\\": 1, \\"medium\\": 2, \\"low\\": 3} return (priority_order[task[\'priority\']], datetime.strptime(task[\'deadline\'], \\"%Y-%m-%d\\")) sorted_tasks = sorted(tasks, key=sort_key) return [task[\'task\'] for task in sorted_tasks] # Example tasks = [ {\\"task\\": \\"Complete report\\", \\"priority\\": \\"high\\", \\"deadline\\": \\"2023-10-01\\"}, {\\"task\\": \\"Buy groceries\\", \\"priority\\": \\"medium\\", \\"deadline\\": \\"2023-10-02\\"}, {\\"task\\": \\"Schedule meeting\\", \\"priority\\": \\"high\\", \\"deadline\\": \\"2023-09-30\\"}, {\\"task\\": \\"Book flight tickets\\", \\"priority\\": \\"low\\", \\"deadline\\": \\"2023-10-01\\"}, {\\"task\\": \\"Go to gym\\", \\"priority\\": \\"medium\\", \\"deadline\\": \\"2023-09-28\\"}, ] expected_output = [ \\"Schedule meeting\\", \\"Complete report\\", \\"Go to gym\\", \\"Buy groceries\\", \\"Book flight tickets\\" ] result = sort_tasks(tasks) assert result == expected_output"},{"question":"# Problem Statement Implement a function that merges two sorted lists into one sorted list. The two input lists are sorted in non-decreasing order, and you must ensure the resultant list is also sorted in non-decreasing order. # Function Signature ```python def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: pass ``` # Input * `list1`: A list of integers sorted in non-decreasing order. * `list2`: A list of integers sorted in non-decreasing order. * `0 <= len(list1), len(list2) <= 10^6` * `-10^9 <= list1[i], list2[i] <= 10^9` for `0 <= i < len(list1)` and `0 <= i < len(list2)` # Output * Returns a list of integers sorted in non-decreasing order, combining elements from both `list1` and `list2`. # Constraints * The function should maintain a time complexity of (O(m + n)), where `m` is the number of elements in `list1` and `n` is the number of elements in `list2`. # Example ```python assert merge_sorted_lists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] assert merge_sorted_lists([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6] assert merge_sorted_lists([], [1, 2, 3]) == [1, 2, 3] assert merge_sorted_lists([1, 2, 3], []) == [1, 2, 3] assert merge_sorted_lists([], []) == [] ``` # Special Requirements * Consider how you will handle edge cases such as empty lists. * Ensure that your function efficiently merges the two lists to handle the upper constraint limits.","solution":"def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: Merges two sorted lists into one sorted list in non-decreasing order. merged_list = [] i, j = 0, 0 # Traverse both lists and merge them in non-decreasing order while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # If there are remaining elements in list1 while i < len(list1): merged_list.append(list1[i]) i += 1 # If there are remaining elements in list2 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"Question Alignment with Wa-Tor Planet Simulation Extension The following question mirrors the complexity, style, and domain of the Wa-Tor planet simulation question, focusing on balancing dynamics in a system (this time involving forest fire simulation), while maintaining a similar scope and technical challenge. Forest Fire Simulation Extension The goal of this coding task is to extend the Forest Fire simulation model with additional functionality to create a balance between tree growth and fire spread, ensuring a dynamic and interesting environment over time. The current implementation allows for basic tree growth and fire propagation but requires more sophisticated control mechanisms. # Task 1. **Add Periodic Growth Cycles**: Modify the forest grid to support periodic tree growth cycles, ensuring that trees can grow back after a certain number of steps even in areas affected by fire. 2. **Implement Fire Suppression Mechanism**: Enhance the fire spread algorithm to randomly implement fire breaks, which can prevent the spread of fire across large areas: * Introduce a probability parameter for fire breaks where fires are stopped. * Apply periodic checks to adjust this probability based on current fire coverage. 3. **Optimize Propagation Efficiency**: Refactor the fire spread function to reduce unnecessary calculations and improve performance. # Input and Output - **Input**: None (except for constants and basic structure). - **Output**: Display console output showing enhanced simulation statistics, such as the number of trees grown and areas of fire suppression activity. # Constraints - **Initial Count**: Ensure that INITIAL_TREE_COUNT is respected. - **Max Coverage**: Ensure the forest does not exceed MAX_TREE_COVERAGE limit. - **Performance**: Simulation should run efficiently for at least 10,000 iterations with the current WIDTH, HEIGHT, and initial tree counts. # Requirements - **Periodic Growth**: Implement tree growth cycles that allow regrowth in cleared areas. - **Fire Suppression**: Introduce a fire break mechanism with adjustable probability checks. - **Efficiency**: Optimize fire spread calculations and tree growth processes. - **Output**: Update visualization to show trees regrown and fire break locations with enhanced real-time statistics. # Example ```python ff = ForestFire(WIDTH, HEIGHT) ff.time_passed = visualize ff.run(iteration_count=10_000) # The optimized version for enhanced running ``` Your task is to modify the `ForestFire` class. Ensure to add your new methods and update existing ones appropriately. You should not need to change the constants or general algorithm - focus on the added functionalities and optimizations.","solution":"from random import random, seed class ForestFire: TREE, FIRE, EMPTY = \'T\', \'F\', \'E\' GROWTH_CYCLE_LENGTH = 3 # Period of tree growth cycles FIRE_SUPPRESSION_PROB = 0.1 # Probability of fire suppression FIRE_SUPPRESSION_CHECK_FREQ = 10 # Frequency of checking fire suppression probability in iterations def __init__(self, width, height, initial_tree_count, max_tree_coverage): self.width = width self.height = height self.initial_tree_count = initial_tree_count self.max_tree_coverage = max_tree_coverage self.grid = [[self.EMPTY for _ in range(width)] for _ in range(height)] self.step_count = 0 self._initialize_forest() def _initialize_forest(self): seed(42) counter = 0 while counter < self.initial_tree_count: x, y = int(random() * self.width), int(random() * self.height) if self.grid[y][x] == self.EMPTY: self.grid[y][x] = self.TREE counter += 1 def step(self): self.step_count += 1 self.apply_fire() self.spread_fire() self.manage_fire_suppression() self.tree_growth() def apply_fire(self): for y in range(self.height): for x in range(self.width): if self.grid[y][x] == self.FIRE: self.grid[y][x] = self.EMPTY def spread_fire(self): new_grid = [row[:] for row in self.grid] for y in range(self.height): for x in range(self.width): if self.grid[y][x] == self.FIRE: for dy in (-1, 0, 1): for dx in (-1, 0, 1): ny, nx = y + dy, x + dx if 0 <= ny < self.height and 0 <= nx < self.width: if self.grid[ny][nx] == self.TREE and random() > self.FIRE_SUPPRESSION_PROB: new_grid[ny][nx] = self.FIRE self.grid = new_grid def manage_fire_suppression(self): if self.step_count % self.FIRE_SUPPRESSION_CHECK_FREQ == 0: fire_count = sum(row.count(self.FIRE) for row in self.grid) total_cells = self.width * self.height current_fire_coverage = fire_count / total_cells self.FIRE_SUPPRESSION_PROB = max(0.05, min(0.2, 1 - current_fire_coverage)) def tree_growth(self): if self.step_count % self.GROWTH_CYCLE_LENGTH == 0: for y in range(self.height): for x in range(self.width): if self.grid[y][x] == self.EMPTY and random() < 0.1: self.grid[y][x] = self.TREE def run(self, iteration_count): for _ in range(iteration_count): self.step() def print_grid(self): for row in self.grid: print(\'\'.join(row)) print(\\"n\\" + (\\"-\\" * self.width))"},{"question":"# Problem Statement You need to implement a simplified version of a file system and support basic operations such as creating directories, navigating directories, and listing directory contents. Function Signature ```python class FileSystem: def __init__(self) -> None: Initialize an empty file system with a root directory. pass def mkdir(self, path: str) -> None: Create a directory at the given path. pass def cd(self, path: str) -> None: Change the current directory to the specified path. pass def ls(self) -> str: List the contents of the current directory. pass ``` # Specifications - **Input Format**: A series of calls to the `mkdir`, `cd`, and `ls` methods. - **Output Format**: The results of the `ls` method calls. - **Constraints**: - Paths will be provided in Unix-like format, e.g., `/a/b/c`. - Commands will not attempt to create a directory in a non-existent path. - You will start in the root directory `/`. - You may assume that paths and directory names consist only of lowercase letters. # Example ```python fs = FileSystem() fs.mkdir(\\"/a\\") fs.mkdir(\\"/a/b\\") fs.cd(\\"/a\\") fs.mkdir(\\"/c\\") print(fs.ls()) # Output: [\'b\', \'c\'] fs.cd(\\"/a/b\\") fs.mkdir(\\"/d\\") fs.cd(\\"/\\") print(fs.ls()) # Output: [\'a\'] fs.cd(\\"/a/b\\") print(fs.ls()) # Output: [\'d\'] ``` # Notes 1. Implement the solution using a dictionary structure to represent the file system tree. 2. Ensure the solution handles edge cases such as navigating to non-existent directories or creating directories that already exist. 3. Directory paths should be adjusted to relative paths whenever navigating through the file system.","solution":"from typing import List class FileSystem: def __init__(self) -> None: self.fs = {\'/\': {}} self.current_path = \\"/\\" def mkdir(self, path: str) -> None: dirs = path.strip(\'/\').split(\'/\') current = self.fs[\'/\'] for d in dirs: if d not in current: current[d] = {} current = current[d] def cd(self, path: str) -> None: if path == \\"/\\": self.current_path = path return dirs = path.strip(\'/\').split(\'/\') current = self.fs[\'/\'] for d in dirs: if d in current: current = current[d] else: raise Exception(f\\"Directory \'{d}\' not found\\") self.current_path = path def ls(self) -> List[str]: if self.current_path == \\"/\\": current = self.fs[\'/\'] else: dirs = self.current_path.strip(\'/\').split(\'/\') current = self.fs[\'/\'] for d in dirs: current = current[d] return sorted(current.keys())"},{"question":"# Scenario In competitive programming and algorithm challenges, it is common to transform and manipulate data structures efficiently. One such task involves rotating a matrix 90 degrees to the right. You are tasked with implementing a function that performs this operation on an `n x n` matrix. # Objective Write a Python function named `rotate_matrix` that accepts an `n x n` matrix (a list of lists) and returns a new matrix representing the original matrix rotated 90 degrees to the right. # Function Signature ```python def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: pass ``` # Input 1. `matrix` (list of list of int): A list of `n` lists, each containing `n` integers representing an `n x n` matrix. # Output * Returns a new `n x n` matrix (list of lists) that is the input matrix rotated 90 degrees to the right. # Constraints * The input matrix is guaranteed to be a non-empty square matrix (i.e., the number of rows is equal to the number of columns). # Requirements 1. The function should handle matrices with a variety of integer values, including negative and positive numbers. 2. Input validation must ensure that the input is a valid `n x n` matrix (i.e., all rows are of the same length). # Examples ```python >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix([[1]]) [[1]] >>> rotate_matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) [[0, 0, 1], [0, 1, 0], [1, 0, 0]] ``` # Notes * The solution should be efficient and work correctly for both small and large matrices. * Ensure your solution handles edge cases such as the minimal matrix size (`1 x 1`). Provide clear documentation and explanations for your code, including any assumptions or decisions made during implementation.","solution":"def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: Rotates the given n x n matrix 90 degrees to the right. Args: matrix (list of list of int): A list of n lists, each containing n integers representing an n x n matrix. Returns: list of list of int: New n x n matrix rotated 90 degrees to the right. n = len(matrix) # Create a new matrix initialized with zeros rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - i - 1] = matrix[i][j] return rotated_matrix"},{"question":"# Coding Problem: Find the Lexicographically Smallest Permutation Context Given a positive integer `n`, you are required to find the lexicographically smallest permutation of an array containing the elements `[1, 2, 3, ..., n]` such that no element remains in its initial position. Problem Statement Write a function `smallest_derangement(n: int) -> List[int]` that returns the lexicographically smallest permutation (derangement) of the array `[1, 2, 3, ..., n]` where no element `i` appears at index `i-1`. Function Signature ```python from typing import List def smallest_derangement(n: int) -> List[int]: pass ``` Input * A single integer `n` (2 ≤ n ≤ 1,000,000). Output * A list of integers representing the lexicographically smallest permutation where no element is in its initial position. Example ```python print(smallest_derangement(3)) # Output: [2, 3, 1] print(smallest_derangement(4)) # Output: [2, 1, 4, 3] ``` Constraints * Your function should operate efficiently even for large inputs. * Aim for a time complexity of approximately O(n). * The algorithm should utilize space proportional to the input size, avoiding excessive allocations. # Notes * A derangement of a set is a permutation where no element appears in its original position. * The lexicographically smallest permutation is the smallest possible permutation when sorted in dictionary order. * For a given integer `n`, ensure the array contains a valid derangement and maintains the lexicographic order. # Implementation Guideline 1. Start with the array `[1, 2, 3, ..., n]`. 2. Swap each element at index `i` with the next element to ensure no element remains at its original position. 3. If `n` is odd, adjust the last two elements post the general swapping to maintain the derangement property. Good luck!","solution":"from typing import List def smallest_derangement(n: int) -> List[int]: if n == 2: return [2, 1] derangement = list(range(1, n + 1)) for i in range(0, n - 1, 2): derangement[i], derangement[i + 1] = derangement[i + 1], derangement[i] if n % 2 == 1: derangement[-1], derangement[-2] = derangement[-2], derangement[-1] return derangement"},{"question":"# Queue Using Two Stacks You are required to implement a Queue data structure using two stacks. Specifically, you will be designing a class that supports standard queue operations such as enqueue (to add an element to the back of the queue), dequeue (to remove an element from the front of the queue), and checking if the queue is empty. Additionally, implement a method to return the current size of the queue and a method to return the front element without removing it. Implementation Details: 1. Create a `Queue` class that internally uses two stacks to manage the elements. 2. Implement the following methods: - `enqueue(value: int) -> None`: Add an element to the back of the queue. - `dequeue() -> int`: Remove and return the front element of the queue. - `peek() -> int`: Return the front element without removing it. - `is_empty() -> bool`: Check if the queue is empty. - `size() -> int`: Return the current size of the queue. Constraints: - Each operation (enqueue, dequeue, peek, is_empty, and size) should run in amortized O(1) time. - You may assume that all operations are called in a way that does not cause the underlying stacks to underflow. Example Usage: ```python >>> q = Queue() >>> q.enqueue(1) >>> q.enqueue(2) >>> q.enqueue(3) >>> assert q.peek() == 1 >>> assert q.dequeue() == 1 >>> assert q.is_empty() == False >>> assert q.size() == 2 >>> assert q.dequeue() == 2 >>> assert q.dequeue() == 3 >>> assert q.is_empty() == True ``` Submit your implementation with the following class signature: ```python class Queue: def __init__(self) -> None: self.stack1 = [] self.stack2 = [] def enqueue(self, value: int) -> None: pass def dequeue(self) -> int: pass def peek(self) -> int: pass def is_empty(self) -> bool: pass def size(self) -> int: pass ```","solution":"class Queue: def __init__(self) -> None: self.stack1 = [] self.stack2 = [] def enqueue(self, value: int) -> None: self.stack1.append(value) def dequeue(self) -> int: if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() def peek(self) -> int: if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2[-1] def is_empty(self) -> bool: return not self.stack1 and not self.stack2 def size(self) -> int: return len(self.stack1) + len(self.stack2)"},{"question":"# Problem Statement: Longest Mountain in Array A mountain array is defined as an array that: 1. Has at least three elements. 2. Has a peak element that is not the first or last element in the array. 3. Consists of an increasing sequence of integers followed by a decreasing sequence of integers. Given an integer array `arr`, you need to determine the length of the longest mountain subarray. If there is no mountain subarray in the array, return 0. # Function Requirements You need to implement the following function: - `longest_mountain(arr: [int]) -> int`: This function takes a list of integers `arr` and returns the length of the longest mountain subarray within `arr`. If no such subarray exists, return 0. # Input - `arr`: A list of integers where ( (1 leq text{len(arr)} leq 10^4) ) and ( (-10^4 leq arr[i] leq 10^4) ). # Output - An integer representing the length of the longest mountain subarray in `arr`. If no mountain subarray exists, return 0. # Example ```python >>> longest_mountain([2, 1, 4, 7, 3, 2, 5]) 5 >>> longest_mountain([2, 2, 2]) 0 >>> longest_mountain([1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1, 0]) 12 ``` # Constraints - The input list `arr` must have at least 1 and not more than 10,000 integers. - All integers in `arr` are within the range ([-10^4, 10^4]). # Hint - you can use a two-pointer approach or dynamic programming to find the length of the longest mountain subarray efficiently.","solution":"def longest_mountain(arr): Returns the length of the longest mountain subarray within arr. If no such subarray exists, return 0. n = len(arr) if n < 3: return 0 longest = 0 for i in range(1, n - 1): if arr[i - 1] < arr[i] > arr[i + 1]: left = i - 1 while left > 0 and arr[left - 1] < arr[left]: left -= 1 right = i + 1 while right < n - 1 and arr[right] > arr[right + 1]: right += 1 current_mountain_length = right - left + 1 longest = max(longest, current_mountain_length) return longest"},{"question":"# Binary Search Tree to Sorted Array Conversion You are tasked with designing a function that converts a Binary Search Tree (BST) into a sorted array. Given a BST, the function should return an array containing the values of the nodes in ascending order. Function Signature ```python def bst_to_sorted_array(root: Optional[TreeNode]) -> List[int]: pass ``` # Input - `root` (Optional[TreeNode]): The root node of the Binary Search Tree. If the tree is empty, the root will be `None`. # Output - A list of integers: A sorted list of values from the BST in ascending order. # Constraints - The values in the BST are unique. - The number of nodes in the BST ranges from 0 to 10^4. - Node values are integer numbers that fit within the standard integer range. # Example * Given the BST below: 5 / 3 7 / 2 4 8 Running `bst_to_sorted_array` should return `[2, 3, 4, 5, 7, 8]`. # Implementation To achieve this, you need to perform an in-order traversal of the BST, which naturally visits nodes in increasing order for a BST. # Edge Cases - An empty tree should return an empty list (`[]`). - A tree with one node should return a list with that single value (`[value]`). Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example BST: # 5 # / # 3 7 # / # 2 4 8 root = TreeNode(5) root.left = TreeNode(3, TreeNode(2), TreeNode(4)) root.right = TreeNode(7, None, TreeNode(8)) assert bst_to_sorted_array(root) == [2, 3, 4, 5, 7, 8] assert bst_to_sorted_array(None) == [] ``` Implement this function ensuring that it handles all edge cases and constraints appropriately.","solution":"from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bst_to_sorted_array(root: Optional[TreeNode]) -> List[int]: def inorder_traversal(node: Optional[TreeNode], result: List[int]): if node: inorder_traversal(node.left, result) result.append(node.val) inorder_traversal(node.right, result) sorted_array = [] inorder_traversal(root, sorted_array) return sorted_array"},{"question":"# Stock Price Trend Calculation Problem Statement You are developing a financial application that analyses stock prices and determines the trend of a stock over a period of time. For a given list of daily stock prices over a specified number of days, your goal is to implement functions that calculate the simple moving average (SMA), determine the trend as \'uptrend\', \'downtrend\', or \'steady\', and provide a recommendation based on the trend. Function Specifications 1. **Function 1: `calculate_sma(prices: list[float], window: int) -> list[float]`** * **Input**: - `prices` - A list of floating-point numbers representing daily stock prices. - `window` - An integer representing the number of days over which to calculate the SMA. * **Output**: A list of floating-point numbers representing the SMA for each day that has enough previous days to form a window. 2. **Function 2: `determine_trend(sma: list[float]) -> str`** * **Input**: `sma` - A list of floating-point numbers representing the SMA over time. * **Output**: A string value which can be: - `\'uptrend\'` if the SMA is consistently increasing, - `\'downtrend\'` if the SMA is consistently decreasing, - `\'steady\'` if there is no clear upward or downward trend. 3. **Function 3: `recommend_trade(trend: str) -> str`** * **Input**: `trend` - A string representing the trend of the stock. * **Output**: A string value which can be: - `\'buy\'` if the trend is `\'uptrend\'`, - `\'sell\'` if the trend is `\'downtrend\'`, - `\'hold\'` if the trend is `\'steady\'`. Constraints * The list of prices must be non-empty and the window size must be a positive integer less than or equal to the length of the list. * Use efficient list and mathematical operations to ensure performance, especially with large datasets. Performance Requirements * Ensure that calculations for SMA, trend determination, and recommendations are performed efficiently. Example ```python prices = [100.0, 102.0, 104.0, 103.0, 107.0, 109.0, 112.0, 110.0] window = 3 # Expected output calls sma = calculate_sma(prices, window) # [102.0, 103.0, 104.66666666666667, 106.33333333333333, 109.33333333333333, 110.33333333333333] trend = determine_trend(sma) # \'uptrend\' recommendation = recommend_trade(trend) # \'buy\' ``` **Note**: Use appropriate list comprehensions and mathematical functions to handle the calculations efficiently. Test the functions with various scenarios to ensure correctness and robustness. Implement these functions ensuring they perform correctly and efficiently. Validate your functions with different stock price lists to confirm their accuracy.","solution":"def calculate_sma(prices, window): Calculate the simple moving average (SMA) over a window for a list of prices. if len(prices) == 0 or window <= 0 or window > len(prices): raise ValueError(\\"Invalid input\\") sma = [] for i in range(len(prices) - window + 1): window_average = sum(prices[i:i + window]) / window sma.append(window_average) return sma def determine_trend(sma): Determine the trend from a list of SMA values. if len(sma) < 2: return \'steady\' is_increasing = all(sma[i] < sma[i + 1] for i in range(len(sma) - 1)) is_decreasing = all(sma[i] > sma[i + 1] for i in range(len(sma) - 1)) if is_increasing: return \'uptrend\' elif is_decreasing: return \'downtrend\' else: return \'steady\' def recommend_trade(trend): Recommend a trade action based on the trend. if trend == \'uptrend\': return \'buy\' elif trend == \'downtrend\': return \'sell\' else: return \'hold\'"},{"question":"Find Intersection Point of Two Linked Lists # Context Two singly linked lists intersect at some point and merge into a single linked list from that point onwards. Given the heads of these two singly linked lists, your task is to find the node at which the two linked lists intersect and return the value of that node. # Input 1. Two instances of `LinkedListNode` representing the heads of the linked lists. # Output 1. An integer value representing the value of the intersection node. # Constraints 1. The elements of the linked lists are integers. 2. The two linked lists can be of different lengths. 3. Assume that the linked lists do not contain cycles. 4. If the two linked lists do not intersect, return `None`. # Performance Requirements 1. The time complexity should be O(n + m), where n and m are the lengths of the two linked lists. 2. The space complexity should be O(1). # Function Definition ```python def get_intersection_node(headA: LinkedListNode, headB: LinkedListNode) -> int: pass ``` # Example ```python # Example Case 1 # Input: # List A: 4 -> 1 -> 8 -> 4 -> 5 # List B: 5 -> 0 -> 1 -> 8 -> 4 -> 5 # Output: # 8 headA = LinkedListNode([4, 1, 8, 4, 5]) headB = LinkedListNode([5, 0, 1, 8, 4, 5]) print(get_intersection_node(headA, headB)) # Output: 8 # Example Case 2 # Input: # List A: 2 -> 6 -> 4 # List B: 1 -> 5 # Output: # None headA = LinkedListNode([2, 6, 4]) headB = LinkedListNode([1, 5]) print(get_intersection_node(headA, headB)) # Output: None ``` # Notes 1. You can assume that the `LinkedListNode` class is defined with an `__init__` method that accepts an iterable for initialization and properly sets up the next pointers. 2. You should handle the embedded linked list intersections correctly by comparing their nodes, rather than their values. 3. Carefully consider edge cases, such as one or both linked lists being empty.","solution":"class LinkedListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def get_intersection_node(headA: LinkedListNode, headB: LinkedListNode) -> int: if not headA or not headB: return None # Create two pointers for both lists pointerA, pointerB = headA, headB # Traverse through both lists while pointerA is not pointerB: # Move to next node or to the other list\'s head if at the end pointerA = pointerA.next if pointerA else headB pointerB = pointerB.next if pointerB else headA # Both pointers will be either at the intersection node or at None return pointerA.value if pointerA else None"},{"question":"# Scenario You are building a small library for basic arithmetic operations and need to create a function that calculates the Least Common Multiple (LCM) of a given list of integers. The LCM is widely used in various mathematical and engineering applications, so it\'s essential to have this functionality available. # Problem Statement Implement a Python function called `least_common_multiple` that computes the Least Common Multiple of a given list of integers. # Function Signature ```python def least_common_multiple(nums: list[int]) -> int: ``` # Inputs * `nums`: A list of integers. There will be at least one integer in the list. # Outputs * An integer representing the least common multiple of the input list. # Constraints * The function must raise a `ValueError` with the message \\"List contains zero or negative numbers\\" if any element in the input list is zero or negative. * The function should handle standard positive integers only. * Utilize efficient algorithms to handle potential large LCM values. # Performance Requirements * The solution should have a time complexity that is efficient for the task at hand given the constraints. # Example ```python assert least_common_multiple([4, 5]) == 20 assert least_common_multiple([2, 3, 5]) == 30 assert least_common_multiple([6, 8, 12]) == 24 try: least_common_multiple([0, 6]) except ValueError as e: assert str(e) == \\"List contains zero or negative numbers\\" try: least_common_multiple([-3, 5]) except ValueError as e: assert str(e) == \\"List contains zero or negative numbers\\" ``` Implement the `least_common_multiple` function to meet the given requirements, ensuring robust handling of edge cases. Write clean and efficient code that adheres to best practices.","solution":"import math from functools import reduce def least_common_multiple(nums: list[int]) -> int: Returns the least common multiple (LCM) of the given list of integers. Raises a ValueError if any number in the input list is zero or negative. # Check for invalid input if any(x <= 0 for x in nums): raise ValueError(\\"List contains zero or negative numbers\\") def lcm(a, b): return a * b // math.gcd(a, b) return reduce(lcm, nums)"},{"question":"# Coding Question You need to develop a program that simulates a simplified stock trading platform. The program should allow users to perform essential operations such as buying stocks, selling stocks, and viewing their portfolio. The functionality should ensure that users cannot sell more stocks than they own and that their account balance is always updated correctly. Objective Design a set of functions that allow users to perform and validate trading operations efficiently. 1. **Develop Functions**: - Create the `buy_stock` function to handle the purchase of stocks, including updating the stock count and deducting the total price from the account balance. - Create the `sell_stock` function to allow selling of stocks, updating the stock count and adding the sale amount back to the account balance. Ensure that users cannot sell more stocks than they own. - Create the `view_portfolio` function to display the user\'s holdings and account balance. 2. **Implement Input Validation**: - Ensure that users enter valid numerical values for stock prices and quantities. - Implement checks to ensure that users do not have a negative account balance after any transaction. Function Implementations - **buy_stock(account_balance: float, stock_count: int, stock_price: float, quantity: int) -> tuple[float, int]**: - Input: Current account balance, current stock count, price per stock, and quantity of stocks to buy. - Output: Returns updated account balance and updated stock count. - **sell_stock(account_balance: float, stock_count: int, stock_price: float, quantity: int) -> tuple[float, int]**: - Input: Current account balance, current stock count, price per stock, and quantity of stocks to sell. - Output: Returns updated account balance and updated stock count. - **view_portfolio(account_balance: float, stock_count: int) -> None**: - Input: Current account balance, current stock count. - Output: Prints the current account balance and stock count. Example Here is an example session demonstrating the usage of the functions. ```python >>> account_balance = 1000.0 >>> stock_count = 0 >>> account_balance, stock_count = buy_stock(account_balance, stock_count, 50.0, 5) >>> print(account_balance, stock_count) 750.0, 5 >>> account_balance, stock_count = sell_stock(account_balance, stock_count, 50.0, 2) >>> print(account_balance, stock_count) 850.0, 3 >>> view_portfolio(account_balance, stock_count) Account Balance: 850.0 Stock Count: 3 ``` When composing your functions, ensure proper error handling and validation. Additionally, make sure that the program logic is clear and straightforward for the user to interact with.","solution":"def buy_stock(account_balance: float, stock_count: int, stock_price: float, quantity: int) -> tuple[float, int]: Handles the purchase of stocks, updating the stock count and deducting the total price from the account balance. :param account_balance: Current account balance :param stock_count: Current stock count :param stock_price: Price per stock :param quantity: Quantity of stocks to buy :return: Updated account balance and updated stock count :raises ValueError: If the total cost exceeds the account balance or if the quantity is invalid. if quantity <= 0: raise ValueError(\\"Quantity must be a positive integer.\\") total_cost = stock_price * quantity if total_cost > account_balance: raise ValueError(\\"Insufficient balance to complete purchase.\\") account_balance -= total_cost stock_count += quantity return account_balance, stock_count def sell_stock(account_balance: float, stock_count: int, stock_price: float, quantity: int) -> tuple[float, int]: Allows selling of stocks, updating the stock count and adding the sale amount back to the account balance. :param account_balance: Current account balance :param stock_count: Current stock count :param stock_price: Price per stock :param quantity: Quantity of stocks to sell :return: Updated account balance and updated stock count :raises ValueError: If the quantity exceeds the stock count or if the quantity is invalid. if quantity <= 0: raise ValueError(\\"Quantity must be a positive integer.\\") if quantity > stock_count: raise ValueError(\\"Cannot sell more stocks than you own.\\") total_sale = stock_price * quantity account_balance += total_sale stock_count -= quantity return account_balance, stock_count def view_portfolio(account_balance: float, stock_count: int) -> None: Displays the user\'s current holdings and account balance. :param account_balance: Current account balance :param stock_count: Current stock count print(f\\"Account Balance: {account_balance:.2f}\\") print(f\\"Stock Count: {stock_count}\\")"},{"question":"# Dividing Substrings You are given a string consisting of lowercase English letters. A substring is referred to as any contiguous sequence of characters within the string. Write a program that divides the string such that each part contains unique characters (no repetitions within each part). The goal is to determine the minimum number of parts needed such that each substring consists of unique characters. Task Implement a function `min_parts_with_unique_chars` that divides the string into the minimum number of parts, each containing unique characters. Your Task 1. **Function Definition** Implement the following function in Python: ```python def min_parts_with_unique_chars(s: str) -> int: # Your implementation here ``` 2. **Inputs** The function will receive: - `s`: A string of lowercase English letters. 3. **Expected Output** - The function should return an integer representing the minimum number of sub-parts required such that each substring has all unique characters. 4. **Constraints** - The length of the string will be between 1 and 1000 inclusive. 5. **Performance Requirements** - The time complexity should be linear concerning the length of the string. Example Example 1: - Input: `s = \\"abac\\"` - Output: `2` - Explanation: The string can be divided into [\\"ab\\", \\"ac\\"]. Example 2: - Input: `s = \\"abcdef\\"` - Output: `1` - Explanation: The string already contains unique characters, so only one part is needed. Example 3: - Input: `s = \\"aaaa\\"` - Output: `4` - Explanation: Each character needs to be in its own part. Additional Instructions 1. Consider edge cases, such as very long strings with many repeated characters. 2. Ensure your code is clean, well-commented, and follows good programming practices. 3. Use efficient data structures to optimize performance during substring checks and splits.","solution":"def min_parts_with_unique_chars(s: str) -> int: Divides the string into the minimum number of parts, each containing unique characters. Parameters: s (str): The string to be divided. Returns: int: The minimum number of parts with unique characters. if not s: return 0 parts = 1 seen_chars = set() for char in s: if char in seen_chars: parts += 1 seen_chars = {char} else: seen_chars.add(char) return parts"},{"question":"# Coding Question Objective Write a function `evaluate_polynomial` that evaluates a polynomial for a given value of `x`. The function should accept a list of coefficients representing the polynomial and a float value `x`, and return the evaluated result as a float. Function Signature ```python def evaluate_polynomial(coeffs: list, x: float) -> float: pass ``` Input * `coeffs`: A list of float or integer values representing the coefficients of the polynomial in decreasing order of their powers. * `x`: A float representing the value at which to evaluate the polynomial. Output * A float representing the evaluated result of the polynomial. Constraints * The function should raise a `ValueError` if `coeffs` is an empty list. * The function should handle large coefficients and large values of `x` efficiently, using Horner\'s method to achieve optimal performance. Examples ```python >>> evaluate_polynomial([2, 0, 3], 3) 21.0 # Corresponds to 2*(3^2) + 0*(3^1) + 3*(3^0) >>> evaluate_polynomial([1, -4, 4], 2) 0.0 # Corresponds to 1*(2^2) - 4*(2^1) + 4*(2^0) >>> evaluate_polynomial([0, 0, 0], 5) 0.0 # Corresponds to an all-zeros polynomial, always 0 >>> evaluate_polynomial([], 2) Traceback (most recent call last): ... ValueError: Coefficients list cannot be empty. ``` Additional Requirements * The function should be optimized for performance with O(n) time complexity using Horner\'s method. * The function should handle edge cases effectively and raise appropriate exceptions for invalid inputs. * Include error handling to manage incorrect inputs and raise relevant error messages.","solution":"def evaluate_polynomial(coeffs: list, x: float) -> float: Evaluates a polynomial for a given value of x using Horner\'s method. Parameters: coeffs (list): A list of float or integer values representing the coefficients of the polynomial in decreasing order of their powers. x (float): The value at which to evaluate the polynomial. Returns: float: The evaluated result of the polynomial. Raises: ValueError: If the coefficients list is empty. if not coeffs: raise ValueError(\\"Coefficients list cannot be empty.\\") result = coeffs[0] for coeff in coeffs[1:]: result = result * x + coeff return float(result)"},{"question":"# Objective: Write a Python function that takes a list of integers and returns a new list with duplicate values removed while maintaining the original order of elements. # Problem Statement: You are asked to create a function that will take a list of integers and return a new list with all duplicates removed, but with the original order of first appearances preserved. Your function should handle lists of varying lengths, including empty lists. # Function Signature: ```python def remove_duplicates(nums: list[int]) -> list[int]: ``` # Input: - `nums`: a list of integers. # Output: - A new list containing the elements of the input list without duplicates, preserving the order of their first occurrence. # Constraints: - All elements of the list are integers. - The list can be empty. - The list can contain negative and positive integers, including zero. # Examples: ```python >>> remove_duplicates([1, 2, 3, 2, 4, 1]) [1, 2, 3, 4] >>> remove_duplicates([5, 5, 5, 5]) [5] >>> remove_duplicates([]) [] >>> remove_duplicates([7, 8, 9, 7, 8, 9, 10]) [7, 8, 9, 10] >>> remove_duplicates([10, -10, 10, -10]) [10, -10] ``` # Requirements: - Implement the function according to the signature and constraints. - Ensure the function properly handles the removal of duplicates while maintaining the order of first appearances. - The function should be efficient in handling large lists with multiple duplicates.","solution":"def remove_duplicates(nums: list[int]) -> list[int]: Removes duplicate values from the list while preserving the original order of first appearances. :param nums: List of integers :return: A new list of integers with duplicates removed seen = set() result = [] for num in nums: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"# Coding Question Problem Statement You are required to implement a function `deep_flatten` that flattens a nested list of arbitrary depth. Your function should return a new list containing all the elements in the original list, flattened to a single level. Function Signature ```python def deep_flatten(nested_list: list) -> list: pass ``` Input and Output Requirements * **Input**: - `nested_list` (list): A list which can contain nested lists of arbitrary depth. * **Output**: - Returns a single list with all elements from the original nested list flattened. Constraints * The input list can contain any mix of integers, strings, and nested lists. * The function should handle nested lists of varying depths. * The function should retain the order of elements as they appear in the original nested list, including handling empty lists. Examples 1. `deep_flatten([1, [2, [3, 4]], 5])` should return `[1, 2, 3, 4, 5]` 2. `deep_flatten([[\\"a\\", [\\"b\\", \\"c\\"], []], \\"d\\"])` should return `[\'a\', \'b\', \'c\', \'d\']` 3. `deep_flatten([])` should return `[]` 4. `deep_flatten([1, [2, [], 3], [4, [5, 6]]])` should return `[1, 2, 3, 4, 5, 6]` Make sure your implementation is efficient and handles all possible edge cases gracefully.","solution":"def deep_flatten(nested_list): Flattens a nested list of arbitrary depth. Args: nested_list (list): A list which can contain nested lists of arbitrary depth. Returns: list: A flattened list. flat_list = [] for element in nested_list: if isinstance(element, list): flat_list.extend(deep_flatten(element)) else: flat_list.append(element) return flat_list"},{"question":"# Coding Assessment Question Problem Statement: Write a Python function that takes a list of integers and returns a new list that contains only the prime numbers from the original list. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Functional Requirements: - Implement a function `filter_primes` that takes a list of integers as input and returns a list of prime numbers. - The function should efficiently check for the primality of each number in the input list. Input: - A list of integers: `filter_primes(numbers: List[int]) -> List[int]` Output: - A list of integers containing only the prime numbers from the input list. Example: ```python >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([11, 13, 17, 19, 23, 29]) [11, 13, 17, 19, 23, 29] >>> filter_primes([15, 21, 22, 24, 25]) [] ``` Constraints: - The input list can contain up to 10,000 integers. - Each integer in the list will be non-negative and can be as large as 1,000,000. - Your function should be optimized for performance given the constraint on input size and number range. Notes: - You can use helper functions within your solution to improve readability and modularity. - Consider edge cases, such as the presence of 0 and 1 in the list, since neither are prime numbers.","solution":"from typing import List def is_prime(n: int) -> bool: Returns True if n is a prime number, else False. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False max_divisor = int(n**0.5) + 1 for d in range(3, max_divisor, 2): if n % d == 0: return False return True def filter_primes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the input list. return [num for num in numbers if is_prime(num)]"},{"question":"# Problem Statement You are tasked with writing a function that examines and validates the structure of a given email address, according to specific criteria. Your task is to write a function `is_valid_email(email_address: str) -> bool`. # Function Definition 1. **is_valid_email** ```python def is_valid_email(email_address: str) -> bool | ValueError: Input Parameters: ----------------- email_address: The email address to be validated as a string. Returns: -------- A boolean indicating whether the email address is valid based on the given criteria. Raises a ValueError if the input is not a string or if it is an empty string. ``` # Validation Criteria - The email address must start with an alphanumeric character. - The email address must contain exactly one \'@\' symbol. - The domain part (the section following the \'@\') must contain at least one dot (\'.\') and have at least one character (a-z, 0-9) between the \'@\' and the dot. - The domain part must end with a top-level domain (TLD) like \\".com\\", \\".net\\", \\".org\\", etc., which is between 2 to 6 characters long. - The email address should only contain alphanumeric characters, dots, hyphens, or underscores. # Constraints * The email address should be a non-empty string. If the input is not a string or is empty, raise a `ValueError`. # Example Scenarios: **Example 1**: ```python # Valid email address is_valid_email(\\"example.user@domain.com\\") # Expected: True # Valid with subdomain is_valid_email(\\"example.user@mail.server.info\\") # Expected: True # Invalid email due to multiple \'@\' symbols is_valid_email(\\"example@user@domain.com\\") # Expected: False ``` **Example 2**: ```python # Invalid due to missing domain part is_valid_email(\\"example.user@\\") # Expected: False # Invalid due to missing local part is_valid_email(\\"@domain.com\\") # Expected: False # Valid email with allowed special characters is_valid_email(\\"user_name@domain.co.uk\\") # Expected: True ``` **Example 3**: ```python # Invalid due to invalid TLD length is_valid_email(\\"user@dom.longtld\\") # Expected: False # Input is not a string is_valid_email(123) # Expected: ValueError(\'Input Error: Email address must be a non-empty string.\') # Empty string input is_valid_email(\\"\\") # Expected: ValueError(\'Input Error: Email address must be a non-empty string.\') ```","solution":"import re def is_valid_email(email_address: str) -> bool: Validate the given email address based on specified criteria. Parameters: ----------- email_address: str The email address to be validated. Returns: -------- bool A boolean indicating whether the email address is valid based on the given criteria. Raises: ------- ValueError If the input is not a string or if it is an empty string. if not isinstance(email_address, str) or not email_address: raise ValueError(\'Input Error: Email address must be a non-empty string.\') # Regular expression for validating an Email regex = r\'^[A-Za-z0-9][A-Za-z0-9._-]*@[A-Za-z0-9.-]+.[A-Za-z]{2,6}\' # Matching the regular expression if re.match(regex, email_address): return True return False"},{"question":"**[Question 2]**: **You are given a singly linked list. Implement a function that checks if the linked list is a palindrome.** # Objective Your task is to write a function `is_palindrome` that takes the head of a singly linked list as input and returns `True` if the linked list is a palindrome, and `False` otherwise. # Function Signature ```python def is_palindrome(head: ListNode) -> bool: ``` # Input The function `is_palindrome` should take a single argument: - `head`: The head node of the singly linked list (ListNode object). # Output The function should return a boolean: - `True` if the linked list is a palindrome. - `False` otherwise. # Constraints - The list can have between 0 and 10^4 nodes. - Each node’s data value is an integer ranging from -10^4 to 10^4. # Example Consider the linked list representation: 1 -> 2 -> 3 -> 2 -> 1 Calling `is_palindrome(head)` should return `True` because the linked list is identical when read from both directions. # Edge Cases 1. A null head should return `True` (an empty list is a palindrome). 2. A single-node list should return `True`. 3. A list with two different elements should return `False`. # Notes - Use the ListNode class provided in the snippet. - The solution should handle large lists efficiently. Consider using a two-pointer technique to achieve O(n) time complexity and O(1) space complexity. - Ensure the list\'s original structure is maintained after checking for palindrome measures.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome(head: ListNode) -> bool: if not head or not head.next: return True # Function to find the middle of the linked list def find_middle(node): slow, fast = node, node while fast and fast.next: slow = slow.next fast = fast.next.next return slow # Function to reverse the second half of the linked list def reverse(node): prev, curr = None, node while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp return prev # Find the middle of the list middle = find_middle(head) # Reverse the second half second_half_start = reverse(middle) # Check palindrome first_half_start = head second_half_copy = second_half_start result = True while second_half_start: if first_half_start.val != second_half_start.val: result = False break first_half_start = first_half_start.next second_half_start = second_half_start.next # Restore the second half reverse(second_half_copy) return result"},{"question":"# Question: Implementing and Comparing Different Sorting Algorithms You are tasked with implementing three different sorting algorithms: Bubble Sort, Insertion Sort, and Merge Sort. Once implemented, you will compare their performance on different datasets using the provided benchmark function. **Function Signatures:** ```python def bubble_sort(arr: List[int]) -> List[int]: pass def insertion_sort(arr: List[int]) -> List[int]: pass def merge_sort(arr: List[int]) -> List[int]: pass ``` # Objectives: 1. Implement the `bubble_sort` function to sort a list of integers using the Bubble Sort algorithm. 2. Implement the `insertion_sort` function to sort a list of integers using the Insertion Sort algorithm. 3. Implement the `merge_sort` function to sort a list of integers using the Merge Sort algorithm. 4. Benchmark the performance of your implementations using the `benchmark_sorting_algorithms` function. # Constraints: * The elements of the input list (`arr`) will be integers between -10^6 and 10^6. * The length of the input list (`arr`) will be between 1 and 10^4. # Examples: ```python >>> bubble_sort([4, 2, 7, 1, 3]) [1, 2, 3, 4, 7] >>> insertion_sort([10, 5, 3, 8, 4]) [3, 4, 5, 8, 10] >>> merge_sort([9, 7, 5, 11, 12, 2]) [2, 5, 7, 9, 11, 12] ``` # Guidelines: 1. Your implementations should efficiently sort the input list of integers. 2. Ensure that each algorithm is correctly implemented according to its standard procedure. 3. Use the following `benchmark_sorting_algorithms` function to compare the performance of your implementations: ```python import timeit from typing import List def benchmark_sorting_algorithms() -> None: Benchmark code for comparing 3 sorting functions: Bubble Sort, Insertion Sort, and Merge Sort. def do_benchmark(arr: List[int], title: str) -> None: setup = \\"import __main__ as z\\" print(f\\"Benchmark for {title}:\\") arr_copy = arr[:] timing = timeit.timeit(lambda: bubble_sort(arr_copy), number=1) print(f\\"bubble_sort() runs in {timing:.8f} seconds\\") arr_copy = arr[:] timing = timeit.timeit(lambda: insertion_sort(arr_copy), number=1) print(f\\"insertion_sort() runs in {timing:.8f} seconds\\") arr_copy = arr[:] timing = timeit.timeit(lambda: merge_sort(arr_copy), number=1) print(f\\"merge_sort() runs in {timing:.8f} seconds\\") print() arrays_to_test = [ ([4, 2, 7, 1, 3], \\"Small array\\"), ([10, 5, 3, 8, 4], \\"Moderate array\\"), ([9, 7, 5, 11, 12, 2], \\"Another moderate array\\"), (list(range(10**4, 0, -1)), \\"Large reversed array\\") ] for arr, title in arrays_to_test: do_benchmark(arr, title) ``` 4. Modify the provided `benchmark_sorting_algorithms` function to include import statements and ensure proper execution within your local namespace. By completing this task, you will demonstrate your understanding of common sorting algorithms and their relative performance characteristics on different datasets.","solution":"from typing import List def bubble_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Bubble Sort algorithm. n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if not swapped: break return arr def insertion_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Insertion Sort algorithm. for i in range(1, len(arr)): key = arr[i] j = i-1 while j >= 0 and key < arr[j]: arr[j+1] = arr[j] j -= 1 arr[j+1] = key return arr def merge_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Merge Sort algorithm. if len(arr) > 1: mid = len(arr) // 2 left_half = arr[:mid] right_half = arr[mid:] merge_sort(left_half) merge_sort(right_half) i = j = k = 0 while i < len(left_half) and j < len(right_half): if left_half[i] < right_half[j]: arr[k] = left_half[i] i += 1 else: arr[k] = right_half[j] j += 1 k += 1 while i < len(left_half): arr[k] = left_half[i] i += 1 k += 1 while j < len(right_half): arr[k] = right_half[j] j += 1 k += 1 return arr"},{"question":"# Question **Context**: Sorting algorithms play a crucial role in computer science and many applications due to their impact on performance with a large dataset. In this task, you will demonstrate your understanding of sorting algorithms by implementing a variant of the bubble sort. Task Write a function `optimized_bubble_sort(arr: List[int]) -> List[int]` that sorts a list of integers using the optimized bubble sort algorithm. The optimization should stop sorting if the list is already sorted before finishing all the passes. Input - `arr` (list of int): A list of integers to be sorted. Output - A list of integers sorted in non-decreasing order. Constraints - The length of `arr` will be in the range [0, 1000]. - Each element in `arr` will fit within the standard range of a 32-bit signed integer. Examples ```python assert optimized_bubble_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90] assert optimized_bubble_sort([5, 1, 4, 2, 8]) == [1, 2, 4, 5, 8] assert optimized_bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert optimized_bubble_sort([]) == [] assert optimized_bubble_sort([1, 1, 1, 1]) == [1, 1, 1, 1] ``` Additional Notes - Consider edge cases such as an empty list or a list with duplicate elements. - Optimize the bubble sort by terminating early if no elements are swapped in a pass, indicating that the list is already sorted.","solution":"def optimized_bubble_sort(arr): Sorts a list of integers using an optimized bubble sort algorithm. :param arr: A list of integers to be sorted. :return: A list of integers sorted in non-decreasing order. n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if not swapped: break return arr"},{"question":"# Scenario: You are building a chatbot for a customer service application. One of the duties of the chatbot is to detect and correct common spelling mistakes in user messages before processing them further. To achieve this, you need to implement a function that takes a string containing the user message and returns the message with corrected spelling, based on a provided dictionary of correct words. # Task: Implement a function `correct_spelling` that takes a user message and a dictionary of correct words, and returns the message with corrected spelling. # Requirements: 1. **Input Parameters**: - `message`: A string representing the user\'s message, consisting of words separated by spaces. - `correct_words`: A set of strings representing the correctly spelled words. 2. **Output**: - A string with the corrected spelling for each word in the message. # Constraints: 1. Each word in the `message` should be replaced by the nearest word in the `correct_words` based on the minimum Levenshtein distance. 2. If there is a tie (two or more words have the same minimal Levenshtein distance), choose the word that is lexicographically smaller. 3. Assume all words are in lowercase, and there are no punctuation marks in the message. # Function Signature: ```python def correct_spelling(message: str, correct_words: Set[str]) -> str: pass ``` # Examples: ```python >>> correct_spelling(\\"hallo wrold\\", {\\"hello\\", \\"world\\"}) \'hello world\' >>> correct_spelling(\\"speling errrs in somthing\\", {\\"spelling\\", \\"errors\\", \\"something\\", \\"in\\"}) \'spelling errors in something\' ```","solution":"from typing import Set def levenshtein_distance(a, b): if len(a) > len(b): a, b = b, a distances = range(len(a) + 1) for i2, c2 in enumerate(b): distances_ = [i2 + 1] for i1, c1 in enumerate(a): if c1 == c2: distances_.append(distances[i1]) else: distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1]))) distances = distances_ return distances[-1] def correct_spelling(message: str, correct_words: Set[str]) -> str: def find_closest_word(word, correct_words): closest_word = None min_distance = float(\'inf\') for correct_word in correct_words: distance = levenshtein_distance(word, correct_word) if distance < min_distance or (distance == min_distance and correct_word < closest_word): min_distance = distance closest_word = correct_word return closest_word words = message.split() corrected_words = [find_closest_word(word, correct_words) for word in words] return \' \'.join(corrected_words)"},{"question":"# Coding Assessment Question Context: You are working on a geometry-based game and need to create a functionality to check if a point lies inside a circle. The circle is represented by its center coordinates and radius. Problem Statement: Write a function `is_point_in_circle` that takes coordinates of the circle\'s center, its radius, and the coordinates of a point. The function should determine if the given point lies within or on the boundary of the circle. ```python def is_point_in_circle(cx: int, cy: int, radius: int, px: int, py: int) -> bool: Check if the circle with center at (cx, cy) and radius `radius` contains the point (px, py). pass ``` Input: - `cx, cy`: Integers representing the coordinates of the center of the circle. - `radius`: An integer representing the radius of the circle. - `px, py`: Integers representing the coordinates of point P to be checked. Output: - Return `True` if the point P(px, py) lies within or on the boundary of the circle with center (cx, cy) and radius `radius`. Otherwise, return `False`. Constraints: - Coordinates and radius are integers in the range -10000 ≤ x, y, radius ≤ 10000. - Radius is a positive integer greater than 0. Performance Requirements: - The function should run in constant time, O(1), for individual input sets. Examples: 1. `is_point_in_circle(0, 0, 5, 3, 4)` should return `True`. 2. `is_point_in_circle(0, 0, 5, 6, 8)` should return `False`. Notes: - Consider edge cases, including when the point lies exactly on the circumference of the circle. - Use the distance formula to solve the problem.","solution":"def is_point_in_circle(cx: int, cy: int, radius: int, px: int, py: int) -> bool: Check if the circle with center at (cx, cy) and radius `radius` contains the point (px, py). # Calculate the squared distance between the center and the point dist_squared = (px - cx)**2 + (py - cy)**2 # Compare it to the squared radius to avoid floating-point arithmetic return dist_squared <= radius**2"},{"question":"# Problem Statement You are given a 2D grid of size `m x n` where each cell contains an integer representing the elevation at that point. Your task is to write a function `find_basin` that identifies the lowest elevation basin. A basin is defined as a local minimum which means the value in the cell is less than or equal to its neighboring cells (up, down, left, right). # Input and Output Formats Input: * `grid` (list of list of integers): A 2D list where each inner list represents a row of the grid. Output: * A tuple representing the coordinates (row, column) of the basin(s) with the lowest elevation. If there are multiple basins with the same lowest elevation, return all of them in a list of tuples. # Constraints: * The grid dimensions are (1 leq m leq 100) and (1 leq n leq 100). * The grid can contain negative, zero, and positive integers. # Performance Requirements: * Your solution should efficiently handle grids up to the maximum size specified by the constraints. # Examples: ```python >>> find_basin([ ... [9, 8, 7], ... [6, 5, 4], ... [3, 2, 1] ... ]) [(2, 2)] >>> find_basin([ ... [1, 2, 3], ... [2, 1, 2], ... [3, 2, 1] ... ]) [(0, 0), (1, 1), (2, 2)] ``` # Additional Test Case: ```python >>> find_basin([ ... [2, 2, 2], ... [2, 1, 2], ... [2, 2, 2] ... ]) [(1, 1)] ``` # Edge Cases: 1. Single cell grid: ```python >>> find_basin([[42]]) [(0, 0)] ``` 2. Multiple identical basins: ```python >>> find_basin([ ... [1, 2, 3, 4], ... [2, 1, 2, 3], ... [3, 2, 1, 2], ... [4, 3, 2, 1] ... ]) [(0, 0), (1, 1), (2, 2), (3, 3)] ``` # Implementation Requirements: * Verify that the input is a valid grid; otherwise raise an `AssertionError`. * Handle cases where grid might include negative numbers or zero by correctly identifying the lowest elevation basin(s). ```python def find_basin(grid): assert isinstance(grid, list) and all(isinstance(row, list) for row in grid), \\"Invalid grid format.\\" m, n = len(grid), len(grid[0]) lowest_basins = [] lowest_elevation = float(\'inf\') for i in range(m): for j in range(n): current_elevation = grid[i][j] neighbors = [] if i > 0: neighbors.append(grid[i-1][j]) if i < m-1: neighbors.append(grid[i+1][j]) if j > 0: neighbors.append(grid[i][j-1]) if j < n-1: neighbors.append(grid[i][j+1]) if current_elevation <= min(neighbors, default=current_elevation) and current_elevation < lowest_elevation: lowest_elevation = current_elevation lowest_basins = [(i, j)] elif current_elevation == lowest_elevation: lowest_basins.append((i, j)) return lowest_basins if len(lowest_basins) > 1 else lowest_basins[0] ```","solution":"def find_basin(grid): assert isinstance(grid, list) and all(isinstance(row, list) for row in grid), \\"Invalid grid format.\\" m, n = len(grid), len(grid[0]) lowest_basins = [] lowest_elevation = float(\'inf\') for i in range(m): for j in range(n): current_elevation = grid[i][j] neighbors = [] if i > 0: neighbors.append(grid[i-1][j]) if i < m-1: neighbors.append(grid[i+1][j]) if j > 0: neighbors.append(grid[i][j-1]) if j < n-1: neighbors.append(grid[i][j+1]) if current_elevation <= min(neighbors, default=current_elevation): if current_elevation < lowest_elevation: lowest_elevation = current_elevation lowest_basins = [(i, j)] elif current_elevation == lowest_elevation: lowest_basins.append((i, j)) return lowest_basins"},{"question":"# Problem Statement You have been asked to develop a function that calculates the greatest common divisor (GCD) of two given positive integers using the Euclidean algorithm. Additionally, your function should return the time complexity of the operation in string format. # Function Signature ```python def gcd_with_complexity(a: int, b: int) -> (int, str): pass ``` # Input * `a` (int): A positive integer. * `b` (int): A positive integer. # Output * A tuple containing: - An integer which is the greatest common divisor of `a` and `b`. - A string that describes the time complexity of the Euclidean algorithm as \\"O(log(min(a, b)))\\". # Constraints * `1 <= a, b <= 10^9` * If `a` or `b` is not a positive integer, your function should raise a ValueError with the message \\"Both numbers must be positive integers\\". # Example ```python >>> gcd_with_complexity(60, 48) (12, \\"O(log(min(a, b)))\\") >>> gcd_with_complexity(7, 5) (1, \\"O(log(min(a, b)))\\") >>> gcd_with_complexity(100, 75) (25, \\"O(log(min(a, b)))\\") >>> gcd_with_complexity(1000000000, 1) (1, \\"O(log(min(a, b)))\\") ``` # Notes 1. Ensure the inputs are validated for the constraints specified. 2. Explain the time complexity of the Euclidean algorithm within the output of the function. 3. Handle large values efficiently as within the constraints provided.","solution":"def gcd_with_complexity(a: int, b: int) -> (int, str): if not (isinstance(a, int) and isinstance(b, int) and a > 0 and b > 0): raise ValueError(\\"Both numbers must be positive integers\\") def gcd(x, y): while y != 0: x, y = y, x % y return x gcd_value = gcd(a, b) return gcd_value, \\"O(log(min(a, b)))\\""},{"question":"# Problem: Convert Array to Heap You are given an array of integers. The objective is to convert this array into a min-heap, which is a complete binary tree where each node is smaller than its children. Instructions: 1. **Implement Heapify Function**: Complete the function `heapify` which takes the array and an index as arguments. This function should ensure that the subtree rooted at the given index adheres to the min-heap property. 2. **Build Min-Heap**: Complete the function `build_min_heap` which takes an array as an argument and applies the `heapify` function to transform the entire array into a min-heap. Input: - A list of integers representing the array. Output: - A list of integers representing the min-heap. Constraints: - The array may contain any integers, positive or negative. - The array length will be between 1 and (10^5) inclusive. - Handle duplicate values correctly. Example Usage: ```python arr1 = [4, 10, 3, 5, 1] arr2 = [9, 7, 8, 3, 2, 5, 6] print(build_min_heap(arr1)) # Output: [1, 4, 3, 5, 10] print(build_min_heap(arr2)) # Output: [2, 3, 5, 9, 7, 8, 6] ``` Example Explanation: - For `arr1`, the array [1, 4, 3, 5, 10] is a valid min-heap. - For `arr2`, the array [2, 3, 5, 9, 7, 8, 6] is a valid min-heap. Hint: - Start from the last non-leaf node and proceed to the root, ensuring each subtree satisfies the min-heap property using the `heapify` function. You will be graded on: - Correctness: The implementation must correctly transform the input array into a min-heap. - Efficiency: Ensure that the solution operates within acceptable time and space complexity limits. - Clarity: Code readability and proper documentation. Make sure to test your implementation thoroughly against all example cases and edge cases. ```python def heapify(arr, n, i): smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] < arr[smallest]: smallest = left if right < n and arr[right] < arr[smallest]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] heapify(arr, n, smallest) def build_min_heap(arr): n = len(arr) for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) return arr ```","solution":"def heapify(arr, n, i): Ensures the subtree rooted at index `i` follows the min-heap property. Parameters: arr (list): The array representation of the heap. n (int): The size of the heap. i (int): The index of the root of the subtree to be heapified. smallest = i left = 2 * i + 1 right = 2 * i + 2 # Check if the left child exists and is smaller than the current smallest if left < n and arr[left] < arr[smallest]: smallest = left # Check if the right child exists and is smaller than the current smallest if right < n and arr[right] < arr[smallest]: smallest = right # If the smallest isn\'t the parent (i), swap and continue heapifying if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] heapify(arr, n, smallest) def build_min_heap(arr): Builds a min-heap from an unsorted array. Parameters: arr (list): The unsorted array. Returns: list: The array transformed into a min-heap. n = len(arr) # Start from the last non-leaf node and go upwards for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) return arr"},{"question":"# Sudoku Validator Enhancement You are provided with a Python class `SudokuValidator` that checks the validity of a 9x9 Sudoku puzzle based on the standard Sudoku rules. Your task is to extend the functionality of this class to support the validation of Sudoku puzzles of any size, including other popular forms like 4x4 and 16x16 puzzles. 1. **Generalized Validation**: * Modify the validation methods to handle Sudoku grids of various sizes, where the size is a perfect square (e.g., 4, 9, 16). * Ensure the class checks the uniqueness of numbers in each row, column, and sub-grid appropriately for the given Sudoku grid size. 2. **Multiple Puzzle Validation**: * Add a new method that takes a list of Sudoku grids and returns a list of boolean values indicating the validity of each grid. **Input**: - For a single puzzle validation: A 2D list `grid` representing the Sudoku puzzle. - For multiple puzzle validation: A list of 2D lists `grids` where each 2D list represents a Sudoku puzzle. **Output**: - For a single puzzle validation: A boolean value indicating whether the Sudoku puzzle is valid or not. - For multiple puzzle validation: A list of boolean values indicating the validity of each Sudoku puzzle in the input list. **Performance Requirements**: - Ensure each grid is validated within a time complexity of O(n^2), where n is the size of the grid. - Handle edge cases like incomplete grids, grids with invalid sizes, and grids with invalid characters gracefully. **Constraints**: - The grid size will always be a perfect square. - The grid will contain only integers, and it may include 0 to represent an empty cell. - Input grids can vary in size but will follow standard Sudoku rules for their respective dimensions. **Example Usage**: ```python validator = SudokuValidator() # Validate a 9x9 Sudoku puzzle puzzle_9x9 = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] print(validator.validate_single(puzzle_9x9)) # Output: True or False # Validate multiple Sudoku puzzles puzzles = [ # Valid 4x4 puzzle [ [1, 2, 3, 4], [3, 4, 1, 2], [2, 3, 4, 1], [4, 1, 2, 3] ], # Invalid 9x9 puzzle [ [8, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] ] print(validator.validate_multiple(puzzles)) # Output: [True, False] ``` Write the enhanced class `SudokuValidator` with the specified improvements.","solution":"class SudokuValidator: def is_valid_block(self, block): Check if a block (row, column, or sub-grid) contains unique non-zero elements. block = [num for num in block if num != 0] return len(block) == len(set(block)) def get_subgrid(self, grid, start_row, start_col, subgrid_size): Extract a subgrid from the grid. subgrid = [] for i in range(start_row, start_row + subgrid_size): for j in range(start_col, start_col + subgrid_size): subgrid.append(grid[i][j]) return subgrid def validate_single(self, grid): grid_size = len(grid) subgrid_size = int(grid_size ** 0.5) # Check all rows for row in grid: if not self.is_valid_block(row): return False # Check all columns for col in range(grid_size): if not self.is_valid_block([grid[row][col] for row in range(grid_size)]): return False # Check all sub-grids for row in range(0, grid_size, subgrid_size): for col in range(0, grid_size, subgrid_size): if not self.is_valid_block(self.get_subgrid(grid, row, col, subgrid_size)): return False return True def validate_multiple(self, grids): return [self.validate_single(grid) for grid in grids]"},{"question":"**Problem Statement** You are given a list of integers and a positive integer `k`. Your task is to find the `k`th smallest pair distance. The distance of a pair `(a, b)` is defined as the absolute difference between `a` and `b`, i.e., `|a - b|`. **Your task** is to implement the function `find_kth_smallest_pair_distance(numbers: List[int], k: int) -> int` that finds the `k`th smallest distance among all the possible pairs. # Input Format * A list of integers `numbers` containing `n` elements. * A single integer `k` which specifies the rank of the distance to find. # Output Format * A single integer representing the `k`th smallest pair distance. # Constraints * `2 <= n <= 10^4` * `0 <= numbers[i] <= 10^6` * `1 <= k <= n * (n - 1) / 2` (You can assume the input is valid) # Example **Example 1:** ```python print(find_kth_smallest_pair_distance([1, 3, 1], 1)) ``` *Output:* ``` 0 ``` **Example 2:** ```python print(find_kth_smallest_pair_distance([1, 6, 1], 3)) ``` *Output:* ``` 5 ``` # Explanation For the first example, with `numbers = [1, 3, 1]` and `k = 1`: - The pairs formed are `(1, 3)`, `(1, 1)`, and `(3, 1)`. - The distances are `2`, `0`, and `2` respectively. - The 1st smallest pair distance is `0`. For the second example, with `numbers = [1, 6, 1]` and `k = 3`: - The pairs formed are `(1, 6)`, `(1, 1)`, and `(6, 1)`. - The distances are `5`, `0`, and `5` respectively. - The 3rd smallest pair distance is `5`. # Notes - It is recommended to sort the list first to make the distance calculation efficient. - Consider using a binary search optimization to solve this problem within the constraints. Feel free to optimize your solution for high performance.","solution":"from typing import List def count_pairs_with_distance_less_than(mid, nums): count = 0 j = 0 for i in range(len(nums)): while j < len(nums) and nums[j] - nums[i] <= mid: j += 1 count += j - i - 1 return count def find_kth_smallest_pair_distance(numbers: List[int], k: int) -> int: numbers.sort() low = 0 high = numbers[-1] - numbers[0] while low < high: mid = (low + high) // 2 if count_pairs_with_distance_less_than(mid, numbers) < k: low = mid + 1 else: high = mid return low"},{"question":"# Graph Traversal & Critical Connections Context You are tasked with analyzing server nodes in a distributed system to identify any connections that, if removed, would isolate part of the system. These critical connections, also known as bridges in graph theory, are essential for maintaining the structural integrity of the system. Task Write a function called `find_critical_connections` that uses Depth-First Search (DFS) to identify and return all critical connections in a given undirected graph. Function Signature ```python def find_critical_connections(n: int, connections: list[list[int]]) -> list[list[int]]: pass ``` Input * `n` (int): The number of nodes in the graph, labeled from 0 to n-1. * `connections` (list[list[int]]): A list of connections where each connection is represented by a pair of integers [u, v], indicating an undirected edge between nodes u and v. Output * `result` (list[list[int]]): A list of all critical connections in the graph. Each connection is represented as a pair of nodes [u, v]. The order of pairs in the result does not matter. Constraints * (2 leq n leq 10^4) * (1 leq connections.length leq 10^5) * Connections form an undirected graph with no parallel edges and no self-loops. * Each connection [u, v] appears only once. Example ```python def test_critical_connections(): n = 5 connections = [ [0, 1], [0, 2], [1, 2], [1, 3], [3, 4] ] result = find_critical_connections(n, connections) expected_result = [[3, 4], [1, 3]] # Order of pairs in result does not matter. assert set(map(frozenset, result)) == set(map(frozenset, expected_result)) n = 4 connections = [ [0, 1], [1, 2], [2, 0], [1, 3] ] result = find_critical_connections(n, connections) expected_result = [[1, 3]] assert set(map(frozenset, result)) == set(map(frozenset, expected_result)) print(\\"All tests passed!\\") test_critical_connections() ``` You are encouraged to write additional test cases to cover edge cases, such as graphs with multiple disconnected components, or graphs with no critical connections.","solution":"def find_critical_connections(n, connections): Returns a list of critical connections in an undirected graph. from collections import defaultdict # Create graph from connections graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) # Helper variables for DFS discovery_time = [-1] * n # discovery time of each node low = [-1] * n # lowest discovery time reachable from the node critical_connections = [] # stores the critical connections time = 0 # initial time def dfs(node, parent): nonlocal time discovery_time[node] = low[node] = time time += 1 for neighbor in graph[node]: if neighbor == parent: continue if discovery_time[neighbor] == -1: # if neighbor is not visited dfs(neighbor, node) # Update low value to the lowest reachable vertex low[node] = min(low[node], low[neighbor]) # Check if the edge is a critical connection if low[neighbor] > discovery_time[node]: critical_connections.append([node, neighbor]) else: # Update low value if the neighbor was already visited low[node] = min(low[node], discovery_time[neighbor]) # Call DFS from each node if not already visited for i in range(n): if discovery_time[i] == -1: dfs(i, -1) return critical_connections"},{"question":"# Matrix Transposition Function Objective Write a function to transpose a given 2D matrix. Transposing a matrix means swapping its rows and columns. Function Signature ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: ``` Input * `matrix` (List[List[int]]): A 2D list representing the matrix to be transposed. Output * Returns a 2D list representing the transposed matrix. Constraints * The matrix will be a non-empty 2D list. * All the rows in the matrix will have the same number of elements. * The elements of the matrix will be integers. # Examples ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([[1]]) [[1]] >>> transpose_matrix([[5, 8, 2, 3], [1, 6, 7, 4]]) [[5, 1], [8, 6], [2, 7], [3, 4]] >>> transpose_matrix([[10], [20], [30]]) [[10, 20, 30]] ``` # Requirements 1. You may assume the input matrix will always be well-formed and non-empty. 2. The function should handle both square and rectangular matrices. 3. Aim for clarity and efficiency in your implementation. # Hints - Utilize list comprehensions to create the transposed matrix. - Remember that transposing the matrix involves interchanging the positions of rows and columns.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transpose a given 2D matrix. Parameters: matrix (List[List[int]]): A 2D list representing the matrix to be transposed. Returns: List[List[int]]: A 2D list representing the transposed matrix. # Using list comprehension to transpose the matrix return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]"},{"question":"You are required to implement a class `PriorityQueue` which supports typical priority queue operations but uses a max-heap structure internally. The max-heap property means that each parent node is greater than or equal to its children, ensuring that the maximum element is always at the root of the heap. # Functionality Requirements: 1. **`insert(element)`**: Inserts an element into the priority queue. 2. **`extract_max()`**: Removes and returns the maximum element from the priority queue. 3. **`max()`**: Returns the maximum element without removing it. 4. **`is_empty()`**: Checks if the priority queue is empty. 5. **`size()`**: Returns the number of elements in the priority queue. 6. **`heapify_up(index)`**: Ensures the max-heap property is maintained while inserting a new element. 7. **`heapify_down(index)`**: Ensures the max-heap property is maintained while removing the maximum element. # Input and Output Formats: - **`insert(element)`**: - Input: `element` is an integer. - Output: None - **`extract_max()`**: - Output: Maximum element. - **`max()`**: - Output: Maximum element. - **`is_empty()`**: - Output: Boolean value. - **`size()`**: - Output: Integer. # Constraints: 1. `element` is an integer such that `-10^6 <= element <= 10^6` 2. The priority queue initializes with an empty list. 3. Typical sequence of operations will not exceed 10000. # Performance Requirements: Ensure that `insert` and `extract_max` operations are performed in logarithmic time, O(log n). # Example Usage: ```python # Initialize a priority queue pq = PriorityQueue() pq.insert(20) pq.insert(15) pq.insert(30) pq.insert(35) assert pq.max() == 35 assert pq.extract_max() == 35 assert pq.max() == 30 pq.insert(10) assert pq.size() == 4 assert pq.is_empty() == False assert pq.extract_max() == 30 assert pq.extract_max() == 20 assert pq.extract_max() == 15 assert pq.is_empty() == False assert pq.extract_max() == 10 assert pq.is_empty() == True ``` Your task is to complete the given class `PriorityQueue` and implement the methods as per the description.","solution":"class PriorityQueue: def __init__(self): self.heap = [] def insert(self, element): self.heap.append(element) self.heapify_up(len(self.heap) - 1) def extract_max(self): if len(self.heap) == 0: raise IndexError(\\"extract_max from empty heap\\") if len(self.heap) == 1: return self.heap.pop() max_element = self.heap[0] self.heap[0] = self.heap.pop() self.heapify_down(0) return max_element def max(self): if len(self.heap) == 0: raise IndexError(\\"max from empty heap\\") return self.heap[0] def is_empty(self): return len(self.heap) == 0 def size(self): return len(self.heap) def heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[parent_index] < self.heap[index]: self.heap[parent_index], self.heap[index] = self.heap[index], self.heap[parent_index] self.heapify_up(parent_index) def heapify_down(self, index): largest = index left_child = 2 * index + 1 right_child = 2 * index + 2 if left_child < len(self.heap) and self.heap[left_child] > self.heap[largest]: largest = left_child if right_child < len(self.heap) and self.heap[right_child] > self.heap[largest]: largest = right_child if largest != index: self.heap[largest], self.heap[index] = self.heap[index], self.heap[largest] self.heapify_down(largest)"},{"question":"# Coding Assessment Question You are tasked with implementing a function that converts a date string into the corresponding day of the week. The date string will be provided in the format `YYYY-MM-DD`. Your function should parse the date, determine the correct day of the week, and return it as a string. Your Task Write a function `day_of_week` that takes a date string in the `YYYY-MM-DD` format and returns the day of the week for that date. # Function Specifications `day_of_week` - **Input**: `date_str` (string) - A date in the format `YYYY-MM-DD` - **Output**: `string` - The day of the week corresponding to the given date (e.g., \\"Monday\\", \\"Tuesday\\"). - **Exceptions**: - Raise `ValueError` if the input string is not in the correct format. - Raise `ValueError` if the date provided is not a valid calendar date. # Example Usage ```python try: print(day_of_week(\\"2023-10-25\\")) # Expected Output: \\"Wednesday\\" print(day_of_week(\\"2024-02-29\\")) # Expected Output: \\"Thursday\\" (Leap Year) print(day_of_week(\\"2019-11-20\\")) # Expected Output: \\"Wednesday\\" # The following calls should raise an exception print(day_of_week(\\"2023-13-25\\")) # Invalid month print(day_of_week(\\"2023-02-30\\")) # Invalid day except ValueError as e: print(e) ``` # Constraints - You should use available libraries (like `datetime` in Python) to assist with date parsing and calculations. - Ensure that any invalid input format or invalid date results in a `ValueError` with an appropriate error message. **Example Error Messages**: - For incorrect format: \\"The date must be in YYYY-MM-DD format.\\" - For invalid date: \\"The date provided is not a valid calendar date.\\" Good luck, and make sure your functions handle both valid and invalid inputs gracefully!","solution":"import datetime def day_of_week(date_str): Returns the day of the week for a given date string in the format YYYY-MM-DD. Args: date_str (str): The date string in the format \'YYYY-MM-DD\'. Returns: str: The day of the week corresponding to the supplied date. Raises: ValueError: If the date string is not in the correct format or is not a valid date. try: # Parse the date date = datetime.datetime.strptime(date_str, \'%Y-%m-%d\').date() # Return the day of the week return date.strftime(\'%A\') except ValueError: raise ValueError(\\"The date must be in YYYY-MM-DD format and be a valid calendar date.\\")"},{"question":"# Coding Question **Context**: Ellie, a software engineer, is developing a system to manage employee work schedules. Part of the system involves computing the total working hours for each employee based on their daily work logs. **Task**: Write a Python function `compute_total_work_hours` that: 1. Takes a list of dictionaries, where each dictionary represents an employee\'s daily work log. 2. Each work log contains the employee\'s name, the start time and end time of their work period. 3. Computes and returns the total work hours for each employee. Each work log dictionary contains the following keys: - `name`: The name of the employee (a string). - `start`: The start time in the format \\"HH:MM\\" (a string). - `end`: The end time in the format \\"HH:MM\\" (a string). **Function Signature**: ```python from typing import List, Dict def compute_total_work_hours(work_logs: List[Dict[str, str]]) -> Dict[str, float]: Computes the total work hours for each employee based on the provided work logs. :param work_logs: List of dictionaries containing \'name\', \'start\', and \'end\' of each work period :return: Dictionary with employee names as keys and total hours worked as values pass ``` **Constraints**: * Assume the working period does not span across midnight (it always starts and ends on the same day). * Ensure the function correctly handles invalid input formats by raising appropriate exceptions. * The function should return the total hours worked rounded to two decimals. **Example**: When calling `compute_total_work_hours([{\'name\': \'Alice\', \'start\': \'09:00\', \'end\': \'17:00\'}, {\'name\': \'Alice\', \'start\': \'10:00\', \'end\': \'12:00\'}, {\'name\': \'Bob\', \'start\': \'09:30\', \'end\': \'16:30\'}])` The output should be: ```python { \'Alice\': 10.0, \'Bob\': 7.0 } ``` Ensure the function handles edge cases like an employee working multiple shifts in a day and correctly computes the cumulative hours.","solution":"from typing import List, Dict from datetime import datetime def compute_total_work_hours(work_logs: List[Dict[str, str]]) -> Dict[str, float]: Computes the total work hours for each employee based on the provided work logs. :param work_logs: List of dictionaries containing \'name\', \'start\', and \'end\' of each work period :return: Dictionary with employee names as keys and total hours worked as values work_hours = {} for log in work_logs: name = log[\'name\'] start_time = log[\'start\'] end_time = log[\'end\'] try: start = datetime.strptime(start_time, \\"%H:%M\\") end = datetime.strptime(end_time, \\"%H:%M\\") except ValueError: raise ValueError(\\"Time format should be HH:MM\\") if end < start: raise ValueError(\\"End time cannot be before start time\\") hours_worked = (end - start).seconds / 3600 if name in work_hours: work_hours[name] += hours_worked else: work_hours[name] = hours_worked for name in work_hours: work_hours[name] = round(work_hours[name], 2) return work_hours"},{"question":"# Problem Statement You\'re asked to develop a function that simulates a basic banking system for managing customer account balances. The system needs to support three essential operations: deposit, withdraw, and check balance. Ensure that withdrawals do not exceed the current balance and that all monetary values are non-negative. Implement a function `manage_bank_account` that takes an initial balance and a list of operations to perform. Each operation is a tuple where the first element is the operation type (`\\"deposit\\"`, `\\"withdraw\\"`, or `\\"balance\\"`) and the second element is the amount (for `\\"deposit\\"` and `\\"withdraw\\"` operations only). # Function Signature ```python def manage_bank_account(initial_balance: float, operations: list[tuple[str, float]]) -> float: pass ``` # Input - `initial_balance`: a non-negative float indicating the starting balance. - `operations`: a list of tuples, where each tuple contains: - a string indicating the type of operation (`\\"deposit\\"`, `\\"withdraw\\"`, or `\\"balance\\"`). - a float representing the amount for `\\"deposit\\"` and `\\"withdraw\\"` operations only. # Output - Returns the final balance after performing all operations as a float. # Constraints - `initial_balance` will be a non-negative float between 0 and (10^9). - The list `operations` will have at most (10^5) elements. - Operation types are only `\\"deposit\\"`, `\\"withdraw\\"`, or `\\"balance\\"`. - Amounts for `\\"deposit\\"` and `\\"withdraw\\"` will be non-negative floats between 0 and (10^9). - Ensure that withdrawals do not exceed the current balance at any time. # Example ```python >>> manage_bank_account(100.0, [(\\"deposit\\", 50.0), (\\"withdraw\\", 30.0), (\\"balance\\", 0)]) 120.0 >>> manage_bank_account(200.0, [(\\"withdraw\\", 50.0), (\\"balance\\", 0), (\\"deposit\\", 20.0)]) 170.0 >>> manage_bank_account(0.0, [(\\"deposit\\", 500.0), (\\"withdraw\\", 200.0), (\\"balance\\", 0)]) 300.0 ``` # Notes - Focus on handling each operation efficiently within the given constraints. - Consider edge cases such as attempting to withdraw more than the current balance.","solution":"def manage_bank_account(initial_balance: float, operations: list[tuple[str, float]]) -> float: balance = initial_balance for operation in operations: op_type = operation[0] if op_type == \\"deposit\\": amount = operation[1] balance += amount elif op_type == \\"withdraw\\": amount = operation[1] if amount <= balance: balance -= amount elif op_type == \\"balance\\": continue return balance"},{"question":"# Scenario You are tasked with designing an application to assist with encrypting and decrypting messages using the Caesar Cipher technique. The Caesar Cipher is a type of substitution cipher where each letter in the plaintext is shifted a certain number of places down the alphabet. # Requirements 1. Implement a function `caesar_cipher` that performs Caesar Cipher encryption and decryption. The function should take three arguments: - `message: str` which is the input string to be encrypted or decrypted. - `shift: int` which is an integer representing the number of positions each character in the message is to be shifted. A positive shift value means right shift (encryption), and a negative shift value means left shift (decryption). - `mode: str` which is a string that can be either \\"encrypt\\" or \\"decrypt\\" to specify the operation mode of the function. 2. The function should return the resulting string after applying the Caesar Cipher based on the provided mode and shift. # Input - `message: str` - The message to be encrypted or decrypted. - `shift: int` - The number of positions to shift each character. - `mode: str` - The mode of operation, either \\"encrypt\\" or \\"decrypt\\". # Output - `str` - The encrypted or decrypted message based on the input parameters. # Constraints - `1 <= len(message) <= 1000` - `-25 <= shift <= 25` - The message only contains alphabetical characters (both uppercase and lowercase) and spaces. - Spaces should remain unaffected by the cipher. - The input mode is guaranteed to be either \\"encrypt\\" or \\"decrypt\\". # Performance - Ensure that the solution handles both small and large messages efficiently within the provided constraints. # Function Signature ```python def caesar_cipher(message: str, shift: int, mode: str) -> str: pass ``` # Example ```python message = \\"HELLO WORLD\\" shift = 3 mode = \\"encrypt\\" assert caesar_cipher(message, shift, mode) == \\"KHOOR ZRUOG\\" message = \\"KHOOR ZRUOG\\" shift = -3 mode = \\"decrypt\\" assert caesar_cipher(message, shift, mode) == \\"HELLO WORLD\\" ```","solution":"def caesar_cipher(message: str, shift: int, mode: str) -> str: def shift_char(c, shift): if c.isalpha(): base = ord(\'A\') if c.isupper() else ord(\'a\') return chr((ord(c) - base + shift) % 26 + base) return c if mode == \\"decrypt\\": shift = -shift result = \'\'.join(shift_char(c, shift) for c in message) return result"},{"question":"# Problem Statement Consider an array of integers where the elements are either strictly increasing, strictly decreasing, or constant in nature. Given such an array, we aim to determine a specific value called the \\"pivot point.\\" A pivot point is defined as the first element in the array that disrupts the initial variant pattern (either increasing or decreasing). Write a function that identifies the pivot point in the array, given the constraints that there is exactly one such pivot point in the array. If the array is constant (all same elements), return `None`. # Function Signature ```python def find_pivot_point(arr: List[int]) -> Union[int, None]: ``` # Input - `arr` (List[int]): A list of integers where `2 ≤ len(arr) ≤ 10^5`. # Output - An integer representing the value of the pivot point in the array, or `None` if there is no pivot point. # Constraints - There will always be exactly one pivot point in the array when it is not constant. - The array length will always be at least 2. # Example ```python assert find_pivot_point([1, 2, 3, 4, 3, 2, 1]) == 3 assert find_pivot_point([9, 7, 5, 6, 8]) == 6 assert find_pivot_point([3, 3, 3, 3]) == None assert find_pivot_point([1, 3, 5, 7, 6]) == 6 ``` # Hints 1. Analyze the array to determine if it\'s initially increasing or decreasing. 2. Traverse the array and identify the first element that does not follow the initial pattern. 3. Check if all elements are the same to return `None` properly.","solution":"from typing import List, Union def find_pivot_point(arr: List[int]) -> Union[int, None]: if all(x == arr[0] for x in arr): return None n = len(arr) increasing = arr[0] < arr[1] for i in range(1, n): if (increasing and arr[i] < arr[i-1]) or (not increasing and arr[i] > arr[i-1]): return arr[i] return None"},{"question":"# Floating-Point Multiplication Validation When dealing with floating-point numbers in computational systems, it is crucial to ensure the accuracy and reliability of multiplication operations due to potential precision loss and rounding errors. # Objective Implement a function `validate_multiplication` that takes three floating-point numbers and verifies if the product of the first two numbers is approximately equal to the third number. # Function Definition 1. **validate_multiplication(a: float, b: float, product: float) -> bool:** * **Input:** * `a` (float): The first number to multiply. * `b` (float): The second number to multiply. * `product` (float): The expected product of the first two numbers. * **Output:** (bool) Return `True` if the product of `a` and `b` is approximately equal to `product`, otherwise return `False`. * **Constraints:** * Use a tolerance level (`epsilon`) of 1e-6 for comparing the product with the expected value. # Example Tests ```python # To test validate_multiplication assert validate_multiplication(10.0, 20.0, 200.0) == True assert validate_multiplication(3.6, 0.25, 0.9) == True assert validate_multiplication(1.234, 2.345, 2.8947) == False assert validate_multiplication(0.1, 0.2, 0.02) == True assert validate_multiplication(-1.5, 2.0, -3.0) == True assert validate_multiplication(10.0, 10.0, 99.999999) == True assert validate_multiplication(10.0, 10.0, 100.000001) == True assert validate_multiplication(10.0, 10.0, 100.00001) == False ``` # Constraints * Ensure that your function compares the product using an absolute tolerance of `1e-6`. * Handle both positive and negative inputs. * The inputs will always be valid floating-point numbers.","solution":"def validate_multiplication(a: float, b: float, product: float) -> bool: Verifies if the product of the first two numbers (a and b) is approximately equal to the third number (product) within a tolerance of 1e-6. epsilon = 1e-6 return abs((a * b) - product) <= epsilon"},{"question":"# Sum of Squares of Distinct Elements Problem Statement You are given an array of positive integers. Your task is to find the sum of the squares of all distinct elements in the array. If the array is empty, return 0. # Function Signature ```python def sum_of_squares(arr: List[int]) -> int: pass ``` # Input * `arr` (List[int]): A list of positive integers. # Output * Return an integer representing the sum of the squares of all distinct elements in the array. # Constraints * The length of `arr` will be between 0 and 10^4 inclusive. * Each integer in `arr` will be between 1 and 10^4 inclusive. # Example ```python assert sum_of_squares([1, 2, 2, 3, 4]) == 30 assert sum_of_squares([5, 5, 5]) == 25 assert sum_of_squares([]) == 0 ``` # Notes * Make sure to handle cases with duplicate elements correctly by only considering each unique element once. * The function should be optimized for performance to handle large arrays efficiently. # Hints * Consider using data structures that can efficiently handle uniqueness, such as sets, to avoid unnecessary calculations.","solution":"from typing import List def sum_of_squares(arr: List[int]) -> int: Returns the sum of the squares of all distinct elements in the array. unique_elements = set(arr) return sum(x ** 2 for x in unique_elements)"},{"question":"# Scenario You are given a list of words, and you need to analyze them to provide specific transformations based on queries. The main challenge is to efficiently handle a large number of queries related to word manipulation, including rearranging characters and validating transformations. # Task Implement a solution that can process the following types of word queries efficiently: 1. **Reverse Query**: Reverse the characters of a specified word. 2. **Concatenate Query**: Concatenate two specified words. 3. **Anagram Check Query**: Determine if two specified words are anagrams of each other. # Input and Output Format * **Input**: 1. `words` - A list of strings representing the words. 2. `queries` - A list of dictionary objects, each with: - `type` - One of `\'reverse\'`, `\'concatenate\'`, or `\'anagram_check\'`. - Additional parameters based on `type`: - For `\'reverse\'`: `index` (the index of the word to reverse). - For `\'concatenate\'`: `index1`, `index2` (the indices of the words to concatenate). - For `\'anagram_check\'`: `index1`, `index2` (the indices of the words to check for anagram). * **Output**: - A list of results, each being a string (for `\'reverse\'` and `\'concatenate\'`) or a boolean (for `\'anagram_check\'`). # Constraints - The list `words` will contain strings where each string\'s length is up to (10^3). - The length of `words` will be up to (10^4). - The number of queries will be up to (10^4). Your implementation should prioritize efficient processing of queries. # Example ```python from typing import List, Dict, Union, Any Query = Dict[str, Union[str, int]] def process_queries(words: List[str], queries: List[Query]) -> List[Any]: # Your implementation here to handle the word queries efficiently pass # Example usage: test_words = [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"elderberry\\"] test_queries = [ {\\"type\\": \\"reverse\\", \\"index\\": 0}, {\\"type\\": \\"concatenate\\", \\"index1\\": 1, \\"index2\\": 2}, {\\"type\\": \\"anagram_check\\", \\"index1\\": 0, \\"index2\\": 4} ] print(process_queries(test_words, test_queries)) # Expected output: [\\"elppa\\", \\"bananacherry\\", False] ```","solution":"from typing import List, Dict, Union, Any Query = Dict[str, Union[str, int]] def process_queries(words: List[str], queries: List[Query]) -> List[Any]: results = [] for query in queries: if query[\\"type\\"] == \\"reverse\\": index = query[\\"index\\"] results.append(words[index][::-1]) elif query[\\"type\\"] == \\"concatenate\\": index1, index2 = query[\\"index1\\"], query[\\"index2\\"] results.append(words[index1] + words[index2]) elif query[\\"type\\"] == \\"anagram_check\\": index1, index2 = query[\\"index1\\"], query[\\"index2\\"] results.append(sorted(words[index1]) == sorted(words[index2])) return results"},{"question":"# Problem Statement **Context**: As a developer, you are required to implement a function for data compression and decompression. The method to be used is Run-Length Encoding (RLE), a simple form of data compression where consecutive repeated elements of data are stored as a single data value and count. Task Write two Python functions, `rle_encode` and `rle_decode`. The `rle_encode` function takes a string as input and returns its run-length encoded string. The `rle_decode` function takes a run-length encoded string and returns the original string. Requirements: * The `rle_encode` function should handle empty input gracefully. * The `rle_decode` function should handle edge cases where the provided encoded string might be incorrectly formatted. * Raise a `ValueError` in `rle_decode` when the encoded string is malformed. Function Signatures ```python def rle_encode(data: str) -> str: pass def rle_decode(encoded_data: str) -> str: pass ``` # Input * `data`: A string `[a1, a2, ..., an]` representing the input data to be encoded. * `encoded_data`: A run-length encoded string `[e1, e2, ..., em]` representing encoded data. # Output * `rle_encode`: A string representing the run-length encoded version of the input data. * `rle_decode`: A string representing the decoded version of the input encoded data. # Constraints * The length of `data` will be between `0` and `10^5`. * The length of `encoded_data` will be between `0` and `10^5`. # Examples ```python >>> rle_encode(\\"aaabbbcccaaa\\") \'a3b3c3a3\' >>> rle_decode(\\"a3b3c3a3\\") \'aaabbbcccaaa\' >>> rle_encode(\\"\\") \'\' >>> rle_decode(\\"\\") \'\' >>> rle_decode(\\"a3b3c3a\\") ValueError: Malformed encoded string ``` # Note * For `rle_encode`, consecutive repeated characters are stored as the character followed by the count. * For `rle_decode`, raise `ValueError` when the string is malformed, such as missing counts for characters.","solution":"def rle_encode(data: str) -> str: if len(data) == 0: return \\"\\" encoded = [] i = 0 while i < len(data): count = 1 while i + 1 < len(data) and data[i] == data[i + 1]: i += 1 count += 1 encoded.append(f\\"{data[i]}{count}\\") i += 1 return \'\'.join(encoded) def rle_decode(encoded_data: str) -> str: if len(encoded_data) == 0: return \\"\\" decoded = [] i = 0 while i < len(encoded_data): if i + 1 < len(encoded_data) and encoded_data[i].isalpha() and encoded_data[i+1].isdigit(): char = encoded_data[i] count_str = \\"\\" i += 1 while i < len(encoded_data) and encoded_data[i].isdigit(): count_str += encoded_data[i] i += 1 decoded.append(char * int(count_str)) else: raise ValueError(\\"Malformed encoded string\\") return \'\'.join(decoded)"},{"question":"**Scenario**: You are developing a text editor with a specific feature that allows users to find and highlight all occurrences of a certain word. To enhance performance, you want to implement search functionality using the Knuth-Morris-Pratt (KMP) algorithm, which efficiently locates substrings within a string. **Challenge**: Implement the function `find_all_occurrences(text: str, pattern: str) -> List[int]` that returns a list of starting indices where the pattern is found in the text. Utilize the KMP algorithm to achieve optimal performance. # Function Signature ```python def find_all_occurrences(text: str, pattern: str) -> List[int]: pass ``` # Example Usage ```python assert find_all_occurrences(\\"abracadabra\\", \\"abra\\") == [0, 7] assert find_all_occurrences(\\"aaaaaa\\", \\"aa\\") == [0, 1, 2, 3, 4] assert find_all_occurrences(\\"abcde\\", \\"f\\") == [] assert find_all_occurrences(\\"abcabcabca\\", \\"abca\\") == [0, 3, 6] assert find_all_occurrences(\\"\\", \\"pattern\\") == [] assert find_all_occurrences(\\"text\\", \\"\\") == [] ``` # Constraints and Performance Requirements * The function should use the KMP algorithm, ensuring time complexity of O(N + M), where N is the length of the text and M is the length of the pattern. * Inputs will be simple strings containing only alphabetical characters and whitespace. * The length of the text and the pattern together will not exceed 10,000 characters. # Notes * Handle edge cases such as empty text or patterns gracefully. * Ensure the function efficiently finds and returns all occurrences of the pattern, with performance suitable for larger texts. * If the pattern is empty, return an empty list.","solution":"from typing import List def compute_lps(pattern: str) -> List[int]: Computes the Longest Prefix which is also Suffix (LPS) array. The LPS array is used to skip characters while matching. lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length-1] else: lps[i] = 0 i += 1 return lps def find_all_occurrences(text: str, pattern: str) -> List[int]: Finds all occurrences of the pattern in the text using the KMP algorithm. if not pattern or not text: return [] lps = compute_lps(pattern) indices = [] i = 0 # index for text j = 0 # index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): indices.append(i - j) j = lps[j-1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j-1] else: i += 1 return indices"},{"question":"# Problem Statement Design a Python function that simulates a basic weather forecast model. The function takes in historical temperature recordings for a specified number of previous days and predicts the temperature for the next day using a simple weighted moving average. # Task Write a Python function called `predict_temperature` that takes in a list of daily temperatures and the number of previous days to consider for the moving average, and returns the predicted temperature for the next day. 1. **Weighted Moving Average**: Calculate the weighted moving average of temperatures over the specified number of previous days. Newer days have a higher weight. 2. **Edge Cases**: Handle cases where there are not enough previous days to calculate the average. # Function Signature ```python def predict_temperature(temperatures: list, days: int) -> float: pass ``` # Input * `temperatures` (list): A list of floating-point numbers representing daily temperatures. * `days` (int): The number of previous days to consider for the moving average. # Output * Returns a floating-point number representing the predicted temperature for the next day. # Constraints * The input `temperatures` list will have at least one element. * The input `days` is a positive integer less than or equal to the length of `temperatures`. # Example ```python >>> temperatures = [20.5, 21.0, 22.8, 21.5, 23.0, 24.0] >>> days = 3 >>> predict_temperature(temperatures, days) 23.6 ``` In this example, you would calculate the weighted moving average of the last 3 days (21.5, 23.0, 24.0) by assigning higher weights to more recent days, leading to a weighted average that predicts 23.6 as the temperature for the next day. Ensure your function is efficient and leverages appropriate computational techniques where possible.","solution":"def predict_temperature(temperatures, days): Predicts the temperature of the next day using a weighted moving average of the past days\' temperatures. Parameters: temperatures (list): A list of floating-point numbers representing daily temperatures. days (int): The number of previous days to consider for the moving average. Returns: float: The predicted temperature for the next day. n = len(temperatures) if days > n: raise ValueError(\\"Number of days should not exceed the length of temperatures list\\") # Calculate weights: newer days have higher weights. weights = range(1, days + 1) weighted_sum = sum(temperatures[-days+i] * w for i, w in enumerate(weights)) total_weight = sum(weights) predicted_temp = weighted_sum / total_weight return predicted_temp"},{"question":"# Context You are developing a small library to handle typical string operations, specifically to simulate and manipulate simple text editor functionalities. The string can have various operations applied to it, such as adding or deleting characters, and reversing the entire string. # Problem Statement Write a class `SimpleTextEditor` with the following methods: 1. `__init__()` 2. `append(text: str) -> None` 3. `delete(count: int) -> None` 4. `get_text() -> str` 5. `reverse() -> None` Method Descriptions: * **__init__**: Initializes the editor with an empty string. * **append**: Appends the given text to the end of the current string. * **delete**: Deletes the last `count` characters from the current string. * **get_text**: Returns the current state of the text. * **reverse**: Reverses the entire string. Input and Output Formats: * **Input**: - For `append`: A string `text` to be appended. - For `delete`: An integer `count` referring to how many characters should be removed from the end. * **Output**: The result of each operation as described above. Constraints: 1. Appended text length and delete count will be valid, ensuring that the resulting text does not become negative in length. 2. Characters in the string are standard ASCII characters. Example Usage: ```python editor = SimpleTextEditor() editor.append(\\"Hello\\") print(editor.get_text()) # Output: \\"Hello\\" editor.append(\\" World\\") print(editor.get_text()) # Output: \\"Hello World\\" editor.delete(6) print(editor.get_text()) # Output: \\"Hello\\" editor.reverse() print(editor.get_text()) # Output: \\"olleH\\" ``` # Performance Requirement The methods should handle typical text editor operations efficiently. Basic string manipulations might involve O(n) operations where n is the length of the string. Good luck and ensure your solution handles the edge cases properly!","solution":"class SimpleTextEditor: def __init__(self): self.text = \\"\\" def append(self, text: str) -> None: self.text += text def delete(self, count: int) -> None: self.text = self.text[:-count] def get_text(self) -> str: return self.text def reverse(self) -> None: self.text = self.text[::-1]"},{"question":"# Advanced Sorting and Searching Algorithms You are given a skeleton code for a program that includes basic implementations of sorting algorithms (like Bubble Sort) and searching techniques (like Linear Search). Your task is to enhance and extend the functionality of this program by implementing more advanced and efficient algorithms. Additionally, perform an analysis comparing the performance of the basic and advanced algorithms under various conditions. # Task Requirements: 1. **Quick Sort**: * Implement the Quick Sort algorithm and replace the existing Bubble Sort implementation. * Compare the performance between Bubble Sort and Quick Sort. 2. **Binary Search**: * Implement the Binary Search algorithm and replace the existing Linear Search implementation. * Ensure to handle the precondition of having a sorted array for Binary Search. 3. **Heap Sort**: * Add an implementation for Heap Sort. * Compare its performance with Quick Sort on various datasets. 4. **Performance Analysis**: * Provide a detailed analysis of the time complexity and practical runtime of each sorting and searching algorithm under different input conditions. # Input and Output Formats: - **Input**: - An unsorted array of integers. - An integer representing the target value to search for. - Configuration parameters (such as type of sort or search algorithm to use). - **Output**: - Sorted integer array. - Index of the target value in the sorted array if found, otherwise an appropriate message. - Performance metrics comparison between different algorithms. # Constraints: - Ensure the input array can handle both small and large datasets efficiently. - Avoid modifying the original array directly unless required (consider using copies). - Aim to implement the changes in a modular and well-documented manner. # Scenario: You work for a software company that is developing a high-performance data processing tool. The module you are responsible for needs to handle sorting and searching operations on datasets efficiently. The datasets size can vary from hundreds to millions of elements. Your module should be versatile, offering different algorithms to cater to various performance requirements and dataset characteristics. # Code Skeleton: ```python class SortingAndSearching: def __init__(self, array: list) -> None: self.array = array def quick_sort(self, low: int, high: int) -> None: # Implement Quick Sort algorithm. pass def partition(self, low: int, high: int) -> int: # Implement the partition function for Quick Sort. pass def heap_sort(self) -> None: # Implement Heap Sort algorithm. pass def bubble_sort(self) -> None: # Existing Bubble Sort implementation. pass def linear_search(self, target: int) -> int: # Existing Linear Search implementation. return -1 # Placeholder return value. def binary_search(self, target: int, low: int, high: int) -> int: # Implement Binary Search algorithm. return -1 # Placeholder return value. def search(self, target: int, method: str = \'binary\') -> int: # Function to select search method (Linear or Binary Search). pass def sort(self, method: str = \'quick\') -> None: # Function to select sort method (Bubble, Quick, or Heap Sort). pass def example_usage() -> None: sample_array = [34, 7, 23, 32, 5, 62] sorting_searching = SortingAndSearching(sample_array) # Example of sorting using Quick Sort. sorting_searching.sort(method=\'quick\') # Example of searching using Binary Search. idx = sorting_searching.search(23, method=\'binary\') # Performance analysis example. # (Implement logic to compare various algorithms within this function.) if __name__ == \\"__main__\\": example_usage() ```","solution":"class SortingAndSearching: def __init__(self, array: list) -> None: self.array = array def quick_sort(self, low: int, high: int) -> None: if low < high: pi = self.partition(low, high) self.quick_sort(low, pi - 1) self.quick_sort(pi + 1, high) def partition(self, low: int, high: int) -> int: pivot = self.array[high] i = low - 1 for j in range(low, high): if self.array[j] < pivot: i += 1 self.array[i], self.array[j] = self.array[j], self.array[i] self.array[i+1], self.array[high] = self.array[high], self.array[i+1] return i + 1 def heap_sort(self) -> None: n = len(self.array) for i in range(n // 2 - 1, -1, -1): self.heapify(n, i) for i in range(n-1, 0, -1): self.array[i], self.array[0] = self.array[0], self.array[i] self.heapify(i, 0) def heapify(self, n, i): largest = i l = 2 * i + 1 r = 2 * i + 2 if l < n and self.array[i] < self.array[l]: largest = l if r < n and self.array[largest] < self.array[r]: largest = r if largest != i: self.array[i], self.array[largest] = self.array[largest], self.array[i] self.heapify(n, largest) def bubble_sort(self) -> None: n = len(self.array) for i in range(n): for j in range(0, n-i-1): if self.array[j] > self.array[j+1]: self.array[j], self.array[j+1] = self.array[j+1], self.array[j] def linear_search(self, target: int) -> int: for i, value in enumerate(self.array): if value == target: return i return -1 def binary_search(self, target: int, low: int, high: int) -> int: if high >= low: mid = (high + low) // 2 if self.array[mid] == target: return mid elif self.array[mid] > target: return self.binary_search(target, low, mid - 1) else: return self.binary_search(target, mid + 1, high) else: return -1 def search(self, target: int, method: str = \'binary\') -> int: if method == \'linear\': return self.linear_search(target) elif method == \'binary\': return self.binary_search(target, 0, len(self.array) - 1) else: raise ValueError(\\"Invalid search method specified.\\") def sort(self, method: str = \'quick\') -> None: if method == \'quick\': self.quick_sort(0, len(self.array) - 1) elif method == \'heap\': self.heap_sort() elif method == \'bubble\': self.bubble_sort() else: raise ValueError(\\"Invalid sort method specified.\\")"},{"question":"# Image Compression using Principal Component Analysis (PCA) You are tasked with implementing a solution to perform image compression by reducing the dimensions of the image using Principal Component Analysis (PCA). The goal is to approximate the image using a reduced number of principal components, thereby compressing the image while preserving as much information as possible. Task Write a function `pca_compress_image` that consumes the following parameters: * `image`: A 2D numpy array representing a grayscale image. * `n_components`: The number of principal components to keep. The function should return a compressed version of the image reconstructed using `n_components` principal components. Constraints * The image is a 2D numpy array of pixel values ranging from 0 to 255. * The number of principal components `n_components` must be a positive integer less than or equal to the smaller dimension of the image. Input Format The input parameters are: 1. `image` (numpy.ndarray): A 2D array representing the grayscale image. 2. `n_components` (int): The number of principal components to retain for the compressed image. Output Format The function should return a 2D numpy array representing the compressed image. Example ```python import numpy as np from sklearn.decomposition import PCA def pca_compress_image(image, n_components): # Ensure proper inputs if n_components <= 0 or n_components > min(image.shape): raise ValueError(\\"n_components must be a positive integer less than or equal to the smaller dimension of the image\\") # Perform PCA pca = PCA(n_components=n_components) transformed_image = pca.fit_transform(image) compressed_image = pca.inverse_transform(transformed_image) return compressed_image # Example usage: image = np.array([[60, 70, 80], [70, 80, 90], [80, 90, 100]]) compressed_image = pca_compress_image(image, 2) print(compressed_image) # Output: An approximated version of the input image using 2 principal components. ``` Your implementation should include necessary error handling for invalid input parameters. Specifically, ensure that `n_components` is within the valid range and handle edge cases where the dimensions of the image may not support the compression process.","solution":"import numpy as np from sklearn.decomposition import PCA def pca_compress_image(image, n_components): Compresses a grayscale image using PCA to reduce its dimensions. Parameters: image (numpy.ndarray): 2D array representing the grayscale image. n_components (int): The number of principal components to keep. Returns: numpy.ndarray: Compressed 2D array representing the reconstructed image. # Ensure proper inputs if not isinstance(image, np.ndarray) or len(image.shape) != 2: raise ValueError(\\"The image must be a 2D numpy array\\") if not isinstance(n_components, int) or n_components <= 0 or n_components > min(image.shape): raise ValueError(\\"n_components must be a positive integer less than or equal to the smaller dimension of the image\\") # Perform PCA pca = PCA(n_components=n_components) transformed_image = pca.fit_transform(image) compressed_image = pca.inverse_transform(transformed_image) return compressed_image.clip(0, 255)"},{"question":"# Coding Challenge: Optimize Network Flow You are tasked with optimizing the traffic flow in a network of interconnected nodes. The network is defined by weighted edges representing the time it takes to travel between nodes. Your goal is to find the shortest travel time from a given start node to a destination node, taking into account potential delays caused by a set of critical nodes that can experience slowdowns. If a critical node is part of the shortest path, you must add a fixed delay time to the total travel time. Function Signature ```python def optimize_network_flow(num_nodes: int, edges: list[tuple[int, int, int]], start: int, end: int, critical_nodes: set[int], delay: int) -> int: pass ``` Parameters - `num_nodes`: An integer representing the total number of nodes in the network (0-indexed). - `edges`: A list of tuples, where each tuple (u, v, w) represents an edge between nodes u and v with weight w. - `start`: An integer representing the starting node. - `end`: An integer representing the destination node. - `critical_nodes`: A set of integers representing nodes that can cause delays. - `delay`: An integer representing the fixed delay time added to the travel time if a critical node is visited. Constraints - 1 <= num_nodes <= 1000 - 0 <= u, v < num_nodes - 1 <= w <= 100 - 0 <= len(edges) <= num_nodes * (num_nodes - 1) / 2 - 0 <= start, end < num_nodes (start != end) - 0 <= len(critical_nodes) <= num_nodes - 0 <= delay <= 100 Output - An integer representing the shortest travel time from the start node to the end node, including any necessary delays. # Example ```python num_nodes = 5 edges = [ (0, 1, 10), (1, 2, 20), (2, 3, 10), (3, 4, 10), (0, 4, 100) ] start = 0 end = 4 critical_nodes = {2, 3} delay = 5 result = optimize_network_flow(num_nodes, edges, start, end, critical_nodes, delay) print(result) ``` **Output:** ```python 50 ``` Write the function `optimize_network_flow` to solve the problem.","solution":"import heapq def optimize_network_flow(num_nodes, edges, start, end, critical_nodes, delay): # Create adjacency list graph = {i: [] for i in range(num_nodes)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra\'s algorithm initialization pq = [(0, start)] # Priority queue of (distance, node) distances = {i: float(\'inf\') for i in range(num_nodes)} distances[start] = 0 visited = set() while pq: current_dist, current_node = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) for neighbor, weight in graph[current_node]: distance = current_dist + weight if neighbor in critical_nodes: distance += delay if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances[end]"},{"question":"# Context You are working for a city transportation department and are assigned to optimize the schedule of the city\'s bus routes. Each bus route has a specific start time and end time during the day, and the goal is to maximize the number of non-overlapping routes that can be scheduled to minimize idle time between them. # Task Implement a function `optimal_schedule` that selects the maximum number of non-overlapping bus routes from a list of bus routes. Each bus route is characterized by its start time and end time. # Function Signature ```python def optimal_schedule(routes: list[list[int]]) -> list[list[int]]: Select the maximum number of non-overlapping bus routes. Parameters: - routes: A list of lists where each sublist represents a bus route with start and end times [start, end]. Returns: - A list of lists representing the non-overlapping bus routes in the order they were selected. Example: >>> optimal_schedule([[1, 3], [2, 5], [4, 6], [7, 10]]) [[1, 3], [4, 6], [7, 10]] ``` # Input Constraints - `routes[i][0]` (start time) and `routes[i][1]` (end time) are non-negative integers where start time is less than the end time. - The number of routes, `n`, will be at least 1 and at most 10^5. # Performance Requirements - The implementation should efficiently handle large datasets with up to 100,000 routes, ensuring an optimal scheduling in terms of time complexity. # Example ```python routes = [ [1, 3], [2, 5], [4, 6], [8, 9], [5, 7] ] scheduled_routes = optimal_schedule(routes) print(scheduled_routes) # Output: [[1, 3], [4, 6], [8, 9]] routes = [ [7, 10], [2, 3], [3, 5], [4, 6], [1, 3] ] scheduled_routes = optimal_schedule(routes) print(scheduled_routes) # Output: [[2, 3], [3, 5], [7, 10]] ```","solution":"def optimal_schedule(routes): Select the maximum number of non-overlapping bus routes. Parameters: - routes: A list of lists where each sublist represents a bus route with start and end times [start, end]. Returns: - A list of lists representing the non-overlapping bus routes in the order they were selected. # Sort the routes by their ending times routes.sort(key=lambda x: x[1]) # Initialize an empty result list result = [] # Start with an end time that is less than any possible start time last_end_time = -1 # Iterate through the sorted routes for route in routes: if route[0] >= last_end_time: result.append(route) last_end_time = route[1] return result"},{"question":"# Coding Assessment Question **Problem Statement**: You are given a list of integers `numbers`. Your task is to write a function `max_product_pair` that returns the pair of distinct indices `(i, j)` (i < j) such that the product of the elements at these indices is the maximum among all possible pairs. If there are multiple pairs with the same maximum product, return the one with the smallest index `i`. If there are no such distinct pairs, the function should return `None`. **Function Signature**: ```python def max_product_pair(numbers: list) -> tuple: pass ``` **Input**: * A list of integers `numbers` where `2 <= len(numbers) <= 10^5` and each integer is between `-10^9` and `10^9`. **Output**: * A tuple `(i, j)` of distinct indices corresponding to the maximum product pair. Return `None` if no such pairs exist. **Constraints**: * The list must contain at least two integers for a valid pair to exist. If not, return `None`. **Examples**: ```python assert max_product_pair([3, 5, -1, 7, 9]) == (3, 4) # because 7*9 = 63 is the maximum product assert max_product_pair([-10, -3, 5, 6, -2]) == (0, 1) # because (-10)*(-3) = 30 is the maximum product assert max_product_pair([1, 1, 1, 1]) == (0, 1) # multiple pairs yield the same product, return the smallest indices (0, 1) assert max_product_pair([2]) == None # not enough elements for a pair assert max_product_pair([1, -1]) == (0, 1) # only two elements, this is the only pair assert max_product_pair([0, 0, 0]) == (0, 1) # multiple pairs with the product 0, return the smallest indices (0, 1) ``` **Performance Requirement**: You should ensure that the function runs efficiently for large input sizes up to `10^5` elements, taking into account possible large values for integers.","solution":"def max_product_pair(numbers): if len(numbers) < 2: return None max_product = float(\'-inf\') max_pair = None for i in range(len(numbers) - 1): for j in range(i + 1, len(numbers)): product = numbers[i] * numbers[j] if product > max_product or (product == max_product and (max_pair is None or i < max_pair[0])): max_product = product max_pair = (i, j) return max_pair"},{"question":"# Coding Assessment Question Given an array of integers, implement a function `find_minimum_window_sum(arr: List[int], target: int) -> int` to find the length of the smallest contiguous subarray whose sum is greater than or equal to the given target value. If there is no such subarray, return 0. Input * `arr`: A list of integers representing the array (1 ≤ length of arr ≤ 10^5, -10^5 ≤ arr[i] ≤ 10^5) * `target`: An integer representing the target sum (1 ≤ target ≤ 10^9) # Output * An integer representing the length of the smallest contiguous subarray with a sum greater than or equal to the target. If no such subarray exists, return 0. Example Input 1: ```python arr = [2, 3, 1, 2, 4, 3] target = 7 ``` Output 1: ```python 2 ``` Input 2: ```python arr = [1, 2, 3, 4, 5] target = 15 ``` Output 2: ```python 5 ``` Explanation * In the first example, the smallest subarray whose sum is at least 7 is `[4, 3]` with a length of 2. * In the second example, the entire array sums up to 15, which is the only subarray that meets the target, with a length of 5. Performance Requirements * Your solution should efficiently handle the input size constraints and be able to process arrays with up to one hundred thousand elements in a reasonable amount of time. Notes * Clearly explain your thought process and code implementation in comments.","solution":"from typing import List def find_minimum_window_sum(arr: List[int], target: int) -> int: Returns the length of the smallest contiguous subarray whose sum is greater than or equal to the target. If no such subarray exists, returns 0. n = len(arr) min_length = n + 1 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length <= n else 0"},{"question":"# Coding Assessment Question **Scenario**: You are tasked with building a `FileSystem` class that simulates a simplified hierarchical file and directory structure. This class should support creating, moving, and deleting files and directories, as well as reading their contents. Implement these functionalities while efficiently managing edge cases. **Requirements**: 1. **File and Directory Creation**: Support creation of both files and directories. Files can contain textual data, while directories can contain other files or directories. 2. **Movement and Deletion**: Implement methods to move and delete files or directories, updating the structure appropriately. 3. **Reading Contents**: Provide functionality to read the contents of a file or list the contents of a directory. 4. **Error Handling**: Ensure that operations handle cases where files or directories do not exist, paths are invalid, or operations are not permitted (e.g., moving a directory into one of its subdirectories). **Function Implementation**: 1. **create(path: str, is_file: bool, content: str = \\"\\") -> None** - Parameters: - `path`: The path where the file or directory should be created. - `is_file`: Boolean indicating if a file (True) or a directory (False) should be created. - `content`: The content to be stored in a file (ignored if creating a directory). - Creates the file or directory at the specified path. 2. **move(src_path: str, dest_path: str) -> None** - Parameters: - `src_path`: The source path of the file or directory. - `dest_path`: The destination path where the file or directory should be moved. - Moves the file or directory from `src_path` to `dest_path`. 3. **delete(path: str) -> None** - Parameter: - `path`: The path of the file or directory to be deleted. - Deletes the file or directory at the specified path. 4. **read(path: str) -> str or list** - Parameter: - `path`: The path of the file or directory to read. - Returns the content of a file or the list of contents in a directory. **Input and Output**: ```python fs = FileSystem() # Create directories fs.create(\\"/a\\", False) fs.create(\\"/a/b\\", False) fs.create(\\"/a/b/c\\", False) # Create files with content fs.create(\\"/a/b/file.txt\\", True, \\"Hello, World!\\") fs.create(\\"/a/b/c/file2.txt\\", True, \\"Sample file content.\\") # Move a directory fs.move(\\"/a/b/c\\", \\"/a/b/moved_c\\") # Read directory and file contents print(fs.read(\\"/a\\")) # Output: [\\"b\\"] print(fs.read(\\"/a/b\\")) # Output: [\\"file.txt\\", \\"moved_c\\"] print(fs.read(\\"/a/b/file.txt\\")) # Output: \\"Hello, World!\\" print(fs.read(\\"/a/b/moved_c/file2.txt\\")) # Output: \\"Sample file content.\\" # Delete a file and verify deletion fs.delete(\\"/a/b/file.txt\\") print(fs.read(\\"/a/b\\")) # Output: [\\"moved_c\\"] ``` **Constraints**: - Paths can have a maximum length of 100 characters and contain alphanumeric characters, slashes, and dots. - The file system can contain up to 10,000 files and directories. - File contents can be up to 10,000 characters long. Ensure to validate the solution with various edge cases, such as attempts to move directories into their subdirectories, creating files in non-existent directories, and handling empty paths.","solution":"class FileSystem: def __init__(self): self.root = {} def _traverse(self, path: str): Traverses the file system to return the target dictionary and the final key. dirs = path.strip(\\"/\\").split(\\"/\\") curr = self.root for dir in dirs[:-1]: if dir not in curr or not isinstance(curr[dir], dict): return None, None curr = curr[dir] return curr, dirs[-1] def create(self, path: str, is_file: bool, content: str = \\"\\") -> None: parent, name = self._traverse(path) if parent is None or name in parent: raise ValueError(f\\"Invalid path or {path} already exists.\\") if is_file: parent[name] = content else: parent[name] = {} def move(self, src_path: str, dest_path: str) -> None: src_parent, src_name = self._traverse(src_path) dest_parent, dest_name = self._traverse(dest_path) if src_parent is None or src_name not in src_parent: raise ValueError(f\\"Source path {src_path} does not exist.\\") if dest_parent is None or dest_name in dest_parent: raise ValueError(f\\"Invalid destination path or {dest_path} already exists.\\") if dest_path.startswith(src_path + \\"/\\"): raise ValueError(\\"Cannot move a directory into one of its subdirectories.\\") dest_parent[dest_name] = src_parent.pop(src_name) def delete(self, path: str) -> None: parent, name = self._traverse(path) if parent is None or name not in parent: raise ValueError(f\\"Path {path} does not exist.\\") del parent[name] def read(self, path: str): parent, name = self._traverse(path) if parent is None or name not in parent: raise ValueError(f\\"Path {path} does not exist.\\") node = parent[name] if isinstance(node, str): return node elif isinstance(node, dict): return list(node.keys()) else: raise ValueError(f\\"Unknown type at path {path}.\\")"},{"question":"# Connected Components in Graph Given an undirected graph represented as an adjacency list where each node has an integer id starting from 0, implement a function `connected_components(graph: List[List[int]]) -> List[List[int]]` that returns the connected components of the graph. Each connected component is a list of node ids, and the function should return a list of such connected components. The order of nodes in the returned connected components list and the order of components does not matter. Input: - A list of lists `graph` where `graph[i]` contains the nodes that node `i` is directly connected to. - It is guaranteed that `graph` will have at least one node and no self-loops. Output: - A list of connected components where each connected component is a list of node ids. # Constraints: - The function should handle graphs with up to 1000 nodes efficiently. - Avoid using excessive memory or deep recursion to prevent stack overflow. # Example: ```python graph = [ [1, 2], [0], [0], [4, 5], [3], [3] ] assert connected_components(graph) in [[[0, 1, 2], [3, 4, 5]], [[1, 0, 2], [4, 3, 5]], ...] # The order does not matter ``` # Additional Guidelines: - Explain the approach, edge cases, and handle potential errors. - Ensure your code is optimized to handle the constraints.","solution":"def connected_components(graph): def dfs(node, visited, component): stack = [node] while stack: u = stack.pop() if not visited[u]: visited[u] = True component.append(u) for v in graph[u]: if not visited[v]: stack.append(v) visited = [False] * len(graph) components = [] for i in range(len(graph)): if not visited[i]: component = [] dfs(i, visited, component) components.append(component) return components"},{"question":"# Question: Subarray Sum Finder You are tasked with implementing two functions to find a contiguous subarray within a one-dimensional array of numbers which has the largest sum. The goal is to assess your understanding of dynamic programming and the divide-and-conquer (Kadane’s Algorithm) approach. Implement the following two functions according to the specifications given: 1. **max_subarray_sum_dp** - **Input**: A list of numbers (integers or floats). - **Output**: The largest sum of a contiguous subarray. - **Constraints**: The function must raise a `ValueError` if the list is empty. 2. **max_subarray_sum_divide_and_conquer** - **Input**: 1. A list of numbers (integers or floats). 2. The leftmost index (inclusive). 3. The rightmost index (inclusive). - **Output**: The largest sum of a contiguous subarray within the specified range in the list. - **Constraints**: 1. The function must raise a `ValueError` if the list is empty. 2. The function must raise an `IndexError` if the indices are out of the list bounds. **Function Definitions**: ```python def max_subarray_sum_dp(nums: list[int | float]) -> int | float: # Your code here def max_subarray_sum_divide_and_conquer(nums: list[int | float], left: int, right: int) -> int | float: # Your code here ``` **Example Test Cases**: ```python assert max_subarray_sum_dp([1, -3, 2, 1, -1]) == 3 assert max_subarray_sum_dp([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 assert max_subarray_sum_dp([-1, -2, -3, -4]) == -1 try: max_subarray_sum_dp([]) except ValueError: print(\\"Caught ValueError as expected\\") assert max_subarray_sum_divide_and_conquer([1, -3, 2, 1, -1], 0, 4) == 3 assert max_subarray_sum_divide_and_conquer([-2, 1, -3, 4, -1, 2, 1, -5, 4], 0, 8) == 6 assert max_subarray_sum_divide_and_conquer([-1, -2, -3, -4], 0, 3) == -1 try: max_subarray_sum_divide_and_conquer([], 0, 0) except ValueError: print(\\"Caught ValueError as expected\\") try: max_subarray_sum_divide_and_conquer([1, 2], -1, 2) except IndexError: print(\\"Caught IndexError as expected\\") ``` **Requirements**: - Make sure to consider edge cases. - Optimize the divide-and-conquer function where possible. - Adhere to the provided function signatures and constraints. Good luck!","solution":"def max_subarray_sum_dp(nums: list[int | float]) -> int | float: Finds the largest sum of a contiguous subarray using dynamic programming. if not nums: raise ValueError(\\"The input list is empty.\\") max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum def max_subarray_sum_divide_and_conquer(nums: list[int | float], left: int, right: int) -> int | float: Finds the largest sum of a contiguous subarray using the divide and conquer approach. if not nums: raise ValueError(\\"The input list is empty.\\") if left < 0 or right >= len(nums) or left > right: raise IndexError(\\"Invalid indices.\\") if left == right: return nums[left] mid = (left + right) // 2 max_left_sum = max_subarray_sum_divide_and_conquer(nums, left, mid) max_right_sum = max_subarray_sum_divide_and_conquer(nums, mid + 1, right) left_sum = float(\'-inf\') current_sum = 0 for i in range(mid, left - 1, -1): current_sum += nums[i] left_sum = max(left_sum, current_sum) right_sum = float(\'-inf\') current_sum = 0 for i in range(mid + 1, right + 1): current_sum += nums[i] right_sum = max(right_sum, current_sum) return max(max_left_sum, max_right_sum, left_sum + right_sum)"},{"question":"# Question: Implement an Efficient Directory Size Calculator You are required to implement a function that calculates the total size of all files within a directory and its subdirectories. This is a common task in file system management and can be used to monitor storage usage. **Function Signature:** ```python def calculate_directory_size(directory_path: str) -> int: # Your code here ``` # Input Format The `calculate_directory_size` function should accept a single string `directory_path`, which is the path to the directory whose size you need to calculate. # Output Format The function should return an integer representing the total size (in bytes) of all files within the given directory and its subdirectories. # Constraints - The function should handle large directories efficiently. - You can assume the path provided is valid and accessible. - The directory may contain other directories, and you should calculate the size recursively. # Example ```python # Assume the directory structure is as follows: # dir/ # ├── file1.txt (100 bytes) # ├── subdir1/ # │ ├── file2.txt (200 bytes) # │ └── file3.txt (300 bytes) # └── subdir2/ # └── file4.txt (400 bytes) total_size = calculate_directory_size(\'dir\') assert total_size == 1000 ``` In the example, the total size of all files in \'dir\' and its subdirectories is calculated as 1000 bytes (100 + 200 + 300 + 400). # Notes - Ensure your function correctly sums the sizes for any depth of nested directories. - Use appropriate error handling for any file reading issues (e.g., permissions). - Optimize for performance, especially for directories with a large number of files.","solution":"import os def calculate_directory_size(directory_path: str) -> int: Calculate the total size of all files within a directory and its subdirectories. Args: directory_path (str): The path to the directory whose size is to be calculated. Returns: int: The total size of all files in bytes. total_size = 0 for dirpath, dirnames, filenames in os.walk(directory_path): for file in filenames: file_path = os.path.join(dirpath, file) if os.path.isfile(file_path): total_size += os.path.getsize(file_path) return total_size"},{"question":"# Background You are given a rectangular grid with cells that can either be open or blocked. You need to determine the shortest path from a start cell to a target cell while avoiding blocked cells. The grid cells are marked with \'0\' for open cells and \'1\' for blocked cells. You can move up, down, left, or right, but cannot move diagonally. # Problem Write a function `shortest_path` to find the minimum number of steps required to reach the target cell from the start cell in the given grid. If there is no possible path, return -1. # Function Signature ```python def shortest_path(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> int: pass ``` # Input * `grid` (List[List[int]]): A rectangular grid where \'0\' represents an open cell and \'1\' represents a blocked cell. * `start` (Tuple[int, int]): The starting cell coordinates as (row, column). * `target` (Tuple[int, int]): The target cell coordinates as (row, column). # Output * Returns an integer representing the minimum number of steps to reach the target cell from the start cell. Return -1 if no path exists. # Example ```python grid = [ [0, 0, 0], [1, 1, 0], [0, 0, 0] ] start = (0, 0) target = (2, 2) shortest_path(grid, start, target) # Returns: 4 grid = [ [0, 1], [1, 0] ] start = (0, 0) target = (1, 1) shortest_path(grid, start, target) # Returns: -1 ``` # Constraints * The grid size will be at most 100x100. * The start and target cells are guaranteed to be within the grid boundaries. * The grid will contain at least one cell (1x1). * The start cell and target cell will always be open (grid[start[0]][start[1]] == 0 and grid[target[0]][target[1]] == 0). # Additional Notes * Use a breadth-first search (BFS) to efficiently find the shortest path in an unweighted grid. * Avoid processing cells outside the grid boundary. * Ensure the function handles edge cases like grids with all cells open or all cells blocked efficiently.","solution":"from collections import deque from typing import List, Tuple def shortest_path(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> int: # Edge case: start and target are the same if start == target: return 0 # Initialize BFS queue and visited set rows, cols = len(grid), len(grid[0]) queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add((start[0], start[1])) # Define the 4 possible movements: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Perform BFS while queue: row, col, dist = queue.popleft() # Explore all 4 directions for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited: # If we reach the target, return the distance if (new_row, new_col) == target: return dist + 1 # If it\'s an open cell, add it to the queue and mark as visited if grid[new_row][new_col] == 0: queue.append((new_row, new_col, dist + 1)) visited.add((new_row, new_col)) # If no path is found, return -1 return -1"},{"question":"# Question You\'re given a sequence of integers and a fixed-length window size. Implement a function `moving_average` to compute the moving average of the sequence with the given window size. # Constraints 1. The sequence must contain at least one integer. 2. The window size must be a positive integer and less than or equal to the length of the sequence. # Function Signature ```python def moving_average(sequence: List[int], window_size: int) -> List[float]: ... ``` # Input Format - `sequence`: A list of integers. - `window_size`: An integer representing the size of the moving window. # Output Format - A list of floats representing the moving averages with the given window size. # Example ```python sequence = [1, 3, 5, 7, 9, 11] window_size = 3 output = moving_average(sequence, window_size) print(output) # Expected: [3.0, 5.0, 7.0, 9.0] ``` # Additional Requirements: 1. Raise a `ValueError` if the window size is less than 1 or greater than the length of the sequence.","solution":"from typing import List def moving_average(sequence: List[int], window_size: int) -> List[float]: Computes the moving average of the sequence with the given window size. Args: sequence (List[int]): The list of integers. window_size (int): The size of the moving window. Returns: List[float]: A list of floats representing the moving averages. Raises: ValueError: If window_size is less than 1 or greater than the length of the sequence. if window_size < 1 or window_size > len(sequence): raise ValueError(\\"Window size must be a positive integer and less than or equal to the length of the sequence.\\") moving_averages = [] for i in range(len(sequence) - window_size + 1): window = sequence[i:i + window_size] window_average = sum(window) / window_size moving_averages.append(window_average) return moving_averages"},{"question":"# Problem Description You are tasked with implementing a basic LRU (Least Recently Used) Cache mechanism. An LRU cache is designed to store a limited number of items with efficient retrieval and storage, where the least recently used item is removed when the capacity is exceeded. # Requirements - Implement the LRU Cache class with the following methods: - `get(key)`: Retrieves an item from the cache. Returns the value if the key exists, otherwise returns -1. - `put(key, value)`: Inserts or updates the value. If the cache reaches its capacity, it should remove the least recently used item. - Utilize a combination of a hash map (dictionary) for quick look-up and a double-ended queue (deque) for maintaining the usage order. # Constraints - All keys and values are integers. - The cache capacity is a positive integer. - Methods should operate in O(1) time complexity on average. # Input The input is a sequence of operations to be performed on the LRU Cache. Each operation is represented by a tuple. - For a `put` operation, the tuple is in the form: `(\\"put\\", key, value)`. - For a `get` operation, the tuple is in the form: `(\\"get\\", key)`. For example: ``` [ (\\"put\\", 1, 1), (\\"put\\", 2, 2), (\\"get\\", 1), (\\"put\\", 3, 3), (\\"get\\", 2), (\\"put\\", 4, 4), (\\"get\\", 1), (\\"get\\", 3), (\\"get\\", 4) ] ``` # Output The output should be a list of values returned by the `get` operations, in the order they were called. For example: ``` [1, -1, -1, 3, 4] ``` # Example Given the sequence of operations: ``` [ (\\"put\\", 1, 1), (\\"put\\", 2, 2), (\\"get\\", 1), (\\"put\\", 3, 3), (\\"get\\", 2), (\\"put\\", 4, 4), (\\"get\\", 1), (\\"get\\", 3), (\\"get\\", 4) ] ``` The corresponding outputs should be: ``` [1, -1, -1, 3, 4] ``` # Implementation Details 1. **LRUCache Class**: - Use a dictionary to map keys to values and track usage. - Use a deque to maintain the order of usage, enabling efficient addition and removal from both ends. # Code Template ```python from collections import deque class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.usage_order = deque() def get(self, key: int) -> int: if key in self.cache: self._update_usage(key) return self.cache[key] return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.cache[key] = value self._update_usage(key) else: if len(self.cache) == self.capacity: oldest = self.usage_order.popleft() del self.cache[oldest] self.cache[key] = value self.usage_order.append(key) def _update_usage(self, key: int) -> None: self.usage_order.remove(key) self.usage_order.append(key) def process_cache_operations(ops: list): outputs = [] cache = LRUCache(2) for op in ops: if op[0] == \\"put\\": cache.put(op[1], op[2]) elif op[0] == \\"get\\": outputs.append(cache.get(op[1])) return outputs # Example usage: # ops = [(\\"put\\", 1, 1), (\\"put\\", 2, 2), (\\"get\\", 1), (\\"put\\", 3, 3), (\\"get\\", 2), (\\"put\\", 4, 4), (\\"get\\", 1), (\\"get\\", 3), (\\"get\\", 4)] # assert process_cache_operations(ops) == [1, -1, -1, 3, 4] ```","solution":"from collections import deque class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.usage_order = deque() def get(self, key: int) -> int: if key in self.cache: self._update_usage(key) return self.cache[key] return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.cache[key] = value self._update_usage(key) else: if len(self.cache) == self.capacity: oldest = self.usage_order.popleft() del self.cache[oldest] self.cache[key] = value self.usage_order.append(key) def _update_usage(self, key: int) -> None: self.usage_order.remove(key) self.usage_order.append(key) def process_cache_operations(ops: list, capacity: int): outputs = [] cache = LRUCache(capacity) for op in ops: if op[0] == \\"put\\": cache.put(op[1], op[2]) elif op[0] == \\"get\\": outputs.append(cache.get(op[1])) return outputs"},{"question":"# Coding Assessment Question: Scenario: You are developing a simple text manipulation library for a text processing application. One of the functions that needs to be implemented is to remove all vowels from a given string. Task: Write a function `remove_vowels(text: str) -> str` that: 1. Accepts a single string `text` as input. 2. Removes all vowels (both uppercase and lowercase) from the input string. 3. Returns the resulting string after vowels have been removed. Input: - A string `text` containing a mix of characters including spaces, punctuation marks, and possible non-alphabetic characters. Output: - A string with all vowels removed, preserving the relative order of the other characters. Constraints: - If the input is not a string, raise a `TypeError`. Example: ```python remove_vowels(\\"Hello World!\\") # Returns \'Hll Wrld!\' remove_vowels(\\"Programming is fun\\") # Returns \'Prgrmmng s fn\' remove_vowels(\\"AEIOU are vowels\\") # Returns \' r vwls\' ``` Requirements: - Ensure the function handles cases with both uppercase and lowercase vowels. - Implement error handling for invalid input types. - Optimize for performance while keeping the code clear and maintainable.","solution":"def remove_vowels(text: str) -> str: Removes all vowels from the input string. Parameters: text (str): The input string. Returns: str: The resulting string after removing all vowels. Raises: TypeError: If input is not a string. if not isinstance(text, str): raise TypeError(\\"Input must be a string\\") vowels = \\"aeiouAEIOU\\" return \'\'.join(char for char in text if char not in vowels)"},{"question":"# Problem Statement In an effort to improve the performance of a data processing pipeline, you are tasked with implementing a custom version of the MapReduce algorithm. The goal is to design a simple and efficient Python function that mimics the behavior of the MapReduce paradigm to transform and reduce large datasets. The implementation should handle various forms of data and provide accurate and optimized results for a wide range of operations. # Function Signature ```python def custom_map_reduce(map_func, reduce_func, data): Apply the MapReduce algorithm to transform and reduce an input list of data. Parameters: map_func -- A function to map each element to a key-value pair reduce_func -- A function to reduce the values of each key data -- An iterable containing the data to be processed Output: A dictionary with the reduced values for each unique key pass ``` # Example Usage ```python >>> def map_func(x): ... return (x, 1) >>> def reduce_func(values): ... return sum(values) >>> data = [1, 2, 2, 3, 3, 3] >>> result = custom_map_reduce(map_func, reduce_func, data) >>> result {1: 1, 2: 2, 3: 3} ``` # Requirements 1. **Input Constraints**: - `map_func` must be callable with one argument and return a tuple (key, value). - `reduce_func` must be callable with an iterable of values and return a single value. - `data` is an iterable (list, tuple, set, etc.) containing elements to be processed. 2. **Output**: - The function should return a dictionary where each key is associated with the reduced value after the `reduce_func` has been applied to all mapped values for that particular key. 3. **Performance Consideration**: - Ensure the function processes the data efficiently, utilizing appropriate data structures. - Optimize both the mapping and reducing steps to handle large datasets within reasonable timeframes. # Background Context MapReduce is a programming model suitable for processing large data sets with a distributed algorithm on a cluster. Implementing a custom MapReduce function in Python will enhance your understanding of data transformation and reduction principles, especially significant in data analysis and processing pipelines. Your task is to create an efficient and scalable solution emulating the core MapReduce functionalities.","solution":"def custom_map_reduce(map_func, reduce_func, data): Apply the MapReduce algorithm to transform and reduce an input list of data. Parameters: map_func -- A function to map each element to a key-value pair reduce_func -- A function to reduce the values of each key data -- An iterable containing the data to be processed Output: A dictionary with the reduced values for each unique key from collections import defaultdict mapped_data = defaultdict(list) # Perform mapping for item in data: key, value = map_func(item) mapped_data[key].append(value) # Perform reducing reduced_data = {key: reduce_func(values) for key, values in mapped_data.items()} return reduced_data"},{"question":"# **Coding Challenge: Inventory Management System with Binary Search Tree** Context You are tasked with designing an inventory management system for a warehouse. The system needs to store items with unique integer IDs and perform the following operations efficiently: 1. Add a new item with a specific ID. 2. Remove an existing item by its ID. 3. Check if an item with a given ID exists in the inventory. 4. Find the item with the minimum ID. 5. Find the item with the maximum ID. A Binary Search Tree (BST) is an appropriate data structure to handle such operations efficiently. Task Implement the Binary Search Tree for managing the inventory items. Input and Output Formats **Input**: 1. A list of operations to perform. Each operation is represented as a list where the first element is a string indicating the type of operation (`\\"add\\"`, `\\"remove\\"`, `\\"exists\\"`, `\\"min\\"`, or `\\"max\\"`), followed by appropriate parameters (if any) for the operation. ``` Example: operations = [[\\"add\\", 4], [\\"add\\", 2], [\\"add\\", 6], [\\"min\\"], [\\"max\\"], [\\"exists\\", 4], [\\"remove\\", 2], [\\"exists\\", 2]] ``` **Output**: 1. For `\\"exists\\"` operations, return `True` or `False` indicating the existence of the item. 2. For `\\"min\\"` and `\\"max\\"` operations, return the minimum or maximum item ID respectively. 3. For `\\"add\\"` and `\\"remove\\"` operations, no output is required. Requirements 1. **Function Signature**: ```python class TreeNode: def __init__(self, key: int): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): # initialize the root of the BST self.root = None def add(self, key: int): # add the item with the given key pass def remove(self, key: int): # remove the item with the given key pass def exists(self, key: int) -> bool: # return True if the item exists, otherwise False pass def find_min(self) -> int: # return the minimum item ID pass def find_max(self) -> int: # return the maximum item ID pass def execute_operations(operations: List[List[Union[str, int]]]) -> List[Union[bool, int]]: # perform the operations on the BST and return the results for exists, min, and max operations pass ``` 2. **Constraints**: * The item IDs will be integers within the range `[1, 10^6]`. * The number of operations `q` will be such that `1 <= q <= 10^4`. Example ```python # Input operations = [[\\"add\\", 4], [\\"add\\", 2], [\\"add\\", 6], [\\"min\\"], [\\"max\\"], [\\"exists\\", 4], [\\"remove\\", 2], [\\"exists\\", 2]] # Output (based on the example operations) [2, 6, True, False] ``` **Note:** The binary search tree should be implemented from scratch and directly using standard Python structures (do not use additional libraries that abstract the BST functionalities).","solution":"class TreeNode: def __init__(self, key: int): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def add(self, key: int): if self.root is None: self.root = TreeNode(key) else: self._add(self.root, key) def _add(self, node: TreeNode, key: int): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._add(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._add(node.right, key) def remove(self, key: int): self.root = self._remove(self.root, key) def _remove(self, node: TreeNode, key: int) -> TreeNode: if node is None: return None if key < node.val: node.left = self._remove(node.left, key) elif key > node.val: node.right = self._remove(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left min_larger_node = self._find_min(node.right) node.val = min_larger_node.val node.right = self._remove(node.right, node.val) return node def exists(self, key: int) -> bool: return self._exists(self.root, key) def _exists(self, node: TreeNode, key: int) -> bool: if node is None: return False if key == node.val: return True elif key < node.val: return self._exists(node.left, key) else: return self._exists(node.right, key) def find_min(self) -> int: if self.root is None: raise ValueError(\\"BST is empty\\") return self._find_min(self.root).val def _find_min(self, node: TreeNode) -> TreeNode: current = node while current.left is not None: current = current.left return current def find_max(self) -> int: if self.root is None: raise ValueError(\\"BST is empty\\") return self._find_max(self.root).val def _find_max(self, node: TreeNode) -> TreeNode: current = node while current.right is not None: current = current.right return current def execute_operations(operations): bst = BinarySearchTree() result = [] for operation in operations: op = operation[0] if op == \\"add\\": bst.add(operation[1]) elif op == \\"remove\\": bst.remove(operation[1]) elif op == \\"exists\\": result.append(bst.exists(operation[1])) elif op == \\"min\\": result.append(bst.find_min()) elif op == \\"max\\": result.append(bst.find_max()) return result"},{"question":"# Problem Statement You are tasked with creating a scheduling system for a small office that has multiple rooms and multiple events happening throughout the day. Each event has a specific start and end time, and it takes place in a specific room. The goal is to determine if a new event can be added to the schedule without causing any conflicts with the existing events. Write a program that, given a list of existing events and a new event, checks if the new event can be added without overlapping with any existing events in the same room. # Requirements: 1. Implement a function `can_add_event(existing_events: List[Tuple[int, int, str]], new_event: Tuple[int, int, str]) -> bool` that returns `True` if the new event can be added without conflicts, and `False` otherwise. 2. An event is represented as a tuple containing the start time, end time, and room name (e.g., `(start, end, room)`). 3. The function should check for conflicts only within the same room. 4. Assume time is represented in a 24-hour format without the need for date information (e.g., `(13:30, 15:00, \\"Conference Room\\")`). # Inputs and Outputs: - **Input**: - `existing_events`: A list of tuples, each representing an existing event in the format `(start_time, end_time, room_name)`. - `new_event`: A tuple representing the new event in the format `(start_time, end_time, room_name)`. - **Output**: A single boolean value indicating whether the new event can be added without conflicts. # Function Signature ```python def can_add_event(existing_events: List[Tuple[int, int, str]], new_event: Tuple[int, int, str]) -> bool: pass ``` # Example ```python def can_add_event(existing_events: List[Tuple[int, int, str]], new_event: Tuple[int, int, str]) -> bool: ... events = [ (9, 10, \\"Room A\\"), (10, 11, \\"Room A\\"), (11, 12, \\"Room B\\"), (13, 14, \\"Room A\\") ] new_event = (11, 12, \\"Room A\\") print(can_add_event(events, new_event)) # Expected output: True new_event = (10, 11, \\"Room A\\") print(can_add_event(events, new_event)) # Expected output: False ``` # Constraints: 1. Assume each event in `existing_events` has a valid non-overlapping schedule. 2. The `start_time` of an event is always less than its `end_time`. 3. The check for conflicts should only consider events that are in the same room. # Notes: - Consider edge cases such as events that just touch each other at the start or end times. - You may find it useful to sort the existing events based on their start times for efficient conflict checking.","solution":"def can_add_event(existing_events, new_event): Given a list of existing events and a new event, check if the new event can be added without conflicts in the specified room. Parameters: existing_events (List[Tuple[int, int, str]]): List of existing events. new_event (Tuple[int, int, str]): The new event that needs to be checked. Returns: bool: True if the new event can be added without conflicts, False otherwise. new_start, new_end, new_room = new_event for start, end, room in existing_events: if room == new_room: # Check for overlapping times if not (new_end <= start or new_start >= end): return False return True"},{"question":"# Coding Question Context You are developing a custom logging system for a web application to keep track of user activities. The current implementation logs all activities into a single file without any distinction between different types of activities or severity levels. Task Write a function `log_activity` that categorizes and logs user activities more systematically. Implement severity levels, rotating log files, and proper error handling. Function Signature ```python def log_activity(activity_type: str, message: str, severity: str) -> None: pass ``` Requirements 1. **Input**: * `activity_type` (str): The type of user activity (e.g., \\"LOGIN\\", \\"SIGNUP\\", \\"ERROR\\"). * `message` (str): A descriptive message of the activity. * `severity` (str): The severity level of the activity (e.g., \\"INFO\\", \\"WARNING\\", \\"ERROR\\"). 2. **Output**: None 3. **Constraints**: * Log messages should be categorized based on `activity_type`. * Implement a severity level system where only `ERROR` messages are logged in a separate file. * Implement log file rotation: when a log file exceeds 5MB, it should be archived, and a new log file should be created. * Make sure to handle cases where the log file cannot be accessed or written to. 4. **Performance**: * Ensure the rotating log mechanism does not block user activities logging. * Handle concurrent logging by multiple processes/users efficiently. Example: ```python if __name__ == \\"__main__\\": log_activity(activity_type=\\"LOGIN\\", message=\\"User \'Alice\' logged in\\", severity=\\"INFO\\") log_activity(activity_type=\\"SIGNUP\\", message=\\"User \'Bob\' signed up\\", severity=\\"INFO\\") log_activity(activity_type=\\"ERROR\\", message=\\"Failed to load user profile\\", severity=\\"ERROR\\") ``` Notes: * Implement clear and concise logging formats. * Make use of Python\'s built-in logging library to facilitate the implementation. * Include comments and error handling to ensure robustness.","solution":"import logging from logging.handlers import RotatingFileHandler import os def setup_logger(name, log_file, level=logging.INFO): Function to setup a logger logger = logging.getLogger(name) logger.setLevel(level) handler = RotatingFileHandler(log_file, maxBytes=5 * 1024 * 1024, backupCount=1) handler.setFormatter(logging.Formatter(\'%(asctime)s - %(name)s - %(levelname)s - %(message)s\')) logger.addHandler(handler) return logger def log_activity(activity_type: str, message: str, severity: str) -> None: try: os.makedirs(\'logs\', exist_ok=True) log_file = f\'logs/{activity_type.lower()}.log\' logger = setup_logger(activity_type, log_file) severity_levels = { \\"DEBUG\\": logging.DEBUG, \\"INFO\\": logging.INFO, \\"WARNING\\": logging.WARNING, \\"ERROR\\": logging.ERROR, \\"CRITICAL\\": logging.CRITICAL } if severity not in severity_levels: raise ValueError(\\"Invalid severity level\\") if severity == \\"ERROR\\": error_logger = setup_logger(\'ERROR\', \'logs/error.log\', logging.ERROR) error_logger.error(message) logger.log(severity_levels[severity], message) except Exception as e: print(f\\"Failed to log activity: {e}\\")"},{"question":"# Network Packet Analyzer You are tasked with developing a network packet analyzer for monitoring data packets in a network. The goal is to identify and categorize packets based on their properties and calculate some statistics over a series of packet transmissions. **Objective**: Implement functions that categorize packets and compute summary statistics based on the packet types and sizes. Input: 1. `packet_generator(packet_count: int, max_size: int) -> list` * Generates and returns a list of packets with each packet being represented as a dictionary. Each packet dictionary has two keys: \\"size\\" (integer) and \\"type\\" (string). 2. `packets`: A list of packet dictionaries generated by `packet_generator`. Output: - A dictionary containing the total number of packets, the total size, and the count of each type of packet. # Function Definitions: 1. Create packets using the `packet_generator(packet_count: int, max_size: int) -> list` function. 2. Analyze packets using the `analyze_packets(packets: list) -> dict` function. # Example: ```python >>> packets = packet_generator(5, 100) >>> packets [{\'size\': 45, \'type\': \'TCP\'}, {\'size\': 32, \'type\': \'UDP\'}, {\'size\': 73, \'type\': \'TCP\'}, {\'size\': 28, \'type\': \'ICMP\'}, {\'size\': 88, \'type\': \'UDP\'}] >>> analyze_packets(packets) { \'total_packets\': 5, \'total_size\': 266, \'type_counts\': { \'TCP\': 2, \'UDP\': 2, \'ICMP\': 1 } } ``` Constraints: 1. `packet_count` will be in the range `[1, 10^3]`. 2. `max_size` will be in the range `[1, 10^3]`. Make sure to handle edge cases like packets with the same type or empty packet list in your function implementation. # Functions: 1. `packet_generator(packet_count: int, max_size: int) -> list`: - Generate a list of packets with random sizes between 1 and `max_size` and random types among a predefined list (e.g., [\'TCP\', \'UDP\', \'ICMP\']). 2. `analyze_packets(packets: list) -> dict`: - Calculate the total number of packets. - Calculate the total size of all packets. - Count the occurrences of each type of packet and return this information in a dictionary format. Your implementation should ensure efficient processing of the input list and aim for clarity and maintainability in your function definitions.","solution":"import random def packet_generator(packet_count, max_size): Generates a list of packets where each packet is represented as a dictionary with \'size\' and \'type\' keys. :param packet_count: Number of packets to generate. :param max_size: Maximum size for each packet. :return: List of packet dictionaries. packet_types = [\'TCP\', \'UDP\', \'ICMP\'] packets = [] for _ in range(packet_count): packet = { \'size\': random.randint(1, max_size), \'type\': random.choice(packet_types) } packets.append(packet) return packets def analyze_packets(packets): Analyzes a list of packets to calculate total number of packets, total size, and count per packet type. :param packets: List of packet dictionaries to analyze. :return: Dictionary containing total_packets, total_size, and type_counts. total_packets = len(packets) total_size = sum(packet[\'size\'] for packet in packets) type_counts = {} for packet in packets: packet_type = packet[\'type\'] if packet_type in type_counts: type_counts[packet_type] += 1 else: type_counts[packet_type] = 1 return { \'total_packets\': total_packets, \'total_size\': total_size, \'type_counts\': type_counts }"},{"question":"# Binary Search Tree Operations The following task requires you to implement and enhance operations on a Binary Search Tree (BST). You will be provided with partial class definitions to complete and ensure the BST functions as intended. Task 1. **Complete the `insert` method**: The `insert` method should add a new node to the BST, maintaining the BST property. 2. **Complete the `find` method**: The `find` method should search for a node with a given key and return the corresponding node. 3. **Implement the `delete` method**: The `delete` method should remove a node with a given key from the BST, ensuring the BST property remains intact. 4. **Enhance Error Handling**: Ensure appropriate error handling in all methods to handle cases like inserting duplicate keys, deleting non-existent keys, and invalid inputs. # Input and Output Input * `insert` method: - `key`: Integer representing the node\'s key to insert. - `value`: Any type representing the node\'s value to associate with the key. * `find` method: - `key`: Integer representing the key to search for. * `delete` method: - `key`: Integer representing the node\'s key to delete. Output * `insert` method: None. This method inserts a new node into the BST. * `find` method: The node\'s value if the key is found; otherwise, an appropriate error message. * `delete` method: None. This method deletes the specified node from the BST. # Constraints 1. The BST should not allow duplicate keys. 2. Ensure the `find` method returns appropriately when the key is not found. 3. Handle deletion scenarios where the node has no children, one child, or two children effectively. 4. The operations should handle up to 10,000 nodes efficiently. # Example Here\'s an example usage of the completed class and methods: ```python class Node: def __init__(self, key, value): self.key = key self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key, value): Insert a new node with the given key and value into the BST. if self.root is None: self.root = Node(key, value) else: self._insert(self.root, key, value) def _insert(self, node, key, value): if key < node.key: if node.left is None: node.left = Node(key, value) else: self._insert(node.left, key, value) elif key > node.key: if node.right is None: node.right = Node(key, value) else: self._insert(node.right, key, value) else: raise ValueError(\\"Cannot insert duplicate key.\\") def find(self, key): Find and return the node\'s value with the given key. return self._find(self.root, key) def _find(self, node, key): if node is None: raise ValueError(\\"Key not found.\\") elif key == node.key: return node.value elif key < node.key: return self._find(node.left, key) else: return self._find(node.right, key) def delete(self, key): Delete the node with the specified key from the BST. self.root = self._delete(self.root, key) def _delete(self, node, key): if node is None: raise ValueError(\\"Key not found.\\") if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if node.left is None and node.right is None: return None elif node.left is None: return node.right elif node.right is None: return node.left min_larger_node = self._find_min(node.right) node.key, node.value = min_larger_node.key, min_larger_node.value node.right = self._delete(node.right, min_larger_node.key) return node def _find_min(self, node): while node.left is not None: node = node.left return node # Sample data for testing bst = BST() bst.insert(10, \\"Value for 10\\") bst.insert(5, \\"Value for 5\\") bst.insert(20, \\"Value for 20\\") bst.insert(3, \\"Value for 3\\") bst.insert(7, \\"Value for 7\\") # Finding a node value = bst.find(10) print(value) # Expected output: \\"Value for 10\\" # Deleting a node bst.delete(10) try: bst.find(10) except ValueError as e: print(e) # Expected output: \\"Key not found.\\" ``` Incorporate the provided elements accurately and ensure your implementation achieves robust functionality according to the specifications. # Submission Guidelines For your submission, provide the complete implementation of the `BST` class with all specified methods and appropriate error handling. Ensure comprehensive testing for all implemented methods. Do not include example code or tests in your final submission, but ensure the class is capable of handling the above example correctly.","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key, value): Insert a new node with the given key and value into the BST. if self.root is None: self.root = Node(key, value) else: self._insert(self.root, key, value) def _insert(self, node, key, value): if key < node.key: if node.left is None: node.left = Node(key, value) else: self._insert(node.left, key, value) elif key > node.key: if node.right is None: node.right = Node(key, value) else: self._insert(node.right, key, value) else: raise ValueError(\\"Cannot insert duplicate key.\\") def find(self, key): Find and return the node\'s value with the given key. return self._find(self.root, key) def _find(self, node, key): if node is None: raise ValueError(\\"Key not found.\\") elif key == node.key: return node.value elif key < node.key: return self._find(node.left, key) else: return self._find(node.right, key) def delete(self, key): Delete the node with the specified key from the BST. self.root = self._delete(self.root, key) def _delete(self, node, key): if node is None: raise ValueError(\\"Key not found.\\") if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if node.left is None and node.right is None: return None elif node.left is None: return node.right elif node.right is None: return node.left min_larger_node = self._find_min(node.right) node.key, node.value = min_larger_node.key, min_larger_node.value node.right = self._delete(node.right, min_larger_node.key) return node def _find_min(self, node): while node.left is not None: node = node.left return node"},{"question":"# Coding Question Context You have been given a function `find_closest_pair` designed to find two distinct numbers in a list whose sums come closest to, but do not exceed a given target. Your job is to optimize this function ensuring it has the optimal time and space complexity. Problem Statement Implement the function `find_closest_pair` such that: 1. Given a list of integers and a target sum, it returns a tuple containing the pair of integers from the list that come closest to the target sum without exceeding it. 2. If no such pair exists, return `None`. ```python def find_closest_pair(nums, target): Finds the pair of integers whose sum is closest to, but does not exceed, the target sum. Parameters: nums (List[int]): The list of integers. target (int): The target sum. Returns: Tuple[int, int] or None: A tuple of two integers whose sum is closest to, but does not exceed, the target. Return None if no such pair exists. pass ``` Constraints 1. The function should work within O(n log n) time complexity where n is the length of the input list. 2. The list of numbers will have at least two elements. 3. All list elements are unique integers. 4. You can assume all input integers are within the range -10^6 to 10^6. Example ```python nums = [10, 22, 28, 29, 30, 40] target = 54 print(find_closest_pair(nums, target)) # Output: (22, 30) nums = [-1, 3, 4, 5, 7, 9] target = 15 print(find_closest_pair(nums, target)) # Output: (5, 9) nums = [1, 3, 4, 5, 9] target = 2 print(find_closest_pair(nums, target)) # Output: (1, 1) ``` # Note 1. The returned pair (a, b) should be such that a + b is the highest possible sum that does not exceed the given target. 2. If there are multiple pairs with the same sum, return any one of them. # Performance Requirements The solution should be optimized to handle large inputs efficiently, aiming for a time complexity of about O(n log n) if sorting is required or better if possible.","solution":"def find_closest_pair(nums, target): Finds the pair of integers whose sum is closest to, but does not exceed, the target sum. Parameters: nums (List[int]): The list of integers. target (int): The target sum. Returns: Tuple[int, int] or None: A tuple of two integers whose sum is closest to, but does not exceed, the target. Return None if no such pair exists. nums.sort() left, right = 0, len(nums) - 1 closest_sum = float(\'-inf\') closest_pair = None while left < right: current_sum = nums[left] + nums[right] if current_sum > target: right -= 1 else: if current_sum > closest_sum: closest_sum = current_sum closest_pair = (nums[left], nums[right]) left += 1 return closest_pair"},{"question":"# Validate and Convert Roman Numerals Problem Description: You are required to implement a function that validates a given Roman numeral string and converts it into its decimal (base-10) equivalent integer. The Roman numeral should follow the standard rules and symbols described below. Function Signature: ```python def roman_to_decimal(roman_string: str) -> int: ``` Input: * A string `roman_string` which contains: - A valid combination of Roman numeral symbols (\'I\', \'V\', \'X\', \'L\', \'C\', \'D\', \'M\'). - Leading and trailing whitespaces that should be ignored. - An empty string or invalid Roman numeral will result in a `ValueError` with an appropriate message. Output: * Returns an integer which is the decimal (base-10) equivalent of the given Roman numeral. Constraints and Considerations: * You must handle the following cases: - If `roman_string` is an empty string, raise a `ValueError` with the message: `\\"Empty string was passed to the function\\"`. - If `roman_string` contains invalid Roman numeral characters, raise a `ValueError` with the message: `\\"Invalid Roman numeral was passed to the function\\"`. - Handle both uppercase and lowercase Roman numeral strings. - Whitespace around the string should be ignored. Samples: ```python >>> roman_to_decimal(\\"XII\\") 12 >>> roman_to_decimal(\\"iv\\") 4 >>> roman_to_decimal(\\" mcmxc \\") 1990 >>> roman_to_decimal(\\"\\") Traceback (most recent call last): ... ValueError: Empty string was passed to the function >>> roman_to_decimal(\\"ABC\\") Traceback (most recent call last): ... ValueError: Invalid Roman numeral was passed to the function ``` Implementation Notes: 1. Strip any leading/trailing whitespaces from the input. 2. Check for empty input and raise a `ValueError` if the string is empty. 3. Ensure all characters in the string are valid Roman numeral symbols or raise a `ValueError`. 4. Convert the lowercase Roman numerals to uppercase for consistency. 5. Perform the conversion from Roman numeral to decimal using standard rules. 6. Return the correct decimal result. Roman Numeral Basics: - Symbols: I = 1, V = 5, X = 10, L = 50, C = 100, D = 500, and M = 1000. - Subtractive notation: e.g., IV = 4, IX = 9, XL = 40, XC = 90, CD = 400, CM = 900. ```python def roman_to_decimal(roman_string: str) -> int: roman_to_int = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } roman_string = roman_string.strip().upper() if not roman_string: raise ValueError(\\"Empty string was passed to the function\\") total, prev_val = 0, 0 for char in roman_string: if char not in roman_to_int: raise ValueError(\\"Invalid Roman numeral was passed to the function\\") current_val = roman_to_int[char] total += current_val if current_val <= prev_val else current_val - 2 * prev_val prev_val = current_val return total ``` This question matches the length, complexity, and style of the original question. It touches on validation, string manipulation, and involves simple arithmetic operations, similar to the octal to decimal conversion task.","solution":"def roman_to_decimal(roman_string: str) -> int: roman_to_int = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } roman_string = roman_string.strip().upper() if not roman_string: raise ValueError(\\"Empty string was passed to the function\\") total, prev_val = 0, 0 for char in roman_string: if char not in roman_to_int: raise ValueError(\\"Invalid Roman numeral was passed to the function\\") current_val = roman_to_int[char] if current_val > prev_val: total += current_val - 2 * prev_val else: total += current_val prev_val = current_val return total"},{"question":"# Question You are tasked with creating a mini database management system that supports basic CRUD (Create, Read, Update, Delete) operations. The system will maintain records in memory and offer operations to manipulate these records through predefined functions. Function Specifications: 1. **add_record(record_id: int, data: dict) -> None** * Adds a new record with a unique `record_id` and the corresponding `data`. * If the `record_id` already exists, the function should raise a `ValueError`. 2. **get_record(record_id: int) -> dict** * Retrieves the record associated with the provided `record_id`. * If the `record_id` does not exist, the function should raise a `KeyError`. 3. **update_record(record_id: int, data: dict) -> None** * Updates an existing record with the given `record_id` with the new `data`. * If the `record_id` does not exist, the function should raise a `KeyError`. 4. **delete_record(record_id: int) -> None** * Deletes the record associated with the provided `record_id`. * If the `record_id` does not exist, the function should raise a `KeyError`. Input/Output Requirements: * The system should handle multiple records, where each record is uniquely identified by an integer `record_id`. * Records should be stored in a dictionary format where keys are the `record_id` and values are the corresponding data dictionaries. * No constraints on the data dictionary\'s structure but assume it will contain only serializable data types (e.g., strings, numbers, lists, nested dictionaries). Constraints: * Ensure that each function operates with O(1) average time complexity for CRUD operations. * Use appropriate error handling to manage the conditions where records don\'t exist or already exist, as specified. Example: ```python def test_mini_database(): database = {} def add_record(record_id, data): if record_id in database: raise ValueError(\\"Duplicate record_id\\") database[record_id] = data def get_record(record_id): if record_id not in database: raise KeyError(\\"Record not found\\") return database[record_id] def update_record(record_id, data): if record_id not in database: raise KeyError(\\"Record not found\\") database[record_id] = data def delete_record(record_id): if record_id not in database: raise KeyError(\\"Record not found\\") del database[record_id] # Adding a new record add_record(1, {\\"name\\": \\"Alice\\", \\"age\\": 30}) assert get_record(1) == {\\"name\\": \\"Alice\\", \\"age\\": 30} # Updating the record update_record(1, {\\"name\\": \\"Alice\\", \\"age\\": 31}) assert get_record(1) == {\\"name\\": \\"Alice\\", \\"age\\": 31} # Deleting the record delete_record(1) try: get_record(1) except KeyError: assert True # Trying to add a duplicate record add_record(2, {\\"name\\": \\"Bob\\", \\"age\\": 25}) try: add_record(2, {\\"name\\": \\"Bob\\", \\"age\\": 25}) except ValueError: assert True test_mini_database() ``` Additional Context: Imagine you are developing this system to be used in a small in-memory application that does not require persistence but needs efficient handling of records for temporary storage and quick access. This system is intended for scenarios where quick data manipulation is critical and where data persistence is not necessary. You are expected to implement these functions with appropriate error handling and efficient CRUD operations as specified.","solution":"class MiniDatabase: def __init__(self): self.records = {} def add_record(self, record_id: int, data: dict) -> None: if record_id in self.records: raise ValueError(f\\"Record with ID {record_id} already exists.\\") self.records[record_id] = data def get_record(self, record_id: int) -> dict: if record_id not in self.records: raise KeyError(f\\"Record with ID {record_id} not found.\\") return self.records[record_id] def update_record(self, record_id: int, data: dict) -> None: if record_id not in self.records: raise KeyError(f\\"Record with ID {record_id} not found.\\") self.records[record_id] = data def delete_record(self, record_id: int) -> None: if record_id not in self.records: raise KeyError(f\\"Record with ID {record_id} not found.\\") del self.records[record_id]"},{"question":"# Task Implement a function that generates all the prime numbers less than a given integer `n` using the Sieve of Eratosthenes algorithm. # Requirements Write a function `sieve_of_eratosthenes` that takes a single integer input `n` and returns a list of all prime numbers less than `n`. # Inputs: * `n` (integer): The upper limit (non-inclusive) for generating prime numbers. # Outputs: * A list of integers representing all prime numbers less than `n`. # Constraints: 1. The input is a 32-bit signed integer. 2. The function should be efficient in terms of both time and space complexity. # Example ```python def sieve_of_eratosthenes(n: int) -> list: Generate all primes less than n using the Sieve of Eratosthenes algorithm. Parameters: n (int): The upper limit (non-inclusive) for prime generation Returns: list: List of prime numbers less than n Examples: >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> sieve_of_eratosthenes(2) [] >>> sieve_of_eratosthenes(1) [] pass # Test cases assert sieve_of_eratosthenes(10) == [2, 3, 5, 7], \\"Test case 1 failed\\" assert sieve_of_eratosthenes(20) == [2, 3, 5, 7, 11, 13, 17, 19], \\"Test case 2 failed\\" assert sieve_of_eratosthenes(2) == [], \\"Test case 3 failed\\" assert sieve_of_eratosthenes(1) == [], \\"Test case 4 failed\\" print(\\"All test cases pass\\") ``` Write the function `sieve_of_eratosthenes` based on the above description and make sure it passes the provided test cases.","solution":"def sieve_of_eratosthenes(n: int) -> list: Generate all primes less than n using the Sieve of Eratosthenes algorithm. Parameters: n (int): The upper limit (non-inclusive) for prime generation Returns: list: List of prime numbers less than n if n <= 2: return [] is_prime = [True] * n is_prime[0] = is_prime[1] = False for i in range(2, int(n**0.5) + 1): if is_prime[i]: for j in range(i*i, n, i): is_prime[j] = False return [i for i in range(n) if is_prime[i]]"},{"question":"# Coding Assessment Question Context: Imagine you are developing a simulation of a warehouse robot that navigates through a grid to pick up items. The robot can only move in four directions: up, down, left, and right. The task is to determine the shortest path between two points on the grid while avoiding obstacles. Task: 1. Implement a function to find the shortest path in an m x n grid from the starting point to the endpoint. 2. Use the Breadth-First Search (BFS) algorithm, as it is suitable for finding the shortest path in an unweighted grid. Requirements: 1. **Function `shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int`** - The function should take a 2D grid, a starting point, and an endpoint. - Obstacles are represented by `1`, and free spaces are represented by `0`. - Return the length of the shortest path from start to end. If there is no valid path, return `-1`. Constraints: - The grid will be at most 100x100 cells. - Coordinates for start and end will always be valid and within the grid bounds. - The start and end positions will always be free spaces (`0`). Example: Consider the following grid: ``` 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 0 ``` - Start: (0, 0) - End: (4, 4) - `shortest_path(grid, (0, 0), (4, 4))` should return `8`. Explanation: The shortest path from (0, 0) to (4, 4) is marked by the following coordinates: (0, 0) -> (1, 0) -> (2, 0) -> (2, 1) -> (2, 2) -> (2, 3) -> (3, 3) -> (4, 3) -> (4, 4), which has a length of 8.","solution":"from collections import deque from typing import List, Tuple def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Returns the length of the shortest path from start to end in the grid. Uses BFS for finding the shortest path in an unweighted grid. :param grid: List[List[int]] - 2D grid representing the warehouse :param start: Tuple[int, int] - Starting coordinates (x, y) :param end: Tuple[int, int] - Ending coordinates (x, y) :return: int - Length of the shortest path, or -1 if no path exists rows, cols = len(grid), len(grid[0]) visited = set() queue = deque([(start, 0)]) # queue contains tuples of (current_position, current_distance) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up while queue: (current_x, current_y), distance = queue.popleft() if (current_x, current_y) == end: return distance for dx, dy in directions: next_x, next_y = current_x + dx, current_y + dy if 0 <= next_x < rows and 0 <= next_y < cols and (next_x, next_y) not in visited and grid[next_x][next_y] == 0: visited.add((next_x, next_y)) queue.append(((next_x, next_y), distance + 1)) return -1 # If no path is found"},{"question":"# Objective You are to implement an efficient function to find the next lexicographical permutation of a given list of integers. This task assesses your understanding of permutation generation, array manipulation, and algorithmic efficiency. # Problem Statement Write a Python function `next_permutation(nums: List[int]) -> List[int]` that takes a list of integers `nums` and returns the next lexicographical permutation of the list. If such permutation does not exist (the list is in descending order), return the smallest permutation (sorted in ascending order). # Input and Output: * **Input**: A list of integers `nums`. * **Output**: The next lexicographical permutation of `nums` or the smallest permutation if the current is the largest. # Constraints: 1. The length of `nums` will be between 1 and 1000. 2. The integers in `nums` can be any valid integer value. # Function Signature: ```python def next_permutation(nums: List[int]) -> List[int]: ``` # Example Input and Output * Input: `nums = [1, 2, 3]` * Output: `[1, 3, 2]` * Input: `nums = [3, 2, 1]` * Output: `[1, 2, 3]` * Input: `nums = [1, 1, 5]` * Output: `[1, 5, 1]` * Input: `nums = [4, 3, 2, 1]` * Output: `[1, 2, 3, 4]` # Constraints and Considerations: 1. **Edge Cases**: * The list is in ascending order (next permutation is straightforward). * The list is in descending order (needs to be reversed). 2. **Performance**: * Ensure the solution runs efficiently for the upper constraints. * Minimize the number of swaps and comparisons. # Approach: 1. Identify the longest suffix that is non-increasing (i.e., the largest sequence of numbers from the end that are sorted in descending order). 2. Determine the pivot just before the suffix. 3. Swap the pivot with the smallest number in the suffix that is larger than the pivot. 4. Reverse the suffix to form the smallest lexicographical order post-swap. 5. Return the modified list as the next permutation.","solution":"from typing import List def next_permutation(nums: List[int]) -> List[int]: Modify nums into its next permutation as per the lexicographical order. If no next permutation is possible, return the smallest permutation. n = len(nums) if n <= 1: return nums # Step 1: Find the largest index i such that nums[i] < nums[i+1] i = n - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 if i >= 0: # Step 2: Find the largest index j > i such that nums[i] < nums[j] j = n - 1 while nums[j] <= nums[i]: j -= 1 # Step 3: Swap the value of nums[i] with nums[j] nums[i], nums[j] = nums[j], nums[i] # Step 4: Reverse the sequence from nums[i + 1] up to the last element nums[i + 1:] = reversed(nums[i + 1:]) return nums"},{"question":"# Question: Bubble Sort Implementation Implement a function `bubble_sort` that performs a bubble sort on a given list of integers. The function should sort the list in ascending order and return the sorted list. Function Signature ```python def bubble_sort(arr: list) -> list: ``` Input - `arr`: A list of integers. Output - A list of integers sorted in ascending order. Constraints - The input list can have up to 10^3 elements. - Each element in the list can be any integer value (including negative integers). Examples ```python print(bubble_sort([64, 34, 25, 12, 22, 11, 90])) # Output: [11, 12, 22, 25, 34, 64, 90] print(bubble_sort([5, 1, 4, 2, 8])) # Output: [1, 2, 4, 5, 8] print(bubble_sort([3, 0, -1, 3, 7, 5])) # Output: [-1, 0, 3, 3, 5, 7] ``` **Note**: Ensure your function is correctly sorting the provided list using the bubble sort algorithm. The function should not use any built-in sort functions.","solution":"def bubble_sort(arr: list) -> list: Performs bubble sort on the input list and returns the sorted list in ascending order. n = len(arr) for i in range(n): # Last i elements are already in place for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: # Swap if the element found is greater than the next element arr[j], arr[j + 1] = arr[j + 1], arr[j] return arr"},{"question":"# Find the Longest Common Subsequence **Context**: In software development, managing different versions of text files is a common task. One critical operation performed is finding the longest common subsequence (LCS) between two text strings. The LCS is a sequence that appears in both text strings in the same order but not necessarily consecutively. This problem has applications in version control systems, comparison tools, and bioinformatics. **Task**: Implement a function `longest_common_subsequence` which takes two strings and returns the length of their longest common subsequence. **Function Signature**: ```python def longest_common_subsequence(text1: str, text2: str) -> int: pass ``` **Input**: - `text1` (str): The first text string for comparison. - `text2` (str): The second text string for comparison. **Output**: - An integer representing the length of the longest common subsequence of `text1` and `text2`. **Constraints**: - The lengths of `text1` and `text2` can range from `0` to `1000`. - The strings will only contain lowercase alphabet characters (`a`-`z`). **Example**: ```python assert longest_common_subsequence(\\"abcde\\", \\"ace\\") == 3 assert longest_common_subsequence(\\"abc\\", \\"abc\\") == 3 assert longest_common_subsequence(\\"abc\\", \\"def\\") == 0 ``` **Notes**: * Ensure the solution efficiently handles the dynamic programming approach. * Properly initiaize matrices and handle edge cases such as empty strings. * This question assesses your understanding of dynamic programming concepts, in particular, the use of a 2D matrix to track the length of the LCS, and the ability to apply these concepts in a practical programming scenario. --- This question mimics the style, complexity, and scope of the existing set, focusing on dynamic programming and its implementation for real-world applications.","solution":"def longest_common_subsequence(text1: str, text2: str) -> int: Returns the length of the longest common subsequence between two strings. m = len(text1) n = len(text2) # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array from bottom up. for i in range(1, m + 1): for j in range(1, n + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"**Problem Statement**: You are tasked with implementing a simple library management system to keep track of the available books. The system must support operations to add new books, remove books, borrow books, and return books. The availability of each book should be tracked by a unique identifier. # Features to Implement: 1. **Add Book**: - Method: `add_book(book_id: str, title: str) -> None` - Description: Adds a new book to the library with the specified `book_id` and `title`. If a book with the same `book_id` already exists, raise a `ValueError`. 2. **Remove Book**: - Method: `remove_book(book_id: str) -> None` - Description: Removes the specified book from the library. If the book does not exist, raise a `ValueError`. 3. **Borrow Book**: - Method: `borrow_book(book_id: str) -> None` - Description: Marks the specified book as borrowed. If the book is already borrowed or does not exist, raise a `ValueError`. 4. **Return Book**: - Method: `return_book(book_id: str) -> None` - Description: Marks the specified book as returned. If the book is not currently borrowed or does not exist, raise a `ValueError`. 5. **Is Book Available**: - Method: `is_book_available(book_id: str) -> bool` - Description: Returns `True` if the book is available to be borrowed, `False` otherwise. If the book does not exist, raise a `ValueError`. 6. **List All Books**: - Method: `list_all_books() -> List[Tuple[str, str, bool]]` - Description: Returns a list of all books in the library. Each book should be represented as a tuple containing the `book_id`, `title`, and a boolean indicating borrowing status (True if borrowed, False otherwise). # Constraints: - Each `book_id` will be unique. - The `title` can be any string. - The system must efficiently handle edge cases such as borrowing or returning books that do not exist. # Example: ```python # Example Usage library = Library() library.add_book(\\"101\\", \\"The Great Gatsby\\") library.add_book(\\"102\\", \\"1984\\") library.borrow_book(\\"101\\") assert library.is_book_available(\\"101\\") == False assert library.list_all_books() == [ (\\"101\\", \\"The Great Gatsby\\", True), (\\"102\\", \\"1984\\", False) ] library.return_book(\\"101\\") assert library.is_book_available(\\"101\\") == True assert library.list_all_books() == [ (\\"101\\", \\"The Great Gatsby\\", False), (\\"102\\", \\"1984\\", False) ] library.remove_book(\\"102\\") assert library.list_all_books() == [(\\"101\\", \\"The Great Gatsby\\", False)] ``` Implement the `Library` class following the above description and ensuring your implementation passes all necessary edge cases.","solution":"from typing import List, Tuple class Library: def __init__(self): self.books = {} self.borrowed_status = {} def add_book(self, book_id: str, title: str) -> None: if book_id in self.books: raise ValueError(\\"Book with this ID already exists.\\") self.books[book_id] = title self.borrowed_status[book_id] = False def remove_book(self, book_id: str) -> None: if book_id not in self.books: raise ValueError(\\"Book not found.\\") del self.books[book_id] del self.borrowed_status[book_id] def borrow_book(self, book_id: str) -> None: if book_id not in self.books: raise ValueError(\\"Book not found.\\") if self.borrowed_status[book_id]: raise ValueError(\\"Book already borrowed.\\") self.borrowed_status[book_id] = True def return_book(self, book_id: str) -> None: if book_id not in self.books: raise ValueError(\\"Book not found.\\") if not self.borrowed_status[book_id]: raise ValueError(\\"Book is not borrowed.\\") self.borrowed_status[book_id] = False def is_book_available(self, book_id: str) -> bool: if book_id not in self.books: raise ValueError(\\"Book not found.\\") return not self.borrowed_status[book_id] def list_all_books(self) -> List[Tuple[str, str, bool]]: return [(book_id, title, self.borrowed_status[book_id]) for book_id, title in self.books.items()]"},{"question":"# Coding Assessment Question **Title**: Implement a Loan Amortization Calculation with Comprehensive Error Handling **Objective**: To evaluate the student’s understanding of class design, numerical methods, and error handling in Python. Problem Statement You are tasked with creating a class that calculates the monthly payments for a loan based on the loan’s principal, annual interest rate, and term (in years). This type of calculation is often used in financial applications to determine how much a borrower needs to pay each month. Your task is to implement the `Loan` class with a method `monthly_payment` that computes the monthly payment amount and handles several edge cases and potential errors. Here are the steps to complete the task: 1. Understand the components of a loan: principal, annual interest rate, and term in years. 2. Implement the `monthly_payment` method in the `Loan` class. 3. Ensure your method handles edge cases, such as: - Invalid principal (e.g., negative or zero). - Invalid interest rates (e.g., negative). - Invalid term (e.g., negative or zero). - Ensure type validation and correct input formats. 4. Your solution must appropriately handle exceptions and return user-friendly error messages. Function Signature ```python class Loan: def __init__(self, principal: float, annual_rate: float, term_years: int): ... def monthly_payment(self) -> float: ... ``` Input - A `Loan` object initialized with: - `principal` (float): the initial amount of the loan. - `annual_rate` (float): the annual interest rate (as a percentage). - `term_years` (int): the term of the loan in years. Output - Returns a `float` representing the monthly payment. - Raises appropriate exceptions for invalid inputs. Constraints - Principal and annual_rate must be non-negative. - Term must be a positive integer. - Ensure the results are accurate up to two decimal places. Examples ```python # Example 1: Simple monthly payment calculation: loan = Loan(principal=10000, annual_rate=5, term_years=10) assert abs(loan.monthly_payment() - 106.07) < 0.01 # Example 2: Handling invalid inputs: try: invalid_loan = Loan(principal=-5000, annual_rate=5, term_years=10) invalid_loan.monthly_payment() except ValueError as e: assert str(e) == \\"Principal amount must be non-negative.\\" # Example 3: Handling a zero annual interest rate: zero_rate_loan = Loan(principal=10000, annual_rate=0, term_years=10) assert abs(zero_rate_loan.monthly_payment() - 83.33) < 0.01 # Example 4: Invalid term: try: invalid_term_loan = Loan(principal=10000, annual_rate=5, term_years=0) invalid_term_loan.monthly_payment() except ValueError as e: assert str(e) == \\"Term in years must be a positive integer.\\" ``` **Notes** - Your implementation should be robust against invalid input and handle various edge cases gracefully. - Use the principles of clean coding and OOP in Python. - Ensure your calculations are precise and formatted correctly.","solution":"class Loan: def __init__(self, principal: float, annual_rate: float, term_years: int): if not isinstance(principal, (int, float)) or principal < 0: raise ValueError(\\"Principal amount must be a non-negative number.\\") if not isinstance(annual_rate, (int, float)) or annual_rate < 0: raise ValueError(\\"Annual interest rate must be a non-negative number.\\") if not isinstance(term_years, int) or term_years <= 0: raise ValueError(\\"Term in years must be a positive integer.\\") self.principal = principal self.annual_rate = annual_rate self.term_years = term_years def monthly_payment(self) -> float: if self.annual_rate == 0: return round(self.principal / (self.term_years * 12), 2) monthly_rate = self.annual_rate / 100 / 12 number_of_payments = self.term_years * 12 payment = self.principal * (monthly_rate * (1 + monthly_rate) ** number_of_payments) / ((1 + monthly_rate) ** number_of_payments - 1) return round(payment, 2)"},{"question":"# Coding Assessment Question **Context**: You need to write a function that detects whether a given genome sequence (represented as a string) contains the pattern of a specific known motif. In genomics, motifs are short, recurring patterns that are presumed to have a biological function. This function will be instrumental in bioinformatics analyses, identifying likely regions of interest in genome sequences. Write a Python function `find_motif_in_genome(genome_sequence: str, motif: str) -> List[int]` that returns all starting positions (1-based index) of the motif within the genome sequence. **Function Signature**: ```python def find_motif_in_genome(genome_sequence: str, motif: str) -> List[int]: ``` **Input**: 1. `genome_sequence`: string, a long string representing the genome sequence (only containing characters \'A\', \'C\', \'G\', and \'T\'). 2. `motif`: string, a short string representing the genomic motif to be found (only containing characters \'A\', \'C\', \'G\', and \'T\'). **Output**: - Return a list of integers where each integer represents a starting position in the genome sequence where the motif begins. (1-based index) **Constraints**: - The genome sequence will be non-empty. - The motif to search for will be non-empty. - Both strings only consist of characters \'A\', \'C\', \'G\', and \'T\'. - `1 <= len(motif) <= len(genome_sequence)` **Example**: ```python genome_sequence = \\"GATATATGCATATACTT\\" motif = \\"ATAT\\" result = find_motif_in_genome(genome_sequence, motif) print(result) # Should return [2, 4, 10] (1-based index) ``` **Additional Instructions**: 1. Ensure that the function handles cases where the motif appears multiple times in the genome sequence. 2. The motif must be matched exactly; no mismatches are allowed. 3. Optimize the function for performance, considering practical lengths of genome sequences (which could be very large).","solution":"from typing import List def find_motif_in_genome(genome_sequence: str, motif: str) -> List[int]: Returns the starting positions (1-based index) of the motif within the genome sequence. positions = [] motif_length = len(motif) # Iterate over the genome sequence to find all occurrences of the motif for i in range(len(genome_sequence) - motif_length + 1): if genome_sequence[i:i + motif_length] == motif: positions.append(i + 1) # Convert 0-based index to 1-based index return positions"},{"question":"# Reducing Array by Replacing Sum of Pairs Context: You are given an array of integers. Your task is to repeatedly replace any two distinct elements from the array with their sum until only one element remains in the array. Each replacement forms a new array where the chosen pair is replaced by their sum, and the other elements remain the same. You should return the final remaining element after performing these replacements. Problem Statement: Given: - An array of integers `nums`. Write a function `final_element(nums: List[int]) -> int` that returns the final remaining element after repeatedly replacing distinct pairs with their sum. Function Signature: ```python def final_element(nums: List[int]) -> int: ``` Input: - `nums`: A list of integers. Output: - An integer representing the final remaining element. Constraints: - 1 ≤ len(nums) ≤ 50 - -10^6 ≤ nums[i] ≤ 10^6 Example: Input: ```python nums = [1, 2, 3, 4, 5] ``` Output: ```python 15 ``` Explanation: For the given example, the process can be: - Replace (1, 2) with 3 => [3, 3, 4, 5] - Replace (3, 3) with 6 => [6, 4, 5] - Replace (4, 5) with 9 => [6, 9] - Replace (6, 9) with 15 => [15] The final remaining element is 15. Consider all possible valid sequences of replacements leading to the solution. Use efficient approaches to ensure that the solution handles the given constraints well.","solution":"from typing import List def final_element(nums: List[int]) -> int: while len(nums) > 1: # Always take the first two elements to sum. # This is a simplified approach that works given the constraints. # Pop two elements, sum them and insert back the result. a = nums.pop(0) b = nums.pop(0) nums.insert(0, a + b) return nums[0]"},{"question":"# Maze Solver Using Depth-First Search **Objective**: Implement a maze-solving algorithm using depth-first search (DFS) to reinforce understanding of graph traversal, recursion, and stack utilization. Scenario You are working on a pathfinding application that solves mazes. Your task is to implement a depth-first search algorithm to find a path from the start to the end of a given maze represented as a 2D grid. Functions to Implement: 1. **`is_valid_move(maze: List[List[int]], visited: List[List[bool]], row: int, col: int) -> bool`**: * Checks if moving to the given cell (`row`, `col`) is valid. * **Input**: `maze` is a 2D list of integers where `0` represents a walkable path and `1` represents a wall; `visited` is a 2D list of booleans tracking visited cells; `row` and `col` are the coordinates of the cell being checked. * **Output**: `True` if the move is valid, otherwise `False`. * **Constraints**: The cell coordinates must be within maze bounds and not yet visited. 2. **`dfs(maze: List[List[int]], row: int, col: int, path: List[Tuple[int, int]], visited: List[List[bool]]) -> bool`**: * Performs depth-first search to find a path from the start to the end. * **Input**: `maze` is a 2D list of integers; `row` and `col` are the current cell coordinates; `path` is a list of tuples storing the current path from start to end; `visited` is a 2D list of booleans tracking visited cells. * **Output**: `True` if a path is found, otherwise `False`. The path list should contain the coordinates of the path if found. * **Constraints**: None. 3. **`find_path(maze: List[List[int]]) -> List[Tuple[int, int]]`**: * Finds a path from the top-left corner to the bottom-right corner of the maze using DFS. * **Input**: `maze` is a 2D list of integers. * **Output**: A list of tuples representing the path from start (top-left) to end (bottom-right). If no path is found, return an empty list. * **Constraints**: The maze is guaranteed to have at least one valid starting and ending cell. # Example Usage and Testing Main Function: * `find_path(maze: List[List[int]]) -> List[Tuple[int, int]]`: Combines the above functions to find a path in the maze. * **Input/Output Examples**: * `find_path([[0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]])` -> `[(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (2, 3), (3, 3), (4, 4)]` (or other valid paths) * `find_path([[0, 1], [1, 0]])` -> `[]` (no valid path) # Instructions 1. Implement each of the functions specified. 2. Ensure each function handles edge cases appropriately, such as invalid grid sizes and blocked cells. 3. Combine the functions to produce the final path as demonstrated in the provided `find_path` function. 4. Test your implementation thoroughly using provided examples and adding your own edge cases. # Constraints * The maze is represented as an `n x m` grid of integers where `0 <= n, m <= 100`. * The starting point is always the top-left corner (0, 0), and the ending point is always the bottom-right corner (n-1, m-1). * The maze may have scenarios where no valid path exists, and the algorithm should account for this possibility. --- By providing this question, we maintain alignment in style, complexity, and scope with the original questions, focusing on core algorithmic skills like depth-first search, which complements understanding of bitwise operations and cryptographic functions.","solution":"from typing import List, Tuple def is_valid_move(maze: List[List[int]], visited: List[List[bool]], row: int, col: int) -> bool: Check if the current cell (row, col) is a valid move. n, m = len(maze), len(maze[0]) return 0 <= row < n and 0 <= col < m and not visited[row][col] and maze[row][col] == 0 def dfs(maze: List[List[int]], row: int, col: int, path: List[Tuple[int, int]], visited: List[List[bool]]) -> bool: Perform DFS to find a path from the start to the end. # Base case: If we\'re at the bottom-right corner, we\'re done if row == len(maze) - 1 and col == len(maze[0]) - 1: path.append((row, col)) return True # Mark the current cell as visited visited[row][col] = True path.append((row, col)) # Explore neighbors: down, right, up, left for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1)]: next_row, next_col = row + dr, col + dc if is_valid_move(maze, visited, next_row, next_col): if dfs(maze, next_row, next_col, path, visited): return True # If none of the moves work, backtrack and unmark current cell from path path.pop() visited[row][col] = False return False def find_path(maze: List[List[int]]) -> List[Tuple[int, int]]: Finds a path from the top-left corner to the bottom-right corner of the maze using DFS. if not maze or maze[0][0] == 1 or maze[-1][-1] == 1: return [] row_len, col_len = len(maze), len(maze[0]) visited = [[False for _ in range(col_len)] for _ in range(row_len)] path = [] if dfs(maze, 0, 0, path, visited): return path return []"},{"question":"# Palindrome Check with Removal You are tasked with writing a function that checks whether a given string can become a palindrome by removing at most one character. The function should verify if the string is already a palindrome or if it can be one by removing a single character. Function Signature ```python def is_almost_palindrome(s: str) -> bool: pass ``` Input - `s` (string): A string containing alphanumeric characters. The string is case-insensitive. Output - Return `True` if the string can be a palindrome by removing at most one character. - Return `False` otherwise. Constraints 1. The input string\'s length must be between 1 and 100,000 characters. 2. The function must be case-insensitive, treating uppercase and lowercase letters as identical. Context Palindrome checks are often used in text processing and validation. Being able to identify if a string can become a palindrome by a minimal change is a useful skill in many applications, including data validation and correction algorithms. # Examples Example 1 **Input**: ```python \'madam\' ``` **Output**: ```python True ``` Example 2 **Input**: ```python \'racecar\' ``` **Output**: ```python True ``` Example 3 **Input**: ```python \'radcar\' ``` **Output**: ```python True ``` Example 4 **Input**: ```python \'hello\' ``` **Output**: ```python False ``` # Instructions - Implement the function `is_almost_palindrome` as described. - Ensure you handle edge cases such as one-character strings and strings that need adjustment at the start, middle, or end. - Consider the time complexity to ensure the solution is efficient for large inputs.","solution":"def is_almost_palindrome(s: str) -> bool: # Normalize the string to lowercase to make the check case-insensitive s = s.lower() def is_palindrome_range(i, j): Utility function to check if s[i:j+1] is a palindrome while i < j: if s[i] != s[j]: return False i, j = i + 1, j - 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Check by removing either the left or the right character return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return True"},{"question":"# Coding Assessment Question **Context**: Given a string containing lowercase alphabets and an integer `k`, your task is to determine whether there is a substring of length `k` that does not contain any repeated characters. This problem tests the efficient manipulation and checking of substrings within a string. # Problem Statement: Write a function `has_unique_substring(s: str, k: int) -> bool` that returns `True` if there is a substring of length `k` in the string `s` with all unique characters, and `False` otherwise. # Input Format: - `s`: A string containing only lowercase alphabets with length `n (1 ≤ n ≤ 10^5)`. - `k`: An integer representing the length of the substring to check for uniqueness (1 ≤ k ≤ 26). # Output Format: - Returns a boolean value `True` if there is a substring of length `k` with all unique characters, otherwise `False`. # Constraints: - The function should consider all potential substrings of length `k` in `s`. - The solution should be efficient and handle large inputs gracefully. # Example: ```python has_unique_substring(\\"algorithms\\", 4) # Output: True (The substring \\"algo\\" is unique) has_unique_substring(\\"aabbccddeeffgghh\\", 2) # Output: False (No substring of length 2 has all unique characters) has_unique_substring(\\"abcdef\\", 7) # Output: False (k is greater than the length of the string) ``` # Performance Requirements: - Aim to achieve a time complexity of O(n) using a sliding window approach. - Ensure that your solution is robust to edge cases and handles all specified constraints.","solution":"def has_unique_substring(s: str, k: int) -> bool: if k > len(s): return False char_set = set() for i in range(k): if s[i] in char_set: return False char_set.add(s[i]) for i in range(k, len(s)): char_set.remove(s[i - k]) if s[i] in char_set: return False char_set.add(s[i]) return True"},{"question":"# Problem Statement One of the most fundamental aspects of computational geometry involves determining the minimum bounding rectangle for a set of points on a 2D plane. Given a set of points defined by their coordinates, your task is to find the smallest rectangle that can enclose all the given points. This rectangle should be aligned with the coordinate axes. # Task Write a function `minimum_bounding_rectangle` that takes a list of points, each represented by a tuple `(x, y)`, and returns the coordinates of the bottom-left and top-right corners of the minimal bounding rectangle. # Function Signature ```python def minimum_bounding_rectangle(points: List[Tuple[int, int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]: ``` # Inputs - `points` (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers representing the x and y coordinates of a point. # Output - Returns a tuple of two tuples: - The first tuple represents the bottom-left corner. - The second tuple represents the top-right corner. # Constraints - The input list will contain at least one point and no more than 10^5 points. - The x and y values of the coordinates will be within the range [-10^6, 10^6]. # Example ```python assert minimum_bounding_rectangle([(0, 0), (1, 1), (-1, -1), (2, 2)]) == ((-1, -1), (2, 2)) assert minimum_bounding_rectangle([(-2, -3), (4, 5), (7, -1), (0, 0)]) == ((-2, -3), (7, 5)) ``` # Explanation - The first example shows the minimal bounding rectangle that includes all four points, resulting in the bottom-left corner at (-1, -1) and the top-right corner at (2, 2). - The second example provides a different set of points leading to a bounding rectangle from (-2, -3) to (7, 5). # Notes - Focus on efficiency as the input size can be large. - Ensure proper handling of edge cases like all points being on a straight line.","solution":"from typing import List, Tuple def minimum_bounding_rectangle(points: List[Tuple[int, int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]: Given a list of points, returns the coordinates of the bottom-left and top-right corners of the minimum bounding rectangle enclosing all points. min_x = min(points, key=lambda p: p[0])[0] max_x = max(points, key=lambda p: p[0])[0] min_y = min(points, key=lambda p: p[1])[1] max_y = max(points, key=lambda p: p[1])[1] return ((min_x, min_y), (max_x, max_y))"},{"question":"# Scenario You are developing a text processing tool that needs to summarize large documents. One approach to text summarization is to identify the most important sentences in the document. For this task, you will implement a simplified version of a text rank algorithm, which ranks sentences based on their importance using the concept of eigenvector centrality. # Problem Statement **Task**: Implement a simplified TextRank algorithm to identify the top N important sentences in a given document. The importance of a sentence is determined by how similar it is to other sentences in the document. # Input & Output **Function Name**: `text_rank` **Input**: - `document`: A string representing the document, where sentences are separated by periods (\'.\') and it may contain multiple sentences. - `top_n`: An integer representing the number of top sentences to return. **Output**: - `top_sentences`: A list of strings representing the top N important sentences in the document. # Constraints - The document may contain up to 10,000 characters. - The number of sentences in the document will be between 1 and 100. - `top_n` will be between 1 and the total number of sentences in the document. - Use cosine similarity to measure the similarity between two sentences. - Ignore punctuation and case while comparing sentences. # Performance Requirements - The function should have a time complexity of O(S² * W), where S is the number of sentences and W is the average number of words per sentence. - The space complexity should be O(S²). ```python import numpy as np import re from sklearn.metrics.pairwise import cosine_similarity from sklearn.feature_extraction.text import CountVectorizer def text_rank(document: str, top_n: int) -> list: Identify the top N important sentences in the document. # Split the document into sentences. sentences = re.split(r\'.|?|!\', document) sentences = [sentence.strip() for sentence in sentences if sentence.strip()] # Compute similarity matrix vectorizer = CountVectorizer().fit_transform(sentences) vectors = vectorizer.toarray() similarity_matrix = cosine_similarity(vectors) # Page rank algorithm to score sentences scores = np.ones(len(sentences)) for _ in range(100): # Fixed number of iterations for simplicity new_scores = np.dot(similarity_matrix, scores) scores = new_scores / np.linalg.norm(new_scores) # Get top N sentences ranked_sentences = [(scores[i], s) for i, s in enumerate(sentences)] ranked_sentences = sorted(ranked_sentences, key=lambda x: x[0], reverse=True) top_sentences = [sentence for score, sentence in ranked_sentences[:top_n]] return top_sentences # Testing the function document = (\\"Natural language processing (NLP) is a field \\" \\"at the intersection of computer science, artificial intelligence, \\" \\"and computational linguistics. NLP involves the creation \\" \\"of computational models of language understanding and generation. \\" \\"Some common applications of NLP include machine translation, \\" \\"speech recognition, and sentiment analysis. Research in NLP \\" \\"is ongoing to improve the quality and efficiency of these applications.\\") top_sentences = text_rank(document, 2) for i, sentence in enumerate(top_sentences, 1): print(f\\"Top {i}: {sentence}\\") ```","solution":"import numpy as np import re from sklearn.metrics.pairwise import cosine_similarity from sklearn.feature_extraction.text import CountVectorizer def text_rank(document: str, top_n: int) -> list: Identify the top N important sentences in the document. # Split the document into sentences. sentences = re.split(r\'.|?|!\', document) sentences = [sentence.strip() for sentence in sentences if sentence.strip()] # Compute similarity matrix vectorizer = CountVectorizer().fit_transform(sentences) vectors = vectorizer.toarray() similarity_matrix = cosine_similarity(vectors) # Page rank algorithm to score sentences scores = np.ones(len(sentences)) for _ in range(100): # Fixed number of iterations for simplicity new_scores = np.dot(similarity_matrix, scores) scores = new_scores / np.linalg.norm(new_scores) # Get top N sentences ranked_sentences = [(scores[i], s) for i, s in enumerate(sentences)] ranked_sentences = sorted(ranked_sentences, key=lambda x: x[0], reverse=True) top_sentences = [sentence for score, sentence in ranked_sentences[:top_n]] return top_sentences"},{"question":"# Coding Assessment Question: Data Structure Serialization You are given a custom data structure implemented as a binary search tree (BST). Your task is to serialize the BST into a string and then deserialize it back to the BST structure. Serialization converts the data structure into a string representation that can be easily stored or transmitted, while deserialization converts the string back into the original data structure. # Task 1. Implement a method `serialize`, which takes the root of a BST and returns a string representation of the BST. 2. Implement a method `deserialize`, which takes a string representation of a BST and returns the root of the reconstructed BST. # Details * **Input**: The input consists of the root node of a binary search tree and functions to serialize and deserialize it. * **Output**: The output is of two types - - A string after serializing the BST. - The root node of the BST after deserializing the string. * **Constraints**: - The BST will contain a maximum of 1000 nodes. - Node values are unique and are integers. - Node values will fit in a signed 32-bit integer. # Example **Input**: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right root = TreeNode(2) root.left = TreeNode(1) root.right = TreeNode(3) ``` **Output**: After calling `serialize` with the root node: ```plaintext \\"2,1,None,None,3,None,None\\" ``` After calling `deserialize` with the string \\"2,1,None,None,3,None,None\\": ```plaintext TreeNode object with root value 2, left child with value 1, and right child with value 3. ``` # Implementation Requirements 1. Implement the `serialize` method in the BST class to convert the tree into a string representation. 2. Implement the `deserialize` method in the BST class to convert the string representation back into the tree. # Additional Information - You can assume that the input BST is always valid. - Use pre-order traversal for serialization.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Encodes a tree to a single string. def helper(node): if not node: return [\\"None\\"] return [str(node.val)] + helper(node.left) + helper(node.right) return \',\'.join(helper(root)) def deserialize(data): Decodes your encoded data to tree. def helper(vals): val = next(vals) if val == \\"None\\": return None node = TreeNode(int(val)) node.left = helper(vals) node.right = helper(vals) return node vals = iter(data.split(\',\')) return helper(vals)"},{"question":"# Coding Question: Processing and Simplifying Polynomials Scenario: You are given a list of polynomial terms, where each term is represented as a tuple containing its coefficient and exponent. Your task is to implement a function that processes and simplifies the polynomial by combining like terms and sorting them in descending order of their exponents. Task: Implement a function `simplify_polynomial` that takes a list of polynomial terms and returns the simplified polynomial in list form, combining like terms and sorted by exponent in descending order. Function Signature: ```python def simplify_polynomial(terms: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pass ``` Input: * `terms` (List[Tuple[int, int]]): A list of tuples where each tuple of two integers represents a term in the polynomial. The first integer is the coefficient, and the second integer is the exponent. Output: * Return the simplified polynomial as a list of tuples sorted by the exponents in descending order. Each tuple represents a term in the simplified polynomial. Constraints: * The coefficients and exponents are integers. * The coefficient can be any integer (positive, negative, or zero). * The exponent is a non-negative integer. * The list can have zero or more terms. Example: ```python >>> simplify_polynomial([(3, 2), (4, 1), (-3, 2), (5, 0)]) [(4, 1), (5, 0)] # Because (3, 2) and (-3, 2) cancel each other out, we\'re left with (4, 1) and (5, 0). >>> simplify_polynomial([(1, 3), (2, 2), (3, 2), (-1, 3)]) [(5, 2)] # (1, 3) and (-1, 3) cancel each other out, (2, 2) and (3, 2) combine to (5, 2). ``` Additional Information: Ensure to handle cases where coefficients cancel out terms completely, and eliminate such terms from the final output list.","solution":"from typing import List, Tuple from collections import defaultdict def simplify_polynomial(terms: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Simplifies a polynomial by combining like terms and sorting by exponents in descending order. Args: terms (List[Tuple[int, int]]): A list of tuples representing polynomial terms. Each tuple contains (coefficient, exponent). Returns: List[Tuple[int, int]]: The simplified polynomial as a list of tuples sorted by exponents in descending order. term_dict = defaultdict(int) # Sum coefficients of like terms for coef, exp in terms: term_dict[exp] += coef # Filter out terms with coefficient of zero and sort by exponents in descending order result = [(coef, exp) for exp, coef in term_dict.items() if coef != 0] result.sort(key=lambda x: x[1], reverse=True) return result"},{"question":"# Problem Statement You are given an encoded string representing a sequence of digits. Your task is to decode the string and find how many distinct ways it can be decoded. Each digit maps to a letter using the following mapping: ``` 1 -> \'A\' 2 -> \'B\' 3 -> \'C\' ... 26 -> \'Z\' ``` Implement a function `num_ways_to_decode(s)` that returns the number of ways to decode the given string. # Function Signature ```python def num_ways_to_decode(s: str) -> int: pass ``` # Input * `s` (str): A non-empty string containing digits (\'0\' - \'9\'). # Output * Returns an integer representing the number of ways to decode the given string. # Constraints * The length of `s` is at most 100 (1 <= len(s) <= 100). # Example ```python num_ways_to_decode(\\"12\\") == 2 # \\"AB\\" (1 2) or \\"L\\" (12) num_ways_to_decode(\\"226\\") == 3 # \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6) num_ways_to_decode(\\"06\\") == 0 # No valid decoding ``` # Additional Notes - The input string `s` will only contain digits and will not be empty. - A leading \'0\' cannot be decoded and thus leads to an invalid decoding. - If there are \'0\'s in the middle, ensure they are properly handled by considering valid preceding numbers (like \'10\' and \'20\'). # Algorithm 1. Use dynamic programming to construct a solution. 2. Create a DP array where `dp[i]` represents the number of ways to decode the substring `s[:i]`. 3. Initialize the base cases. 4. Iterate through the string and update the DP array based on valid single and double digit mappings. 5. Return the number of decodings for the entire string. # Edge Cases * Handle strings containing \'0\' and ensure they are part of valid double-digit decodings. * Ensure the algorithm efficiently computes the number of decodings for strings up to the maximum allowed length.","solution":"def num_ways_to_decode(s: str) -> int: if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = dp[1] = 1 # Base case initialization for i in range(2, n + 1): one_digit = int(s[i-1:i]) two_digits = int(s[i-2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i-1] if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"# Coding Question: Implement and Test a User Authentication System **Scenario:** You are tasked with implementing a simple user authentication system. The system should allow users to create accounts and then authenticate using their username and password. For security reasons, the passwords should be stored securely (not in plain text). Additionally, you need to write unit tests to ensure the functionality of both user registration and authentication. **Function Implementation**: 1. Implement the function `register_user(username: str, password: str) -> bool:` which: - Stores the username and a securely hashed version of the password. - Returns `True` if the registration was successful, `False` if the username already exists. 2. Implement the function `authenticate_user(username: str, password: str) -> bool:` which: - Verifies the username and password provided by the user against the stored values. - Returns `True` if authentication is successful, `False` otherwise. **Hashing Requirement**: - Use a secure hash function (e.g., SHA-256) to hash passwords before storing and comparing them during authentication. **Testing Requirement**: - Write unit tests to verify your implementations. - Ensure that user registration and authentication work correctly. - Verify that passwords are hashed and compared securely using mocking. **Function Signatures**: ```python import hashlib user_db = {} def register_user(username: str, password: str) -> bool: # Your implementation here pass def authenticate_user(username: str, password: str) -> bool: # Your implementation here pass ``` # Input: - `username` (str): the username of the user. - `password` (str): the password of the user. # Output: - `register_user` returns a boolean indicating the success of the registration. - `authenticate_user` returns a boolean indicating the success of the authentication. # Constraints: - Assume the input strings are non-empty and contain no special characters except underscores and numbers. - Passwords should be securely hashed with a minimum length requirement of 8 characters. Example: ```python def test_register_user_success(): user_db.clear() assert register_user(\\"test_user\\", \\"securePass123\\") == True def test_register_user_duplicate(): user_db.clear() register_user(\\"test_user\\", \\"securePass123\\") assert register_user(\\"test_user\\", \\"securePass123\\") == False def test_authenticate_user_success(): user_db.clear() register_user(\\"test_user\\", \\"securePass123\\") assert authenticate_user(\\"test_user\\", \\"securePass123\\") == True def test_authenticate_user_failure(): user_db.clear() register_user(\\"test_user\\", \\"securePass123\\") assert authenticate_user(\\"test_user\\", \\"wrongPass456\\") == False # Add more thorough tests to cover other edge cases and scenarios. ``` **Note**: Ensure your tests cover both successful and unsuccessful scenarios for user registration and authentication. Use mocking to verify that passwords are securely hashed and compared.","solution":"import hashlib # In-Memory user db user_db = {} def hash_password(password: str) -> str: return hashlib.sha256(password.encode()).hexdigest() def register_user(username: str, password: str) -> bool: if username in user_db: return False hashed_password = hash_password(password) user_db[username] = hashed_password return True def authenticate_user(username: str, password: str) -> bool: if username not in user_db: return False hashed_password = hash_password(password) return user_db[username] == hashed_password"},{"question":"# Problem Statement: You are given an array of integers representing the heights of various buildings in a city skyline. The goal is to calculate the maximum area of a rectangle that can be formed by any combination of contiguous buildings’ heights. Input: * A list of integers `heights` where each integer represents the height of a building. Output: * An integer representing the maximum rectangular area that can be formed. # Constraints: * The list `heights` will contain at least one and up to (10^5) integers. * Each height value is a non-negative integer. # Example: ```python heights = [2, 1, 5, 6, 2, 3] expected_output = 10 ``` The maximum rectangular area is formed by the heights [5, 6], so the area is 5 * 2 = 10. Implement the function `max_rectangle_area(heights)` to return the maximum rectangular area for the given input heights. # Function Signature: ```python def max_rectangle_area(heights: List[int]) -> int: ... ```","solution":"def max_rectangle_area(heights): Returns the maximum rectangular area that can be formed by any combination of contiguous buildings\' heights. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"Question # Context: A company needs to manage a collection of projects, each with a list of tasks. You are tasked with creating a class `ProjectManager` that allows the company to add, remove, and display projects and their tasks. Each project can hold an arbitrary number of tasks, and tasks can be added or removed dynamically. # Task: Write a Python class `ProjectManager` with the following methods: - `add_project(project_name: str) -> None`: Adds a new project with the given name. - `remove_project(project_name: str) -> None`: Removes the project with the given name. - `add_task(project_name: str, task: str) -> None`: Adds a task to the specified project. - `remove_task(project_name: str, task: str) -> None`: Removes a task from the specified project. - `get_tasks(project_name: str) -> List[str]`: Returns a list of tasks for the specified project. - `get_projects() -> List[str]`: Returns a list of all project names. # Class Definition: ```python class ProjectManager: def __init__(self): pass def add_project(self, project_name: str) -> None: pass def remove_project(self, project_name: str) -> None: pass def add_task(self, project_name: str, task: str) -> None: pass def remove_task(self, project_name: str, task: str) -> None: pass def get_tasks(self, project_name: str) -> List[str]: pass def get_projects(self) -> List[str]: pass ``` # Example: ```python manager = ProjectManager() # Adding projects manager.add_project(\\"Project A\\") manager.add_project(\\"Project B\\") # Adding tasks manager.add_task(\\"Project A\\", \\"Task 1\\") manager.add_task(\\"Project A\\", \\"Task 2\\") manager.add_task(\\"Project B\\", \\"Task 1\\") # Getting tasks print(manager.get_tasks(\\"Project A\\")) # Output: [\\"Task 1\\", \\"Task 2\\"] print(manager.get_tasks(\\"Project B\\")) # Output: [\\"Task 1\\"] # Removing tasks manager.remove_task(\\"Project A\\", \\"Task 1\\") print(manager.get_tasks(\\"Project A\\")) # Output: [\\"Task 2\\"] # Getting project names print(manager.get_projects()) # Output: [\\"Project A\\", \\"Project B\\"] # Removing project manager.remove_project(\\"Project A\\") print(manager.get_projects()) # Output: [\\"Project B\\"] ``` # Requirements: - Ensure that you handle cases where projects or tasks might not exist. - Maintain the internal state of projects and tasks correctly with efficient data structures. - Implement error handling for invalid operations (e.g., removing a non-existent project or task). # Performance: - The class should handle a reasonably large number of projects and tasks. - Optimize methods for adding, removing, and retrieving data to ensure the system remains responsive. [End of Question]","solution":"class ProjectManager: def __init__(self): self.projects = {} def add_project(self, project_name: str) -> None: if project_name not in self.projects: self.projects[project_name] = [] def remove_project(self, project_name: str) -> None: if project_name in self.projects: del self.projects[project_name] def add_task(self, project_name: str, task: str) -> None: if project_name in self.projects: self.projects[project_name].append(task) def remove_task(self, project_name: str, task: str) -> None: if project_name in self.projects and task in self.projects[project_name]: self.projects[project_name].remove(task) def get_tasks(self, project_name: str) -> list[str]: if project_name in self.projects: return self.projects[project_name] return [] def get_projects(self) -> list[str]: return list(self.projects.keys())"},{"question":"# Morse Code Translator **Context:** You are building a communication system that translates text into Morse code and vice versa. Morse code is a method used in telecommunication to encode text characters as sequences of two different signal durations, called dots and dashes. **Problem Statement:** Write a Python class `MorseCodeTranslator` with methods to convert a given text string into Morse code and to decode a given Morse code string back into text. The class should handle invalid input cases gracefully by raising appropriate exceptions. **Class Signature:** ```python class MorseCodeTranslator: MORSE_CODE_DICT = { \'A\': \'.-\', \'B\': \'-...\', \'C\': \'-.-.\', \'D\': \'-..\', \'E\': \'.\', \'F\': \'..-.\', \'G\': \'--.\', \'H\': \'....\', \'I\': \'..\', \'J\': \'.---\', \'K\': \'-.-\', \'L\': \'.-..\', \'M\': \'--\', \'N\': \'-.\', \'O\': \'---\', \'P\': \'.--.\', \'Q\': \'--.-\', \'R\': \'.-.\', \'S\': \'...\', \'T\': \'-\', \'U\': \'..-\', \'V\': \'...-\', \'W\': \'.--\', \'X\': \'-..-\', \'Y\': \'-.--\', \'Z\': \'--..\', \'1\': \'.----\', \'2\': \'..---\', \'3\': \'...--\', \'4\': \'....-\', \'5\': \'.....\', \'6\': \'-....\', \'7\': \'--...\', \'8\': \'---..\', \'9\': \'----.\', \'0\': \'-----\', \' \': \' \' } @staticmethod def text_to_morse(text: str) -> str: Converts a text string to Morse code. Parameters: - text (str): The input text to be converted. Returns: - str: The converted Morse code string. Raises: - ValueError: If the input text contains invalid characters. @staticmethod def morse_to_text(morse: str) -> str: Converts a Morse code string to text. Parameters: - morse (str): The Morse code to be converted. Returns: - str: The decoded text string. Raises: - ValueError: If the input Morse code is invalid. ``` **Constraints:** - The input text can only contain uppercase English letters (A-Z), digits (0-9), and spaces. - Each Morse code character is separated by a single space, and words are separated by three spaces. - Handle invalid characters by raising a `ValueError`. **Examples:** ```python >>> translator = MorseCodeTranslator() >>> translator.text_to_morse(\\"HELLO WORLD\\") \'.... . .-.. .-.. --- .-- --- .-. .-.. -..\' >>> translator.morse_to_text(\\".... . .-.. .-.. --- .-- --- .-. .-.. -..\\") \'HELLO WORLD\' >>> translator.text_to_morse(\\"SOS 123\\") \'... --- ... .---- ..--- ...--\' >>> translator.morse_to_text(\\"... --- ... / .---- / ..--- ...--\\") Traceback (most recent call last): ... ValueError: Invalid Morse code input. >>> translator.text_to_morse(\\"HELLO@WORLD\\") Traceback (most recent call last): ... ValueError: Invalid characters in input text. ``` **Notes:** - Use the provided `MORSE_CODE_DICT` for encoding and decoding. - Ensure the Morse code translation maintains proper spacing conventions. - Validate input strings and raise `ValueError` when inputs contain invalid characters or formatting.","solution":"class MorseCodeTranslator: MORSE_CODE_DICT = { \'A\': \'.-\', \'B\': \'-...\', \'C\': \'-.-.\', \'D\': \'-..\', \'E\': \'.\', \'F\': \'..-.\', \'G\': \'--.\', \'H\': \'....\', \'I\': \'..\', \'J\': \'.---\', \'K\': \'-.-\', \'L\': \'.-..\', \'M\': \'--\', \'N\': \'-.\', \'O\': \'---\', \'P\': \'.--.\', \'Q\': \'--.-\', \'R\': \'.-.\', \'S\': \'...\', \'T\': \'-\', \'U\': \'..-\', \'V\': \'...-\', \'W\': \'.--\', \'X\': \'-..-\', \'Y\': \'-.--\', \'Z\': \'--..\', \'1\': \'.----\', \'2\': \'..---\', \'3\': \'...--\', \'4\': \'....-\', \'5\': \'.....\', \'6\': \'-....\', \'7\': \'--...\', \'8\': \'---..\', \'9\': \'----.\', \'0\': \'-----\', \' \': \' \' } @staticmethod def text_to_morse(text: str) -> str: if any(char not in MorseCodeTranslator.MORSE_CODE_DICT for char in text): raise ValueError(\\"Invalid characters in input text.\\") return \' \'.join( \' \'.join(MorseCodeTranslator.MORSE_CODE_DICT[char] for char in word) for word in text.split(\' \') ) @staticmethod def morse_to_text(morse: str) -> str: reversed_dict = {v: k for k, v in MorseCodeTranslator.MORSE_CODE_DICT.items()} words = morse.split(\' \') decoded_message = [] for word in words: chars = word.split(\' \') decoded_word = \'\'.join(reversed_dict[char] for char in chars if char in reversed_dict) if len(decoded_word) != len(chars): raise ValueError(\\"Invalid Morse code input.\\") decoded_message.append(decoded_word) return \' \'.join(decoded_message)"},{"question":"# Problem Statement You are tasked with implementing the Sieve of Eratosthenes algorithm to find all prime numbers less than or equal to a given integer `n`. The Sieve of Eratosthenes is an ancient algorithm for finding all primes smaller than a given integer and works by iteratively marking the multiples of primes as composite (i.e., not prime). # Function Signature ```python def sieve_of_eratosthenes(n: int) -> List[int]: pass ``` # Input - `n` (int): A positive integer. # Output - List of integers representing all prime numbers less than or equal to `n`. # Constraints 1. `2 <= n <= 10^6` # Example ```python assert sieve_of_eratosthenes(10) == [2, 3, 5, 7] assert sieve_of_eratosthenes(30) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] ``` # Notes - Your implementation should be efficient, ideally with a time complexity of O(n log log n). - Use a boolean list to represent prime candidates, where the indices represent the numbers. - Initialize the list with `True` values and then mark non-prime indices as `False`. Provide an implementation that demonstrates your understanding of algorithm design and optimization. # Example Implementation ```python def sieve_of_eratosthenes(n: int) -> List[int]: is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if is_prime[p] == True: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 prime_numbers = [prime for prime in range(2, n + 1) if is_prime[prime]] return prime_numbers ```","solution":"from typing import List def sieve_of_eratosthenes(n: int) -> List[int]: Returns a list of prime numbers less than or equal to n using the Sieve of Eratosthenes algorithm. if n < 2: return [] is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 prime_numbers = [p for p in range(2, n + 1) if is_prime[p]] return prime_numbers"},{"question":"# Sorting a Dictionary by Value Context: You are asked to implement a function that sorts a dictionary by its values. # Function: Sort Dictionary By Value Write a function `sort_dict_by_value(d: Dict[Any, int]) -> List[Tuple[Any, int]]` that takes a dictionary `d` as input and returns a list of tuples, where each tuple contains a key and its corresponding value from the dictionary. The list should be sorted in ascending order based on the values. If multiple keys have the same value, their order should be determined by the natural order of the keys. Example: ```python >>> sort_dict_by_value({\'apple\': 10, \'banana\': 5, \'cherry\': 10, \'date\': 2}) [(\'date\', 2), (\'banana\', 5), (\'apple\', 10), (\'cherry\', 10)] >>> sort_dict_by_value({\'a\': 3, \'b\': 1, \'c\': 2}) [(\'b\', 1), (\'c\', 2), (\'a\', 3)] >>> sort_dict_by_value({}) [] ``` # Constraints: 1. The input dictionary may have any hashable type as keys and integers as values. 2. The function should return an empty list if the input dictionary is empty. 3. The time complexity should be O(n log n), where n is the number of items in the dictionary. 4. Do not modify the keys of the dictionary in any way; preserve the original keys and their types. # Note: - You may use the built-in `sorted` function or any other sorting algorithm to achieve the desired order. - Ensure the solution works efficiently even for larger dictionaries.","solution":"from typing import Dict, Any, List, Tuple def sort_dict_by_value(d: Dict[Any, int]) -> List[Tuple[Any, int]]: Sorts a dictionary by its values in ascending order. :param d: Dictionary with values of type int. :return: List of tuples (key, value) sorted by value. return sorted(d.items(), key=lambda item: (item[1], item[0]))"},{"question":"Problem Statement # Context You have recently started working with a team that focuses on data manipulation and transformation tasks. One of the common operations carried out is finding the intersection of multiple lists. This operation is essential in various domains such as database querying, information retrieval, and data analysis. # Task Write a function `find_intersection` that takes a list of lists and returns a list containing the common elements present in all the given lists. The function should return the elements in the order of their first appearance in any of the lists. # Requirements 1. The function should be named `find_intersection`. 2. The function should accept one parameter: - `lists` (list of list of int): A list containing multiple sublists of integers. 3. The function should return a list of integers, representing the intersection of all input lists. 4. If the input `lists` is empty or contains an empty list, the function should return an empty list. # Function Signature ```python def find_intersection(lists: list[list[int]]) -> list[int]: pass ``` # Constraints * Each element in the input lists will be an integer from -10^6 to 10^6. * The length of each sublist will be between 0 and 10^4. * The number of sublists in the `lists` will be between 0 and 10^3. # Example ```python assert find_intersection([[1, 2, 3], [2, 3, 4], [2, 4, 6]]) == [2] assert find_intersection([[5, 3, 2], [3, 4, 5], [5, 3]]) == [5, 3] assert find_intersection([[1, 2], []]) == [] assert find_intersection([[]]) == [] assert find_intersection([[1, 3, 5], [9, 7], [2]]) == [] ``` # Notes Your implementation should carefully handle the edge cases such as empty input lists and varying lengths of sublists. Ensure the solution is efficient given the constraints.","solution":"def find_intersection(lists): Returns the intersection of all input lists. if not lists or any(not sublist for sublist in lists): return [] # Initialize the intersection set with the first list\'s elements intersection_set = set(lists[0]) for sublist in lists[1:]: intersection_set.intersection_update(sublist) # Maintain the order of first appearance of elements in any list intersection_list = [] first_appearance_set = set() for sublist in lists: for el in sublist: if el in intersection_set and el not in first_appearance_set: first_appearance_set.add(el) intersection_list.append(el) return intersection_list"},{"question":"Problem Description You are assigned the task of enhancing a simple text compressor. The compressor will use a rudimentary form of Run-Length Encoding (RLE) to compress strings. Your task is to improve its functionality by including support for decoding, validating input, and handling special cases for extended character sets. Task 1. **Implement the `enhanced_compress` function**: * **Compression**: Use RLE to compress strings. Consecutive occurrences of a character should be replaced with the character followed by the count of its occurrences. * Example: \\"aaabbc\\" should compress to \\"a3b2c1\\". 2. **Implement the `enhanced_decompress` function**: * **Decompression**: Take a compressed string and return the original string. * Example: \\"a3b2c1\\" should decompress to \\"aaabbc\\". 3. **Optimize Input Validation**: * Rather than checking each character individually for validity, validate the entire input in one pass. The input should only contain valid alphabetic characters for compression; for decompression, it should follow the correct format (alternating characters and digits). 4. **Add a Bulk Handling Feature for Both Compression and Decompression**: * Add a function `bulk_compress` to handle multiple strings. * Add a function `bulk_decompress` to handle multiple compressed strings. * These functions should take a list of strings and return a list of encoded or decoded results respectively. # Input and Output Formats Function 1: `enhanced_compress` * **Input**: * A `word` (string) containing alphabetic characters. * Constraints: The string is guaranteed to only contain alphabetic characters (a-z, A-Z). * **Output**: * A compressed string where each character is followed by its count of consecutive occurrences. * **Example**: ```python enhanced_compress(\\"aaabbc\\") == \\"a3b2c1\\" ``` Function 2: `enhanced_decompress` * **Input**: * A `compressed_word` (string) in the format produced by `enhanced_compress`. * Constraints: The string is guaranteed to follow the correct format. * **Output**: * The original uncompressed string. * **Example**: ```python enhanced_decompress(\\"a3b2c1\\") == \\"aaabbc\\" ``` Function 3: `bulk_compress` * **Input**: * A list of `words` containing alphabetic characters. * Constraints: Each string in the list only contains alphabetic characters. * **Output**: * A list of compressed strings. * **Example**: ```python bulk_compress([\\"aaabbc\\", \\"hellooo\\"]) == [\\"a3b2c1\\", \\"h1e1l2o3\\"] ``` Function 4: `bulk_decompress` * **Input**: * A list of `compressed_words` in the format produced by `enhanced_compress`. * Constraints: Each string in the list is guaranteed to follow the correct format. * **Output**: * A list of decompressed strings. * **Example**: ```python bulk_decompress([\\"a3b2c1\\", \\"h1e1l2o3\\"]) == [\\"aaabbc\\", \\"hellooo\\"] ``` Implementation Details 1. Implement `enhanced_compress` to use Run-Length Encoding for the compression. 2. Implement `enhanced_decompress` to reverse the Run-Length Encoding. 3. Implement `bulk_compress` to process a list of strings using the `enhanced_compress` function. 4. Implement `bulk_decompress` to process a list of compressed strings using the `enhanced_decompress` function.","solution":"def enhanced_compress(word): Compresses a string using Run-Length Encoding (RLE). Parameters: word (str): The string to compress. Returns: str: The compressed string. if not word: return \\"\\" compressed = [] count = 1 for i in range(1, len(word)): if word[i] == word[i - 1]: count += 1 else: compressed.append(word[i - 1] + str(count)) count = 1 compressed.append(word[-1] + str(count)) return \'\'.join(compressed) def enhanced_decompress(compressed_word): Decompresses a string encoded with Run-Length Encoding (RLE). Parameters: compressed_word (str): The string to decompress. Returns: str: The decompressed string. if not compressed_word: return \\"\\" decompressed = [] length = len(compressed_word) i = 0 while i < length: char = compressed_word[i] count = \\"\\" i += 1 while i < length and compressed_word[i].isdigit(): count += compressed_word[i] i += 1 decompressed.append(char * int(count)) return \'\'.join(decompressed) def bulk_compress(words): Compresses a list of strings using Run-Length Encoding (RLE). Parameters: words (list): The list of strings to compress. Returns: list: The list of compressed strings. return [enhanced_compress(word) for word in words] def bulk_decompress(compressed_words): Decompresses a list of strings encoded with Run-Length Encoding (RLE). Parameters: compressed_words (list): The list of strings to decompress. Returns: list: The list of decompressed strings. return [enhanced_decompress(word) for word in compressed_words]"},{"question":"# Scenario You are tasked with creating a utility to evaluate mathematical expressions containing different levels of operator precedence. These expressions may include addition, subtraction, multiplication, and division. The aim is to correctly parse and evaluate the expressions according to standard mathematical rules. # Problem Statement Implement the `evaluate_expression` function that takes a string containing a mathematical expression and returns the computed result as a float. The function should correctly handle operator precedence and parenthesis. # Function Signature ```python def evaluate_expression(expression: str) -> float: ``` # Input * `expression` (str): A string representing a mathematical expression. The expression can include: - Positive numbers (integers and decimals). - The operators: `+`, `-`, `*`, `/`. - Parentheses: `(`, `)`. # Output * Returns a float representing the evaluation of the expression. # Exception Handling * Raise a `ValueError` if the expression contains invalid characters or is malformed. * Display an appropriate error message on invalid inputs. # Constraints * The input string will be a valid expression with at most 100 characters. * Division by zero should raise a `ZeroDivisionError`. # Example ```python # Example usage of evaluate_expression print(evaluate_expression(\\"3 + 2 * 2\\")) # 7.0 print(evaluate_expression(\\"(1 + 2) * 3\\")) # 9.0 ``` # Test Cases Ensure your function passes the following test cases: 1. `evaluate_expression(\\"10 + 2 * 6\\")` should return `22.0` 2. `evaluate_expression(\\"100 * 2 + 12\\")` should return `212.0` 3. `evaluate_expression(\\"100 * ( 2 + 12 )\\")` should return `1400.0` 4. `evaluate_expression(\\"100 * ( 2 + 12 ) / 14\\")` should return `100.0` 5. `evaluate_expression(\\"4 / 0\\")` should raise a `ZeroDivisionError` This question ensures learners are familiar with parsing and evaluating expressions according to operator precedence, handling exceptions, and working with common mathematical operations.","solution":"def evaluate_expression(expression: str) -> float: Evaluate a mathematical expression as a string and return the computed result as a float. Handles operator precedence and parentheses. import re # Validate the expression for any invalid characters if not re.match(r\'^[0-9+-*/(). ]+\', expression): raise ValueError(\\"Invalid characters in expression\\") def parse(expression): def get_number(expression, position): num = \'\' while position < len(expression) and (expression[position].isdigit() or expression[position] == \'.\'): num += expression[position] position += 1 return float(num), position def helper(expression, position): num_stack = [] op_stack = [] while position < len(expression): char = expression[position] if char.isdigit() or char == \'.\': num, position = get_number(expression, position) num_stack.append(num) elif char in \\"+-\\": while op_stack and op_stack[-1] in \\"+-*/\\": apply_operator(num_stack, op_stack.pop()) op_stack.append(char) position += 1 elif char in \\"*/\\": while op_stack and op_stack[-1] in \\"*/\\": apply_operator(num_stack, op_stack.pop()) op_stack.append(char) position += 1 elif char == \'(\': num, position = helper(expression, position + 1) num_stack.append(num) elif char == \')\': position += 1 break else: position += 1 while op_stack: apply_operator(num_stack, op_stack.pop()) return num_stack[0], position def apply_operator(num_stack, operator): b = num_stack.pop() a = num_stack.pop() if operator == \'+\': num_stack.append(a + b) elif operator == \'-\': num_stack.append(a - b) elif operator == \'*\': num_stack.append(a * b) elif operator == \'/\': if b == 0: raise ZeroDivisionError(\\"Division by zero\\") num_stack.append(a / b) expr_cleaned = re.sub(r\'s+\', \'\', expression) return helper(expr_cleaned, 0)[0] return parse(expression)"},{"question":"# Coding Assessment Question Context In computer science, an isomorphism between two strings means you can map the characters of one string to characters of another string one-to-one and onto. This means no two characters of the first string map to the same character of the second string and vice versa. Task Write a function `are_isomorphic(str1: str, str2: str) -> bool` that determines if two given strings are isomorphic. Function Signature ```python def are_isomorphic(str1: str, str2: str) -> bool: pass ``` Input - Two strings `str1` and `str2`, each of (1 leq text{len(str1)} = text{len(str2)} leq 10^4). Output - A boolean `True` if the strings are isomorphic, otherwise `False`. Constraints - The function should handle strings containing any printable ASCII characters. - The function should be case-sensitive i.e., \'A\' and \'a\' are different characters. Examples ```python >>> are_isomorphic(\\"egg\\", \\"add\\") True >>> are_isomorphic(\\"foo\\", \\"bar\\") False >>> are_isomorphic(\\"paper\\", \\"title\\") True >>> are_isomorphic(\\"abc\\", \\"ab\\") Traceback (most recent call last): ... ValueError: Strings are of different lengths, cannot be isomorphic >>> are_isomorphic(\\"ab\\", \\"aa\\") False ``` Hints - Utilize dictionaries to establish the mapping between characters. - Ensure that the mapping is bidirectional. Special Cases to Consider - Strings with one character. - Strings with repeated characters.","solution":"def are_isomorphic(str1: str, str2: str) -> bool: Determines if two strings are isomorphic. Two strings are isomorphic if there is a one-to-one mapping between every character of str1 to every character of str2. Parameters: - str1 (str): The first input string. - str2 (str): The second input string of the same length as str1. Returns: - bool: True if strings are isomorphic, otherwise False. Raises: - ValueError: If the input strings are of different lengths. if len(str1) != len(str2): raise ValueError(\\"Strings are of different lengths, cannot be isomorphic\\") mapping_str1_to_str2 = {} mapping_str2_to_str1 = {} for char1, char2 in zip(str1, str2): if char1 in mapping_str1_to_str2: if mapping_str1_to_str2[char1] != char2: return False else: mapping_str1_to_str2[char1] = char2 if char2 in mapping_str2_to_str1: if mapping_str2_to_str1[char2] != char1: return False else: mapping_str2_to_str1[char2] = char1 return True"},{"question":"# Scenario: You are working on a utility tool that performs basic list manipulations. One of the functionalities needed is the ability to rotate a list to the left by a specified number of positions. # Problem Statement: Given a list of integers and a non-negative integer `k`, implement a function that returns a new list that is rotated to the left by `k` positions. If `k` is greater than the length of the list, the rotation should continue cyclically. # Function Signature: ```python def rotate_left(lst: List[int], k: int) -> List[int]: ``` # Input: * `lst`: A List of integers. Length `n`. * `k`: A non-negative integer representing the number of positions to rotate the list. # Output: * Returns a List of integers representing the rotated list. # Constraints: * 0 <= k * 0 <= n <= 10^5 # Example: ```python assert rotate_left([1, 2, 3, 4, 5], 2) == [3, 4, 5, 1, 2] assert rotate_left([0, 1, 2, 3], 4) == [0, 1, 2, 3] assert rotate_left([1, 2, 3], 5) == [3, 1, 2] assert rotate_left([], 3) == [] ``` # Additional Instructions: * Ensure that the solution is efficient and handles large inputs gracefully. * Consider edge cases like empty lists and when `k` is zero. --- This new question aims to maintain the consistent style, complexity, and scope of the provided sample while introducing a different yet related problem. It matches the original question\'s length, aligns with list manipulation and algorithmic problem-solving, thereby fitting seamlessly into the original set of questions.","solution":"def rotate_left(lst, k): Rotates the list to the left by k positions. Parameters: lst (List[int]): The list of integers to be rotated. k (int): The number of positions to rotate the list. Returns: List[int]: The rotated list. if not lst: return lst n = len(lst) k = k % n # To handle cases where k is greater than the length of the list return lst[k:] + lst[:k]"},{"question":"# Problem Statement You are given a dictionary representing a list of students along with their marks in various subjects. Implement a function that will rank the students based on their average marks across all subjects. In case two students have the same average marks, rank them alphabetically by their names. You need to complete the function: 1. `rank_students(students: dict) -> list` Function Description 1. **rank_students** * **Input:** - `students (dict)`: A dictionary where keys are student names (strings) and values are lists of integers representing their marks in various subjects. * **Output:** - Returns a list of student names ranked in descending order based on their average marks. If two students have the same average marks, sort them alphabetically by their names. Performance Requirements The solution should be efficient with a time complexity of O(n log n) and space complexity of O(n), where n is the number of students. Input/Output Format * **Input Example:** ```python students = { \\"Alice\\": [85, 90, 78], \\"Bob\\": [90, 88, 92], \\"Charlie\\": [85, 90, 78], \\"David\\": [70, 75, 80] } ``` * **Output Example:** ```python rank_students(students) # Output: [\\"Bob\\", \\"Alice\\", \\"Charlie\\", \\"David\\"] ``` Make sure to handle edge cases such as students with no marks and students with identical average marks.","solution":"def rank_students(students): # Calculate the average marks for each student averages = {} for student, marks in students.items(): if marks: # Avoid division by zero averages[student] = sum(marks) / len(marks) else: averages[student] = 0 # Sort students first by name alphabetically for tie-breaking sorted_students = sorted(averages.items()) # Sort students by average marks in descending order sorted_students_by_avg = sorted(sorted_students, key=lambda x: x[1], reverse=True) # Extract the student names from the sorted list ranked_students = [student for student, avg in sorted_students_by_avg] return ranked_students"},{"question":"# Problem Statement You need to write a function that determines the first unique character in a string. This problem requires knowledge of string manipulation, dictionary usage, and algorithm optimization. # Function Signature ```python def first_unique_char(s: str) -> int: Finds the index of the first unique (non-repeating) character in the string s. :param s: A string in which to find the first unique character. :return: An integer representing the index of the first unique character in the string. If there is no unique character, return -1. Example: >>> first_unique_char(\\"leetcode\\") 0 >>> first_unique_char(\\"loveleetcode\\") 2 >>> first_unique_char(\\"aabb\\") -1 pass ``` # Constraints 1. The input string `s` will only contain lowercase English letters (\'a\' - \'z\'). 2. The length of the string `s` will be between 1 and 10^5. # Requirements - The function should aim for O(n) time complexity where n is the length of the string. - Ensure the solution is memory efficient, using appropriate data structures. # Example **Input**: ```python s = \\"leetcode\\" ``` **Output**: ```python 0 ``` **Explanation**: - The first non-repeating character is \'l\', which is at index 0. **Input**: ```python s = \\"loveleetcode\\" ``` **Output**: ```python 2 ``` **Explanation**: - The first non-repeating character is \'v\', which is at index 2. **Input**: ```python s = \\"aabb\\" ``` **Output**: ```python -1 ``` **Explanation**: - There are no unique characters in the string.","solution":"def first_unique_char(s: str) -> int: Finds the index of the first unique (non-repeating) character in the string s. :param s: A string in which to find the first unique character. :return: An integer representing the index of the first unique character in the string. If there is no unique character, return -1. # Dictionary to store the frequency of each character char_count = {} # First pass to count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass to find the index of the first unique character for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"# Task: Implement a Nested List Summation Context You are developing a general-purpose summation utility for processing datasets. These datasets are structured as nested lists, where each element can either be an integer or another nested list containing integers. Objective Write a function `nested_list_sum` that computes the sum of all integers within a nested list structure. The function should handle arbitrarily deep nesting. # Function Signature ```python def nested_list_sum(nested_list: list) -> int: pass ``` # Input * **nested_list** (list): A list where elements can be integers or further nested lists containing integers. # Output * **int**: The sum of all integers present within the nested list. # Constraints * The depth of the nested list will be in the range [1, 100]. * Each element in the list will be either an integer or another list. * Integers will be in the range [-10^6, 10^6]. # Example Scenarios Example 1 * **Input**: [1, [2, 3, [4]], 5] * **Output**: 15 * **Explanation**: The sum of all integers is 1 + 2 + 3 + 4 + 5 = 15. Example 2 * **Input**: [1, [2, [3, [4, [5]]]]] * **Output**: 15 * **Explanation**: The sum of all integers is 1 + 2 + 3 + 4 + 5 = 15. Example 3 * **Input**: [-1, [-2, [-3, [-4, [-5]]]]] * **Output**: -15 * **Explanation**: The sum of all integers is -1 + (-2) + (-3) + (-4) + (-5) = -15. # Performance Requirements * The function should efficiently handle deeply nested lists using recursion. # Points to Consider * Handle edge cases with empty nested lists. * Ensure to validate that all non-list elements are integers.","solution":"def nested_list_sum(nested_list: list) -> int: def helper(lst): total = 0 for element in lst: if isinstance(element, list): total += helper(element) else: total += element return total return helper(nested_list)"},{"question":"# Reverse Words in a String Problem Statement You are given a string where each word is separated by a single space. Your task is to write a function that reverses the words in the string while maintaining the original word spacing. Write a function `reverse_words(input_str: str) -> str` that takes a string as input and returns a new string with the words in reverse order. Input Format * A non-empty string `input_str`. Output Format * A single string with the words reversed. Example Input: ```python input_str = \\"Hello World\\" ``` Output: ```python \\"World Hello\\" ``` Additional Example Scenarios Input: ```python input_str = \\"Coding is fun\\" ``` Output: ```python \\"fun is Coding\\" ``` Constraints * The input string `input_str` will have at least one word. * The words in the input string will be separated by a single space. * The input string will contain only alphabetic characters and spaces. Requirements * Implement the function `reverse_words` with the following signature: ```python def reverse_words(input_str: str) -> str: ``` Performance * The implementation should run with a time complexity of O(n), where n is the length of the input string.","solution":"def reverse_words(input_str: str) -> str: Returns a string with the words in reversed order. :param input_str: A string where each word is separated by a single space. :return: A single string with the words reversed. words = input_str.split() reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"# Context You are working on a function that generates all unique permutations of a given string. This function could be useful for various applications such as generating anagrams or solving puzzles. # Problem Statement Implement a function `generate_permutations` that returns all unique permutations of a given string. # Requirements 1. **Function Signature**: ```python def generate_permutations(s: str) -> list[str]: ``` 2. **Input**: - `s` (str): A string for which unique permutations are to be generated. 3. **Output**: - Returns a list of strings representing all unique permutations of the input string. 4. **Constraints**: - The input string `s` will consist of only lowercase alphabets (\'a\' - \'z\'). - The length of the input string will not exceed 10 characters. 5. **Error Handling**: - If the input string is empty, return an empty list. # Examples ```python >>> generate_permutations(\\"abc\\") [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] >>> generate_permutations(\\"aabc\\") [\'aabc\', \'aacb\', \'abac\', \'abca\', \'acab\', \'acba\', \'baac\', \'baca\', \'bcaa\', \'caab\', \'caba\', \'cbaa\'] >>> generate_permutations(\\"\\") [] ``` # Notes - Ensure the code handles generation of permutations efficiently. - Consider using a recursive approach or a library like `itertools` for generating permutations. - Remove any duplicate permutations to ensure the uniqueness of the results. --- This question follows the style and complexity of the provided sample question. It addresses a common algorithmic problem (permutations) that tests the candidate\'s understanding of recursion or iterative techniques and their ability to handle unique values and efficient computation.","solution":"import itertools def generate_permutations(s: str) -> list[str]: Generate all unique permutations of a given string s. Parameters: s (str): The input string Returns: list[str]: A list containing all unique permutations of the string if not s: return [] permutations = set(itertools.permutations(s)) return [\'\'.join(p) for p in permutations]"},{"question":"# Temperature Unit Converter You are tasked with developing a function to convert temperature values between different units using a predefined conversion table. The conversion table lists the conversion formulas for different units (Celsius, Fahrenheit, Kelvin). Function Signature ```python def convert_temperature(temp_value: float, unit_from: str, unit_to: str) -> float: ``` Input * `temp_value` (float): The temperature value to be converted. Must be of type float or int. * `unit_from` (str): The unit of the provided temperature value. Must be one of the keys in `temp_chart`. * `unit_to` (str): The unit to which the temperature should be converted. Must be one of the keys in `temp_chart`. Output * The converted temperature value rounded to two decimal places. Errors The function should raise a `ValueError` if: * Either `unit_from` or `unit_to` is not in `temp_chart`. Conversion Formulas The temperature units and their corresponding conversion formulas are provided in the `temp_chart` dictionary: ```python temp_chart: dict[tuple, callable] = { (\\"Celsius\\", \\"Fahrenheit\\"): lambda c: c * 9 / 5 + 32, (\\"Celsius\\", \\"Kelvin\\"): lambda c: c + 273.15, (\\"Fahrenheit\\", \\"Celsius\\"): lambda f: (f - 32) * 5 / 9, (\\"Fahrenheit\\", \\"Kelvin\\"): lambda f: (f - 32) * 5 / 9 + 273.15, (\\"Kelvin\\", \\"Celsius\\"): lambda k: k - 273.15, (\\"Kelvin\\", \\"Fahrenheit\\"): lambda k: (k - 273.15) * 9 / 5 + 32, } ``` Example Usage ```python >>> convert_temperature(25, \\"Celsius\\", \\"Fahrenheit\\") 77.00 >>> convert_temperature(0, \\"Celsius\\", \\"Kelvin\\") 273.15 >>> convert_temperature(100, \\"Fahrenheit\\", \\"Celsius\\") 37.78 >>> convert_temperature(300, \\"Kelvin\\", \\"Celsius\\") 26.85 >>> convert_temperature(500, \\"Kelvin\\", \\"Fahrenheit\\") 440.33 >>> convert_temperature(32, \\"Fahrenheit\\", \\"Kelvin\\") 273.15 ```","solution":"def convert_temperature(temp_value: float, unit_from: str, unit_to: str) -> float: Converts a temperature value from one unit to another based on predefined conversion formulas. Args: temp_value (float): The temperature value to be converted. unit_from (str): The unit of the provided temperature value. Must be one of \'Celsius\', \'Fahrenheit\', or \'Kelvin\'. unit_to (str): The unit to which the temperature should be converted. Must be one of \'Celsius\', \'Fahrenheit\', or \'Kelvin\'. Returns: float: The converted temperature value rounded to two decimal places. Raises: ValueError: If the units provided are not one of \'Celsius\', \'Fahrenheit\', or \'Kelvin\'. temp_chart = { (\\"Celsius\\", \\"Fahrenheit\\"): lambda c: c * 9 / 5 + 32, (\\"Celsius\\", \\"Kelvin\\"): lambda c: c + 273.15, (\\"Fahrenheit\\", \\"Celsius\\"): lambda f: (f - 32) * 5 / 9, (\\"Fahrenheit\\", \\"Kelvin\\"): lambda f: (f - 32) * 5 / 9 + 273.15, (\\"Kelvin\\", \\"Celsius\\"): lambda k: k - 273.15, (\\"Kelvin\\", \\"Fahrenheit\\"): lambda k: (k - 273.15) * 9 / 5 + 32, } if (unit_from, unit_to) not in temp_chart: raise ValueError(f\\"Conversion from {unit_from} to {unit_to} is not supported.\\") converted_value = temp_chart[(unit_from, unit_to)](temp_value) return round(converted_value, 2)"},{"question":"# Problem Statement A company is implementing a new discount system based on customers\' purchase histories. Each customer has a unique ID and a list of past purchase amounts. The company wants to compute a cumulative discount for each customer based on their spending. Here is the rule for calculating the discount: - For every purchase history amount that is a multiple of 10, the customer gets a discount equivalent to 10% of that purchase. - For all other amounts, the customer gets no discount. Write a function that computes the total discount given the customer\'s purchase history. # Function Signature ```python def calculate_total_discount(purchase_history: List[int]) -> float: pass ``` # Inputs * `purchase_history` (List[int]): A list of integers representing the amounts of the customer\'s purchases. The list may contain up to 100,000 purchases, and each amount is between 1 and 10,000. # Outputs * Returns (float): The total discount amount. # Constraints * Ensure that the function efficiently handles the large size of the `purchase_history` list. * The function should return the discount as a floating-point number rounded to two decimal places. # Example 1. `calculate_total_discount([10, 55, 30, 14, 20])` -> `6.00` 2. `calculate_total_discount([100, 200, 300])` -> `60.00` 3. `calculate_total_discount([5, 7, 11, 19])` -> `0.00` # Scenario A customer with ID 12345 has made the following purchases: 10, 55, 30, 14, 20. The company wants to know how much discount they can offer this customer. Since the purchases 10, 30, and 20 are multiples of 10, the customer will earn a discount of (0.1 * 10) + (0.1 * 30) + (0.1 * 20) = 1.00 + 3.00 + 2.00 = 6.00. Implement the `calculate_total_discount` function to automate this calculation across various customers and their purchase histories.","solution":"from typing import List def calculate_total_discount(purchase_history: List[int]) -> float: total_discount = 0.0 for amount in purchase_history: if amount % 10 == 0: total_discount += amount * 0.10 return round(total_discount, 2)"},{"question":"# Coding Challenge: Rotating Matrix in Place # Question: Write a function that rotates an `N x N` matrix 90 degrees clockwise in place. The matrix is represented as a list of lists, where each inner list corresponds to a row in the matrix. Your task is to modify the input matrix directly, without using extra space for another matrix (i.e., in-place rotation). **Function Signature**: ```python def rotate_matrix(matrix: List[List[int]]) -> None: pass ``` **Parameters**: - `matrix` (List[List[int]]): An `N x N` list of lists representing the matrix to be rotated. Each cell contains an integer. **Returns**: - This function does not return anything. The input matrix should be modified in place, reflecting the rotation. **Constraints**: - The input matrix will always be a square matrix (i.e., `N x N`). - `1 <= N <= 200`. - Each element in the matrix is an integer within the range `-1000 <= matrix[i][j] <= 1000`. **Example**: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) print(matrix) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` **Hint**: You may find it helpful to first transpose the matrix and then reverse each row.","solution":"def rotate_matrix(matrix): Rotates an NxN matrix 90 degrees clockwise in place. :param matrix: List[List[int]], the NxN matrix to be rotated # First, transpose the matrix n = len(matrix) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Problem Statement You are given a list that contains information about various students and their respective marks in different subjects. Your task is to implement a function that calculates and returns the class average for a specified subject. # Requirements Implement the function `class_average()` that calculates the average mark for a specified subject across all students. # Function Signature ```python def class_average(students: list[dict], subject: str) -> float | ValueError: pass ``` # Input Parameters - `students`: A list of dictionaries, where each dictionary represents a student. Each dictionary contains the following keys: - `\\"name\\"`: The name of the student (a string). - `\\"marks\\"`: A dictionary of subjects and their respective marks (subject names as strings and marks as integers). - `subject`: The subject for which the class average is to be calculated (a string). # Output Return the average mark for the specified subject across all students. If the `subject` does not exist in a student\'s marks dictionary or if the `students` list is empty, return a `ValueError` with the message \\"Input Error: Invalid subject or empty student list.\\" # Example ```python >>> students = [ ... {\\"name\\": \\"Alice\\", \\"marks\\": {\\"math\\": 85, \\"science\\": 90}}, ... {\\"name\\": \\"Bob\\", \\"marks\\": {\\"math\\": 78, \\"science\\": 85}}, ... {\\"name\\": \\"Charlie\\", \\"marks\\": {\\"math\\": 92, \\"science\\": 88}} ...] >>> class_average(students, \\"math\\") 85.0 >>> class_average(students, \\"english\\") ValueError(\'Input Error: Invalid subject or empty student list.\') >>> class_average([], \\"science\\") ValueError(\'Input Error: Invalid subject or empty student list.\') ``` # Constraints - The function should check if the students list is non-empty. - Ensure that the specified subject exists in the marks dictionary of each student. - Handle edge cases where the subject is not present or the list of students is empty appropriately by raising a `ValueError`.","solution":"def class_average(students, subject): Calculates the average mark for a specified subject across all students. :param students: List of dictionaries containing student names and their marks. :param subject: The subject for which the class average is to be calculated. :return: The average mark for the specified subject or raises a ValueError. if not students: raise ValueError(\\"Input Error: Invalid subject or empty student list.\\") total_marks = 0 count = 0 for student in students: marks = student.get(\\"marks\\", {}) if subject in marks: total_marks += marks[subject] count += 1 if count == 0: raise ValueError(\\"Input Error: Invalid subject or empty student list.\\") return total_marks / count"},{"question":"# Coding Question Write a function that computes the final amount of money in a bank account after a series of transactions, based on the initial amount and a list of transactions. Each transaction can be a deposit (positive amount) or a withdrawal (negative amount). **Function: `calculate_final_balance`** ```python def calculate_final_balance(initial_balance: float, transactions: list) -> float: This function takes an initial balance (in USD) and a list of transactions. Each transaction can be either a positive amount (deposit) or a negative amount (withdrawal). It returns the final balance of the account after applying all transactions. Examples: >>> calculate_final_balance(100.0, [20.0, -30.0, 50.0, -10.0]) 130.0 >>> calculate_final_balance(200.0, [-50.0, -75.0]) 75.0 >>> calculate_final_balance(150.0, [0.0, 0.0]) 150.0 >>> calculate_final_balance(500.0, []) 500.0 >>> calculate_final_balance(100.0, [200.0, -100.0, -50.0]) 150.0 pass # your code here ``` # Explanation The function should implement the following logic: 1. Start with the `initial_balance`. 2. For each transaction in the `transactions` list, add the transaction amount to the balance. 3. Return the final balance after processing all transactions. # Constraints * Initial balance must be a non-negative real number. * Each transaction must be a real number. # Example Scenario: You are developing a personal finance application where users can track their bank account balance. To provide accurate information, you need to calculate the final account balance based on their initial balance and a series of financial transactions. **Sample Input:** ```python initial_balance = 100.0 transactions = [20.0, -30.0, 50.0, -10.0] ``` **Sample Output:** ```python 130.0 ```","solution":"def calculate_final_balance(initial_balance: float, transactions: list) -> float: This function takes an initial balance (in USD) and a list of transactions. Each transaction can be either a positive amount (deposit) or a negative amount (withdrawal). It returns the final balance of the account after applying all transactions. Examples: >>> calculate_final_balance(100.0, [20.0, -30.0, 50.0, -10.0]) 130.0 >>> calculate_final_balance(200.0, [-50.0, -75.0]) 75.0 >>> calculate_final_balance(150.0, [0.0, 0.0]) 150.0 >>> calculate_final_balance(500.0, []) 500.0 >>> calculate_final_balance(100.0, [200.0, -100.0, -50.0]) 150.0 final_balance = initial_balance for transaction in transactions: final_balance += transaction return final_balance"},{"question":"# Detect Cycle in a Directed Graph **Objective**: Write a Python function to detect if there is a cycle in a given directed graph. **Function Signature**: ```python def has_cycle(graph: dict) -> bool: ``` Input: 1. **`graph`** (dict): The adjacency list representation of the directed graph where keys are node labels, and values are lists of nodes to which the key node has a directed edge. Output: - **`bool`**: Return `True` if there is a cycle in the graph, otherwise return `False`. Constraints: 1. The graph can contain any number of nodes, including zero (an empty graph). 2. Node labels are unique integers. 3. The function must handle both positive and negative integers and any valid graph configuration. Example Scenarios: Here are some example scenarios to illustrate the expected outputs: 1. **Example 1:** * Input: `graph = {0: [1], 1: [2], 2: [0]}` * Output: `True` * Explanation: There is a cycle (0 -> 1 -> 2 -> 0). 2. **Example 2:** * Input: `graph = {0: [1, 2], 1: [2], 2: []}` * Output: `False` * Explanation: There is no cycle in this graph. 3. **Example 3:** * Input: `graph = {0: []}` * Output: `False` * Explanation: There is only one node with no edges, so no cycle can exist. 4. **Example 4:** * Input: `graph = {}` * Output: `False` * Explanation: An empty graph has no cycles. Additional Requirements: 1. Your implementation must be efficient with respect to both time and space. 2. Please include sufficient tests to validate your implementation, covering both typical and edge cases. Use the given format for the graph representation and ensure your solution is robust enough to handle varied and potentially sparse inputs.","solution":"def has_cycle(graph: dict) -> bool: Detects if a directed graph has a cycle. Args: - graph (dict): The adjacency list representation of the directed graph Returns: - bool: True if there is a cycle, otherwise False def visit(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph.get(node, []): if visit(neighbor): return True visiting.remove(node) visited.add(node) return False visited = set() visiting = set() for node in graph: if visit(node): return True return False"},{"question":"# Employee Hierarchy Objective Write a function `find_closest_common_manager(top_manager, emp1, emp2)` that determines the closest common manager of two employees in an organizational hierarchy. Requirements & Constraints 1. The function should accept: * `top_manager`: An instance of `Employee`, acting as the topmost manager in the hierarchy. * `emp1`: An instance of `Employee`, representing the first employee. * `emp2`: An instance of `Employee`, representing the second employee. 2. `Employee` class is defined with: ```python class Employee: def __init__(self, name): self.name = name self.direct_reports = [] # List of direct reports (subordinates) ``` 3. The function should return the closest common manager (an instance of `Employee`) who has both `emp1` and `emp2` as direct or indirect subordinates. 4. It is guaranteed that both employees are part of the organization under the given `top_manager`. 5. Consider edge cases such as one employee being the manager of the other and both employees reporting to the same direct manager. Example ```python class Employee: def __init__(self, name): self.name = name self.direct_reports = [] def find_closest_common_manager(top_manager, emp1, emp2): >>> ceo = Employee(\\"CEO\\") >>> head_sales = Employee(\\"Head of Sales\\") >>> sales_manager_1 = Employee(\\"Sales Manager 1\\") >>> sales_manager_2 = Employee(\\"Sales Manager 2\\") >>> ceo.direct_reports = [head_sales] >>> head_sales.direct_reports = [sales_manager_1, sales_manager_2] >>> find_closest_common_manager(ceo, sales_manager_1, sales_manager_2).name \'Head of Sales\' >>> find_closest_common_manager(ceo, head_sales, sales_manager_1).name \'Head of Sales\' >>> find_closest_common_manager(ceo, ceo, sales_manager_1).name \'CEO\' # Your implementation here # Example Tests ceo = Employee(\\"CEO\\") head_sales = Employee(\\"Head of Sales\\") sales_manager_1 = Employee(\\"Sales Manager 1\\") sales_manager_2 = Employee(\\"Sales Manager 2\\") ceo.direct_reports = [head_sales] head_sales.direct_reports = [sales_manager_1, sales_manager_2] print(find_closest_common_manager(ceo, sales_manager_1, sales_manager_2).name) # \'Head of Sales\' print(find_closest_common_manager(ceo, head_sales, sales_manager_1).name) # \'Head of Sales\' print(find_closest_common_manager(ceo, ceo, sales_manager_1).name) # \'CEO\' ``` Your function should pass the provided example tests along with additional edge cases you can think of that must validate against the described requirements and constraints. Implementation Notes - Consider depth-first search or any suitable tree-based algorithm to find ancestors. - Pay attention to edge cases and organizational structure variations.","solution":"class Employee: def __init__(self, name): self.name = name self.direct_reports = [] def find_closest_common_manager(top_manager, emp1, emp2): Determines the closest common manager of emp1 and emp2 under the hierarchy starting from top_manager. if top_manager is None or top_manager == emp1 or top_manager == emp2: return top_manager count = 0 temp_manager = None for report in top_manager.direct_reports: manager = find_closest_common_manager(report, emp1, emp2) if manager is not None: count += 1 temp_manager = manager # If both employees are found in the subtree, the current manager is common if count == 2: return top_manager return temp_manager"},{"question":"# Task Description You are given a binary tree represented by the `BinaryTreeNode` class. Implement a function `find_nodes_at_level(root: BinaryTreeNode | None, level: int) -> list[int]` that returns a list of node values that are present at the specified level in the given binary tree. # Function Signature ```python def find_nodes_at_level(root: BinaryTreeNode | None, level: int) -> list[int]: ``` # Input - **root**: The root node of the binary tree (`BinaryTreeNode` | `None`). If the root is `None`, return an empty list. - **level**: An integer representing the level for which the nodes\' values are to be found. # Output - A list of integers representing the node values at the specified level. The nodes should be returned in the order they appear from left to right. # Constraints - You may assume the tree has at most `10^4` nodes. - The level provided will be at least `0`. If the level given is greater than the height of the tree, return an empty list. # Example Given the binary tree constructed as follows: ``` 1 / 2 3 / 4 5 ``` - For level `0`, the nodes are `[1]`. - For level `1`, the nodes are `[2, 3]`. - For level `2`, the nodes are `[4, 5]`. For the binary tree above, the `find_nodes_at_level` function should return: - `find_nodes_at_level(root, 0)` -> `[1]` - `find_nodes_at_level(root, 1)` -> `[2, 3]` - `find_nodes_at_level(root, 2)` -> `[4, 5]` # Notes - Consider performance optimizations for handling large trees. - Ensure thorough testing for edge cases mentioned in the analysis. # Implementation Implement the function `find_nodes_at_level` in Python. The function should efficiently handle trees of large size and depth.","solution":"class BinaryTreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_nodes_at_level(root: BinaryTreeNode | None, level: int) -> list[int]: if not root: return [] if level == 0: return [root.value] current_level = 0 queue = [(root, current_level)] result = [] while queue: node, current_level = queue.pop(0) if current_level == level: result.append(node.value) if node.left: queue.append((node.left, current_level + 1)) if node.right: queue.append((node.right, current_level + 1)) return result"},{"question":"# Coding Assessment Question **Context**: You are given a sequence of integers where each integer represents the level of a node in a binary tree. The root of the tree is at level 1, its children are at level 2, and so on. The goal is to reconstruct the binary tree based on the given sequence and perform a level-order traversal. The level-order traversal visits nodes at each tree depth level from left to right. **Task**: Write a function to reconstruct a binary tree from a given sequence of node levels and then return its level-order traversal. **Function Signature**: ```python def level_order_traversal_from_levels(levels: List[int]) -> List[List[int]]: This function reconstructs a binary tree based on the sequence of node levels and returns its level-order traversal. ``` **Input**: * A list of integers `levels` (1 ≤ len(levels) ≤ 1000), where each integer represents the level of a node in the tree. The sequence always starts with the root level (1). **Output**: * A list of lists of integers, with each sublist representing the values of nodes at each level of the tree in left-to-right order. **Example**: ```python >>> level_order_traversal_from_levels([1, 2, 2, 3, 3, 3, 3]) [[1], [2, 2], [3, 3, 3, 3]] >>> level_order_traversal_from_levels([1, 2, 3, 3, 2, 3, 3]) [[1], [2, 2], [3, 3, 3, 3]] ``` **Constraints/Notes**: * The binary tree must follow the property of complete binary trees, meaning every level except possibly the last is completely filled, and all nodes are as far left as possible. * Ensure your solution can handle the maximum constraints efficiently. * Nodes at the same level should be ordered as they appear in the input list.","solution":"from collections import defaultdict, deque from typing import List def level_order_traversal_from_levels(levels: List[int]) -> List[List[int]]: This function reconstructs a binary tree based on the sequence of node levels and returns its level-order traversal. # Dictionary to hold nodes for each level level_dict = defaultdict(list) # Populate the dictionary with nodes at each level for node in levels: level_dict[node].append(node) # Extract and sort the levels to ensure correct level-order traversal sorted_levels = sorted(level_dict.keys()) # Build the result list by concatenating node lists in level order result = [level_dict[level] for level in sorted_levels] return result"},{"question":"# Problem Statement Write a function `generate_request_url(base_url: str, params: dict) -> str` that constructs a properly formatted URL string with query parameters. The function should accept a base URL and a dictionary representing the query parameters and their corresponding values. # Input and Output Format **Input**: 1. `base_url` (str): The base URL to which query parameters should be appended. 2. `params` (dict): A dictionary with query parameter names as keys and their corresponding values. **Output**: - Returns a `str` representing the full URL with the query parameters properly appended. # Constraints: - `base_url` is a valid URL string. - `params` values can be either strings or numbers. - Keys and values in `params` are non-empty and URL-safe. # Example Input: ```python base_url = \\"https://api.example.com/data\\" params = { \\"user\\": \\"john_doe\\", \\"id\\": 12345, \\"format\\": \\"json\\" } ``` Output: ```python \\"https://api.example.com/data?user=john_doe&id=12345&format=json\\" ``` # Edge Cases to Consider - Empty `params` dictionary. - `base_url` without an existing query string. - Handling special characters in the parameters appropriately. # Additional Instructions Ensure the function correctly handles encoding of query parameters and combines the base URL with the encoded query string efficiently.","solution":"import urllib.parse def generate_request_url(base_url: str, params: dict) -> str: Constructs a properly formatted URL string with query parameters. :param base_url: The base URL to which query parameters should be appended. :param params: A dictionary with query parameter names as keys and their corresponding values. :return: A string representing the full URL with the query parameters properly appended. if not params: return base_url query_string = urllib.parse.urlencode(params) return f\\"{base_url}?{query_string}\\""},{"question":"Problem Statement Write a function that returns the nth term in the Fibonacci sequence. The Fibonacci sequence is defined as follows: - The first term (n = 1) is 0. - The second term (n = 2) is 1. - Each subsequent term is the sum of the two preceding terms. Your task is to implement a function that calculates the nth Fibonacci number efficiently, considering both iterative and recursive approaches where the recursive method should utilize memoization to avoid redundant calculations. # Function Signature: ```python def fibonacci(n: int) -> int: ``` # Input * `n` - An integer with the constraint 1 ≤ n ≤ 1000. # Output * Return the nth term in the Fibonacci sequence. # Example ```python >>> fibonacci(1) 0 >>> fibonacci(5) 3 >>> fibonacci(10) 34 ``` # Constraints 1. The function should be optimized to handle large values of n efficiently. 2. Utilize memoization if using a recursive approach to ensure the function executes within a reasonable time frame for large n. 3. The function must return accurate results for all integers within the given range.","solution":"def fibonacci(n: int) -> int: Returns the nth term in the Fibonacci sequence. if n <= 0: raise ValueError(\\"n must be a positive integer\\") # Base cases if n == 1: return 0 if n == 2: return 1 # Initialize the first two terms in the Fibonacci sequence prev, curr = 0, 1 # Iteratively compute the nth Fibonacci number for i in range(3, n + 1): prev, curr = curr, prev + curr return curr"},{"question":"# Median of Medians Algorithm for Quickselect in Finding the k-th Smallest Element You are tasked with implementing an efficient algorithm to find the k-th smallest element in an unsorted array. Utilize the \\"Median of Medians\\" algorithm to achieve a guaranteed worst-case time complexity. Your task is to implement the Median of Medians algorithm, which will be used in the Quickselect partitioning to ensure optimal performance: 1. **Partition the array** to rearrange elements based on a pivot. 2. **Select the median of medians** to find an optimal pivot for partitioning. 3. **Quickselect**: Utilize the overall structure to find the k-th smallest element. # Function Definitions Implement the following functions: 1. **`median_of_medians`**: Selects the pivot using the Median of Medians method. ```python def median_of_medians(arr: List[int], left: int, right: int) -> int: Selects the pivot element using the Median of Medians method within the given subarray. :param arr: The input array. :param left: The starting index of the subarray. :param right: The ending index of the subarray. :return: The pivot element selected using the Median of Medians method. pass ``` 2. **`partition`**: Rearranges the array based on the pivot selected. ```python def partition(arr: List[int], left: int, right: int, pivot: int) -> int: Partitions the array around the given pivot element. :param arr: The input array. :param left: The starting index of the subarray. :param right: The ending index of the subarray. :param pivot: The pivot element for partitioning. :return: The index of the pivot element after partitioning. pass ``` 3. **`quickselect`**: Uses the partitioning to find the k-th smallest element. ```python def quickselect(arr: List[int], left: int, right: int, k: int) -> int: Finds the k-th smallest element in the array using the Quickselect algorithm. :param arr: The input array. :param left: The starting index of the subarray. :param right: The ending index of the subarray. :param k: The order of the smallest element to find (1-based index). :return: The k-th smallest element in the array. pass ``` # Requirements 1. **Performance**: * Ensure the algorithm works with O(n) time complexity in the worst case. * Handle large datasets efficiently. 2. **Edge Cases**: * Handle cases where k is out of bounds. * Handle arrays with duplicate elements and single elements. # Input and Output * **Input**: An array of integers and an integer k. * **Output**: The k-th smallest element in the array. # Example ```python # Example array and k value array = [12, 3, 5, 7, 4, 19, 26] k = 3 # Find the k-th smallest element result = quickselect(array, 0, len(array) - 1, k) print(result) ``` *Expected Output*: ```python 5 # The 3rd smallest element in the array ``` # Notes - The `median_of_medians` function should split the array into groups of 5, find the median of each group, and then recursively find the median of these medians. - The `partition` function should rearrange the array such that elements less than the pivot are on the left, elements equal to the pivot are in the middle, and elements greater than the pivot are on the right. - The `quickselect` function should use the above helper functions to efficiently find the k-th smallest element.","solution":"from typing import List def median_of_medians(arr: List[int], left: int, right: int) -> int: Selects the pivot element using the Median of Medians method within the given subarray. n = right - left + 1 if n <= 5: return sorted(arr[left:right + 1])[n // 2] medians = [] for i in range(left, right + 1, 5): sub_right = min(i + 4, right) median = sorted(arr[i:sub_right + 1])[((sub_right - i) // 2)] medians.append(median) return median_of_medians(medians, 0, len(medians) - 1) def partition(arr: List[int], left: int, right: int, pivot: int) -> int: Partitions the array around the given pivot element. pivot_index = arr.index(pivot) arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left for i in range(left, right): if arr[i] < pivot: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[store_index], arr[right] = arr[right], arr[store_index] return store_index def quickselect(arr: List[int], left: int, right: int, k: int) -> int: Finds the k-th smallest element in the array using the Quickselect algorithm. if left == right: return arr[left] pivot = median_of_medians(arr, left, right) pivot_index = partition(arr, left, right, pivot) if k - 1 == pivot_index: return arr[pivot_index] elif k - 1 < pivot_index: return quickselect(arr, left, pivot_index - 1, k) else: return quickselect(arr, pivot_index + 1, right, k)"},{"question":"# Question You are given a binary tree where each node has a value between 0 and 9. Each root-to-leaf path represents a number constructed by concatenating the values along the path. Write a Python function to find the sum of all the numbers represented by the root-to-leaf paths in the tree. **Input**: * `root` (TreeNode): The root of the binary tree. **Output**: * Return an integer representing the sum of all the numbers formed by the root-to-leaf paths. **Constraints**: * Each node\'s value is between `[0, 9]`. * The number of nodes in the tree is between `[1, 1000]`. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example Tree: # 1 # / # 2 3 root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> sumNumbers(root) 25 ``` **Explanation**: - The root-to-leaf paths are 12 and 13. - The numbers formed are 12 and 13. - Their sum is 12 + 13 = 25. Implement the function `sumNumbers(root: TreeNode) -> int:` that solves the problem efficiently, taking both time and space complexity into account.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumNumbers(root: TreeNode) -> int: def dfs(node, current_number): if not node: return 0 current_number = current_number * 10 + node.val if not node.left and not node.right: return current_number return dfs(node.left, current_number) + dfs(node.right, current_number) return dfs(root, 0)"},{"question":"# Subarray Product Less Than Target Given an array of positive integers and a target value, implement a function that returns the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than the given target value. Function Signature ```python def num_subarray_product_less_than_target(arr: [int], target: int) -> int: ``` Input * An array `arr` of positive integers where each value is in the range `[1, 10]`. * An integer `target` (1 ≤ target ≤ 10^8). Output * An integer representing the number of contiguous subarrays whose product of elements is less than the target. Example ```python >>> num_subarray_product_less_than_target([10, 5, 2, 6], 100) 8 >>> num_subarray_product_less_than_target([1, 2, 3, 4], 10) 7 >>> num_subarray_product_less_than_target([1, 1, 1], 2) 6 >>> num_subarray_product_less_than_target([1, 1, 1, 2], 4) 10 ``` Constraints * Your solution should efficiently handle arrays with a length up to 10^4. * Consider using a sliding window approach or two-pointer technique to optimize the performance. Notes * Ensure that subarrays are considered as contiguous segments of the array. * Handle edge cases such as very small and very large target values appropriately.","solution":"def num_subarray_product_less_than_target(arr, target): if target <= 1: return 0 start = 0 product = 1 count = 0 for end in range(len(arr)): product *= arr[end] while product >= target and start <= end: product //= arr[start] start += 1 count += end - start + 1 return count"},{"question":"# Problem Statement The Fibonacci sequence is a series of numbers where the next number is found by adding up the two numbers before it. However, in this variation, the previous three numbers determine the next number in the sequence (tribonacci sequence). Write a function that generates the first N numbers of this generalized Fibonacci sequence. # Detailed Requirements * Define a function `tribonacci(n: int) -> List[int]` that computes the tribonacci sequence up to the nth term. * Start the sequence with 0, 1, 1. * For (i geq 3), ( T(i) = T(i-1) + T(i-2) + T(i-3) ), where (T(i)) is the ith term in the tribonacci sequence. # Input - **n**: An integer indicating the number of terms in the sequence to generate. (1 ≤ n ≤ 100) # Output - **Output**: A list of integers representing the first n terms of the tribonacci sequence. # Constraints 1. The function should handle: * Boundary conditions (first few terms of the sequence). * Efficient computation up to the 100th term. * Validity of input type and constraints. # Example Cases ``` tribonacci(1) -> [0] tribonacci(5) -> [0, 1, 1, 2, 4] tribonacci(10) -> [0, 1, 1, 2, 4, 7, 13, 24, 44, 81] ``` # Explanation - For `n = 1`, the sequence is `[0]`. - For `n = 5`, the sequence includes the first 5 numbers: `[0, 1, 1, 2, 4]` as calculated by the given formula. - For `n = 10`, the sequence expands to `[0, 1, 1, 2, 4, 7, 13, 24, 44, 81]` according to the same rules.","solution":"def tribonacci(n): Generates the first n numbers of the tribonacci sequence. Parameters: n (int): The number of terms to generate. Returns: List[int]: A list containing the first n terms of the tribonacci sequence. if n <= 0: return [] # Base case for the first 3 numbers result = [0, 1, 1] if n <= 3: return result[:n] # Generate the sequence for i in range(3, n): next_value = result[-1] + result[-2] + result[-3] result.append(next_value) return result"},{"question":"# Coding Question: Enhanced String Matching with Rabin-Karp Algorithm **Background**: The Rabin-Karp algorithm is an efficient text-searching algorithm that uses hashing to find an exact pattern within a text. This algorithm is particularly useful for finding multiple pattern matches. **Task**: Implement a version of the Rabin-Karp algorithm that allows for finding all occurrences of a pattern within a given text and supports multiple patterns to be searched simultaneously. **Function Signature**: ```python def rabin_karp_search(text: str, patterns: list) -> dict: Finds all occurrences of the given patterns within the text using the Rabin-Karp algorithm. :param text: The text in which to search for the patterns. :param patterns: A list of string patterns to search for in the text. :return: A dictionary where each pattern maps to a list of starting indices of its occurrences in the text. Example: >>> rabin_karp_search(\\"abracadabra\\", [\\"abra\\", \\"cad\\"]) {\'abra\': [0, 7], \'cad\': [4]} pass ``` **Instructions**: 1. Implement the function `rabin_karp_search(text, patterns)` which searches for `patterns` within the `text`. 2. Use the Rabin-Karp algorithm to efficiently find all occurrences of each pattern. 3. Handle edge cases appropriately: - Empty text input - Empty patterns list - Patterns that do not exist in the text 4. The function should return a dictionary where each key is a pattern and the value is a list of starting indices where the pattern occurs in the text. 5. Optimize for performance, ensuring the implementation handles large texts and multiple patterns efficiently. **Constraints**: - The length of `text` can be up to 10^5 characters. - The number of patterns will not exceed 100. - Each pattern and the text will contain only uppercase and lowercase English letters. - The length of each pattern will be between 1 and 100 characters. **Example**: ```python >>> rabin_karp_search(\\"abracadabra\\", [\\"abra\\", \\"cad\\"]) {\'abra\': [0, 7], \'cad\': [4]} >>> rabin_karp_search(\\"hellohellohell\\", [\\"hell\\", \\"lo\\", \\"hello\\"]) {\'hell\': [0, 5, 10], \'lo\': [3, 8], \'hello\': [0, 5]} >>> rabin_karp_search(\\"\\", [\\"a\\", \\"b\\"]) {\'a\': [], \'b\': []} >>> rabin_karp_search(\\"abcdefgh\\", []) {} ```","solution":"def rabin_karp_search(text: str, patterns: list) -> dict: Finds all occurrences of the given patterns within the text using the Rabin-Karp algorithm. :param text: The text in which to search for the patterns. :param patterns: A list of string patterns to search for in the text. :return: A dictionary where each pattern maps to a list of starting indices of its occurrences in the text. if not text: return {pattern: [] for pattern in patterns} if not patterns: return {} def get_hash(s): h = 0 for char in s: h = h * 31 + ord(char) return h hash_pats = {pat: get_hash(pat) for pat in patterns} len_pats = {pat: len(pat) for pat in patterns} res = {pat: [] for pat in patterns} for i in range(len(text)): for pat in patterns: len_pat = len_pats[pat] if i + len_pat <= len(text): sub = text[i:i + len_pat] if get_hash(sub) == hash_pats[pat]: if sub == pat: res[pat].append(i) return res"},{"question":"# Problem Statement You are given a set of words. Your task is to implement a function that finds and returns the longest common prefix shared among all the words in the set. If there is no common prefix, the function should return an empty string. # Input Format * A list of strings ( words ) where ( 1 leq len(words) leq 500 ) and ( 0 leq len(words[i]) leq 100 ). # Output Format * A single string representing the longest common prefix shared among all input strings. # Constraints * The input list will contain at least one word. * The words can contain lowercase English letters (a-z) only. # Example ```python For input words [\\"flower\\", \\"flow\\", \\"flight\\"], the output should be \\"fl\\". For input words [\\"dog\\", \\"racecar\\", \\"car\\"], the output should be \\"\\". ``` # Instructions 1. Do not use built-in functions to find the common prefix. 2. Optimize the function for both time and space complexity. # Solution Template Here is a starting template for your solution: ```python def longest_common_prefix(words): if not words: return \\"\\" # Find the shortest word in the list shortest_word = min(words, key=len) # Check prefixes of the shortest word in all words for i in range(len(shortest_word)): char = shortest_word[i] for word in words: if word[i] != char: return shortest_word[:i] return shortest_word if __name__ == \\"__main__\\": user_input = input(\\"Enter words separated by a comma:n\\").strip() words = [item.strip() for item in user_input.split(\\",\\")] print(longest_common_prefix(words)) ``` In your implementation, ensure you handle all edge cases effectively and test the function against a variety of input scenarios before finalizing your code.","solution":"def longest_common_prefix(words): if not words: return \\"\\" # Find the shortest word in the list shortest_word = min(words, key=len) # Check prefixes of the shortest word in all words for i in range(len(shortest_word)): char = shortest_word[i] for word in words: if word[i] != char: return shortest_word[:i] return shortest_word"},{"question":"# Problem Statement: You have been tasked with implementing an algorithm that generates the first `N` prime numbers. A prime number is a natural number greater than 1 that cannot be formed by multiplying two smaller natural numbers. # Detailed Requirements 1. **Input**: - An integer `N` which denotes the number of prime numbers to generate. 2. **Output**: - A list of the first `N` prime numbers. 3. **Constraints**: - `1 ≤ N ≤ 1000` # Algorithm Instructions: 1. Implement a function `is_prime(x)` to check if a number `x` is prime. 2. Use this function within `generate_primes(N)` to obtain the first `N` prime numbers. # Performance Your implementation should ensure that it efficiently generates the primes up to the `N`-th prime, considering optimal time complexity for prime checking and generation. ```python def is_prime(x: int) -> bool: Check if a number is prime. :param x: The number to check. :return: True if x is prime, False otherwise. if x <= 1: return False for i in range(2, int(x**0.5) + 1): if x % i == 0: return False return True def generate_primes(N: int) -> list: Generate the first N prime numbers. :param N: The number of primes to generate. :return: A list of the first N prime numbers. primes = [] number = 2 # Starting from the smallest prime number while len(primes) < N: if is_prime(number): primes.append(number) number += 1 return primes # Example usage print(generate_primes(10)) # Output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] ``` Test your function with different values of `N` to ensure the correct and efficient generation of prime numbers.","solution":"def is_prime(x: int) -> bool: Check if a number is prime. :param x: The number to check. :return: True if x is prime, False otherwise. if x <= 1: return False for i in range(2, int(x**0.5) + 1): if x % i == 0: return False return True def generate_primes(N: int) -> list: Generate the first N prime numbers. :param N: The number of primes to generate. :return: A list of the first N prime numbers. primes = [] number = 2 # Starting from the smallest prime number while len(primes) < N: if is_prime(number): primes.append(number) number += 1 return primes"},{"question":"# Problem Statement You are tasked with analyzing the efficiency of network communication by examining the packet transmission times recorded in milliseconds. Your job is to determine the median transmission time, which gives a good indication of typical performance by mitigating the effects of outliers. Write a function `find_median` that computes the median value of a list of non-negative integer transmission times. The function should handle both odd and even numbers of elements in the input list. # Function Signature ```python def find_median(times: list[int]) -> float: ``` # Input * `times` (list of int): A list containing non-negative integers representing transmission times in milliseconds. The list is guaranteed to have at least one element. # Output * Returns a float representing the median transmission time. # Constraints * The function must raise a `ValueError` with the message \\"All transmission times must be non-negative integers\\" for: * Lists containing negative integers * Non-integer elements (including floats, strings, etc.) # Examples ```python >>> find_median([10, 20, 30, 40, 50]) 30.0 >>> find_median([5, 15, 25, 35]) 20.0 >>> find_median([100, 200, 50, 150, 300]) 150.0 >>> find_median([5]) 5.0 >>> find_median([-10, 20, 30]) Traceback (most recent call last): ... ValueError: All transmission times must be non-negative integers >>> find_median([10, \\"20\\", 30]) Traceback (most recent call last): ... ValueError: All transmission times must be non-negative integers ``` # Hints * The median of a list with an odd number of elements is the middle element after sorting. * The median of a list with an even number of elements is the average of the two middle elements after sorting. * Consider input validation to ensure robustness.","solution":"def find_median(times: list[int]) -> float: Computes the median value of a list of non-negative integer transmission times. Parameters: times (list of int): A list containing non-negative integers representing transmission times in milliseconds. Returns: float: The median transmission time. Raises: ValueError: If the list contains negative integers or non-integer elements. if any(not isinstance(time, int) or time < 0 for time in times): raise ValueError(\\"All transmission times must be non-negative integers\\") sorted_times = sorted(times) n = len(sorted_times) if n % 2 == 1: # Odd length, the median is the middle element return float(sorted_times[n // 2]) else: # Even length, the median is the average of the two middle elements mid1 = sorted_times[n // 2 - 1] mid2 = sorted_times[n // 2] return (mid1 + mid2) / 2.0"},{"question":"# Context You are developing a recommendation system for an e-commerce platform. One of the key components involves suggesting related items based on user purchase history. To accomplish this task, you need to frequently compute the intersection of multiple sets of items representing different users\' purchase histories. # Task Implement a function in Python that takes two lists of integers, each representing the purchase history of a user, and returns a list containing the common items purchased by both users. The result should be sorted in ascending order. # Requirements - Function Name: `common_items` - **Input**: Two lists of integers, `list1` and `list2`. Each list contains integers representing item IDs. - **Output**: A list of integers representing the common items in sorted order. - **Constraints**: - The maximum length of each list will be 10^5. - Each integer in the list will be a signed 32-bit integer. - The lists can be of different lengths. # Example ```python # Example usage list1 = [12, 24, 35, 45, 56, 78] list2 = [35, 56, 78, 89, 90] result = common_items(list1, list2) print(result) # Output should be: [35, 56, 78] list1 = [5, 10, 15, 20, 25] list2 = [3, 6, 9, 12, 15, 18, 21, 24] result = common_items(list1, list2) print(result) # Output should be: [15] ``` # Notes: - Ensure your function efficiently handles the input size constraints. - Consider edge cases such as empty lists, lists with no common elements, and lists with all identical elements. - The result should have no duplicates and should be sorted using the built-in sorting capabilities. **Implement the Function Below:** ```python def common_items(list1, list2): # your code here ```","solution":"def common_items(list1, list2): Takes two lists of integers and returns a sorted list containing the common items in both lists. set1 = set(list1) set2 = set(list2) common = set1.intersection(set2) result = sorted(common) return result"},{"question":"Flatten Nested List Iterator You are given a nested list of integers, where some of the elements are integers and some are lists (which may contain integers or other lists). Your task is to flatten the nested list structure and iterate over the integers in a sequential manner. Write a Python class `NestedIterator` to accomplish this. # Input * **nestedList**: A nested list of integers. # Output * An iterator that provides the integers in the nested list in a sequential manner. # Methods to Implement * **__init__**(self, nestedList: list) -> None: Initializes the iterator with the nested list. * **next(self) -> int**: Returns the next integer in the sequence. * **hasNext(self) -> bool**: Returns `True` if there are further integers left in the sequence, `False` otherwise. # Constraints * The input nested list can be of any reasonable length and depth. # Examples ```python class NestedIterator: def __init__(self, nestedList: list): # Your initialization code here def next(self) -> int: # Your code to return the next integer def hasNext(self) -> bool: # Your code to check if more integers are left # Example Usage nestedList = [[1,1],2,[1,[1,2]],3] i = NestedIterator(nestedList) result = [] while i.hasNext(): result.append(i.next()) print(result) # Output: [1, 1, 2, 1, 1, 2, 3] nestedList = [1,[4,[6]]] i = NestedIterator(nestedList) result = [] while i.hasNext(): result.append(i.next()) print(result) # Output: [1, 4, 6] nestedList = [] i = NestedIterator(nestedList) result = [] while i.hasNext(): result.append(i.next()) print(result) # Output: [] ``` # Guidelines * Use an efficient algorithm to ensure the iterator operates within reasonable time limits. * Handle deep nesting structures and edge cases, such as empty lists or lists with varying levels of nested empty lists. * Ensure to validate your implementation with a variety of nested list structures.","solution":"class NestedIterator: def __init__(self, nestedList: list): self.list = nestedList self.index = 0 self.flat_list = [] self.flatten(self.list) def flatten(self, nestedList): for element in nestedList: if isinstance(element, int): self.flat_list.append(element) else: self.flatten(element) def next(self) -> int: result = self.flat_list[self.index] self.index += 1 return result def hasNext(self) -> bool: return self.index < len(self.flat_list)"},{"question":"# String Compression You are given a function that compresses a given string by utilizing a basic run-length encoding algorithm. The function should take a string as input and return a new compressed string. Consecutive duplicate characters in the input string should be replaced with the character followed by the count of repeated characters. If the compressed string is not shorter than the original string, the function should return the original string. # Function Signature ```python def compress_string(input_string: str) -> str: pass ``` # Expected Input and Output * **Input**: A string of any length, consisting of uppercase letters (A-Z) and lowercase letters (a-z). * **Output**: A compressed string that is shorter than the original, or the original string itself if compression does not reduce its length. # Constraints * The input string can contain any printable ASCII characters. * The input string length will be between 1 and 100 characters inclusive. # Performance Requirements * Time Complexity: O(n) where `n` is the length of the input string. * Space Complexity: O(n). # Example ```python # Example 1 input_string = \\"aabcccccaaa\\" compressed_string = compress_string(input_string) print(compressed_string) # Output: \\"a2b1c5a3\\" # Example 2 input_string = \\"abc\\" compressed_string = compress_string(input_string) print(compressed_string) # Output: \\"abc\\" # Example 3 input_string = \\"aabbccdd\\" compressed_string = compress_string(input_string) print(compressed_string) # Output: \\"aabbccdd\\" ``` # Notes * You should handle edge cases like an empty string or a string with no repeating characters. * Implementing the function in an efficient manner while ensuring clarity and readability is important. * Consider using a list for building the compressed string as appending to a list is more efficient than concatenating strings. # Implementation Define the `compress_string` function, ensuring that it integrates smoothly with the existing codebase and handles both typical and edge cases effectively.","solution":"def compress_string(input_string: str) -> str: Compresses input_string using run-length encoding. If the compressed string is not shorter than the original string, returns the original string. if not input_string: # Edge case for empty string return input_string compressed = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i - 1]: count += 1 else: compressed.append(input_string[i - 1] + str(count)) count = 1 # Add the last group compressed.append(input_string[-1] + str(count)) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(input_string) else input_string"},{"question":"# Factorial Prime Factors **Context**: The prime factorization of factorials is a crucial concept in number theory and can be used to solve various problems in mathematics and computer science, such as algorithm optimization, cryptographic applications, and numerical analyses. # Problem Statement Write a function `factorial_prime_factors(n: int) -> dict[int, int]` that calculates the prime factorization of the factorial of a given number `n`. The function should return a dictionary where the keys are the prime numbers and the values are their respective powers in the factorization of `n!`. # Input and Output Format **Input**: 1. `n` (int): The number for which the factorial\'s prime factorization is to be calculated. **Output**: - Returns a `dict[int, int]` representing the prime factors of `n!` and their respective counts. # Constraints: - `1 <= n <= 100` # Example Input: ```python n = 10 ``` Output: ```python {2: 8, 3: 4, 5: 2, 7: 1} ``` # Explanation For `n = 10`, `10! = 3628800`. The prime factorization of `3628800` is `2^8 * 3^4 * 5^2 * 7^1`. # Edge Cases to Consider - Small values of `n`, such as `1` or `2` - Large values of `n` close to the upper constraint. - Efficient decomposition and factorization approach is required due to large values of factorials for larger `n`. # Additional Instructions Ensure the function is efficient, particularly for large values of `n`, and handles edge cases and improper inputs gracefully. Consider using optimization techniques for generating primes and calculating their powers.","solution":"from collections import defaultdict import math def sieve_of_eratosthenes(limit): Generate a list of primes up to the limit using the Sieve of Eratosthenes algorithm. is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False # 0 and 1 are not primes for start in range(2, int(math.sqrt(limit)) + 1): if is_prime[start]: for multiples in range(start*start, limit + 1, start): is_prime[multiples] = False primes = [num for num, prime in enumerate(is_prime) if prime] return primes def prime_factors_in_factorial(n, primes): Calculate the prime factors and their powers in n!. prime_factors_count = defaultdict(int) for prime in primes: k = 1 while prime ** k <= n: prime_factors_count[prime] += n // (prime ** k) k += 1 return dict(prime_factors_count) def factorial_prime_factors(n): Calculates the prime factorization of the factorial of a given number n. Returns a dictionary where the keys are prime numbers and values are their respective powers in the factorization of n!. if n < 0: raise ValueError(\\"Input n should be a non-negative integer\\") if n == 0 or n == 1: return {} primes = sieve_of_eratosthenes(n) return prime_factors_in_factorial(n, primes)"},{"question":"# Array Product Except Self Given an array `nums` of `n` integers where `n` is greater than 1, implement the function `product_except_self(nums: List[int]) -> List[int]` that returns an array `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`. The solution should not use division and should run in O(n) time complexity. Input: * A list of integers `nums` (2 ≤ len(nums) ≤ 10^5), where each integer is in the range [-30, 30] and the list contains at least two numbers. Output: * A list of integers representing the product of all elements except the corresponding element at each index. Constraints: * Your algorithm should have a time complexity of O(n). * You should not use the division operation. Example: ```python assert product_except_self([1,2,3,4]) == [24,12,8,6] assert product_except_self([5,6,7,8]) == [336,280,240,210] assert product_except_self([-1,1,0,-3,3]) == [0,0,9,0,0] ``` # Implementation: * Create two auxiliary arrays, `left_products` and `right_products`, and initialize to 1. * `left_products[i]` contains the product of all elements to the left of `nums[i]`. * `right_products[i]` contains the product of all elements to the right of `nums[i]`. * Iterate through the array to populate `left_products` and `right_products`. * Construct the result by multiplying the corresponding elements from `left_products` and `right_products` for each index.","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: n = len(nums) output = [1] * n # Calculate left product for each element left_product = 1 for i in range(n): output[i] = left_product left_product *= nums[i] # Calculate right product for each element right_product = 1 for i in range(n-1, -1, -1): output[i] *= right_product right_product *= nums[i] return output"},{"question":"# Fraction to Recurring Decimal Conversion Problem Statement: Your task is to write a function that converts a fraction to its decimal representation. If the fractional part repeats, enclose the repeating part in parentheses. Input: * Two integers, **numerator** and **denominator** such that: -1000 ≤ **numerator** ≤ 1000 -1000 ≤ **denominator** ≤ 1000 Denominator will never be zero. Output: * A string representing the decimal form of the fraction. Constraints: * Handle both positive and negative fractions. * If there is no repeating part, output the decimal normally. * If the numerator is zero, the result should simply be \\"0\\". * Avoid leading zeros unless the result is a fractional number between -1 and 1. Example: ```python Input: numerator = 1, denominator = 2 Output: \\"0.5\\" ``` ```python Input: numerator = 2, denominator = 3 Output: \\"0.(6)\\" ``` ```python Input: numerator = -50, denominator = 8 Output: \\"-6.25\\" ``` Hints: 1. Use a hash table to record the position of each remainder when performing the division. 2. If a remainder repeats, the sequence of digits between the first occurrence and the repeating remainder forms the repeating part. 3. Consider edge cases such as negative numbers and convert the sign appropriately.","solution":"def fraction_to_decimal(numerator, denominator): if numerator == 0: return \\"0\\" result = [] # Determine the sign of the result if (numerator < 0) ^ (denominator < 0): result.append(\\"-\\") numerator = abs(numerator) denominator = abs(denominator) # Process the integral part integral_part = numerator // denominator result.append(str(integral_part)) remainder = numerator % denominator if remainder == 0: return \\"\\".join(result) result.append(\\".\\") # Process the fractional part remainders_map = {} while remainder != 0: if remainder in remainders_map: start = remainders_map[remainder] result.insert(start, \\"(\\") result.append(\\")\\") break remainders_map[remainder] = len(result) remainder *= 10 fractional_part_digit = remainder // denominator result.append(str(fractional_part_digit)) remainder %= denominator return \\"\\".join(result)"},{"question":"# Question You are given an integer `n` representing the number of steps in a staircase. You are initially on the 0th step and you can move to either the next step or skip one step. Write a function to compute the total number of distinct ways you can reach the nth step. # Function Signature ```python def count_ways(n: int) -> int: ``` # Input - `n`: an integer representing the number of steps (0 ≤ n ≤ 45). # Output - An integer representing the number of distinct ways to reach the nth step. # Constraints - 0 ≤ n ≤ 45 # Examples ```python >>> count_ways(2) 2 >>> count_ways(3) 3 >>> count_ways(4) 5 >>> count_ways(5) 8 >>> count_ways(0) 1 >>> count_ways(1) 1 ``` # Explanation - In the first example, you can reach the 2nd step in two ways: (0->1->2) or (0->2). - In the second example, you can reach the 3rd step in three ways: (0->1->2->3), (0->1->3), or (0->2->3). - The problem can be thought of as finding the (n+1)th Fibonacci number, where the first and second Fibonacci numbers are initialized to 1. Implement your function in Python: ```python def count_ways(n: int) -> int: # Your code here # ```","solution":"def count_ways(n: int) -> int: Computes the number of distinct ways to reach the nth step. This is essentially finding the (n+1)th Fibonacci number. if n == 0: return 1 elif n == 1: return 1 a, b = 1, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Coding Assessment Question Objective To assess the ability to implement efficient search algorithms and handle large data sets. Question You are given a sorted list of unique integers and a target integer. Your task is to write a function to determine the index of the target integer in the list. If the target is not present in the list, return the index where it would be if it were inserted in order. Function Signature ```python def search_insert_position(nums: list[int], target: int) -> int: Returns the index of the target or the index where it would be if inserted in order. :param nums: A sorted list of unique integers. :param target: An integer to search for in the list. :return: Index of the target or the insertion point. ``` Inputs 1. `nums`: A sorted list of unique integers. (1 ≤ len(nums) ≤ 10^5, -10^4 ≤ nums[i] ≤ 10^4) 2. `target`: An integer to search for in the list. (-10^4 ≤ target ≤ 10^4) Outputs - An integer representing the index of the target or the index where it would be if inserted in order. Constraints - Ensure the function runs in logarithmic time, O(log n). - Do not use built-in functions for searching or insertion. Example ```python >>> nums = [1, 3, 5, 6] >>> target = 5 >>> search_insert_position(nums, target) 2 >>> nums = [1, 3, 5, 6] >>> target = 2 >>> search_insert_position(nums, target) 1 >>> nums = [1, 3, 5, 6] >>> target = 7 >>> search_insert_position(nums, target) 4 >>> nums = [1, 3, 5, 6] >>> target = 0 >>> search_insert_position(nums, target) 0 >>> nums = [1] >>> target = 1 >>> search_insert_position(nums, target) 0 ``` Notes * Consider edge cases where the list is either very small or very large. * Handle the cases where the target is smaller or larger than all elements in the list. * Justify the reason to prefer binary search technique over other methods. * Ensure the function is efficient and concise. Example Explanation In the first example, the target `5` is found at index `2`. In the second example, the target `2` is not in the list, but it would be inserted between `1` and `3`, making the insertion index `1`. The same logic applies to the other examples, ensuring the insertion point is correctly identified.","solution":"def search_insert_position(nums: list[int], target: int) -> int: Returns the index of the target or the index where it would be if inserted in order. :param nums: A sorted list of unique integers. :param target: An integer to search for in the list. :return: Index of the target or the insertion point. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"# Context Database structures often require efficient methods to retrieve specific data patterns. One such commonly employed technique is the KMP (Knuth-Morris-Pratt) pattern matching algorithm used for string searches within databases or large text files. # Task Implement a Python class `KMPMatcher` with a method named `kmp_search` to perform substring search using the KMP algorithm. Your task is to create a method that finds all occurrences of a pattern within a given text. # Input 1. A string `text` representing the text where the search is to be performed. 2. A string `pattern` representing the substring pattern that needs to be searched. # Output 1. A list of starting indices of occurrences of the `pattern` in `text`. # Constraints 1. The length of `text` (N) is at most (10^6). 2. The length of `pattern` (M) is at most (10^4). # Performance Requirements 1. Ensure your solution has a time complexity of O(N + M). # Function Signature ```python class KMPMatcher: def kmp_search(self, text: str, pattern: str) -> [int]: # Your implementation here pass ``` # Example ```python matcher = KMPMatcher() text = \\"ABABDABACDABABCABAB\\" pattern = \\"ABABCABAB\\" indices = matcher.kmp_search(text, pattern) print(indices) # Expected output: # [10] ``` Ensure your implementation adheres to the provided guidelines and performance constraints.","solution":"class KMPMatcher: def kmp_search(self, text: str, pattern: str) -> [int]: if not pattern: return [] # Compute the LPS (Longest Prefix Suffix) array lps = self.compute_lps(pattern) result = [] i = 0 # index for text j = 0 # index for pattern while i < len(text): if text[i] == pattern[j]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and text[i] != pattern[j]: if j != 0: j = lps[j - 1] else: i += 1 return result def compute_lps(self, pattern: str) -> [int]: lps = [0] * len(pattern) length = 0 # length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps"},{"question":"# Problem: Sorted Merged List Without Duplicates Given two lists of integers sorted in non-decreasing order, your task is to write a function that merges these two lists into one sorted list without any duplicates. # Task Write a function `merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]` which takes two sorted lists of integers and returns a new sorted list containing unique elements from both lists. # Input * `list1` (List[int]): A sorted list of integers with possible duplicates. * `list2` (List[int]): A sorted list of integers with possible duplicates. # Output * (List[int]): A sorted list of integers containing unique elements. # Constraints * Both lists will contain up to 1000 integers. * Integer values will be between -10^6 and 10^6. * The combined length of both lists will not exceed 2000 integers. # Example ```python def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: # Implement this function pass # Example Usage print(merge_sorted_lists([1, 2, 3], [2, 3, 4])) # Output: [1, 2, 3, 4] print(merge_sorted_lists([-5, -3, 0], [-10, -3, 2, 3])) # Output: [-10, -5, -3, 0, 2, 3] print(merge_sorted_lists([7, 8, 9], [1, 5, 10])) # Output: [1, 5, 7, 8, 9, 10] print(merge_sorted_lists([], [1, 2, 3])) # Output: [1, 2, 3] print(merge_sorted_lists([1, 1, 1], [1, 1, 1])) # Output: [1] ``` # Additional Information 1. Utilize efficient techniques to merge the lists without duplicates, given that both lists are already sorted. 2. Aim for a solution with a time complexity of O(n + m), where n and m are the lengths of the two input lists. 3. Consider edge cases such as empty lists or lists with all identical elements.","solution":"from typing import List def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two sorted lists into one sorted list without duplicates. i, j = 0, 0 merged_list = [] while i < len(list1) and j < len(list2): if list1[i] < list2[j]: if not merged_list or merged_list[-1] != list1[i]: merged_list.append(list1[i]) i += 1 elif list1[i] > list2[j]: if not merged_list or merged_list[-1] != list2[j]: merged_list.append(list2[j]) j += 1 else: # list1[i] == list2[j] if not merged_list or merged_list[-1] != list1[i]: merged_list.append(list1[i]) i += 1 j += 1 while i < len(list1): if not merged_list or merged_list[-1] != list1[i]: merged_list.append(list1[i]) i += 1 while j < len(list2): if not merged_list or merged_list[-1] != list2[j]: merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Question: You are tasked with implementing a function to parse a simplified arithmetic expression and evaluate its result. The expression will contain only non-negative integers, addition (`+`), subtraction (`-`), and multiplication (`*`) operators. Operators will have standard precedence rules (i.e., multiplication before addition and subtraction). **Function Signature**: ```python def evaluate_expression(expression: str) -> int: pass ``` **Input**: - `expression`: A string representing the arithmetic expression, containing only the digits `0-9`, and the operators `+`, `-`, `*`. The expression will **NOT** contain any whitespace or parentheses. **Output**: - An integer representing the result of evaluating the expression. **Constraints**: - The length of the input string will not exceed 100 characters. - The input string will always be a valid arithmetic expression as per the described restrictions. **Example**: ```python >>> evaluate_expression(\\"3+5*2-6\\") 7 >>> evaluate_expression(\\"10+20*30\\") 610 >>> evaluate_expression(\\"100-50*3+6\\") -44 ``` *Your task is to implement the `evaluate_expression` function to correctly parse and evaluate the simplified arithmetic expressions according to standard operator precedence.*","solution":"def evaluate_expression(expression: str) -> int: def operate(a, b, op): if op == \'+\': return a + b elif op == \'-\': return a - b elif op == \'*\': return a * b def perform_all_operations(numbers, operators): while operators: if \'*\' in operators: idx = operators.index(\'*\') numbers[idx] = operate(numbers[idx], numbers[idx + 1], operators[idx]) del numbers[idx + 1] del operators[idx] else: idx = 0 numbers[idx] = operate(numbers[idx], numbers[idx + 1], operators[idx]) del numbers[idx + 1] del operators[idx] numbers = [] operators = [] current_num = [] for char in expression: if char in \\"+-*\\": numbers.append(int(\'\'.join(current_num))) operators.append(char) current_num = [] else: current_num.append(char) if current_num: numbers.append(int(\'\'.join(current_num))) perform_all_operations(numbers, operators) return numbers[0]"},{"question":"# Coding Assessment Question Context: Now that we have explored finding the maximum value in nested lists, let us delve into another foundational problem involving manipulation of nested structures: summing all numerical values within these nested lists. Task: Write a function `sum_nested(nums: list[int | float | list]) -> int | float` that computes the sum of all numerical values in a potentially nested list. Your function should recursively navigate through the levels of nesting to sum all numbers contained within. Input: * A list, `nums`, consisting of integers, floats, or other lists that can be nested arbitrarily. Output: * A single integer or float representing the sum of all the numerical values within the list. Constraints: * The input list may be deeply nested. * The elements of the list are exclusively integers, floats, or lists of such types. * At least one numerical value is guaranteed to be present in the list. Performance Requirements: * Aim for a solution with an O(n) time complexity where n is the total number of numerical elements in the nested structure. * Minimize space complexity keeping in mind the depth of nesting. Example: ```python def sum_nested(nums: list[int | float | list]) -> int | float: # Your implementation here # Test cases print(sum_nested([1, [2, [3, [4]]]])) # Output: 10 print(sum_nested([[1.2, 3.4], [5.6, 7.8]])) # Output: 18.0 print(sum_nested([[-1, -5, [-3, -7]], -2])) # Output: -18 ``` Note: * Consider edge cases such as lists containing only nested empty lists, though at least one number is guaranteed to be present. * Ensure the algorithm properly navigates and processes the nested structure without excessive use of additional space.","solution":"def sum_nested(nums): Recursively computes the sum of all numerical values in a potentially nested list. Parameters: nums (list[int | float | list]): A list of integers, floats, or nested lists of such types. Returns: int | float: The sum of all numerical values within the list. total = 0 for num in nums: if isinstance(num, (int, float)): total += num elif isinstance(num, list): total += sum_nested(num) return total"},{"question":"# Binary Search Tree: Find Kth Largest Element Background: The Binary Search Tree (BST) is a fundamental data structure where each node follows the left child < root < right child property. This question requires navigating and analyzing the tree to extract specific information efficiently. Task: You need to extend the `BinarySearchTree` class with a functionality to find the k-th largest element. This is generally achieved through an in-order traversal but focusing on descending order. Requirements: - Write a method `find_kth_largest(self, k)` that returns the k-th largest element in the tree. Function Signature: ```python def find_kth_largest(self, k: int) -> int: # Your code here ``` Input: - The `find_kth_largest` method will be called on a tree node as part of its class definition. - The input parameter `k` is an integer indicating which largest element to find (1-based index). Output: - The method `find_kth_largest` returns an integer, which is the value of the k-th largest element in the tree. Constraints / Assumptions: - Assume the tree has at least `k` nodes. - The tree can hold integer values, and no duplicate values exist in the tree. # Function Examples: ```python # Example 1 tree = BinarySearchTree() tree = tree.insert(10).insert(5).insert(20).insert(15).insert(25) print(tree.find_kth_largest(3)) # Returns 15 # Example 2 tree = BinarySearchTree() tree = tree.insert(30).insert(20).insert(40) print(tree.find_kth_largest(1)) # Returns 40 # Note: You may add utility functions and properties as required to complete this method. ``` By providing the implementation for finding the k-th largest element, you will handle a common real-world task efficiently leveraging the properties of the BST.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) return self def _insert(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) def find_kth_largest(self, k): # An in-order traversal in reverse order provides descending sorted order self.count = 0 self.kth_largest = None self._find_kth_largest(self.root, k) return self.kth_largest def _find_kth_largest(self, node, k): # Reverse in-order traversal (right, root, left) if node is not None and self.count < k: self._find_kth_largest(node.right, k) self.count += 1 if self.count == k: self.kth_largest = node.val return self._find_kth_largest(node.left, k)"},{"question":"# Problem Statement **Matrix Diagonal Sum** You are given a function template `calculate_diagonal_sum(matrix: List[List[int]]) -> Tuple[int, int]`. This function calculates the sum of the main diagonal and the secondary diagonal of a given square matrix. Given an ( n times n ) square matrix, the main diagonal is the set of elements that run from the top-left corner to the bottom-right corner of the matrix. The secondary diagonal is the set of elements that run from the top-right corner to the bottom-left corner of the matrix. You need to: - Ensure the matrix is square (i.e., has the same number of rows and columns). - Calculate the sum of the elements along the main diagonal. - Calculate the sum of the elements along the secondary diagonal. - Return a tuple containing the sums of the main diagonal and the secondary diagonal. **Function Signature:** ```python from typing import List, Tuple def calculate_diagonal_sum(matrix: List[List[int]]) -> Tuple[int, int]: pass ``` # Expected Input and Output Formats * **Input**: The function accepts a list of lists of integers: - `matrix`: An ( n times n ) square matrix of integers. * **Output**: The function returns a tuple of the form: - `(main_diagonal_sum (int), secondary_diagonal_sum (int))` * **Constraints**: - The matrix must be square (i.e., the number of rows is equal to the number of columns). - The matrix should have at least one element. * If the matrix is not square, raise a `ValueError` with the message `\\"Matrix must be square\\"`. # Examples 1. **Example 1**: - Input: `matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]` - Output: `(15, 15)` 2. **Example 2**: - Input: `matrix = [ [1, 2], [3, 4] ]` - Output: `(5, 5)` 3. **Example 3**: - Input: `matrix = [ [5] ]` - Output: `(5, 5)` Implement the function `calculate_diagonal_sum(matrix: List[List[int]]) -> Tuple[int, int]` to fit the description above and pass all the test cases.","solution":"from typing import List, Tuple def calculate_diagonal_sum(matrix: List[List[int]]) -> Tuple[int, int]: # Check if the matrix is square if not matrix or any(len(row) != len(matrix) for row in matrix): raise ValueError(\\"Matrix must be square\\") n = len(matrix) main_diagonal_sum = 0 secondary_diagonal_sum = 0 for i in range(n): main_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][n - 1 - i] return main_diagonal_sum, secondary_diagonal_sum"},{"question":"# Problem Statement: You\'ve been assigned the task of developing a utility to help analyze word frequencies within a set of texts. The core functionality involves generating a frequency distribution for each word in the given text. # Description: The word frequency distribution is a count of all unique words appearing in a text, ignoring case, punctuation, and numbers. The word frequency should be calculated in a case-insensitive manner (i.e., \'The\' and \'the\' should be considered the same word). # Function Signature: ```python def word_frequency_distribution(text: str) -> Dict[str, int]: ``` # Constraints: 1. The input `text` is a string containing one or more sentences. 2. Ignore any punctuation and numbers. 3. Words are to be counted in a case-insensitive manner. # Inputs: - `text` (str): A string of text containing multiple words, potentially with punctuation. # Outputs: - Returns a dictionary where keys are unique words (in lowercase) and values are the counts of each word. # Example: ```python >>> word_frequency_distribution(\\"The quick brown fox jumps over the lazy dog. The dog barks.\\") {\'the\': 3, \'quick\': 1, \'brown\': 1, \'fox\': 1, \'jumps\': 1, \'over\': 1, \'lazy\': 1, \'dog\': 2, \'barks\': 1} >>> word_frequency_distribution(\\"Python is great. PYTHON is fun!\\") {\'python\': 2, \'is\': 2, \'great\': 1, \'fun\': 1} ``` Doctests and edge case checks will ensure your implementation is correct. Make sure your function passes the following doctests provided in the stub. Good luck and happy coding!","solution":"import re from typing import Dict def word_frequency_distribution(text: str) -> Dict[str, int]: Returns a frequency distribution for each word in the given text. Words are case-insensitive, and punctuations/numbers are ignored. # Convert text to lower case text = text.lower() # Use regex to find all the words in the text words = re.findall(r\'b[a-z]+b\', text) # Generate frequency distribution freq_distribution = {} for word in words: if word in freq_distribution: freq_distribution[word] += 1 else: freq_distribution[word] = 1 return freq_distribution"},{"question":"# Problem Statement You are given a dictionary where the keys are student names and the values are their respective grades. Your task is to write a function `average_grade` that calculates the average grade for each student and then returns a list of student names whose average grade is above a given threshold. # Input and Output Formats Input: * `grades_dict` (dict): A dictionary where keys are strings (student names) and values are lists of integers (the grades). * `threshold` (int): An integer representing the grade threshold. Output: * A list of strings containing the names of the students whose average grade is above the specified threshold. The list should be sorted alphabetically. # Constraints: * Each key in `grades_dict` is a string consisting of alphabetic characters only. * The values in `grades_dict` are lists containing integers ranging from 0 to 100. * The length of the list for any student will be at least 1. * The number of students (keys in `grades_dict`) does not exceed (10^3). # Performance Requirements: * Your implementation should be optimized for performance given the constraints. # Examples: ```python >>> average_grade({\'Alice\': [90, 95, 85], \'Bob\': [70, 80, 65], \'Charlie\': [80, 85, 90]}, 80) [\'Alice\', \'Charlie\'] >>> average_grade({\'Alice\': [90, 95, 85], \'Bob\': [70, 80, 65], \'Charlie\': [80, 85, 90]}, 85) [\'Alice\'] ``` # Additional Test Case: ```python >>> average_grade({\'Alice\': [100], \'Bob\': [65, 70], \'Charlie\': [90, 91]}, 85) [\'Alice\', \'Charlie\'] ``` # Edge Cases: 1. When no student\'s average grade is above the threshold: ```python >>> average_grade({\'Alice\': [70, 75], \'Bob\': [60, 50], \'Charlie\': [65, 70]}, 80) [] ``` 2. When the threshold is very low: ```python >>> average_grade({\'Alice\': [10, 20], \'Bob\': [15, 25], \'Charlie\': [5, 30]}, 5) [\'Alice\', \'Bob\', \'Charlie\'] ``` # Implementation Requirements: * Ensure that the input dictionary is non-empty, and the threshold is a valid integer, otherwise raise an `AssertionError`. * You can assume that all names and grade lists are correctly formatted as described.","solution":"def average_grade(grades_dict, threshold): Returns a list of student names whose average grade is above the given threshold. :param grades_dict: dict, a dictionary with student names as keys and a list of grades as values :param threshold: int, the grade threshold :return: list of student names sorted alphabetically assert isinstance(grades_dict, dict), \\"grades_dict must be a dictionary\\" assert isinstance(threshold, int), \\"threshold must be an integer\\" assert len(grades_dict) > 0, \\"grades_dict must be non-empty\\" students_above_threshold = [] for student, grades in grades_dict.items(): average = sum(grades) / len(grades) if average > threshold: students_above_threshold.append(student) return sorted(students_above_threshold)"},{"question":"# Problem Statement Implement the function `minimum_operations_to_match` that computes the minimum number of operations required to transform one string into another. The allowed operations are: 1. Insert a character. 2. Delete a character. 3. Replace a character. This problem is a variant of the classic \\"edit distance\\" or \\"Levenshtein distance\\" problem. # Function Specifications minimum_operations_to_match(word1: str, word2: str) -> int * **Input**: - A string `word1` representing the source string. - A string `word2` representing the target string. * **Output**: An integer representing the minimum number of operations required to transform `word1` into `word2`. # Examples ```python >>> minimum_operations_to_match(\\"kitten\\", \\"sitting\\") 3 >>> minimum_operations_to_match(\\"flaw\\", \\"lawn\\") 2 ``` # Constraints * Both input strings will have a length between 1 and 1000 characters. * The strings will consist of lowercase English letters only. * Your function should aim for an efficient solution with a time complexity of O(m * n), where m is the length of `word1` and n is the length of `word2`. # Requirements 1. Implement a dynamic programming solution to solve the problem. 2. Ensure code readability and include comments to describe the main steps of your algorithm. 3. Handle edge cases where the strings are empty or already identical.","solution":"def minimum_operations_to_match(word1, word2): Computes the minimum number of operations required to transform word1 into word2 using insert, delete, or replace operations. m = len(word1) n = len(word2) # Create a DP table to memoize the results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the base cases for i in range(m + 1): dp[i][0] = i # Deleting all characters from word1 for j in range(n + 1): dp[0][j] = j # Inserting all characters of word2 # Fill the DP table using the provided recurrence relation for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no operation needed else: dp[i][j] = min( dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1 # Replacement ) # Return the final result return dp[m][n]"},{"question":"# Question: Enhanced Fibonacci Sequence Calculation **Context:** Your task is to extend a simple function that computes Fibonacci numbers. The basic implementation of Fibonacci number calculation has been provided, and now you must augment this with additional features focusing on performance and advanced mathematical properties. **Objective:** Implement the following functions, ensuring to handle large inputs efficiently using memoization or iterative techniques: 1. **Fibonacci Without Recursion**: Return the n-th Fibonacci number using an iterative approach to avoid recursion limits. 2. **Sum of Even Fibonacci Numbers**: Calculate the sum of all even Fibonacci numbers up to the n-th Fibonacci number. 3. **Position of Fibonacci Number**: Given a Fibonacci number, return its position in the Fibonacci sequence. **Function Signatures:** ```python def fibonacci_iterative(n: int) -> int: pass def sum_of_even_fibonacci(n: int) -> int: pass def fibonacci_position(f: int) -> int: pass ``` **Expected Input and Output:** ```python assert fibonacci_iterative(10) == 55 assert sum_of_even_fibonacci(10) == 44 # (2 + 8 + 34) assert fibonacci_position(55) == 10 ``` **Constraints:** - The input n for all functions will be a positive integer (greater than zero) and up to 10^5 for `fibonacci_iterative` and `sum_of_even_fibonacci`. - The input f for `fibonacci_position` will be a Fibonacci number within the range of typical Fibonacci sequence numbers for values up to Fibonacci(30). **Detailed Requirements:** 1. **Fibonacci Without Recursion**: - **Input:** A positive integer, n. - **Output:** The n-th Fibonacci number as an integer. - Implement using an iterative method to handle large values of n efficiently without recursion depth issues. 2. **Sum of Even Fibonacci Numbers**: - **Input:** A positive integer, n. - **Output:** The sum of all even Fibonacci numbers up to the n-th Fibonacci number. - Iterate through the sequence up to the n-th Fibonacci number, summing only the even numbers. 3. **Position of Fibonacci Number**: - **Input:** A positive integer, f, which is a Fibonacci number. - **Output:** The integer position of f in the Fibonacci sequence. - Identify the position in a zero-based index manner. **Edge Cases to Consider**: - Minimal Input: Test the smallest input values (e.g., fibonacci_iterative(1) == 1). - Performance: Ensure the solution handles upper bounds efficiently using memoization or iterative techniques. - Special Fibonacci Properties: Verify functions correctly identify positions and sums for non-standard inputs (e.g., sum_of_even_fibonacci(1) == 0 since there\'s no even Fibonacci number before it).","solution":"def fibonacci_iterative(n): Returns the n-th Fibonacci number using an iterative approach. if n <= 0: raise ValueError(\\"n must be a positive integer\\") if n == 1: return 1 if n == 2: return 1 a, b = 1, 1 for _ in range(3, n + 1): a, b = b, a + b return b def sum_of_even_fibonacci(n): Returns the sum of all even Fibonacci numbers up to the n-th Fibonacci number. if n <= 0: raise ValueError(\\"n must be a positive integer\\") a, b = 0, 1 even_sum = 0 for _ in range(n): a, b = b, a + b if a % 2 == 0: even_sum += a return even_sum def fibonacci_position(f): Returns the position of the Fibonacci number f in the Fibonacci sequence. if f <= 0: raise ValueError(\\"f must be a positive integer\\") a, b = 1, 1 position = 2 # because we\'ve already covered f1 = 1 and f2 = 1 if f == 1: return 1 # since there are two positions (1 and 2) both equal to 1 in the sequence while b < f: a, b = b, a + b position += 1 if b == f: return position else: raise ValueError(f\\"{f} is not a Fibonacci number\\")"},{"question":"Given the following scenario of placing the minimum number of meeting rooms required, write a program that will determine the number of meeting rooms needed at any point in time. # Scenario You are managing a meeting facility with several meeting rooms. Each meeting has a defined start and end time. Your goal is to identify the minimum number of meeting rooms that are required to accommodate all given meetings without conflicts. # Function Signature ```python def min_meeting_rooms(schedule: list) -> int: pass ``` # Input * `schedule`: A list of tuples, where each tuple contains two integers representing the start and end times of a meeting. # Output * `min_meeting_rooms` should return an integer, representing the minimum number of meeting rooms required. # Constraints * Each meeting time is represented by a tuple `(start_time, end_time)` where `start_time` and `end_time` are non-negative integers. * `start_time` is always less than `end_time`. # Performance Requirements * Aim for a solution that has time complexity of `O(n log n)` and space complexity of `O(n)`. # Notes 1. Raise a `ValueError` if any start or end time is negative. 2. Raise a `ValueError` if `start_time` is not less than `end_time` within any tuple. # Example ```python schedule = [(0, 30), (5, 10), (15, 20)] # Expected Output: 2 (Meetings (0,30) and (5,10) clash, requiring 2 rooms) print(min_meeting_rooms(schedule)) # Output: 2 ``` # Edge Cases 1. If the `schedule` list is empty, the expected output is 0. 2. Handle case where meetings start and end at the same time correctly (if provided in advanced variations). Implement the `min_meeting_rooms` function, ensuring your solution passes the provided test cases.","solution":"def min_meeting_rooms(schedule: list) -> int: if not schedule: return 0 # Pre-check for input constraints for start, end in schedule: if start < 0 or end < 0 or start >= end: raise ValueError(\\"Invalid meeting times\\") # Extract start and end times and sort them start_times = sorted([start for start, end in schedule]) end_times = sorted([end for start, end in schedule]) start_pointer = end_pointer = 0 used_rooms = 0 max_rooms_needed = 0 # Iterate over all the meetings while start_pointer < len(schedule): if start_times[start_pointer] < end_times[end_pointer]: # Need a new room used_rooms += 1 start_pointer += 1 else: # Meeting ended, free up a room used_rooms -= 1 end_pointer += 1 max_rooms_needed = max(max_rooms_needed, used_rooms) return max_rooms_needed"},{"question":"# Coding Assessment Question Scenario: You are working on a system that requires the computation of the greatest common divisor (GCD) of a list of integers, which is a common task in cryptography and data compression algorithms. The GCD of a list of numbers is the largest number that divides all the elements of the list without leaving a remainder. Problem Statement: Implement a Python function `gcd_of_list(nums: List[int]) -> int` that computes the GCD of a list of integers. Requirements: 1. The function should handle both positive and negative integers. 2. If the list is empty, the function should return 0. 3. Non-integer and non-numeric inputs within the list should raise a `TypeError`. 4. The function should efficiently compute the GCD using the Euclidean algorithm. Input: - A list of integers, `nums`, where each integer in the list can be positive, negative, or zero. Output: - An integer representing the GCD of the list. Constraints: - You must use an efficient GCD method, leveraging the properties of the Euclidean algorithm. - Your solution should not exceed (O(n log (min|a_i|))), where ( n ) is the number of elements in the list and ( a_i ) is an element of the list. Function Signature: ```python from typing import List def gcd_of_list(nums: List[int]) -> int: ``` Example Cases: ```python assert gcd_of_list([24, 36, 48]) == 12 assert gcd_of_list([-8, 16, -32]) == 8 assert gcd_of_list([0, 0, 0]) == 0 assert gcd_of_list([7, 5, 15, 3]) == 1 assert gcd_of_list([]) == 0 assert gcd_of_list([20, 40, 60]) == 20 ``` Additional Information: - Utilize the provided helper functions `gcd` for implementation. - Ensure the function handles edge cases such as zeros and negative numbers appropriately. Implement the `gcd_of_list` function as per the outlined requirements.","solution":"from typing import List from math import gcd from functools import reduce def gcd_of_list(nums: List[int]) -> int: Compute the GCD of a list of integers. Args: nums (List[int]): A list of integers. Returns: int: The GCD of the list, or 0 if the list is empty. Raises: TypeError: If any element in the list is not an integer. if not nums: return 0 for num in nums: if not isinstance(num, int): raise TypeError(\\"All elements in the list must be integers.\\") return reduce(gcd, nums) # Example usage print(gcd_of_list([24, 36, 48])) # Output should be 12 print(gcd_of_list([-8, 16, -32])) # Output should be 8 print(gcd_of_list([0, 0, 0])) # Output should be 0 print(gcd_of_list([7, 5, 15, 3])) # Output should be 1 print(gcd_of_list([])) # Output should be 0 print(gcd_of_list([20, 40, 60])) # Output should be 20"},{"question":"# Implementing Custom Support Vector Machine (SVM) from Scratch You are tasked with implementing a simple Support Vector Machine (SVM) for binary classification from scratch using Python and numpy. Your implementation should include methods for fitting the model to training data and making predictions on new data. # Requirements: 1. Implement the SVM using the hinge loss and L2 regularization. 2. Use the Stochastic Gradient Descent (SGD) algorithm for optimization. 3. Your implementation should include the following methods: - `fit`: Trains the SVM model using the training dataset. - `predict`: Predicts the class labels for the provided dataset. # Input and Output Formats: 1. **Input**: - `X` (numpy.ndarray): A 2D array of shape (num_samples, num_features) representing the input features. - `y` (numpy.ndarray): A 1D array of shape (num_samples,) with binary class labels {-1, 1}. - `learning_rate` (float): The learning rate for SGD. - `epochs` (int): The number of epochs for training. 2. **Output**: - `fit` (None): Trains the model and stores the parameters internally. - `predict` (numpy.ndarray): A 1D array of shape (num_samples,) representing the predicted class labels {-1, 1} for each input sample. # Constraints: - ( text{num_samples} leq 10^4 ) - ( text{num_features} leq 100 ) - ( text{epochs} leq 1000 ) - `learning_rate` should be a small constant, e.g., 0.01 # Testing and Performance: - Implement a test case using the Iris dataset (binary classification subset). - The model should achieve a reasonable accuracy (e.g., >70%) on the test set. ```python import numpy as np from sklearn.datasets import load_iris from sklearn.metrics import accuracy_score from sklearn.model_selection import train_test_split class SVM: def __init__(self, learning_rate: float = 0.01, epochs: int = 1000): Initialize the SVM classifier. Parameters: - learning_rate (float): The learning rate for SGD. - epochs (int): The number of epochs to train. self.learning_rate = learning_rate self.epochs = epochs self.weights = None self.bias = None def fit(self, X: np.ndarray, y: np.ndarray) -> None: Fit the SVM model to the training data. Parameters: - X (np.ndarray): The training features. - y (np.ndarray): The target values. Returns: None num_samples, num_features = X.shape self.weights = np.zeros(num_features) self.bias = 0 for _ in range(self.epochs): for idx, x_i in enumerate(X): condition = y[idx] * (np.dot(x_i, self.weights) - self.bias) >= 1 if condition: self.weights -= self.learning_rate * (2 * 0.01 * self.weights) else: self.weights -= self.learning_rate * (2 * 0.01 * self.weights - np.dot(x_i, y[idx])) self.bias -= self.learning_rate * y[idx] def predict(self, X: np.ndarray) -> np.ndarray: Predict the class labels for provided data. Parameters: - X (np.ndarray): The input data. Returns: - np.ndarray: The predicted class labels. linear_output = np.dot(X, self.weights) - self.bias return np.sign(linear_output) if __name__ == \\"__main__\\": iris = load_iris() X, y = iris.data, iris.target # Filter to keep only the two classes (0 and 1) for binary classification binary_class_indices = np.where(y != 2) X = X[binary_class_indices] y = y[binary_class_indices] y = np.where(y == 0, -1, 1) # Convert labels to {-1, 1} X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) svm = SVM(learning_rate=0.01, epochs=1000) svm.fit(X_train, y_train) y_pred = svm.predict(X_test) accuracy = accuracy_score(y_test, y_pred) print(f\\"Accuracy: {accuracy:.2f}\\") ```","solution":"import numpy as np class SVM: def __init__(self, learning_rate: float = 0.01, epochs: int = 1000): Initialize the SVM classifier. Parameters: - learning_rate (float): The learning rate for SGD. - epochs (int): The number of epochs to train. self.learning_rate = learning_rate self.epochs = epochs self.weights = None self.bias = None def fit(self, X: np.ndarray, y: np.ndarray) -> None: Fit the SVM model to the training data. Parameters: - X (np.ndarray): The training features. - y (np.ndarray): The target values. Returns: None num_samples, num_features = X.shape self.weights = np.zeros(num_features) self.bias = 0 for _ in range(self.epochs): for idx, x_i in enumerate(X): condition = y[idx] * (np.dot(x_i, self.weights) - self.bias) >= 1 if condition: self.weights -= self.learning_rate * (2 * 0.01 * self.weights) else: self.weights -= self.learning_rate * (2 * 0.01 * self.weights - np.dot(x_i, y[idx])) self.bias -= self.learning_rate * y[idx] def predict(self, X: np.ndarray) -> np.ndarray: Predict the class labels for provided data. Parameters: - X (np.ndarray): The input data. Returns: - np.ndarray: The predicted class labels. linear_output = np.dot(X, self.weights) - self.bias return np.sign(linear_output)"},{"question":"Problem Statement Create a function `merge_sorted_lists` that takes two sorted lists of integers and returns a single merged list, which is also sorted. # Requirements 1. **Function Signature**: ```python def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: ``` 2. **Inputs**: * `list1` (List[int]): A sorted list of integers. * `list2` (List[int]): Another sorted list of integers. 3. **Outputs**: * Returns a single sorted list containing all the integers from `list1` and `list2`. 4. **Constraints**: * The elements in `list1` and `list2` will be sorted in non-descending order. * Both lists can be empty but not both at the same time unless the entire set of lists is empty. # Example Usage ```python >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([0, 1, 2], []) [0, 1, 2] >>> merge_sorted_lists([], [5, 7, 8]) [5, 7, 8] >>> merge_sorted_lists([2, 4, 6, 8], [1, 3, 7, 9]) [1, 2, 3, 4, 6, 7, 8, 9] ``` # Additional Notes - The function should handle the alternating order of elements seamlessly ensuring the merged result remains sorted. - Be attentive to potential edge cases, such as when elements of one list might interleave multiple times within the other list. - The solution should be optimized for time complexity, aiming for O(n + m) where n and m are the lengths of `list1` and `list2` respectively.","solution":"from typing import List def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two sorted lists into a single sorted list. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Append any remaining elements from list1 or list2 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Job Scheduler Simulation Objective Implement a class `JobScheduler` that simulates job scheduling on a single processor. The goal is to maximize the number of jobs that can be completed without overlapping based on their start and end times. Expected Input and Output Formats * **Input**: Two lists: * `start_times`: A list of integers representing the start times of jobs. * `end_times`: A list of integers representing the end times of jobs. * **Output**: An integer representing the maximum number of non-overlapping jobs that can be scheduled. Constraints and Limitations * Ensure each job\'s start time is less than its end time. * Handle cases where no jobs can be scheduled. * Both lists have the same length, representing valid pairs of job timing. Performance Requirements * The algorithm should run efficiently with respect to both time and space for large input sizes. Scenario You are managing a single-processor system that needs to execute a set of jobs. Each job has a specific start time and a finish time. Your task is to implement an optimal job scheduler to determine the maximum number of non-overlapping jobs that can be processed. # Class Requirements The class should implement the following: * **Initialization**: Ensure the input lists are valid, have the same length, and all jobs have valid timings. * **Methods**: 1. `schedule_jobs` - Schedules the maximum number of non-overlapping jobs and returns this count. Implement the `JobScheduler` class considering the above requirements. Ensure to handle edge cases and constraints validation. ```python class JobScheduler: def __init__(self, start_times: list[int], end_times: list[int]) -> None: if len(start_times) != len(end_times): raise ValueError(\\"Start times and end times lists must be of the same length.\\") for start, end in zip(start_times, end_times): if start >= end: raise ValueError(\\"Each job\'s start time must be less than its end time.\\") self.jobs = sorted(zip(start_times, end_times), key=lambda x: x[1]) def schedule_jobs(self) -> int: if not self.jobs: return 0 count = 1 last_end_time = self.jobs[0][1] for i in range(1, len(self.jobs)): if self.jobs[i][0] >= last_end_time: count += 1 last_end_time = self.jobs[i][1] return count if __name__ == \\"__main__\\": scheduler = JobScheduler([1, 3, 2, 5], [2, 4, 3, 6]) print(scheduler.schedule_jobs()) # Output: 3 ```","solution":"class JobScheduler: def __init__(self, start_times: list[int], end_times: list[int]) -> None: if len(start_times) != len(end_times): raise ValueError(\\"Start times and end times lists must be of the same length.\\") for start, end in zip(start_times, end_times): if start >= end: raise ValueError(\\"Each job\'s start time must be less than its end time.\\") self.jobs = sorted(zip(start_times, end_times), key=lambda x: x[1]) def schedule_jobs(self) -> int: if not self.jobs: return 0 count = 1 last_end_time = self.jobs[0][1] for i in range(1, len(self.jobs)): if self.jobs[i][0] >= last_end_time: count += 1 last_end_time = self.jobs[i][1] return count"},{"question":"Problem Statement You are tasked with implementing a `SpecialQueue` class which extends the given queue class. This specialized queue should support all standard queue operations (`enqueue`, `dequeue`, `front`, `rear`, `is_empty`, `size`, `__contains__`). Additionally, it should implement a `max_element` operation that returns the maximum element in the queue in constant time. # Requirements 1. Implement a new `SpecialQueue` class that extends the provided `Queue` class. 2. Ensure `max_element` operation returns the maximum element of the queue with O(1) time complexity. 3. Modify the queue methods to maintain the additional structure (if applicable) to keep track of the maximum element. 4. Use appropriate exception handling for queue underflow scenarios. # Input - Standard queue operations (`enqueue`, `dequeue`, `front`, etc.) inputs. - An additional method `max_element` which takes no inputs. # Output - Return standard queue operation results as defined (e.g., `dequeue` returns the dequeued element). - `max_element` returns the maximum element in the queue. # Constraints - The queue has a fixed or dynamic capacity as defined in the `limit`. - All operations should aim for minimal time complexity ideally maintaining O(1) where achievable, especially for `enqueue`, `dequeue`, `front`, and `max_element`. # Example ```python >>> sq = SpecialQueue(5) >>> sq.enqueue(3) >>> sq.enqueue(5) >>> sq.max_element() 5 >>> sq.enqueue(2) >>> sq.enqueue(1) >>> sq.max_element() 5 >>> sq.dequeue() 3 >>> sq.max_element() 5 >>> sq.dequeue() 5 >>> sq.max_element() 2 ``` # Note - Make sure to handle all edge cases including queue underflow. - Ensure class methods are well documented and include necessary exception handling.","solution":"class Queue: def __init__(self, limit): self.queue = [] self.limit = limit def is_empty(self): return len(self.queue) == 0 def size(self): return len(self.queue) def enqueue(self, data): if self.size() >= self.limit: raise Exception(\\"Queue Overflow\\") self.queue.append(data) def dequeue(self): if self.is_empty(): raise Exception(\\"Queue Underflow\\") return self.queue.pop(0) def front(self): if self.is_empty(): raise Exception(\\"Queue Underflow\\") return self.queue[0] def rear(self): if self.is_empty(): raise Exception(\\"Queue Underflow\\") return self.queue[-1] def __contains__(self, item): return item in self.queue class SpecialQueue(Queue): def __init__(self, limit): super().__init__(limit) self.max_values = [] def enqueue(self, data): super().enqueue(data) while self.max_values and self.max_values[-1] < data: self.max_values.pop() self.max_values.append(data) def dequeue(self): element = super().dequeue() if element == self.max_values[0]: self.max_values.pop(0) return element def max_element(self): if self.is_empty(): raise Exception(\\"Queue is empty\\") return self.max_values[0]"},{"question":"Problem Statement You are given a list of unsorted integers. Your task is to identify and return the second largest number in the list. If the list contains fewer than two unique numbers, return `None`. Write a function `find_second_largest(arr: List[int]) -> Optional[int]` that takes a single parameter: - `arr` (a list of integers): The input list of integers. The function should return the second largest number in the list, or `None` if there are fewer than two unique numbers. # Constraints 1. The input list will have between 1 and `10^5` integers. 2. Each integer in the list will be in the range `-10^9` to `10^9`. # Example ```python def find_second_largest(arr: List[int]) -> Optional[int]: # TODO: Write your implementation here ``` Input: ```python find_second_largest([4, 3, 1, 4, 2]) ``` Output: ```python 3 ``` Input: ```python find_second_largest([10, 10, 10]) ``` Output: ```python None ``` Input: ```python find_second_largest([20, 10, 30, 40, 50]) ``` Output: ```python 40 ``` # Notes - Your solution should have a time complexity of O(n), where n is the length of the input list. - Be mindful of edge cases such as lists with duplicate numbers or all elements being the same.","solution":"from typing import List, Optional def find_second_largest(arr: List[int]) -> Optional[int]: if len(arr) < 2: return None first = second = float(\'-inf\') for num in arr: if num > first: second = first first = num elif num > second and num != first: second = num return second if second != float(\'-inf\') else None"},{"question":"# Coding Assessment Question You are developing a new feature for a financial analysis tool that involves statistical calculations on stock data. Your task is to implement a utility function that computes various financial metrics based on a given stock\'s historical prices. You need to create a function `compute_financial_metrics` that takes in the following parameters: - `metric_type` (str): The type of financial metric to compute. It can be one of the following: - \\"simple_moving_average\\" - \\"exponential_moving_average\\" - \\"bollinger_bands\\" - \\"relative_strength_index\\" - \\"moving_average_convergence_divergence\\" - \\"average_true_range\\" - \\"rate_of_change\\" - \\"stochastic_oscillator\\" - \\"momentum\\" - `prices` (np.ndarray): A numpy array of stock closing prices. - `kwargs` (dict): Additional keyword arguments for specific financial metrics. The function should return the computed financial metric value(s) as a numpy array. Input and Output Formats ```python def compute_financial_metrics(metric_type: str, prices: np.ndarray, **kwargs) -> np.ndarray: pass # Example usage: prices = np.array([100, 102, 101, 105, 107, 110, 108, 111, 115, 113]) print(compute_financial_metrics(\\"simple_moving_average\\", prices, window=3)) # Expected: array([101., 102.66666667, 104.33333333, 107.33333333, 108.33333333, 110., 111.33333333, 113.]) prices = np.array([100, 102, 101, 105, 107, 110, 108, 111, 115, 113]) print(compute_financial_metrics(\\"relative_strength_index\\", prices, period=14)) # Expected: array([...]) # Actual values depend on the RSI computation ``` Constraints - Validate the input numpy array to ensure it contains appropriate historical price data. - Handle edge cases, such as insufficient data points for the specified metric computations. - Ensure accurate and efficient calculations using appropriate financial formulas. Requirements - Implement error handling for invalid metric types and mismatched input data. - Optimize the implementation using vectorized operations where possible to handle large datasets efficiently. - Provide documentation for using the function, including example use cases and explanations of additional keyword arguments. # Note Use known financial calculation formulas for each metric type to implement and validate your solution.","solution":"import numpy as np def compute_financial_metrics(metric_type: str, prices: np.ndarray, **kwargs) -> np.ndarray: if not isinstance(prices, np.ndarray): raise ValueError(\\"Input \'prices\' must be a numpy array.\\") if metric_type == \\"simple_moving_average\\": return simple_moving_average(prices, **kwargs) elif metric_type == \\"exponential_moving_average\\": return exponential_moving_average(prices, **kwargs) elif metric_type == \\"bollinger_bands\\": return bollinger_bands(prices, **kwargs) elif metric_type == \\"relative_strength_index\\": return relative_strength_index(prices, **kwargs) elif metric_type == \\"moving_average_convergence_divergence\\": return moving_average_convergence_divergence(prices, **kwargs) elif metric_type == \\"average_true_range\\": return average_true_range(prices, **kwargs) elif metric_type == \\"rate_of_change\\": return rate_of_change(prices, **kwargs) elif metric_type == \\"stochastic_oscillator\\": return stochastic_oscillator(prices, **kwargs) elif metric_type == \\"momentum\\": return momentum(prices, **kwargs) else: raise ValueError(f\\"Unknown metric type: {metric_type}\\") def simple_moving_average(prices, window=3): return np.convolve(prices, np.ones(window) / window, mode=\'valid\') def exponential_moving_average(prices, span=3): return np.array(pd.Series(prices).ewm(span=span, adjust=False).mean()) def bollinger_bands(prices, window=20, num_std=2): sma = simple_moving_average(prices, window) std = np.std([prices[i: i + window] for i in range(len(prices) - window + 1)], axis=1) upper_band = sma + num_std * std lower_band = sma - num_std * std return np.vstack((upper_band, sma, lower_band)).T def relative_strength_index(prices, period=14): delta = np.diff(prices) gain = np.where(delta > 0, delta, 0) loss = np.where(delta < 0, -delta, 0) avg_gain = np.convolve(gain, np.ones(period) / period, mode=\'valid\') avg_loss = np.convolve(loss, np.ones(period) / period, mode=\'valid\') rs = avg_gain / (avg_loss + 1e-10) return 100 - (100 / (1 + rs)) def moving_average_convergence_divergence(prices, n_slow=26, n_fast=12): ema_slow = exponential_moving_average(prices, span=n_slow) ema_fast = exponential_moving_average(prices, span=n_fast) macd = ema_fast[-len(ema_slow):] - ema_slow signal = np.array(pd.Series(macd).ewm(span=9, adjust=False).mean()) return macd, signal def average_true_range(prices, period=14): high_low = np.max(prices) - np.min(prices) true_ranges = np.max([high_low, np.abs(np.diff(prices))], axis=0) return np.convolve(true_ranges, np.ones(period) / period, mode=\'valid\') def rate_of_change(prices, period=12): return ((prices[period:] - prices[:-period]) / prices[:-period]) * 100 def stochastic_oscillator(prices, k_period=14, d_period=3): min_val = np.min(prices[-k_period:]) max_val = np.max(prices[-k_period:]) k = (prices[-1] - min_val) / (max_val - min_val) * 100 d = simple_moving_average(np.array([k]), d_period) return k, d def momentum(prices, period=10): return prices[period:] - prices[:-period]"},{"question":"# Question Prompt Implement a simplified version of the Snake game with the following features: 1. **Game Initialization**: The game starts with the snake positioned at the center of the grid and extends upwards. 2. **Movement**: Implement methods to move the snake in four directions (up, down, left, right). The game should be capable of receiving a sequence of moves and processing them one by one. 3. **Food Consumption**: Place a piece of food at a random unoccupied position on the grid. When the snake moves to the position with the food, it should grow in length. 4. **Game Over Detection**: The game ends if the snake runs into the walls or itself. Expected Input and Output - **Input**: The grid size, a list of moves, and the initial position of the food. - **Output**: The length of the snake after processing all moves, or indicate if the game has ended before all moves are processed due to a collision. Constraints and Limitations - The grid size should be at least 5x5 and at most 50x50. - The moves are limited to \'U\' (up), \'D\' (down), \'L\' (left), \'R\' (right). - Ensure efficient handling of the snake\'s body using appropriate data structures for quick updates. ```python class SnakeGame: def __init__(self, width: int, height: int): self.width = width self.height = height self.snake = deque([(width // 2, height // 2), (width // 2, height // 2 - 1), (width // 2, height // 2 - 2)]) self.food_position = None self.place_food() self.directions = {\'U\': (-1, 0), \'D\': (1, 0), \'L\': (0, -1), \'R\': (0, 1)} def place_food(self): Place food at a random position not occupied by the snake. available_positions = [(x, y) for x in range(self.width) for y in range(self.height) if (x, y) not in self.snake] self.food_position = choice(available_positions) def move(self, direction: str) -> bool: Move the snake in the given direction. Return False if game over, True otherwise. # Calculate new head position curr_head = self.snake[0] new_head = (curr_head[0] + self.directions[direction][0], curr_head[1] + self.directions[direction][1]) # Check for collisions with walls or itself if (new_head[0] < 0 or new_head[0] >= self.width or new_head[1] < 0 or new_head[1] >= self.height or new_head in self.snake): return False # Check if new head position is food if new_head == self.food_position: self.snake.appendleft(new_head) # Extend snake self.place_food() # Place new food else: self.snake.appendleft(new_head) self.snake.pop() return True def play_game(self, moves: List[str]) -> Tuple[int, bool]: Process all moves and return the length of the snake or indicate game over. for move in moves: if not self.move(move): return len(self.snake), False return len(self.snake), True # Example usage: game = SnakeGame(10, 10) moves = [\'R\', \'R\', \'D\', \'D\', \'L\', \'L\', \'U\', \'U\', \'R\'] snake_length, still_playing = game.play_game(moves) if still_playing: print(f\\"Snake Length: {snake_length}\\") else: print(\\"Game Over\\") ``` Objectives: 1. Implement the `place_food` and `move` methods to handle the game logic including food consumption and collision detection. 2. Implement the `play_game` method to process a series of moves and return the state of the game after processing the moves.","solution":"from collections import deque from random import choice from typing import List, Tuple class SnakeGame: def __init__(self, width: int, height: int): self.width = width self.height = height self.snake = deque([(width // 2, height // 2), (width // 2, height // 2 - 1), (width // 2, height // 2 - 2)]) self.food_position = None self.place_food() self.directions = {\'U\': (-1, 0), \'D\': (1, 0), \'L\': (0, -1), \'R\': (0, 1)} def place_food(self): Place food at a random position not occupied by the snake. available_positions = [(x, y) for x in range(self.width) for y in range(self.height) if (x, y) not in self.snake] self.food_position = choice(available_positions) def move(self, direction: str) -> bool: Move the snake in the given direction. Return False if game over, True otherwise. # Calculate new head position curr_head = self.snake[0] new_head = (curr_head[0] + self.directions[direction][0], curr_head[1] + self.directions[direction][1]) # Check for collisions with walls or itself if (new_head[0] < 0 or new_head[0] >= self.width or new_head[1] < 0 or new_head[1] >= self.height or new_head in self.snake): return False # Check if new head position is food if new_head == self.food_position: self.snake.appendleft(new_head) # Extend snake self.place_food() # Place new food else: self.snake.appendleft(new_head) self.snake.pop() return True def play_game(self, moves: List[str]) -> Tuple[int, bool]: Process all moves and return the length of the snake or indicate game over. for move in moves: if not self.move(move): return len(self.snake), False return len(self.snake), True # Example usage: # game = SnakeGame(10, 10) # moves = [\'R\', \'R\', \'D\', \'D\', \'L\', \'L\', \'U\', \'U\', \'R\'] # snake_length, still_playing = game.play_game(moves) # if still_playing: # print(f\\"Snake Length: {snake_length}\\") # else: # print(\\"Game Over\\")"},{"question":"# Context You are developing a utility for generating secure passwords based on various user-defined criteria. This utility takes user input to determine the length of the password and the types of characters to include (e.g., lowercase, uppercase, digits, and special characters). To ensure that the generated password meets the specified criteria, you need to write unit tests to validate the functionality of the password generator. # Task Write a unit test using the `unittest` framework to test a function `generate_password` that creates passwords based on the provided length and character types. Your test should: 1. Verify that the generated password meets the specified length. 2. Check that the password includes at least one character from each of the specified character types. 3. Ensure proper handling of edge cases, such as invalid lengths and character type configurations. # Function Signature ```python def generate_password(length: int, use_lowercase: bool, use_uppercase: bool, use_digits: bool, use_special: bool) -> str: Generate a secure password based on provided criteria. Args: length (int): Desired length of the password. use_lowercase (bool): Whether to include lowercase letters. use_uppercase (bool): Whether to include uppercase letters. use_digits (bool): Whether to include digits. use_special (bool): Whether to include special characters. Returns: str: The generated password. pass ``` # Input and Output Formats * **Input**: - `length` (integer): The length of the desired password (must be 1 or greater). - `use_lowercase` (boolean): Whether to include lowercase letters. - `use_uppercase` (boolean): Whether to include uppercase letters. - `use_digits` (boolean): Whether to include digits. - `use_special` (boolean): Whether to include special characters. * **Output**: A string representing the generated password. # Constraints * The `length` must be an integer of 1 or greater. * At least one character type parameter (`use_lowercase`, `use_uppercase`, `use_digits`, `use_special`) must be True. * The function should raise a `ValueError` if invalid constraints are provided (e.g., invalid length, no character types specified). # Example Assume the following input: ```python length = 8 use_lowercase = True use_uppercase = True use_digits = True use_special = True ``` A successful call to `generate_password` with these parameters should return an 8-character string that includes at least one lowercase letter, one uppercase letter, one digit, and one special character. # Requirements 1. Implement the `generate_password` function. 2. Write the test function using `unittest` to thoroughly test various scenarios, including typical cases and edge cases. ```python import unittest def generate_password(length: int, use_lowercase: bool, use_uppercase: bool, use_digits: bool, use_special: bool) -> str: # Implement this function pass class TestGeneratePassword(unittest.TestCase): def test_password_length(self): # Implement this test pass def test_password_character_types(self): # Implement this test pass def test_edge_cases(self): # Implement this test pass if __name__ == \'__main__\': unittest.main() ``` # Performance Requirements The unit test should complete within a reasonable time frame and cover a variety of scenarios to ensure the `generate_password` function is robust and reliable.","solution":"import random import string def generate_password(length: int, use_lowercase: bool, use_uppercase: bool, use_digits: bool, use_special: bool) -> str: Generate a secure password based on provided criteria. Args: length (int): Desired length of the password. use_lowercase (bool): Whether to include lowercase letters. use_uppercase (bool): Whether to include uppercase letters. use_digits (bool): Whether to include digits. use_special (bool): Whether to include special characters. Returns: str: The generated password. if length < 1: raise ValueError(\\"Password length must be at least 1\\") character_sets = [] if use_lowercase: character_sets.append(string.ascii_lowercase) if use_uppercase: character_sets.append(string.ascii_uppercase) if use_digits: character_sets.append(string.digits) if use_special: character_sets.append(string.punctuation) if not character_sets: raise ValueError(\\"At least one character type must be selected\\") all_characters = \'\'.join(character_sets) password = [random.choice(char_set) for char_set in character_sets] # Ensure at least one of each selected type while len(password) < length: password.append(random.choice(all_characters)) random.shuffle(password) return \'\'.join(password)"},{"question":"# Problem Statement The provided function `number_swapper(a: int, b: int) -> tuple` swaps the values of two integer variables without using any additional storage or temporary variables. Input - Two integers, `a` and `b`. Output - A tuple containing the swapped values of `a` and `b`. # Task Implement the function `number_swapper(a: int, b: int) -> tuple` to swap the values of the two integers without using a temporary variable. Follow the example structure provided below: ```python def number_swapper(a: int, b: int) -> tuple: # Your implementation here ``` Examples 1. **Input**: `number_swapper(3, 5)` - **Output**: `(5, 3)` 2. **Input**: `number_swapper(7, -2)` - **Output**: `(-2, 7)` 3. **Input**: `number_swapper(0, 100)` - **Output**: `(100, 0)` 4. **Input**: `number_swapper(-10, -20)` - **Output**: `(-20, -10)` Constraints - The integers `a` and `b` can be any valid integers in the range of a 32-bit signed integer. # Notes - Utilize arithmetic operations or bitwise operations to achieve the swap without the use of temporary storage.","solution":"def number_swapper(a: int, b: int) -> tuple: Swaps the values of a and b without using a temporary variable. # Using arithmetic operations to swap numbers without temporary variable a = a + b b = a - b a = a - b return (a, b)"},{"question":"# Question: Validate and Parse Nested Parentheses Design a function that validates and parses a string containing nested parentheses. The purpose of this function is to ensure that the string follows correct parentheses nesting and then produces a structured representation of these nested groups. # Requirements: 1. Implement the function `parse_nested_parentheses(s: str) -> list`: * **`s` (str)**: The input string containing only parentheses `(` and `)`. 2. The function must validate if the parentheses are properly nested. 3. The function should return a nested list structure representing the nesting. 4. If the parentheses are not properly nested, the function should raise a `ValueError` with the message `\\"Invalid parentheses nesting\\"`. # Example: ```python parse_nested_parentheses(\\"((()))\\") // Should return: [[[]]] parse_nested_parentheses(\\"(())()\\") // Should return: [[], []] parse_nested_parentheses(\\")(\\") // Should raise: ValueError(\\"Invalid parentheses nesting\\") ``` # Constraints: * The input string will contain only the characters `(` and `)`. * The length of the string will be between 0 and 1000. # Performance Requirements: * The function should run in linear time relative to the input size (`O(n)` complexity).","solution":"def parse_nested_parentheses(s: str) -> list: Validates and parses a string containing nested parentheses into a nested list structure. :param s: The input string containing only parentheses `(` and `)`. :return: A nested list structure representing the nested parentheses. :raises ValueError: If the parentheses are not properly nested. stack = [] current_level = [] for char in s: if char == \'(\': new_level = [] current_level.append(new_level) stack.append(current_level) current_level = new_level elif char == \')\': if not stack: raise ValueError(\\"Invalid parentheses nesting\\") current_level = stack.pop() else: raise ValueError(\\"Invalid character in input string\\") if stack: raise ValueError(\\"Invalid parentheses nesting\\") return current_level"},{"question":"# Merge Ranges of Time Slots You are given a list of time slots in a 24-hour format represented as tuples. Each tuple contains a pair of start and end times, indicating when a person is busy. You need to write a function to merge overlapping time slots and return the list of merged ranges. # Function Signature ```python def merge_time_slots(time_slots: List[Tuple[str, str]]) -> List[Tuple[str, str]]: pass ``` # Input - `time_slots`: A list of tuples, where each tuple contains two strings representing the start and end times in `HH:MM` format (24-hour clock). # Output - A list of tuples, where each tuple contains two strings representing the start and end times of the merged time slots. # Constraints - The list of time slots have a length `1 <= len(time_slots) <= 1000`. - The start and end times are valid 24-hour time representations. - Each time slot will have a valid start time that is earlier than the end time. # Example ```python time_slots = [ (\\"09:00\\", \\"10:30\\"), (\\"11:00\\", \\"13:00\\"), (\\"12:45\\", \\"14:30\\"), (\\"14:15\\", \\"15:00\\"), (\\"16:00\\", \\"17:00\\"), (\\"13:30\\", \\"14:30\\") ] print(merge_time_slots(time_slots)) ``` # Expected Output ```python [ (\\"09:00\\", \\"10:30\\"), (\\"11:00\\", \\"15:00\\"), (\\"16:00\\", \\"17:00\\") ] ``` # Explanation The function `merge_time_slots` should iterate through the given time slots, sorting them by start times, merging any overlapping ranges, and returning the consolidated list of time ranges. # Notes - Ensure your function correctly handles the cases where time slots completely overlap or partially overlap. - Make sure to return the result in ascending order of start times.","solution":"from typing import List, Tuple def merge_time_slots(time_slots: List[Tuple[str, str]]) -> List[Tuple[str, str]]: if not time_slots: return [] # Convert time strings to minutes from midnight for easy comparison def to_minutes(time: str) -> int: hours, minutes = map(int, time.split(\\":\\")) return hours * 60 + minutes # Sort the time slots based on start time time_slots.sort(key=lambda x: to_minutes(x[0])) merged = [] current_start, current_end = time_slots[0] for start, end in time_slots[1:]: if to_minutes(start) <= to_minutes(current_end): current_end = max(current_end, end, key=to_minutes) else: merged.append((current_start, current_end)) current_start, current_end = start, end merged.append((current_start, current_end)) return merged"},{"question":"# Question: Binary Tree Right Side View # Problem Statement: Given the root of a binary tree, perform a right side view traversal and return the values of the nodes as seen from the right side. The right side view of a binary tree is the set of nodes visible when the tree is viewed from the right side. # Function Signature: ```python def right_side_view(root: Node) -> List[int]: pass ``` # Input: - The function takes a single argument `root` which is the root node of a binary tree. - `root`: `(Node | None)` - The root node of the binary tree or `None` if the tree is empty. # Output: - The function returns a list of integers representing the values of the nodes visible from the right side. - `List[int]` - A list of integers. # Constraints: - The number of nodes in the tree is in the range `[0, 10^4]`. - The values of the nodes are in the range `[-10^6, 10^6]`. # Example: ```python # Example 1: # Input: root = Node(1) root.left = Node(2) root.right = Node(3) root.left.right = Node(5) root.right.right = Node(4) # Initial Tree: # 1 # / # 2 3 # # 5 4 # Right Side View: [1, 3, 4] view = right_side_view(root) # Expected Output: [1, 3, 4] # Example 2: # Input: root = Node(10) root.left = Node(7) root.right = Node(15) root.right.left = Node(11) root.right.right = Node(18) # Initial Tree: # 10 # / # 7 15 # / # 11 18 # Right Side View: [10, 15, 18] view = right_side_view(root) # Expected Output: [10, 15, 18] ``` # Additional Notes: - Assume that the Node class and binary tree structure are already defined and available for use. - Your solution should perform the traversal in O(n) time where n is the number of nodes in the tree. - Consider edge cases such as an empty tree or trees with all nodes on one side. # Node Class Definition: ```python @dataclass class Node: value: int left: Node | None = None right: Node | None = None ```","solution":"from typing import List, Optional from dataclasses import dataclass from collections import deque @dataclass class Node: value: int left: Optional[\'Node\'] = None right: Optional[\'Node\'] = None def right_side_view(root: Optional[Node]) -> List[int]: if not root: return [] queue = deque([root]) rightside = [] while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() # If it\'s the rightmost element at the level if i == level_length - 1: rightside.append(node.value) # Add child nodes for the next level if node.left: queue.append(node.left) if node.right: queue.append(node.right) return rightside"},{"question":"# Matrix Determinant Calculation You are tasked with implementing the determinant calculation for an `SquareMatrix` class. Specifically, you need to implement the following method: 1. **Matrix Determinant**: * Implement a method `determinant` that computes the determinant of a square matrix using recursion and the Laplace expansion. * **Input**: An `SquareMatrix` object representing a square matrix. * **Output**: A float representing the determinant of the matrix. **Function Signature**: ```python def determinant(self) -> float: ... ``` **Constraints**: 1. Only square matrices (n x n) are considered. 2. Raise an exception if the matrix is not square. **Example Usage**: ```python # Assuming SquareMatrix class has been defined which accepts a 2D list of numbers matrix1 = SquareMatrix([[1, 2], [3, 4]]) # Determinant Calculation result_determinant = matrix1.determinant() print(result_determinant) # Output: -2.0 matrix2 = SquareMatrix([[6, 1, 1], [4, -2, 5], [2, 8, 7]]) # Determinant Calculation result_determinant2 = matrix2.determinant() print(result_determinant2) # Output: -306.0 ``` **Hint**: You may find it useful to implement a helper method to obtain the minor matrix (i.e., matrix formed by removing the specified row and column). Avoid recalculating submatrices for efficiency. ```python def get_minor(matrix: list[list[float]], row: int, col: int) -> list[list[float]]: return [row[:col] + row[col+1:] for row in (matrix[:row] + matrix[row+1:])] ```","solution":"class SquareMatrix: def __init__(self, matrix): self.matrix = matrix n = len(matrix) if any(len(row) != n for row in matrix): raise ValueError(\\"The matrix must be square (n x n).\\") def get_minor(self, matrix, i, j): return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def determinant(self): matrix = self.matrix n = len(matrix) # Base case for 2x2 matrix if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] # Recursive case det = 0 for c in range(n): minor = self.get_minor(matrix, 0, c) det += ((-1) ** c) * matrix[0][c] * SquareMatrix(minor).determinant() return det"},{"question":"# Problem Scenario You are tasked with developing a small library management system where you need to keep track of books and their statuses, such as whether a book is available or checked out by someone. The system should allow additions of new books, checking out of books, and returning books. # Task: Implement a class `Library` that supports adding books to the library, checking out books, and returning books. # Key Requirements: 1. Add a new book to the library. 2. Check out a book from the library. 3. Return a book to the library. 4. Check the availability of a book. # Specifications: 1. **Class**: `Library` 2. **Methods**: * `__init__(self)`: Initializes an empty library. * `add_book(self, title: str)`: Adds a book to the library with the given title. Books are identified uniquely by their titles. * `checkout_book(self, title: str) -> bool`: Checks out a book from the library by its title. Returns `True` if successful and `False` if the book is not available or does not exist. * `return_book(self, title: str) -> bool`: Returns a book to the library by its title. Returns `True` if successful and `False` if the book is not currently checked out or does not exist. * `is_available(self, title: str) -> bool`: Checks if a book is currently available in the library (i.e., not checked out). 3. **Input/Output**: * The `add_book` method accepts a string `title` and adds it to the library inventory. * The `checkout_book` and `return_book` methods accept a string `title` and perform the respective operations, returning a boolean indicating success or failure. * The `is_available` method accepts a string `title` and returns a boolean indicating if the book is currently available. # Constraints: * Book titles are case-sensitive. * Attempting to add a book that already exists in the library should silently do nothing (i.e., no error should be raised, and the book should not be added again). # Example: ```python # Example Usage library = Library() library.add_book(\\"Harry Potter and the Philosopher\'s Stone\\") library.add_book(\\"The Hobbit\\") is_checked_out = library.checkout_book(\\"Harry Potter and the Philosopher\'s Stone\\") # Returns True is_available = library.is_available(\\"Harry Potter and the Philosopher\'s Stone\\") # Returns False returned = library.return_book(\\"Harry Potter and the Philosopher\'s Stone\\") # Returns True is_available = library.is_available(\\"Harry Potter and the Philosopher\'s Stone\\") # Returns True ``` # Notes: * Handle tracking the status of each book within the library. * Ensure the operations for checking out and returning a book are properly managing the availability status of the books.","solution":"class Library: def __init__(self): self.books = {} def add_book(self, title: str): if title not in self.books: self.books[title] = True # Book is not checked out (available) def checkout_book(self, title: str) -> bool: if title in self.books and self.books[title]: self.books[title] = False # Book is now checked out (not available) return True return False def return_book(self, title: str) -> bool: if title in self.books and not self.books[title]: self.books[title] = True # Book is now available return True return False def is_available(self, title: str) -> bool: return self.books.get(title, False)"},{"question":"Task You are required to write a function that finds the intersection of two singly linked lists. Each linked list\'s nodes contain an integer value, and there may be a point where the two lists converge, forming a common tail. The function should return the reference of the intersecting node. If the two linked lists do not intersect, the function should return `None`. # Function Signature ```python def get_intersection_node(headA: ListNode, headB: ListNode) -> ListNode: pass ``` # Input * `headA (ListNode)`: The head of the first singly linked list. * `headB (ListNode)`: The head of the second singly linked list. # Output * The reference of the intersecting node, or `None` if there is no intersection. # Constraints * The number of nodes in both lists is between `0` and `10^4`. * The values of the nodes in the linked lists range from `-10^5` to `10^5`. # Example Consider the following linked lists: List A: `1 -> 9 -> 1 -> [2 -> 4]` List B: `3 -> [2 -> 4]` Nodes `2` and `4` are the intersection point where the lists converge. ```python # Definition for singly-linked list. class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next headA = ListNode(1, ListNode(9, ListNode(1, ListNode(2, ListNode(4))))) headB = ListNode(3, ListNode(2, ListNode(4))) result = get_intersection_node(headA, headB) print(result.val if result else None) ``` In the above example, the output should be: ``` 2 ``` # Notes You should implement the `get_intersection_node` function in a way that optimizes for time complexity. Consider edge cases like when one or both of the linked lists are empty, or when the linked lists have no intersection at all.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def get_intersection_node(headA: ListNode, headB: ListNode) -> ListNode: Finds the intersection node of two singly linked lists. If no intersection, returns None. if not headA or not headB: return None ptrA, ptrB = headA, headB # Traverse both lists. When reaching the end, continue from the beginning of the other list. # If the lists intersect, the pointers will meet at the intersection node. while ptrA is not ptrB: ptrA = ptrA.next if ptrA else headB ptrB = ptrB.next if ptrB else headA return ptrA"},{"question":"# Coding Question: Remove Duplicates from Sorted List You are given a sorted linked list of integers. Your task is to write a function `remove_duplicates` that removes all duplicates such that each element appears only once in the list. The function should return the modified linked list. # Input - A singly linked list `head` where each node contains an integer. # Output - The head of the modified linked list with duplicates removed. # Constraints - The length of the linked list will be in the range `[1, 10^4]`. - The values in the linked list will be sorted in non-decreasing order and will be in the range `[-10^4, 10^4]`. # Example: ```python >>> class ListNode: ... def __init__(self, val=0, next=None): ... self.val = val ... self.next = next >>> def print_list(node): ... result = [] ... while node: ... result.append(node.val) ... node = node.next ... return result >>> list1 = ListNode(1, ListNode(1, ListNode(2))) >>> result1 = remove_duplicates(list1) >>> print_list(result1) [1, 2] >>> list2 = ListNode(1, ListNode(1, ListNode(2, ListNode(3, ListNode(3))))) >>> result2 = remove_duplicates(list2) >>> print_list(result2) [1, 2, 3] >>> list3 = ListNode(1, ListNode(2, ListNode(3))) >>> result3 = remove_duplicates(list3) >>> print_list(result3) [1, 2, 3] ``` # Note: - For the given input linked list `1 -> 1 -> 2`, your function should return `1 -> 2`. - The function should be implemented within a class that includes the necessary data structures and methods to handle linked lists.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head): Remove duplicates from a sorted linked list. Args: head (ListNode): Head of the sorted linked list. Returns: ListNode: Head of the modified linked list with duplicates removed. current = head # Iterate through the list while current and current.next: if current.val == current.next.val: # Skip the next node because it\'s a duplicate current.next = current.next.next else: # Move to the next node current = current.next return head"},{"question":"# Question Matrix Transpose with Diagonals Preservation You are given a square matrix and need to implement a function that performs its transpose while preserving the diagonal elements. In other words, only the elements that are not on the main diagonal should be swapped, leaving the diagonal elements in their original positions. Implement the following function: **transpose_preserve_diagonal(matrix: List[List[int]]) -> List[List[int]]** **Function Definition**: 1. **transpose_preserve_diagonal(matrix: List[List[int]]) -> List[List[int]]**: * This function receives a square matrix (a list of lists of integers) and returns its transpose with the main diagonal elements preserved. * The given matrix will be a square matrix with dimensions n x n, where 1 <= n <= 100. * Example: * Input: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` * Output: ``` [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] ``` **Constraints**: * The matrix is guaranteed to be square. * The values in the matrix are integers. # Example Test Cases ```python assert transpose_preserve_diagonal([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] assert transpose_preserve_diagonal([ [1, 2], [3, 4] ]) == [ [1, 3], [2, 4] ] assert transpose_preserve_diagonal([ [5] ]) == [ [5] ] assert transpose_preserve_diagonal([ [1, 9, 12, 8], [8, 2, 7, 10], [4, 5, 3, 6], [0, 11, 13, 4] ]) == [ [1, 8, 4, 0], [9, 2, 5, 11], [12, 7, 3, 13], [8, 10, 6, 4] ] ``` *Note*: Ensure that the diagonal elements remain unchanged during the transposition of other elements in the matrix.","solution":"def transpose_preserve_diagonal(matrix): Transposes the given square matrix while preserving the diagonal elements. Args: matrix (List[List[int]]): A square matrix to be transposed. Returns: List[List[int]]: The transposed matrix with the main diagonal elements preserved. n = len(matrix) # Creating a new matrix to hold the transposed values result = [row[:] for row in matrix] for i in range(n): for j in range(i + 1, n): result[i][j], result[j][i] = result[j][i], result[i][j] return result"},{"question":"# Word Frequency Counter Scenario: You are developing a text analysis tool that provides insights into the frequency of word occurrences in a given piece of text. One of the features to be implemented is counting the occurrences of each word in a given string of text while excluding common English stop words. # Task Write a Python function that takes a string of text and returns a dictionary with the frequency count of each word, excluding a predefined list of common stop words. Your function should be case-insensitive and should correctly handle punctuation. Function Signature ```python def word_frequency_counter(text: str) -> dict: pass ``` Input * `text` (str): A string of text. Output * Returns a dictionary where keys are words and values are their respective counts. Constraints * The input text will have a maximum length of 10,000 characters. * Words are considered case-insensitively. Example Stop Words List ```python STOP_WORDS = {\'a\', \'an\', \'the\', \'and\', \'or\', \'but\', \'on\', \'in\', \'with\', \'is\', \'it\', \'by\', \'to\', \'of\', \'for\', \'at\', \'as\', \'be\', \'from\', \'that\', \'this\', \'which\'} ``` Examples ```python >>> word_frequency_counter(\\"The quick brown fox jumps over the lazy dog\\") {\'quick\': 1, \'brown\': 1, \'fox\': 1, \'jumps\': 1, \'over\': 1, \'lazy\': 1, \'dog\': 1} >>> word_frequency_counter(\\"This is a test. This test is simple.\\") {\'test\': 2, \'simple\': 1} >>> word_frequency_counter(\\"Python programming is fun and educational. Educational content is valuable.\\") {\'python\': 1, \'programming\': 1, \'fun\': 1, \'educational\': 2, \'content\': 1, \'valuable\': 1} ``` Validation and Error Handling Your function should handle the following cases: * Ignore words that are in the stop words list. * Treat words case-insensitively. * Correctly handle punctuation, considering it separates words but does not count as part of a word.","solution":"import re from collections import defaultdict STOP_WORDS = {\'a\', \'an\', \'the\', \'and\', \'or\', \'but\', \'on\', \'in\', \'with\', \'is\', \'it\', \'by\', \'to\', \'of\', \'for\', \'at\', \'as\', \'be\', \'from\', \'that\', \'this\', \'which\'} def word_frequency_counter(text): Returns a dictionary with the frequency count of each word in the provided text, excluding common stop words. word_count = defaultdict(int) # Convert to lowercase and remove punctuation text = re.sub(r\'[^ws]\', \'\', text.lower()) words = text.split() for word in words: if word not in STOP_WORDS: word_count[word] += 1 return dict(word_count)"},{"question":"# Problem Statement As a software engineer working on a game engine, your task is to develop a function that finds the longest increasing subsequence of scores in a list of player scores. The longest increasing subsequence (LIS) is the longest subsequence of a sequence such that for all elements i and j in the subsequence, if i < j then sequence[i] < sequence[j]. You need to write a function `longest_increasing_subsequence` that takes a list of integers (representing player scores) and returns the length of the longest increasing subsequence. # Function Signature ```python from typing import List def longest_increasing_subsequence(scores: List[int]) -> int: ... ``` # Input * `scores` - A list of integers where each integer represents the score of a player. The list may contain zero or more integers. # Output * An integer representing the length of the longest increasing subsequence in the input list. # Constraints 1. The list `scores` can be empty, in which case return 0. 2. The length of the list `scores` will not exceed 2000 elements. # Examples ```python >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1 >>> longest_increasing_subsequence([]) 0 ``` # Notes 1. Ensure the function runs efficiently, using dynamic programming or other optimization techniques to handle the constraints. 2. The function should be able to handle edge cases such as an empty list or a list with identical elements. The function should use an optimal approach to achieve O(n log n) time complexity to ensure efficiency with larger input sizes.","solution":"from typing import List def longest_increasing_subsequence(scores: List[int]) -> int: if not scores: return 0 n = len(scores) # Array to store our subproblems, dp[i] will be length of LIS ending at index i dp = [1] * n for i in range(n): for j in range(i): if scores[i] > scores[j]: dp[i] = max(dp[i], dp[j] + 1) # The result is the maximum value in dp array, which represents the longest increasing subsequence return max(dp)"},{"question":"Implement a Python function `find_repeating_decimal` that evaluates the decimal representation of a fraction and identifies whether it has a repeating sequence after the decimal point. If a repeating sequence exists, the function should return the sequence; otherwise, it should return an empty string. # Requirements: 1. The numerator and the denominator must be non-negative integers where the denominator is not zero. 2. The function should handle cases where the fraction results in a finite decimal. 3. If there\'s no repeating sequence in the decimal representation, return an empty string. # Input: - `numerator` (numerator >= 0): Integer representing the numerator of the fraction. - `denominator` (denominator > 0): Integer representing the denominator of the fraction. # Output: - A string representing the repeating sequence in the decimal representation if it exists, otherwise an empty string. # Function Signature ```python def find_repeating_decimal(numerator: int, denominator: int) -> str: pass ``` # Example ```python # Example usage: # The fraction 1/3 is 0.(3), the repeating sequence is \\"3\\" print(find_repeating_decimal(1, 3)) # Output: \\"3\\" # The fraction 1/2 is 0.5, no repeating sequence print(find_repeating_decimal(1, 2)) # Output: \\"\\" # The fraction 22/7 is approximately 3.(142857), the repeating sequence is \\"142857\\" print(find_repeating_decimal(22, 7)) # Output: \\"142857\\" # The fraction 1/6 is 0.1(6), the repeating sequence is \\"6\\" print(find_repeating_decimal(1, 6)) # Output: \\"6\\" ``` # Constraints: - The numerator must be a non-negative integer. - The denominator must be a positive integer and not zero. # Notes: - Use efficient methods to detect repeating sequences in the decimal expansion. - The function should handle small numerators and denominators efficiently. - Do not use any external libraries for decimal operations; rely on basic arithmetic and string manipulation.","solution":"def find_repeating_decimal(numerator: int, denominator: int) -> str: # Create a dictionary to store the seen remainders remainders = {} # Determine the integer part of the division integer_part = numerator // denominator remainder = numerator % denominator # Story to build the decimal part decimal_part = [] while remainder != 0: # If the remainder is already seen, a repeating sequence is found if remainder in remainders: repeat_index = remainders[remainder] return \'\'.join(decimal_part[repeat_index:]) # Store the position where this remainder was first seen remainders[remainder] = len(decimal_part) remainder *= 10 decimal_part.append(str(remainder // denominator)) remainder %= denominator # If we complete the loop without repeating remainders return \\"\\" # Example usage: print(find_repeating_decimal(1, 3)) # Output: \\"3\\" print(find_repeating_decimal(1, 2)) # Output: \\"\\" print(find_repeating_decimal(22, 7)) # Output: \\"142857\\" print(find_repeating_decimal(1, 6)) # Output: \\"6\\""},{"question":"# Graph Traversal Using Depth-First Search (DFS) Context You have been tasked with implementing a graph traversal function based on the Depth-First Search (DFS) algorithm. The function should be able to handle undirected graphs, finding all connected components. Problem Statement Write a function `depth_first_search(graph: Dict[int, List[int]]) -> List[List[int]]` that takes a graph represented as an adjacency list and returns a list of connected components. Each connected component should be represented as a list of vertices. Input * `graph`: A dictionary where the keys are integers representing nodes, and the values are lists of integers representing the nodes connected to the corresponding key node. Output * A list of connected components, where each connected component is represented as a list of vertices. Constraints * 1 <= len(graph) <= 10^3 Performance Requirements * The DFS algorithm should be efficiently implemented, ensuring time complexity close to O(V + E), where V is the number of vertices and E is the number of edges. Example ```python graph = { 0: [1, 2], 1: [0, 3], 2: [0], 3: [1], 4: [5], 5: [4] } # Output: [[0, 1, 2, 3], [4, 5]] graph = { 0: [], 1: [2], 2: [1], 3: [4], 4: [3, 5], 5: [4] } # Output: [[0], [1, 2], [3, 4, 5]] graph = { 0: [1], 1: [0], 2: [], 3: [4, 5], 4: [3], 5: [3] } # Output: [[0, 1], [2], [3, 4, 5]] ``` Notes * Ensure your implementation handles all relevant edge cases such as isolated nodes and graphs with no edges. * You are encouraged to write modular code and include helper functions where appropriate. * The order of vertices in the resulting lists is not strictly important but should represent the order they are visited by the DFS algorithm.","solution":"def depth_first_search(graph): Performs DFS on the given graph and returns all connected components. Parameters: graph (dict): The graph represented as an adjacency list. Returns: List[List[int]]: A list of connected components. def dfs(node, visited, component): visited.add(node) component.append(node) for neighbor in graph[node]: if neighbor not in visited: dfs(neighbor, visited, component) visited = set() components = [] for node in graph: if node not in visited: component = [] dfs(node, visited, component) components.append(component) return components"},{"question":"# List Processing Algorithm Enhancement You have been provided with a function that processes lists of integers by performing various operations such as filtering and sorting based on specific criteria. The current implementation of this function works correctly but lacks robustness in handling edge cases and invalid inputs. Objective Enhance the existing list processing function to: 1. **Input Validation**: Ensure the function can handle various types of invalid inputs, such as non-integer elements or empty lists, by returning meaningful error messages. 2. **Performance Optimization**: Optimize the function to efficiently handle large lists and reduce unnecessary computations. Requirements 1. **Function Enhancement**: - Validate inputs and handle cases where the list contains non-integer elements or is empty by returning appropriate error messages. - Optimize the function logic to minimize time complexity while performing necessary operations. 2. **Input and Output**: - **Input**: A list of integers and a boolean flag `reverse` indicating whether the sorting should be in descending order. - **Output**: A processed list of integers or a string error message for invalid inputs. 3. **Constraints**: - The function should only accept lists that contain integers. Any list with non-integer elements should be considered invalid. - Ensure the function performs optimally for lists containing up to 10^6 elements. 4. **Function Signature**: - The function signature should not be changed from the original to maintain consistency with existing code. Example Here is the sample function that you need to update. Ensure similar updates are applied to all related functions if provided. ```python def process_list(values: list, reverse: bool = False) -> list: Filters out negative values from the list, sorts the remaining values in ascending order or descending order based on the reverse flag, and returns the processed list. If the input is invalid, return an appropriate error message. >>> process_list([3, -1, 2, 0], False) [0, 2, 3] >>> process_list([3, -1, 2, 0], True) [3, 2, 0] >>> process_list([3, \'a\', 2, 0]) \'Invalid input: all elements in the list must be integers\' >>> process_list([]) \'Invalid input: the list should not be empty\' if not values: return \'Invalid input: the list should not be empty\' if not all(isinstance(x, int) for x in values): return \'Invalid input: all elements in the list must be integers\' filtered_values = [x for x in values if x >= 0] return sorted(filtered_values, reverse=reverse) ``` Task Update the given function to include input validation and performance optimizations. Ensure all provided tests pass successfully while adhering to enhanced specifications.","solution":"def process_list(values: list, reverse: bool = False) -> list: Filters out negative values from the list, sorts the remaining values in ascending order or descending order based on the reverse flag, and returns the processed list. If the input is invalid, return an appropriate error message. >>> process_list([3, -1, 2, 0], False) [0, 2, 3] >>> process_list([3, -1, 2, 0], True) [3, 2, 0] >>> process_list([3, \'a\', 2, 0]) \'Invalid input: all elements in the list must be integers\' >>> process_list([]) \'Invalid input: the list should not be empty\' if not values: return \'Invalid input: the list should not be empty\' if not all(isinstance(x, int) for x in values): return \'Invalid input: all elements in the list must be integers\' filtered_values = [x for x in values if x >= 0] return sorted(filtered_values, reverse=reverse)"},{"question":"# Problem Statement You are tasked with creating a feature for a text editor that automatically removes duplicated lines from a document, while preserving the order of their initial appearance. The editor is represented by a list of strings, where each string is a line in the document. Write a function `remove_duplicate_lines(lines: list[str]) -> list[str]` that takes a list of strings as input and returns a new list of strings with all duplicate lines removed, preserving the order of their first occurrence. # Input * `lines`: A list of strings (can be empty). Each string represents a line in the document. # Output * A list of strings with duplicated lines removed in the order of their first appearance in the input list. # Constraints * If the input list is empty, the output should be an empty list. * Each line can be an empty string. * If the input contains non-string elements, raise a `ValueError` with the message \\"lines must be an iterable of strings\\". * The input list should be processed in O(n) time complexity, where n is the number of elements in the input list. # Example Usage ```python # Example 1 print(remove_duplicate_lines([ \\"first line\\", \\"second line\\", \\"first line\\", \\"third line\\" ])) # Output: [\\"first line\\", \\"second line\\", \\"third line\\"] # Example 2 print(remove_duplicate_lines([ \\"line 1\\", \\"line 2\\", \\"line 1\\", \\"line 1\\", \\"line 2\\", \\"line 3\\" ])) # Output: [\\"line 1\\", \\"line 2\\", \\"line 3\\"] # Example 3 print(remove_duplicate_lines([])) # Output: [] # Example 4 print(remove_duplicate_lines([\\"\\"])) # Output: [\\"\\"] # Example 5 print(remove_duplicate_lines([\\"a\\", \\"a\\", \\"b\\", \\"a\\"])) # Output: [\\"a\\", \\"b\\"] # Example 6 print(remove_duplicate_lines([1, 2, 3])) # Raises ValueError: \\"lines must be an iterable of strings\\" # Example 7 print(remove_duplicate_lines(\\"ABC\\")) # Raises ValueError: \\"lines must be an iterable of strings\\" ``` # Performance Requirement * The solution should run in O(n) time complexity, where n is the number of elements in the input list. * The space complexity should be O(n). Your task is to ensure the function handles all edge cases efficiently and returns the correct result as specified.","solution":"def remove_duplicate_lines(lines): Removes duplicate lines from a list while preserving order of their first occurrence. Args: lines (list of str): A list of strings where each string represents a line in a document. Returns: list of str: A list of strings with duplicated lines removed. Raises: ValueError: If input is not an iterable of strings. if not isinstance(lines, list): raise ValueError(\\"lines must be an iterable of strings\\") seen = set() result = [] for line in lines: if not isinstance(line, str): raise ValueError(\\"lines must be an iterable of strings\\") if line not in seen: seen.add(line) result.append(line) return result"},{"question":"**Context**: You are implementing a digital document processing system where each document is represented as a sequence of pages. Each page contains a mixture of text blocks and images. Each document needs to maintain the correct order of pages and allow for efficient addition, retrieval, and removal of pages. **Objective**: Implement a class `Document` that supports operations to manage pages. Each page can be added at a specific position, retrieved by its position, and removed. # Requirements: 1. **Class Design**: Design a `Page` class and a `Document` class to manage the collection of `Page` instances. 2. **Methods to Implement**: * `add_page`: Adds a page to the document at a specified position. * `get_page`: Retrieves the content of the page at the specified position. * `remove_page`: Removes the page from the document at the specified position. # Define Class Structure ```python class Page: def __init__(self, content): self.content = content # You may include more attributes if needed class Document: def __init__(self): # Initialize a list to hold pages of the document self.pages = [] def add_page(self, page: Page, position: int = None): Add a page at a specified position. If no position is specified, add at the end. # Implement addition logic def get_page(self, position: int) -> Page: Retrieve the page at the specified position. # Implement retrieval logic and handle invalid positions def remove_page(self, position: int): Remove the page at the specified position. # Implement removal logic and handle invalid positions ``` # Instructions 1. **Page Class**: Initialize with content that can either be text or image descriptions. 2. **Document Class**: Maintain pages in a list and provide methods to manipulate them. 3. **Adding Pages**: `add_page` should insert the page at the given position. If no position is provided, append the page to the end. 4. **Retrieving Pages**: `get_page` should return the page at the given position. Raise an appropriate error if the position is out of bounds. 5. **Removing Pages**: `remove_page` should remove the page at the given position. Raise an appropriate error if the position is out of bounds. # Constraints * `content` can be either a string representing text or a string describing an image. * There can be up to 10,000 pages in a document. * Positions are 0-indexed. # Example ```python # Example usage document = Document() page1 = Page(\\"This is the first page.\\") page2 = Page(\\"This is the second page with an image: [image2.jpg]\\") document.add_page(page1) document.add_page(page2, 0) # Insert at the beginning print(document.get_page(0).content) # Output: \\"This is the second page with an image: [image2.jpg]\\" document.remove_page(1) ```","solution":"class Page: def __init__(self, content): self.content = content class Document: def __init__(self): self.pages = [] def add_page(self, page: Page, position: int = None): if position is None: self.pages.append(page) else: if position < 0 or position > len(self.pages): raise IndexError(\\"Invalid position\\") self.pages.insert(position, page) def get_page(self, position: int) -> Page: if position < 0 or position >= len(self.pages): raise IndexError(\\"Invalid position\\") return self.pages[position] def remove_page(self, position: int): if position < 0 or position >= len(self.pages): raise IndexError(\\"Invalid position\\") del self.pages[position]"},{"question":"# Coding Assessment Question Objective Implement a Python function to simulate a vending machine dispensing system. The vending machine accepts a variety of coins, and you need to determine the optimal change to be returned in coins when a user makes a purchase. Problem Statement Given an item price and the amount paid by the user, calculate the minimum number of coins that will be needed to provide the correct change. Assume the vending machine has an infinite supply of the following coins: 1 cent, 5 cents, 10 cents, 25 cents, and 1 dollar. Function Specifications 1. **Function Name**: `get_change` 2. **Input Parameters**: - `item_price`: float; The price of the item in dollars. - `amount_paid`: float; The amount paid by the user in dollars. 3. **Output**: - A dictionary where the keys are the coin denominations (as Integers representing cents) and the values are the number of each type of coin needed to make the change. - If the amount paid is less than the item price, raise a `ValueError` with a descriptive message. 4. **Constraints**: - `item_price` and `amount_paid` should be positive values, rounded to two decimal places. - The vending machine should return the minimum number of coins required. - This problem can be modeled as a variant of the coin change problem. ```python def get_change(item_price: float, amount_paid: float) -> dict[int, int] | ValueError: Input Parameters: ----------------- item_price: The price of the item in dollars. amount_paid: The amount paid by the user in dollars. Returns: -------- The function returns a dictionary with the coin counts: - Keys are the coin denominations (in cents): 1, 5, 10, 25, 100 - Values are the counts of each coin needed to make the change If the amount paid is less than the item price, raises a ValueError with an appropriate error message. Examples: --------- >>> get_change(0.75, 1.00) {25: 1} >>> get_change(1.50, 2.00) {25: 2} >>> get_change(1.30, 1.00) ValueError(\'Input Error: Insufficient amount paid.\') Notes: ------ Assume we have an infinite supply of coins of denominations 1, 5, 10, 25 cents, and 1 dollar. pass # Your code here ``` Notes: 1. Validate the inputs to ensure `item_price` and `amount_paid` are positive and that `amount_paid` is not less than `item_price`. 2. Use a greedy algorithm to ensure the minimum number of coins is used to make the change. 3. Ensure the function handles edge cases gracefully and provides informative error messages.","solution":"def get_change(item_price, amount_paid): Calculate the minimum number of coins needed to provide the correct change. Args: item_price: float - the price of the item in dollars amount_paid: float - the amount paid by the user in dollars Returns: dict - a dictionary with the coin counts Raises: ValueError: If the amount paid is less than the item price Examples: --------- >>> get_change(0.75, 1.00) {25: 1} >>> get_change(1.50, 2.00) {25: 2} if amount_paid < item_price: raise ValueError(\'Input Error: Insufficient amount paid.\') # Convert dollar amounts to cents change = round((amount_paid - item_price) * 100) coins = [100, 25, 10, 5, 1] change_dict = {} for coin in coins: if change == 0: break coin_count = change // coin if coin_count > 0: change_dict[coin] = coin_count change -= coin_count * coin return change_dict"},{"question":"# Coding Task: Implement K-Means Clustering with Custom Distance Metric Description You are tasked to implement the K-Means clustering algorithm with a custom distance metric. The goal is to group a set of data points into K clusters, minimizing the distance between points within each cluster and the cluster centroid using the custom distance metric. Requirements 1. Implement the `CustomKMeans` class. 2. This class should have methods to fit the model to the training data and make predictions for new data points. 3. Your implementation should allow for a custom distance metric (e.g., Euclidean, Manhattan). 4. Ensure proper re-calculation of centroids and assignment of clusters until convergence. Input Format 1. Training data as a numpy ndarray where rows represent samples and columns represent features. 2. Number of desired clusters, K. 3. Custom distance function to calculate distance between two points. Output Format An array of cluster assignments for the training samples after fitting the model. Constraints 1. The algorithm should handle cases where initial centroids might be chosen randomly. 2. Ensure the clustering process converges effectively. 3. The custom distance function should take two points as input and return a single numeric distance value. Example ```python import numpy as np # Define custom distance metric (Euclidean distance in this case) def custom_distance(x, y): return np.sqrt(np.sum((x - y)**2)) # Training data train_data = np.array([ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0] ]) # K-Means Model Initialization kmeans = CustomKMeans( train_data=train_data, n_clusters=2, distance_func=custom_distance, max_iter=100 ) # Fitting the model kmeans.fit() # Predicting cluster_assignments = kmeans.predict(train_data) print(cluster_assignments) # Expected Output: array([0, 0, 1, 1, 0, 1]) ``` Implement the `CustomKMeans` class based on the given example above.","solution":"import numpy as np class CustomKMeans: def __init__(self, n_clusters, distance_func, max_iter=100): self.n_clusters = n_clusters self.distance_func = distance_func self.max_iter = max_iter self.centroids = None self.labels_ = None def fit(self, X): # Randomly initialize centroids np.random.seed(42) # Seed for reproducibility initial_indices = np.random.permutation(X.shape[0])[:self.n_clusters] self.centroids = X[initial_indices] for _ in range(self.max_iter): # Assign labels based on closest centroid self.labels_ = self.assign_labels(X) # Compute new centroids new_centroids = self.compute_centroids(X) # Check for convergence (if centroids do not change) if np.all(new_centroids == self.centroids): break self.centroids = new_centroids def assign_labels(self, X): labels = np.zeros(X.shape[0], dtype=int) for i in range(X.shape[0]): distances = np.array([self.distance_func(X[i], centroid) for centroid in self.centroids]) labels[i] = np.argmin(distances) return labels def compute_centroids(self, X): centroids = np.zeros((self.n_clusters, X.shape[1])) for k in range(self.n_clusters): cluster_points = X[self.labels_ == k] if len(cluster_points) > 0: centroids[k] = np.mean(cluster_points, axis=0) return centroids def predict(self, X): return self.assign_labels(X)"},{"question":"# Question Problem Statement Write a function to calculate the power of a number using recursion. The function should take two arguments: the base and the exponent. The base can be a float, and the exponent is a non-negative integer. Your function should efficiently compute the power using the \\"exponentiation by squaring\\" method. Function Signature ```python def recursive_power(base: float, exponent: int) -> float: Compute the power of a base raised to an exponent using recursion. :param base: A float representing the base value. :param exponent: A non-negative integer representing the exponent value. :return: A float that is base raised to the power of exponent. ``` Input * `base`: A floating-point number. * `exponent`: A non-negative integer. Output * Return the float value of `base` raised to the `exponent`. Constraints * The input base is a floating-point number. * The input exponent is a non-negative integer (0 <= exponent <= 1000). * Implement error handling to manage incorrect input formats (like negative exponents or non-integer exponents). Examples ```python recursive_power(2, 3) # Returns 8.0 recursive_power(5, 0) # Returns 1.0 recursive_power(2.5, 2) # Returns 6.25 recursive_power(3, 4) # Returns 81.0 recursive_power(7, 1) # Returns 7.0 ``` Performance Requirements * The solution should run in O(log n) time complexity, where `n` is the exponent due to the halving method used in \\"exponentiation by squaring\\". Implementation Notes * Reflect the recursive method for computing powers using exponentiation by squaring. * Handle edge cases such as the zero exponent (which should return 1) and base values as 1 or 0. * Implement a suite of tests to validate your function\'s performance and correctness over a range of input scenarios.","solution":"def recursive_power(base: float, exponent: int) -> float: Compute the power of a base raised to an exponent using recursion. :param base: A float representing the base value. :param exponent: A non-negative integer representing the exponent value. :return: A float that is base raised to the power of exponent. if not isinstance(base, (int, float)): raise ValueError(\\"Base must be a number.\\") if not isinstance(exponent, int) or exponent < 0: raise ValueError(\\"Exponent must be a non-negative integer.\\") if exponent == 0: return 1.0 if exponent == 1: return base half_power = recursive_power(base, exponent // 2) if exponent % 2 == 0: return half_power * half_power else: return half_power * half_power * base"},{"question":"# Maximum Length of Palindromic Subsequence **Objective**: Write a function that finds the length of the longest palindromic subsequence in a given string. Function to Implement ```python def max_palindromic_subseq_length(s: str) -> int: Returns the length of the longest palindromic subsequence in the given string. Parameters: s (str): The input string. Returns: int: The length of the longest palindromic subsequence. Examples: >>> max_palindromic_subseq_length(\\"bbabcbcab\\") 7 >>> max_palindromic_subseq_length(\\"racecar\\") 7 >>> max_palindromic_subseq_length(\\"abcd\\") 1 pass ``` Input - `s` (str): The input string consisting of lowercase and/or uppercase characters. Output - Returns the length of the longest palindromic subsequence within the string `s`. Constraints - 1 ≤ `len(s)` ≤ 1000 - The input string `s` consists of printable ASCII characters. Special Considerations - Consider both time and space complexity to ensure the solution is efficient for the highest constraint value. - The function should handle edge cases such as empty strings or strings without any palindromic subsequence properly. Example Usage ```python print(max_palindromic_subseq_length(\\"bbabcbcab\\")) # Output: 7 print(max_palindromic_subseq_length(\\"racecar\\")) # Output: 7 print(max_palindromic_subseq_length(\\"abcd\\")) # Output: 1 ```","solution":"def max_palindromic_subseq_length(s: str) -> int: Returns the length of the longest palindromic subsequence in the given string. Parameters: s (str): The input string. Returns: int: The length of the longest palindromic subsequence. n = len(s) if n == 0: return 0 # Create a 2D array to store the lengths of longest palindromic subsequences dp = [[0 for _ in range(n)] for _ in range(n)] # Every single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Build the table for substrings of different lengths for length in range(2, n+1): for i in range(n-length+1): j = i + length - 1 if s[i] == s[j] and length == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) # The result is in the top right corner of the table return dp[0][n-1]"},{"question":"# Scenario You are tasked with developing a text-based adventure game where players navigate through a world represented by a grid of rooms. Each room can have different properties, such as whether it contains an item, an obstacle, or is empty. # Task Implement a `Room` class to define individual rooms in the grid. Additionally, create a `Grid` class to handle the overall game world. The `Grid` class should allow players to navigate through rooms and report back the current status of the room they are in. # Function Signature Below are the classes and methods you need to implement: ```python class Room: def __init__(self, description: str, has_item: bool = False, is_obstacle: bool = False): Initialize a room with description, item presence, and obstacle flag. Args: description (str): Description of the room. has_item (bool): Whether the room contains an item. is_obstacle (bool): Whether the room contains an obstacle. self.description = description self.has_item = has_item self.is_obstacle = is_obstacle class Grid: def __init__(self, rows: int, cols: int): Initialize a grid of given dimensions. Args: rows (int): Number of rows in the grid. cols (int): Number of columns in the grid. self.grid = [[Room(\\"Empty room\\") for _ in range(cols)] for _ in range(rows)] self.current_row = 0 self.current_col = 0 def set_room(self, row: int, col: int, room: Room): Set a room in the specified location. Args: row (int): Row index. col (int): Column index. room (Room): The room object to set. self.grid[row][col] = room def move(self, direction: str) -> str: Move the player in the specified direction. Args: direction (str): One of \'north\', \'south\', \'east\', \'west\'. Returns: str: Description of the new room or error message if move is invalid. if direction == \'north\': if self.current_row > 0: self.current_row -= 1 else: return \\"Cannot move north.\\" elif direction == \'south\': if self.current_row < len(self.grid) - 1: self.current_row += 1 else: return \\"Cannot move south.\\" elif direction == \'east\': if self.current_col < len(self.grid[0]) - 1: self.current_col += 1 else: return \\"Cannot move east.\\" elif direction == \'west\': if self.current_col > 0: self.current_col -= 1 else: return \\"Cannot move west.\\" else: return \\"Invalid direction.\\" current_room = self.grid[self.current_row][self.current_col] return current_room.description # Example Usage ```python # Create a grid grid = Grid(3, 3) # Set some rooms grid.set_room(0, 0, Room(\\"Starting room\\")) grid.set_room(1, 0, Room(\\"Room with an item\\", has_item=True)) grid.set_room(2, 2, Room(\\"Obstacle room\\", is_obstacle=True)) # Move within the grid print(grid.move(\'south\')) # Outputs: Room with an item print(grid.move(\'south\')) # Outputs: Cannot move south. print(grid.move(\'east\')) # Outputs: Empty room ``` # Note - Restrict movements to within grid boundaries. - Add additional properties or methods to `Room` and `Grid` if necessary to enhance functionality.","solution":"class Room: def __init__(self, description: str, has_item: bool = False, is_obstacle: bool = False): Initialize a room with description, item presence, and obstacle flag. Args: description (str): Description of the room. has_item (bool): Whether the room contains an item. is_obstacle (bool): Whether the room contains an obstacle. self.description = description self.has_item = has_item self.is_obstacle = is_obstacle class Grid: def __init__(self, rows: int, cols: int): Initialize a grid of given dimensions. Args: rows (int): Number of rows in the grid. cols (int): Number of columns in the grid. self.grid = [[Room(\\"Empty room\\") for _ in range(cols)] for _ in range(rows)] self.current_row = 0 self.current_col = 0 def set_room(self, row: int, col: int, room: Room): Set a room in the specified location. Args: row (int): Row index. col (int): Column index. room (Room): The room object to set. self.grid[row][col] = room def move(self, direction: str) -> str: Move the player in the specified direction. Args: direction (str): One of \'north\', \'south\', \'east\', \'west\'. Returns: str: Description of the new room or error message if move is invalid. if direction == \'north\': if self.current_row > 0: self.current_row -= 1 else: return \\"Cannot move north.\\" elif direction == \'south\': if self.current_row < len(self.grid) - 1: self.current_row += 1 else: return \\"Cannot move south.\\" elif direction == \'east\': if self.current_col < len(self.grid[0]) - 1: self.current_col += 1 else: return \\"Cannot move east.\\" elif direction == \'west\': if self.current_col > 0: self.current_col -= 1 else: return \\"Cannot move west.\\" else: return \\"Invalid direction.\\" current_room = self.grid[self.current_row][self.current_col] return current_room.description"},{"question":"# Question Context: You are working on optimizing a task scheduler for a critical system. To ensure the system runs smoothly, certain tasks must be executed in a specific order due to dependencies between them. The scheduler needs to determine if it is possible to complete all the given tasks without any circular dependencies. Task: Write a Python function `can_finish(num_tasks: int, prerequisites: List[List[int]]) -> bool` that receives an integer `num_tasks` and a list of prerequisite pairs. Each pair `[a, b]` indicates that task `b` must be completed before task `a`. The function should return `True` if it is possible to finish all tasks without any circular dependency, and `False` otherwise. Input: - `num_tasks` (int): An integer representing the total number of tasks. (1 ≤ num_tasks ≤ 1000) - `prerequisites` (List[List[int]]): A list of pairs where each pair `[a, b]` indicates that task `b` must be completed before task `a`. (0 ≤ len(prerequisites) ≤ 10000) Output: - Return a boolean value: `True` if it is possible to finish all tasks, `False` otherwise. Constraints: - Ensure your solution runs efficiently and can handle the input bounds provided. Example: ```python assert can_finish(2, [[1, 0]]) == True assert can_finish(2, [[1, 0], [0, 1]]) == False assert can_finish(3, [[0, 1], [1, 2]]) == True assert can_finish(4, [[0, 1], [1, 2], [2, 3], [3, 1]]) == False assert can_finish(5, [[1, 0], [2, 1], [3, 2], [4, 3]]) == True ```","solution":"from typing import List, Dict from collections import deque, defaultdict def can_finish(num_tasks: int, prerequisites: List[List[int]]) -> bool: # Create a graph representation and a degree array to track in-degrees graph = defaultdict(list) in_degree = [0] * num_tasks # Build the graph and populate the in-degree array for dest, src in prerequisites: graph[src].append(dest) in_degree[dest] += 1 # Initialize the queue with nodes having zero in-degree queue = deque([i for i in range(num_tasks) if in_degree[i] == 0]) visited = 0 # Process the graph while queue: current = queue.popleft() visited += 1 # Reduce the in-degree of each neighbor by 1 for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If we visited all nodes, it means we can complete all tasks return visited == num_tasks"},{"question":"# Problem Statement You are given a list of words. Your task is to implement a function that finds and returns all the anagram groups. Words are considered anagrams if they contain the same characters with the same frequency. # Function Signature ```python def find_anagram_groups(words: list) -> list: Find groups of anagrams in a list of words. Parameters: words (list): A list of words (strings). Returns: list: A list of lists, where each inner list contains words that are anagrams of each other. pass ``` # Input - `words` (list): A list of words (strings) containing up to 10^4 words. Each word consists of lowercase English letters and has a length between 1 and 100 characters. # Output - `list`: A list of lists, where each inner list contains words that are anagrams of each other. # Constraints - Each word in the list consists of lowercase English letters only. - You may assume that there are no duplicate words in the provided list. # Performance Requirements - The solution should run in O(N * M log M) time complexity, where N is the number of words and M is the length of the longest word. - The space complexity should be O(N * M). # Example ```python words = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] print(find_anagram_groups(words)) # Output: [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] words = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gooegl\\"] print(find_anagram_groups(words)) # Output: [[\\"listen\\", \\"silent\\", \\"enlist\\"], [\\"google\\", \\"gooegl\\"]] ``` # Implementation Notes 1. To identify anagrams, you can sort each word and use it as a key in a dictionary. 2. Traverse the list of words, and for each word, compute the sorted version of that word. 3. Use the sorted word as a key and group words that have the same sorted key. 4. Collect and return all groups of anagrams as a list of lists.","solution":"def find_anagram_groups(words: list) -> list: from collections import defaultdict # Dictionary to hold the groups of anagrams anagram_groups = defaultdict(list) # Iterate over the list of words for word in words: # Sort the word to get the key sorted_word = \'\'.join(sorted(word)) # Append the original word to the corresponding anagram group anagram_groups[sorted_word].append(word) # Return the values of the dictionary as a list of lists return list(anagram_groups.values())"},{"question":"# Coding Assessment Question: Inventory Management System Context: You are developing an inventory management system for a small retail store. The system should track the quantity of various items in the store, allow for updating stock levels, and provide reports on inventory status. Task: Implement the `InventorySystem` class that provides functionality to add, update, and report on inventory items. Class Signature: ```python class InventorySystem: def __init__(self): pass def add_item(self, item_id: int, item_name: str, quantity: int): pass def update_stock(self, item_id: int, quantity_change: int): pass def generate_report(self) -> str: pass ``` Methods: 1. `__init__(self) -> None`: Initializes an empty inventory system. 2. `add_item(self, item_id: int, item_name: str, quantity: int) -> None`: Adds a new item to the inventory with the specified item ID, name, and initial quantity. If the item ID already exists, it should update the item name and quantity. 3. `update_stock(self, item_id: int, quantity_change: int) -> None`: Updates the stock level of the specified item by adding `quantity_change` to the current quantity. If the item does not exist, it should raise a `ValueError`. 4. `generate_report(self) -> str`: Generates a report of the current inventory status, listing each item ID, item name, and quantity. The report should be a single string with each item on a new line, in the format: \\"ID: item_id, Name: item_name, Quantity: quantity\\". Input Types: - `item_id` (int): The unique identifier for an item. - `item_name` (str): The name of the item. - `quantity` (int): The quantity of the item to add or update. - `quantity_change` (int): The change in quantity for an existing item. Output Type: - A string representing the current inventory status for the `generate_report` method. Example: ```python inventory = InventorySystem() inventory.add_item(101, \\"Apple\\", 50) inventory.add_item(102, \\"Banana\\", 30) inventory.add_item(103, \\"Orange\\", 40) inventory.update_stock(101, -10) inventory.update_stock(102, 20) report = inventory.generate_report() print(report) # Expected Output: # \\"ID: 101, Name: Apple, Quantity: 40nID: 102, Name: Banana, Quantity: 50nID: 103, Name: Orange, Quantity: 40\\" ``` **Note**: The class should handle invalid inputs gracefully, and changes to stock should not result in negative quantities.","solution":"class InventorySystem: def __init__(self): self.inventory = {} def add_item(self, item_id: int, item_name: str, quantity: int): if quantity < 0: raise ValueError(\\"Quantity cannot be negative\\") self.inventory[item_id] = {\\"name\\": item_name, \\"quantity\\": quantity} def update_stock(self, item_id: int, quantity_change: int): if item_id not in self.inventory: raise ValueError(\\"Item ID does not exist\\") new_quantity = self.inventory[item_id][\\"quantity\\"] + quantity_change if new_quantity < 0: raise ValueError(\\"Resulting quantity cannot be negative\\") self.inventory[item_id][\\"quantity\\"] = new_quantity def generate_report(self) -> str: report_lines = [] for item_id, data in self.inventory.items(): report_lines.append(f\\"ID: {item_id}, Name: {data[\'name\']}, Quantity: {data[\'quantity\']}\\") return \\"n\\".join(report_lines)"},{"question":"# Sum of Subarray Exact Length and Value Context and Objective You are working on a financial application that helps users track their transactions. One of the features involves analyzing segments of the transaction history to identify segments that meet specific criteria. The system needs a function to determine if there exists any contiguous subarray of exact length `L` whose sum is exactly `S`. Problem Statement Given an array of integers representing transaction amounts, and two integers `L` and `S`, write a function `has_subarray_with_sum` that checks if there is any contiguous subarray of the exact length `L` whose sum equals `S`. Function Signature ```python def has_subarray_with_sum(arr: list[int], L: int, S: int) -> bool: pass ``` Input Constraints - `arr`: A list of integers representing transaction amounts. - `L`: A positive integer representing the length of the subarray. - `S`: An integer representing the target sum. Assume: - `1 <= L <= len(arr)` Output - Return `True` if there exists at least one contiguous subarray of length `L` with sum `S`, otherwise return `False`. Example ```python # Example 1: arr = [1, 2, 3, 4, 5] L = 3 S = 6 # Possible subarrays of length 3: [1, 2, 3], [2, 3, 4], [3, 4, 5] # Subarray [1, 2, 3] has a sum of 6 assert has_subarray_with_sum(arr, L, S) == True # Example 2: arr = [10, 2, -2, -20, 10] L = 2 S = -22 # Possible subarrays of length 2: [10, 2], [2, -2], [-2, -20], [-20, 10] # Subarray [-2, -20] has a sum of -22 assert has_subarray_with_sum(arr, L, S) == True # Example 3: arr = [1, 2, 3, 4, 5] L = 2 S = 10 # No subarray of length 2 sums to 10 assert has_subarray_with_sum(arr, L, S) == False ``` Notes - Aim for an efficient approach with a time complexity ideally O(n), where n is the length of the array. - Use a sliding window technique to solve the problem efficiently.","solution":"def has_subarray_with_sum(arr, L, S): Checks if there is any contiguous subarray of length L with sum S. Parameters: arr (list of int): Array of integers L (int): Length of the subarray S (int): Target sum Returns: bool: True if there exists a subarray of length L with sum S, False otherwise n = len(arr) curr_sum = sum(arr[:L]) if curr_sum == S: return True for i in range(L, n): curr_sum += arr[i] - arr[i - L] if curr_sum == S: return True return False"},{"question":"# Coding Assessment Question Implement a function `pancake_sort` that sorts a list of numbers using the Pancake Sorting algorithm. Pancake sorting involves flipping sublists similarly to flipping pancakes in a pan. Your task is to sort the list by performing a sequence of pancake flips. Function Signature ```python def pancake_sort(sequence: list) -> list: pass ``` Input - `sequence` (list of ints): The list to be sorted. Output - Returns a new list of integers sorted in ascending order, derived by flipping sublists in the original list. Constraints - List may contain up to `10^3` elements. - Elements can be negative or positive integers. - Ensure the function returns a new sorted list, not modifying the original list in-place. Example ```python seq = [3, 6, 5, 4, 1, 2] sorted_seq = pancake_sort(seq) print(sorted_seq) # Output: [1, 2, 3, 4, 5, 6] seq = [10, 9, 8, 7, 6] sorted_seq = pancake_sort(seq) print(sorted_seq) # Output: [6, 7, 8, 9, 10] seq = [] sorted_seq = pancake_sort(seq) print(sorted_seq) # Output: [] seq = [1] sorted_seq = pancake_sort(seq) print(sorted_seq) # Output: [1] seq = [4, 3, 2, 1] sorted_seq = pancake_sort(seq) print(sorted_seq) # Output: [1, 2, 3, 4] ``` Scenarios to Validate - Sorting an empty list. - Sorting a single-element list. - Sorting a pre-sorted list. - Sorting a reverse-sorted list. - Sorting a list with duplicates. Hints - A flip operation for a sublist ending at index `k` can be simulated by reversing the list slice up to index `k+1`. - Prioritize finding the largest unsorted element and flipping it to its correct position.","solution":"def pancake_sort(sequence: list) -> list: def flip(arr, k): return arr[:k+1][::-1] + arr[k+1:] arr = sequence[:] n = len(arr) for size in range(n, 1, -1): # Find the index of the maximum element in arr[0...size-1] max_index = max(range(size), key=arr.__getitem__) if max_index == size - 1: continue # It\'s already in place # Flip the maximum element to the front if it\'s not already at the front if max_index != 0: arr = flip(arr, max_index) # Flip it to its correct place arr = flip(arr, size - 1) return arr"},{"question":"# Problem Statement In this problem, you are required to create a function that can transpose a given square matrix. The transpose of a matrix is obtained by swapping the rows with columns – effectively flipping the matrix over its diagonal. # Function Signature ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transpose a given square matrix. Args: matrix - A list of lists where each sublist represents a row of the matrix. Returns: A new list of lists representing the transposed matrix. Raises: ValueError - If the input is not a square matrix. pass ``` # Input - `matrix`: A list of lists of integers, where each sublist has the same length as the outer list, representing an `n x n` square matrix. # Output - A new list of lists of integers that represent the transposed matrix. # Constraints - The function should handle matrices with different sizes but they will always be square matrices (i.e., number of rows equals number of columns). - Matrices can have elements ranging in value up to 10^9. - The size of the matrix (n) can be up to 500 (which means input can be up to 500x500 elements). # Performance Requirements - The solution should aim for efficient processing with time and space complexity close to O(n^2), where `n` is the size of the matrix. # Example Given the input matrix: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The output should be: ```python [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] ``` # Edge Cases - A matrix with a single element should return the same single element. - The function should raise a `ValueError` if the input matrix is not square. - The function should handle the maximum sized matrix efficiently. Ensure your implementation correctly handles the constraints and edge cases mentioned above. Writing your own tests will help validate the robustness of your solution.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transpose a given square matrix. Args: matrix - A list of lists where each sublist represents a row of the matrix. Returns: A new list of lists representing the transposed matrix. Raises: ValueError - If the input is not a square matrix. n = len(matrix) if any(len(row) != n for row in matrix): raise ValueError(\\"The input matrix is not square.\\") transposed = [[matrix[j][i] for j in range(n)] for i in range(n)] return transposed"},{"question":"# Competitive Gamified Learning Platform You are building a competitive gamified learning platform where users earn points by solving coding challenges. Each challenge has a difficulty level and a category (e.g., Algorithms, Data Structures, Databases). Task: Implement a leaderboard system with the following functionalities: 1. `add_user(username: str) -> None`: Adds a new user to the leaderboard. 2. `add_challenge(category: str, difficulty: int) -> None`: Adds a new challenge to the platform specifying its category and difficulty. 3. `submit_challenge(username: str, challenge_id: str) -> int`: Records a user\'s submission of a challenge and updates their score. The score for a challenge is its difficulty level. 4. `get_leaderboard(category: str) -> list[tuple[str, int]]`: Returns a sorted list of users and their scores for the specified category in descending order. Input: * Usernames are unique strings. * Challenge categories are non-empty strings. * Difficulty levels are integers between 1 and 100. * Challenge IDs are unique strings. Example Usage: ```python add_user(\\"alice\\") add_user(\\"bob\\") add_challenge(\\"Algorithms\\", 30) add_challenge(\\"Data Structures\\", 50) challenge_id_1 = \\"alg-123\\" challenge_id_2 = \\"ds-456\\" submit_challenge(\\"alice\\", challenge_id_1) # Returns 30 submit_challenge(\\"bob\\", challenge_id_2) # Returns 50 submit_challenge(\\"alice\\", challenge_id_2) # Returns 50 get_leaderboard(\\"Algorithms\\") # Returns [(\\"alice\\", 30)] get_leaderboard(\\"Data Structures\\") # Returns [(\\"bob\\", 50), (\\"alice\\", 50)] ``` Constraints: * `1 <= difficulty <= 100` * Usernames and challenge IDs are unique. * Assume submissions of challenges are valid and users always submit challenges that exist. Performance: * Ensure the system can handle a large number of users and challenges efficiently. Additional Notes: * Address the need for efficient updates and retrievals within the leaderboard. * Consider edge cases such as no users in a category or challenges of the same difficulty.","solution":"class LeaderboardSystem: def __init__(self): self.users_scores = {} # user -> {category -> score} self.challenges = {} # challenge_id -> (category, difficulty) def add_user(self, username: str) -> None: if username not in self.users_scores: self.users_scores[username] = {} def add_challenge(self, challenge_id: str, category: str, difficulty: int) -> None: if challenge_id not in self.challenges: self.challenges[challenge_id] = (category, difficulty) def submit_challenge(self, username: str, challenge_id: str) -> int: category, difficulty = self.challenges[challenge_id] if category not in self.users_scores[username]: self.users_scores[username][category] = 0 self.users_scores[username][category] += difficulty return difficulty def get_leaderboard(self, category: str) -> list[tuple[str, int]]: leaderboard = [] for user, scores in self.users_scores.items(): if category in scores: leaderboard.append((user, scores[category])) leaderboard.sort(key=lambda x: x[1], reverse=True) return leaderboard"},{"question":"# Objective: To implement a function that checks whether a given date string represents a valid Gregorian calendar date, and a main function to demonstrate this validation. # Task: 1. Implement a `validate_date` function that takes a string `date_str` and checks if it is a valid Gregorian calendar date in the format \\"YYYY-MM-DD\\". 2. Implement a `main` function to demonstrate the date validation. # Function Signature: ```python def validate_date(date_str: str) -> bool: ``` # Input: * `date_str` (str): the date string in the format \\"YYYY-MM-DD\\". # Output: * A boolean value indicating whether the given date string represents a valid Gregorian calendar date. # Requirements: 1. The date must be in the format \\"YYYY-MM-DD\\". 2. The function should check if the year, month, and day values form a valid date. 3. Consider leap years when verifying February dates. 4. Return `True` if the date is valid, otherwise return `False`. # Constraints: * The year must be a positive integer. * The month must be between 1 and 12. * The day must be valid for the given month and year. # Examples: ```python >>> validate_date(\\"2023-10-15\\") True >>> validate_date(\\"2024-02-29\\") True >>> validate_date(\\"2021-02-29\\") False >>> validate_date(\\"2021-13-10\\") False >>> validate_date(\\"abcd-10-10\\") False ``` # Additional Information: Implement the `main` function to: 1. Prompt the user to input a date string. 2. Validate the date using the `validate_date` function. 3. Output whether the date is valid or not. Sample Implementation: ```python def validate_date(date_str: str) -> bool: try: year, month, day = map(int, date_str.split(\'-\')) if not (1 <= month <= 12): return False if month in {1, 3, 5, 7, 8, 10, 12}: return 1 <= day <= 31 elif month in {4, 6, 9, 11}: return 1 <= day <= 30 elif month == 2: if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): return 1 <= day <= 29 # Leap year else: return 1 <= day <= 28 return False except ValueError: return False def main(): date_str = input(\\"Enter a date (YYYY-MM-DD): \\") if validate_date(date_str): print(\\"The date is valid.\\") else: print(\\"The date is invalid.\\") if __name__ == \\"__main__\\": main() ``` With this implementation, you can test the validation of various date strings to ensure that the function behaves as expected and correctly identifies valid and invalid dates.","solution":"def validate_date(date_str: str) -> bool: try: year, month, day = map(int, date_str.split(\'-\')) if year <= 0: return False if not (1 <= month <= 12): return False if month in {1, 3, 5, 7, 8, 10, 12}: return 1 <= day <= 31 elif month in {4, 6, 9, 11}: return 1 <= day <= 30 elif month == 2: if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): return 1 <= day <= 29 # Leap year else: return 1 <= day <= 28 return False except ValueError: return False def main(): date_str = input(\\"Enter a date (YYYY-MM-DD): \\") if validate_date(date_str): print(\\"The date is valid.\\") else: print(\\"The date is invalid.\\") if __name__ == \\"__main__\\": main()"},{"question":"# Problem Statement You are given a text document that contains multiple lines of text. Your task is to write a function that finds and returns the longest word in the document. If there are multiple words with the same length, return the first one encountered. # Function Signature ```python def find_longest_word(document: list[str]) -> str: Find the longest word in the given text document. Parameters: document (list[str]): A list of strings, where each string represents a line in the document. Returns: str: The longest word found in the document. pass ``` # Input - **document**: A list of strings, where each string is a line of text. # Output - A string that represents the longest word in the document. If there are multiple words with the same length, return the first one encountered. # Example ```python document = [ \\"The quick brown fox\\", \\"jumps over the lazy dog\\", \\"and scares the pigeon away\\" ] # \\"scares\\" is the longest word in the document longest_word = find_longest_word(document) print(longest_word) # Expected output: \\"scares\\" ``` # Constraints - The document may contain punctuation marks. You should strip punctuation from words when considering their length. - Consider only alphabetic characters when determining word length. - The document will contain at least one word. - Words are case-insensitive for the purposes of this task, meaning \'Apple\' and \'apple\' should be treated as the same word.","solution":"import string def find_longest_word(document: list[str]) -> str: Find the longest word in the given text document. Parameters: document (list[str]): A list of strings, where each string represents a line in the document. Returns: str: The longest word found in the document. longest_word = \'\' for line in document: words = line.split() for word in words: # Strip punctuation from the word and convert to lower case clean_word = word.strip(string.punctuation).lower() if len(clean_word) > len(longest_word): longest_word = clean_word return longest_word"},{"question":"# Problem Description You need to write a Python function that simulates a simple pattern drawing on a 2D grid. Given the dimensions of the grid and a character to be used in drawing, the function will generate a square pattern where each diagonal line from the top-left to the bottom-right and from the top-right to the bottom-left is filled with the given character. # Function Signature ```python def draw_diagonal_pattern(n: int, char: str) -> List[str]: pass ``` # Input - `n`: An integer specifying the size of the grid where 1 ≤ n ≤ 50. - `char`: A single character string used for drawing the diagonal lines. # Output - Returns a list of strings representing the grid pattern. # Constraints - The character used in drawing will always be a single visible ASCII character. # Example ```python >>> draw_diagonal_pattern(5, \'*\') [\'* *\', \' * * \', \' * \', \' * * \', \'* *\'] >>> draw_diagonal_pattern(3, \'#\') [\'# #\', \' # \', \'# #\'] >>> draw_diagonal_pattern(1, \'A\') [\'A\'] >>> draw_diagonal_pattern(4, \'X\') [\'X X\', \' XX \', \' XX \', \'X X\'] ``` # Explanation - In the first example, the function creates a 5x5 grid with \'*\' on both diagonals. - In the second example, the function creates a 3x3 grid with \'#\' on the diagonals. Your function should construct the grid by iterating over rows and columns and placing the specified character `char` only on the appropriate diagonals. The positions not part of the pattern should be filled with spaces. This ensures the pattern is both visually distinct and centered within the given dimensions.","solution":"from typing import List def draw_diagonal_pattern(n: int, char: str) -> List[str]: Generates a grid of size n x n with diagonal lines from top-left to bottom-right and from top-right to bottom-left filled with the specified character. grid = [] for i in range(n): row = [\' \'] * n row[i] = char # Top-left to bottom-right diagonal row[n - i - 1] = char # Top-right to bottom-left diagonal grid.append(\'\'.join(row)) return grid"},{"question":"# Coding Assessment Question Problem Statement You are given a 2D matrix of dimensions `m x n` consisting of only ones (`1`) and zeros (`0`). Your task is to find the largest square, composed of ones, that can be found within the matrix. Implement a function `max_square(matrix: List[List[int]]) -> int` that returns the side length of the largest square found. # Function Signature ```python def max_square(matrix: List[List[int]]) -> int: ``` # Input * `matrix` (1 ≤ m, n ≤ 300): A 2D list of integers where each element is either `0` or `1`. # Output * Returns a single integer which is the side length of the largest square composed entirely of ones. # Constraints * The dimensions of the matrix ensure that processing should not exceed practical limits for time and space. * The matrix contains at least one element. # Performance Requirements * Aim for a solution with O(m*n) time complexity and O(m*n) space complexity. # Example ```python assert max_square([[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]) == 2 assert max_square([[0, 1], [1, 0]]) == 1 assert max_square([[0]]) == 0 assert max_square([[1, 1], [1, 1]]) == 2 ``` # Implementation Notes 1. **Dynamic Programming**: Use a DP table where `dp[i][j]` represents the side length of the largest square that ends at cell `(i, j)`. 2. **Transition**: For each cell `(i, j)` in the matrix, if it\'s a `1`, then `dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1`. If it\'s a `0`, then `dp[i][j] = 0`. 3. **Maximal Result**: Track the maximum value in the `dp` table to determine the side length of the largest square composed entirely of ones. 4. **Optimization**: Use a single 2D list for DP to save space if needed.","solution":"from typing import List def max_square(matrix: List[List[int]]) -> int: if not matrix: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] max_side_len = 0 for i in range(m): for j in range(n): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side_len = max(max_side_len, dp[i][j]) return max_side_len"},{"question":"# Context A company manages data for various departments, and each department\'s data is stored in a separate list. The system requires an efficient way to merge the data from all departments into a single sorted list without duplicates. # Problem Statement Write a function `merge_department_data(department_data: List[List[int]]) -> List[int]` that takes as input a list `department_data` of lists where each inner list contains integers representing the data of a single department. Merge all the department data into a single sorted list with no duplicates. # Function Signature ```python def merge_department_data(department_data: List[List[int]]) -> List[int]: Merges and sorts the data from multiple departments, removing duplicates. ``` # Input - `department_data`: A list of lists of integers where each inner list represents the data of a single department. Length of department_data can be up to (10^3) and length of an inner list can be up to (10^5). # Output - Returns a single list containing all unique integers from all the departments, sorted in ascending order. # Examples ```python assert merge_department_data([[1, 2, 3], [4, 5, 6], [3, 6, 9]]) == [1, 2, 3, 4, 5, 6, 9] assert merge_department_data([[10, 20], [20, 30], [30, 40, 50]]) == [10, 20, 30, 40, 50] assert merge_department_data([[100], [], [100, 200, 300], [100]]) == [100, 200, 300] assert merge_department_data([[], []]) == [] ``` # Constraints - The integers within the lists can be positive or negative and can be within the range of -10^9 to 10^9. - The solution should efficiently handle the merging and sorting process, considering the potentially large input sizes.","solution":"from typing import List def merge_department_data(department_data: List[List[int]]) -> List[int]: Merges and sorts the data from multiple departments, removing duplicates. unique_data = set() for department in department_data: unique_data.update(department) return sorted(unique_data)"},{"question":"# Coding Assessment Question You have been provided with the implementation of the popular n-gram model in natural language processing (NLP). To further test your understanding of NLP concepts, you are tasked with implementing a custom function to generate trigrams from a given input text. # Scenario Your task is to implement a function called `generate_trigrams`. A trigram is a contiguous sequence of three items from a given sample of text. The function should generate all possible trigrams from the input. # Function Definition Implement the function `generate_trigrams` that takes a string of text and returns a list of trigrams. # Mathematical Definition For an input string `text`, generate all possible trigrams, where a trigram is defined as a sequence of three consecutive words. # Function Signature ```python def generate_trigrams(text: str) -> List[Tuple[str, str, str]]: pass ``` # Input * `text` (str): A string of text containing words separated by spaces. # Output * Returns (List[Tuple[str, str, str]]): A list of tuples, each containing three consecutive words from the input text. # Constraints * The input `text` will consist of lowercase alphabetic words separated by single spaces. * There will be at least three words in the input text. # Performance Requirements Your implementation must generate the trigrams efficiently in O(N) time, where N is the number of words in the input text. # Examples ```python >>> generate_trigrams(\\"the quick brown fox jumps over the lazy dog\\") [(\'the\', \'quick\', \'brown\'), (\'quick\', \'brown\', \'fox\'), (\'brown\', \'fox\', \'jumps\'), (\'fox\', \'jumps\', \'over\'), (\'jumps\', \'over\', \'the\'), (\'over\', \'the\', \'lazy\'), (\'the\', \'lazy\', \'dog\')] >>> generate_trigrams(\\"i love natural language processing\\") [(\'i\', \'love\', \'natural\'), (\'love\', \'natural\', \'language\'), (\'natural\', \'language\', \'processing\')] ```","solution":"from typing import List, Tuple def generate_trigrams(text: str) -> List[Tuple[str, str, str]]: Generates all possible trigrams from the input text. Args: text (str): A string of text containing words separated by spaces. Returns: List[Tuple[str, str, str]]: A list of tuples, each containing three consecutive words from the text. words = text.split() return [(words[i], words[i+1], words[i+2]) for i in range(len(words) - 2)]"},{"question":"**Question:** Implement a function `longest_common_subsequence(seq1, seq2)` that finds the length of the longest subsequence present in both given sequences. A subsequence is a sequence that appears in the same relative order but not necessarily consecutively. # Function Signature ```python def longest_common_subsequence(seq1: str, seq2: str) -> int: pass ``` # Input * `seq1` (str): A string representing the first sequence. * `seq2` (str): A string representing the second sequence. # Output * Returns an integer value representing the length of the longest common subsequence. # Constraints * (1 leq text{len(seq1)}, text{len(seq2)} leq 1000) # Example ```python # Example 1 seq1 = \\"abcde\\" seq2 = \\"ace\\" print(longest_common_subsequence(seq1, seq2)) # Outputs 3 (The longest common subsequence is \\"ace\\") # Example 2 seq1 = \\"abc\\" seq2 = \\"abc\\" print(longest_common_subsequence(seq1, seq2)) # Outputs 3 (The longest common subsequence is \\"abc\\") # Example 3 seq1 = \\"abc\\" seq2 = \\"def\\" print(longest_common_subsequence(seq1, seq2)) # Outputs 0 (There is no common subsequence) ``` # Note: * The function should aim to be efficient, taking into consideration the time and space complexity. * Consider edge cases where one or both sequences might be empty. * Dynamic programming is an appropriate technique to solve this problem.","solution":"def longest_common_subsequence(seq1: str, seq2: str) -> int: Returns the length of the longest common subsequence in seq1 and seq2. m = len(seq1) n = len(seq2) # Create a 2D array to store the lengths of longest common subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array from the bottom up for i in range(1, m + 1): for j in range(1, n + 1): if seq1[i - 1] == seq2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"# Coin Change Variations You are given a set of coins of varying denominations and an integer amount representing a total amount of money. You need to determine the number of different ways to make up that amount using the given coins. You can assume that each coin has an infinite supply. Write a function `count_coin_ways(coins: List[int], amount: int) -> int` that returns the number of ways to make the amount using the given set of coins. # Input: - `coins` (List[int]): a list of integers representing the coin denominations. (1 <= len(coins) <= 50, 1 <= coins[i] <= 100) - `amount` (int): the total amount of money. (0 <= amount <= 1000) # Output: - (int): The number of different ways to make the amount using the given coins. # Example: ```python # Example Case 1 # Input: coins = [1, 2, 5], amount = 5 # Output: 4 # Explanation: There are four ways to make the amount: # 5 # 2 + 2 + 1 # 2 + 1 + 1 + 1 # 1 + 1 + 1 + 1 + 1 # Example Case 2 # Input: coins = [2], amount = 3 # Output: 0 # Explanation: It is not possible to make the amount 3 with an even-sized coin set. # Example Case 3 # Input: coins = [10], amount = 10 # Output: 1 # Explanation: There is only one way to make the amount 10, which is using the coin 10 alone. ``` # Constraints: - The integers in the coin list and the amount are non-negative and within the specified range. # Performance Requirement: Ensure your algorithm runs efficiently for the maximum input size (amount = 1000). # Hints: 1. Consider using a dynamic programming approach. 2. Create a DP array where the index represents each sub-amount up to the total amount. Write your function implementation below: ```python from typing import List def count_coin_ways(coins: List[int], amount: int) -> int: dp = [0] * (amount + 1) dp[0] = 1 for coin in coins: for x in range(coin, amount + 1): dp[x] += dp[x - coin] return dp[amount] # Testing the function print(count_coin_ways([1, 2, 5], 5)) # Output: 4 print(count_coin_ways([2], 3)) # Output: 0 print(count_coin_ways([10], 10)) # Output: 1 ```","solution":"from typing import List def count_coin_ways(coins: List[int], amount: int) -> int: dp = [0] * (amount + 1) dp[0] = 1 # Base case: there is one way to make amount 0 (use no coins) for coin in coins: for x in range(coin, amount + 1): dp[x] += dp[x - coin] return dp[amount]"},{"question":"# Coding Assessment Question Scenario You are developing a system that requires efficient computation of the product of elements in subarrays. You need to implement a class that supports efficient point updates and range product queries. Task Implement a class `ProductSegmentTree` that provides the functionality of point updates and querying the product of elements within a given range. # Class Definition ```python class ProductSegmentTree: def __init__(self, array: List[int]) -> None: # Initialize the class with a given array and build the segment tree def update(self, index: int, value: int) -> None: # Update the value at the given index def query(self, left: int, right: int) -> int: # Query the product of elements within the range [left, right) ``` # Method Details * **`__init__(self, array: List[int]) -> None`**: * Initializes the ProductSegmentTree with the given array and builds the segment tree for efficient queries and updates. * **`update(self, index: int, value: int) -> None`**: * Updates the value at the specified index with the given value and updates the segment tree accordingly. * **`query(self, left: int, right: int) -> int`**: * Queries the product of elements within the range `[left, right)`. * For example, if `left=1` and `right=4` in an array `[2, 3, 5, 7, 11]`, the product is (3 times 5 times 7 = 105). # Constraints * `1 <= len(array) <= 10^5` * `1 <= left < right <= len(array)` * Array elements `<= 10^9` * The product of elements in any query will fit within a 64-bit integer. # Output Format * Function method returns an integer. # Example ```python pst = ProductSegmentTree([2, 3, 5, 7, 11]) assert pst.query(1, 4) == 105 # The product of subarray [3, 5, 7] is 105 pst.update(2, 4) # Update the array to [2, 3, 4, 7, 11] assert pst.query(1, 4) == 84 # The product of subarray [3, 4, 7] is 84 ```","solution":"from typing import List class ProductSegmentTree: def __init__(self, array: List[int]) -> None: self.n = len(array) self.tree = [1] * (2 * self.n) self.build(array) def build(self, array: List[int]) -> None: # Initialize the leaf nodes for i in range(self.n): self.tree[self.n + i] = array[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i << 1] * self.tree[i << 1 | 1] def update(self, index: int, value: int) -> None: # Update the value at position `index` pos = index + self.n self.tree[pos] = value # Update the segment tree while pos > 1: pos >>= 1 self.tree[pos] = self.tree[pos << 1] * self.tree[pos << 1 | 1] def query(self, left: int, right: int) -> int: # Move the indices to correspond leaf nodes in the tree left += self.n right += self.n product = 1 while left < right: if left & 1: product *= self.tree[left] left += 1 if right & 1: right -= 1 product *= self.tree[right] left >>= 1 right >>= 1 return product"},{"question":"**Dynamic Programming: Coin Change Problem** A financial company is developing an application to assist customers in managing their coin transactions efficiently. Customers often need to make a specific amount using the fewest possible coins of given denominations. You are tasked with implementing a function that computes this efficiently. # Problem Statement You are given a list `coins` which represents the denominations of available coins and an integer `amount` representing the total amount of money. Write a function that returns the minimum number of coins required to make up the given amount. If it is not possible to make that amount with the given coin denominations, return `-1`. # Task Implement the function `coin_change(coins, amount)` that computes the minimum number of coins needed to make up the `amount`. # Expected Input and Output Formats ```python def coin_change(coins: List[int], amount: int) -> int: pass ``` - `coins`: A list of integers where each integer represents a coin denomination. - `amount`: An integer representing the total amount of money. **Output**: An integer representing the minimum number of coins required to make up the `amount`. If it is not possible, return `-1`. # Constraints 1. `1 <= len(coins) <= 200` 2. `1 <= coins[i] <= 10^6` 3. `0 <= amount <= 10^7` # Performance Requirements Your solution should utilize a dynamic programming approach to handle large amounts and diverse coin denominations efficiently. # Scenario Imagine you are developing a feature for a mobile wallet application that helps users break down their large bills into smaller denominations for easier transactions. # Example ```python coins = [1, 2, 5] amount = 11 print(coin_change(coins, amount)) # Output: 3 ``` In this example, the minimum number of coins required to make the amount 11 is 3, which can be done by using two 5-coin and one 1-coin. ```python coins = [2] amount = 3 print(coin_change(coins, amount)) # Output: -1 ``` In this example, it is not possible to make the amount 3 with the given coin of denomination 2. # Additional Example ```python coins = [1, 10, 25] amount = 30 print(coin_change(coins, amount)) # Output: 2 ``` In this example, the minimum number of coins required to make the amount 30 is 2, which can be done by using one 25-coin and one 5-coin.","solution":"from typing import List def coin_change(coins: List[int], amount: int) -> int: Function to compute the minimum number of coins required to make up the given amount. If it is not possible to make that amount with the given coin denominations, return -1. # Initialize a list with amount + 1 elements set to a high value (amount + 1) dp = [amount + 1] * (amount + 1) dp[0] = 0 # Base case, 0 coins are needed to make up amount 0 # Compute the minimum coins needed for all amounts from 1 to amount for i in range(1, amount + 1): for coin in coins: if coin <= i: dp[i] = min(dp[i], dp[i - coin] + 1) # If dp[amount] is still amount + 1, it means no combination can make up the amount return dp[amount] if dp[amount] != amount + 1 else -1"},{"question":"# Problem Statement Your task is to implement a function `missing_number(nums: List[int]) -> int` that finds the one missing number in an array containing `n` distinct numbers taken from the range `0` to `n`. # Requirements * **Input**: - `nums`: A list of `n` integers where each integer is unique and lies in the range [0, n]. The list will always be length `n` and contain `n-1` of the numbers from the complete range. * **Output**: - An integer representing the missing number in the list. # Function Signature ```python def missing_number(nums: List[int]) -> int: ``` # Examples *Example 1*: ```python print(missing_number([3, 0, 1])) # Output: 2 ``` *Example 2*: ```python print(missing_number([0, 1])) # Output: 2 ``` *Example 3*: ```python print(missing_number([9,6,4,2,3,5,7,0,1])) # Output: 8 ``` # Constraints 1. The length of the list `nums` is `n`, where `n` can range from 1 to 10^4. 2. The elements in the list `nums` are all unique numbers taken from the range `0` to `n`. # Notes 1. Implement an efficient solution that avoids performance bottlenecks. Consider both time and space complexity. 2. Think about using properties of arithmetic sequences to find the missing number. # Hint You may use the sum formula for the first `n` natural numbers and compare it to the sum of elements in the list to find the missing number.","solution":"from typing import List def missing_number(nums: List[int]) -> int: Returns the one missing number in an array containing n distinct numbers taken from the range 0 to n. n = len(nums) # Sum of first n natural numbers expected_sum = n * (n + 1) // 2 # Sum of elements in the nums list actual_sum = sum(nums) # The missing number is the difference between expected sum and actual sum return expected_sum - actual_sum"},{"question":"# Question **Context**: You are a software engineer at a tech company, and your team is working on a feature to recommend users potential friends based on shared interests. You have a large database of users where each user has a list of interests. Your task is to find pairs of users who share at least a specified minimum number of interests. **Task**: Develop a function that identifies pairs of users who share at least a given number of interests. **Function Signature**: ```python def find_shared_interests(users: dict[str, list[str]], min_shared_interests: int) -> list[tuple[str, str]]: Args: - users: A dictionary where keys are user IDs (strings) and values are lists of interests (strings). - min_shared_interests: The minimum number of shared interests for two users to be considered a pair. Returns: - A list of tuples, each containing a pair of user IDs (sorted alphabetically) who share at least the specified minimum number of interests. ``` **Requirements**: 1. Implement the function `find_shared_interests` that takes in: * `users`: A dictionary where keys are user IDs (strings) and values are lists of interests (strings). * `min_shared_interests`: An integer representing the minimum number of shared interests for two users to be considered a pair. 2. The function should return a list of tuples. Each tuple should contain: * A pair of user IDs (sorted alphabetically) who share at least `min_shared_interests` interests. 3. Use the provided docstrings for testing with examples to ensure the correctness of your implementation. **Examples**: ```python >>> users = { ... \'user1\': [\'music\', \'sports\', \'movies\'], ... \'user2\': [\'music\', \'movies\', \'reading\'], ... \'user3\': [\'hiking\', \'music\'], ... \'user4\': [\'sports\', \'movies\', \'reading\'] ... } >>> find_shared_interests(users, 2) [(\'user1\', \'user2\'), (\'user1\', \'user4\')] >>> users = { ... \'alice\': [\'cooking\', \'yoga\', \'reading\'], ... \'bob\': [\'cooking\', \'cycling\'], ... \'carol\': [\'yoga\', \'reading\'], ... \'dave\': [\'reading\', \'movies\'] ... } >>> find_shared_interests(users, 1) [(\'alice\', \'bob\'), (\'alice\', \'carol\'), (\'alice\', \'dave\'), (\'carol\', \'dave\')] ``` **Constraints**: * The dictionary can contain up to (10^4) users. * Each list of interests can have up to (10^2) items. Interests are represented as strings and are unique within the list. * The length of each interest string does not exceed 50 characters. Good luck, and happy coding!","solution":"from itertools import combinations def find_shared_interests(users: dict[str, list[str]], min_shared_interests: int) -> list[tuple[str, str]]: Args: - users: A dictionary where keys are user IDs (strings) and values are lists of interests (strings). - min_shared_interests: The minimum number of shared interests for two users to be considered a pair. Returns: - A list of tuples, each containing a pair of user IDs (sorted alphabetically) who share at least the specified minimum number of interests. result = [] # Create all combinations of user pairs user_pairs = combinations(users.keys(), 2) for u1, u2 in user_pairs: shared_interests = set(users[u1]) & set(users[u2]) if len(shared_interests) >= min_shared_interests: result.append(tuple(sorted([u1, u2]))) return result"},{"question":"# Scenario You are developing a program that tracks and manages the inventory of an online bookstore. Your task is to ensure the integrity and accuracy of the inventory data while performing various operations like stock updates, processing orders, and generating a summary report. # Task Write a Python class `BookstoreInventory` that includes the following methods: 1. `__init__` Initializes the inventory with a dictionary where keys are book titles (strings) and values are the number of copies available (integers). 2. `update_stock(title, quantity)` Updates the stock for a given title by adding the specified quantity. If the title does not exist, it should be added to the inventory. 3. `process_order(title, quantity)` Processes an order for the given title and quantity. If the quantity requested is available, it should be deducted from the inventory; if not, it should print \\"Insufficient stock for [title]\\". 4. `generate_report()` Generates and prints a summary report of the current inventory, listing book titles and their available quantities. # Requirements - Implement the core functionality for inventory management. - Ensure stock levels are accurately updated based on operations. - Provide meaningful output messages for operations such as stock updates and order processing. # Constraints - Book titles are case-sensitive and unique in the inventory. - All inventory operations must maintain data integrity. - Use only standard libraries. # Example ```python class BookstoreInventory: def __init__(self, initial_inventory): pass def update_stock(self, title, quantity): pass def process_order(self, title, quantity): pass def generate_report(self): pass # Example usage: inventory = BookstoreInventory({ \\"Harry Potter\\": 10, \\"The Hobbit\\": 5, \\"1984\\": 8 }) inventory.update_stock(\\"The Great Gatsby\\", 3) inventory.process_order(\\"1984\\", 2) inventory.process_order(\\"The Hobbit\\", 6) inventory.generate_report() # Expected Output: # Insufficient stock for The Hobbit # Harry Potter: 10 # The Hobbit: 5 # 1984: 6 # The Great Gatsby: 3 ``` # Notes - The methods should work for various scenarios beyond the example provided. - Raise appropriate errors if input constraints are violated.","solution":"class BookstoreInventory: def __init__(self, initial_inventory): Initializes the inventory with a dictionary where keys are book titles (strings) and values are the number of copies available (integers). self.inventory = initial_inventory def update_stock(self, title, quantity): Updates the stock for a given title by adding the specified quantity. If the title does not exist, it should be added to the inventory. if title in self.inventory: self.inventory[title] += quantity else: self.inventory[title] = quantity def process_order(self, title, quantity): Processes an order for the given title and quantity. If the quantity requested is available, it should be deducted from the inventory; if not, it should print \\"Insufficient stock for [title]\\". if title in self.inventory and self.inventory[title] >= quantity: self.inventory[title] -= quantity else: print(f\\"Insufficient stock for {title}\\") def generate_report(self): Generates and prints a summary report of the current inventory, listing book titles and their available quantities. for title, quantity in self.inventory.items(): print(f\\"{title}: {quantity}\\")"},{"question":"# Question: Validate and Parse Nested JSON Strings **Scenario**: You are part of a team developing a data integration platform that receives data from various sources in JSON format. You need to validate and parse the JSON strings to ensure they meet certain requirements before they are processed further. The JSON structure can be nested, so your solution must handle these complexities. **Function to Implement**: Implement the function `parse_json(json_str: Any) -> Any` that takes a JSON string, validates it, and returns the parsed JSON object. The function should also ensure the structure is correctly formatted and handles any potential errors. **Requirements**: 1. Validate that the input is a string. 2. Check that the string is a valid JSON format and can be parsed. 3. The JSON string should not be empty once trimmed of whitespace. 4. Handle nested JSON structures gracefully. **Input**: - A single value, `json_str`, which should be validated to be a proper JSON string. **Output**: - The parsed JSON object if the input is valid. **Constraints**: - If `json_str` is not a string, raise a `TypeError`. - If `json_str` is an invalid JSON format, raise a `ValueError`. - If `json_str` is a valid JSON but results in an empty structure (e.g., empty object or array), raise a `ValueError`. **Example Cases**: ```python >>> parse_json(\'{\\"name\\": \\"Alice\\", \\"age\\": 30}\') {\'name\': \'Alice\', \'age\': 30} >>> parse_json(\'{\\"data\\": {\\"items\\": [{\\"id\\": 1}, {\\"id\\": 2}]}}\') {\'data\': {\'items\': [{\'id\': 1}, {\'id\': 2}]}} >>> parse_json(\' {\\"key\\": \\"value\\"} \') {\'key\': \'value\'} >>> parse_json(\'\') Traceback (most recent call last): ... ValueError: JSON string is empty or not properly formatted. >>> parse_json(\'{}\') {} >>> parse_json(\'{\\"empty\\": []}\') {\'empty\': []} >>> parse_json(123) Traceback (most recent call last): ... TypeError: Input value must be a string >>> parse_json(\'Invalid JSON\') Traceback (most recent call last): ... ValueError: JSON string is empty or not properly formatted. ``` **Function Template**: ```python import json from typing import Any def parse_json(json_str: Any) -> Any: Validate and parse a JSON string, handling nested structures properly. :param json_str: Input string to parse :return: Parsed JSON object :raises ValueError: If the string is an invalid JSON format or empty after parsing :raises TypeError: If input is not a string if not isinstance(json_str, str): raise TypeError(\\"Input value must be a string\\") json_str = json_str.strip() if not json_str: raise ValueError(\\"JSON string is empty or not properly formatted.\\") try: parsed_json = json.loads(json_str) if parsed_json == \\"\\" or parsed_json == {} or parsed_json == []: raise ValueError(\\"JSON string is empty or not properly formatted.\\") return parsed_json except json.JSONDecodeError: raise ValueError(\\"JSON string is empty or not properly formatted.\\") if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"import json from typing import Any def parse_json(json_str: Any) -> Any: Validate and parse a JSON string, handling nested structures properly. :param json_str: Input string to parse :return: Parsed JSON object :raises ValueError: If the string is an invalid JSON format or empty after parsing :raises TypeError: If input is not a string if not isinstance(json_str, str): raise TypeError(\\"Input value must be a string\\") json_str = json_str.strip() if not json_str: raise ValueError(\\"JSON string is empty or not properly formatted.\\") try: parsed_json = json.loads(json_str) if parsed_json == \\"\\" or parsed_json == {} or parsed_json == []: raise ValueError(\\"JSON string is empty or not properly formatted.\\") return parsed_json except json.JSONDecodeError: raise ValueError(\\"JSON string is empty or not properly formatted.\\")"},{"question":"# Question: Validating and Parsing Phone Numbers You are given the task to validate and parse phone numbers. A valid phone number should follow the North American Numbering Plan (NANP) format: a three-digit area code followed by a seven-digit local number (e.g., `123-456-7890`). Your role is to write a Python function that validates a phone number string and returns a parsed representation if valid, else returns `None`. Function Signature ```python def validate_and_parse_phone_number(phone_number: str) -> dict: ``` Input - `phone_number`: a string representing a phone number. The phone number should be in the format: `XXX-XXX-XXXX`, where `X` is a digit from 0 to 9. Output - A dictionary with two keys, `area_code` and `local_number`, containing the parsed parts of the phone number if valid. - `area_code` is a string of the three-digit area code. - `local_number` is a string of the seven-digit local number. - Return `None` if the phone number is invalid. Constraints - The phone number will be a string. - The phone number could contain whitespaces at the beginning or end, which should be ignored. Example ```python >>> validate_and_parse_phone_number(\\"123-456-7890\\") {\'area_code\': \'123\', \'local_number\': \'4567890\'} >>> validate_and_parse_phone_number(\\"234-567-8901\\") {\'area_code\': \'234\', \'local_number\': \'5678901\'} >>> validate_and_parse_phone_number(\\"invalid-number\\") None >>> validate_and_parse_phone_number(\\" 345-678-9012 \\") {\'area_code\': \'345\', \'local_number\': \'6789012\'} >>> validate_and_parse_phone_number(\\"1234567890\\") None ``` Performance Requirements - Ensure the function accurately identifies valid and invalid phone numbers within a reasonable time frame. - Implement input validation effectively to handle edge cases. # Additional Guidelines - Use regular expressions or built-in string methods where appropriate. - Provide meaningful comments to explain your logic, especially for handling edge cases.","solution":"import re def validate_and_parse_phone_number(phone_number: str) -> dict: Validates and parses a phone number that follows the North American Numbering Plan (NANP). A valid phone number should be in the format: XXX-XXX-XXXX. Args: phone_number (str): The phone number string. Returns: dict: A dictionary with \'area_code\' and \'local_number\' if valid, else None. # Trim any leading or trailing whitespaces phone_number = phone_number.strip() # Regular expression to match the NANP format pattern = re.compile(r\\"^(d{3})-(d{3})-(d{4})\\") match = pattern.match(phone_number) if match: return { \'area_code\': match.group(1), \'local_number\': match.group(2) + match.group(3) } else: return None"},{"question":"# Conversion Between Date Formats You are tasked with implementing a function that converts a date from one string format to another. The input and output formats are given as arguments to the function. The possible formats are: - \\"YYYY-MM-DD\\": Year-Month-Day format, e.g., \\"2023-10-25\\" - \\"MM/DD/YYYY\\": Month/Day/Year format, e.g., \\"10/25/2023\\" - \\"DD-MM-YYYY\\": Day-Month-Year format, e.g., \\"25-10-2023\\" # Function Signature ```python def convert_date_format(date_str: str, current_format: str, target_format: str) -> str: pass ``` # Input * `date_str`: A string representing the date in the `current_format`. * `current_format`: A string representing the current format of the `date_str`. One of \\"YYYY-MM-DD\\", \\"MM/DD/YYYY\\", or \\"DD-MM-YYYY\\". * `target_format`: A string representing the desired format for the output date string. One of \\"YYYY-MM-DD\\", \\"MM/DD/YYYY\\", or \\"DD-MM-YYYY\\". # Output * A string representing the date in the `target_format`. # Constraints * The date string will always be valid and in the correct `current_format`. * Both `current_format` and `target_format` will always be one of the three specified formats. # Example Consider the following scenarios: 1. Input: `date_str = \\"2023-10-25\\"`, `current_format = \\"YYYY-MM-DD\\"`, `target_format = \\"MM/DD/YYYY\\"` - Output: `\\"10/25/2023\\"` 2. Input: `date_str = \\"10/25/2023\\"`, `current_format = \\"MM/DD/YYYY\\"`, `target_format = \\"DD-MM-YYYY\\"` - Output: `\\"25-10-2023\\"` # Constraints & Edge Cases * Handling different separators (\'-\', \'/\') correctly. * Ensuring correct parsing and recombination of date components without altering their value. # Performance * Your solution should accurately and efficiently perform the conversion even if the date components are at the edge of their ranges (e.g., leap years). Write your implementation of the `convert_date_format` function:","solution":"def convert_date_format(date_str: str, current_format: str, target_format: str) -> str: Converts a date from one string format to another. :param date_str: A string representing the date in the current_format. :param current_format: A string representing the current format of the date_str. :param target_format: A string representing the desired format for the output date string. :return: A string representing the date in the target_format. date_parts = {} if current_format == \\"YYYY-MM-DD\\": date_parts[\'year\'], date_parts[\'month\'], date_parts[\'day\'] = date_str.split(\'-\') elif current_format == \\"MM/DD/YYYY\\": date_parts[\'month\'], date_parts[\'day\'], date_parts[\'year\'] = date_str.split(\'/\') elif current_format == \\"DD-MM-YYYY\\": date_parts[\'day\'], date_parts[\'month\'], date_parts[\'year\'] = date_str.split(\'-\') if target_format == \\"YYYY-MM-DD\\": return f\\"{date_parts[\'year\']}-{date_parts[\'month\']}-{date_parts[\'day\']}\\" elif target_format == \\"MM/DD/YYYY\\": return f\\"{date_parts[\'month\']}/{date_parts[\'day\']}/{date_parts[\'year\']}\\" elif target_format == \\"DD-MM-YYYY\\": return f\\"{date_parts[\'day\']}-{date_parts[\'month\']}-{date_parts[\'year\']}\\""},{"question":"# Given Context You have been asked to improve the functionality of a Python script that processes and analyzes log files from various servers. The current implementation efficiently reads and processes a single file, but the requirement is to extend it to handle multiple files concurrently, due to the growing volume of log data. # Task 1. Modify the `process_log_files` function to accept a list of log file paths and process them concurrently using Python\'s `concurrent.futures` module. 2. Ensure that errors in processing one file do not stop the processing of other files. Collect and return the errors if any. # Input and Output Formats * **Function to modify**: * `process_log_files` - Will now take a list of log file paths and process them concurrently. * **Constraints**: * The processing of log files should be done concurrently. * Handle exceptions for individual files and return a list of any errors encountered. * Do not alter the existing log processing logic; only refactor it to enable concurrent execution. # Example Scenario Assume you have multiple log files located on different servers. Your updated script should be able to handle the reading and processing of these log files concurrently, improving overall efficiency and handling any file-specific errors. # Starter Code ```python import concurrent.futures import os def process_log_file(file_path: str) -> dict: Processes a single log file and extracts relevant information. result = {} try: with open(file_path, \'r\') as file: # Simulated log processing logic for line in file: # Extract some data from the log file and store it in the result dictionary pass except Exception as e: result[\'error\'] = str(e) return result def process_log_files(file_paths: list[str]) -> list[dict]: Processes multiple log files concurrently and returns their results. results = [] with concurrent.futures.ThreadPoolExecutor() as executor: future_to_file = {executor.submit(process_log_file, file_path): file_path for file_path in file_paths} for future in concurrent.futures.as_completed(future_to_file): file_path = future_to_file[future] try: result = future.result() if \'error\' in result: results.append({\'file\': file_path, \'error\': result[\'error\']}) else: results.append({\'file\': file_path, \'result\': result}) except Exception as exc: results.append({\'file\': file_path, \'error\': str(exc)}) return results # Example usage log_files = [\'/path/to/log1.txt\', \'/path/to/log2.txt\', \'/path/to/log3.txt\'] print(process_log_files(log_files)) ``` # Expected Output A list of dictionaries where each dictionary contains the file path and the respective results or errors encountered during processing. ```python [ {\'file\': \'/path/to/log1.txt\', \'result\': {...}}, {\'file\': \'/path/to/log2.txt\', \'error\': \'FileNotFoundError: [Errno 2] No such file or directory: /path/to/log2.txt\'}, {\'file\': \'/path/to/log3.txt\', \'result\': {...}} ] ```","solution":"import concurrent.futures import os def process_log_file(file_path: str) -> dict: Processes a single log file and extracts relevant information. result = {} try: with open(file_path, \'r\') as file: # Simulated log processing logic for line in file: # Extract some data from the log file and store it in the result dictionary result[line] = line.strip() # Example processing logic except Exception as e: result[\'error\'] = str(e) return result def process_log_files(file_paths: list[str]) -> list[dict]: Processes multiple log files concurrently and returns their results. results = [] with concurrent.futures.ThreadPoolExecutor() as executor: future_to_file = {executor.submit(process_log_file, file_path): file_path for file_path in file_paths} for future in concurrent.futures.as_completed(future_to_file): file_path = future_to_file[future] try: result = future.result() if \'error\' in result: results.append({\'file\': file_path, \'error\': result[\'error\']}) else: results.append({\'file\': file_path, \'result\': result}) except Exception as exc: results.append({\'file\': file_path, \'error\': str(exc)}) return results # Example usage log_files = [\'/path/to/log1.txt\', \'/path/to/log2.txt\', \'/path/to/log3.txt\'] print(process_log_files(log_files))"},{"question":"**Object-Oriented Design for a Simple Banking System** You are required to implement a simple banking system using object-oriented programming principles. The system should allow users to create accounts, deposit money, withdraw money, and check balances. Your task is to implement the following classes: 1. **Account** - **Attributes**: - `account_number` (int): The unique identifier for the account. - `balance` (float): The current balance in the account, default is 0. - **Methods**: - `__init__(self, account_number: int, initial_balance: float = 0)`: Constructor to initialize the account with a unique number and an optional initial balance. - `deposit(self, amount: float) -> None`: Method to deposit an amount into the account. Amount should be positive, otherwise raise `ValueError`. - `withdraw(self, amount: float) -> None`: Method to withdraw an amount from the account. Amount should be positive and should not exceed the current balance, otherwise raise `ValueError`. - `get_balance(self) -> float`: Method to get the current balance of the account. 2. **Bank** - **Attributes**: - `accounts` (list): A list to store all account instances. - **Methods**: - `__init__(self)`: Constructor to initialize the bank with an empty list of accounts. - `create_account(self, account_number: int, initial_balance: float = 0) -> Account`: Method to create a new account with a unique account number and an optional initial balance. If the account number already exists, raise a `ValueError`. - `get_account(self, account_number: int) -> Account`: Method to retrieve an account by its number. If no account found, raise a `ValueError`. - `total_funds(self) -> float`: Method to compute and return the total funds across all accounts in the bank. # Function Signature ```python class Account: def __init__(self, account_number: int, initial_balance: float = 0): pass def deposit(self, amount: float) -> None: pass def withdraw(self, amount: float) -> None: pass def get_balance(self) -> float: pass class Bank: def __init__(self): pass def create_account(self, account_number: int, initial_balance: float = 0) -> Account: pass def get_account(self, account_number: int) -> Account: pass def total_funds(self) -> float: pass ``` # Example ```python # Example workflow bank = Bank() # Creating accounts account_1 = bank.create_account(account_number=1, initial_balance=100.0) account_2 = bank.create_account(account_number=2) # Depositing to accounts account_1.deposit(50) account_2.deposit(200) # Withdrawing from accounts account_1.withdraw(30) # Checking balance print(account_1.get_balance()) # Output: 120.0 print(account_2.get_balance()) # Output: 200.0 # Getting account by number account = bank.get_account(1) print(account.get_balance()) # Output: 120.0 # Total funds in the bank print(bank.total_funds()) # Output: 320.0 ``` # Hints - Ensure proper validation and error handling for deposits and withdrawals. - Use appropriate error messages for raised exceptions. - Maintain the encapsulation of account data and methods within their respective classes. By following these guidelines, the question integrates seamlessly with the original set, maintaining consistency in style, complexity, and scope.","solution":"class Account: def __init__(self, account_number: int, initial_balance: float = 0.0): self.account_number = account_number self.balance = initial_balance def deposit(self, amount: float) -> None: if amount <= 0: raise ValueError(\\"Deposit amount must be positive\\") self.balance += amount def withdraw(self, amount: float) -> None: if amount <= 0: raise ValueError(\\"Withdraw amount must be positive\\") if amount > self.balance: raise ValueError(\\"Insufficient funds\\") self.balance -= amount def get_balance(self) -> float: return self.balance class Bank: def __init__(self): self.accounts = [] def create_account(self, account_number: int, initial_balance: float = 0.0) -> Account: if any(acc.account_number == account_number for acc in self.accounts): raise ValueError(\\"Account number already exists\\") new_account = Account(account_number, initial_balance) self.accounts.append(new_account) return new_account def get_account(self, account_number: int) -> Account: for account in self.accounts: if account.account_number == account_number: return account raise ValueError(\\"Account not found\\") def total_funds(self) -> float: return sum(account.get_balance() for account in self.accounts)"},{"question":"# Coding Assessment Question **Problem Statement:** Implement a system to manage a social network\'s friend recommendations. Given a social network represented as an undirected graph where nodes are users and edges are friendships, implement functions that can recommend friends who are 2 degrees away (friends of friends but not direct friends or the user themselves) and find the shortest path of friendships between two users if it exists. **Function Signatures**: ```python def recommend_friends(user: int, network: Dict[int, List[int]]) -> List[int]: def shortest_friendship_path(user1: int, user2: int, network: Dict[int, List[int]]) -> List[int]: ``` **Expected Input/Output**: - `recommend_friends` function will take an integer `user` representing the user ID and a dictionary `network` where keys are user IDs and values are lists of user IDs that represent direct friends. - `shortest_friendship_path` function will take two integers `user1` and `user2` representing the user IDs and the same `network` dictionary as above. **Constraints**: - The network may contain up to 10,000 users. - The graph is guaranteed to be connected. - The graph will not have more than 100,000 edges. - There will be no duplicate edges. **Example**: Given a social network as: ```python network = { 1: [2, 3], 2: [1, 4], 3: [1, 5], 4: [2, 6], 5: [3], 6: [4, 7], 7: [6] } ``` **Output**: - `recommend_friends(1, network)` should return [4, 5] (users 4 and 5 are friends of friends but not direct friends of user 1) - `shortest_friendship_path(1, 6, network)` should return [1, 2, 4, 6] (the shortest path from user 1 to user 6 is through users 2 and 4) **Note**: - For `recommend_friends`, ensure the returning users are not direct friends or the user themselves. - For `shortest_friendship_path`, if there are multiple paths with the same shortest length, return any one of them. - Consider edge cases such as requesting recommendations for a user with no friends or trying to find a path between the same user.","solution":"from typing import List, Dict from collections import deque def recommend_friends(user: int, network: Dict[int, List[int]]) -> List[int]: Recommend friends to the user who are friends of friends but not direct friends or the user themselves. direct_friends = set(network.get(user, [])) potential_friends = set() for friend in direct_friends: for fof in network.get(friend, []): if fof != user and fof not in direct_friends: potential_friends.add(fof) return list(potential_friends) def shortest_friendship_path(user1: int, user2: int, network: Dict[int, List[int]]) -> List[int]: Find the shortest path of friendships between two users if it exists. if user1 == user2: return [user1] queue = deque([(user1, [user1])]) visited = set([user1]) while queue: current, path = queue.popleft() for neighbor in network.get(current, []): if neighbor == user2: return path + [user2] if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return [] # if no path exists"},{"question":"# Distance Calculation: Great-circle Distance Problem Statement: The great-circle distance is the shortest distance between two points on the surface of a sphere, measured along the surface of the sphere. The most common application of this concept is determining the shortest route between points on the globe. You are required to implement a Python function `great_circle_distance` which calculates the great-circle distance between two points on the Earth\'s surface, given their latitude and longitude using the haversine formula. Function Signature ```python def great_circle_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float: ``` Inputs - `lat1`: Latitude of the first point in degrees (as a float) - `lon1`: Longitude of the first point in degrees (as a float) - `lat2`: Latitude of the second point in degrees (as a float) - `lon2`: Longitude of the second point in degrees (as a float) Output - Returns a float representing the distance between the two points in kilometers. Notes - For the sake of this calculation, assume the radius of the Earth is 6371.0 kilometers. - Latitude values are between -90 and 90 degrees. - Longitude values are between -180 and 180 degrees. Example Usage: ```python # Example 1 print(great_circle_distance(52.2296756, 21.0122287, 41.8919300, 12.5113300)) # Expected output: ~1318.13 km # Example 2 print(great_circle_distance(36.12, -86.67, 33.94, -118.40)) # Expected output: ~2886.45 km # Example 3 (Equator Crossing) print(great_circle_distance(0, 0, 0, 90)) # Expected output: ~10007.54 km ``` # Implementation: Here is the Python implementation of the `great_circle_distance` function: ```python import math def great_circle_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float: # Convert latitude and longitude from degrees to radians lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2]) # Haversine formula to calculate the great-circle distance dlat = lat2 - lat1 dlon = lon2 - lon1 a = math.sin(dlat / 2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2)**2 c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a)) # Radius of earth in kilometers (mean radius) R = 6371.0 distance = R * c return distance ``` This problem should provide a challenge comparable to the original question and assess the candidate\'s ability to work with trigonometric functions and mathematical calculations in Python.","solution":"import math def great_circle_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float: Calculate the great-circle distance between two points on the Earth\'s surface given their latitude and longitude using the haversine formula. Args: lat1 (float): Latitude of the first point in degrees. lon1 (float): Longitude of the first point in degrees. lat2 (float): Latitude of the second point in degrees. lon2 (float): Longitude of the second point in degrees. Returns: float: Distance between the two points in kilometers. # Convert latitude and longitude from degrees to radians lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2]) # Haversine formula to calculate the great-circle distance dlat = lat2 - lat1 dlon = lon2 - lon1 a = math.sin(dlat / 2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2)**2 c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a)) # Radius of earth in kilometers (mean radius) R = 6371.0 distance = R * c return distance"},{"question":"# Context Consider you are part of a development team working on a software for a financial institution to assist users in managing their personal finances by tracking their income and expenses. The software includes features such as auto-categorizing transactions based on descriptions and tags, generating reports, and providing insights to users. # Task Implement a function `categorize_transaction(description: str) -> str` that automatically categorizes a transaction based on its description. The function should use a predefined dictionary that maps keywords to categories. If no keywords are found in the description, categorize the transaction as \\"Miscellaneous\\". # Input Requirements 1. `description`: A string representing the transaction description. # Output Format A string representing the category of the transaction. # Predefined Categories Use the following dictionary for keyword-to-category mapping: ```python categories = { \\"grocery\\": [\\"walmart\\", \\"supermarket\\", \\"groceries\\"], \\"utilities\\": [\\"electric\\", \\"water\\", \\"gas\\", \\"utility\\"], \\"entertainment\\": [\\"movie\\", \\"netflix\\", \\"amusement\\"], \\"restaurant\\": [\\"restaurant\\", \\"dining\\", \\"cafe\\"], \\"transportation\\": [\\"taxi\\", \\"uber\\", \\"bus\\", \\"fuel\\"], \\"healthcare\\": [\\"hospital\\", \\"pharmacy\\", \\"doctor\\"] } ``` # Constraints & Considerations - **Constraints**: - Raise a **TypeError** if the input is not a string. - The categorization should be case-insensitive. - In case multiple categories match the description, return any one of the applicable categories. # Function Signature In the implementation, ensure to define the function signature as follows: ```python def categorize_transaction(description: str) -> str: pass ``` # Example ```python >>> categorize_transaction(\\"Paid at Walmart for groceries\\") \'grocery\' >>> categorize_transaction(\\"Monthly gas bill payment\\") \'autotility\' >>> categorize_transaction(\\"Movie night with friends\\") \'entertainment\' >>> categorize_transaction(\\"Lunch at a cafe downtown\\") \'restaurant\' >>> categorize_transaction(\\"Gift for a friend\\") \'miscellaneous\' >>> categorize_transaction(12345) Traceback (most recent call last): ... TypeError: Description must be a string. ```","solution":"def categorize_transaction(description: str) -> str: Automatically categorizes a transaction based on its description using predefined keywords. Args: description (str): A string representing the transaction description. Returns: str: The category of the transaction. Raises: TypeError: If the input is not a string. if not isinstance(description, str): raise TypeError(\\"Description must be a string.\\") categories = { \\"grocery\\": [\\"walmart\\", \\"supermarket\\", \\"groceries\\"], \\"utilities\\": [\\"electric\\", \\"water\\", \\"gas\\", \\"utility\\"], \\"entertainment\\": [\\"movie\\", \\"netflix\\", \\"amusement\\"], \\"restaurant\\": [\\"restaurant\\", \\"dining\\", \\"cafe\\"], \\"transportation\\": [\\"taxi\\", \\"uber\\", \\"bus\\", \\"fuel\\"], \\"healthcare\\": [\\"hospital\\", \\"pharmacy\\", \\"doctor\\"] } description = description.lower() for category, keywords in categories.items(): for keyword in keywords: if keyword in description: return category return \\"miscellaneous\\""},{"question":"# Array Reversal Challenge Given an array of integers, write a function `reverse_array(arr: List[int]) -> List[int]` that reverses the order of elements in the array without using any built-in list reversal functions. Input * A list of integers `arr` containing any integer values (length ≤ 10^5). Output * A list of integers with the order of elements reversed. Constraints * The input list can contain any integer values (positive, negative, or zero). * You should not use built-in list methods such as `list.reverse()` in your implementation. Example ```python assert reverse_array([1, 2, 3]) == [3, 2, 1] assert reverse_array([4, -5, 6, 7]) == [7, 6, -5, 4] assert reverse_array([0, 0, 0]) == [0, 0, 0] assert reverse_array([]) == [] ``` # Context You are developing a tool that performs a series of operations on data sets, where reversing the data is a common requirement. Due to the need for custom solutions in some environments, you cannot rely on built-in functions and must implement the reversal using fundamental programming constructs. # Notes Consider handling edge cases such as: * Arrays that contain only one element. * Arrays with mixed positive and negative integers. * Empty arrays. Your solution should be optimized to handle large arrays effectively within the given constraints.","solution":"from typing import List def reverse_array(arr: List[int]) -> List[int]: Returns a new list that is the reverse of the input list arr. Parameters: arr (List[int]): The input list of integers to be reversed. Returns: List[int]: A new list with elements in reverse order. reversed_arr = [] for i in range(len(arr)-1, -1, -1): reversed_arr.append(arr[i]) return reversed_arr"},{"question":"# Question: Write a Function to Check for a Winning Tic-Tac-Toe Board You are asked to implement a function that checks if a given Tic-Tac-Toe board position has a winner. In Tic-Tac-Toe, two players take turns marking spaces in a 3x3 grid. The player who succeeds in placing three of their marks in a horizontal, vertical, or diagonal row is the winner. # Function Signature ```python def check_winner(board: List[List[str]]) -> str: pass ``` # Input - A 3x3 list of lists `board` representing the Tic-Tac-Toe board, where each cell can contain \'X\', \'O\', or be empty \'\'. # Output - Return \'X\' if player X has won, \'O\' if player O has won, or \'No Winner\' if there is no winner. # Constraints - `board` always has a size of 3x3. - Each cell contains either \'X\', \'O\', or \'\'. # Examples 1. **Input**: `[ [\'X\', \'X\', \'X\'], [\'O\', \'\', \'O\'], [\'\', \'\', \'\'] ]` - **Output**: `\'X\'` 2. **Input**: `[ [\'X\', \'O\', \'X\'], [\'O\', \'O\', \'O\'], [\'X\', \'\', \'X\'] ]` - **Output**: `\'O\'` 3. **Input**: `[ [\'X\', \'O\', \'X\'], [\'O\', \'\', \'X\'], [\'O\', \'\', \'\'] ]` - **Output**: `\'No Winner\'` # Sample Test ```python assert check_winner([ [\'X\', \'X\', \'X\'], [\'O\', \'\', \'O\'], [\'\', \'\', \'\'] ]) == \'X\' assert check_winner([ [\'X\', \'O\', \'X\'], [\'O\', \'O\', \'O\'], [\'X\', \'\', \'X\'] ]) == \'O\' assert check_winner([ [\'X\', \'O\', \'X\'], [\'O\', \'\', \'X\'], [\'O\', \'\', \'\'] ]) == \'No Winner\' ``` # Hint Inspect each row, column, and diagonal to determine if all cells contain the same marker (\'X\' or \'O\'). Note that an empty cell should not be considered as part of a winning combination.","solution":"from typing import List def check_winner(board: List[List[str]]) -> str: # Checking Rows and Columns for i in range(3): # Check Row if board[i][0] == board[i][1] == board[i][2] != \'\': return board[i][0] # Check Column if board[0][i] == board[1][i] == board[2][i] != \'\': return board[0][i] # Checking Diagonals if board[0][0] == board[1][1] == board[2][2] != \'\': return board[0][0] if board[0][2] == board[1][1] == board[2][0] != \'\': return board[0][2] return \'No Winner\'"},{"question":"# Problem Statement Implement a feature to validate and correct common date formats in textual data. You need to write two functions: 1. `is_valid_date(date_str: str) -> bool` 2. `correct_date_format(date_str: str) -> str` # Function Specifications 1. is_valid_date(date_str: str) -> bool * Checks if the provided string is a valid date in the formats `YYYY-MM-DD`, `DD-MM-YYYY`, or `MM/DD/YYYY`. * **Input**: A string representing a date. * **Output**: A boolean indicating whether the date string is valid. Example: ```python >>> is_valid_date(\'2023-10-15\') True >>> is_valid_date(\'15-10-2023\') True >>> is_valid_date(\'10/15/2023\') True >>> is_valid_date(\'2023/10/15\') False >>> is_valid_date(\'2023-13-01\') False ``` 2. correct_date_format(date_str: str) -> str * Converts a date in any of the valid formats (`YYYY-MM-DD`, `DD-MM-YYYY`, or `MM/DD/YYYY`) to the standard format `YYYY-MM-DD`. If the date string is invalid, return `\\"Invalid date\\"`. * **Input**: A string representing a date. * **Output**: A string representing the date in the standardized `YYYY-MM-DD` format, or `\\"Invalid date\\"` if the input is not valid. Example: ```python >>> correct_date_format(\'15-10-2023\') \'2023-10-15\' >>> correct_date_format(\'10/15/2023\') \'2023-10-15\' >>> correct_date_format(\'2023-10-15\') \'2023-10-15\' >>> correct_date_format(\'2023/10/15\') \'Invalid date\' >>> correct_date_format(\'2023-13-01\') \'Invalid date\' ``` # Constraints * Assume the input strings contain only valid date characters (`digits`, `-`, `/`). * The year will always be represented by four digits. * The month and day will always be represented by two digits. * The provided dates follow the calendar rules. # Requirements 1. Implement robust date validation to handle common formats and identify obvious errors (e.g., `month` greater than 12). 2. Ensure readable and maintainable code. 3. Include necessary comments to explain the logic behind the functions.","solution":"import re from datetime import datetime def is_valid_date(date_str): Checks if the provided string is a valid date in the formats YYYY-MM-DD, DD-MM-YYYY, or MM/DD/YYYY. Args: date_str (str): A string representing a date. Returns: bool: A boolean indicating whether the date string is valid. date_patterns = [ r\'^d{4}-d{2}-d{2}\', # YYYY-MM-DD r\'^d{2}-d{2}-d{4}\', # DD-MM-YYYY r\'^d{2}/d{2}/d{4}\' # MM/DD/YYYY ] match = any(re.match(pattern, date_str) for pattern in date_patterns) if not match: return False try: if \\"-\\" in date_str: if date_str[4] == \'-\': # YYYY-MM-DD datetime.strptime(date_str, \'%Y-%m-%d\') else: # DD-MM-YYYY datetime.strptime(date_str, \'%d-%m-%Y\') else: # MM/DD/YYYY datetime.strptime(date_str, \'%m/%d/%Y\') return True except ValueError: return False def correct_date_format(date_str): Converts a date in any of the valid formats (YYYY-MM-DD, DD-MM-YYYY, or MM/DD/YYYY) to the standard format YYYY-MM-DD. Args: date_str (str): A string representing a date. Returns: str: A string representing the date in the standardized YYYY-MM-DD format, or \'Invalid date\' if the input is not valid. if not is_valid_date(date_str): return \\"Invalid date\\" if \\"-\\" in date_str: if date_str[4] == \'-\': # YYYY-MM-DD return date_str else: # DD-MM-YYYY return datetime.strptime(date_str, \'%d-%m-%Y\').strftime(\'%Y-%m-%d\') else: # MM/DD/YYYY return datetime.strptime(date_str, \'%m/%d/%Y\').strftime(\'%Y-%m-%d\')"},{"question":"**Question: Implement Roman Numeral Converter** You are given the task to implement a converter for Roman numerals with the following specifications: 1. **Handling Special Cases**: Modify your converter to handle the special Roman numeral cases where subtraction is used (e.g., `IV` for 4, `IX` for 9, etc.). 2. **Bidirectional Conversion**: Implement functions to convert between integers and Roman numerals and vice versa. 3. **Function Specification**: * Implement the function `int_to_roman(n: int) -> str`, which converts an integer to a Roman numeral string. * Implement the function `roman_to_int(s: str) -> int`, which converts a Roman numeral string to an integer. **Input:** * An integer `n` for the `int_to_roman` function. * A string `s` containing a valid Roman numeral for the `roman_to_int` function. **Output:** * A Roman numeral string for the `int_to_roman` function. * An integer for the `roman_to_int` function. **Constraints:** * The input integer will be in the range 1 to 3999. * Ensure the Roman numeral string is valid. **Example:** ```python >>> int_to_roman(1994) \'MCMXCIV\' >>> roman_to_int(\'MCMXCIV\') 1994 ``` In this question, you\'ll need to ensure that both functions handle the special cases of Roman numerals correctly and provide accurate conversions between integers and Roman numerals.","solution":"def int_to_roman(n: int) -> str: Converts an integer to a Roman numeral string. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \'\' i = 0 while n > 0: for _ in range(n // val[i]): roman_num += syb[i] n -= val[i] i += 1 return roman_num def roman_to_int(s: str) -> int: Converts a Roman numeral string to an integer. roman = {\'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000} n = 0 prev_value = 0 for c in reversed(s): value = roman[c] if value < prev_value: n -= value else: n += value prev_value = value return n"},{"question":"# Sum of Unique Pairs Problem Statement: Given an array of integers, find all unique pairs of elements that add up to a specific target sum. Each pair should be represented as a tuple, and the order of elements in the tuple should be in ascending order. The order of the pairs in the result does not matter. Function Signature: ```python def find_unique_pairs(arr: List[int], target: int) -> List[Tuple[int, int]]: pass ``` # Input: * `arr` (List[int]): A list of integers. * `target` (int): The target sum for the pairs. # Output: * `List[Tuple[int, int]]`: A list of tuples of integers where each tuple represents a unique pair that adds up to the target sum. # Constraints: * 1 <= len(arr) <= 10^3 * -10^5 <= arr[i] <= 10^5 # Example: ```python assert find_unique_pairs([1, 2, 3, 4, 5], 5) == [(1, 4), (2, 3)] assert find_unique_pairs([1, 1, 2, 3, 4], 4) == [(1, 3)] assert find_unique_pairs([-1, 0, 1, 2, -1, -4], 1) == [(0, 1), (-1, 2)] ``` # Explanation: - `find_unique_pairs([1, 2, 3, 4, 5], 5)` returns `[(1, 4), (2, 3)]` because the pairs of numbers that sum up to 5 are (1, 4) and (2, 3). - `find_unique_pairs([1, 1, 2, 3, 4], 4)` returns `[(1, 3)]` because the only unique pair that adds up to 4 is (1, 3). Note that the pair (1, 3) should only appear once. - `find_unique_pairs([-1, 0, 1, 2, -1, -4], 1)` returns `[(0, 1), (-1, 2)]` because the unique pairs that sum up to 1 are (0, 1) and (-1, 2). # Notes: - Pairs should be unique; (1, 2) and (2, 1) are considered the same pair and should only appear once as (1, 2). - Ensure the solution handles both positive and negative integers in the array.","solution":"from typing import List, Tuple def find_unique_pairs(arr: List[int], target: int) -> List[Tuple[int, int]]: Given an array of integers, find all unique pairs that add up to a specific target sum. Each pair should be represented as a tuple, and the order of elements in the tuple should be in ascending order. arr.sort() left, right = 0, len(arr) - 1 unique_pairs = [] seen = set() while left < right: current_sum = arr[left] + arr[right] if current_sum == target and (arr[left], arr[right]) not in seen: unique_pairs.append((arr[left], arr[right])) seen.add((arr[left], arr[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return unique_pairs"},{"question":"# Problem Statement You are given a list of integers and you need to find the smallest positive integer that is not present in the list. The integer should be greater than zero. # Function Specification Input * Your function will receive a single list of integers `nums`, where: * `nums` is a non-empty list of integers that can be both positive and negative. * The length of the list is between 1 and 10^6 elements. * Each integer in the list can be between -10^6 and 10^6. Output * The function should return the smallest positive integer (greater than zero) that is not present in the list. # Requirements * Your solution should efficiently handle large input sizes up to 1,000,000 elements. * Aim for a time complexity of O(n) and space complexity of O(1) additional space (excluding the input list). # Function Signatures ```python def find_smallest_missing_positive(nums: List[int]) -> int: pass ``` # Example ```python assert find_smallest_missing_positive([1, 2, 0]) == 3 assert find_smallest_missing_positive([3, 4, -1, 1]) == 2 assert find_smallest_missing_positive([7, 8, 9, 11, 12]) == 1 assert find_smallest_missing_positive([-1, -2, -3, -4]) == 1 assert find_smallest_missing_positive([1]) == 2 ``` # Constraints * You must ensure that your implementation is efficient both in terms of time and space. * Properly handle edge cases such as lists that contain only negative numbers or large numbers. # Hint - Consider using an algorithm that attempts to place each number `n` at its corresponding index `n-1` if it lies within the correct range. Afterward, iterate through the list to find the smallest index that doesn\'t match its intended number.","solution":"from typing import List def find_smallest_missing_positive(nums: List[int]) -> int: n = len(nums) # Step 1: Mark numbers (num < 1 or num > n) with a larger number (n+1) for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Step 2: Use the index as a hash and mark the corresponding index negative for i in range(n): num = abs(nums[i]) if num <= n: nums[num - 1] = -abs(nums[num - 1]) # Step 3: Find the first missing positive number for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"# Stock Price Fluctuation Analyzer You have been provided with a sequence of stock prices over a series of days. Your tasks are to implement the following functionalities: 1. **Maximum Profit Calculation**: Implement a function `max_profit` to determine the maximum possible profit from a single buy and sell transaction. 2. **Longest Increasing Subsequence of Prices**: Implement a function `longest_increasing_subsequence` to calculate the length of the longest increasing subsequence of stock prices. 3. **Moving Average Calculation**: Implement a function `moving_average` to calculate the moving average of the stock prices over a given window size. # Input and Output Formats: **Function 1: Maximum Profit Calculation** * Input: A list of integers representing the stock prices on consecutive days (e.g., [7, 1, 5, 3, 6, 4]). * Output: An integer representing the maximum possible profit (e.g., 5). **Function 2: Longest Increasing Subsequence of Prices** * Input: A list of integers representing the stock prices on consecutive days (e.g., [7, 1, 5, 3, 6, 4]). * Output: An integer representing the length of the longest increasing subsequence of prices (e.g., 3). **Function 3: Moving Average Calculation** * Input: - A list of integers representing the stock prices on consecutive days (e.g., [7, 1, 5, 3, 6, 4]). - An integer `k` representing the window size for the moving average (e.g., 3). * Output: A list of floats representing the moving averages over the specified window size (e.g., [4.33, 3.0, 4.67, 4.33]). # Constraints: * The input list for all functions can contain 0 to 1000 elements. * Stock prices are non-negative integers. * Moving average window size `k` will be a positive integer ≤ the length of the stock prices list. # Performance Requirements: * Your solution should efficiently handle up to 1000 stock prices. # Implementation: Implement the following Python functions: ```python def max_profit(prices: list) -> int: # Implement the function as described def longest_increasing_subsequence(prices: list) -> int: # Implement the function as described def moving_average(prices: list, k: int) -> list: # Implement the function as described ``` # Example: ```python assert max_profit([7, 1, 5, 3, 6, 4]) == 5 assert longest_increasing_subsequence([7, 1, 5, 3, 6, 4]) == 3 assert moving_average([7, 1, 5, 3, 6, 4], 3) == [4.33, 3.0, 4.67, 4.33] ```","solution":"def max_profit(prices): This function returns the maximum possible profit from a single buy and sell transaction. if not prices: return 0 min_price = float(\'inf\') max_profit_val = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit_val: max_profit_val = price - min_price return max_profit_val def longest_increasing_subsequence(prices): This function returns the length of the longest increasing subsequence of stock prices. if not prices: return 0 n = len(prices) lis = [1] * n for i in range(1, n): for j in range(0, i): if prices[i] > prices[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis) def moving_average(prices, k): This function returns the moving averages of the stock prices over a given window size. if not prices or k <= 0 or k > len(prices): return [] result = [] window_sum = sum(prices[:k]) result.append(round(window_sum / k, 2)) for i in range(k, len(prices)): window_sum += prices[i] - prices[i - k] result.append(round(window_sum / k, 2)) return result"},{"question":"# Coding Question: Find All Anagrams in a String Context You are tasked with finding all anagrams of a given pattern in a given string. An anagram is a rearrangement of all the letters in a word or pattern. Task Description Implement the function `find_anagrams(s: str, p: str) -> list[int]` which finds all the start indices of `p`\'s anagrams in `s`. Both input strings `s` and `p` consist of lowercase English letters. For example: ```python s = \\"cbaebabacd\\" p = \\"abc\\" ``` Your function should return: ```python [0, 6] ``` Explanation: - The substring with start index 0 is \\"cba\\", which is an anagram of \\"abc\\". - The substring with start index 6 is \\"bac\\", which is an anagram of \\"abc\\". Constraints * 1 <= len(s), len(p) <= 10^4 * `s` and `p` consist of lowercase English letters. Function Signature ```python def find_anagrams(s: str, p: str) -> list[int]: pass ``` Requirements 1. Implement the function efficiently to handle larger strings. 2. Use sliding window and frequency comparison techniques to find all anagrams. 3. The function should return the starting indices of the anagrams in ascending order. Example Scenario Given the input: ```python s = \\"abab\\" p = \\"ab\\" ``` Your function should return: ```python [0, 1, 2] ``` Explanation: - The substrings with start indices 0, 1, and 2 are \\"ab\\", \\"ba\\", and \\"ab\\" respectively, which are anagrams of \\"ab\\". Ensure to handle edge cases such as: * `s` and `p` having the same length. * No anagrams present in `s`. * `s` or `p` being just one letter long.","solution":"def find_anagrams(s: str, p: str) -> list[int]: Finds all start indices of p\'s anagrams in s. :param s: string to search within :param p: pattern string :return: list of start indices of anagrams of p in s from collections import Counter # Result list to hold start indices of anagrams result_indexes = [] # Lengths of the input strings len_s, len_p = len(s), len(p) # If the pattern is longer than the string, there can\'t be any anagrams if len_p > len_s: return result_indexes # Counters for characters in pattern and the first window in the string p_counter = Counter(p) s_counter = Counter(s[:len_p-1]) # Iterate over the string using a sliding window for i in range(len_p - 1, len_s): # Include a new character in the window s_counter[s[i]] += 1 # Check if window matches pattern if s_counter == p_counter: result_indexes.append(i - len_p + 1) # Remove the character left behind as the window slides forward s_counter[s[i - len_p + 1]] -= 1 if s_counter[s[i - len_p + 1]] == 0: del s_counter[s[i - len_p + 1]] return result_indexes"},{"question":"# Knapsack Problem: Dynamic Programming Implementation **Scenario**: Given a set of items, each with a weight and a value, determine the maximum value obtainable by selecting a subset of these items to include in a knapsack of a specified capacity `W`. Each item can be included only once. **Function Specifications**: Function 1: `recursive_knapsack(W: int, weights: list, values: list, n: int) -> int` 1. **Input**: * `W` (int): The maximum capacity of the knapsack. * `weights` (list): A list where `weights[i]` is the weight of item `i`. * `values` (list): A list where `values[i]` is the value of item `i`. * `n` (int): The number of items available. 2. **Output**: * Returns the maximum value obtainable within the given knapsack capacity. Function 2: `top_down_knapsack(W: int, weights: list, values: list, n: int) -> int` 1. **Input**: * Same as Function 1. 2. **Output**: * Same as Function 1. Function 3: `bottom_up_knapsack(W: int, weights: list, values: list, n: int) -> int` 1. **Input**: * Same as Function 1. 2. **Output**: * Same as Function 1. **Tasks**: 1. Implement the three functions as specified. Verify the correctness of each through test cases. 2. Analyze the time and space complexity of each function. 3. Compare the performance of the recursive and dynamic programming approaches. **Constraints**: * For each function, ensure `W` and the weights in the `weights` list are non-negative integers. * The `values` list should contain non-negative integers. * `n` should be a non-negative integer less than or equal to len(weights) and len(values). **Performance Requirements**: * Verify that the dynamic programming solutions perform significantly better than the recursive approach as `W` and `n` increase. ```python # You may utilize the test cases provided in the following main function. def main(): weights = [1, 3, 4, 5] values = [1, 4, 5, 7] W = 7 n = len(weights) # Test the functions with the given weights and values assert recursive_knapsack(W, weights, values, n) == 9 assert top_down_knapsack(W, weights, values, n) == 9 assert bottom_up_knapsack(W, weights, values, n) == 9 print(\\"All test cases passed!\\") if __name__ == \\"__main__\\": main() ``` --- In this new question, you are asked to solve the Knapsack problem, which closely relates to the dynamic programming techniques explored in the original Rod-Cutting problem. Similar to the provided set, this problem involves implementing recursive and dynamic programming approaches, analyzing their complexities, and validating solutions against test cases. It also maintains similar difficulty and scope by focusing on optimization problems and dynamic programming methods.","solution":"def recursive_knapsack(W, weights, values, n): Returns the maximum value obtainable within the given knapsack capacity using recursion. if n == 0 or W == 0: return 0 if weights[n-1] > W: return recursive_knapsack(W, weights, values, n-1) else: return max(values[n-1] + recursive_knapsack(W-weights[n-1], weights, values, n-1), recursive_knapsack(W, weights, values, n-1)) def top_down_knapsack(W, weights, values, n, memo=None): Returns the maximum value obtainable within the given knapsack capacity using top-down approach with memoization. if memo is None: memo = [[-1] * (W + 1) for _ in range(n + 1)] if n == 0 or W == 0: return 0 if memo[n][W] != -1: return memo[n][W] if weights[n-1] > W: memo[n][W] = top_down_knapsack(W, weights, values, n-1, memo) else: memo[n][W] = max(values[n-1] + top_down_knapsack(W-weights[n-1], weights, values, n-1, memo), top_down_knapsack(W, weights, values, n-1, memo)) return memo[n][W] def bottom_up_knapsack(W, weights, values, n): Returns the maximum value obtainable within the given knapsack capacity using bottom-up approach. K = [[0 for x in range(W + 1)] for x in range(n + 1)] for i in range(n + 1): for w in range(W + 1): if i == 0 or w == 0: K[i][w] = 0 elif weights[i-1] <= w: K[i][w] = max(values[i-1] + K[i-1][w-weights[i-1]], K[i-1][w]) else: K[i][w] = K[i-1][w] return K[n][W]"},{"question":"# Coding Assessment Question: Implementing an Activity Selection Algorithm Context You are working on a project that involves scheduling multiple activities, each with a start and end time. The goal is to find the maximum number of non-overlapping activities that can be performed by a single person. This is known as the Activity Selection problem, which can be solved using a greedy algorithm. Task Write a function that selects the maximum number of non-overlapping activities and returns the list of selected activities. Function Signature ```python def select_activities(activities: list[tuple[int, int]]) -> list[tuple[int, int]]: ``` Input Format * `activities`: A list of tuples, where each tuple represents an activity with a start time and an end time. Each tuple is of the form `(start_time, end_time)`. Output Format * The function returns a list of tuples, representing the maximum number of non-overlapping activities selected. Each tuple is of the form `(start_time, end_time)` and the list should be in the same order of activities as given in the input. Constraints * The `start_time` and `end_time` for each activity will be non-negative integers. * The end time of an activity is always greater than the start time. * The number of activities (`n`) will be a positive integer. Example ```python activities = [(1, 4), (3, 5), (0, 6), (5, 7), (3, 8), (5, 9), (6, 10), (8, 11), (8, 12), (2, 13), (12, 14)] selected_activities = select_activities(activities) print(f\\"Selected activities: {selected_activities}\\") ``` **Note:** Ensure your implementation sorts the activities based on their end time and selects the maximum number of non-overlapping activities using a greedy approach.","solution":"def select_activities(activities: list[tuple[int, int]]) -> list[tuple[int, int]]: Returns a list of non-overlapping activities that can be performed # Step 1: Sort activities based on their end time sorted_activities = sorted(activities, key=lambda x: x[1]) # Initialize selected activities list selected_activities = [] # The end time of the last selected activity last_end_time = 0 for activity in sorted_activities: start_time, end_time = activity if start_time >= last_end_time: selected_activities.append(activity) last_end_time = end_time return selected_activities"},{"question":"# Coding Assessment Question **Context:** You are given an implementation of a basic linked list in Python. The linked list supports operations such as adding elements to the end, removing elements by value, and retrieving the length of the list. **Task:** **Implement a function, `merge_two_sorted_lists(l1, l2)`,** that merges two sorted linked lists `l1` and `l2` into one sorted linked list. The function should return the head of the merged list. **Input & Output**: - **l1**: The head of the first sorted linked list. - **l2**: The head of the second sorted linked list. **Requirements**: - Implement the function such that it runs efficiently, ensuring the merged list maintains sorted order. - Consider edge cases such as: - One or both lists being empty. - Lists of different lengths. **Example**: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1, l2): # Your implementation here # Example usage: # Creating first sorted linked list: 1 -> 3 -> 5 l1 = ListNode(1) l1.next = ListNode(3) l1.next.next = ListNode(5) # Creating second sorted linked list: 2 -> 4 -> 6 l2 = ListNode(2) l2.next = ListNode(4) l2.next.next = ListNode(6) # Merging both linked lists merged_head = merge_two_sorted_lists(l1, l2) # Traversing the merged list to print its elements current_node = merged_head while current_node: print(current_node.val, end=\\" -> \\") current_node = current_node.next # Expected Output: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> ```","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1, l2): Merges two sorted linked lists l1 and l2 and returns the head of the merged list. dummy = ListNode() tail = dummy while l1 and l2: if l1.val < l2.val: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next # If there are remaining elements in either list, add them here if l1: tail.next = l1 elif l2: tail.next = l2 return dummy.next"},{"question":"You are tasked with implementing a social network feature where users can form friendships and also request to find out if they belong to a specific friend group. Implement the Union-Find data structure to efficiently manage these operations. **Task**: Perform a series of union operations to form friendships and then check if given pairs of users belong to the same friend group. **Function Signature**: ```python def social_network(n: int, operations: List[Tuple[str, int, int]]) -> List[str]: Args: n : int : Number of users (each user initially in a separate friend group) operations : List[Tuple[str, int, int]] : A list of tuples where each tuple signifies an operation: - (\'union\', a, b): merge the friend group of a and b - (\'find\', a, b): check if a and b are in the same friend group. Returns: List[str] : List of results for \'find\' operations. \\"Yes\\" if they are in the same friend group, otherwise \\"No\\". ``` # Input * Integer `n` representing the number of users (1 ≤ n ≤ 10^5). * List `operations` of tuples where each tuple (operation_type, a, b) specifies: - operation_type: \'union\' or \'find\' - (0 ≤ a, b < n) representing user indices. # Output * List of strings where each string is either \\"Yes\\" or \\"No\\" result for the \'find\' operations. # Example ```python operations = [(\'union\', 0, 1), (\'union\', 1, 2), (\'find\', 0, 2), (\'union\', 2, 3), (\'find\', 3, 4), (\'find\', 0, 3)] print(social_network(5, operations)) # Output: [\\"Yes\\", \\"No\\", \\"Yes\\"] ``` # Explanation - After merging users 0 and 1 into a friend group. - Then merging users 1 and 2 into the same friend group. - Checking if users 0 and 2 belong to the same group returns \\"Yes\\" since they are connected [0-1-2]. - Merging user 2 to user 3. - Checking if user 3 and 4 belong to the same group returns \\"No\\" since user 4 is not connected. - Finally, checking if user 0 and 3 belong to the same group returns \\"Yes\\" since they are connected through the chain [0-1-2-3]. # Constraints * The union-find data structure should employ path compression and union by rank to ensure efficient operations.","solution":"from typing import List, Tuple def social_network(n: int, operations: List[Tuple[str, int, int]]) -> List[str]: parent = list(range(n)) rank = [0] * n def find(x): if parent[x] != x: parent[x] = find(parent[x]) # Path compression return parent[x] def union(x, y): root_x = find(x) root_y = find(y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 result = [] for op in operations: if op[0] == \'union\': union(op[1], op[2]) elif op[0] == \'find\': if find(op[1]) == find(op[2]): result.append(\\"Yes\\") else: result.append(\\"No\\") return result"},{"question":"# Airline Reservation System: Flight Seat Allocation Design and implement an airline reservation system that can handle seat allocation for passengers on different flights. Your task is to create a class-based implementation that provides functionalities for booking and releasing seats, and for tracking occupied and available seats on each flight. Objectives: 1. **AirlineReservationSystem Class**: - Create a class named `AirlineReservationSystem` that maintains details of flights and their seat allocations. - Each flight should have a unique flight number and a fixed number of seats. 2. **Implementation Requirements**: - Implement methods to add new flights with a specified number of seats. - Implement a method to book a seat on a flight for a passenger. - Implement a method to release a booked seat. - Implement methods to get the list of available and occupied seats on a flight. 3. **Input and Output Formats**: - **Input**: - **New Flight**: `add_flight(flight_number: str, seat_count: int)` - **Book Seat**: `book_seat(flight_number: str, passenger_name: str)` - **Release Seat**: `release_seat(flight_number: str, passenger_name: str)` - **Available Seats**: `get_available_seats(flight_number: str) -> List[int]` - **Occupied Seats**: `get_occupied_seats(flight_number: str) -> List[int]` - **Output**: - Seat allocation and availability for a given flight. 4. **Data Constraints**: - `seat_count` ≤ 500 - Each flight can have up to 500 seats. - Passenger names are unique per flight. 5. **Performance Requirement**: - The system should handle seat allocation and release in constant time. - The system should manage multiple flights efficiently. Context: You are building an airline reservation system. The functionalities should allow adding new flights with a specific number of seats, booking seats for passengers, releasing those seats when canceled, and checking which seats are available and which are occupied. It should ensure efficient handling of seat allocation and tracking. Example Usage: ```python # Initialize system reservation_system = AirlineReservationSystem() # Add flights reservation_system.add_flight(\\"FL123\\", 100) reservation_system.add_flight(\\"FL124\\", 150) # Book seats reservation_system.book_seat(\\"FL123\\", \\"Alice\\") reservation_system.book_seat(\\"FL123\\", \\"Bob\\") # Release a seat reservation_system.release_seat(\\"FL123\\", \\"Alice\\") # Check available seats available_seats = reservation_system.get_available_seats(\\"FL123\\") occupied_seats = reservation_system.get_occupied_seats(\\"FL123\\") print(f\'Available Seats for FL123: {available_seats}\') print(f\'Occupied Seats for FL123: {occupied_seats}\') ``` Your implementation should handle these requirements efficiently and ensure accurate seat tracking and allocation for each flight.","solution":"class AirlineReservationSystem: def __init__(self): self.flights = {} def add_flight(self, flight_number: str, seat_count: int): if flight_number in self.flights: raise ValueError(\\"Flight with this number already exists.\\") self.flights[flight_number] = { \\"total_seats\\": seat_count, \\"booked_seats\\": {}, \\"next_available_seat\\": 1 } def book_seat(self, flight_number: str, passenger_name: str): if flight_number not in self.flights: raise ValueError(\\"Flight does not exist.\\") flight = self.flights[flight_number] if passenger_name in flight[\\"booked_seats\\"]: raise ValueError(\\"Passenger already booked a seat.\\") if flight[\\"next_available_seat\\"] > flight[\\"total_seats\\"]: raise ValueError(\\"No available seats.\\") flight[\\"booked_seats\\"][passenger_name] = flight[\\"next_available_seat\\"] flight[\\"next_available_seat\\"] += 1 def release_seat(self, flight_number: str, passenger_name: str): if flight_number not in self.flights: raise ValueError(\\"Flight does not exist.\\") flight = self.flights[flight_number] if passenger_name not in flight[\\"booked_seats\\"]: raise ValueError(\\"Passenger did not book a seat.\\") del flight[\\"booked_seats\\"][passenger_name] def get_available_seats(self, flight_number: str): if flight_number not in self.flights: raise ValueError(\\"Flight does not exist.\\") flight = self.flights[flight_number] booked_seat_numbers = set(flight[\\"booked_seats\\"].values()) return [seat for seat in range(1, flight[\\"total_seats\\"] + 1) if seat not in booked_seat_numbers] def get_occupied_seats(self, flight_number: str): if flight_number not in self.flights: raise ValueError(\\"Flight does not exist.\\") flight = self.flights[flight_number] return sorted(list(flight[\\"booked_seats\\"].values()))"},{"question":"# Coding Task: Multi-rule Roman Numeral Converter **Objective**: Create an advanced Roman numeral converter that can convert integer numbers to Roman numeral strings, validate Roman numeral strings, and calculate the sum of two Roman numeral strings. Functions to Implement: 1. **`int_to_roman(n: int) -> str`**: - **Input**: - `n` (Integer): The integer number to convert to Roman numeral string. - **Output**: - Returns the Roman numeral string representation of the given integer number. - **Constraints**: - `n` must be between 1 and 3999 (inclusive). - **Exception Handling**: - Raise `ValueError` if `n` is not within the specified range. - Raise `TypeError` if `n` is not an integer. 2. **`is_valid_roman(roman: str) -> bool`**: - **Input**: - `roman` (String): The Roman numeral string to validate. - **Output**: - Returns `True` if the given string is a valid Roman numeral, otherwise `False`. - **Constraints**: - The input string must contain characters from {\'I\', \'V\', \'X\', \'L\', \'C\', \'D\', \'M\'}. - **Exception Handling**: - Raise `TypeError` if `roman` is not a string. 3. **`sum_romans(roman1: str, roman2: str) -> str`**: - **Input**: - `roman1` (String): The first Roman numeral string. - `roman2` (String): The second Roman numeral string. - **Output**: - Returns the Roman numeral string representation of the sum of the two given Roman numeral strings. - **Constraints**: - Both inputs must be valid Roman numeral strings representing numbers between 1 and 3999 (inclusive). - **Exception Handling**: - Raise `ValueError` if the resulting sum exceeds 3999. - Raise `TypeError` if any of the inputs is not a string. **Example Usages**: ```python assert int_to_roman(3549) == \'MMMDXLIX\' assert is_valid_roman(\'XXI\') == True assert is_valid_roman(\'IIII\') == False assert sum_romans(\'XXI\', \'X\') == \'XXXI\' ``` **Notes**: - Ensure that your code handles edge cases such as large sums. - Provide appropriate documentation and doctests for each function. - Optimize the implementation where possible to handle input efficiently.","solution":"def int_to_roman(n: int) -> str: Converts an integer to a Roman numeral string. Args: - n (int): The integer to convert (must be between 1 and 3999). Returns: - str: The Roman numeral representation of the integer. Raises: - ValueError: If n is not within the range 1-3999. - TypeError: If n is not an integer. if not isinstance(n, int): raise TypeError(\\"Input must be an integer.\\") if n < 1 or n > 3999: raise ValueError(\\"Value must be within the range 1-3999.\\") val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman = \'\' i = 0 while n > 0: for _ in range(n // val[i]): roman += syms[i] n -= val[i] i += 1 return roman def is_valid_roman(roman: str) -> bool: Validates if a string is a valid Roman numeral. Args: - roman (str): The Roman numeral string to validate. Returns: - bool: True if the string is a valid Roman numeral, False otherwise. Raises: - TypeError: If the input is not a string. if not isinstance(roman, str): raise TypeError(\\"Input must be a string.\\") import re pattern = re.compile(r\\"^(M{0,3})(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})\\") return bool(pattern.fullmatch(roman)) def roman_to_int(roman: str) -> int: Converts a Roman numeral to an integer. Args: - roman (str): The Roman numeral string to convert. Returns: - int: The integer representation of the Roman numeral. roman_to_val = { \\"I\\": 1, \\"V\\": 5, \\"X\\": 10, \\"L\\": 50, \\"C\\": 100, \\"D\\": 500, \\"M\\": 1000 } val = 0 prev_value = 0 for char in reversed(roman): curr_value = roman_to_val[char] if curr_value >= prev_value: val += curr_value else: val -= curr_value prev_value = curr_value return val def sum_romans(roman1: str, roman2: str) -> str: Sums two Roman numeral strings and returns the result as a Roman numeral string. Args: - roman1 (str): The first Roman numeral string. - roman2 (str): The second Roman numeral string. Returns: - str: The Roman numeral representation of the sum. Raises: - ValueError: If the resulting sum exceeds 3999. - TypeError: If any of the inputs is not a string. if not isinstance(roman1, str) or not isinstance(roman2, str): raise TypeError(\\"Both inputs must be strings.\\") if not is_valid_roman(roman1) or not is_valid_roman(roman2): raise ValueError(\\"Both inputs must be valid Roman numerals.\\") int_sum = roman_to_int(roman1) + roman_to_int(roman2) if int_sum > 3999: raise ValueError(\\"The resulting sum exceeds 3999.\\") return int_to_roman(int_sum)"},{"question":"# Problem Statement You need to implement a function `rotate_matrix` that takes a square matrix `matrix` (a list of lists) and returns the matrix rotated 90 degrees to the right. Perform the rotation in-place if feasible. # Input & Output Formats - **Input**: - `matrix`: A list of lists, where each inner list represents a row of the matrix (1 ≤ length of rows in matrix ≤ 50) - **Output**: - A list of lists representing the matrix rotated 90 degrees to the right. # Constraints - The input matrix is square, i.e., the number of rows is equal to the number of columns. - Elements of the matrix are integers. # Example ```python >>> matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> rotate_matrix(matrix) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [[5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16]] >>> rotate_matrix(matrix) [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]] ``` # Instructions 1. Implement the `rotate_matrix` function to rotate the input matrix 90 degrees to the right. 2. Think about how you can do this transformation in-place, minimizing the amount of additional memory required. Hints - A common approach is to first transpose the matrix and then reverse the rows. - Consider the symmetry and reversal properties of the matrix to make transformations simpler.","solution":"def rotate_matrix(matrix): Rotates a square matrix 90 degrees to the right. This operation is performed in-place. :param matrix: List[List[int]], a square matrix :return: None, the matrix is modified in-place n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Binary Number with Alternating Bits Your task is to write a function to determine if a given positive integer\'s binary representation has alternating bits: namely, if no two consecutive bits are the same. A number is said to have alternating bits if the binary representation of the number contains no two consecutive `0s` or `1s`. For example, the binary representation of `5` is `101`, which meets the criteria, while the binary representation of `11` is `1011`, which does not. Function Signature: ```python def has_alternating_bits(n: int) -> bool: pass ``` # Requirements: - **Input**: A positive integer `n` (1 ≤ n ≤ 10^9). - **Output**: A boolean value `True` if the integer has alternating bits, and `False` otherwise. # Example Usage: ```python print(has_alternating_bits(5)) # Expected: True (binary: 101) print(has_alternating_bits(7)) # Expected: False (binary: 111) print(has_alternating_bits(10)) # Expected: True (binary: 1010) print(has_alternating_bits(11)) # Expected: False (binary: 1011) ``` # Detailed Explanation of Concepts: - **Binary Conversion**: Convert the number to its binary representation, either through built-in functions or bit manipulation. - **Bit Checking**: Traverse through each bit in the binary representation and check if consecutive bits are the same. - **Algorithm Efficiency**: Since the input range is limited to a maximum of 10^9, consider efficient ways to handle bit manipulation and traversal. Focus on writing a clear, efficient, and well-documented implementation, taking into account different binary patterns and edge cases.","solution":"def has_alternating_bits(n: int) -> bool: Returns True if the binary representation of n has alternating bits, False otherwise. # Get the least significant bit last_bit = n & 1 n = n >> 1 # Shift right by one to check the next bit while n > 0: current_bit = n & 1 # If two consecutive bits are the same, return False if current_bit == last_bit: return False # Update last_bit to the current bit for the next comparison last_bit = current_bit n = n >> 1 # Shift right by one to check the next bit return True"},{"question":"# Scenario With the increasing complexity and size of data processed in modern applications, efficient data structures and algorithms for searching are critical. In particular, engineers often use binary search to quickly locate elements in a sorted list. However, instead of a standard comparator function, some scenarios require a custom comparator to determine the order of elements. # Problem Statement Write a function `custom_binary_search(arr: list, target: any, comp: callable) -> int` that performs a binary search on a given sorted list `arr` to locate `target` using a custom comparator function `comp`. # Input Format * `arr` is a list of elements sorted in a custom order defined by `comp`. * `target` is the element to search for in the list. * `comp` is a comparator function that takes two arguments and returns: * A negative integer if the first argument is less than the second. * Zero if the first argument is equal to the second. * A positive integer if the first argument is greater than the second. # Output Format * Return the index of `target` in `arr` if present, otherwise return -1. # Constraints * 1 ≤ len(arr) ≤ 1000 * The elements in `arr` can be of any type, as long as the comparator can handle them. # Performance Requirements * The solution should operate within O(log n) time complexity, assuming the comparator is O(1). # Example ```python def custom_compare(a, b): return a - b >>> custom_binary_search([1, 2, 3, 4, 5], 3, custom_compare) 2 >>> custom_binary_search([\'apple\', \'banana\', \'cherry\'], \'banana\', lambda a, b: (a > b) - (a < b)) 1 >>> custom_binary_search([10, 20, 30, 40], 25, lambda a, b: a - b) -1 ``` # Notes * Ensure that your solution correctly handles custom comparator logic, as the target element\'s position depends entirely on the comparator\'s results. * Include error handling for cases where the input list is empty or the comparator is incorrect for the given types of elements.","solution":"def custom_binary_search(arr, target, comp): Perform a binary search on a sorted list using a custom comparator function. :param arr: List of elements sorted based on custom comparator. :param target: Element to search for in the list. :param comp: Comparator function to determine the order of elements. :return: Index of target in arr if present, otherwise -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 comparison = comp(arr[mid], target) if comparison == 0: return mid elif comparison < 0: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Matrix Transpose In mathematical computing, the transpose of a matrix is formed by turning all the rows of the matrix into columns and vice versa. This operation is a fundamental matrix manipulation task often encountered in various algorithms and data transformations. Task You are required to implement a function `matrix_transpose` that takes a 2D list (matrix) as input and returns its transpose. The transpose of a matrix is formed by swapping the matrix\'s rows and columns. Function Signature ```python def matrix_transpose(matrix: list[list[int]]) -> list[list[int]]: pass ``` Input * `matrix` (list of list of ints): A non-empty 2D list where each inner list represents a row of integers in the matrix. Output * Returns a list of lists of integers representing the transposed matrix. Constraints * The number of rows and columns in the matrix will be between 1 and 1000 (inclusive). * Each element of the matrix `matrix[i][j]` will be an integer within the range `-10^6` to `10^6`. Examples * Example 1: - Input: `[[1, 2, 3], [4, 5, 6]]` - Output: `[[1, 4], [2, 5], [3, 6]]` * Example 2: - Input: `[[7, 8], [9, 10], [11, 12]]` - Output: `[[7, 9, 11], [8, 10, 12]]` * Example 3: - Input: `[[1]]` - Output: `[[1]]` * Example 4: - Input: `[[1, -2, 3], [-4, 5, -6], [7, 8, 9]]` - Output: `[[1, -4, 7], [-2, 5, 8], [3, -6, 9]]` * Example 5: - Input: `[[-1, 4], [-5, -10], [6, 7]]` - Output: `[[-1, -5, 6], [4, -10, 7]]` Requirements * Ensure the function handles edge cases such as a 1x1 matrix. * The implementation should correctly transform the matrix regardless of size or element values. * Optimize for cases where the matrix dimensions are large (i.e., up to 1000x1000).","solution":"def matrix_transpose(matrix: list[list[int]]) -> list[list[int]]: Returns the transpose of the given matrix. :param matrix: A 2D list where each inner list represents a row of integers in the matrix. :return: A 2D list representing the transposed matrix. return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]"},{"question":"# Question: You are designing a ticket reservation system for a theater with a fixed seating layout. The theater has a number of rows, and each row contains a specific number of seats. The system should support the following operations: - `reserve(row, seat)`: Reserve a specific seat in a specific row. If the seat is already reserved, the operation should fail and return `False`. Otherwise, the seat is reserved, and the operation returns `True`. - `cancel(row, seat)`: Cancel the reservation of a specific seat in a specific row. If the seat is already free, the operation should fail and return `False`. Otherwise, the reservation is canceled, and the operation returns `True`. - `status()`: Return a dictionary showing the current status of reservations for all rows. **Requirements**: - Implement a class `Theater` that supports the ticket reservation operations. - Ensure that `reserve` and `cancel` operations check the availability of the seat first. - Maximum capacity of the theater is defined during the initialization (rows and seats per row). **Input/Output**: - `reserve(row: int, seat: int) -> bool` - `cancel(row: int, seat: int) -> bool` - `status() -> dict` **Constraints**: - The number of rows and seats in each row will be in the range [1, 100]. - Rows and seats are 1-indexed. - The number of `reserve` and `cancel` operations will be in the range [1, 10^5]. **Example**: ```python theater = Theater(rows=3, seats_per_row=5) print(theater.reserve(1, 3)) # returns True print(theater.reserve(1, 3)) # returns False (already reserved) print(theater.status()) # returns {1: {1: False, 2: False, 3: True, 4: False, 5: False}, # 2: {1: False, 2: False, 3: False, 4: False, 5: False}, # 3: {1: False, 2: False, 3: False, 4: False, 5: False}} print(theater.cancel(1, 3)) # returns True print(theater.cancel(1, 3)) # returns False (already free) print(theater.status()) # returns {1: {1: False, 2: False, 3: False, 4: False, 5: False}, # 2: {1: False, 2: False, 3: False, 4: False, 5: False}, # 3: {1: False, 2: False, 3: False, 4: False, 5: False}} ``` You will need to implement the internals of the `Theater` class to handle the seat reservation logic efficiently and maintain accurate status information.","solution":"class Theater: A class to represent the theater seating arrangement and handle reservations. def __init__(self, rows, seats_per_row): Initialize the theater seating with given number of rows and seats per row. All seats are initially free. self.seating = {row: {seat: False for seat in range(1, seats_per_row + 1)} for row in range(1, rows + 1)} def reserve(self, row, seat): Reserve a specific seat in a specific row. :param row: int, the row number (1-indexed) :param seat: int, the seat number in the row (1-indexed) :return: bool, True if reservation is successful, False otherwise if self.seating[row][seat]: return False self.seating[row][seat] = True return True def cancel(self, row, seat): Cancel the reservation of a specific seat in a specific row. :param row: int, the row number (1-indexed) :param seat: int, the seat number in the row (1-indexed) :return: bool, True if cancellation is successful, False otherwise if not self.seating[row][seat]: return False self.seating[row][seat] = False return True def status(self): Return the current status of all seat reservations. :return: dict, a dictionary representation of the seating arrangement return self.seating"},{"question":"# Task: Implement a Stack with Max Function Develop a Python class `MaxStack` that supports the following operations: 1. `push(x)`: Pushes the element `x` onto the stack. 2. `pop()`: Removes the element on the top of the stack and returns it. If the stack is empty, returns `None`. 3. `top()`: Gets the top element of the stack without removing it. If the stack is empty, returns `None`. 4. `getMax()`: Retrieves the maximum element in the stack. If the stack is empty, returns `None`. # Class Interface ```python class MaxStack: def __init__(self) -> None: Initialize the Max Stack. pass def push(self, x: int) -> None: Pushes the element x onto the stack. pass def pop(self) -> int | None: Removes the element on the top of the stack and returns it. Returns None if the stack is empty. pass def top(self) -> int | None: Gets the top element of the stack without removing it. Returns None if the stack is empty. pass def getMax(self) -> int | None: Retrieves the maximum element in the stack. Returns None if the stack is empty. pass ``` # Constraints * There are no constraints on the values for elements of the stack. * All operations should be performed in constant time. # Example ```python # Testing the Max Stack stack = MaxStack() stack.push(5) assert stack.getMax() == 5 # Returns 5 stack.push(1) assert stack.getMax() == 5 # Returns 5 stack.push(5) assert stack.getMax() == 5 # Returns 5 assert stack.pop() == 5 # Returns 5 assert stack.getMax() == 5 # Returns 5 assert stack.pop() == 1 # Returns 1 assert stack.getMax() == 5 # Returns 5 assert stack.pop() == 5 # Returns 5 assert stack.getMax() == None # Returns None assert stack.top() == None # Returns None ```","solution":"class MaxStack: def __init__(self) -> None: Initialize the Max Stack. self.stack = [] self.max_stack = [] def push(self, x: int) -> None: Pushes the element x onto the stack. self.stack.append(x) if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) def pop(self) -> int | None: Removes the element on the top of the stack and returns it. Returns None if the stack is empty. if not self.stack: return None top_element = self.stack.pop() if top_element == self.max_stack[-1]: self.max_stack.pop() return top_element def top(self) -> int | None: Gets the top element of the stack without removing it. Returns None if the stack is empty. if not self.stack: return None return self.stack[-1] def getMax(self) -> int | None: Retrieves the maximum element in the stack. Returns None if the stack is empty. if not self.max_stack: return None return self.max_stack[-1]"},{"question":"# Analyzing Financial Data You are required to write a function that analyzes historical stock prices and identifies the maximum profit that could have been made from a single buy-and-hold strategy. The function should determine the best day to buy and the best day to sell a stock within the given data points. Function Signature ```python def max_profit(stock_prices: List[float]) -> float: ``` Input: - `stock_prices` (List[float]): A list of floating-point numbers representing the stock prices over a period of days. The list contains at least two prices. Output: - Returns the maximum profit possible as a floating-point number. If no profit is possible, returns 0. Constraints: - You must buy and sell the stock once. You cannot buy and sell on the same day. Example: ```python max_profit([7.1, 1.5, 5.3, 3.6, 6.4, 4.2]) ``` This might return: ```python 4.9 ``` Explanation: - Buy on day 2 (price=1.5) and sell on day 5 (price=6.4), profit = 6.4 - 1.5 = 4.9 Notes: - You can assume the list of prices is given in chronological order. - Ensure the function is efficient, ideally running in linear time O(n). - Handle edge cases where the prices might be decreasing every day and no profit can be made.","solution":"from typing import List def max_profit(stock_prices: List[float]) -> float: Determines the maximum profit that could have been made from a single buy-and-hold strategy. Parameters: stock_prices (List[float]): A list of floating-point numbers representing stock prices over a period of days. Returns: float: The maximum profit possible. If no profit is possible, returns 0. if not stock_prices or len(stock_prices) < 2: return 0.0 min_price = stock_prices[0] max_profit = 0.0 for price in stock_prices[1:]: if price < min_price: min_price = price else: profit = price - min_price max_profit = max(max_profit, profit) return max_profit"},{"question":"# Coding Question **Context**: There is a need to perform efficient inventory management for a warehouse. One important operation is to group and count items based on their categories. It is your task to write a function that handles this requirement effectively. **Objective**: Write a function `categorize_inventory(items: List[str]) -> Dict[str, int]` that takes a list of item names and counts the occurrence of each category of items. An item name consists of its category followed by a hyphen and a unique identifier (e.g., \\"Electronics-12345\\"). # Criteria: 1. **Input**: * A list of strings where each string represents an item in the format \\"Category-UniqueID\\". 2. **Output**: * A dictionary where the key is the category and the value is the number of items in that category. 3. **Constraints**: * The function should handle any number of items. * The category names and unique identifiers are alphanumeric. 4. **Performance**: * The function should be efficient even if the number of items is large. # Example: ```python def categorize_inventory(items: List[str]) -> Dict[str, int]: # Your implementation here items = [ \\"Electronics-1001\\", \\"Clothing-2233\\", \\"Electronics-1002\\", \\"Electronics-1003\\", \\"Food-2001\\", \\"Clothing-2234\\", \\"Food-2002\\" ] print(categorize_inventory(items)) # Expected: {\'Electronics\': 3, \'Clothing\': 2, \'Food\': 2} ``` Write your function to solve this problem, bearing in mind both the efficiency and correct handling of the defined constraints.","solution":"from typing import List, Dict def categorize_inventory(items: List[str]) -> Dict[str, int]: Takes a list of item names and counts the occurrence of each category of items. Parameters: items (List[str]): A list of strings where each string represents an item in the format \\"Category-UniqueID\\". Returns: Dict[str, int]: A dictionary where the key is the category and the value is the number of items in that category. category_count = {} for item in items: category = item.split(\'-\')[0] if category in category_count: category_count[category] += 1 else: category_count[category] = 1 return category_count"},{"question":"# Coding Assessment Question Question: You are tasked with creating a function to generate all possible combinations of well-formed parentheses for a given number of pairs `n`. A pair of parentheses is defined as \\"()\\". Write a function `generate_parentheses(n: int) -> List[str]` that returns a list of all possible combinations of `n` pairs of well-formed parentheses. Function Signature: ```python def generate_parentheses(n: int) -> List[str]: pass ``` Input: - `n` (int): A non-negative integer representing the number of pairs of parentheses to generate. If `n` is negative or not an integer, your function should raise a `ValueError` with the message \\"Invalid input\\". Output: - `List[str]`: A list containing all unique combinations of well-formed parentheses. Each combination should be a string. Constraints: - The total number of combinations when `n` pairs of well-formed parentheses are generated is given by the `(n+1)th` Catalan number, which grows exponentially with `n`. Example: ```python >>> generate_parentheses(3) [\'((()))\', \'(()())\', \'(())()\', \'()(())\', \'()()()\'] >>> generate_parentheses(1) [\'()\'] >>> generate_parentheses(0) [\'\'] >>> generate_parentheses(-1) Traceback (most recent call last): ... ValueError: Invalid input >>> generate_parentheses(1.5) Traceback (most recent call last): ... ValueError: Invalid input ``` # Additional Information: 1. Ensure your implementation efficiently handles generating and returning all well-formed parentheses combinations. 2. Your function should validate that `n` is a non-negative integer; otherwise, it should raise a `ValueError`. 3. Consider using a recursive or backtracking approach to generate the combinations.","solution":"def generate_parentheses(n: int): if not isinstance(n, int) or n < 0: raise ValueError(\\"Invalid input\\") def backtrack(curr, open, close): if len(curr) == 2 * n: result.append(curr) return if open < n: backtrack(curr + \\"(\\", open + 1, close) if close < open: backtrack(curr + \\")\\", open, close + 1) result = [] backtrack(\\"\\", 0, 0) return result"},{"question":"# Scenario You need to analyze a dataset consisting of daily temperatures from two different cities over a month. Your task is to compute the moving average of the temperature data for each city. The moving average will help smooth out short-term fluctuations and highlight longer-term trends or cycles. # Task Write a Python function `compute_moving_average(temps_city1, temps_city2, window_size)` that: 1. Computes the moving average of the temperature data for each city. 2. Returns the moving averages as two lists, one for each city. # Input Format * `temps_city1` (list of floats): Daily temperatures for the first city. * `temps_city2` (list of floats): Daily temperatures for the second city. * `window_size` (integer): The size of the moving average window. # Output Format * Two lists of floats: The moving averages of the temperatures for `temps_city1` and `temps_city2`. # Constraints 1. Assume `temps_city1` and `temps_city2` are non-empty and have the same length. 2. The `window_size` is a positive integer and less than or equal to the length of the temperature lists. # Example ```python temps_city1 = [30.0, 32.0, 33.0, 31.0, 30.0, 34.0, 35.0] temps_city2 = [25.0, 27.0, 26.0, 29.0, 28.0, 30.0, 31.0] window_size = 3 result_city1, result_city2 = compute_moving_average(temps_city1, temps_city2, window_size) assert result_city1 == [31.666666666666668, 32.0, 31.333333333333332, 31.666666666666668, 33.0] assert result_city2 == [26.0, 27.333333333333332, 27.666666666666668, 29.0, 29.666666666666668] ``` # Requirements 1. Ensure the implementation uses efficient computations to handle potentially large datasets. 2. Follow good coding practices with clear, readable code and comments.","solution":"def compute_moving_average(temps_city1, temps_city2, window_size): Computes the moving average of daily temperatures for two cities. Args: temps_city1 (list of floats): Daily temperatures for the first city. temps_city2 (list of floats): Daily temperatures for the second city. window_size (int): The size of the moving average window. Returns: (list of floats, list of floats): The moving averages of the temperatures for both cities. def moving_average(temps, window): moving_averages = [] for i in range(len(temps) - window + 1): window_avg = sum(temps[i:i + window]) / window moving_averages.append(window_avg) return moving_averages avg_city1 = moving_average(temps_city1, window_size) avg_city2 = moving_average(temps_city2, window_size) return avg_city1, avg_city2"},{"question":"# Question: You are tasked with creating a software tool for an online bookstore that helps manage its collection of books. One of the requirements is to implement a function that categorizes books based on their genres and calculates the total number of books in each genre. Write a function `categorize_books(books: List[Tuple[str, str]]) -> Dict[str, int]` that organizes a list of books into a dictionary, with genres as keys and the number of books in each genre as values. Each book is represented as a tuple containing the title and the genre. Your function should handle the case where genres are not provided or are empty strings by categorizing such books under the genre \\"Unknown\\". # Input: - `books` (List[Tuple[str, str]]): A list of tuples where each tuple contains two strings: - The first string is the title of the book. - The second string is the genre of the book. # Output: A dictionary where the keys are genres and the values are integers representing the number of books in each genre. # Constraints: - The list can include any number of books (from 0 to 10^4). - Titles and genres are case-sensitive and can include any characters. - If the genre is an empty string or not provided, it should be recorded as \\"Unknown\\". # Examples: 1. Given a list of books: ```python books = [(\\"The Great Gatsby\\", \\"Fiction\\"), (\\"To Kill a Mockingbird\\", \\"Fiction\\"), (\\"A Brief History of Time\\", \\"Science\\"), (\\"No Genre Book\\", \\"\\")] ``` ```python categorize_books(books) ``` Should return `{\\"Fiction\\": 2, \\"Science\\": 1, \\"Unknown\\": 1}`. 2. Given a list of books: ```python books = [(\\"Python Programming\\", \\"Technology\\"), (\\"Quantum Physics\\", \\"Science\\"), (\\"Machine Learning\\", \\"Technology\\")] ``` ```python categorize_books(books) ``` Should return `{\\"Technology\\": 2, \\"Science\\": 1}`. 3. Given an empty list of books: ```python books = [] ``` ```python categorize_books(books) ``` Should return `{}`. # Additional Notes: - Consider edge cases such as books with empty titles or genres. - Ensure that the function is efficient and can handle the upper limit of books gracefully. - Include test cases to verify the correctness of your implementation.","solution":"from typing import List, Tuple, Dict def categorize_books(books: List[Tuple[str, str]]) -> Dict[str, int]: Categorizes books based on their genres and calculates the total number of books in each genre. Parameters: books (List[Tuple[str, str]]): A list of tuples where each tuple contains the title and genre of a book. Returns: Dict[str, int]: A dictionary where the keys are genres and the values are the number of books in each genre. genres_count = {} for title, genre in books: if not genre: genre = \\"Unknown\\" if genre in genres_count: genres_count[genre] += 1 else: genres_count[genre] = 1 return genres_count"},{"question":"# Scenario A new feature is being added to your company\'s messaging application, allowing users to manage their contacts efficiently. Users should be able to search, add, or remove contacts from a sorted list. Given the large number of contacts, the application must maintain the list in a way that allows for quick searching, insertion, and deletion operations. # Task Implement a class `ContactList` that supports the following operations on a list of contacts: - `add_contact(name: str) -> None`: Adds a contact to the list in sorted order. - `remove_contact(name: str) -> bool`: Removes a contact from the list. Returns `True` if the contact was removed, `False` if the contact does not exist. - `find_contact(name: str) -> bool`: Checks if a contact exists in the list. Returns `True` if the contact is found, `False` otherwise. # Class Definition ```python class ContactList: def __init__(self): Initializes an empty contact list. def add_contact(self, name: str) -> None: Adds a contact to the list in sorted order. :param name: The name of the contact to add. def remove_contact(self, name: str) -> bool: Removes a contact from the list if it exists. :param name: The name of the contact to remove. :return: True if the contact was removed, False if the contact was not found. def find_contact(self, name: str) -> bool: Searches for a contact in the list. :param name: The name of the contact to search for. :return: True if the contact is found, False otherwise. ``` # Input - The methods of `ContactList` will receive: - `name`: A string representing the name of the contact. # Output - The `add_contact` method does not return anything. - The `remove_contact` method returns a boolean indicating whether the removal was successful. - The `find_contact` method returns a boolean indicating whether the contact exists in the list. # Constraints - The name of each contact is a non-empty string containing only alphabetical characters. - No two contacts will have the same name. # Performance Requirements - The `add_contact`, `remove_contact`, and `find_contact` methods should be efficient, with a target of O(log n) time complexity for each operation, where n is the number of contacts in the list. # Examples ```python contacts = ContactList() contacts.add_contact(\\"Alice\\") contacts.add_contact(\\"Bob\\") contacts.add_contact(\\"Charlie\\") print(contacts.find_contact(\\"Bob\\")) # Output: True print(contacts.find_contact(\\"David\\")) # Output: False print(contacts.remove_contact(\\"Alice\\")) # Output: True print(contacts.remove_contact(\\"Alice\\")) # Output: False print(contacts.find_contact(\\"Alice\\")) # Output: False ```","solution":"import bisect class ContactList: def __init__(self): Initializes an empty contact list. self.contacts = [] def add_contact(self, name: str) -> None: Adds a contact to the list in sorted order. :param name: The name of the contact to add. bisect.insort(self.contacts, name) def remove_contact(self, name: str) -> bool: Removes a contact from the list if it exists. :param name: The name of the contact to remove. :return: True if the contact was removed, False if the contact was not found. index = bisect.bisect_left(self.contacts, name) if index < len(self.contacts) and self.contacts[index] == name: self.contacts.pop(index) return True return False def find_contact(self, name: str) -> bool: Searches for a contact in the list. :param name: The name of the contact to search for. :return: True if the contact is found, False otherwise. index = bisect.bisect_left(self.contacts, name) return index < len(self.contacts) and self.contacts[index] == name"},{"question":"# Context You are a backend developer and have been tasked with developing a feature for a blogging platform. The platform allows users to write and post articles, and you need to implement a functionality to manage user comments on these articles. # Problem Statement Write a function `manage_comments(action: str, article_id: int, comment: str = None, comment_id: int = None) -> str` that performs different actions related to user comments on articles. The function should handle adding, editing, and deleting comments. Your task is to ensure the function updates the in-memory data structure that stores comments correctly. Function Signature ```python def manage_comments(action: str, article_id: int, comment: str = None, comment_id: int = None) -> str: pass ``` Input - `action` (str): The action to perform. Valid values are \\"add\\", \\"edit\\", and \\"delete\\". - `article_id` (int): The ID of the article to which the comment pertains. - `comment` (str): The content of the comment (required for \\"add\\" and \\"edit\\"). - `comment_id` (int): The ID of the comment to edit or delete (required for \\"edit\\" and \\"delete\\"). Output - (str): A message indicating the result of the action (e.g., \\"Comment added\\", \\"Comment edited\\", \\"Comment deleted\\", \\"Invalid action\\"). # Requirements 1. The function should accurately simulate adding, editing, and deleting comments in an in-memory data structure. 2. Handle edge cases and provide clear error messages if an invalid action is specified, if required parameters are missing, or if the given article or comment IDs do not exist. 3. Ensure that each new comment receives a unique ID that increments from 1. 4. Maintain data integrity by not allowing actions on non-existent articles or comments. Example ```python # Assume a calling context where articles exist and their comments are managed in memory. # Adding a new comment (assume no prior comments for simplicity) print(manage_comments(\\"add\\", 101, \\"This is the first comment.\\")) # Expected output: \\"Comment added\\" # Editing the existing comment (with ID 1) print(manage_comments(\\"edit\\", 101, \\"This is the updated comment.\\", 1)) # Expected output: \\"Comment edited\\" # Deleting the existing comment (with ID 1) print(manage_comments(\\"delete\\", 101, comment_id=1)) # Expected output: \\"Comment deleted\\" ``` # Constraints - Each `article_id` is a positive integer. Assume that valid article IDs are always positive and no duplicates exist. - Unique comment IDs should start from 1 and increment by 1 for each new comment. - There should be no more than 1000 articles, and each article can hold a maximum of 200 comments. # Notes 1. You may use a dictionary to simulate the in-memory data structure for storing comments. 2. Consider extensibility and maintainability while designing your function, providing checks and balances for potential data issues. 3. Ensure that all actions are processed efficiently to handle large sets of articles and comments.","solution":"comments_db = {} comment_counter = {} def manage_comments(action: str, article_id: int, comment: str = None, comment_id: int = None) -> str: if not isinstance(article_id, int) or article_id <= 0: return \\"Invalid article_id\\" if action == \\"add\\": if not comment: return \\"Comment content is required for adding\\" if article_id not in comments_db: comments_db[article_id] = [] comment_counter[article_id] = 0 comment_counter[article_id] += 1 new_comment = { \\"id\\": comment_counter[article_id], \\"content\\": comment } comments_db[article_id].append(new_comment) return \\"Comment added\\" elif action == \\"edit\\": if not comment or not comment_id: return \\"Comment content and comment_id are required for editing\\" if article_id not in comments_db: return \\"Article not found\\" for com in comments_db[article_id]: if com[\\"id\\"] == comment_id: com[\\"content\\"] = comment return \\"Comment edited\\" return \\"Comment not found\\" elif action == \\"delete\\": if not comment_id: return \\"Comment_id is required for deleting\\" if article_id not in comments_db: return \\"Article not found\\" for i, com in enumerate(comments_db[article_id]): if com[\\"id\\"] == comment_id: comments_db[article_id].pop(i) return \\"Comment deleted\\" return \\"Comment not found\\" else: return \\"Invalid action\\""},{"question":"**Question**: Optimal Meeting Point in a Grid You are tasked with implementing a function that determines the optimal meeting point for a group of people represented by their coordinates on a 2D grid. The goal is to minimize the total walking distance for all people to the meeting point. The Manhattan distance should be used as the metric for distance calculation. # Problem Statement Given a list of coordinates representing the positions of people on a 2D grid, find the coordinate that minimizes the total Manhattan distance to all other points. # Input Format - A list of tuples, where each tuple represents the (x, y) coordinates of a person. # Output Format - A tuple representing the optimal meeting point coordinates. # Constraints - The input list will have at least one coordinate and no more than (10^4) coordinates. - Coordinates are integers, and all coordinate values will be within the range ([-10^4, 10^4]). # Example ```python def optimal_meeting_point(coordinates: list[tuple[int, int]]) -> tuple[int, int]: x_coords = sorted([coord[0] for coord in coordinates]) y_coords = sorted([coord[1] for coord in coordinates]) x_median = x_coords[len(x_coords) // 2] y_median = y_coords[len(y_coords) // 2] return (x_median, y_median) # Example Usage: print(optimal_meeting_point([(1, 2), (3, 4), (6, 8)])) # Output: (3, 4) print(optimal_meeting_point([(1, 2), (3, 4), (1, 8), (6, 8)])) # Output: (1, 8) ``` # Notes - Manhattan distance between two points ((x_1, y_1)) and ((x_2, y_2)) is defined as (|x_1 - x_2| + |y_1 - y_2|). - The coordinate that minimizes the total walking distance is often the median of the x coordinates and the median of the y coordinates respectively, in ordered lists. - Consider performance implications given the constraints, and ensure your algorithm can handle the upper limits efficiently. # Explanation - The median of the coordinates minimizes the sum of absolute deviations, which makes it the optimal meeting point in terms of Manhattan distance. - Sorting the coordinate values and selecting the median ensures you find the optimal point in (O(n log n)) time due to sorting, which is efficient for the given constraints.","solution":"def optimal_meeting_point(coordinates): Finds the optimal meeting point that minimizes the total Manhattan distance for a group of people with given coordinates. Parameters: coordinates (list of tuples): List of (x, y) coordinates. Returns: tuple: The (x, y) coordinate of the optimal meeting point. x_coords = sorted(coord[0] for coord in coordinates) y_coords = sorted(coord[1] for coord in coordinates) x_median = x_coords[len(x_coords) // 2] y_median = y_coords[len(y_coords) // 2] return (x_median, y_median)"},{"question":"# Scenario You are part of a team developing a financial software system that deals with complex investment transactions. As part of the system, you need to implement a function that calculates the maximum possible profit from a list of stock prices given specific constraints. # Task Write a function `max_profit_with_cooldown(prices: list[int]) -> int` that calculates the maximum profit you can achieve from an array of stock prices, with the added complexity that after you sell a stock, you must wait for one day before you can buy another stock (a cooldown period). # Function Signature ```python def max_profit_with_cooldown(prices: list[int]) -> int ``` # Input * A list of integers `prices` where each element represents the price of a given stock on that particular day. # Output * An integer representing the maximum profit you can achieve. # Constraints * The length of prices will be within the range from 0 to 10^4. * Each price in the list will be an integer within the range from 0 to 10^5. # Example 1. For an input `prices = [1, 2, 3, 0, 2]` - The function should return `3` because you can buy on day 0 (price = 1), sell on day 2 (price = 3), then wait for the cooldown and buy on day 3 (price = 0), and sell on day 4 (price = 2). 2. For an input `prices = [1]` - The function should return `0` because there\'s only one day, hence no transaction can be made. # Additional Requirements * The function should be efficient and able to handle the large input size within the given constraints. * Think about dynamic programming or other optimization techniques to ensure the solution performs well.","solution":"def max_profit_with_cooldown(prices): if not prices: return 0 n = len(prices) if n == 1: return 0 # Initializing the dp arrays hold = [0] * n # profit when holding stock sold = [0] * n # profit when just sold stock rest = [0] * n # profit when in rest state hold[0] = -prices[0] # if we buy on day 0 sold[0] = 0 # no stock to sell on day 0 rest[0] = 0 # just rest for i in range(1, n): hold[i] = max(hold[i-1], rest[i-1] - prices[i]) sold[i] = hold[i-1] + prices[i] rest[i] = max(rest[i-1], sold[i-1]) return max(sold[-1], rest[-1])"},{"question":"# Problem statement You are given a sequence of digits that represent the number of levels in a building. Your task is to implement a function that calculates the total number of windows in the building, given that each level has a variable number of windows which follows a specific pattern. # Requirements Implement the function `total_windows()` that calculates the total number of windows based on the level of the building. # Pattern Given The pattern of windows can be described as follows: - Level 1 has 5 windows. - Level 2 has 10 windows. - Level 3 has 15 windows. - And so forth, with each level increasing by 5 additional windows from the previous level. # Function Signature ```python def total_windows(levels: int) -> int | ValueError: pass ``` # Input Parameters - `levels`: The number of levels in the building (integer greater than or equal to 1). # Output Return the total number of windows in the building. If the input parameter is not valid (less than 1), return `ValueError` with the message \\"Input Error: Levels must be greater than or equal to 1.\\" # Example ```python >>> total_windows(1) 5 >>> total_windows(3) 30 >>> total_windows(5) 75 >>> total_windows(0) ValueError(\'Input Error: Levels must be greater than or equal to 1.\') >>> total_windows(-3) ValueError(\'Input Error: Levels must be greater than or equal to 1.\') >>> total_windows() Traceback (most recent call last): ... TypeError: total_windows() missing 1 required positional argument: \'levels\' ``` # Constraints - The function should check if the input value for levels is greater than or equal to 1. - Handle edge cases where the input is less than 1 appropriately by raising a `ValueError`. - Raise a `TypeError` if the number of provided arguments is incorrect. # Implementation To calculate the total number of windows, you can use the following approach: 1. Iterate through each level from 1 to `levels`. 2. Calculate the number of windows for each level using the pattern. 3. Sum the windows across all levels to get the total. # Example Calculation For `levels = 3`: - Level 1: 5 windows - Level 2: 10 windows - Level 3: 15 windows Total windows = 5 + 10 + 15 = 30","solution":"def total_windows(levels: int) -> int: Calculates the total number of windows in a building with a given number of levels. Each level i has 5 * i windows. Args: levels (int): The number of levels in the building. Returns: int: The total number of windows in the building. Raises: ValueError: If the input levels is less than 1. if levels < 1: raise ValueError(\'Input Error: Levels must be greater than or equal to 1.\') total = sum(5 * i for i in range(1, levels + 1)) return total"},{"question":"Scenario As a software development engineer, you often need to generate unique identifiers for various objects in your applications. A common approach is to use GUIDs (Globally Unique Identifiers). In this question, your task involves generating and validating these identifiers. This requires a solid understanding of string manipulation, regular expressions, and basic validation techniques. Problem Statement Given a string `s`, implement the function `is_valid_guid(s: str) -> bool`, which determines whether the string is a valid GUID. A valid GUID satisfies the following format: - 32 hexadecimal characters (0-9, a-f, A-F) - Contains 4 hyphens inserted at positions 9, 14, 19, and 24, respectively. For simplicity, you may assume the input string is well-formed and contains only alphanumeric characters or hyphens. Input - `s` (string): A string representing the GUID. The string length will always be 36 characters including the hyphens. Output - Returns a boolean indicating whether the provided string is a valid GUID. Function Signature ```python def is_valid_guid(s: str) -> bool: pass ``` Example ```python >>> is_valid_guid(\\"123e4567-e89b-12d3-a456-426614174000\\") True >>> is_valid_guid(\\"123e4567e89b12d3a456426614174000\\") False >>> is_valid_guid(\\"Z23e4567-e89b-12d3-a456-426614174000\\") False ``` Constraints - The provided string will always have a length of 36 characters. - Case insensitivity check: characters can be in uppercase or lowercase. Note Consider using regular expressions for an elegant and efficient solution, taking special care to validate the structure and contents of the string.","solution":"import re def is_valid_guid(s: str) -> bool: Determines whether the input string `s` is a valid GUID. A valid GUID has the format of 8-4-4-4-12 hexadecimal characters. Args: s (str): The string to check. Returns: bool: True if the string is a valid GUID, False otherwise. pattern = re.compile(r\'^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}\') return bool(pattern.match(s))"},{"question":"# Circular Array Rotation You are given an array of integers `arr` and an integer `k` representing the number of times the array should be rotated to the right. Your task is to implement a function that returns the array after `k` right rotations. # Function Signature ```python def rotate_array(arr: list, k: int) -> list: ``` # Input - `arr` (list of int): A list of integers (0 ≤ `len(arr)` ≤ 1000, -10^9 ≤ `arr[i]` ≤ 10^9) - `k` (int): A non-negative integer representing the number of rotations (0 ≤ `k` ≤ 10^9) # Output - Returns (list of int): The array after `k` right rotations. # Constraints - An empty array remains empty regardless of the number of rotations. - The rotations are circular, meaning the elements that fall off the end reappear at the beginning. # Example ```python def test_rotate_array(): assert rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_array([1, 2, 3], 4) == [3, 1, 2] assert rotate_array([0, 0, 0], 1) == [0, 0, 0] assert rotate_array([], 5) == [] assert rotate_array([1], 10) == [1] test_rotate_array() ``` # Description 1. Implement the `rotate_array` function to take in an array and the number of rotations and return the array after the specified number of rotations. 2. Consider optimizing the rotations using modulo arithmetic to avoid unnecessary full rotations. 3. Include appropriate checks to handle errors and edge cases. # Hint Calculate the effective number of rotations by taking `k % len(arr)` to handle cases where `k` is larger than the length of the array.","solution":"def rotate_array(arr, k): Rotates the array \'arr\' to the right by \'k\' steps. Parameters: arr (List[int]): The input array to rotate. k (int): The number of rotations to perform. Returns: List[int]: The rotated array. if not arr: return arr n = len(arr) k = k % n # Effective rotations return arr[-k:] + arr[:-k]"},{"question":"# Matrix Diagonal Traversal Scenario Alice is currently working on optimizing image processing algorithms. Part of her task involves processing a matrix of pixel values in a diagonal traversal manner. Diagonal traversal starts from the top-left corner of the matrix, collects elements along each diagonal, and proceeds to the next diagonal until the entire matrix is processed. Objective Implement a function `diagonal_traversal` in Python that takes a 2D matrix as input and returns a list of its elements traversed diagonally. The function should handle both square and rectangular matrices. Requirements * **Function Specifications**: * The function should be efficient with respect to both time and space complexities. * Handle edge cases like empty matrices. * **Constraints**: * The dimensions of the matrix `m x n` should be such that `1 <= m, n <= 1000`. * The input elements are integers with values `-1000 <= matrix[i][j] <= 1000`. * **Performance**: * Ensure traversal is done systematically without redundancies. Implementation Given the following function template: ```python def diagonal_traversal(matrix: List[List[int]]) -> List[int]: Returns the elements of the matrix in diagonal order traversal. Args: matrix (List[List[int]]): 2D list of integers representing the matrix. Returns: List[int]: List of elements of the matrix in diagonal order. Examples: >>> diagonal_traversal([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [1, 2, 4, 7, 5, 3, 6, 8, 9] >>> diagonal_traversal([[1, 2], [3, 4]]) [1, 2, 3, 4] >>> diagonal_traversal([[1]]) [1] >>> diagonal_traversal([]) [] # Your implementation here ``` Complete the implementation of the `diagonal_traversal` function. Ensure it adheres to the constraints and optimally processes the matrix.","solution":"from typing import List def diagonal_traversal(matrix: List[List[int]]) -> List[int]: Returns the elements of the matrix in diagonal order traversal. Args: matrix (List[List[int]]): 2D list of integers representing the matrix. Returns: List[int]: List of elements of the matrix in diagonal order. if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) result = [] for d in range(m + n - 1): if d % 2 == 0: r = range(0, d + 1)[::-1] else: r = range(0, d + 1) for i in r: j = d - i if 0 <= i < m and 0 <= j < n: result.append(matrix[i][j]) return result"},{"question":"# Product Category Comprehension Context An e-commerce website categorizes its products into multiple categories for easy browsing and filtering by customers. Each product belongs to one or more categories, and customers often search for products within specific categories to find what they need. Task Write two functions, `categorize_product` and `products_by_category`. The first function should categorize products by assigning them to provided categories. The second function should return a list of products that belong to a specified category. Specifications: **Function 1: categorize_product** * **Input**: product (str), categories (list of str) * **Output**: None **Function 2: products_by_category** * **Input**: category (str) * **Output**: list of str Example ```python categorize_product(\\"Smartphone\\", [\\"Electronics\\", \\"Mobile\\"]) categorize_product(\\"Laptop\\", [\\"Electronics\\", \\"Computers\\"]) categorize_product(\\"Shirt\\", [\\"Clothing\\", \\"Fashion\\"]) categorize_product(\\"Jeans\\", [\\"Clothing\\", \\"Fashion\\", \\"Casual Wear\\"]) electronics_products = products_by_category(\\"Electronics\\") # Expected Output: [\'Smartphone\', \'Laptop\'] clothing_products = products_by_category(\\"Clothing\\") # Expected Output: [\'Shirt\', \'Jeans\'] assert products_by_category(\\"Mobile\\") == [\'Smartphone\'] assert products_by_category(\\"Fashion\\") == [\'Shirt\', \'Jeans\'] ``` Constraints 1. Both functions should work without global state; products and their categories should be handled within the scope of the functions or using any appropriate data structure. 2. Categories can have overlapping products but all products listed must maintain their category associations correctly. 3. The `categorize_product` function can be called multiple times with the same product or different products.","solution":"from collections import defaultdict product_categories = defaultdict(list) def categorize_product(product, categories): Assigns the product to the specified categories. Args: product (str): The name of the product. categories (list of str): The list of categories to which the product belongs. for category in categories: if product not in product_categories[category]: product_categories[category].append(product) def products_by_category(category): Returns a list of products that belong to the specified category. Args: category (str): The category to filter products by. Returns: A list of products that belong to the specified category. return product_categories[category]"},{"question":"# Context You are working with a dataset of user activity logs from a website, where each row represents a user\'s session with various features including the length of the session in seconds and the number of actions performed. Your task is to implement a k-means clustering algorithm to segment users based on their activity patterns. # Requirements Implement a function `kmeans_clustering` that will group the users into a specified number of clusters using the k-means clustering algorithm. # Function Specification ```python def kmeans_clustering(data: np.ndarray, k: int, iterations: int) -> np.ndarray: Perform k-means clustering on the dataset to group users into k clusters. :param data: np.ndarray, matrix of input features where each row is a data point and each column corresponds to a feature. :param k: int, number of clusters. :param iterations: int, number of iterations for the k-means algorithm. :return: np.ndarray, matrix where each row corresponds to the cluster centroid. pass ``` # Input - `data` - Matrix of size `(n, p)`, where n is the number of data points and p is the number of features. - `k` - Number of clusters. - `iterations` - Number of iterations to run the k-means algorithm. # Output - Returns a matrix (of shape (k, p)) containing the cluster centroids. # Example ```python import numpy as np # Example inputs data = np.array([[2.0, 3.0], [2.5, 4.5], [3.0, 5.0], [10.0, 10.0], [10.5, 10.5], [11.0, 11.0]]) # Running the algorithm (pseudo outputs given default params) centroids = kmeans_clustering(data, k=2, iterations=100) print(centroids) # Example Output ``` # Constraints - Ensure that `k` is a positive integer. - Ensure that `iterations` is a positive integer. - Use numpy for array operations. # Notes - Properly initialize the centroids, possibly using random selection from the data points. - Update cluster assignments and centroids iteratively until convergence or until the maximum number of iterations is reached. - Additional auxiliary functions (like calculating the distance or updating cluster assignments) could be implemented but ensure they are integrated well within your main function.","solution":"import numpy as np def initialize_centroids(data, k): Randomly initialize the cluster centroids by selecting k unique data points. :param data: np.ndarray, matrix of input features. :param k: int, number of clusters. :return: np.ndarray, matrix containing the initialized centroids. indices = np.random.choice(data.shape[0], size=k, replace=False) centroids = data[indices] return centroids def assign_clusters(data, centroids): Assign each data point to the nearest centroid. :param data: np.ndarray, matrix of input features. :param centroids: np.ndarray, matrix of current centroids. :return: np.ndarray, array of cluster assignments. distances = np.linalg.norm(data[:, np.newaxis] - centroids, axis=2) return np.argmin(distances, axis=1) def update_centroids(data, assignments, k): Update centroids by computing the mean of all data points assigned to each cluster. :param data: np.ndarray, matrix of input features. :param assignments: np.ndarray, array of cluster assignments. :param k: int, number of clusters. :return: np.ndarray, updated centroids. new_centroids = np.array([data[assignments == i].mean(axis=0) for i in range(k)]) return new_centroids def kmeans_clustering(data, k, iterations): Perform k-means clustering on the dataset to group users into k clusters. :param data: np.ndarray, matrix of input features where each row is a data point and each column corresponds to a feature. :param k: int, number of clusters. :param iterations: int, number of iterations for the k-means algorithm. :return: np.ndarray, matrix where each row corresponds to the cluster centroid. centroids = initialize_centroids(data, k) for _ in range(iterations): assignments = assign_clusters(data, centroids) centroids = update_centroids(data, assignments, k) return centroids"},{"question":"# Sum of Unique Elements You are to implement a function that takes a list of integers as input and returns the sum of elements that only appear once in the list. If there are no unique elements, the function should return 0. # Function Signature ```python def sum_of_unique_elements(numbers: list) -> int: ``` # Input: * A list of integers `numbers` where `0 <= len(numbers) <= 10^5` and all elements are in the range of `-10^6` to `10^6`. # Output: * An integer representing the sum of unique elements in the list. # Constraints: * The input list can be empty. * The function should handle large inputs efficiently both in terms of time and space complexity. # Examples: ```python >>> sum_of_unique_elements([4, 5, 2, 4, 3, 5, 2]) 3 >>> sum_of_unique_elements([1, 2, 3, 4, 5]) 15 >>> sum_of_unique_elements([10, 10, 10, 10]) 0 >>> sum_of_unique_elements([]) 0 >>> sum_of_unique_elements([1, 2, 2, 3, 3, 3, 4, 5]) 10 ``` # Explanation: 1. Initialize a dictionary to count the occurrences of each element in the list. 2. Iterate over the list and update the count for each element in the dictionary. 3. Iterate over the dictionary and sum the keys that have a count of 1. 4. Return the sum of these unique elements. 5. Ensure the function handles edge cases such as an empty list or a list with no unique elements.","solution":"def sum_of_unique_elements(numbers: list) -> int: Returns the sum of elements in the list that appear only once. If there are no unique elements, the function returns 0. from collections import defaultdict # Create a dictionary to count occurrences of each element count_dict = defaultdict(int) # Count occurrences of each element for num in numbers: count_dict[num] += 1 # Compute the sum of elements that appear only once unique_sum = sum(num for num, count in count_dict.items() if count == 1) return unique_sum"},{"question":"# Coding Assessment Question Context The task involves determining the longest common subsequence (LCS) between two strings, a classic problem in computer science, particularly within the domains of bioinformatics and natural language processing. Calculating the LCS is instrumental in understanding similarities between sequences and is widely used. Task Write a function `longest_common_subsequence(s1: str, s2: str) -> int` that returns the length of the longest common subsequence between two given strings `s1` and `s2`. This problem tests your ability to implement dynamic programming techniques to solve sequence alignment problems. Input and Output Formats * **Input**: * `s1 (str)`: A string of length 1 ≤ |s1| ≤ 1,000 * `s2 (str)`: A string of length 1 ≤ |s2| ≤ 1,000 * **Output**: * An integer representing the length of the longest common subsequence between `s1` and `s2`. Constraints and Performance Requirements * You must ensure that the solution efficiently handles strings up to a length of 1,000. * Optimize for both time and space complexity, typically O(n*m), where n and m are the lengths of the strings. Special Notes 1. Ensure that edge cases such as empty strings and no common subsequences are correctly handled. 2. You may use tabulation or memoization strategies for dynamic programming to achieve the desired performance. Example ```python def longest_common_subsequence(s1: str, s2: str) -> int: pass ``` **Example Usage:** ```python >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence(\\"abcdef\\", \\"defabc\\") 3 ```","solution":"def longest_common_subsequence(s1: str, s2: str) -> int: Returns the length of the longest common subsequence between two strings s1 and s2. n = len(s1) m = len(s2) # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"# Coding Question: Prime Factorization and Divisors Calculation You are tasked with implementing a function that takes an integer ( n ) and returns two things: 1. A list of all prime factors of ( n ). 2. The total number of divisors of ( n ). This method ensures the computation uses efficient algorithms for prime checking and factorization to handle moderately large inputs. Function Signature ```python def prime_factors_and_divisors(n: int) -> (list, int): Calculate the prime factors and the number of divisors of a given integer. Parameters: n (int): The integer to factorize (1 <= n <= 10^12). Returns: tuple: A tuple containing a list of prime factors of n, and an integer representing the total number of divisors of n. pass ``` # Input * An integer `n` where ( 1 leq n leq 10^{12} ) # Output * A tuple: * The first element is a list of integers representing the prime factors of ( n ) (without repetition). * The second element is an integer representing the total number of divisors of ( n ). # Constraints * Your function should handle large inputs efficiently. * Perform input validation and handle edge cases with an appropriate message. # Performance Requirements * Time Complexity: ( O(sqrt{n}) ) * Space Complexity: ( O(sqrt{n}) ) # Example Given input: ```python print(prime_factors_and_divisors(28)) ``` Expected output: ```python ([2, 7], 6) ``` # Scenario Imagine you are working on a cryptographic application where prime factorization and knowledge of divisors play a crucial role for encryption algorithms and security protocols. It is vital to compute these values quickly and accurately even for very large inputs.","solution":"def prime_factors_and_divisors(n: int) -> (list, int): Calculate the prime factors and the number of divisors of a given integer. Parameters: n (int): The integer to factorize (1 <= n <= 10^12). Returns: tuple: A tuple containing a list of prime factors of n, and an integer representing the total number of divisors of n. if n <= 0: raise ValueError(\\"Input must be a positive integer.\\") if n == 1: return ([], 1) def prime_factors(n): i = 2 factors = {} while i * i <= n: while (n % i) == 0: if i in factors: factors[i] += 1 else: factors[i] = 1 n //= i i += 1 if n > 1: factors[n] = 1 return factors factors = prime_factors(n) prime_factors_list = list(factors.keys()) num_divisors = 1 for exponent in factors.values(): num_divisors *= (exponent + 1) return (prime_factors_list, num_divisors)"},{"question":"# Intersection of Two Sorted Arrays You are given two functions that deal with finding common elements in two sorted arrays: 1. `find_intersection(arr1: list, arr2: list) -> list`: This function finds the intersection of two sorted arrays and returns it as a list. 2. `merge_sort(arr: list) -> list`: This function sorts the input list using the merge sort algorithm and returns the sorted list. Task Your task is to write a function `sorted_intersection(arr1: list, arr2: list) -> list` which combines the functionality of the above two functions: - The function should first ensure that both input arrays are sorted using the `merge_sort` function. - Then, find and return the intersection of these two sorted arrays. Input: - `arr1` (list of integers): A non-empty list of integers. - `arr2` (list of integers): A non-empty list of integers. Output: - A list of integers representing the intersection of the two arrays. Examples: 1. **Input**: [1, 3, 4, 5, 7], [2, 3, 5, 6] **Output**: [3, 5] 2. **Input**: [10, 20, 30], [30, 40, 50] **Output**: [30] 3. **Input**: [1, 2, 2, 3], [2, 2, 4] **Output**: [2, 2] 4. **Input**: [7, 8, 9], [2, 3, 5] **Output**: [] Additional Requirements: - Ensure the function handles duplicate elements correctly by including them in the intersection as many times as they appear in both arrays. - The input arrays may contain negative integers.","solution":"def merge_sort(arr): if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left, right): sorted_array = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 while i < len(left): sorted_array.append(left[i]) i += 1 while j < len(right): sorted_array.append(right[j]) j += 1 return sorted_array def find_intersection(arr1, arr2): i = j = 0 intersection = [] while i < len(arr1) and j < len(arr2): if arr1[i] == arr2[j]: intersection.append(arr1[i]) i += 1 j += 1 elif arr1[i] < arr2[j]: i += 1 else: j += 1 return intersection def sorted_intersection(arr1, arr2): sorted_arr1 = merge_sort(arr1) sorted_arr2 = merge_sort(arr2) return find_intersection(sorted_arr1, sorted_arr2)"},{"question":"# Problem Statement You are tasked with creating a function that processes a list of employee records and determines the employees who are eligible for a performance bonus. The employee records are provided as dictionaries within a list, and the eligibility for a bonus depends on certain criteria: the number of projects completed and their overall performance rating. Your task: 1. **Filter Employees**: Identify employees who have completed at least a given number of projects and have a performance rating above a specified threshold. 2. **Sorting**: Return the eligible employees sorted by their performance rating in descending order. 3. **Additional Data Extraction**: Extract and return specific fields for each eligible employee. Function Signature: ```python def get_bonus_eligible_employees( employees: list[dict], min_projects: int, min_rating: float, fields: list[str] ) -> list[dict]: employees : list[dict] : List of employee records with keys \\"name\\", \\"projects_completed\\", and \\"performance_rating\\" min_projects : int : Minimum number of projects an employee must have completed to be eligible min_rating : float : Minimum performance rating required fields : list[str] : List of specific fields to include in the result for each eligible employee ``` Guidelines: 1. **Filtering**: Only include employees who meet both the minimum number of projects completed and the performance rating criteria. 2. **Sorting**: Sort the eligible employees by their performance ratings in descending order. 3. **Field Extraction**: Include only the specified fields for each eligible employee in the output. Input and Output: * **Input**: - `employees` : A list of dictionaries where each dictionary represents an employee record, including the keys: \\"name\\", \\"projects_completed\\", and \\"performance_rating\\". - `min_projects` : An integer specifying the minimum number of projects an employee must have completed to be eligible for a bonus. - `min_rating` : A float specifying the minimum performance rating required for eligibility. - `fields` : A list of strings specifying the fields to include in the result for each eligible employee. * **Output**: A list of dictionaries with filtered, sorted, and extracted employee data. Constraints: * Return an empty list if no employees meet the eligibility criteria. * Handle invalid field names gracefully and exclude them from the results. * Ensure the function is efficient even with a larger list of employee records. Example: ```python # Sample employee data employees = [ {\\"name\\": \\"Alice\\", \\"projects_completed\\": 5, \\"performance_rating\\": 4.5}, {\\"name\\": \\"Bob\\", \\"projects_completed\\": 3, \\"performance_rating\\": 4.0}, {\\"name\\": \\"Charlie\\", \\"projects_completed\\": 7, \\"performance_rating\\": 3.9} ] # Field-specific and eligibility criteria results = get_bonus_eligible_employees( employees, min_projects=4, min_rating=4.0, fields=[\\"name\\", \\"performance_rating\\"] ) # Output example # Should return filtered, sorted, and specific fields for eligible employees [ {\\"name\\": \\"Alice\\", \\"performance_rating\\": 4.5} ] ```","solution":"def get_bonus_eligible_employees(employees, min_projects, min_rating, fields): Returns the list of employees who are eligible for a performance bonus based on the criteria. Args: employees (list[dict]): List of employee records. min_projects (int): Minimum number of projects an employee must have completed to be eligible. min_rating (float): Minimum performance rating required. fields (list[str]): List of specific fields to include in the result for each eligible employee. Returns: list[dict]: List of dictionaries with filtered, sorted, and extracted employee data. # Filter employees based on the criteria eligible_employees = [ employee for employee in employees if employee[\\"projects_completed\\"] >= min_projects and employee[\\"performance_rating\\"] >= min_rating ] # Sort the eligible employees by performance_rating in descending order eligible_employees.sort(key=lambda x: x[\\"performance_rating\\"], reverse=True) # Extract only the specified fields final_employees = [ {field: employee[field] for field in fields if field in employee} for employee in eligible_employees ] return final_employees"},{"question":"# Problem Statement You are required to solve a problem related to temperature data analysis from various monitoring stations. Each station records the temperature in Celsius throughout the day and reports the readings. # Your Task 1. **Compute Average Daily Temperature**: Implement a function that calculates the average temperature of a given list of temperature readings. 2. **Detect Temperature Anomaly**: Implement a function that identifies if any of the recorded temperatures deviate significantly from the average by a given threshold. A temperature reading is considered anomalous if it is more than the threshold units away from the average temperature. # Instructions 1. **average_temperature**: * **Input**: `temperatures` (List[float]) - a list of temperature readings in Celsius. * **Output**: `float` - the average temperature of all the readings. * **Constraints**: The list will contain at least one reading, and each reading will be a valid floating-point number. 2. **detect_anomaly**: * **Input**: `temperatures` (List[float]), `threshold` (float) - a list of temperature readings and the threshold value. * **Output**: `bool` - True if any temperature is considered anomalous based on the given threshold, and False otherwise. * **Constraints**: The list will contain at least one reading, and each reading will be a valid floating-point number. # Example ```python >>> average_temperature([20.5, 22.0, 19.5, 25.0]) 21.75 >>> detect_anomaly([20.5, 22.0, 19.5, 25.0], 3.0) False >>> detect_anomaly([20.5, 22.0, 19.5, 30.0], 3.0) True ``` # Requirements - The solution should handle edge cases involving invalid inputs. - Performance should be O(n) for both functions, where n is the number of temperature readings. - Adhere to the provided constraints for correctness.","solution":"def average_temperature(temperatures): Calculates the average temperature of the given list of temperature readings. Parameters: temperatures (List[float]): List of temperature readings in Celsius. Returns: float: The average temperature. if not temperatures: raise ValueError(\\"The list of temperatures must contain at least one value.\\") return sum(temperatures) / len(temperatures) def detect_anomaly(temperatures, threshold): Identifies if any of the recorded temperatures deviate significantly from the average by a given threshold. Parameters: temperatures (List[float]): List of temperature readings in Celsius. threshold (float): The threshold value to detect anomalies. Returns: bool: True if any temperature is considered anomalous, False otherwise. avg_temp = average_temperature(temperatures) return any(abs(temp - avg_temp) > threshold for temp in temperatures)"},{"question":"# String Transformation Challenge **Context**: You are tasked with building a system that can transform a string by performing multiple predefined operations. Each operation is either reversing a substring, deleting a substring, or replacing all occurrences of a substring with another substring. **Task**: Implement the function `transform_string(s: str, operations: List[Tuple[str, ...]]) -> str` that performs a series of transformations on the input string `s`. **Input**: - `s`: A string containing alphanumeric characters and spaces. - `operations`: A list of tuples, each specifying an operation. The first element of each tuple will be one of the following operations: - `(\\"reverse\\", start, end)`: Reverse the substring from index `start` to `end` inclusive (0-indexed). - `(\\"delete\\", start, end)`: Delete the substring from index `start` to `end` inclusive. - `(\\"replace\\", old, new)`: Replace all occurrences of substring `old` with substring `new`. **Output**: - Return the transformed string after applying all the operations in the given order. **Constraints**: - 0 ≤ `start` ≤ `end` < len(s) - `old` and `new` are non-empty strings. - Operations are guaranteed to be valid. **Examples**: ```python >>> transform_string(\\"abcdef\\", [(\\"reverse\\", 2, 4)]) \\"abedcf\\" >>> transform_string(\\"abcdef\\", [(\\"delete\\", 1, 3)]) \\"aef\\" >>> transform_string(\\"hello world\\", [(\\"replace\\", \\"world\\", \\"there\\")]) \\"hello there\\" >>> transform_string(\\"hello there\\", [(\\"replace\\", \\"there\\", \\"world\\"), (\\"reverse\\", 0, 4)]) \\"olleh world\\" ``` **Hints**: - Handle each operation sequentially as they are presented in the `operations` list. - For reversing and deleting operations, make sure to adjust subsequent indices appropriately if operations are applied consecutively. - Consider edge cases such as reversing or deleting at the bounds of the string.","solution":"from typing import List, Tuple def transform_string(s: str, operations: List[Tuple[str, ...]]) -> str: Transforms the input string `s` by applying a series of operations in order. Parameters: s (str): Input string. operations (List[Tuple[str, ...]]): List of operations to apply on the string. Returns: str: Transformed string after applying all operations. for operation in operations: if operation[0] == \\"reverse\\": _, start, end = operation s = s[:start] + s[start:end+1][::-1] + s[end+1:] elif operation[0] == \\"delete\\": _, start, end = operation s = s[:start] + s[end+1:] elif operation[0] == \\"replace\\": _, old, new = operation s = s.replace(old, new) return s"},{"question":"# Array Rotation Coding Challenge **Context:** Array manipulation is a fundamental concept in programming that involves operations such as shifting and rearranging elements. In this challenge, you will implement an efficient algorithm to rotate an array to the right by a given number of steps. **Task:** Write a function to rotate an array of integers to the right by `k` steps, where `k` is non-negative. **Function Signature:** - `def rotate_array(nums: List[int], k: int) -> None` **Specifications:** 1. **Parameters:** - `nums` (List[int]): A list of integers. - `k` (int): A non-negative integer representing the number of steps to rotate the array. 2. **Output:** - The function should modify the input list `nums` in place and does not return anything. 3. **Constraints:** - The length of the array `nums` will be in the range `[1, 10^5]`. - `k` will be in the range `[0, 10^9]`. 4. **Performance Requirements:** - Your solution should work in O(n) time complexity, with O(1) additional space complexity (modifying the array in-place). **Example Usage:** ```python nums = [1, 2, 3, 4, 5, 6, 7] rotate_array(nums, 3) print(nums) # Output: [5, 6, 7, 1, 2, 3, 4] nums = [-1, -100, 3, 99] rotate_array(nums, 2) print(nums) # Output: [3, 99, -1, -100] ``` **Hints:** - Consider the effect of a large `k` relative to the length of `nums`. - Think about how the array can be divided into parts and recombined to achieve the rotation. - In-place rotation means you should strive to use constant extra space. **Edge Cases:** - Ensure handling of cases where `k` is greater than the length of the array. - Handle scenarios where the array contains a single element or all elements are the same.","solution":"from typing import List def rotate_array(nums: List[int], k: int) -> None: Rotates the array nums to the right by k steps in place. n = len(nums) k = k % n # Handle cases where k is larger than the length of nums def reverse(start: int, end: int) -> None: Reverse the elements of nums between start and end inclusive. while start < end: nums[start], nums[end] = nums[end], nums[start] start += 1 end -= 1 # When k is 0, no need to rotate if k == 0: return # Reverse the whole array reverse(0, n - 1) # Reverse the first k elements reverse(0, k - 1) # Reverse the elements from k to the end of the array reverse(k, n - 1)"},{"question":"# Coding Assessment Question **Context:** You are given an implementation of a Directed and an Undirected Graph in Python. These graphs support operations such as adding vertices and edges, removing pairs, traversing nodes using DFS (Depth-First Search) and BFS (Breadth-First Search), and cycle detection. **Task:** **Implement a function, `find_all_paths(graph, start, end)`,**, that finds all paths between the `start` and `end` nodes in the given graph. The function should return a list of paths, where each path is represented as a list of nodes. If there\'s no path from start to end, return an empty list. **Input & Output**: - **graph**: An instance of either `DirectedGraph` or `Graph` (Undirected Graph). - **start**: The starting node (integer). - **end**: The target node (integer). **Requirements**: - Implement the function inside the given class such that it utilizes graph traversal methods efficiently to find all possible paths. - Ensure consideration of edge cases such as: - Unreachable nodes. - Non-existent nodes. - Graph with cycles. **Example**: ```python g = Graph() g.add_pair(1, 2) g.add_pair(2, 3) g.add_pair(1, 3) print(g.find_all_paths(1, 3)) # Output: [[1, 3], [1, 2, 3]] dg = DirectedGraph() dg.add_pair(1, 2) dg.add_pair(2, 3) print(dg.find_all_paths(1, 3)) # Output: [[1, 2, 3]] print(dg.find_all_paths(3, 1)) # Output: [] # since it\'s directional and there is no path from 3 to 1 ```","solution":"class Graph: def __init__(self): self.adj_list = {} def add_pair(self, node1, node2): # For undirected graph add both ways if node1 not in self.adj_list: self.adj_list[node1] = [] if node2 not in self.adj_list: self.adj_list[node2] = [] self.adj_list[node1].append(node2) self.adj_list[node2].append(node1) def find_all_paths(self, start, end): def dfs(current, path): if current == end: paths.append(list(path)) return for neighbor in self.adj_list.get(current, []): if neighbor not in path: path.append(neighbor) dfs(neighbor, path) path.pop() paths = [] dfs(start, [start]) return paths class DirectedGraph: def __init__(self): self.adj_list = {} def add_pair(self, from_node, to_node): # For directed graph add only one way if from_node not in self.adj_list: self.adj_list[from_node] = [] self.adj_list[from_node].append(to_node) def find_all_paths(self, start, end): def dfs(current, path): if current == end: paths.append(list(path)) return for neighbor in self.adj_list.get(current, []): if neighbor not in path: path.append(neighbor) dfs(neighbor, path) path.pop() paths = [] dfs(start, [start]) return paths"},{"question":"# Coding Assessment Question You are tasked with writing a function `next_prime(n: int) -> int` which takes an integer `n` and returns the smallest prime number greater than `n`. **Function Signature**: ```python def next_prime(n: int) -> int: pass ``` # Input - An integer `n` where `1 <= n <= 10^6`. # Output - Return an integer which is the smallest prime number greater than `n`. # Example ```python assert next_prime(3) == 5 assert next_prime(11) == 13 assert next_prime(17) == 19 assert next_prime(24) == 29 ``` # Constraints - The function should raise a `ValueError` if `n` is not a positive integer. # Performance Requirements - Your solution should handle the provided constraints efficiently, testing edge cases with input values close to the upper limit. # Explanation Consider providing comments within your code explaining the steps or approaches taken, especially around: - Input validation - Efficient prime checking algorithm - Handling of exceptional scenarios # Hints - You may use Python\'s built-in `math` module if needed. - To check if a number is prime, devise an efficient algorithm to reduce computation time, particularly for larger numbers. Good luck!","solution":"import math def is_prime(num): Efficient check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def next_prime(n): Returns the smallest prime number greater than n. if not isinstance(n, int) or n <= 0: raise ValueError(\\"Input must be a positive integer.\\") candidate = n + 1 while not is_prime(candidate): candidate += 1 return candidate"},{"question":"# Scenario: You are designing an automated inventory management system for a warehouse. The system must predict the price of items based on historical data. You have a dataset of previous sales, and each entry contains the item type, quantity sold, and the sale price. You need to create a function that predicts the average price of an item type based on previously sold quantities. # Problem Description: Implement the function `predict_price(data, item_type)` that calculates the predicted price for a given item type. # Function Signature: ```python def predict_price(data: List[Tuple[str, int, float]], item_type: str) -> float: ``` # Input: 1. `data` (List[Tuple[str, int, float]]): A list of tuples where each tuple contains: - A string representing the item type. - An integer representing the quantity sold. - A float representing the sale price. 2. `item_type` (str): A string representing the type of item for which you want to predict the price. # Output: - Returns a float value representing the predicted average price for the specified item type. # Constraints: - 1 <= len(data) <= 10000 - 1 <= quantity sold <= 100 - 0 <= sale price <= 10000 - The item type string will be in lowercase and contain only alphabetic characters. # Requirements: 1. Include a robust procedure to correctly average the sale prices for the given item type. 2. Handle cases where the item type is not present in the data by returning 0.0. # Example: ```python from typing import List, Tuple def predict_price(data: List[Tuple[str, int, float]], item_type: str) -> float: total_price = 0.0 total_quantity = 0 for entry in data: if entry[0] == item_type: total_quantity += entry[1] total_price += entry[1] * entry[2] if total_quantity == 0: return 0.0 return total_price / total_quantity # Test cases data = [ (\\"apple\\", 10, 2.0), (\\"banana\\", 5, 1.5), (\\"apple\\", 20, 1.8), (\\"orange\\", 15, 3.0), (\\"banana\\", 25, 1.6) ] print(predict_price(data, \\"apple\\")) # Output: 1.8666666666666667 print(predict_price(data, \\"banana\\")) # Output: 1.575 print(predict_price(data, \\"kiwi\\")) # Output: 0.0 ``` Create unit tests to verify the functionality of your implementation.","solution":"from typing import List, Tuple def predict_price(data: List[Tuple[str, int, float]], item_type: str) -> float: total_price = 0.0 total_quantity = 0 for entry in data: if entry[0] == item_type: total_quantity += entry[1] total_price += entry[1] * entry[2] if total_quantity == 0: return 0.0 return total_price / total_quantity"},{"question":"# Scenario: You are working on a matrix manipulation library for a scientific application. One of the frequently needed operations is to rotate a square matrix (n x n) 90 degrees clockwise. Your task is to implement this functionality efficiently. # Problem Statement: Given a square matrix (a list of lists in Python), return the matrix rotated 90 degrees clockwise. Ensure the function handles edge cases such as an empty matrix. # Function Signature: ```python def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: ``` # Input: * `matrix`: A List of Lists of integers, representing the square matrix of size `n x n`. # Output: * Returns a List of Lists of integers representing the rotated matrix. # Constraints: * 0 <= n <= 1000 * Each element in the matrix is an integer. # Example: ```python assert rotate_matrix([[1, 2], [3, 4]]) == [[3, 1], [4, 2]] assert rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]] assert rotate_matrix([[1]]) == [[1]] assert rotate_matrix([]) == [] ``` # Additional Instructions: * You should not use extra space for another matrix; the rotation should be done in-place if possible. * Handle the case where the input matrix is empty. In this case, return an empty list.","solution":"def rotate_matrix(matrix): Rotates a given n x n square matrix 90 degrees clockwise. if not matrix or not matrix[0]: return [] n = len(matrix) # First step is to transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then reverse each row to get the rotated matrix for i in range(n): matrix[i].reverse() return matrix"},{"question":"# Question You are tasked with creating a function that simulates a simple in-memory key-value store with a versioning mechanism. The key-value store should let you set keys to specific values and retrieve the latest value for a given key. Moreover, it should be able to return the historical values of a key based on time versions. Implement the function `KeyValStore` class that fulfills the following requirements: * **Methods**: * `set_key(key: str, value: str) -> None`: * Sets the value for the specified key. * Internally stores the time version as an incremental integer starting from 1. * `get_key(key: str) -> str`: * Returns the latest value set for the specified key. * `get_key_version(key: str, version: int) -> str`: * Returns the value for the specified key at the specified version. * Raises a `ValueError` if the version does not exist. * **Constraints**: * If `get_key` is called on a non-existent key, raise a `KeyError`. * Values and keys are case-sensitive. * Operations should have an average time complexity of O(1). * **Examples**: ```python store = KeyValStore() store.set_key(\'key1\', \'value1\') store.set_key(\'key1\', \'value2\') store.set_key(\'key2\', \'value3\') assert store.get_key(\'key1\') == \'value2\' assert store.get_key_version(\'key1\', 1) == \'value1\' assert store.get_key_version(\'key1\', 2) == \'value2\' assert store.get_key(\'key2\') == \'value3\' try: store.get_key(\'key3\') except KeyError: print(\'KeyError\') try: store.get_key_version(\'key1\', 3) except ValueError: print(\'ValueError\') ``` * **Definition**: ```python class KeyValStore: def __init__(self): self.store = {} self.version_store = {} def set_key(self, key: str, value: str) -> None: current_version = self.version_store.get(key, 0) + 1 if key not in self.store: self.store[key] = {} self.store[key][current_version] = value self.version_store[key] = current_version def get_key(self, key: str) -> str: if key not in self.store or self.version_store[key] < 1: raise KeyError(f\\"The key \'{key}\' does not exist.\\") latest_version = self.version_store[key] return self.store[key][latest_version] def get_key_version(self, key: str, version: int) -> str: if key not in self.store or version not in self.store[key]: raise ValueError(f\\"The version \'{version}\' for key \'{key}\' does not exist.\\") return self.store[key][version] ``` This class handles a simple versioned key-value store, implementing a way to store, retrieve, and retrieve specific versions of keys efficiently.","solution":"class KeyValStore: def __init__(self): self.store = {} self.version_store = {} def set_key(self, key: str, value: str) -> None: current_version = self.version_store.get(key, 0) + 1 if key not in self.store: self.store[key] = {} self.store[key][current_version] = value self.version_store[key] = current_version def get_key(self, key: str) -> str: if key not in self.store or self.version_store[key] < 1: raise KeyError(f\\"The key \'{key}\' does not exist.\\") latest_version = self.version_store[key] return self.store[key][latest_version] def get_key_version(self, key: str, version: int) -> str: if key not in self.store or version not in self.store[key]: raise ValueError(f\\"The version \'{version}\' for key \'{key}\' does not exist.\\") return self.store[key][version]"},{"question":"# Problem Statement Inverted Pyramid Star Pattern You are required to write a function that prints an inverted pyramid star pattern for a given number of rows `n`. The printed pattern should follow the exact format shown in the examples below. # Function Signature ```python def inverted_pyramid(n: int) -> None: pass ``` # Input and Output **Input**: * `n` (integer): An integer `n` where `1 <= n <= 50`. **Output**: * The function should directly print the star pattern to the console. It does not return anything. # Constraints 1. The function should handle values of `n` up to 50. # Examples Consider the following examples to understand the required implementation: ```python inverted_pyramid(5) ``` Output: ``` ********* ******* ***** *** * ``` ```python inverted_pyramid(3) ``` Output: ``` ***** *** * ``` ```python inverted_pyramid(1) ``` Output: ``` * ``` # Hint You may find it useful to calculate the number of leading spaces and the number of stars to be printed for each row to create the correct alignment in the pattern. **Important Notes**: * You are not allowed to use any imported libraries beyond the base Python libraries. * Ensure that your pattern is printed with the exact spacing and formatting as shown in the examples. # Evaluation Criteria * **Correctness**: Does the function produce the correct star pattern for a range of inputs? * **Formatting**: Is the output pattern formatted precisely as described? * **Boundary Cases**: Have you considered edge cases such as the smallest input (`n` = 1)? # Submission Please submit your function `inverted_pyramid` as defined above.","solution":"def inverted_pyramid(n: int) -> None: Prints an inverted pyramid star pattern for n rows. if not (1 <= n <= 50): return for i in range(n): spaces = \' \' * i stars = \'*\' * (2 * (n - i) - 1) print(f\\"{spaces}{stars}\\")"},{"question":"Title: Generate All Unique Subsets of a Set # Description You are to write a function that generates all unique subsets of a given set of integers. The subsets should be returned as a list of lists, with each subset being a list of integers. The function should ensure that no subset is repeated. Your function should handle invalid input by raising a `ValueError` with the message \\"Input must be a list of integers.\\" # Function Signature ```python def generate_unique_subsets(input_set: list) -> list: pass ``` # Input * `input_set` (list): A list of integers representing the set. # Output * Returns a list of lists, each containing a unique subset of the given set. # Constraints * The function should only accept lists of integers. * If the input `input_set` is not a list or contains non-integer values, raise a `ValueError` with the message \\"Input must be a list of integers\\". * Ensure that the order of elements within each subset is non-decreasing. * The resulting list of subsets should have each subset sorted in non-decreasing order as well. # Examples ```python generate_unique_subsets([1, 2, 3]) # returns [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] generate_unique_subsets([4, 4, 2, 1]) # returns [[], [1], [2], [4], [1, 2], [1, 4], [2, 4], [1, 2, 4], [4, 4], [1, 4, 4], [2, 4, 4], [1, 2, 4, 4]] ``` # Notes * Make sure to test the function with edge cases such as an empty list, lists with duplicate elements, lists with single elements, and lists with negative numbers. * Pay attention to the constraint of non-decreasing order within the subsets and the resulting list of subsets.","solution":"def generate_unique_subsets(input_set): Generates all unique subsets of a given set of integers. Parameters: input_set (list): A list of integers representing the set. Returns: list: A list of lists, each containing a unique subset of the given set. # Check if input is a list of integers if not isinstance(input_set, list) or not all(isinstance(x, int) for x in input_set): raise ValueError(\\"Input must be a list of integers\\") # Sort the list to ensure subsets are generated in non-decreasing order input_set.sort() # Use a helper function for the recursive approach to generate subsets def backtrack(start, path, result): result.append(path) for i in range(start, len(input_set)): if i > start and input_set[i] == input_set[i-1]: continue # Skip duplicates backtrack(i + 1, path + [input_set[i]], result) result = [] backtrack(0, [], result) return result"},{"question":"# Problem Statement Write a function that takes a list of strings, each representing a product listing. Each listing contains the product\'s name and price, separated by a comma in the format `name,price`. Your task is to sort the listings based on the product names in alphabetical order. If two products have the same name, sort them based on their price in ascending order. * **Input**: A list of strings `product_listings` where each string is in the format `name,price`, where: * `name` is a string containing the product\'s name. * `price` is a positive floating-point number representing the product\'s price. * **Output**: A list of strings sorted based on the criteria mentioned. # Constraints * Product names consist only of alphabetical characters. * Prices are positive floating-point numbers. * There can be multiple products with the same name but different prices. * The input list contains at least one product listing but no more than 1000 listings. * The product names are case-insensitive during sorting. # Examples Given the input list: ``` [\\"banana,1.50\\", \\"apple,2.00\\", \\"apple,1.75\\", \\"banana,2.25\\"] ``` The correct output would be: ``` [\\"apple,1.75\\", \\"apple,2.00\\", \\"banana,1.50\\", \\"banana,2.25\\"] ``` Given the input list: ``` [\\"brush,5.00\\", \\"apple,2.00\\", \\"brush,2.50\\", \\"apple,1.50\\"] ``` The correct output would be: ``` [\\"apple,1.50\\", \\"apple,2.00\\", \\"brush,2.50\\", \\"brush,5.00\\"] ``` # Function Signature ```python def sort_product_listings(product_listings: list) -> list: pass ``` # Requirements * The function should handle case-insensitive sorting of product names. * Prices should be sorted in ascending order when product names are identical. * Ensure efficient handling of the input list with a maximum length of 1000 items.","solution":"def sort_product_listings(product_listings): Sorts a list of product listings based on alphabetical order of names. If two products have the same name, they are sorted based on their price in ascending order. Args: product_listings (list of str): List of product listings in the format name,price Returns: list of str: Sorted list of product listings based on the rules. # Split each listing into a tuple of (name, price). products = [] for listing in product_listings: name, price = listing.split(\',\') products.append((name.lower(), float(price), listing)) # Sort the products based on the (name, then price). products.sort(key=lambda p: (p[0], p[1])) # Extract the original listings from the sorted tuples. sorted_listings = [p[2] for p in products] return sorted_listings"},{"question":"# Scenario You work for a company that provides cloud storage services. Your team is tasked with developing a file synchronization feature that ensures files are properly updated in case of network failures or multiple device accesses. # Task Implement a function that simulates the synchronization process by identifying the most recent version of each file based on timestamps. # Function Signature ```python def sync_files(files): ``` # Inputs - `files` (List[Tuple[str, int, str]]): A list of tuples where each tuple (file_name, timestamp, device_id) represents a specific version of a file. `file_name` is a string, `timestamp` is an integer representing the last modified time, and `device_id` is a string representing the device where the file was last modified. # Outputs - A dictionary `latest_versions` (Dict[str, Tuple[int, str]]): A dictionary where each key is a `file_name` and the associated value is a tuple (timestamp, device_id) representing the most recent version of that file. # Constraints - `1 <= len(files) <= 10^4` (Ensure the file list is manageable) - `1 <= len(file_name) <= 100` (Ensure a reasonable file name length) - Timestamps are non-negative integers. - `1 <= len(device_id) <= 50` # Example Given the file list: ``` files = [ (\\"file1.txt\\", 1638316800, \\"deviceA\\"), (\\"file2.txt\\", 1638316805, \\"deviceB\\"), (\\"file1.txt\\", 1638316803, \\"deviceB\\"), (\\"file2.txt\\", 1638316802, \\"deviceA\\"), (\\"file3.txt\\", 1638316804, \\"deviceC\\") ] ``` The function should output: ``` { \\"file1.txt\\": (1638316803, \\"deviceB\\"), \\"file2.txt\\": (1638316805, \\"deviceB\\"), \\"file3.txt\\": (1638316804, \\"deviceC\\") } ``` # Remarks - Assume all timestamps are unique for each file version. - Focus on ensuring your solution efficiently handles the provided constraints. - Clearly document any assumptions or edge cases considered during the implementation.","solution":"def sync_files(files): Given a list of file versions, identify the most recent version of each file. Args: files (List[Tuple[str, int, str]]): List of tuples where each tuple (file_name, timestamp, device_id) represents a specific version of a file. Returns: Dict[str, Tuple[int, str]]: A dictionary where each key is a file_name and the associated value is a tuple (timestamp, device_id) representing the most recent version of the file. latest_versions = {} for file_name, timestamp, device_id in files: if file_name not in latest_versions or timestamp > latest_versions[file_name][0]: latest_versions[file_name] = (timestamp, device_id) return latest_versions"},{"question":"# Coding Challenge: Calculating the Circumference and Area of a Circle In this challenge, you are required to write a function that calculates both the circumference and the area of a circle given its radius. The circumference ( C ) of a circle is given by the formula ( C = 2pi r ), and the area ( A ) is given by ( A = pi r^2 ), where ( r ) is the radius of the circle. # Function Specification: ```python def circle_metrics(radius: float) -> tuple: Calculate the circumference and area of a circle. The circumference of a circle is 2 * π * r and the area is π * r^2, where r is the radius of the circle. Args: radius (float): The radius of the circle. Returns: tuple: A tuple containing two floating-point numbers: - The circumference of the circle - The area of the circle ``` # Constraints 1. The radius of the circle (`radius`) will be a non-negative float. 2. Use the value of ( pi ) as 3.14159. # Input * `radius`: a floating-point number representing the radius of the circle. # Output * Return a tuple consisting of two floating-point numbers: - The first element is the circumference of the circle. - The second element is the area of the circle. # Example ```python >>> circle_metrics(10) (62.8318, 314.159) >>> circle_metrics(0) (0.0, 0.0) >>> circle_metrics(2.5) (15.70795, 19.6349375) >>> circle_metrics(5) (31.4159, 78.53975) >>> circle_metrics(7.2) (45.23904, 162.860016) ``` # Additional Considerations Consider edge cases such as: * What happens if the radius is zero? * Ensure the precision of your calculations matches typical usage scenarios (e.g., two decimal places might be sufficient, but it\'s better to match the floating-point precision). Ensure your function is efficient and handles the input without errors for a robust and reliable solution.","solution":"def circle_metrics(radius: float) -> tuple: Calculate the circumference and area of a circle. The circumference of a circle is 2 * π * r and the area is π * r^2, where r is the radius of the circle. Args: radius (float): The radius of the circle. Returns: tuple: A tuple containing two floating-point numbers: - The circumference of the circle - The area of the circle pi = 3.14159 circumference = 2 * pi * radius area = pi * radius * radius return circumference, area"},{"question":"# Coding Assessment Question Longest Consecutive Subsequence You have been hired as a software engineer by a data analytics company. One of your tasks is to analyze sequences of integers to find the longest consecutive subsequence. A consecutive subsequence is a sequence in which each number follows the previous number without any gaps. **Task**: Write a Python function `longest_consecutive_subsequence(numbers: List[int]) -> int` that accepts a list of integers and returns the length of the longest consecutive subsequence found in the list. **Input Constraints**: - The list `numbers` can have between 1 and 10^5 integers. - Each integer in the list will be within the range of -10^6 to 10^6. **Performance Requirement**: Your solution should aim to efficiently handle the provided constraints, with a focus on linear time complexity. Example: ```python def longest_consecutive_subsequence(numbers: List[int]) -> int: pass # Example Usage assert longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) == 4 assert longest_consecutive_subsequence([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) == 9 ``` Explanation: In the first example, the longest consecutive subsequence is [1, 2, 3, 4], which has a length of 4. In the second example, the longest consecutive subsequence is [0, 1, 2, 3, 4, 5, 6, 7, 8], which has a length of 9.","solution":"from typing import List def longest_consecutive_subsequence(numbers: List[int]) -> int: if not numbers: return 0 numbers_set = set(numbers) longest_length = 0 for num in numbers_set: # Check if `num` is the start of a sequence if num - 1 not in numbers_set: current_num = num current_length = 1 while current_num + 1 in numbers_set: current_num += 1 current_length += 1 longest_length = max(longest_length, current_length) return longest_length"},{"question":"# Question: Implementing K-means Clustering You are provided with a list of data points that need to be clustered into a specified number of groups, ( k ), using the K-means clustering algorithm. Function Signature ```python def kmeans_clustering(data_points: list[list[float]], k: int, max_iterations: int = 100) -> list[int]: ``` # Input 1. `data_points` (list of lists): Each inner list contains feature values of a data point. 2. `k` (int): The number of clusters. 3. `max_iterations` (int, optional): The maximum number of iterations to run the algorithm. Default is 100. # Output * `cluster_labels` (list): A list of cluster labels assigned to each data point. # Constraints * All the elements in `data_points` will be floating-point numbers. * ( 0 < text{number of data points} leq 10^3 ) * ( 0 < text{number of features} leq 50 ) * ( 1 leq k leq 10 ) # Example ```python data_points = [ [1.0, 2.0], [2.0, 3.0], [3.0, 3.5], [1.5, 2.2], [3.1, 4.0], [3.2, 4.1] ] k = 2 kmeans_clustering(data_points, k) ``` Expected Output: ```python [0, 0, 1, 0, 1, 1] ``` # Explanation 1. Data points are initially assigned to clusters randomly. 2. Iteratively, the centroids of the clusters are recalculated and data points are reassigned to the nearest centroid. 3. The process is repeated until the assignments do not change or the maximum number of iterations is reached. # Notes 1. Choose initial cluster centroids randomly from the data points. 2. Use Euclidean distance to calculate the distance between data points and centroids. 3. Update the centroid of each cluster to the mean of the points assigned to it. # Grading Criteria * Correctness: The function should correctly assign data points to clusters. * Efficiency: The function should handle the input constraints within a reasonable time frame. * Convergence: The algorithm should converge within the provided maximum number of iterations. Hints 1. Initialize centroids and loop until convergence or max_iterations. 2. Calculate distances and reassess clusters at each iteration. 3. Recompute centroids as the mean of the assigned points. **Good Luck!**","solution":"import random from typing import List import numpy as np def kmeans_clustering(data_points: List[List[float]], k: int, max_iterations: int = 100) -> List[int]: Performs K-means clustering on the given data points. Parameters: data_points (list of list of float): The data points to cluster. k (int): The number of clusters. max_iterations (int): The maximum number of iterations to run the algorithm. Returns: list of int: The cluster labels assigned to each data point. n = len(data_points) if n == 0 or k <= 0: raise ValueError(\\"Number of data points must be greater than 0 and k must be a positive integer.\\") # Initialize centroids randomly from the data points data_points_np = np.array(data_points) centroids = data_points_np[random.sample(range(n), k)] labels = [0] * n for _ in range(max_iterations): # Assign data points to the nearest centroid for i in range(n): distances = np.linalg.norm(data_points_np[i] - centroids, axis=1) labels[i] = np.argmin(distances) # Calculate new centroids new_centroids = np.array([ data_points_np[np.array(labels) == j].mean(axis=0) if np.any(np.array(labels) == j) else centroids[j] for j in range(k) ]) # If centroids do not change, break out of the loop if np.allclose(centroids, new_centroids): break centroids = new_centroids return labels"},{"question":"# Scenario: You are working as a software engineer tasked with building an analytical tool for processing large sets of data. One critical component of this tool involves working with linked structures, specifically **Doubly Linked Lists**. You need to implement a feature that efficiently modifies the list. # Problem Statement: Your task is to implement a method called `reverse_between` for the `DoublyLinkedList` class that reverses the nodes of the linked list from position `m` to `n` (both inclusive). Implementation Requirements: - The method `reverse_between` should be added to the `DoublyLinkedList` class. - It should take two integer arguments `m` and `n`, where `1 ≤ m ≤ n ≤ length of the list`. - It should modify the list in place and should not return any value. # Constraints: 1. You can assume all integers in the nodes are unique. 2. The length of the constructed list is not greater than 5,000. Input: - The input will not come directly but will use the existing `DoublyLinkedList` and `Node` classes\' methods to create lists. Output: - The list should be modified in place reflecting the reversed section. # Example: Assuming you have a `DoublyLinkedList` instance as follows: ```python dll = DoublyLinkedList() dll.append(1) dll.append(2) dll.append(3) dll.append(4) dll.append(5) ``` After implementing `reverse_between`, calling `dll.reverse_between(2, 4)` will modify the list so that it becomes `[1, 4, 3, 2, 5]`. # Instructions: 1. Add your method to the `DoublyLinkedList` class. 2. Ensure it runs correctly for the example scenarios. 3. Check edge cases such as reversing a single node, reversing the entire list, and reversing the head or tail section. Good luck!","solution":"class Node: def __init__(self, data=None): self.data = data self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None def append(self, data): new_node = Node(data) if self.head is None: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node new_node.prev = last def reverse_between(self, m, n): if not self.head or m == n: return current = self.head pos = 1 # Move to the mth node while current and pos < m: current = current.next pos += 1 before_m_node = current.prev mth_node = current # Reverse nodes from m to n prev = None while current and pos <= n: next_node = current.next current.next = prev current.prev = next_node prev = current current = next_node pos += 1 nth_node = prev after_n_node = current # Connect before_m_node to nth_node if before_m_node: before_m_node.next = nth_node else: self.head = nth_node if nth_node: nth_node.prev = before_m_node # Connect mth_node to after_n_node if mth_node: mth_node.next = after_n_node if after_n_node: after_n_node.prev = mth_node def to_list(self): result = [] current = self.head while current: result.append(current.data) current = current.next return result"},{"question":"# Question: Duplicate Number Finder You are tasked with implementing two functions to find a duplicate number in a list of numbers. The goal is to assess your understanding of both searching techniques and utilize your ability to handle edge cases. Implement the following two functions according to the specifications given: 1. **find_duplicate_using_set** - **Input**: A list of integers. - **Output**: The first duplicated number found in the list. If no duplicates are found, return `None`. - **Constraints**: The function must raise a `ValueError` if the list is empty. 2. **find_duplicate_using_sort** - **Input**: A list of integers. - **Output**: The first duplicated number found in the list by first sorting the list. If no duplicates are found, return `None`. - **Constraints**: 1. The function must raise a `ValueError` if the list is empty. 2. Preserve the original list, do not modify it in-place. **Function Definitions**: ```python def find_duplicate_using_set(nums: list[int]) -> int | None: # Your code here def find_duplicate_using_sort(nums: list[int]) -> int | None: # Your code here ``` **Example Test Cases**: ```python assert find_duplicate_using_set([3, 1, 3, 4, 2]) == 3 assert find_duplicate_using_set([1, 2, 3, 4, 5]) == None assert find_duplicate_using_set([5, 1, 5, 2, 3]) == 5 assert find_duplicate_using_set([2, 2, 2, 2]) == 2 try: find_duplicate_using_set([]) except ValueError: print(\\"Caught ValueError as expected\\") assert find_duplicate_using_sort([3, 1, 3, 4, 2]) == 3 assert find_duplicate_using_sort([1, 2, 3, 4, 5]) == None assert find_duplicate_using_sort([5, 1, 5, 2, 3]) == 5 assert find_duplicate_using_sort([2, 2, 2, 2]) == 2 try: find_duplicate_using_sort([]) except ValueError: print(\\"Caught ValueError as expected\\") ``` **Requirements**: - Make sure to consider edge cases. - Optimize the duplicate detection where possible. - Adhere to the provided function signatures and constraints. Good luck!","solution":"def find_duplicate_using_set(nums): if not nums: raise ValueError(\\"The list is empty\\") seen = set() for num in nums: if num in seen: return num seen.add(num) return None def find_duplicate_using_sort(nums): if not nums: raise ValueError(\\"The list is empty\\") sorted_nums = sorted(nums) for i in range(1, len(sorted_nums)): if sorted_nums[i] == sorted_nums[i-1]: return sorted_nums[i] return None"},{"question":"# Coding Assessment Question Problem Description Implement the `frequency_sort` function that sorts the elements of the input list based on their frequency in descending order. If two elements have the same frequency, they should be sorted based on their value in ascending order. The function should return a new list that meets these criteria. Function Signature ```python def frequency_sort(collection: list[int]) -> list[int]: pass ``` Input - `collection (list[int])`: A mutable, ordered sequence of integers. Output - Returns a list containing the elements in `collection` sorted primarily by their frequency (in descending order) and secondarily by their value (in ascending order). Constraints 1. The function should not modify the original list. 2. The function should be efficient with regard to time complexity. Example ```python >>> frequency_sort([4, 2, 2, 8, 3, 3, 3, 1]) [3, 3, 3, 2, 2, 1, 4, 8] >>> frequency_sort([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) [4, 4, 4, 4, 3, 3, 3, 2, 2, 1] >>> frequency_sort([4, 4, 4, 3, 3, 1, 1, 1, 1]) [1, 1, 1, 1, 4, 4, 4, 3, 3] >>> frequency_sort([10]) [10] ``` Explanation - In the first example, the number 3 appears three times, the number 2 appears twice, and the numbers 4, 8, and 1 appear once. Thus, the sorted list is `[3, 3, 3, 2, 2, 1, 4, 8]`. - In the second example, the number 4 appears four times, the number 3 appears three times, and the number 2 appears twice. Thus, the sorted list is `[4, 4, 4, 4, 3, 3, 3, 2, 2, 1]`. - In the third example, the number 1 appears four times, the number 4 appears three times, and the number 3 appears twice. Thus, the sorted list is `[1, 1, 1, 1, 4, 4, 4, 3, 3]`. Good luck!","solution":"from collections import Counter def frequency_sort(collection: list[int]) -> list[int]: Sorts elements of the collection based on their frequency in descending order. If two elements have the same frequency, they are sorted based on their value in ascending order. # Count the frequency of each element in the collection freq_map = Counter(collection) # Sort the collection based on the frequency and value sorted_list = sorted(collection, key=lambda x: (-freq_map[x], x)) return sorted_list"},{"question":"# Problem Statement Your task is to implement a function that identifies the k most frequent elements in a given list of integers. If there is a tie between the frequencies of elements, the function should prioritize the elements that appeared first in the list. # Function Signature ```python def k_most_frequent_elements(arr: List[int], k: int) -> List[int]: This function finds the k most frequent elements in the given list. :param arr: A list of integers. :param k: The number of most frequent elements to return. :returns: A list of k most frequent elements, ordered by frequency and their first appearance. ``` # Input - `arr` (List[int]): A list of integers. The length of the list can vary from 0 to 10^5. - `k` (int): A positive integer indicating the number of most frequent elements to return. # Output - The function must return a list of `k` integers, which are the most frequent elements in `arr`. - If the list `arr` is empty or if `k` is 0, return an empty list. # Constraints - The algorithm should run in O(n log k) time complexity where n is the length of the list `arr`. # Examples ```python assert k_most_frequent_elements([1, 1, 1, 2, 2, 3], 2) == [1, 2] assert k_most_frequent_elements([4, 4, 4, 6, 6, 5, 5, 5], 3) == [4, 5, 6] assert k_most_frequent_elements([1], 1) == [1] assert k_most_frequent_elements([1, 2, 3, 4, 5], 3) == [1, 2, 3] assert k_most_frequent_elements([1, 1, 1, 2, 2, 3, 3, 3], 3) == [1, 3, 2] assert k_most_frequent_elements([], 3) == [] assert k_most_frequent_elements([5, 7, 5, 5, 6, 7, 7, 8], 2) == [5, 7] ``` # Notes - In cases where multiple elements have the same frequency, the function should prioritize elements based on their first appearance in the list. - Ensure that the function handles the edge case where the input list is empty or `k` is greater than the number of unique elements in the list.","solution":"from typing import List from collections import Counter def k_most_frequent_elements(arr: List[int], k: int) -> List[int]: This function finds the k most frequent elements in the given list. :param arr: A list of integers. :param k: The number of most frequent elements to return. :returns: A list of k most frequent elements, ordered by frequency and their first appearance. if not arr or k == 0: return [] # Count frequency of elements freq_map = Counter(arr) # Sort based on frequency and first appearance sorted_items = sorted(freq_map.items(), key=lambda x: (-x[1], arr.index(x[0]))) # Extract the top k elements result = [item[0] for item in sorted_items[:k]] return result"},{"question":"# Maximum Subarray Sum (Kadane\'s Algorithm) Assessment Question You are developing a financial analysis tool that processes historical stock prices to find trends and patterns. One requirement is to help investors identify the period with the maximum cumulative profit. Task: Write a function `maximum_subarray_sum(prices: List[int]) -> int` that takes a single argument as input: - `prices` (List[int]): A list of integers representing daily changes in stock prices (e.g., profit or loss). The function should return an integer representing the maximum sum of any contiguous subarray within the given list of prices. Input: - The input list will contain at least one and at most 10,000 integers. Each integer in the list will be between -10,000 and 10,000. Output: - Return an integer representing the maximum sum of any contiguous subarray. Examples: ```python >>> maximum_subarray_sum([1, -3, 2, 1, -1]) 3 >>> maximum_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> maximum_subarray_sum([1]) 1 >>> maximum_subarray_sum([-1, -2, -3, -4]) -1 >>> maximum_subarray_sum([5, 4, -1, 7, 8]) 23 ``` Constraints: - The function should handle cases where the subarray includes the possibility of all negative integers. - Performance should be optimized for input lists up to 10,000 integers. Implementing an efficient algorithm such as Kadane\'s Algorithm would be beneficial to handle larger inputs effectively.","solution":"from typing import List def maximum_subarray_sum(prices: List[int]) -> int: Function to find the maximum sum of any contiguous subarray within the given list of prices. Utilizes Kadane\'s algorithm for efficient computation. :param prices: List[int] - List of daily changes in stock prices :return: int - Maximum sum of any contiguous subarray max_current = max_global = prices[0] for price in prices[1:]: max_current = max(price, max_current + price) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Coding Assessment Question Context Imagine you need to efficiently calculate the lowest common multiple (LCM) of a list of integers. This problem requires understanding of number theory and implementing an algorithm that scales well with both the number and size of inputs. Task Write a function `calculate_lcm` that takes a list of integers and returns their lowest common multiple. * **Input**: * `numbers` (List[int]): A list of integers for which the LCM is to be calculated. * **Output**: * An integer representing the LCM of the given list of numbers. For example: ```python >>> calculate_lcm([4, 5]) 20 >>> calculate_lcm([6, 8, 3]) 24 ``` Constraints * All elements in the input list `numbers` will be positive integers (1 ≤ numbers[i] ≤ 10^6). * The length of the list `numbers` will be between 1 and 100 (1 ≤ len(numbers) ≤ 100). Requirements * Efficiently handle large inputs in terms of both the size of the list and the values of the integers. * Return an appropriate response if the input list is empty. * Utilize properties of prime factors and GCD (greatest common divisor) for optimizing the LCM calculation. * Aim for a solution that operates within a reasonable time complexity given the constraints. Performance Your solution should leverage efficient mathematical operations, ideally using properties such as `LCM(a, b) * GCD(a, b) = a * b` to ensure performance efficiency. Edge Cases: * Handle cases with single elements in the list. * Provide checks to throw or handle errors for non-integer elements, although the input will be guaranteed to conform to `List[int]` structure in typical usage. # Example The following illustrates the expected result: ```python >>> calculate_lcm([2]) 2 >>> calculate_lcm([2, 3, 5, 7]) 210 ``` # Implement the function below: ```python import math from functools import reduce def calculate_lcm(numbers): if not numbers: return 0 def lcm(a, b): return abs(a*b) // math.gcd(a, b) return reduce(lcm, numbers) ```","solution":"import math from functools import reduce def calculate_lcm(numbers): if not numbers: return 0 def lcm(a, b): return abs(a * b) // math.gcd(a, b) return reduce(lcm, numbers)"},{"question":"# Problem Statement You are tasked with evaluating the performance of cryptocurrency investments over a period. Given a list of daily prices for a certain cryptocurrency, determine the best possible profit that could have been made by buying on one day and selling on another later day. Note that it is not allowed to buy and sell on the same day. # Function to Implement Implement the function `max_profit(prices: List[int]) -> int`. This function should return the maximum profit that could have been obtained from these prices. If no profit is possible, return 0. # Input * `prices` (List[int]): A list of integers representing the daily prices of the cryptocurrency. # Output * (int): The maximum profit that could be achieved. # Constraints 1. All elements in the `prices` list are non-negative integers. 2. The length of `prices` list will be at least 2 and can go up to (10^5). # Examples ```python assert max_profit([7, 1, 5, 3, 6, 4]) == 5 # Buy on day 2 (price 1) and sell on day 5 (price 6) assert max_profit([7, 6, 4, 3, 1]) == 0 # No profitable transactions assert max_profit([1, 2, 3, 4, 5]) == 4 # Buy on day 1 (price 1) and sell on day 5 (price 5) assert max_profit([0, 2, 4, 7, 1, 3, 5]) == 7 # Buy on day 1 (price 0) and sell on day 4 (price 7) ``` # Additional Notes * For optimal implementation, consider using a single pass algorithm that tracks the minimum price observed so far and calculates potential profits accordingly. * Handle edge cases where the list is in complete ascending or descending order, ensuring your solution works efficiently for large inputs. # Scenario You are a software engineer developing a financial analysis tool that needs to provide insights for potential buy and sell strategies based on historical price data. Ensuring the tool can compute the best profit using past data is crucial for making informed decisions.","solution":"from typing import List def max_profit(prices: List[int]) -> int: Given a list of daily prices for a cryptocurrency, determine the maximum profit that could be achieved by buying on one day and selling on another later day. :param prices: List[int] with daily cryptocurrency prices. :return: The maximum possible profit or 0 if no profit is possible. if not prices or len(prices) < 2: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"# Question Scenario: You are developing a system to handle large datasets efficiently, and one of the tasks is to merge two sorted lists into a single sorted list. This is a common operation in data processing pipelines. Your solution should be efficient in terms of both time complexity and space complexity. Task: Implement a function `merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]` that takes in two sorted lists and merges them into a single sorted list. Input: - `list1`: A list of integers sorted in ascending order. - `list2`: Another list of integers sorted in ascending order. Output: - A single list of integers sorted in ascending order that contains all the elements from both input lists. Constraints: - The input lists may have different lengths. - The input lists contain integers, and they can include duplicates. - The elements of the lists range from -10^6 to 10^6. - Either of the lists can be empty. Performance Requirements: - Ensure that the merging is done in linear time, O(n + m), where n is the length of `list1` and m is the length of `list2`. Example: ```python from typing import List def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Example usage: >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([10, 20, 30], [5, 15, 25, 35]) [5, 10, 15, 20, 25, 30, 35] >>> merge_sorted_lists([-5, 0, 5], [-10, -1, 3, 7]) [-10, -5, -1, 0, 3, 5, 7] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([], []) [] # Your implementation here # Driver Code (Optional) if __name__ == \\"__main__\\": list1 = [1, 3, 5] list2 = [2, 4, 6] print(merge_sorted_lists(list1, list2)) ``` Make sure you handle edge cases effectively and test your code thoroughly before submission.","solution":"from typing import List def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two sorted lists into one sorted list. Example usage: >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([10, 20, 30], [5, 15, 25, 35]) [5, 10, 15, 20, 25, 30, 35] >>> merge_sorted_lists([-5, 0, 5], [-10, -1, 3, 7]) [-10, -5, -1, 0, 3, 5, 7] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([], []) [] merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Add the remaining elements from list1 or list2 (if any) while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Problem Statement You are given an integer ( n ) representing the number of nodes in an undirected graph and a list of edges where each edge is represented as a tuple of two integers ((u, v)) indicating that there is an edge between node ( u ) and node ( v ). Your task is to determine if the graph is bipartite. # Context In graph theory, a bipartite graph is a graph whose vertices can be divided into two disjoint and independent sets ( U ) and ( V ) such that every edge connects a vertex in ( U ) to one in ( V ). A graph is bipartite if and only if it is 2-colorable. # Function Signature ```python def is_bipartite(n: int, edges: list[tuple[int, int]]) -> bool: ``` # Input - `n`: An integer representing the number of nodes in the graph, generally indexed from 0 to ( n-1 ). - `edges`: A list of tuples where each tuple ((u, v)) signifies an undirected edge between node ( u ) and node ( v ). # Output - Return `True` if the graph is bipartite, else return `False`. # Constraints - ( 1 leq n leq 10^5 ) - ( 0 leq u, v < n ) - Each node is identified by a unique integer between 0 and ( n-1 ). - The list of edges can contain at most ( 10^5 ) edges. # Example ```python n = 4 edges = [(0, 1), (1, 2), (2, 3), (3, 0)] print(is_bipartite(n, edges)) # Should output: True n = 3 edges = [(0, 1), (1, 2), (2, 0)] print(is_bipartite(n, edges)) # Should output: False ``` # Specifications 1. Utilize a BFS or DFS approach to check if the graph can be 2-colored. 2. Ensure the function handles edge cases like disconnected graphs effectively. 3. Implement error handling for invalid input formats or impossible graph configurations.","solution":"def is_bipartite(n: int, edges: list[tuple[int, int]]) -> bool: from collections import deque, defaultdict # Initialize graph and color array graph = defaultdict(list) # Build the graph for u, v in edges: graph[u].append(v) graph[v].append(u) # -1 represents uncolored, 0 and 1 represent two different colors color = [-1] * n def bfs(start): queue = deque([start]) color[start] = 0 # Start coloring with 0 while queue: node = queue.popleft() current_color = color[node] next_color = 1 - current_color # Alternate color for neighbor in graph[node]: if color[neighbor] == -1: color[neighbor] = next_color queue.append(neighbor) elif color[neighbor] == current_color: return False return True for i in range(n): if color[i] == -1: # If the node is uncolored if not bfs(i): return False return True"},{"question":"# Insertion Sort on a Sublimited List **Context**: You are working on a classic sorting task but with a constraint. Imagine you are given a partially sorted list, and you need to fully sort it. This is a scenario where an insertion sort algorithm can be very efficient because of its good performance on nearly sorted data. **Task**: Implement the Insertion Sort algorithm to sort a list of integers in ascending order. Your implementation should make use of the fact that the array is almost sorted and optimize for it. **Function Signature**: ```python def insertion_sort(array: list) -> list: pass ``` **Input**: * A list of integers `array` where -10^6 <= array[i] <= 10^6. * The maximum length for `array` is 10^5. **Output**: * A sorted list of integers in ascending order. **Constraints**: * The implementation should be in-place, i.e., it should not utilize additional space beyond O(1). **Examples**: ```python assert insertion_sort([3, 1, 4, 5, 2]) == [1, 2, 3, 4, 5] assert insertion_sort([1, 2, 3, 5, 4]) == [1, 2, 3, 4, 5] assert insertion_sort([-1, 2, -3, 4, 0]) == [-3, -1, 0, 2, 4] ``` **Additional Information**: * You may assume that the list might be almost sorted, which means that elements are not more than a certain number of positions away from their final sorted position. * Focus on optimizing the implementation to leverage the near-sorted nature of the input list.","solution":"def insertion_sort(array: list) -> list: Sorts a list of integers using the insertion sort algorithm. Args: array (list): List of integers to sort. Returns: list: Sorted list of integers. length = len(array) for i in range(1, length): key = array[i] j = i - 1 # Move elements of array[0..i-1], that are greater than key, # to one position ahead of their current position while j >= 0 and array[j] > key: array[j + 1] = array[j] j -= 1 array[j + 1] = key return array"},{"question":"# Missing Number in Array Coding Challenge # Problem Statement Write a function `find_missing_number` that receives a list of distinct integers ranging between 1 and n (inclusive) with one number missing and returns the missing number. The function should be optimized for both time and space efficiency. # Detailed Requirements - **Function Signature**: `def find_missing_number(numbers: list[int]) -> int:` - The input list `numbers` will contain `n-1` distinct integers in the range `[1, n]`. - If the input list is empty or does not fit the expected pattern, return `0`. - Raise a `ValueError` with a meaningful error message if the input is not a list or tuple of integers. # Example Test Cases ```python def test_find_missing_number(): assert find_missing_number([1, 2, 4]) == 3, \\"Test case 1 failed\\" assert find_missing_number([3, 7, 1, 2, 8, 4, 5]) == 6, \\"Test case 2 failed\\" assert find_missing_number([2, 3, 4, 5, 6, 7, 8, 9, 10]) == 1, \\"Test case 3 failed\\" assert find_missing_number([1]) == 2, \\"Test case 4 failed\\" assert find_missing_number([]) == 0, \\"Test case 5 failed\\" try: find_missing_number([1, 2, 2, 4]) except ValueError as e: assert str(e) == \\"numbers must be an iterable of distinct integers\\", \\"Test case 6 failed\\" try: find_missing_number([1, \'a\', 3, 4]) except ValueError as e: assert str(e) == \\"numbers must be an iterable of integers\\", \\"Test case 7 failed\\" try: find_missing_number(None) except ValueError as e: assert str(e) == \\"numbers must be an iterable of integers\\", \\"Test case 8 failed\\" print(\\"All test cases pass\\") ``` # Constraints * Your solution should handle lists of varying lengths efficiently. * Assume no other numbers outside the range `1` to `n` are included. # Guidelines * Ensure your code handles edge cases such as empty lists, non-integer inputs, duplicate numbers, and other invalid forms before processing. * Optimize your solution to use O(1) additional space and aim for O(n) time complexity. Consider mathematical approaches or other innovative solutions for optimal performance.","solution":"def find_missing_number(numbers: list[int]) -> int: Finds the missing number in the list of distinct integers ranging between 1 and n, inclusive. if not isinstance(numbers, (list, tuple)): raise ValueError(\\"numbers must be an iterable of integers\\") if not all(isinstance(num, int) for num in numbers): raise ValueError(\\"numbers must be an iterable of integers\\") n = len(numbers) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(numbers) return expected_sum - actual_sum"},{"question":"# Problem Statement You are given a linked list either singly or doubly linked. Your task is to remove all the duplicates in the linked list, ensuring that each element appears only once. You must solve this problem within the constraints of O(n) time complexity and O(1) space complexity, where n is the number of nodes in the linked list. # Objective Write a function `remove_duplicates_from_linked_list(head)` that takes the head node of the linked list and returns the head node of the modified list with duplicates removed. # Input - `head`: The head node of the linked list, which will not be `None`. # Output - Returns the head node of the modified linked list with duplicates removed. # Constraints - The node values are integers. - If the linked list is empty, return `None`. - You must achieve O(n) time complexity and O(1) space complexity. # Example ```python class ListNode: def __init__(self, value: int = 0) -> None: self.value = value self.next: ListNode | None = None # Given linked list: # 1 -> 2 -> 3 -> 2 -> 4 -> 5 -> 4 # # The modified list should be: # 1 -> 2 -> 3 -> 4 -> 5 head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(2) head.next.next.next.next = ListNode(4) head.next.next.next.next.next = ListNode(5) head.next.next.next.next.next.next = ListNode(4) def remove_duplicates_from_linked_list(head: ListNode | None) -> ListNode | None: if head is None: return None current = head while current: runner = current while runner.next: if runner.next.value == current.value: runner.next = runner.next.next else: runner = runner.next current = current.next return head # Function to print the linked list def print_linked_list(head: ListNode | None) -> None: current = head while current: print(current.value, end=\' -> \' if current.next else \'\') current = current.next print() # Testing the modified linked list modified_head = remove_duplicates_from_linked_list(head) print_linked_list(modified_head) # Expected Output: 1 -> 2 -> 3 -> 4 -> 5 ```","solution":"class ListNode: def __init__(self, value: int = 0): self.value = value self.next: ListNode | None = None def remove_duplicates_from_linked_list(head: ListNode | None) -> ListNode | None: if head is None: return None current = head while current: runner = current while runner.next: if runner.next.value == current.value: runner.next = runner.next.next else: runner = runner.next current = current.next return head"},{"question":"# Problem Statement In a given 2D grid, some of the cells are occupied (marked by `1`) and others are empty (marked by `0`). We define a cluster as a group of occupied cells adjacent horizontally or vertically to each other. Your task is to find the size of the largest cluster on the grid. Write a function `largest_cluster_size` that takes a single parameter: - `grid` (a list of lists representing the 2D grid, where each inner list is of equal length) The function should return the size of the largest cluster of occupied cells. Input: - `grid`: List[List[int]] (a list of lists where each value is either 0 or 1) Output: - An integer representing the size of the largest cluster (i.e., the count of connected 1\'s). Constraints: - All rows in the grid are of the same length. - The dimensions of the grid are non-zero, and each dimension does not exceed 50 (i.e., `1 <= len(grid), len(grid[0]) <= 50`). # Examples: 1. `largest_cluster_size([[0, 1, 0, 0], [1, 1, 0, 0], [0, 0, 1, 0], [0, 0, 1, 1]])` should return `3`. 2. `largest_cluster_size([[1, 0, 0], [0, 0, 0], [0, 0, 1]])` should return `1`. 3. `largest_cluster_size([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]])` should return `0`. 4. `largest_cluster_size([[1, 1, 1], [0, 1, 0], [1, 1, 1]])` should return `7`. # Notes: - You can assume that the grid will always contain at least one cell. - Use Depth First Search (DFS) or Breadth First Search (BFS) to explore and count connected components of the grid efficiently. - Ensure to handle edge cases where there are no clusters (i.e., the entire grid is filled with 0\'s).","solution":"def largest_cluster_size(grid): def dfs(x, y): Perform a Depth First Search to find the size of the cluster starting from (x, y). # Stack for DFS stack = [(x, y)] size = 0 while stack: cx, cy = stack.pop() # Check bounds and if the cell is part of a cluster if 0 <= cx < len(grid) and 0 <= cy < len(grid[0]) and grid[cx][cy] == 1: size += 1 grid[cx][cy] = 0 # mark as visited # Add neighboring cells to stack stack.extend([(cx - 1, cy), (cx + 1, cy), (cx, cy - 1), (cx, cy + 1)]) return size max_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: current_cluster_size = dfs(i, j) max_size = max(max_size, current_cluster_size) return max_size"},{"question":"# Question: You have been tasked with refactoring a function that calculates the edit distance (Levenshtein distance) between two strings. The current implementation has a high time complexity, and you need to optimize it for better performance. Function Signature: ```python def optimized_edit_distance(s1: str, s2: str) -> int: ``` # Requirements: 1. Refactor the function to minimize its time complexity. 2. Return the minimum number of operations required to transform one string into another. 3. Ensure that the implementation handles edge cases such as: - When one or both strings are empty. - When the strings are identical. 4. Validate correctness using the provided test cases. # Expected Input and Output Formats: - **Input**: Two strings, `s1` and `s2`. - **Output**: An integer representing the minimum number of changes required. # Performance Requirements: - **Aim for O(m * n)** time complexity for `optimized_edit_distance`, where `m` and `n` are the lengths of the input strings. # Sample Test Cases: ```python assert optimized_edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert optimized_edit_distance(\\"flaw\\", \\"lawn\\") == 2 assert optimized_edit_distance(\\"\\", \\"test\\") == 4 assert optimized_edit_distance(\\"same\\", \\"same\\") == 0 ``` # Additional Context: - Optimize the function using dynamic programming approaches or efficient data storage techniques. - Avoid redundant calculations and ensure that the solution scales well with input size.","solution":"def optimized_edit_distance(s1: str, s2: str) -> int: Calculate the edit distance (Levenshtein distance) between two strings. m, n = len(s1), len(s2) # Create a (m+1) x (n+1) matrix to store the distances dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize dp table for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill the dp table for i in range(1, m + 1): for j in range(1, n + 1): if s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] # No operation needed else: dp[i][j] = min(dp[i-1][j] + 1, # Deletion dp[i][j-1] + 1, # Insertion dp[i-1][j-1] + 1) # Substitution return dp[m][n]"},{"question":"# Implement Custom Queue Class You are tasked with implementing a custom Queue class that provides basic queue functionalities such as enqueue, dequeue, peek, and checking if the queue is empty. Your implementation should handle edge cases appropriately. # Class Definition Implement a class `Queue` that supports the following methods: `__init__()` Initialize your queue class. - **Input**: No input parameters. - **Output**: None. `enqueue(element: int) -> None` Add an element to the end of the queue. - **Input**: An integer `element` to be added to the queue. - **Output**: None. `dequeue() -> int` Remove and return the element from the front of the queue. If the queue is empty, raise an `IndexError` with a message \\"Queue is empty\\". - **Input**: No input parameters. - **Output**: The integer that was removed from the front of the queue. `peek() -> int` Return the element at the front of the queue without removing it. If the queue is empty, raise an `IndexError` with a message \\"Queue is empty\\". - **Input**: No input parameters. - **Output**: The integer at the front of the queue. `is_empty() -> bool` Check if the queue is empty. - **Input**: No input parameters. - **Output**: A boolean value `True` if the queue is empty, `False` otherwise. # Examples ```python # Example for initializing and basic operations q = Queue() q.enqueue(1) q.enqueue(2) assert q.peek() == 1 assert q.dequeue() == 1 assert q.peek() == 2 assert q.is_empty() == False assert q.dequeue() == 2 assert q.is_empty() == True # Example for handling empty queue case empty_q = Queue() try: empty_q.dequeue() except IndexError as e: assert str(e) == \\"Queue is empty\\" try: empty_q.peek() except IndexError as e: assert str(e) == \\"Queue is empty\\" ``` # Notes - Make sure to handle edge cases such as attempting to dequeue from an empty queue or peeking at an empty queue. - Optimize for efficient enqueue and dequeue operations.","solution":"class Queue: def __init__(self): self._queue = [] def enqueue(self, element: int) -> None: self._queue.append(element) def dequeue(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._queue.pop(0) def peek(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._queue[0] def is_empty(self) -> bool: return len(self._queue) == 0"},{"question":"# Problem Statement 1. **Function to Implement**: Write a function `find_missing_number(arr: Sequence[int], n: int) -> int` that takes two parameters: * `arr` (sequence of integers): A list containing `n` distinct integers from 1 to `n+1` except one number which is missing. * `n` (integer): The size of the list `arr`. 2. **Expected Output**: This function should return the missing integer from the sequence. # Constraints * 1 <= `n` <= 10^6 * All integers in `arr` are unique and within the range [1, `n+1`] # Example ```python >>> find_missing_number([1, 2, 4, 6, 3, 7, 8], 7) 5 >>> find_missing_number([1, 2, 3, 5], 4) 4 ``` # Notes * You can assume that the input format is correct and that there is exactly one number missing in the sequence. * The function should be optimized to handle the upper limit constraint efficiently. # Task Breakdown 1. Implement the `find_missing_number` function to determine the missing number. 2. Consider using techniques that allow for an optimal solution in terms of time and space complexity. 3. Handle edge cases such as the sequence being in non-linear order, ensuring your solution is robust and accurate.","solution":"from typing import Sequence def find_missing_number(arr: Sequence[int], n: int) -> int: Returns the missing number in the sequence from 1 to n+1. # Calculate the expected sum of numbers from 1 to n+1 expected_sum = (n + 1) * (n + 2) // 2 # Calculate the actual sum of the numbers in the list actual_sum = sum(arr) # The missing number is the difference between the expected sum and the actual sum return expected_sum - actual_sum"},{"question":"# Problem Statement You have been assigned to develop a feature for a library management system that allows librarians to evaluate the demand for books. Specifically, you need to write a function that calculates the average demand for each book given its weekly demand over a certain period. If a book had no recorded demand in some weeks, it should not affect the average demand calculation. # Requirements Your task is to write a function `average_book_demand` that takes a dictionary representing the weekly demand of multiple books and returns a dictionary with the average demand for each book. # Function Signature ```python def average_book_demand(weekly_demand: dict[str, list[int]]) -> dict[str, float]: pass ``` # Input * `weekly_demand` (dict): A dictionary where keys are book titles (strings) and values are lists of integers representing the weekly demand. The lists can have different lengths and may contain zeroes. # Output * A dictionary where keys are book titles (strings) and values are floats representing the average demand for each book, rounded to one decimal place. # Constraints * If a book has no recorded demand (empty list), its average demand should be considered as 0.0. * The function should handle edge cases, including no books and books with zero demand across all weeks. # Examples ```python weekly_demand = { \\"Book A\\": [5, 3, 0, 7, 2], \\"Book B\\": [2, 2, 3], \\"Book C\\": [0, 0, 0], \\"Book D\\": [] } print(average_book_demand(weekly_demand)) # Output: {\\"Book A\\": 3.4, \\"Book B\\": 2.3, \\"Book C\\": 0.0, \\"Book D\\": 0.0} weekly_demand = { \\"Harry Potter\\": [10, 10, 10], \\"Lord of the Rings\\": [7, 7, 7, 7], \\"Hobbit\\": [], \\"1984\\": [0, 0, 0] } print(average_book_demand(weekly_demand)) # Output: {\\"Harry Potter\\": 10.0, \\"Lord of the Rings\\": 7.0, \\"Hobbit\\": 0.0, \\"1984\\": 0.0} ``` # Explanation In the provided examples, the average demand for each book is calculated by summing its weekly demand and dividing by the number of weeks it has been recorded. Zeroes in the weekly demand list are included in the total count of weeks. Good luck with your implementation!","solution":"def average_book_demand(weekly_demand): Calculate the average demand for each book, ignoring weeks with zero demand. Parameters: weekly_demand (dict): Dictionary where keys are book titles and values are lists of integers representing weekly demand. Returns: dict: Dictionary where keys are book titles and values are average demand as a float rounded to one decimal place. average_demand = {} for book, demands in weekly_demand.items(): if not demands or all(demand == 0 for demand in demands): average_demand[book] = 0.0 else: total_demand = sum(demands) weeks_count = len(demands) average_demand[book] = round(total_demand / weeks_count, 1) return average_demand"},{"question":"# Coding Assessment Question **Title**: Construct and Query a Segment Tree **Objective**: Implement a segment tree data structure to support efficient range queries and updates in an array. **Context**: Bob is working with large datasets and requires a way to quickly retrieve and update information over specific ranges. By using a segment tree, he can perform these operations efficiently. Bob needs your help to implement such a structure. **Task**: Write a class `SegmentTree` that can construct a segment tree from an array, support range sum queries, and handle point updates. # Requirements Class Definition ```python class SegmentTree: def __init__(self, data: list[int]): Initialize the Segment Tree with the given data. Args: data (list[int]): The array to build the segment tree from. pass def update(self, index: int, value: int) -> None: Update the value at the given index in the original data array and the segment tree. Args: index (int): The index to update. value (int): The new value to set. pass def query(self, left: int, right: int) -> int: Query the sum over a range [left, right] in the original data array. Args: left (int): The starting index of the range. right (int): The ending index of the range. Returns: int: The sum of the range. pass ``` # Examples: **Example 1** ```python data = [1, 3, 5, 7, 9, 11] segment_tree = SegmentTree(data) # Perform a range sum query print(segment_tree.query(1, 3)) # Output should be 3 + 5 + 7 = 15 # Update an element and perform another query segment_tree.update(1, 10) # data becomes [1, 10, 5, 7, 9, 11] print(segment_tree.query(1, 3)) # Output should be 10 + 5 + 7 = 22 ``` **Example 2** ```python data = [2, 4, 6, 8, 10] segment_tree = SegmentTree(data) # Perform a range sum query print(segment_tree.query(0, 2)) # Output should be 2 + 4 + 6 = 12 # Update an element and perform another query segment_tree.update(4, 20) # data becomes [2, 4, 6, 8, 20] print(segment_tree.query(3, 4)) # Output should be 8 + 20 = 28 ``` # Performance Requirements: - The solution should support queries and updates in logarithmic time with respect to the size of the input array. # Assumptions: - You can assume valid input is provided for all methods. - The input array\'s length does not exceed 10⁵ elements. - Any range [left, right] is a valid subarray within the bounds of the original array. This question evaluates your ability to understand and implement advanced data structures, ensuring efficient data manipulation and querying.","solution":"class SegmentTree: def __init__(self, data: list[int]): self.n = len(data) self.tree = [0] * (2 * self.n) # Build the tree for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, index: int, value: int) -> None: # Update element at index and recompute tree index += self.n self.tree[index] = value while index > 1: index //= 2 self.tree[index] = self.tree[2 * index] + self.tree[2 * index + 1] def query(self, left: int, right: int) -> int: # Initialize result result = 0 left += self.n right += self.n + 1 while left < right: if left % 2 == 1: result += self.tree[left] left += 1 if right % 2 == 1: right -= 1 result += self.tree[right] left //= 2 right //= 2 return result"},{"question":"Context You are tasked with developing a system that deals with detecting and correcting misspelled words in a large body of text. For that purpose, you decide to implement a `SpellingChecker` class that uses a trie (prefix tree) to efficiently manage a dictionary of correctly spelled words and quickly check whether a given word is spelled correctly. Task Implement a `SpellingChecker` class which uses a trie data structure for managing a dictionary of words. The class should have methods to add a word to the dictionary, search for a word, and provide suggestions for misspelled words. # Function Signature ```python class SpellingChecker: def __init__(self): pass def build_dictionary(self, words: List[str]) -> None: pass def add_word(self, word: str) -> None: pass def search_word(self, word: str) -> bool: pass def suggest_words(self, word: str) -> List[str]: pass ``` # Requirements 1. **Constructor**: Initialize the spelling checker without any pre-loaded dictionary. 2. **Build Dictionary Function**: Load a list of words into the trie. It replaces any existing dictionary. 3. **Add Word Function**: Add a single word into the trie without replacing the existing dictionary. 4. **Search Word Function**: Check if a word is in the trie and return `True` if it is, `False` otherwise. 5. **Suggest Words Function**: Provide a list of words with the minimum edit distance from the given word. The edit distance is defined as the minimum number of single-character edits (insertions, deletions, substitutions) required to change one word into the other. # Constraints - The words consist only of lowercase English letters. - The dictionary will have a maximum of `10^5` words. - Each word in the dictionary has a maximum length of `50`. # Example ```python # Create a spelling checker instance checker = SpellingChecker() # Build dictionary with a list of words checker.build_dictionary([\\"apple\\", \\"banana\\", \\"grape\\", \\"cherry\\", \\"strawberry\\"]) # Add a new word to the dictionary checker.add_word(\\"peach\\") # Search for words in the dictionary assert checker.search_word(\\"apple\\") is True assert checker.search_word(\\"peach\\") is True assert checker.search_word(\\"mango\\") is False # Get suggestions for a misspelled word assert \\"apple\\" in checker.suggest_words(\\"appl\\") assert \\"banana\\" in checker.suggest_words(\\"banan\\") assert \\"grape\\" in checker.suggest_words(\\"graep\\") ``` **Note**: Ensure your implementation of the trie is efficient and the `suggest_words` function returns reasonable suggestions based on the minimum edit distance.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class SpellingChecker: def __init__(self): self.root = TrieNode() def build_dictionary(self, words): self.root = TrieNode() # Reset the trie for word in words: self.add_word(word) def add_word(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search_word(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def suggest_words(self, word): suggestions = [] self._dfs(self.root, word, \\"\\", 0, {}, suggestions, 2) # Allow 2 edits return suggestions def _dfs(self, node, word, current_word, depth, memo, suggestions, max_dist): if (depth, current_word) not in memo: if len(current_word) <= len(word) + max_dist and len(current_word) >= len(word) - max_dist: dist = self._calculate_edit_distance(word, current_word) if dist <= max_dist: if node.is_end_of_word: suggestions.append(current_word) for char, next_node in node.children.items(): self._dfs(next_node, word, current_word + char, depth + 1, memo, suggestions, max_dist) memo[(depth, current_word)] = True @staticmethod def _calculate_edit_distance(word1, word2): dp = [[0] * (len(word2) + 1) for _ in range(len(word1) + 1)] for i in range(len(word1) + 1): for j in range(len(word2) + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) return dp[len(word1)][len(word2)]"},{"question":"# Scenario: You are a software developer working on a library management system. One of the features you need to implement is the ability to find books by their International Standard Book Number (ISBN-10). The ISBN-10 is a 10-digit code where each digit (except the last one, which can be \'X\' representing the value 10) contributes to a checksum formula, which verifies the authenticity of the number. # Task: Implement the function `is_valid_isbn(isbn: str) -> bool` that determines whether a given ISBN-10 number is valid. # Input: - `isbn` (str): A string representing the ISBN-10. The string will always be 10 characters long and may contain digits (\'0\'-\'9\') and an \'X\' only as the last character. # Output: - Returns `True` if the given ISBN-10 number is valid, or `False` otherwise. # Notes: - The ISBN-10 validity is determined by the following formula: `(1*d1 + 2*d2 + 3*d3 + ... + 10*d10) % 11 == 0`. - For the 10th digit (which can be \'X\'), consider its value to be 10. # Constraints: - The input `isbn` is guaranteed to be a string of length 10. - The string can contain digits \'0\' to \'9\' or \'X\' as the last character only. # Example: ```python >>> is_valid_isbn(\\"0306406152\\") True >>> is_valid_isbn(\\"123456789X\\") True >>> is_valid_isbn(\\"1234567890\\") False >>> is_valid_isbn(\\"048665088X\\") True ``` # Performance Requirements: - The function should run in O(1) time complexity as the length of ISBN-10 is constant.","solution":"def is_valid_isbn(isbn: str) -> bool: Checks if the given ISBN-10 number is valid. Each digit (except the last which can also be \'X\') contributes to a checksum formula. The checksum is calculated as (1*d1 + 2*d2 + 3*d3 + ... + 10*d10) % 11 == 0. For the 10th digit, \'X\' is considered to have the value 10. Parameters: - isbn (str): A string of length 10 representing the ISBN. Returns: - bool: True if the ISBN is valid, False otherwise. if len(isbn) != 10: return False checksum = 0 for i in range(10): if isbn[i] == \'X\': value = 10 if i == 9 else 0 else: value = int(isbn[i]) checksum += (i + 1) * value return checksum % 11 == 0"},{"question":"# Scenario: You are developing a library management system for a community library. As part of the system, you need to design a way to keep track of the books, patrons, and issuing details efficiently. One critical functionality users have requested is to be able to search books based on different criteria such as by title, author, or genre. # Task: Implement a class `Library` that supports adding books and searching for books based on various criteria. # Specifications: 1. The `Library` class should have the following methods: ```python class Library: def add_book(self, title: str, author: str, genre: str) -> None: pass def search_books(self, **criteria) -> List[dict]: pass ``` 2. The `add_book` method should: * Accept the title, author, and genre of a book. * Store the book information as a dictionary in an internal list. 3. The `search_books` method should: * Accept criteria as keyword arguments (`title`, `author`, and/or `genre`). * Return a list of books (as dictionaries) that match all given criteria. * If no criteria are provided, return all books. # Input: * For `add_book`: - `title`: A `str` representing the title of the book. - `author`: A `str` representing the author of the book. - `genre`: A `str` representing the genre of the book. * For `search_books`: - Keyword arguments: (`title`, `author`, and/or `genre`). # Output: * For `search_books`: - A `List` of `dict` objects, where each `dict` represents a book that matches the search criteria. # Examples: 1. Add a book to the library: ```python library = Library() library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"Fiction\\") library.add_book(\\"1984\\", \\"George Orwell\\", \\"Dystopian\\") ``` 2. Search for books by title: ```python books = library.search_books(title=\\"1984\\") # Expected output: [{\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"genre\\": \\"Dystopian\\"}] ``` 3. Search for books by genre: ```python books = library.search_books(genre=\\"Fiction\\") # Expected output: [{\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"genre\\": \\"Fiction\\"}] ``` 4. Search for all books: ```python books = library.search_books() # Expected output: [{\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"genre\\": \\"Fiction\\"}, # {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"genre\\": \\"Dystopian\\"}] ``` # Constraints: - Titles, authors, and genres are case-sensitive and should be stored exactly as they are input. # Notes: - Ensure thorough error handling for invalid input types. - Utilize appropriate data structures to optimize search operations. - Maintain code readability and organization for ease of maintenance and future updates.","solution":"from typing import List, Dict class Library: def __init__(self): self.books = [] def add_book(self, title: str, author: str, genre: str) -> None: book = {\\"title\\": title, \\"author\\": author, \\"genre\\": genre} self.books.append(book) def search_books(self, **criteria) -> List[Dict]: results = self.books for key, value in criteria.items(): results = [book for book in results if book.get(key) == value] return results"},{"question":"# Data Structure and Search Algorithm Question **Scenario**: You are working on a software project where you need to manage and search through a dynamic list of user login timestamps. The goal is to efficiently store the timestamps and perform multiple queries on this data to find out how many logins occurred within a specific time range. **Task**: Implement a class `LoginTimestampManager` that supports adding new timestamps and querying the count of logins within a specified time range. **Class Definition**: ```python class LoginTimestampManager: def __init__(self): Initialize the data structure to store timestamps. # Your code here def add_timestamp(self, timestamp: int) -> None: Add a new login timestamp. Parameters: timestamp (int): The login timestamp to be added. This integer represents the timestamp in seconds since epoch. Example Usage: >>> manager = LoginTimestampManager() >>> manager.add_timestamp(1632994025) # Your code here def query_logins(self, start_time: int, end_time: int) -> int: Query the number of logins that occurred between start_time (inclusive) and end_time (inclusive). Parameters: start_time (int): The start of the time range for the query. end_time (int): The end of the time range for the query. Returns: int: The number of login timestamps within the specified range. Example Usage: >>> manager = LoginTimestampManager() >>> manager.add_timestamp(1632994025) >>> manager.add_timestamp(1632994825) >>> manager.query_logins(1632994000, 1632994600) 1 >>> manager.query_logins(1632994000, 1632995000) 2 # Your code here ``` **Constraints**: - The `timestamp`, `start_time`, and `end_time` are integers within the range [0, 2^31 - 1]. - Timestamps are added in non-decreasing order. - The class should be able to handle up to 10^6 timestamps. - The `query_logins` method should execute efficiently, even with large amounts of data. Ensure your implementation is optimized for both adding timestamps and executing multiple range queries. Consider using appropriate data structures that provide efficient insertion and search capabilities.","solution":"from bisect import bisect_left, bisect_right class LoginTimestampManager: def __init__(self): Initialize the data structure to store timestamps. self.timestamps = [] def add_timestamp(self, timestamp: int) -> None: Add a new login timestamp. Parameters: timestamp (int): The login timestamp to be added. This integer represents the timestamp in seconds since epoch. self.timestamps.append(timestamp) def query_logins(self, start_time: int, end_time: int) -> int: Query the number of logins that occurred between start_time (inclusive) and end_time (inclusive). Parameters: start_time (int): The start of the time range for the query. end_time (int): The end of the time range for the query. Returns: int: The number of login timestamps within the specified range. # Use binary search to find the indices of timestamps in the specified range start_index = bisect_left(self.timestamps, start_time) end_index = bisect_right(self.timestamps, end_time) return end_index - start_index"},{"question":"# Problem Statement You are given a list of dictionaries representing different products in an inventory. Each dictionary contains \'name\', \'category\', and \'price\' keys. The task is to implement a function that performs the following operations: 1. Filter the products based on a given category. 2. Calculate the average price of the filtered products. 3. Sort the filtered products by their price in ascending order. # Function Signature ```python def filter_and_sort_products(products, target_category): :param products: List[Dict[str, Union[str, float]]] - List of product dictionaries :param target_category: str - Category to filter the products by :return: Tuple[List[Dict[str, Union[str, float]]], float] - Sorted list of filtered products and average price ``` # Constraints & Input Format - `products` is a list of dictionaries where each dictionary has the structure: ```python { \'name\': str, \'category\': str, \'price\': float } ``` - `target_category` is a non-empty string. - Each product dictionary has valid data: non-empty strings for \'name\' and \'category\', and a non-negative float for \'price\'. - The list `products` has at least one product dictionary. # Example ```python products = [ {\'name\': \'Apple iPhone 12\', \'category\': \'Electronics\', \'price\': 799.99}, {\'name\': \'Samsung Galaxy S21\', \'category\': \'Electronics\', \'price\': 749.99}, {\'name\': \'Sony WH-1000XM4\', \'category\': \'Electronics\', \'price\': 299.99}, {\'name\': \'Dell XPS 13\', \'category\': \'Electronics\', \'price\': 999.99}, {\'name\': \'Nike Air Max\', \'category\': \'Shoes\', \'price\': 129.99}, ] target_category = \'Electronics\' filtered_products, avg_price = filter_and_sort_products(products, target_category) print(filtered_products) # Expected output: # [ # {\'name\': \'Sony WH-1000XM4\', \'category\': \'Electronics\', \'price\': 299.99}, # {\'name\': \'Samsung Galaxy S21\', \'category\': \'Electronics\', \'price\': 749.99}, # {\'name\': \'Apple iPhone 12\', \'category\': \'Electronics\', \'price\': 799.99}, # {\'name\': \'Dell XPS 13\', \'category\': \'Electronics\', \'price\': 999.99} # ] print(avg_price) # Expected output: 712.49 ``` # Explanation 1. **Data Filtering**: Only products that belong to the `target_category` are selected. 2. **Average Price Calculation**: The function calculates the average price of the filtered products. 3. **Sorting**: The function sorts the filtered products by their price in ascending order.","solution":"def filter_and_sort_products(products, target_category): Filters products by category, calculates the average price of filtered products, and sorts filtered products by price. :param products: List[Dict[str, Union[str, float]]] - List of product dictionaries :param target_category: str - Category to filter the products by :return: Tuple[List[Dict[str, Union[str, float]]], float] - Sorted list of filtered products and average price # Filter products by the target category filtered_products = [product for product in products if product[\'category\'] == target_category] # Calculate the average price of the filtered products if filtered_products: avg_price = sum(product[\'price\'] for product in filtered_products) / len(filtered_products) else: avg_price = 0.0 # Sort the filtered products by price in ascending order sorted_products = sorted(filtered_products, key=lambda x: x[\'price\']) return sorted_products, avg_price"},{"question":"# Question: Implementing Caesar Cipher **Context**: The Caesar Cipher is a simple substitution cipher where each letter in the plaintext is shifted a certain number of places down the alphabet. Your task is to implement both encoding and decoding functions of this cipher. **Function 1**: `encode(message: str, shift: int) -> str` **Function 2**: `decode(encoded_message: str, shift: int) -> str` **Input**: 1. `message` (string) - A message containing only alphabetic characters and spaces that needs to be encoded. * All letters should be treated as lowercase. 2. `shift` (integer) - The number of places each letter in the message is shifted down the alphabet during encoding. 3. `encoded_message` (string) - An encoded message containing only alphabetic characters that needs to be decoded. * The letter \'a\' shifted by 3 becomes \'d\', \'b\' becomes \'e\', and so on. It wraps around such that \'z\' shifted by 3 becomes \'c\'. **Output**: 1. `encode` returns a string which is the encoded version of the input message. 2. `decode` returns a string which is the original message decoded from the encoded message. **Constraints**: * Input strings will not contain digits or special characters, other than spaces. * The shift value will be a non-negative integer. * You must preserve spaces in the encoded and decoded output as in the input. **Examples**: 1. `encode(\'hello world\', 3)` returns `\'khoor zruog\'` 2. `decode(\'khoor zruog\', 3)` returns `\'hello world\'` 3. `encode(\'caesar cipher\', 5)` returns `\'hfjxfw hnumjw\'` 4. `decode(\'hfjxfw hnumjw\', 5)` returns `\'caesar cipher\'` **Performance Requirements**: * Aim for concise and efficient resolution with considerations for cases when string manipulation might be a bottleneck.","solution":"def encode(message: str, shift: int) -> str: encoded_message = [] for char in message: if char == \' \': encoded_message.append(char) else: # Calculate the shifted character shifted_char = chr(((ord(char) - 97 + shift) % 26) + 97) encoded_message.append(shifted_char) return \'\'.join(encoded_message) def decode(encoded_message: str, shift: int) -> str: decoded_message = [] for char in encoded_message: if char == \' \': decoded_message.append(char) else: # Calculate the original character after reversing the shift original_char = chr(((ord(char) - 97 - shift) % 26) + 97) decoded_message.append(original_char) return \'\'.join(decoded_message)"},{"question":"# Problem Statement You are tasked with optimizing an image represented in a 2D matrix by compressing it using the Run-Length Encoding (RLE) algorithm. Your task is to implement both the compression and decompression functions to handle this process. The RLE algorithm efficiently compresses data by finding sequences of repeating elements. # Task 1. **Compression Algorithm (Core Algorithm)**: - Implement the `compress_image` function that takes a 2D matrix of integers and returns a 1D list of tuples where each tuple contains a value and its run length. 2. **Decompression Algorithm (Integration)**: - Implement the `decompress_image` function that takes a 1D list of tuples and returns the original 2D matrix of integers. # Constraints - The 2D matrix can have dimensions of up to 1000x1000. - Values in the matrix can be any integer. # Performance Requirements - Time Complexity: O(n) where n is the number of elements in the matrix. - Space Complexity: O(n) for both functions. # Function Signatures ```python def compress_image(matrix: List[List[int]]) -> List[Tuple[int, int]]: pass def decompress_image(rle: List[Tuple[int, int]], rows: int, cols: int) -> List[List[int]]: pass ``` # Example Input ```python matrix = [ [3, 3, 3, 2, 2], [2, 2, 1, 1, 1], [1, 3, 3, 0, 0] ] ``` Output ```python compressed = [(3, 3), (2, 2), (2, 3), (1, 3), (3, 1), (0, 2)] ``` Decompress Input ```python rle = [(3, 3), (2, 2), (2, 3), (1, 3), (3, 1), (0, 2)] rows = 3 cols = 5 ``` Decompress Output ```python matrix = [ [3, 3, 3, 2, 2], [2, 2, 1, 1, 1], [1, 3, 3, 0, 0] ] ``` # Implementation Details **Compression:** - Traverse the 2D matrix row by row. - Identify sequences of repeated values. - Store each value along with its run length. **Decompression:** - Traverse the list of tuples. - Expand each tuple into the appropriate amount of values. - Reconstruct the 2D matrix row by row. # Notes - Make sure to handle edge cases where the matrix might have a single row or column. - Ensure that the compressed format is efficiently transformed back to the original matrix. Good luck and happy coding!","solution":"from typing import List, Tuple def compress_image(matrix: List[List[int]]) -> List[Tuple[int, int]]: Compresses a 2D matrix using Run-Length Encoding (RLE). Args: matrix: List of lists containing integers representing the image. Returns: List of tuples where each tuple contains an integer and its run length. if not matrix or not matrix[0]: return [] compressed = [] for row in matrix: if not row: continue prev = row[0] count = 1 for i in range(1, len(row)): if row[i] == prev: count += 1 else: compressed.append((prev, count)) prev = row[i] count = 1 compressed.append((prev, count)) return compressed def decompress_image(rle: List[Tuple[int, int]], rows: int, cols: int) -> List[List[int]]: Decompresses a Run-Length Encoded list back into a 2D matrix. Args: rle: List of tuples where each tuple contains an integer and its run length. rows: Number of rows in the original matrix. cols: Number of columns in the original matrix. Returns: The decompressed 2D matrix. matrix = [] row = [] for value, length in rle: while length > 0: row.append(value) length -= 1 if len(row) == cols: matrix.append(row) row = [] return matrix"},{"question":"# Coding Assessment Question Objective Write a function that calculates the minimum cost of multiplying a sequence of matrices. This problem is designed to assess your understanding of dynamic programming, and more specifically, the matrix chain multiplication technique. Problem Statement Given an array `dims` of size `n+1` where the `i-th` element represents the number of rows of the matrix `i` and the `i+1-th` element represents the number of columns of the matrix `i`, develop a Python function `matrix_chain_order(dims: List[int]) -> int` that computes the minimum cost of multiplying the sequence of matrices. # Input * The input is a list `dims` of positive integers where the length of the list is at least 2 and at most 101. # Output * Output a single integer representing the minimum number of scalar multiplications needed to multiply the sequence of matrices. # Example ```python assert matrix_chain_order([1, 2, 3, 4]) == 18 assert matrix_chain_order([10, 20, 30, 40, 30]) == 30000 ``` # Constraints * The number of matrices will not exceed 100. * The dimensions, represented by elements of `dims`, are positive integers. # Function Signature ```python from typing import List def matrix_chain_order(dims: List[int]) -> int: pass ``` Notes * Use dynamic programming to store results of subproblems to avoid redundant calculations. * The cost of multiplying two matrices A of dimensions `p x q` and B of dimensions `q x r` is `p*q*r`. * The order of matrix multiplication is associative, but the sequence of operations significantly influences the computation cost. * Optimize space and time complexity to handle the upper limit of constraints efficiently.","solution":"from typing import List def matrix_chain_order(dims: List[int]) -> int: n = len(dims) - 1 # Initialize the matrix to hold our results dp = [[0 for _ in range(n)] for _ in range(n)] for length in range(2, n+1): # length is the length of the chain for i in range(n - length + 1): j = i + length - 1 dp[i][j] = float(\'inf\') for k in range(i, j): # cost of splitting at k cost = dp[i][k] + dp[k+1][j] + dims[i] * dims[k+1] * dims[j+1] if cost < dp[i][j]: dp[i][j] = cost return dp[0][n-1]"},{"question":"# String Permutation Checker Context A string permutation is a rearrangement of the characters of a string into a different sequence. Two strings are said to be permutations of each other if they contain the same characters with the same frequencies, but possibly in different orders. Problem Statement Write a function that checks if two given strings are permutations of each other. Function Signature ```python def are_permutations(str1: str, str2: str) -> bool: pass ``` Input - `str1` (str): A string containing alphanumeric characters and/or symbols. - `str2` (str): A string containing alphanumeric characters and/or symbols. Output - A boolean value indicating whether the two strings are permutations of each other. Constraints - Both `str1` and `str2` will contain at least one character and at most 10^6 characters. Example ```python str1 = \\"listen\\" str2 = \\"silent\\" str3 = \\"hello\\" str4 = \\"olehl\\" str5 = \\"integral\\" str6 = \\"triangle\\" assert are_permutations(str1, str2) == True assert are_permutations(str3, str4) == True assert are_permutations(str5, str6) == True assert are_permutations(str1, str3) == False assert are_permutations(str2, str6) == False ``` Notes - The comparison should be case-sensitive. - To optimize the solution, consider the computational efficiency of the approach, especially for large input sizes. - Consider only the characters and their frequencies, ignoring spaces and other delimiters to determine if the strings are permutations of each other.","solution":"def are_permutations(str1: str, str2: str) -> bool: Checks if two given strings are permutations of each other. Args: str1 (str): First string to compare. str2 (str): Second string to compare. Returns: bool: True if the strings are permutations of each other, False otherwise. # If the lengths of the two strings are not the same, they cannot be permutations if len(str1) != len(str2): return False # Create dictionaries to count the frequencies of characters in each string char_count1 = {} char_count2 = {} for char in str1: char_count1[char] = char_count1.get(char, 0) + 1 for char in str2: char_count2[char] = char_count2.get(char, 0) + 1 # If both dictionaries are equal, the strings are permutations of each other return char_count1 == char_count2"},{"question":"# Three-in-One Stack Implementation Design a data structure that simulates three separate stacks within a single, shared array. Implement operations to push, pop, and peek for each of the three stacks, as well as check if any of the stacks are empty. Class Definition ```python class ThreeInOne: def __init__(self, stack_size: int): # Initializes three stacks within a single array. def push(self, stack_num: int, value: int) -> None: # Pushes value onto the specified stack number (0, 1, or 2). def pop(self, stack_num: int) -> int: # Pops value from the specified stack number (0, 1, or 2). def peek(self, stack_num: int) -> int: # Peeks the top value of the specified stack number (0, 1, or 2). def is_empty(self, stack_num: int) -> bool: # Checks if the specified stack number (0, 1, or 2) is empty. ``` Expected Input and Output * **Input**: * `stack_num` (int): The stack number (0, 1, or 2). * `value` (int): The value to push onto the stack. * `stack_size` (int): The initial size allocated for each stack. * **Output**: * `push`: None. * `pop`: The value removed from the stack. * `peek`: The top value of the stack. * `is_empty`: A boolean indicating whether the stack is empty. Constraints * The stack number should be between 0 and 2 (inclusive). * The value should be any valid integer. * The stack size should be a positive integer. * Each stack operation should adhere to the stack size limit. Overflow or underflow should be handled gracefully. Examples ```python stacks = ThreeInOne(5) stacks.push(0, 10) stacks.push(1, 20) stacks.push(2, 30) assert stacks.pop(0) == 10 assert stacks.peek(1) == 20 assert stacks.is_empty(0) == True assert stacks.is_empty(1) == False stacks.push(2, 40) assert stacks.pop(2) == 40 assert stacks.peek(2) == 30 ``` Instructions 1. **Implement the class**: Implement the `ThreeInOne` class with the methods detailed above. 2. **Edge cases**: Ensure that your methods handle overflow and underflow conditions appropriately by either raising exceptions or providing meaningful return values. 3. **Preservation of State**: Ensure that each stack maintains its elements correctly and independently of the other stacks sharing the array. 4. **Efficiency**: Optimize the operations to perform efficiently within the constraints provided.","solution":"class ThreeInOne: def __init__(self, stack_size: int): Initializes three stacks within a single array. self.stack_size = stack_size self.num_stacks = 3 self.array = [0] * (stack_size * self.num_stacks) self.sizes = [0] * self.num_stacks def push(self, stack_num: int, value: int) -> None: Pushes value onto the specified stack number (0, 1, or 2). if self.sizes[stack_num] >= self.stack_size: raise Exception(\\"Stack Overflow\\") self.array[self._index_of_top(stack_num) + 1] = value self.sizes[stack_num] += 1 def pop(self, stack_num: int) -> int: Pops value from the specified stack number (0, 1, or 2). if self.is_empty(stack_num): raise Exception(\\"Stack Underflow\\") top_index = self._index_of_top(stack_num) value = self.array[top_index] self.array[top_index] = 0 self.sizes[stack_num] -= 1 return value def peek(self, stack_num: int) -> int: Peeks the top value of the specified stack number (0, 1, or 2). if self.is_empty(stack_num): raise Exception(\\"Stack is empty\\") return self.array[self._index_of_top(stack_num)] def is_empty(self, stack_num: int) -> bool: Checks if the specified stack number (0, 1, or 2) is empty. return self.sizes[stack_num] == 0 def _index_of_top(self, stack_num: int) -> int: Helper function to calculate the index of the top element of a stack. offset = stack_num * self.stack_size return offset + self.sizes[stack_num] - 1"},{"question":"# Coding Assessment Question: Maximal Rectangle in a Binary Matrix **Scenario**: You are working on a geographical information system that involves analyzing two-dimensional grids of data. One common operation is identifying the largest rectangular region in a binary grid that is filled entirely with `1`s, which can represent areas of interest or regions meeting specific criteria. **Problem Statement**: Write a function `maximal_rectangle(matrix: list[list[int]]) -> int` that will find the area of the largest rectangle containing only `1`s in the given binary matrix. **Input**: - `matrix`: A list of lists of integers (binary matrix) where `matrix[r][c]` is either `0` or `1`, and represents the value at row `r` and column `c` in the grid. **Output**: - An integer representing the area of the largest rectangle containing only `1`s. **Constraints**: - `1 <= len(matrix) <= 200` - `1 <= len(matrix[0]) <= 200` - The elements of `matrix` will be either `0` or `1`. **Performance Requirements**: - The implementation should efficiently handle the case where the matrix size is up to 200x200. **Example**: Given the following binary matrix: ```python matrix = [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ] ``` The function call `maximal_rectangle(matrix)` should return `6`, which represents the area of the largest rectangle (of dimensions 2x3) composed entirely of `1`s. **Additional Notes**: - Consider the use of algorithms and data structures that can help efficiently determine the size of the largest rectangle. - Utilize appropriate strategies to handle the transition from rows to rectangles, such as histogram-based approaches. - Ensure your function handles edge cases such as single rows, single columns, or matrices with no `1`s effectively.","solution":"def maximal_rectangle(matrix): if not matrix: return 0 max_area = 0 n_cols = len(matrix[0]) heights = [0] * n_cols for row in matrix: for i in range(n_cols): if row[i] == 0: heights[i] = 0 else: heights[i] += 1 max_area = max(max_area, max_histogram_area(heights)) return max_area def max_histogram_area(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"# Validate and Parse a Mathematical Expression Write a function that validates and parses a simple mathematical expression consisting of non-negative integers and the operators `+` and `*`. The function should evaluate the expression and return the result. The expression is guaranteed to be valid and contains no parentheses. Function Signature ```python def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression consisting of non-negative integers and the operators \'+\' and \'*\'. :param expression: str - A valid mathematical expression :return: int - The result of the evaluated expression ``` Input - A string `expression` (1 ≤ len(expression) ≤ 1000): The mathematical expression to evaluate. It contains only digits `0-9`, `+`, and `*`. Output - Return an integer as the result of evaluating the expression. Constraints - The function should handle the operator precedence correctly (`*` has higher precedence than `+`). Example ```python >>> evaluate_expression(\\"2+3*4\\") 14 >>> evaluate_expression(\\"10+20+30*2\\") 90 ```","solution":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression consisting of non-negative integers and the operators \'+\' and \'*\'. :param expression: str - A valid mathematical expression :return: int - The result of the evaluated expression import re # Split the input expression into components (numbers and operators) tokens = re.split(r\'(D)\', expression) # Handle multiplication first stack = [] i = 0 while i < len(tokens): if tokens[i] == \'*\': prev_num = stack.pop() next_num = tokens[i + 1] stack.append(str(int(prev_num) * int(next_num))) i += 2 else: stack.append(tokens[i]) i += 1 # Now handle addition result = 0 i = 0 while i < len(stack): if stack[i] == \'+\': i += 1 else: result += int(stack[i]) i += 1 return result"},{"question":"# E-commerce Item Recommendation System using Collaborative Filtering You are tasked to implement an item recommendation system for an e-commerce platform based on collaborative filtering. Your system should recommend items to users based on their historical interactions and preferences using matrix factorization techniques. # Implementation Tasks 1. **Matrix Factorization Initialization**: - Initialize the user and item matrices with random values. - The matrices should have dimensions ( m times k ) and ( k times n ) respectively, where ( m ) is the number of users, ( n ) is the number of items, and ( k ) is the factor dimension. 2. **Training Function**: - Implement the training function using Stochastic Gradient Descent (SGD) for matrix factorization. - The function should minimize the mean squared error (MSE) between the observed interactions and predicted interactions. - Parameters: - `R` (np.ndarray): User-item interaction matrix with shape ( m times n ). - `n_factors` (int): Number of latent factors. - `alpha` (float): Learning rate. - `beta` (float): Regularization parameter. - `n_epochs` (int): Number of epochs for training. 3. **Prediction Function**: - Implement the `predict` function to predict the rating a user would give to an item. - Return a matrix of the same dimensions as the input user-item interaction matrix with all predicted ratings. 4. **Recommendation Function**: - Implement the `recommend` function to generate a list of top-N recommended items for a given user. - Parameters: - `user_id` (int): User for whom the recommendations are being made. - `N` (int): Number of items to recommend. # Input - `R` : numpy array of shape ( m times n ) containing interaction data (e.g., ratings) between m users and n items. - `n_factors` : integer indicating the number of latent factors. - `alpha` : float indicating the learning rate. - `beta` : float indicating the regularization parameter. - `n_epochs` : integer indicating the number of epochs for training. - `user_id` : integer representing the user for whom recommendations are generated. - `N` : integer indicating the number of items to recommend. # Output - A list of the top-N recommended item indices for the specified user. # Constraints - The user-item interaction matrix `R` contains integer ratings from 1 to 5 with zeros indicating missing ratings. - Ensure the factor dimension ( k ) is appropriately chosen to balance computational efficiency and recommendation accuracy. - The matrix factorization should efficiently handle large datasets typically found in e-commerce platforms (e.g., thousands of users and items). - The recommendation accuracy should be evaluated using metrics such as root mean squared error (RMSE) or mean absolute error (MAE). # Performance Requirements Ensure that your implementation is scalable and able to handle large matrices. Implement mechanisms to avoid overfitting, such as regularization (L2 norm). Optimize the training process for time efficiency. # Example Scenario You are provided with a user-item interaction matrix from an e-commerce site. Your task is to train the model using matrix factorization, validate its performance, and then generate top-N item recommendations for a specified user.","solution":"import numpy as np def matrix_factorization(R, n_factors, alpha, beta, n_epochs): Perform matrix factorization using Stochastic Gradient Descent. Parameters: R (np.ndarray): User-item interaction matrix. n_factors (int): Number of latent factors. alpha (float): Learning rate. beta (float): Regularization parameter. n_epochs (int): Number of epochs for training. Returns: P (np.ndarray): User feature matrix. Q (np.ndarray): Item feature matrix. m, n = R.shape P = np.random.normal(scale=1./n_factors, size=(m, n_factors)) Q = np.random.normal(scale=1./n_factors, size=(n_factors, n)) for epoch in range(n_epochs): for i in range(m): for j in range(n): if R[i, j] > 0: # Compute the error of the prediction eij = R[i, j] - np.dot(P[i, :], Q[:, j]) # Update user and item latent feature matrices for k in range(n_factors): P[i, k] += alpha * (2 * eij * Q[k, j] - beta * P[i, k]) Q[k, j] += alpha * (2 * eij * P[i, k] - beta * Q[k, j]) return P, Q def predict(P, Q): Predict the full user-item matrix using the learned user and item features. Parameters: P (np.ndarray): User feature matrix. Q (np.ndarray): Item feature matrix. Returns: np.ndarray: Complete predicted user-item interaction matrix. return np.dot(P, Q) def recommend(R, P, Q, user_id, N): Generate top-N item recommendations for a given user. Parameters: R (np.ndarray): Original user-item interaction matrix. P (np.ndarray): User feature matrix. Q (np.ndarray): Item feature matrix. user_id (int): User for whom recommendations are being made. N (int): Number of items to recommend. Returns: list: List of top-N recommended item indices. user_predictions = np.dot(P[user_id, :], Q) unrated_items = np.where(R[user_id, :] == 0)[0] recommendations = [ (i, user_predictions[i]) for i in unrated_items ] return [item[0] for item in sorted(recommendations, key=lambda x: x[1], reverse=True)[:N]]"},{"question":"# Coding Assessment Question Scenario You are building a library management system and need to implement a feature that identifies if a given sequence of book titles forms an anagram group. An anagram group consists of strings that can be rearranged to form one another. Your task is to check if the provided list of book titles contains only titles that are all anagrams of each other. Task Implement the function `are_anagrams` which takes a list of strings, each representing a book title, and determines if all titles are anagrams of one another. The function should return `True` if all titles are anagrams, and `False` otherwise. Requirements - Define the function `are_anagrams(titles: List[str]) -> bool`. - The function should handle case insensitivity. - Ignore spaces and punctuation characters in the titles when determining if they are anagrams. - Include relevant test cases to verify your implementation. Constraints - Number of titles: 0 to 10^3. - Length of each title: 1 to 10^3 characters. - Ensure the function completes within a reasonable time frame. Performance Requirements - Time Complexity: O(m * n), where m is the number of titles and n is the average length of a title. - Space Complexity: O(n), for the space used by the counting mechanism. Example ```python >>> are_anagrams([\'Dormitory\', \'Dirty Room\', \'Dormitory#\']) True >>> are_anagrams([\'Astronomer\', \'Moon starer\', \'Astrogen ham\']) False >>> are_anagrams([\'Listen\', \'Silent\', \'SilEnT\', \'LiStEn\']) True >>> are_anagrams([\\"\\"]) True >>> are_anagrams([]) True ```","solution":"from typing import List import re from collections import Counter def are_anagrams(titles: List[str]) -> bool: Determines if all book titles in the list are anagrams of each other. This function ignores case, spaces, and punctuation characters. if not titles: return True def normalize(title: str) -> str: # Remove non-alphabetic characters and convert to lowercase return \'\'.join(sorted(re.sub(r\'W+\', \'\', title).lower())) # Normalize the first title to compare others normalized_first = normalize(titles[0]) # Compare all normalized titles to the first normalized title for title in titles[1:]: if normalize(title) != normalized_first: return False return True"},{"question":"# Advanced Coding Challenge: Implementing K-Means Clustering with Optimizations Background K-Means clustering is a widely-used algorithm for partitioning a dataset into K clusters, where each data point belongs to the cluster with the nearest mean. The algorithm works iteratively, alternating between assigning data points to the nearest cluster centroid and updating the centroids based on the current assignments. However, the basic implementation can be computationally intensive, especially on large datasets. Task Your goal is to implement an optimized version of the K-Means clustering algorithm. Specifically, your improvements should focus on: 1. Initializing centroids using the K-Means++ algorithm to improve the quality of the initial cluster centers. 2. Employing an optimization to reduce redundant distance calculations, such as the use of a distance matrix or other suitable techniques to avoid recalculating distances between points and centroids repeatedly. Requirements 1. Implement the K-Means++ initialization for selecting initial cluster centers. 2. Implement the main K-Means algorithm with optimizations to reduce redundant distance calculations. 3. Ensure your implementation can handle large datasets efficiently. Inputs and Outputs - **Input:** The input dataset will be a two-dimensional array of shape (N, D), where N is the number of data points and D is the number of features. The second input is an integer K, the number of clusters. - **Output:** The output should be an array of shape (N, ) containing the cluster assignment for each data point. Constraints - The number of data points, N, will be in the range of 100 to 100,000. - The number of features, D, will be in the range of 2 to 50. - The number of clusters, K, will be in the range of 2 to 20. Instructions 1. Implement the `k_means_plus_plus` function to initialize the centroids using the K-Means++ algorithm. 2. Implement the main `k_means` function that performs the clustering with the specified optimizations. 3. Your code should be efficient and handle large datasets within reasonable time limits. Example ```python import numpy as np def k_means(data, K): # Your implementation here pass # Example dataset data = np.array([ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0] ]) K = 2 assignments = k_means(data, K) print(assignments) # Output should be an array of cluster assignments, e.g., [0, 0, 1, 1, 0, 1] ``` This question requires candidates to demonstrate their ability to improve existing algorithms through better initialization techniques and optimization strategies, ensuring they are equipped to tackle real-world computational challenges.","solution":"import numpy as np def k_means_plus_plus(data, K): n_samples, n_features = data.shape centroids = np.empty((K, n_features)) # Choose the first centroid randomly from the data points centroids[0] = data[np.random.choice(n_samples)] for k in range(1, K): # Compute the distance from each point to the nearest centroid dists = np.min(np.linalg.norm(data[:, np.newaxis] - centroids[:k], axis=2), axis=1) # Compute probabilities proportional to the squared distances prob = dists**2 / np.sum(dists**2) # Choose a new centroid based on the computed probabilities new_centroid = data[np.random.choice(n_samples, p=prob)] centroids[k] = new_centroid return centroids def k_means(data, K, max_iters=300, tol=1e-4): n_samples = data.shape[0] centroids = k_means_plus_plus(data, K) prev_centroids = centroids.copy() labels = np.zeros(n_samples) for _ in range(max_iters): # Distance matrix calculation dists = np.linalg.norm(data[:, np.newaxis] - centroids, axis=2) # Assign clusters based on nearest centroid labels = np.argmin(dists, axis=1) # Update centroids for k in range(K): centroids[k] = data[labels == k].mean(axis=0) if np.any(labels == k) else centroids[k] # Convergence check if np.all(np.abs(centroids - prev_centroids) < tol): break prev_centroids = centroids.copy() return labels"},{"question":"# New Coding Assessment Question Scenario You have been hired by a logistics company to help manage their vehicle fleet data. The company keeps track of each vehicle\'s usage stats, including its current mileage and service history. To ensure efficient fleet management, you need to implement a system to handle various operations on vehicle records. Task Write a function that processes a series of operations on an initially empty collection of vehicle records. Each vehicle is identified by a unique vehicle ID and stores its current mileage. Function Signature ```python def process_vehicle_operations(operations: List[Tuple[str, Union[int, Tuple[int, int]]]]) -> List[int]: Processes a sequence of vehicle operations and returns results of \'mileage\' operations. :param operations: A list of tuples where each tuple represents an operation: - \\"add\\", (vehicle_id, mileage): Adds a vehicle with the given mileage. - \\"update_mileage\\", (vehicle_id, new_mileage): Updates the mileage of the specified vehicle. - \\"delete\\", vehicle_id: Deletes the specified vehicle. - \\"mileage\\", vehicle_id: Returns the mileage of the specified vehicle. :return: A list of mileages for each \\"mileage\\" operation. ``` Constraints 1. `vehicle_id` is guaranteed to be unique for each vehicle. 2. The `operations` list will contain up to (10^5) operations. 3. Vehicle mileages are integer values and can be any non-negative number. Example Given the following operations: ```python operations = [ (\\"add\\", (1, 10000)), (\\"add\\", (2, 15000)), (\\"mileage\\", 1), (\\"update_mileage\\", (1, 12000)), (\\"mileage\\", 1), (\\"delete\\", 2), (\\"mileage\\", 2) ] ``` The function should return: `[10000, 12000, -1]` because the mileage of vehicle 1 is 10000 initially, it updates to 12000, and vehicle 2 is deleted, leading to a mileage query returning -1 for the non-existent vehicle.","solution":"def process_vehicle_operations(operations): vehicles = {} results = [] for operation in operations: action = operation[0] params = operation[1] if action == \\"add\\": vehicle_id, mileage = params vehicles[vehicle_id] = mileage elif action == \\"update_mileage\\": vehicle_id, new_mileage = params if vehicle_id in vehicles: vehicles[vehicle_id] = new_mileage elif action == \\"delete\\": vehicle_id = params vehicles.pop(vehicle_id, None) elif action == \\"mileage\\": vehicle_id = params mileage = vehicles.get(vehicle_id, -1) results.append(mileage) return results"},{"question":"# Coding Assessment Question You have been hired to develop a task manager application that can handle different types of tasks with varying priorities. One key feature required is the ability to enforce rules on task names and priority levels, supporting both addition and retrieval of tasks efficiently. # Task Details Implement a `TaskManager` class with the following methods: 1. `add_task(task_name: str, priority: int) -> None`: Adds a task with a given name and priority to the task manager. - **Input**: - A string `task_name` representing the task\'s name. - An integer `priority` representing the task\'s priority, where a higher number indicates higher priority. - **Output**: None - **Constraints**: - The task name must be a non-empty string and contain only alphanumeric characters and spaces. - The priority must be a non-negative integer. - Adding tasks with the same name should update the priority to the new value. - Any invalid input should raise a `ValueError` with a clear message. 2. `get_highest_priority_task() -> str`: Retrieves the name of the highest priority task. - **Output**: A string representing the name of the task with the highest priority. - **Constraints**: - If there are multiple tasks with the same highest priority, return any one of them. - If no tasks are present in the task manager, return an empty string. You must maintain the tasks in an efficient structure that allows for quick updates and retrievals. # Example Usage ```python >>> tm = TaskManager() >>> tm.add_task(\\"Write Report\\", 3) >>> tm.add_task(\\"Email Client\\", 2) >>> tm.get_highest_priority_task() \'Write Report\' >>> tm.add_task(\\"Email Client\\", 5) >>> tm.get_highest_priority_task() \'Email Client\' >>> tm.add_task(\\"Dev Meeting\\", 5) >>> tm.get_highest_priority_task() \'Email Client\' # or \'Dev Meeting\' >>> tm.add_task(\\"Lunch\\", -1) Traceback (most recent call last): ... ValueError: Invalid priority value >>> tm.add_task(\\" \\", 5) Traceback (most recent call last): ... ValueError: Invalid task name >>> tm.add_task(\\"Complete Documentation\\", 4) >>> tm.add_task(\\"Read Emails\\", 2) >>> tm.get_highest_priority_task() \'Dev Meeting\' # or \'Email Client\' or \'Complete Documentation\' ``` # Additional Requirements - Ensure your implementation includes adequate comments and error handling. - Use efficient data structures to maintain the tasks and their priorities. - Provide at least five unit tests that cover a variety of edge cases. Deliver the Python code that passes the above example usages and unit tests provided.","solution":"class TaskManager: def __init__(self): self.tasks = {} def add_task(self, task_name: str, priority: int) -> None: if not task_name or not isinstance(task_name, str) or not task_name.strip() or not task_name.replace(\' \', \'\').isalnum(): raise ValueError(\\"Invalid task name\\") if not isinstance(priority, int) or priority < 0: raise ValueError(\\"Invalid priority value\\") self.tasks[task_name] = priority def get_highest_priority_task(self) -> str: if not self.tasks: return \\"\\" highest_priority_task = max(self.tasks, key=self.tasks.get) return highest_priority_task"},{"question":"# Coding Assessment Question Scenario You are developing a system that monitors sensor data from various environmental sensors. One of the tasks is to determine if a recorded temperature value, for which the data is given in Celsius, falls within a specified range that is deemed \\"safe\\" for the monitored environment. Task Write a function `is_temperature_safe` that determines whether the given temperature in Celsius is within the safe range. The safe range is defined by two inclusive limits: `min_safe_temp` and `max_safe_temp`. Function Signature ```python def is_temperature_safe(temp: float, min_safe_temp: float, max_safe_temp: float) -> bool: ``` Input * `temp`: A float representing the temperature in Celsius. * `min_safe_temp`: A float representing the minimum safe temperature in Celsius. * `max_safe_temp`: A float representing the maximum safe temperature in Celsius. Output * A boolean value, `True` if the temperature is within the safe range (inclusive), or `False` otherwise. Constraints * The `min_safe_temp` will always be less than or equal to `max_safe_temp`. * The temperature values can be negative or positive. Examples ```python >>> is_temperature_safe(25.0, 20.0, 30.0) True >>> is_temperature_safe(15.0, 20.0, 30.0) False >>> is_temperature_safe(-5.0, -10.0, 0.0) True >>> is_temperature_safe(35.0, 20.0, 30.0) False >>> is_temperature_safe(20.0, 20.0, 30.0) True ``` Explanation of Examples * For `is_temperature_safe(25.0, 20.0, 30.0)`, the temperature 25.0° is within the range 20.0° to 30.0°, inclusive, so the output is `True`. * For `is_temperature_safe(15.0, 20.0, 30.0)`, the temperature 15.0° is below the range 20.0° to 30.0°, and hence the output is `False`. * For `is_temperature_safe(-5.0, -10.0, 0.0)`, the temperature -5.0° is within the range -10.0° to 0.0°, inclusive, so the output is `True`. * For `is_temperature_safe(35.0, 20.0, 30.0)`, the temperature 35.0° is above the range 20.0° to 30.0°, and hence the output is `False`. * For `is_temperature_safe(20.0, 20.0, 30.0)`, the temperature 20.0° is exactly at the minimum limit of the range 20.0° to 30.0°, inclusive, so the output is `True`. Performance Requirements * The function should execute in constant time O(1).","solution":"def is_temperature_safe(temp: float, min_safe_temp: float, max_safe_temp: float) -> bool: Determines if the given temperature is within the safe range. Parameters: - temp: float, the temperature in Celsius. - min_safe_temp: float, the minimum safe temperature in Celsius. - max_safe_temp: float, the maximum safe temperature in Celsius. Returns: - bool: True if the temperature is within the safe range, False otherwise. return min_safe_temp <= temp <= max_safe_temp"},{"question":"# Coding Assessment Question **Objective:** Implement a function to generate all possible unique subsets of a given set of integers. Problem Statement You are given a list of unique integers. Your task is to generate all possible unique subsets of this list, including the empty set and the set itself. The subsets within the result should be in non-descending order and should not contain duplicate subsets. Write a function `generate_subsets` that takes the following input: - `nums`: (List[int]) A list of unique integers. The function should return a list of lists, where each list is a subset of the input list. Constraints - The input list can contain up to 10 unique integers. - The integers in the input list are distinct and can range from -100 to 100. Expected Input and Output ```python def generate_subsets(nums: List[int]) -> List[List[int]]: # your implementation here # Example usage: subsets = generate_subsets([1, 2, 3]) ``` * `Input`: * `nums`: [1, 2, 3] * `Output`: A list of subsets: * `[[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]` Notes 1. Ensure the subsets are presented in non-descending order. 2. The order of the subsets in the output does not need to follow any specific pattern. 3. The function should handle edge cases where the input list is empty by returning `[[]]`.","solution":"from typing import List def generate_subsets(nums: List[int]) -> List[List[int]]: Generates all possible unique subsets of a list of unique integers. subsets = [] def backtrack(start, path): subsets.append(path) for i in range(start, len(nums)): backtrack(i + 1, path + [nums[i]]) nums.sort() # Ensure the input list is sorted backtrack(0, []) return subsets"},{"question":"# Problem: **Linked List Cycle Detection** You are given the task of detecting if a singly linked list has a cycle in it. To expand on this, you will also implement functions to determine the length of the cycle if one exists and to remove the cycle while keeping the list intact otherwise. Operations to Implement: 1. **hasCycle**: Write a function that returns a boolean indicating if a cycle is present in the linked list. 2. **cycleLength**: Write a function that returns the length of the cycle if it exists in the linked list, and 0 otherwise. 3. **removeCycle**: Write a function that removes the cycle from the linked list if it exists. Input and Output Formats: 1. **hasCycle**: - Input: None (method will operate on the linked list) - Output: A boolean indicating whether a cycle was detected 2. **cycleLength**: - Input: None (method will operate on the linked list) - Output: The length of the cycle in the linked list, or 0 if no cycle exists 3. **removeCycle**: - Input: None (method will operate on the linked list) - Output: None # Constraints: - Use O(n) time complexity for cycle detection and removal. - Use O(1) additional space complexity for cycle detection and removal. - You can assume the linked list contains at least one node. # Performance Requirements: - Maintain O(n) time complexity for all operations where n is the number of nodes in the list. - Do not use any extra space other than a few pointers. Example: ```python # Define the LinkedList Node class ListNode: def __init__(self, key): self.key = key self.next = None # Detect if cycle exists def hasCycle(head: ListNode) -> bool: # Implement cycle detection pass # Length of detected cycle def cycleLength(head: ListNode) -> int: # Implement cycle length calculation pass # Remove detected cycle while keeping list intact def removeCycle(head: ListNode) -> None: # Implement cycle removal pass # Example usage: # Create nodes head = ListNode(3) node2 = ListNode(2) node3 = ListNode(0) node4 = ListNode(-4) # Link nodes to form a cycle: 3 -> 2 -> 0 -> -4 -> 2 head.next = node2 node2.next = node3 node3.next = node4 node4.next = node2 print(hasCycle(head)) # Output: True print(cycleLength(head)) # Output: 3 removeCycle(head) print(hasCycle(head)) # Output: False ``` Troubleshoot your implementations to ensure accurate cycle detection, correct length calculation of the cycle, and proper cycle removal if one is present in the linked list.","solution":"class ListNode: def __init__(self, key): self.key = key self.next = None def hasCycle(head: ListNode) -> bool: slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def cycleLength(head: ListNode) -> int: slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected, determine its length current = slow length = 1 while current.next != slow: current = current.next length += 1 return length return 0 def removeCycle(head: ListNode) -> None: slow, fast = head, head cycle_detected = False while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: cycle_detected = True break if not cycle_detected: return # No cycle # Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next # `slow` is now at the start of the cycle # Find the node just before the start of the cycle while fast.next != slow: fast = fast.next # Remove the cycle fast.next = None"},{"question":"# Problem Statement You are tasked with determining if a given list of integers can be partitioned into two subsets such that the sum of elements in both subsets is equal. Implement the function `can_partition(nums)` that accepts a list of integers and returns a boolean value indicating whether the list can be partitioned in the described manner. # Function Signature ```python def can_partition(nums: List[int]) -> bool: ``` # Input - `nums`: A list of integers where `1 <= len(nums) <= 200` and each integer is in the range `1 <= nums[i] <= 100`. # Output - A boolean value `True` if the array can be partitioned into two subsets with equal sum, otherwise `False`. # Constraints - Each integer in the list will be positive. - The total number of elements will be between 1 and 200 inclusive. - The sum of all elements in the list will not exceed 20,000. # Example ```python print(can_partition([1, 5, 11, 5])) # Outputs: True print(can_partition([1, 2, 3, 5])) # Outputs: False ``` # Execution Requirements - The function should efficiently handle the problem within acceptable time limits, considering the constraints. - Ensure edge cases are handled, such as lists with small lengths or sums that are not possible to partition evenly. # Scenario Suppose you are organizing items into two equal-weight piles for transport to ensure balance. To automate this process efficiently, you need to determine if the items (represented as weights in the list) can be equally divided into two groups. # Notes - Leverage dynamic programming for optimal solutions. - The approach involves checking if there exists a subset with a sum equal to half of the total sum of the array. - Return `False` if the total sum is odd, as it cannot be evenly divided. - Ensure your solution is both time-efficient and space-efficient within the constraints given.","solution":"from typing import List def can_partition(nums: List[int]) -> bool: total_sum = sum(nums) # If the total sum is odd, it cannot be partitioned into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Initialize a DP array. dp[i] will be True if a subset with sum i can be achieved dp = [False] * (target + 1) dp[0] = True # Iterate over each number in the input list for num in nums: # Update the DP array from right to left for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"# Question Description Write a Python function that takes an array of `n` integers and returns the length of the longest subarray whose sum is equal to a given target sum `S`. The subarray should be continuous. Your function should handle edge cases and use an efficient algorithm to find the solution, taking into consideration time and space complexity. # Function Signature ```python def longest_subarray_length(nums: list[int], S: int) -> int: Finds the length of the longest subarray with the sum equal to `S`. Parameters: nums (list[int]): A list of integers. S (int): The target sum of the subarray. Returns: int: The length of the longest subarray with sum equal to `S`. Constraints: - 1 <= len(nums) <= 10^4 - -10^4 <= nums[i] <= 10^4 - -10^9 <= S <= 10^9 ``` # Input - A list `nums` of integers, representing the input array. - An integer `S`, representing the target sum. # Output - An integer representing the length of the longest subarray whose sum equals the target `S`. # Example ```python >>> longest_subarray_length([1, -1, 5, -2, 3], 3) 4 >>> longest_subarray_length([-2, -1, 2, 1], 1) 2 >>> longest_subarray_length([1, 2, 3], 6) 3 >>> longest_subarray_length([1, 2, 3], 10) 0 ``` # Constraints - The length of the input list will be at least 1 and at most 10^4. - Each integer in the list can range from (-10^4) to (10^4). - The target sum (S) can range from (-10^9) to (10^9). # Notes Your implementation should seek to find the most efficient solution possible. Consider utilizing techniques such as prefix sums and hashmaps to achieve the optimal time complexity.","solution":"def longest_subarray_length(nums: list[int], S: int) -> int: Finds the length of the longest subarray with the sum equal to `S`. Parameters: nums (list[int]): A list of integers. S (int): The target sum of the subarray. Returns: int: The length of the longest subarray with sum equal to `S`. prefix_sum = 0 prefix_sums_map = {} max_length = 0 for i, num in enumerate(nums): prefix_sum += num if prefix_sum == S: max_length = i + 1 if (prefix_sum - S) in prefix_sums_map: max_length = max(max_length, i - prefix_sums_map[prefix_sum - S]) if prefix_sum not in prefix_sums_map: prefix_sums_map[prefix_sum] = i return max_length"},{"question":"# Description: You are given a function `rotate_matrix_90_clockwise` that rotates a matrix by 90 degrees clockwise using an in-place algorithm. Your task is to implement the function and ensure that the resultant matrix represents a 90-degree clockwise rotation of the given matrix. # Task: Implement the function `rotate_matrix_90_clockwise(matrix: list[list[int]]) -> None` that: 1. Rotates the given `matrix` by 90 degrees clockwise. 2. Modifies the matrix in-place. # Constraints: - The input matrix is a square matrix (NxN). - The matrix contains only integers. - The function should not return anything, as the matrix should be modified in-place. # Inputs: - `matrix` (List of lists of integers): An NxN matrix to be rotated. # Output: - The function does not return anything. It modifies the matrix in-place. # Example Usage: ```python >>> matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] >>> rotate_matrix_90_clockwise(matrix) >>> print(matrix) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ [5, 1, 9], [2, 4, 8], [3, 6, 7] ] >>> rotate_matrix_90_clockwise(matrix) >>> print(matrix) [ [3, 2, 5], [6, 4, 1], [7, 8, 9] ] ``` # Note: - Ensure your implementation is efficient and handles edge cases correctly. - Do not use any extra memory for another matrix; the rotation should be performed in-place. ```python def rotate_matrix_90_clockwise(matrix: list[list[int]]) -> None: n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() ```","solution":"def rotate_matrix_90_clockwise(matrix: list[list[int]]) -> None: Rotates the given NxN matrix by 90 degrees clockwise in place. :param matrix: NxN list of lists of integers representing the matrix n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for row in matrix: row.reverse()"},{"question":"# Problem Statement You are given an array of integers representing the heights of a set of buildings. Assume these buildings form a block. The overarching task is to find out how much water would be trapped between the buildings after a rainstorm. Each building is represented by an index in the array, with the value at that index being the height of the building. # Function Signature ```python def trap_water(height: list[int]) -> int: pass ``` # Input - `height`: A list of integers where each integer represents the height of a building. # Output - The function should return an integer, the total amount of water trapped between the buildings. # Constraints - 0 ≤ len(height) ≤ 10^5 - 0 ≤ height[i] ≤ 10^4 for each element in the height array # Example ```python height = [0,1,0,2,1,0,1,3,2,1,2,1] print(trap_water(height)) # Expected: 6 height = [4,2,0,3,2,5] print(trap_water(height)) # Expected: 9 ``` # Notes - Water trapped between buildings is calculated by checking how much space (in terms of height) exists between taller buildings before and after a group of smaller buildings. - You need to consider both left and right maximum heights for each element to calculate the trapped water effectively. - Optimize the algorithm to handle the upper constraint limits efficiently.","solution":"def trap_water(height): if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"# Question: Implement a Queue Using Two Stacks You need to implement a `QueueUsingStacks` class, which simulates a queue using two stacks. The class should support the following operations: - `enqueue(x: int)`: Adds the element `x` to the end of the queue. - `dequeue() -> int | None`: Removes the element from the front of the queue and returns it. If the queue is empty, return `None`. # Function Signature ```python class QueueUsingStacks: def __init__(self): pass def enqueue(self, x: int) -> None: pass def dequeue(self) -> int | None: pass ``` # Input Format - The sequence of operations is performed via class methods. # Output Format - The method `dequeue` should return an integer representing the element dequeued from the front of the queue or `None` if the queue is empty. # Constraints - Assume the queue contains only integer values. - Ensure that operations `enqueue` and `dequeue` are performed in an average time complexity of O(1). # Example ```python queue = QueueUsingStacks() queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) print(queue.dequeue()) # Output: 1 print(queue.dequeue()) # Output: 2 queue.enqueue(4) print(queue.dequeue()) # Output: 3 print(queue.dequeue()) # Output: 4 print(queue.dequeue()) # Output: None ``` **Hint**: Consider using two stacks to handle the operations, where one stack manages incoming elements and the other stack manages elements to be dequeued.","solution":"class QueueUsingStacks: def __init__(self): self.stack_in = [] self.stack_out = [] def enqueue(self, x: int) -> None: self.stack_in.append(x) def dequeue(self) -> int | None: if not self.stack_out: while self.stack_in: self.stack_out.append(self.stack_in.pop()) return self.stack_out.pop() if self.stack_out else None"},{"question":"**Problem Statement** You are given a list of integers where every integer appears exactly twice, except for one integer that appears exactly once. Your task is to find the integer that appears exactly once. **Your task** is to implement the function `find_single_number(nums: List[int]) -> int` that finds and returns the integer which appears only once in the list. # Input Format * A list of integers, `nums`, where each integer appears exactly twice, except for one integer which appears exactly once. # Output Format * A single integer representing the integer that appears only once in the list. # Constraints * The length of the list will always be an odd number. * `1 <= len(nums) <= 10^5` * `-10^9 <= nums[i] <= 10^9` # Example **Example 1:** ```python print(find_single_number([2, 2, 3, 4, 4])) ``` *Output:* ``` 3 ``` **Example 2:** ```python print(find_single_number([0, 1, 0, 1, 0, 1, 99])) ``` *Output:* ``` 99 ``` # Explanation For the first example, with the list `[2, 2, 3, 4, 4]`: - All numbers appear twice except for the number 3, which appears once. For the second example, with the list `[0, 1, 0, 1, 0, 1, 99]`: - All numbers appear twice except for the number 99, which appears once. # Notes - Consider using bitwise XOR operation to find the single number efficiently. The XOR operation `a ^ a = 0` and `a ^ 0 = a` can be helpful here. - Ensure your solution has a linear time complexity O(n) and uses constant space O(1).","solution":"from typing import List def find_single_number(nums: List[int]) -> int: Finds and returns the integer that appears only once in the list. All other integers appear exactly twice. single_number = 0 for num in nums: single_number ^= num return single_number"},{"question":"Problem Statement You are tasked to write a function that determines if a given integer is a prime number or not. A prime number is defined as a natural number greater than 1 that is not a product of two smaller natural numbers. # Function Signature ```python def is_prime(n: int) -> bool: Check if a given number is a prime number. :param n: Integer to check for primality. :return: True if n is a prime number, else False. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(19) True >>> is_prime(25) False >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(-3) False >>> is_prime(101) True >>> is_prime(102) False pass ``` # Constraints 1. The function should handle both positive and negative integers. 2. The input values can range from -10^12 to 10^12. 3. The function should efficiently determine the primality of large numbers. # Requirements 1. Create a function `is_prime` that matches the specified signature. 2. Implement the logic to efficiently check the primality of the given number. 3. Handle edge cases appropriately, ensuring that negative numbers and numbers less than 2 return `False`. # Example Usage * `is_prime(2)` should return `True`. * `is_prime(4)` should return `False`. * `is_prime(17)` should return `True`.","solution":"def is_prime(n: int) -> bool: Check if a given number is a prime number. :param n: Integer to check for primality. :return: True if n is a prime number, else False. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(19) True >>> is_prime(25) False >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(-3) False >>> is_prime(101) True >>> is_prime(102) False if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Question A company is developing a simple banking system and needs a function to securely handle transfers between accounts. Implement a function that performs a money transfer between two accounts only if certain conditions are met. The function should return a status message based on the result. Function Signature ```python def transfer_funds(account_from: dict, account_to: dict, amount: float) -> str: ... ``` Input - **account_from** (dict): a dictionary representing the account from which the funds will be transferred. Contains the keys \'account_id\' (int), \'balance\' (float), and \'is_active\' (bool). - **account_to** (dict): a dictionary representing the account to which the funds will be transferred. Contains the keys \'account_id\' (int), \'balance\' (float), and \'is_active\' (bool). - **amount** (float): the amount of money to transfer. Must be a positive float. Output - (str): a status message indicating if the transfer was successful or why it failed. Constraints - Both accounts must be active for the transfer to occur. - The `account_from` must have a balance greater than or equal to the transfer amount. - The `amount` must be positive. Examples ```python >>> account_a = {\'account_id\': 1, \'balance\': 1000.0, \'is_active\': True} >>> account_b = {\'account_id\': 2, \'balance\': 500.0, \'is_active\': True} >>> transfer_funds(account_a, account_b, 200.0) \\"Transfer successful\\" >>> account_c = {\'account_id\': 3, \'balance\': 50.0, \'is_active\': True} >>> transfer_funds(account_a, account_c, 2000.0) \\"Transfer failed: Insufficient funds\\" >>> account_d = {\'account_id\': 4, \'balance\': 300.0, \'is_active\': False} >>> transfer_funds(account_a, account_d, 100.0) \\"Transfer failed: Inactive account\\" ```","solution":"def transfer_funds(account_from: dict, account_to: dict, amount: float) -> str: Perform a transfer of funds between two accounts if conditions are met. :param account_from: dict - account from which the funds will be transferred. :param account_to: dict - account to which the funds will be transferred. :param amount: float - the amount of money to transfer. :return: str - status message indicating success or reason for failure. if not account_from[\'is_active\'] or not account_to[\'is_active\']: return \\"Transfer failed: Inactive account\\" if amount <= 0: return \\"Transfer failed: Invalid transfer amount\\" if account_from[\'balance\'] < amount: return \\"Transfer failed: Insufficient funds\\" # Perform the transfer account_from[\'balance\'] -= amount account_to[\'balance\'] += amount return \\"Transfer successful\\""},{"question":"# Question: Find the Kth Largest Element in an Array Context Given an unsorted array, finding the Kth largest element may be required in various applications, such as determining the median, identifying outliers, or statistical analysis. Two common methods include using a heap or quickselect algorithm, both of which offer efficient approaches. Task Implement a class `KthLargestElement` that contains methods to find the Kth largest element in an array using: - `heap_find` method: Implements a Min-Heap to find the Kth largest element. - `quickselect_find` method: Implements the Quickselect algorithm to find the Kth largest element. Input and Output 1. **Input**: - An unsorted list of integers. - An integer K representing the Kth largest element to find. 2. **Output**: - Return the Kth largest element in the array. **Function Signatures**: ```python class KthLargestElement: def heap_find(self, array: list[int], k: int) -> int: # Your implementation here def quickselect_find(self, array: list[int], k: int) -> int: # Your implementation here ``` Constraints - The input array can contain duplicate elements, and the array is unsorted. - You must manage edge cases like arrays with fewer elements than K or empty arrays. **Constraints**: - 1 <= len(array) <= 10^6 - -10^9 <= array[i] <= 10^9 - 1 <= k <= len(array) Example ```python >>> kle = KthLargestElement() >>> kle.heap_find([3, 2, 1, 5, 6, 4], 2) 5 >>> kle.quickselect_find([3, 2, 1, 5, 6, 4], 4) 3 >>> kle.heap_find([3, 2, 1, 5, 6, 4], 1) 6 >>> kle.quickselect_find([1], 1) 1 >>> kle.heap_find([], 1) ValueError: Array must contain at least k elements ``` Ensure your implementations can handle both large arrays efficiently and return the correct Kth largest element without errors.","solution":"import heapq class KthLargestElement: def heap_find(self, array: list[int], k: int) -> int: if len(array) < k: raise ValueError(\\"Array must contain at least k elements\\") # Use a min-heap to store the k largest elements min_heap = array[:k] heapq.heapify(min_heap) for num in array[k:]: if num > min_heap[0]: heapq.heappop(min_heap) heapq.heappush(min_heap, num) return min_heap[0] def quickselect_find(self, array: list[int], k: int) -> int: if len(array) < k: raise ValueError(\\"Array must contain at least k elements\\") def partition(left, right, pivot_index): pivot_value = array[pivot_index] # Move pivot to end array[pivot_index], array[right] = array[right], array[pivot_index] store_index = left for i in range(left, right): if array[i] < pivot_value: array[i], array[store_index] = array[store_index], array[i] store_index += 1 # Move pivot to its final place array[right], array[store_index] = array[store_index], array[right] return store_index def quickselect(left, right, k_smallest): if left == right: return array[left] pivot_index = left + (right - left) // 2 pivot_index = partition(left, right, pivot_index) if k_smallest == pivot_index: return array[k_smallest] elif k_smallest < pivot_index: return quickselect(left, pivot_index - 1, k_smallest) else: return quickselect(pivot_index + 1, right, k_smallest) # Kth largest is (len(array) - k)th smallest in 0-indexed return quickselect(0, len(array) - 1, len(array) - k)"},{"question":"# Virtual Assistant Task Manager You are tasked with developing a basic functionality of a virtual assistant that can manage and track tasks. **Task**: Implement the function `manage_tasks` that takes a list of predefined commands and manages a list of tasks. # Function Signature ```python def manage_tasks(commands: list) -> dict: Build a task manager to add, remove, and list tasks. Args: commands (list): List of strings representing commands. Returns: dict: A dictionary representing the final state of tasks after all commands have been executed. Example format: { \'todo\': [\'task1\', \'task3\'], \'done\': [\'task2\'] } ``` # Requirements 1. **Input**: - `commands` (list): A list of strings where each string represents a command in the format `\\"COMMAND_NAME task_details\\"`. - `COMMAND_NAME` can be: * `ADD`: Adds a task to the todo list. * `REMOVE`: Removes a task from either todo or done list. * `DONE`: Marks a task as done. * `UNDONE`: Marks a task as not done (moves back to the todo list). 2. **Output**: - A dictionary representing the state of tasks in two categories: * `todo` (list): Tasks that are pending. * `done` (list): Tasks that are completed. # Instructions 1. Implement commands: - `\'ADD task_name\'`: Adds `task_name` to the todo list. - `\'REMOVE task_name\'`: Removes `task_name` from todo or done list. - `\'DONE task_name\'`: Moves `task_name` from todo list to done list. - `\'UNDONE task_name\'`: Moves `task_name` from done list back to todo list. 2. Ensure that tasks in the todo and done lists are unique. 3. Return the final state of `todo` and `done` lists as a dictionary. 4. Handle any exceptional cases gracefully and ensure the integrity of task lists. # Constraints: - Tasks names are unique and do not contain spaces. - Input commands are valid and well-formed. # Example ```python >>> manage_tasks([\\"ADD task1\\", \\"ADD task2\\", \\"DONE task1\\", \\"REMOVE task2\\", \\"ADD task3\\", \\"DONE task3\\", \\"UNDONE task1\\"]) { \'todo\': [\'task1\'], \'done\': [\'task3\'] } ``` Ensure your solution handles all edge cases and maintains efficiency with a clear and logical structure.","solution":"def manage_tasks(commands: list) -> dict: Build a task manager to add, remove, and list tasks. Args: commands (list): List of strings representing commands. Returns: dict: A dictionary representing the final state of tasks after all commands have been executed. Example format: { \'todo\': [\'task1\', \'task3\'], \'done\': [\'task2\'] } tasks = {\'todo\': [], \'done\': []} for command in commands: cmd_parts = command.split(maxsplit=1) cmd_name = cmd_parts[0] cmd_task = cmd_parts[1] if len(cmd_parts) > 1 else \\"\\" if cmd_name == \'ADD\': if cmd_task and cmd_task not in tasks[\'todo\'] and cmd_task not in tasks[\'done\']: tasks[\'todo\'].append(cmd_task) elif cmd_name == \'REMOVE\': if cmd_task in tasks[\'todo\']: tasks[\'todo\'].remove(cmd_task) elif cmd_task in tasks[\'done\']: tasks[\'done\'].remove(cmd_task) elif cmd_name == \'DONE\': if cmd_task in tasks[\'todo\']: tasks[\'todo\'].remove(cmd_task) tasks[\'done\'].append(cmd_task) elif cmd_name == \'UNDONE\': if cmd_task in tasks[\'done\']: tasks[\'done\'].remove(cmd_task) tasks[\'todo\'].append(cmd_task) return tasks"},{"question":"# Problem Statement You are working with a grid-based game where players move on a 2D grid. The grid contains traps that players need to avoid. The goal of each player is to reach the bottom-right corner of the grid from the top-left corner. You need to determine the number of unique paths a player can take to reach the goal while avoiding the traps. Implement a function `unique_paths_with_traps(grid: List[List[int]]) -> int` that returns the number of unique paths from the top-left corner to the bottom-right corner of the grid, given the following constraints: 1. The grid is represented as a 2D list of integers, where `0` denotes an empty cell and `1` denotes a trap. 2. Players can only move right or down at any point in time. Input - A 2D list `grid` where `grid[i][j]` is either `0` (empty cell) or `1` (trap). The dimensions of the grid are `m x n` (1 ≤ m, n ≤ 100). Output - An integer representing the number of unique paths from the top-left corner to the bottom-right corner avoiding traps. Constraints - The starting cell (top-left) and the ending cell (bottom-right) are always empty cells (`0`). - Ensure the function is efficient in terms of time and space complexity. # Example ```python def unique_paths_with_traps(grid: List[List[int]]) -> int: # Your implementation here # Example grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] result = unique_paths_with_traps(grid) print(result) # Output should be 2 ``` # Notes - Your implementation should efficiently handle the given constraints and grid dimensions. - Remember to consider edge cases such as all cells being empty (`0`) except for the starting and ending cells.","solution":"from typing import List def unique_paths_with_traps(grid: List[List[int]]) -> int: m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Coding Assessment Question **Context**: You have been asked to develop a function for a system that processes customer transactions. One of the requirements is to determine the most frequently sold product. The input is a list of product names representing transactions. **Objective**: Write a function `most_frequent_product` that identifies the product with the highest frequency of sales. In case of a tie, return the product that appears first in the list. **Function signature**: ```python def most_frequent_product(transactions: list) -> str: pass ``` **Input**: * A list of strings `transactions` where each string represents a product name. The list is guaranteed to have at least one transaction. **Output**: * Return a single string representing the product with the highest frequency of sales. In case of a tie, the product that appears first in the list should be returned. **Constraints**: 1. The product names are case sensitive, meaning \'Apple\' and \'apple\' are considered different products. 2. The list will contain at least one transaction and less than 1000 transactions. **Example**: ```python >>> most_frequent_product([\'apple\', \'banana\', \'apple\', \'orange\', \'banana\', \'apple\']) \'apple\' >>> most_frequent_product([\'toy\', \'book\', \'toy\', \'pen\', \'pen\', \'book\']) \'toy\' ``` **Performance Requirements**: * The function should maintain efficient performance, ideally with a linear time complexity (O(n)). **Additional Information**: * Consider using a dictionary to keep track of the number of sales for each product. * Ensure the solution handles ties by prioritizing the product that appears first in the list.","solution":"def most_frequent_product(transactions: list) -> str: Identifies the product with the highest frequency of sales. In case of a tie, returns the product that appears first in the list. from collections import defaultdict # Record the frequency count and the first occurrence index of each product product_count = defaultdict(int) product_first_index = {} for i, product in enumerate(transactions): if product not in product_first_index: product_first_index[product] = i product_count[product] += 1 # Determine the product with the highest frequency and earliest first occurrence in case of tie most_frequent = None highest_count = 0 for product, count in product_count.items(): if count > highest_count or (count == highest_count and product_first_index[product] < product_first_index[most_frequent]): highest_count = count most_frequent = product return most_frequent"},{"question":"# Coding Assessment Question You have been provided two methods to determine if a string contains valid parentheses: 1. An iterative method using a stack. 2. A recursive method that reduces the problem size at each step. # Task Write a Python function that does the following: 1. Reads in a string containing only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. 2. Compares the validity of the parentheses structure as determined by both the iterative and recursive methods. 3. If both methods agree that the parentheses are valid or invalid, return a string \\"Matching Validation: [valid/invalid]\\". 4. If their results differ, return a string \\"Discrepancy: Iterative found [iterative_result], Recursive found [recursive_result]\\". # Requirements 1. **Input**: A string with parentheses characters. 2. **Output**: A string message as specified above. 3. **Constraints**: * The input string can have up to 100,000 characters. * The input string can be empty. In such a case, the function should return the string \\"Empty string provided\\". # Performance: * The function must handle large strings efficiently, taking both time and space complexities into consideration. Examples: ```python # Example 1: input_string = \\"({[()]})\\" validate_parentheses(input_string) # Output: \\"Matching Validation: valid\\" # Example 2: input_string = \\"({[({})]}\\" validate_parentheses(input_string) # Output: \\"Matching Validation: invalid\\" # Example 3: input_string = \\"\\" validate_parentheses(input_string) # Output: \\"Empty string provided\\" ```","solution":"def validate_parentheses(input_string): if not input_string: return \\"Empty string provided\\" def iterative_check(s): stack = [] matching_bracket = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket.keys(): if stack == [] or matching_bracket[char] != stack.pop(): return False return stack == [] def recursive_check(s, stack=[]): if not s: return stack == [] first, rest = s[0], s[1:] if first in \'({[\': return recursive_check(rest, stack + [first]) elif first in \')}]\': if not stack or {\')\': \'(\', \'}\': \'{\', \']\': \'[\'}[first] != stack[-1]: return False return recursive_check(rest, stack[:-1]) else: return recursive_check(rest, stack) iterative_result = iterative_check(input_string) recursive_result = recursive_check(input_string) if iterative_result == recursive_result: return f\\"Matching Validation: {\'valid\' if iterative_result else \'invalid\'}\\" else: return f\\"Discrepancy: Iterative found {\'valid\' if iterative_result else \'invalid\'}, Recursive found {\'valid\' if recursive_result else \'invalid\'}\\""},{"question":"# Coding Question: Maximum Length of Subarray with Equal Number of 0s and 1s You are provided with a binary array (an array containing only 0s and 1s). Implement the function `max_length_equal_zeros_ones(arr: list[int]) -> int` which returns the length of the longest contiguous subarray that contains an equal number of 0s and 1s. Input - `arr`: A list of integers `arr[0], arr[1], ..., arr[n-1]`, where `1 <= n <= 10^5` and `arr[i]` is either 0 or 1. Output - Return an integer that represents the maximum length of the subarray with an equal number of 0s and 1s. Constraints - The array can have all 0s or all 1s. - Consider edge cases such as: short arrays, arrays with alternating 0s and 1s, and arrays where the maximum length subarray is not at the ends. Examples ```python >>> max_length_equal_zeros_ones([0, 1, 0, 1, 1, 0, 0]) 6 >>> max_length_equal_zeros_ones([0, 0, 1, 1, 0]) 4 >>> max_length_equal_zeros_ones([0, 1]) 2 >>> max_length_equal_zeros_ones([0, 1, 1, 0]) 4 >>> max_length_equal_zeros_ones([1, 1, 1, 1]) 0 >>> max_length_equal_zeros_ones([0]) 0 ``` Performance Considerations The function should efficiently handle large inputs, with both time and space complexity considerations kept in mind. Detailed Explanation: 1. Convert the array to a form where 0 becomes -1, allowing the problem to be reduced to finding the longest subarray with sum 0. 2. Utilize a hashmap to track the first occurrence of each cumulative sum. 3. Iterate through the array while maintaining the cumulative sum, and use the hashmap to check for subarray lengths. 4. Efficiently handle edge cases, ensuring correctness for all input scenarios.","solution":"def max_length_equal_zeros_ones(arr): Returns the length of the longest subarray with an equal number of 0s and 1s. # Step 1: Initialize variables max_length = 0 cumulative_sum = 0 sum_indices = {0: -1} # Initialize with base case # Step 2: Traverse the array for index, value in enumerate(arr): if value == 0: cumulative_sum -= 1 else: cumulative_sum += 1 if cumulative_sum in sum_indices: max_length = max(max_length, index - sum_indices[cumulative_sum]) else: sum_indices[cumulative_sum] = index return max_length"},{"question":"# Question: Graph Traversal: Depth-First Search (DFS) Implementation As a software engineer tasked with designing a network analysis tool, you are required to implement a core functionality: depth-first search (DFS) traversal on a graph. The objective is to explore all nodes reachable from a given starting node and return the nodes in the order they are visited. Function 1: `dfs_iterative` Implement a function `dfs_iterative` that performs depth-first search using an iterative approach. The function should take in two parameters: * `graph` (dict): A dictionary representing the adjacency list of the graph, where the keys are node identifiers and the values are lists of adjacent nodes. * `start` (any): The starting node for the DFS traversal. The function should return a list of nodes in the order they are visited. Function 2: `dfs_recursive` Implement a function `dfs_recursive` that performs depth-first search using a recursive approach. The function should take in three parameters: * `graph` (dict): A dictionary representing the adjacency list of the graph, where the keys are node identifiers and the values are lists of adjacent nodes. * `start` (any): The starting node for the DFS traversal. * `visited` (set): A set to keep track of visited nodes during recursion. The function should return a list of nodes in the order they are visited. # Constraints * The input graph is represented as a dictionary with non-negative integer nodes. * The graph can be directed or undirected. * Ensure the functions handle graphs with cycles without causing infinite loops. * `start` node is guaranteed to be a valid key in the graph. # Examples ```python graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0, 5], 3: [1], 4: [1], 5: [2] } # Iterative DFS traversal from node 0 print(dfs_iterative(graph, 0)) # [0, 2, 5, 1, 4, 3] # Recursive DFS traversal from node 0 print(dfs_recursive(graph, 0, set())) # [0, 1, 3, 4, 2, 5] ``` # Requirements Your functions should: 1. Handle invalid graphs or start nodes by raising a `ValueError`. 2. Ensure to properly manage visited nodes to avoid infinite loops. 3. Handle cases where the graph is empty, and the start node has no neighbors gracefully. Start coding these functions ensuring that all the provided examples and edge cases are handled effectively. Good luck!","solution":"def dfs_iterative(graph, start): if not graph or start not in graph: raise ValueError(\\"Invalid graph or start node\\") visited = set() stack = [start] result = [] while stack: node = stack.pop() if node not in visited: visited.add(node) result.append(node) stack.extend(graph[node][::-1]) # Add neighbors to the stack in reverse order return result def dfs_recursive(graph, start, visited=None): if not graph or start not in graph: raise ValueError(\\"Invalid graph or start node\\") if visited is None: visited = set() if start not in visited: visited.add(start) result = [start] for neighbor in graph[start]: result.extend(dfs_recursive(graph, neighbor, visited)) return result return []"},{"question":"# Coding Assessment Question Objective: Implement a function to identify and categorize odd and even numbers from a given list of integers, and return their respective counts. Description: You are given a list of integers. Write a function `categorize_numbers` that processes this list and counts how many of the numbers are odd and how many are even. Input: - A list of integers, which can be positive, negative, or zero. Output: - Return a dictionary with two keys: \\"odd\\" and \\"even\\". The value for each key should be the count of odd and even numbers in the input list, respectively. Constraints: - Assume a maximum of 1000 integers in the list. - Integers can be both negative and positive. Example: ```python input_numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] expected_output = { \\"odd\\": 5, \\"even\\": 5 } ``` ```python input_numbers = [-10, -3, -2, -1, 0, 1, 2, 3] expected_output = { \\"odd\\": 4, \\"even\\": 4 } ``` Function Signature: ```python def categorize_numbers(numbers: list) -> dict: pass ``` Implementation Instructions: 1. Implement the function that iterates through the list and classifies each number as odd or even. 2. Count the occurrences of odd and even numbers. 3. Return the counts in the specified dictionary format, ensuring correctness and readability.","solution":"def categorize_numbers(numbers: list) -> dict: Processes a list of integers and counts how many are odd and how many are even. Parameters: numbers (list): A list of integers. Returns: dict: A dictionary with counts of odd and even numbers. count = {\\"odd\\": 0, \\"even\\": 0} for num in numbers: if num % 2 == 0: count[\\"even\\"] += 1 else: count[\\"odd\\"] += 1 return count"},{"question":"# Scenario You are developing a text analysis tool that needs to provide word frequency counts from a collection of documents. Each document is a string of text, and the goal is to count the frequency of each unique word across all documents in the collection. # Coding Task Write a function `count_word_frequencies(documents: List[str]) -> Dict[str, int]` that processes a list of documents and returns a dictionary where keys are unique words and values are the respective counts of those words. # Input 1. `documents` (List[str]): A list of strings, where each string represents a document. # Output 1. A dictionary where keys are unique words (case-insensitive) and values are the frequency counts of those words. # Constraints 1. Each document is a non-empty string containing words separated by whitespace and/or punctuation marks. 2. Assume words are case-insensitive (e.g., \\"Word\\" and \\"word\\" should be considered the same). 3. The total number of words across all documents will not exceed 10,000. # Performance Requirements 1. Efficiently handle the given input size constraints. 2. Properly handle punctuation and normalization of word cases. # Starter Code ```python from typing import List, Dict import re from collections import defaultdict def count_word_frequencies(documents: List[str]) -> Dict[str, int]: # Use a default dictionary to store word frequencies word_frequencies = defaultdict(int) # Define a regex pattern to capture words word_pattern = re.compile(r\'bw+b\') for document in documents: # Extract words from the document and normalize them to lower case words = word_pattern.findall(document.lower()) for word in words: word_frequencies[word] += 1 return dict(word_frequencies) # Example: # documents = [\\"Hello world!\\", \\"World of code.\\", \\"Hello again, world.\\"] # result = count_word_frequencies(documents) # print(result) # Output: {\'hello\': 2, \'world\': 3, \'of\': 1, \'code\': 1, \'again\': 1} ``` # Evaluation Criteria * Correctness: The functionality should correctly count word frequencies regardless of case and handle punctuation properly. * Efficiency: The implementation should be able to handle the input size constraints effectively. * Edge Case Handling: Ensure that the solution works well with different forms of punctuation and cases in the text.","solution":"from typing import List, Dict import re from collections import defaultdict def count_word_frequencies(documents: List[str]) -> Dict[str, int]: # Use a default dictionary to store word frequencies word_frequencies = defaultdict(int) # Define a regex pattern to capture words word_pattern = re.compile(r\'bw+b\') for document in documents: # Extract words from the document and normalize them to lower case words = word_pattern.findall(document.lower()) for word in words: word_frequencies[word] += 1 return dict(word_frequencies)"},{"question":"# Problem Statement Implement a function that takes an integer `n`, and returns a list of all unique complete binary trees with `n` nodes. Each tree should be represented as a root node with potential left and right children nodes. # Function Signature ```python import itertools from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def all_unique_complete_bsts(n: int) -> List[TreeNode]: Generate all unique complete binary trees with n nodes. Parameters: n (int): The number of nodes in the binary tree, where 1 <= n <= 10. Returns: List[TreeNode]: A list of TreeNode objects, each representing a unique complete binary tree with n nodes. Examples: >>> len(all_unique_complete_bsts(3)) 1 >>> len(all_unique_complete_bsts(4)) 2 ``` # Requirements 1. **Input**: * An integer `n`, representing the number of nodes in the complete binary trees. Constraint: `1 <= n <= 10`. 2. **Output**: * A list of `TreeNode` objects, where each TreeNode represents a unique complete binary tree with `n` nodes. 3. **Constraints**: * The trees should be \\"complete\\" binary trees, meaning all levels except possibly the last are completely filled, and all nodes are as far left as possible. * Input value `n` is constrained within a reasonable range to ensure feasibility of operations within typical limits. # Example Scenarios Example 1: * **Input**: `3` * **Output**: `[<TreeNode>]` (list containing one complete binary tree) * **Explanation**: There is only one unique complete binary tree with 3 nodes. Example 2: * **Input**: `4` * **Output**: `[<TreeNode>, <TreeNode>]` (list containing two unique complete binary trees) * **Explanation**: There are exactly two unique complete binary trees with 4 nodes. # Notes 1. Ensure that the function does not recompute results for the same input to improve efficiency. 2. Use a TreeNode class for constructing output binary trees. 3. Implement a helper method if necessary to construct intermediate tree structures.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def all_unique_complete_bsts(n: int) -> List[TreeNode]: def generate_trees(start, end): if start > end: return [None] all_trees = [] for i in range(start, end + 1): left_trees = generate_trees(start, i - 1) right_trees = generate_trees(i + 1, end) for l in left_trees: for r in right_trees: root = TreeNode(i) root.left = l root.right = r all_trees.append(root) return all_trees if n == 0: return [] return generate_trees(1, n)"},{"question":"# Question: Optimal Meeting Point in a 2D Grid You are given a 2D grid of size `m x n` filled with organic cells. Each cell in the grid can either be occupied (\'1\') or empty (\'0\'). A group of cells form a cluster if they are directly connected horizontally or vertically. Your task is to determine the optimal meeting point within the grid such that the total travel distance for all cells in the largest cluster (the one containing the maximum \'1\'s) is minimized. The total travel distance is the sum of the Manhattan distances from all \'1\'s in the largest cluster to the meeting point. The Manhattan distance between two cells (x1, y1) and (x2, y2) is |x1 - x2| + |y1 - y2|. **Function Signature**: ```python def optimal_meeting_point(grid: list[list[str]]) -> tuple[int, int]: ... ``` # Input - `grid`: A 2D list of characters (\'0\' or \'1\'), of size `m x n` (1 ≤ m, n ≤ 100). # Output - Return a tuple (row, col) representing the coordinates of the optimal meeting point. # Constraints * The function should execute efficiently even for large grids. * If there are multiple optimal meeting points, return any one of them. # Examples ```python # Example 1 grid1 = [ [\'1\', \'0\', \'0\', \'0\'], [\'0\', \'1\', \'1\', \'0\'], [\'0\', \'0\', \'0\', \'1\'], [\'1\', \'0\', \'0\', \'0\'] ] assert optimal_meeting_point(grid1) == (1, 2) # or (2, 1) or any other positions with the same minimal distance # Example 2 grid2 = [ [\'1\', \'1\', \'0\', \'1\'], [\'1\', \'0\', \'0\', \'1\'], [\'0\', \'0\', \'1\', \'1\'] ] assert optimal_meeting_point(grid2) == (1, 0) # or any other positions with the same minimal distance # Example 3 grid3 = [ [\'0\', \'0\', \'0\', \'0\'], [\'0\', \'0\', \'0\', \'0\'], [\'0\', \'1\', \'1\', \'0\'], [\'0\', \'1\', \'1\', \'0\'] ] assert optimal_meeting_point(grid3) == (2, 2) # or (3, 2) or any other positions with the same minimal distance # Example 4 grid4 = [ [\'1\'] ] assert optimal_meeting_point(grid4) == (0, 0) # Example 5 grid5 = [ [\'0\', \'0\', \'0\'], [\'0\', \'0\', \'0\'], [\'0\', \'0\', \'0\'] ] assert optimal_meeting_point(grid5) == None ``` # Description - Your task is to implement the function `optimal_meeting_point(grid: list[list[str]]) -> tuple[int, int]` which returns the coordinates of the optimal meeting point for the largest cluster within the grid. If the grid contains no \'1\'s, return `None`. - **Optimal Meeting Point**: * The Manhattan distance should be minimized for all cells in the largest cluster. * If there are multiple optimal meeting points, any one of them can be returned. # Notes * Consider any edge cases such as grids with no \'1\'s or smallest possible grids. * The grid can have multiple equally optimal meeting points, return any one of them. * Ensure to optimize the solution for larger grids up to the provided constraints.","solution":"def optimal_meeting_point(grid: list[list[str]]) -> tuple[int, int]: from collections import deque def bfs(start): m, n = len(grid), len(grid[0]) visited = set() q = deque([start]) cluster = [] while q: x, y = q.popleft() if (x, y) in visited: continue visited.add((x, y)) cluster.append((x, y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == \'1\' and (nx, ny) not in visited: q.append((nx, ny)) return cluster m, n = len(grid), len(grid[0]) largest_cluster = [] for i in range(m): for j in range(n): if grid[i][j] == \'1\': candidate_cluster = bfs((i, j)) if len(candidate_cluster) > len(largest_cluster): largest_cluster = candidate_cluster if not largest_cluster: return None xs = sorted(x for x, y in largest_cluster) ys = sorted(y for x, y in largest_cluster) median_x = xs[len(xs) // 2] median_y = ys[len(ys) // 2] return (median_x, median_y)"},{"question":"# Problem Statement Write a Python function `find_combinations(s: str)` that returns all possible combinations of the characters in the input string `s`. Each combination should be a string containing the characters in the input string in any order. # Function Signature ```python def find_combinations(s: str) -> set: ``` # Input - A string `s`, where `0 <= len(s) <= 8`. The string may contain duplicate characters. # Output - A set of strings, each representing a unique combination of the input string\'s characters. # Constraints - If the input string is empty, return a set with an empty string. # Performance Requirements - The solution should handle cases up to the maximum input length efficiently. # Example ```python >>> find_combinations(\\"abc\\") {\'a\', \'ab\', \'abc\', \'ac\', \'b\', \'bc\', \'c\'} >>> find_combinations(\\"a\\") {\'a\'} >>> find_combinations(\\"\\") {\'\'} ``` # Additional Test Cases ```python >>> find_combinations(\\"abb\\") {\'a\', \'ab\', \'abb\', \'b\', \'bb\'} >>> find_combinations(\\"aa\\") {\'a\', \'aa\'} >>> find_combinations(\\"123\\") {\'1\', \'12\', \'123\', \'13\', \'2\', \'23\', \'3\'} ``` # Implementation Constraints - Avoid using built-in functions that directly generate combinations. - Handle the creation of combinations internally within the function.","solution":"from itertools import combinations def find_combinations(s: str) -> set: Returns all possible combinations of the characters in the input string s. result = set() for i in range(1, len(s) + 1): for combo in combinations(s, i): result.add(\'\'.join(combo)) if not s: result.add(\'\') return result"},{"question":"**Task**: Implement a function `transpose_csv(input_path: str, output_path: str) -> None` that reads a CSV file and writes a new CSV file in which the rows and columns are transposed. The first row of the input file will become the first column of the output file, the second row will become the second column, and so on. **Requirements**: - Read the input CSV file and parse its contents. - Transpose the rows and columns of the data. - Write the transposed data to the specified output CSV file. - Ensure that the CSV file handles commas within data correctly and maintains the integrity of quoted fields. **Input/Output Specification**: - **Input**: `input_path` - Path to the input CSV file. - **Output**: `output_path` - Path to the output transposed CSV file. - **Constraints**: - The input file is assumed to be a properly formatted CSV. - Field values may contain commas and quotes, which must be handled correctly. - The output file must preserve the original formatting and values from the input file. **Performance**: Your solution should aim for efficiency in reading, transposing, and writing the data, maintaining a time complexity of O(n * m) where n is the number of rows and m is the number of columns. **Scenario**: Given an input CSV file, you need to: - Read all the rows and columns from the input file. - Swap rows with columns, so the first row becomes the first column in the output, the second row becomes the second column, and so on. - Write the transposed data to the specified output file in CSV format. **Edge Cases**: - The input file is empty or contains only a header row. - Row lengths are inconsistent (i.e., some rows have more columns than others). Implement and thoroughly test the `transpose_csv` function to handle various scenarios and edge cases.","solution":"import csv def transpose_csv(input_path: str, output_path: str) -> None: Reads a CSV file, transposes the rows and columns, and writes the transposed content to a new CSV file. Parameters: input_path (str): Path to the input CSV file. output_path (str): Path to the output CSV file. with open(input_path, \'r\', newline=\'\') as input_file: reader = csv.reader(input_file) rows = list(reader) if not rows: # If the input file is empty, also create an empty output file. with open(output_path, \'w\', newline=\'\') as output_file: pass return transposed_data = list(map(list, zip(*rows))) with open(output_path, \'w\', newline=\'\') as output_file: writer = csv.writer(output_file) writer.writerows(transposed_data)"},{"question":"# Coding Assessment Question Description You are provided with an algorithm to count the occurrences of each word in a text file and generate a word frequency dictionary. The goal is to write a function that analyzes a file and returns the most frequently occurring word along with its count. Task Implement the function: ```python def most_frequent_word(file_path: str) -> tuple: :param file_path: String path to the text file. :return: Tuple containing the most frequent word and its count in the format (word: str, count: int). ``` This function should: * Read the contents of the file specified by `file_path`. * Normalize the text by converting it to lowercase. * Remove punctuation from the words. * Count the occurrences of each word. * Determine the most frequent word and return it along with its count. Input * `file_path`: String representing the path to a text file. Output * Return a tuple consisting of the most frequent word (string) and its count (integer). Constraints * The text file will contain at most 10^6 characters. * Words are separated by whitespace. * The file will contain at least one word. * Punctuation to be removed includes: \'.\', \',\', \'!\', \'?\', \':\', \';\'. Performance Requirements * The function should handle large files within reasonable time limits. Example: Suppose the content of the text file `sample.txt` is: ``` This, is a sample text file. This file is used to check the most frequent word and its count. ``` ```python file_path = \\"sample.txt\\" result = most_frequent_word(file_path) ``` The `result` would be `(\'is\', 2)` as the word \\"is\\" appears twice, which is the highest frequency among all words in the file. This question requires the use of file handling, string manipulation, and dictionary operations to achieve the desired functionality. Implementing the function correctly will demonstrate proficiency in handling text data and extracting meaningful information efficiently.","solution":"import string from collections import Counter def most_frequent_word(file_path: str) -> tuple: Reads a text file and returns the most frequent word along with its count. with open(file_path, \'r\') as file: text = file.read() # Normalize the text text = text.lower() text = text.translate(str.maketrans(\'\', \'\', string.punctuation)) # Split text into words words = text.split() # Count occurrences of each word word_counts = Counter(words) # Find the most frequent word and its count most_common_word, most_common_count = word_counts.most_common(1)[0] return most_common_word, most_common_count"},{"question":"**Implement a function that checks if a given string can be transformed into a palindrome by removing at most one character.** # Objective Your task is to write a function `can_form_palindrome_by_removal` that takes a string as input and returns `True` if the string can be transformed into a palindrome by removing at most one character, and `False` otherwise. # Function Signature ```python def can_form_palindrome_by_removal(s: str) -> bool: ``` # Input The function `can_form_palindrome_by_removal` should take a single argument: - `s`: A string of length between 1 and 10^5, consisting of lowercase English letters. # Output The function should return a boolean: - `True` if the string can be transformed into a palindrome by removing at most one character. - `False` otherwise. # Example ```python print(can_form_palindrome_by_removal(\\"abca\\")) # Should return True print(can_form_palindrome_by_removal(\\"racecar\\")) # Should return True print(can_form_palindrome_by_removal(\\"abecbea\\")) # Should return False ``` # Explanation 1. For the input `abca`, you can remove the character \'c\' (or \'b\') to get `aba` which is a palindrome. 2. For `racecar`, it\'s already a palindrome, thus does not require any removals. 3. For `abecbea`, removing any single character will not result in a palindrome. # Notes - A palindrome is a string that reads the same forwards and backwards. - Consider all possible single character removals to determine if the resulting string is a palindrome. - Optimize your solution to handle the upper constraint efficiently.","solution":"def can_form_palindrome_by_removal(s: str) -> bool: def is_palindrome_range(i, j): Check if substring s[i:j+1] is a palindrome return all(s[k] == s[j - k + i] for k in range(i, (j + i) // 2 + 1)) l, r = 0, len(s) - 1 while l < r: if s[l] != s[r]: # If there\'s a mismatch, check both removals return is_palindrome_range(l + 1, r) or is_palindrome_range(l, r - 1) l += 1 r -= 1 return True"},{"question":"# Problem Statement You are given a task to work with strings and perform two specific operations: checking if a string is a palindrome and finding the longest palindromic substring within a string. You are provided with the following two tasks: 1. **Check if a String is a Palindrome**: Write a function named `is_palindrome` that takes a string as input and returns a boolean indicating whether the string is a palindrome. If the input is not a string or is an empty string, your function should raise a `ValueError`. 2. **Find the Longest Palindromic Substring**: Write a function named `longest_palindromic_substring` that takes a string as input and returns the longest palindromic substring. If the input is not a string or is an empty string, your function should raise a `ValueError`. # Requirements * Implement the functions as per the provided function prototypes: ```python def is_palindrome(s: str) -> bool: # Your code here def longest_palindromic_substring(s: str) -> str: # Your code here ``` * **Input Constraints**: * `s` is a string consisting of alphanumeric characters. * A valid input `s` consists of at least one character. # Examples The `is_palindrome` function should work as follows: * `is_palindrome(\\"racecar\\")` should return `True`. * `is_palindrome(\\"hello\\")` should return `False`. * `is_palindrome(\\"a\\")` should return `True`. * `is_palindrome(\\"\\")` should raise a `ValueError`. The `longest_palindromic_substring` function should work as follows: * `longest_palindromic_substring(\\"babad\\")` should return `\\"bab\\"` or `\\"aba\\"`. * `longest_palindromic_substring(\\"cbbd\\")` should return `\\"bb\\"`. * `longest_palindromic_substring(\\"a\\")` should return `\\"a\\"`. * `longest_palindromic_substring(\\"\\")` should raise a `ValueError`. # Notes: * Ensure that your code efficiently handles edge cases. * Use appropriate error handling to manage invalid inputs.","solution":"def is_palindrome(s: str) -> bool: if not isinstance(s, str) or s == \\"\\": raise ValueError(\\"Input must be a non-empty string\\") return s == s[::-1] def longest_palindromic_substring(s: str) -> str: if not isinstance(s, str) or s == \\"\\": raise ValueError(\\"Input must be a non-empty string\\") n = len(s) if n == 1: return s start = 0 max_length = 1 table = [[0] * n for _ in range(n)] for i in range(n): table[i][i] = True for i in range(n - 1): if s[i] == s[i + 1]: table[i][i + 1] = True start = i max_length = 2 for k in range(3, n + 1): for i in range(n - k + 1): j = i + k - 1 if table[i + 1][j - 1] and s[i] == s[j]: table[i][j] = True if k > max_length: start = i max_length = k return s[start:start + max_length]"},{"question":"# Context For this assessment, you need to demonstrate your understanding of data structures, specifically stacks, and simulate a scenario using stack operations. The problem addresses basic stack operations, and your solution hinge on effectively managing a stack and ensuring the operations follow the last-in, first-out (LIFO) principle. # Problem Statement Design a function `evaluate_postfix_expression` that evaluates a given postfix expression using a stack. # Function Signature ```python def evaluate_postfix_expression(expression: str) -> int: ``` # Input * A string `expression` containing a postfix expression where: * Operands are single-digit non-negative integers (0-9). * Operators can be `+`, `-`, `*`, or `/`. * All elements in the expression are separated by spaces. # Output * The function returns the integer result of the evaluated postfix expression. # Constraints * The input expression is guaranteed to be a valid postfix expression. * The length of the expression will be between 1 and 100. * Division should use integer division (i.e., use // for Python). * You may not use any built-in evaluation functions such as `eval()`. # Example ```python # Example 1 expr = \\"2 3 1 * + 9 -\\" result = evaluate_postfix_expression(expr) print(result) # Output: -4 # Example 2 expr = \\"4 13 5 / +\\" result = evaluate_postfix_expression(expr) print(result) # Output: 6 # Example 3 expr = \\"10 2 * 3 +\\" result = evaluate_postfix_expression(expr) print(result) # Output: 23 ``` # Hints * Use a stack to manage the operands. * Parse the postfix expression token by token. * When an operator is encountered, pop the required number of operands from the stack, apply the operator, and push the result back onto the stack. * Finally, the stack should contain a single element which is the result of the postfix expression.","solution":"def evaluate_postfix_expression(expression: str) -> int: Evaluates a given postfix expression. :param expression: A string containing the postfix expression. :return: The integer result of the evaluated expression. stack = [] tokens = expression.split() for token in tokens: if token.isdigit(): stack.append(int(token)) else: right = stack.pop() left = stack.pop() if token == \'+\': result = left + right elif token == \'-\': result = left - right elif token == \'*\': result = left * right elif token == \'/\': result = left // right stack.append(result) return stack[0]"},{"question":"# Coding Question Introduction: Hamiltonian paths are paths in a graph that visit each vertex exactly once. These paths are of significant interest in graph theory, especially for solving optimization problems and analyzing network traversals. In this task, you will write a function to determine if a Hamiltonian path exists in a given undirected graph. Task: Write a function `has_hamiltonian_path` that takes an undirected graph represented as an adjacency list and determines whether there exists a Hamiltonian path in the graph. The function should return `True` if such a path exists, and `False` otherwise. Function Signature: ```python def has_hamiltonian_path(graph: dict) -> bool: ``` Input: - `graph`: A dictionary where keys are node labels (strings) and values are lists of neighboring node labels. Output: - A boolean value `True` if there exists a Hamiltonian path in the graph, otherwise `False`. Constraints: - The number of nodes in the graph will not exceed 10. - Ensure the function can handle edge cases, such as graphs with disconnected components or isolated nodes. Example: ```python # Example call graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'C\', \'D\'], \'C\': [\'A\', \'B\', \'D\'], \'D\': [\'B\', \'C\'] } result = has_hamiltonian_path(graph) # Example output # True ``` Notes: 1. Ensure your function efficiently explores possible paths without redundant computations. 2. Handle graphs with disconnected components by appropriately returning `False`. 3. You may assume that the input graph is undirected and contains no self-loops or multiple edges. 4. You can use recursive backtracking to explore potential Hamiltonian paths.","solution":"def has_hamiltonian_path(graph: dict) -> bool: def backtrack(current, visited): # If all nodes are visited, return True if len(visited) == len(graph): return True for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) if backtrack(neighbor, visited): return True visited.remove(neighbor) return False # Try to start a Hamiltonian path from each node for node in graph: if backtrack(node, {node}): return True return False"},{"question":"# Graph Shortest Path Calculation You are tasked with developing an algorithm to calculate the shortest path between two nodes in an undirected, weighted graph. Your solution should be capable of handling various edge cases, such as graphs with cycles and disconnected components. # Requirements: 1. **Graph Representation**: - Implement the graph using an adjacency list representation. - Ensure support for both integer weights and negative weights (without introducing negative cycles). 2. **Handling Special Cases**: - Update the algorithm to manage disconnected nodes. If no path exists between the source and target nodes, return an appropriate message. - Integrate functionality to detect and handle small graphs consisting of one or no edges. 3. **Shortest Path Calculation**: - Use a well-known algorithm such as Dijkstra\'s or Bellman-Ford to determine the shortest path from the source node to all other nodes. - Provide a facility to retrieve the shortest path length and the actual path taken. 4. **Performance Optimization**: - Optimize the algorithm for both time and space complexity. Ensure it operates efficiently on graphs with up to 1000 nodes and edges. 5. **Robust Testing**: - Conduct thorough testing, using various datasets to demonstrate the correctness and efficiency of your implementation. 6. **Documentation**: - Clearly document your code with comments explaining each function and the overall logic. # Specification: - Input: List of tuples representing edges (node1, node2, weight), source node, and target node. - Output: Shortest path length and the path, or a message indicating no path exists. - Constraints: - Nodes are non-negative integers. - Weights of edges are integers; can be negative but don’t lead to negative cycles. - Graph follows zero-based indexing for node representation. # Deliverables: - The complete implementation in Python. - Demonstration of the shortest path calculation using a sample graph. - A brief report summarizing the algorithm used, any enhancements made, and the test results. ```python class Graph: def __init__(self): self.graph = {} def add_edge(self, u, v, weight): if u not in self.graph: self.graph[u] = [] if v not in self.graph: self.graph[v] = [] self.graph[u].append((v, weight)) self.graph[v].append((u, weight)) def shortest_path(self, src, tgt): # Implement the Dijkstra\'s or Bellman-Ford algorithm to find the shortest # path from src to tgt. Ensure to handle all edge cases mentioned. pass def print_path(self, path): # Helper function to print the path neatly pass def test_graph(self): # Function to test the implementation on various edge cases pass if __name__ == \\"__main__\\": # Example to demonstrate the shortest path calculation g = Graph() edges = [(0, 1, 4), (0, 2, 1), (1, 2, 2), (2, 3, 5), (1, 3, 1)] for u, v, w in edges: g.add_edge(u, v, w) src, tgt = 0, 3 path_length, path = g.shortest_path(src, tgt) if path: print(f\\"Shortest path from {src} to {tgt} is {path_length} with path: {path}\\") else: print(f\\"No path exists between {src} and {tgt}\\") ``` By formulating this question, you will challenge candidates to demonstrate their understanding of graph algorithms, their ability to manage edge cases, and their competency in optimizing code for performance. The question also ensures relevance by including robust testing and documentation requirements.","solution":"import heapq class Graph: def __init__(self): self.graph = {} def add_edge(self, u, v, weight): if u not in self.graph: self.graph[u] = [] if v not in self.graph: self.graph[v] = [] self.graph[u].append((v, weight)) self.graph[v].append((u, weight)) def dijkstra(self, src, tgt): pq = [(0, src, [])] # Priority queue: (cost, current_node, path_taken) visited = set() heapq.heapify(pq) while pq: (cost, current_node, path) = heapq.heappop(pq) if current_node in visited: continue path = path + [current_node] visited.add(current_node) if current_node == tgt: return (cost, path) for neighbor, weight in self.graph.get(current_node, []): if neighbor not in visited: heapq.heappush(pq, (cost + weight, neighbor, path)) return (float(\\"inf\\"), None) def shortest_path(self, src, tgt): if src not in self.graph or tgt not in self.graph: return (float(\\"inf\\"), None) return self.dijkstra(src, tgt)"},{"question":"# Coding Assessment Question Context: You need to write a function that determines the minimum number of moves required to transform a given string into a target string. A move is defined as either an insertion, deletion, or substitution of a single character. This problem is a variation of the well-known \\"edit distance\\" problem. Task: Implement a function `min_transformations(source: str, target: str) -> int` that takes two strings, `source` and `target`, and returns the minimum number of moves required to transform the `source` string into the `target` string. Input: - `source` (1 <= len(source) <= 1000) - `target` (1 <= len(target) <= 1000) Output: - An integer representing the minimum number of moves to transform the `source` string into the `target` string. Function Signature: ```python def min_transformations(source: str, target: str) -> int: pass ``` Example: ```python assert min_transformations(\\"kitten\\", \\"sitting\\") == 3 assert min_transformations(\\"flaw\\", \\"lawn\\") == 2 ``` Constraints: - Ensure efficient use of resources, aiming for a time complexity of O(m*n) where m is the length of `source` and n is the length of `target`. - Focus on space optimization, potentially using an O(min(m, n)) space solution. Notes: - Consider edge cases such as empty strings or strings that are already identical. - Ensure the function handles common substring scenarios efficiently to minimize computation efforts.","solution":"def min_transformations(source: str, target: str) -> int: Returns the minimum number of moves required to transform the source string into the target string using insertions, deletions, or substitutions. m, n = len(source), len(target) # Create a table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If source is empty, insert all target characters elif j == 0: dp[i][j] = i # If target is empty, remove all source characters elif source[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If last characters are the same, ignore them and recurse for the remaining else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"Binary Search Tree (BST) - Height Calculation You are provided with a class definition for a binary search tree (BST) which includes several methods such as `insert`, `delete`, and `find`. Your task is to implement a new method `height` for the `BST` class, which computes and returns the maximum height of the binary search tree. The height of a binary tree is the number of edges on the longest path from the root node to a leaf node. Requirements: 1. **Input**: The `height` method should take no input parameters (other than `self` for the class method). 2. **Output**: The method should return an integer representing the height of the BST. 3. **Performance Constraints**: The method should ideally run in O(n) time complexity, where n is the number of nodes in the tree. 4. **Corner Cases**: Handle edge cases where the BST is empty (should return -1) or has a single node (should return 0). Function Signature: ```python def height(self) -> int ``` Example: ```python # Example 1 bst = make_bst([10, 5, 15, 2, 7, 12, 20]) assert bst.height() == 2 # height of the BST # Example 2 bst = make_bst([10]) assert bst.height() == 0 # single node tree # Example 3 bst = make_bst([]) assert bst.height() == -1 # empty tree ``` **Note**: Make sure you thoroughly test your implementation with various edge cases to ensure its robustness.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.value = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.value: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def height(self): def _height(node): if node is None: return -1 else: return 1 + max(_height(node.left), _height(node.right)) return _height(self.root) # Helper function to create a BST from a list of keys def make_bst(keys): bst = BST() for key in keys: bst.insert(key) return bst"},{"question":"# Question: Sum of Unique Elements You are tasked with implementing functions to identify and sum unique elements present in a list. Unique elements are defined as those that appear exactly once in the input list. Implement the Following Functions: **1. Function `find_unique_elements(values: list) -> list`:** * **Input**: A list of integers. * **Output**: A list of integers containing elements that appear exactly once in the input list. * **Constraints**: * Raise a `ValueError` for invalid input (e.g., non-integer elements, empty list, or non-list input). **2. Function `sum_of_unique_elements(values: list) -> int`:** * **Input**: A list of integers. * **Output**: An integer representing the sum of elements that appear exactly once in the input list. * **Constraints**: * Raise a `ValueError` for invalid input (e.g., non-integer elements, empty list, or non-list input). Example ```python >>> find_unique_elements([1, 2, 2, 3, 4, 4, 5]) [1, 3, 5] >>> find_unique_elements([7, 8, 9]) [7, 8, 9] >>> find_unique_elements([6, 6, 6]) [] >>> find_unique_elements([0]) [0] >>> find_unique_elements([-1, -1, 0, 2, 3, 2]) [0, 3] >>> sum_of_unique_elements([1, 2, 2, 3, 4, 4, 5]) 9 >>> sum_of_unique_elements([7, 8, 9]) 24 >>> sum_of_unique_elements([6, 6, 6]) 0 >>> sum_of_unique_elements([0]) 0 >>> sum_of_unique_elements([-1, -1, 0, 2, 3, 2]) 3 ``` Notes: * Consider edge cases, such as improper list input and lists with only duplicate elements. * A list with no unique elements should return an empty list from `find_unique_elements` and zero from `sum_of_unique_elements`. Performance Requirements * Your implementations should be O(n) in time complexity and use O(n) in space complexity where `n` is the number of elements in the input list. **Good Luck!**","solution":"from collections import Counter def find_unique_elements(values): if not isinstance(values, list) or any(not isinstance(x, int) for x in values): raise ValueError(\\"Input must be a list of integers.\\") if not values: raise ValueError(\\"Input list must not be empty.\\") counter = Counter(values) unique_elements = [x for x in values if counter[x] == 1] return unique_elements def sum_of_unique_elements(values): if not isinstance(values, list) or any(not isinstance(x, int) for x in values): raise ValueError(\\"Input must be a list of integers.\\") if not values: raise ValueError(\\"Input list must not be empty.\\") unique_elements = find_unique_elements(values) return sum(unique_elements)"},{"question":"# Longest Subarray with Maximum Sum Given an array of integers `numbers`, write a function `longest_subarray_with_max_sum` that returns the length of the longest contiguous subarray that has the maximum sum of all possible subarrays. If there are multiple subarrays with the same maximum sum, return the length of the longest one among them. # Function Signature ```python def longest_subarray_with_max_sum(numbers: list[int]) -> int: pass ``` # Input * `numbers` (list[int]): A list of integers. # Output * Return an integer representing the length of the longest contiguous subarray with the maximum sum. # Constraints * The list can contain both positive and negative integers. * The list can be empty. * The list can have up to 10^6 elements. # Examples ```python assert longest_subarray_with_max_sum([1, -2, 3, 4, -1, 2, 1, -5, 4]) == 5 # The subarray is [3, 4, -1, 2, 1] assert longest_subarray_with_max_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 4 # The subarray is [4, -1, -2, 1, 5] assert longest_subarray_with_max_sum([1, 2, 3, 4, 5]) == 5 # The subarray is the entire array [1, 2, 3, 4, 5] assert longest_subarray_with_max_sum([-1, -2, -3, -4]) == 1 # The subarray is any single element, max is [-1] assert longest_subarray_with_max_sum([5, 4, -1, 7, 8]) == 5 # The subarray is the entire array [5, 4, -1, 7, 8] ``` # Constraints * The function should handle edge cases like: * Empty list * All negative numbers * Single-element arrays * Large datasets with both positive and negative numbers * Ensure the function is optimized to handle lists with large numbers of elements efficiently.","solution":"def longest_subarray_with_max_sum(numbers: list[int]) -> int: Returns the length of the longest contiguous subarray with the maximum sum in the given list of numbers. if not numbers: return 0 max_sum = cur_sum = numbers[0] max_length = cur_length = 1 for num in numbers[1:]: if cur_sum + num > num: cur_sum += num cur_length += 1 else: cur_sum = num cur_length = 1 if cur_sum > max_sum: max_sum = cur_sum max_length = cur_length elif cur_sum == max_sum: max_length = max(max_length, cur_length) return max_length"},{"question":"# Coding Assessment Question Scenario You are tasked with developing a function to optimize the performance of operating systems. One of the recurring tasks is to determine the shortest path between two points in a network. You have a list of direct connections between the points and the cost associated with each connection. Your goal is to compute the minimum cost to travel from a starting point to a destination. Task Write a function named `shortest_path` that takes three arguments: 1. A list of tuples `connections`, where each tuple contains three elements: `(start, end, cost)`. It represents a direct connection from `start` to `end` with a travel cost of `cost`. 2. A string `start_point` representing the starting point. 3. A string `end_point` representing the destination point. The function should return the minimum cost to travel from `start_point` to `end_point`. If there is no viable path from `start_point` to `end_point`, return `-1`. Input * `connections`: A list of tuples where each tuple consists of `(start: str, end: str, cost: int)`. * `start_point`: A string representing the starting point in the network. * `end_point`: A string representing the destination point in the network. Output * An integer representing the minimum travel cost from `start_point` to `end_point`, or `-1` if no path exists. Constraints * You may assume that all input strings representing points are non-empty and only contain alphanumeric characters. * Costs are non-negative integers. * The list `connections` contains at least one connection. Function Signature ```python def shortest_path(connections: list[tuple[str, str, int]], start_point: str, end_point: str) -> int: ``` # Example ```python assert shortest_path([(\'A\', \'B\', 1), (\'B\', \'C\', 2), (\'A\', \'C\', 4)], \'A\', \'C\') == 3 assert shortest_path([(\'A\', \'B\', 1), (\'B\', \'C\', 2), (\'C\', \'D\', 1), (\'B\', \'E\', 5)], \'A\', \'E\') == 6 assert shortest_path([(\'X\', \'Y\', 10), (\'Y\', \'Z\', 20)], \'X\', \'Z\') == 30 assert shortest_path([(\'M\', \'N\', 5), (\'O\', \'P\', 10)], \'M\', \'P\') == -1 assert shortest_path([], \'A\', \'B\') == -1 ``` Explanation - In the first example, the path `A -> B -> C` yields a total cost of `1 + 2 = 3`, which is less than the direct path `A -> C` with a cost of 4. - In the second example, the path `A -> B -> C -> D -> E` is not less costly than `A -> B -> E`, which costs `1 + 5 = 6`. - In the third example, the cumulative cost from `X -> Y -> Z` is `10 + 20 = 30`. - In the fourth example, since there is no path from `M` to `P`, the function returns `-1`. - In the fifth example, with no connections provided, no path exists, so the function returns `-1`. Notes - Implement efficient graph traversal algorithms such as Dijkstra\'s algorithm to handle large input data. - Consider all possible edge cases, such as disconnected graphs and zero-cost routes.","solution":"import heapq from collections import defaultdict def shortest_path(connections, start_point, end_point): def dijkstra(graph, start): heap = [(0, start)] visited = set() min_cost = {start: 0} while heap: cost, node = heapq.heappop(heap) if node in visited: continue visited.add(node) for neighbor, weight in graph[node]: if neighbor not in visited: new_cost = cost + weight if new_cost < min_cost.get(neighbor, float(\'inf\')): min_cost[neighbor] = new_cost heapq.heappush(heap, (new_cost, neighbor)) return min_cost # Create graph graph = defaultdict(list) for start, end, cost in connections: graph[start].append((end, cost)) # Calculate shortest path from start_point min_cost_from_start = dijkstra(graph, start_point) # Return the cost to end_point return min_cost_from_start.get(end_point, -1)"},{"question":"# Question: Employee Productivity Tracker In a company, employees work on multiple projects, and each project has a certain number of tasks to complete. Your task is to implement a function that calculates the total number of tasks completed by each employee. You are given a dictionary where keys are employee names, and values are lists of tuples. Each tuple contains the project name and the number of tasks completed by the employee in that project. Your task is to implement the function `calculate_productivity` that returns a dictionary with employee names as keys and the total number of tasks completed as values. Function Signature ```python def calculate_productivity(employee_projects: dict) -> dict: Args: employee_projects (dict): A dictionary where keys are employee names (strings), and values are lists of tuples (project name, tasks completed). Returns: dict: A dictionary with employee names as keys and the total number of tasks completed as values. ``` Example ```python employee_data = { \\"Alice\\": [(\\"Project1\\", 5), (\\"Project2\\", 3)], \\"Bob\\": [(\\"Project2\\", 6), (\\"Project3\\", 2)], \\"Charlie\\": [(\\"Project1\\", 7), (\\"Project3\\", 4)] } print(calculate_productivity(employee_data)) # Output: {\'Alice\': 8, \'Bob\': 8, \'Charlie\': 11} ``` Constraints - The dictionary keys (employee names) are non-empty strings. - Each list of tuples represents different projects and their associated completed tasks for that employee. - The number of tasks completed is a non-negative integer. - Each employee-name key in the input dictionary will have a list of tuples with at least one project-task pair. - Handle edge cases where an employee might not be working on any projects (an empty list).","solution":"def calculate_productivity(employee_projects): Calculates the total number of tasks completed by each employee. Args: employee_projects (dict): A dictionary where keys are employee names (strings), and values are lists of tuples (project name, tasks completed). Returns: dict: A dictionary with employee names as keys and the total number of tasks completed as values. productivity = {} for employee, projects in employee_projects.items(): total_tasks = sum(tasks for project, tasks in projects) productivity[employee] = total_tasks return productivity"},{"question":"# Palindromic Substring Checker Context In string manipulation and related algorithms, checking for palindromic properties is a common task. A substring is considered palindromic if it reads the same forward and backward. This problem requires checking if a given substring within a string is palindromic. Problem Statement Implement a Python function `is_palindromic_substring(s: str, start: int, end: int) -> bool` that determines if the specified substring of `s` (from `start` to `end` inclusive) is a palindrome. Function Signature: ```python def is_palindromic_substring(s: str, start: int, end: int) -> bool: pass ``` Input: - `s` (string): The original string within which the palindrome check will be performed. - `start` (integer): The starting index of the substring (0 ≤ start ≤ end < len(s)). - `end` (integer): The ending index of the substring. Output: - A boolean value indicating whether the specified substring is palindromic. Constraints: - The input string `s` will have a length between 1 and 10^4. - The `start` and `end` indices will define a valid substring within `s`. Performance Requirements: - The solution should efficiently check the palindromic nature of the substring. Examples: ```python >>> is_palindromic_substring(\\"racecar\\", 0, 6) True >>> is_palindromic_substring(\\"hello\\", 1, 3) False >>> is_palindromic_substring(\\"level\\", 0, 4) True >>> is_palindromic_substring(\\"algorithm\\", 3, 5) False ``` Use the provided test cases to validate your solution.","solution":"def is_palindromic_substring(s: str, start: int, end: int) -> bool: Determines if the specified substring of s (from start to end inclusive) is a palindrome. Parameters: - s: str -> The original string. - start: int -> The starting index of the substring. - end: int -> The ending index of the substring. Returns: - bool: True if the substring is palindromic, False otherwise. substring = s[start:end+1] return substring == substring[::-1]"},{"question":"# Coding Assessment Question: Implementing a Multi-Class Perceptron Context You are developing a machine learning model that can classify data points into multiple classes. One approach is to use a multi-class perceptron, which can be trained using the perceptron learning algorithm. This model will adjust its weights iteratively based on the training data and the prediction errors to improve its accuracy. Task Write a function that trains a multi-class perceptron and returns the final weights after a defined number of epochs, and the predicted class for a test sample. Function Signature ```python def train_multiclass_perceptron(training_samples: list[list[int]], training_labels: list[int], num_classes: int, epochs: int, alpha: float, test_sample: list[int]) -> tuple[list[list[float]], int]: ``` Input Format * `training_samples`: A 2D list of integers where each inner list represents a training sample with `n` features. * `training_labels`: A list of integers where each integer represents the class label for the corresponding training sample. * `num_classes`: An integer representing the number of unique classes in the training set. * `epochs`: An integer representing the number of training iterations. * `alpha`: A float representing the learning rate for updating the weights. * `test_sample`: A list of integers representing the sample to be classified. Output Format * The function returns a tuple: * The first element is a 2D list of floats representing the final trained weights, where each inner list corresponds to the weights for a particular class. * The second element is an integer representing the predicted class index for the test sample. Constraints * You can assume the weights and samples are of compatible dimensions for vector operations. * The number of epochs (`epochs`) will be a positive integer. * The learning rate (`alpha`) will be a small positive float (typically between 0.01 and 0.1). * `training_labels` will be integers ranging from 0 to `num_classes`-1. Example ```python training_samples = [[1, 1, 0, 0], [0, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]] training_labels = [0, 1, 0, 1] num_classes = 2 epochs = 5 alpha = 0.1 test_sample = [0, 1, 0, 1] final_weights, predicted_class = train_multiclass_perceptron(training_samples, training_labels, num_classes, epochs, alpha, test_sample) print(f\\"Final weights: {final_weights}\\") print(f\\"Predicted class for the test sample: {predicted_class}\\") ``` **Note:** Ensure your implementation handles edge cases, such as ties in classification and appropriate weight updates for convergence.","solution":"def train_multiclass_perceptron(training_samples, training_labels, num_classes, epochs, alpha, test_sample): # Initialize weights for all classes with zeros num_features = len(training_samples[0]) weights = [[0.0 for _ in range(num_features)] for _ in range(num_classes)] for epoch in range(epochs): for sample, label in zip(training_samples, training_labels): # Calculate the net input for each class net_inputs = [sum(w * x for w, x in zip(class_weights, sample)) for class_weights in weights] # Predict the class with the highest net input predicted_class = net_inputs.index(max(net_inputs)) if predicted_class != label: # Update weights for the wrong class weights[predicted_class] = [w - alpha * x for w, x in zip(weights[predicted_class], sample)] # Update weights for the correct class weights[label] = [w + alpha * x for w, x in zip(weights[label], sample)] # Predict the class for the test sample net_inputs = [sum(w * x for w, x in zip(class_weights, test_sample)) for class_weights in weights] predicted_class = net_inputs.index(max(net_inputs)) return weights, predicted_class"},{"question":"# Coding Assessment Question: Permutations with Constraints Problem Statement You are tasked with generating all possible permutations of a given string with a constraint. The constraint ensures that no two adjacent characters in any permutation are the same. If it is impossible to generate such a permutation, return an empty list. # Requirements 1. **Function Signature**: Write a function `constrained_permutations(s: str) -> List[str]` in Python. 2. **Input**: * A string (`s`) of length ranging from **1 to 10**. 3. **Output**: * A list of all possible permutations of the input string where no two adjacent characters are the same. 4. **Constraints**: * Each permutation in the output list must contain all the characters of the input string exactly once. # Steps to Implement 1. **Generate all Permutations**: * Use a method to generate all permutations of the given input string `s`. 2. **Filter Valid Permutations**: * Check each permutation to ensure that no two adjacent characters are the same. * If a valid permutation is found, add it to the result list. # Example ```python def constrained_permutations(s: str) -> List[str]: # Implement the required algorithm here pass # Example Usage print(constrained_permutations(\\"aab\\")) # Output: [\\"aba\\"] print(constrained_permutations(\\"aa\\")) # Output: [] print(constrained_permutations(\\"abc\\")) # Output: [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] ``` # Performance Requirements: * Given the relatively small input size (up to length 10), ensure the solution is efficient in generating and validating permutations. * Aim for a function with reasonable run-time performance for the given constraints. # Additional Notes: * Consider edge cases, such as strings with all identical characters, which might not have any valid permutations. * Utilize Python’s built-in `itertools.permutations` function effectively and ensure to handle string and array manipulations carefully to meet the constraints.","solution":"from itertools import permutations from typing import List def constrained_permutations(s: str) -> List[str]: results = [] perms = permutations(s) for perm in set(perms): # Use set to avoid duplicate permutations valid = True for i in range(len(perm) - 1): if perm[i] == perm[i+1]: valid = False break if valid: results.append(\'\'.join(perm)) return results"},{"question":"# Question: Implement a Simple Graph Data Structure with DFS Traversal You are required to implement a Python class that models a simple, undirected graph. The class should support adding nodes, adding edges, and performing a depth-first traversal (DFS) starting from a given node. Requirements: 1. Implement a class named `Graph`. 2. Add an `__init__` method to initialize the graph storage. 3. Implement a method `add_node(node: int) -> None` that adds a node to the graph. 4. Implement a method `add_edge(node1: int, node2: int) -> None` that adds an undirected edge between two nodes in the graph. 5. Implement a method `dfs(start_node: int) -> List[int]` that performs a DFS traversal starting from the provided node and returns the list of nodes in the order they were visited. 6. Handle edge cases gracefully (e.g., attempting to perform DFS from a non-existent node should raise a ValueError). Input: * The various methods of the `Graph` class. Output: * The output varies based on the method: - `add_node(node: int) -> None` does not return anything. - `add_edge(node1: int, node2: int) -> None` does not return anything. - `dfs(start_node: int) -> List[int]` returns a list of integers representing the nodes visited during the DFS traversal. Constraints: * The graph can contain up to 1000 nodes. * Nodes are represented by integer values. * Optimize for clear, correct, and maintainable code. Example: ```python >>> graph = Graph() >>> graph.add_node(1) >>> graph.add_node(2) >>> graph.add_node(3) >>> graph.add_edge(1, 2) >>> graph.add_edge(1, 3) >>> graph.dfs(1) [1, 2, 3] >>> graph.dfs(2) [2, 1, 3] >>> graph.dfs(4) Traceback (most recent call last): ... ValueError: Start node does not exist in the graph ``` Your implementation should demonstrate the correct functionality of a graph data structure and a depth-first traversal that adheres to the constraints specified.","solution":"from typing import List, Dict, Set class Graph: def __init__(self): self.graph: Dict[int, Set[int]] = {} def add_node(self, node: int) -> None: if node not in self.graph: self.graph[node] = set() def add_edge(self, node1: int, node2: int) -> None: if node1 not in self.graph or node2 not in self.graph: raise ValueError(\\"Both nodes must exist in the graph\\") self.graph[node1].add(node2) self.graph[node2].add(node1) def dfs(self, start_node: int) -> List[int]: if start_node not in self.graph: raise ValueError(\\"Start node does not exist in the graph\\") visited = set() result = [] self._dfs_helper(start_node, visited, result) return result def _dfs_helper(self, node: int, visited: Set[int], result: List[int]) -> None: visited.add(node) result.append(node) for neighbor in self.graph[node]: if neighbor not in visited: self._dfs_helper(neighbor, visited, result)"},{"question":"# Circular Linked List Cycle Detection Objective: Implement a function that detects if a given circular linked list contains a cycle, where a cycle is defined as a series of nodes that follows a forward direction and returns back to an earlier node. Problem Statement: Write a function `has_cycle(head: Optional[Node]) -> bool` that determines whether the circular linked list starting from `head` contains a cycle. Function Signature: ```python from typing import Optional class Node: def __init__(self, value: int): self.value = value self.next: Optional[Node] = None def has_cycle(head: Optional[Node]) -> bool: pass ``` Inputs: * `head` (Optional[Node]): The head node of the linked list. Output: * `bool`: Returns `True` if the linked list contains a cycle, otherwise returns `False`. Example: ```python # Example to create nodes and form a cycle node1 = Node(1) node2 = Node(2) node3 = Node(3) node4 = Node(4) node5 = Node(5) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 node5.next = node3 # Cycle here print(has_cycle(node1)) # Output: True # Example to create nodes without forming a cycle node1 = Node(1) node2 = Node(2) node3 = Node(3) node4 = Node(4) node5 = Node(5) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 node5.next = None # No cycle here print(has_cycle(node1)) # Output: False ``` Constraints: * The solution should ideally run in O(n) time complexity and O(1) space complexity. * Assume that the list can be empty or can contain any number of nodes, where a node can point to `None` indicating the end of the list.","solution":"from typing import Optional class Node: def __init__(self, value: int): self.value = value self.next: Optional[Node] = None def has_cycle(head: Optional[Node]) -> bool: Function to detect cycle in a linked list. It uses Floyd\'s Tortoise and Hare algorithm. Args: head (Optional[Node]): The head node of the linked list. Returns: bool: True if cycle is detected, False otherwise. if not head or not head.next: return False slow, fast = head, head.next while fast and fast.next: if slow == fast: return True slow = slow.next fast = fast.next.next return False"},{"question":"# Context In competitive programming, it often becomes necessary to evaluate the efficiency of different sorting algorithms under various scenarios. One common scenario involves sorting lists that contain a combination of positive, negative, and zero integers. Sorting such lists efficiently can be crucial for solving time-sensitive problems in competitions. # Task You are required to implement a function that sorts a list of integers containing positive, negative, and zero values. Additionally, you should ensure that the function maintains stability, meaning that two equal elements should retain their original order in the sorted list. # Requirements Write a function `stable_sort(lst: list) -> list` that: 1. Takes in a single list of integers `lst`. 2. Returns a new list where the integers are sorted in non-decreasing order. 3. Ensures the sorting algorithm used maintains stability. **Input Constraints**: - The length of the input list `lst` will be between 0 and 100,000. - The elements in `lst` will be integers within the range of -10^9 to 10^9. **Output Format**: - Return the sorted list. # Examples ```python >>> stable_sort([3, -1, 4, 0, -2, 1]) [-2, -1, 0, 1, 3, 4] >>> stable_sort([1, 1, -1, 0, -1, 2]) [-1, -1, 0, 1, 1, 2] >>> stable_sort([5, -5, 5, -5, 5]) [-5, -5, 5, 5, 5] >>> stable_sort([]) [] ``` # Notes - The given examples show the behavior of maintaining the original order where duplicates and zeroes appear in the sorted output. - Ensure your implementation is efficient and can handle the upper limits of the input constraints effectively. Implement this function considering both stability and performance.","solution":"def stable_sort(lst): Sorts a list of integers containing positive, negative, and zero values in non-decreasing order. Ensures that the sorting algorithm used maintains stability. return sorted(lst)"},{"question":"# Coding Assessment Question Scenario As part of a financial analytics tool, you are tasked with developing a function to calculate the Compound Annual Growth Rate (CAGR) of an investment. The CAGR is a useful measure of growth over multiple time periods. Given the initial value of an investment, its final value, and the number of years, you need to compute and return the CAGR. Task Write a function `calculate_cagr` that computes the CAGR using the formula: [ CAGR = left(frac{FV}{PV}right)^{frac{1}{n}} - 1 ] Where: - ( FV ) is the final value of the investment. - ( PV ) is the initial value of the investment. - ( n ) is the number of years. Requirements 1. If `initial_value` is less than or equal to 0, raise a `ValueError` with the message \\"Initial value should be positive\\". 2. If `final_value` is less than or equal to 0, raise a `ValueError` with the message \\"Final value should be positive\\". 3. If `years` is less than or equal to 0, raise a `ValueError` with the message \\"Number of years should be positive\\". Function Signature ```python def calculate_cagr(initial_value: float, final_value: float, years: float) -> float: pass ``` Inputs - `initial_value` (float): The initial value of the investment. - `final_value` (float): The final value of the investment. - `years` (float): The number of years over which the investment has grown. Output - (float): The computed CAGR. Constraints - All inputs will be float numbers within the range of (1e-6) to (1e12). - The CAGR should be returned as a decimal (e.g., 0.05 for 5%). Example ```python >>> calculate_cagr(initial_value=1000, final_value=2000, years=5) 0.148698354997035 >>> calculate_cagr(initial_value=1500, final_value=3000, years=10) 0.071773462536293 >>> calculate_cagr(initial_value=1000, final_value=2000, years=0) Traceback (most recent call last): ... ValueError: Number of years should be positive ``` Implement this function and ensure it handles all edge cases and constraints as specified.","solution":"def calculate_cagr(initial_value: float, final_value: float, years: float) -> float: if initial_value <= 0: raise ValueError(\\"Initial value should be positive\\") if final_value <= 0: raise ValueError(\\"Final value should be positive\\") if years <= 0: raise ValueError(\\"Number of years should be positive\\") cagr = (final_value / initial_value) ** (1 / years) - 1 return cagr"},{"question":"# Graph Pathfinding Challenge You are given a weighted, directed graph represented as an adjacency list. Your task is to find the shortest path from a given start node to a target node and return the total weight of that path. If there is no such path, return -1. Task: Write a function `shortest_path(graph: dict, start: str, target: str) -> int` that: - Accepts a graph as an adjacency list, a start node, and a target node. - Returns the minimum total weight of the shortest path from the start node to the target node. Inputs: - `graph`: A dictionary where keys are strings representing nodes, and values are lists of tuples representing edges with their weights. - For example, `graph[\'A\'] = [(\'B\', 1), (\'C\', 4)]` means there are edges from node \'A\' to \'B\' with weight 1, and to \'C\' with weight 4. - `start`: A string representing the starting node. - `target`: A string representing the target node. Output: - Return an integer representing the total weight of the shortest path. If no path is found, return -1. Constraints: - The graph will contain at least 1 node and no more than 1000 nodes. - The weight of each edge will be a non-negative integer. - There may be edges with zero weight. Example Scenario: ```python graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'C\', 2), (\'D\', 5)], \'C\': [(\'D\', 1)], \'D\': [] } # The shortest path from \'A\' to \'D\' is: # \'A\' -> \'B\' -> \'C\' -> \'D\' with a total weight of 1 + 2 + 1 = 4 shortest_path(graph, \'A\', \'D\') # should return 4 ``` Ensure to handle edge cases and test your implementation for correctness and efficiency.","solution":"import heapq def shortest_path(graph, start, target): Find the shortest path from start to target using Dijkstra\'s algorithm. :param graph: dict representing the adjacency list of the graph :param start: starting node :param target: target node :return: total weight of the shortest path from start to target or -1 if no path exists if start not in graph or target not in graph: return -1 # Priority queue to store (cost, node) pq = [(0, start)] # Dictionary to store the minimum distance to each node dist = {start: 0} while pq: current_dist, current_node = heapq.heappop(pq) # If we reached the target node, return the distance if current_node == target: return current_dist # If the current distance is greater than the recorded distance, skip processing if current_dist > dist.get(current_node, float(\'inf\')): continue # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_dist + weight # If a shorter path to the neighbor is found if distance < dist.get(neighbor, float(\'inf\')): dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1 # Target not reachable"},{"question":"# Question: Implement Tarjan\'s Algorithm for Finding Bridges in a Graph **Background:** Tarjan\'s Algorithm is used to find all the bridges in a connected undirected graph. A bridge (or cut-edge) is an edge in a graph whose removal increases the number of connected components. **Task:** Implement Tarjan\'s Algorithm in Python to find all the bridges in an undirected graph. **Function Signature:** ```python class Graph: def __init__(self, num_of_nodes: int) -> None: # Initialization function # It should initialize any necessary data structures def add_edge(self, u_node: int, v_node: int) -> None: # Adds an edge to the graph def find_bridges(self) -> list[tuple[int, int]]: # Executes Tarjan\'s Algorithm and returns a list of bridges # Each bridge should be represented as a tuple of two nodes ``` **Expected Input and Output Formats:** - `__init__: Graph(n)`: initializes a graph with `n` nodes. - `add_edge(u_node: int, v_node: int)`: adds an undirected edge between `u_node` and `v_node`. - `find_bridges() -> list[tuple[int, int]]`: returns a list of bridges in the format `(u_node, v_node)`. **Constraints:** 1. The graph will have at least 2 nodes. 2. The number of nodes `n` will be between 2 and 1000. 3. The number of edges `m` will be between 1 and 10000. 4. Nodes are zero-indexed. **Performance Requirements:** The solution should handle graphs up to the given limits efficiently, utilizing O(V + E) time complexity, where `V` is the number of vertices and `E` is the number of edges. **Example:** ```python g = Graph(5) edges = [(0, 1), (0, 2), (1, 2), (1, 3), (3, 4)] for u, v in edges: g.add_edge(u, v) bridges = g.find_bridges() print(bridges) # Expected output: [(3, 4), (1, 3)] ``` Implement the missing methods in the `Graph` class to complete Tarjan\'s Algorithm for finding bridges in a graph. This question is designed to test your understanding of graph theory, depth-first search (DFS), and the use of algorithms to uncover critical components in connected structures.","solution":"class Graph: def __init__(self, num_of_nodes: int) -> None: self.num_of_nodes = num_of_nodes self.adj_list = [[] for _ in range(num_of_nodes)] self.time = 0 def add_edge(self, u_node: int, v_node: int) -> None: self.adj_list[u_node].append(v_node) self.adj_list[v_node].append(u_node) def find_bridges(self) -> list[tuple[int, int]]: self.visited = [False] * self.num_of_nodes self.disc = [float(\'inf\')] * self.num_of_nodes self.low = [float(\'inf\')] * self.num_of_nodes self.parent = [-1] * self.num_of_nodes self.bridges = [] for i in range(self.num_of_nodes): if not self.visited[i]: self.dfs(i) return self.bridges def dfs(self, u: int) -> None: self.visited[u] = True self.disc[u] = self.low[u] = self.time self.time += 1 for v in self.adj_list[u]: if not self.visited[v]: self.parent[v] = u self.dfs(v) self.low[u] = min(self.low[u], self.low[v]) if self.low[v] > self.disc[u]: self.bridges.append((u, v)) elif v != self.parent[u]: self.low[u] = min(self.low[u], self.disc[v])"},{"question":"# Finding the Most Frequent Element in a List You have been provided with a list of integers, and your task is to write a function that finds the most frequent element in the list. If two or more elements have the same highest frequency, return the smallest one. **Task Description**: * Write a Python function named `find_most_frequent` that takes a list of integers and returns the most frequent element. **Function Signature**: ```python def find_most_frequent(numbers: list[int]) -> int: pass ``` **Input**: * `numbers` (list[int]): A list of integers. The list may be empty. **Output**: * Returns an integer representing the most frequent element in the list. If the list is empty, return `None`. **Exceptions**: * If `numbers` is not a list, raise a `TypeError` with the message \\"The input should be a list of integers\\". * If any element in `numbers` is not an integer, raise a `TypeError` with the message \\"All elements in the input list should be integers\\". **Edge Cases**: * If the list contains multiple elements with the same highest frequency, return the smallest one. * If the list is empty, the function should return `None`. **Example**: ```python # Example case 1 print(find_most_frequent([1, 3, 1, 3, 2, 1])) # Output: 1, as \'1\' appears 3 times and \'3\' appears 2 times # Example case 2 print(find_most_frequent([3, 1, 3, 3, 2, 1])) # Output: 3, as \'3\' appears 3 times # Example case 3 print(find_most_frequent([1, 2, 2, 3, 3])) # Output: 2, as \'2\' and \'3\' both appear 2 times but \'2\' is smaller # Example case 4 print(find_most_frequent([])) # Output: None, as the list is empty # Error cases print(find_most_frequent(1)) # Output: TypeError: The input should be a list of integers print(find_most_frequent([1, \'a\', 3])) # Output: TypeError: All elements in the input list should be integers ``` Remember to include test cases to verify the correctness of your implementation.","solution":"from collections import Counter from typing import List, Optional def find_most_frequent(numbers: List[int]) -> Optional[int]: Finds the most frequent element in the list of integers. :param numbers: List of integers :return: The most frequent integer, or None if the list is empty if not isinstance(numbers, list): raise TypeError(\\"The input should be a list of integers\\") if not all(isinstance(n, int) for n in numbers): raise TypeError(\\"All elements in the input list should be integers\\") if not numbers: return None count = Counter(numbers) most_common = count.most_common() most_frequent = min([num for num, freq in most_common if freq == most_common[0][1]]) return most_frequent"},{"question":"# Problem Description Write a Python function that validates and calculates the area of a triangle given the lengths of its three sides. The function should handle invalid inputs and provide error messages if the input does not form a valid triangle. # Function to Implement Write a Python function `triangle_area(a: float, b: float, c: float) -> str:` that: 1. Ensures the input values are valid: * All sides must be positive numbers. * The sum of any two sides must be greater than the third side (triangle inequality). 2. If the input values are invalid: * Return a specific string message describing the error. 3. If the inputs are valid: * Compute the area using Heron\'s formula. * Return a formatted string with the computed area up to two decimal places. # Heron\'s Formula Given the sides of a triangle (a), (b), and (c): 1. Calculate the semi-perimeter (s = frac{a + b + c}{2}). 2. Compute the area (A) as: [A = sqrt{s(s-a)(s-b)(s-c)}] # Example ```python def triangle_area(a: float, b: float, c: float) -> str: # Your implementation here # Example Usage print(triangle_area(3, 4, 5)) # Expected: \\"The area of the triangle is 6.00\\" print(triangle_area(1, 1, 3)) # Expected: \\"Error: The given sides do not form a valid triangle\\" print(triangle_area(-3, 4, 5)) # Expected: \\"Error: All sides must be positive numbers\\" ``` # Input * `a` (float): The length of the first side of the triangle, should be a positive number. * `b` (float): The length of the second side of the triangle, should be a positive number. * `c` (float): The length of the third side of the triangle, should be a positive number. # Output * If the input is invalid, the function should return a string in one of the following formats: * \\"Error: All sides must be positive numbers\\" * \\"Error: The given sides do not form a valid triangle\\" * If the input is valid, the function should return: * \\"The area of the triangle is X.XX\\", where `X.XX` is the area rounded to two decimal places. # Constraints * Use the value of ( sqrt{} ) from the math module. * Edge cases as mentioned need to be considered. * The function should be efficient and handle the input validation and calculation in (O(1)) time.","solution":"import math def triangle_area(a: float, b: float, c: float) -> str: # Validate that all sides are positive numbers if a <= 0 or b <= 0 or c <= 0: return \\"Error: All sides must be positive numbers\\" # Validate triangle inequality if a + b <= c or a + c <= b or b + c <= a: return \\"Error: The given sides do not form a valid triangle\\" # Calculate semi-perimeter s = (a + b + c) / 2 # Calculate area using Heron\'s formula area = math.sqrt(s * (s - a) * (s - b) * (s - c)) # Return area formatted to two decimal places return f\\"The area of the triangle is {area:.2f}\\""},{"question":"# Sort Even and Odd Integers Separately You need to implement a function that takes a list of integers and returns a new list where all even integers appear first, followed by all odd integers. Each subgroup (even and odd) should be sorted in non-decreasing order. The function should take the following input: - `numbers` (List[int]): A list of integers. Your implementation should: 1. Separate the even and odd integers from the input list. 2. Sort the even integers in non-decreasing order. 3. Sort the odd integers in non-decreasing order. 4. Concatenate the sorted even and odd integers, with even integers appearing first. # Function Signature ```python def sort_even_odd(numbers: List[int]) -> List[int]: pass ``` # Input * numbers (List[int]): A list of integers. # Output * List[int]: A new list where even integers come first, sorted in non-decreasing order, followed by odd integers, also sorted in non-decreasing order. # Example ```python # Example usage sort_even_odd([4, 3, 7, 8, 2, 5, 1, 6]) # Output: [2, 4, 6, 8, 1, 3, 5, 7] sort_even_odd([15, 14, 13, 12, 11, 10]) # Output: [10, 12, 14, 11, 13, 15] ``` # Constraints * The input list size will be within the range 1 to 10^4. * The input integers will be within the range -10^6 to 10^6. # Hints - Use Python\'s list comprehensions to filter even and odd integers. - Utilize Python\'s built-in sorting functions for efficiency. - Ensure to handle edge cases such as empty list inputs or lists with only even or only odd integers.","solution":"from typing import List def sort_even_odd(numbers: List[int]) -> List[int]: Returns a new list with all even integers appearing first, followed by all odd integers, with each group sorted in non-decreasing order. even_numbers = sorted([num for num in numbers if num % 2 == 0]) odd_numbers = sorted([num for num in numbers if num % 2 != 0]) return even_numbers + odd_numbers"},{"question":"# Question: Pascal\'s Triangle Row Generator You are given a positive integer `row_index` representing the index of a row in Pascal\'s Triangle. Your task is to implement a function `generate_pascals_triangle_row(row_index: int) -> List[int]` which generates the specific row in Pascal\'s Triangle using the formula for binomial coefficients ( C(n, k) = frac{n!}{k!(n-k)!} ). Function Signature ```python def generate_pascals_triangle_row(row_index: int) -> List[int]: pass ``` Input * A single integer `row_index` where `0 <= row_index < 34`. Output * A list of integers representing the `row_index-th` row of Pascal\'s Triangle. Constraints * The input `row_index` will always be a non-negative integer within the range specified. * The function should raise a `ValueError` if the input is not a non-negative integer or raise a `TypeError` if the input is not an integer. Example ```python >>> generate_pascals_triangle_row(0) [1] >>> generate_pascals_triangle_row(3) [1, 3, 3, 1] >>> generate_pascals_triangle_row(5) [1, 5, 10, 10, 5, 1] >>> generate_pascals_triangle_row(-1) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer >>> generate_pascals_triangle_row(2.5) Traceback (most recent call last): ... TypeError: Input value of [number=2.5] must be an integer ``` # Scenario You are developing a mathematics learning application that helps students visualize and understand Pascal\'s Triangle. By providing a row index, the application displays the specific row from Pascal\'s Triangle. Your task is to accurately implement the function that calculates any given row to enhance these educational experiences. Implement the function with careful consideration for constraints, edge cases, and the requirements provided.","solution":"from math import comb from typing import List def generate_pascals_triangle_row(row_index: int) -> List[int]: if not isinstance(row_index, int): raise TypeError(f\\"Input value of [number={row_index}] must be an integer\\") if row_index < 0: raise ValueError(\\"Input must be a non-negative integer\\") return [comb(row_index, k) for k in range(row_index + 1)]"},{"question":"# Problem Statement You are given a list of `n` integers in a specific format and asked to determine certain properties of the segment sums within the list. The integers follow a pattern such that every integer in the list is either positive or negative and has the property that any contiguous subarray of length `k` has a sum that is inherently positive. Write a function `validSegmentSums(nums: List[int], k: int) -> bool` that checks if the provided list `nums` of integers obeys the segment sum rule and returns `True` if every contiguous subarray of length `k` produces a positive sum, otherwise returns `False`. # Input Format - A list `nums` containing `n` integers (`1 ≤ n ≤ 10^5`). - An integer `k` representing the length of contiguous subarrays to check (`1 ≤ k ≤ n`). # Output Format - A boolean value: `True` if every contiguous subarray of length `k` has a positive sum, otherwise `False`. # Example ```python >>> validSegmentSums([3, -1, 2, 1, 4], 2) True >>> validSegmentSums([3, -1, -2, 1, 4], 2) False >>> validSegmentSums([1, 2, 3, -2, 5], 3) True ``` # Constraints - The function should efficiently handle lists with up to 100,000 elements. - Optimal solutions should consider appropriate data structures to manage the sliding window of sums. # Guidelines - Utilize sliding window techniques to maintain and update the sum of each segment of length `k`. - Avoid recomputation of the entire sum for each segment to achieve optimal performance. - Iterate through `nums` and update the segment sums using addition and subtraction as necessary.","solution":"def validSegmentSums(nums, k): Check if every contiguous subarray of length k has a positive sum. Args: nums: List[int] - A list of integers. k: int - Length of the contiguous subarrays to check. Returns: bool - True if all contiguous subarrays of length k have a positive sum, otherwise False. # Calculate the sum of the first window of size k window_sum = sum(nums[:k]) # If the sum of the first window is not positive, we can return False immediately if window_sum <= 0: return False # Slide the window from left to right across the array for i in range(k, len(nums)): # Slide the window to the right by subtracting the element that is leaving the window # and adding the element that is entering the window window_sum += nums[i] - nums[i - k] # If the sum of the current window is not positive, return False if window_sum <= 0: return False # If all windows have positive sums, return True return True"},{"question":"# Question: Collision Detection for Moving Circles Implement a function to detect collisions between two moving circles in a 2D plane. Each circle is characterized by its current position, radius, and velocity vector. The task is to determine whether the circles will collide at any point given their trajectories. # Function Signature ```python def will_circles_collide(circle1: dict, circle2: dict) -> bool: pass ``` # Input 1. `circle1`: A dictionary representing the first circle: - `position`: A list of two floats `[x1, y1]` indicating the current position. - `velocity`: A list of two floats `[vx1, vy1]` indicating the velocity vector. - `radius`: A float representing the radius of the circle. 2. `circle2`: A dictionary representing the second circle: - `position`: A list of two floats `[x2, y2]` indicating the current position. - `velocity`: A list of two floats `[vx2, vy2]` indicating the velocity vector. - `radius`: A float representing the radius of the circle. # Output * Return `True` if the circles will collide within a finite time; otherwise, return `False`. # Constraints - All positions are in the range of -10^3 to 10^3. - All velocity components are in the range of -10^2 to 10^2. - All radii are in the range of 0.1 to 10^2. - Assume a continuous and linear motion for the circles. # Performance Requirements - Efficiently compute the potential collision considering the equations of motion. - Ensure numerical stability to avoid inaccuracies for high velocities. # Example ```python circle1 = { \\"position\\": [0.0, 0.0], \\"velocity\\": [1.0, 0.0], \\"radius\\": 1.0 } circle2 = { \\"position\\": [5.0, 0.0], \\"velocity\\": [-1.0, 0.0], \\"radius\\": 1.0 } print(will_circles_collide(circle1, circle2)) # Output: True circle1 = { \\"position\\": [0.0, 0.0], \\"velocity\\": [0.0, 1.0], \\"radius\\": 1.0 } circle2 = { \\"position\\": [5.0, 0.0], \\"velocity\\": [0.0, -1.0], \\"radius\\": 1.0 } print(will_circles_collide(circle1, circle2)) # Output: False ``` # Notes - Consider the equations of motion for determining relative movement between the circles. - A collision occurs when the distance between the centers of the circles equals the sum of their radii. - Use vector algebra to derive the time to collision and determine if it\'s within a feasible range. - Handle edge cases such as circles moving parallel, circles moving apart, and stationary circles. # Hints - Use the relative position and velocity to reduce the problem to a single moving circle in a static reference frame. - Solve the quadratic equation to find the time of collision and check if it\'s positive and finite. By following these instructions, you will create a well-structured and complex question that fits seamlessly into a coding assessment that includes aspects like physics-based simulations and computational geometry.","solution":"import math def will_circles_collide(circle1, circle2): Determines if two circles will collide given their positions, velocities, and radii. # Unpack circle properties x1, y1 = circle1[\\"position\\"] vx1, vy1 = circle1[\\"velocity\\"] r1 = circle1[\\"radius\\"] x2, y2 = circle2[\\"position\\"] vx2, vy2 = circle2[\\"velocity\\"] r2 = circle2[\\"radius\\"] # Calculate relative position and velocity dx = x2 - x1 dy = y2 - y1 dvx = vx2 - vx1 dvy = vy2 - vy1 # Calculate coefficients for the quadratic equation a*t^2 + b*t + c = 0 a = dvx**2 + dvy**2 b = 2 * (dx*dvx + dy*dvy) c = dx**2 + dy**2 - (r1 + r2)**2 # Check if the circles are initially overlapping if c <= 0: return True # When a == 0, the circles are moving parallel or stationary relative to each other if a == 0: return False # Calculate the discriminant of the quadratic equation discriminant = b**2 - 4*a*c if discriminant < 0: return False # Solve the quadratic equation for the smallest non-negative time t t1 = (-b - math.sqrt(discriminant)) / (2 * a) t2 = (-b + math.sqrt(discriminant)) / (2 * a) return t1 >= 0 or t2 >= 0"},{"question":"# Problem Statement You are working on a system that needs to analyze text sequences and perform various operations based on specific requirements. One critical feature is to check whether a given string contains all the letters of the alphabet at least once, making it a \\"pangram\\". # Task Implement a function `is_pangram` that checks if the given input string contains every letter of the English alphabet at least once, case-insensitively. Function Signature ```python def is_pangram(input_string: str) -> bool: ``` Input * `input_string` (str): A string that may contain uppercase and lowercase letters, spaces, and punctuation. Output * (bool): Return `True` if the input string is a pangram, otherwise return `False`. Constraints * The length of `input_string` will be between 1 and 1000 characters. # Example ```python pangram_status = is_pangram(\\"The quick brown fox jumps over the lazy dog\\") print(pangram_status) # Output: True pangram_status = is_pangram(\\"Hello World\\") print(pangram_status) # Output: False ``` # Notes 1. Ignore spaces and punctuation when checking for pangram status. 2. Ensure the check is case-insensitive; treating \'A\' and \'a\' as the same. 3. Document any edge cases considered and handled in your solution. # Additional Considerations - Consider using a set to keep track of the unique letters encountered in the input string, which may simplify the implementation. - Optimize for time and space complexity to handle the upper constraint efficiently.","solution":"def is_pangram(input_string: str) -> bool: Check if the input string is a pangram. Parameters: input_string (str): The string to check. Returns: bool: True if the input string is a pangram, False otherwise. # Create a set containing all the letters of the alphabet alphabet_set = set(\'abcdefghijklmnopqrstuvwxyz\') # Convert input string to lowercase and create a set of characters input_set = set(input_string.lower()) # Check if all letters in the alphabet are present in the input string set return alphabet_set.issubset(input_set)"},{"question":"# Palindrome Combiner **Objective**: Write a function that checks if any combination of characters from two given strings can form a palindrome. Requirements: 1. **Core Task**: Implement a function that takes two strings as input and checks if any permutation of characters from the combined string of both inputs can form a palindrome. 2. **Expected Output**: The function should return `True` if the permutation is possible, `False` otherwise. 3. **Constraints**: - The combined length of the input strings will not exceed 1000 characters. - Input can only consist of lowercase letters `a` to `z`. Example: ```python def can_form_palindrome(s1: str, s2: str) -> bool: Function to determine if any permutation of characters from the combined string s1 + s2 can form a palindrome. # Your implementation goes here # Example usage: print(can_form_palindrome(\\"ab\\", \\"cba\\")) # Expected output: True print(can_form_palindrome(\\"abc\\", \\"def\\")) # Expected output: False ``` Explanation: - For the first example, the combined string is `abcba`. Possible palindromes could be `abccba` or `abcba`. - For the second example, the combined string `abcdef` cannot be rearranged to form a palindrome.","solution":"def can_form_palindrome(s1: str, s2: str) -> bool: Function to determine if any permutation of characters from the combined string s1 + s2 can form a palindrome. from collections import Counter combined_str = s1 + s2 char_count = Counter(combined_str) # A string can form a palindrome if at most one character has an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"# Introduction You are developing a 2D simulation of diffusion processes in a rectangular grid. The goal is to model the spread of a substance from an initial point over time. At every time step, the substance spreads evenly to its neighboring cells based on a given diffusion factor. Your task involves implementing functions to initialize the grid, simulate one step of the diffusion process, and calculate the concentration of the substance at a specific point after a given number of steps. # Problem Description Write three functions `initialize_grid`, `diffuse_step`, and `concentration_at_point` that work together to model the diffusion process. Function 1: `initialize_grid` Write a function `initialize_grid` that initializes a 2D grid with an initial concentration of substance at a specific point. **Function Signature**: ```python def initialize_grid( width: int, height: int, initial_point: Tuple[int, int], initial_concentration: float ) -> List[List[float]]: ``` **Input**: - `width` (int): Width of the grid. - `height` (int): Height of the grid. - `initial_point` (Tuple[int, int]): Coordinates (x, y) of the initial concentration point. - `initial_concentration` (float): Initial concentration of the substance at the initial point. **Output**: - (List[List[float]]): The initialized grid with the initial concentration set at the specified point. **Constraints**: - The width and height must be positive integers. - The initial point must be within the bounds of the grid. - The initial concentration must be a non-negative number. Function 2: `diffuse_step` Write a function `diffuse_step` that simulates a single step of the diffusion process based on a diffusion factor. **Function Signature**: ```python def diffuse_step( grid: List[List[float]], diffusion_factor: float ) -> List[List[float]]: ``` **Input**: - `grid` (List[List[float]]): The current state of the grid. - `diffusion_factor` (float): The factor by which the substance spreads to adjacent cells (between 0 and 1). **Output**: - (List[List[float]]): The new state of the grid after one diffusion step. **Constraints**: - The diffusion factor must be between 0 and 1. Function 3: `concentration_at_point` Write a function `concentration_at_point` that calculates the concentration of the substance at a specific point after a given number of diffusion steps. **Function Signature**: ```python def concentration_at_point( width: int, height: int, initial_point: Tuple[int, int], initial_concentration: float, diffusion_factor: float, steps: int, point: Tuple[int, int] ) -> float: ``` **Input**: - `width` (int): Width of the grid. - `height` (int): Height of the grid. - `initial_point` (Tuple[int, int]): Coordinates (x, y) of the initial concentration point. - `initial_concentration` (float): Initial concentration of the substance at the initial point. - `diffusion_factor` (float): The factor by which the substance spreads to adjacent cells (between 0 and 1). - `steps` (int): Number of diffusion steps to simulate. - `point` (Tuple[int, int]): Coordinates (x, y) of the point where you want to calculate the concentration. **Output**: - (float): The concentration of the substance at the specified point after the given number of steps. **Constraints**: - The width and height must be positive integers. - The initial point and the point of interest must be within the bounds of the grid. - The initial concentration must be a non-negative number. - The diffusion factor must be between 0 and 1. - The number of steps must be a non-negative integer. # Example ```python grid = initialize_grid(5, 5, (2, 2), 100.0) assert grid == [[0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 100.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0]] diffused_grid = diffuse_step(grid, 0.25) expected_diffused_grid = [[0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 25.0, 0.0, 0.0], [0.0, 25.0, 0.0, 25.0, 0.0], [0.0, 0.0, 25.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0]] assert diffused_grid == expected_diffused_grid concentration = concentration_at_point(5, 5, (2, 2), 100.0, 0.25, 1, (1, 2)) assert concentration == 25.0 ``` # Note - Include appropriate error handling for invalid inputs as specified in the constraints. - The solution should include necessary imports and follow proper coding standards.","solution":"from typing import List, Tuple def initialize_grid( width: int, height: int, initial_point: Tuple[int, int], initial_concentration: float ) -> List[List[float]]: if width <= 0 or height <= 0: raise ValueError(\\"Width and height must be positive integers\\") if initial_concentration < 0: raise ValueError(\\"Initial concentration must be a non-negative number\\") if not (0 <= initial_point[0] < width) or not (0 <= initial_point[1] < height): raise ValueError(\\"Initial point must be within the bounds of the grid\\") grid = [[0.0 for _ in range(width)] for _ in range(height)] x, y = initial_point grid[y][x] = initial_concentration return grid def diffuse_step( grid: List[List[float]], diffusion_factor: float ) -> List[List[float]]: if not (0 <= diffusion_factor <= 1): raise ValueError(\\"Diffusion factor must be between 0 and 1\\") height = len(grid) width = len(grid[0]) new_grid = [[0.0 for _ in range(width)] for _ in range(height)] for y in range(height): for x in range(width): amount = grid[y][x] * diffusion_factor remaining = grid[y][x] - 4 * amount neighbours = [(y-1, x), (y+1, x), (y, x-1), (y, x+1)] for ny, nx in neighbours: if 0 <= ny < height and 0 <= nx < width: new_grid[ny][nx] += amount new_grid[y][x] += remaining return new_grid def concentration_at_point( width: int, height: int, initial_point: Tuple[int, int], initial_concentration: float, diffusion_factor: float, steps: int, point: Tuple[int, int] ) -> float: if width <= 0 or height <= 0: raise ValueError(\\"Width and height must be positive integers\\") if initial_concentration < 0: raise ValueError(\\"Initial concentration must be a non-negative number\\") if not (0 <= initial_point[0] < width) or not (0 <= initial_point[1] < height): raise ValueError(\\"Initial point must be within the bounds of the grid\\") if not (0 <= point[0] < width) or not (0 <= point[1] < height): raise ValueError(\\"Target point must be within the bounds of the grid\\") if steps < 0: raise ValueError(\\"Number of steps must be a non-negative integer\\") if not (0 <= diffusion_factor <= 1): raise ValueError(\\"Diffusion factor must be between 0 and 1\\") grid = initialize_grid(width, height, initial_point, initial_concentration) for _ in range(steps): grid = diffuse_step(grid, diffusion_factor) x, y = point return grid[y][x]"},{"question":"# Question Style - Coding focus: Algorithmic implementation, handling edge cases, and optimization. - Clear problem statement with input, output, and constraints. - Example usage demonstrating expected behavior. # Question **Most Frequent Element Calculation** You need to implement a function to find the most frequently occurring element in a list of integers. If there are multiple elements with the same highest frequency, return any one of them. Your solution should be efficient and well-suited for large input sizes. # Problem Statement Implement the function `most_frequent(nums: list[int]) -> int` that returns the most frequent element in the input list of integers. # Input * A list of integers, `nums`, where (0 leq |nums| leq 10^6) and (|nums[i]| leq 10^9). # Output * An integer representing the most frequent element in the list. If the list is empty, return `None`. # Constraints 1. If the list is empty, return `None`. 2. If there are multiple elements with the same maximum frequency, return any one of them. # Examples ```python assert most_frequent([1, 3, 1, 3, 2, 1]) == 1 assert most_frequent([2, 2, 3, 3, 2]) == 2 assert most_frequent([7]) == 7 assert most_frequent([]) is None ``` # Requirements * Your solution should handle lists up to size (10^6) efficiently. * Consider edge cases and error scenarios in your implementation. * Utilize appropriate data structures to achieve optimal runtime. # Guidelines * Avoid solutions that require excessive space. * Explore data structures that assist in tracking frequency counts efficiently, such as hash maps.","solution":"def most_frequent(nums): Returns the most frequent element in the list of integers. If the list is empty, returns None. If there are multiple elements with the same highest frequency, returns any one of them. if not nums: return None frequency = {} for num in nums: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 most_frequent_element = max(frequency, key=frequency.get) return most_frequent_element"},{"question":"# Word Ladder Transformation Using BFS Scenario You are hired to implement a word transformation solution for a linguistic research project. The task is to transform a given start word into a target word by changing only one letter at a time. Each intermediate transformation must also be a valid English word from a provided list. Objective Implement the `WordLadder` class to find the shortest transformation sequence from the start word to the target word using Breadth-First Search (BFS). Your solution needs to demonstrate an understanding of graph traversal algorithms. Requirements 1. **Input**: - A start string `beginWord`. - An end string `endWord`. - A list of strings `wordList` representing a dictionary of valid words. 2. **Output**: - The length of the shortest transformation sequence from `beginWord` to `endWord`, or `0` if no such transformation is possible. 3. **Constraints**: - All words consist of lowercase English letters and have the same length. - The length of `beginWord` and `endWord` will be in the range `[1, 10]`. - The total number of words in the `wordList` will be within the range `[1, 10^3]`. 4. **Performance**: - The solution should efficiently handle the provided constraints. Function Signature ```python class WordLadder: def __init__(self, beginWord: str, endWord: str, wordList: list[str]): # initialization code def findShortestTransformationSequence(self) -> int: # code to perform BFS and return the length of the shortest transformation sequence ``` Hints - Use BFS to explore all possible transformations level by level. - Preprocess the word list to create a mapping of possible intermediate words to optimize the transformation process. - Make sure to account for cases where no transformation is possible if `endWord` is not in the `wordList`. Example ```python beginWord = \\"hit\\" endWord = \\"cog\\" wordList = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] wl = WordLadder(beginWord, endWord, wordList) length = wl.findShortestTransformationSequence() print(length) # Expected output: 5 (hit -> hot -> dot -> dog -> cog) ```","solution":"from collections import deque, defaultdict from typing import List class WordLadder: def __init__(self, beginWord: str, endWord: str, wordList: List[str]): self.beginWord = beginWord self.endWord = endWord self.wordList = wordList self.word_set = set(wordList) self.length = len(beginWord) def findShortestTransformationSequence(self) -> int: if self.endWord not in self.word_set: return 0 all_combo_dict = defaultdict(list) for word in self.word_set: for i in range(self.length): intermediate_word = word[:i] + \'*\' + word[i+1:] all_combo_dict[intermediate_word].append(word) queue = deque([(self.beginWord, 1)]) visited = set() visited.add(self.beginWord) while queue: current_word, level = queue.popleft() for i in range(self.length): intermediate_word = current_word[:i] + \'*\' + current_word[i+1:] for word in all_combo_dict[intermediate_word]: if word == self.endWord: return level + 1 if word not in visited: visited.add(word) queue.append((word, level + 1)) all_combo_dict[intermediate_word] = [] return 0"},{"question":"# Task Write a function that accepts a string containing a mix of words and numbers (separated by spaces) and returns a list of the numbers in sorted order. Function Signature ```python def sort_numbers_in_string(input_string: str) -> list: Extracts all the numbers from a given string and returns them as a sorted list of integers. Args: input_string (str): A string containing words and numbers separated by spaces. Returns: list: A sorted list of integers extracted from the string. ``` # Input * A string `input_string` containing a mixture of words and numbers separated by spaces. # Output * Return a list of numbers (integers) sorted in ascending order. # Constraints * The string can contain up to 10,000 characters. * Numbers will be non-negative integers and can appear multiple times. * Words and numbers are separated by spaces and words don\'t contain numeric characters. * You can assume that the string contains at least one number. # Example ```python input_string = \\"42 apples 12 oranges 7 bananas 42 watermelons 0 grapes\\" print(sort_numbers_in_string(input_string)) # Output: [0, 7, 12, 42, 42] ``` # Notes * Use appropriate string manipulation and sorting techniques. * Assume the input is well-formed and does not require extensive validation.","solution":"def sort_numbers_in_string(input_string: str) -> list: Extracts all the numbers from a given string and returns them as a sorted list of integers. Args: input_string (str): A string containing words and numbers separated by spaces. Returns: list: A sorted list of integers extracted from the string. # Split the input string by spaces to get all the words and numbers elements = input_string.split() # Extract numbers from the elements, filtering out non-digits and converting to integers numbers = [int(element) for element in elements if element.isdigit()] # Sort the numbers in ascending order sorted_numbers = sorted(numbers) return sorted_numbers"},{"question":"**Title**: Implement Functions for Matrix Operations **Context**: Matrix operations are fundamental in various fields like computer graphics, scientific computations, and machine learning. Implementing common matrix operations helps in understanding and optimizing these complex systems. **Task**: Implement two functions: `matrix_multiplication` and `transpose_matrix`. # 1. Matrix Multiplication **Function**: `matrix_multiplication(A: list[list[int]], B: list[list[int]]) -> list[list[int]]` **Description**: Implement a function to multiply two matrices `A` and `B`. The result of matrix multiplication is a new matrix where each element is the dot product of the rows of `A` and the columns of `B`. **Input**: - `A`: A 2D list representing matrix A. - `B`: A 2D list representing matrix B. **Output**: - A 2D list representing the resultant matrix after multiplying `A` and `B`. **Constraints**: - The number of columns in `A` must be equal to the number of rows in `B`. # 2. Transpose Matrix **Function**: `transpose_matrix(M: list[list[int]]) -> list[list[int]]` **Description**: Implement a function to transpose a given matrix `M`. The transpose of a matrix is another matrix where the rows of the original are columns in the result and vice versa. **Input**: - `M`: A 2D list representing matrix M. **Output**: - A 2D list representing the transposed matrix. **Example Cases**: **Case 1**: ```python A = [ [1, 2, 3], [4, 5, 6] ] B = [ [7, 8], [9, 10], [11, 12] ] assert matrix_multiplication(A, B) == [ [58, 64], [139, 154] ] ``` **Case 2**: ```python M = [ [1, 2, 3], [4, 5, 6] ] assert transpose_matrix(M) == [ [1, 4], [2, 5], [3, 6] ] ``` **Case 3**: ```python A = [ [2, 3], [4, 1] ] B = [ [5, 7], [6, 8] ] assert matrix_multiplication(A, B) == [ [28, 38], [26, 36] ] ``` **Case 4**: ```python M = [ [1, 4], [2, 5], [3, 6] ] assert transpose_matrix(M) == [ [1, 2, 3], [4, 5, 6] ] ```","solution":"def matrix_multiplication(A, B): Multiplies two matrices A and B and returns the result matrix. Assumption: The number of columns in A is equal to the number of rows in B. result = [[0] * len(B[0]) for _ in range(len(A))] for i in range(len(A)): for j in range(len(B[0])): for k in range(len(B)): result[i][j] += A[i][k] * B[k][j] return result def transpose_matrix(M): Returns the transpose of matrix M. return [[M[j][i] for j in range(len(M))] for i in range(len(M[0]))]"},{"question":"# Coding Assessment Question Write a function that takes a string as input and returns a compressed version of the string using the following format: each character followed by the number of times it appears consecutively. If the compressed string is not shorter than the original string, return the original string instead. # Function Signature: ```python def compress_string(s: str) -> str: ``` # Input: - `s` (string): A non-empty string consisting of only uppercase and lowercase alphabetic characters. # Output: - Returns a compressed version of the string if it is shorter; otherwise, returns the original string. # Constraints: - The input string can contain only alphabetic characters (both uppercase and lowercase). - The length of the input string is at most 10^4. # Examples: - Example 1: ```python s = \\"aabcccccaaa\\" print(compress_string(s)) # Output: \\"a2b1c5a3\\" ``` - Example 2: ```python s = \\"abcdef\\" print(compress_string(s)) # Output: \\"abcdef\\" ``` - Example 3: ```python s = \\"aabbcc\\" print(compress_string(s)) # Output: \\"aabbcc\\" ``` # Notes: - If the compressed string has the same length or longer than the original string, return the original string. - This problem is designed to test both string manipulation and algorithm efficiency. # Hints: - Consider using a list to build the compressed version of the string for better performance. - Ensure edge cases are handled, such as different character patterns and single-character strings.","solution":"def compress_string(s: str) -> str: if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Problem Statement You are tasked with implementing a function that simulates a simplified version of a PageRank algorithm, which is used to rank web pages based on their importance. The function should take a transition probability matrix of the web pages, an optional initial rank vector, and a specified number of iterations. The function should return the final rank vector after the specified iterations. # Function Signature ```python def page_rank(trans_matrix: List[List[float]], initial_vector: List[float] = None, iterations: int = 100) -> List[float]: pass ``` # Parameters - `trans_matrix`: A 2D list of floats representing the transition probability matrix (n x n) of the web pages. - `initial_vector`: An optional list of floats representing the initial rank vector (n x 1). If not provided, assume an equal rank for all pages. - `iterations`: An integer specifying the number of iterations to run the PageRank algorithm. # Output - Returns a list of floats representing the rank vector after the specified iterations. # Constraints - The matrix is always square (n x n). - The sum of elements in each row of the transition matrix is equal to 1 (i.e., each row is a probability distribution). - Elements of the transition matrix are within the range of 0 to 1. - Number of iterations is positive and does not exceed 10^6. - Initial rank vector elements are within the range of 0 to 1. - The size of the transition matrix is between 2 and 1000. # Example ```python # Example 1: trans_matrix = [ [0.5, 0.5], [0.5, 0.5] ] assert page_rank(trans_matrix, iterations=1) == [0.5, 0.5] # Example 2: trans_matrix = [ [0.0, 1.0], [1.0, 0.0] ] assert page_rank(trans_matrix, iterations=2) == [0.5, 0.5] ``` # Guidelines 1. Use matrix-vector multiplication to update the rank vector in each iteration. 2. Ensure numerical precision is retained during the computations. 3. Handle the edge cases where the initial rank vector is not provided and all pages should start with equal rank. # Hints - The rank vector\'s values should be normalized such that their sum is 1 after each iteration. - Efficient matrix-vector multiplication will ensure the function runs within acceptable time limits given the constraints.","solution":"from typing import List def page_rank(trans_matrix: List[List[float]], initial_vector: List[float] = None, iterations: int = 100) -> List[float]: n = len(trans_matrix) if initial_vector is None: rank_vector = [1/n for _ in range(n)] else: rank_vector = initial_vector[:] for _ in range(iterations): new_rank_vector = [0] * n for i in range(n): new_rank_vector[i] = sum(trans_matrix[i][j] * rank_vector[j] for j in range(n)) # Normalize rank_vector total_rank = sum(new_rank_vector) rank_vector = [val/total_rank for val in new_rank_vector] return rank_vector"},{"question":"# Problem Statement: Develop the function `findFibonacciIndex(n: int) -> int`, which is designed to determine the index of the smallest Fibonacci number that has exactly `n` digits. The Fibonacci sequence is defined by the recurrence relation: [ F(0) = 0, ] [ F(1) = 1, ] [ F(n) = F(n-1) + F(n-2) text{ for } n geq 2. ] Your task is to: 1. Understand the Fibonacci sequence and identify the properties of its growth. 2. Implement an efficient method to calculate Fibonacci numbers and find the desired index, ensuring minimized computation overhead. 3. Ensure that the implementation can handle large values of `n` properly. # Function Signature: ```python def findFibonacciIndex(n: int) -> int: pass ``` # Input: - `n` (int): The number of digits required in the Fibonacci number. # Output: - An integer representing the index of the first Fibonacci number that has exactly `n` digits. # Constraints: - ( 1 leq n leq 1000 ) # Requirements: 1. **Performance**: Aim for an efficient algorithm that handles the upper constraint effectively. Avoid naive approaches that result in excessive computations. 2. **Correctness**: Ensure the function returns the correct index, maintaining the accuracy of the Fibonacci sequence. 3. **Optimization**: - Consider iterative or matrix exponentiation methods for Fibonacci calculation. - Avoid recomputation by using techniques such as memoization if necessary. - Take advantage of mathematical properties of Fibonacci numbers to reduce the number of computations. # Example: ```python >>> findFibonacciIndex(2) 7 >>> findFibonacciIndex(3) 12 >>> findFibonacciIndex(10) 45 >>> findFibonacciIndex(100) 476 ``` # Hint: - Consider the properties and approximation formulas of Fibonacci numbers, such as Binet\'s formula or logarithmic approaches, which can help in estimating the number of digits efficiently. - Utilize efficient computation methods to handle large Fibonacci numbers, ensuring that you do not run into performance bottlenecks.","solution":"def findFibonacciIndex(n: int) -> int: Returns the index of the first Fibonacci number that has exactly n digits. if n == 1: # The first two Fibonacci numbers F(0)=0 and F(1)=1 both have 1 digit. return 1 a, b = 1, 1 index = 2 while len(str(b)) < n: a, b = b, a + b index += 1 return index"},{"question":"# Problem Statement: You are working on a financial application that involves analyzing stock prices over a given period. You are tasked with implementing a function `average_stock_price(prices: List[float], k: int) -> List[float]` that calculates the average of every k consecutive stock prices in the given list. # Function Signature: ```python def average_stock_price(prices: List[float], k: int) -> List[float]: pass ``` # Input: - `prices`: A list of n floating-point numbers representing the stock prices over n days. - `k`: An integer representing the number of consecutive days for which the average stock price needs to be calculated. # Output: - A list of floating-point numbers representing the average stock prices for each window of k consecutive days. The length of the output list would be `n - k + 1`. # Constraints: - The length of `prices` will be between 1 and 1,000 (inclusive). - The value of `k` will be between 1 and the length of `prices` (inclusive). - You can assume that the input will always be a valid list of prices with at least k prices. # Example: ```python assert average_stock_price([1.0, 2.0, 3.0, 4.0, 5.0], 3) == [2.0, 3.0, 4.0] assert average_stock_price([7.0, 8.0, 8.5, 9.0, 10.0], 2) == [7.5, 8.25, 8.75, 9.5] ``` # Additional Information: - Consider implementing an efficient solution to handle the upper constraint limits. - Take advantage of sliding window techniques where appropriate. - Ensure your solution maintains numerical precision and handles edge cases correctly. **Note**: Do not modify the function signature and ensure your solution passes the provided test cases.","solution":"from typing import List def average_stock_price(prices: List[float], k: int) -> List[float]: Function to calculate the average of every k consecutive stock prices in the given list. Parameters: prices (List[float]): List of stock prices. k (int): Number of consecutive days for averaging. Returns: List[float]: List of average stock prices for each k consecutive days. if not prices or k <= 0 or k > len(prices): return [] n = len(prices) result = [] window_sum = sum(prices[:k]) for i in range(n - k + 1): if i == 0: result.append(window_sum / k) else: window_sum = window_sum - prices[i - 1] + prices[i + k - 1] result.append(window_sum / k) return result"},{"question":"# Problem Statement A group of friends went to a restaurant and they want to equally split the bill among themselves. However, some friends brought exact change and others need change back because they have larger denominations than required. Write a function to calculate the necessary change each friend needs and the total amount of change returned by the restaurant. # Detailed Requirements * Define a function `calculate_change(n: int, total_bill: float, payments: List[float]) -> Tuple[Dict[int, float], float]` where: - `n` is the number of friends - `total_bill` is the total cost of the meal - `payments` is a list of floats representing the amounts each friend paid * The function should: - Calculate the amount each friend should contribute (total_bill / n). - Determine the amount of change each friend needs (if any). - Return a dictionary where keys are the index of the friends (0-based) and values are the amount of change each friend should get back. - Return the total amount of change returned by the restaurant. # Input and Output - **Input**: - An integer, `n` representing the number of friends. - A float, `total_bill` representing the total cost of the meal. - A list of floats, `payments` representing the amount paid by each friend. - **Output**: - A tuple containing a dictionary and a float. The dictionary shows the amount of change each friend receives and the float is the total change returned by the restaurant. # Constraints: 1. All payments are positive floats. 2. Total bill and payments will be represented using up to two decimal places. 3. Assume friends don\'t make mistakes in payment and there is always enough money to cover the bill. # Example Case ``` calculate_change(3, 60.00, [20.00, 30.00, 20.00]) -> ({0: 0.00, 1: 10.00, 2: 0.00}, 10.00) ``` # Explanation: 1. Each friend should contribute 20.00 (60.00 / 3). 2. Friend 0 paid 20.00, so no change is needed. 3. Friend 1 paid 30.00, so 10.00 change is needed. 4. Friend 2 paid 20.00, so no change is needed. 5. The total change returned by the restaurant is 10.00.","solution":"from typing import List, Tuple, Dict def calculate_change(n: int, total_bill: float, payments: List[float]) -> Tuple[Dict[int, float], float]: Calculate the necessary change each friend needs and the total amount of change returned by the restaurant. Parameters: n (int): The number of friends. total_bill (float): The total cost of the meal. payments (List[float]): Amounts each friend paid. Returns: Tuple[Dict[int, float], float]: A dictionary where keys are the index of the friends and values are the amount of change each friend should get back, and the total amount of change returned by the restaurant. share = total_bill / n changes = {} total_change = 0.0 for i in range(n): change = max(0, payments[i] - share) changes[i] = round(change, 2) total_change += change total_change = round(total_change, 2) return changes, total_change"},{"question":"# Question Overview Given a sorted array of unique integers and a target integer `k`, determine if there are two numbers in the array that add up to `k`. The function should return `True` if such a pair exists, and `False` otherwise. Implement the function `has_pair_with_sum` that performs this check. Function Signature ```python def has_pair_with_sum(nums: List[int], k: int) -> bool: pass ``` Input - `nums`: A list of integers, sorted in non-decreasing order. ( 2 leq text{len(nums)} leq 10^5 ) - `k`: An integer, the target sum to find. ( -10^9 leq k leq 10^9 ) Output - The function should return a boolean value `True` if there exists a pair of distinct elements in the array that sum to `k`, otherwise `False`. Example ```python assert has_pair_with_sum([1, 2, 3, 4, 9], 8) == False assert has_pair_with_sum([1, 2, 3, 4, 4, 7], 8) == True assert has_pair_with_sum([-10, -3, 0, 1, 4], -2) == True ``` Constraints - Use an algorithm with a time complexity of ( O(n) ), where ( n ) is the length of the input list. Performance Requirements - The function should efficiently handle the maximum constraint for the length of the input list within acceptable runtime limits.","solution":"from typing import List def has_pair_with_sum(nums: List[int], k: int) -> bool: Determine if there are two numbers in the sorted array \'nums\' that add up to \'k\'. left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == k: return True elif current_sum < k: left += 1 else: right -= 1 return False"},{"question":"# Deepest Binary Tree Node Context: Given a binary tree, each node stores an integer value. We need to find the value stored in the deepest node. If multiple nodes are at the same deepest level, return the leftmost one. Problem Statement: Write a function `deepest_binary_tree_node(root: Optional[TreeNode]) -> int` that returns the value of the deepest node in the binary tree. If there are multiple deepest nodes, return the value of the leftmost one. Input: - `root` (Optional[TreeNode]): The root node of the binary tree. Output: - Returns an integer. The value of the deepest node. Constraints: - The number of nodes in the binary tree is in the range `[1, 10^4]`. - The value of each node is in the range `[-10^5, 10^5]`. Example: Consider the following binary tree: ``` 1 / 2 3 / 4 / 5 ``` ```python >>> deepest_binary_tree_node(root) 5 >>> deepest_binary_tree_node(TreeNode(1, TreeNode(2, TreeNode(3)))) 3 >>> deepest_binary_tree_node(TreeNode(1, None, TreeNode(2, None, TreeNode(3)))) 3 ``` Performance Requirements: - The function should efficiently handle large binary trees. Note: - You can use level-order traversal to find the deepest nodes and keep track of the leftmost one at each level. # Implementation Constraints: - Avoid using excessive memory or unnecessary data structures. - Focus on optimal traversal techniques to ensure the solution is scalable. ```python from typing import Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def deepest_binary_tree_node(root: Optional[TreeNode]) -> int: if not root: return -1 queue = [(root, 0)] max_depth = -1 current_value = root.val while queue: node, depth = queue.pop(0) if depth > max_depth: max_depth = depth current_value = node.val if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return current_value ```","solution":"from typing import Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def deepest_binary_tree_node(root: Optional[TreeNode]) -> int: if not root: return -1 queue = [(root, 0)] max_depth = -1 current_value = root.val while queue: node, depth = queue.pop(0) if depth > max_depth: max_depth = depth current_value = node.val if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return current_value"},{"question":"# Problem Statement You are developing a small feature to rotate elements in a 2D matrix by 90 degrees in a clockwise direction. Your task is to implement the algorithm that performs this rotation in place. # Function to Implement Implement the function `rotate_matrix(matrix: List[List[int]]) -> None` in Python, where: * `matrix` is a 2D list of integers representing the matrix to be rotated. # Input and Output * **Input**: * A 2D list `matrix`, where all internal lists (rows) have the same length. * **Output**: * The function modifies the input matrix in place and does not return a value. # Constraints 1. The matrix will have sizes between 1x1 and 1000x1000. 2. The elements within the matrix are integers between `-10^9` and `10^9`. # Examples ```python matrix_1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix_1) # matrix_1 should now be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] matrix_2 = [ [1, 2], [3, 4] ] rotate_matrix(matrix_2) # matrix_2 should now be: # [ # [3, 1], # [4, 2] # ] matrix_3 = [ [1] ] rotate_matrix(matrix_3) # matrix_3 should now be: # [ # [1] # ] ``` # Performance Requirements * Ensure the rotation operation is efficient with respect to both time and space complexity, with ideally an O(n^2) time complexity. # Additional Notes Consider edge cases such as: * Single-element matrices. * Non-square matrices (not relevant here as we assume square matrices given the constraints). * Handling very large and very small numbers properly within the constraints. Implement your function to handle all edge cases effectively.","solution":"def rotate_matrix(matrix): Rotates the matrix 90 degrees clockwise in place. n = len(matrix) # First step is to transpose the matrix for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Second step is to reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Connect Common Nodes in Different Lists Context: You are given two singly linked lists. Each list contains nodes with integer values. Some of the values might be common between the two lists. Your task is to identify the common nodes based on their values and create a new linked list that contains these common nodes in the ascending order of their values. Task: Implement a function `linked_list_common_nodes` that takes the head nodes of two linked lists and returns the head node of the new linked list containing the common nodes in ascending order. Function Signature: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def linked_list_common_nodes(head1: ListNode, head2: ListNode) -> ListNode: pass ``` Input and Output: - **Input**: - `head1`: Head node of the first linked list. - `head2`: Head node of the second linked list. - **Output**: A new linked list\'s head node containing common nodes of the input lists in ascending order. Constraints: - The linked lists can have different lengths, including being empty. - All node values are integers. - The resulting linked list should not have duplicate nodes even if the input lists contain duplicates. - The linked list should be sorted in ascending order by value. - Assume no memory constraints. Performance Requirements: - Aim for an O(n + m) time complexity, where n and m are the lengths of the two linked lists. - The space complexity should be minimized, minimizing additional data structures where possible. Examples: 1. Given linked list 1: `1 -> 3 -> 4 -> 6` and linked list 2: `2 -> 3 -> 6 -> 7`, the function should return a linked list: `3 -> 6`. 2. Given linked list 1: `1 -> 2 -> 2 -> 4 -> 5` and linked list 2: `2 -> 2 -> 3 -> 5`, the function should return a linked list: `2 -> 5`. 3. Given linked list 1: `0 -> 1 -> 2 -> 4` and linked list 2: `5 -> 6 -> 7`, the function should return a linked list: `None`. Notes: - Focus on efficiency and handling of edge cases such as empty lists or lists with no common values. - Avoid using built-in sorting functions; leverage the inherent order of the linked lists for efficient traversal and merging. - Ensure proper definition and handling of the `ListNode` class for creating and managing linked list nodes.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def linked_list_common_nodes(head1: ListNode, head2: ListNode) -> ListNode: # Function to generate a sorted list from the nodes\' values def generate_sorted_list(node): values_set = set() while node: values_set.add(node.val) node = node.next return sorted(values_set) # Get sorted lists from both linked lists sorted_list1 = generate_sorted_list(head1) sorted_list2 = generate_sorted_list(head2) # Find common elements in the two sorted lists common_values = sorted(set(sorted_list1).intersection(set(sorted_list2))) # Creating the new linked list with common elements dummy = ListNode() # Dummy node to start the new linked list current = dummy for val in common_values: current.next = ListNode(val) current = current.next return dummy.next"},{"question":"# Scenario You are working on a web application that provides personalized content recommendations to users. One component of this system is to predict user ratings for unseen content using collaborative filtering. Specifically, you want to implement a User-Based Collaborative Filtering algorithm where the predicted rating for a user on a particular item is based on the ratings from similar users. # Task Implement a User-Based Collaborative Filtering system to predict ratings for users. # Implement the Following Functions 1. `class UserCollaborativeFiltering:` - `__init__(self, ratings: Dict[int, Dict[int, float]])`: Initialize the system with a dictionary of user ratings, where the keys are user IDs and the values are dictionaries mapping item IDs to the respective ratings. - `compute_similarity(self, user1: int, user2: int) -> float`: Compute the similarity between two users using cosine similarity. - `predict_rating(self, user_id: int, item_id: int, k: int) -> float`: Predict the rating for a given user and item using the k most similar users\' ratings. # Constraints - If the user hasn\'t rated any item, the similarity should be considered zero. - `k` will be a positive integer less than or equal to the number of users in the dataset. # Expected Input and Output Formats - Input: ```python ratings = { user_id1: {item_id1: rating1, item_id2: rating2, ...}, user_id2: {item_id3: rating3, item_id4: rating4, ...}, ... } user_id = some_user_id item_id = some_item_id k = 3 ``` - Output: ```python predicted_rating = 4.5 ``` # Example ```python ratings = { 1: {101: 5.0, 102: 3.0, 103: 4.0}, 2: {101: 4.0, 102: 2.0}, 3: {101: 2.0, 103: 5.0, 104: 3.0} } user_id = 1 item_id = 104 k = 2 cf_system = UserCollaborativeFiltering(ratings) predicted_rating = cf_system.predict_rating(user_id, item_id, k) print(predicted_rating) # Output might be 3.5 ``` # Notes - Use cosine similarity to measure user-user similarity. - When predicting, consider users who have rated the item in question. - If no similar users have rated the item, you may return a fallback rating such as the global average rating.","solution":"from typing import Dict from collections import defaultdict import math class UserCollaborativeFiltering: def __init__(self, ratings: Dict[int, Dict[int, float]]): self.ratings = ratings def compute_similarity(self, user1: int, user2: int) -> float: common_items = set(self.ratings[user1].keys()).intersection(set(self.ratings[user2].keys())) if not common_items: return 0.0 sum1 = sum2 = sum_product = 0 for item in common_items: rating1 = self.ratings[user1][item] rating2 = self.ratings[user2][item] sum1 += rating1 ** 2 sum2 += rating2 ** 2 sum_product += rating1 * rating2 if sum1 == 0 or sum2 == 0: return 0.0 return sum_product / (math.sqrt(sum1) * math.sqrt(sum2)) def predict_rating(self, user_id: int, item_id: int, k: int) -> float: similarities = [] for other_user_id in self.ratings: if other_user_id != user_id and item_id in self.ratings[other_user_id]: similarity = self.compute_similarity(user_id, other_user_id) similarities.append((similarity, self.ratings[other_user_id][item_id])) similarities.sort(reverse=True, key=lambda x: x[0]) numerator = denominator = 0 for similarity, rating in similarities[:k]: numerator += similarity * rating denominator += abs(similarity) if denominator == 0: return self.global_average_rating() return numerator / denominator def global_average_rating(self) -> float: total = count = 0 for user_ratings in self.ratings.values(): for rating in user_ratings.values(): total += rating count += 1 return total / count if count != 0 else 0.0"},{"question":"# Question You are developing a module for statistical analysis and need to calculate the variance of a given list of numbers. The variance is a measure of how much the numbers in the list deviate from their average value. It is computed using the following formula: [ text{Variance} = frac{1}{N} sum_{i=1}^{N} (x_i - bar{x})^2 ] Where: * (N) is the number of elements in the list. * (x_i) is each individual element in the list. * (bar{x}) is the mean (average) of the elements in the list. The function should raise specific errors for invalid inputs: 1. If the list is empty, raise a `ValueError` with the message \\"The list must contain at least one number.\\" 2. If the list contains non-numeric values, raise a `TypeError` with the message \\"All elements in the list must be numbers.\\" Implement a function `calculate_variance` which calculates the variance of the input list of numbers. Function Signature ```python def calculate_variance(numbers: list) -> float: ``` Input * `numbers (list)`: A list of numerical values. Output * Return the computed variance as a float. Constraints * The list must contain at least one number. * All elements in the list must be numbers (integers or floats). Example ```python >>> calculate_variance([2, 4, 4, 4, 5, 5, 7, 9]) 4.0 ``` Errors ```python >>> calculate_variance([]) Traceback (most recent call last): ... ValueError: The list must contain at least one number >>> calculate_variance([2, \'four\', 4]) Traceback (most recent call last): ... TypeError: All elements in the list must be numbers ```","solution":"def calculate_variance(numbers: list) -> float: Calculate the variance of a list of numbers. :param numbers: A list of numerical values. :return: The variance of the list. :raises ValueError: If the list is empty. :raises TypeError: If any element in the list is not a number. if not numbers: raise ValueError(\\"The list must contain at least one number.\\") if any(not isinstance(num, (int, float)) for num in numbers): raise TypeError(\\"All elements in the list must be numbers.\\") mean = sum(numbers) / len(numbers) variance = sum((num - mean) ** 2 for num in numbers) / len(numbers) return variance"},{"question":"# Differentiate and Count Elements You are given a list of elements which can contain both integers and strings. Implement a function that separates the integers and strings into two distinct lists within a dictionary. The function also needs to return the count of unique integers and unique strings found in the original list. # Function Signature ```python def differentiate_and_count(elements: list) -> dict: pass ``` # Input - `elements`: A list containing integers and strings. The list is guaranteed to be non-empty. # Output A dictionary with three keys: - \'integers\': A sorted list of unique integers from the `elements` list. - \'strings\': A sorted list of unique strings from the `elements` list. - \'counts\': A dictionary with two keys: - \'integer_count\': representing the count of unique integers. - \'string_count\': representing the count of unique strings. # Constraints and Notes - The function should ensure correctness of type separation (integers and strings). - The input list will not contain any elements other than integers and strings. - The lists returned should not have any duplicates. - The integers should be compared and sorted numerically; the strings should be compared and sorted lexicographically. # Example ```python elements = [3, \\"apple\\", 1, \\"banana\\", \\"apple\\", 2, \\"banana\\", 3, 5.0, \\"cherry\\"] differentiate_and_count(elements) # Output: # { # \'integers\': [1, 2, 3, 5], # \'strings\': [\'apple\', \'banana\', \'cherry\'], # \'counts\': { # \'integer_count\': 4, # \'string_count\': 3 # } # } elements = [42, \\"42\\", \\"hello\\", 42, \\"world\\", \\"hello\\"] differentiate_and_count(elements) # Output: # { # \'integers\': [42], # \'strings\': [\'42\', \'hello\', \'world\'], # \'counts\': { # \'integer_count\': 1, # \'string_count\': 3 # } # } ``` # Requirements - Ensure appropriate handling of integer and string types even if strings might represent numerical values. - Implement error checking for invalid types if necessary, but assume clean input as per constraints. - The function should be efficient with respect to time and space complexity and leverage appropriate Python data structures.","solution":"def differentiate_and_count(elements: list) -> dict: integers = set() strings = set() for element in elements: if isinstance(element, int): integers.add(element) elif isinstance(element, str): strings.add(element) sorted_integers = sorted(integers) sorted_strings = sorted(strings) result = { \'integers\': sorted_integers, \'strings\': sorted_strings, \'counts\': { \'integer_count\': len(sorted_integers), \'string_count\': len(sorted_strings) } } return result"},{"question":"# Phone Number Word Decoder **Context**: Phone numbers traditionally used letters corresponding to numbers on older phone keypads, for example, 2 corresponds to \'ABC\', 3 corresponds to \'DEF\', etc. This format is often used to create memorable phone numbers (e.g., 1-800-FLOWERS). Given a phone number written with letters, it\'s crucial to translate it back to its digit-only form for processing by modern digital systems. **Objective**: Write a function that decodes a phone number containing both digits and letters to a purely digit-based phone number. Leave any non-alphanumeric characters (such as hyphens or spaces) in their original places. # Function Signature ```python def decode_phone_number(phone_number: str) -> str: Decode a phone number written with letters to its digit-only form. Non-alphanumeric characters should remain in the same position. Parameters: - phone_number (str): A phone number string that may contain letters, digits, and non-alphanumeric characters. Returns: - str: The decoded phone number with letters replaced by corresponding digits and non-alphanumeric characters in their original positions. Examples: >>> decode_phone_number(\\"1-800-FLOWERS\\") \'1-800-3569377\' >>> decode_phone_number(\\"(555) - GET-FOOD\\") \'(555) - 438-3663\' >>> decode_phone_number(\\"1-800-DO-MATH\\") \'1-800-36-6284\' >>> decode_phone_number(\\"CALL-NOW\\") \'2255-669\' >>> decode_phone_number(\\"PYTHON-123\\") \'798466-123\' pass ``` # Constraints * The input string can contain both uppercase and lowercase letters. Map them to the corresponding digits irrespective of case. * Non-alphanumeric characters (such as hyphens, spaces, parentheses, etc.) should remain unchanged and in the same position. * You may assume the input string does not contain any leading or trailing whitespace. * The length of the input string will not exceed 100 characters. # Requirements * Complete the `decode_phone_number(phone_number: str) -> str` function to achieve the objectives as described. * Maintain time complexity O(n) where n is the total number of characters in the phone number string.","solution":"def decode_phone_number(phone_number: str) -> str: Decode a phone number written with letters to its digit-only form. Non-alphanumeric characters should remain in the same position. # Mapping of letters to their corresponding digits letter_to_digit = { \'A\': \'2\', \'B\': \'2\', \'C\': \'2\', \'D\': \'3\', \'E\': \'3\', \'F\': \'3\', \'G\': \'4\', \'H\': \'4\', \'I\': \'4\', \'J\': \'5\', \'K\': \'5\', \'L\': \'5\', \'M\': \'6\', \'N\': \'6\', \'O\': \'6\', \'P\': \'7\', \'Q\': \'7\', \'R\': \'7\', \'S\': \'7\', \'T\': \'8\', \'U\': \'8\', \'V\': \'8\', \'W\': \'9\', \'X\': \'9\', \'Y\': \'9\', \'Z\': \'9\' } decoded_number = [] for char in phone_number: if char.isalpha(): decoded_number.append(letter_to_digit[char.upper()]) else: decoded_number.append(char) return \'\'.join(decoded_number)"},{"question":"# Implementing a Basic E-commerce Cart System You are required to build a simplified e-commerce cart system. Users can add items to the cart, view the cart, and remove items from the cart. The items have an item code, name, price, and quantity. Your function should implement the following requirements: 1. Create a class `Cart` with the following methods: - `add_item(item_code: str, name: str, price: float, quantity: int = 1) -> None`: Adds an item to the cart or updates the quantity if the item already exists. - `remove_item(item_code: str, quantity: int = 1) -> None`: Removes an item or decreases the quantity of the item in the cart. If the quantity reduces to zero, the item should be removed. - `view_cart() -> list[tuple[str, str, float, int]]`: Returns a list of tuples with each tuple containing item code, name, price, and quantity of each item in the cart. - `total_cost() -> float`: Returns the total cost of items in the cart. The class signature should be: ```python class Cart: def __init__(self): Initializes an empty cart. def add_item(self, item_code: str, name: str, price: float, quantity: int = 1) -> None: Adds an item to the cart or updates the quantity if the item already exists. def remove_item(self, item_code: str, quantity: int = 1) -> None: Removes an item or decreases the quantity of the item in the cart. If the quantity reduces to zero, the item should be removed. def view_cart(self) -> list[tuple[str, str, float, int]]: Returns a list of tuples with each tuple containing item code, name, price, and quantity of each item in the cart. def total_cost(self) -> float: Returns the total cost of items in the cart. ``` Input: - None, as this is a class-based implementation. Output: - `add_item`: Adds the item to the cart; does not return anything. - `remove_item`: Removes or decreases the quantity of the item in the cart; does not return anything. - `view_cart`: Returns a list of tuples containing item code, name, price, and quantity of each item in the cart. - `total_cost`: Returns the total cost of the items in the cart. Constraints: - Prices are non-negative floats. - Quantities are non-negative integers. - Removing an item that does not exist or reducing the quantity below zero should do nothing. Example: ```python cart = Cart() cart.add_item(\\"001\\", \\"Apple\\", 0.5, 5) cart.add_item(\\"002\\", \\"Banana\\", 0.2, 10) cart.remove_item(\\"001\\", 2) print(cart.view_cart()) # -> [(\\"001\\", \\"Apple\\", 0.5, 3), (\\"002\\", \\"Banana\\", 0.2, 10)] print(cart.total_cost()) # -> 4.5 cart.remove_item(\\"001\\", 3) print(cart.view_cart()) # -> [(\\"002\\", \\"Banana\\", 0.2, 10)] print(cart.total_cost()) # -> 2.0 cart.remove_item(\\"002\\", 15) # Removing more than existing quantity print(cart.view_cart()) # -> [] print(cart.total_cost()) # -> 0.0 ``` Additional Notes: Ensure you handle cases where removal attempts to reduce the quantity below zero gracefully. Keep the implementation efficient and straightforward, checking for key existence when adding and removing items. Good luck!","solution":"class Cart: def __init__(self): Initializes an empty cart. self.items = {} def add_item(self, item_code: str, name: str, price: float, quantity: int = 1) -> None: Adds an item to the cart or updates the quantity if the item already exists. if item_code in self.items: self.items[item_code][\'quantity\'] += quantity else: self.items[item_code] = {\'name\': name, \'price\': price, \'quantity\': quantity} def remove_item(self, item_code: str, quantity: int = 1) -> None: Removes an item or decreases the quantity of the item in the cart. If the quantity reduces to zero, the item should be removed. if item_code in self.items: current_quantity = self.items[item_code][\'quantity\'] if current_quantity <= quantity: del self.items[item_code] else: self.items[item_code][\'quantity\'] -= quantity def view_cart(self) -> list: Returns a list of tuples with each tuple containing item code, name, price, and quantity of each item in the cart. return [(item_code, item_data[\'name\'], item_data[\'price\'], item_data[\'quantity\']) for item_code, item_data in self.items.items()] def total_cost(self) -> float: Returns the total cost of items in the cart. total = 0.0 for item_data in self.items.values(): total += item_data[\'price\'] * item_data[\'quantity\'] return total"},{"question":"# Problem Description You are working on a software that needs to manage a collection of messages. Each message has a unique identifier and a timestamp indicating when it was received. There is a requirement to sort the messages in chronological order to be processed correctly. # Your Task Implement a function to sort a list of messages by their timestamps in ascending order. Each message is represented as a dictionary with the following keys: - `id` (a unique identifier for the message, string) - `timestamp` (time when the message was received, string in the format \\"YYYY-MM-DD HH:MM:SS\\") # Input Your function will take one parameter: 1. `messages` (a list of dictionaries): Each dictionary represents a message and has the keys `id` and `timestamp`. # Output Your function should return a list of message ids sorted by their timestamps in ascending order. # Constraints * Each `id` is a unique string with a maximum length of 15 characters. * The `timestamp` is a string formatted as \\"YYYY-MM-DD HH:MM:SS\\". * The list `messages` will contain at most 1000 messages. # Example ```python messages = [ {\\"id\\": \\"msg1\\", \\"timestamp\\": \\"2023-09-12 08:00:00\\"}, {\\"id\\": \\"msg2\\", \\"timestamp\\": \\"2022-05-01 12:30:45\\"}, {\\"id\\": \\"msg3\\", \\"timestamp\\": \\"2023-01-15 00:00:00\\"}, ] ``` * Expected Output: `[\\"msg2\\", \\"msg3\\", \\"msg1\\"]` # Function Signature ```python from typing import List def sort_messages_by_timestamp(messages: List[dict]) -> List[str]: pass # You might include the following example usage if __name__ == \\"__main__\\": messages = [ {\\"id\\": \\"msg1\\", \\"timestamp\\": \\"2023-09-12 08:00:00\\"}, {\\"id\\": \\"msg2\\", \\"timestamp\\": \\"2022-05-01 12:30:45\\"}, {\\"id\\": \\"msg3\\", \\"timestamp\\": \\"2023-01-15 00:00:00\\"}, ] print(sort_messages_by_timestamp(messages)) # Should return [\'msg2\', \'msg3\', \'msg1\'] ```","solution":"from typing import List def sort_messages_by_timestamp(messages: List[dict]) -> List[str]: Sorts a list of messages by their timestamps in ascending order. :param messages: List of dictionaries each containing \'id\' and \'timestamp\' :return: List of message ids sorted by their timestamps in ascending order # Sort the messages by their timestamp using sorted() with key as timestamp sorted_messages = sorted(messages, key=lambda x: x[\'timestamp\']) # Extract the ids from the sorted messages sorted_ids = [message[\'id\'] for message in sorted_messages] return sorted_ids"},{"question":"# Problem Statement Create a function `integer_palindromes(a: int, b: int) -> int` that counts the number of palindromic integers within a given range [a, b] inclusive. A palindromic integer is an integer that remains the same when its digits are reversed. # Function Specifications - **Input**: Two integers `a` and `b` where `1 <= a <= b <= 10^6`. - **Output**: An integer representing the count of palindromic numbers in the inclusive range [a, b]. - **Constraints**: Raise a `ValueError` if `a` or `b` are not within the specified range or if `a > b`. # Example ```python def integer_palindromes(a: int, b: int) -> int: if not (1 <= a <= 10**6) or not (1 <= b <= 10**6) or a > b: raise ValueError(\\"Input integers must be within the range 1 <= a <= b <= 10^6 and a <= b\\") count = 0 for num in range(a, b + 1): if str(num) == str(num)[::-1]: count += 1 return count ``` **Example Usage** ```python print(integer_palindromes(1, 10)) # Output: 9 print(integer_palindromes(100, 200)) # Output: 10 print(integer_palindromes(1000, 1100)) # Output: 10 ``` **Explanation** - In the first example, palindromes between 1 and 10 are: 1, 2, 3, 4, 5, 6, 7, 8, 9. - In the second example, palindromes between 100 and 200 are: 101, 111, 121, 131, 141, 151, 161, 171, 181, 191. - In the third example, palindromes between 1000 and 1100 are: 1001, 1111, 1221, 1331, 1441, 1551, 1661, 1771, 1881, 1991.","solution":"def integer_palindromes(a: int, b: int) -> int: Counts the number of palindromic integers within a given range [a, b] inclusive. A palindromic integer is an integer that remains the same when its digits are reversed. Args: - a (int): The start of the range, inclusive. - b (int): The end of the range, inclusive. Returns: - int: The count of palindromic integers within the range. Raises: - ValueError: If the input integers are not within the specified range or if a > b. if not (1 <= a <= 10**6) or not (1 <= b <= 10**6) or a > b: raise ValueError(\\"Input integers must be within the range 1 <= a <= b <= 10^6 and a <= b\\") def is_palindrome(n: int) -> bool: s = str(n) return s == s[::-1] count = 0 for num in range(a, b + 1): if is_palindrome(num): count += 1 return count"},{"question":"# Coding Assessment Question You are to implement a function to determine if two given strings are one edit away from being identical. There are three potential types of edits: 1. Inserting a single character anywhere in the string. 2. Deleting a single character from anywhere in the string. 3. Replacing a single character anywhere in the string. Task Write a function `one_edit_away(s1: str, s2: str) -> bool`, which given two strings, determines if they are one edit (or zero edits) away from being the same. Input * `s1` and `s2` are two strings of arbitrary lengths. Output * Returns `True` if the strings are one edit (or zero edits) away from each other, otherwise `False`. Example ```python assert one_edit_away(\\"pale\\", \\"ple\\") == True assert one_edit_away(\\"pales\\", \\"pale\\") == True assert one_edit_away(\\"pale\\", \\"bale\\") == True assert one_edit_away(\\"pale\\", \\"bake\\") == False ``` Constraints * The input strings will contain only alphabetic characters. * Consider the time complexity with respect to comparing lengths and character positions in the two strings. Notes * Pay special attention to cases of string lengths and different positions where edits might occur. The solution should efficiently handle all possible types of edits.","solution":"def one_edit_away(s1: str, s2: str) -> bool: Returns True if s1 and s2 are one edit or zero edits away from being the same, otherwise False. len1, len2 = len(s1), len(s2) if abs(len1 - len2) > 1: return False # If lengths are the same, check for replacements if len1 == len2: found_difference = False for i in range(len1): if s1[i] != s2[i]: if found_difference: return False found_difference = True return True # If lengths differ by one, check for insertions/deletions if len1 < len2: s1, s2 = s2, s1 # Ensure s1 is the longer string index1 = index2 = 0 found_difference = False while index1 < len(s1) and index2 < len(s2): if s1[index1] != s2[index2]: if found_difference: return False found_difference = True index1 += 1 # Skip the extra character in the longer string else: index1 += 1 index2 += 1 return True"},{"question":"# Most Frequent Character in String You are tasked with finding the most frequent character in a given string. If there are multiple characters with the same maximum frequency, return the lexicographically smallest one. **Problem Statement**: Given a string, find the character that appears most frequently. If multiple characters have the same highest frequency, return the one that comes first in alphabetical order. Write a function named `most_frequent_character` that accepts a string `s` and returns the most frequent character in the string. # Function Signature ```python def most_frequent_character(s: str) -> str: ``` # Input - A string `s` (1 ≤ len(s) ≤ 100000) consisting of lowercase English letters. # Output - A character (a single byte) representing the most frequent character in the given string. # Constraints 1. The function should be optimized for performance. 2. Handle edge cases such as when all characters are unique or when multiple characters have the same frequency. # Examples 1. **Input**: `s = \\"apple\\"` - **Output**: `p` 2. **Input**: `s = \\"banana\\"` - **Output**: `a` 3. **Input**: `s = \\"character\\"` - **Output**: `c` 4. **Input**: `s = \\"mississippi\\"` - **Output**: `i` # Explanation - For a string \\"apple\\", the character \'p\' appears most frequently (2 times). - For a string \\"banana\\", the character \'a\' appears most frequently (3 times). - For a string \\"character\\", both \'c\' and \'a\' appear twice, so \'a\' is chosen as it is lexicographically smaller. - For a string \\"mississippi\\", \'i\' appears most frequently (4 times).","solution":"def most_frequent_character(s: str) -> str: from collections import Counter # Get the frequency of each character in the string frequency = Counter(s) # Find the character with the highest frequency most_frequent = max(frequency.items(), key=lambda item: (item[1], -ord(item[0]))) return most_frequent[0]"},{"question":"# Problem Statement You are tasked with designing an efficient system to process large files by splitting them into smaller, more manageable chunks. This is particularly useful for distributed computing environments where tasks need to be processed in parallel. Your objective is to implement a function that splits a given file into specified chunk sizes and saves these chunks as separate files. Additionally, your function should return metadata about the chunking process which includes the total number of chunks created and their respective sizes. # Instructions 1. Write a function `split_file` that splits a given file into smaller chunks. 2. The function should take the following parameters: * `file_path`: Path to the original file. * `chunk_size`: Maximum size (in bytes) of each chunk. 3. For each chunk created, the function should: * Save the chunk as a new file with a name pattern `originalfilename_chunkN.extension` (e.g., if the original file is `data.txt`, chunks should be named `data_chunk1.txt`, `data_chunk2.txt`, etc.). * Store information about each chunk size in a metadata list. 4. The function should return a tuple containing: * The total number of chunks created. * A list of tuples where each tuple contains the chunk number and the corresponding chunk size. # Function Signature ```python def split_file(file_path: str, chunk_size: int) -> tuple[int, list[tuple[int, int]]]: pass ``` # Input * `file_path`: The path to the original file (str). * `chunk_size`: The maximum size of each chunk in bytes (int). # Output * A tuple containing: * The total number of chunks created (int). * A list of tuples containing chunk number (int) and chunk size (int). # Example Assume that `example.txt` is a text file of 162 bytes. ```python >>> result = split_file(\\"example.txt\\", chunk_size=50) >>> total_chunks, metadata = result >>> total_chunks 4 >>> metadata [(1, 50), (2, 50), (3, 50), (4, 12)] ``` # Constraints * Ensure that the function handles cases where the file size is smaller than the chunk size. * The function should raise `FileNotFoundError` if the specified file does not exist. * Efficient handling of large files is crucial, so avoid loading the entire file into memory if it\'s very large. # Notes - Preserve the original file content while splitting into chunks. - Do not alter the content within each chunk. - Handle potential I/O errors gracefully and ensure resource cleanup (e.g., closing open file handles).","solution":"import os def split_file(file_path: str, chunk_size: int) -> tuple[int, list[tuple[int, int]]]: if not os.path.isfile(file_path): raise FileNotFoundError(f\\"The file {file_path} does not exist.\\") total_chunks = 0 metadata = [] file_base = os.path.splitext(file_path)[0] file_ext = os.path.splitext(file_path)[1] chunk_num = 1 with open(file_path, \'rb\') as f: while True: chunk_data = f.read(chunk_size) if not chunk_data: break chunk_filename = f\\"{file_base}_chunk{chunk_num}{file_ext}\\" with open(chunk_filename, \'wb\') as chunk_file: chunk_file.write(chunk_data) chunk_size_written = len(chunk_data) metadata.append((chunk_num, chunk_size_written)) total_chunks += 1 chunk_num += 1 return total_chunks, metadata"},{"question":"# Implementing AVL Tree Operations You are required to implement certain operations of an AVL Tree, a type of self-balancing binary search tree. The AVL Tree ensures that the tree remains balanced after each insertion or deletion, using rotations to maintain the balance. This implementation must support operations for insertion, deletion, and retrieving the height of the tree. **Objective**: Implement the following operations for an AVL Tree: 1. **Insertion**: Insert a new value into the AVL Tree. 2. **Deletion**: Delete a value from the AVL Tree. 3. **Height Calculation**: Return the height of the AVL Tree. **Detailed Instructions**: 1. **Insert Operation** - Implement the method `insert(self, val)` in the `AVLTree` class. - This method should insert the value `val` into the tree maintaining the AVL property. - After insertion, perform necessary rotations to keep the tree balanced. 2. **Delete Operation** - Implement the method `delete(self, val)` in the `AVLTree` class. - The method should delete the value `val` from the tree maintaining the AVL property. - After deletion, perform necessary rotations to keep the tree balanced. 3. **Height Calculation** - Implement the method `get_height(self)` in the `AVLTree` class. - This method should return the height of the tree, where height is defined as the number of edges on the longest path from the root to a leaf node. Here is the structure of the `AVLNode` class and `AVLTree` class (already provided): ```python class AVLNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self, root=None): self.root = root def insert(self, key): # Logic for insertion pass def delete(self, key): # Logic for deletion pass def _get_balance(self, node): # Utility method to get balance factor of node pass def _rotate_left(self, z): # Utility method for left rotation pass def _rotate_right(self, y): # Utility method for right rotation pass def get_height(self): # Utility method for height calculation pass ``` **Constraints**: 1. Ensure the tree remains balanced after each insert or delete operation. 2. The implemented methods should handle cases where the tree is empty or the value is not found (for deletion). **Examples**: ```python # Insert and Get Height avl_tree = AVLTree() avl_tree.insert(10) avl_tree.insert(20) avl_tree.insert(30) assert avl_tree.get_height() == 2 # Deletion Operation avl_tree.delete(20) assert avl_tree.get_height() == 1 # Balanced after insertions avl_tree.insert(25) avl_tree.insert(15) assert avl_tree.get_height() == 2 assert avl_tree.root.key == 25 ```","solution":"class AVLNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self, root=None): self.root = root def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return AVLNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) # Left Left if balance > 1 and key < node.left.key: return self._rotate_right(node) # Right Right if balance < -1 and key > node.right.key: return self._rotate_left(node) # Left Right if balance > 1 and key > node.left.key: node.left = self._rotate_left(node.left) return self._rotate_right(node) # Right Left if balance < -1 and key < node.right.key: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left min_larger_node = self._get_min(node.right) node.key = min_larger_node.key node.right = self._delete(node.right, min_larger_node.key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) # Left Left if balance > 1 and self._get_balance(node.left) >= 0: return self._rotate_right(node) # Left Right if balance > 1 and self._get_balance(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) # Right Right if balance < -1 and self._get_balance(node.right) <= 0: return self._rotate_left(node) # Right Left if balance < -1 and self._get_balance(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def get_height(self): return self._get_height(self.root) - 1 def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rotate_right(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) return x def _get_min(self, node): current = node while current.left: current = current.left return current"},{"question":"# Problem Statement You are given an integer array `arr` of size `n`. Your task is to implement a function that checks if there exists a pair of distinct indices (i, j) such that the absolute difference between the elements at these indices is equal to a given integer `k`. The provided function, `pair_exists`, implements a basic nested loop method to solve this problem. Your task is to optimize this function to handle larger inputs efficiently. # Requirements: 1. Implement an optimized function named `optimized_pair_exists` that takes an array `arr` and an integer `k`, and returns a boolean indicating whether such a pair exists. 2. Ensure the function handles edge cases, including arrays with less than two elements, appropriately by ensuring no unnecessary computations are made. 3. The solution must improve upon the basic nested loop approach in terms of time complexity, ideally targeting a linear rather than quadratic time complexity. # Input Format: 1. An integer array `arr` of size `n`, where `n >= 0`. 2. An integer `k` where `k >= 0`. # Output Format: 1. A boolean value (`True` or `False`) that indicates if a pair with the given condition exists. # Constraints: 1. 0 <= n <= 10^5 2. -10^9 <= arr[i] <= 10^9 3. 0 <= k <= 10^9 # Example: ```python >>> optimized_pair_exists([1, 5, 3, 4, 2], 2) True >>> optimized_pair_exists([1, 5, 3, 4, 2], 6) False >>> optimized_pair_exists([1, 3, 3, 4, 2], 0) True ``` Note: * Implement your function considering all possible edge cases. * Your solution will be tested on large inputs to ensure its efficiency and correctness.","solution":"def optimized_pair_exists(arr, k): Checks if there exists a pair of distinct indices (i, j) such that the absolute difference between the elements at these indices is equal to k. Args: arr (list of int): The list of integers. k (int): The target absolute difference. Returns: bool: True if such a pair exists, False otherwise. if len(arr) < 2: return False seen = set() for number in arr: if (number + k) in seen or (number - k) in seen: return True seen.add(number) return False"},{"question":"# Question Description You are given a list of strings and a list of queries. For each query, you need to determine if the query is a substring of any string in the list. Implement a function to perform this task efficiently using a Trie data structure. Function Signature ```python def substring_search(strings: list, queries: list) -> list: ... ``` Input - `strings`: A list of strings, where each string has at most 100 characters. - `queries`: A list of queries, where each query is a string with at most 25 characters. Output - A list of booleans, where each boolean corresponds to a query. `True` if the query is a substring of any string in the list, `False` otherwise. Constraints - The `strings` list will have at most 10^3 strings. - The `queries` list will have at most 10^3 queries. Example ```python strings = [\\"abracadabra\\", \\"alligator\\", \\"brazilian\\"] queries = [\\"cad\\", \\"gat\\", \\"br\\"] output = substring_search(strings, queries) print(output) # Expected Output: [True, True, True] ``` Performance Requirements Your solution should handle the edge cases effectively, including: - Large input sizes - Strings with overlapping substrings - Queries that are longer than some strings Implement this with maximum efficiency in terms of both time and space complexity.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return True def build_suffix_trie(strings): trie = Trie() for string in strings: # Insert all suffixes of each string for i in range(len(string)): suffix = string[i:] trie.insert(suffix) return trie def substring_search(strings, queries): # Build a suffix trie from the strings trie = build_suffix_trie(strings) result = [] for query in queries: result.append(trie.search(query)) return result"},{"question":"# Coding Assessment Question: Implementing a Custom Absolute Value Function Context Understanding how to work with numbers and their properties is a fundamental skill in programming. The absolute value function is often used in various applications, including statistical analysis, optimization problems, and graphical computations. This exercise will help you demonstrate a solid understanding of arithmetic operations by implementing a custom version of the absolute value function. Problem Statement Write a function `absolute_value(x: float) -> float` that returns the absolute value of a floating-point number `x`. The absolute value of a number is its non-negative value without regard to its sign. Input and Output * The input will be a floating-point number `x`. * The output should be a floating-point number which is the absolute value of `x`. Constraints * The input value `x` will be a valid floating-point number within the range of -10^6 to 10^6. * Do not use any external libraries or built-in functions such as `abs`. Edge Cases * Consider how to handle negative numbers, zero, and very small floating-point numbers. * Ensure the implementation is efficient with O(1) time complexity. Example ```python def absolute_value(x: float) -> float: Return the absolute value of x. :param x: the number :return: the non-negative absolute value of x. >>> absolute_value(1.1) 1.1 >>> absolute_value(-1.1) 1.1 >>> absolute_value(0.0) 0.0 >>> absolute_value(-0.0) 0.0 >>> absolute_value(-10**6) 1000000.0 >>> absolute_value(10**6) 1000000.0 pass ``` Implement the function and ensure it passes all the provided tests.","solution":"def absolute_value(x: float) -> float: Return the absolute value of x. :param x: the number :return: the non-negative absolute value of x. return x if x >= 0 else -x"},{"question":"# Statistical Data Aggregation Scenario A company collects real-time sensor readings from multiple devices deployed in manufacturing plants. Each device provides a series of readings throughout the day. The company wants to summarize these readings to help in various analyses and to monitor the performance of their devices. Each sensor reading consists of a timestamp and a value. Your task is to calculate the average reading for each device over the specified period and identify any devices with unusually high readings. Task Implement a function `aggregate_sensor_data` that calculates the average reading for each device and identifies any device with readings above a specified threshold. Function Signature ```python def aggregate_sensor_data(sensor_data: dict[str, list[tuple[str, float]]], threshold: float) -> dict[str, dict[str, float]]: pass ``` Parameters - `sensor_data (dict[str, list[tuple[str, float]]])`: A dictionary where the key is the device ID and the value is a list of tuples, each containing a timestamp (string) and a reading (float). - `threshold (float)`: A value above which any reading is considered unusually high. Returns - A dictionary where each key is a device ID, and the value is another dictionary containing: - The average reading (\'avg\') for that device. - The count of readings above the threshold (\'high_readings\'). Constraints - Each device will have at least one reading. - The timestamp is given in the format \'YYYY-MM-DD HH:MM:SS\' and can be ignored for the purpose of calculations. - If a device has no unusually high readings, its \'high_readings\' count should be 0. Examples - `aggregate_sensor_data({\'device_1\': [(\'2023-10-01 10:00:00\', 5.0), (\'2023-10-01 11:00:00\', 7.0)], \'device_2\': [(\'2023-10-01 10:00:00\', 12.0), (\'2023-10-01 11:00:00\', 15.0)]}, 10.0)` should return ```python { \'device_1\': {\'avg\': 6.0, \'high_readings\': 0}, \'device_2\': {\'avg\': 13.5, \'high_readings\': 2} } ``` - `aggregate_sensor_data({\'device_1\': [(\'2023-10-01 10:00:00\', 9.0)]}, 10.0)` should return ```python { \'device_1\': {\'avg\': 9.0, \'high_readings\': 0} } ``` - `aggregate_sensor_data({\'device_1\': [(\'2023-10-01 10:00:00\', 9.0), (\'2023-10-01 12:00:00\', 11.0)]}, 10.0)` should return ```python { \'device_1\': {\'avg\': 10.0, \'high_readings\': 1} } ```","solution":"def aggregate_sensor_data(sensor_data: dict[str, list[tuple[str, float]]], threshold: float) -> dict[str, dict[str, float]]: result = {} for device_id, readings in sensor_data.items(): total = 0.0 count = 0 high_readings_count = 0 for timestamp, value in readings: total += value count += 1 if value > threshold: high_readings_count += 1 average = total / count if count != 0 else 0.0 result[device_id] = {\'avg\': average, \'high_readings\': high_readings_count} return result"},{"question":"# Coding Assessment: Analyze Product Sales Data Objective You are required to write Python functions to analyze sales data for a given product within a specific date range. The data is provided in the form of an API endpoint, and your solution should efficiently fetch, process, and summarize sales data while handling potential errors gracefully. Requirements 1. **Function 1: `fetch_sales_data(product_id: str, start_date: str, end_date: str) -> list`** - Input: - A string representing the product ID. - A string representing the start date in the format \'YYYY-MM-DD\'. - A string representing the end date in the format \'YYYY-MM-DD\'. - Output: - A list of dictionaries containing the raw sales data fetched from the API within the specified date range. - Constraints: - The `product_id` input should be a valid string. - The date inputs should be valid and in the correct format. - If the data cannot be fetched, return an appropriate error message. 2. **Function 2: `summarize_sales_data(sales_data: list) -> dict`** - Input: - A list of dictionaries containing raw sales data. - Output: - A dictionary containing a summary of the sales data including: - Total Sales - Total Revenue - Number of Transactions - Average Sale Amount - Top 3 Dates by Sales Performance Requirements - Your solution should handle large data efficiently. - Consider handling any API delays or errors gracefully without breaking the program flow. Example ```python >>> sales_data = fetch_sales_data(\\"12345\\", \\"2023-01-01\\", \\"2023-01-31\\") >>> summary = summarize_sales_data(sales_data) >>> print(summary) { \\"Total Sales\\": 200, \\"Total Revenue\\": 3000.0, \\"Number of Transactions\\": 150, \\"Average Sale Amount\\": 20.0, \\"Top 3 Dates by Sales\\": [\\"2023-01-15\\", \\"2023-01-20\\", \\"2023-01-25\\"] } ``` Notes 1. Pay attention to possible API restrictions and handle them properly using appropriate error messages. 2. Make sure that your summarization handles missing data gracefully and include default values where necessary. 3. Ensure date values are properly validated. Constraints - The `product_id` should be a non-empty string. - Dates should be valid and in the format \'YYYY-MM-DD\'. - Handle timeout scenarios and missing data fields properly.","solution":"import requests from datetime import datetime from collections import defaultdict def fetch_sales_data(product_id: str, start_date: str, end_date: str) -> list: Fetches sales data from API within a specified date range. Args: - product_id: str, product ID - start_date: str, start date in \'YYYY-MM-DD\' format - end_date: str, end date in \'YYYY-MM-DD\' format Returns: - list: List of dictionaries containing raw sales data url = f\\"http://api.example.com/sales?product_id={product_id}&start_date={start_date}&end_date={end_date}\\" try: response = requests.get(url) response.raise_for_status() # Raises an HTTPError if the HTTP request returned an unsuccessful status code. return response.json() except requests.exceptions.RequestException as e: print(f\\"Error fetching sales data: {e}\\") return [] def summarize_sales_data(sales_data: list) -> dict: Summarizes the sales data by calculating total sales, total revenue, number of transactions, average sale amount, and top 3 dates by sales. Args: - sales_data: list, list of dictionaries containing raw sales data Returns: - dict: Summary dictionary total_sales = 0 total_revenue = 0.0 transactions_count = 0 sales_by_date = defaultdict(int) for record in sales_data: if \\"sale_amount\\" in record: sale_amount = record[\\"sale_amount\\"] date = record[\\"date\\"] total_sales += sale_amount total_revenue += sale_amount transactions_count += 1 sales_by_date[date] += sale_amount average_sale_amount = total_revenue / transactions_count if transactions_count > 0 else 0 top_3_dates_by_sales = sorted(sales_by_date.items(), key=lambda x: x[1], reverse=True)[:3] return { \\"Total Sales\\": total_sales, \\"Total Revenue\\": total_revenue, \\"Number of Transactions\\": transactions_count, \\"Average Sale Amount\\": average_sale_amount, \\"Top 3 Dates by Sales\\": [date for date, _ in top_3_dates_by_sales] }"},{"question":"# Context In a binary search tree (BST), each node has at most two children (left and right), with left child nodes having values less than the parent node and right child nodes having values greater than the parent node. You are tasked with writing a function to return the second largest element in a given BST. # Function Implementation You need to implement the function `find_second_largest`: ```python class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def find_second_largest(root): Find the second largest element in the Binary Search Tree. Args: root (TreeNode): The root node of the BST. Returns: int or None: The second largest element in the BST, or None if it does not exist. Example: >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(25) >>> find_second_largest(root) 20 pass ``` * **Input Format**: - `root`: A TreeNode object representing the root of the binary search tree. * **Output Format**: - An integer representing the second largest element in the BST, or `None` if it does not exist. * **Constraints**: - The number of nodes in the BST is at most `1000`. # Examples ```python # Example 1 - Using the provided example in the docstring root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(25) print(find_second_largest(root)) # Output: 20 # Example 2 - BST with only one node root = TreeNode(10) print(find_second_largest(root)) # Output: None # Example 3 - BST with two nodes root = TreeNode(10) root.right = TreeNode(20) print(find_second_largest(root)) # Output: 10 ``` # Additional Notes * Consider edge cases where the tree has less than two nodes. * Ensure that the function handles typical BST nodes, including both left and right children scenarios.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def find_second_largest(root): Find the second largest element in the Binary Search Tree. Args: root (TreeNode): The root node of the BST. Returns: int or None: The second largest element in the BST, or None if it does not exist. if not root or (not root.left and not root.right): return None def find_largest(node): while node.right: node = node.right return node # Start from the root and look for the second largest current = root while current: # Case 1: Current has a right child, and the right child has no children if current.right and not current.right.left and not current.right.right: return current.val # Case 2: Current has no right child, so the largest is in the left subtree if not current.right: return find_largest(current.left).val # Move to the right child current = current.right"},{"question":"# Data Compression Algorithm You are tasked with implementing a function to compress a given string using the Run-Length Encoding (RLE) algorithm, which represents consecutive repeated characters as a single character followed by the number of times it is repeated. Function Signature ```python def run_length_encoding(input_string: str) -> str: pass ``` Objective Write a function `run_length_encoding` that takes an input string and returns a compressed string where each sequence of the form `aaa` is represented as `a3`. If a character appears only once, it is represented as `a1`. Input * `input_string` (str): The string to be compressed. (1 <= len(input_string) <= 10^6) Output * `str`: A compressed string using the Run-Length Encoding algorithm. Constraints * The input string consists of printable ASCII characters. Examples ```python assert run_length_encoding(\\"aaabbbbcc\\") == \\"a3b4c2\\" assert run_length_encoding(\\"aabb\\") == \\"a2b2\\" assert run_length_encoding(\\"abc\\") == \\"a1b1c1\\" ``` Notes: * Consider edge cases where the input string consists of a single character, repeated characters, or unique characters. * Ensure the function handles both uppercase and lowercase characters correctly. Good luck!","solution":"def run_length_encoding(input_string: str) -> str: Compresses the input string using Run-Length Encoding (RLE). Parameters: input_string (str): The string to be compressed. Returns: str: The compressed string using RLE. if not input_string: return \\"\\" compressed_parts = [] current_char = input_string[0] current_count = 1 for char in input_string[1:]: if char == current_char: current_count += 1 else: compressed_parts.append(f\\"{current_char}{current_count}\\") current_char = char current_count = 1 compressed_parts.append(f\\"{current_char}{current_count}\\") return \'\'.join(compressed_parts)"},{"question":"# Coding Challenge: Book Library Management Your task is to design a Python script that manages a collection of books in a library. You need to implement functions to add, remove, search, and list books, ensuring proper handling of different scenarios. Function Signatures ```python class Library: def __init__(self): Initialize the library with an empty collection of books. def add_book(self, title: str, author: str, year: int) -> str: Add a new book to the library collection. Args: title (str): The title of the book. author (str): The author of the book. year (int): The publication year of the book. Returns: str: A success message indicating the book was added. def remove_book(self, title: str) -> str: Remove a book from the library collection by its title. Args: title (str): The title of the book to be removed. Returns: str: A success message indicating the book was removed, or an error message if the book was not found. def search_book(self, title: str) -> dict: Search for a book in the library collection by its title. Args: title (str): The title of the book to be searched. Returns: dict: The details of the book (title, author, year), or an error message if the book was not found. def list_books(self) -> list: List all the books in the library collection. Returns: list: A list of dictionaries, each containing the details of a book (title, author, year). ``` # Instructions 1. **Adding Books**: - Implement `add_book` to add a new book to the library collection. Ensure that the same book (by title) cannot be added multiple times. 2. **Removing Books**: - Implement `remove_book` to remove a book from the collection by its title. If the book is not found, the function should return an appropriate error message. 3. **Searching Books**: - Implement `search_book` to search for a book by its title. If found, return the book\'s details; otherwise, return an error message. 4. **Listing Books**: - Implement `list_books` to return a comprehensive list of all books in the collection, sorted alphabetically by title. 5. **Error Handling**: - Handle errors properly, such as attempts to add a book that already exists, remove a nonexistent book, or search for a book that\'s not in the collection. 6. **Testing**: - Write tests to cover various scenarios, including adding, removing, searching, and listing books. Test edge cases like empty library, non-existent books, and duplicates. # Constraints - Assume that book titles are unique in the library. - The year must be a non-negative integer. ```python class Library: def __init__(self): self.collection = [] def add_book(self, title: str, author: str, year: int) -> str: for book in self.collection: if book[\'title\'] == title: return \\"Book already in library.\\" self.collection.append({\'title\': title, \'author\': author, \'year\': year}) return \\"Book added successfully.\\" def remove_book(self, title: str) -> str: for book in self.collection: if book[\'title\'] == title: self.collection.remove(book) return \\"Book removed successfully.\\" return \\"Book not found.\\" def search_book(self, title: str) -> dict: for book in self.collection: if book[\'title\'] == title: return book return {\\"Error\\": \\"Book not found.\\"} def list_books(self) -> list: return sorted(self.collection, key=lambda x: x[\'title\']) if __name__ == \\"__main__\\": library = Library() print(library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925)) print(library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925)) print(library.add_book(\\"1984\\", \\"George Orwell\\", 1949)) print(library.remove_book(\\"The Great Gatsby\\")) print(library.remove_book(\\"Invisible Man\\")) print(library.search_book(\\"1984\\")) print(library.search_book(\\"Brave New World\\")) print(library.list_books()) ``` # Example ```python >>> library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) \'Book added successfully.\' >>> library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) \'Book already in library.\' >>> library.remove_book(\\"Harry Potter\\") \'Book not found.\' >>> library.search_book(\\"To Kill a Mockingbird\\") {\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'year\': 1960} >>> library.list_books() [{\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'year\': 1960}] ``` Ensure your class methods handle the specified requirements and work efficiently.","solution":"class Library: def __init__(self): self.collection = [] def add_book(self, title: str, author: str, year: int) -> str: for book in self.collection: if book[\'title\'] == title: return \\"Book already in library.\\" self.collection.append({\'title\': title, \'author\': author, \'year\': year}) return \\"Book added successfully.\\" def remove_book(self, title: str) -> str: for book in self.collection: if book[\'title\'] == title: self.collection.remove(book) return \\"Book removed successfully.\\" return \\"Book not found.\\" def search_book(self, title: str) -> dict: for book in self.collection: if book[\'title\'] == title: return book return {\\"Error\\": \\"Book not found.\\"} def list_books(self) -> list: return sorted(self.collection, key=lambda x: x[\'title\'])"},{"question":"# Context The Quickselect algorithm is an efficient selection algorithm to find the k-th smallest (or largest) element in an unordered list. It is an in-place algorithm, essentially a partial sort that uses a divide-and-conquer approach similar to Quicksort. # Task Implement the Quickselect algorithm to find the k-th smallest element in an integer list. Your implementation should efficiently partition and select the desired element without sorting the entire list. # Function Signature ```python def quickselect(arr: List[int], k: int) -> int: pass ``` # Input - `arr` (List[int]): A list of integers to select from. - `k` (int): The index (0-based) of the k-th smallest element to find in the list. # Output - `int`: The k-th smallest element in the given list. # Constraints - 0 <= `k` < len(`arr`) - The list `arr` contains distinct integers. # Examples ```python >>> quickselect([3, 2, 1, 5, 4], 0) 1 >>> quickselect([10, 4, 5, 8, 6, 11, 26], 4) 10 >>> quickselect([7, 10, 4, 3, 20, 15], 3) 10 ``` # Additional Requirements - Raise a `ValueError` if `k` is outside the valid range with the message \\"k must be within the range of the list length\\". - Make efficient use of space and time complexity, leveraging the properties of the Quickselect algorithm.","solution":"from typing import List def quickselect(arr: List[int], k: int) -> int: def partition(left, right, pivot_index): pivot_value = arr[pivot_index] arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def select(left, right, k): if left == right: return arr[left] pivot_index = left + (right - left) // 2 pivot_index = partition(left, right, pivot_index) if k == pivot_index: return arr[k] elif k < pivot_index: return select(left, pivot_index - 1, k) else: return select(pivot_index + 1, right, k) if k < 0 or k >= len(arr): raise ValueError(\\"k must be within the range of the list length\\") return select(0, len(arr) - 1, k)"},{"question":"# Maximal Square in a Binary Grid Background You are given a binary grid of size `m x n` consisting of only 0\'s and 1\'s. Your task is to find the largest square containing only 1\'s and return its area. Task Implement a function `maximalSquare` that finds the largest square sub-matrix containing only 1\'s in a given binary grid and returns the area of that square. Function Signature ```python def maximalSquare(matrix: List[List[int]]) -> int: pass ``` Input - A 2D binary grid (list of lists), where each element is either 0 or 1. Output - An integer representing the area of the largest square sub-matrix containing only 1\'s. Example ```python # Example 1 matrix = [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ] assert maximalSquare(matrix) == 4 # The largest square contains four 1s and the area is 4. # Example 2 matrix = [ [0, 1], [1, 0] ] assert maximalSquare(matrix) == 1 # The largest square contains one 1 and the area is 1. # Example 3 matrix = [ [0] ] assert maximalSquare(matrix) == 0 # No square of 1s, area is 0. ``` Description A dynamic programming approach can be used to solve this problem efficiently. We can create a 2D list `dp` where `dp[i][j]` represents the size of the largest square whose bottom-right corner is at `(i, j)`. The value of `dp[i][j]` can be computed as: [ dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 ] if the cell `(i, j)` in the original matrix is `1`. If the cell is `0`, then `dp[i][j]` is also `0`. The size of the largest square found will be the maximum value in the `dp` table, and the area of that square is the square of the size. Constraints - The matrix dimensions `m` and `n` will not exceed 300. - Each matrix element is a binary value (0 or 1). Good luck!","solution":"from typing import List def maximalSquare(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) max_side = 0 # Create DP table with extra row and column dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if matrix[i - 1][j - 1] == 1: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"# Problem Description You are given a matrix of integers where each element in the matrix represents the cost of passing through that cell. The goal is to find the minimum cost path from the top-left corner of the matrix to the bottom-right corner. You can only move right or down from a given cell. # Function Signature ```python def min_path_cost(matrix: List[List[int]]) -> int: pass ``` # Input - `matrix`: A list of lists of integers where each inner list represents a row in the matrix and each integer within an inner list represents the cost of that cell. The dimensions of the matrix are guaranteed to be at least 1x1 and at most 1000x1000. # Output - An integer representing the minimum cost to move from the top-left corner to the bottom-right corner of the matrix. # Constraints - `1 ≤ matrix[i][j] ≤ 1000` for all `i, j` in the matrix. # Example ```python >>> min_path_cost([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 ``` Explanation: - The path with the minimum cost is 1 → 3 → 1 → 1 → 1 with a total cost of 7. # Notes - Use dynamic programming to solve the problem. - Create a DP table where `dp[i][j]` represents the minimum cost to reach cell `(i, j)`. - Initialize `dp[0][0]` with `matrix[0][0]`. - For each cell, compute `dp[i][j]` as `min(dp[i-1][j], dp[i][j-1]) + matrix[i][j]`. - The answer will be in `dp[-1][-1]`.","solution":"from typing import List def min_path_cost(matrix: List[List[int]]) -> int: rows = len(matrix) cols = len(matrix[0]) dp = [[0]*cols for _ in range(rows)] dp[0][0] = matrix[0][0] # Initialize the first column of the dp table for i in range(1, rows): dp[i][0] = dp[i-1][0] + matrix[i][0] # Initialize the first row of the dp table for j in range(1, cols): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill in the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[-1][-1]"},{"question":"Problem Description You are to implement a solution to convert a Binary Search Tree (BST) into a sorted doubly linked list in-place. This doubly linked list should maintain the same order as an in-order traversal of the BST. Each node in the BST has a left pointer, right pointer, and a value. You must update these pointers such that they function as the previous and next pointers in a doubly linked list, respectively. # Requirements - Implement a function to traverse the BST in-order and re-link the nodes to form a doubly linked list. - The left pointers of the nodes should be used as the \'previous\' pointers in the doubly linked list. - The right pointers of the nodes should be used as the \'next\' pointers in the doubly linked list. # Constraints - Node values will be unique. - The number of nodes in the tree will not exceed 10<sup>4</sup>. - Node values will be in the range -10<sup>5</sup> to 10<sup>5</sup>. # Input The input to the function will be the root node of the BST. The structure of a node is defined as follows: ```python class TreeNode: def __init__(self, value: int, left: TreeNode = None, right: TreeNode = None): self.value = value self.left = left self.right = right ``` # Output The function should return the head of the doubly linked list. The head is the node with the smallest value (first in in-order traversal). # Example Given the root of the BST: ``` 4 / 2 5 / 1 3 ``` The output should be the head of the doubly linked list: ``` 1 <-> 2 <-> 3 <-> 4 <-> 5 ``` # Implementation Details 1. **TreeNode Class**: - Ensure the tree node class has a constructor method as described. 2. **BST to Doubly Linked List Conversion**: - Implement the conversion function that processes the BST in-place to convert it to a doubly linked list. - Handle edge cases such as empty trees and single-node trees. # Code Template ```python class TreeNode: def __init__(self, value: int, left: TreeNode = None, right: TreeNode = None): self.value = value self.left = left self.right = right def bst_to_doubly_linked_list(root: TreeNode) -> TreeNode: Converts a BST to a sorted doubly linked list in-place. :param root: The root node of the BST :return: The head of the doubly linked list if not root: return None def convert(node): nonlocal last, head if node: convert(node.left) if last: last.right, node.left = node, last else: head = node last = node convert(node.right) last, head = None, None convert(root) return head # Example usage: root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(5)) head = bst_to_doubly_linked_list(root) # Verify the doubly linked list current = head while current: print(current.value, end=\\" \\") current = current.right # Should print: 1 2 3 4 5 ```","solution":"class TreeNode: def __init__(self, value: int, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.value = value self.left = left self.right = right def bst_to_doubly_linked_list(root: TreeNode) -> TreeNode: Converts a BST to a sorted doubly linked list in-place. :param root: The root node of the BST :return: The head of the doubly linked list if not root: return None def convert(node): nonlocal last, head if node: convert(node.left) if last: last.right, node.left = node, last else: head = node last = node convert(node.right) last, head = None, None convert(root) return head # Example usage: # root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(5)) # head = bst_to_doubly_linked_list(root) # # Verify the doubly linked list # current = head # while current: # print(current.value, end=\\" \\") # current = current.right # Should print: 1 2 3 4 5"},{"question":"# Question: Dynamic Programming and Graph Traversal Background: You are assigned a task to determine the minimum cost path in a grid where each cell has a different cost associated with moving through it. Your goal is to move from the top-left corner to the bottom-right corner of the grid with the least total cost. Problem Statement: Write a function `min_cost_path(grid: List[List[int]]) -> int` that performs the following: 1. **Grid Traversal**: Traverse the grid from the top-left corner to the bottom-right corner, moving only right or down at each step. 2. **Compute Minimum Cost**: Calculate the minimum cost required to travel from the top-left to the bottom-right of the grid. Input: * `grid`: A 2D list representing a grid of size m x n (1 ≤ m, n ≤ 100), where grid[i][j] is a non-negative integer representing the cost at cell (i, j). Output: * Return an integer representing the minimum cost path from the top-left to the bottom-right corner of the grid. Example: ```python Input: grid = [ [1, 3, 4], [2, 1, 3], [3, 2, 1] ] Output: 7 ``` Explanation: 1. Start at the top-left corner (1). 2. Traverse through the grid with the minimum cost path `[1, 3, 1, 2, 1]`. 3. The total minimum cost to reach the bottom-right corner is `1 + 3 + 1 + 2 + 1 = 8`. Constraints: - Ensure the input grid dimensions are correctly validated. - Handle edge cases such as grids with only one row or one column. --- Implement the function `min_cost_path(grid: List[List[int]]) -> int` in Python and provide an analysis of its complexity.","solution":"from typing import List def min_cost_path(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a 2D list to store the minimum cost to reach each cell dp = [[0]*n for _ in range(m)] # Initialize the dp grid dp[0][0] = grid[0][0] # Fill in the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill in the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the dp grid for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"# Problem Statement You are tasked with implementing a function that validates if a given string containing only brackets (`\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'`, `\']\'`) is valid. A string is considered valid if brackets are closed in the correct order with correct nesting. This validation must be performed using a stack data structure for optimal performance. # Function Signature ```python def is_valid_brackets(s: str) -> bool: ``` # Input * `s` (str): A string containing only the characters `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'`, `\']\'`. The length of the string `n` is in the range [0, 100]. # Output * `bool`: Returns `True` if the string is valid, otherwise returns `False`. # Constraints 1. The string can be empty or contain up to 100 characters. 2. The characters in the string will only be `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'`, and `\']\'`. # Examples 1. `is_valid_brackets(\\"()\\")` should return `True` 2. `is_valid_brackets(\\"()[]{}\\")` should return `True` 3. `is_valid_brackets(\\"(]\\")` should return `False` 4. `is_valid_brackets(\\"([)]\\")` should return `False` 5. `is_valid_brackets(\\"{[]}\\")` should return `True` # Requirements 1. Your solution should utilize a stack to efficiently check the validity of the string. 2. Handle the edge cases and validate correctly: - Empty string - Mixed types of brackets - Correctly nested brackets # Scenario Imagine you are developing a code editor that highlights syntax errors as developers type. Implementing this bracket validation function will ensure that your editor can immediately highlight mismatched or improperly nested brackets to the user. This can greatly assist in reducing syntax errors and improving code quality.","solution":"def is_valid_brackets(s: str) -> bool: Returns True if the input string s containing only brackets ( \'()\', \'{}\', \'[]\' ) is valid. A string is valid if brackets are closed in the correct order. stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in bracket_map: top_element = stack.pop() if stack else \'#\' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"# Context You are required to create a data structure that can efficiently categorize and query books in a library. Each book has a title, author, genre, and year of publication. Your task is to design and implement a class to store this information, provide methods to add new books, and query books based on different criteria efficiently. # Task Implement the `Library` class with methods to add books and query them by title, author, genre, and year of publication. Your solution should emphasize performance, particularly for the query operations. # Method Signatures ```python class Library: def __init__(self) -> None: Initializes an empty Library instance. pass def add_book(self, title: str, author: str, genre: str, year: int) -> None: Adds a new book to the library. Args: title (str): The title of the book. author (str): The author of the book. genre (str): The genre of the book. year (int): The year of publication of the book. pass def query_books_by_title(self, title: str) -> List[Dict[str, Any]]: Returns a list of books matching the specified title. Args: title (str): The title of the book(s) to query. Returns: List[Dict[str, Any]]: A list of dictionaries where each dictionary represents a book with matching title. pass def query_books_by_author(self, author: str) -> List[Dict[str, Any]]: Returns a list of books written by the specified author. Args: author (str): The author of the book(s) to query. Returns: List[Dict[str, Any]]: A list of dictionaries where each dictionary represents a book written by the specified author. pass def query_books_by_genre(self, genre: str) -> List[Dict[str, Any]]: Returns a list of books in the specified genre. Args: genre (str): The genre of the book(s) to query. Returns: List[Dict[str, Any]]: A list of dictionaries where each dictionary represents a book in the specified genre. pass def query_books_by_year(self, year: int) -> List[Dict[str, Any]]: Returns a list of books published in the specified year. Args: year (int): The publication year of the book(s) to query. Returns: List[Dict[str, Any]]: A list of dictionaries where each dictionary represents a book published in the specified year. pass ``` # Constraints - The Library should efficiently handle a large number of books. - Each query should return results quickly, even if the library contains thousands of books. - The `add_book` and each `query_books_by_*` method should have an average time complexity of O(1) to O(log n). - Methods should return lists of dictionaries with each dictionary containing `title`, `author`, `genre`, and `year` for books matching the query criteria. - Raising errors for invalid inputs is not mandatory but should be correctly handled if implemented. # Example Usage ```python library = Library() library.add_book(title=\\"To Kill a Mockingbird\\", author=\\"Harper Lee\\", genre=\\"Fiction\\", year=1960) library.add_book(title=\\"1984\\", author=\\"George Orwell\\", genre=\\"Dystopian\\", year=1949) library.add_book(title=\\"George\'s Marvelous Medicine\\", author=\\"Roald Dahl\\", genre=\\"Children\'s\\", year=1981) # Query by title print(library.query_books_by_title(\\"1984\\")) # Expected output: [{\'title\': \'1984\', \'author\': \'George Orwell\', \'genre\': \'Dystopian\', \'year\': 1949}] # Query by author print(library.query_books_by_author(\\"Harper Lee\\")) # Expected output: [{\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'genre\': \'Fiction\', \'year\': 1960}] # Query by genre print(library.query_books_by_genre(\\"Children\'s\\")) # Expected output: [{\'title\': \\"George\'s Marvelous Medicine\\", \'author\': \'Roald Dahl\', \'genre\': \\"Children\'s\\", \'year\': 1981}] # Query by year print(library.query_books_by_year(1960)) # Expected output: [{\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'genre\': \'Fiction\', \'year\': 1960}] ```","solution":"from typing import List, Dict, Any class Library: def __init__(self) -> None: self.books = [] self.books_by_title = {} self.books_by_author = {} self.books_by_genre = {} self.books_by_year = {} def add_book(self, title: str, author: str, genre: str, year: int) -> None: book = {\'title\': title, \'author\': author, \'genre\': genre, \'year\': year} self.books.append(book) if title not in self.books_by_title: self.books_by_title[title] = [] self.books_by_title[title].append(book) if author not in self.books_by_author: self.books_by_author[author] = [] self.books_by_author[author].append(book) if genre not in self.books_by_genre: self.books_by_genre[genre] = [] self.books_by_genre[genre].append(book) if year not in self.books_by_year: self.books_by_year[year] = [] self.books_by_year[year].append(book) def query_books_by_title(self, title: str) -> List[Dict[str, Any]]: return self.books_by_title.get(title, []) def query_books_by_author(self, author: str) -> List[Dict[str, Any]]: return self.books_by_author.get(author, []) def query_books_by_genre(self, genre: str) -> List[Dict[str, Any]]: return self.books_by_genre.get(genre, []) def query_books_by_year(self, year: int) -> List[Dict[str, Any]]: return self.books_by_year.get(year, [])"},{"question":"# Problem Statement A company uses task scheduling software to assign tasks to employees. Each task has a specific duration and a list of dependencies (other tasks that must be completed before the current task can begin). Your task is to determine the minimum time required to complete all tasks, given their durations and dependencies. Use a topological sorting approach to solve this problem. # Function Signature ```python def min_completion_time(n: int, durations: list[int], dependencies: list[list[int]]) -> int: :param n: the number of tasks (1 <= n <= 1000) :param durations: a list of integers where durations[i] is the duration of task i (0 <= durations[i] <= 1000) :param dependencies: a list of pairs where each pair [a, b] indicates that task b depends on task a :return: the minimum time required to complete all tasks Raises ValueError if the input criteria are not met (e.g., durations list length not equal to n or invalid task indices). ``` # Example ```python print(min_completion_time(5, [1, 2, 3, 4, 5], [[0, 1], [1, 2], [2, 3], [3, 4]])) # Expected output: 15 print(min_completion_time(3, [3, 2, 1], [[0, 1], [1, 2]])) # Expected output: 6 print(min_completion_time(4, [2, 2, 1, 3], [])) # Expected output: 3 ``` # Constraints * You can assume the following: - `n` is an integer in the range [1, 1000]. - `durations` is a list of integers with exactly `n` elements, where each element represents the duration of a task (0 <= durations[i] <= 1000). - `dependencies` is a list of pairs of integers where each pair [a, b] indicates that task b depends on task a. The indices `a` and `b` are valid if 0 <= a, b < n. * Your algorithm should aim to optimize the time and space complexity subject to the constraints provided. # Tasks 1. Implement validation to handle erroneous inputs. 2. Use a topological sorting approach to determine the order of task execution. 3. Calculate the total duration taking into account the dependency constraints. 4. Consider edge cases, such as no dependencies, cyclic dependencies, or inappropriate task indices. # Notes - Focus on ensuring correctness and efficiency. - Consider modularizing the problem using helper functions if necessary. - Handle cyclic dependencies as an invalid input case.","solution":"from collections import deque, defaultdict def min_completion_time(n: int, durations: list[int], dependencies: list[list[int]]) -> int: if len(durations) != n: raise ValueError(\\"durations list length is not equal to n\\") # Create an adjacency list for the graph adj_list = defaultdict(list) in_degree = [0] * n for dep in dependencies: a, b = dep if not (0 <= a < n) or not (0 <= b < n): raise ValueError(\\"Invalid task indices in dependencies\\") adj_list[a].append(b) in_degree[b] += 1 # Queue to perform the topological sort queue = deque() # Initialize the queue with all tasks that have no dependencies for i in range(n): if in_degree[i] == 0: queue.append(i) topo_order = [] while queue: current = queue.popleft() topo_order.append(current) for neighbor in adj_list[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(topo_order) != n: # If we could not add all tasks, there must be a cycle in the dependencies raise ValueError(\\"Graph has a cycle, cannot perform topological sort\\") # Compute the minimum completion time using dynamic programming task_time = [0] * n for node in topo_order: task_time[node] += durations[node] for neighbor in adj_list[node]: task_time[neighbor] = max(task_time[neighbor], task_time[node]) return max(task_time)"},{"question":"# Custom Dictionary Implementation **Context**: You are designing a custom data structure that acts similarly to a Python dictionary but with added constraints. Your custom dictionary should support basic operations such as insertion, deletion, and lookup, while also enabling retrieval of the smallest and largest keys efficiently. **Problem Statement**: Implement a `CustomDict` class with the following methods: `insert`, `delete`, `lookup`, `get_min_key`, and `get_max_key`. This data structure will use an internal balanced BST (binary search tree) or any appropriate data structure to maintain the elements. # Class Definition ```python class CustomDict: def __init__(self): self.data = {} # any additional initialization needed for BST or sorted structure def insert(self, key: int, value: any) -> None: pass def delete(self, key: int) -> None: pass def lookup(self, key: int) -> any: pass def get_min_key(self) -> int: pass def get_max_key(self) -> int: pass ``` # Methods - **insert(key: int, value: any) -> None**: Insert a (key, value) pair. If the key already exists, update the value. - **delete(key: int) -> None**: Remove the (key, value) pair. If the key does not exist, do nothing. - **lookup(key: int) -> any**: Return the value associated with the key. If the key does not exist, raise a KeyError. - **get_min_key() -> int**: Return the smallest key in the dictionary. If the dictionary is empty, raise a ValueError with a descriptive message. - **get_max_key() -> int**: Return the largest key in the dictionary. If the dictionary is empty, raise a ValueError with a descriptive message. # Constraints 1. The keys are integers. 2. The values can be of any type. 3. Each method should have an average-case time complexity of O(log n). # Examples ```python custom_dict = CustomDict() custom_dict.insert(10, \'a\') custom_dict.insert(5, \'b\') custom_dict.insert(20, \'c\') print(custom_dict.lookup(10)) # Output: \'a\' print(custom_dict.get_min_key()) # Output: 5 print(custom_dict.get_max_key()) # Output: 20 custom_dict.delete(10) print(custom_dict.lookup(10)) # Raises KeyError custom_dict.insert(15, \'d\') print(custom_dict.lookup(15)) # Output: \'d\' print(custom_dict.get_min_key()) # Output: 5 print(custom_dict.get_max_key()) # Output: 20 ``` # Notes * Your internal data structure should efficiently support O(log n) insertion, deletion, and lookup operations. * Methods should handle edge cases gracefully, such as lookups for non-existent keys or retrieving min/max keys from an empty dictionary. * Consideration should be given for the memory footprint and potential performance optimizations. **Testing**: In addition to the provided examples, create a comprehensive suite of tests covering: 1. Edge cases such as insertion, lookup, and deletion of keys at the boundaries. 2. Performance with a large number of elements. 3. Usage of all class methods in various sequences to ensure consistency and correctness.","solution":"class CustomDict: def __init__(self): self.data = {} self.sorted_keys = [] def insert(self, key: int, value: any) -> None: if key in self.data: self.data[key] = value else: self.data[key] = value self.sorted_keys.append(key) self.sorted_keys.sort() def delete(self, key: int) -> None: if key in self.data: del self.data[key] self.sorted_keys.remove(key) def lookup(self, key: int) -> any: if key in self.data: return self.data[key] else: raise KeyError(f\\"Key {key} not found\\") def get_min_key(self) -> int: if not self.sorted_keys: raise ValueError(\\"CustomDict is empty\\") return self.sorted_keys[0] def get_max_key(self) -> int: if not self.sorted_keys: raise ValueError(\\"CustomDict is empty\\") return self.sorted_keys[-1]"},{"question":"# Graph Traversal Problem Problem Statement You are given an unweighted, undirected graph represented as an adjacency list. Write a function `shortest_path_length` that takes in two nodes, `start` and `end`, and returns the length of the shortest path between these two nodes. If there is no path between the nodes, return -1. The graph is represented as a dictionary where keys are node labels, and values are lists of nodes directly connected to the key node. Input Format * `graph`: A dictionary representing the adjacency list of the graph. * `start`: An integer representing the starting node. * `end`: An integer representing the ending node. Output Format * An integer representing the length of the shortest path from the starting node to the ending node. Return -1 if no path exists. Constraints * The graph contains at most 100 nodes. * Each node is labeled with a unique integer from 0 to 99. Example ```python def shortest_path_length(graph, start, end): # Implementation goes here. # Example usage: graph = { 0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2, 4], 4: [3] } start = 0 end = 4 print(shortest_path_length(graph, start, end)) # Output: 3 ``` **Explanation**: For the given example, the shortest path from node 0 to node 4 is 0 -> 2 -> 3 -> 4, which has a length of 3. Notes * Consider edge cases where the start node is the same as the end node. * Use BFS (Breadth-First Search) to find the shortest path in the unweighted graph.","solution":"from collections import deque def shortest_path_length(graph, start, end): Returns the length of the shortest path between start and end nodes in an unweighted graph. If there is no path, returns -1. :param graph: Dictionary representing the adjacency list of the graph. :param start: The starting node. :param end: The ending node. :return: Length of the shortest path, or -1 if no path exists. if start == end: return 0 visited = {start} queue = deque([(start, 0)]) # (current_node, current_distance) while queue: current, distance = queue.popleft() for neighbor in graph.get(current, []): if neighbor == end: return distance + 1 if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, distance + 1)) return -1"},{"question":"# Implement a Basic HashMap In this coding task, you are required to implement a basic hashmap data structure using closed addressing (chaining) in Python. A hashmap (also known as a hash table or dictionary) is a data structure that provides efficient key-value pair storage and lookup. # Implementation Details: 1. **Hash Function**: Implement a simple modular hash function to calculate the index for keys. 2. **Collision Handling**: Use lists to handle collisions via chaining. 3. **Operations**: Implement the following operations: - `put(key, value)`: Insert or update the value associated with the key. - `get(key)`: Retrieve the value associated with the key. If the key is not found, return `None`. - `remove(key)`: Remove the key-value pair from the hashmap. If the key is not found, do nothing. # Class Signature: ```python class BasicHashMap: def __init__(self, size: int = 100): pass def put(self, key: int, value: int): pass def get(self, key: int) -> int: pass def remove(self, key: int): pass ``` # Input: * `size`: An integer specifying the initial number of buckets in the hashmap. * `key`: An integer key. * `value`: An integer value associated with the key. # Output: * `put`: No output. * `get`: Return the value associated with the key or `None` if the key is not found. * `remove`: No output. # Constraints: * The keys and values are integers. * The number of buckets in the hashmap will be a positive integer. # Requirements: 1. Ensure correct handling of key collisions using separate chaining. 2. Efficient insertion, lookup, and deletion operations. 3. Handle edge cases gracefully, such as operations on an empty hashmap. # Examples: ```python # Create a BasicHashMap with 10 buckets hashmap = BasicHashMap(10) # Put some key-value pairs hashmap.put(1, 10) hashmap.put(2, 20) hashmap.put(11, 110) # Get values assert hashmap.get(1) == 10 assert hashmap.get(2) == 20 assert hashmap.get(11) == 110 assert hashmap.get(3) == None # Remove a key hashmap.remove(2) assert hashmap.get(2) == None # Update value for an existing key hashmap.put(1, 15) assert hashmap.get(1) == 15 ``` Implement the `BasicHashMap` class in Python and ensure it passes the provided examples and edge cases.","solution":"class BasicHashMap: def __init__(self, size: int = 100): self.size = size self.buckets = [[] for _ in range(size)] def _hash(self, key: int) -> int: return key % self.size def put(self, key: int, value: int): index = self._hash(key) for pair in self.buckets[index]: if pair[0] == key: pair[1] = value return self.buckets[index].append([key, value]) def get(self, key: int) -> int: index = self._hash(key) for pair in self.buckets[index]: if pair[0] == key: return pair[1] return None def remove(self, key: int): index = self._hash(key) for i, pair in enumerate(self.buckets[index]): if pair[0] == key: del self.buckets[index][i] return"},{"question":"# Problem Statement You are working on a web analytics project and your task is to process the logs of user interactions on a website. Each interaction is represented by an event and contains the URL visited and the user ID. Your goal is to write a function that determines the URLs visited by the highest number of unique users. # Task Design a function `top_urls_by_unique_users(logs: List[Tuple[str, str]]) -> List[str]` that takes a list of logs and returns a list of URLs visited by the highest number of unique users, ordered by the number of unique users in descending order. # Input - A list of tuples `logs` where each tuple contains: - A string representing the URL visited. - A string representing the user ID. # Output - A list of strings representing the URLs ordered by the number of unique users in descending order. # Constraints - `1 <= len(logs) <= 100000`, meaning there will be at least one log and at most 100000 logs. - Each URL and user ID is a non-empty string of up to 100 characters. - It\'s guaranteed that each user ID will be unique per URL in the logs. # Example ```python >>> top_urls_by_unique_users([(\\"url1\\", \\"user1\\"), (\\"url1\\", \\"user2\\"), (\\"url2\\", \\"user1\\")]) [\'url1\', \'url2\'] >>> top_urls_by_unique_users([(\\"url2\\", \\"user1\\"), (\\"url3\\", \\"user2\\"), (\\"url3\\", \\"user3\\"), (\\"url2\\", \\"user1\\"), (\\"url1\\", \\"user2\\")]) [\'url3\', \'url2\', \'url1\'] >>> top_urls_by_unique_users([(\\"url1\\", \\"user1\\")]) [\'url1\'] ``` # Detailed Requirements 1. Aggregate the logs to count the number of unique users for each URL. 2. Sort the URLs based on the number of unique users in descending order. 3. If multiple URLs have the same number of unique users, maintain alphabetical order for those URLs. 4. Ensure the function is optimized for both runtime and memory usage given the constraints.","solution":"from collections import defaultdict from typing import List, Tuple def top_urls_by_unique_users(logs: List[Tuple[str, str]]) -> List[str]: Returns the URLs visited by the highest number of unique users, ordered by the number of unique users in descending order. :param logs: List of tuples containing URL and user ID. :return: List of URLs ordered by unique user count in descending order. url_users = defaultdict(set) for url, user in logs: url_users[url].add(user) sorted_urls = sorted(url_users.items(), key=lambda item: (-len(item[1]), item[0])) return [url for url, users in sorted_urls]"},{"question":"# Question: Segment Tree for Range Sum Query Scenario You are developing a software module for a data analysis tool that needs to efficiently handle multiple range sum queries and updates on large datasets. A segment tree can provide an effective way to manage these operations in logarithmic time. Your task is to implement a segment tree for performing range sum queries and updates. Task Write a class `SegmentTree` with the following methods: 1. `__init__(self, nums: List[int])`: Initializes the segment tree with the given list of integers. 2. `update(self, index: int, value: int)`: Updates the element at the specified index to the given value. 3. `range_sum(self, left: int, right: int) -> int`: Returns the sum of the elements within the range `[left, right]` (inclusive). Class Signature ```python class SegmentTree: def __init__(self, nums: List[int]): pass def update(self, index: int, value: int): pass def range_sum(self, left: int, right: int) -> int: pass ``` Input * `nums`: List of integers (1 leq |nums| leq 10^5). * `index`: Integer, the index of the element to update (0-based). * `value`: Integer, the new value to update the element to. * `left`: Integer, the starting index of the range (0-based). * `right`: Integer, the ending index of the range (0-based, inclusive). Output * `update`: No return value. Updates the element at the specified index. * `range_sum`: Returns the integer sum of the elements within the specified range. Example ```python nums = [1, 3, 5, 7, 9, 11] segment_tree = SegmentTree(nums) assert segment_tree.range_sum(1, 3) == 15 # [3, 5, 7] segment_tree.update(1, 10) assert segment_tree.range_sum(1, 3) == 22 # [10, 5, 7] ``` Constraints * The input array elements will be within the range of (-10^9) to (10^9). * The `update` and `range_sum` operations should be efficient, ideally (O(log n)). Implementation Details * Use a segment tree to ensure efficient range query and update operations. * Handle edge cases such as updates at boundaries and queries over the full range. * Avoid excessive memory usage by implementing a balanced segment tree.","solution":"class SegmentTree: def __init__(self, nums): self.n = len(nums) self.tree = [0] * (2 * self.n) self.build(nums) def build(self, nums): for i in range(self.n): self.tree[i + self.n] = nums[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, index, value): pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[pos * 2] + self.tree[pos * 2 + 1] def range_sum(self, left, right): left += self.n right += self.n + 1 sum_ = 0 while left < right: if left % 2 == 1: sum_ += self.tree[left] left += 1 if right % 2 == 1: right -= 1 sum_ += self.tree[right] left //= 2 right //= 2 return sum_"},{"question":"# Problem Statement You are given a string containing parentheses - open `(` and close `)` - and you need to determine the minimum number of parentheses to remove to make the string valid. A string is valid if every open parenthesis `(` has a corresponding closing parenthesis `)` and vice-versa. # Function Signature ```python def min_remove_to_make_valid(s: str) -> str: ``` # Input * `s` (string): A string containing only the characters `(` and `)`. The length of `s` will not exceed 10^5. # Output * A string representing the modified version of `s` where minimal removals are made to make it valid. # Constraints * The length of the string `s` will be between 1 and 10^5 characters. # Examples ```python print(min_remove_to_make_valid(\\"lee(t(c)o)de)\\")) # Output: \\"lee(t(c)o)de\\" print(min_remove_to_make_valid(\\"a)b(c)d\\")) # Output: \\"ab(c)d\\" print(min_remove_to_make_valid(\\"))((\\")) # Output: \\"\\" ``` # Explanation 1. For the first example, the function should return \\"lee(t(c)o)de\\" by removing the last `)`. 2. For the second example, the function should return \\"ab(c)d\\" by removing the first `)`. 3. For the third example, the function should return an empty string because removing all characters makes the string valid. # Notes - The input string may contain other characters besides parentheses. - The removals should be minimal meaning the resulting string should retain the original appearance as much as possible.","solution":"def min_remove_to_make_valid(s: str) -> str: Returns a string with the minimum number of parentheses removed to make it valid. stack = [] to_remove = set() for i, char in enumerate(s): if char == \'(\': stack.append(i) elif char == \')\': if stack: stack.pop() else: to_remove.add(i) # Add all indices from stack to to_remove as they are unmatched \'(\' to_remove = to_remove.union(set(stack)) result = [] for i, char in enumerate(s): if i not in to_remove: result.append(char) return \'\'.join(result)"},{"question":"# Binary Search Tree (BST) Operations **Background**: You are provided with a class that implements a Binary Search Tree (BST). Your task is to add additional functionalities to perform specific operations within the BST. **Objective**: Implement the functionality to: 1. Find the minimum value within the BST. 2. Find the maximum value within the BST. 3. Calculate the height of the BST. # Requirements 1. **find_min()**: This function should return the minimum value present in the BST. 2. **find_max()**: This function should return the maximum value present in the BST. 3. **calculate_height()**: This function should return the height of the BST. Height is defined as the number of edges in the longest path from the root to a leaf node. **Function Signatures**: ```python class Node: def __init__(self, key): self.left = None self.right = None self.value = key class BST: def __init__(self): self.root = None # Existing methods including insert... def find_min(self): pass def find_max(self): pass def calculate_height(self): pass ``` # Input and Output **Find Min** * **Input**: No input required. * **Output**: The minimum value present in the BST. **Find Max** * **Input**: No input required. * **Output**: The maximum value present in the BST. **Calculate Height** * **Input**: No input required. * **Output**: An integer representing the height of the BST. # Example ```python # Assuming the BST class has an \'insert\' method to add values >>> tree = BST() >>> tree.insert(10) >>> tree.insert(20) >>> tree.insert(5) >>> tree.insert(1) >>> tree.insert(15) >>> tree.find_min() 1 >>> tree.find_max() 20 >>> tree.calculate_height() 2 ``` Complete the implementation of the three functions in the `BST` class to meet these requirements.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.value = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.value: if node.left is None: node.left = Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = Node(key) else: self._insert(node.right, key) def find_min(self): if self.root is None: return None return self._find_min(self.root) def _find_min(self, node): current = node while current.left is not None: current = current.left return current.value def find_max(self): if self.root is None: return None return self._find_max(self.root) def _find_max(self, node): current = node while current.right is not None: current = current.right return current.value def calculate_height(self): if self.root is None: return 0 return self._calculate_height(self.root) def _calculate_height(self, node): if node is None: return -1 left_height = self._calculate_height(node.left) right_height = self._calculate_height(node.right) return max(left_height, right_height) + 1"},{"question":"# Question: Sort Metrics by Conversion Rate **Context**: You are given a list of advertisement metrics, where each metric records impressions, clicks, and conversions for different ads. You need to rank these metrics based on their conversion rate to determine the most effective ads. Conversion rate is defined as the number of conversions divided by the number of clicks. If two ads have the same conversion rate, they should be ranked by the number of clicks in decreasing order. **Problem Statement**: Write a function named `sort_metrics_by_conversion_rate` that sorts a list of advertisement metrics based on their conversion rate in descending order. If two ads have the same conversion rate, they should be sorted by clicks in descending order. **Function Signature**: ```python def sort_metrics_by_conversion_rate(metrics: list) -> list: ``` **Input**: * `metrics` (list of tuples): A list where each tuple contains three integers (impressions, clicks, conversions). **Output**: * Returns a list of sorted tuples based on the conversion rate in descending order, and by clicks in descending order in case of ties. **Constraints**: * `1 <= len(metrics) <= 10^5` * `0 <= impressions[i] <= 10^6` for all valid `i` * `0 <= clicks[i] <= impressions[i]` for all valid `i` * `0 <= conversions[i] <= clicks[i]` for all valid `i` **Example**: ```python metrics = [(100, 10, 4), (200, 20, 15), (300, 25, 10)] print(sort_metrics_by_conversion_rate(metrics)) # Output: [(200, 20, 15), (300, 25, 10), (100, 10, 4)] metrics = [(1000, 100, 50), (2000, 100, 70), (1500, 100, 40)] print(sort_metrics_by_conversion_rate(metrics)) # Output: [(2000, 100, 70), (1000, 100, 50), (1500, 100, 40)] ``` **Verification**: 1. Ensure the function handles edge cases, such as when all conversion rates are the same. 2. Validate the function with lists containing varying numbers of metrics, including very large lists. 3. Confirm that ties in conversion rate are broken correctly by the number of clicks.","solution":"def sort_metrics_by_conversion_rate(metrics): Sorts the advertisement metrics by conversion rate in descending order. If two ads have the same conversion rate, they are sorted by clicks in descending order. :param metrics: List of tuples (impressions, clicks, conversions) :return: List of sorted tuples return sorted(metrics, key=lambda x: (x[2] / x[1] if x[1] != 0 else 0, x[1]), reverse=True)"},{"question":"# Question Scenario You are working on a data analysis project where you need to clean and process textual data. The dataset contains user reviews where each review is a string. You have to implement a function that removes non-alphanumeric characters from the reviews, converts all characters to lowercase, and then returns a list of the cleaned reviews. Task Write a Python function `clean_reviews` that processes a list of user reviews, removing all non-alphanumeric characters (except space) and converting them to lowercase. Function Specification ```python def clean_reviews(reviews): Cleans a list of user reviews by removing non-alphanumeric characters and converting to lowercase. Args: reviews (list of str): A list of user reviews. Returns: list of str: A list of cleaned reviews. ``` Constraints - The input list `reviews` will contain between 1 and 1000 reviews. - Each review will have a length of up to 500 characters. - Only English letters and numbers should be kept; all other characters (excluding spaces) should be removed. Examples ```python reviews = [ \\"This product is AMAZING!!!\\", \\"Would not buy again. Terrible quality :(\\", \\"Excellent value for money. 5/5 stars!\\" ] assert clean_reviews(reviews) == [ \\"this product is amazing\\", \\"would not buy again terrible quality \\", \\"excellent value for money 55 stars\\" ] ``` Performance Requirements - The function should efficiently handle the upper limit of 1000 reviews with a length of 500 characters each. - The memory usage should be within acceptable limits for standard personal computers.","solution":"import re def clean_reviews(reviews): Cleans a list of user reviews by removing non-alphanumeric characters and converting to lowercase. Args: reviews (list of str): A list of user reviews. Returns: list of str: A list of cleaned reviews. cleaned_reviews = [] for review in reviews: cleaned_review = re.sub(r\'[^a-zA-Z0-9 ]\', \'\', review).lower() cleaned_reviews.append(cleaned_review) return cleaned_reviews"},{"question":"# Question: Validate and Format Data Records You are to implement a function that validates and formats data records based on predefined rules. Each record contains a list of dictionaries where each dictionary represents an individual record with potentially various fields. Your task is to ensure all records meet the following criteria: 1. Required fields `id`, `name`, and `age` must be present. 2. The `id` field must be a non-negative integer. 3. The `name` field must be a non-empty string. 4. The `age` field must be an integer between 0 and 130 (inclusive). 5. Optionally, `email` fields must contain a valid email address format. If any record does not meet these criteria, it should be excluded from the output list. Additionally, the function should format the `name` field to capitalize the first letter of each word and the `email` field to be all lowercase. Function Specification Define the function `validate_and_format_records` as follows: ```python def validate_and_format_records(records: List[dict]) -> List[dict]: Validates and formats a list of data records. :param records: a list of dictionaries, where each dictionary represents a record :return: a list of valid and formatted records ``` Input and Output Format: - **Input**: - `records`: A list of dictionaries, where each dictionary represents a data record. - **Output**: - A list of valid and formatted records that meet all specified criteria. Constraints: - Each record is a dictionary containing various fields. - Each record must at least contain the fields `id`, `name`, and `age`. Example: ```python input_records = [ {\\"id\\": 1, \\"name\\": \\"john doe\\", \\"age\\": 28, \\"email\\": \\"JOHN.DOE@example.com\\"}, {\\"id\\": -3, \\"name\\": \\"jane smith\\", \\"age\\": 135, \\"email\\": \\"JaneSmith\\"}, {\\"id\\": 2, \\"name\\": \\"\\", \\"age\\": 22}, {\\"id\\": 3, \\"name\\": \\"alice johnson\\", \\"age\\": 30} ] formatted_records = validate_and_format_records(input_records) print(formatted_records) # Expected Output: # [ # {\\"id\\": 1, \\"name\\": \\"John Doe\\", \\"age\\": 28, \\"email\\": \\"john.doe@example.com\\"}, # {\\"id\\": 3, \\"name\\": \\"Alice Johnson\\", \\"age\\": 30} # ] ``` Additional Requirements: - Ensure your function can handle various types of malformed data records gracefully. - Aim to preserve as much valid data as possible while meeting the validation criteria.","solution":"import re from typing import List, Dict def validate_and_format_records(records: List[Dict]) -> List[Dict]: Validates and formats a list of data records. :param records: a list of dictionaries, where each dictionary represents a record :return: a list of valid and formatted records def is_valid_email(email: str) -> bool: return re.match(r\'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}\', email) is not None def format_name(name: str) -> str: return \' \'.join(word.capitalize() for word in name.split()) valid_records = [] for record in records: # Check for required keys if not all(key in record for key in [\'id\', \'name\', \'age\']): continue # Validate id if not isinstance(record[\'id\'], int) or record[\'id\'] < 0: continue # Validate name if not isinstance(record[\'name\'], str) or not record[\'name\'].strip(): continue # Validate age if not isinstance(record[\'age\'], int) or not (0 <= record[\'age\'] <= 130): continue # Check and validate the optional email if \'email\' in record and (not isinstance(record[\'email\'], str) or not is_valid_email(record[\'email\'])): continue # Format name and email record[\'name\'] = format_name(record[\'name\']) if \'email\' in record: record[\'email\'] = record[\'email\'].lower() valid_records.append(record) return valid_records"},{"question":"# Binary Tree Depth Sum **Scenario**: You are given a binary tree and need to calculate the sum of the values of all nodes, where each node\'s value is multiplied by its depth (level) in the tree. The depth of the root node is considered to be 1, the depth of its children is 2, and so on. **Objective**: Implement a function `depth_sum(root: TreeNode) -> int` that calculates and returns the sum described above. **Function Signature**: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def depth_sum(root: TreeNode) -> int: # your code here ``` **Input**: * `root`: A `TreeNode` object representing the root of the binary tree. **Output**: * An integer representing the sum of all nodes\' values multiplied by their respective depths. **Constraints**: * The binary tree may contain up to (10^4) nodes. * Node values are integers and can be negative, zero, or positive. **Edge Cases**: * The tree is empty (i.e., `root` is `None`). * All node values are zero. # Example 1: ```python # Example of a binary tree: # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) depth_sum(root) # Returns: 27 # Calculation: (1*1) + (2*2) + (3*2) + (4*3) + (5*3) = 1 + 4 + 6 + 12 + 15 = 38 ``` # Example 2: ```python # Example of a binary tree: # 3 # / # 1 4 root = TreeNode(3) root.left = TreeNode(1) root.right = TreeNode(4) depth_sum(root) # Returns: 14 # Calculation: (3*1) + (1*2) + (4*2) = 3 + 2 + 8 = 13 ``` Write your function considering the provided scenarios and constraints. Ensure your implementation efficiently handles all edge cases and correctly calculates the depth sum of the binary tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def depth_sum(root: TreeNode) -> int: def dfs(node, depth): if not node: return 0 return node.val * depth + dfs(node.left, depth + 1) + dfs(node.right, depth + 1) return dfs(root, 1)"},{"question":"Task: Summing Prime Numbers within a Range You are required to implement a function that computes the sum of all prime numbers within a given inclusive range `[a, b]`. A prime number is a natural number greater than 1 that is not divisible by any number other than 1 and itself. # Function Signature ```python def sum_of_primes(a: int, b: int) -> int: pass ``` # Input - Two integers `a` and `b` where `1 <= a <= b <= 10^6`. # Output - The sum of all prime numbers within the inclusive range `[a, b]`. # Constraints - The input will always consist of valid integers within the specified range. # Performance Requirements - The solution should be efficient, capable of handling the upper limit within a reasonable time frame. - Consider using the Sieve of Eratosthenes to find all prime numbers up to the maximum value of `b` and then sum the appropriate subset. # Examples ```python >>> sum_of_primes(10, 20) 60 # 11 + 13 + 17 + 19 = 60 >>> sum_of_primes(1, 10) 17 # 2 + 3 + 5 + 7 = 17 >>> sum_of_primes(5, 5) 5 # 5 is prime >>> sum_of_primes(4, 4) 0 # 4 is not prime >>> sum_of_primes(1, 1) 0 # No prime number in this range ``` # Notes - Ensure the solution efficiently handles the range and avoids unnecessary recomputation. - Utilize the Sieve of Eratosthenes to precompute prime numbers up to the maximum range value, then sum the subset within the given range to ensure optimal performance.","solution":"def sum_of_primes(a: int, b: int) -> int: Computes the sum of all prime numbers within the inclusive range [a, b]. if b < 2: # No prime numbers less than 2 return 0 # Implementation of the Sieve of Eratosthenes to find all primes up to b sieve = [True] * (b + 1) sieve[0] = sieve[1] = False p = 2 while p * p <= b: if sieve[p]: for multiple in range(p * p, b + 1, p): sieve[multiple] = False p += 1 # Sum all primes in the range [a, b] return sum(i for i in range(a, b + 1) if sieve[i])"},{"question":"# Scenario You are developing a navigation system for a marine vessel that needs to determine the optimal path through a set of waypoints. The goal is to visit each waypoint exactly once and return to the starting point, minimizing the total traveled distance. This is a classic Traveling Salesperson Problem (TSP) in a 2D plane. # Task Implement the function `find_optimal_path(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]` in Python, which takes a list of 2D points as input and returns an ordered list of points representing the optimal path to visit each waypoint exactly once, starting and ending at the same point. # Requirements 1. **Input**: - `points`: A list of unique tuples representing the coordinates (x, y) of each waypoint. Length of the list is at least 2 but no more than 20. 2. **Output**: - A list of tuples representing the waypoints\' coordinates in the order they should be visited to achieve the shortest path. # Input/Output Format - **Input**: `points = [(0, 0), (2, 3), (5, 5), (1, 1)]` - **Output**: `[(0, 0), (1, 1), (2, 3), (5, 5), (0, 0)]` # Constraints 1. Points are unique and provided as integer coordinates. 2. There are at least 2 and no more than 20 points. 3. The output path must start and end at the same point. # Performance Requirements - Your solution should handle the input size efficiently, given the constraint on the number of points. # Example ```python >>> find_optimal_path([(0, 0), (2, 3), (5, 5), (1, 1)]) [(0, 0), (1, 1), (2, 3), (5, 5), (0, 0)] >>> find_optimal_path([(0, 0), (1, 1), (1, 2)]) [(0, 0), (1, 1), (1, 2), (0, 0)] >>> find_optimal_path([(0, 0), (3, 3), (6, 6), (9, 9), (5, 5)]) [(0, 0), (3, 3), (5, 5), (6, 6), (9, 9), (0, 0)] ``` # Notes - You may use any algorithm suitable for solving small instances of the TSP, such as a brute-force approach or a heuristic. - Consider paths\' lengths to optimize the travel distance. - Handle the minimum number of points gracefully. Implement the `find_optimal_path` function to determine the shortest path through the given points.","solution":"from itertools import permutations from typing import List, Tuple def calculate_total_distance(path: List[Tuple[int, int]]) -> float: Calculate the total distance of a given path. def euclidean_distance(p1, p2): return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5 total_distance = 0 for i in range(len(path) - 1): total_distance += euclidean_distance(path[i], path[i + 1]) return total_distance def find_optimal_path(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Determines the optimal path to visit each point exactly once and return to the start. if len(points) < 2: return points optimal_path = None min_distance = float(\'inf\') initial_point = points[0] for perm in permutations(points[1:]): current_path = [initial_point] + list(perm) + [initial_point] current_distance = calculate_total_distance(current_path) if current_distance < min_distance: min_distance = current_distance optimal_path = current_path return optimal_path"}]'),N={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},L={class:"search-container"},O={class:"card-container"},F={key:0,class:"empty-state"},R=["disabled"],z={key:0},D={key:1};function j(r,e,l,m,s,a){const p=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",L,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",O,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(p,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",F,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",D,"Loading...")):(n(),i("span",z,"See more"))],8,R)):u("",!0)])}const Y=h(N,[["render",j],["__scopeId","data-v-694e09ad"]]),V=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/33.md","filePath":"drive/33.md"}'),P={name:"drive/33.md"},B=Object.assign(P,{setup(r){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{V as __pageData,B as default};
