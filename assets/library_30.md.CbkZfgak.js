import{_ as c,o as r,c as s,a as t,m as _,t as u,C as h,M as g,U as b,f as d,F as y,p as v,e as x,q as w}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},L={class:"review-title"},A={class:"review-content"};function N(i,e,l,f,n,a){return r(),s("div",q,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),_(u(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",A,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),_(u(l.poem.solution),1)])])])}const R=c(k,[["render",N],["__scopeId","data-v-a898a52d"]]),E=JSON.parse(`[{"question":"class Node: def __init__(self, value): self.value = value self.next = None class Queue: A Queue implementation using a singly linked list. >>> q = Queue() >>> q.is_empty() True >>> q.enqueue(1) >>> q.enqueue(2) >>> q.peek() 1 >>> q.is_empty() False >>> q.dequeue() 1 >>> q.dequeue() 2 >>> try: ... q.dequeue() ... except IndexError: ... pass # Expected behavior, as the queue is empty >>> try: ... q.peek() ... except IndexError: ... pass # Expected behavior, as the queue is empty def __init__(self): pass def enqueue(self, value): pass def dequeue(self): pass def is_empty(self): pass def peek(self): pass if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"class Node: def __init__(self, value): self.value = value self.next = None class Queue: def __init__(self): self.front = None self.rear = None def enqueue(self, value): new_node = Node(value) if self.rear is None: self.front = self.rear = new_node return self.rear.next = new_node self.rear = new_node def dequeue(self): if self.is_empty(): raise IndexError(\\"Dequeue from empty queue\\") temp = self.front self.front = temp.next if self.front is None: self.rear = None return temp.value def is_empty(self): return self.front is None def peek(self): if self.is_empty(): raise IndexError(\\"Peek from empty queue\\") return self.front.value"},{"question":"def calculate_final_score(scores: list) -> float: Calculates the average of valid scores in the list, rounded to two decimal places. A valid score is between 0 and 100 inclusive. Parameters: scores (list): A list of integers or floats representing the scores. Returns: float: The average of valid scores rounded to two decimal places. Raises: ValueError: If there are no valid scores in the list. Examples: >>> calculate_final_score([95, 85, 92, 88, 76]) 87.20 >>> calculate_final_score([100, 100, 100, 0, 0, 0]) 50.00 >>> calculate_final_score([-10, 105, 80, 90]) 85.00 >>> calculate_final_score([45.5, 78.3, 86.0]) 69.93 >>> calculate_final_score([55]) 55.00 >>> calculate_final_score([-10, 105, 101, -5]) ValueError: No valid scores available.","solution":"def calculate_final_score(scores): Calculates the average of valid scores in the list, rounded to two decimal places. A valid score is between 0 and 100 inclusive. Parameters: scores (list): A list of integers or floats representing the scores. Returns: float: The average of valid scores rounded to two decimal places. Raises: ValueError: If there are no valid scores in the list. valid_scores = [score for score in scores if 0 <= score <= 100] if not valid_scores: raise ValueError(\\"No valid scores available.\\") average_score = sum(valid_scores) / len(valid_scores) return round(average_score, 2)"},{"question":"def reconstruct_itinerary(tickets: List[Tuple[str, str]]) -> List[str]: Reconstruct the itinerary from flight tickets in lexicographical order starting from 'JFK'. >>> reconstruct_itinerary([(\\"MUC\\", \\"LHR\\"), (\\"JFK\\", \\"MUC\\"), (\\"SFO\\", \\"SJC\\"), (\\"LHR\\", \\"SFO\\")]) [\\"JFK\\", \\"MUC\\", \\"LHR\\", \\"SFO\\", \\"SJC\\"] >>> reconstruct_itinerary([(\\"JFK\\", \\"SFO\\"), (\\"JFK\\", \\"ATL\\"), (\\"SFO\\", \\"ATL\\"), (\\"ATL\\", \\"JFK\\"), (\\"ATL\\", \\"SFO\\")]) [\\"JFK\\", \\"ATL\\", \\"JFK\\", \\"SFO\\", \\"ATL\\", \\"SFO\\"] # Example Usage: tickets = [(\\"MUC\\", \\"LHR\\"), (\\"JFK\\", \\"MUC\\"), (\\"SFO\\", \\"SJC\\"), (\\"LHR\\", \\"SFO\\")] print(reconstruct_itinerary(tickets)) # Expected Output: [\\"JFK\\", \\"MUC\\", \\"LHR\\", \\"SFO\\", \\"SJC\\"] tickets = [(\\"JFK\\", \\"SFO\\"), (\\"JFK\\", \\"ATL\\"), (\\"SFO\\", \\"ATL\\"), (\\"ATL\\", \\"JFK\\"), (\\"ATL\\", \\"SFO\\")] print(reconstruct_itinerary(tickets)) # Expected Output: [\\"JFK\\", \\"ATL\\", \\"JFK\\", \\"SFO\\", \\"ATL\\", \\"SFO\\"]","solution":"from typing import List, Tuple from collections import defaultdict, deque def reconstruct_itinerary(tickets: List[Tuple[str, str]]) -> List[str]: graph = defaultdict(deque) # Create the graph, sorting each adjacency list lexicographically for start, end in sorted(tickets): graph[start].append(end) itinerary = [] def dfs(airport): while graph[airport]: next_airport = graph[airport].popleft() dfs(next_airport) itinerary.append(airport) # Start the journey from 'JFK' dfs('JFK') # Since we add airports after visiting the end of their edges, reverse the result return itinerary[::-1]"},{"question":"def min_coins(coins: list[int], sum_amount: int) -> int: Calculate the minimum number of coins required to make the given sum. Args: - coins (list[int]): Available denominations of coins. - sum_amount (int): Target sum to be made using the coins. Returns: - int: Minimum number of coins needed to reach the given sum. >>> min_coins([1, 2, 5], 11) 3 >>> min_coins([2], 3) -1 pass def get_coin_combination(coins: list[int], sum_amount: int) -> list[int]: Retrieve the combination of coins that make up the given sum using the minimum number of coins. Args: - coins (list[int]): Available denominations of coins. - sum_amount (int): Target sum to be made using the coins. Returns: - list[int]: A list of coins that sums up to the given sum using the minimum number of coins. >>> sorted(get_coin_combination([1, 2, 5], 11)) [1, 5, 5] >>> get_coin_combination([2], 3) [] pass","solution":"def min_coins(coins, sum_amount): Calculate the minimum number of coins required to make the given sum. Args: - coins (list[int]): Available denominations of coins. - sum_amount (int): Target sum to be made using the coins. Returns: - int: Minimum number of coins needed to reach the given sum, or -1 if it is not possible. dp = [float('inf')] * (sum_amount + 1) dp[0] = 0 # Zero coins needed to make sum 0 for coin in coins: for x in range(coin, sum_amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[sum_amount] if dp[sum_amount] != float('inf') else -1 def get_coin_combination(coins, sum_amount): Retrieve the combination of coins that make up the given sum using the minimum number of coins. Args: - coins (list[int]): Available denominations of coins. - sum_amount (int): Target sum to be made using the coins. Returns: - list[int]: A list of coins that sums up to the given sum using the minimum number of coins, or an empty list if it is not possible. dp = [float('inf')] * (sum_amount + 1) dp[0] = 0 # Zero coins needed to make sum 0 backtrack = [-1] * (sum_amount + 1) for coin in coins: for x in range(coin, sum_amount + 1): if dp[x - coin] + 1 < dp[x]: dp[x] = dp[x - coin] + 1 backtrack[x] = coin if dp[sum_amount] == float('inf'): return [] result = [] while sum_amount > 0: coin = backtrack[sum_amount] result.append(coin) sum_amount -= coin return result"},{"question":"Write a Python class \`KthSmallest\` which supports initialization and adding elements while maintaining the k-th smallest element in a stream of integers. The class should have the following methods: 1. \`__init__(self, k: int, nums: List[int])\`: Initializes the object with the integer \`k\` and the list \`nums\` containing initial elements of the stream. 2. \`add(self, val: int) -> int\`: Appends the integer \`val\` to the stream and returns the k-th smallest element in the stream. Your implementation should be efficient to handle the maximum constraints provided: - The length of \`nums\` will be between 0 and (10^4). - All elements of \`nums\` and all \`val\` values added through \`add\` will be integers between -(10^4) and (10^4). - 1 <= \`k\` <= (10^4) - The \`add\` method will be called at most (10^4) times. import heapq from typing import List class KthSmallest: def __init__(self, k: int, nums: list[int]): Initializes the object with the integer k and the list nums containing initial elements of the stream. self.k = k self.min_heap = nums heapq.heapify(self.min_heap) # Reduce heap_size to k if necessary while len(self.min_heap) > self.k: heapq.heappop(self.min_heap) def add(self, val: int) -> int: Appends the integer val to the stream and returns the k-th smallest element in the stream. heapq.heappush(self.min_heap, val) if len(self.min_heap) > self.k: heapq.heappop(self.min_heap) return self.min_heap[0] Example Usage: kth_smallest = KthSmallest(3, [4, 5, 8, 2]) print(kth_smallest.add(3)) # returns 4 print(kth_smallest.add(5)) # returns 5 print(kth_smallest.add(10)) # returns 5 print(kth_smallest.add(9)) # returns 8 print(kth_smallest.add(4)) # returns 8","solution":"import heapq class KthSmallest: def __init__(self, k: int, nums: list[int]): Initializes the object with the integer k and the list nums containing initial elements of the stream. self.k = k self.min_heap = nums heapq.heapify(self.min_heap) # Reduce heap_size to k if necessary while len(self.min_heap) > self.k: heapq.heappop(self.min_heap) def add(self, val: int) -> int: Appends the integer val to the stream and returns the k-th smallest element in the stream. heapq.heappush(self.min_heap, val) if len(self.min_heap) > self.k: heapq.heappop(self.min_heap) return self.min_heap[0]"},{"question":"from typing import List def longest_increasing_subsequence(scores: List[int]) -> int: Determines the length of the longest subsequence of increasing scores from a given list of scores. Args: scores (List[int]): A list of integers representing the student's scores over time. Returns: int: The length of the longest increasing subsequence of the given scores. Examples: >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1","solution":"from typing import List import bisect def longest_increasing_subsequence(scores: List[int]) -> int: Returns the length of the longest increasing subsequence of a given list of scores. if not scores: return 0 lis = [] for score in scores: pos = bisect.bisect_left(lis, score) if pos < len(lis): lis[pos] = score else: lis.append(score) return len(lis)"},{"question":"def quick_sort_inplace(collection): Sorts a list of integers in ascending order using the quick sort algorithm. :param collection: list of integers :return: sorted list of integers Example: >>> quick_sort_inplace([3, 1, 4, 1, 5, 9, 2, 6]) [1, 1, 2, 3, 4, 5, 6, 9] # Implement your in-place quick sort logic here pass # Unit tests def test_quick_sort_inplace(): assert quick_sort_inplace([3, 1, 4, 1, 5, 9, 2, 6]) == [1, 1, 2, 3, 4, 5, 6, 9] def test_quick_sort_inplace_empty(): assert quick_sort_inplace([]) == [] def test_quick_sort_inplace_sorted(): assert quick_sort_inplace([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_quick_sort_inplace_reverse_sorted(): assert quick_sort_inplace([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] def test_quick_sort_inplace_duplicates(): assert quick_sort_inplace([3, 3, 3, 3, 3]) == [3, 3, 3, 3, 3] def test_quick_sort_inplace_mix(): assert quick_sort_inplace([8, 1, 7, 3, 9, 10, 0, 2, 4]) == [0, 1, 2, 3, 4, 7, 8, 9, 10] def test_quick_sort_inplace_large_numbers(): assert quick_sort_inplace([200000, -200000, 0, -15, 15]) == [-200000, -15, 0, 15, 200000]","solution":"def quick_sort_inplace(collection): Sorts a list of integers in ascending order using the quick sort algorithm. :param collection: list of integers :return: sorted list of integers def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i = i + 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort_recursion(arr, low, high): if low < high: pivot_index = partition(arr, low, high) quick_sort_recursion(arr, low, pivot_index - 1) quick_sort_recursion(arr, pivot_index + 1, high) # The quick sort function will call the recursive function quick_sort_recursion(collection, 0, len(collection) - 1) return collection"},{"question":"import numpy as np def polynomial_regression(x_train: np.ndarray, y_train: np.ndarray, x_new: np.ndarray, degree: int) -> np.ndarray: Performs polynomial regression on the training data and predicts outputs for new inputs. Parameters: x_train (np.ndarray): Input data points for training (shape (n,)) y_train (np.ndarray): Output data points for training (shape (n,)) x_new (np.ndarray): New input values for which to predict the output (shape (m,)) degree (int): Degree of the polynomial to fit Returns: np.ndarray: Predicted output values for x_new (shape (m,)) # Complete the function implementation here # Test Cases x_train = np.array([1, 2, 3, 4, 5]) y_train = np.array([2, 3, 4, 5, 6]) # Linear relationship y = x + 1 x_new = np.array([6, 7, 8]) assert np.allclose(polynomial_regression(x_train, y_train, x_new, 1), np.array([7, 8, 9])) x_train = np.array([1, 2, 3, 4, 5]) y_train = np.array([1, 4, 9, 16, 25]) # Quadratic relationship y = x^2 x_new = np.array([6, 7, 8]) assert np.allclose(polynomial_regression(x_train, y_train, x_new, 2), np.array([36, 49, 64])) x_train = np.array([1, 2, 3, 4, 5]) y_train = np.array([1, 8, 27, 64, 125]) # Cubic relationship y = x^3 x_new = np.array([6, 7, 8]) assert np.allclose(polynomial_regression(x_train, y_train, x_new, 3), np.array([216, 343, 512])) x_train = np.array([1.5, 2.5, 3.5, 4.5]) y_train = np.array([2.25, 6.25, 12.25, 20.25]) # Quadratic relationship y = x^2 x_new = np.array([5.5, 6.5]) assert np.allclose(polynomial_regression(x_train, y_train, x_new, 2), np.array([30.25, 42.25])) x_train = np.array([1, 2, 3]) y_train = np.array([2, 2, 2]) # Constant relationship y = 2 x_new = np.array([4, 5, 6]) assert np.allclose(polynomial_regression(x_train, y_train, x_new, 0), np.array([2, 2, 2]))","solution":"import numpy as np def polynomial_regression(x_train: np.ndarray, y_train: np.ndarray, x_new: np.ndarray, degree: int) -> np.ndarray: Performs polynomial regression on the training data and predicts outputs for new inputs. Parameters: x_train (np.ndarray): Input data points for training (shape (n,)) y_train (np.ndarray): Output data points for training (shape (n,)) x_new (np.ndarray): New input values for which to predict the output (shape (m,)) degree (int): Degree of the polynomial to fit Returns: np.ndarray: Predicted output values for x_new (shape (m,)) # Create the Vandermonde matrix for the training data X = np.vander(x_train, degree + 1) # Compute the least-squares solution for the polynomial coefficients coeffs = np.linalg.lstsq(X, y_train, rcond=None)[0] # Create the Vandermonde matrix for the new input data X_new = np.vander(x_new, degree + 1) # Compute the predicted values using the polynomial coefficients y_new = X_new @ coeffs return y_new"},{"question":"def is_prime(num: int) -> bool: Helper function to check if a given number is a prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(1) False pass def prime_pairs_sequence(n: int) -> list[tuple[int, int]]: Returns a list of n pairs of consecutive prime numbers. >>> prime_pairs_sequence(3) [(3, 5), (5, 7), (11, 13)] >>> prime_pairs_sequence(5) [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31)] pass def test_is_prime(): assert is_prime(2) assert is_prime(3) assert not is_prime(4) assert is_prime(5) assert not is_prime(1) assert not is_prime(0) assert is_prime(13) assert not is_prime(14) def test_prime_pairs_sequence(): assert prime_pairs_sequence(1) == [(3, 5)] assert prime_pairs_sequence(2) == [(3, 5), (5, 7)] assert prime_pairs_sequence(3) == [(3, 5), (5, 7), (11, 13)] assert prime_pairs_sequence(5) == [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31)] result = prime_pairs_sequence(50) assert len(result) == 50 result = prime_pairs_sequence(10) consecutive_pairs = [ (3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73), (101, 103), (107, 109) ] assert result == consecutive_pairs","solution":"def is_prime(num): Helper function to check if a given number is a prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def prime_pairs_sequence(n: int) -> list[tuple[int, int]]: Returns a list of n pairs of consecutive prime numbers. primes = [] prime_pairs = [] current = 2 # starting from the smallest prime number while len(prime_pairs) < n: if is_prime(current): primes.append(current) # Check if we have at least two primes to form a pair if len(primes) >= 2: if primes[-1] == primes[-2] + 2: # Check if consecutive primes are exactly 2 apart prime_pairs.append((primes[-2], primes[-1])) current += 1 return prime_pairs"},{"question":"import heapq class PriorityQueue: def __init__(self): Initialize your data structure here. pass def enqueue(self, element: any, priority: int) -> None: Adds an \`element\` to the queue with the given \`priority\`. Elements with the same \`priority\` should be dequeued in the order they were enqueued. >>> pq = PriorityQueue() >>> pq.enqueue('apple', 2) >>> pq.enqueue('banana', 1) >>> pq.enqueue('cherry', 3) >>> pq.enqueue('date', 2) pass def dequeue(self) -> any: Removes and returns the element with the highest priority. If multiple elements have the highest priority, return the one that was enqueued first. If the queue is empty, return \`None\`. >>> pq = PriorityQueue() >>> pq.dequeue() None pass def test_enqueue_dequeue(): pq = PriorityQueue() pq.enqueue('apple', 2) pq.enqueue('banana', 1) pq.enqueue('cherry', 3) pq.enqueue('date', 2) assert pq.dequeue() == 'cherry' assert pq.dequeue() == 'apple' assert pq.dequeue() == 'date' assert pq.dequeue() == 'banana' assert pq.dequeue() == None def test_empty_queue(): pq = PriorityQueue() assert pq.dequeue() == None def test_same_priority(): pq = PriorityQueue() pq.enqueue('apple', 1) pq.enqueue('banana', 1) pq.enqueue('cherry', 1) assert pq.dequeue() == 'apple' assert pq.dequeue() == 'banana' assert pq.dequeue() == 'cherry' def test_different_priorities(): pq = PriorityQueue() pq.enqueue('apple', 1) pq.enqueue('banana', 5) pq.enqueue('cherry', 3) assert pq.dequeue() == 'banana' assert pq.dequeue() == 'cherry' assert pq.dequeue() == 'apple'","solution":"import heapq class PriorityQueue: def __init__(self): self.counter = 0 self.pq = [] def enqueue(self, element: any, priority: int) -> None: heapq.heappush(self.pq, (-priority, self.counter, element)) self.counter += 1 def dequeue(self) -> any: if self.pq: return heapq.heappop(self.pq)[2] return None"},{"question":"def robot_path_exists(grid: list[list[int]], updates: list[tuple[int, int, int]]) -> bool: Determines if there exists a path for a robot to move from the top-left corner (0, 0) to the bottom-right corner (N-1, N-1) on a dynamically changing grid. Args: grid (list[list[int]]): A 2D list representing the initial grid configuration. updates (list[tuple[int, int, int]]): A list of updates, where each update is a tuple containing (row, col, value). Returns: bool: Returns True if there is a valid path from the top-left corner to the bottom-right corner after considering all updates, otherwise False. Example: >>> grid = [ ... [0, 1, 0], ... [0, 0, 0], ... [1, 0, 0] ... ] >>> updates = [(1, 1, 1), (2, 1, 1), (2, 2, 1)] >>> robot_path_exists(grid, updates) False >>> grid = [ ... [0, 0, 1], ... [1, 0, 1], ... [0, 0, 0] ... ] >>> updates = [(0, 2, 0), (1, 0, 0)] >>> robot_path_exists(grid, updates) True >>> grid = [ ... [0] ... ] >>> updates = [] >>> robot_path_exists(grid, updates) True","solution":"from collections import deque def is_valid(grid, x, y, N): Checks if the given coordinates are within the grid bounds and if the cell is not an obstacle. return 0 <= x < N and 0 <= y < N and grid[x][y] == 0 def bfs(grid, N): Performs BFS to find if there is a path from top-left corner to bottom-right corner. if grid[0][0] == 1 or grid[N-1][N-1] == 1: return False queue = deque([(0, 0)]) visited = set((0, 0)) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while queue: x, y = queue.popleft() if (x, y) == (N-1, N-1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(grid, nx, ny, N) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False def robot_path_exists(grid, updates): Returns True if there is a path from the top-left to bottom-right corner after applying all updates. N = len(grid) # Apply updates to the grid for row, col, value in updates: grid[row][col] = value return bfs(grid, N)"},{"question":"def find_pattern(text: str, pattern: str) -> int: Function that searches for the first occurrence of a given pattern in a string. If the pattern is found, the function should return the index of its first occurrence; otherwise, it should return -1. >>> find_pattern(\\"hello world\\", \\"world\\") 6 >>> find_pattern(\\"abcdefg\\", \\"def\\") 3 >>> find_pattern(\\"test string\\", \\"test\\") 0 >>> find_pattern(\\"example\\", \\"abc\\") -1 >>> find_pattern(\\"abc\\", \\"abc\\") 0 pass","solution":"def find_pattern(text: str, pattern: str) -> int: Function that searches for the first occurrence of a given pattern in a string. If found, returns the index of its first occurrence; otherwise, returns -1. if not pattern: return 0 # Preprocess the pattern to build the partial match table (lps array) lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 i = j = 0 while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): return i - j elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"def bulk_update_prices(products: list[dict[str, str | float]]) -> None: Updates the prices of multiple products in the database. Args: products (list): A list of dictionaries with 'product_id' (str) and 'new_price' (float). Raises: ValueError: If product_id is not found or new_price is invalid. pass # Implement the function here def get_expensive_products(min_price: float, max_price: float, limit: int = 10) -> list[dict[str, str | float]]: Retrieves the most expensive products within a specified price range. Args: min_price (float): Minimum price to filter products. max_price (float): Maximum price to filter products. limit (int): Number of products to retrieve (default is 10). Returns: list: A list of dictionaries containing product details. Raises: ValueError: If min_price or max_price is invalid. pass # Implement the function here import pytest def test_bulk_update_prices(): # Backup the original database original_database = database['products'].copy() # Test valid updates bulk_update_prices([ {'product_id': 'p1', 'new_price': 120.0}, {'product_id': 'p2', 'new_price': 180.0} ]) assert database['products'][0]['price'] == 120.0 assert database['products'][1]['price'] == 180.0 # Restore original prices database['products'] = original_database # Test invalid product_id with pytest.raises(ValueError): bulk_update_prices([{'product_id': 'p4', 'new_price': 130.0}]) # Test invalid price with pytest.raises(ValueError): bulk_update_prices([{'product_id': 'p1', 'new_price': -10.0}]) def test_get_expensive_products(): products = get_expensive_products(100.0, 200.0) assert len(products) == 3 # All three products should be within the range products = get_expensive_products(150.0, 200.0, limit=1) assert len(products) == 1 # Only the most expensive product within the range should be returned assert products[0]['product_id'] == 'p3' # Test invalid range with pytest.raises(ValueError): get_expensive_products(-100.0, 200.0) with pytest.raises(ValueError): get_expensive_products(200.0, 100.0) # Run the tests pytest.main()","solution":"# Let's assume we have a simple in-memory database represented by a dictionary for this task. # In a real-world scenario, you would interact with an actual database using an ORM or direct SQL queries. # Here is a simple in-memory database database = { 'products': [ {'product_id': 'p1', 'name': 'Product 1', 'price': 100.0}, {'product_id': 'p2', 'name': 'Product 2', 'price': 150.0}, {'product_id': 'p3', 'name': 'Product 3', 'price': 200.0}, ] } def bulk_update_prices(products: list[dict[str, str | float]]) -> None: Updates the prices of multiple products in the database. Args: products (list): A list of dictionaries with 'product_id' (str) and 'new_price' (float). Raises: ValueError: If product_id is not found or new_price is invalid. product_map = {product['product_id']: product for product in database['products']} for item in products: product_id = item.get('product_id') new_price = item.get('new_price') if not product_id or product_id not in product_map: raise ValueError(f\\"Product ID {product_id} not found.\\") if not isinstance(new_price, (int, float)) or new_price < 0: raise ValueError(f\\"Invalid price {new_price} for product ID {product_id}.\\") product_map[product_id]['price'] = new_price def get_expensive_products(min_price: float, max_price: float, limit: int = 10) -> list[dict[str, str | float]]: Retrieves the most expensive products within a specified price range. Args: min_price (float): Minimum price to filter products. max_price (float): Maximum price to filter products. limit (int): Number of products to retrieve (default is 10). Returns: list: A list of dictionaries containing product details. Raises: ValueError: If min_price or max_price is invalid. if min_price < 0 or max_price < min_price: raise ValueError(\\"Invalid price range.\\") filtered_products = [p for p in database['products'] if min_price <= p['price'] <= max_price] filtered_products.sort(key=lambda x: -x['price']) # Sort by price descending return filtered_products[:limit]"},{"question":"from typing import List, Tuple def sieve_of_eratosthenes(limit: int) -> List[int]: Generates all prime numbers up to the limit using the Sieve of Eratosthenes. >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19] pass def consecutive_primes_sum(n: int) -> Tuple[int, int]: Find the longest sequence of consecutive prime numbers that adds up to a prime less than a given number \`n\`. >>> consecutive_primes_sum(100) (6, 41) >>> consecutive_primes_sum(1000) (21, 953) pass","solution":"from typing import List, Tuple def sieve_of_eratosthenes(limit: int) -> List[int]: is_prime = [True] * limit is_prime[0] = is_prime[1] = False for start in range(2, int(limit**0.5) + 1): if is_prime[start]: for multiple in range(start*start, limit, start): is_prime[multiple] = False return [num for num, prime in enumerate(is_prime) if prime] def consecutive_primes_sum(n: int) -> Tuple[int, int]: primes = sieve_of_eratosthenes(n) max_length = 0 max_prime_sum = 0 for i in range(len(primes)): for j in range(i + max_length, len(primes)): prime_sum = sum(primes[i:j]) if prime_sum >= n: break if prime_sum in primes: max_length = j - i max_prime_sum = prime_sum return (max_length, max_prime_sum)"},{"question":"def max_positive_subarray_sum(arr: List[int]) -> int: Return the sum of the largest contiguous subarray with all positive elements. :param arr: list of integers :return: sum of the largest positive subarray >>> max_positive_subarray_sum([1, -2, 3, 4, -5, 6, 7]) 13 >>> max_positive_subarray_sum([-1, -2, -3, -4]) 0 >>> max_positive_subarray_sum([5, 4, -1, 7, 8]) 15 >>> max_positive_subarray_sum([-1, 2, 3, -2, 4]) 5 >>> max_positive_subarray_sum([1, 2, 3, 4, 5]) 15","solution":"def max_positive_subarray_sum(arr): Return the sum of the largest contiguous subarray with all positive elements. :param arr: list of integers :return: sum of the largest positive subarray max_sum = 0 current_sum = 0 for num in arr: if num > 0: current_sum += num else: max_sum = max(max_sum, current_sum) current_sum = 0 # Check last segment sum max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Problem Statement **Unique Substring of K Length** Given a string \`s\` and an integer \`k\`, identify all unique substrings of length \`k\` and calculate their numerical scores. The score of a substring is defined as the sum of the ASCII values of its characters. Write a function \`unique_substrings_score(s: str, k: int) -> Dict[str, int]\` that returns a dictionary where keys are the unique substrings of length \`k\` and values are their corresponding scores. **Constraints:** - \`1 <= k <= len(s) <= 10^4\` - The string \`s\` contains only lowercase alphabets. Input - \`s\` (str): The input string (only lowercase alphabets). - \`k\` (int): The length of the substrings to consider. Output - \`Dict[str, int]\`: A dictionary with unique substrings of length \`k\` as keys and their scores as values. Example def unique_substrings_score(s: str, k: int) -> Dict[str, int]: # Implementation here... print(unique_substrings_score(\\"abcdef\\", 3)) # Expected output: {\\"abc\\": 294, \\"bcd\\": 297, \\"cde\\": 300, \\"def\\": 303} print(unique_substrings_score(\\"aaaaa\\", 2)) # Expected output: {\\"aa\\": 194} Notes - Each substring of length \`k\` is constructed by taking \`k\` consecutive characters from \`s\`. - The ASCII value of a lowercase letter can be obtained using the \`ord\` function, where \`ord('a') = 97\`, \`ord('b') = 98\`, ..., \`ord('z') = 122\`. Performance Requirements - The function should efficiently handle inputs where the length of the string \`s\` is up to 10,000 characters. [Unit Test] from solution import unique_substrings_score def test_example_cases(): assert unique_substrings_score(\\"abcdef\\", 3) == {\\"abc\\": 294, \\"bcd\\": 297, \\"cde\\": 300, \\"def\\": 303} assert unique_substrings_score(\\"aaaaa\\", 2) == {\\"aa\\": 194} def test_single_character_string(): assert unique_substrings_score(\\"a\\", 1) == {\\"a\\": 97} def test_substring_length_equals_string_length(): assert unique_substrings_score(\\"abcde\\", 5) == {\\"abcde\\": 495} def test_no_repeated_substring(): assert unique_substrings_score(\\"abcdefgh\\", 3) == { \\"abc\\": 294, \\"bcd\\": 297, \\"cde\\": 300, \\"def\\": 303, \\"efg\\": 306, \\"fgh\\": 309 } def test_repeated_substrings(): assert unique_substrings_score(\\"abababab\\", 2) == { \\"ab\\": 195, \\"ba\\": 195 } def test_substrings_with_all_same_chars(): assert unique_substrings_score(\\"aaaaaa\\", 3) == {\\"aaa\\": 291} def test_maximum_length(): assert unique_substrings_score(\\"a\\" * 10000, 5) == {\\"aaaaa\\": 485}","solution":"def unique_substrings_score(s: str, k: int): Returns a dictionary of unique substrings of length k and their corresponding scores. substrings_score = {} for i in range(len(s) - k + 1): substr = s[i:i+k] if substr not in substrings_score: score = sum(ord(char) for char in substr) substrings_score[substr] = score return substrings_score"},{"question":"import numpy as np class MatrixMultiplier: @staticmethod def multiply(matrix_a, matrix_b): Perform matrix multiplication with error handling for dimension compatibility and invalid values. Replaces NaN and infinite values in the input matrices with zero before proceeding. Parameters: matrix_a (ndarray): 2D numpy array representing the first matrix. matrix_b (ndarray): 2D numpy array representing the second matrix. Returns: ndarray: Result of the matrix multiplication. Raises: ValueError: If the dimensions of the matrices are incompatible. Examples: >>> matrix_a = np.array([[1, 2], [3, 4]]) >>> matrix_b = np.array([[5, 6], [7, 8]]) >>> MatrixMultiplier.multiply(matrix_a, matrix_b) array([[19, 22], [43, 50]]) >>> matrix_a = np.array([[1, 2], [3, np.nan]]) >>> matrix_b = np.array([[5, 6], [7, 8]]) >>> MatrixMultiplier.multiply(matrix_a, matrix_b) array([[19, 22], [15, 18]]) >>> matrix_a = np.array([[1, 2], [3, np.inf]]) >>> matrix_b = np.array([[5, 6], [7, 8]]) >>> MatrixMultiplier.multiply(matrix_a, matrix_b) array([[19, 22], [15, 18]]) pass # Test cases matrix_a = np.array([[1, 2], [3, 4]]) matrix_b = np.array([[5, np.nan], [7, 8]]) # Including NaN for testing try: result = MatrixMultiplier.multiply(matrix_a, matrix_b) print(\\"Result:n\\", result) except ValueError as e: print(\\"Error:\\", e) def test_multiply_normal_matrices(): matrix_a = np.array([[1, 2], [3, 4]]) matrix_b = np.array([[5, 6], [7, 8]]) result = MatrixMultiplier.multiply(matrix_a, matrix_b) expected = np.array([[19, 22], [43, 50]]) assert np.array_equal(result, expected) def test_multiply_with_nan_values(): matrix_a = np.array([[1, 2], [3, np.nan]]) matrix_b = np.array([[5, 6], [7, 8]]) result = MatrixMultiplier.multiply(matrix_a, matrix_b) expected = np.array([[19, 22], [15, 18]]) # np.nan replaced with 0, so second row becomes [3, 0] assert np.array_equal(result, expected) def test_multiply_with_infinite_values(): matrix_a = np.array([[1, 2], [3, np.inf]]) matrix_b = np.array([[5, 6], [7, 8]]) result = MatrixMultiplier.multiply(matrix_a, matrix_b) expected = np.array([[19, 22], [15, 18]]) # np.inf replaced with 0, so second row becomes [3, 0] assert np.array_equal(result, expected) def test_incompatible_dimensions(): matrix_a = np.array([[1, 2, 3], [4, 5, 6]]) matrix_b = np.array([[1, 2], [3, 4]]) try: MatrixMultiplier.multiply(matrix_a, matrix_b) except ValueError as e: assert str(e) == \\"Incompatible dimensions for matrix multiplication.\\" def test_empty_matrices(): matrix_a = np.array([[]]) matrix_b = np.array([[]]) try: MatrixMultiplier.multiply(matrix_a, matrix_b) except ValueError as e: assert str(e) == \\"Incompatible dimensions for matrix multiplication.\\"","solution":"import numpy as np class MatrixMultiplier: @staticmethod def multiply(matrix_a, matrix_b): # Check dimensions if matrix_a.shape[1] != matrix_b.shape[0]: raise ValueError(\\"Incompatible dimensions for matrix multiplication.\\") # Check and replace NaN and infinite values if np.isnan(matrix_a).any() or np.isinf(matrix_a).any() or np.isnan(matrix_b).any() or np.isinf(matrix_b).any(): print(\\"Warning: Replacing NaN or infinite values with zero in input matrices\\") matrix_a = np.nan_to_num(matrix_a, nan=0.0, posinf=0.0, neginf=0.0) matrix_b = np.nan_to_num(matrix_b, nan=0.0, posinf=0.0, neginf=0.0) # Perform matrix multiplication return np.matmul(matrix_a, matrix_b)"},{"question":"from typing import Dict, List def calculate_total_weight(data: Dict) -> float: Calculate the total weight of a crop after applying a series of daily growth rates. :param data: Dictionary containing initial_weight and a list of daily growth rates :type data: dict :return: Total weight of the crop after applying the growth rates :rtype: float >>> data = {\\"initial_weight\\": 10.0, \\"growth_rates\\": [10, 20, 30]} >>> calculate_total_weight(data) 15.6 >>> data = {\\"initial_weight\\": 10.0, \\"growth_rates\\": [0, 0, 0]} >>> calculate_total_weight(data) 10.0 >>> data = {\\"initial_weight\\": 10.0, \\"growth_rates\\": [10]} >>> calculate_total_weight(data) 11.0 >>> data = {\\"initial_weight\\": 1000.0, \\"growth_rates\\": [10, 20, 30]} >>> calculate_total_weight(data) 1716.0 >>> data = {\\"initial_weight\\": 10.0, \\"growth_rates\\": [50, 50, 50]} >>> calculate_total_weight(data) 33.75","solution":"def calculate_total_weight(data): Calculate the total weight of a crop after applying a series of daily growth rates. :param data: Dictionary containing initial_weight and a list of daily growth rates :type data: dict :return: Total weight of the crop after applying the growth rates :rtype: float initial_weight = data['initial_weight'] growth_rates = data['growth_rates'] current_weight = initial_weight for rate in growth_rates: current_weight += current_weight * (rate / 100) return current_weight"},{"question":"def connected_components(graph): Find all the connected components in an undirected graph. Parameters: graph (dict): A dictionary representing the graph, where keys are node names and values are lists of neighboring nodes. Returns: list[set]: A list of sets, each containing the nodes that form a connected component. Example: >>> graph = { ... 'A': ['B', 'C'], ... 'B': ['A', 'D'], ... 'C': ['A'], ... 'D': ['B'], ... 'E': ['F'], ... 'F': ['E'] ... } >>> connected_components(graph) [{'A', 'B', 'C', 'D'}, {'E', 'F'}] pass # Unit tests def test_disconnected_graph(): graph = { 'A': ['B', 'C'], 'B': ['A', 'D'], 'C': ['A'], 'D': ['B'], 'E': ['F'], 'F': ['E'] } result = connected_components(graph) expected = [{'A', 'B', 'C', 'D'}, {'E', 'F'}] assert all(comp in result for comp in expected) def test_single_node_graph(): graph = { 'A': [] } result = connected_components(graph) expected = [{'A'}] assert result == expected def test_fully_connected_graph(): graph = { 'A': ['B', 'C'], 'B': ['A', 'C'], 'C': ['A', 'B'] } result = connected_components(graph) expected = [{'A', 'B', 'C'}] assert result == expected def test_multiple_disconnected_nodes(): graph = { 'A': [], 'B': [], 'C': [] } result = connected_components(graph) expected = [{'A'}, {'B'}, {'C'}] assert all(comp in result for comp in expected) def test_complex_graph(): graph = { 'A': ['B', 'C'], 'B': ['A', 'D'], 'C': ['A', 'E'], 'D': ['B', 'F'], 'E': ['C'], 'F': ['D'], 'G': ['H'], 'H': ['G'] } result = connected_components(graph) expected = [{'A', 'B', 'C', 'D', 'E', 'F'}, {'G', 'H'}] assert all(comp in result for comp in expected)","solution":"def connected_components(graph): def dfs(node, visited, component): stack = [node] while stack: n = stack.pop() if n not in visited: visited.add(n) component.add(n) for neighbor in graph[n]: if neighbor not in visited: stack.append(neighbor) components = [] visited = set() for node in graph: if node not in visited: component = set() dfs(node, visited, component) components.append(component) return components"},{"question":"def fibonacci(n: int) -> int: Returns the Nth Fibonacci number. Parameters: n (int): The position in the Fibonacci sequence. Returns: int: The Nth Fibonacci number. Raises: ValueError: If n is not a non-negative integer. pass # Unit test import pytest def test_fibonacci_base_case(): assert fibonacci(0) == 0 assert fibonacci(1) == 1 def test_fibonacci_small_numbers(): assert fibonacci(2) == 1 assert fibonacci(3) == 2 assert fibonacci(4) == 3 assert fibonacci(5) == 5 def test_fibonacci_large_numbers(): assert fibonacci(10) == 55 assert fibonacci(20) == 6765 assert fibonacci(30) == 832040 def test_fibonacci_value_error_negative(): with pytest.raises(ValueError): fibonacci(-1) def test_fibonacci_value_error_non_integer(): with pytest.raises(ValueError): fibonacci(10.5) with pytest.raises(ValueError): fibonacci(\\"ten\\") def test_fibonacci_edge_cases(): assert fibonacci(50) == 12586269025 assert fibonacci(100) == 354224848179261915075","solution":"def fibonacci(n: int) -> int: Returns the Nth Fibonacci number. Parameters: n (int): The position in the Fibonacci sequence. Returns: int: The Nth Fibonacci number. Raises: ValueError: If n is not a non-negative integer. if not isinstance(n, int) or n < 0: raise ValueError(f\\"n={n} must be a non-negative integer\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def plot_movie_releases(file_path: str, start_year: int, end_year: int) -> None: Reads a CSV file containing movie data, processes the data, and plots a bar chart showing the number of movies released each year within the specified range. Parameters: - file_path (str): Path to the CSV file containing movie data. - start_year (int): The start year for the range. - end_year (int): The end year for the range. Returns: - None. Displays a matplotlib bar chart. import pandas as pd import matplotlib.pyplot as plt import pytest from unittest.mock import patch from io import StringIO def test_plot_movie_releases(): mock_csv_data = Title,Release Year Movie A,2000 Movie B,2001 Movie C,2002 Movie D,2003 Movie E,2004 Movie F,InvalidYear Movie G,2005 Movie H,2006 with patch('pandas.read_csv', return_value=pd.read_csv(StringIO(mock_csv_data))): with patch.object(plt, 'show'): plot_movie_releases('dummy_path.csv', 2000, 2006) def test_plot_movie_releases_no_such_file(): with patch('pandas.read_csv', side_effect=FileNotFoundError('File not found')): plot_movie_releases('dummy_path.csv', 2000, 2006) def test_plot_movie_releases_missing_column(): mock_csv_data_missing_col = Title,SomeOtherColumn Movie A,2000 Movie B,2001 with patch('pandas.read_csv', return_value=pd.read_csv(StringIO(mock_csv_data_missing_col))): with patch.object(plt, 'show'): plot_movie_releases('dummy_path.csv', 2000, 2006) def test_plot_movie_releases_no_movies_in_range(): mock_csv_data_no_movies_in_range = Title,Release Year Movie A,1990 Movie B,1991 with patch('pandas.read_csv', return_value=pd.read_csv(StringIO(mock_csv_data_no_movies_in_range))): with patch.object(plt, 'show'): plot_movie_releases('dummy_path.csv', 2000, 2006)","solution":"import pandas as pd import matplotlib.pyplot as plt def plot_movie_releases(file_path: str, start_year: int, end_year: int) -> None: Reads a CSV file containing movie data, processes the data, and plots a bar chart showing the number of movies released each year within the specified range. Parameters: - file_path (str): Path to the CSV file containing movie data. - start_year (int): The start year for the range. - end_year (int): The end year for the range. Returns: - None. Displays a matplotlib bar chart. # Read the CSV file try: df = pd.read_csv(file_path) except Exception as e: print(f\\"Error reading the CSV file: {e}\\") return # Verify that the necessary columns are present if 'Release Year' not in df.columns: print(\\"The CSV file does not have the required 'Release Year' column.\\") return # Filter out rows with invalid or missing 'Release Year' df = df[pd.to_numeric(df['Release Year'], errors='coerce').notnull()] df['Release Year'] = df['Release Year'].astype(int) # Filter data to include only the specified year range df_filtered = df[(df['Release Year'] >= start_year) & (df['Release Year'] <= end_year)] # Group by 'Release Year' and count the number of movies movie_counts = df_filtered['Release Year'].value_counts().sort_index() # Generate the years range and ensure every year has a count years_range = range(start_year, end_year + 1) counts = [movie_counts.get(year, 0) for year in years_range] # Plot the bar chart plt.figure(figsize=(10, 6)) plt.bar(years_range, counts, color='skyblue') plt.xlabel('Year') plt.ylabel('Number of Movies') plt.title('Number of Movie Releases per Year') plt.xticks(years_range, rotation=45) plt.tight_layout() plt.show()"},{"question":"def check_permutation_substring(s1: str, s2: str) -> bool: Determine whether any permutation of a given string s1 is a substring of another string s2. >>> check_permutation_substring(\\"ab\\", \\"eidbaooo\\") True >>> check_permutation_substring(\\"ab\\", \\"eidboaoo\\") False >>> check_permutation_substring(\\"adc\\", \\"dcda\\") True >>> check_permutation_substring(\\"a\\", \\"a\\") True >>> check_permutation_substring(\\"a\\", \\"b\\") False","solution":"def check_permutation_substring(s1: str, s2: str) -> bool: from collections import Counter len1, len2 = len(s1), len(s2) if len1 > len2: return False s1_count = Counter(s1) window_count = Counter(s2[:len1]) if s1_count == window_count: return True for i in range(len1, len2): window_count[s2[i]] += 1 window_count[s2[i - len1]] -= 1 if window_count[s2[i - len1]] == 0: del window_count[s2[i - len1]] if s1_count == window_count: return True return False"},{"question":"class VirtualFileSystem: def __init__(self): self.files = {} def create_file(self, file_name: str, content: str) -> bool: Creates a new file with the given file_name and fills it with content. If the file already exists, return False and do not overwrite the existing file. If successfully created, return True. pass def read_file(self, file_name: str) -> str: Returns the content of the file with the given file_name. If the file does not exist, return an empty string. pass def delete_file(self, file_name: str) -> bool: Deletes the file with the given file_name. If the file does not exist, return False. If successfully deleted, return True. pass def rename_file(self, old_name: str, new_name: str) -> bool: Renames a file from old_name to new_name. If a file with new_name already exists or old_name does not exist, return False. Otherwise, return True. pass import pytest def test_create_file(): vfs = VirtualFileSystem() assert vfs.create_file('file1', 'Hello, World!') == True assert vfs.create_file('file1', 'Should Fail') == False def test_read_file(): vfs = VirtualFileSystem() vfs.create_file('file1', 'Hello, World!') assert vfs.read_file('file1') == 'Hello, World!' assert vfs.read_file('file2') == '' def test_delete_file(): vfs = VirtualFileSystem() vfs.create_file('file1', 'Hello, World!') assert vfs.delete_file('file1') == True assert vfs.delete_file('file1') == False def test_rename_file(): vfs = VirtualFileSystem() vfs.create_file('file1', 'Hello, World!') assert vfs.rename_file('file1', 'file2') == True assert vfs.read_file('file2') == 'Hello, World!' assert vfs.rename_file('file1', 'file3') == False assert vfs.rename_file('file2', 'file2') == False vfs.create_file('file3', 'Another file') assert vfs.rename_file('file2', 'file3') == False if __name__ == \\"__main__\\": pytest.main()","solution":"class VirtualFileSystem: def __init__(self): self.files = {} def create_file(self, file_name: str, content: str) -> bool: if file_name in self.files: return False self.files[file_name] = content return True def read_file(self, file_name: str) -> str: return self.files.get(file_name, \\"\\") def delete_file(self, file_name: str) -> bool: if file_name in self.files: del self.files[file_name] return True return False def rename_file(self, old_name: str, new_name: str) -> bool: if old_name not in self.files or new_name in self.files: return False self.files[new_name] = self.files.pop(old_name) return True"},{"question":"def sort_by_alphabetic_weight(words: list[str]) -> list[str]: Sort the list of words based on their alphabetic weight (sum of the positions of the characters in the alphabet). :param words: list of strings to be sorted :return: list of sorted strings >>> sort_by_alphabetic_weight([\\"apple\\", \\"banana\\", \\"cherry\\"]) ['banana', 'apple', 'cherry'] >>> sort_by_alphabetic_weight([\\"dog\\", \\"cat\\", \\"bat\\"]) ['bat', 'cat', 'dog'] >>> sort_by_alphabetic_weight([\\"a\\", \\"aa\\", \\"aaa\\"]) ['a', 'aa', 'aaa'] def test_sort_by_alphabetic_weight_normal_case(): assert sort_by_alphabetic_weight([\\"apple\\", \\"banana\\", \\"cherry\\"]) == [\\"banana\\", \\"apple\\", \\"cherry\\"] def test_sort_by_alphabetic_weight_same_weight(): assert sort_by_alphabetic_weight([\\"dog\\", \\"cat\\", \\"bat\\"]) == [\\"bat\\", \\"cat\\", \\"dog\\"] def test_sort_by_alphabetic_weight_single_char(): assert sort_by_alphabetic_weight([\\"a\\", \\"b\\", \\"c\\"]) == [\\"a\\", \\"b\\", \\"c\\"] def test_sort_by_alphabetic_weight_multiple_char_same_letter(): assert sort_by_alphabetic_weight([\\"a\\", \\"aa\\", \\"aaa\\"]) == [\\"a\\", \\"aa\\", \\"aaa\\"] def test_sort_by_alphabetic_weight_mixed_lengths(): assert sort_by_alphabetic_weight([\\"ab\\", \\"a\\", \\"abcd\\"]) == [\\"a\\", \\"ab\\", \\"abcd\\"] def test_sort_by_alphabetic_weight_duplicate_weights(): assert sort_by_alphabetic_weight([\\"ace\\", \\"bdf\\", \\"acf\\", \\"bde\\"]) == [\\"ace\\", \\"acf\\", \\"bde\\", \\"bdf\\"]","solution":"def sort_by_alphabetic_weight(words: list[str]) -> list[str]: Sort the list of words based on their alphabetic weight (sum of the positions of the characters in the alphabet). :param words: list of strings to be sorted :return: list of sorted strings def alphabetic_weight(word): # Calculate the sum of positions of the characters in the word (a=1, b=2, ..., z=26) return sum(ord(char) - ord('a') + 1 for char in word) # Sort words by their alphabetic weight sorted_words = sorted(words, key=alphabetic_weight) return sorted_words"},{"question":"def sort_files(file_list): Sort a list of filenames primarily by file extension and secondarily by filename. The sort should be case-insensitive but maintain the original case in the output. Args: file_list (list): List of filenames to sort. Returns: list: Sorted list of filenames. Example: >>> sort_files([\\"file.txt\\", \\"file.TXT\\", \\"analyzer.EXE\\", \\"data.csv\\", \\"Report.docx\\"]) [\\"data.csv\\", \\"Report.docx\\", \\"analyzer.EXE\\", \\"file.txt\\", \\"file.TXT\\"] >>> sort_files([\\"image.jpeg\\", \\"File.TXT\\", \\"image.PNG\\"]) [\\"image.jpeg\\", \\"image.PNG\\", \\"File.TXT\\"] # Test cases def test_sort_files_basic(): assert sort_files([\\"file.txt\\", \\"file.TXT\\", \\"analyzer.EXE\\", \\"data.csv\\", \\"Report.docx\\"]) == [\\"data.csv\\", \\"Report.docx\\", \\"analyzer.EXE\\", \\"file.txt\\", \\"file.TXT\\"] def test_sort_files_case_sensitive_filenames(): assert sort_files([\\"image.jpeg\\", \\"File.TXT\\", \\"image.PNG\\"]) == [\\"image.jpeg\\", \\"image.PNG\\", \\"File.TXT\\"] def test_sort_files_mixed_case(): assert sort_files([\\"a.TXT\\", \\"b.txt\\", \\"C.txt\\", \\"abc.EXE\\"]) == [\\"abc.EXE\\", \\"a.TXT\\", \\"b.txt\\", \\"C.txt\\"] def test_sort_files_same_extension_different_case(): assert sort_files([\\"file.A\\", \\"file.a\\", \\"File.B\\", \\"file.b\\"]) == [\\"file.A\\", \\"file.a\\", \\"File.B\\", \\"file.b\\"] def test_sort_files_only_one_file(): assert sort_files([\\"singlefile.txt\\"]) == [\\"singlefile.txt\\"] def test_sort_files_no_files(): assert sort_files([]) == []","solution":"def sort_files(file_list): Sort a list of filenames primarily by file extension and secondarily by filename. The sort should be case-insensitive but maintain the original case in the output. return sorted(file_list, key=lambda x: (x.split('.')[-1].lower(), x.lower()))"},{"question":"def detect_fraud(transactions: list[tuple[int, int, float]]) -> list[int]: Detect fraudulent transactions from a list of transaction logs. A function to identify suspicious transactions for each account, where a transaction is considered suspicious if it is more than 3 times the average amount of all previous transactions for that account. Args: transactions (list[tuple[int, int, float]]): A list of tuples containing transaction data. Each tuple consists of (timestamp, account_id, amount). Returns: list[int]: A list of account ids where suspicious transactions are detected. Examples: >>> detect_fraud([(1622547800, 1, 100.0), (1622547801, 2, 50.0), (1622547802, 1, 500.0)]) [1] >>> detect_fraud([(1622547800, 1, 100.0), (1622547801, 1, 50.0), (1622547802, 1, 1000.0)]) [1] >>> detect_fraud([(1622547800, 1, 100.0), (1622547801, 1, 150.0), (1622547802, 1, 120.0)]) [] pass # Unit Test def test_single_transaction_no_fraud(): transactions = [(1622547800, 1, 100.0)] assert detect_fraud(transactions) == [] def test_multiple_transactions_no_fraud(): transactions = [ (1622547800, 1, 100.0), (1622547801, 1, 150.0), (1622547802, 1, 120.0) ] assert detect_fraud(transactions) == [] def test_single_fraudulent_transaction(): transactions = [ (1622547800, 1, 100.0), (1622547801, 1, 50.0), (1622547802, 1, 1000.0) ] assert detect_fraud(transactions) == [1] def test_multiple_accounts_some_fraudulent(): transactions = [ (1622547800, 1, 100.0), (1622547801, 2, 100.0), (1622547802, 1, 50.0), (1622547803, 2, 75.0), (1622547804, 1, 500.0), (1622547805, 2, 500.0) ] assert detect_fraud(transactions) == [1, 2] def test_no_transactions(): transactions = [] assert detect_fraud(transactions) == [] def test_transactions_edge_case(): transactions = [ (1622547800, 1, 100.0), (1622547801, 1, 300.0), (1622547802, 1, 400.0) ] assert detect_fraud(transactions) == [] def test_frequent_small_transactions_then_large(): transactions = [ (1622547800, 1, 1.0), (1622547801, 1, 1.0), (1622547802, 1, 1.0), (1622547803, 1, 10.0) ] assert detect_fraud(transactions) == [1]","solution":"def detect_fraud(transactions): account_data = {} suspicious_accounts = set() for timestamp, account_id, amount in transactions: if account_id not in account_data: account_data[account_id] = { \\"total_amount\\": 0, \\"transaction_count\\": 0, \\"suspicious\\": False } account = account_data[account_id] total_amount = account[\\"total_amount\\"] transaction_count = account[\\"transaction_count\\"] if transaction_count > 0: avg_amount = total_amount / transaction_count if amount > 3 * avg_amount and not account[\\"suspicious\\"]: suspicious_accounts.add(account_id) account_data[account_id][\\"suspicious\\"] = True account_data[account_id][\\"total_amount\\"] += amount account_data[account_id][\\"transaction_count\\"] += 1 return sorted(suspicious_accounts)"},{"question":"class FileNotFoundError(Exception): pass class FileSystem: def __init__(self): Initializes the root directory of the file system. pass def mkdir(self, path: str): Creates a directory at the specified path. If intermediate directories do not exist, they should be created. Args: path (str): The path where the directory should be created. Example: fs = FileSystem() fs.mkdir('/a/b/c') pass def addFile(self, path: str, content: str): Creates a file at the specified path with the given content. If intermediate directories do not exist, they should be created. Args: path (str): The path where the file should be created. content (str): The content to be written to the file. Example: fs = FileSystem() fs.addFile('/a/b/c/d.txt', 'Hello World') pass def readFile(self, path: str): Reads the content of the file at the specified path. Args: path (str): The path of the file whose content is to be read. Returns: str: The content of the file. Raises: FileNotFoundError: If the file does not exist. Example: fs = FileSystem() fs.addFile('/a/b/c/d.txt', 'Hello World') assert fs.readFile('/a/b/c/d.txt') == 'Hello World' pass def delete(self, path: str): Deletes the file or directory at the specified path. If the path is a directory, all its contents (files and directories) should also be deleted to mimic a recursive deletion. Args: path (str): The path of the file or directory to be deleted. Raises: FileNotFoundError: If the file or directory does not exist. Example: fs = FileSystem() fs.addFile('/a/b/c/d.txt', 'Hello World') fs.delete('/a/b/c/d.txt') try: fs.readFile('/a/b/c/d.txt') except FileNotFoundError: pass # Expected a FileNotFoundError pass","solution":"class FileNotFoundError(Exception): pass class FileSystem: def __init__(self): self.root = {} def mkdir(self, path: str): dirs = path.strip('/').split('/') current = self.root for directory in dirs: if directory not in current: current[directory] = {} current = current[directory] def addFile(self, path: str, content: str): dirs = path.strip('/').split('/') filename = dirs.pop(-1) current = self.root for directory in dirs: if directory not in current: current[directory] = {} current = current[directory] current[filename] = content def readFile(self, path: str): dirs = path.strip('/').split('/') filename = dirs.pop(-1) current = self.root for directory in dirs: if directory in current: current = current[directory] else: raise FileNotFoundError(\\"File or directory does not exist\\") if filename in current: if isinstance(current[filename], str): return current[filename] else: raise FileNotFoundError(\\"Requested path is a directory, not a file\\") else: raise FileNotFoundError(\\"File does not exist\\") def delete(self, path: str): dirs = path.strip('/').split('/') filename = dirs.pop(-1) current = self.root for directory in dirs: if directory in current: current = current[directory] else: raise FileNotFoundError(\\"File or directory does not exist\\") if filename in current: del current[filename] else: raise FileNotFoundError(\\"File or directory does not exist\\")"},{"question":"def file_type(filename: str) -> str: Takes in a filename and returns the file type based on its extension. >>> file_type(\\"document.txt\\") 'Text File' >>> file_type(\\"picture.jpg\\") 'Image File' >>> file_type(\\"script.py\\") 'Python Script' >>> file_type(\\"report.pdf\\") 'PDF Document' >>> file_type(\\"archive.zip\\") 'Unknown'","solution":"def file_type(filename: str) -> str: Takes in a filename and returns the file type based on its extension. if filename.endswith('.txt'): return 'Text File' elif filename.endswith('.jpg') or filename.endswith('.jpeg'): return 'Image File' elif filename.endswith('.py'): return 'Python Script' elif filename.endswith('.pdf'): return 'PDF Document' else: return 'Unknown'"},{"question":"import numpy as np def canny_edge_detector(image: np.ndarray, low_threshold: float, high_threshold: float) -> np.ndarray: Detect edges in the input grayscale image using a simplified version of the Canny edge detection algorithm. Parameters: - image: Input grayscale image (normalized to values between 0 and 1). - low_threshold: Lower bound for hysteresis thresholding. - high_threshold: Upper bound for hysteresis thresholding. Returns: - 2D NumPy array indicating detected edges with pixel values set to 1 (edge) or 0 (non-edge). # Step 1: Apply Gaussian filter # Step 2: Compute gradients using Sobel operators # Step 3: Calculate gradient magnitude and direction # Step 4: Apply Non-Maximum Suppression # Step 5: Perform Hysteresis Thresholding # ... [Your Code Here] ... return edges # Example usage: image = np.array([[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]], dtype=np.float32) low_threshold = 0.1 high_threshold = 0.3 edges = canny_edge_detector(image, low_threshold, high_threshold) print(edges)","solution":"import numpy as np from scipy.ndimage import gaussian_filter, sobel def canny_edge_detector(image: np.ndarray, low_threshold: float, high_threshold: float) -> np.ndarray: Detect edges in the input grayscale image using a simplified version of the Canny edge detection algorithm. Parameters: - image: Input grayscale image (normalized to values between 0 and 1). - low_threshold: Lower bound for hysteresis thresholding. - high_threshold: Upper bound for hysteresis thresholding. Returns: - 2D NumPy array indicating detected edges with pixel values set to 1 (edge) or 0 (non-edge). # Step 1: Apply Gaussian filter to smooth the image smoothed = gaussian_filter(image, sigma=1.4) # Step 2: Compute gradients using Sobel operators gradient_x = sobel(smoothed, axis=1) gradient_y = sobel(smoothed, axis=0) # Step 3: Calculate gradient magnitude and direction gradient_magnitude = np.hypot(gradient_x, gradient_y) gradient_direction = np.arctan2(gradient_y, gradient_x) # Step 4: Apply Non-Maximum Suppression M, N = gradient_magnitude.shape suppressed = np.zeros((M, N), dtype=np.float32) angle = gradient_direction * 180. / np.pi angle[angle < 0] += 180 for i in range(1, M-1): for j in range(1, N-1): q, r = 255, 255 # Angle 0 if (0 <= angle[i, j] < 22.5) or (157.5 <= angle[i, j] <= 180): q = gradient_magnitude[i, j+1] r = gradient_magnitude[i, j-1] # Angle 45 elif 22.5 <= angle[i, j] < 67.5: q = gradient_magnitude[i+1, j-1] r = gradient_magnitude[i-1, j+1] # Angle 90 elif 67.5 <= angle[i, j] < 112.5: q = gradient_magnitude[i+1, j] r = gradient_magnitude[i-1, j] # Angle 135 elif 112.5 <= angle[i, j] < 157.5: q = gradient_magnitude[i-1, j-1] r = gradient_magnitude[i+1, j+1] if (gradient_magnitude[i, j] >= q) and (gradient_magnitude[i, j] >= r): suppressed[i, j] = gradient_magnitude[i, j] else: suppressed[i, j] = 0 # Step 5: Perform Hysteresis Thresholding edges = np.zeros((M, N), dtype=np.float32) strong = high_threshold weak = low_threshold strong_i, strong_j = np.where(suppressed >= strong) zeros_i, zeros_j = np.where(suppressed < weak) weak_i, weak_j = np.where((suppressed <= strong) & (suppressed >= weak)) edges[strong_i, strong_j] = 1 edges[weak_i, weak_j] = 0.5 for i in range(1, M-1): for j in range(1, N-1): if edges[i, j] == 0.5: if ((edges[i+1, j-1:j+2] == 1).any() or (edges[i-1, j-1:j+2] == 1).any() or (edges[i, [j-1, j+1]] == 1).any()): edges[i, j] = 1 else: edges[i, j] = 0 return edges.astype(int)"},{"question":"from typing import List, Callable, Tuple # Selection Methods def tournament_selection(population: List, fitness: List, k: int) -> List: Implements the tournament selection method for genetic algorithms. Args: population (List): List of individuals in the population. fitness (List): List of fitness values corresponding to the individuals. k (int): The number of individuals to be selected in each tournament. Returns: List: Selected individuals after tournament selection. def rank_based_selection(population: List, fitness: List) -> List: Implements rank-based selection method for genetic algorithms. Args: population (List): List of individuals in the population. fitness (List): List of fitness values corresponding to the individuals. Returns: List: Selected individuals after rank-based selection. # Crossover Methods def single_point_crossover(parent1: List, parent2: List) -> Tuple[List, List]: Implements single-point crossover method. Args: parent1 (List): The first parent individual. parent2 (List): The second parent individual. Returns: Tuple[List, List]: Two offspring individuals generated from the parents. def two_point_crossover(parent1: List, parent2: List) -> Tuple[List, List]: Implements two-point crossover method. Args: parent1 (List): The first parent individual. parent2 (List): The second parent individual. Returns: Tuple[List, List]: Two offspring individuals generated from the parents. # Mutation Method def mutation(individual: List, mutation_prob: float) -> List: Implements the mutation method for genetic algorithms. Args: individual (List): The individual to be mutated. mutation_prob (float): The probability of mutation. Returns: List: The mutated individual. # Genetic Algorithm Framework def genetic_algorithm( population: List[List[int]], generations: int, population_size: int, crossover_rate: float, mutation_prob: float, fitness_func: Callable[[List[int]], float], selection_method: Callable[[List[List[int]], List[float]], List[List[int]]] = rank_based_selection, crossover_method: Callable[[List[int], List[int]], Tuple[List[int], List[int]]] = single_point_crossover ) -> List[int]: Implements the genetic algorithm framework. Args: population (List[List[int]]): The initial population of individuals. generations (int): The number of generations to run the algorithm. population_size (int): The size of the population. crossover_rate (float): The probability of crossover. mutation_prob (float): The probability of mutation. fitness_func (Callable[[List[int]], float]): The fitness function to evaluate individuals. selection_method (Callable[[List[List[int]], List[float]], List[List[int]]]): The selection method to use. crossover_method (Callable[[List[int], List[int]], Tuple[List[int], List[int]]]): The crossover method to use. Returns: List[int]: The best individual found after running the algorithm.","solution":"import random from typing import List, Callable, Tuple # Selection Methods def tournament_selection(population: List, fitness: List, k: int) -> List: selected = [] for _ in range(len(population)): tournament = random.sample(list(zip(population, fitness)), k) winner = max(tournament, key=lambda x: x[1]) selected.append(winner[0]) return selected def rank_based_selection(population: List, fitness: List) -> List: sorted_population = [p for p, f in sorted(zip(population, fitness), key=lambda x: x[1])] ranks = [i+1 for i in range(len(sorted_population))] total_rank = sum(ranks) probabilities = [rank/total_rank for rank in ranks] selected = random.choices(sorted_population, weights=probabilities, k=len(population)) return selected # Crossover Methods def single_point_crossover(parent1: List, parent2: List) -> Tuple[List, List]: point = random.randint(1, len(parent1) - 1) child1 = parent1[:point] + parent2[point:] child2 = parent2[:point] + parent1[point:] return child1, child2 def two_point_crossover(parent1: List, parent2: List) -> Tuple[List, List]: point1, point2 = sorted(random.sample(range(1, len(parent1)), 2)) child1 = parent1[:point1] + parent2[point1:point2] + parent1[point2:] child2 = parent2[:point1] + parent1[point1:point2] + parent2[point2:] return child1, child2 # Mutation Method def mutation(individual: List, mutation_prob: float) -> List: return [gene if random.random() > mutation_prob else 1 - gene for gene in individual] # Genetic Algorithm Framework def genetic_algorithm( population: List[List[int]], generations: int, population_size: int, crossover_rate: float, mutation_prob: float, fitness_func: Callable[[List[int]], float], selection_method: Callable[[List[List[int]], List[float]], List[List[int]]] = rank_based_selection, crossover_method: Callable[[List[int], List[int]], Tuple[List[int], List[int]]] = single_point_crossover ) -> List[int]: for generation in range(generations): fitness = [fitness_func(individual) for individual in population] selected_population = selection_method(population, fitness) next_population = [] while len(next_population) < population_size: if len(selected_population) >= 2: parent1, parent2 = random.sample(selected_population, 2) if random.random() < crossover_rate: offspring1, offspring2 = crossover_method(parent1, parent2) else: offspring1, offspring2 = parent1, parent2 next_population.extend([offspring1, offspring2]) else: next_population.append(selected_population[0]) next_population = [mutation(individual, mutation_prob) for individual in next_population][:population_size] population = next_population best_individual = max(population, key=fitness_func) return best_individual"},{"question":"def max_items(grid: List[List[int]]) -> int: Calculate the maximum number of items the robot can collect while reaching the destination. >>> max_items([ ... [1, 0, 0, 1], ... [1, 1, 0, 0], ... [0, 1, 1, 1], ... [1, 1, 0, 0] ... ]) 6 >>> max_items([ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ]) 0 >>> max_items([[1]]) 1 >>> max_items([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 5 >>> max_items([ ... [1, 0, 1, 0], ... [0, 1, 0, 1], ... [1, 0, 1, 0] ... ]) 3 >>> max_items([]) 0","solution":"from typing import List def max_items(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"from typing import List def find_missing_numbers(arr: List[int], m: int) -> List[int]: Returns a sorted list of all the integers between 1 and m (inclusive) that are not present in arr. Examples: >>> find_missing_numbers([1, 2, 4], 5) [3, 5] >>> find_missing_numbers([2, 3, 7, 8], 10) [1, 4, 5, 6, 9, 10] >>> find_missing_numbers([], 5) [1, 2, 3, 4, 5] def test_example_cases(): assert find_missing_numbers([1, 2, 4], 5) == [3, 5] assert find_missing_numbers([2, 3, 7, 8], 10) == [1, 4, 5, 6, 9, 10] assert find_missing_numbers([], 5) == [1, 2, 3, 4, 5] def test_no_missing_numbers(): assert find_missing_numbers([1, 2, 3, 4, 5], 5) == [] assert find_missing_numbers([1, 2, 3], 3) == [] def test_all_missing_numbers(): assert find_missing_numbers([], 3) == [1, 2, 3] assert find_missing_numbers([], 1) == [1] def test_large_input(): # All numbers from 1 to 100000 are present assert find_missing_numbers(list(range(1, 100001)), 100000) == [] # All numbers except 100000 are present assert find_missing_numbers(list(range(1, 100000)), 100000) == [100000] def test_single_element_lists(): assert find_missing_numbers([1], 2) == [2] assert find_missing_numbers([2], 2) == [1] assert find_missing_numbers([1], 1) == [] def test_randomized_lists(): assert find_missing_numbers([3, 1, 2, 5], 5) == [4] assert find_missing_numbers([2, 5, 3, 7, 8], 10) == [1, 4, 6, 9, 10]","solution":"from typing import List def find_missing_numbers(arr: List[int], m: int) -> List[int]: Returns a sorted list of all the integers between 1 and m (inclusive) that are not present in arr. # Convert arr to a set for O(1) lookups arr_set = set(arr) # Find missing numbers by iterating from 1 to m missing_numbers = [num for num in range(1, m + 1) if num not in arr_set] return missing_numbers"},{"question":"def filter_employees_by_experience(employees: list, min_experience: int) -> list: Filters a list of employees based on a given minimum number of years of experience. Args: employees (list): List of dictionaries representing employees. Each dictionary has keys 'name', 'position', and 'years_experience'. min_experience (int): The minimum number of years of experience required to pass the filter. Returns: list: A list of dictionaries representing the employees who meet the experience criteria. Examples: >>> filter_employees_by_experience( [ {\\"name\\": \\"Alice\\", \\"position\\": \\"Engineer\\", \\"years_experience\\": 5}, {\\"name\\": \\"Bob\\", \\"position\\": \\"Manager\\", \\"years_experience\\": 8}, {\\"name\\": \\"Charlie\\", \\"position\\": \\"Intern\\", \\"years_experience\\": 1} ], 4 ) [{'name': 'Alice', 'position': 'Engineer', 'years_experience': 5}, {'name': 'Bob', 'position': 'Manager', 'years_experience': 8}] >>> filter_employees_by_experience( [ {\\"name\\": \\"Alice\\", \\"position\\": \\"Engineer\\", \\"years_experience\\": 1}, {\\"name\\": \\"Bob\\", \\"position\\": \\"Manager\\", \\"years_experience\\": 2}, {\\"name\\": \\"Charlie\\", \\"position\\": \\"Intern\\", \\"years_experience\\": 0} ], 4 ) [] pass","solution":"def filter_employees_by_experience(employees: list, min_experience: int) -> list: Filters a list of employees based on a given minimum number of years of experience. Args: employees (list): List of dictionaries representing employees. Each dictionary has keys 'name', 'position', and 'years_experience'. min_experience (int): The minimum number of years of experience required to pass the filter. Returns: list: A list of dictionaries representing the employees who meet the experience criteria. return [employee for employee in employees if employee['years_experience'] >= min_experience]"},{"question":"def max_sales_gain(sales: List[int]) -> int: Calculate the maximum difference between any two daily sales figures where the later day has higher sales than an earlier day. >>> max_sales_gain([100, 200, 150, 300, 250, 500]) 400 >>> max_sales_gain([500, 400, 300, 200, 100]) 0 >>> max_sales_gain([100, 100, 100, 100, 100]) 0","solution":"def max_sales_gain(sales): Returns the maximum difference (gain) between any two days where the later day has a higher sales figure than an earlier day. if not sales or len(sales) < 2: return 0 min_sales = sales[0] max_gain = 0 for sale in sales[1:]: if sale > min_sales: max_gain = max(max_gain, sale - min_sales) min_sales = min(min_sales, sale) return max_gain"},{"question":"from typing import Callable, Union class Node: def __init__(self, value: int = 0) -> None: self.value = value self.next: Union['Node', None] = None def remove_nodes_by_pattern(head: Node | None, pattern: Callable[[int], bool]) -> Node | None: Remove all nodes from the linked list whose values follow a given pattern. >>> def is_even(value): return value % 2 == 0 >>> head = Node(1) >>> head.next = Node(2) >>> head.next.next = Node(3) >>> head.next.next.next = Node(4) >>> head.next.next.next.next = Node(5) >>> updated_head = remove_nodes_by_pattern(head, is_even) >>> current = updated_head >>> while current: ... print(current.value, end=\\" \\") ... current = current.next 1 3 5 pass","solution":"from typing import Callable, Union class Node: def __init__(self, value: int = 0) -> None: self.value = value self.next: Union['Node', None] = None def remove_nodes_by_pattern(head: Node | None, pattern: Callable[[int], bool]) -> Node | None: dummy = Node(0) dummy.next = head prev, current = dummy, head while current is not None: if pattern(current.value): prev.next = current.next else: prev = current current = current.next return dummy.next"},{"question":"def balance_binary_string(s: str) -> int: This function returns the maximum number of balanced substrings such that each substring contains an equal number of '0's and '1's. If it is not possible to split the string into such substrings, the function returns -1. >>> balance_binary_string(\\"0011\\") 1 >>> balance_binary_string(\\"010101\\") 3 >>> balance_binary_string(\\"000111\\") 1 >>> balance_binary_string(\\"0000\\") -1 # Implement the function here def test_balance_binary_string(): assert balance_binary_string(\\"0011\\") == 1 assert balance_binary_string(\\"010101\\") == 3 assert balance_binary_string(\\"000111\\") == 1 assert balance_binary_string(\\"0000\\") == -1 assert balance_binary_string(\\"01\\") == 1 assert balance_binary_string(\\"00001111\\") == 1 assert balance_binary_string(\\"0101\\") == 2 assert balance_binary_string(\\"11110000\\") == 1 assert balance_binary_string(\\"1\\") == -1 assert balance_binary_string(\\"0\\") == -1 assert balance_binary_string(\\"0110\\") == 2 if __name__ == \\"__main__\\": test_balance_binary_string() print(\\"All tests passed!\\")","solution":"def balance_binary_string(s: str) -> int: This function returns the maximum number of balanced substrings such that each substring contains an equal number of '0's and '1's. If it is not possible to split the string into such substrings, the function returns -1. count_0 = 0 count_1 = 0 max_balanced_substrings = 0 for ch in s: if ch == '0': count_0 += 1 else: count_1 += 1 if count_0 == count_1: max_balanced_substrings += 1 if count_0 != count_1: return -1 return max_balanced_substrings"},{"question":"class Stack: def __init__(self): self.items = [] def push(self, item): self.items.append(item) def pop(self): if not self.is_empty(): return self.items.pop() def peek(self): if not self.is_empty(): return self.items[-1] def is_empty(self): return len(self.items) == 0 def __iter__(self): # To allow comparison using list() for testing return iter(self.items[::-1]) def sort_stack(self): Sort the stack in ascending order using an auxiliary stack. Returns: None Examples: >>> stack = Stack() >>> stack.push(34) >>> stack.push(3) >>> stack.push(31) >>> stack.push(98) >>> stack.push(92) >>> stack.push(23) >>> list(stack) [23, 92, 98, 31, 3, 34] >>> stack.sort_stack() >>> list(stack) [3, 23, 31, 34, 92, 98] pass # Your sorting implementation goes here import pytest def test_sort_stack_multiple_elements(): stack = Stack() stack.push(34) stack.push(3) stack.push(31) stack.push(98) stack.push(92) stack.push(23) assert list(stack) == [23, 92, 98, 31, 3, 34] stack.sort_stack() assert list(stack) == [3, 23, 31, 34, 92, 98] def test_sort_stack_empty(): stack = Stack() assert list(stack) == [] stack.sort_stack() assert list(stack) == [] def test_sort_stack_single_element(): stack = Stack() stack.push(1) assert list(stack) == [1] stack.sort_stack() assert list(stack) == [1] def test_sort_stack_two_elements(): stack = Stack() stack.push(2) stack.push(1) assert list(stack) == [1, 2] stack.sort_stack() assert list(stack) == [1, 2] def test_sort_stack_already_sorted(): stack = Stack() elements = [5, 4, 3, 2, 1] for element in elements: stack.push(element) assert list(stack) == [1, 2, 3, 4, 5] stack.sort_stack() assert list(stack) == [1, 2, 3, 4, 5] def test_sort_stack_reverse_order(): stack = Stack() elements = [1, 2, 3, 4, 5] for element in elements: stack.push(element) assert list(stack) == [5, 4, 3, 2, 1] stack.sort_stack() assert list(stack) == [1, 2, 3, 4, 5] def test_sort_stack_with_duplicates(): stack = Stack() elements = [5, 1, 3, 2, 2, 5] for element in elements: stack.push(element) assert list(stack) == [5, 2, 2, 3, 1, 5] stack.sort_stack() assert list(stack) == [1, 2, 2, 3, 5, 5]","solution":"class Stack: def __init__(self): self.items = [] def push(self, item): self.items.append(item) def pop(self): if not self.is_empty(): return self.items.pop() def peek(self): if not self.is_empty(): return self.items[-1] def is_empty(self): return len(self.items) == 0 def __iter__(self): # To allow comparison using list() for testing return iter(self.items[::-1]) def sort_stack(self): Sort the stack in ascending order using an auxiliary stack. auxiliary_stack = Stack() while not self.is_empty(): # Take the top element from the original stack current = self.pop() # Transfer elements from auxiliary stack back to original stack # until correct position for current is found while not auxiliary_stack.is_empty() and auxiliary_stack.peek() > current: self.push(auxiliary_stack.pop()) # Place current in its sorted position auxiliary_stack.push(current) # Transfer sorted elements back to the original stack while not auxiliary_stack.is_empty(): self.push(auxiliary_stack.pop())"},{"question":"from typing import List def find_dna_pattern_occurrences(genome: str, pattern: str) -> List[int]: This function returns a list of starting indices where the pattern is found within the genome. It also prints the time taken for the search. >>> find_dna_pattern_occurrences(\\"ACGTACGTGACG\\", \\"ACG\\") Pattern found at indices: [0, 4, 9] Time taken: 1.2 ms >>> find_dna_pattern_occurrences(\\"\\", \\"A\\") Pattern found at indices: [] Time taken: 0.0 ms >>> find_dna_pattern_occurrences(\\"ACGT\\", \\"ACGTG\\") Pattern found at indices: [] Time taken: 0.0 ms >>> find_dna_pattern_occurrences(\\"ACGT\\", \\"ACGT\\") Pattern found at indices: [0] Time taken: 0.1 ms >>> find_dna_pattern_occurrences(\\"ACACACAC\\", \\"AC\\") Pattern found at indices: [0, 2, 4, 6] Time taken: 4.3 ms >>> find_dna_pattern_occurrences(\\"AAAA\\", \\"AA\\") Pattern found at indices: [0, 1, 2] Time taken: 3.8 ms >>> find_dna_pattern_occurrences(\\"ACGTACGT\\", \\"TTT\\") Pattern found at indices: [] Time taken: 1.0 ms >>> find_dna_pattern_occurrences(\\"ACGTGACGT\\", \\"GACGT\\") Pattern found at indices: [4] Time taken: 2.5 ms pass","solution":"from typing import List import time def find_dna_pattern_occurrences(genome: str, pattern: str) -> List[int]: This function returns a list of starting indices where the pattern is found within the genome. It also prints the time taken for the search. start_time = time.time() occurrences = [] # Simple substring search for i in range(len(genome) - len(pattern) + 1): if genome[i:i+len(pattern)] == pattern: occurrences.append(i) end_time = time.time() time_taken = (end_time - start_time) * 1000 # time in milliseconds print(f\\"Pattern found at indices: {occurrences}\\") print(f\\"Time taken: {time_taken:.2f} ms\\") return occurrences"},{"question":"from PIL import Image import numpy as np from typing import Tuple def detect_dominant_color(img_path: str) -> Tuple[int, int, int]: Detects the dominant color in an image. Parameters: img_path (str): The path to the input image file. Returns: tuple: A tuple representing the RGB values of the dominant color. (R, G, B) where each value is between 0 and 255. # Your code here # Unit tests def test_detect_dominant_color_red(): # Create a solid red image img = Image.new('RGB', (100, 100), color = (255, 0, 0)) img_path = '/tmp/red_image.png' img.save(img_path) assert detect_dominant_color(img_path) == (255, 0, 0) def test_detect_dominant_color_green(): # Create a solid green image img = Image.new('RGB', (100, 100), color = (0, 255, 0)) img_path = '/tmp/green_image.png' img.save(img_path) assert detect_dominant_color(img_path) == (0, 255, 0) def test_detect_dominant_color_blue(): # Create a solid blue image img = Image.new('RGB', (100, 100), color = (0, 0, 255)) img_path = '/tmp/blue_image.png' img.save(img_path) assert detect_dominant_color(img_path) == (0, 0, 255) def test_detect_dominant_color_mixed(): # Create an image with equal areas of red, green, and blue img = Image.new('RGB', (300, 100)) for i in range(100): for j in range(300): if j < 100: img.putpixel((j, i), (255, 0, 0)) elif j < 200: img.putpixel((j, i), (0, 255, 0)) else: img.putpixel((j, i), (0, 0, 255)) img_path = '/tmp/mixed_image.png' img.save(img_path) # In this case any of the three colors could be dominant dominant_color = detect_dominant_color(img_path) assert dominant_color in [(255, 0, 0), (0, 255, 0), (0, 0, 255)]","solution":"from PIL import Image import numpy as np from collections import Counter def detect_dominant_color(img_path: str) -> tuple: Detects the dominant color in an image. Parameters: img_path (str): The path to the input image file. Returns: tuple: A tuple representing the RGB values of the dominant color. (R, G, B) where each value is between 0 and 255. # Open the image using PIL image = Image.open(img_path) # Convert the image to RGB mode (if not already in RGB) image = image.convert('RGB') # Resize the image to speed up the process (optional) image = image.resize((100, 100)) # Convert the image to a numpy array np_image = np.array(image) # Reshape the array to be a list of pixels pixels = np_image.reshape(-1, 3) # Use Counter to find the most common pixel (color) dominant_color = Counter(map(tuple, pixels)).most_common(1)[0][0] return dominant_color"},{"question":"import re def markdown_to_html(markdown_text: str) -> str: Converts Markdown formatted text into HTML. Headers: - Convert lines starting with \`#\` to \`<h1>\`, \`\` to \`<h2>\`, and \`#\` to \`<h3>\`. Bold text: - Convert text wrapped with \`**\` to be inside \`<b>\` tags. Italic text: - Convert text wrapped with \`_\` to be inside \`<i>\` tags. Paragraphs: - Any text not fitting the above rules should be encapsulated within \`<p>\` tags. >>> markdown_to_html(\\"# Heading 1\\") '<h1>Heading 1</h1>' >>> markdown_to_html(\\" Heading 2\\") '<h2>Heading 2</h2>' >>> markdown_to_html(\\"# Heading 3\\") '<h3>Heading 3</h3>' >>> markdown_to_html(\\"This is **bold** text.\\") '<p>This is <b>bold</b> text.</p>' >>> markdown_to_html(\\"This is _italic_ text.\\") '<p>This is <i>italic</i> text.</p>' >>> markdown_to_html(\\"This is **bold** and _italic_ text.\\") '<p>This is <b>bold</b> and <i>italic</i> text.</p>' >>> markdown_to_html(\\"Paragraph 1.nnParagraph 2.\\") '<p>Paragraph 1.</p><p>Paragraph 2.</p>' >>> markdown_to_html(\\"# Heading 1n Heading 2nSome **bold** text and some _italic_ text.nnAnother paragraph.\\") '<h1>Heading 1</h1><h2>Heading 2</h2><p>Some <b>bold</b> text and some <i>italic</i> text.</p><p>Another paragraph.</p>' >>> markdown_to_html(\\"\\") '' >>> markdown_to_html(\\"Just a simple paragraph.\\") '<p>Just a simple paragraph.</p>'","solution":"import re def markdown_to_html(markdown_text): Converts Markdown formatted text into HTML. html_text = [] if not markdown_text.strip(): return \\"\\" paragraphs = markdown_text.strip().split(\\"nn\\") for para in paragraphs: lines = para.split(\\"n\\") for line in lines: line = re.sub(r\\"(?<!)**(.*?)**\\", r\\"<b>1</b>\\", line) # Bold line = re.sub(r\\"(?<!)_(.*?)_\\", r\\"<i>1</i>\\", line) # Italic if line.startswith('# '): html_text.append(f\\"<h3>{line[4:]}</h3>\\") elif line.startswith(' '): html_text.append(f\\"<h2>{line[3:]}</h2>\\") elif line.startswith('# '): html_text.append(f\\"<h1>{line[2:]}</h1>\\") else: html_text.append(f\\"<p>{line}</p>\\") return ''.join(html_text)"},{"question":"from typing import List class CourseEnrollment: Course Enrollment Application Implement a class \`CourseEnrollment\` that supports enrolling students in courses and querying course and enrollment information. Methods: - enroll_student(self, student: str, course: str): Enrolls a student in a course. - courses_for_student(self, student: str) -> List[str]: Returns a list of courses the given student is enrolled in, sorted in alphabetical order. - students_in_course(self, course: str) -> List[str]: Returns a list of students enrolled in the given course, sorted in alphabetical order. Example Usage: >>> enrollment = CourseEnrollment() >>> enrollment.enroll_student(\\"Alice\\", \\"Math\\") >>> enrollment.enroll_student(\\"Bob\\", \\"Math\\") >>> enrollment.enroll_student(\\"Alice\\", \\"History\\") >>> enrollment.courses_for_student(\\"Alice\\") ['History', 'Math'] >>> enrollment.students_in_course(\\"Math\\") ['Alice', 'Bob'] >>> enrollment.students_in_course(\\"History\\") ['Alice'] >>> enrollment.courses_for_student(\\"Bob\\") ['Math'] def __init__(self): pass def enroll_student(self, student: str, course: str): pass def courses_for_student(self, student: str) -> List[str]: pass def students_in_course(self, course: str) -> List[str]: pass Unit Test: def test_enroll_student(): enrollment = CourseEnrollment() enrollment.enroll_student(\\"Alice\\", \\"Math\\") enrollment.enroll_student(\\"Alice\\", \\"Science\\") enrollment.enroll_student(\\"Bob\\", \\"Math\\") # Check Alice's courses assert enrollment.courses_for_student(\\"Alice\\") == [\\"Math\\", \\"Science\\"] # Check Bob's courses assert enrollment.courses_for_student(\\"Bob\\") == [\\"Math\\"] # Check non-enrolled student's courses assert enrollment.courses_for_student(\\"Charlie\\") == [] def test_students_in_course(): enrollment = CourseEnrollment() enrollment.enroll_student(\\"Alice\\", \\"Math\\") enrollment.enroll_student(\\"Alice\\", \\"Science\\") enrollment.enroll_student(\\"Bob\\", \\"Math\\") # Check students in Math course assert enrollment.students_in_course(\\"Math\\") == [\\"Alice\\", \\"Bob\\"] # Check students in Science course assert enrollment.students_in_course(\\"Science\\") == [\\"Alice\\"] # Check non-enrolled course's students assert enrollment.students_in_course(\\"History\\") == [] def test_no_duplicate_enrollments(): enrollment = CourseEnrollment() enrollment.enroll_student(\\"Alice\\", \\"Math\\") enrollment.enroll_student(\\"Alice\\", \\"Math\\") # Duplicate enrollment # Check Alice's courses assert enrollment.courses_for_student(\\"Alice\\") == [\\"Math\\"] # Check students in Math course assert enrollment.students_in_course(\\"Math\\") == [\\"Alice\\"] def test_mixed_case_handling(): enrollment = CourseEnrollment() enrollment.enroll_student(\\"Alice\\", \\"math\\") enrollment.enroll_student(\\"alice\\", \\"Math\\") # Different case should be treated as different # Check \\"Alice\\" courses assert enrollment.courses_for_student(\\"Alice\\") == [\\"math\\"] # Check \\"alice\\" courses assert enrollment.courses_for_student(\\"alice\\") == [\\"Math\\"] # Check students in \\"math\\" course assert enrollment.students_in_course(\\"math\\") == [\\"Alice\\"] # Check students in \\"Math\\" course assert enrollment.students_in_course(\\"Math\\") == [\\"alice\\"]","solution":"from typing import List class CourseEnrollment: def __init__(self): self.student_courses = {} self.course_students = {} def enroll_student(self, student: str, course: str): if student not in self.student_courses: self.student_courses[student] = set() if course not in self.course_students: self.course_students[course] = set() self.student_courses[student].add(course) self.course_students[course].add(student) def courses_for_student(self, student: str) -> List[str]: if student not in self.student_courses: return [] return sorted(self.student_courses[student]) def students_in_course(self, course: str) -> List[str]: if course not in self.course_students: return [] return sorted(self.course_students[course])"},{"question":"class AutocompleteSystem: def __init__(self): Initialize the AutocompleteSystem with an empty dictionary. pass def add_word(self, word: str, frequency: int) -> None: Add a word to the dictionary with the given frequency. If the word already exists, update its frequency. Args: - word (str): The word to add to the dictionary. - frequency (int): The frequency of the word. pass def get_suggestions(self, prefix: str, k: int) -> list[str]: Get up to k suggestions for the given prefix ordered by frequency. If two words have the same frequency, order them lexicographically. Args: - prefix (str): The prefix to autocomplete. - k (int): The maximum number of suggestions to return. Returns: - list[str]: A list of up to k autocomplete suggestions. pass # Example Usage # Initialize the Autocomplete System auto_complete = AutocompleteSystem() # Add words to the dictionary with their frequencies auto_complete.add_word(\\"apple\\", 5) auto_complete.add_word(\\"app\\", 3) auto_complete.add_word(\\"application\\", 4) auto_complete.add_word(\\"appetizer\\", 3) # Get autocomplete suggestions for the prefix 'app' suggestions = auto_complete.get_suggestions(\\"app\\", 3) print(suggestions) # [\\"apple\\", \\"application\\", \\"appetizer\\"] or [\\"apple\\", \\"application\\", \\"app\\"] depending on if app and appetizer have same frequency # Add more words to update frequencies auto_complete.add_word(\\"apply\\", 2) # Get autocomplete suggestions for the prefix 'app' suggestions = auto_complete.get_suggestions(\\"app\\", 4) print(suggestions) # [\\"apple\\", \\"application\\", \\"appetizer\\", \\"apply\\"] # Unit tests def test_add_and_get_suggestions(): auto_complete = AutocompleteSystem() auto_complete.add_word(\\"apple\\", 5) auto_complete.add_word(\\"app\\", 3) auto_complete.add_word(\\"application\\", 4) auto_complete.add_word(\\"appetizer\\", 3) assert auto_complete.get_suggestions(\\"app\\", 3) == [\\"apple\\", \\"application\\", \\"app\\"] def test_update_word_frequency(): auto_complete = AutocompleteSystem() auto_complete.add_word(\\"apple\\", 5) auto_complete.add_word(\\"apple\\", 3) # Update frequency auto_complete.add_word(\\"app\\", 3) auto_complete.add_word(\\"application\\", 4) auto_complete.add_word(\\"appetizer\\", 3) assert auto_complete.get_suggestions(\\"app\\", 3) == [\\"apple\\", \\"application\\", \\"app\\"] def test_get_suggestions_more_than_k(): auto_complete = AutocompleteSystem() auto_complete.add_word(\\"apple\\", 5) auto_complete.add_word(\\"app\\", 3) auto_complete.add_word(\\"application\\", 4) auto_complete.add_word(\\"appetizer\\", 3) auto_complete.add_word(\\"apply\\", 2) assert auto_complete.get_suggestions(\\"app\\", 4) == [\\"apple\\", \\"application\\", \\"app\\", \\"appetizer\\"] def test_get_suggestions_with_ties(): auto_complete = AutocompleteSystem() auto_complete.add_word(\\"apple\\", 5) auto_complete.add_word(\\"app\\", 3) auto_complete.add_word(\\"application\\", 4) auto_complete.add_word(\\"appetizer\\", 3) auto_complete.add_word(\\"apprt\\", 3) assert auto_complete.get_suggestions(\\"app\\", 4) == [\\"apple\\", \\"application\\", \\"app\\", \\"appetizer\\"] def test_get_suggestions_no_results(): auto_complete = AutocompleteSystem() auto_complete.add_word(\\"banana\\", 5) auto_complete.add_word(\\"band\\", 3) auto_complete.add_word(\\"bandana\\", 4) assert auto_complete.get_suggestions(\\"cat\\", 3) == []","solution":"class AutocompleteSystem: def __init__(self): Initialize the AutocompleteSystem with an empty dictionary. self.word_freq = {} def add_word(self, word: str, frequency: int) -> None: Add a word to the dictionary with the given frequency. If the word already exists, update its frequency. Args: - word (str): The word to add to the dictionary. - frequency (int): The frequency of the word. if word in self.word_freq: self.word_freq[word] += frequency else: self.word_freq[word] = frequency def get_suggestions(self, prefix: str, k: int) -> list: Get up to k suggestions for the given prefix ordered by frequency. If two words have the same frequency, order them lexicographically. Args: - prefix (str): The prefix to autocomplete. - k (int): The maximum number of suggestions to return. Returns: - list: A list of up to k autocomplete suggestions. suggestions = [word for word in self.word_freq if word.startswith(prefix)] sorted_suggestions = sorted(suggestions, key=lambda x: (-self.word_freq[x], x)) return sorted_suggestions[:k]"},{"question":"from typing import List, Tuple def detect_negative_cycle(n: int, edges: List[Tuple[int, int, int]]) -> bool: Detect if there is a negative weight cycle in the given graph using the Bellman-Ford algorithm. :param n: Number of vertices in the graph. :param edges: List of edges represented as tuples (u, v, w) where 'u' is the start vertex, 'v' is the end vertex, and 'w' is the weight of the edge. :return: True if there is a negative weight cycle, False otherwise. >>> detect_negative_cycle(5, [(0, 1, 1), (1, 2, -1), (2, 0, -1)]) True >>> detect_negative_cycle(4, [(0, 1, 2), (1, 2, 3), (2, 3, 4)]) False","solution":"def detect_negative_cycle(n, edges): Detect if there is a negative weight cycle in the given graph using the Bellman-Ford algorithm. :param n: Number of vertices in the graph. :param edges: List of edges represented as tuples (u, v, w) where 'u' is the start vertex, 'v' is the end vertex, and 'w' is the weight of the edge. :return: True if there is a negative weight cycle, False otherwise. # Initialize distances with INF except the start vertex inf = float('inf') distance = [inf] * n distance[0] = 0 # Relax edges up to n-1 times for _ in range(n - 1): for u, v, w in edges: if distance[u] != inf and distance[u] + w < distance[v]: distance[v] = distance[u] + w # Check for negative weight cycles for u, v, w in edges: if distance[u] != inf and distance[u] + w < distance[v]: return True return False"},{"question":"class GridIllumination: Grid Illumination System to track the lighting status of grid cells. >>> grid = GridIllumination(5) >>> grid.toggle(2, 3) >>> grid.query(2, 3) True >>> len(grid) 1 >>> grid.toggle(2, 3) >>> grid.query(2, 3) False >>> len(grid) 0 >>> grid.toggle(0, 0) >>> grid.toggle(1, 1) >>> len(grid) 2 def __init__(self, n: int): # Initialize the grid with all cells dark. def toggle(self, row: int, col: int): # Toggle the status of the cell at the given coordinates. def query(self, row: int, col: int) -> bool: # Return the current status of the cell at the given coordinates. def __len__(self) -> int: # Return the number of cells that are currently lit in the grid. def test_initial_state(): grid = GridIllumination(5) assert len(grid) == 0 for i in range(5): for j in range(5): assert grid.query(i, j) == False def test_toggle_and_query(): grid = GridIllumination(5) grid.toggle(0, 0) assert grid.query(0, 0) == True grid.toggle(0, 0) assert grid.query(0, 0) == False grid.toggle(2, 2) assert grid.query(2, 2) == True grid.toggle(2, 2) assert grid.query(2, 2) == False def test_len(): grid = GridIllumination(5) assert len(grid) == 0 grid.toggle(0, 0) assert len(grid) == 1 grid.toggle(4, 4) assert len(grid) == 2 grid.toggle(0, 0) assert len(grid) == 1 def test_multiple_toggles(): grid = GridIllumination(5) grid.toggle(1, 1) grid.toggle(2, 2) grid.toggle(3, 3) assert len(grid) == 3 grid.toggle(1, 1) assert len(grid) == 2 grid.toggle(2, 2) assert len(grid) == 1 grid.toggle(3, 3) assert len(grid) == 0 def test_edge_cases(): grid = GridIllumination(5) grid.toggle(0, 0) grid.toggle(4, 4) assert grid.query(0, 0) == True assert grid.query(4, 4) == True assert len(grid) == 2","solution":"class GridIllumination: def __init__(self, n: int): self.n = n self.grid = [[False] * n for _ in range(n)] self.lit_count = 0 def toggle(self, row: int, col: int): if self.grid[row][col]: self.grid[row][col] = False self.lit_count -= 1 else: self.grid[row][col] = True self.lit_count += 1 def query(self, row: int, col: int) -> bool: return self.grid[row][col] def __len__(self) -> int: return self.lit_count"},{"question":"def is_complete_binary_tree(nodes): Determine if the binary tree represented by \`nodes\` in level-order traversal is a complete binary tree. :param nodes: List of integers and None values representing the binary tree :return: Boolean indicating whether the binary tree is complete","solution":"def is_complete_binary_tree(nodes): Determine if the binary tree represented by \`nodes\` in level-order traversal is a complete binary tree. :param nodes: List of integers and None values representing the binary tree :return: Boolean indicating whether the binary tree is complete if not nodes: return True n = len(nodes) index = 0 # Find the first missing node and store its index while index < n and nodes[index] is not None: index += 1 # If all nodes are present, it's a complete binary tree if index == n: return True # After the first None, all subsequent elements must also be None while index < n: if nodes[index] is not None: return False index += 1 return True"},{"question":"class TextEditor: def __init__(self): Initializes the TextEditor with an empty document and history. pass def append(self, text: str): Appends the given text to the document. Args: text (str): The text to append. pass def undo(self): Reverts the document to its state before the last operation. pass def bold(self, range: tuple): Applies bold formatting to the specified range. Args: range (tuple): A tuple (start, end) specifying the inclusive range to be bolded. pass def italic(self, range: tuple): Applies italics formatting to the specified range. Args: range (tuple): A tuple (start, end) specifying the inclusive range to be italicized. pass def print(self) -> str: Returns the current state of the document with applied formatting. Returns: str: The current state of the document. pass from solution import TextEditor def test_append(): editor = TextEditor() editor.append(\\"Hello\\") assert editor.print() == \\"Hello\\" editor.append(\\", World!\\") assert editor.print() == \\"Hello, World!\\" def test_undo_append(): editor = TextEditor() editor.append(\\"Hello\\") editor.append(\\", World!\\") editor.undo() assert editor.print() == \\"Hello\\" editor.undo() assert editor.print() == \\"\\" def test_bold_formatting(): editor = TextEditor() editor.append(\\"Hello, World!\\") editor.bold((7, 11)) assert editor.print() == \\"Hello, <b>World</b>!\\" def test_italic_formatting(): editor = TextEditor() editor.append(\\"Hello, World!\\") editor.italic((0, 4)) assert editor.print() == \\"<i>Hello</i>, World!\\" def test_combined_formatting(): editor = TextEditor() editor.append(\\"Hello, World!\\") editor.bold((7, 11)) editor.append(\\" How are you?\\") assert editor.print() == \\"Hello, <b>World</b>! How are you?\\" editor.italic((0, 4)) assert editor.print() == \\"<i>Hello</i>, <b>World</b>! How are you?\\" def test_undo_formatting(): editor = TextEditor() editor.append(\\"Hello, World!\\") editor.bold((7, 11)) editor.italic((0, 4)) editor.undo() assert editor.print() == \\"Hello, <b>World</b>!\\" editor.undo() assert editor.print() == \\"Hello, World!\\" def test_edge_cases(): editor = TextEditor() editor.append(\\"Edge\\") editor.bold((0, 4)) assert editor.print() == \\"<b>Edge</b>\\" editor.undo() assert editor.print() == \\"Edge\\" editor.italic((0, 3)) assert editor.print() == \\"<i>Edge</i>\\" editor.undo() assert editor.print() == \\"Edge\\" editor.bold((1, 3)) assert editor.print() == \\"E<b>dge</b>\\"","solution":"class TextEditor: def __init__(self): self.history = [] self.document = \\"\\" def append(self, text: str): self.history.append(self.document) self.document += text def undo(self): if self.history: self.document = self.history.pop() def bold(self, range: tuple): self.history.append(self.document) start, end = range self.document = self.document[:start] + \\"<b>\\" + self.document[start:end+1] + \\"</b>\\" + self.document[end+1:] def italic(self, range: tuple): self.history.append(self.document) start, end = range self.document = self.document[:start] + \\"<i>\\" + self.document[start:end+1] + \\"</i>\\" + self.document[end+1:] def print(self) -> str: return self.document"},{"question":"def count_unique_words(text: str) -> dict: Takes a string 'text' and returns a dictionary where the keys are unique words in alphabetical order and the values are the number of times each word appears in the text. >>> count_unique_words(\\"hello world hello\\") {\\"hello\\": 2, \\"world\\": 1} >>> count_unique_words(\\"the quick brown fox jumps over the lazy dog\\") {\\"brown\\": 1, \\"dog\\": 1, \\"fox\\": 1, \\"jumps\\": 1, \\"lazy\\": 1, \\"over\\": 1, \\"quick\\": 1, \\"the\\": 2} >>> count_unique_words(\\"a a a b b c\\") {\\"a\\": 3, \\"b\\": 2, \\"c\\": 1}","solution":"def count_unique_words(text: str) -> dict: Takes a string 'text' and returns a dictionary where the keys are unique words in alphabetical order and the values are the number of times each word appears in the text. words = text.split() word_counts = {} for word in words: if word in word_counts: word_counts[word] += 1 else: word_counts[word] = 1 sorted_word_counts = dict(sorted(word_counts.items())) return sorted_word_counts"},{"question":"def custom_string_sort(string_list: list[str], order: str) -> list[str]: Sorts a list of strings based on the given character precedence order. Parameters: string_list (list of str): A list of strings to be sorted. order (str): A string representing the desired character order. Returns: list of str: Sorted list of strings according to the given character precedence. Examples: >>> custom_string_sort([\\"cabbage\\", \\"apple\\", \\"banana\\"], \\"zyxwvutsrqponmlkjihgfedcba\\") ['cabbage', 'banana', 'apple'] >>> custom_string_sort([\\"dog\\", \\"cat\\", \\"bird\\"], \\"abcdefghijklmnopqrstuvwxyz\\") ['bird', 'cat', 'dog'] >>> custom_string_sort([\\"xyz\\", \\"abc\\", \\"def\\"], \\"zyxwvutsrqponmlkjihgfedcba\\") ['xyz', 'def', 'abc'] >>> custom_string_sort([\\"a\\", \\"aaa\\", \\"aa\\"], \\"abcdefgh\\") ['a', 'aa', 'aaa']","solution":"def custom_string_sort(string_list: list[str], order: str) -> list[str]: Sorts a list of strings based on the given character precedence order. Parameters: string_list (list of str): A list of strings to be sorted. order (str): A string representing the desired character order. Returns: list of str: Sorted list of strings according to the given character precedence. Examples: >>> custom_string_sort([\\"cabbage\\", \\"apple\\", \\"banana\\"], \\"zyxwvutsrqponmlkjihgfedcba\\") ['cabbage', 'banana', 'apple'] >>> custom_string_sort([\\"dog\\", \\"cat\\", \\"bird\\"], \\"abcdefghijklmnopqrstuvwxyz\\") ['bird', 'cat', 'dog'] >>> custom_string_sort([\\"xyz\\", \\"abc\\", \\"def\\"], \\"zyxwvutsrqponmlkjihgfedcba\\") ['xyz', 'def', 'abc'] >>> custom_string_sort([\\"a\\", \\"aaa\\", \\"aa\\"], \\"abcdefgh\\") ['a', 'aa', 'aaa'] # Create a dictionary to map each character in \`order\` to its index order_index = {char: idx for idx, char in enumerate(order)} # Define a custom key function that transforms each string into a tuple of indices def custom_key(string): return [order_index[char] for char in string] # Sort the list with the custom key return sorted(string_list, key=custom_key)"},{"question":"def reverse_words(s: str) -> str: Returns a new string with the words in reverse order, while preserving the original order of characters within each word. >>> reverse_words(\\"the sky is blue\\") == \\"blue is sky the\\" >>> reverse_words(\\"hello world\\") == \\"world hello\\" >>> reverse_words(\\"a b c d\\") == \\"d c b a\\" >>> reverse_words(\\"single_word\\") == \\"single_word\\" >>> reverse_words(\\"\\") == \\"\\" >>> reverse_words(\\"a\\") == \\"a\\"","solution":"def reverse_words(s): Returns a new string with the words in reverse order, while preserving the original order of characters within each word. words = s.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"def mask_digits(s: str) -> str: Masks all the digits in the input string by replacing them with the \\"#\\" symbol. Args: s (str): The input string containing lowercase and uppercase alphabetic characters, digits, and special characters. Returns: str: A new string with all digits replaced by \\"#\\". Examples: >>> mask_digits(\\"Hello123\\") 'Hello#' >>> mask_digits(\\"P@ssw0rd!\\") 'P@ssw#rd!' >>> mask_digits(\\"Secr3tC0d3\\") 'Secr#tC#d#' >>> mask_digits(\\"2022-10-04\\") '--' >>> mask_digits(\\"UniVers1ty3\\") 'UniVers#ty#' >>> mask_digits(\\"!23*abc\\") '!*abc'","solution":"def mask_digits(s: str) -> str: Returns a new string where all digits in the input string are replaced with the \\"#\\" symbol. return ''.join(['#' if char.isdigit() else char for char in s])"},{"question":"from http.server import SimpleHTTPRequestHandler, HTTPServer import os import time from email.utils import formatdate from datetime import datetime class CacheCompatibleHTTPRequestHandler(SimpleHTTPRequestHandler): def do_GET(self): Handle GET requests with caching support. # Handle the GET request logic here def cache_compatible_http_server(): Run the cache-compatible HTTP server. # Implement the server setup and start the server here if __name__ == \\"__main__\\": cache_compatible_http_server()","solution":"from http.server import SimpleHTTPRequestHandler, HTTPServer import os import time from email.utils import formatdate from datetime import datetime class CacheCompatibleHTTPRequestHandler(SimpleHTTPRequestHandler): def do_GET(self): filepath = self.translate_path(self.path) if not os.path.exists(filepath): self.send_error(404, \\"File not found\\") return last_modified = os.path.getmtime(filepath) last_modified_str = formatdate(last_modified, usegmt=True) if 'If-Modified-Since' in self.headers: if_modified_since = self.headers['If-Modified-Since'] try: if_modified_since_time = time.mktime(datetime.strptime(if_modified_since, '%a, %d %b %Y %H:%M:%S GMT').timetuple()) except ValueError: if_modified_since_time = 0 if last_modified <= if_modified_since_time: self.send_response(304) self.end_headers() return self.send_response(200) self.send_header('Last-Modified', last_modified_str) self.end_headers() with open(filepath, 'rb') as file: self.copyfile(file, self.wfile) def cache_compatible_http_server(): server_address = ('', 8080) httpd = HTTPServer(server_address, CacheCompatibleHTTPRequestHandler) print(\\"Serving on port 8080...\\") httpd.serve_forever() if __name__ == \\"__main__\\": cache_compatible_http_server()"},{"question":"import json import os def summarize_chat_log(file_path: str, output_path: str) -> dict: Processes a chat log file to extract and summarize user activity. Parameters: - file_path (str): The path to the chat log file. - output_path (str): The path where the summary report will be saved. Returns: - dict: A dictionary containing either the summary data or an error message. pass def setup_module(module): if not os.path.exists(\\"./chat_logs\\"): os.makedirs(\\"./chat_logs\\") with open('./chat_logs/log.txt', 'w') as f: f.write(\\"2023-10-10 10:10:10,user1,Hello worldn\\") f.write(\\"2023-10-10 10:11:10,user2,Hi there!n\\") f.write(\\"2023-10-10 10:12:10,user1,How are you?n\\") def teardown_module(module): if os.path.exists('./chat_logs/log.txt'): os.remove('./chat_logs/log.txt') if os.path.exists('./chat_summary/summary.json'): os.remove('./chat_summary/summary.json') def test_file_not_found(): result = summarize_chat_log(\\"./chat_logs/non_existing_file.txt\\", \\"./chat_summary/summary.json\\") assert result == {\\"error\\": \\"File not found\\"} def test_invalid_data_format(): invalid_data_path = './chat_logs/invalid_log.txt' with open(invalid_data_path, 'w') as f: f.write(\\"2023-10-10 10:10:10,user1n\\") result = summarize_chat_log(invalid_data_path, \\"./chat_summary/summary.json\\") assert result == {\\"error\\": \\"Invalid data format\\"} os.remove(invalid_data_path) def test_successful_summary(): result = summarize_chat_log(\\"./chat_logs/log.txt\\", \\"./chat_summary/summary.json\\") assert \\"user1\\" in result assert \\"user2\\" in result assert result[\\"user1\\"][\\"total_messages\\"] == 2 assert result[\\"user1\\"][\\"average_length\\"] == (len(\\"Hello world\\") + len(\\"How are you?\\")) / 2 assert result[\\"user2\\"][\\"total_messages\\"] == 1 assert result[\\"user2\\"][\\"average_length\\"] == len(\\"Hi there!\\") def test_summary_file_creation(): summarize_chat_log(\\"./chat_logs/log.txt\\", \\"./chat_summary/summary.json\\") assert os.path.exists(\\"./chat_summary/summary.json\\") with open(\\"./chat_summary/summary.json\\", 'r') as f: summary = json.load(f) assert \\"user1\\" in summary assert \\"user2\\" in summary","solution":"import json import os def summarize_chat_log(file_path: str, output_path: str) -> dict: Processes a chat log file to extract and summarize user activity. Parameters: - file_path (str): The path to the chat log file. - output_path (str): The path where the summary report will be saved. Returns: - dict: A dictionary containing either the summary data or an error message. user_activity = {} try: if not os.path.isfile(file_path): return {\\"error\\": \\"File not found\\"} with open(file_path, 'r') as file: for line in file: try: timestamp, user_id, message = line.strip().split(',', 2) if user_id not in user_activity: user_activity[user_id] = { \\"total_messages\\": 0, \\"total_length\\": 0, } user_activity[user_id][\\"total_messages\\"] += 1 user_activity[user_id][\\"total_length\\"] += len(message) except ValueError: return {\\"error\\": \\"Invalid data format\\"} for user_id in user_activity: user_activity[user_id][\\"average_length\\"] = ( user_activity[user_id][\\"total_length\\"] / user_activity[user_id][\\"total_messages\\"] ) try: if not os.path.exists(os.path.dirname(output_path)): os.makedirs(os.path.dirname(output_path)) with open(output_path, 'w') as outfile: json.dump(user_activity, outfile, indent=4) return user_activity except OSError as e: return {\\"error\\": f\\"File write error: {str(e)}\\"} except IOError as e: return {\\"error\\": f\\"File read error: {str(e)}\\"}"},{"question":"class FileSizeTracker: def __init__(self): Initialize your data structure here. def addFile(self, filename: str, filesize: int) -> None: Add a new file with its size. If the file already exists, overwrite its size. def updateFile(self, filename: str, newsize: int) -> None: Update the size of an existing file. def getMedianSize(self) -> float: Return the median size of all tracked files. If there are an even number of files, return the average of the two middle sizes. # Example usage: tracker = FileSizeTracker() tracker.addFile('file1', 100) tracker.addFile('file2', 200) tracker.updateFile('file1', 150) assert tracker.getMedianSize() == 175.0 tracker.addFile('file3', 300) tracker.addFile('file4', 400) assert tracker.getMedianSize() == 250.0","solution":"import bisect class FileSizeTracker: def __init__(self): Initialize your data structure here. self.file_sizes = {} self.sorted_sizes = [] def addFile(self, filename: str, filesize: int) -> None: Add a new file with its size. If the file already exists, overwrite its size. if filename in self.file_sizes: # Removing old file size from sorted list old_size = self.file_sizes[filename] self.sorted_sizes.remove(old_size) # Inserting new file size into the sorted list bisect.insort(self.sorted_sizes, filesize) self.file_sizes[filename] = filesize def updateFile(self, filename: str, newsize: int) -> None: Update the size of an existing file. if filename in self.file_sizes: # Removing old file size from sorted list old_size = self.file_sizes[filename] self.sorted_sizes.remove(old_size) # Inserting new file size into the sorted list bisect.insort(self.sorted_sizes, newsize) self.file_sizes[filename] = newsize def getMedianSize(self) -> float: Return the median size of all tracked files. If there are an even number of files, return the average of the two middle sizes. if not self.sorted_sizes: return None # or raise an exception n = len(self.sorted_sizes) mid = n // 2 if n % 2 == 1: # Odd number of elements return float(self.sorted_sizes[mid]) else: # Even number of elements return (self.sorted_sizes[mid - 1] + self.sorted_sizes[mid]) / 2"},{"question":"def rotational_kinetic_energy(moment_of_inertia: float, angular_velocity: float) -> float: Calculate the rotational kinetic energy of a rotating object. The rotational kinetic energy \`E\` can be calculated as: E = 0.5 * I * ^2 where \`I\` is the moment of inertia and \`\` is the angular velocity. Both \`moment_of_inertia\` and \`angular_velocity\` must be positive values. Raises: ValueError: If either \`moment_of_inertia\` or \`angular_velocity\` is not positive. Example: >>> rotational_kinetic_energy(10, 5) 125.0 >>> rotational_kinetic_energy(3.5, 2) 7.0 >>> rotational_kinetic_energy(-5, 3) Traceback (most recent call last): ... ValueError: moment_of_inertia and angular_velocity must be positive pass","solution":"def rotational_kinetic_energy(moment_of_inertia: float, angular_velocity: float) -> float: if moment_of_inertia <= 0 or angular_velocity <= 0: raise ValueError(\\"moment_of_inertia and angular_velocity must be positive\\") return 0.5 * moment_of_inertia * angular_velocity ** 2"},{"question":"def categorize_transaction(description: str) -> str: Automatically categorizes a transaction based on its description using predefined keywords. Args: description (str): A string representing the transaction description. Returns: str: The category of the transaction. Raises: TypeError: If the input is not a string. >>> categorize_transaction(\\"Paid at Walmart for groceries\\") 'grocery' >>> categorize_transaction(\\"Monthly gas bill payment\\") 'utilities' >>> categorize_transaction(\\"Movie night with friends\\") 'entertainment' >>> categorize_transaction(\\"Lunch at a cafe downtown\\") 'restaurant' >>> categorize_transaction(\\"Gift for a friend\\") 'miscellaneous' >>> categorize_transaction(12345) Traceback (most recent call last): ... TypeError: Description must be a string. pass","solution":"def categorize_transaction(description: str) -> str: Automatically categorizes a transaction based on its description using predefined keywords. Args: description (str): A string representing the transaction description. Returns: str: The category of the transaction. Raises: TypeError: If the input is not a string. if not isinstance(description, str): raise TypeError(\\"Description must be a string.\\") categories = { \\"grocery\\": [\\"walmart\\", \\"supermarket\\", \\"groceries\\"], \\"utilities\\": [\\"electric\\", \\"water\\", \\"gas\\", \\"utility\\"], \\"entertainment\\": [\\"movie\\", \\"netflix\\", \\"amusement\\"], \\"restaurant\\": [\\"restaurant\\", \\"dining\\", \\"cafe\\"], \\"transportation\\": [\\"taxi\\", \\"uber\\", \\"bus\\", \\"fuel\\"], \\"healthcare\\": [\\"hospital\\", \\"pharmacy\\", \\"doctor\\"] } description = description.lower() for category, keywords in categories.items(): for keyword in keywords: if keyword in description: return category return \\"miscellaneous\\""},{"question":"import random from typing import List def constrained_shuffle(nums: List[int]) -> List[int]: Returns a shuffled list where no integer appears in its original index. If the list has fewer than 2 elements, return it unchanged. >>> constrained_shuffle([1, 2, 3, 4, 5]) [2, 3, 1, 5, 4] >>> constrained_shuffle([1]) [1] >>> constrained_shuffle([]) [] >>> constrained_shuffle([1, 2]) [2, 1] def test_constrained_shuffle_empty(): assert constrained_shuffle([]) == [] def test_constrained_shuffle_one_element(): assert constrained_shuffle([1]) == [1] def test_constrained_shuffle_two_elements(): nums = [1, 2] shuffled = constrained_shuffle(nums) assert shuffled == [2, 1] # The only valid shuffle def test_constrained_shuffle_three_elements(): nums = [1, 2, 3] shuffled = constrained_shuffle(nums) assert len(shuffled) == 3 assert shuffled != nums for i in range(len(nums)): assert shuffled[i] != nums[i] def test_constrained_shuffle_larger_list(): nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] shuffled = constrained_shuffle(nums) assert len(shuffled) == len(nums) for i in range(len(nums)): assert shuffled[i] != nums[i] def test_constrained_shuffle_gives_valid_permutations(): nums = [10, 20, 30, 40, 50, 60] shuffled = constrained_shuffle(nums) assert len(shuffled) == len(nums) for i in range(len(nums)): assert shuffled[i] != nums[i] assert set(shuffled) == set(nums)","solution":"import random from typing import List def constrained_shuffle(nums: List[int]) -> List[int]: Returns a shuffled list where no integer appears in its original index. If the list has fewer than 2 elements, return it unchanged. if len(nums) < 2: return nums shuffled = nums[:] while True: random.shuffle(shuffled) if all(original != shuffled[idx] for idx, original in enumerate(nums)): break return shuffled"},{"question":"# Function: flatten_multilevel_list class Node: def __init__(self, val, next=None, prev=None, child=None): self.val = val self.next = next self.prev = prev self.child = child def flatten_multilevel_list(head: Node) -> Node: Flatten a multilevel doubly linked list to a single-level doubly linked list in place without using extra space for storing nodes. :param head: Node, head node of the multilevel doubly linked list :return: Node, head node of the flattened doubly linked list if not head: return head stack = [] current = head while current: if current.child: if current.next: stack.append(current.next) current.next.prev = None current.next = current.child current.child.prev = current current.child = None if not current.next and stack: current.next = stack.pop() current.next.prev = current current = current.next return head","solution":"class Node: def __init__(self, val, next=None, prev=None, child=None): self.val = val self.next = next self.prev = prev self.child = child def flatten_multilevel_list(head: Node) -> Node: if not head: return head stack = [] current = head while current: # If the current node has a child, we need to process the child if current.child: # If current node's next is not null, push it to the stack if current.next: stack.append(current.next) current.next.prev = None # Connect the current node to the child current.next = current.child current.child.prev = current current.child = None # If we reach the end of the current level and there's something on the stack if not current.next and stack: current.next = stack.pop() current.next.prev = current current = current.next return head"},{"question":"import math from typing import List def vector_magnitude(components: List[float]) -> float: Calculate the magnitude of a high-dimensional vector. Args: components: A list of floats representing the components of the vector. Returns: A float representing the magnitude of the vector. Examples: >>> vector_magnitude([3.0, 4.0]) 5.0 >>> vector_magnitude([1.0, 2.0, 2.0]) 3.0 >>> vector_magnitude([0.0, 0.0, 0.0, 0.0]) 0.0","solution":"import math from typing import List def vector_magnitude(components: List[float]) -> float: Calculate the magnitude of a high-dimensional vector. Args: components: A list of floats representing the components of the vector. Returns: A float representing the magnitude of the vector. return math.sqrt(sum(x**2 for x in components))"},{"question":"from typing import Dict, List, Tuple def initialize_graph(edges: List[Tuple[str, str, int]]) -> Dict[str, Dict[str, int]]: Initialize a graph with given edges ensuring non-negative weights. >>> initialize_graph([('A', 'B', 1), ('A', 'C', 4), ('B', 'C', 2), ('B', 'D', 5), ('C', 'D', 1)]) {'A': {'B': 1, 'C': 4}, 'B': {'C': 2, 'D': 5}, 'C': {'D': 1}, 'D': {}} >>> initialize_graph([('A', 'B', 1), ('A', 'C', -4)]) ValueError: Edge weights must be non-negative def dijkstra(graph: Dict[str, Dict[str, int]], start_node: str) -> Dict[str, int]: Compute the shortest path from a given start node to all other nodes using Dijkstra's algorithm. >>> graph = {'A': {'B': 1, 'C': 4}, 'B': {'C': 2, 'D': 5}, 'C': {'D': 1}, 'D': {}} >>> dijkstra(graph, 'A') {'A': 0, 'B': 1, 'C': 3, 'D': 4} >>> graph = {'A': {'B': 1}, 'B': {'C': 2}, 'C': {}, 'D': {'E': 1}, 'E': {}} >>> dijkstra(graph, 'A') {'A': 0, 'B': 1, 'C': 3, 'D': float('infinity'), 'E': float('infinity')} >>> graph = {'A': {}} >>> dijkstra(graph, 'A') {'A': 0} >>> graph = {'A': {'B': 1, 'C': 4}, 'B': {'C': 2, 'D': 5}, 'C': {'D': 1}, 'D': {}} >>> dijkstra(graph, 'E') ValueError: Start node not in graph","solution":"import heapq def initialize_graph(edges): graph = {} for edge in edges: u, v, weight = edge if weight < 0: raise ValueError(\\"Edge weights must be non-negative\\") if u not in graph: graph[u] = {} if v not in graph: graph[v] = {} graph[u][v] = weight return graph def dijkstra(graph, start_node): if start_node not in graph: raise ValueError(\\"Start node not in graph\\") distances = {node: float('infinity') for node in graph} distances[start_node] = 0 priority_queue = [(0, start_node)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"from math import log def calculate_half_life(decay_constant: float) -> float: Takes the decay constant (in s^-1) of a radioactive substance and returns its half-life (in seconds). Examples: >>> calculate_half_life(0.0001) 6931.471805599453 >>> calculate_half_life(0.005) 138.62943611198905 >>> calculate_half_life(0) Traceback (most recent call last): ... Exception: Decay constant should be greater than 0 >>> calculate_half_life(-0.01) Traceback (most recent call last): ... Exception: Decay constant should be greater than 0","solution":"from math import log def calculate_half_life(decay_constant: float) -> float: Takes the decay constant (in s^-1) of a radioactive substance and returns its half-life (in seconds). Examples: >>> calculate_half_life(0.0001) 6931.471805599453 >>> calculate_half_life(0.005) 138.62943611198905 >>> calculate_half_life(0) Traceback (most recent call last): ... Exception: Decay constant should be greater than 0 >>> calculate_half_life(-0.01) Traceback (most recent call last): ... Exception: Decay constant should be greater than 0 if decay_constant <= 0: raise Exception(\\"Decay constant should be greater than 0\\") return log(2) / decay_constant"},{"question":"def num_trees(n: int) -> int: Function to calculate the number of unique BSTs that can be built with \`n\` distinct nodes. >>> num_trees(1) == 1 >>> num_trees(2) == 2 >>> num_trees(3) == 5 >>> num_trees(4) == 14 >>> num_trees(5) == 42 >>> num_trees(19) == 1767263190","solution":"def num_trees(n: int) -> int: Function to calculate the number of unique BSTs that can be built with \`n\` distinct nodes. # Base case for 0 and 1 nodes if n == 0 or n == 1: return 1 # DP array to store the number of unique BSTs for each count of nodes dp = [0] * (n + 1) dp[0] = 1 # empty tree dp[1] = 1 # single node tree # Fill the dp array for nodes in range(2, n + 1): for root in range(1, nodes + 1): dp[nodes] += dp[root - 1] * dp[nodes - root] return dp[n]"},{"question":"import math def euclidean_distance(point1: list, point2: list) -> float: Calculate the Euclidean distance between two points in a 2D plane. Args: point1 (list): List containing two integers representing the first point. point2 (list): List containing two integers representing the second point. Returns: float: Euclidean distance between the two points. Raises: ValueError: If the input lists do not contain exactly two elements each. pass def is_integer_distance(point1: list, point2: list) -> bool: Check whether the Euclidean distance between two points is an integer. Args: point1 (list): List containing two integers representing the first point. point2 (list): List containing two integers representing the second point. Returns: bool: True if the Euclidean distance is an integer; otherwise, False. Raises: ValueError: If the input lists do not contain exactly two elements each. pass","solution":"import math def euclidean_distance(point1: list, point2: list) -> float: Calculate the Euclidean distance between two points in a 2D plane. Args: point1 (list): List containing two integers representing the first point. point2 (list): List containing two integers representing the second point. Returns: float: Euclidean distance between the two points. Raises: ValueError: If the input lists do not contain exactly two elements each. if len(point1) != 2 or len(point2) != 2: raise ValueError(\\"Each point must contain exactly two integers.\\") return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) def is_integer_distance(point1: list, point2: list) -> bool: Check whether the Euclidean distance between two points is an integer. Args: point1 (list): List containing two integers representing the first point. point2 (list): List containing two integers representing the second point. Returns: bool: True if the Euclidean distance is an integer; otherwise, False. Raises: ValueError: If the input lists do not contain exactly two elements each. distance = euclidean_distance(point1, point2) return distance.is_integer()"},{"question":"def max_subarray_sum_k(input_list: list, k: int) -> int: Find the maximum sum of any subarray containing exactly k elements. >>> max_subarray_sum_k([2, 1, 5, 1, 3, 2], 3) 9 >>> max_subarray_sum_k([4, -1, 2, 1, -5, 4], 4) 6 >>> max_subarray_sum_k([1, 2, 3, 4, 5], 2) 9 >>> max_subarray_sum_k([-2, -3, -4], 2) -5 pass","solution":"def max_subarray_sum_k(input_list, k): if len(input_list) == 0 or k <= 0: return 0 # Initialize the window sum with the sum of the first 'k' elements max_sum = current_sum = sum(input_list[:k]) # Slide the window over the array, updating the window sum at each step for i in range(k, len(input_list)): current_sum += input_list[i] - input_list[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List, Tuple def apply_increment_operations(length: int, operations: List[Tuple[int, int, int]]) -> List[int]: Apply a series of range increment operations to an array of zeros of given length. Parameters: length (int): The length of the zeroed array. operations (List[Tuple[int, int, int]]): A list of operations where each operation is represented by a tuple (start_idx, end_idx, increment). The range is inclusive of \`start_idx\` and \`end_idx\`. Returns: List[int]: The final array after all operations have been applied. Example Usage: >>> apply_increment_operations(5, [(1, 3, 2), (2, 4, 3)]) [0, 2, 5, 5, 3] >>> apply_increment_operations(3, [(0, 2, 1), (1, 1, 5)]) [1, 6, 1] def test_apply_increment_operations_example_1(): assert apply_increment_operations(5, [(1, 3, 2), (2, 4, 3)]) == [0, 2, 5, 5, 3] def test_apply_increment_operations_example_2(): assert apply_increment_operations(3, [(0, 2, 1), (1, 1, 5)]) == [1, 6, 1] def test_apply_increment_operations_single_operation_full_range(): assert apply_increment_operations(5, [(0, 4, 1)]) == [1, 1, 1, 1, 1] def test_apply_increment_operations_no_operations(): assert apply_increment_operations(5, []) == [0, 0, 0, 0, 0] def test_apply_increment_operations_multiple_operations_overlap(): assert apply_increment_operations(5, [(0, 2, 1), (1, 3, 2), (2, 4, 3)]) == [1, 3, 6, 5, 3] def test_apply_increment_operations_edge_case_length_1(): assert apply_increment_operations(1, [(0, 0, 5)]) == [5] def test_apply_increment_operations_negative_increments(): assert apply_increment_operations(5, [(0, 2, -3), (1, 3, 4)]) == [-3, 1, 1, 4, 0]","solution":"from typing import List, Tuple def apply_increment_operations(length: int, operations: List[Tuple[int, int, int]]) -> List[int]: Apply a series of range increment operations to an array of zeros of given length. Parameters: length (int): The length of the zeroed array. operations (List[Tuple[int, int, int]]): A list of operations where each operation is represented by a tuple (start_idx, end_idx, increment). The range is inclusive of \`start_idx\` and \`end_idx\`. Returns: List[int]: The final array after all operations have been applied. # Initialize the array with zeros array = [0] * length # Apply the operations using a difference array approach for start_idx, end_idx, increment in operations: array[start_idx] += increment if end_idx + 1 < length: array[end_idx + 1] -= increment # Compute the actual values of the array using prefix sum current_value = 0 for i in range(length): current_value += array[i] array[i] = current_value return array"},{"question":"WEIGHT_TIERS = { (0, 1): 5.00, (1, 5): 10.00, (5, 10): 15.00, (10, 20): 25.00, (20, float('inf')): 50.00 } ZONE_COSTS = { 1: 0.00, 2: 10.00, 3: 20.00, 4: 30.00 } def calculate_shipping_cost(weight, length, width, height, zone): Calculate the shipping cost based on weight, dimensions, and destination zone. Parameters: weight (float): The weight of the package in kilograms. length, width, height (float): The dimensions of the package in centimeters. zone (int): The destination zone (1-4). Returns: float: The total shipping cost. Raises: ValueError: If any of the input parameters are invalid. >>> calculate_shipping_cost(1.5, 10.0, 20.0, 15.0, 3) 30.00 >>> calculate_shipping_cost(8.0, 50.0, 40.0, 30.0, 2) 25.00 >>> calculate_shipping_cost(25.0, 100.0, 80.0, 60.0, 1) 50.00 >>> calculate_shipping_cost(0.5, 5.0, 5.0, 5.0, 4) 35.00","solution":"WEIGHT_TIERS = { (0, 1): 5.00, (1, 5): 10.00, (5, 10): 15.00, (10, 20): 25.00, (20, float('inf')): 50.00 } ZONE_COSTS = { 1: 0.00, 2: 10.00, 3: 20.00, 4: 30.00 } def calculate_shipping_cost(weight, length, width, height, zone): Calculate the shipping cost based on weight, dimensions, and destination zone. Parameters: weight (float): The weight of the package in kilograms. length, width, height (float): The dimensions of the package in centimeters. zone (int): The destination zone (1-4). Returns: float: The total shipping cost. Raises: ValueError: If any of the input parameters are invalid. >>> calculate_shipping_cost(1.5, 10.0, 20.0, 15.0, 3) 30.00 >>> calculate_shipping_cost(8.0, 50.0, 40.0, 30.0, 2) 25.00 >>> calculate_shipping_cost(25.0, 100.0, 80.0, 60.0, 1) 50.00 >>> calculate_shipping_cost(0.5, 5.0, 5.0, 5.0, 4) 35.00 if weight < 0 or length <= 0 or width <= 0 or height <= 0 or zone not in ZONE_COSTS: raise ValueError(\\"Invalid input parameters\\") for weight_range, base_cost in WEIGHT_TIERS.items(): if weight_range[0] <= weight < weight_range[1]: break total_shipping_cost = base_cost + ZONE_COSTS[zone] return round(total_shipping_cost, 2)"},{"question":"from typing import List def most_frequent_element(numbers: List[int]) -> int: Returns the most frequent element in the list. In case of a tie, it returns the smallest integer among the most frequent elements. >>> most_frequent_element([1, 3, 1, 3, 2, 1]) 1 >>> most_frequent_element([4, 4, 1, 2, 3, 3, 3, 4]) 4 >>> most_frequent_element([5, 5, 6, 6]) 5 >>> most_frequent_element([7]) 7 >>> most_frequent_element([1000000000, 1000000000, -1000000000, -1000000000, 1000000000]) 1000000000 >>> most_frequent_element([-1, -1, -2, -2, -1]) -1","solution":"from typing import List from collections import Counter def most_frequent_element(numbers: List[int]) -> int: Returns the most frequent element in the list. In case of a tie, it returns the smallest integer among the most frequent elements. if not numbers: raise ValueError(\\"The input list should not be empty.\\") count = Counter(numbers) max_frequency = max(count.values()) # Get the list of elements with the highest frequency most_frequent = [k for k, v in count.items() if v == max_frequency] # Return the smallest element among the most frequent elements return min(most_frequent)"},{"question":"def matrix_multiplication(matrix_a: List[List[float]], matrix_b: List[List[float]]) -> List[List[float]]: Multiplies two matrices and returns the result as a new matrix. Raise ValueError if the number of columns in matrix_a does not match the number of rows in matrix_b. >>> matrix_multiplication([ [1.0, 4.0], [2.0, 5.0], [3.0, 6.0] ], [ [7.0, 8.0, 9.0], [10.0, 11.0, 12.0] ]) [[47.0, 52.0, 57.0], [64.0, 71.0, 78.0], [81.0, 90.0, 99.0]] >>> matrix_multiplication([ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0] ], [ [7.0, 8.0], [9.0, 10.0], [11.0, 12.0] ]) [[58.0, 64.0], [139.0, 154.0]] >>> matrix_multiplication([ [1.0] ], [ [2.0] ]) [[2.0]] >>> matrix_multiplication([ [1.0, 0.0], [0.0, 1.0] ], [ [2.0, 3.0], [4.0, 5.0] ]) [[2.0, 3.0], [4.0, 5.0]] # This will raise an error because the dimensions do not match for multiplication >>> matrix_multiplication([ [1, 2], [3, 4] ], [ [1, 2] ]) Traceback (most recent call last): ... ValueError: Number of columns in matrix_a must be equal to number of rows in matrix_b","solution":"from typing import List def matrix_multiplication(matrix_a: List[List[float]], matrix_b: List[List[float]]) -> List[List[float]]: Multiplies two matrices and returns the result as a new matrix. # Check if the matrices are valid for multiplication if len(matrix_a[0]) != len(matrix_b): raise ValueError(\\"Number of columns in matrix_a must be equal to number of rows in matrix_b\\") # Initialize result matrix with zeros result = [[0.0 for _ in range(len(matrix_b[0]))] for _ in range(len(matrix_a))] # Perform matrix multiplication for i in range(len(matrix_a)): for j in range(len(matrix_b[0])): for k in range(len(matrix_b)): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result"},{"question":"def min_coins(coins: list, amount: int) -> int: Calculate the minimum number of coins needed to make up a given amount. If the amount cannot be made up by any combination of the given coins, return -1. >>> min_coins([1, 2, 5], 11) 3 >>> min_coins([2], 3) -1 >>> min_coins([1], 0) 0","solution":"def min_coins(coins, amount): Returns the minimum number of coins needed to make the given amount. If the amount cannot be made up by any combination of the given coins, returns -1. # Initialize the dp array where dp[i] will store the minimum number of coins for amount i. dp = [float('inf')] * (amount + 1) dp[0] = 0 # Base case: 0 coins needed to make amount 0. for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"def fibonacci(n: int) -> int: Returns the n-th Fibonacci number using constant space. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(3) 2 >>> fibonacci(4) 3 >>> fibonacci(5) 5 >>> fibonacci(10) 55","solution":"def fibonacci(n: int) -> int: Returns the n-th Fibonacci number using constant space. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"class MatrixManipulation: def __init__(self, matrix): self.matrix = matrix def rotate_90_clockwise(self): Rotates the given n x n matrix 90 degrees clockwise. :return: Rotated matrix pass # Test Cases from solution import MatrixManipulation def test_rotate_90_clockwise_3x3(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] matrix_manipulation = MatrixManipulation(matrix) assert matrix_manipulation.rotate_90_clockwise() == expected def test_rotate_90_clockwise_4x4(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] matrix_manipulation = MatrixManipulation(matrix) assert matrix_manipulation.rotate_90_clockwise() == expected def test_rotate_90_clockwise_1x1(): matrix = [ [1] ] expected = [ [1] ] matrix_manipulation = MatrixManipulation(matrix) assert matrix_manipulation.rotate_90_clockwise() == expected def test_rotate_90_clockwise_2x2(): matrix = [ [1, 2], [3, 4] ] expected = [ [3, 1], [4, 2] ] matrix_manipulation = MatrixManipulation(matrix) assert matrix_manipulation.rotate_90_clockwise() == expected def test_rotate_90_clockwise_with_negatives(): matrix = [ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ] expected = [ [-7, -4, -1], [-8, -5, -2], [-9, -6, -3] ] matrix_manipulation = MatrixManipulation(matrix) assert matrix_manipulation.rotate_90_clockwise() == expected","solution":"class MatrixManipulation: def __init__(self, matrix): self.matrix = matrix def rotate_90_clockwise(self): Rotates the given n x n matrix 90 degrees clockwise. :return: Rotated matrix return [list(reversed(col)) for col in zip(*self.matrix)]"},{"question":"def get_bonus_eligible_employees( employees: list[dict], min_projects: int, min_rating: float, fields: list[str] ) -> list[dict]: Returns the list of employees who are eligible for a performance bonus based on the criteria. Args: employees (list[dict]): List of employee records. min_projects (int): Minimum number of projects an employee must have completed to be eligible. min_rating (float): Minimum performance rating required. fields (list[str]): List of specific fields to include in the result for each eligible employee. Returns: list[dict]: List of dictionaries with filtered, sorted, and extracted employee data. >>> employees = [ ... {\\"name\\": \\"Alice\\", \\"projects_completed\\": 5, \\"performance_rating\\": 4.5}, ... {\\"name\\": \\"Bob\\", \\"projects_completed\\": 3, \\"performance_rating\\": 4.0}, ... {\\"name\\": \\"Charlie\\", \\"projects_completed\\": 7, \\"performance_rating\\": 3.9}, ... {\\"name\\": \\"David\\", \\"projects_completed\\": 6, \\"performance_rating\\": 4.8}, ... {\\"name\\": \\"Eve\\", \\"projects_completed\\": 2, \\"performance_rating\\": 4.2} ... ] >>> get_bonus_eligible_employees(employees, 4, 4.0, [\\"name\\", \\"performance_rating\\"]) [{'name': 'David', 'performance_rating': 4.8}, {'name': 'Alice', 'performance_rating': 4.5}]","solution":"def get_bonus_eligible_employees(employees, min_projects, min_rating, fields): Returns the list of employees who are eligible for a performance bonus based on the criteria. Args: employees (list[dict]): List of employee records. min_projects (int): Minimum number of projects an employee must have completed to be eligible. min_rating (float): Minimum performance rating required. fields (list[str]): List of specific fields to include in the result for each eligible employee. Returns: list[dict]: List of dictionaries with filtered, sorted, and extracted employee data. # Filter employees based on the criteria eligible_employees = [ employee for employee in employees if employee[\\"projects_completed\\"] >= min_projects and employee[\\"performance_rating\\"] >= min_rating ] # Sort the eligible employees by performance_rating in descending order eligible_employees.sort(key=lambda x: x[\\"performance_rating\\"], reverse=True) # Extract only the specified fields final_employees = [ {field: employee[field] for field in fields if field in employee} for employee in eligible_employees ] return final_employees"},{"question":"def rotate_matrix(matrix: List[List[int]]) -> None: Rotate the given n x n matrix 90 degrees clockwise in place. Args: matrix (List[List[int]]): 2D list representing the square matrix. Returns: None: The matrix is modified in place. # Write your code here # Test Cases def test_rotate_matrix_3x3(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) assert matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] def test_rotate_matrix_1x1(): matrix = [[1]] rotate_matrix(matrix) assert matrix == [[1]] def test_rotate_matrix_2x2(): matrix = [ [1, 2], [3, 4] ] rotate_matrix(matrix) assert matrix == [ [3, 1], [4, 2] ] def test_rotate_matrix_4x4(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] rotate_matrix(matrix) assert matrix == [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] def test_rotate_matrix_large(): matrix = [[j for j in range(i*10, (i + 1)*10)] for i in range(10)] rotated_matrix = [ [90, 80, 70, 60, 50, 40, 30, 20, 10, 0], [91, 81, 71, 61, 51, 41, 31, 21, 11, 1], [92, 82, 72, 62, 52, 42, 32, 22, 12, 2], [93, 83, 73, 63, 53, 43, 33, 23, 13, 3], [94, 84, 74, 64, 54, 44, 34, 24, 14, 4], [95, 85, 75, 65, 55, 45, 35, 25, 15, 5], [96, 86, 76, 66, 56, 46, 36, 26, 16, 6], [97, 87, 77, 67, 57, 47, 37, 27, 17, 7], [98, 88, 78, 68, 58, 48, 38, 28, 18, 8], [99, 89, 79, 69, 59, 49, 39, 29, 19, 9] ] rotate_matrix(matrix) assert matrix == rotated_matrix","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotate the given n x n matrix 90 degrees clockwise in place. Args: matrix (List[List[int]]): 2D list representing the square matrix. Returns: None: The matrix is modified in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def num_trees(n: int) -> int: Calculate the number of unique Binary Search Trees (BSTs) that can be formed using n distinct nodes. Parameters: - n (int): The number of distinct nodes. Returns: - int: The number of unique BSTs that can be formed. Constraints: - Handle edge cases effectively. - Ensure the solution is efficient enough for large values of n. Example: >>> num_trees(3) 5 >>> num_trees(1) 1 >>> num_trees(0) 1 >>> num_trees(5) 42 pass def test_num_trees_example_cases(): assert num_trees(3) == 5 assert num_trees(1) == 1 assert num_trees(0) == 1 assert num_trees(5) == 42 def test_num_trees_edge_cases(): assert num_trees(2) == 2 assert num_trees(4) == 14 assert num_trees(6) == 132 def test_num_trees_large_value(): assert num_trees(10) == 16796 assert num_trees(15) == 9694845 def test_num_trees_invalid_input(): try: num_trees(-1) except ValueError as e: assert str(e) == \\"n must be a non-negative integer\\" try: num_trees(\\"three\\") except TypeError: pass # Expected due to wrong data type # Run the tests if __name__ == \\"__main__\\": test_num_trees_example_cases() test_num_trees_edge_cases() test_num_trees_large_value() test_num_trees_invalid_input() print(\\"All tests passed.\\")","solution":"def num_trees(n: int) -> int: Returns the number of unique Binary Search Trees (BSTs) that can be formed using \`n\` distinct nodes. Parameters: - n (int): The number of distinct nodes. Returns: - int: The number of unique BSTs that can be formed. if n < 0: raise ValueError(\\"n must be a non-negative integer\\") # Base case if n == 0 or n == 1: return 1 # DP array to store the number of unique BSTs for each count of nodes dp = [0] * (n + 1) dp[0] = dp[1] = 1 # Fill the dp array for nodes in range(2, n + 1): for root in range(1, nodes + 1): dp[nodes] += dp[root - 1] * dp[nodes - root] return dp[n]"},{"question":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Find the sum of the maximum sum subarray using the divide-and-conquer approach. Parameters: - arr: A list of integers representing the array. Returns: - An integer representing the sum of the maximum sum subarray. Constraints: - The elements of the array can be negative or positive integers. - The array is non-empty. Examples: >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4]) -1","solution":"from typing import List def max_crossing_sum(arr: List[int], left: int, mid: int, right: int) -> int: left_sum = float('-inf') curr_sum = 0 for i in range(mid, left - 1, -1): curr_sum += arr[i] if curr_sum > left_sum: left_sum = curr_sum right_sum = float('-inf') curr_sum = 0 for i in range(mid + 1, right + 1): curr_sum += arr[i] if curr_sum > right_sum: right_sum = curr_sum return left_sum + right_sum def max_subarray_sum_recursive(arr: List[int], left: int, right: int) -> int: if left == right: return arr[left] mid = (left + right) // 2 left_sum = max_subarray_sum_recursive(arr, left, mid) right_sum = max_subarray_sum_recursive(arr, mid + 1, right) crossing_sum = max_crossing_sum(arr, left, mid, right) return max(left_sum, right_sum, crossing_sum) def max_subarray_sum(arr: List[int]) -> int: return max_subarray_sum_recursive(arr, 0, len(arr) - 1)"},{"question":"def sliding_window_sum(arr: list, k: int) -> list: Calculate the sum of each sliding window (subarray of length k) in the given list. Parameters: arr (list): The list of integers. k (int): The window size. Returns: list: A list of integers representing the sum of each sliding window. Examples: >>> sliding_window_sum([1, 2, 3, 4, 5], 3) [6, 9, 12] >>> sliding_window_sum([10, 20, 30], 2) [30, 50] >>> sliding_window_sum([3, 3, 3, 3], 1) [3, 3, 3, 3] >>> sliding_window_sum([], 1) [] >>> sliding_window_sum([15, 25, 35, 45, 55], 5) [175] pass from solution import sliding_window_sum def test_sliding_window_sum_basic(): assert sliding_window_sum([1, 2, 3, 4, 5], 3) == [6, 9, 12] def test_sliding_window_sum_two_elements(): assert sliding_window_sum([10, 20, 30], 2) == [30, 50] def test_sliding_window_sum_single_element_windows(): assert sliding_window_sum([3, 3, 3, 3], 1) == [3, 3, 3, 3] def test_sliding_window_sum_empty_list(): assert sliding_window_sum([], 1) == [] def test_sliding_window_sum_full_window(): assert sliding_window_sum([15, 25, 35, 45, 55], 5) == [175] def test_sliding_window_sum_large_input(): large_list = list(range(1, 100001)) # 1 to 100000 window_size = 1000 result = sliding_window_sum(large_list, window_size) for i in range(len(result)): assert result[i] == sum(range(i + 1, i + 1001)) def test_sliding_window_sum_large_input_k1(): large_list = list(range(1, 100001)) # 1 to 100000 window_size = 1 result = sliding_window_sum(large_list, window_size) assert result == large_list def test_sliding_window_sum_invalid_k_zero(): assert sliding_window_sum([1, 2, 3], 0) == [] def test_sliding_window_sum_invalid_k_negative(): assert sliding_window_sum([1, 2, 3], -1) == [] def test_sliding_window_sum_k_larger_than_list(): assert sliding_window_sum([1, 2, 3], 4) == []","solution":"def sliding_window_sum(arr: list, k: int) -> list: Calculate the sum of each sliding window (subarray of length k) in the given list. Parameters: arr (list): The list of integers. k (int): The window size. Returns: list: A list of integers representing the sum of each sliding window. if not arr or k <= 0 or k > len(arr): return [] n = len(arr) result = [] window_sum = sum(arr[:k]) result.append(window_sum) for i in range(k, n): window_sum += arr[i] - arr[i - k] result.append(window_sum) return result"},{"question":"def duplicate_vowels(input_string: str) -> str: Returns the string with all vowels duplicated. >>> duplicate_vowels('Hello World') 'Heelloo Woorld' >>> duplicate_vowels('Python') 'Pythoon' >>> duplicate_vowels('') '' >>> duplicate_vowels('xyz') 'xyz' >>> duplicate_vowels('aeiou') 'aaeeiioouu' >>> duplicate_vowels('AEIOU') 'AAEEIIOOUU' >>> duplicate_vowels('AaEeIiOoUu') 'AAaaEEeeIIiiOOooUUuu' >>> duplicate_vowels('a e i o u') 'aa ee ii oo uu' >>> duplicate_vowels('a' * 100000) 'aa' * 100000","solution":"def duplicate_vowels(input_string: str) -> str: vowels = \\"aeiouAEIOU\\" result = [] for char in input_string: result.append(char) if char in vowels: result.append(char) return ''.join(result)"},{"question":"def can_enroll(student_courses: list, course: str, prerequisites: dict) -> bool: Determines if the student can enroll in the given course based on previously completed courses and the prerequisites of the desired course. Parameters: - student_courses: List of courses the student has already completed - course: The course the student wishes to enroll in - prerequisites: Dictionary of courses with their respective list of prerequisites Returns: - True if the student can enroll in the course, otherwise False Examples: >>> can_enroll([\\"Math101\\", \\"CS101\\"], \\"Math201\\", {\\"Math201\\": [], \\"CS201\\": []}) True >>> can_enroll([\\"Math101\\"], \\"CS201\\", {\\"Math201\\": [\\"Math101\\"], \\"CS201\\": [\\"CS101\\"]}) False def test_no_prerequisites(): student_courses = [\\"Math101\\", \\"CS101\\"] prerequisites = { \\"Math201\\": [], \\"CS201\\": [] } assert can_enroll(student_courses, \\"Math201\\", prerequisites) == True assert can_enroll(student_courses, \\"CS201\\", prerequisites) == True def test_single_prerequisite_met(): student_courses = [\\"Math101\\", \\"CS101\\"] prerequisites = { \\"Math201\\": [\\"Math101\\"], \\"CS201\\": [\\"CS101\\"] } assert can_enroll(student_courses, \\"Math201\\", prerequisites) == True assert can_enroll(student_courses, \\"CS201\\", prerequisites) == True def test_single_prerequisite_not_met(): student_courses = [\\"Math101\\"] prerequisites = { \\"Math201\\": [\\"Math101\\"], \\"CS201\\": [\\"CS101\\"] } assert can_enroll(student_courses, \\"Math201\\", prerequisites) == True assert can_enroll(student_courses, \\"CS201\\", prerequisites) == False def test_multiple_prerequisites_met(): student_courses = [\\"Math101\\", \\"CS101\\", \\"Physics101\\"] prerequisites = { \\"Math301\\": [\\"Math101\\", \\"Physics101\\"], \\"CS301\\": [\\"CS101\\", \\"Math101\\"] } assert can_enroll(student_courses, \\"Math301\\", prerequisites) == True assert can_enroll(student_courses, \\"CS301\\", prerequisites) == True def test_multiple_prerequisites_not_met(): student_courses = [\\"Math101\\", \\"CS101\\"] prerequisites = { \\"Math301\\": [\\"Math101\\", \\"Physics101\\"], # Physics101 missing \\"CS301\\": [\\"CS101\\", \\"Math201\\"] # Math201 missing } assert can_enroll(student_courses, \\"Math301\\", prerequisites) == False assert can_enroll(student_courses, \\"CS301\\", prerequisites) == False def test_prerequisites_partly_met(): student_courses = [\\"Math101\\"] prerequisites = { \\"Math301\\": [\\"Math101\\", \\"Physics101\\"], # Physics101 missing \\"CS301\\": [\\"CS101\\", \\"Math101\\"] # CS101 missing } assert can_enroll(student_courses, \\"Math301\\", prerequisites) == False assert can_enroll(student_courses, \\"CS301\\", prerequisites) == False","solution":"def can_enroll(student_courses: list, course: str, prerequisites: dict) -> bool: Determines if the student can enroll in the given course based on previously completed courses and the prerequisites of the desired course. :param student_courses: List of courses the student has already completed :param course: The course the student wishes to enroll in :param prerequisites: Dictionary of courses with their respective list of prerequisites :return: True if the student can enroll in the course, otherwise False # Get the list of prerequisites for the chosen course course_prerequisites = prerequisites.get(course, []) # Check if all the prerequisites are in the student's completed courses list for prereq in course_prerequisites: if prereq not in student_courses: return False return True"},{"question":"def dijkstra_shortest_path(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]: Implement Dijkstra's Algorithm to find the shortest path from a source node to all other nodes in a weighted graph. Args: graph (Dict[int, List[Tuple[int, int]]]): A dictionary where the key is a node, and the value is a list of tuples (neighbor, weight) representing the connected nodes and the edge weights. start (int): An integer representing the starting node for the shortest path calculation. Returns: Dict[int, int]: A dictionary where the key is a node, and the value is the minimum distance from the start node to that node. >>> graph = {0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: []} >>> dijkstra_shortest_path(graph, 0) {0: 0, 1: 3, 2: 1, 3: 4} >>> graph = {0: [(1, 2)], 1: [], 2: [(3, 2)], 3: []} >>> dijkstra_shortest_path(graph, 0) {0: 0, 1: 2, 2: float('infinity'), 3: float('infinity')}","solution":"def dijkstra_shortest_path(graph, start): import heapq # Initialize distances with infinity except for the start node distances = {node: float('infinity') for node in graph} distances[start] = 0 # Use a priority queue to store (distance, node) tuples priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the distance is greater than the recorded shortest distance, skip it if current_distance > distances[current_node]: continue # Check neighbors of the current node for neighbor, weight in graph[current_node]: distance = current_distance + weight # If a new shorter path is found, update the distance and push to the priority queue if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate the arithmetic expression containing non-negative integers and operators + and *. :param expression: str : The arithmetic expression to evaluate :return: int: The result of the arithmetic evaluation >>> evaluate_expression(\\"3+5*2\\") 13 >>> evaluate_expression(\\"10 + 2 * 3\\") 16 >>> evaluate_expression(\\"10 + 2 *\\") Traceback (most recent call last): ... ValueError: Invalid expression >>> evaluate_expression(\\" 3 + 4 * 2 \\") 11 >>> evaluate_expression(\\"\\") Traceback (most recent call last): ... ValueError: Invalid expression # Your implementation here import pytest def test_evaluate_expression_basic(): assert evaluate_expression(\\"3+5*2\\") == 13 def test_evaluate_expression_with_spaces(): assert evaluate_expression(\\"10 + 2 * 3\\") == 16 assert evaluate_expression(\\" 3 + 4 * 2 \\") == 11 def test_evaluate_expression_invalid(): with pytest.raises(ValueError, match=\\"Invalid expression\\"): evaluate_expression(\\"10 + 2 *\\") with pytest.raises(ValueError, match=\\"Invalid expression\\"): evaluate_expression(\\"\\") def test_evaluate_expression_only_addition(): assert evaluate_expression(\\"1+2+3+4\\") == 10 def test_evaluate_expression_only_multiplication(): assert evaluate_expression(\\"2*3*4\\") == 24 def test_evaluate_expression_complex(): assert evaluate_expression(\\"2 + 3 * 4 + 5 * 6\\") == 44 assert evaluate_expression(\\"2+3 * 4+ 5*6\\") == 44 def test_evaluate_expression_with_large_numbers(): assert evaluate_expression(\\"1000+2000*3\\") == 7000 assert evaluate_expression(\\"1*2*3*4+5+6\\") == 35","solution":"import re def evaluate_expression(expression: str) -> int: Evaluate the arithmetic expression containing non-negative integers and operators + and *. :param expression: str : The arithmetic expression to evaluate :return: int: The result of the arithmetic evaluation if not expression: raise ValueError(\\"Invalid expression\\") # Remove all spaces expression = expression.replace(\\" \\", \\"\\") if not re.fullmatch(r'(d+[+*])*?d+', expression): raise ValueError(\\"Invalid expression\\") # Split the expression into terms by '+' while preserving operators terms = re.split(r'(+)', expression) # Transform each term by evaluating multiplications first result_terms = [] for term in terms: if '*' in term: factors = map(int, term.split('*')) product = 1 for factor in factors: product *= factor result_terms.append(str(product)) else: result_terms.append(term) # Now evaluate the remaining addition result_expression = ''.join(result_terms) return eval(result_expression)"},{"question":"class Node: def __init__(self, key, value): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity): Initialize the LRU cache with a fixed capacity. pass def get(self, key): Access the value associated with the key, making it the most recently used. Raise a KeyError if the key is not found. Args: key: The key to be accessed. Returns: The value associated with the key. Raises: KeyError: If the key is not found. pass def put(self, key, value): Insert a key-value pair into the cache. If the cache exceeds its capacity, the least recently used item will be evicted. Args: key: The key of the item to insert. value: The value of the item to insert. pass def delete(self, key): Delete a key-value pair from the cache. Raise a KeyError if the key is not found. Args: key: The key to be deleted. Raises: KeyError: If the key is not found. pass def state(self): Retrieve the current state of the cache as a list of key-value pairs, ordered from most recently used to least recently used. Returns: A list of key-value pairs or \\"Cache is empty\\" if there are no elements. pass # Example Unit Test Cases import pytest def test_lru_cache_operations(): cache = LRUCache(2) cache.put(1, 'A') assert cache.state() == [(1, 'A')] cache.put(2, 'B') assert cache.state() == [(2, 'B'), (1, 'A')] assert cache.get(1) == 'A' assert cache.state() == [(1, 'A'), (2, 'B')] cache.put(3, 'C') assert cache.state() == [(3, 'C'), (1, 'A')] cache.delete(1) assert cache.state() == [(3, 'C')] cache.delete(3) assert cache.state() == \\"Cache is empty\\" with pytest.raises(KeyError): cache.delete(2) with pytest.raises(KeyError): cache.get(2) def test_lru_cache_full_eviction(): cache = LRUCache(2) cache.put(1, 'A') cache.put(2, 'B') cache.put(3, 'C') assert cache.state() == [(3, 'C'), (2, 'B')] def test_lru_cache_delete_and_add(): cache = LRUCache(2) cache.put(1, 'A') cache.put(2, 'B') cache.delete(1) cache.put(3, 'C') assert cache.state() == [(3, 'C'), (2, 'B')] def test_lru_cache_put_existing_key(): cache = LRUCache(2) cache.put(1, 'A') cache.put(2, 'B') cache.put(1, 'AA') assert cache.state() == [(1, 'AA'), (2, 'B')] if __name__ == \\"__main__\\": pytest.main()","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity): self.capacity = capacity self.cache = {} self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def _remove(self, node): prev = node.prev nxt = node.next prev.next = nxt nxt.prev = prev def _add(self, node): prev = self.head nxt = self.head.next prev.next = node node.prev = prev node.next = nxt nxt.prev = node def get(self, key): if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value else: raise KeyError(\\"Key not found\\") def put(self, key, value): if key in self.cache: self._remove(self.cache[key]) node = Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: node_to_remove = self.tail.prev self._remove(node_to_remove) del self.cache[node_to_remove.key] def delete(self, key): if key in self.cache: self._remove(self.cache[key]) del self.cache[key] else: raise KeyError(\\"Key not found\\") def state(self): elements = [] current = self.head.next while current != self.tail: elements.append((current.key, current.value)) current = current.next return elements if elements else \\"Cache is empty\\""},{"question":"from typing import List, Dict def find_path_dfs(graph: Dict[int, List[int]], start: int, end: int) -> List[int]: Perform DFS to find a path between start and end nodes in a directed graph. Args: graph (Dict[int, List[int]]): Adjacency list representing the graph. start (int): Start node. end (int): End node. Returns: List[int]: Path from start to end if exists, else an empty list. >>> graph1 = { ... 0: [1, 2], ... 1: [2, 3], ... 2: [3], ... 3: [4], ... 4: [5], ... 5: [] ... } >>> find_path_dfs(graph1, 0, 5) [0, 1, 2, 3, 4, 5] >>> graph2 = { ... 0: [1, 2], ... 1: [3], ... 2: [3], ... 3: [4], ... 4: [] ... } >>> find_path_dfs(graph2, 0, 4) [0, 1, 3, 4] >>> graph3 = { ... 0: [1, 2], ... 1: [2, 3], ... 2: [0, 3], ... 3: [4], ... 4: [5], ... 5: [] ... } >>> find_path_dfs(graph3, 0, 6) [] >>> graph4 = { ... 0: [1], ... 1: [2], ... 2: [3], ... 3: [4], ... 4: [5], ... 5: [0] # Creating a cycle ... } >>> find_path_dfs(graph4, 3, 0) [3, 4, 5, 0] >>> graph5 = { ... 0: [1], ... 1: [2], ... 3: [4], ... 4: [5] ... } >>> find_path_dfs(graph5, 0, 4) [] >>> find_path_dfs(graph5, 3, 5) [3, 4, 5] >>> graph6 = { ... 0: [], ... 1: [] ... } >>> find_path_dfs(graph6, 0, 1) [] >>> find_path_dfs(graph6, 1, 0) []","solution":"def find_path_dfs(graph, start, end): Perform DFS to find a path between start and end nodes in a directed graph. Parameters: - graph (dict): Adjacency list representing the graph. - start (int): Start node. - end (int): End node. Returns: - List[int]: Path from start to end if exists, else an empty list. def dfs(current_node, path): # Add current node to the path path.append(current_node) # If the current node is the end node, return True to signal that a path is found if current_node == end: return True # Recur for all neighbors of the current node for neighbor in graph.get(current_node, []): if neighbor not in path: # Check to avoid revisiting nodes if dfs(neighbor, path): return True # Backtrack: remove current node from the path path.pop() return False path = [] if dfs(start, path): return path return []"},{"question":"class PrefixTreeNode: def __init__(self) -> None: self.children = {} self.is_word = False class PrefixTree: def __init__(self) -> None: self.root = PrefixTreeNode() def insert(self, word: str) -> None: Insert a word into the Prefix Tree. ... def search(self, word: str) -> bool: Search for a word in the Prefix Tree. Returns True if the word is found, otherwise returns False. ... def starts_with(self, prefix: str) -> list[str]: List all words in the Prefix Tree that start with the given prefix. Returns a list of words in lexicographical order. ... # Example Usage: # trie = PrefixTree() # trie.insert(\\"apple\\") # print(trie.search(\\"apple\\")) # Returns True # print(trie.search(\\"app\\")) # Returns False # print(trie.starts_with(\\"app\\")) # Returns [\\"apple\\"] # trie.insert(\\"app\\") # print(trie.search(\\"app\\")) # Returns True # print(trie.starts_with(\\"ap\\")) # Returns [\\"app\\", \\"apple\\"] # Unit tests def test_insert_and_search(): trie = PrefixTree() trie.insert(\\"apple\\") assert trie.search(\\"apple\\") == True assert trie.search(\\"app\\") == False trie.insert(\\"app\\") assert trie.search(\\"app\\") == True assert trie.search(\\"appl\\") == False def test_prefix_listing(): trie = PrefixTree() words = [\\"apple\\", \\"app\\", \\"bat\\", \\"ball\\", \\"batch\\", \\"bats\\"] for word in words: trie.insert(word) assert trie.starts_with(\\"bat\\") == [\\"bat\\", \\"batch\\", \\"bats\\"] assert trie.starts_with(\\"bal\\") == [\\"ball\\"] assert trie.starts_with(\\"ba\\") == [\\"ball\\", \\"bat\\", \\"batch\\", \\"bats\\"] assert trie.starts_with(\\"xyz\\") == [] def test_empty_trie(): trie = PrefixTree() assert trie.search(\\"nothing\\") == False assert trie.starts_with(\\"no_prefix\\") == [] def test_common_prefix(): trie = PrefixTree() words = [\\"car\\", \\"carbon\\", \\"carpet\\", \\"carp\\"] for word in words: trie.insert(word) assert trie.starts_with(\\"car\\") == [\\"car\\", \\"carbon\\", \\"carp\\", \\"carpet\\"] assert trie.starts_with(\\"cars\\") == [] assert trie.starts_with(\\"ca\\") == [\\"car\\", \\"carbon\\", \\"carp\\", \\"carpet\\"] def test_full_match_prefix(): trie = PrefixTree() words = [\\"example\\", \\"examine\\", \\"exist\\", \\"exit\\"] for word in words: trie.insert(word) assert trie.starts_with(\\"example\\") == [\\"example\\"] assert trie.starts_with(\\"exa\\") == [\\"examine\\", \\"example\\"]","solution":"class PrefixTreeNode: def __init__(self) -> None: self.children = {} self.is_word = False class PrefixTree: def __init__(self) -> None: self.root = PrefixTreeNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = PrefixTreeNode() node = node.children[char] node.is_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_word def starts_with(self, prefix: str) -> list[str]: def dfs(current_node: PrefixTreeNode, path: str, results: list) -> None: if current_node.is_word: results.append(path) for char, next_node in sorted(current_node.children.items()): dfs(next_node, path + char, results) node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] results = [] dfs(node, prefix, results) return results"},{"question":"import datetime from typing import List, Dict # Custom Exceptions class AuthorExistsError(Exception): pass class AuthorNotFoundError(Exception): pass class InvalidInputError(Exception): pass def add_author(name: str, email: str) -> Dict: Add a new author to the system. Parameters: name (str): The full name of the author. email (str): The email address of the author. Returns: Dict: A dictionary containing the author's ID, name, and email. Raises: AuthorExistsError: If an author with the given email already exists. InvalidInputError: If the inputs are invalid. Example: >>> add_author(\\"John Doe\\", \\"john@example.com\\") {'id': 1, 'name': 'John Doe', 'email': 'john@example.com'} pass def create_post(author_id: int, title: str, content: str, tags: List[str]) -> Dict: Add a new blog post. Parameters: author_id (int): The ID of the author writing the post. title (str): The title of the blog post. content (str): The main content of the blog post. tags (List[str]): A list of tags related to the post. Returns: Dict: A dictionary containing the post's ID, author ID, title, content, tags, and the creation timestamp. Raises: AuthorNotFoundError: If the author does not exist. InvalidInputError: If the inputs are invalid. Example: >>> create_post(author_id=1, title=\\"My First Blog Post\\", content=\\"This is the content of the blog post.\\", tags=[\\"introduction\\", \\"personal\\"]) { 'id': 1, 'author_id': 1, 'title': 'My First Blog Post', 'content': 'This is the content of the blog post.', 'tags': ['introduction', 'personal'], 'timestamp': '2023-10-15T18:45:00Z' } pass # Example Usage # 1. Add a new author author_data = add_author(\\"Alice Johnson\\", \\"alice@example.com\\") print(author_data) # 2. Create a new blog post post_data = create_post(author_id=1, title=\\"My First Blog Post\\", content=\\"This is the content of the blog post.\\", tags=[\\"introduction\\", \\"personal\\"]) print(post_data)","solution":"import datetime from typing import List, Dict # Global counters author_counter = 1 post_counter = 1 # Global storage authors = {} posts = {} class AuthorExistsError(Exception): pass class AuthorNotFoundError(Exception): pass class InvalidInputError(Exception): pass def add_author(name: str, email: str) -> Dict: global author_counter if not name or not email: raise InvalidInputError(\\"Name and email are required fields.\\") # Check if the email is already present for author in authors.values(): if author['email'] == email: raise AuthorExistsError(f\\"Author with email {email} already exists.\\") author_id = author_counter authors[author_id] = { 'id': author_id, 'name': name, 'email': email } author_counter += 1 return authors[author_id] def create_post(author_id: int, title: str, content: str, tags: List[str]) -> Dict: global post_counter if not author_id or not title or not content or tags is None: raise InvalidInputError(\\"Author ID, title, content, and tags are required fields.\\") # Check if the author exists if author_id not in authors: raise AuthorNotFoundError(f\\"Author with ID {author_id} does not exist.\\") post_id = post_counter timestamp = datetime.datetime.utcnow().isoformat() + \\"Z\\" posts[post_id] = { 'id': post_id, 'author_id': author_id, 'title': title, 'content': content, 'tags': tags, 'timestamp': timestamp } post_counter += 1 return posts[post_id]"},{"question":"def detect_fraudulent_activity( transaction_log: list[tuple[int, float, str, int]], max_transactions: int, max_locations: int, time_window: int ) -> list[int]: Detect potentially fraudulent user activities based on transaction patterns. Parameters: - transaction_log: List of tuples representing transactions (user_id, amount, location, timestamp). - max_transactions: Maximum allowed transactions within the time window. - max_locations: Maximum allowed distinct locations within the time window. - time_window: Time window in seconds to evaluate transactions. Returns: - List of user IDs with potential fraudulent activities, sorted in ascending order. pass # Test cases def test_no_fraudulent_activity(): result = detect_fraudulent_activity([], 2, 2, 10) assert result == [] def test_single_user_fraudulent_activity(): transaction_log = [ (1, 120.0, \\"New York\\", 1623437800), (1, 75.0, \\"Boston\\", 1623437810), (1, 90.0, \\"Miami\\", 1623437820) ] result = detect_fraudulent_activity(transaction_log, 2, 2, 3600) assert result == [1] def test_multiple_users_fraudulent_activity(): transaction_log = [ (1, 120.0, \\"New York\\", 1623437800), (1, 75.0, \\"Boston\\", 1623437810), (1, 90.0, \\"Miami\\", 1623437820), (2, 150.0, \\"New York\\", 1623438000), (2, 80.0, \\"Los Angeles\\", 1623438100), (2, 60.0, \\"New York\\", 1623438200) ] result = detect_fraudulent_activity(transaction_log, 2, 1, 300) assert result == [1, 2] def test_no_fraud_activity_due_to_time_window(): transaction_log = [ (1, 120.0, \\"New York\\", 1623437800), (1, 75.0, \\"Boston\\", 1623439800), (1, 90.0, \\"Miami\\", 1623441800) ] result = detect_fraudulent_activity(transaction_log, 2, 2, 300) assert result == [] def test_fraud_activity_with_large_data(): transaction_log = [ (1, i, \\"Location\\" + str(i % 10), 1623437800 + i * 10) for i in range(100) ] result = detect_fraudulent_activity(transaction_log, 5, 3, 600) assert result == [1]","solution":"from collections import defaultdict def detect_fraudulent_activity( transaction_log, max_transactions, max_locations, time_window ): Detect potentially fraudulent user activities based on transaction patterns. Parameters: - transaction_log: List of tuples representing transactions (user_id, amount, location, timestamp). - max_transactions: Maximum allowed transactions within the time window. - max_locations: Maximum allowed distinct locations within the time window. - time_window: Time window in seconds to evaluate transactions. Returns: - List of user IDs with potential fraudulent activities, sorted in ascending order. user_transactions = defaultdict(list) for transaction in transaction_log: user_id, amount, location, timestamp = transaction user_transactions[user_id].append((amount, location, timestamp)) potential_fraud_users = set() for user_id, transactions in user_transactions.items(): transactions.sort(key=lambda x: x[2]) # Sort transactions by timestamp for i in range(len(transactions)): current_window = [] unique_locations = set() for j in range(i, len(transactions)): if transactions[j][2] - transactions[i][2] <= time_window: current_window.append(transactions[j]) unique_locations.add(transactions[j][1]) else: break if len(current_window) > max_transactions or len(unique_locations) > max_locations: potential_fraud_users.add(user_id) break return sorted(potential_fraud_users)"},{"question":"import time from typing import List, Dict def bubble_sort(arr: List[int]) -> List[int]: Returns a sorted list using the Bubble Sort algorithm. >>> bubble_sort([64, 34, 25, 12, 22, 11, 90]) [11, 12, 22, 25, 34, 64, 90] >>> bubble_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] # Implement Bubble Sort algorithm here pass def merge_sort(arr: List[int]) -> List[int]: Returns a sorted list using the Merge Sort algorithm. >>> merge_sort([64, 34, 25, 12, 22, 11, 90]) [11, 12, 22, 25, 34, 64, 90] >>> merge_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] # Implement Merge Sort algorithm here pass def quick_sort(arr: List[int]) -> List[int]: Returns a sorted list using the Quick Sort algorithm. >>> quick_sort([64, 34, 25, 12, 22, 11, 90]) [11, 12, 22, 25, 34, 64, 90] >>> quick_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] # Implement Quick Sort algorithm here pass def performance_comparison(arr_list: List[List[int]]) -> Dict[str, List[float]]: Measures the performance of different sorting algorithms on given datasets. >>> performance_comparison([ ... [64, 34, 25, 12, 22, 11, 90], ... [38, 27, 43, 3, 9, 82, 10], ... [5, 1, 4, 2, 8] ... ]) { ... 'BubbleSort': [0.0002, 0.00015, 0.0001], ... 'MergeSort': [0.0001, 0.00011, 0.00009], ... 'QuickSort': [0.0001, 0.00008, 0.00007] ... } # Implement performance comparison here pass","solution":"import time def bubble_sort(arr): Returns a sorted list using the Bubble Sort algorithm. n = len(arr) for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr def merge_sort(arr): Returns a sorted list using the Merge Sort algorithm. if len(arr) > 1: mid = len(arr) // 2 L = arr[:mid] R = arr[mid:] merge_sort(L) merge_sort(R) i = j = k = 0 while i < len(L) and j < len(R): if L[i] < R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i < len(L): arr[k] = L[i] i += 1 k += 1 while j < len(R): arr[k] = R[j] j += 1 k += 1 return arr def quick_sort(arr): Returns a sorted list using the Quick Sort algorithm. if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right) def performance_comparison(arr_list): Measures the performance of different sorting algorithms on given datasets. times = { 'BubbleSort': [], 'MergeSort': [], 'QuickSort': [] } for arr in arr_list: arr_copy = arr.copy() start_time = time.time() bubble_sort(arr_copy) times['BubbleSort'].append(time.time() - start_time) arr_copy = arr.copy() start_time = time.time() merge_sort(arr_copy) times['MergeSort'].append(time.time() - start_time) arr_copy = arr.copy() start_time = time.time() quick_sort(arr_copy) times['QuickSort'].append(time.time() - start_time) return times"},{"question":"def convert_currency(amount: float, currency: str, rates: dict, ndigits: int = 2) -> dict: Converts the given amount of money in the specified currency to several other major currencies. Args: amount: The amount of money to convert (as a float). currency: The currency of the input amount (e.g., 'USD', 'EUR', 'GBP', 'JPY', 'AUD'). rates: A dictionary containing the conversion rates to USD for each currency. ndigits: The number of decimal places to round the converted amounts (default is 2). Returns: A dictionary containing the converted amounts in USD, EUR, GBP, JPY, and AUD. Example: >>> convert_currency(100, 'EUR', {'USD': 1.18, 'EUR': 1.0, 'GBP': 0.86, 'JPY': 130.2, 'AUD': 1.55}) {'USD': 118.0, 'EUR': 100.0, 'GBP': 86.0, 'JPY': 13020.0, 'AUD': 155.0} >>> convert_currency(100, 'JPY', {'USD': 0.0091, 'EUR': 0.0077, 'GBP': 0.0066, 'JPY': 1.0, 'AUD': 0.0119}) {'USD': 0.91, 'EUR': 0.77, 'GBP': 0.66, 'JPY': 100.0, 'AUD': 1.19}","solution":"def convert_currency(amount: float, currency: str, rates: dict, ndigits: int = 2) -> dict: Converts the given amount of money in the specified currency to several other major currencies. Args: amount: The amount of money to convert (as a float). currency: The currency of the input amount (e.g., 'USD', 'EUR', 'GBP', 'JPY', 'AUD'). rates: A dictionary containing the conversion rates to USD for each currency. ndigits: The number of decimal places to round the converted amounts (default is 2). Returns: A dictionary containing the converted amounts in USD, EUR, GBP, JPY, and AUD. # First, convert the amount to USD amount_in_usd = amount / rates[currency] # Then, convert USD to the other currencies converted_amounts = { 'USD': round(amount_in_usd, ndigits), 'EUR': round(amount_in_usd * rates['EUR'], ndigits), 'GBP': round(amount_in_usd * rates['GBP'], ndigits), 'JPY': round(amount_in_usd * rates['JPY'], ndigits), 'AUD': round(amount_in_usd * rates['AUD'], ndigits) } return converted_amounts"},{"question":"def reverse_words(sentence: str) -> str: Reverse the words in a sentence, preserving the original positions of all punctuation and spaces. >>> reverse_words(\\"Hello, world!\\") \\"olleH, dlrow!\\" >>> reverse_words(\\"This is a test.\\") \\"sihT si a tset.\\" >>> reverse_words(\\"Coding? In Python!\\") \\"gnidoC? nI nohtyP!\\" >>> reverse_words(\\"Keep calm and code on.\\") \\"peeK mlac dna edoc no.\\" >>> reverse_words(\\"\\") \\"\\"","solution":"def reverse_words(sentence: str) -> str: def is_letter(c): return c.isalpha() words = [] start = 0 while start < len(sentence): if is_letter(sentence[start]): end = start while end < len(sentence) and is_letter(sentence[end]): end += 1 words.append(sentence[start:end][::-1]) start = end else: words.append(sentence[start]) start += 1 return ''.join(words)"},{"question":"def reverse_integer(n: int) -> int: Reverses the digits of the given integer while preserving its sign. >>> reverse_integer(123) 321 >>> reverse_integer(-456) -654 >>> reverse_integer(100) 1 >>> reverse_integer(-800) -8 >>> reverse_integer(0) 0 from solution import reverse_integer def test_reverse_positive_numbers(): assert reverse_integer(123) == 321 assert reverse_integer(100) == 1 assert reverse_integer(908) == 809 def test_reverse_negative_numbers(): assert reverse_integer(-456) == -654 assert reverse_integer(-800) == -8 assert reverse_integer(-12345) == -54321 def test_reverse_zero(): assert reverse_integer(0) == 0 def test_reverse_large_numbers(): assert reverse_integer(1534236469) == 0 # This reverses to 9646324351 which is out of the 32-bit range assert reverse_integer(-1534236469) == 0 # This reverses to -9646324351 which is out of the 32-bit range def test_reverse_edge_cases(): assert reverse_integer(2**31 - 1) == 0 assert reverse_integer(-(2**31)) == 0","solution":"def reverse_integer(n: int) -> int: Reverses the digits of the given integer while preserving its sign. Args: n (int): The integer to be reversed. Returns: int: The reversed integer with the original sign preserved. sign = -1 if n < 0 else 1 n_abs = abs(n) reversed_str = str(n_abs)[::-1] reversed_int = int(reversed_str) * sign # Check if the reversed integer is within the valid range if reversed_int < -2**31 or reversed_int > 2**31 - 1: return 0 return reversed_int"},{"question":"class Library: Library management system to keep track of book availability and perform reservations. Methods: - add_book(title: str, copies: int) -> None: Adds a certain number of copies of a book to the inventory. If the book already exists, it increases the count by the given number of copies. - checkout_book(title: str) -> bool: Checks out a book if there are available copies. Returns \`True\` if the checkout is successful, \`False\` otherwise. - return_book(title: str) -> None: Returns a book back to the inventory. - is_book_available(title: str) -> bool: Checks if the book is available for checkout. Returns \`True\` if at least one copy is available, \`False\` otherwise. def test_add_and_check_out_book(): library = Library() library.add_book(\\"The Great Gatsby\\", 3) assert library.checkout_book(\\"The Great Gatsby\\") == True assert library.is_book_available(\\"The Great Gatsby\\") == True assert library.inventory[\\"The Great Gatsby\\"] == 2 def test_checkout_book_not_in_inventory(): library = Library() assert library.checkout_book(\\"1984\\") == False def test_return_book(): library = Library() library.add_book(\\"1984\\", 1) library.checkout_book(\\"1984\\") assert library.is_book_available(\\"1984\\") == False library.return_book(\\"1984\\") assert library.is_book_available(\\"1984\\") == True def test_is_book_available(): library = Library() library.add_book(\\"To Kill a Mockingbird\\", 2) assert library.is_book_available(\\"To Kill a Mockingbird\\") == True library.checkout_book(\\"To Kill a Mockingbird\\") library.checkout_book(\\"To Kill a Mockingbird\\") assert library.is_book_available(\\"To Kill a Mockingbird\\") == False def test_inventory_handling(): library = Library() library.add_book(\\"Pride and Prejudice\\", 5) assert library.inventory[\\"Pride and Prejudice\\"] == 5 library.add_book(\\"Pride and Prejudice\\", 3) assert library.inventory[\\"Pride and Prejudice\\"] == 8 library.checkout_book(\\"Pride and Prejudice\\") assert library.inventory[\\"Pride and Prejudice\\"] == 7 library.return_book(\\"Pride and Prejudice\\") assert library.inventory[\\"Pride and Prejudice\\"] == 8","solution":"class Library: def __init__(self): self.inventory = {} def add_book(self, title: str, copies: int) -> None: if title in self.inventory: self.inventory[title] += copies else: self.inventory[title] = copies def checkout_book(self, title: str) -> bool: if title in self.inventory and self.inventory[title] > 0: self.inventory[title] -= 1 return True return False def return_book(self, title: str) -> None: if title in self.inventory: self.inventory[title] += 1 def is_book_available(self, title: str) -> bool: return title in self.inventory and self.inventory[title] > 0"},{"question":"class DynamicString: def __init__(self) -> None: Initializes an empty dynamic string. self.current_string = \\"\\" def append(self, value: str) -> None: Appends the given value to the current string. Args: value (str): The string to append. pass def delete(self, count: int) -> None: Deletes the last count characters from the current string. Args: count (int): Number of characters to delete. pass def get_string(self) -> str: Returns the current string. Returns: str: The current string. pass # Example usage ds = DynamicString() ds.append(\\"Hello\\") ds.append(\\"World\\") assert ds.get_string() == \\"HelloWorld\\" ds.delete(5) assert ds.get_string() == \\"Hello\\" ds.delete(10) assert ds.get_string() == \\"\\" ds.append(\\"Python\\") assert ds.get_string() == \\"Python\\" # Unit tests def test_append(): ds = DynamicString() ds.append(\\"Hello\\") assert ds.get_string() == \\"Hello\\" ds.append(\\"World\\") assert ds.get_string() == \\"HelloWorld\\" def test_delete_within_bounds(): ds = DynamicString() ds.append(\\"Hello\\") ds.append(\\"World\\") ds.delete(5) assert ds.get_string() == \\"Hello\\" ds.delete(2) assert ds.get_string() == \\"Hel\\" def test_delete_beyond_bounds(): ds = DynamicString() ds.append(\\"Hello\\") ds.delete(10) assert ds.get_string() == \\"\\" def test_delete_to_empty_and_append(): ds = DynamicString() ds.append(\\"Hello\\") ds.delete(5) ds.append(\\"Python\\") assert ds.get_string() == \\"Python\\" def test_get_string_empty(): ds = DynamicString() assert ds.get_string() == \\"\\"","solution":"class DynamicString: def __init__(self) -> None: self.current_string = [] def append(self, value: str) -> None: self.current_string.append(value) def delete(self, count: int) -> None: remaining_count = count while remaining_count > 0 and self.current_string: last_string = self.current_string.pop() if len(last_string) > remaining_count: self.current_string.append(last_string[:-remaining_count]) remaining_count = 0 else: remaining_count -= len(last_string) def get_string(self) -> str: return ''.join(self.current_string)"},{"question":"def smallest_binary_to_decimal(binaries: str) -> int: Takes a string of binary numbers separated by spaces and returns the decimal equivalent of the binary number that represents the smallest unsigned integer value. >>> smallest_binary_to_decimal(\\"101 010 001\\") 1 >>> smallest_binary_to_decimal(\\"1111 100000 10\\") 2","solution":"def smallest_binary_to_decimal(binaries: str) -> int: Takes a string of binary numbers separated by spaces and returns the decimal equivalent of the binary number that represents the smallest unsigned integer value. binary_numbers = binaries.split() decimal_numbers = [int(b, 2) for b in binary_numbers] return min(decimal_numbers)"},{"question":"def calculate_rental_fee( daily_fee: float, rental_days: int, return_days: int, late_fee_per_day: float ) -> float: Calculate the total rental fee including any late fees if applicable. Parameters: daily_fee (float): The fee charged per day for renting the movie. rental_days (int): The number of days the movie was originally rented for. return_days (int): The number of days after renting that the movie is actually returned. late_fee_per_day (float): The additional fee charged per day after the due date. Returns: float: The total fee for renting the movie, including any late fees. Raises: ValueError: If any parameter is negative. Examples: >>> calculate_rental_fee(5.0, 3, 5, 2.0) 19.0 >>> calculate_rental_fee(7.0, 2, 2, 3.0) 14.0 >>> calculate_rental_fee(8.0, 4, 4, 1.5) 32.0 if daily_fee < 0 or rental_days < 0 or return_days < 0 or late_fee_per_day < 0: raise ValueError(\\"All parameters must be non-negative.\\")","solution":"def calculate_rental_fee(daily_fee: float, rental_days: int, return_days: int, late_fee_per_day: float) -> float: Calculate the total rental fee including any late fees if applicable. Parameters: daily_fee (float): The fee charged per day for renting the movie. rental_days (int): The number of days the movie was originally rented for. return_days (int): The number of days after renting that the movie is actually returned. late_fee_per_day (float): The additional fee charged per day after the due date. Returns: float: The total fee for renting the movie, including any late fees. Raises: ValueError: If any parameter is negative. if daily_fee < 0 or rental_days < 0 or return_days < 0 or late_fee_per_day < 0: raise ValueError(\\"All parameters must be non-negative.\\") late_days = max(0, return_days - rental_days) total_fee = (daily_fee * rental_days) + (late_fee_per_day * late_days) return total_fee"},{"question":"def partition_labels(s: str) -> list[int]: Given a string \`s\`, partitions the string into as many parts as possible so that each letter appears in at most one part, and returns a list of integers representing the sizes of these parts. Parameters: s (str): A string consisting of lowercase English letters. Returns: list: A list of integers representing the sizes of the partitions. Example: >>> s = \\"ababcbacadefegdehijhklij\\" >>> partition_labels(s) [9, 7, 8]","solution":"def partition_labels(s: str) -> list[int]: Given a string \`s\`, partitions the string into as many parts as possible so that each letter appears in at most one part, and returns a list of integers representing the sizes of these parts. Parameters: s (str): A string consisting of lowercase English letters. Returns: list: A list of integers representing the sizes of the partitions. Example: >>> s = \\"ababcbacadefegdehijhklij\\" >>> partition_labels(s) [9, 7, 8] last_occurrence = {char: idx for idx, char in enumerate(s)} j = anchor = 0 result = [] for i, char in enumerate(s): j = max(j, last_occurrence[char]) if i == j: result.append(i - anchor + 1) anchor = i + 1 return result"},{"question":"def format_phone_number(numbers: list[int]) -> str: Formats a list of 10 integers into a phone number string in the format \\"(XXX) XXX-XXXX\\". >>> format_phone_number([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]) '(123) 456-7890' >>> format_phone_number([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) '(987) 654-3210'","solution":"def format_phone_number(numbers): Formats a list of 10 integers into a phone number string in the format \\"(XXX) XXX-XXXX\\". if len(numbers) != 10: raise ValueError(\\"Input list must contain exactly 10 digits.\\") for num in numbers: if not isinstance(num, int) or not (0 <= num <= 9): raise ValueError(\\"All elements in input list must be integers in the range 0 to 9.\\") phone_number = f\\"({numbers[0]}{numbers[1]}{numbers[2]}) {numbers[3]}{numbers[4]}{numbers[5]}-{numbers[6]}{numbers[7]}{numbers[8]}{numbers[9]}\\" return phone_number"},{"question":"def matrix_multiply(matrix_a: list, matrix_b: list) -> list: Multiplies two matrices and returns the resulting matrix. If the matrices cannot be multiplied due to dimension mismatch, returns an empty list. >>> matrix_multiply([[1, 2], [3, 4]], [[2, 0], [1, 2]]) [[4, 4], [10, 8]] >>> matrix_multiply([[1, 0, 2], [-1, 3, 1]], [[3, 1], [2, 1], [1, 0]]) [[5, 1], [4, 2]] >>> matrix_multiply([[1, 2, 3]], [[4], [5], [6]]) [[32]] >>> matrix_multiply([[1, 2]], [[1, 2], [3, 4], [5, 6]]) [] >>> matrix_multiply([[1, 0], [0, 1]], [[5, 6], [7, 8]]) [[5, 6], [7, 8]] >>> matrix_multiply([[0, 0], [0, 0]], [[1, 2], [3, 4]]) [[0, 0], [0, 0]] pass","solution":"def matrix_multiply(matrix_a, matrix_b): Multiplies two matrices and returns the resulting matrix. If the matrices cannot be multiplied due to dimension mismatch, returns an empty list. # Get dimensions of the matrices rows_a = len(matrix_a) cols_a = len(matrix_a[0]) rows_b = len(matrix_b) cols_b = len(matrix_b[0]) # Check if multiplication is possible if cols_a != rows_b: return [] # Initialize the result matrix with zeros result = [[0] * cols_b for _ in range(rows_a)] # Perform the multiplication for i in range(rows_a): for j in range(cols_b): for k in range(cols_a): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result"},{"question":"from typing import List def longest_common_prefix_pairs(strings: List[str]) -> List[str]: Given a list of strings, return a list of the longest common prefixes for sequential pairs of strings in the input list. >>> longest_common_prefix_pairs([\\"apple\\", \\"apricot\\", \\"banana\\", \\"bandana\\", \\"cherry\\"]) ['ap', '', 'ban', ''] >>> longest_common_prefix_pairs([\\"hello\\", \\"helium\\", \\"hero\\", \\"herald\\"]) ['hel', 'he', 'her'] >>> longest_common_prefix_pairs([\\"abc\\", \\"abcd\\", \\"abcde\\"]) ['abc', 'abcd']","solution":"from typing import List def longest_common_prefix_pairs(strings: List[str]) -> List[str]: def common_prefix(str1, str2): min_len = min(len(str1), len(str2)) for i in range(min_len): if str1[i] != str2[i]: return str1[:i] return str1[:min_len] result = [] for i in range(len(strings) - 1): result.append(common_prefix(strings[i], strings[i + 1])) return result"},{"question":"def merge_sorted_lists(list_a, list_b): Merges two sorted lists into a single sorted list without using any built-in sorting functions. Parameters: list_a (list): A list of integers sorted in ascending order. list_b (list): Another list of integers sorted in ascending order. Returns: list: A merged list sorted in ascending order. >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([-1, 0, 1], [-2, 2]) [-2, -1, 0, 1, 2] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([4, 5, 6], []) [4, 5, 6] >>> merge_sorted_lists([], []) [] >>> merge_sorted_lists([1, 2, 3], [1, 2, 3]) [1, 1, 2, 2, 3, 3] >>> merge_sorted_lists([1, 1, 1], [1, 1, 1]) [1, 1, 1, 1, 1, 1]","solution":"def merge_sorted_lists(list_a, list_b): Merges two sorted lists into a single sorted list. Parameters: list_a (list): A list of integers sorted in ascending order. list_b (list): Another list of integers sorted in ascending order. Returns: list: A merged list sorted in ascending order. # Ensure inputs are list assert isinstance(list_a, list), \\"Expected list, got {}\\".format(type(list_a)) assert isinstance(list_b, list), \\"Expected list, got {}\\".format(type(list_b)) i, j = 0, 0 result = [] # Merge the two lists while i < len(list_a) and j < len(list_b): if list_a[i] < list_b[j]: result.append(list_a[i]) i += 1 else: result.append(list_b[j]) j += 1 # Add any remaining elements from list_a while i < len(list_a): result.append(list_a[i]) i += 1 # Add any remaining elements from list_b while j < len(list_b): result.append(list_b[j]) j += 1 return result"},{"question":"def max_subarray_sum(arr: list, k: int) -> int: Determine the maximum sum of any k consecutive elements in the array. Parameters: arr (list): A list of integers. k (int): The number of consecutive elements to consider for the sum. Returns: int: The maximum sum of any k consecutive elements in the array. >>> max_subarray_sum([2, 1, 5, 1, 3, 2], 3) 9 >>> max_subarray_sum([1, 2, 3, 4, 5], 2) 9 >>> max_subarray_sum([-1, -2, -3, -4], 2) -3 >>> max_subarray_sum([4, -1, 2, 1], 2) 5 from solution import max_subarray_sum def test_example_case(): arr = [2, 1, 5, 1, 3, 2] k = 3 assert max_subarray_sum(arr, k) == 9 def test_all_positive_elements(): arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] k = 4 assert max_subarray_sum(arr, k) == 34 def test_all_negative_elements(): arr = [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10] k = 3 assert max_subarray_sum(arr, k) == -6 def test_mixed_elements(): arr = [2, -1, 2, 3, -2, 3] k = 2 assert max_subarray_sum(arr, k) == 5 def test_k_equals_array_length(): arr = [5, 1, 2, 3, -1, -2, 4] k = 7 assert max_subarray_sum(arr, k) == 12 def test_single_element_array(): arr = [-3] k = 1 assert max_subarray_sum(arr, k) == -3 def test_large_array(): arr = [i for i in range(100000)] k = 50000 assert max_subarray_sum(arr, k) == sum(range(50000, 100000)) def test_large_array_with_negative_numbers(): arr = [i - 50000 for i in range(100000)] k = 50000 assert max_subarray_sum(arr, k) == sum(range(50000))","solution":"def max_subarray_sum(arr, k): Returns the maximum sum of any k consecutive elements in the array. Parameters: arr (list): A list of integers. k (int): The number of consecutive elements to consider for the sum. Returns: int: The maximum sum of any k consecutive elements in the array. n = len(arr) if n == 0 or k > n: return 0 # Calculate the sum of the first k elements current_sum = sum(arr[:k]) max_sum = current_sum # Slide the window across the array, adjusting the sum by subtracting # the element that is left behind and adding the new element. for i in range(n - k): current_sum = current_sum - arr[i] + arr[i + k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"class Library: def __init__(self): self.books = {} self.members = {} def add_book(self, book_id: int, title: str, author: str) -> None: - book_id <type: int>: Unique identifier for the book - title <type: str>: Title of the book - author <type: str>: Author of the book Returns: None pass def lend_book(self, book_id: int, member_id: int) -> bool: - book_id <type: int>: Unique identifier for the book to be lent - member_id <type: int>: Unique identifier for the member who wants to borrow the book Returns <type: bool>: - True if the book is successfully lent - False if the book is not available or member ID is invalid pass def return_book(self, book_id: int) -> bool: - book_id <type: int>: Unique identifier for the book to be returned Returns <type: bool>: - True if the book is successfully returned - False if the book ID is invalid or the book was not on loan pass def view_library(self) -> None: Displays the current list of books with their status (available/loaned). Returns: None pass","solution":"class Library: def __init__(self): self.books = {} self.members = {} def add_book(self, book_id: int, title: str, author: str) -> None: - book_id <type: int>: Unique identifier for the book - title <type: str>: Title of the book - author <type: str>: Author of the book Returns: None if book_id in self.books: raise ValueError(\\"A book with this ID already exists.\\") self.books[book_id] = { \\"title\\": title, \\"author\\": author, \\"is_available\\": True } def lend_book(self, book_id: int, member_id: int) -> bool: - book_id <type: int>: Unique identifier for the book to be lent - member_id <type: int>: Unique identifier for the member who wants to borrow the book Returns <type: bool>: - True if the book is successfully lent - False if the book is not available or member ID is invalid if book_id not in self.books or not self.books[book_id][\\"is_available\\"]: return False self.books[book_id][\\"is_available\\"] = False self.members[member_id] = book_id return True def return_book(self, book_id: int) -> bool: - book_id <type: int>: Unique identifier for the book to be returned Returns <type: bool>: - True if the book is successfully returned - False if the book ID is invalid or the book was not on loan if book_id not in self.books or self.books[book_id][\\"is_available\\"]: return False self.books[book_id][\\"is_available\\"] = True member_id = [k for k, v in self.members.items() if v == book_id] if member_id: del self.members[member_id[0]] return True def view_library(self) -> None: Displays the current list of books with their status (available/loaned). Returns: None for book_id, details in self.books.items(): status = \\"available\\" if details[\\"is_available\\"] else \\"on loan\\" print(f\\"ID: {book_id}, Title: {details['title']}, Author: {details['author']}, Status: {status}\\")"},{"question":"class Task: def __init__(self, name: str, priority: int, completion_time: int): self.name = name self.priority = priority self.completion_time = completion_time def sort_tasks(tasks: List[Task]) -> List[Task]: Sorts tasks based on multiple criteria: - Primary sorting by \`priority\` in descending order. - Secondary sorting by \`completion_time\` in ascending order. - If both \`priority\` and \`completion_time\` are identical, sort by \`name\` in ascending order. >>> tasks = [ ... Task(\\"task1\\", 2, 100), ... Task(\\"task2\\", 1, 200), ... Task(\\"task3\\", 2, 50), ... Task(\\"task4\\", 3, 150) ... ] >>> sorted_tasks = sort_tasks(tasks) >>> [task.name for task in sorted_tasks] [\\"task4\\", \\"task3\\", \\"task1\\", \\"task2\\"] >>> tasks = [ ... Task(\\"taskA\\", 1, 100), ... Task(\\"taskB\\", 1, 100), ... Task(\\"taskC\\", 1, 100) ... ] >>> sorted_tasks = sort_tasks(tasks) >>> [task.name for task in sorted_tasks] [\\"taskA\\", \\"taskB\\", \\"taskC\\"] pass","solution":"class Task: def __init__(self, name: str, priority: int, completion_time: int): self.name = name self.priority = priority self.completion_time = completion_time def sort_tasks(tasks): Sorts tasks based on multiple criteria: - Primary sorting by \`priority\` in descending order. - Secondary sorting by \`completion_time\` in ascending order. - If both \`priority\` and \`completion_time\` are identical, sort by \`name\` in ascending order. sorted_tasks = sorted(tasks, key=lambda task: (-task.priority, task.completion_time, task.name)) return sorted_tasks"},{"question":"from typing import List, Tuple def has_cycle(n: int, edges: List[Tuple[int, int]]) -> bool: Determine if the undirected graph contains any cycles. >>> has_cycle(4, [(0, 1), (1, 2), (2, 3), (3, 1)]) True >>> has_cycle(3, [(0, 1), (1, 2)]) False from typing import List, Tuple def test_cycle_detection_with_cycle(): n = 4 edges = [(0, 1), (1, 2), (2, 3), (3, 1)] assert has_cycle(n, edges) == True def test_cycle_detection_without_cycle(): n = 3 edges = [(0, 1), (1, 2)] assert has_cycle(n, edges) == False def test_no_vertices(): n = 0 edges = [] assert has_cycle(n, edges) == False def test_single_vertex_no_edges(): n = 1 edges = [] assert has_cycle(n, edges) == False def test_single_edge(): n = 2 edges = [(0, 1)] assert has_cycle(n, edges) == False def test_multiple_components_with_no_cycle(): n = 6 edges = [(0, 1), (2, 3), (4, 5)] assert has_cycle(n, edges) == False def test_multiple_components_with_cycle(): n = 6 edges = [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5)] assert has_cycle(n, edges) == True def test_self_loop(): n = 3 edges = [(0, 1), (1, 2), (1, 1)] assert has_cycle(n, edges) == True","solution":"from typing import List, Tuple def has_cycle(n: int, edges: List[Tuple[int, int]]) -> bool: def dfs(v, parent): visited[v] = True for neighbor in adjacency_list[v]: if not visited[neighbor]: if dfs(neighbor, v): return True elif neighbor != parent: return True return False if n <= 1: return False adjacency_list = [[] for _ in range(n)] for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) visited = [False] * n for i in range(n): if not visited[i]: if dfs(i, -1): return True return False"},{"question":"class Graph: def __init__(self): self.adj_list = {} def add_edge(self, u, v): if u not in self.adj_list: self.adj_list[u] = [] if v not in self.adj_list: self.adj_list[v] = [] self.adj_list[u].append(v) self.adj_list[v].append(u) def has_cycle_util(self, v, visited, parent): A utility function to perform DFS and check for cycle. visited[v] = True # Recur for all the vertices adjacent to this vertex for i in self.adj_list[v]: # If the adjacent node is not visited, then recurse on it if not visited[i]: if self.has_cycle_util(i, visited, v): return True # If an adjacent vertex is visited and is not parent of the current vertex, # then there is a cycle elif parent != i: return True return False def has_cycle(self) -> bool: Use DFS to detect if the graph contains any cycles. Returns True if there is a cycle, False otherwise. >>> g = Graph() >>> g.add_edge(0, 1) >>> g.add_edge(1, 2) >>> g.add_edge(2, 0) >>> g.add_edge(2, 3) >>> g.add_edge(3, 4) >>> g.has_cycle() True >>> g2 = Graph() >>> g2.add_edge(0, 1) >>> g2.add_edge(1, 2) >>> g2.add_edge(2, 3) >>> g2.has_cycle() False visited = {i: False for i in self.adj_list} for i in self.adj_list: if not visited[i]: # Don't recur for already visited vertices if self.has_cycle_util(i, visited, -1): return True return False","solution":"class Graph: def __init__(self): self.adj_list = {} def add_edge(self, u, v): if u not in self.adj_list: self.adj_list[u] = [] if v not in self.adj_list: self.adj_list[v] = [] self.adj_list[u].append(v) self.adj_list[v].append(u) def has_cycle_util(self, v, visited, parent): visited[v] = True # Recur for all the vertices adjacent to this vertex for i in self.adj_list[v]: # If the adjacent node is not visited, then recurse on it if not visited[i]: if self.has_cycle_util(i, visited, v): return True # If an adjacent vertex is visited and is not parent of the current vertex, # then there is a cycle elif parent != i: return True return False def has_cycle(self): visited = {i: False for i in self.adj_list} for i in self.adj_list: if not visited[i]: # Don't recur for already visited vertices if self.has_cycle_util(i, visited, -1): return True return False"},{"question":"import pandas as pd import matplotlib.pyplot as plt def analyze_sales_data(file_path: str) -> dict: Analyze and visualize sales data from the CSV file. Parameters: - file_path: str - Path to the sales data CSV file. Returns: A dictionary with keys as months (formatted YYYY-MM) and values as total sales amount for that month. Displays a bar graph of the top 5 products based on sales amount. pass # Unit Test import pytest from io import StringIO from solution import analyze_sales_data # Assuming the function is stored in 'solution.py' def test_analyze_sales_data(): csv_data = StringIO( Date,Product,Quantity,Price 2022-01-01,ProductA,10,15.5 2022-01-15,ProductB,5,20 2022-02-01,ProductA,6,15.5 2022-02-15,ProductC,7,40 2022-02-28,ProductA,2,15.5 2022-03-05,ProductB,3,20 ,ProductD,5,50 2022-03-15,ProductD,NaN,50 2022-03-25,ProductE,10,35 ) expected_output = { '2022-01': 10 * 15.5 + 5 * 20, '2022-02': 6 * 15.5 + 7 * 40 + 2 * 15.5, '2022-03': 3 * 20 + 10 * 35 } # Test the function result = analyze_sales_data(csv_data) assert result == expected_output def test_analyze_sales_data_with_empty_data(): csv_data = StringIO( Date,Product,Quantity,Price ) expected_output = {} # Test the function result = analyze_sales_data(csv_data) assert result == expected_output def test_analyze_sales_data_with_missing_values(): csv_data = StringIO( Date,Product,Quantity,Price 2022-01-01,ProductA,10, 2022-01-15,ProductB,,20 ,ProductC,5,30 2022-02-01,ProductC,5,30 ) expected_output = { '2022-02': 5 * 30 } # Test the function result = analyze_sales_data(csv_data) assert result == expected_output","solution":"import pandas as pd import matplotlib.pyplot as plt def analyze_sales_data(file_path: str) -> dict: Analyze and visualize sales data from the CSV file. Parameters: - file_path: str - Path to the sales data CSV file. Returns: A dictionary with keys as months (formatted YYYY-MM) and values as total sales amount for that month. Displays a bar graph of the top 5 products based on sales amount. try: # Load data df = pd.read_csv(file_path) # Clean data df['Date'] = pd.to_datetime(df['Date'], errors='coerce') df = df.dropna(subset=['Date', 'Product', 'Quantity', 'Price']) df['Quantity'] = pd.to_numeric(df['Quantity'], errors='coerce') df['Price'] = pd.to_numeric(df['Price'], errors='coerce') df = df.dropna(subset=['Quantity', 'Price']) # Calculate total sales amount df['SalesAmount'] = df['Quantity'] * df['Price'] # Monthly sales df['Month'] = df['Date'].dt.strftime('%Y-%m') monthly_sales = df.groupby('Month')['SalesAmount'].sum().to_dict() # Top products product_sales = df.groupby('Product')['SalesAmount'].sum().sort_values(ascending=False) top_products = product_sales.head(5) # Plot top products top_products.plot(kind='bar', title='Top 5 Products by Sales Amount', ylabel='Sales Amount') plt.show() return monthly_sales except Exception as e: print(f\\"An error occurred: {e}\\") return {}"},{"question":"def count_unique_words(text: str) -> int: Count the number of unique words in a given input string. >>> count_unique_words(\\"hello world\\") 2 >>> count_unique_words(\\"The quick brown fox jumps over the lazy dog\\") 8 >>> count_unique_words(\\"A good good night\\") 3","solution":"def count_unique_words(text): Returns the count of unique words in the input text. # Split the text into words using whitespace as the delimiter words = text.split() # Use a set to store unique words unique_words = set(words) # Return the number of unique words return len(unique_words)"},{"question":"def validate_postcode(postcode: str) -> bool: Validates whether a given string is a valid postal code. Valid postal code pattern: - 1st character: Letter - 2nd character: Digit - 3rd character: Letter - 4th character: space (optional) - 5th character: Digit - 6th character: Letter - 7th character: Digit >>> validate_postcode(\\"A1B 2C3\\") # returns True >>> validate_postcode(\\"A1B2C3\\") # returns True >>> validate_postcode(\\"K7L 5A9\\") # returns True >>> validate_postcode(\\"1234567\\") # returns False >>> validate_postcode(\\"A2 C4\\") # returns False >>> validate_postcode(\\"A1B 2C34\\")# returns False >>> validate_postcode(\\"a1b 2c3\\") # returns False","solution":"import re def validate_postcode(postcode: str) -> bool: Validates whether the given string is a valid postal code. Args: postcode (str): The postal code to validate. Returns: bool: True if the postal code is valid, otherwise False. # Regular expression pattern for validating the postal code pattern = re.compile(r'^[A-Z]d[A-Z] ?d[A-Z]d') return bool(pattern.match(postcode))"},{"question":"def convert_currency(amount: float, rate: float) -> float: Convert an amount of money to another currency using the provided rate. Parameters: amount (float): The amount of money in the original currency. rate (float): The conversion rate to the target currency. Returns: float: The converted amount in the target currency. >>> convert_currency(100.0, 0.85) 85.0 >>> convert_currency(200.0, 1.2) 240.0 pass def apply_tax(amount: float, tax_rate: float) -> float: Apply tax to the given amount. Parameters: amount (float): The amount of money before tax. tax_rate (float): The tax rate as a percentage. Returns: float: The total amount after applying the tax. >>> apply_tax(100.0, 15.0) 115.0 >>> apply_tax(200.0, 7.5) 215.0 pass # Unit Tests def test_convert_currency(): assert convert_currency(100.0, 0.85) == 85.0 assert convert_currency(200.0, 1.2) == 240.0 assert convert_currency(0.0, 1.5) == 0.0 assert convert_currency(50.0, 0.0) == 0.0 assert convert_currency(100.0, 1.0) == 100.0 def test_apply_tax(): assert apply_tax(100.0, 15.0) == 115.0 assert apply_tax(200.0, 7.5) == 215.0 assert apply_tax(0.0, 10.0) == 0.0 assert apply_tax(100.0, 0.0) == 100.0 assert apply_tax(100.0, 100.0) == 200.0 def test_combined_usage(): usd_amount = convert_currency(100.0, 0.85) final_amount = apply_tax(usd_amount, 15.0) assert final_amount == 97.75 eur_amount = convert_currency(150.0, 0.9) final_amount = apply_tax(eur_amount, 20.0) assert final_amount == 162.0 def test_edge_cases(): assert convert_currency(1e-10, 0.85) == 0.0 assert apply_tax(1e-10, 15.0) == 0.0","solution":"def convert_currency(amount: float, rate: float) -> float: Convert an amount of money to another currency using the provided rate. Parameters: amount (float): The amount of money in the original currency. rate (float): The conversion rate to the target currency. Returns: float: The converted amount in the target currency. return round(amount * rate, 2) def apply_tax(amount: float, tax_rate: float) -> float: Apply tax to the given amount. Parameters: amount (float): The amount of money before tax. tax_rate (float): The tax rate as a percentage. Returns: float: The total amount after applying the tax. tax_amount = amount * (tax_rate / 100) return round(amount + tax_amount, 2)"},{"question":"# Implement \`ActivityTracker\` Class Implement the following class \`ActivityTracker\`: class ActivityTracker: def __init__(self): pass def log_activity(self, timestamp: int, activity: str) -> None: pass def get_recent_activities(self, n: int) -> list[str]: pass def get_most_frequent_activities(self, start_time: int, end_time: int) -> list[str]: pass Your implementation should complete the methods: 1. \`log_activity(self, timestamp: int, activity: str) -> None\`: Logs an activity with a given timestamp. 2. \`get_recent_activities(self, n: int) -> list[str]\`: Retrieves the most recent \`n\` activities, in reverse chronological order. 3. \`get_most_frequent_activities(self, start_time: int, end_time: int) -> list[str]\`: Retrieves the most frequent activities performed within a specified timeframe. Ensure that \`get_most_frequent_activities\` returns activities sorted lexicographically in case of ties. from collections import defaultdict, deque from heapq import nlargest class ActivityTracker: def __init__(self): self.activities = deque() self.activity_log = defaultdict(list) def log_activity(self, timestamp: int, activity: str) -> None: self.activities.append((timestamp, activity)) self.activity_log[activity].append(timestamp) def get_recent_activities(self, n: int) -> list[str]: return [activity for _, activity in list(self.activities)[-n:]][::-1] def get_most_frequent_activities(self, start_time: int, end_time: int) -> list[str]: count = defaultdict(int) for activity, timestamps in self.activity_log.items(): for timestamp in timestamps: if start_time <= timestamp <= end_time: count[activity] += 1 max_freq = max(count.values(), default=0) most_frequent = [activity for activity, freq in count.items() if freq == max_freq] return sorted(most_frequent) # Example Usage tracker = ActivityTracker() tracker.log_activity(1, \\"login\\") tracker.log_activity(2, \\"view_page\\") tracker.log_activity(3, \\"logout\\") tracker.log_activity(4, \\"login\\") tracker.log_activity(5, \\"purchase\\") assert tracker.get_recent_activities(3) == [\\"purchase\\", \\"login\\", \\"logout\\"] assert tracker.get_most_frequent_activities(1, 5) == [\\"login\\"]","solution":"from collections import defaultdict, deque from heapq import nlargest class ActivityTracker: def __init__(self): self.activities = deque() self.activity_log = defaultdict(list) def log_activity(self, timestamp: int, activity: str) -> None: self.activities.append((timestamp, activity)) self.activity_log[activity].append(timestamp) def get_recent_activities(self, n: int) -> list[str]: return [activity for _, activity in list(self.activities)[-n:]][::-1] def get_most_frequent_activities(self, start_time: int, end_time: int) -> list[str]: count = defaultdict(int) for activity, timestamps in self.activity_log.items(): for timestamp in timestamps: if start_time <= timestamp <= end_time: count[activity] += 1 max_freq = max(count.values(), default=0) most_frequent = [activity for activity, freq in count.items() if freq == max_freq] return sorted(most_frequent)"},{"question":"def is_fibonacci(x: int) -> bool: Check if an integer is a Fibonacci number. Given an integer \`x\`, determine if it is a member of the Fibonacci sequence. Args: x (int): The integer to be tested for Fibonacci membership. Returns: bool: True if \`x\` is a Fibonacci number, False otherwise. >>> is_fibonacci(8) True >>> is_fibonacci(10) False >>> is_fibonacci(13) True >>> is_fibonacci(21) True >>> is_fibonacci(-5) False import pytest def test_positive_fibonacci_numbers(): assert is_fibonacci(0) == True assert is_fibonacci(1) == True assert is_fibonacci(2) == True assert is_fibonacci(3) == True assert is_fibonacci(5) == True assert is_fibonacci(8) == True assert is_fibonacci(13) == True assert is_fibonacci(21) == True assert is_fibonacci(34) == True def test_non_fibonacci_numbers(): assert is_fibonacci(4) == False assert is_fibonacci(6) == False assert is_fibonacci(7) == False assert is_fibonacci(9) == False assert is_fibonacci(10) == False assert is_fibonacci(14) == False def test_large_fibonacci_numbers(): assert is_fibonacci(144) == True assert is_fibonacci(233) == True assert is_fibonacci(987) == True def test_large_non_fibonacci_numbers(): assert is_fibonacci(500) == False assert is_fibonacci(1000) == False assert is_fibonacci(1500) == False def test_negative_numbers(): assert is_fibonacci(-1) == False assert is_fibonacci(-5) == False assert is_fibonacci(-21) == False def test_invalid_inputs(): with pytest.raises(ValueError): is_fibonacci(\\"a string\\") with pytest.raises(ValueError): is_fibonacci(5.5) with pytest.raises(ValueError): is_fibonacci([3]) pytest.main()","solution":"import math def is_fibonacci(x: int) -> bool: Check if a given integer x is a Fibonacci number. if not isinstance(x, int): raise ValueError(\\"Input must be an integer.\\") if x < 0: return False # A number is a Fibonacci number if and only if one or both of (5*x^2 + 4) or (5*x^2 - 4) # is a perfect square. def is_perfect_square(n): s = int(math.isqrt(n)) return s * s == n val1 = 5 * x * x + 4 val2 = 5 * x * x - 4 return is_perfect_square(val1) or is_perfect_square(val2)"},{"question":"**Complete the \`unique_paths_with_obstacles\` function to return the correct result based on the given grid.** def unique_paths_with_obstacles(grid: list[list[int]]) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of the grid. m, n = len(grid), len(grid[0]) # Edge case where the start or end is an obstacle if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 # Initialize the DP table dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Starting point # Fill the DP table for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1] def test_unique_paths_with_obstacles(): assert unique_paths_with_obstacles([ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]) == 2 assert unique_paths_with_obstacles([ [0, 1], [0, 0] ]) == 1 assert unique_paths_with_obstacles([ [1, 0], [0, 0] ]) == 0 assert unique_paths_with_obstacles([ [0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0] ]) == 2 assert unique_paths_with_obstacles([ [0] ]) == 1 assert unique_paths_with_obstacles([ [0, 0], [0, 1] ]) == 0 assert unique_paths_with_obstacles([ [0, 0, 1], [1, 0, 0], [0, 0, 0] ]) == 2 def test_no_path_due_to_obstacles(): assert unique_paths_with_obstacles([ [0, 0, 0], [0, 0, 0], [1, 1, 1] ]) == 0","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of the grid. m, n = len(grid), len(grid[0]) # Edge case where the start or end is an obstacle if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 # Initialize the DP table dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Starting point # Fill the DP table for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def total_histogram_area(heights: list[int]) -> int: Calculate the total area of the histogram where each bar can be aligned vertically with the previous bar, with each bar starting at the level of the previous bar or higher. :param heights: List of non-negative integers representing the heights of the histogram bars. :return: Integer representing the total area of the histogram. Examples: >>> total_histogram_area([1, 2, 3, 4, 5]) 15 >>> total_histogram_area([0, 2, 2, 2]) 6 >>> total_histogram_area([1, 1, 2, 3]) 7 >>> total_histogram_area([5, 5, 5]) 15 >>> total_histogram_area([3, 4, 4, 5, 6]) 22 >>> total_histogram_area([]) 0","solution":"def total_histogram_area(heights): Calculate the total area of the histogram where each bar can be aligned vertically with the previous bar, with each bar starting at the level of the previous bar or higher. :param heights: List of non-negative integers representing the heights of the histogram bars. :return: Integer representing the total area of the histogram. if not heights: return 0 total_area = 0 for height in heights: total_area += height return total_area"},{"question":"def count_vowels(s: str) -> int: Recursively counts the number of vowels in the string s. Args: s (str): A string containing only alphabetic characters. Returns: int: The number of vowels in the string. >>> count_vowels(\\"hello\\") 2 >>> count_vowels(\\"HELLO\\") 2 >>> count_vowels(\\"aEiOu\\") 5 >>> count_vowels(\\"Programming\\") 3 >>> count_vowels(\\"\\") 0","solution":"def count_vowels(s: str) -> int: Recursively counts the number of vowels in the string s. vowels = \\"aeiou\\" s = s.lower() if len(s) == 0: return 0 if s[0] in vowels: return 1 + count_vowels(s[1:]) else: return count_vowels(s[1:])"},{"question":"def levenshtein_distance(s1: str, s2: str) -> int: Compute the Levenshtein distance between two strings. :param s1: The first string. :param s2: The second string. :return: The Levenshtein distance between s1 and s2. >>> levenshtein_distance(\\"kitten\\", \\"sitting\\") # 3 >>> levenshtein_distance(\\"flaw\\", \\"lawn\\") # 2 >>> levenshtein_distance(\\"gumbo\\", \\"gambol\\") # 2 >>> levenshtein_distance(\\"\\", \\"abc\\") # 3 >>> levenshtein_distance(\\"abc\\", \\"\\") # 3 >>> levenshtein_distance(\\"abc\\", \\"abc\\") # 0 >>> levenshtein_distance(\\"a\\", \\"a\\") # 0 >>> levenshtein_distance(\\"a\\", \\"b\\") # 1 >>> levenshtein_distance(\\"ab\\", \\"ba\\") # 2 >>> levenshtein_distance(\\"intention\\", \\"execution\\") # 5","solution":"def levenshtein_distance(s1: str, s2: str) -> int: Compute the Levenshtein distance between two strings. :param s1: The first string. :param s2: The second string. :return: The Levenshtein distance between s1 and s2. n, m = len(s1), len(s2) # If one of the strings is empty if n == 0: return m if m == 0: return n # Create a distance matrix dp = [[0] * (m + 1) for _ in range(n + 1)] # Initialize the distance matrix for i in range(n + 1): dp[i][0] = i for j in range(m + 1): dp[0][j] = j # Compute distances using dynamic programming for i in range(1, n + 1): for j in range(1, m + 1): cost = 0 if s1[i - 1] == s2[j - 1] else 1 dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + cost) # Substitution return dp[n][m]"},{"question":"from typing import List class LRUCache: Implements a Least Recently Used (LRU) Cache. Args: - capacity (int): Maximum number of key-value pairs the cache can hold. Methods: - get(key: int) -> int: Retrieves the value associated with the key, or -1 if the key does not exist. - put(key: int, value: int) -> None: Inserts or updates the key-value pair into the cache following the LRU policy. - delete(key: int) -> None: Removes the key-value pair if the key exists. Example: >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) 1 >>> cache.put(3, 3) # Evicts key 2 >>> cache.get(2) -1 >>> cache.put(4, 4) # Evicts key 1 >>> cache.get(1) -1 >>> cache.get(3) 3 >>> cache.get(4) 4 >>> cache.delete(3) >>> cache.get(3) -1 def __init__(self, capacity: int): # Your initialization here def get(self, key: int) -> int: # Your implementation here def put(self, key: int, value: int) -> None: # Your implementation here def delete(self, key: int) -> None: # Your implementation here def test_lru_cache_put_get(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # returns 1 cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1 # returns -1 (not found) cache.put(4, 4) # evicts key 1 assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(3) == 3 # returns 3 assert cache.get(4) == 4 # returns 4 def test_lru_cache_delete(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.delete(1) assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(2) == 2 # returns 2 cache.put(3, 3) # does not evict any key since delete happened assert cache.get(3) == 3 # returns 3 def test_lru_cache_update(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(1, 10) # updates key 1 with value 10 assert cache.get(1) == 10 # returns 10 assert cache.get(2) == 2 # returns 2 def test_lru_cache_eviction_order(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(3, 3) # evicts key 1 assert cache.get(1) == -1 cache.put(4, 4) # evicts key 2 assert cache.get(2) == -1 assert cache.get(3) == 3 assert cache.get(4) == 4 def test_lru_cache_capacity_one(): cache = LRUCache(1) cache.put(1, 1) assert cache.get(1) == 1 cache.put(2, 2) # evicts key 1 assert cache.get(1) == -1 assert cache.get(2) == 2","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) def delete(self, key: int) -> None: if key in self.cache: del self.cache[key]"},{"question":"class ListNode: def __init__(self, val=0, next=None, random=None): self.val = val self.next = next self.random = random def copyRandomList(head: Optional[ListNode]) -> Optional[ListNode]: Implement a function that clones a linked list where each node contains an additional random pointer pointing to any node in the list or null. Args: head (Optional[ListNode]): The head of the linked list. Returns: Optional[ListNode]: The head of the new cloned linked list, which is a deep copy of the original list. Example: >>> node1 = ListNode(7) >>> node2 = ListNode(13) >>> node3 = ListNode(11) >>> node4 = ListNode(10) >>> node5 = ListNode(1) >>> node1.next = node2 >>> node2.next = node3 >>> node3.next = node4 >>> node4.next = node5 >>> node1.random = None >>> node2.random = node1 >>> node3.random = node5 >>> node4.random = node3 >>> node5.random = node1 >>> cloned_head = copyRandomList(node1) >>> cloned_head.val 7 >>> cloned_head.next.val 13 >>> cloned_head.next.random.val 7 >>> copyRandomList(None) is None True pass","solution":"class ListNode: def __init__(self, val=0, next=None, random=None): self.val = val self.next = next self.random = random def copyRandomList(head: ListNode) -> ListNode: if not head: return None # Step 1: Create new nodes next to original nodes current = head while current: new_node = ListNode(current.val) new_node.next = current.next current.next = new_node current = new_node.next # Step 2: Assign random pointers for cloned nodes current = head while current: if current.random: current.next.random = current.random.next current = current.next.next # Step 3: Separate the cloned list from the original list pseudo_head = ListNode(0) current = head clone_current = pseudo_head while current: clone_current.next = current.next clone_current = clone_current.next current.next = current.next.next current = current.next return pseudo_head.next"},{"question":"from typing import List, Tuple def can_form_teams(n: int, k: int, pairs: List[Tuple[int, int]]) -> bool: Determine if it is possible to form project teams following given constraints. Each project team should have exactly \`k\` employees, all members of a project team must be listed in pairs of preferences, and each employee can only be in one project team. >>> can_form_teams(4, 2, [(1, 2), (2, 3), (3, 4), (1, 4)]) True >>> can_form_teams(5, 2, [(1, 2), (2, 3), (3, 4), (4, 5)]) False >>> can_form_teams(3, 3, [(1, 2), (2, 3), (1, 3)]) True >>> can_form_teams(3, 2, []) False >>> can_form_teams(6, 3, [(1, 2), (2, 3), (1, 3), (4, 5), (5, 6), (4, 6)]) True >>> can_form_teams(6, 3, [(1, 2), (2, 3), (1, 3), (4, 5)]) False >>> can_form_teams(9, 3, [(1, 2), (2, 3), (1, 3), (4, 5), (5, 6), (4, 6), (7, 8), (8, 9), (7, 9)]) True","solution":"def can_form_teams(n, k, pairs): from collections import defaultdict import itertools if n % k != 0: return False # Create a graph from the pairs adjacency_list = defaultdict(set) for a, b in pairs: adjacency_list[a].add(b) adjacency_list[b].add(a) # Function to find all k-sized cliques in the graph def k_cliques(adjacency_list, k): potential_cliques = list(itertools.combinations(adjacency_list.keys(), k)) valid_cliques = [] for clique in potential_cliques: if all(adjacency_list[u].intersection(clique) >= set(clique) - {u} for u in clique): valid_cliques.append(set(clique)) return valid_cliques # Find all k-sized cliques cliques = k_cliques(adjacency_list, k) if len(cliques) < n // k: return False # Check for overlap in cliques visited = set() for clique in cliques: if visited.intersection(clique): continue visited.update(clique) return len(visited) == n"},{"question":"import re def is_valid_time(time_str: str) -> bool: Determines if the provided time string is a valid 24-hour formatted time. :param time_str: Input time string in HH:MM format :return: Boolean indicating whether the time string is valid according to the defined rules >>> is_valid_time(\\"14:30\\") True >>> is_valid_time(\\"09:45\\") True >>> is_valid_time(\\"23:59\\") True >>> is_valid_time(\\"24:00\\") False >>> is_valid_time(\\"12:60\\") False >>> is_valid_time(\\"7:30\\") False >>> is_valid_time(\\"14:3\\") False","solution":"import re def is_valid_time(time_str): Determines if the provided time string is a valid 24-hour formatted time. :param time_str: Input time string in HH:MM format :return: Boolean indicating whether the time string is valid according to the defined rules pattern = r\\"^(2[0-3]|[01]d):([0-5]d)\\" if re.match(pattern, time_str): return True return False"},{"question":"def longest_increasing_subsequence(text: str) -> str: Returns the longest increasing alphabetical subsequence from the input string. >>> longest_increasing_subsequence('abcbdab') == 'abcd' >>> longest_increasing_subsequence('zyxwv') == 'z' >>> longest_increasing_subsequence('abcdz') == 'abcdz'","solution":"def longest_increasing_subsequence(text: str) -> str: Returns the longest increasing alphabetical subsequence from the input string. if not text: return '' # Initialize the longest increasing subsequence lis = [] for char in text: # If the character is greater than the last character in the LIS, append it if not lis or char > lis[-1]: lis.append(char) return ''.join(lis)"},{"question":"def merge_sorted_lists(list1: list, list2: list) -> list: Merge two sorted lists into a single sorted list without duplicates. >>> merge_sorted_lists([1, 3, 5], [2, 3, 6]) [1, 2, 3, 5, 6] >>> merge_sorted_lists([0, 4, 4, 10], [4, 7, 12]) [0, 4, 7, 10, 12] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([1, 2, 2, 3], []) [1, 2, 3]","solution":"def merge_sorted_lists(list1: list, list2: list) -> list: Merge two sorted lists into a single sorted list without duplicates. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: if not merged_list or list1[i] != merged_list[-1]: merged_list.append(list1[i]) i += 1 elif list1[i] > list2[j]: if not merged_list or list2[j] != merged_list[-1]: merged_list.append(list2[j]) j += 1 else: if not merged_list or list1[i] != merged_list[-1]: merged_list.append(list1[i]) i += 1 j += 1 # Append remaining elements of list1 while i < len(list1): if not merged_list or list1[i] != merged_list[-1]: merged_list.append(list1[i]) i += 1 # Append remaining elements of list2 while j < len(list2): if not merged_list or list2[j] != merged_list[-1]: merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def run_length_encode(s: str) -> str: Efficient String Compression Using Run-Length Encoding (RLE) Run-Length Encoding (RLE) compresses consecutive identical elements by replacing them with one instance of the element followed by the number of occurrences. Args: s (str): The input string to be compressed. Returns: str: The RLE-compressed version of the input string. Examples: >>> run_length_encode(\\"aaabbcccc\\") 'a3b2c4' >>> run_length_encode(\\"abcd\\") 'a1b1c1d1' >>> run_length_encode(\\"\\") '' pass # Unit test examples def test_run_length_encode_basic(): assert run_length_encode(\\"aaabbcccc\\") == \\"a3b2c4\\" assert run_length_encode(\\"abcd\\") == \\"a1b1c1d1\\" assert run_length_encode(\\"\\") == \\"\\" def test_run_length_encode_single_char_string(): assert run_length_encode(\\"a\\") == \\"a1\\" assert run_length_encode(\\"bbbbb\\") == \\"b5\\" def test_run_length_encode_mixed_chars(): assert run_length_encode(\\"aabbccdd\\") == \\"a2b2c2d2\\" assert run_length_encode(\\"aabbaaa\\") == \\"a2b2a3\\" assert run_length_encode(\\"zzzzaaaabbbcccc\\") == \\"z4a4b3c4\\" def test_run_length_encode_no_repeating_chars(): assert run_length_encode(\\"abcdefgh\\") == \\"a1b1c1d1e1f1g1h1\\" def test_run_length_encode_large_input(): large_input = \\"a\\" * 100000 expected_output = \\"a100000\\" assert run_length_encode(large_input) == expected_output def test_run_length_encode_boundary_case(): assert run_length_encode(\\"z\\" * 50000 + \\"y\\" * 50000) == \\"z50000y50000\\"","solution":"def run_length_encode(s: str) -> str: if not s: return \\"\\" encoded_string = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: encoded_string.append(current_char + str(count)) current_char = char count = 1 # Don't forget to add the last set of characters encoded_string.append(current_char + str(count)) return \\"\\".join(encoded_string)"},{"question":"def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: Transpose a given 2D matrix. Args: - matrix: A list of lists where each sublist represents a row of the matrix. Returns: - A new matrix that is the transpose of the input matrix. Examples: >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([[1]]) [[1]] >>> transpose_matrix([[1, 2, 3, 4], [5, 6, 7, 8]]) [[1, 5], [2, 6], [3, 7], [4, 8]]","solution":"def transpose_matrix(matrix): Returns the transpose of the given 2D matrix. Args: - matrix: A list of lists where each sublist represents a row of the matrix. Returns: - A new matrix that is the transpose of the input matrix. # Use zip(*matrix) to transpose rows and columns transposed = [list(row) for row in zip(*matrix)] return transposed"},{"question":"def count_distinct_subsequences(s: str, t: str) -> int: Count the number of distinct subsequences of s that equal the target string t. Args: s (str): Input string s containing lowercase English letters. t (str): Target string t containing lowercase English letters. Returns: int: The number of distinct subsequences of s that are equal to t. Examples: >>> count_distinct_subsequences(\\"rabbbit\\", \\"rabbit\\") 3 >>> count_distinct_subsequences(\\"babgbag\\", \\"bag\\") 5 >>> count_distinct_subsequences(\\"abcdef\\", \\"z\\") 0 >>> count_distinct_subsequences(\\"bbab\\", \\"bab\\") 2 >>> count_distinct_subsequences(\\"abcdef\\", \\"\\") 1 >>> count_distinct_subsequences(\\"\\", \\"a\\") 0 >>> count_distinct_subsequences(\\"abc\\", \\"abc\\") 1 >>> count_distinct_subsequences(\\"abc\\", \\"abcd\\") 0","solution":"def count_distinct_subsequences(s: str, t: str) -> int: m, n = len(t), len(s) if m > n: return 0 dp = [[0] * (n + 1) for _ in range(m + 1)] for j in range(n + 1): dp[0][j] = 1 # An empty t has 1 subsequence in any prefix of s. for i in range(1, m + 1): for j in range(1, n + 1): if t[i - 1] == s[j - 1]: dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1] else: dp[i][j] = dp[i][j - 1] return dp[m][n]"},{"question":"from typing import Any, Dict def book_quantity(inventory: Dict[str, Dict[str, Any]], book_name: str) -> int: Returns the quantity of the specified book in the inventory. Args: inventory: A dictionary representing the bookstore's inventory. book_name: The title of the book whose quantity is to be fetched. Returns: The available quantity of the specified book. >>> inventory = { >>> \\"Book A\\": {\\"quantity\\": 10, \\"genre\\": \\"Fiction\\"}, >>> \\"Book B\\": {\\"quantity\\": 5, \\"genre\\": \\"Science\\"}, >>> \\"Book C\\": {\\"quantity\\": 3, \\"genre\\": \\"Fiction\\"} >>> } >>> book_quantity(inventory, \\"Book A\\") 10 >>> book_quantity(inventory, \\"Book B\\") 5 >>> book_quantity(inventory, \\"Book D\\") 0 def inventory_value( inventory: Dict[str, Dict[str, Any]], book_prices: Dict[str, float], genre: str ) -> float: Computes the total value of all books in the inventory for a specific genre. Args: inventory: A dictionary representing the bookstore's inventory. book_prices: A dictionary where keys are book titles and values are their prices. genre: The genre of books for which the total inventory value needs to be calculated. Returns: The total value of the inventory for the specified genre. >>> inventory = { >>> \\"Book A\\": {\\"quantity\\": 10, \\"genre\\": \\"Fiction\\"}, >>> \\"Book B\\": {\\"quantity\\": 5, \\"genre\\": \\"Science\\"}, >>> \\"Book C\\": {\\"quantity\\": 3, \\"genre\\": \\"Fiction\\"}, >>> \\"Book D\\": {\\"quantity\\": 2, \\"genre\\": \\"Science\\"} >>> } >>> book_prices = { >>> \\"Book A\\": 15.0, >>> \\"Book B\\": 20.0, >>> \\"Book C\\": 25.0, >>> \\"Book D\\": 30.0 >>> } >>> inventory_value(inventory, book_prices, \\"Fiction\\") 325.0 >>> inventory_value(inventory, book_prices, \\"Science\\") 160.0 >>> inventory_value(inventory, book_prices, \\"Non-Fiction\\") 0.0","solution":"from typing import Any, Dict def book_quantity(inventory: Dict[str, Dict[str, Any]], book_name: str) -> int: Returns the quantity of the specified book in the inventory. Args: inventory: A dictionary representing the bookstore's inventory. book_name: The title of the book whose quantity is to be fetched. Returns: The available quantity of the specified book. return inventory.get(book_name, {}).get('quantity', 0) def inventory_value( inventory: Dict[str, Dict[str, Any]], book_prices: Dict[str, float], genre: str ) -> float: Computes the total value of all books in the inventory for a specific genre. Args: inventory: A dictionary representing the bookstore's inventory. book_prices: A dictionary where keys are book titles and values are their prices. genre: The genre of books for which the total inventory value needs to be calculated. Returns: The total value of the inventory for the specified genre. total_value = 0.0 for book, details in inventory.items(): if details['genre'] == genre: total_value += details['quantity'] * book_prices.get(book, 0.0) return total_value"},{"question":"from typing import List, Tuple, Union def recommend_genre(books: List[Tuple[str, str]]) -> Union[str, List[str]]: Recommend the most read genre(s) based on the list of books. :param books: List of tuples, where each tuple contains a book title and its genre. :return: The genre that is most read, or a list of genres if there is a tie. >>> recommend_genre([('The Hobbit', 'Fantasy'), ('1984', 'Dystopian'), ('Hobbit', 'Fantasy'), ('Brave New World', 'Dystopian')]) ['Dystopian', 'Fantasy'] >>> recommend_genre([('Book1', 'Fantasy'), ('Book2', 'Fantasy')]) 'Fantasy' >>> recommend_genre([('Book1', 'Fantasy'), ('Book2', 'Dystopian')]) ['Dystopian', 'Fantasy'] >>> recommend_genre([('Book1', 'Fantasy'), ('Book2', 'Fantasy'), ('Book3', 'Dystopian'), ('Book4', 'Dystopian')]) ['Dystopian', 'Fantasy'] >>> recommend_genre([('Book1', 'Fantasy'), ('Book2', 'Fantasy'), ('Book3', 'Dystopian')]) 'Fantasy' >>> recommend_genre([('Book1', 'Fantasy')]) 'Fantasy'","solution":"from typing import List, Tuple, Union from collections import Counter def recommend_genre(books: List[Tuple[str, str]]) -> Union[str, List[str]]: Recommend the most read genre(s) based on the list of books. :param books: List of tuples, where each tuple contains a book title and its genre. :return: The genre that is most read, or a list of genres if there is a tie. genre_count = Counter(genre for _, genre in books) max_count = max(genre_count.values()) most_read_genres = [genre for genre, count in genre_count.items() if count == max_count] if len(most_read_genres) == 1: return most_read_genres[0] return sorted(most_read_genres)"},{"question":"import numpy as np from scipy.spatial import distance def knn_anomaly_detection(data: np.ndarray, k: int, threshold: float) -> np.ndarray: Detect anomalies using k-Nearest Neighbors. Parameters: - data (ndarray): A 2D NumPy array of shape (n_samples, n_features). - k (int): The number of nearest neighbors to consider. - threshold (float): The distance threshold above which a sample is considered an anomaly. Returns: - A 1D NumPy array of indices representing the samples detected as anomalies. >>> data = np.array([[1.0, 2.0], [1.1, 2.1], [1.2, 2.2], [10.0, 10.0], [10.1, 10.1]]) >>> k = 2 >>> threshold = 5.0 >>> knn_anomaly_detection(data, k, threshold) array([3, 4]) >>> data = np.array([[1.0, 2.0], [1.1, 2.1], [1.2, 2.2], [1.3, 2.3], [1.4, 2.4]]) >>> k = 2 >>> threshold = 5.0 >>> knn_anomaly_detection(data, k, threshold) array([]) >>> data = np.array([[1.0, 2.0], [2.0, 3.0], [3.0, 4.0], [4.0, 5.0], [5.0, 6.0]]) >>> k = 2 >>> threshold = 1.0 >>> knn_anomaly_detection(data, k, threshold) array([0, 1, 2, 3, 4]) >>> data = np.random.rand(100, 50) >>> k = 5 >>> threshold = 0.5 >>> result = knn_anomaly_detection(data, k, threshold) >>> result.ndim == 1 True","solution":"import numpy as np from scipy.spatial import distance def knn_anomaly_detection(data, k, threshold): Detect anomalies using k-Nearest Neighbors. Parameters: - data (ndarray): A 2D NumPy array of shape (n_samples, n_features). - k (int): The number of nearest neighbors to consider. - threshold (float): The distance threshold above which a sample is considered an anomaly. Returns: - A 1D NumPy array of indices representing the samples detected as anomalies. n_samples = data.shape[0] anomalies = [] # Compute distances between each point and all other points dist_matrix = distance.cdist(data, data, 'euclidean') for i in range(n_samples): # Sort distances for the current point and exclude the zero distance (self-distance) sorted_dists = np.sort(dist_matrix[i])[1:k+1] # If the average distance to the k nearest neighbors exceeds the threshold, mark it as an anomaly if np.mean(sorted_dists) > threshold: anomalies.append(i) return np.array(anomalies)"},{"question":"class QueueOverflowError(Exception): pass class QueueUnderflowError(Exception): pass class Queue: def __init__(self, limit: int): Initialize the queue with a size limit. Arguments: limit -- maximum number of elements the queue can hold. def enqueue(self, data): Add an element to the back of the queue. Arguments: data -- the element to be added to the queue Raises: QueueOverflowError: if the queue is full. def dequeue(self): Remove and return the front element of the queue. Raises: QueueUnderflowError: if the queue is empty. Returns: the front element of the queue def front(self): Return but do not remove the front element of the queue. Raises: QueueUnderflowError: if the queue is empty. Returns: the front element of the queue def is_empty(self): Check if the queue is empty. Returns: True if the queue is empty, False otherwise def is_full(self): Check if the queue is full. Returns: True if the queue is full, False otherwise def size(self): Return the number of elements currently in the queue. Returns: an integer indicating the queue's current size # Unit Tests import pytest def test_enqueue(): q = Queue(3) q.enqueue(1) q.enqueue(2) q.enqueue(3) assert q.size() == 3 with pytest.raises(QueueOverflowError): q.enqueue(4) def test_dequeue(): q = Queue(3) q.enqueue(1) q.enqueue(2) assert q.dequeue() == 1 assert q.dequeue() == 2 with pytest.raises(QueueUnderflowError): q.dequeue() def test_front(): q = Queue(3) q.enqueue(1) assert q.front() == 1 q.enqueue(2) assert q.front() == 1 q.dequeue() assert q.front() == 2 with pytest.raises(QueueUnderflowError): empty_queue = Queue(3) empty_queue.front() def test_is_empty(): q = Queue(3) assert q.is_empty() == True q.enqueue(1) assert q.is_empty() == False q.dequeue() assert q.is_empty() == True def test_is_full(): q = Queue(3) assert q.is_full() == False q.enqueue(1) q.enqueue(2) q.enqueue(3) assert q.is_full() == True q.dequeue() assert q.is_full() == False def test_size(): q = Queue(3) assert q.size() == 0 q.enqueue(1) q.enqueue(2) assert q.size() == 2 q.enqueue(3) assert q.size() == 3 q.dequeue() assert q.size() == 2","solution":"class QueueOverflowError(Exception): pass class QueueUnderflowError(Exception): pass class Queue: def __init__(self, limit: int): self.limit = limit self.queue = [] def enqueue(self, data): if len(self.queue) >= self.limit: raise QueueOverflowError(\\"Too many elements\\") self.queue.append(data) def dequeue(self): if len(self.queue) == 0: raise QueueUnderflowError(\\"No elements to dequeue\\") return self.queue.pop(0) def front(self): if len(self.queue) == 0: raise QueueUnderflowError(\\"No elements in the queue\\") return self.queue[0] def is_empty(self): return len(self.queue) == 0 def is_full(self): return len(self.queue) >= self.limit def size(self): return len(self.queue)"},{"question":"def can_form_by_deletion(source: str, s: str) -> bool: Determines if \`s\` can be formed from \`source\` by deleting some or none of the characters from \`source\` without changing the order of the remaining characters. >>> can_form_by_deletion(\\"helloworld\\", \\"hlo\\") True >>> can_form_by_deletion(\\"helloworld\\", \\"hero\\") False >>> can_form_by_deletion(\\"abcde\\", \\"ace\\") True >>> can_form_by_deletion(\\"abcde\\", \\"aec\\") False >>> can_form_by_deletion(\\"aaaaa\\", \\"aa\\") True","solution":"def can_form_by_deletion(source: str, s: str) -> bool: Determines if \`s\` can be formed from \`source\` by deleting some of the characters in \`source\` without reordering the remaining characters. :param source: The source string from which characters are deleted. :param s: The target string to form. :return: True if s can be formed by deleting characters from source, otherwise False. source_index = 0 s_index = 0 while source_index < len(source) and s_index < len(s): if source[source_index] == s[s_index]: s_index += 1 source_index += 1 return s_index == len(s)"},{"question":"from typing import List def longest_even_subarray(arr: List[int]) -> int: Returns the length of the longest contiguous subarray consisting of only even numbers. Args: arr (List[int]): A list of integers. Returns: int: The length of the longest contiguous subarray of even numbers. Examples: >>> longest_even_subarray([1, 2, 4, 6, 3, 8, 10, 12]) 3 >>> longest_even_subarray([1, 3, 5, 7, 9]) 0 >>> longest_even_subarray([2, 4, 6, 8, 10]) 5 >>> longest_even_subarray([]) 0 >>> longest_even_subarray([-4, 2, -6, 7, 10, -8]) 3","solution":"def longest_even_subarray(arr): Returns the length of the longest contiguous subarray consisting of only even numbers. max_length = 0 current_length = 0 for num in arr: if num % 2 == 0: current_length += 1 else: max_length = max(max_length, current_length) current_length = 0 # Check at the end of the array max_length = max(max_length, current_length) return max_length"},{"question":"def insertion_sort(arr: list[int]) -> list[int]: Sort a list of integers using the insertion sort algorithm. >>> insertion_sort([4, 2, 2, 8, 3, 3, 1]) [1, 2, 2, 3, 3, 4, 8] >>> insertion_sort([12, 11, 13, 5, 6, 7]) [5, 6, 7, 11, 12, 13] >>> insertion_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> insertion_sort([]) [] pass def validate_insertion_sort( test_cases: list[list[int]], sorted_cases: list[list[int]], ) -> bool: Validate the Insertion Sort algorithm against Python's built-in sorting function for accuracy and stability. Parameters ---------- test_cases : list of list of int List containing lists of integers to be sorted. sorted_cases : list of list of int List containing the expected sorted lists for comparison. Returns ------- bool True if the Insertion Sort algorithm correctly sorts all the given lists and maintains stability, False otherwise. >>> test_cases = [ >>> [4, 2, 2, 8, 3, 3, 1], >>> [12, 11, 13, 5, 6, 7], >>> [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], >>> [1, 3, 2, 1, 3, 2], >>> [-1, -3, 2, 1, 0, -5, 4] >>> ] >>> sorted_cases = [ >>> [1, 2, 2, 3, 3, 4, 8], >>> [5, 6, 7, 11, 12, 13], >>> [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9], >>> [1, 1, 2, 2, 3, 3], >>> [-5, -3, -1, 0, 1, 2, 4] >>> ] >>> validate_insertion_sort(test_cases, sorted_cases) True pass","solution":"def insertion_sort(arr): for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def validate_insertion_sort(test_cases, sorted_cases): for i, test_case in enumerate(test_cases): # Apply insertion sort sorted_result = insertion_sort(test_case.copy()) # Validate against expected sorted result if sorted_result != sorted_cases[i]: return False # Validate against built-in sorted function if sorted_result != sorted(test_case): return False return True"},{"question":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, key: int): Insert a new element into the BST. Input: Integer data - key Output: None def _insert(self, node: TreeNode, key: int): Helper method to recursively insert a new node. Input: node - current tree node key - integer data to insert Output: None def height(self) -> int: Calculate the height of the BST. Output: Integer representing the height of the tree. >>> bst = BinarySearchTree() >>> inputs = [30, 20, 40, 10, 25] >>> for inp in inputs: bst.insert(inp) >>> bst.height() 3 >>> bst = BinarySearchTree() >>> bst.height() 0 def _height(self, node: TreeNode) -> int: Helper method to recursively determine the height of a node. Input: current tree node Output: integer height of the node's subtree def in_order_traversal(self) -> List[int]: Perform in-order traversal of the BST and return the list of elements. Output: List of integers. >>> bst = BinarySearchTree() >>> inputs = [30, 20, 40, 10, 25] >>> for inp in inputs: bst.insert(inp) >>> bst.in_order_traversal() [10, 20, 25, 30, 40] >>> bst = BinarySearchTree() >>> bst.in_order_traversal() [] def _in_order_traversal(self, node: TreeNode, result: List[int]): Helper method to recursively perform in-order traversal. Input: node - current tree node result - list to which the traversal result is appended.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.key: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) def height(self): return self._height(self.root) def _height(self, node): if not node: return 0 left_height = self._height(node.left) right_height = self._height(node.right) return 1 + max(left_height, right_height) def in_order_traversal(self): result = [] self._in_order_traversal(self.root, result) return result def _in_order_traversal(self, node, result): if not node: return self._in_order_traversal(node.left, result) result.append(node.key) self._in_order_traversal(node.right, result) # Example Usage bst = BinarySearchTree() inputs = [30, 20, 40, 10, 25] for inp in inputs: bst.insert(inp) print(\\"Height of BST:\\", bst.height()) # Output: 3 print(\\"In-order Traversal of BST:\\", bst.in_order_traversal()) # Output: [10, 20, 25, 30, 40]"},{"question":"def flatten_directory(directory: dict, current_path: str = '') -> list[str]: Flattens the directory structure into a list of paths to each file. >>> flatten_directory({'a': {'b': {'c': None}}, 'd': {'e': None}, 'f.txt': None}) ['a/b/c', 'd/e', 'f.txt'] >>> flatten_directory({'root': {'folder1': {'file1.txt': None}, 'folder2': {'file2.txt': None}}}) ['root/folder1/file1.txt', 'root/folder2/file2.txt'] >>> flatten_directory({'docs': {'readme.md': None, 'tutorial': {'part1.md': None, 'part2.md': None}}, 'image.png': None}) ['docs/readme.md', 'docs/tutorial/part1.md', 'docs/tutorial/part2.md', 'image.png'] >>> flatten_directory({}) [] import pytest from solution import flatten_directory def test_single_file(): assert flatten_directory({'file.txt': None}) == ['file.txt'] def test_nested_directories(): assert flatten_directory({'a': {'b': {'c': None}}, 'd': {'e': None}}) == ['a/b/c', 'd/e'] def test_mixed_content(): assert flatten_directory({'root': {'folder1': {'file1.txt': None}, 'folder2': {'file2.txt': None}}, 'log.txt': None}) == ['root/folder1/file1.txt', 'root/folder2/file2.txt', 'log.txt'] def test_deeply_nested(): assert flatten_directory({'a': {'b': {'c': {'d': {'e': None}}}}}) == ['a/b/c/d/e'] def test_empty_directory(): assert flatten_directory({}) == [] def test_direct_files_under_root(): assert flatten_directory({'docs': {'readme.md': None, 'tutorial': {'part1.md': None, 'part2.md': None}}, 'image.png': None}) == ['docs/readme.md', 'docs/tutorial/part1.md', 'docs/tutorial/part2.md', 'image.png'] def test_edge_case_only_directories_no_files(): assert flatten_directory({'folder1': {}}) == [] def test_mix_of_files_and_directories(): assert flatten_directory({'a': {'b': None, 'c': {'d': None}}, 'e.txt': None}) == ['a/b', 'a/c/d', 'e.txt']","solution":"def flatten_directory(directory: dict, current_path: str = '') -> list: paths = [] for name, content in directory.items(): new_path = f'{current_path}/{name}' if current_path else name if content is None: paths.append(new_path) else: paths.extend(flatten_directory(content, new_path)) return paths"},{"question":"def find_anagrams(words: list[str]) -> list[str]: Given a list of strings \`words\`, return the list of all the strings that are anagrams of another string in the list. A string is an anagram of another string if it can be formed by rearranging the letters of the other string. Args: words (list of str): A list of strings where each string consists of lowercase English letters. Returns: list of str: A list of all the strings that are anagrams of another string in the list. The returned list should be sorted in lexicographical order. Examples: >>> find_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"rat\\", \\"tar\\", \\"art\\", \\"evil\\", \\"vile\\", \\"live\\"]) [\\"art\\", \\"enlist\\", \\"evil\\", \\"listen\\", \\"live\\", \\"rat\\", \\"silent\\", \\"tar\\", \\"vile\\"] >>> find_anagrams([\\"abcd\\", \\"bcda\\", \\"dabc\\", \\"eabcd\\", \\"efgh\\"]) [\\"abcd\\", \\"bcda\\", \\"dabc\\"] >>> find_anagrams([\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\"]) [] from collections import defaultdict anagrams_map = defaultdict(list) for word in words: key = \\"\\".join(sorted(word)) anagrams_map[key].append(word) result = [] for value in anagrams_map.values(): if len(value) > 1: result.extend(value) return sorted(result)","solution":"def find_anagrams(words: list[str]) -> list[str]: from collections import defaultdict anagrams_map = defaultdict(list) for word in words: key = \\"\\".join(sorted(word)) anagrams_map[key].append(word) result = [] for value in anagrams_map.values(): if len(value) > 1: result.extend(value) return sorted(result)"},{"question":"def prefix_to_infix(expression: str) -> str: Convert a given mathematical expression from prefix notation to infix notation. Args: expression (str): A string containing a valid prefix expression. Returns: str: A string representing the equivalent infix expression. Examples: >>> prefix_to_infix(\\"* + A B - C D\\") '((A + B) * (C - D))' >>> prefix_to_infix(\\"+ 3 * 5 6\\") '(3 + (5 * 6))' >>> prefix_to_infix(\\"- 3 4\\") '(3 - 4)'","solution":"def prefix_to_infix(expression: str) -> str: stack = [] operators = set(['+', '-', '*', '/']) expression = expression.split()[::-1] # reverse the expression list for symbol in expression: if symbol not in operators: stack.append(symbol) else: operand1 = stack.pop() operand2 = stack.pop() stack.append(f'({operand1} {symbol} {operand2})') return stack[0]"},{"question":"from typing import List def prefix_sum_array(arr: List[int]) -> List[int]: Given a list of integers, returns a list containing the prefix sum for each element in the list. Args: arr: List[int] - A list of integers Returns: List[int] - A list containing the prefix sum of each element in arr. >>> prefix_sum_array([1, 2, -3, 4]) [1, 3, 0, 4] >>> prefix_sum_array([0, 0, 0, 0]) [0, 0, 0, 0] >>> prefix_sum_array([1, -1, 1, -1]) [1, 0, 1, 0] >>> prefix_sum_array([]) []","solution":"from typing import List def prefix_sum_array(arr: List[int]) -> List[int]: Given a list of integers, returns a list containing the prefix sum for each element in the list. Args: arr: List[int] - A list of integers Returns: List[int] - A list containing the prefix sum of each element in arr. if not arr: return [] prefix_sums = [0] * len(arr) prefix_sums[0] = arr[0] for i in range(1, len(arr)): prefix_sums[i] = prefix_sums[i - 1] + arr[i] return prefix_sums"},{"question":"import heapq def efficient_dijkstra(graph, start_node): Implement Dijkstra's algorithm using a priority queue for performance optimization. Args: graph (dict): A dictionary of nodes and their neighbors with edge weights. start_node (any): The starting node identifier. Returns: dict: A dictionary of shortest path distances from start_node to all other nodes. Example: >>> graph = {'A': [('B', 1), ('C', 4)], 'B': [('A', 1), ('C', 2), ('D', 5)], 'C': [('A', 4), ('B', 2), ('D', 1)], 'D': [('B', 5), ('C', 1)]} >>> efficient_dijkstra(graph, 'A') {'A': 0, 'B': 1, 'C': 3, 'D': 4}","solution":"import heapq def efficient_dijkstra(graph, start_node): Implement Dijkstra's algorithm using a priority queue for performance optimization. Args: graph (dict): A dictionary of nodes and their neighbors with edge weights. start_node (any): The starting node identifier. Returns: dict: A dictionary of shortest path distances from start_node to all other nodes. # Initialize distances dictionary distances = {node: float('inf') for node in graph} distances[start_node] = 0 # Priority queue to manage exploration of nodes priority_queue = [(0, start_node)] while priority_queue: # Get the node with the smallest distance current_distance, current_node = heapq.heappop(priority_queue) # Skip if the current distance is not up-to-date if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight # Update the distance if found a shorter path if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances # Example usage: graph = { 'A': [('B', 1), ('C', 4)], 'B': [('A', 1), ('C', 2), ('D', 5)], 'C': [('A', 4), ('B', 2), ('D', 1)], 'D': [('B', 5), ('C', 1)] } start_node = 'A' distances = efficient_dijkstra(graph, start_node) print(\\"Shortest path distances from start node:\\", distances)"},{"question":"def detect_cycle_in_graph(graph: dict[int, list[int]]) -> bool: Detects if a directed graph contains any cycles. >>> detect_cycle_in_graph({ >>> 0: [1], >>> 1: [2], >>> 2: [0], # Cycle here >>> 3: [4], >>> 4: [5], >>> 5: [] >>> }) True >>> detect_cycle_in_graph({ >>> 0: [1, 2], >>> 1: [2], >>> 2: [3], >>> 3: [] >>> }) False Unit Test: from solution import detect_cycle_in_graph def test_cycle_in_small_graph(): graph = { 0: [1], 1: [2], 2: [0] # Cycle here } assert detect_cycle_in_graph(graph) == True def test_no_cycle_in_small_graph(): graph = { 0: [1, 2], 1: [2], 2: [3], 3: [] } assert detect_cycle_in_graph(graph) == False def test_disconnected_graph_with_cycle(): graph = { 0: [1], 1: [2], 2: [0], # Cycle here 3: [4], 4: [5], 5: [] } assert detect_cycle_in_graph(graph) == True def test_disconnected_graph_no_cycle(): graph = { 0: [1], 1: [2], 2: [], 3: [4], 4: [5], 5: [] } assert detect_cycle_in_graph(graph) == False def test_empty_graph(): graph = {} assert detect_cycle_in_graph(graph) == False def test_single_node_no_edges(): graph = { 0: [] } assert detect_cycle_in_graph(graph) == False def test_two_nodes_with_cycle(): graph = { 0: [1], 1: [0] } assert detect_cycle_in_graph(graph) == True def test_larger_graph_with_cycle(): graph = { 0: [1], 1: [2], 2: [3], 3: [4], 4: [0] # Cycle here } assert detect_cycle_in_graph(graph) == True def test_larger_graph_no_cycle(): graph = { 0: [1], 1: [2], 2: [3], 3: [4], 4: [] } assert detect_cycle_in_graph(graph) == False","solution":"def detect_cycle_in_graph(graph): Detects if a directed graph contains any cycles using DFS. def dfs(node): if node in recursion_stack: return True # Cycle detected if node in visited: return False visited.add(node) recursion_stack.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True recursion_stack.remove(node) return False visited = set() recursion_stack = set() for node in graph: if node not in visited: if dfs(node): return True return False"},{"question":"def search_matrix(matrix: List[List[int]], target: int) -> Tuple[int, int]: Searches for a given target value in a matrix where each row is sorted in ascending order from left to right, and each column is sorted in ascending order from top to bottom. Args: matrix (List[List[int]]): A 2D list of integers. target (int): The integer value to search for. Returns: Tuple[int, int]: A tuple of two integers representing the row and column of the target in the matrix. If the target is not found, return (-1, -1). Examples: >>> search_matrix([ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ], 5) (1, 1) >>> search_matrix([ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ], 20) (-1, -1)","solution":"from typing import List, Tuple def search_matrix(matrix: List[List[int]], target: int) -> Tuple[int, int]: if not matrix or not matrix[0]: return (-1, -1) rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return (row, col) elif matrix[row][col] > target: col -= 1 else: row += 1 return (-1, -1)"},{"question":"def trap_rain_water(heights: List[int]) -> int: Given a list of heights representing the height of buildings, determine the maximum amount of water that can be trapped between the buildings after raining. Parameters: ---------- heights: List[int] - A non-empty list of non-negative integers representing the heights of the buildings. Returns: ------- int - The maximum amount of trapped water. Constraints: ----------- - 1 <= len(heights) <= 100000 - 0 <= heights[i] <= 10000 >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) == 9 >>> trap_rain_water([2, 0, 2]) == 2 >>> trap_rain_water([3, 2, 1, 2, 3]) == 4 >>> trap_rain_water([1, 1, 1, 1, 1]) == 0 >>> trap_rain_water([0, 0, 0, 0, 0]) == 0 >>> trap_rain_water([3, 0, 0, 0, 3]) == 9 >>> trap_rain_water([5, 4, 1, 2]) == 1 >>> trap_rain_water([]) == 0 >>> trap_rain_water([5]) == 0 >>> trap_rain_water([5, 5, 5, 5]) == 0 pass","solution":"from typing import List def trap_rain_water(heights: List[int]) -> int: Given a list of heights representing the height of buildings, determine the maximum amount of water that can be trapped between the buildings after raining. Parameters: ---------- heights: List[int] - A non-empty list of non-negative integers representing the heights of the buildings. Returns: ------- int - The maximum amount of trapped water. if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def add_profile(profiles: dict, user_id: int, name: str, email: str, age: int) -> None: Adds a new user profile to the profiles dictionary. Args: profiles (dict): A dictionary to store user profiles. user_id (int): An integer representing the unique ID of the user. name (str): A string representing the name of the user. email (str): A string representing the email address of the user. age (int): An integer representing the age of the user. Returns: None. The function modifies the profiles dictionary in-place. pass def get_profile(profiles: dict, user_id: int) -> dict: Retrieves a user profile from the profiles dictionary based on the user ID. Args: profiles (dict): The dictionary containing user profiles. user_id (int): An integer representing the unique ID of the user whose profile needs to be retrieved. Returns: dict: A dictionary containing the user's profile details (\`name\`, \`email\`, \`age\`) if the user ID exists, otherwise an empty dictionary. pass if __name__ == \\"__main__\\": user_profiles = {} add_profile(user_profiles, 1, \\"Alice\\", \\"alice@example.com\\", 25) add_profile(user_profiles, 2, \\"Bob\\", \\"bob@example.com\\", 30) print(get_profile(user_profiles, 1)) # Output: {'name': 'Alice', 'email': 'alice@example.com', 'age': 25} print(get_profile(user_profiles, 3)) # Output: {}","solution":"def add_profile(profiles: dict, user_id: int, name: str, email: str, age: int) -> None: Adds a new user profile to the profiles dictionary. Args: profiles (dict): A dictionary to store user profiles. user_id (int): An integer representing the unique ID of the user. name (str): A string representing the name of the user. email (str): A string representing the email address of the user. age (int): An integer representing the age of the user. Returns: None. The function modifies the profiles dictionary in-place. profiles[user_id] = {\\"name\\": name, \\"email\\": email, \\"age\\": age} def get_profile(profiles: dict, user_id: int) -> dict: Retrieves a user profile from the profiles dictionary based on the user ID. Args: profiles (dict): The dictionary containing user profiles. user_id (int): An integer representing the unique ID of the user whose profile needs to be retrieved. Returns: dict: A dictionary containing the user's profile details (\`name\`, \`email\`, \`age\`) if the user ID exists, otherwise an empty dictionary. return profiles.get(user_id, {})"},{"question":"products = {} def add_product(product_name: str, price: int) -> None: Adds a product with its name and price to the collection. :param product_name: str - The name of the product :param price: int - The price of the product >>> add_product(\\"Apple\\", 120) >>> add_product(\\"Orange\\", 100) >>> \\"Apple\\" in products True >>> products[\\"Apple\\"] 120 pass def remove_product(product_name: str) -> None: Removes the product with the given name from the collection. :param product_name: str - The name of the product to be removed >>> remove_product(\\"Apple\\") >>> \\"Apple\\" in products False pass def find_cheapest() -> str: Finds and returns the name of the cheapest product. :return: str - The name of the cheapest product or None if no products are available >>> add_product(\\"Apple\\", 120) >>> add_product(\\"Banana\\", 80) >>> find_cheapest() 'Banana' pass def find_by_prefix(prefix: str) -> list: Returns a list of product names that start with the given prefix, sorted lexicographically. :param prefix: str - The prefix to match against product names :return: list - A list of matching product names sorted lexicographically >>> add_product(\\"Apple\\", 120) >>> add_product(\\"Grapefruit\\", 95) >>> find_by_prefix(\\"Ap\\") ['Apple'] >>> find_by_prefix(\\"G\\") ['Grapefruit'] pass","solution":"products = {} def add_product(product_name: str, price: int) -> None: products[product_name] = price def remove_product(product_name: str) -> None: if product_name in products: del products[product_name] def find_cheapest() -> str: if not products: return None return min(products, key=products.get) def find_by_prefix(prefix: str) -> list: return sorted([name for name in products if name.startswith(prefix)])"},{"question":"import numpy as np def fibonacci_matrix_transformation(matrix: np.ndarray) -> np.ndarray: Transform a given 2D numpy array by replacing its elements with Fibonacci numbers based on their positions in row-major order. >>> fibonacci_matrix_transformation(np.array([[2, 3], [5, 8]])) array([[0, 1], [1, 2]]) >>> fibonacci_matrix_transformation(np.array([[1, 2], [3, 4]])) array([[0, 1], [1, 2]]) from solution import fibonacci_matrix_transformation def test_single_element_matrix(): matrix = np.array([[7]]) transformed = fibonacci_matrix_transformation(matrix) assert np.array_equal(transformed, np.array([[0]])) def test_two_by_two_matrix(): matrix = np.array([[1, 2], [3, 4]]) transformed = fibonacci_matrix_transformation(matrix) assert np.array_equal(transformed, np.array([[0, 1], [1, 2]])) def test_three_by_two_matrix(): matrix = np.array([[1, 8], [9, 12], [5, 7]]) transformed = fibonacci_matrix_transformation(matrix) assert np.array_equal(transformed, np.array([[0, 1], [1, 2], [3, 5]])) def test_large_matrix(): matrix = np.ones((4, 4)) transformed = fibonacci_matrix_transformation(matrix) assert np.array_equal(transformed, np.array([ [0, 1, 1, 2], [3, 5, 8, 13], [21, 34, 55, 89], [144, 233, 377, 610] ]))","solution":"import numpy as np def fibonacci_matrix_transformation(matrix: np.ndarray) -> np.ndarray: # Find the size of the matrix M, N = matrix.shape size = M * N # Generating Fibonacci sequence of required length fib_seq = [0, 1] for i in range(2, size): fib_seq.append(fib_seq[-1] + fib_seq[-2]) # Creating the transformed matrix transformed_matrix = np.array(fib_seq[:size]).reshape(M, N) return transformed_matrix"},{"question":"import math from typing import List, Tuple def calculate_distance(waypoints: List[Tuple[float, float]]) -> float: Calculates the total distance traveled by a rover given a series of waypoints. Args: waypoints: A list of tuples, where each tuple contains two float values representing the x and y coordinates of each waypoint visited by the rover. Returns: The total distance the rover has traveled. >>> calculate_distance([(0, 0), (3, 4)]) 5.0 >>> calculate_distance([(1, 1), (4, 5), (9, 9)]) 12.806248474865697 >>> calculate_distance([(0, 0), (0, 0)]) 0.0 >>> calculate_distance([(0, 0)]) Traceback (most recent call last): ... ValueError: The rover must visit at least 2 waypoints","solution":"import math from typing import List, Tuple def calculate_distance(waypoints: List[Tuple[float, float]]) -> float: Calculates the total distance traveled by a rover given a series of waypoints. Args: waypoints: A list of tuples, where each tuple contains two float values representing the x and y coordinates of each waypoint visited by the rover. Returns: The total distance the rover has traveled. if len(waypoints) < 2: raise ValueError(\\"The rover must visit at least 2 waypoints\\") total_distance = 0.0 for i in range(1, len(waypoints)): x1, y1 = waypoints[i - 1] x2, y2 = waypoints[i] total_distance += math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) return total_distance"},{"question":"import math def find_smallest_multiple(m: int) -> int: Given an upper limit m, find the smallest positive number that is evenly divisible by all of the numbers from 1 to m. :param m: An integer representing the upper limit (m > 1) :return: An integer, representing the smallest number that is evenly divisible by all of the numbers from 1 to m. Example: >>> find_smallest_multiple(10) 2520 >>> find_smallest_multiple(15) 360360 >>> find_smallest_multiple(20) 232792560 pass","solution":"import math def find_smallest_multiple(m: int) -> int: Given an upper limit m, find the smallest positive number that is evenly divisible by all of the numbers from 1 to m. def lcm(a, b): return a * b // math.gcd(a, b) multiple = 1 for i in range(1, m + 1): multiple = lcm(multiple, i) return multiple"},{"question":"def find_unique_triplets(nums: list[int]) -> list[list[int]]: Returns all unique triplets in the array which sum to zero. Args: nums : list[int] List of integers. Returns: list[list[int]] List of unique triplets that sum to zero. >>> find_unique_triplets([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> find_unique_triplets([]) [] >>> find_unique_triplets([0, 0, 0]) [[0, 0, 0]] >>> find_unique_triplets([-2, 0, 1, 1, 2]) [[-2, 0, 2], [-2, 1, 1]] from solution import find_unique_triplets def test_example_case1(): assert sorted(find_unique_triplets([-1, 0, 1, 2, -1, -4])) == sorted([[-1, -1, 2], [-1, 0, 1]]) def test_example_case2(): assert find_unique_triplets([]) == [] def test_example_case3(): assert find_unique_triplets([0, 0, 0]) == [[0, 0, 0]] def test_example_case4(): assert sorted(find_unique_triplets([-2, 0, 1, 1, 2])) == sorted([[-2, 0, 2], [-2, 1, 1]]) def test_no_triplets(): assert find_unique_triplets([1, 2, 3, 4, 5]) == [] def test_only_negative_numbers(): assert find_unique_triplets([-5, -4, -3, -2, -1]) == [] def test_mixed_sign_numbers(): assert sorted(find_unique_triplets([-1, -1, 2, 2, -4, 0, 1, 1])) == sorted([[-4, 2, 2], [-1, 0, 1], [-1, -1, 2]]) def test_duplicates(): assert sorted(find_unique_triplets([0, 0, 0, 0])) == [[0, 0, 0]] def test_large_input(): import random nums = [random.randint(-10000, 10000) for _ in range(3000)] triplets = find_unique_triplets(nums) for triplet in triplets: assert sum(triplet) == 0","solution":"def find_unique_triplets(nums): Returns all unique triplets in the array which sum to zero. Args: nums : list[int] List of integers. Returns: list[list[int]] List of unique triplets that sum to zero. nums.sort() res = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, len(nums) - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total < 0: left += 1 elif total > 0: right -= 1 else: res.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 return res"},{"question":"[Completion Task in Python] import math def euclidean_distance(point1: tuple[float, float], point2: tuple[float, float]) -> float: Calculate the Euclidean distance between two points in a 2D plane. :param point1: Tuple containing two floats representing the x and y coordinates of the first point. :param point2: Tuple containing two floats representing the x and y coordinates of the second point. :return: A float representing the Euclidean distance between the two points. >>> euclidean_distance((3.0, 4.0), (0.0, 0.0)) 5.0 >>> euclidean_distance((1.5, -1.5), (-1.5, 1.5)) 4.242640687119285 >>> euclidean_distance((0.0, 0.0), (0.0, 0.0)) 0.0 >>> euclidean_distance((10**6, 10**6), (-10**6, -10**6)) 2828427.12474619 # Your code here","solution":"import math def euclidean_distance(point1: tuple[float, float], point2: tuple[float, float]) -> float: Calculate the Euclidean distance between two points in a 2D plane. :param point1: Tuple containing two floats representing the x and y coordinates of the first point. :param point2: Tuple containing two floats representing the x and y coordinates of the second point. :return: A float representing the Euclidean distance between the two points. if not isinstance(point1, tuple) or not isinstance(point2, tuple): raise TypeError(\\"Both points must be of type tuple.\\") if len(point1) != 2 or len(point2) != 2: raise ValueError(\\"Both points must contain exactly two elements.\\") x1, y1 = point1 x2, y2 = point2 return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)"},{"question":"def count_word_occurrences(text: str, word: str) -> int: Returns the count of how many times the specified word appears in the text. The search is case-insensitive and only counts whole word matches. >>> count_word_occurrences(\\"Hello world\\", \\"hello\\") 1 >>> count_word_occurrences(\\"Python is amazing. The python language is versatile.\\", \\"python\\") 2 >>> count_word_occurrences(\\"This is a test. Testing is essential.\\", \\"is\\") 2 >>> count_word_occurrences(\\"text analysis is fun\\", \\"word\\") 0 >>> count_word_occurrences(\\"Count the occurrences of specific words within a text.\\", \\"of\\") 1","solution":"def count_word_occurrences(text: str, word: str) -> int: Returns the count of how many times the specified word appears in the text. The search is case-insensitive and only counts whole word matches. if not isinstance(text, str) or not isinstance(word, str): raise ValueError(\\"Both text and word should be strings.\\") word = word.lower() text = text.lower() words = text.split() count = 0 for w in words: if w.strip('.,!?\\";:()[]{}') == word: count += 1 return count"},{"question":"file_system = {} def add_file(file_name: str) -> None: Add a new file to the system. pass def delete_file(file_name: str) -> None: Remove a file from the system. pass def update_metadata(file_name: str, metadata_key: str, metadata_value: str) -> None: Update the metadata attributes of a file. pass def get_metadata(file_name: str, metadata_key: str) -> str: Retrieve the metadata value of a specific attribute for a file. pass import pytest def test_add_file(): add_file(\\"file1.txt\\") assert \\"file1.txt\\" in file_system def test_delete_file(): add_file(\\"file2.txt\\") delete_file(\\"file2.txt\\") assert \\"file2.txt\\" not in file_system def test_update_metadata(): add_file(\\"file3.txt\\") update_metadata(\\"file3.txt\\", \\"author\\", \\"Alice\\") assert file_system[\\"file3.txt\\"][\\"author\\"] == \\"Alice\\" def test_update_metadata_nonexistent_file(): with pytest.raises(FileNotFoundError): update_metadata(\\"file4.txt\\", \\"author\\", \\"Alice\\") def test_get_metadata(): add_file(\\"file5.txt\\") update_metadata(\\"file5.txt\\", \\"author\\", \\"Bob\\") assert get_metadata(\\"file5.txt\\", \\"author\\") == \\"Bob\\" def test_get_metadata_nonexistent_file(): with pytest.raises(FileNotFoundError): get_metadata(\\"file6.txt\\", \\"author\\") def test_get_metadata_nonexistent_key(): add_file(\\"file7.txt\\") assert get_metadata(\\"file7.txt\\", \\"title\\") == None","solution":"file_system = {} def add_file(file_name: str) -> None: if file_name not in file_system: file_system[file_name] = {} def delete_file(file_name: str) -> None: if file_name in file_system: del file_system[file_name] def update_metadata(file_name: str, metadata_key: str, metadata_value: str) -> None: if file_name not in file_system: raise FileNotFoundError(f\\"File '{file_name}' not found.\\") file_system[file_name][metadata_key] = metadata_value def get_metadata(file_name: str, metadata_key: str) -> str: if file_name not in file_system: raise FileNotFoundError(f\\"File '{file_name}' not found.\\") return file_system[file_name].get(metadata_key, None)"},{"question":"from typing import List def merge_sort_desc(arr: List[int]) -> List[int]: Sort an array of integers in descending order using the Merge Sort algorithm. >>> merge_sort_desc([5, 3, 8, 4, 2]) [8, 5, 4, 3, 2] >>> merge_sort_desc([1]) [1] >>> merge_sort_desc([]) [] >>> merge_sort_desc([10, 9, 8, 7, 6]) [10, 9, 8, 7, 6] >>> merge_sort_desc([4, 5, 4, 3, 4, 2]) [5, 4, 4, 4, 3, 2] >>> merge_sort_desc([4000000, 1, 2, 1000000000]) [1000000000, 4000000, 2, 1] >>> merge_sort_desc([0, -1, -10, -300]) [0, -1, -10, -300] >>> merge_sort_desc([7, -2, 6, -5, 0]) [7, 6, 0, -2, -5]","solution":"from typing import List def merge_sort_desc(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort_desc(arr[:mid]) right_half = merge_sort_desc(arr[mid:]) return merge_descending(left_half, right_half) def merge_descending(left: List[int], right: List[int]) -> List[int]: result = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] > right[right_index]: result.append(left[left_index]) left_index += 1 else: result.append(right[right_index]) right_index += 1 result.extend(left[left_index:]) result.extend(right[right_index:]) return result"},{"question":"class Matrix: def __init__(self, rows: int, cols: int) -> None: Initialize the matrix with the given dimensions and set all elements to zero. pass def update(self, x: int, y: int, value: int) -> None: Update the value at position (x, y) in the matrix. pass def multiply(self, other: 'Matrix') -> 'Matrix': Multiply the current matrix with another matrix and return the resulting matrix. pass def sum(self) -> int: Return the sum of all elements in the matrix. pass # Unit tests import pytest def test_matrix_initialization(): m = Matrix(2, 3) assert m.rows == 2 assert m.cols == 3 assert m.data == [[0, 0, 0], [0, 0, 0]] def test_matrix_update(): m = Matrix(2, 2) m.update(0, 0, 5) m.update(1, 1, 10) assert m.data == [[5, 0], [0, 10]] def test_matrix_sum(): m = Matrix(2, 2) m.update(0, 0, 1) m.update(0, 1, 2) m.update(1, 0, 3) m.update(1, 1, 4) assert m.sum() == 10 def test_matrix_multiplication(): m1 = Matrix(2, 2) m1.update(0, 0, 1) m1.update(0, 1, 2) m1.update(1, 0, 3) m1.update(1, 1, 4) m2 = Matrix(2, 2) m2.update(0, 0, 5) m2.update(0, 1, 6) m2.update(1, 0, 7) m2.update(1, 1, 8) result = m1.multiply(m2) expected_data = [[19, 22], [43, 50]] assert result.data == expected_data assert result.sum() == 134 def test_incorrect_matrix_multiplication(): m1 = Matrix(2, 3) m2 = Matrix(2, 2) with pytest.raises(ValueError): m1.multiply(m2) def test_matrix_multiplication_different_sizes(): m3 = Matrix(1, 3) m3.update(0, 0, 1) m3.update(0, 1, 1) m3.update(0, 2, 1) m4 = Matrix(3, 1) m4.update(0, 0, 1) m4.update(1, 0, 1) m4.update(2, 0, 1) result = m3.multiply(m4) expected_data = [[3]] assert result.data == expected_data assert result.sum() == 3","solution":"class Matrix: def __init__(self, rows: int, cols: int) -> None: self.rows = rows self.cols = cols self.data = [[0 for _ in range(cols)] for _ in range(rows)] def update(self, x: int, y: int, value: int) -> None: self.data[x][y] = value def multiply(self, other: 'Matrix') -> 'Matrix': if self.cols != other.rows: raise ValueError(\\"Matrix dimensions do not allow multiplication\\") result = Matrix(self.rows, other.cols) for i in range(self.rows): for j in range(other.cols): cell_sum = 0 for k in range(self.cols): cell_sum += self.data[i][k] * other.data[k][j] result.update(i, j, cell_sum) return result def sum(self) -> int: return sum(sum(row) for row in self.data)"},{"question":"def binary_search(arr: list, target: int, recursive: bool = True) -> tuple: Enhances the standard binary search algorithm to include: 1. Count of the number of comparisons made during the search. 2. Ability to handle both recursive and iterative implementations, selectable by a parameter. Parameters: - arr: A sorted list of integers. - target: An integer value to search within the list. - recursive: A boolean parameter to select the search method (default True). Returns: A tuple containing: - The index of the target if found, else -1. - The number of comparisons made during the search. Example: >>> binary_search([1, 3, 5, 7, 9, 11, 13], 7, recursive=True) (3, number_of_comparisons) >>> binary_search([1, 3, 5, 7, 9, 11, 13], 4, recursive=False) (-1, number_of_comparisons) pass # Unit tests def test_recursive_search_found(): arr = [1, 3, 5, 7, 9, 11, 13] target = 7 result = binary_search(arr, target, recursive=True) assert result[0] == 3 assert result[1] > 0 # Number of comparisons made def test_recursive_search_not_found(): arr = [1, 3, 5, 7, 9, 11, 13] target = 4 result = binary_search(arr, target, recursive=True) assert result[0] == -1 assert result[1] > 0 # Number of comparisons made def test_iterative_search_found(): arr = [1, 3, 5, 7, 9, 11, 13] target = 9 result = binary_search(arr, target, recursive=False) assert result[0] == 4 assert result[1] > 0 # Number of comparisons made def test_iterative_search_not_found(): arr = [1, 3, 5, 7, 9, 11, 13] target = 2 result = binary_search(arr, target, recursive=False) assert result[0] == -1 assert result[1] > 0 # Number of comparisons made def test_recursive_search_single_element_found(): arr = [7] target = 7 result = binary_search(arr, target, recursive=True) assert result[0] == 0 assert result[1] == 1 # Number of comparisons made def test_recursive_search_single_element_not_found(): arr = [7] target = 5 result = binary_search(arr, target, recursive=True) assert result[0] == -1 assert result[1] == 1 # Number of comparisons made def test_iterative_search_single_element_found(): arr = [7] target = 7 result = binary_search(arr, target, recursive=False) assert result[0] == 0 assert result[1] == 1 # Number of comparisons made def test_iterative_search_single_element_not_found(): arr = [7] target = 5 result = binary_search(arr, target, recursive=False) assert result[0] == -1 assert result[1] == 1 # Number of comparisons made","solution":"def binary_search(arr, target, recursive=True): Performs a binary search and returns a tuple (index, comparisons). Parameters: - arr: a sorted list of integers. - target: the integer to search for within the list. - recursive: boolean to select between recursive and iterative implementations. Returns: A tuple containing: - index: the position of the target in the array if found, else -1. - comparisons: the total number of target comparisons made. def recursive_search(arr, target, left, right, comparisons): if left > right: return -1, comparisons mid = (left + right) // 2 comparisons += 1 if arr[mid] == target: return mid, comparisons elif arr[mid] < target: return recursive_search(arr, target, mid + 1, right, comparisons) else: return recursive_search(arr, target, left, mid - 1, comparisons) def iterative_search(arr, target): left, right = 0, len(arr) - 1 comparisons = 0 while left <= right: mid = (left + right) // 2 comparisons += 1 if arr[mid] == target: return mid, comparisons elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1, comparisons if recursive: return recursive_search(arr, target, 0, len(arr) - 1, 0) else: return iterative_search(arr, target)"},{"question":"from typing import List, Dict, Union Query = Dict[str, Union[str, int]] class FenwickTree: A class that represents a Fenwick Tree (Binary Indexed Tree), supporting efficient prefix sum calculation and value updates. def __init__(self, size: int): Initialize the Fenwick Tree of given size. self.size = size self.tree = [0] * (size + 1) def update(self, index: int, value: int): Increment the value at the given index by the specified amount. index += 1 while index <= self.size: self.tree[index] += value index += index & -index def prefix_sum(self, index: int) -> int: Calculate the prefix sum from the start of the array to the given index. sum_ = 0 index += 1 while index > 0: sum_ += self.tree[index] index -= index & -index return sum_ def fenwick_tree(queries: List[Query], arr: List[int]) -> List[int]: Handle a sequence of update and prefix sum queries on the array. Args: queries (List[Query]): A list of query dictionaries. arr (List[int]): The initial array. Returns: List[int]: The results of the prefix sum queries. Examples: >>> fenwick_tree([ ... {\\"type\\": \\"prefix_sum\\", \\"index\\": 5}, ... {\\"type\\": \\"update\\", \\"index\\": 3, \\"value\\": 5}, ... {\\"type\\": \\"prefix_sum\\", \\"index\\": 5}, ... ], [1, 7, 3, 0, 7, 8, 3, 2, 6, 2]) [26, 31] ft = FenwickTree(len(arr)) for i, num in enumerate(arr): ft.update(i, num) result = [] for query in queries: if query[\\"type\\"] == \\"update\\": ft.update(query[\\"index\\"], query[\\"value\\"]) elif query[\\"type\\"] == \\"prefix_sum\\": result.append(ft.prefix_sum(query[\\"index\\"])) return result # Unit tests def test_prefix_sum_simple(): arr = [1, 2, 3, 4, 5] queries = [{\\"type\\": \\"prefix_sum\\", \\"index\\": 2}] assert fenwick_tree(queries, arr) == [6] # 1 + 2 + 3 = 6 def test_update_and_prefix_sum(): arr = [1, 2, 3, 4, 5] queries = [ {\\"type\\": \\"prefix_sum\\", \\"index\\": 2}, {\\"type\\": \\"update\\", \\"index\\": 2, \\"value\\": 1}, {\\"type\\": \\"prefix_sum\\", \\"index\\": 2}, ] assert fenwick_tree(queries, arr) == [6, 7] # 1 + 2 + 3 = 6 then 1 + 2 + (3+1) = 7 def test_multiple_updates_and_prefix_sum(): arr = [1, 2, 3, 4, 5] queries = [ {\\"type\\": \\"update\\", \\"index\\": 0, \\"value\\": 2}, {\\"type\\": \\"prefix_sum\\", \\"index\\": 1}, {\\"type\\": \\"update\\", \\"index\\": 1, \\"value\\": 3}, {\\"type\\": \\"prefix_sum\\", \\"index\\": 2}, ] assert fenwick_tree(queries, arr) == [5, 11] # 3 + 2 = 5 then 3 + (2+3) + 3 = 11 def test_update_on_large_index(): arr = [1, 2, 3, 4, 5] queries = [ {\\"type\\": \\"update\\", \\"index\\": 4, \\"value\\": 5}, {\\"type\\": \\"prefix_sum\\", \\"index\\": 4}, ] assert fenwick_tree(queries, arr) == [20] # 1 + 2 + 3 + 4 + (5+5) = 20 def test_empty_queries(): arr = [1, 2, 3, 4, 5] queries = [] assert fenwick_tree(queries, arr) == [] def test_no_update_prefix_sum(): arr = [10, 20, 30, 40] queries = [ {\\"type\\": \\"prefix_sum\\", \\"index\\": 3}, {\\"type\\": \\"prefix_sum\\", \\"index\\": 1}, ] assert fenwick_tree(queries, arr) == [100, 30] # 10 + 20 + 30 + 40 = 100, 10 + 20 = 30","solution":"from typing import List, Dict, Union Query = Dict[str, Union[str, int]] class FenwickTree: def __init__(self, size: int): self.size = size self.tree = [0] * (size + 1) def update(self, index: int, value: int): index += 1 while index <= self.size: self.tree[index] += value index += index & -index def prefix_sum(self, index: int) -> int: sum_ = 0 index += 1 while index > 0: sum_ += self.tree[index] index -= index & -index return sum_ def fenwick_tree(queries: List[Query], arr: List[int]) -> List[int]: ft = FenwickTree(len(arr)) for i, num in enumerate(arr): ft.update(i, num) result = [] for query in queries: if query[\\"type\\"] == \\"update\\": ft.update(query[\\"index\\"], query[\\"value\\"]) elif query[\\"type\\"] == \\"prefix_sum\\": result.append(ft.prefix_sum(query[\\"index\\"])) return result"},{"question":"from typing import List def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]: Takes a square matrix (2D list) as input and rotates it 90 degrees clockwise. >>> rotate_matrix_90_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_clockwise([ ... [1, 2], ... [3, 4]]) [[3, 1], [4, 2]] pass # Implement the function here # Test cases to validate the solution def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] result = rotate_matrix_90_clockwise(matrix) expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert result == expected def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] result = rotate_matrix_90_clockwise(matrix) expected = [ [3, 1], [4, 2] ] assert result == expected def test_rotate_4x4_matrix(): matrix = [ [ 1, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12], [13, 14, 15, 16] ] result = rotate_matrix_90_clockwise(matrix) expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert result == expected def test_rotate_1x1_matrix(): matrix = [ [1] ] result = rotate_matrix_90_clockwise(matrix) expected = [ [1] ] assert result == expected def test_large_5x5_matrix(): matrix = [ [ 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] result = rotate_matrix_90_clockwise(matrix) expected = [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ] assert result == expected","solution":"from typing import List def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) # Create a new matrix of the same size rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - i - 1] = matrix[i][j] return rotated_matrix"},{"question":"def reverse_words(sentence: str) -> str: Reverses the words in the given sentence while maintaining the original spaces. Parameters: sentence (str): A string containing words separated by spaces. Returns: str: A string with the words in reverse order. Examples: >>> reverse_words(\\"Hello world\\") \\"world Hello\\" >>> reverse_words(\\"The quick brown fox\\") \\"fox brown quick The\\" >>> reverse_words(\\"A B C D\\") \\"D C B A\\"","solution":"def reverse_words(sentence: str) -> str: Reverses the words in the given sentence while maintaining the original spaces. Parameters: sentence (str): A string containing words separated by spaces. Returns: str: A string with the words in reverse order. words = sentence.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"from typing import List, Union def quickselect(arr: List[int], k: int) -> Union[int, None]: Find the \`k\`-th smallest element in an unsorted list of integers using the Quickselect algorithm. >>> quickselect([3, 2, 1, 5, 4], 1) 1 >>> quickselect([3, 2, 1, 5, 4], 3) 3 >>> quickselect([3, 2, 1, 5, 4], 5) 5 >>> quickselect([3, 2, 1, 5, 4], 6) None >>> quickselect([7, 10, 4, 3, 20, 15], 4) 10 import pytest def test_quickselect_basic(): assert quickselect([3, 2, 1, 5, 4], 1) == 1 assert quickselect([3, 2, 1, 5, 4], 3) == 3 assert quickselect([3, 2, 1, 5, 4], 5) == 5 assert quickselect([3, 2, 1, 5, 4], 6) == None def test_quickselect_more_cases(): assert quickselect([7, 10, 4, 3, 20, 15], 4) == 10 assert quickselect([1, 2, 3, 4, 5], 3) == 3 assert quickselect([10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 7) == 7 def test_quickselect_edge_cases(): assert quickselect([1], 1) == 1 assert quickselect([], 1) == None assert quickselect([2, 1], 2) == 2 assert quickselect([2, 1], 1) == 1 def test_quickselect_invalid_k(): assert quickselect([1, 2, 3], 0) == None assert quickselect([1, 2, 3], 4) == None pytest.main()","solution":"from typing import List, Union def partition(arr: List[int], low: int, high: int) -> int: pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quickselect_helper(arr: List[int], low: int, high: int, k: int) -> int: if low <= high: pivot_index = partition(arr, low, high) if pivot_index == k: return arr[pivot_index] elif pivot_index > k: return quickselect_helper(arr, low, pivot_index - 1, k) else: return quickselect_helper(arr, pivot_index + 1, high, k) def quickselect(arr: List[int], k: int) -> Union[int, None]: if not (1 <= k <= len(arr)): return None return quickselect_helper(arr, 0, len(arr) - 1, k - 1)"},{"question":"def most_frequent_char(s: str) -> str: Returns the character that appears most frequently in the string. If there are multiple characters with the same highest frequency, returns the one that appears first in the string. >>> most_frequent_char(\\"aabcc\\") 'a' >>> most_frequent_char(\\"aabbcc\\") 'a' >>> most_frequent_char(\\"!@#@!\\") '@' >>> most_frequent_char(\\"This is a test\\") ' ' >>> most_frequent_char(\\"ZZzzZz\\") 'Z'","solution":"def most_frequent_char(s: str) -> str: char_count = {} max_char = '' max_count = 0 for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 if char_count[char] > max_count: max_count = char_count[char] max_char = char return max_char"},{"question":"def is_power_of_two_bitwise(number: int) -> bool: Check if a given non-negative integer is a power of two using bitwise operations. >>> is_power_of_two_bitwise(1) True >>> is_power_of_two_bitwise(2) True >>> is_power_of_two_bitwise(3) False >>> is_power_of_two_bitwise(16) True >>> is_power_of_two_bitwise(18) False >>> is_power_of_two_bitwise(0) False pass def is_power_of_two_log(number: int) -> bool: Check if a given non-negative integer is a power of two using logarithms. >>> is_power_of_two_log(1) True >>> is_power_of_two_log(2) True >>> is_power_of_two_log(3) False >>> is_power_of_two_log(16) True >>> is_power_of_two_log(18) False >>> is_power_of_two_log(0) False pass # Test cases to validate the solution try: assert is_power_of_two_bitwise(1) == True assert is_power_of_two_bitwise(2) == True assert is_power_of_two_bitwise(3) == False assert is_power_of_two_bitwise(16) == True assert is_power_of_two_bitwise(18) == False assert is_power_of_two_bitwise(0) == False try: is_power_of_two_bitwise(-8) except ValueError: print(\\"ValueError caught as expected\\") except AssertionError: print(\\"Test case failed for is_power_of_two_bitwise\\") try: assert is_power_of_two_log(1) == True assert is_power_of_two_log(2) == True assert is_power_of_two_log(3) == False assert is_power_of_two_log(16) == True assert is_power_of_two_log(18) == False assert is_power_of_two_log(0) == False try: is_power_of_two_log(-8) except ValueError: print(\\"ValueError caught as expected\\") except AssertionError: print(\\"Test case failed for is_power_of_two_log\\")","solution":"import math def is_power_of_two_bitwise(number: int) -> bool: This function checks if a number is a power of two using bitwise operations. if number < 0: raise ValueError(\\"Number must be non-negative.\\") # A number is a power of two if and only if it has exactly one bit set in the binary representation. # For example, 4 (binary 100) is a power of two, but 5 (binary 101) is not. return number != 0 and (number & (number - 1)) == 0 def is_power_of_two_log(number: int) -> bool: This function checks if a number is a power of two using logarithms. if number < 0: raise ValueError(\\"Number must be non-negative.\\") if number == 0: return False # A number is a power of two if log2(number) is an integer. return math.log2(number).is_integer()"},{"question":"from typing import List def max_non_adjacent_subarray_sum(nums: List[int]) -> int: Find the maximum sum of any contiguous subarray with no two elements adjacent in the original array. >>> max_non_adjacent_subarray_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_subarray_sum([-5, -1, 2, 7, -3]) 7 >>> max_non_adjacent_subarray_sum([1, 2, 3, 4, 5]) 9 def test_max_non_adjacent_subarray_sum(): from solution import max_non_adjacent_subarray_sum def test_empty(): assert max_non_adjacent_subarray_sum([]) == 0 def test_single_element(): assert max_non_adjacent_subarray_sum([5]) == 5 assert max_non_adjacent_subarray_sum([-5]) == 0 def test_all_negative(): assert max_non_adjacent_subarray_sum([-1, -2, -3, -4, -5]) == 0 def test_mixed_elements(): assert max_non_adjacent_subarray_sum([3, 2, 5, 10, 7]) == 15 assert max_non_adjacent_subarray_sum([-5, -1, 2, 7, -3]) == 7 assert max_non_adjacent_subarray_sum([1, 2, 3, 4, 5]) == 9 test_empty() test_single_element() test_all_negative() test_mixed_elements()","solution":"def max_non_adjacent_subarray_sum(nums): if not nums: return 0 incl = 0 excl = 0 for num in nums: new_excl = max(excl, incl) incl = num + excl excl = new_excl return max(excl, incl)"},{"question":"import math def distance_between_points(x1: float, y1: float, y2: float) -> float: Calculates the Euclidean distance between two points on a 2D plane. Args: x1 (float): The x-coordinate of the first point. y1 (float): The y-coordinate of the first point. x2 (float): The x-coordinate of the second point. y2 (float): The y-coordinate of the second point. Returns: float: The straight-line distance between the two points. >>> distance_between_points(1, 1, 4, 5) 5.0 >>> distance_between_points(-1, -1, 2, 3) 5.0 >>> distance_between_points(0, 0, 0, 0) 0.0 def test_distance_between_points_basic(): result = distance_between_points(1, 1, 4, 5) assert result == 5.0 def test_distance_between_points_negative_coordinates(): result = distance_between_points(-1, -1, 2, 3) assert result == 5.0 def test_distance_between_points_zero_distance(): result = distance_between_points(0, 0, 0, 0) assert result == 0.0 def test_distance_between_points_mixed_coordinates(): result = distance_between_points(1.5, 2.5, 4.5, 6.5) assert result == 5.0 def test_distance_between_points_float_results(): result = distance_between_points(1.2, 3.4, 5.6, 7.8) expected = math.sqrt((5.6 - 1.2)**2 + (7.8 - 3.4)**2) assert result == expected def test_distance_between_points_invalid_input(): with pytest.raises(Exception) as e: distance_between_points(1, \\"a\\", 4, 5) assert str(e.value) == \\"All coordinates must be real numbers\\" with pytest.raises(Exception) as e: distance_between_points(1, 1, {}, []) assert str(e.value) == \\"All coordinates must be real numbers\\"","solution":"import math def distance_between_points(x1: float, y1: float, x2: float, y2: float) -> float: Calculates the Euclidean distance between two points on a 2D plane. Args: x1 (float): The x-coordinate of the first point. y1 (float): The y-coordinate of the first point. x2 (float): The x-coordinate of the second point. y2 (float): The y-coordinate of the second point. Returns: float: The straight-line distance between the two points. # Input validation if not all(isinstance(coord, (int, float)) for coord in [x1, y1, x2, y2]): raise Exception(\\"All coordinates must be real numbers\\") # Calculate the Euclidean distance return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def morris_inorder_traversal(root: TreeNode) -> list[int]: Perform inorder traversal of a binary tree using Morris Traversal algorithm. The traversal should not use additional stack or recursion. >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.left = TreeNode(3) >>> morris_inorder_traversal(root) [1, 3, 2] >>> empty_tree = None >>> morris_inorder_traversal(empty_tree) []","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def morris_inorder_traversal(root: TreeNode) -> list[int]: result = [] current = root while current: if current.left is None: result.append(current.value) current = current.right else: # Finding the inorder predecessor of current predecessor = current.left while predecessor.right and predecessor.right is not current: predecessor = predecessor.right if predecessor.right is None: # Make current as the right child of its inorder predecessor predecessor.right = current current = current.left else: # Revert the changes made predecessor.right = None result.append(current.value) current = current.right return result"},{"question":"import heapq from typing import List def kth_smallest(matrix: List[List[int]], K: int) -> int: Returns the Kth smallest integer in a sorted matrix. :param matrix: List[List[int]], a 2D list representing a sorted matrix of integers. :param K: int, the position (1-indexed) of the smallest integer to find. :return: int, the Kth smallest integer in the sorted matrix. Constraints: 1 <= len(matrix) <= 100 1 <= len(matrix[0]) <= 100 -10^9 <= matrix[i][j] <= 10^9 All the rows and columns of the matrix are sorted in ascending order. Example: >>> matrix = [ ... [1, 5, 9], ... [10, 11, 13], ... [12, 13, 15] ... ] >>> kth_smallest(matrix, 8) 13 >>> kth_smallest(matrix, 1) 1 >>> kth_smallest(matrix, 6) 12 def test_example(): matrix = [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ] assert kth_smallest(matrix, 8) == 13 assert kth_smallest(matrix, 1) == 1 assert kth_smallest(matrix, 6) == 12 def test_single_element(): matrix = [[-10**9]] assert kth_smallest(matrix, 1) == -10**9 def test_all_elements_same(): matrix = [ [5, 5, 5], [5, 5, 5], [5, 5, 5] ] assert kth_smallest(matrix, 5) == 5 def test_small_k(): matrix = [ [1, 3, 5], [6, 7, 12], [11, 14, 14] ] assert kth_smallest(matrix, 1) == 1 def test_large_k(): matrix = [ [1, 3, 5], [6, 7, 12], [11, 14, 14] ] assert kth_smallest(matrix, 9) == 14 def test_matrix_size_more_than_k(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert kth_smallest(matrix, 5) == 5 def test_large_values(): matrix = [ [-5, -4, -3], [1, 2, 1000000000], [999, 1000, 1001] ] assert kth_smallest(matrix, 5) == 2","solution":"import heapq from typing import List def kth_smallest(matrix: List[List[int]], K: int) -> int: Returns the Kth smallest integer in a sorted matrix. # Using a min-heap to keep track of the smallest elements min_heap = [] n = len(matrix) # Initialize the min-heap with the first element of each row for r in range(min(n, K)): # No need to push more than K rows as K <= total elements heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract the smallest element from the heap K times for _ in range(K - 1): val, r, c = heapq.heappop(min_heap) if c + 1 < len(matrix[0]): heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return heapq.heappop(min_heap)[0]"},{"question":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, value): new_node = Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def __str__(self): values = [] current = self.head while current: values.append(current.value) current = current.next return ' -> '.join(map(str, values)) def merge_sorted_lists(list1, list2): Merge two sorted linked lists into a single sorted linked list. Parameters: list1 (Node): Head node of the first sorted linked list. list2 (Node): Head node of the second sorted linked list. Returns: Node: Head node of the merged sorted linked list. # Implement your code here # Example Usage if __name__ == \\"__main__\\": # Create the first sorted linked list ll1 = LinkedList() ll1.insert(1) ll1.insert(3) ll1.insert(5) # Create the second sorted linked list ll2 = LinkedList() ll2.insert(2) ll2.insert(4) ll2.insert(6) # Merge the two sorted linked lists merged_head = merge_sorted_lists(ll1.head, ll2.head) # Create a linked list from the merged head merged_list = LinkedList() merged_list.head = merged_head print(merged_list) # Output: \\"1 -> 2 -> 3 -> 4 -> 5 -> 6\\"","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, value): new_node = Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def __str__(self): values = [] current = self.head while current: values.append(current.value) current = current.next return ' -> '.join(map(str, values)) def merge_sorted_lists(list1, list2): dummy = Node(0) # Dummy node to serve as the start of the merged list tail = dummy # Tail of the merged list while list1 and list2: if list1.value < list2.value: tail.next = list1 list1 = list1.next else: tail.next = list2 list2 = list2.next tail = tail.next # At this point, at least one of the lists is exhausted if list1: tail.next = list1 elif list2: tail.next = list2 return dummy.next"},{"question":"import re from collections import Counter from typing import Tuple, Optional def most_frequent_word_in_file(file_path: str) -> Optional[Tuple[str, int]]: Finds the most frequent word in a given text file. :param file_path: Path to the text file :return: Tuple containing the most frequent word and its frequency count Return None if the file is empty or contains no valid words >>> create_temp_file(\\"Hello, world! Hello world.\\") == (\\"hello\\", 2) >>> create_temp_file(\\"\\") == None >>> create_temp_file(\\"Hello\\") == (\\"hello\\", 1) >>> create_temp_file(\\"Hello world hello World.\\") == (\\"hello\\", 2) >>> create_temp_file(\\"Hello! World, Hello... World?\\") == (\\"hello\\", 2) >>> create_temp_file(\\"123 hello 123 World 123\\") == (\\"123\\", 3)","solution":"import re from collections import Counter from typing import Tuple, Optional def most_frequent_word_in_file(file_path: str) -> Optional[Tuple[str, int]]: Finds the most frequent word in a given text file. :param file_path: Path to the text file :return: Tuple containing the most frequent word and its frequency count Return None if the file is empty or contains no valid words with open(file_path, 'r') as file: text = file.read().lower() # Extract words ignoring punctuation words = re.findall(r'bw+b', text) if not words: return None # Count word frequencies using Counter word_counts = Counter(words) # Find the word with the highest frequency most_common_word, freq = word_counts.most_common(1)[0] return (most_common_word, freq)"},{"question":"def smallest_window(s: str, t: str) -> str: Find the smallest substring of 's' that contains all the characters in 't'. >>> smallest_window(\\"this is a test string\\", \\"tist\\") \\"t stri\\" >>> smallest_window(\\"geeksforgeeks\\", \\"ork\\") \\"ksfor\\" >>> smallest_window(\\"a\\", \\"a\\") \\"a\\" >>> smallest_window(\\"hello\\", \\"world\\") \\"\\" >>> smallest_window(\\"abcdefgh\\", \\"hgf\\") \\"fgh\\" >>> smallest_window(\\"aaabbbccc\\", \\"abc\\") \\"abbbc\\" >>> smallest_window(\\"adobecodebanc\\", \\"abc\\") \\"banc\\" >>> smallest_window(\\"a\\" * 10000 + \\"b\\" + \\"a\\" * 10000, \\"ab\\") \\"ab\\"","solution":"def smallest_window(s: str, t: str) -> str: from collections import defaultdict if not s or not t: return \\"\\" required_chars = set(t) char_count_t = defaultdict(int) for char in t: char_count_t[char] += 1 start = 0 min_len = float('inf') min_start = 0 found_chars = defaultdict(int) found_count = 0 for end in range(len(s)): end_char = s[end] if end_char in required_chars: found_chars[end_char] += 1 if found_chars[end_char] <= char_count_t[end_char]: found_count += 1 while found_count == len(t): window_len = end - start + 1 if window_len < min_len: min_len = window_len min_start = start start_char = s[start] if start_char in required_chars: found_chars[start_char] -= 1 if found_chars[start_char] < char_count_t[start_char]: found_count -= 1 start += 1 return \\"\\" if min_len == float('inf') else s[min_start:min_start + min_len]"},{"question":"def LongestSubstringWithKDistinct(s: str, k: int) -> tuple: Find the longest substring of a given string that contains no more than \`k\` distinct characters. Args: s (str): the input string k (int): the number of distinct characters allowed in the substring Returns: tuple: a tuple containing the longest substring and its length Examples: >>> LongestSubstringWithKDistinct(\\"eceba\\", 2) (\\"ece\\", 3) >>> LongestSubstringWithKDistinct(\\"aa\\", 1) (\\"aa\\", 2)","solution":"def LongestSubstringWithKDistinct(s: str, k: int) -> tuple: if k == 0: return (\\"\\", 0) n = len(s) left = 0 right = 0 max_length = 0 start = 0 char_map = {} while right < n: # add right character to char_map or update its count if s[right] in char_map: char_map[s[right]] += 1 else: char_map[s[right]] = 1 # shrink the window from the left if the distinct character count exceeds k while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 # update the maximum length and starting index of the substring if right - left + 1 > max_length: max_length = right - left + 1 start = left right += 1 return (s[start:start + max_length], max_length)"},{"question":"from typing import List def find_peak_prices(prices: List[int]) -> List[int]: Find the peak home prices in a neighborhood. A \\"peak\\" is defined as a price which is greater than the prices immediately before and after it, except for the first and last houses, which only need to be greater than the single neighboring house. >>> find_peak_prices([300, 450, 600, 480, 700, 650, 800]) [600, 700, 800] >>> find_peak_prices([100, 200, 300]) [300] >>> find_peak_prices([900, 800, 1000, 700]) [900, 1000] def test_peak_prices_single_element(): assert find_peak_prices([300]) == [300] def test_peak_prices_two_elements_increasing(): assert find_peak_prices([100, 200]) == [200] def test_peak_prices_two_elements_decreasing(): assert find_peak_prices([200, 100]) == [200] def test_peak_prices_no_peak(): assert find_peak_prices([100, 100, 100]) == [] def test_peak_prices_with_peaks(): assert find_peak_prices([300, 450, 600, 480, 700, 650, 800]) == [600, 700, 800] def test_peak_prices_with_single_peak_at_end(): assert find_peak_prices([100, 200, 300]) == [300] def test_peak_prices_with_peaks_at_both_ends(): assert find_peak_prices([900, 800, 1000, 700]) == [900, 1000] def test_peak_prices_multiple_peaks(): assert find_peak_prices([500, 1000, 200, 800, 400, 600, 300]) == [1000, 800, 600]","solution":"from typing import List def find_peak_prices(prices: List[int]) -> List[int]: if len(prices) == 1: return prices peaks = [] for i in range(len(prices)): # For the first element, check only the next element if i == 0 and prices[i] > prices[i + 1]: peaks.append(prices[i]) # For the last element, check only the previous element elif i == len(prices) - 1 and prices[i] > prices[i - 1]: peaks.append(prices[i]) # For all other elements, check both previous and next elements elif 0 < i < len(prices) - 1 and prices[i] > prices[i - 1] and prices[i] > prices[i + 1]: peaks.append(prices[i]) return peaks"},{"question":"def sum_of_fifth_powers() -> int: Determine the sum of all the numbers that can be written as the sum of the fifth powers of their digits. >>> sum_of_fifth_powers() 443839 from solution import sum_of_fifth_powers def test_sum_of_fifth_powers(): assert sum_of_fifth_powers() == 443839","solution":"def sum_of_fifth_powers() -> int: def fifth_power_sum(n): return sum(int(digit) ** 5 for digit in str(n)) # Since n-digit number's upper bound is 9^5 * n, let's find a reasonable limit. limit = 9 ** 5 * 6 # Covering up to six-digit numbers should be safe. result = [] for num in range(2, limit): if num == fifth_power_sum(num): result.append(num) return sum(result)"},{"question":"from typing import List def largest_submatrix(matrix: List[List[int]]) -> int: Given a binary matrix, find the largest submatrix with all 1s. >>> largest_submatrix([ ... [0, 1, 1, 0, 1], ... [1, 1, 0, 1, 0], ... [0, 1, 1, 1, 0], ... [1, 1, 1, 1, 0] ... ]) == 6 >>> largest_submatrix([ ... [1, 0, 1, 1, 1], ... [0, 1, 1, 1, 1], ... [0, 1, 1, 1, 1], ... [1, 1, 1, 1, 0] ... ]) == 9 >>> largest_submatrix([]) == 0 >>> largest_submatrix([[1]]) == 1 >>> largest_submatrix([[0]]) == 0 >>> largest_submatrix([ ... [1, 1], ... [1, 1] ... ]) == 4","solution":"from typing import List def largest_submatrix(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) # Create a dp array to store heights of histograms dp = [[0] * cols for _ in range(rows)] # Fill the dp array for i in range(rows): for j in range(cols): if matrix[i][j] == 1: dp[i][j] = dp[i-1][j] + 1 if i > 0 else 1 # Function to calculate maximum rectangle in histogram def max_histogram_area(heights: List[int]) -> int: stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area max_area = 0 # Calculate the maximum area rectangle in each histogram row for row in dp: max_area = max(max_area, max_histogram_area(row)) return max_area"},{"question":"[Completion Task in Python] def run_length_encoding(text: str) -> str: Implement the run-length encoding (RLE) of a string. RLE replaces consecutive identical characters (runs) with the number of occurrences followed by the character. Parameters: text (str): A string consisting of only uppercase and lowercase alphabets. Returns: str: A string representing the run-length encoded version of the input. Example: >>> run_length_encoding(\\"AABBBCCDAA\\") 'A2B3C2D1A2' >>> run_length_encoding(\\"A\\") 'A1' >>> run_length_encoding(\\"ABCDEFG\\") 'A1B1C1D1E1F1G1' >>> run_length_encoding(\\"AAAAAA\\") 'A6' >>> run_length_encoding(\\"AABCCCCCCDAA\\") 'A2B1C6D1A2' >>> run_length_encoding(\\"\\") '' >>> run_length_encoding(\\"AAABBAACCC\\") 'A3B2A2C3' if not text: return \\"\\" encoded = [] count = 1 prev_char = text[0] for char in text[1:]: if char == prev_char: count += 1 else: encoded.append(f\\"{prev_char}{count}\\") prev_char = char count = 1 encoded.append(f\\"{prev_char}{count}\\") return ''.join(encoded)","solution":"def run_length_encoding(text: str) -> str: if not text: return \\"\\" encoded = [] count = 1 prev_char = text[0] for char in text[1:]: if char == prev_char: count += 1 else: encoded.append(f\\"{prev_char}{count}\\") prev_char = char count = 1 encoded.append(f\\"{prev_char}{count}\\") return ''.join(encoded)"},{"question":"def is_balanced(labels: list) -> bool: Function that checks if the dataset is balanced. A dataset is considered balanced if it contains an equal number of positive (1) and negative (-1) labels. Parameters: labels (list): A list of integers where each integer is either 1 or -1. Returns: bool: True if the dataset is balanced, False otherwise. >>> is_balanced([1, -1, 1, -1]) True >>> is_balanced([1, -1, 1]) False >>> is_balanced([]) True >>> is_balanced([-1, -1, 1, 1, 1, -1]) True >>> is_balanced([1, 1, 1, 1]) False","solution":"def is_balanced(labels: list) -> bool: Function that checks if the dataset is balanced. A dataset is considered balanced if it contains an equal number of positive (1) and negative (-1) labels. Parameters: labels (list): A list of integers where each integer is either 1 or -1. Returns: bool: True if the dataset is balanced, False otherwise. >>> is_balanced([1, -1, 1, -1]) True >>> is_balanced([1, -1, 1]) False >>> is_balanced([]) True >>> is_balanced([-1, -1, 1, 1, 1, -1]) True >>> is_balanced([1, 1, 1, 1]) False positive_count = labels.count(1) negative_count = labels.count(-1) return positive_count == negative_count"},{"question":"def longest_repeating_substring(input_string: str) -> int: Finds the length of the longest substring where all characters are the same. >>> longest_repeating_substring(\\"aaabb\\") 3 >>> longest_repeating_substring(\\"abbbbbcc\\") 5 >>> longest_repeating_substring(\\"abc\\") 1 >>> longest_repeating_substring(\\"\\") 0 >>> longest_repeating_substring(\\"a\\") 1","solution":"def longest_repeating_substring(input_string): Finds the length of the longest substring where all characters are the same. if not input_string: return 0 max_length = 1 current_length = 1 n = len(input_string) for i in range(1, n): if input_string[i] == input_string[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"def multiply_elements_by_indices(matrix: List[List[int]]) -> List[List[int]]: Multiplies each element in the matrix by its row and column indices. Args: matrix (List[List[int]]): A list of lists representing the integer matrix. Returns: List[List[int]]: A 2D list where each element is multiplied by its row and column indices. Example: >>> multiply_elements_by_indices([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [0, 0, 0], [0, 5, 12], [0, 16, 36] ] >>> multiply_elements_by_indices([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) [ [0, 0, 0], [0, -5, -12], [0, -16, -36] ]","solution":"from typing import List def multiply_elements_by_indices(matrix: List[List[int]]) -> List[List[int]]: Multiplies each element in the matrix by its row and column indices. Parameters: matrix (List[List[int]]): A list of lists representing the integer matrix. Returns: List[List[int]]: A 2D list where each element is multiplied by its row and column indices. result_matrix = [] for i, row in enumerate(matrix): result_row = [] for j, value in enumerate(row): result_row.append(value * i * j) result_matrix.append(result_row) return result_matrix"},{"question":"from typing import List def find_kth_smallest(arr1: List[int], arr2: List[int], k: int) -> int: Find the k-th smallest element in the merged sorted array without merging the arrays. Args: arr1 (List[int]): First sorted list of integers. arr2 (List[int]): Second sorted list of integers. k (int): Positive integer representing the position (1-indexed) of the element we want to find in the merged sorted array. Returns: int: The k-th smallest element in the merged sorted array. Examples: >>> find_kth_smallest([1, 3, 5], [2, 4, 6], 4) 4 >>> find_kth_smallest([1, 2, 3, 4, 5], [6, 7, 8, 9, 10], 7) 7 >>> find_kth_smallest([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) 6 >>> find_kth_smallest([1, 5, 9], [2, 3, 4, 6, 7, 8, 10], 1) 1 >>> find_kth_smallest([], [1, 2, 3, 4, 5], 3) 3 >>> find_kth_smallest([1], [2], 1) 1 >>> find_kth_smallest([1], [2], 2) 2 >>> find_kth_smallest([1, 2, 3], [4, 5, 6, 7, 8], 5) 5 >>> find_kth_smallest([1, 3, 5, 7], [2, 4, 6, 8], 6) 6 pass","solution":"from typing import List def find_kth_smallest(arr1: List[int], arr2: List[int], k: int) -> int: def kth_smallest_in_merged(arr1, arr2, k): len1, len2 = len(arr1), len(arr2) low, high = max(0, k - len2), min(k, len1) while low < high: mid1 = (low + high) // 2 mid2 = k - mid1 if mid2 > len2 or (mid1 < len1 and arr1[mid1] < arr2[mid2 - 1]): low = mid1 + 1 else: high = mid1 mid1 = low mid2 = k - low if mid1 == 0: return arr2[mid2 - 1] if mid2 == 0: return arr1[mid1 - 1] return max(arr1[mid1 - 1], arr2[mid2 - 1]) return kth_smallest_in_merged(arr1, arr2, k)"},{"question":"def string_operations(operation: str, data: list[str] | str, params: dict = {}) -> list[str] | str | int | bool: Perform various string operations based on the specified operation. Args: - operation: a string specifying the operation (\\"concat\\", \\"split\\", \\"find\\", \\"count\\", \\"replace\\", \\"length\\", \\"palindrome\\"). - data: a list of strings for concatenation or a single string for other operations. - params: optional dictionary containing additional parameters required for the operation. Returns: - Depending on the operation: a single string, list of strings, integer, or boolean. >>> string_operations(\\"concat\\", [\\"hello\\", \\" \\", \\"world\\"]) \\"hello world\\" >>> string_operations(\\"split\\", \\"hello world today\\", {\\"delimiter\\": \\" \\"}) [\\"hello\\", \\"world\\", \\"today\\"] >>> string_operations(\\"find\\", \\"hello world\\", {\\"substring\\": \\"world\\"}) 6 >>> string_operations(\\"count\\", \\"hello world\\", {\\"substring\\": \\"l\\"}) 3 >>> string_operations(\\"replace\\", \\"hello world\\", {\\"substring\\": \\"world\\", \\"new_string\\": \\"there\\"}) \\"hello there\\" >>> string_operations(\\"length\\", \\"hello world\\") 11 >>> string_operations(\\"palindrome\\", \\"A Santa at NASA\\") True pass import pytest def test_concat(): assert string_operations(\\"concat\\", [\\"hello\\", \\" \\", \\"world\\"]) == \\"hello world\\" assert string_operations(\\"concat\\", [\\"foo\\", \\"bar\\"]) == \\"foobar\\" assert string_operations(\\"concat\\", [\\"\\"]) == \\"\\" assert string_operations(\\"concat\\", []) == \\"\\" def test_split(): assert string_operations(\\"split\\", \\"hello world today\\", {\\"delimiter\\": \\" \\"}) == [\\"hello\\", \\"world\\", \\"today\\"] assert string_operations(\\"split\\", \\"a,b,c\\", {\\"delimiter\\": \\",\\"}) == [\\"a\\", \\"b\\", \\"c\\"] assert string_operations(\\"split\\", \\"hello\\", {\\"delimiter\\": \\",\\"}) == [\\"hello\\"] def test_find(): assert string_operations(\\"find\\", \\"hello world\\", {\\"substring\\": \\"world\\"}) == 6 assert string_operations(\\"find\\", \\"hello world\\", {\\"substring\\": \\"hello\\"}) == 0 assert string_operations(\\"find\\", \\"hello world\\", {\\"substring\\": \\"test\\"}) == -1 def test_count(): assert string_operations(\\"count\\", \\"hello world\\", {\\"substring\\": \\"l\\"}) == 3 assert string_operations(\\"count\\", \\"hello hello\\", {\\"substring\\": \\"hello\\"}) == 2 assert string_operations(\\"count\\", \\"hello\\", {\\"substring\\": \\"test\\"}) == 0 def test_replace(): assert string_operations(\\"replace\\", \\"hello world\\", {\\"substring\\": \\"world\\", \\"new_string\\": \\"there\\"}) == \\"hello there\\" assert string_operations(\\"replace\\", \\"foobarfoo\\", {\\"substring\\": \\"foo\\", \\"new_string\\": \\"bar\\"}) == \\"barbarbar\\" assert string_operations(\\"replace\\", \\"hello\\", {\\"substring\\": \\"test\\", \\"new_string\\": \\"pass\\"}) == \\"hello\\" def test_length(): assert string_operations(\\"length\\", \\"hello world\\") == 11 assert string_operations(\\"length\\", \\"\\") == 0 assert string_operations(\\"length\\", \\"12345\\") == 5 def test_palindrome(): assert string_operations(\\"palindrome\\", \\"A Santa at NASA\\") == True assert string_operations(\\"palindrome\\", \\"hello\\") == False assert string_operations(\\"palindrome\\", \\"racecar\\") == True assert string_operations(\\"palindrome\\", \\"\\") == True def test_invalid_operation(): with pytest.raises(ValueError): string_operations(\\"invalid\\", \\"test\\") def test_invalid_data_type(): with pytest.raises(ValueError): string_operations(\\"concat\\", \\"not a list\\") string_operations(\\"split\\", [\\"not a string\\"]) string_operations(\\"find\\", [\\"not a string\\"])","solution":"def string_operations(operation: str, data: list[str] | str, params: dict = {}) -> list[str] | str | int | bool: Perform various string operations based on the specified operation. Args: - operation: a string specifying the operation (\\"concat\\", \\"split\\", \\"find\\", \\"count\\", \\"replace\\", \\"length\\", \\"palindrome\\"). - data: a list of strings for concatenation or a single string for other operations. - params: optional dictionary containing additional parameters required for the operation. Returns: - Depending on the operation: a single string, list of strings, integer, or boolean. if operation == \\"concat\\" and isinstance(data, list): return ''.join(data) elif operation == \\"split\\" and isinstance(data, str): delimiter = params.get('delimiter', ' ') return data.split(delimiter) elif operation == \\"find\\" and isinstance(data, str): substring = params.get('substring', '') return data.find(substring) elif operation == \\"count\\" and isinstance(data, str): substring = params.get('substring', '') return data.count(substring) elif operation == \\"replace\\" and isinstance(data, str): substring = params.get('substring', '') new_string = params.get('new_string', '') return data.replace(substring, new_string) elif operation == \\"length\\" and isinstance(data, str): return len(data) elif operation == \\"palindrome\\" and isinstance(data, str): filtered_data = ''.join(filter(str.isalnum, data)).lower() return filtered_data == filtered_data[::-1] else: raise ValueError(\\"Invalid operation or data type\\")"},{"question":"from typing import List def trap_rainwater(heights: List[int]) -> int: Calculate how much water can be trapped between the buildings represented by heights in an array after it rains. Args: heights (List[int]): A list of integers where each integer represents the height of a building. Returns: int: The total amount of trapped rainwater. >>> trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rainwater([4, 2, 0, 3, 2, 5]) 9 pass # implementation goes here def test_trap_rainwater_example(): assert trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 def test_trap_rainwater_additional_example(): assert trap_rainwater([4, 2, 0, 3, 2, 5]) == 9 def test_trap_rainwater_no_trapped_water(): assert trap_rainwater([1, 1, 1, 1, 1]) == 0 assert trap_rainwater([]) == 0 def test_trap_rainwater_single_building(): assert trap_rainwater([0]) == 0 assert trap_rainwater([1]) == 0 def test_trap_rainwater_increasing_heights(): assert trap_rainwater([1, 2, 3, 4, 5]) == 0 def test_trap_rainwater_decreasing_heights(): assert trap_rainwater([5, 4, 3, 2, 1]) == 0 def test_trap_rainwater_peak_in_middle(): assert trap_rainwater([3, 0, 2, 0, 4]) == 7 def test_trap_rainwater_valley_in_middle(): assert trap_rainwater([2, 0, 2]) == 2","solution":"from typing import List def trap_rainwater(heights: List[int]) -> int: if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] total_water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) total_water += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) total_water += max(0, right_max - heights[right]) return total_water"},{"question":"def find_total_rain_water(heights: List[int]) -> int: Calculate the total amount of rainwater that could be trapped between the buildings after raining. >>> find_total_rain_water([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 >>> find_total_rain_water([4,2,0,3,2,5]) == 9 pass # Unit Test def test_find_total_rain_water(): assert find_total_rain_water([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 assert find_total_rain_water([4,2,0,3,2,5]) == 9 assert find_total_rain_water([1,1,1,1,1]) == 0 assert find_total_rain_water([5,4,3,2,1]) == 0 assert find_total_rain_water([1,2,3,4,5]) == 0 assert find_total_rain_water([2,0,2]) == 2 assert find_total_rain_water([3, 0, 2, 0, 4]) == 7 assert find_total_rain_water([]) == 0 assert find_total_rain_water([3]) == 0 assert find_total_rain_water([3, 4]) == 0 if __name__ == \\"__main__\\": test_find_total_rain_water() print(\\"All tests passed.\\")","solution":"from typing import List def find_total_rain_water(heights: List[int]) -> int: if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water"},{"question":"from typing import Callable def integrate_trapezoidal(func: Callable[[float], float], a: float, b: float, n: int) -> float: Perform numerical integration using the Trapezoidal Rule. Args: func (Callable[[float], float]): A function to integrate, which takes a single float and returns a float. a (float): The start of the interval of integration. b (float): The end of the interval of integration. n (int): The number of sub-intervals to use (must be a positive integer). Returns: float: The approximate value of the integral over [a, b] using the trapezoidal rule. Raises: ValueError: If n is not a positive integer or if a is not less than b. Examples: >>> from math import sin, pi >>> result = integrate_trapezoidal(sin, 0, pi, 1000) >>> abs(result - 2) < 1e-3 True >>> from math import exp >>> result = integrate_trapezoidal(exp, 0, 1, 1000) >>> abs(result - (exp(1) - 1)) < 1e-3 True","solution":"from typing import Callable def integrate_trapezoidal(func: Callable[[float], float], a: float, b: float, n: int) -> float: if n <= 0: raise ValueError(\\"Number of intervals n must be a positive integer.\\") if a >= b: raise ValueError(\\"The start of the interval a must be less than the end b.\\") h = (b - a) / n integral = 0.5 * (func(a) + func(b)) for i in range(1, n): integral += func(a + i * h) integral *= h return integral"},{"question":"from typing import List def longest_activity_streak(days: List[int]) -> int: Calculate the length of the longest streak of consecutive active days. >>> longest_activity_streak([1, 2, 3, 5, 6, 8, 9, 10]) 3 >>> longest_activity_streak([7, 1, 2, 3, 7, 8, 9, 10]) 4 >>> longest_activity_streak([5, 9, 1, 11, 12, 13]) 3 >>> longest_activity_streak([4, 2, 0, 5, 6, 7, 1]) 4 >>> longest_activity_streak([]) 0 >>> longest_activity_streak([5]) 1 >>> longest_activity_streak([100, 4, 200, 1, 3, 2]) 4 >>> longest_activity_streak([0, 0, 0, 0]) 1 >>> longest_activity_streak([1, 1, 1, 2, 2, 2, 3, 3, 3]) 3 >>> longest_activity_streak([5, 4, 3, 2, 1]) 5 >>> longest_activity_streak([1, 4, 5, 6, 8, 9, 11, 12, 15]) 3 >>> longest_activity_streak([13, 14, 15, 16, 11, 12, 10, 11]) 7","solution":"from typing import List def longest_activity_streak(days: List[int]) -> int: if not days: return 0 days_set = set(days) longest_streak = 0 for day in days_set: if day - 1 not in days_set: # only start counting from the beginning of a streak current_day = day current_streak = 1 while current_day + 1 in days_set: current_day += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"from typing import List def construct_array(arr: List[int]) -> List[int]: Returns a new array where each element at index \`i\` is the product of all elements in the original array except the one at \`i\`. Example: >>> construct_array([1, 2, 3, 4]) [24, 12, 8, 6] >>> construct_array([0, 1, 2, 3]) [6, 0, 0, 0] def test_construct_array(): assert construct_array([1, 2, 3, 4]) == [24, 12, 8, 6] assert construct_array([0, 1, 2, 3]) == [6, 0, 0, 0] assert construct_array([2, 3, 0, 4]) == [0, 0, 24, 0] assert construct_array([1, 2, 3, 0, 4, 5]) == [0, 0, 0, 120, 0, 0] assert construct_array([1, 1, 1, 1, 1]) == [1, 1, 1, 1, 1] assert construct_array([-1, 2, -3, 4]) == [-24, 12, -8, 6] assert construct_array([10, 0, 0, 30]) == [0, 0, 0, 0] assert construct_array([-1, -1, -1, -1, -1]) == [1, 1, 1, 1, 1] assert construct_array([7, 3]) == [3, 7] assert construct_array([8, 1, 2, 1, 2, 7]) == [28, 224, 112, 224, 112, 32] if __name__ == \\"__main__\\": test_construct_array()","solution":"def construct_array(arr): Returns a new array where each element at index \`i\` is the product of all elements in the original array except the one at \`i\`. n = len(arr) # Initialize the result array with ones result = [1] * n # Compute the prefix products prefix_product = 1 for i in range(n): result[i] = prefix_product prefix_product *= arr[i] # Compute the suffix products and combine with prefix products suffix_product = 1 for i in range(n-1, -1, -1): result[i] *= suffix_product suffix_product *= arr[i] return result"},{"question":"def sort_and_filter_books( books: list, genre: str | None = None, year_range: tuple[int, int] | None = None, sort_by: str | None = None, ascending: bool = True ) -> list | str: Filter and sort a list of books based on specified criteria. Parameters: - books (list): A list of dictionaries, where each dictionary represents a book. - genre (str): The genre to filter the books by. Optional. - year_range (tuple): A tuple of two integers representing the start and end years for filtering books based on their publication year. Optional. - sort_by (str): The attribute to sort the books by. It can be 'title', 'author', or 'publication_year'. Optional. - ascending (bool): The sorting order. True for ascending, False for descending. Default is True. Returns: - list | str: Either a sorted list of filtered books or a string message indicating no books matched the criteria.","solution":"def sort_and_filter_books( books, genre=None, year_range=None, sort_by=None, ascending=True ): Filter and sort a list of books based on specified criteria. Parameters: - books (list): A list of dictionaries, where each dictionary represents a book. - genre (str): The genre to filter the books by. Optional. - year_range (tuple): A tuple of two integers representing the start and end years for filtering books based on their publication year. Optional. - sort_by (str): The attribute to sort the books by. It can be 'title', 'author', or 'publication_year'. Optional. - ascending (bool): The sorting order. True for ascending, False for descending. Default is True. Returns: - list | str: Either a sorted list of filtered books or a string message indicating no books matched the criteria. # Filter books based on the given genre if genre: books = [book for book in books if book.get(\\"genre\\") == genre] # Filter books based on the given year range if year_range: start_year, end_year = year_range books = [ book for book in books if start_year <= book.get(\\"publication_year\\") <= end_year ] # If no books are left after filtering if not books: return \\"No books matched the criteria.\\" # Sort books based on the given attribute, if any if sort_by in [\\"title\\", \\"author\\", \\"publication_year\\"]: books = sorted(books, key=lambda x: x.get(sort_by), reverse=not ascending) return books"},{"question":"def organize_songs(song_list, sort_by, order): Organize a list of songs based on specified attribute and order. Args: song_list (list of dict): List of songs with attributes. sort_by (str): Attribute to sort by ('title', 'artist', 'duration', 'year'). order (str): Sorting order ('asc' or 'desc'). Returns: list of dict: Sorted list of songs. Example: >>> song_list = [ ... {'title': 'Song A', 'artist': 'Artist 1', 'duration': 200, 'year': 2021}, ... {'title': 'Song B', 'artist': 'Artist 2', 'duration': 180, 'year': 2020}, ... {'title': 'Song C', 'artist': 'Artist 1', 'duration': 240, 'year': 2021} ... ] >>> organize_songs(song_list, 'duration', 'asc') [{'title': 'Song B', 'artist': 'Artist 2', 'duration': 180, 'year': 2020}, {'title': 'Song A', 'artist': 'Artist 1', 'duration': 200, 'year': 2021}, {'title': 'Song C', 'artist': 'Artist 1', 'duration': 240, 'year': 2021}]","solution":"def organize_songs(song_list, sort_by, order): Organize a list of songs based on specified attribute and order. Args: song_list (list of dict): List of songs with attributes. sort_by (str): Attribute to sort by ('title', 'artist', 'duration', 'year'). order (str): Sorting order ('asc' or 'desc'). Returns: list of dict: Sorted list of songs. # Toggle between ascending and descending reverse = order == 'desc' # Sort the song list by the specified attribute sorted_songs = sorted(song_list, key=lambda song: song[sort_by], reverse=reverse) return sorted_songs"},{"question":"class LibrarySystem: Library Management System to handle book operations. Supports operations: add_book, borrow_book, return_book, is_available. Example: >>> library = LibrarySystem() >>> library.add_book(1) >>> library.add_book(2) >>> print(library.is_available(1)) # True >>> library.borrow_book(1) >>> print(library.is_available(1)) # False >>> library.return_book(1) >>> print(library.is_available(1)) # True def __init__(self): Initializes the Library System. def add_book(self, book_id): Adds a new book to the collection. def borrow_book(self, book_id): Borrows a book from the library if it is available. def return_book(self, book_id): Returns a borrowed book back to the library. def is_available(self, book_id): Checks if a book is available to borrow. return book_id in self.books def test_library_system(): library = LibrarySystem() library.add_book(1) library.add_book(2) assert library.is_available(1) == True assert library.is_available(2) == True assert library.is_available(3) == False library.borrow_book(1) assert library.is_available(1) == False library.return_book(1) assert library.is_available(1) == True library.borrow_book(3) assert library.is_available(3) == False library.add_book(3) assert library.is_available(3) == True library.borrow_book(2) assert library.is_available(2) == False library.return_book(2) assert library.is_available(2) == True","solution":"class LibrarySystem: def __init__(self): Initializes the Library System. self.books = set() self.borrowed_books = set() def add_book(self, book_id): Adds a new book to the collection. self.books.add(book_id) self.borrowed_books.discard(book_id) def borrow_book(self, book_id): Borrows a book from the library if it is available. if book_id in self.books: self.books.remove(book_id) self.borrowed_books.add(book_id) def return_book(self, book_id): Returns a borrowed book back to the library. if book_id in self.borrowed_books: self.borrowed_books.remove(book_id) self.books.add(book_id) def is_available(self, book_id): Checks if a book is available to borrow. return book_id in self.books"},{"question":"def prime_numbers_summary(n: int) -> str: Create a summary of all prime numbers up to and including \`n\`. >>> prime_numbers_summary(10) \\"Prime count: 4, Sum: 17, Average: 4.25\\" >>> prime_numbers_summary(20) \\"Prime count: 8, Sum: 77, Average: 9.62\\" >>> prime_numbers_summary(5) \\"Prime count: 3, Sum: 10, Average: 3.33\\" >>> prime_numbers_summary(2) \\"Prime count: 1, Sum: 2, Average: 2.00\\"","solution":"import math def prime_numbers_summary(n: int) -> str: def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False # 0 and 1 are not primes for i in range(2, int(math.sqrt(limit)) + 1): if is_prime[i]: for j in range(i * i, limit + 1, i): is_prime[j] = False primes = [i for i in range(2, limit + 1) if is_prime[i]] return primes primes = sieve_of_eratosthenes(n) prime_count = len(primes) prime_sum = sum(primes) prime_average = round(prime_sum / prime_count, 2) if prime_count > 0 else 0 return f\\"Prime count: {prime_count}, Sum: {prime_sum}, Average: {prime_average:.2f}\\""},{"question":"def decode_string(s: str) -> str: Decode an encoded string where \\"N[substr]\\" denotes that the substring \`substr\` should be repeated \`N\` times. >>> decode_string(\\"3[a]2[bc]\\") == \\"aaabcbc\\" >>> decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" >>> decode_string(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" >>> decode_string(\\"10[a]\\") == \\"aaaaaaaaaa\\"","solution":"def decode_string(s: str) -> str: stack = [] current_num = 0 current_string = '' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == '[': stack.append((current_string, current_num)) current_string = '' current_num = 0 elif char == ']': last_string, num = stack.pop() current_string = last_string + num * current_string else: current_string += char return current_string"},{"question":"from typing import List, Tuple def check_meeting_conflict(existing_meetings: List[Tuple[int, int]], new_meeting: Tuple[int, int]) -> bool: Checks if a new meeting conflicts with any existing meetings. :param existing_meetings: List of tuples where each tuple represents an existing meeting's start and end time. :param new_meeting: A tuple representing the new meeting's start and end time. :return: Boolean value indicating whether the new meeting time conflicts with any existing meetings. pass def add_meeting(existing_meetings: List[Tuple[int, int]], new_meeting: Tuple[int, int]) -> List[Tuple[int, int]]: Adds a new meeting to the list of existing meetings if there is no conflict. :param existing_meetings: List of tuples where each tuple represents existing meetings' start and end times. :param new_meeting: A tuple representing the new meeting's start and end time. :return: List of tuples representing all meetings including the newly added meeting. pass def test_check_meeting_conflict_no_conflict(): existing_meetings = [(900, 1030), (1300, 1430), (1600, 1730)] new_meeting = (1100, 1200) assert check_meeting_conflict(existing_meetings, new_meeting) == False def test_check_meeting_conflict_with_conflict(): existing_meetings = [(900, 1030), (1300, 1430), (1600, 1730)] new_meeting = (1000, 1100) assert check_meeting_conflict(existing_meetings, new_meeting) == True def test_add_meeting_no_conflict(): existing_meetings = [(900, 1030), (1300, 1430), (1600, 1730)] new_meeting = (1100, 1200) assert add_meeting(existing_meetings, new_meeting) == [(900, 1030), (1300, 1430), (1600, 1730), (1100, 1200)] def test_add_meeting_with_conflict(): existing_meetings = [(900, 1030), (1300, 1430), (1600, 1730)] new_meeting = (1000, 1100) assert add_meeting(existing_meetings, new_meeting) == existing_meetings def test_check_edge_case_conflict(): existing_meetings = [(0, 600), (2300, 2359)] new_meeting = (500, 700) assert check_meeting_conflict(existing_meetings, new_meeting) == True def test_check_edge_case_no_conflict(): existing_meetings = [(0, 600), (2300, 2359)] new_meeting = (600, 2300) assert check_meeting_conflict(existing_meetings, new_meeting) == False","solution":"from typing import List, Tuple def check_meeting_conflict(existing_meetings: List[Tuple[int, int]], new_meeting: Tuple[int, int]) -> bool: Checks if a new meeting conflicts with any existing meetings. :param existing_meetings: List of tuples where each tuple represents an existing meeting's start and end time. :param new_meeting: A tuple representing the new meeting's start and end time. :return: Boolean value indicating whether the new meeting time conflicts with any existing meetings. new_start, new_end = new_meeting for start, end in existing_meetings: if not (new_end <= start or new_start >= end): return True return False def add_meeting(existing_meetings: List[Tuple[int, int]], new_meeting: Tuple[int, int]) -> List[Tuple[int, int]]: Adds a new meeting to the list of existing meetings if there is no conflict. :param existing_meetings: List of tuples where each tuple represents existing meetings' start and end times. :param new_meeting: A tuple representing the new meeting's start and end time. :return: List of tuples representing all meetings including the newly added meeting. if check_meeting_conflict(existing_meetings, new_meeting): return existing_meetings return existing_meetings + [new_meeting]"},{"question":"class GraphTraversal: A class to perform various graph traversal algorithms. Methods: - dfs(graph, start): Traverses the graph using Depth-First Search starting from the specified vertex. - bfs(graph, start): Traverses the graph using Breadth-First Search starting from the specified vertex. - is_cyclic(graph): Determines if the graph contains any cycles. Examples: >>> graph = {'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['F'], 'D': [], 'E': ['F'], 'F': []} >>> traversals = GraphTraversal() >>> traversals.dfs(graph, 'A') ['A', 'B', 'D', 'E', 'F', 'C'] >>> traversals.bfs(graph, 'A') ['A', 'B', 'C', 'D', 'E', 'F'] >>> traversals.is_cyclic(graph) False >>> cyclic_graph = {'A': ['B'], 'B': ['C'], 'C': ['A']} >>> traversals.is_cyclic(cyclic_graph) True def dfs(self, graph, start): pass # Add your implementation here def bfs(self, graph, start): pass # Add your implementation here def is_cyclic(self, graph): pass # Add your implementation here","solution":"class GraphTraversal: def dfs(self, graph, start): if not isinstance(graph, dict): raise TypeError(\\"Graph should be a dictionary.\\") if start not in graph: raise ValueError(\\"The start vertex does not exist in the graph.\\") visited = set() result = [] def _dfs(v): if v not in visited: visited.add(v) result.append(v) for neighbor in graph.get(v, []): _dfs(neighbor) _dfs(start) return result def bfs(self, graph, start): if not isinstance(graph, dict): raise TypeError(\\"Graph should be a dictionary.\\") if start not in graph: raise ValueError(\\"The start vertex does not exist in the graph.\\") visited = set() queue = [start] result = [] while queue: vertex = queue.pop(0) if vertex not in visited: visited.add(vertex) result.append(vertex) queue.extend([neighbor for neighbor in graph.get(vertex, []) if neighbor not in visited]) return result def is_cyclic(self, graph): if not isinstance(graph, dict): raise TypeError(\\"Graph should be a dictionary.\\") visited = set() rec_stack = set() def _is_cyclic(v): visited.add(v) rec_stack.add(v) for neighbor in graph.get(v, []): if neighbor not in visited and _is_cyclic(neighbor): return True elif neighbor in rec_stack: return True rec_stack.remove(v) return False for vertex in graph: if vertex not in visited: if _is_cyclic(vertex): return True return False"},{"question":"def largest_subarray_with_sum_k(arr: List[int], k: int) -> int: Find the length of the largest subarray with sum equal to k. >>> largest_subarray_with_sum_k([1, -1, 5, -2, 3], 3) 4 >>> largest_subarray_with_sum_k([-2, -1, 2, 1], 1) 2 >>> largest_subarray_with_sum_k([1, 2, 3], 7) 0 >>> largest_subarray_with_sum_k([1, 2, 3, -2, -3], 1) 5 >>> largest_subarray_with_sum_k([5], 5) 1","solution":"def largest_subarray_with_sum_k(arr, k): Function to find the length of the largest subarray with sum equal to k. Parameters: arr (List[int]): The array of integers. k (int): The target sum. Returns: int: The length of the largest subarray with sum equal to k. sum_map = {} current_sum = 0 max_len = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum == k: max_len = i + 1 if current_sum - k in sum_map: max_len = max(max_len, i - sum_map[current_sum - k]) if current_sum not in sum_map: sum_map[current_sum] = i return max_len"},{"question":"from typing import List, Tuple def calculate_calories_burned(cyclists: List[Tuple[float, float]]) -> List[float]: Calculate the total calories burned during a cycling workout for multiple cyclists. Each cyclist is defined by a tuple containing their weight in kilograms and the distance they have cycled in kilometers. The function validates input values, raises ValueError for invalid inputs, and returns a list of total calories burned for each cyclist. Parameters: cyclists (List[Tuple[float, float]]): A list of tuples where each tuple contains weight (in kg) and distance (in km). Returns: List[float]: A list of float values where each value is the total calories burned by the corresponding cyclist. Raises: - ValueError: If the weight is not between 30 and 200 kg. - ValueError: If the distance is not between 0 and 500 km. Examples: >>> calculate_calories_burned([(70, 20), (55, 15), (80, 30)]) [11200.0, 6600.0, 19200.0] import pytest def test_calculate_calories_burned_valid_cases(): assert calculate_calories_burned([(70, 20), (55, 15), (80, 30)]) == [11200.0, 6600.0, 19200.0] assert calculate_calories_burned([(100, 0), (200, 500)]) == [0.0, 800000.0] def test_calculate_calories_burned_invalid_weight_low(): with pytest.raises(ValueError, match=\\"Weight must be between 30 and 200 kg\\"): calculate_calories_burned([(20, 20)]) def test_calculate_calories_burned_invalid_weight_high(): with pytest.raises(ValueError, match=\\"Weight must be between 30 and 200 kg\\"): calculate_calories_burned([(210, 20)]) def test_calculate_calories_burned_invalid_distance_low(): with pytest.raises(ValueError, match=\\"Distance must be between 0 and 500 km\\"): calculate_calories_burned([(70, -1)]) def test_calculate_calories_burned_invalid_distance_high(): with pytest.raises(ValueError, match=\\"Distance must be between 0 and 500 km\\"): calculate_calories_burned([(70, 600)]) def test_calculate_calories_burned_boundary_values(): assert calculate_calories_burned([(30, 0), (200, 500)]) == [0.0, 800000.0] def test_calculate_calories_burned_mixed_valid_invalid(): with pytest.raises(ValueError, match=\\"Distance must be between 0 and 500 km\\"): calculate_calories_burned([(100, 100), (200, 600)])","solution":"from typing import List, Tuple def calculate_calories_burned(cyclists: List[Tuple[float, float]]) -> List[float]: def calories_burned(weight: float, distance: float) -> float: Calculates the number of calories burned given the weight of the cyclist (in kg) and the distance cycled (in km). CALORIES_PER_KG_PER_KM = 8 return weight * CALORIES_PER_KG_PER_KM * distance results = [] for weight, distance in cyclists: if not (30 <= weight <= 200): raise ValueError(\\"Weight must be between 30 and 200 kg\\") if not (0 <= distance <= 500): raise ValueError(\\"Distance must be between 0 and 500 km\\") results.append(calories_burned(weight, distance)) return results"},{"question":"def find_word_occurrences(input_text: str, target_word: str) -> list: Finds all occurrences of the target word in the input text and returns their starting indices. The search is case-insensitive. >>> find_word_occurrences(\\"The quick Brown fox jumps over the brown dog.\\", \\"brown\\") [10, 35] >>> find_word_occurrences(\\"hello world, hello everyone\\", \\"hello\\") [0, 13] >>> find_word_occurrences(\\"Python is fun. python programming is interesting.\\", \\"python\\") [0, 15] >>> find_word_occurrences(\\"Lorem ipsum dolor sit amet.\\", \\"test\\") [] pass","solution":"def find_word_occurrences(input_text: str, target_word: str) -> list: Finds all occurrences of the target word in the input text and returns their starting indices. The search is case-insensitive. input_text_lower = input_text.lower() target_word_lower = target_word.lower() word_length = len(target_word_lower) indices = [] start = 0 while True: start = input_text_lower.find(target_word_lower, start) if start == -1: break indices.append(start) start += word_length return indices"},{"question":"def is_prime(n: int) -> bool: Check if a given number is a prime number. :param n: Integer to check for primality. :return: True if n is a prime number, else False. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(19) True >>> is_prime(25) False >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(-3) False >>> is_prime(101) True >>> is_prime(102) False pass","solution":"def is_prime(n: int) -> bool: Check if a given number is a prime number. :param n: Integer to check for primality. :return: True if n is a prime number, else False. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(19) True >>> is_prime(25) False >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(-3) False >>> is_prime(101) True >>> is_prime(102) False if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"class ShoppingCart: def __init__(self): Initialize an empty shopping cart with no items. self.items = {} def add_item(self, item_name: str, item_price: float): Add an item to the shopping cart. The item is added only if it is not already present in the cart. pass def remove_item(self, item_name: str): Remove an item from the shopping cart. If the item is not present, the cart remains unchanged. pass def total_cost(self) -> float: Calculate the total cost of the items in the cart after applying dynamic pricing discounts. Discounts: - No discount for total values less than 100. - 10% discount for total values between 100 and 200 (inclusive). - 20% discount for total values exceeding 200. Returns: float: The total cost after applying the appropriate discount. pass # Unit Tests (referenced for usage) def test_add_item(): cart = ShoppingCart() cart.add_item(\\"Laptop\\", 150) assert cart.items == {\\"Laptop\\": 150} def test_add_duplicate_item(): cart = ShoppingCart() cart.add_item(\\"Laptop\\", 150) cart.add_item(\\"Laptop\\", 200) assert cart.items == {\\"Laptop\\": 150} def test_remove_item(): cart = ShoppingCart() cart.add_item(\\"Laptop\\", 150) cart.remove_item(\\"Laptop\\") assert cart.items == {} def test_remove_nonexistent_item(): cart = ShoppingCart() cart.add_item(\\"Laptop\\", 150) cart.remove_item(\\"Mouse\\") assert cart.items == {\\"Laptop\\": 150} def test_total_cost_no_discount(): cart = ShoppingCart() cart.add_item(\\"Mouse\\", 50) assert cart.total_cost() == 50 def test_total_cost_10_percent_discount(): cart = ShoppingCart() cart.add_item(\\"Laptop\\", 150) cart.add_item(\\"Mouse\\", 50) assert cart.total_cost() == 180.0 # 200 - 10% = 180 def test_total_cost_20_percent_discount(): cart = ShoppingCart() cart.add_item(\\"Laptop\\", 150) cart.add_item(\\"Mouse\\", 50) cart.add_item(\\"Monitor\\", 100) assert cart.total_cost() == 240.0 # 300 - 20% = 240 def test_total_cost_after_removing_item_no_discount(): cart = ShoppingCart() cart.add_item(\\"Laptop\\", 150) cart.add_item(\\"Mouse\\", 50) cart.remove_item(\\"Monitor\\") assert cart.total_cost() == 180.0 def test_total_cost_after_removing_item_discount_change(): cart = ShoppingCart() cart.add_item(\\"Laptop\\", 150) cart.add_item(\\"Mouse\\", 50) cart.add_item(\\"Monitor\\", 100) cart.remove_item(\\"Mouse\\") assert cart.total_cost() == 200.0 def test_total_cost_after_removing_item(): cart = ShoppingCart() cart.add_item(\\"Laptop\\", 150) cart.add_item(\\"Mouse\\", 50) cart.add_item(\\"Monitor\\", 100) cart.remove_item(\\"Monitor\\") assert cart.total_cost() == 180.0","solution":"class ShoppingCart: def __init__(self): self.items = {} def add_item(self, item_name: str, item_price: float): if item_name not in self.items: self.items[item_name] = item_price def remove_item(self, item_name: str): if item_name in self.items: del self.items[item_name] def total_cost(self) -> float: total = sum(self.items.values()) if total > 200: discount = 0.20 elif total >= 100: discount = 0.10 else: discount = 0.0 return total * (1 - discount)"},{"question":"from typing import List def find_longest_string_without_repeating_characters(words: List[str]) -> str: Finds the longest word in the list that does not contain any repeating characters. Args: words: A list of words. Returns: A string which is the longest word in the list that does not contain any repeating characters, or an empty string if no such word exists. Examples: >>> find_longest_string_without_repeating_characters([\\"abc\\", \\"deefg\\", \\"abcdefgh\\", \\"aabbcc\\"]) 'abcdefgh' >>> find_longest_string_without_repeating_characters([\\"a\\", \\"b\\", \\"ab\\", \\"aa\\", \\"aba\\"]) 'ab' >>> find_longest_string_without_repeating_characters([\\"aa\\", \\"bb\\", \\"cc\\"]) '' >>> find_longest_string_without_repeating_characters([]) '' >>> find_longest_string_without_repeating_characters([\\"qwerty\\", \\"asdfgh\\", \\"zxcvbn\\"]) 'qwerty' pass","solution":"from typing import List def find_longest_string_without_repeating_characters(words: List[str]) -> str: def has_unique_characters(word: str) -> bool: return len(set(word)) == len(word) longest_word = \\"\\" for word in words: if has_unique_characters(word): if len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"from typing import List, Tuple def book_rooms(bookings: List[Tuple[int, int]]) -> int: Determine the maximum number of rooms booked at the same time. Args: bookings (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers representing the start and end times of a booking. Returns: int: The maximum number of rooms booked at the same time. Examples: >>> book_rooms([(1, 4), (2, 5), (6, 7), (3, 8)]) 3 >>> book_rooms([(1, 2), (3, 4), (5, 6), (7, 8)]) 1 >>> book_rooms([(1, 2)]) 1 >>> book_rooms([(1, 2), (1, 2)]) 2 >>> book_rooms([]) 0 >>> book_rooms([(1, 10), (10, 11), (1, 5), (6, 10), (5, 9), (7, 8)]) 4","solution":"from typing import List, Tuple def book_rooms(bookings: List[Tuple[int, int]]) -> int: events = [] for start, end in bookings: events.append((start, 'start')) events.append((end+1, 'end')) # To count the room as still booked at end time events.sort() # Sort events first by time, then by type ('start' before 'end') max_rooms = 0 current_rooms = 0 for time, event_type in events: if event_type == 'start': current_rooms += 1 max_rooms = max(max_rooms, current_rooms) else: current_rooms -= 1 return max_rooms"},{"question":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Take in a 2D list (matrix) and return the transpose of the matrix. In a transposed matrix, the rows become columns and the columns become rows. Example: >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1]]) [[1]]","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Take in a 2D list (matrix) and return the transpose of the matrix. In a transposed matrix, the rows become columns and the columns become rows. Example: >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1]]) [[1]] if not matrix: # Handle empty matrix input. return [] return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]"},{"question":"import random from sympy import isprime, mod_inverse from typing import Tuple def generate_primes(bits: int) -> Tuple[int, int]: Generates two distinct large prime numbers each approximated to the specified bit length. Args: bits (int): The bit length of the prime numbers. Returns: Tuple[int, int]: A tuple containing two distinct prime numbers. pass def compute_keys(prime1: int, prime2: int) -> Tuple[Tuple[int, int], Tuple[int, int]]: Computes the RSA public and private keys from two prime numbers. Args: prime1 (int): The first prime number. prime2 (int): The second prime number. Returns: Tuple[Tuple[int, int], Tuple[int, int]]: A tuple containing the public and private keys. pass def rsa_encrypt_decrypt(message: int, key: Tuple[int, int], n: int) -> int: Encrypts/Decrypts a message using the provided key and modulus. Args: message (int): The integer message to encrypt/decrypt. key (Tuple[int, int]): A tuple containing the exponent and modulus of the key. n (int): The modulus of the key. Returns: int: The encrypted or decrypted message as an integer. pass # Tests def test_generate_primes(): prime1, prime2 = generate_primes(16) assert prime1 != prime2 assert isprime(prime1) assert isprime(prime2) def test_compute_keys(): prime1, prime2 = generate_primes(16) public_key, private_key = compute_keys(prime1, prime2) e, n = public_key d, n2 = private_key assert n == prime1 * prime2 assert mod_inverse(e, (prime1-1)*(prime2-1)) == d def test_rsa_encrypt_decrypt(): prime1, prime2 = generate_primes(16) public_key, private_key = compute_keys(prime1, prime2) message = 42 n = public_key[1] encrypted_message = rsa_encrypt_decrypt(message, public_key, n) decrypted_message = rsa_encrypt_decrypt(encrypted_message, private_key, n) assert decrypted_message == message def test_rsa_encrypt_decrypt_with_larger_primes(): prime1, prime2 = generate_primes(32) public_key, private_key = compute_keys(prime1, prime2) message = 123456 n = public_key[1] encrypted_message = rsa_encrypt_decrypt(message, public_key, n) decrypted_message = rsa_encrypt_decrypt(encrypted_message, private_key, n) assert decrypted_message == message","solution":"import random from sympy import isprime, mod_inverse def generate_primes(bits: int) -> tuple[int, int]: Generates two distinct large prime numbers each of the specified bit length. prime1 = prime2 = 1 while prime1 == prime2: prime1 = random.getrandbits(bits) prime2 = random.getrandbits(bits) # Ensure they are prime while not isprime(prime1): prime1 = random.getrandbits(bits) while not isprime(prime2): prime2 = random.getrandbits(bits) return prime1, prime2 def compute_keys(prime1: int, prime2: int) -> tuple[tuple[int, int], tuple[int, int]]: Computes the RSA public and private keys from two prime numbers. n = prime1 * prime2 phi_n = (prime1 - 1) * (prime2 - 1) e = 65537 d = mod_inverse(e, phi_n) return (e, n), (d, n) def rsa_encrypt_decrypt(message: int, key: tuple[int, int], n: int) -> int: Encrypts/Decrypts a message using the provided key and modulus. Performs modular exponentiation. exponent, modulus = key return pow(message, exponent, modulus)"},{"question":"def calculate_simple_interest(principal: float, rate: float, time: float) -> float: Calculate the simple interest based on the provided principal amount, annual interest rate, and time in years. Parameters: principal (float): The principal amount in dollars. rate (float): The annual interest rate as a percentage. time (float): The time in years. Returns: float: The calculated simple interest. Raises: ValueError: If any of the principal, rate, or time are negative. # Implementation goes here # Example usage >>> calculate_simple_interest(1000, 5, 2) 100.0 >>> calculate_simple_interest(1500, 4, 3) 180.0 >>> calculate_simple_interest(2000, 3.5, 1.5) 105.0","solution":"def calculate_simple_interest(principal: float, rate: float, time: float) -> float: Calculate the simple interest based on the provided principal amount, annual interest rate, and time in years. Parameters: principal (float): The principal amount in dollars. rate (float): The annual interest rate as a percentage. time (float): The time in years. Returns: float: The calculated simple interest. Raises: ValueError: If any of the principal, rate, or time are negative. if principal < 0: raise ValueError(\\"Principal amount cannot be negative.\\") if rate < 0: raise ValueError(\\"Annual interest rate cannot be negative.\\") if time < 0: raise ValueError(\\"Time in years cannot be negative.\\") simple_interest = (principal * rate * time) / 100 return simple_interest"},{"question":"from typing import List def length_of_LIS(numbers: List[int]) -> int: Returns the length of the longest increasing sub-sequence (LIS) in the list of integers. >>> length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_LIS([0, 1, 0, 3, 2, 3]) 4 >>> length_of_LIS([7, 7, 7, 7, 7, 7, 7]) 1 >>> length_of_LIS([]) 0 >>> length_of_LIS([1]) 1 >>> length_of_LIS([10, 20, 10, 30, 40, 50]) 5 >>> length_of_LIS([3, 10, 2, 1, 20]) 3 >>> length_of_LIS([1, 7, 8, 4, 5, 6, 3, 4, 2, 9]) 5 >>> length_of_LIS([-1, 3, 4, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 5, 3]) 4 >>> length_of_LIS([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6","solution":"from typing import List import bisect def length_of_LIS(numbers: List[int]) -> int: Returns the length of the longest increasing sub-sequence (LIS) in the list of integers. if not numbers: return 0 tails = [] # tails[i] will be the smallest ending number of an increasing subsequence of length i+1 for num in numbers: # Use binary search to find the insertion point of num in tails index = bisect.bisect_left(tails, num) # If num is greater than any element in tails, add it if index == len(tails): tails.append(num) else: # Otherwise, replace the first element in tails that is greater than or equal to num tails[index] = num return len(tails)"},{"question":"from typing import List, Tuple def word_frequency_counter(text: str, top_n: int, stopwords: List[str]) -> List[Tuple[str, int]]: Count the most frequent words in the text, ignoring stopwords. >>> word_frequency_counter(\\"Hello world! This is a test. Hello, hello, world: this is only a test.\\", 3, [\\"is\\", \\"a\\", \\"this\\", \\"only\\"]) [('hello', 3), ('test', 2), ('world', 2)] >>> word_frequency_counter(\\"Hello... hello!!! world?? world\\", 2, []) [('hello', 2), ('world', 2)] >>> word_frequency_counter(\\"Word word WORD!\\", 1, []) [('word', 3)] >>> word_frequency_counter(\\"It's a beautiful day in the neighborhood.\\", 3, [\\"it\\", \\"a\\", \\"in\\", \\"the\\"]) [('beautiful', 1), ('day', 1), ('neighborhood', 1)] >>> word_frequency_counter(\\"\\", 5, [\\"empty\\", \\"text\\"]) [] >>> word_frequency_counter(\\"This function should return an empty list for top_n equals 0.\\", 0, [\\"this\\", \\"should\\", \\"for\\"]) []","solution":"from collections import Counter import re from typing import List, Tuple def word_frequency_counter(text: str, top_n: int, stopwords: List[str]) -> List[Tuple[str, int]]: # Convert text to lower case text = text.lower() # Remove punctuation text = re.sub(r'[^ws]', ' ', text) # Tokenize the text by splitting on whitespace words = text.split() # Filter out stopwords words = [word for word in words if word not in stopwords] # Count word frequencies word_counts = Counter(words) # Get the most common words sorted by frequency and alphabetically most_common_words = word_counts.most_common() sorted_most_common_words = sorted(most_common_words, key=lambda x: (-x[1], x[0])) # Return top_n words return sorted_most_common_words[:top_n]"},{"question":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the elements of the input list \`arr\` to the right by \`k\` steps. >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 3) [3, 4, 5, 1, 2] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_array([1], 5) [1] def find_minimum(arr: List[int]) -> int: Returns the minimum value in the list \`arr\`. >>> find_minimum([4, 5, 1, 2, 3]) 1 >>> find_minimum([10, 20, 5, 70, 30]) 5 >>> find_minimum([-10, -20, -30, -5]) -30 >>> find_minimum([1]) 1 >>> find_minimum([i for i in range(100000, 0, -1)]) 1","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the elements of the input list \`arr\` to the right by \`k\` steps. n = len(arr) k = k % n # To handle cases where k is larger than the array length. return arr[-k:] + arr[:-k] def find_minimum(arr: List[int]) -> int: Returns the minimum value in the list \`arr\`. if not arr: # Guard clause for empty list raise ValueError(\\"Empty array has no minimum value\\") return min(arr)"},{"question":"def binary_addition(bin1: str, bin2: str) -> str: Simulates a simplified version of the binary addition operation between two binary strings. Both binary strings will be non-negative and without a \\"0b\\" prefix. The function should return the resulting binary string, also without the \\"0b\\" prefix. >>> binary_addition('1010', '1011') '10101' >>> binary_addition('110', '1010') '10000' >>> binary_addition('111', '1') '1000'","solution":"def binary_addition(bin1: str, bin2: str) -> str: Returns the binary sum of two binary strings. max_len = max(len(bin1), len(bin2)) # Padding the shorter string with zeros bin1 = bin1.zfill(max_len) bin2 = bin2.zfill(max_len) carry = 0 result = [] # Add the binary numbers from right to left for i in range(max_len - 1, -1, -1): digit_sum = carry digit_sum += int(bin1[i]) digit_sum += int(bin2[i]) result.append(str(digit_sum % 2)) # current (result) digit carry = digit_sum // 2 # carry to the next digit if carry: result.append('1') result.reverse() return ''.join(result)"},{"question":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates an NxN matrix by 90 degrees clockwise in-place. Args: matrix (list of list of int): NxN matrix to be rotated. Returns: None: The function modifies the matrix in-place. >>> matrix1 = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix1) >>> print(matrix1) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix2 = [ ... [1, 2], ... [3, 4] ... ] >>> rotate_matrix(matrix2) >>> print(matrix2) [ [3, 1], [4, 2] ]","solution":"def rotate_matrix(matrix): Rotates an NxN matrix by 90 degrees clockwise in-place. Args: matrix (list of list of int): NxN matrix to be rotated. Returns: None: The function modifies the matrix in-place. n = len(matrix) # Perform the rotation in layers for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): # Offset is used to keep track of the position in the layer offset = i - first # Save the top element top = matrix[first][i] # Move left element to top matrix[first][i] = matrix[last - offset][first] # Move bottom element to left matrix[last - offset][first] = matrix[last][last - offset] # Move right element to bottom matrix[last][last - offset] = matrix[i][last] # Move saved top element to right matrix[i][last] = top"},{"question":"# Compute the Area of Intersection of Two Rectangles Write a function \`rectangle_intersection_area()\` that calculates the area of intersection between two rectangles. Each rectangle is defined by its bottom-left and top-right coordinates. from typing import Tuple def rectangle_intersection_area(rect1: Tuple[int, int, int, int], rect2: Tuple[int, int, int, int]) -> int: Calculate the area of intersection between two rectangles. rect1: (x1, y1, x2, y2) rect2: (x3, y3, x4, y4) >>> rectangle_intersection_area((1, 1, 3, 3), (2, 2, 4, 4)) 1 >>> rectangle_intersection_area((1, 1, 2, 2), (3, 3, 4, 4)) 0 >>> rectangle_intersection_area((1, 1, 4, 4), (2, 2, 5, 5)) 4 >>> rectangle_intersection_area((1, 1, 4, 4), (2, 2, 3, 3)) 1 >>> rectangle_intersection_area((1, 1, 3, 3), (3, 3, 5, 5)) 0 >>> rectangle_intersection_area((1, 1, 3, 3), (1, 1, 3, 3)) 4 >>> rectangle_intersection_area((1, 1, 2, 4), (2, 2, 3, 3)) 0 >>> rectangle_intersection_area((-10000, -10000, 10000, 10000), (-5000, -5000, 5000, 5000)) 100000000","solution":"from typing import Tuple def rectangle_intersection_area(rect1: Tuple[int, int, int, int], rect2: Tuple[int, int, int, int]) -> int: Calculate the area of intersection between two rectangles. rect1: (x1, y1, x2, y2) rect2: (x3, y3, x4, y4) # Unpacking the bottom-left and top-right coordinates of both rectangles x1, y1, x2, y2 = rect1 x3, y3, x4, y4 = rect2 # Calculate the overlapping width and height overlap_width = min(x2, x4) - max(x1, x3) overlap_height = min(y2, y4) - max(y1, y3) # If there is no overlap, return 0 if overlap_width <= 0 or overlap_height <= 0: return 0 # Calculate and return the area of the intersection return overlap_width * overlap_height"},{"question":"from typing import List def find_median_sorted_arrays(nums1: List[int], nums2: List[int]) -> float: Compute the median of two sorted arrays. >>> find_median_sorted_arrays([1, 3], [2]) 2.0 >>> find_median_sorted_arrays([1, 2], [3, 4]) 2.5 >>> find_median_sorted_arrays([0, 0], [0, 0]) 0.0 >>> find_median_sorted_arrays([], [1]) 1.0 >>> find_median_sorted_arrays([2], []) 2.0","solution":"from typing import List def find_median_sorted_arrays(nums1: List[int], nums2: List[int]) -> float: if len(nums1) > len(nums2): nums1, nums2 = nums2, nums1 m, n = len(nums1), len(nums2) imin, imax, half_len = 0, m, (m + n + 1) // 2 while imin <= imax: i = (imin + imax) // 2 j = half_len - i if i < m and nums1[i] < nums2[j - 1]: imin = i + 1 elif i > 0 and nums1[i - 1] > nums2[j]: imax = i - 1 else: if i == 0: left_max = nums2[j - 1] elif j == 0: left_max = nums1[i - 1] else: left_max = max(nums1[i - 1], nums2[j - 1]) if (m + n) % 2 == 1: return float(left_max) if i == m: right_min = nums2[j] elif j == n: right_min = nums1[i] else: right_min = min(nums1[i], nums2[j]) return (left_max + right_min) / 2.0"},{"question":"def generate_fibonacci(n: int) -> list: Generates the Fibonacci sequence up to the n-th term using dynamic programming. Parameters: n (int): The index of the final term in the Fibonacci sequence to be generated. Returns: list: A list of integers representing the Fibonacci sequence from F(0) to F(n). Examples: >>> generate_fibonacci(0) [0] >>> generate_fibonacci(1) [0, 1] >>> generate_fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]","solution":"def generate_fibonacci(n: int) -> list: Generates the Fibonacci sequence up to the n-th term. Parameters: n (int): The index of the final term in the Fibonacci sequence to be generated. Returns: list: A list of integers representing the Fibonacci sequence from F(0) to F(n). if n < 0: raise ValueError(\\"The input must be a non-negative integer.\\") if n == 0: return [0] elif n == 1: return [0, 1] # DP array to store Fibonacci numbers fib = [0] * (n + 1) fib[0] = 0 fib[1] = 1 for i in range(2, n + 1): fib[i] = fib[i - 1] + fib[i - 2] return fib"},{"question":"class DBMS: def __init__(self): self.table = {} self.fields = [] def create_table(self, fields): Initializes the table with the provided fields. The first field is considered as the primary key. pass def insert_record(self, record): Inserts a record into the table. Ensures the primary key is unique. pass def get_record(self, key): Retrieves a record from the table based on the primary key. Returns None if the record does not exist. pass def update_record(self, key, updated_values): Updates a record in the table with the given primary key. Ensures the record exists. pass def delete_record(self, key): Deletes a record from the table based on the primary key. Ensures the record exists. pass # Unit tests import pytest def test_create_table(): dbms = DBMS() fields = ['id', 'name', 'age'] dbms.create_table(fields) assert dbms.fields == fields def test_insert_record(): dbms = DBMS() dbms.create_table(['id', 'name', 'age']) record = {'id': '101', 'name': 'Alice', 'age': 25} dbms.insert_record(record) assert dbms.get_record('101') == record def test_insert_record_duplicate_key(): dbms = DBMS() dbms.create_table(['id', 'name', 'age']) record = {'id': '101', 'name': 'Alice', 'age': 25} dbms.insert_record(record) with pytest.raises(ValueError, match=\\"Record with this primary key already exists.\\"): dbms.insert_record(record) def test_get_record(): dbms = DBMS() dbms.create_table(['id', 'name', 'age']) assert dbms.get_record('101') is None record = {'id': '101', 'name': 'Alice', 'age': 25} dbms.insert_record(record) assert dbms.get_record('101') == record def test_update_record(): dbms = DBMS() dbms.create_table(['id', 'name', 'age']) record = {'id': '101', 'name': 'Alice', 'age': 25} dbms.insert_record(record) dbms.update_record('101', {'age': 26}) assert dbms.get_record('101') == {'id': '101', 'name': 'Alice', 'age': 26} def test_update_record_non_existent(): dbms = DBMS() dbms.create_table(['id', 'name', 'age']) with pytest.raises(ValueError, match=\\"Record with this primary key does not exist.\\"): dbms.update_record('101', {'age': 26}) def test_delete_record(): dbms = DBMS() dbms.create_table(['id', 'name', 'age']) record = {'id': '101', 'name': 'Alice', 'age': 25} dbms.insert_record(record) dbms.delete_record('101') assert dbms.get_record('101') is None def test_delete_record_non_existent(): dbms = DBMS() dbms.create_table(['id', 'name', 'age']) with pytest.raises(ValueError, match=\\"Record with this primary key does not exist.\\"): dbms.delete_record('101')","solution":"class DBMS: def __init__(self): self.table = {} self.fields = [] def create_table(self, fields): Initializes the table with the provided fields. The first field is considered as the primary key. self.fields = fields def insert_record(self, record): Inserts a record into the table. Ensures the primary key is unique. primary_key = record[self.fields[0]] if primary_key in self.table: raise ValueError(\\"Record with this primary key already exists.\\") self.table[primary_key] = record def get_record(self, key): Retrieves a record from the table based on the primary key. Returns None if the record does not exist. return self.table.get(key, None) def update_record(self, key, updated_values): Updates a record in the table with the given primary key. Ensures the record exists. if key not in self.table: raise ValueError(\\"Record with this primary key does not exist.\\") for field, value in updated_values.items(): self.table[key][field] = value def delete_record(self, key): Deletes a record from the table based on the primary key. Ensures the record exists. if key not in self.table: raise ValueError(\\"Record with this primary key does not exist.\\") del self.table[key]"},{"question":"class Inventory: def __init__(self): Initializes an empty inventory. pass def add_item(self, item_id: int, item_name: str, quantity: int) -> None: Adds a new item to the inventory. If the item already exists, its quantity should be updated. pass def update_quantity(self, item_id: int, quantity: int) -> None: Updates the quantity of an existing item. If the item does not exist, raises a ValueError with the message 'Item not found' pass def remove_item(self, item_id: int) -> None: Removes an item from the inventory if it exists. If the item does not exist, raises a ValueError with the message 'Item not found' pass def get_inventory(self) -> dict: Returns a dictionary representing the current inventory. The keys are the item IDs, and the values are another dictionary with 'name' and 'quantity' of the item. pass import pytest def test_add_item(): inventory = Inventory() inventory.add_item(1, \\"Laptop\\", 10) assert inventory.get_inventory() == { 1: {\\"name\\": \\"Laptop\\", \\"quantity\\": 10} } def test_update_quantity_existing_item(): inventory = Inventory() inventory.add_item(1, \\"Laptop\\", 10) inventory.update_quantity(1, 15) assert inventory.get_inventory() == { 1: {\\"name\\": \\"Laptop\\", \\"quantity\\": 15} } def test_update_quantity_non_existing_item(): inventory = Inventory() with pytest.raises(ValueError, match=\\"Item not found\\"): inventory.update_quantity(2, 5) def test_remove_item_existing(): inventory = Inventory() inventory.add_item(1, \\"Laptop\\", 10) inventory.remove_item(1) assert inventory.get_inventory() == {} def test_remove_item_non_existing(): inventory = Inventory() with pytest.raises(ValueError, match=\\"Item not found\\"): inventory.remove_item(2) def test_get_inventory(): inventory = Inventory() inventory.add_item(1, \\"Laptop\\", 10) inventory.add_item(2, \\"Smartphone\\", 5) assert inventory.get_inventory() == { 1: {\\"name\\": \\"Laptop\\", \\"quantity\\": 10}, 2: {\\"name\\": \\"Smartphone\\", \\"quantity\\": 5} } def test_add_item_existing(): inventory = Inventory() inventory.add_item(1, \\"Laptop\\", 10) inventory.add_item(1, \\"Laptop\\", 5) assert inventory.get_inventory() == { 1: {\\"name\\": \\"Laptop\\", \\"quantity\\": 15} } def test_add_item_with_zero_quantity(): inventory = Inventory() inventory.add_item(1, \\"Laptop\\", 0) assert inventory.get_inventory() == { 1: {\\"name\\": \\"Laptop\\", \\"quantity\\": 0} }","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, item_id: int, item_name: str, quantity: int) -> None: if item_id in self.items: self.items[item_id]['quantity'] += quantity else: self.items[item_id] = {\\"name\\": item_name, \\"quantity\\": quantity} def update_quantity(self, item_id: int, quantity: int) -> None: if item_id not in self.items: raise ValueError(\\"Item not found\\") self.items[item_id]['quantity'] = quantity def remove_item(self, item_id: int) -> None: if item_id not in self.items: raise ValueError(\\"Item not found\\") del self.items[item_id] def get_inventory(self) -> dict: return self.items"},{"question":"def matrix_diagonal_sum(matrix: list[list[int]]) -> int: Calculates the sum of the diagonal elements in a given square matrix, considering both primary and secondary diagonals and ensuring that any elements that overlap are only counted once. Parameters: matrix (list[list[int]]): The n x n square matrix. Returns: int: The sum of the diagonal elements. Raises: ValueError: If the input is not a square matrix. Examples: >>> matrix_diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 25 >>> matrix_diagonal_sum([[7]]) 7 >>> matrix_diagonal_sum([[2, 9], [3, 5]]) 19 >>> matrix_diagonal_sum([[1, 2, 3], [4, 5, 6]]) Traceback (most recent call last): ... ValueError: Input must be a square matrix","solution":"def matrix_diagonal_sum(matrix: list[list[int]]) -> int: Calculates the sum of the diagonal elements in a given square matrix, considering both primary and secondary diagonals and ensuring that any elements that overlap are only counted once. Parameters: matrix (list[list[int]]): The n x n square matrix. Returns: int: The sum of the diagonal elements. Raises: ValueError: If the input is not a square matrix. n = len(matrix) for row in matrix: if len(row) != n: raise ValueError(\\"Input must be a square matrix\\") diagonal_sum = 0 for i in range(n): diagonal_sum += matrix[i][i] # Primary diagonal diagonal_sum += matrix[i][n - 1 - i] # Secondary diagonal # If the matrix has an odd size, subtract the middle element as it was counted twice if n % 2 == 1: diagonal_sum -= matrix[n // 2][n // 2] return diagonal_sum"},{"question":"# Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def merge_k_lists(self, lists): import heapq min_heap = [] for i, node in enumerate(lists): if node: heapq.heappush(min_heap, (node.val, i, node)) dummy = ListNode(0) current = dummy while min_heap: val, i, node = heapq.heappop(min_heap) current.next = node current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, i, node.next)) return dummy.next","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def merge_k_lists(self, lists): import heapq min_heap = [] for i, node in enumerate(lists): if node: heapq.heappush(min_heap, (node.val, i, node)) dummy = ListNode(0) current = dummy while min_heap: val, i, node = heapq.heappop(min_heap) current.next = node current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, i, node.next)) return dummy.next"},{"question":"def kruskal_mst(n: int, edges: list[tuple[int, int, int]]) -> list[tuple[int, int, int]]: Implement Kruskal's algorithm to find the minimum spanning tree (MST) given a list of routes and travel times between cities. Args: - n: An integer representing the number of cities (nodes). - edges: A list of tuples, where each tuple consists of three integers (u, v, w) representing a direct route between cities u and v with travel time w. Returns: - A list of tuples, each containing three integers (u, v, w), representing the edges in the MST. Examples: >>> n = 4 >>> edges = [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)] >>> kruskal_mst(n, edges) [(2, 3, 4), (0, 3, 5), (0, 1, 10)] >>> n = 3 >>> edges = [(0, 1, 1), (1, 2, 4), (0, 2, 3)] >>> kruskal_mst(n, edges) [(0, 1, 1), (0, 2, 3)] pass","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal_mst(n, edges): # Initializing result array result = [] # Sorting edges based on the weight edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) e = 0 # Initialize count of edges in result array i = 0 # Index to iterate through sorted edges while e < n - 1: u, v, w = edges[i] i = i + 1 x = find(parent, u) y = find(parent, v) if x != y: e = e + 1 result.append((u, v, w)) union(parent, rank, x, y) return result # Example usage: # n = 4 # edges = [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)] # print(kruskal_mst(n, edges))"},{"question":"class InsufficientFundsError(Exception): Exception to be raised when withdrawal amount exceeds the balance. pass class BankAccount: def __init__(self, initial_balance: float = 0.0): Initializes the bank account with an optional initial balance. Raises: ValueError: If the initial balance is negative. pass def deposit(self, amount: float) -> None: Adds the specified amount to the account balance. Raises: ValueError: If the deposit amount is negative. pass def withdraw(self, amount: float) -> None: Deducts the specified amount from the account balance, if sufficient funds are available. Raises: ValueError: If the withdrawal amount is negative. InsufficientFundsError: If the withdrawal amount exceeds the current balance. pass def get_balance(self) -> float: Returns the current account balance. pass def test_initial_balance(): account = BankAccount(100) assert account.get_balance() == 100 def test_initial_balance_default(): account = BankAccount() assert account.get_balance() == 0.0 def test_initial_balance_negative(): try: BankAccount(-100) except ValueError as e: assert str(e) == \\"Initial balance cannot be negative.\\" def test_deposit_positive_amount(): account = BankAccount(100) account.deposit(50) assert account.get_balance() == 150 def test_deposit_negative_amount(): account = BankAccount(100) try: account.deposit(-50) except ValueError as e: assert str(e) == \\"Deposit amount cannot be negative.\\" def test_withdraw_positive_amount(): account = BankAccount(100) account.withdraw(50) assert account.get_balance() == 50 def test_withdraw_negative_amount(): account = BankAccount(100) try: account.withdraw(-50) except ValueError as e: assert str(e) == \\"Withdrawal amount cannot be negative.\\" def test_withdraw_exceed_balance(): account = BankAccount(100) try: account.withdraw(150) except InsufficientFundsError as e: assert str(e) == \\"Insufficient funds for this transaction.\\" assert account.get_balance() == 100 def test_withdraw_all_funds(): account = BankAccount(100) account.withdraw(100) assert account.get_balance() == 0","solution":"class InsufficientFundsError(Exception): Exception to be raised when withdrawal amount exceeds the balance. pass class BankAccount: def __init__(self, initial_balance: float = 0.0): if initial_balance < 0: raise ValueError(\\"Initial balance cannot be negative.\\") self.balance = initial_balance def deposit(self, amount: float) -> None: if amount < 0: raise ValueError(\\"Deposit amount cannot be negative.\\") self.balance += amount def withdraw(self, amount: float) -> None: if amount < 0: raise ValueError(\\"Withdrawal amount cannot be negative.\\") if amount > self.balance: raise InsufficientFundsError(\\"Insufficient funds for this transaction.\\") self.balance -= amount def get_balance(self) -> float: return self.balance"},{"question":"import numpy as np def matrix_factorization(R, n_factors, alpha, beta, n_epochs): Perform matrix factorization using Stochastic Gradient Descent. Parameters: R (np.ndarray): User-item interaction matrix. n_factors (int): Number of latent factors. alpha (float): Learning rate. beta (float): Regularization parameter. n_epochs (int): Number of epochs for training. Returns: P (np.ndarray): User feature matrix. Q (np.ndarray): Item feature matrix. >>> R = np.array([[5, 3, 0, 1], [4, 0, 0, 1], [1, 1, 0, 5], [1, 0, 0, 4], [0, 1, 5, 4]]) >>> n_factors = 3 >>> alpha = 0.01 >>> beta = 0.01 >>> n_epochs = 5000 >>> P, Q = matrix_factorization(R, n_factors, alpha, beta, n_epochs) >>> P.shape (5, 3) >>> Q.shape (3, 4) pass def predict(P, Q): Predict the full user-item matrix using the learned user and item features. Parameters: P (np.ndarray): User feature matrix. Q (np.ndarray): Item feature matrix. Returns: np.ndarray: Complete predicted user-item interaction matrix. >>> P = np.random.rand(5, 3) >>> Q = np.random.rand(3, 4) >>> predictions = predict(P, Q) >>> predictions.shape (5, 4) pass def recommend(R, P, Q, user_id, N): Generate top-N item recommendations for a given user. Parameters: R (np.ndarray): Original user-item interaction matrix. P (np.ndarray): User feature matrix. Q (np.ndarray): Item feature matrix. user_id (int): User for whom recommendations are being made. N (int): Number of items to recommend. Returns: list: List of top-N recommended item indices. >>> R = np.array([[5, 3, 0, 1], [4, 0, 0, 1], [1, 1, 0, 5], [1, 0, 0, 4], [0, 1, 5, 4]]) >>> n_factors = 3 >>> alpha = 0.01 >>> beta = 0.01 >>> n_epochs = 5000 >>> P, Q = matrix_factorization(R, n_factors, alpha, beta, n_epochs) >>> recommendations = recommend(R, P, Q, user_id=1, N=2) >>> len(recommendations) 2 pass","solution":"import numpy as np def matrix_factorization(R, n_factors, alpha, beta, n_epochs): Perform matrix factorization using Stochastic Gradient Descent. Parameters: R (np.ndarray): User-item interaction matrix. n_factors (int): Number of latent factors. alpha (float): Learning rate. beta (float): Regularization parameter. n_epochs (int): Number of epochs for training. Returns: P (np.ndarray): User feature matrix. Q (np.ndarray): Item feature matrix. m, n = R.shape P = np.random.normal(scale=1./n_factors, size=(m, n_factors)) Q = np.random.normal(scale=1./n_factors, size=(n_factors, n)) for epoch in range(n_epochs): for i in range(m): for j in range(n): if R[i, j] > 0: # Compute the error of the prediction eij = R[i, j] - np.dot(P[i, :], Q[:, j]) # Update user and item latent feature matrices for k in range(n_factors): P[i, k] += alpha * (2 * eij * Q[k, j] - beta * P[i, k]) Q[k, j] += alpha * (2 * eij * P[i, k] - beta * Q[k, j]) return P, Q def predict(P, Q): Predict the full user-item matrix using the learned user and item features. Parameters: P (np.ndarray): User feature matrix. Q (np.ndarray): Item feature matrix. Returns: np.ndarray: Complete predicted user-item interaction matrix. return np.dot(P, Q) def recommend(R, P, Q, user_id, N): Generate top-N item recommendations for a given user. Parameters: R (np.ndarray): Original user-item interaction matrix. P (np.ndarray): User feature matrix. Q (np.ndarray): Item feature matrix. user_id (int): User for whom recommendations are being made. N (int): Number of items to recommend. Returns: list: List of top-N recommended item indices. user_predictions = np.dot(P[user_id, :], Q) unrated_items = np.where(R[user_id, :] == 0)[0] recommendations = [ (i, user_predictions[i]) for i in unrated_items ] return [item[0] for item in sorted(recommendations, key=lambda x: x[1], reverse=True)[:N]]"},{"question":"from collections import Counter class UserPreferenceManager: def __init__(self): self.preferences = [] def submit_preference(self, user_id, category, preference): Submit a user's preference for a specific category. pass def get_top_preferences(self, category): Get the top 5 most common preferences for the specified category. >>> manager = UserPreferenceManager() >>> manager.submit_preference(1, \\"movie_genre\\", \\"Action\\") >>> manager.submit_preference(2, \\"movie_genre\\", \\"Comedy\\") >>> manager.get_top_preferences(\\"movie_genre\\") [\\"Action\\", \\"Comedy\\"] pass import pytest def test_submit_single_preference(): manager = UserPreferenceManager() manager.submit_preference(1, \\"movie_genre\\", \\"Action\\") assert manager.preferences == [(1, \\"movie_genre\\", \\"Action\\")] def test_top_preferences_one_entry(): manager = UserPreferenceManager() manager.submit_preference(1, \\"movie_genre\\", \\"Action\\") top_prefs = manager.get_top_preferences(\\"movie_genre\\") assert top_prefs == [\\"Action\\"] def test_top_preferences_multiple_entries(): manager = UserPreferenceManager() manager.submit_preference(1, \\"movie_genre\\", \\"Action\\") manager.submit_preference(2, \\"movie_genre\\", \\"Comedy\\") manager.submit_preference(3, \\"movie_genre\\", \\"Action\\") manager.submit_preference(4, \\"movie_genre\\", \\"Comedy\\") manager.submit_preference(5, \\"movie_genre\\", \\"Drama\\") manager.submit_preference(6, \\"movie_genre\\", \\"Horror\\") manager.submit_preference(7, \\"movie_genre\\", \\"Sci-Fi\\") top_prefs = manager.get_top_preferences(\\"movie_genre\\") assert top_prefs == [\\"Action\\", \\"Comedy\\", \\"Drama\\", \\"Horror\\", \\"Sci-Fi\\"] def test_top_preferences_tied_entries(): manager = UserPreferenceManager() manager.submit_preference(1, \\"movie_genre\\", \\"Action\\") manager.submit_preference(2, \\"movie_genre\\", \\"Comedy\\") manager.submit_preference(3, \\"movie_genre\\", \\"Action\\") manager.submit_preference(4, \\"movie_genre\\", \\"Comedy\\") manager.submit_preference(5, \\"movie_genre\\", \\"Drama\\") manager.submit_preference(6, \\"movie_genre\\", \\"Horror\\") manager.submit_preference(7, \\"movie_genre\\", \\"Sci-Fi\\") manager.submit_preference(8, \\"movie_genre\\", \\"Fantasy\\") top_prefs = manager.get_top_preferences(\\"movie_genre\\") assert top_prefs == [\\"Action\\", \\"Comedy\\", \\"Drama\\", \\"Horror\\", \\"Sci-Fi\\"] def test_top_preferences_less_than_five_entries(): manager = UserPreferenceManager() manager.submit_preference(1, \\"food_preference\\", \\"Pizza\\") manager.submit_preference(2, \\"food_preference\\", \\"Burger\\") top_prefs = manager.get_top_preferences(\\"food_preference\\") assert top_prefs == [\\"Pizza\\", \\"Burger\\"] def test_top_preferences_no_entries(): manager = UserPreferenceManager() top_prefs = manager.get_top_preferences(\\"non_existing_category\\") assert top_prefs == []","solution":"from collections import Counter class UserPreferenceManager: def __init__(self): self.preferences = [] def submit_preference(self, user_id, category, preference): Submit a user's preference for a specific category. self.preferences.append((user_id, category, preference)) def get_top_preferences(self, category): Get the top 5 most common preferences for the specified category. category_preferences = [pref[2] for pref in self.preferences if pref[1] == category] top_preferences = [item[0] for item in Counter(category_preferences).most_common(5)] return top_preferences"},{"question":"def toggle_case(s: str) -> str: Toggles the case of all alphabetic characters in the string s. >>> toggle_case(\\"Hello, World!\\") 'hELLO, wORLD!' >>> toggle_case(\\"Python 3.8\\") 'pYTHON 3.8' >>> toggle_case(\\"aBcDeF\\") 'AbCdEf' >>> toggle_case(\\"abcdef\\") 'ABCDEF' >>> toggle_case(\\"ABCDEF\\") 'abcdef' >>> toggle_case(\\" \\") ' ' >>> toggle_case(\\"!@#%^&*()\\") '!@#%^&*()' >>> toggle_case(\\"Hi There! It's 2023.\\") 'hI tHERE! iT'S 2023.'","solution":"def toggle_case(s: str) -> str: Toggles the case of all alphabetic characters in the string s. Args: s (str): The input string. Returns: str: A new string with the case of all alphabetic characters inverted. result = [] for char in s: if char.islower(): result.append(char.upper()) elif char.isupper(): result.append(char.lower()) else: result.append(char) return ''.join(result)"},{"question":"def is_valid_knight_move(start: str, end: str) -> bool: Determines if the move from 'start' to 'end' is a valid knight move in chess. Parameters: start (str): The starting position on the chessboard (e.g., \\"b1\\"). end (str): The ending position on the chessboard (e.g., \\"c3\\"). Returns: bool: True if the move is valid, False otherwise. >>> is_valid_knight_move(\\"b1\\", \\"c3\\") True >>> is_valid_knight_move(\\"g1\\", \\"e1\\") False","solution":"def is_valid_knight_move(start, end): Determines if the move from 'start' to 'end' is a valid knight move in chess. Parameters: start (str): The starting position on the chessboard (e.g., \\"b1\\"). end (str): The ending position on the chessboard (e.g., \\"c3\\"). Returns: bool: True if the move is valid, False otherwise. start_col, start_row = start[0], int(start[1]) end_col, end_row = end[0], int(end[1]) # Convert columns from letters to numbers (e.g., 'a' -> 1, 'b' -> 2, ..., 'h' -> 8) start_col = ord(start_col) - ord('a') + 1 end_col = ord(end_col) - ord('a') + 1 # Calculate the differences col_diff = abs(end_col - start_col) row_diff = abs(end_row - start_row) # A valid knight move is two squares in one direction and one square in the perpendicular direction return (col_diff == 2 and row_diff == 1) or (col_diff == 1 and row_diff == 2)"},{"question":"def rle_compress(data: str) -> str: Compresses the given string using Run-Length Encoding (RLE). Args: - data (str): The string to be compressed. Returns: - str: The compressed string. >>> rle_compress(\\"aaabbc\\") 'a3b2c1' >>> rle_compress(\\"a\\") 'a1' >>> rle_compress(\\"abcd\\") 'a1b1c1d1' >>> rle_compress(\\"aaaaaa\\") 'a6' >>> rle_compress(\\"\\") '' >>> rle_compress(\\"aabbcc\\") 'a2b2c2' >>> rle_compress(\\"abcdefghij\\") 'a1b1c1d1e1f1g1h1i1j1' def rle_decompress(encoded: str) -> str: Decompresses the given RLE string. Args: - encoded (str): The RLE encoded string. Returns: - str: The decompressed original string. >>> rle_decompress(\\"a3b2c1\\") 'aaabbc' >>> rle_decompress(\\"a1\\") 'a' >>> rle_decompress(\\"a1b1c1d1\\") 'abcd' >>> rle_decompress(\\"a6\\") 'aaaaaa' >>> rle_decompress(\\"\\") '' >>> rle_decompress(\\"a2b2c2\\") 'aabbcc' >>> rle_decompress(\\"a1b1c1d1e1f1g1h1i1j1\\") 'abcdefghij'","solution":"def rle_compress(data: str) -> str: Compresses the given string using Run-Length Encoding (RLE). Args: - data (str): The string to be compressed. Returns: - str: The compressed string. if not data: return \\"\\" compressed = [] count = 1 for i in range(1, len(data)): if data[i] == data[i - 1]: count += 1 else: compressed.append(data[i - 1] + str(count)) count = 1 compressed.append(data[-1] + str(count)) return ''.join(compressed) def rle_decompress(encoded: str) -> str: Decompresses the given RLE string. Args: - encoded (str): The RLE encoded string. Returns: - str: The decompressed original string. if not encoded: return \\"\\" decompressed = [] i = 0 while i < len(encoded): char = encoded[i] num = '' i += 1 while i < len(encoded) and encoded[i].isdigit(): num += encoded[i] i += 1 decompressed.append(char * int(num)) return ''.join(decompressed)"},{"question":"from typing import List def weighted_average(values: List[float], weights: List[float]) -> float: Calculate the weighted average of a list of numbers. Args: values: A list of float numbers representing the values to be averaged. weights: A list of float numbers representing the corresponding weights for each value. Returns: A float representing the weighted average. Raises: ValueError: If the values and weights lists are not of the same length or are empty. ZeroDivisionError: If the sum of weights is zero. Examples: >>> weighted_average([1.0, 2.0, 3.0], [0.2, 0.3, 0.5]) 2.3 >>> weighted_average([10, 20, 30], [1, 1, 1]) 20.0","solution":"from typing import List def weighted_average(values: List[float], weights: List[float]) -> float: if not values or not weights or len(values) != len(weights): raise ValueError(\\"Values and weights must be of the same length and non-empty.\\") total_weight = sum(weights) if total_weight == 0: raise ZeroDivisionError(\\"The sum of weights must be greater than zero.\\") weighted_sum = sum(value * weight for value, weight in zip(values, weights)) return weighted_sum / total_weight"},{"question":"class PageTracker: Write a class \`PageTracker\` that efficiently tracks page visits and provides the top \`k\` most visited pages. The class should include following methods: - \`visit(page: str) -> None\`: Records a visit to the given page URL. - \`top(k: int) -> list[str]\`: Returns a list of the top \`k\` most visited page URLs, ordered by visit frequency in descending order. If there are ties, return the URLs in lexicographical order. def __init__(self): self.visits = {} def visit(self, page: str) -> None: if page in self.visits: self.visits[page] += 1 else: self.visits[page] = 1 def top(self, k: int) -> list[str]: return [page for page, count in sorted(self.visits.items(), key=lambda item: (-item[1], item[0]))[:k]]","solution":"from collections import Counter class PageTracker: def __init__(self): self.visits = Counter() def visit(self, page: str) -> None: self.visits[page] += 1 def top(self, k: int) -> list[str]: sorted_pages = sorted(self.visits.items(), key=lambda item: (-item[1], item[0])) return [page for page, count in sorted_pages[:k]]"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums: List[int]) -> Optional[TreeNode]: Constructs a height-balanced binary search tree (BST) from a sorted array. Args: nums (List[int]): A sorted list of integers. Returns: TreeNode: The root node of the height-balanced BST. Example: >>> result = sorted_array_to_bst([-10, -3, 0, 5, 9]) >>> bst_to_list(result) [-10, -3, 0, 5, 9] >>> result = sorted_array_to_bst([1, 3]) >>> bst_to_list(result) [1, 3] pass def bst_to_list(root: TreeNode) -> List[int]: if not root: return [] return bst_to_list(root.left) + [root.val] + bst_to_list(root.right) def test_sorted_array_to_bst(): # Test Case 1: Basic case with 1 element nums = [1] root = sorted_array_to_bst(nums) assert bst_to_list(root) == nums # Test Case 2: Basic case with 2 elements nums = [1, 3] root = sorted_array_to_bst(nums) assert bst_to_list(root) == nums # Test Case 3: Basic case with 3 elements nums = [1, 2, 3] root = sorted_array_to_bst(nums) assert bst_to_list(root) == nums # Test Case 4: Larger set of elements nums = [-10, -3, 0, 5, 9] root = sorted_array_to_bst(nums) assert bst_to_list(root) == nums # Test Case 5: Case with no elements nums = [] root = sorted_array_to_bst(nums) assert root == None def test_balanced_property(): nums = [-10, -3, 0, 5, 9] root = sorted_array_to_bst(nums) def maxDepth(node): if not node: return 0 return max(maxDepth(node.left), maxDepth(node.right)) + 1 def minDepth(node): if not node: return 0 return min(minDepth(node.left), minDepth(node.right)) + 1 assert maxDepth(root) - minDepth(root) <= 1 def test_bst_property(): def is_bst(node, low=float('-inf'), high=float('inf')): if not node: return True if not (low < node.val < high): return False return is_bst(node.left, low, node.val) and is_bst(node.right, node.val, high) nums = [-10, -3, 0, 5, 9] root = sorted_array_to_bst(nums) assert is_bst(root)","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums: List[int]) -> Optional[TreeNode]: if not nums: return None # Find the middle element and use it as a root mid = len(nums) // 2 root = TreeNode(nums[mid]) # Recursively build the left and right subtrees root.left = sorted_array_to_bst(nums[:mid]) root.right = sorted_array_to_bst(nums[mid+1:]) return root"},{"question":"from typing import List def is_self_dividing(n: int) -> bool: Check if a number is self-dividing. >>> is_self_dividing(1) True >>> is_self_dividing(128) True >>> is_self_dividing(12) True >>> is_self_dividing(102) False >>> is_self_dividing(120) False def self_dividing_numbers(left: int, right: int) -> List[int]: Find all self-dividing numbers within the given range [left, right]. >>> self_dividing_numbers(1, 22) [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22] >>> self_dividing_numbers(1, 1) [1] >>> self_dividing_numbers(5, 6) [5, 6] >>> self_dividing_numbers(10, 20) [11, 12, 15] >>> self_dividing_numbers(21, 22) [22] >>> self_dividing_numbers(15, 15) [15]","solution":"from typing import List def is_self_dividing(n: int) -> bool: Check if a number is self-dividing. original = n while n > 0: digit = n % 10 if digit == 0 or original % digit != 0: return False n //= 10 return True def self_dividing_numbers(left: int, right: int) -> List[int]: Find all self-dividing numbers within the given range [left, right]. result = [] for num in range(left, right + 1): if is_self_dividing(num): result.append(num) return result"},{"question":"from typing import List, Tuple def flag_suspicious_transactions( transactions: List[Tuple[int, float, str]], threshold: float, days: int ) -> List[int]: Process a list of transactions to flag suspicious activities based on a defined threshold. Args: transactions (List[Tuple[int, float, str]]): A list of tuples representing transaction records. Each tuple contains an identifier (int), amount (float), and date (str in 'YYYY-MM-DD' format). threshold (float): The threshold amount for flagging suspicious transactions. days (int): The number of days within which the cumulative amount is considered for flagging. Returns: List[int]: A sorted list of unique transaction identifiers that are flagged as suspicious. Example: >>> transactions = [ ... (1, 100.0, '2023-10-01'), ... (1, 250.0, '2023-10-02'), ... (2, 300.0, '2023-10-01'), ... (2, 200.0, '2023-10-02'), ... (1, 200.0, '2023-10-03'), ... (3, 500.0, '2023-10-01'), ... ] >>> threshold = 500.0 >>> days = 2 >>> flag_suspicious_transactions(transactions, threshold, days) [1] pass # Unit tests def test_single_day_suspicious(): transactions = [ (1, 600.0, '2023-10-01'), (2, 400.0, '2023-10-01') ] assert flag_suspicious_transactions(transactions, 500.0, 1) == [1] def test_multiple_days_suspicious(): transactions = [ (1, 300.0, '2023-10-01'), (1, 300.0, '2023-10-02'), (2, 200.0, '2023-10-01'), (2, 400.0, '2023-10-02') ] assert flag_suspicious_transactions(transactions, 500.0, 2) == [1, 2] def test_no_suspicious_transactions(): transactions = [ (1, 200.0, '2023-10-01'), (2, 300.0, '2023-10-01') ] assert flag_suspicious_transactions(transactions, 500.0, 2) == [] def test_edge_case_threshold_equal(): transactions = [ (1, 500.0, '2023-10-01') ] assert flag_suspicious_transactions(transactions, 500.0, 1) == [] def test_large_transaction_amount(): transactions = [ (1, 1000.0, '2023-10-01'), (1, 3000.0, '2023-10-02'), (1, 100.0, '2023-10-03') ] assert flag_suspicious_transactions(transactions, 2000.0, 2) == [1] def test_edge_case_days_equal_to_transactions(): transactions = [ (1, 200.0, '2023-10-01'), (1, 300.0, '2023-10-01'), (2, 400.0, '2023-10-02'), (2, 600.0, '2023-10-03') ] assert flag_suspicious_transactions(transactions, 500.0, 1) == [2]","solution":"from typing import List, Tuple from collections import defaultdict from datetime import datetime, timedelta def flag_suspicious_transactions(transactions: List[Tuple[int, float, str]], threshold: float, days: int) -> List[int]: # Create a dictionary to store transaction sums for each identifier by date transaction_dict = defaultdict(lambda: defaultdict(float)) # Fill the dictionary with cumulative amounts for identifier, amount, date_str in transactions: date = datetime.strptime(date_str, \\"%Y-%m-%d\\") transaction_dict[identifier][date] += amount suspicious_identifiers = set() # For each identifier, check the sums in the specified timeframe for identifier, date_amounts in transaction_dict.items(): dates = sorted(date_amounts.keys()) # Check sums in the given range for i in range(len(dates)): current_sum = 0 for j in range(i, min(i + days, len(dates))): current_sum += date_amounts[dates[j]] if current_sum > threshold: suspicious_identifiers.add(identifier) break return sorted(suspicious_identifiers)"},{"question":"from typing import List def rotate_matrix_90(matrix: List[List[int]]) -> List[List[int]]: Rotates the given NxN matrix by 90 degrees clockwise. Args: matrix (List[List[int]]): A 2D list representing an NxN matrix of integers. Returns: List[List[int]]: A new NxN matrix representing the input matrix rotated 90 degrees clockwise. Examples: >>> rotate_matrix_90([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]] >>> rotate_matrix_90([ ... [1] ... ]) [[1]]","solution":"from typing import List def rotate_matrix_90(matrix: List[List[int]]) -> List[List[int]]: Rotates the given NxN matrix by 90 degrees clockwise. Args: matrix (List[List[int]]): A 2D list representing an NxN matrix of integers. Returns: List[List[int]]: A new NxN matrix representing the input matrix rotated 90 degrees clockwise. N = len(matrix) # Initialize the result matrix with 0s result = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): # Assign the value of matrix[i][j] to its new position after rotation result[j][N - 1 - i] = matrix[i][j] return result"},{"question":"def calculate_weighted_average(grades: dict[str, tuple[float, float]]) -> float: Calculates the weighted average of grades based on provided weights. Args: grades (dict): A dictionary where keys are the names of subjects and values are tuples containing the grade (float) and the weight (float) of each grade. Returns: float: The computed weighted average rounded to two decimal places. >>> grades = { ... 'Math': (85.0, 0.3), ... 'English': (90.0, 0.2), ... 'History': (78.0, 0.5) ... } >>> calculate_weighted_average(grades) 82.5 pass # Test cases grades1 = { 'Math': (85.0, 0.3), 'English': (90.0, 0.2), 'History': (78.0, 0.5) } assert calculate_weighted_average(grades1) == 82.5 grades2 = { 'Math': (70.0, 1.0) } assert calculate_weighted_average(grades2) == 70.0 grades3 = { 'Math': (70.0, 0.33), 'English': (80.0, 0.34), 'History': (90.0, 0.33) } assert calculate_weighted_average(grades3) == 80.0 grades4 = { 'Math': (75.0, 0.2), 'English': (65.0, 0.3), 'History': (85.0, 0.5) } assert calculate_weighted_average(grades4) == 77.0 grades5 = { 'Math': (85.0, 0.3), 'English': (90.0, 0.2), 'History': (78.0, 0.0) } assert calculate_weighted_average(grades5) == 87.0 grades6 = { 'Math': (85.0, 0.25), 'English': (92.0, 0.25), 'History': (88.0, 0.25), 'Science': (90.0, 0.25) } assert calculate_weighted_average(grades6) == 88.75","solution":"def calculate_weighted_average(grades): Calculates the weighted average of grades based on provided weights. Args: grades (dict): A dictionary where keys are the names of subjects and values are tuples containing the grade (float) and the weight (float) of each grade. Returns: float: The computed weighted average rounded to two decimal places. total_weight = 0.0 weighted_sum = 0.0 for subject, (grade, weight) in grades.items(): weighted_sum += grade * weight total_weight += weight weighted_average = weighted_sum / total_weight return round(weighted_average, 2)"},{"question":"def calculate_bonus(annual_salary: float, years_with_company: int) -> float: Calculates the annual bonus for an employee based on their annual salary and years with the company. Parameters: annual_salary (float): The annual salary of the employee. Must be greater than 0. years_with_company (int): The number of years the employee has been with the company. Must be a non-negative integer. Returns: float: The calculated annual bonus. Raises: ValueError: If annual_salary is  0 or years_with_company is < 0. >>> calculate_bonus(50000, 12) 5000.0 >>> calculate_bonus(40000, 7) 2000.0 >>> calculate_bonus(30000, 3) 600.0 >>> calculate_bonus(0, 3) Traceback (most recent call last): ... ValueError: Annual salary must be > 0 >>> calculate_bonus(50000, -1) Traceback (most recent call last): ... ValueError: Years with the company must be >= 0 >>> calculate_bonus(0.01, 5) 0.0002 >>> calculate_bonus(60000, 10) 3000.0 >>> calculate_bonus(45000, 5) 900.0 >>> calculate_bonus(1000000, 20) 100000.0","solution":"def calculate_bonus(annual_salary: float, years_with_company: int) -> float: Calculates the annual bonus for an employee based on their annual salary and years with the company. Parameters: annual_salary (float): The annual salary of the employee. Must be greater than 0. years_with_company (int): The number of years the employee has been with the company. Must be a non-negative integer. Returns: float: The calculated annual bonus. if annual_salary <= 0: raise ValueError(\\"Annual salary must be > 0\\") if years_with_company < 0: raise ValueError(\\"Years with the company must be >= 0\\") if years_with_company > 10: bonus = annual_salary * 0.10 elif 5 < years_with_company <= 10: bonus = annual_salary * 0.05 else: bonus = annual_salary * 0.02 return bonus"},{"question":"def can_finish_courses(num_courses, prerequisites): Determine if all courses can be finished given the prerequisite pairs. >>> can_finish_courses(2, []) == True >>> can_finish_courses(2, [[0, 1], [1, 0]]) == False >>> can_finish_courses(4, [[1, 0], [2, 1], [3, 2]]) == True >>> can_finish_courses(4, [[1, 0], [2, 1], [3, 2], [1, 3]]) == False >>> can_finish_courses(4, [[1, 0], [3, 2]]) == True >>> can_finish_courses(1, [[0, 0]]) == False >>> can_finish_courses(4, [[0, 1], [1, 0], [2, 3], [3, 2]]) == False pass","solution":"def can_finish_courses(num_courses, prerequisites): from collections import defaultdict # Create an adjacency list for the graph graph = defaultdict(list) for dest, src in prerequisites: graph[src].append(dest) # Track visit states: 0 = not visited, 1 = visiting, 2 = visited visit = [0] * num_courses def dfs(course): if visit[course] == 1: # currently visiting (cycle detected) return False if visit[course] == 2: # fully visited return True visit[course] = 1 # mark as currently visiting for neighbor in graph[course]: if not dfs(neighbor): return False visit[course] = 2 # mark as fully visited return True # Check each course for course in range(num_courses): if not dfs(course): return False return True"},{"question":"def min_edit_distance(str1: str, str2: str) -> int: Computes the minimum number of operations (insertion, deletion, substitution) required to transform str1 into str2. :param str1: The source string. :param str2: The target string. :return: The minimum number of operations needed to transform str1 into str2. pass # Example usage and test cases def test_min_edit_distance(): assert min_edit_distance(\\"kitten\\", \\"sitting\\") == 3 # Operation sequence: kitten -> sitten -> sittin -> sitting assert min_edit_distance(\\"flaw\\", \\"lawn\\") == 2 # Operation sequence: flaw -> law -> lawn assert min_edit_distance(\\"intention\\", \\"execution\\") == 5 # intention -> exenti -> exention -> execution assert min_edit_distance(\\"\\", \\"hello\\") == 5 # insert all characters of \\"hello\\" assert min_edit_distance(\\"hello\\", \\"\\") == 5 # delete all characters of \\"hello\\" assert min_edit_distance(\\"abc\\", \\"abc\\") == 0 # no operations needed assert min_edit_distance(\\"abc\\", \\"def\\") == 3 # replace all three characters assert min_edit_distance(\\"horse\\", \\"ros\\") == 3 # horse -> rorse -> rose -> ros assert min_edit_distance(\\"\\", \\"\\") == 0 # no operations needed for empty strings assert min_edit_distance(\\"a\\", \\"a\\") == 0 # no operations needed assert min_edit_distance(\\"a\\", \\"b\\") == 1 # one substitution needed assert min_edit_distance(\\"abcdef\\", \\"azced\\") == 3 # abcdef -> abcded -> azcded -> azced","solution":"def min_edit_distance(str1: str, str2: str) -> int: Computes the minimum number of operations (insertion, deletion, substitution) required to transform str1 into str2. :param str1: The source string. :param str2: The target string. :return: The minimum number of operations needed to transform str1 into str2. m, n = len(str1), len(str2) # Create a table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the first row and column of the DP table for i in range(m + 1): dp[i][0] = i # Minimum operations = i (all deletions) for j in range(n + 1): dp[0][j] = j # Minimum operations = j (all insertions) # Fill the DP table in bottom-up manner for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: # If characters match, no new operation needed dp[i][j] = dp[i - 1][j - 1] else: # Otherwise, consider all possibilities and find minimum insert_op = dp[i][j - 1] delete_op = dp[i - 1][j] replace_op = dp[i - 1][j - 1] dp[i][j] = 1 + min(insert_op, delete_op, replace_op) # The last cell of the table contains the answer return dp[m][n]"},{"question":"def first_non_repeated_integer(nums: list[int]) -> int: Returns the first non-repeated integer in the given list 'nums'. If all integers are repeated or the list is empty, returns None. >>> first_non_repeated_integer([4, 5, 1, 2, 0, 4]) 5 >>> first_non_repeated_integer([3, 3, 2, 2, 3, 4]) 4 >>> first_non_repeated_integer([1, 1, 1, 1]) None >>> first_non_repeated_integer([]) None","solution":"def first_non_repeated_integer(nums): Returns the first non-repeated integer in the given list 'nums'. If all integers are repeated or the list is empty, returns None. count_map = {} # First pass: count occurrences of each number for num in nums: if num in count_map: count_map[num] += 1 else: count_map[num] = 1 # Second pass: find the first number with single occurrence for num in nums: if count_map[num] == 1: return num return None"},{"question":"import threading class BankAccount: def __init__(self, account_id: int, initial_balance: float = 0.0): Initializes the bank account with a unique account ID and an initial balance. pass def deposit(self, amount: float) -> None: Adds the specified amount to the account balance. pass def withdraw(self, amount: float) -> bool: Subtracts the specified amount from the account balance if sufficient funds are available. pass def get_balance(self) -> float: Returns the current account balance. pass class Bank: def __init__(self): Initializes the bank with no accounts. pass def create_account(self, account_id: int, initial_balance: float = 0.0) -> None: Creates a new bank account with the given ID and initial balance. pass def get_account(self, account_id: int) -> BankAccount: Retrieves the BankAccount object corresponding to the given account ID. pass # Unit tests import pytest from threading import Thread def test_create_account(): bank = Bank() bank.create_account(1, 1000.0) account = bank.get_account(1) assert account is not None assert account.get_balance() == 1000.0 def test_deposit(): bank = Bank() bank.create_account(1, 1000.0) account = bank.get_account(1) account.deposit(500.0) assert account.get_balance() == 1500.0 def test_withdraw_success(): bank = Bank() bank.create_account(1, 1000.0) account = bank.get_account(1) result = account.withdraw(500.0) assert result is True assert account.get_balance() == 500.0 def test_withdraw_failure(): bank = Bank() bank.create_account(1, 1000.0) account = bank.get_account(1) result = account.withdraw(1500.0) assert result is False assert account.get_balance() == 1000.0 def test_thread_safety(): bank = Bank() bank.create_account(1, 1000.0) def deposit_funds(account_id, amount): account = bank.get_account(account_id) account.deposit(amount) def withdraw_funds(account_id, amount): account = bank.get_account(account_id) account.withdraw(amount) threads = [] threads.append(Thread(target=deposit_funds, args=(1, 500.0))) threads.append(Thread(target=withdraw_funds, args=(1, 200.0))) threads.append(Thread(target=withdraw_funds, args=(1, 500.0))) for thread in threads: thread.start() for thread in threads: thread.join() final_balance = bank.get_account(1).get_balance() assert final_balance == 800.0 # Expected final balance: 1000 + 500 - 200 - 500 + 500 if __name__ == \\"__main__\\": pytest.main()","solution":"import threading class BankAccount: def __init__(self, account_id: int, initial_balance: float = 0.0): self.account_id = account_id self.balance = initial_balance self.lock = threading.Lock() def deposit(self, amount: float) -> None: with self.lock: if amount >= 0: self.balance += amount def withdraw(self, amount: float) -> bool: with self.lock: if amount >= 0 and self.balance >= amount: self.balance -= amount return True return False def get_balance(self) -> float: with self.lock: return self.balance class Bank: def __init__(self): self.accounts = {} self.lock = threading.Lock() def create_account(self, account_id: int, initial_balance: float = 0.0) -> None: with self.lock: if account_id not in self.accounts: self.accounts[account_id] = BankAccount(account_id, initial_balance) def get_account(self, account_id: int) -> BankAccount: with self.lock: return self.accounts.get(account_id)"},{"question":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = Node(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = Node(value) else: self._insert(node.left, value) else: if node.right is None: node.right = Node(value) else: self._insert(node.right, value) def inorder_traversal(self): This function prints the values of the nodes in the binary tree using an inorder traversal. >>> bt = BinaryTree() >>> bt.insert(4) >>> bt.insert(2) >>> bt.insert(5) >>> bt.insert(1) >>> bt.insert(3) >>> bt.inorder_traversal() 1 2 3 4 5 def tree_height(self): This function returns the height of the binary tree. >>> bt = BinaryTree() >>> bt.insert(4) >>> bt.insert(2) >>> bt.insert(5) >>> bt.insert(1) >>> bt.insert(3) >>> bt.tree_height() 2 def is_balanced(self): This function checks if the binary tree is height-balanced. Returns True if the tree is balanced, False otherwise. >>> bt = BinaryTree() >>> bt.insert(4) >>> bt.insert(2) >>> bt.insert(5) >>> bt.insert(1) >>> bt.insert(3) >>> bt.is_balanced() True >>> bt.insert(6) >>> bt.is_balanced() True >>> bt.insert(0) >>> bt.is_balanced() False","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = Node(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = Node(value) else: self._insert(node.left, value) else: if node.right is None: node.right = Node(value) else: self._insert(node.right, value) def inorder_traversal(self): def _inorder_traversal(node): if node: _inorder_traversal(node.left) print(node.value, end=' ') _inorder_traversal(node.right) _inorder_traversal(self.root) print() def tree_height(self): def _tree_height(node): if node is None: return 0 left_height = _tree_height(node.left) right_height = _tree_height(node.right) return max(left_height, right_height) + 1 return _tree_height(self.root) - 1 def is_balanced(self): def _check_balance(node): if node is None: return 0, True left_height, left_balanced = _check_balance(node.left) right_height, right_balanced = _check_balance(node.right) current_height = max(left_height, right_height) + 1 current_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, current_balanced height, balanced = _check_balance(self.root) return balanced"},{"question":"def custom_string_reverser(input_str: str) -> str: Returns a string with alphabetic characters reversed and non-alphabetic characters in their original positions. Parameters: input_str (str): The input string containing both alphabetic and non-alphabetic characters. Returns: str: The resulting string with alphabetic characters reversed. Examples: >>> custom_string_reverser(\\"a,bc\\") 'c,ba' >>> custom_string_reverser(\\"Ab,c?!De\\") 'eD,c?!bA'","solution":"def custom_string_reverser(input_str: str) -> str: Returns a string with alphabetic characters reversed and non-alphabetic characters in their original positions Parameters: input_str (str): The input string containing both alphabetic and non-alphabetic characters Returns: str: The resulting string with alphabetic characters reversed Example: >>> custom_string_reverser(\\"a,bc\\") \\"c,ba\\" >>> custom_string_reverser(\\"Ab,c?!De\\") \\"eD,c?!bA\\" # Extract alphabetic characters and reverse them letters = [char for char in input_str if char.isalpha()] reversed_letters = letters[::-1] # Reconstruct the string with reversed letters and original non-alphabetic characters result = [] letter_index = 0 for char in input_str: if char.isalpha(): result.append(reversed_letters[letter_index]) letter_index += 1 else: result.append(char) return ''.join(result)"},{"question":"class Book: Represents a book in a library system. The Book class allows for checking availability, borrowing and returning the book. Attributes: title (str): The title of the book. author (str): The author of the book. isbn (str): The International Standard Book Number. genre (str): The genre of the book. available (bool): The availability status of the book, initially set to True. def __init__(self, title: str, author: str, isbn: str, genre: str): Initializes a new book instance with the title, author, ISBN and genre. Args: title (str): The title of the book. author (str): The author of the book. isbn (str): The International Standard Book Number. genre (str): The genre of the book. pass def is_available(self) -> bool: Checks if the book is available. Returns: bool: True if the book is available, False otherwise. Examples: >>> book = Book('1984', 'George Orwell', '978-0451524935', 'Dystopian') >>> book.is_available() True pass def borrow(self): Borrows the book, setting it to not available. Raises: ValueError: If the book is already borrowed. Examples: >>> book = Book('1984', 'George Orwell', '978-0451524935', 'Dystopian') >>> book.borrow() >>> book.is_available() False pass def return_book(self): Returns the book, setting it to available. Raises: ValueError: If the book is already available. Examples: >>> book = Book('1984', 'George Orwell', '978-0451524935', 'Dystopian') >>> book.borrow() >>> book.return_book() >>> book.is_available() True pass # Example usage b = Book('The Great Gatsby', 'F. Scott Fitzgerald', '978-0743273565', 'Fiction') print(b.is_available()) # Expected output: True b.borrow() print(b.is_available()) # Expected output: False # b.borrow() # Should raise ValueError: Book is already borrowed. b.return_book() print(b.is_available()) # Expected output: True","solution":"class Book: def __init__(self, title, author, isbn, genre): self.title = title self.author = author self.isbn = isbn self.genre = genre self.available = True def is_available(self): return self.available def borrow(self): if not self.available: raise ValueError(\\"Book is already borrowed.\\") self.available = False def return_book(self): if self.available: raise ValueError(\\"Book is already available.\\") self.available = True"},{"question":"class QueueWithStacks: def __init__(self): Initialize your data structure here. self.stack_push = [] self.stack_pop = [] def enqueue(self, x): Push element x to the back of queue. :type x: int :rtype: None >>> q = QueueWithStacks() >>> q.enqueue(1) >>> q.enqueue(2) >>> q.enqueue(3) >>> q.peek() 1 >>> q.dequeue() 1 >>> q.dequeue() 2 pass def dequeue(self): Removes the element from in front of queue and returns that element. :rtype: int >>> q = QueueWithStacks() >>> q.enqueue(1) >>> q.enqueue(2) >>> q.dequeue() 1 pass def peek(self): Get the front element. :rtype: int >>> q = QueueWithStacks() >>> q.enqueue(1) >>> q.enqueue(2) >>> q.peek() 1 pass","solution":"class QueueWithStacks: def __init__(self): self.stack_push = [] self.stack_pop = [] def enqueue(self, x): self.stack_push.append(x) def dequeue(self): if not self.stack_pop: while self.stack_push: self.stack_pop.append(self.stack_push.pop()) if not self.stack_pop: raise IndexError(\\"dequeue from empty queue\\") return self.stack_pop.pop() def peek(self): if not self.stack_pop: while self.stack_push: self.stack_pop.append(self.stack_push.pop()) if not self.stack_pop: raise IndexError(\\"peek from empty queue\\") return self.stack_pop[-1]"},{"question":"import numpy as np from sklearn.metrics import silhouette_score def calculate_silhouette_score(data, labels): Calculate the average silhouette score for the given clustered data. @param data: A 2D numpy array of shape (n_samples, n_features) containing the dataset. @param labels: A one-dimensional numpy array of length n_samples containing the cluster labels for each sample. @return: A float representing the average silhouette score of the clustered data. # Your code here pass def test_calculate_silhouette_score_basic(): data = np.array([[1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0]]) labels = np.array([0, 0, 1, 1, 0, 1]) result = calculate_silhouette_score(data, labels) expected_result = silhouette_score(data, labels) assert np.isclose(result, expected_result) def test_calculate_silhouette_score_with_two_clusters(): data = np.array([[1, 2], [2, 3], [10, 10], [12, 12]]) labels = np.array([0, 0, 1, 1]) result = calculate_silhouette_score(data, labels) expected_result = silhouette_score(data, labels) assert np.isclose(result, expected_result) def test_calculate_silhouette_score_invalid_data(): # Test for ValueError when length of data and labels don't match data = np.array([[1, 2], [2, 3], [10, 10], [12, 12]]) labels = np.array([0, 0, 1]) try: calculate_silhouette_score(data, labels) except ValueError as e: assert str(e) == \\"The data array should be at least 2x2 in dimensions and match the length of the labels array.\\" def test_calculate_silhouette_score_insufficient_data(): # Test for ValueError when data is less than 2x2 data = np.array([[1, 2]]) labels = np.array([0]) try: calculate_silhouette_score(data, labels) except ValueError as e: assert str(e) == \\"The data array should be at least 2x2 in dimensions and match the length of the labels array.\\"","solution":"from sklearn.metrics import silhouette_score import numpy as np def calculate_silhouette_score(data, labels): Calculate the average silhouette score for the given clustered data. @param data: A 2D numpy array of shape (n_samples, n_features) containing the dataset. @param labels: A one-dimensional numpy array of length n_samples containing the cluster labels for each sample. @return: A float representing the average silhouette score of the clustered data. if len(data) < 2 or len(data) != len(labels): raise ValueError(\\"The data array should be at least 2x2 in dimensions and match the length of the labels array.\\") return silhouette_score(data, labels)"},{"question":"from typing import List def largest_prime_factor(n: int, primes: List[int]) -> int: Returns the largest prime factor of n from the provided list of primes. If no prime from the list divides n, returns -1. >>> largest_prime_factor(56, [2, 3, 5, 7, 11, 13, 17]) == 7 >>> largest_prime_factor(30, [2, 3, 5, 7, 11, 13, 17]) == 5 >>> largest_prime_factor(97, [2, 3, 5, 7, 11, 13, 17]) == -1 >>> largest_prime_factor(1000000, [2, 3, 5, 7, 11, 31, 41, 61]) == 5 >>> largest_prime_factor(17, [2, 3, 5, 7, 11, 13, 17]) == 17 >>> largest_prime_factor(30, []) == -1","solution":"from typing import List def largest_prime_factor(n: int, primes: List[int]) -> int: Returns the largest prime factor of n from the provided list of primes. If no prime from the list divides n, returns -1. # Sorting primes in descending order to find the largest prime factor primes.sort(reverse=True) for prime in primes: if n % prime == 0: return prime return -1"},{"question":"[Finding Longest Common Prefix] # Problem Statement Create a function that finds the longest common prefix among a list of strings. # Function Signature def longest_common_prefix(strs: List[str]) -> str: This function takes a list of strings and returns the longest common prefix among the strings. If there's no common prefix, return an empty string. :param strs: A list of strings to find the common prefix. :return: The longest common prefix string. # Add your implementation here","solution":"from bisect import bisect_left, bisect_right class PriceRangeCounter: def __init__(self): Initializes an empty PriceRangeCounter. self.prices = [] def add_price(self, price: int) -> None: Adds a product price to the data structure. :param price: The price of the product to be added, -10^6 <= price <= 10^6. index = bisect_right(self.prices, price) self.prices.insert(index, price) def count_in_range(self, low: int, high: int) -> int: Returns the count of product prices within the given range [low, high]. :param low: The lower bound of the price range. :param high: The upper bound of the price range. :return: The count of product prices within the range [low, high]. left_index = bisect_left(self.prices, low) right_index = bisect_right(self.prices, high) return right_index - left_index"},{"question":"def find_combinations(target: int, numbers: list) -> list: Find all unique combinations of numbers in a list where the chosen numbers sum to a target value. >>> find_combinations(7, [2, 3, 6, 7]) [[2, 2, 3], [7]] >>> find_combinations(8, [2, 3, 5]) [[2, 2, 2, 2], [2, 3, 3], [3, 5]] >>> find_combinations(5, [2, 4]) [] >>> find_combinations(7, []) [] from solution import find_combinations def test_find_combinations_example_1(): assert find_combinations(7, [2, 3, 6, 7]) == [[2, 2, 3], [7]] def test_find_combinations_example_2(): assert find_combinations(8, [2, 3, 5]) == [[2, 2, 2, 2], [2, 3, 3], [3, 5]] def test_find_combinations_example_3(): assert find_combinations(5, [2, 4]) == [] def test_find_combinations_single_element(): assert find_combinations(7, [7]) == [[7]] def test_find_combinations_no_combinations(): assert find_combinations(1, [2, 3, 4]) == [] def test_find_combinations_multiple_ways(): assert find_combinations(6, [2, 3]) == [[2, 2, 2], [3, 3]] def test_find_combinations_large_numbers(): assert find_combinations(100, [25, 50, 75]) == [[25, 25, 25, 25], [25, 25, 50], [25, 75], [50, 50]] def test_find_combinations_edge_case_empty_list(): assert find_combinations(7, []) == []","solution":"def combination_sum(target, numbers, start, combination, result): Uses backtracking to find combinations of numbers that add up to the target sum. if target == 0: result.append(list(combination)) return elif target < 0: return for i in range(start, len(numbers)): num = numbers[i] combination.append(num) combination_sum(target - num, numbers, i, combination, result) combination.pop() def find_combinations(target, numbers): Finds all unique combinations of numbers from the list that sum up to the target value. result = [] combination = [] combination_sum(target, numbers, 0, combination, result) return result"},{"question":"def quick_sort(arr: list[int]) -> list[int]: Implements the QuickSort algorithm to sort a list in ascending order. >>> quick_sort([3, 6, 8, 10, 1, 2, 1]) [1, 1, 2, 3, 6, 8, 10] >>> quick_sort([5, 3, 8, 4, 2]) [2, 3, 4, 5, 8] >>> quick_sort([10, 7, 8, 9, 1, 5]) [1, 5, 7, 8, 9, 10] >>> quick_sort([]) [] >>> quick_sort([1]) [1] >>> quick_sort([2, 1]) [1, 2] >>> quick_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> quick_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> quick_sort([5, 3, 8, 8, 3, 4, 2, 2]) [2, 2, 3, 3, 4, 5, 8, 8] >>> quick_sort([1, 1, 1, 1, 1]) [1, 1, 1, 1, 1]","solution":"def quick_sort(arr: list[int]) -> list[int]: Implements the QuickSort algorithm to sort a list in ascending order. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"class CircularQueue: Circular Queue class with dynamic resizing. Methods: - __init__(self, initial_capacity: int): Initializes the circular queue with the given initial capacity. - enqueue(self, value: int) -> None: Adds an element to the end of the queue, resizing if necessary. - dequeue(self) -> int: Removes and returns an element from the front of the queue. Raises an exception if the queue is empty. - is_empty(self) -> bool: Returns True if the queue is empty, False otherwise. - is_full(self) -> bool: Returns True if the queue is full, False otherwise. - size(self) -> int: Returns the current number of elements in the queue. Example: >>> cq = CircularQueue(3) >>> cq.enqueue(1) >>> cq.enqueue(2) >>> cq.enqueue(3) >>> cq.is_full() True >>> cq.dequeue() 1 >>> cq.enqueue(4) >>> cq.is_full() True >>> cq.dequeue() 2 >>> cq.dequeue() 3 >>> cq.size() 1 >>> cq.dequeue() 4 >>> cq.is_empty() True def __init__(self, initial_capacity: int): pass def enqueue(self, value: int) -> None: pass def dequeue(self) -> int: pass def is_empty(self) -> bool: pass def is_full(self) -> bool: pass def size(self) -> int: pass def _resize(self, new_capacity: int) -> None: pass # Test cases if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"class CircularQueue: def __init__(self, initial_capacity: int): self.queue = [None] * initial_capacity self.capacity = initial_capacity self.front = 0 self.rear = 0 self.current_size = 0 def enqueue(self, value: int) -> None: if self.is_full(): self._resize(2 * self.capacity) self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.current_size += 1 def dequeue(self) -> int: if self.is_empty(): raise ValueError(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.current_size -= 1 if 0 < self.capacity // 4 > self.current_size: self._resize(self.capacity // 2) return value def is_empty(self) -> bool: return self.current_size == 0 def is_full(self) -> bool: return self.current_size == self.capacity def size(self) -> int: return self.current_size def _resize(self, new_capacity: int) -> None: new_queue = [None] * new_capacity for i in range(self.current_size): new_queue[i] = self.queue[(self.front + i) % self.capacity] self.queue = new_queue self.capacity = new_capacity self.front = 0 self.rear = self.current_size"},{"question":"class CircularBuffer: def __init__(self, size: int): Initialize the circular buffer with a fixed size. Args: size (int): The size of the buffer. pass def enqueue(self, value: int) -> None: Add an element to the end of the buffer. Args: value (int): The value to be added. pass def dequeue(self) -> int: Remove and return the oldest element from the buffer. Returns: int: The value removed from the buffer. pass def peek(self) -> int: Get the value of the oldest element without removing it. Returns: int: The value at the front of the buffer. pass def is_full(self) -> bool: Check if the buffer is full. Returns: bool: True if the buffer is full, otherwise False. pass def is_empty(self) -> bool: Check if the buffer is empty. Returns: bool: True if the buffer is empty, otherwise False. pass # Example usage and test cases buffer = CircularBuffer(3) buffer.enqueue(1) buffer.enqueue(2) buffer.enqueue(3) print(buffer.dequeue()) # Output: 1 print(buffer.peek()) # Output: 2 buffer.enqueue(4) print(buffer.is_full()) # Output: True print(buffer.dequeue()) # Output: 2 print(buffer.dequeue()) # Output: 3 print(buffer.dequeue()) # Output: 4 print(buffer.is_empty()) # Output: True buffer = CircularBuffer(2) buffer.enqueue(10) buffer.enqueue(20) print(buffer.is_full()) # Output: True buffer.enqueue(30) print(buffer.peek()) # Output: 20 print(buffer.dequeue()) # Output: 20 print(buffer.dequeue()) # Output: 30 print(buffer.is_empty()) # Output: True","solution":"class CircularBuffer: def __init__(self, size: int): Initialize the circular buffer with a fixed size. Args: size (int): The size of the buffer. self.size = size self.buffer = [None] * size self.head = 0 self.tail = 0 self.count = 0 def enqueue(self, value: int) -> None: Add an element to the end of the buffer. Args: value (int): The value to be added. if self.is_full(): # Overwrite the oldest data self.head = (self.head + 1) % self.size else: self.count += 1 self.buffer[self.tail] = value self.tail = (self.tail + 1) % self.size def dequeue(self) -> int: Remove and return the oldest element from the buffer. Returns: int: The value removed from the buffer. if self.is_empty(): raise IndexError(\\"Buffer is empty\\") value = self.buffer[self.head] self.buffer[self.head] = None self.head = (self.head + 1) % self.size self.count -= 1 return value def peek(self) -> int: Get the value of the oldest element without removing it. Returns: int: The value at the front of the buffer. if self.is_empty(): raise IndexError(\\"Buffer is empty\\") return self.buffer[self.head] def is_full(self) -> bool: Check if the buffer is full. Returns: bool: True if the buffer is full, otherwise False. return self.count == self.size def is_empty(self) -> bool: Check if the buffer is empty. Returns: bool: True if the buffer is empty, otherwise False. return self.count == 0"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates an n x n matrix by 90 degrees clockwise. >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]] >>> rotate_matrix([ ... [1] ... ]) [[1]]","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates an n x n matrix by 90 degrees clockwise. n = len(matrix) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): result[j][n-1-i] = matrix[i][j] return result"},{"question":"def stack_calculator(commands: list[str]) -> int: Simulates a miniature stack-based calculator. Args: commands (list[str]): A list of strings representing commands. Returns: int: The final top of the stack, or 0 if the stack is empty. >>> stack_calculator([\\"push 5\\", \\"push 3\\", \\"add\\", \\"push 2\\", \\"add\\"]) 10 >>> stack_calculator([\\"push 1\\", \\"push 2\\", \\"pop\\", \\"add\\"]) 1 >>> stack_calculator([\\"push 7\\", \\"push 8\\", \\"add\\", \\"pop\\"]) 0 pass # Unit tests def test_single_push(): assert stack_calculator([\\"push 5\\"]) == 5 def test_multiple_push(): assert stack_calculator([\\"push 5\\", \\"push 10\\"]) == 10 def test_push_and_pop(): assert stack_calculator([\\"push 5\\", \\"pop\\"]) == 0 def test_push_pop_and_add(): assert stack_calculator([\\"push 5\\", \\"push 3\\", \\"add\\"]) == 8 def test_complex_operations(): assert stack_calculator([\\"push 5\\", \\"push 3\\", \\"add\\", \\"push 2\\", \\"add\\"]) == 10 def test_not_enough_elements_add(): assert stack_calculator([\\"push 1\\", \\"add\\"]) == 1 def test_continuous_popping(): assert stack_calculator([\\"push 1\\", \\"pop\\", \\"pop\\", \\"pop\\"]) == 0 def test_empty_commands(): assert stack_calculator([]) == 0 def test_invalid_commands(): assert stack_calculator([\\"invalid\\", \\"push x\\", \\"add\\"]) == 0 # Should handle gracefully without exceptions def test_mixed_operations(): assert stack_calculator([\\"push 7\\", \\"push 8\\", \\"add\\", \\"pop\\"]) == 0 assert stack_calculator([\\"push 4\\", \\"push 5\\", \\"pop\\", \\"push 6\\", \\"add\\"]) == 10 def test_extra_pops_and_adds(): assert stack_calculator([\\"pop\\", \\"add\\", \\"push 1\\"]) == 1","solution":"def stack_calculator(commands): stack = [] for command in commands: if command.startswith(\\"push\\"): try: _, value = command.split() stack.append(int(value)) except ValueError: pass # Silently ignore invalid push commands elif command == \\"pop\\": if stack: stack.pop() elif command == \\"add\\": if len(stack) >= 2: a = stack.pop() b = stack.pop() stack.append(a + b) return stack[-1] if stack else 0"},{"question":"import math from typing import List, Dict def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: dot_product = sum(x * y for x, y in zip(vec1, vec2)) magnitude1 = math.sqrt(sum(x ** 2 for x in vec1)) magnitude2 = math.sqrt(sum(x ** 2 for x in vec2)) if magnitude1 == 0 or magnitude2 == 0: return 0 return dot_product / (magnitude1 * magnitude2) class SuggestionEngine: def __init__(self): Initialize your data structure here. def add_product(self, product_id: str, features: List[float]): Add the product and its features to the suggestion engine. Parameters: product_id (str): The unique identifier of the product. features (List[float]): The feature vector of the product. def recommend(self, viewed_products: List[str], top_k: int) -> List[str]: Recommend products similar to what the user has viewed. Parameters: viewed_products (List[str]): The list of product IDs that the user has viewed. top_k (int): The number of top recommendations to return. Returns: List[str]: The list of \`top_k\` product IDs recommended based on the similarity. # Example usage: # engine = SuggestionEngine() # engine.add_product(\\"product_1\\", [0.1, 0.2, 0.3]) # engine.add_product(\\"product_2\\", [0.4, 0.0, 0.5]) # engine.add_product(\\"product_3\\", [0.2, 0.3, 0.4]) # engine.add_product(\\"product_4\\", [0.6, 0.7, 0.8]) # recommended_products = engine.recommend([\\"product_1\\", \\"product_2\\"], 2) # print(recommended_products) # Output should be the most similar product IDs # Unit tests import pytest def test_add_product(): engine = SuggestionEngine() engine.add_product(\\"product_1\\", [0.1, 0.2, 0.3]) assert engine.product_features[\\"product_1\\"] == [0.1, 0.2, 0.3] def test_recommend_no_viewed_products(): engine = SuggestionEngine() engine.add_product(\\"product_1\\", [0.1, 0.2, 0.3]) engine.add_product(\\"product_2\\", [0.4, 0.5, 0.6]) recommendations = engine.recommend([], 2) assert recommendations == [] def test_recommend_single_viewed_product(): engine = SuggestionEngine() engine.add_product(\\"product_1\\", [0.1, 0.2, 0.3]) engine.add_product(\\"product_2\\", [0.4, 0.5, 0.6]) engine.add_product(\\"product_3\\", [0.1, 0.2, 0.4]) recommendations = engine.recommend([\\"product_1\\"], 2) assert recommendations == [\\"product_3\\", \\"product_2\\"] def test_recommend_multiple_viewed_products(): engine = SuggestionEngine() engine.add_product(\\"product_1\\", [0.1, 0.2, 0.3]) engine.add_product(\\"product_2\\", [0.4, 0.0, 0.5]) engine.add_product(\\"product_3\\", [0.2, 0.3, 0.4]) engine.add_product(\\"product_4\\", [0.6, 0.7, 0.8]) recommendations = engine.recommend([\\"product_1\\", \\"product_2\\"], 2) assert recommendations == [\\"product_3\\", \\"product_4\\"] def test_recommend_with_insufficient_products(): engine = SuggestionEngine() engine.add_product(\\"product_1\\", [0.1, 0.2, 0.3]) recommendations = engine.recommend([\\"product_1\\"], 2) assert recommendations == [] def test_recommend_with_exact_k(): engine = SuggestionEngine() engine.add_product(\\"product_1\\", [0.1, 0.2, 0.3]) engine.add_product(\\"product_2\\", [0.4, 0.0, 0.5]) engine.add_product(\\"product_3\\", [0.2, 0.3, 0.4]) recommendations = engine.recommend([\\"product_1\\"], 2) assert recommendations == [\\"product_3\\", \\"product_2\\"]","solution":"import math from typing import List, Dict def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: dot_product = sum(x * y for x, y in zip(vec1, vec2)) magnitude1 = math.sqrt(sum(x ** 2 for x in vec1)) magnitude2 = math.sqrt(sum(x ** 2 for x in vec2)) if magnitude1 == 0 or magnitude2 == 0: return 0.0 return dot_product / (magnitude1 * magnitude2) class SuggestionEngine: def __init__(self): self.product_features: Dict[str, List[float]] = {} def add_product(self, product_id: str, features: List[float]): self.product_features[product_id] = features def recommend(self, viewed_products: List[str], top_k: int) -> List[str]: viewed_features = [self.product_features[pid] for pid in viewed_products if pid in self.product_features] if not viewed_features: return [] avg_viewed_features = [sum(feat) / len(viewed_features) for feat in zip(*viewed_features)] similarity_scores = [] for pid, features in self.product_features.items(): if pid not in viewed_products: similarity = cosine_similarity(avg_viewed_features, features) similarity_scores.append((pid, similarity)) similarity_scores.sort(key=lambda x: x[1], reverse=True) return [pid for pid, _ in similarity_scores[:top_k]]"},{"question":"from typing import Tuple def resize_image(original_width: int, original_height: int, new_width: int = None, new_height: int = None) -> Tuple[int, int]: Calculate the new dimensions of the image while maintaining the original aspect ratio. Args: - original_width (int): Original width of the image. - original_height (int): Original height of the image. - new_width (int, optional): New width of the image. Defaults to None. - new_height (int, optional): New height of the image. Defaults to None. Returns: - tuple: New dimensions (width, height) of the image maintaining the original aspect ratio. Raises: - ValueError: If both new_width and new_height are provided or both are None. Examples: >>> resize_image(1920, 1080, new_width=960) (960, 540) >>> resize_image(1920, 1080, new_height=540) (960, 540) >>> resize_image(400, 300, new_width=200) (200, 150) >>> resize_image(400, 300, new_height=150) (200, 150) >>> resize_image(1920, 1080) Traceback (most recent call last): ... ValueError: Either new_width or new_height must be provided, but not both. pass # Code to be implemented def test_resize_image_by_width(): assert resize_image(1920, 1080, new_width=960) == (960, 540) assert resize_image(400, 300, new_width=200) == (200, 150) assert resize_image(800, 600, new_width=400) == (400, 300) def test_resize_image_by_height(): assert resize_image(1920, 1080, new_height=540) == (960, 540) assert resize_image(400, 300, new_height=150) == (200, 150) assert resize_image(800, 600, new_height=300) == (400, 300) def test_resize_image_invalid_input(): try: resize_image(1920, 1080) except ValueError as e: assert str(e) == \\"Either new_width or new_height must be provided, but not both.\\" try: resize_image(1920, 1080, new_width=960, new_height=540) except ValueError as e: assert str(e) == \\"Either new_width or new_height must be provided, but not both.\\" def test_resize_image_non_integer_result(): assert resize_image(800, 333, new_width=400) == (400, 166) assert resize_image(333, 800, new_height=400) == (166, 400)","solution":"def resize_image(original_width: int, original_height: int, new_width: int = None, new_height: int = None) -> tuple: Calculate the new dimensions of the image while maintaining the original aspect ratio. Args: - original_width (int): Original width of the image. - original_height (int): Original height of the image. - new_width (int, optional): New width of the image. Defaults to None. - new_height (int, optional): New height of the image. Defaults to None. Returns: - tuple: New dimensions (width, height) of the image maintaining the original aspect ratio. Raises: - ValueError: If both new_width and new_height are provided or both are None. if (new_width is None and new_height is None) or (new_width is not None and new_height is not None): raise ValueError(\\"Either new_width or new_height must be provided, but not both.\\") if new_width is not None: new_height = int((new_width / original_width) * original_height) return (new_width, new_height) if new_height is not None: new_width = int((new_height / original_height) * original_width) return (new_width, new_height)"},{"question":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeClassifier def train_weather_model(csv_file: str) -> DecisionTreeClassifier: Train a decision tree classifier on the historical weather data. Parameters: csv_file (str): Path to the CSV file containing historical weather data. Returns: DecisionTreeClassifier: Trained Decision Tree model. pass def predict_weather(model: DecisionTreeClassifier, input_data: dict) -> str: Predict the weather condition for the given input data. Parameters: model (DecisionTreeClassifier): Trained Decision Tree model. input_data (dict): Dictionary containing 'temperature', 'humidity', and 'wind_speed'. Returns: str: Predicted weather condition. pass # Example Usage if __name__ == \\"__main__\\": model = train_weather_model(\\"historical_weather_data.csv\\") next_day_weather = {'temperature': 25, 'humidity': 60, 'wind_speed': 15} predicted_condition = predict_weather(model, next_day_weather) print(predicted_condition) # Outputs: 'sunny' or 'rainy' or 'cloudy'","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeClassifier from sklearn.metrics import accuracy_score def train_weather_model(csv_file: str) -> DecisionTreeClassifier: Train a decision tree classifier on the historical weather data. Parameters: csv_file (str): Path to the CSV file containing historical weather data. Returns: DecisionTreeClassifier: Trained Decision Tree model. # Load the dataset from the CSV file data = pd.read_csv(csv_file) # Extract features and target variable features = data[['temperature', 'humidity', 'wind_speed']] target = data['weather_condition'] # Split the data into training and validation sets X_train, X_val, y_train, y_val = train_test_split(features, target, test_size=0.2, random_state=42) # Initialize the Decision Tree Classifier model = DecisionTreeClassifier(random_state=42) # Train the model model.fit(X_train, y_train) # Validate the model y_pred = model.predict(X_val) accuracy = accuracy_score(y_val, y_pred) print(f\\"Validation Accuracy: {accuracy:.2f}\\") return model def predict_weather(model: DecisionTreeClassifier, input_data: dict) -> str: Predict the weather condition for the given input data. Parameters: model (DecisionTreeClassifier): Trained Decision Tree model. input_data (dict): Dictionary containing 'temperature', 'humidity', and 'wind_speed'. Returns: str: Predicted weather condition. # Convert input data dictionary to DataFrame input_df = pd.DataFrame([input_data]) # Predict the weather condition prediction = model.predict(input_df) return prediction[0]"},{"question":"from typing import List, Tuple def top_n_frequent_words(documents: List[str], N: int) -> List[Tuple[str, int]]: Returns the top N most frequent words across a list of documents. >>> documents1 = [ ... \\"The quick brown fox jumps over the lazy dog\\", ... \\"The dog is quick and the fox is jumped over by the dog\\" ... ] >>> top_n_frequent_words(documents1, 3) [('the', 5), ('dog', 3), ('fox', 2)] >>> documents2 = [ ... \\"Lorem ipsum dolor sit amet, consectetur adipiscing elit\\", ... \\"Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua\\", ... \\"Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat\\" ... ] >>> top_n_frequent_words(documents2, 5) [('ut', 3), ('ad', 2), ('dolor', 2), ('ipsum', 2), ('labore', 2)] pass","solution":"from collections import Counter import re def top_n_frequent_words(documents: list[str], N: int) -> list[tuple[str, int]]: Returns the top N most frequent words across a list of documents. word_counts = Counter() for doc in documents: words = re.findall(r'bw+b', doc.lower()) word_counts.update(words) most_common_words = word_counts.most_common() most_common_words.sort(key=lambda x: (-x[1], x[0])) return most_common_words[:N]"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Given an array of integers, return an array such that each element at index \`i\` is the product of all the elements in the original array except the one at \`i\`, without using division and in O(n) time complexity. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 1, 2, 3]) [6, 0, 0, 0] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> product_except_self([5, 6, 2, 3]) [36, 30, 90, 60]","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: n = len(nums) # Initialize two arrays to keep track of the prefix and suffix products left_products = [1] * n right_products = [1] * n # Compute the prefix products for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Compute the suffix products for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Compute the result by multiplying the corresponding entries from the two arrays result = [1] * n for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def sort_teams_by_scores(team_scores: dict) -> list: Sort teams based on their average scores. Parameters: - team_scores (dict): A dictionary where keys are team names (str) and values are lists of match scores (list of integers). Returns: - list: A sorted list of tuples, each containing the team name (str) and their average score (float), in the specified order. Example Usage: >>> sort_teams_by_scores({\\"TeamA\\": [10, 20, 30], \\"TeamB\\": [20, 30], \\"TeamC\\": [30, 40, 10]}) [('TeamC', 26.67), ('TeamA', 20.0), ('TeamB', 25.0)] >>> sort_teams_by_scores({\\"TeamAlpha\\": [75, 85, 95], \\"TeamBeta\\": [60, 70, 80], \\"TeamGamma\\": [80, 60, 70]}) [('TeamAlpha', 85.0), ('TeamGamma', 70.0), ('TeamBeta', 70.0)]","solution":"def sort_teams_by_scores(team_scores: dict) -> list: Sort teams based on their average scores. Parameters: - team_scores (dict): A dictionary where keys are team names (str) and values are lists of match scores (list of integers). Returns: - list: A sorted list of tuples, each containing the team name (str) and their average score (float), in the specified order. # Calculate average scores averages = [(team, sum(scores) / len(scores)) for team, scores in team_scores.items()] # Sort by average score (desc) then by team name (asc) sorted_teams = sorted(averages, key=lambda x: (-x[1], x[0])) # Round scores to 2 decimal places sorted_teams = [(team, round(avg, 2)) for team, avg in sorted_teams] return sorted_teams"},{"question":"def rotate_array(arr: list, rotations: int) -> list: Rotates the array to the right by a given number of rotations. >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([0, -1, -2, -3, -4], 3) [-2, -3, -4, 0, -1] >>> rotate_array([7, 8, 9], 10) [8, 9, 7] >>> rotate_array([11, 12, 13, 14], 0) [11, 12, 13, 14]","solution":"def rotate_array(arr, rotations): Rotates the array to the right by a given number of rotations. Parameters: arr (list): A non-empty list of integers. rotations (int): A non-negative integer representing the number of rotations. Returns: list: The rotated array. if not arr: raise ValueError(\\"The array must not be empty.\\") if not isinstance(rotations, int) or rotations < 0: raise ValueError(\\"The number of rotations must be a non-negative integer.\\") n = len(arr) rotations = rotations % n # to handle cases where rotations > n if rotations == 0: return arr return arr[-rotations:] + arr[:-rotations]"},{"question":"def is_prime(n: int) -> bool: Returns True if n is a prime number, else False. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(131) True >>> is_prime(133) False >>> is_prime(1) False >>> is_prime(0) False >>> is_prime(-5) False def is_palindrome(n: int) -> bool: Returns True if n is a palindrome, else False. >>> is_palindrome(2) True >>> is_palindrome(3) True >>> is_palindrome(131) True >>> is_palindrome(133) False >>> is_palindrome(727) True >>> is_palindrome(123) False def palindromic_prime(n: int) -> bool: Returns True if n is both a prime and a palindrome. >>> palindromic_prime(2) True >>> palindromic_prime(3) True >>> palindromic_prime(131) True >>> palindromic_prime(133) False >>> palindromic_prime(727) True >>> palindromic_prime(4) False >>> palindromic_prime(11) True >>> palindromic_prime(101) True","solution":"def is_prime(n: int) -> bool: Returns True if n is a prime number, else False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_palindrome(n: int) -> bool: Returns True if n is a palindrome, else False. return str(n) == str(n)[::-1] def palindromic_prime(n: int) -> bool: Returns True if n is both a prime and a palindrome. return is_prime(n) and is_palindrome(n)"},{"question":"class TextEditor: A text editor class that supports insert, delete, and find operations. Methods: - __init__(self): Initialize the text editor with an empty string. - insert(self, pos: int, S: str) -> None: Insert the substring S at position pos. - delete(self, pos: int, length: int) -> str: Delete the substring of given length starting from position pos, and return the deleted substring. - find(self, pos: int, length: int) -> str: Return the substring of given length starting from position pos. >>> editor = TextEditor() >>> editor.insert(0, \\"Hello\\") >>> editor.insert(5, \\" World\\") >>> editor.find(0, 11) 'Hello World' >>> editor.delete(5, 1) ' ' >>> editor.find(0, 10) 'HelloWorld' >>> editor.insert(5, \\" Beautiful\\") >>> editor.find(0, 19) 'Hello BeautifulWorld' def __init__(self): pass def insert(self, pos: int, S: str) -> None: pass def delete(self, pos: int, length: int) -> str: pass def find(self, pos: int, length: int) -> str: pass # Unit tests import pytest def test_insert(): editor = TextEditor() editor.insert(0, \\"Hello\\") assert editor.text == \\"Hello\\" editor.insert(5, \\" World\\") assert editor.text == \\"Hello World\\" def test_delete(): editor = TextEditor() editor.insert(0, \\"Hello World\\") deleted_text = editor.delete(5, 1) assert deleted_text == \\" \\" assert editor.text == \\"HelloWorld\\" def test_find(): editor = TextEditor() editor.insert(0, \\"Hello World\\") assert editor.find(0, 5) == \\"Hello\\" assert editor.find(6, 5) == \\"World\\" def test_insert_invalid_position(): editor = TextEditor() with pytest.raises(ValueError): editor.insert(10, \\"Hello\\") def test_delete_invalid_position(): editor = TextEditor() with pytest.raises(ValueError): editor.delete(10, 1) def test_find_invalid_position(): editor = TextEditor() with pytest.raises(ValueError): editor.find(10, 1) def test_delete_invalid_length(): editor = TextEditor() editor.insert(0, \\"Hello\\") with pytest.raises(ValueError): editor.delete(3, 10) def test_find_invalid_length(): editor = TextEditor() editor.insert(0, \\"Hello\\") with pytest.raises(ValueError): editor.find(3, 10)","solution":"class TextEditor: def __init__(self): self.text = \\"\\" def insert(self, pos: int, S: str) -> None: if pos < 0 or pos > len(self.text): raise ValueError(\\"Position out of range.\\") self.text = self.text[:pos] + S + self.text[pos:] def delete(self, pos: int, length: int) -> str: if pos < 0 or pos >= len(self.text): raise ValueError(\\"Position out of range.\\") if length < 0 or pos + length > len(self.text): raise ValueError(\\"Length out of range.\\") deleted_substring = self.text[pos:pos+length] self.text = self.text[:pos] + self.text[pos+length:] return deleted_substring def find(self, pos: int, length: int) -> str: if pos < 0 or pos >= len(self.text): raise ValueError(\\"Position out of range.\\") if length < 0 or pos + length > len(self.text): raise ValueError(\\"Length out of range.\\") return self.text[pos:pos+length]"},{"question":"from typing import List def xor_sum(arr: List[int]) -> int: Returns the sum of the bitwise XOR of all pairs (i, j) where i < j in the array arr. Args: arr (List[int]): List of integers. Returns: int: The sum of XORs of all unique pairs. Examples: >>> xor_sum([1, 2, 3]) 6 >>> xor_sum([1, 1, 1]) 0 >>> xor_sum([4, 5, 7]) 6 pass","solution":"from typing import List def xor_sum(arr: List[int]) -> int: Returns the sum of the bitwise XOR of all pairs (i, j) where i < j in the array arr. total_sum = 0 n = len(arr) for i in range(n): for j in range(i + 1, n): total_sum += arr[i] ^ arr[j] return total_sum"},{"question":"def merge_sorted_arrays(arr1: list[int], m: int, arr2: list[int], n: int) -> None: Merges two sorted arrays into a single sorted array in place in arr1. :param arr1: First sorted array of integers with extra space to accommodate arr2 :param m: Number of initial elements in arr1 :param arr2: Second sorted array of integers :param n: Number of elements in arr2 pass def test_merge_sorted_arrays_example_case_1(): arr1 = [1, 2, 3, 0, 0, 0] arr2 = [2, 5, 6] merge_sorted_arrays(arr1, 3, arr2, 3) assert arr1 == [1, 2, 2, 3, 5, 6] def test_merge_sorted_arrays_example_case_2(): arr1 = [1, 2, 4, 5, 6, 0] arr2 = [3] merge_sorted_arrays(arr1, 5, arr2, 1) assert arr1 == [1, 2, 3, 4, 5, 6] def test_merge_sorted_arrays_example_case_3(): arr1 = [2, 0] arr2 = [1] merge_sorted_arrays(arr1, 1, arr2, 1) assert arr1 == [1, 2] def test_merge_sorted_arrays_edge_case_empty_arr2(): arr1 = [1, 2, 3] arr2 = [] merge_sorted_arrays(arr1, 3, arr2, 0) assert arr1 == [1, 2, 3] def test_merge_sorted_arrays_edge_case_empty_arr1(): arr1 = [0, 0, 0] arr2 = [1, 2, 3] merge_sorted_arrays(arr1, 0, arr2, 3) assert arr1 == [1, 2, 3] def test_merge_sorted_arrays_with_duplicates(): arr1 = [2, 2, 3, 0, 0, 0] arr2 = [2, 5, 6] merge_sorted_arrays(arr1, 3, arr2, 3) assert arr1 == [2, 2, 2, 3, 5, 6]","solution":"def merge_sorted_arrays(arr1: list[int], m: int, arr2: list[int], n: int) -> None: Merges two sorted arrays into a single sorted array in place in arr1. :param arr1: First sorted array of integers with extra space to accommodate arr2 :param m: Number of initial elements in arr1 :param arr2: Second sorted array of integers :param n: Number of elements in arr2 # Index for the last element in arr1's initial elements i = m - 1 # Index for the last element in arr2 j = n - 1 # Index for the last position in arr1 k = m + n - 1 # Start merging from the end of the arrays while i >= 0 and j >= 0: if arr1[i] > arr2[j]: arr1[k] = arr1[i] i -= 1 else: arr1[k] = arr2[j] j -= 1 k -= 1 # If there are remaining elements in arr2, copy them over while j >= 0: arr1[k] = arr2[j] k -= 1 j -= 1"},{"question":"class BookmarkManager: Manage bookmarks with functionalities to add, retrieve and search bookmarks by name. >>> manager = BookmarkManager() >>> manager.add_bookmark(\\"First Bookmark\\", \\"http://example.com\\", \\"2023-10-01\\") >>> manager.add_bookmark(\\"Second Bookmark\\", \\"http://example.org\\", \\"2023-10-02\\") >>> manager.add_bookmark(\\"Third Bookmark\\", \\"http://example.net\\", \\"2023-09-30\\") >>> manager.get_all_bookmarks() [ {\\"name\\": \\"Second Bookmark\\", \\"url\\": \\"http://example.org\\", \\"date_added\\": \\"2023-10-02\\"}, {\\"name\\": \\"First Bookmark\\", \\"url\\": \\"http://example.com\\", \\"date_added\\": \\"2023-10-01\\"}, {\\"name\\": \\"Third Bookmark\\", \\"url\\": \\"http://example.net\\", \\"date_added\\": \\"2023-09-30\\"} ] >>> manager.search_bookmark(\\"First Bookmark\\") {\\"name\\": \\"First Bookmark\\", \\"url\\": \\"http://example.com\\", \\"date_added\\": \\"2023-10-01\\"} >>> manager.search_bookmark(\\"Nonexistent Bookmark\\") {} def __init__(self): pass def add_bookmark(self, name: str, url: str, date_added: str) -> None: pass def get_all_bookmarks(self) -> list: pass def search_bookmark(self, name: str) -> dict: pass # Unit tests def test_add_and_get_all_bookmarks(): bm = BookmarkManager() bm.add_bookmark(\\"First Bookmark\\", \\"http://example.com\\", \\"2023-10-01\\") bm.add_bookmark(\\"Second Bookmark\\", \\"http://example.org\\", \\"2023-10-02\\") bm.add_bookmark(\\"Third Bookmark\\", \\"http://example.net\\", \\"2023-09-30\\") bookmarks = bm.get_all_bookmarks() assert bookmarks == [ {\\"name\\": \\"Second Bookmark\\", \\"url\\": \\"http://example.org\\", \\"date_added\\": \\"2023-10-02\\"}, {\\"name\\": \\"First Bookmark\\", \\"url\\": \\"http://example.com\\", \\"date_added\\": \\"2023-10-01\\"}, {\\"name\\": \\"Third Bookmark\\", \\"url\\": \\"http://example.net\\", \\"date_added\\": \\"2023-09-30\\"}, ] def test_search_bookmark(): bm = BookmarkManager() bm.add_bookmark(\\"First Bookmark\\", \\"http://example.com\\", \\"2023-10-01\\") bm.add_bookmark(\\"Second Bookmark\\", \\"http://example.org\\", \\"2023-10-02\\") result = bm.search_bookmark(\\"First Bookmark\\") assert result == {\\"name\\": \\"First Bookmark\\", \\"url\\": \\"http://example.com\\", \\"date_added\\": \\"2023-10-01\\"} result = bm.search_bookmark(\\"Nonexistent Bookmark\\") assert result == {} def test_add_bookmark_with_similar_names_but_different_dates(): bm = BookmarkManager() bm.add_bookmark(\\"Bookmark\\", \\"http://example.com/1\\", \\"2023-10-01\\") bm.add_bookmark(\\"Bookmark\\", \\"http://example.com/2\\", \\"2023-10-02\\") bookmarks = bm.get_all_bookmarks() assert bookmarks == [ {\\"name\\": \\"Bookmark\\", \\"url\\": \\"http://example.com/2\\", \\"date_added\\": \\"2023-10-02\\"}, {\\"name\\": \\"Bookmark\\", \\"url\\": \\"http://example.com/1\\", \\"date_added\\": \\"2023-10-01\\"}, ] assert len(bookmarks) == 2 def test_edge_cases(): bm = BookmarkManager() # Test no bookmarks bookmarks = bm.get_all_bookmarks() assert bookmarks == [] # Test searching in empty bookmarks result = bm.search_bookmark(\\"No Bookmark\\") assert result == {}","solution":"class BookmarkManager: def __init__(self): self.bookmarks = [] def add_bookmark(self, name: str, url: str, date_added: str) -> None: self.bookmarks.append({\\"name\\": name, \\"url\\": url, \\"date_added\\": date_added}) def get_all_bookmarks(self) -> list: return sorted(self.bookmarks, key=lambda b: b[\\"date_added\\"], reverse=True) def search_bookmark(self, name: str) -> dict: for bookmark in self.bookmarks: if bookmark[\\"name\\"] == name: return bookmark return {}"},{"question":"def sum_first_n_primes(n: int) -> str: Calculate the sum of the first \`n\` prime numbers. >>> sum_first_n_primes(5) 'The sum of the first 5 primes is 28' >>> sum_first_n_primes(0) 'Error: n should be a positive integer' >>> sum_first_n_primes(-3) 'Error: n should be a positive integer' >>> sum_first_n_primes(1) 'The sum of the first 1 primes is 2' >>> sum_first_n_primes(2) 'The sum of the first 2 primes is 5' >>> sum_first_n_primes(10) 'The sum of the first 10 primes is 129'","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def sum_first_n_primes(n: int) -> str: if n <= 0: return \\"Error: n should be a positive integer\\" count = 0 num = 2 prime_sum = 0 while count < n: if is_prime(num): prime_sum += num count += 1 num += 1 return f\\"The sum of the first {n} primes is {prime_sum}\\""},{"question":"def validate_parentheses(expression: str) -> bool: Checks whether the parentheses in the given expression are balanced. >>> validate_parentheses(\\"((a+b)*c)\\") True >>> validate_parentheses(\\"((a+b)*c\\") False >>> validate_parentheses(\\"a+b)\\") False >>> validate_parentheses(\\"a+(b*(c/d))\\") True >>> validate_parentheses(\\"()\\") True >>> validate_parentheses(\\")(\\") False from solution import validate_parentheses def test_validate_parentheses_balanced(): assert validate_parentheses(\\"((a+b)*c)\\") == True assert validate_parentheses(\\"a+(b*(c/d))\\") == True assert validate_parentheses(\\"()\\") == True def test_validate_parentheses_unbalanced(): assert validate_parentheses(\\"((a+b)*c\\") == False assert validate_parentheses(\\"a+b)\\") == False assert validate_parentheses(\\")(\\") == False def test_validate_parentheses_empty_string(): assert validate_parentheses(\\"\\") == True def test_validate_parentheses_no_parentheses(): assert validate_parentheses(\\"a+b*c-d/e\\") == True assert validate_parentheses(\\"123456\\") == True def test_validate_parentheses_complex_cases(): assert validate_parentheses(\\"((a+(b*c)-d)/e)\\") == True assert validate_parentheses(\\"((a+b)*(c-(d/e))\\") == False assert validate_parentheses(\\"(a+b)*(c-(d/e))\\") == True","solution":"def validate_parentheses(expression: str) -> bool: Checks whether the parentheses in the given expression are balanced. stack = [] for char in expression: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"from typing import List def wordBreakCombinations(s: str, wordDict: List[str]) -> List[str]: Find all possible word break combinations of given string using given set of words. >>> wordBreakCombinations(\\"catsanddog\\", [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]) [\\"cat sand dog\\", \\"cats and dog\\"] >>> wordBreakCombinations(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) [\\"pine apple pen apple\\", \\"pineapple pen apple\\", \\"pine applepen apple\\"] >>> wordBreakCombinations(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) [] >>> wordBreakCombinations(\\"\\", [\\"cat\\", \\"dog\\"]) [\\"\\"] >>> wordBreakCombinations(\\"cat\\", [\\"cat\\"]) [\\"cat\\"] >>> wordBreakCombinations(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) [\\"apple pen apple\\"]","solution":"from typing import List def wordBreakCombinations(s: str, wordDict: List[str]) -> List[str]: word_set = set(wordDict) memo = {} def backtrack(start: int) -> List[str]: if start in memo: return memo[start] if start == len(s): return [\\"\\"] partitions = [] for end in range(start + 1, len(s) + 1): word = s[start:end] if word in word_set: for sub_partition in backtrack(end): if sub_partition: partitions.append(word + \\" \\" + sub_partition) else: partitions.append(word) memo[start] = partitions return partitions return backtrack(0)"},{"question":"def search_rotated_array(nums, target): Search for a target value in a rotated sorted array. @param nums: a list of distinct integers which has been sorted and then rotated. @param target: an integer target to search for in the list. @return: the index of the target if found, otherwise -1. # Your code here pass # Example Input: nums = [4, 5, 6, 7, 0, 1, 2] target = 0 print(search_rotated_array(nums, target)) # Output: 4 # Example Input: nums = [4, 5, 6, 7, 0, 1, 2] target = 3 print(search_rotated_array(nums, target)) # Output: -1 from solution import search_rotated_array def test_search_rotated_array_found(): assert search_rotated_array([4, 5, 6, 7, 0, 1, 2], 0) == 4 assert search_rotated_array([4, 5, 6, 7, 0, 1, 2], 6) == 2 def test_search_rotated_array_not_found(): assert search_rotated_array([4, 5, 6, 7, 0, 1, 2], 3) == -1 def test_search_rotated_array_single_element(): assert search_rotated_array([1], 1) == 0 assert search_rotated_array([1], 2) == -1 def test_search_rotated_array_two_elements(): assert search_rotated_array([2, 1], 1) == 1 assert search_rotated_array([2, 1], 2) == 0 assert search_rotated_array([2, 1], 3) == -1 def test_search_rotated_array_edge_cases(): assert search_rotated_array([10, 11, 12, 13, 14, 2, 4, 7], 4) == 6 assert search_rotated_array([], 5) == -1 assert search_rotated_array([5, 1, 3], 5) == 0","solution":"def search_rotated_array(nums, target): Search for a target value in a rotated sorted array. @param nums: a list of distinct integers which has been sorted and then rotated. @param target: an integer target to search for in the list. @return: the index of the target if found, otherwise -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid # Check if the left half is sorted if nums[left] <= nums[mid]: # Target is in the left half if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 # Otherwise, the right half must be sorted else: # Target is in the right half if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"from typing import List def sort_versions(versions: List[str]) -> List[str]: Sort a list of version strings based on semantic versioning rules. Semantic versioning follows the pattern MAJOR.MINOR.PATCH where each part is a non-negative integer. Args: versions (List of strings): A list of version strings. Returns: List of strings: A list of version strings sorted in ascending order of version. >>> sort_versions([\\"1.0.0\\", \\"2.0.0\\", \\"1.2.3\\", \\"1.2.2\\", \\"1.1.5\\", \\"2.2.1\\", \\"0.1.9\\", \\"1.1.10\\"]) [\\"0.1.9\\", \\"1.0.0\\", \\"1.1.5\\", \\"1.1.10\\", \\"1.2.2\\", \\"1.2.3\\", \\"2.0.0\\", \\"2.2.1\\"] >>> sort_versions([\\"1.0.1\\", \\"1.0.3\\", \\"1.0.2\\"]) [\\"1.0.1\\", \\"1.0.2\\", \\"1.0.3\\"] >>> sort_versions([\\"1.0.0\\"]) [\\"1.0.0\\"] >>> sort_versions([\\"1.2.100\\", \\"1.2.99\\", \\"1.2.101\\"]) [\\"1.2.99\\", \\"1.2.100\\", \\"1.2.101\\"] >>> sort_versions([\\"0.0.0\\", \\"0.1.0\\", \\"0.0.1\\"]) [\\"0.0.0\\", \\"0.0.1\\", \\"0.1.0\\"]","solution":"from typing import List def sort_versions(versions: List[str]) -> List[str]: Sort a list of version strings based on semantic versioning rules. Semantic versioning follows the pattern MAJOR.MINOR.PATCH where each part is a non-negative integer. Args: versions (List of strings): A list of version strings. Returns: List of strings: A list of version strings sorted in ascending order of version. return sorted(versions, key=lambda version: [int(part) for part in version.split('.')])"},{"question":"class Matrix: def __init__(self, matrix: list[list[int]]): self.matrix = matrix def rotate(self) -> None: Rotate the matrix 90 degrees clockwise. >>> matrix = Matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) >>> matrix.rotate() >>> matrix.matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] def has_pattern(self, pattern: list[int]) -> bool: Check if a specific integer pattern exists in the matrix, either horizontally, vertically, or diagonally in any direction including rotations. >>> matrix = Matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) >>> matrix.has_pattern([1, 5, 9]) True >>> matrix.has_pattern([3, 6, 9]) True # After rotation >>> matrix.has_pattern([2, 5, 8]) True # Test cases def test_rotate_square_matrix(): matrix = Matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) matrix.rotate() assert matrix.matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] def test_rotate_rectangle_matrix(): matrix = Matrix([ [1, 2, 3, 4], [5, 6, 7, 8] ]) matrix.rotate() assert matrix.matrix == [ [5, 1], [6, 2], [7, 3], [8, 4] ] def test_has_pattern_in_original(): matrix = Matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) assert matrix.has_pattern([1, 2, 3]) == True assert matrix.has_pattern([4, 5, 6]) == True assert matrix.has_pattern([7, 8, 9]) == True def test_has_pattern_after_rotation(): matrix = Matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) assert matrix.has_pattern([7, 4, 1]) == True # After one rotation assert matrix.has_pattern([9, 6, 3]) == True # After three rotations def test_has_pattern_diagonal(): matrix = Matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) assert matrix.has_pattern([1, 5, 9]) == True assert matrix.has_pattern([3, 5, 7]) == True # Diagonal from bottom left to top right def test_pattern_not_found(): matrix = Matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) assert matrix.has_pattern([1, 9, 5]) == False assert matrix.has_pattern([2, 6, 4]) == False","solution":"class Matrix: def __init__(self, matrix: list[list[int]]): self.matrix = matrix def rotate(self) -> None: n = len(self.matrix) m = len(self.matrix[0]) # Create a new matrix to hold rotated values new_matrix = [[0] * n for _ in range(m)] for i in range(n): for j in range(m): new_matrix[j][n - 1 - i] = self.matrix[i][j] self.matrix = new_matrix def has_pattern(self, pattern: list[int]) -> bool: def check_pattern(matrix, pattern): rows, cols = len(matrix), len(matrix[0]) len_pattern = len(pattern) for i in range(rows): for j in range(cols): if ( j <= cols - len_pattern and all(matrix[i][j + k] == pattern[k] for k in range(len_pattern)) or i <= rows - len_pattern and all(matrix[i + k][j] == pattern[k] for k in range(len_pattern)) or i <= rows - len_pattern and j <= cols - len_pattern and all(matrix[i + k][j + k] == pattern[k] for k in range(len_pattern)) or i >= len_pattern - 1 and j <= cols - len_pattern and all(matrix[i - k][j + k] == pattern[k] for k in range(len_pattern)) ): return True return False for _ in range(4): if check_pattern(self.matrix, pattern): return True self.rotate() return False"},{"question":"class SocialMediaPlatform: Simulate a simple social media platform where users can follow each other and posts can be made. It retrieves the 10 most recent posts in the news feed for a user, prioritizing posts from people they follow. Example usage: >>> smp = SocialMediaPlatform() >>> smp.post(1, 101) >>> smp.post(1, 102) >>> smp.post(2, 201) >>> smp.follow(1, 2) >>> smp.post(2, 202) >>> smp.post(1, 103) >>> smp.get_news_feed(1) [103, 202, 102, 101] >>> smp.unfollow(1, 2) >>> smp.get_news_feed(1) [103, 102, 101] def __init__(self): pass def follow(self, user: int, followee: int) -> None: pass def unfollow(self, user: int, followee: int) -> None: pass def post(self, user: int, post_id: int) -> None: pass def get_news_feed(self, user: int) -> list: pass","solution":"from collections import defaultdict, deque import heapq import time class SocialMediaPlatform: def __init__(self): self.followees = defaultdict(set) self.posts = defaultdict(deque) self.timestamp = 0 def follow(self, user: int, followee: int) -> None: if user != followee: self.followees[user].add(followee) def unfollow(self, user: int, followee: int) -> None: self.followees[user].discard(followee) def post(self, user: int, post_id: int) -> None: self.posts[user].appendleft((self.timestamp, post_id)) self.timestamp += 1 def get_news_feed(self, user: int) -> list: min_heap = [] users_to_check = self.followees[user] | {user} for u in users_to_check: for post in list(self.posts[u])[:10]: if len(min_heap) < 10: heapq.heappush(min_heap, post) else: heapq.heappushpop(min_heap, post) return [post_id for _, post_id in sorted(min_heap, reverse=True)]"},{"question":"Create the following function: def binary_tree_level_order_traversal(tree: 'BinaryTree') -> List[List[int]]: Given an instance of the BinaryTree class, this function returns the level order traversal (breadth-first traversal) of the tree in the form of a list of lists. Args: tree (BinaryTree): Instance of BinaryTree class. Returns: List[List[int]]: A list of lists containing the values of the nodes at each level. result = [] if not tree.root: return result queue = deque([tree.root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, value: int = 0, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self): self.root = None def insert(self, value: int): if not self.root: self.root = TreeNode(value) else: queue = deque([self.root]) while queue: node = queue.popleft() if not node.left: node.left = TreeNode(value) return else: queue.append(node.left) if not node.right: node.right = TreeNode(value) return else: queue.append(node.right) def level_order_traversal(self) -> List[List[int]]: result = [] if not self.root: return result queue = deque([self.root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"def compress_rle(input_string: str) -> str: Compress the input string using the Run-Length Encoding (RLE) algorithm. >>> compress_rle(\\"aaabbccc\\") 'a3b2c3' >>> compress_rle(\\"aaaaa\\") 'a5' pass def decompress_rle(encoded_string: str) -> str: Decompress the RLE encoded string back to its original form. >>> decompress_rle(\\"a3b2c3\\") 'aaabbccc' >>> decompress_rle(\\"a5\\") 'aaaaa' pass","solution":"def compress_rle(input_string: str) -> str: Compresses the input string using Run-Length Encoding (RLE) algorithm. if not input_string: return \\"\\" compressed = [] count = 1 prev_char = input_string[0] for char in input_string[1:]: if char == prev_char: count += 1 else: compressed.append(prev_char + str(count)) prev_char = char count = 1 compressed.append(prev_char + str(count)) return ''.join(compressed) def decompress_rle(encoded_string: str) -> str: Decompresses the RLE encoded string back to its original form. if not encoded_string: return \\"\\" decompressed = [] count = '' for char in encoded_string: if char.isdigit(): count += char else: if count: decompressed.append(prev_char * int(count)) count = '' prev_char = char decompressed.append(prev_char * int(count)) return ''.join(decompressed)"},{"question":"from typing import List def longest_continuous_sequence(dates: List[str], holidays: List[str]) -> List[str]: Find the longest continuous sequence of dates that span over weekends and holidays. return [] # Test Cases def test_long_sequence_including_weekend_and_holiday(): dates = [ \\"2024-01-05\\", \\"2024-01-06\\", \\"2024-01-07\\", \\"2024-01-08\\", \\"2024-03-14\\", \\"2024-03-15\\", \\"2024-03-16\\", \\"2024-03-17\\", \\"2024-03-18\\", \\"2024-12-25\\", ] holidays = [ \\"2024-01-08\\", \\"2024-03-18\\", ] assert longest_continuous_sequence(dates, holidays) == [ \\"2024-03-14\\", \\"2024-03-15\\", \\"2024-03-16\\", \\"2024-03-17\\", \\"2024-03-18\\" ] def test_single_date_sequence(): dates = [\\"2024-01-05\\"] holidays = [] assert longest_continuous_sequence(dates, holidays) == [] def test_multiple_equal_length_sequences(): dates = [ \\"2024-01-05\\", \\"2024-01-06\\", \\"2024-01-07\\", \\"2024-01-12\\", \\"2024-01-13\\", \\"2024-01-14\\", ] holidays = [] assert longest_continuous_sequence(dates, holidays) == [ \\"2024-01-05\\", \\"2024-01-06\\", \\"2024-01-07\\" ] def test_no_weekend_or_holiday_present(): dates = [ \\"2024-01-10\\", \\"2024-01-11\\", \\"2024-01-12\\" ] holidays = [] assert longest_continuous_sequence(dates, holidays) == [] def test_sequence_with_holiday_midweek(): dates = [ \\"2024-01-10\\", \\"2024-01-11\\", \\"2024-01-12\\", \\"2024-01-13\\", \\"2024-01-14\\" ] holidays = [\\"2024-01-12\\"] assert longest_continuous_sequence(dates, holidays) == [ \\"2024-01-10\\", \\"2024-01-11\\", \\"2024-01-12\\", \\"2024-01-13\\", \\"2024-01-14\\" ]","solution":"from datetime import datetime, timedelta from typing import List def longest_continuous_sequence(dates: List[str], holidays: List[str]) -> List[str]: holidays_set = set(holidays) date_objects = [datetime.strptime(date, \\"%Y-%m-%d\\") for date in dates] date_strs = [date.strftime(\\"%Y-%m-%d\\") for date in date_objects] def is_weekend_or_holiday(date_str): date_obj = datetime.strptime(date_str, \\"%Y-%m-%d\\") if date_str in holidays_set: return True if date_obj.weekday() in (5, 6): # Saturday or Sunday return True return False max_sequence = [] current_sequence = [] for i in range(len(date_objects)): current_sequence.append(date_strs[i]) if i == len(date_objects) - 1 or (date_objects[i+1] - date_objects[i]).days != 1: if any(is_weekend_or_holiday(date) for date in current_sequence): if len(current_sequence) > len(max_sequence): max_sequence = current_sequence.copy() current_sequence = [] return max_sequence"},{"question":"from typing import Any, List class Stack: A simple Stack data structure with LIFO (Last In First Out) property. Methods: push(item: Any) -> None: Adds \`item\` to the top of the stack. pop() -> Any: Removes and returns the item from the top of the stack. Raises \`IndexError\` if the stack is empty. peek() -> Any: Returns the item at the top of the stack without removing it. Raises \`IndexError\` if the stack is empty. is_empty() -> bool: Returns \`True\` if the stack is empty, \`False\` otherwise. size() -> int: Returns the number of items in the stack. Example usage: >>> s = Stack() >>> s.push(10) >>> s.push(20) >>> s.peek() # Output: 20 >>> s.pop() # Output: 20 >>> s.size() # Output: 1 >>> s.is_empty() # Output: False >>> s.pop() >>> s.is_empty() # Output: True # Example test cases import pytest def test_stack_push(): stack = Stack() stack.push(10) assert stack.size() == 1 stack.push(20) assert stack.size() == 2 assert stack.peek() == 20 def test_stack_pop(): stack = Stack() stack.push(10) stack.push(20) assert stack.pop() == 20 assert stack.size() == 1 assert stack.pop() == 10 assert stack.size() == 0 with pytest.raises(IndexError, match=\\"pop from empty stack\\"): stack.pop() def test_stack_peek(): stack = Stack() stack.push(10) stack.push(20) assert stack.peek() == 20 stack.pop() assert stack.peek() == 10 stack.pop() with pytest.raises(IndexError, match=\\"peek from empty stack\\"): stack.peek() def test_stack_is_empty(): stack = Stack() assert stack.is_empty() is True stack.push(10) assert stack.is_empty() is False stack.pop() assert stack.is_empty() is True def test_stack_size(): stack = Stack() assert stack.size() == 0 stack.push(10) assert stack.size() == 1 stack.push(20) assert stack.size() == 2 stack.pop() assert stack.size() == 1 stack.pop() assert stack.size() == 0","solution":"from typing import Any, List class Stack: def __init__(self): self._stack: List[Any] = [] def push(self, item: Any) -> None: self._stack.append(item) def pop(self) -> Any: if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self._stack.pop() def peek(self) -> Any: if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self._stack[-1] def is_empty(self) -> bool: return len(self._stack) == 0 def size(self) -> int: return len(self._stack)"},{"question":"from typing import List def most_frequent_word(words: List[str]) -> str: Find the most frequent word in the list. If there is a tie, return the lexicographically smallest word. Parameters: words (List[str]): A list of strings representing words. Returns: str: The most frequent word. def test_most_frequent_word_single_word(): assert most_frequent_word([\\"apple\\"]) == \\"apple\\" def test_most_frequent_word_simple_case(): assert most_frequent_word([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]) == \\"apple\\" def test_most_frequent_word_with_tie(): assert most_frequent_word([\\"cat\\", \\"dog\\", \\"cat\\", \\"bird\\", \\"dog\\", \\"dog\\"]) == \\"dog\\" assert most_frequent_word([\\"bat\\", \\"cat\\", \\"bat\\", \\"cat\\"]) == \\"bat\\" def test_most_frequent_word_all_unique(): assert most_frequent_word([\\"ant\\", \\"bee\\", \\"cat\\", \\"dog\\"]) == \\"ant\\" def test_most_frequent_word_large_input(): words = [\\"word\\"] * 100000 + [\\"anotherword\\"] * 99999 assert most_frequent_word(words) == \\"word\\"","solution":"from typing import List from collections import Counter def most_frequent_word(words: List[str]) -> str: Find the most frequent word in the list. If there is a tie, return the lexicographically smallest word. Parameters: words (List[str]): A list of strings representing words. Returns: str: The most frequent word. word_count = Counter(words) max_frequency = max(word_count.values()) max_words = [word for word, count in word_count.items() if count == max_frequency] return min(max_words)"},{"question":"def is_prime(n: int) -> bool: Takes an integer n and returns True if n is a prime number, otherwise False. Examples: >>> is_prime(2) True >>> is_prime(17) True >>> is_prime(18) False >>> is_prime(1) False >>> is_prime(-5) Traceback (most recent call last): ... Exception: Input must be a non-negative integer","solution":"def is_prime(n: int) -> bool: Takes an integer n and returns True if n is a prime number, otherwise False. Examples: >>> is_prime(2) True >>> is_prime(17) True >>> is_prime(18) False >>> is_prime(1) False >>> is_prime(-5) Traceback (most recent call last): ... Exception: Input must be a non-negative integer if not isinstance(n, int): raise Exception(\\"Input must be an integer\\") if n < 0: raise Exception(\\"Input must be a non-negative integer\\") if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True"},{"question":"def flatten_list(nested_list: list) -> list: Flattens a nested list into a single list containing all elements in depth-first order. :param nested_list: A list which can contain other nested lists. :returns: A single list with all elements from the nested list. Examples: >>> flatten_list([1, [2, [3, 4], 5], 6]) [1, 2, 3, 4, 5, 6] >>> flatten_list([['a'], ['b', ['c', ['d']], 'e'], 'f']) ['a', 'b', 'c', 'd', 'e', 'f'] >>> flatten_list([[], [1, 2, [], [3]], [[4]], 5]) [1, 2, 3, 4, 5]","solution":"def flatten_list(nested_list): Flattens a nested list into a single list containing all elements in depth-first order. :param nested_list: A list which can contain other nested lists. :returns: A single list with all elements from the nested list. flat_list = [] for item in nested_list: if isinstance(item, list): flat_list.extend(flatten_list(item)) else: flat_list.append(item) return flat_list"},{"question":"from typing import List def trap(height: List[int]) -> int: Calculate the amount of water that can be trapped after raining given an elevation map. Args: height (List[int]): A list of non-negative integers representing the height of bars. Returns: int: The total units of water trapped after it rains. Examples: >>> trap([0, 1, 0, 2, 1, 0, 3, 1, 0, 1, 2]) 8 >>> trap([4, 2, 0, 3, 2, 5]) 9 >>> trap([]) 0 >>> trap([1, 2, 3, 4, 5]) 0 >>> trap([5]) 0 >>> trap([2, 1]) 0 >>> trap([10000, 1, 10000]) 9999 >>> trap([5, 4, 3, 2, 1, 2, 3, 4, 5]) 16 pass","solution":"from typing import List def trap(height: List[int]) -> int: if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"def find_anagram_pairs(words: list[str]) -> list[list[str]]: Identify all pairs of anagram strings within a given list. >>> find_anagram_pairs([\\"listen\\", \\"silent\\", \\"enlist\\", \\"hello\\", \\"olleh\\", \\"world\\"]) [['listen', 'silent'], ['listen', 'enlist'], ['silent', 'enlist'], ['hello', 'olleh']] >>> find_anagram_pairs([\\"test\\", \\"sett\\", \\"tset\\", \\"test\\"]) [['test', 'sett'], ['test', 'tset'], ['test', 'test'], ['sett', 'tset'], ['sett', 'test'], ['tset', 'test']] >>> find_anagram_pairs([\\"apple\\", \\"banana\\", \\"grape\\"]) [] >>> find_anagram_pairs([]) [] >>> find_anagram_pairs([\\"Listen\\", \\"Silent\\", \\"enlist\\", \\"Hello\\", \\"Olleh\\", \\"world\\"]) [['Listen', 'Silent'], ['Listen', 'enlist'], ['Silent', 'enlist'], ['Hello', 'Olleh']]","solution":"def find_anagram_pairs(words: list[str]) -> list[list[str]]: from collections import defaultdict # A dictionary to store the sorted tuple of characters as key and original words as values anagrams = defaultdict(list) # Iterate over each word and add it to the correct list in the dictionary for word in words: sorted_word = ''.join(sorted(word.lower())) # Sort characters alphabetically and convert to lower case anagrams[sorted_word].append(word) # Generate pairs of anagrams from the lists in the dictionary anagram_pairs = [] for key, group in anagrams.items(): for i in range(len(group)): for j in range(i + 1, len(group)): anagram_pairs.append([group[i], group[j]]) return anagram_pairs"},{"question":"def rotate_matrix(matrix: list) -> list: Rotates a given n x n matrix by 90 degrees clockwise. >>> rotate_matrix([[1]]) [[1]] >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[0, -1], [-2, 3]]) [[-2, 0], [3, -1]] >>> rotate_matrix([]) [] pass # Example usage: # result = rotate_matrix([[1, 2], [3, 4]]) # print(result) # Output should be [[3, 1], [4, 2]]","solution":"def rotate_matrix(matrix: list) -> list: Rotates a given n x n matrix by 90 degrees clockwise. n = len(matrix) if n == 0: return matrix # Perform the rotation in-place for i in range(n // 2): for j in range(i, n - i - 1): # Store the value of one element temporarily temp = matrix[i][j] # Move values from left to top matrix[i][j] = matrix[n - j - 1][i] # Move values from bottom to left matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1] # Move values from right to bottom matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1] # Assign temp to right matrix[j][n - i - 1] = temp return matrix"},{"question":"def max_window_sum(points: list[int], window_size: int) -> int: Calculate the maximum sum of points from any contiguous subarray with the specified window size. :param points: List of non-negative integers representing points scored in a game session. :param window_size: Integer representing the size of the window to consider for summing points. :return: The maximum sum of points from any contiguous subarray with the specified window size, or 0 if conditions are not met. >>> max_window_sum([1, 2, 3, 4, 5, 6, 1], 3) 15 >>> max_window_sum([1, 2, 3, 4], 2) 7 >>> max_window_sum([1], 1) 1 >>> max_window_sum([], 3) 0 >>> max_window_sum([4, 2, 10, 1, 5, 6], 2) 15","solution":"def max_window_sum(points: list[int], window_size: int) -> int: Calculate the maximum sum of points from any contiguous subarray with the specified window size. :param points: List of non-negative integers representing points scored in a game session. :param window_size: Integer representing the size of the window to consider for summing points. :return: The maximum sum of points from any contiguous subarray with the specified window size, or 0 if conditions are not met. n = len(points) # If the list is empty or the window size is larger than the number of elements if n == 0 or window_size > n: return 0 # Calculate the sum of the first window size elements window_sum = sum(points[:window_size]) max_sum = window_sum # Use sliding window technique to find the maximum sum of a window of size k for i in range(window_size, n): window_sum += points[i] - points[i - window_size] if window_sum > max_sum: max_sum = window_sum return max_sum"},{"question":"def in_place_reverse(s: list[str]) -> list[str]: Reverses the input string in place without using extra space for another string or list. :param s: Input string represented as a list of characters :return: The same list with characters reversed >>> in_place_reverse(['h', 'e', 'l', 'l', 'o']) ['o', 'l', 'l', 'e', 'h'] >>> in_place_reverse(['a', 'b', 'c', 'd']) ['d', 'c', 'b', 'a']","solution":"def in_place_reverse(s: list[str]) -> list[str]: Reverses the input string in place without using extra space for another string or list. :param s: Input string represented as a list of characters :return: The same list with characters reversed left, right = 0, len(s) - 1 while left < right: s[left], s[right] = s[right], s[left] left += 1 right -= 1 return s"},{"question":"from typing import List def sort_by_length(strings: List[str]) -> List[str]: Sorts a list of strings in decreasing order of their lengths. Args: strings (List[str]): The list of strings to sort. Returns: List[str]: The sorted list of strings by decreasing length. Examples: >>> sort_by_length([\\"apple\\", \\"banana\\", \\"pear\\", \\"grape\\"]) [\\"banana\\", \\"apple\\", \\"grape\\", \\"pear\\"] >>> sort_by_length([\\"a\\", \\"abc\\", \\"abcd\\", \\"ab\\", \\"abcdef\\"]) [\\"abcdef\\", \\"abcd\\", \\"abc\\", \\"ab\\", \\"a\\"] >>> sort_by_length([]) [] >>> sort_by_length([\\"same\\", \\"length\\", \\"test\\"]) [\\"length\\", \\"same\\", \\"test\\"] pass","solution":"from typing import List def sort_by_length(strings: List[str]) -> List[str]: Sorts a list of strings in decreasing order of their lengths. Parameters: strings (List[str]): The list of strings to sort. Returns: List[str]: The sorted list of strings by decreasing length. return sorted(strings, key=len, reverse=True)"},{"question":"def reverse_without_punctuation(s: str) -> str: Reverses the characters of each word in the input string \`s\` while keeping the punctuation marks in their original positions. >>> reverse_without_punctuation(\\"hello world!\\") \\"olleh dlrow!\\" >>> reverse_without_punctuation(\\"a,b.c!\\") \\"c,b.a!\\" >>> reverse_without_punctuation(\\"abcd! efgh?\\") \\"dcba! hgfe?\\" >>> reverse_without_punctuation(\\"\\") \\"\\"","solution":"def reverse_without_punctuation(s: str) -> str: Reverses the characters of each word in the input string \`s\` while keeping the punctuation marks in their original positions. result = [] for word in s.split(' '): new_word = list(word) left, right = 0, len(new_word) - 1 while left < right: if new_word[left].isalpha(): while not new_word[right].isalpha() and left < right: right -= 1 new_word[left], new_word[right] = new_word[right], new_word[left] right -= 1 left += 1 result.append(''.join(new_word)) return ' '.join(result)"},{"question":"import csv def compare_csv_files(file1: str, file2: str) -> bool: Compare two CSV files to check if they contain the same data. Parameters: file1 (str): Path to the first CSV file. file2 (str): Path to the second CSV file. Returns: bool: True if the two files contain identical data, False otherwise. Example: >>> compare_csv_files('file1.csv', 'file2.csv') True >>> compare_csv_files('file1.csv', 'file2_diff.csv') False","solution":"import csv def compare_csv_files(file1: str, file2: str) -> bool: Compare two CSV files to check if they contain the same data. Parameters: file1 (str): Path to the first CSV file. file2 (str): Path to the second CSV file. Returns: bool: True if the two files contain identical data, False otherwise. try: with open(file1, 'r') as f1, open(file2, 'r') as f2: reader1 = csv.reader(f1) reader2 = csv.reader(f2) for row1, row2 in zip(reader1, reader2): if row1 != row2: return False # Ensure both files have the same number of rows # If one of the readers has more rows, zip will not exhaust them # We need to explicitly read the rest and check if there is any extra row try: next(reader1) return False except StopIteration: pass try: next(reader2) return False except StopIteration: pass return True except IOError: # Handle I/O errors while reading the files raise"},{"question":"def min_bracket_move(s: str) -> int: Determine the number of moves needed to make a bracket sequence valid. Parameters: s (str): A string consisting of characters '(' and ')' only. Returns: int: Minimum number of moves required to make the bracket sequence valid. Examples: >>> min_bracket_move(\\"(()\\") 1 >>> min_bracket_move(\\")(\\") 2 >>> min_bracket_move(\\"\\") 0 pass","solution":"def min_bracket_move(s: str) -> int: Returns the minimum number of moves required to make the bracket sequence valid. A move is defined as either adding or removing one bracket. balance = 0 moves = 0 for char in s: if char == '(': balance += 1 else: # char == ')' if balance > 0: balance -= 1 else: moves += 1 # Balance holds the number of unmatched '(' brackets return moves + balance"},{"question":"from typing import List, Tuple def busiest_hour(records: List[Tuple[str, int]]) -> str: Determine the timestamp at which the store reached its maximum occupancy for the first time. Args: records (List[Tuple[str, int]]): List of tuples where each tuple contains a timestamp and the number of customers entering or leaving the store at that timestamp. Returns: str: The timestamp at which the store reached its maximum occupancy for the first time. Examples: >>> busiest_hour([(\\"2023-01-01 10:00:00\\", 10), (\\"2023-01-01 10:30:00\\", 5), (\\"2023-01-01 11:00:00\\", -3), ... (\\"2023-01-01 11:30:00\\", 8), (\\"2023-01-01 12:00:00\\", -10), (\\"2023-01-01 12:30:00\\", 5)]) \\"2023-01-01 11:30:00\\" >>> busiest_hour([(\\"2023-01-01 08:00:00\\", 3), (\\"2023-01-01 09:00:00\\", -1), (\\"2023-01-01 10:00:00\\", 2), ... (\\"2023-01-01 11:00:00\\", -2), (\\"2023-01-01 12:00:00\\", 5)]) \\"2023-01-01 12:00:00\\" pass","solution":"from typing import List, Tuple def busiest_hour(records: List[Tuple[str, int]]) -> str: max_occupancy = 0 current_occupancy = 0 max_occupancy_timestamp = \\"\\" for timestamp, change in records: current_occupancy += change if current_occupancy > max_occupancy: max_occupancy = current_occupancy max_occupancy_timestamp = timestamp return max_occupancy_timestamp"},{"question":"def longest_non_decreasing_rainfall(rainfall_data: list[int]) -> int: Determines the length of the longest contiguous sequence of days with non-decreasing rainfall. >>> longest_non_decreasing_rainfall([1, 2, 2, 1, 2, 3, 4, 1]) 4 >>> longest_non_decreasing_rainfall([5, 3, 2, 1]) 1 >>> longest_non_decreasing_rainfall([1, 3, 5, 7, 9, 2, 4, 6, 8]) 5 >>> longest_non_decreasing_rainfall([]) 0","solution":"def longest_non_decreasing_rainfall(rainfall_data: list[int]) -> int: Determines the length of the longest contiguous sequence of days with non-decreasing rainfall. if not rainfall_data: return 0 max_length = 1 current_length = 1 for i in range(1, len(rainfall_data)): if rainfall_data[i] >= rainfall_data[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"from typing import List def binary_search(nums: List[int], target: int) -> int: Perform a binary search on a sorted array to find the index of a given target value. Parameters: nums (list of int): The sorted array of integers. target (int): The integer value to search for in the array. Returns: int: The index of the target in the array if found, otherwise -1. >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) 4 >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 11) -1 >>> binary_search([], 7) -1 # Your code here pass","solution":"def binary_search(nums, target): Perform a binary search on a sorted array to find the index of a given target value. Parameters: nums (list of int): The sorted array of integers. target (int): The integer value to search for in the array. Returns: int: The index of the target in the array if found, otherwise -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def rotate_matrix(mat: List[List[int]]) -> List[List[int]]: Rotates the input square matrix by 90 degrees clockwise. Args: mat (list of list of int): The 2D square matrix to be rotated. Returns: list of list of int: The rotated matrix. Examples: >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1]]) [[1]] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]] >>> rotate_matrix([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]] >>> rotate_matrix([ ... [1, 2, 3, 4, 5], ... [6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20], ... [21, 22, 23, 24, 25] ... ]) [[21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5]]","solution":"def rotate_matrix(mat): Rotates the input square matrix by 90 degrees clockwise. Args: mat (list of list of int): The 2D square matrix to be rotated. Returns: list of list of int: The rotated matrix. n = len(mat) rotated_mat = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_mat[j][n - 1 - i] = mat[i][j] return rotated_mat"},{"question":"class GameInventory: A class representing an inventory system for a text-based game. Supports adding items, removing items, and querying the quantity of any item. Methods: add_item(item_name: str, quantity: int) -> None: Adds the given quantity of the specified item to the inventory. remove_item(item_name: str, quantity: int) -> None: Removes the specified quantity of the item from the inventory. If the quantity to be removed exceeds the current quantity, it removes all the items and prints a warning message. get_quantity(item_name: str) -> int: Returns the current quantity of the specified item in the inventory. If the item does not exist, returns 0. def __init__(self): Initialize an empty inventory. pass def add_item(self, item_name: str, quantity: int) -> None: Add a specified quantity of an item to the inventory. pass def remove_item(self, item_name: str, quantity: int) -> None: Remove a specified quantity of an item from the inventory. pass def get_quantity(self, item_name: str) -> int: Get the current quantity of an item in the inventory. pass # Unit tests for the GameInventory class import pytest def test_add_item(): inventory = GameInventory() inventory.add_item(\\"sword\\", 5) assert inventory.get_quantity(\\"sword\\") == 5 def test_add_more_of_the_same_item(): inventory = GameInventory() inventory.add_item(\\"sword\\", 5) inventory.add_item(\\"sword\\", 3) assert inventory.get_quantity(\\"sword\\") == 8 def test_add_item_negative_quantity(): inventory = GameInventory() with pytest.raises(ValueError): inventory.add_item(\\"sword\\", -2) def test_remove_item(): inventory = GameInventory() inventory.add_item(\\"shield\\", 3) inventory.remove_item(\\"shield\\", 2) assert inventory.get_quantity(\\"shield\\") == 1 def test_remove_more_than_present_item(): inventory = GameInventory() inventory.add_item(\\"potion\\", 5) inventory.remove_item(\\"potion\\", 7) assert inventory.get_quantity(\\"potion\\") == 0 def test_remove_item_negative_quantity(): inventory = GameInventory() with pytest.raises(ValueError): inventory.remove_item(\\"shield\\", -3) def test_get_quantity_non_existing_item(): inventory = GameInventory() assert inventory.get_quantity(\\"axe\\") == 0","solution":"class GameInventory: def __init__(self): self.inventory = {} def add_item(self, item_name: str, quantity: int) -> None: if quantity < 0: raise ValueError(\\"Quantity must be a non-negative integer.\\") if item_name in self.inventory: self.inventory[item_name] += quantity else: self.inventory[item_name] = quantity def remove_item(self, item_name: str, quantity: int) -> None: if quantity < 0: raise ValueError(\\"Quantity must be a non-negative integer.\\") if item_name in self.inventory: if self.inventory[item_name] > quantity: self.inventory[item_name] -= quantity else: print(f\\"Attempt to remove more items than present. Remove all {item_name}s instead.\\") self.inventory[item_name] = 0 def get_quantity(self, item_name: str) -> int: return self.inventory.get(item_name, 0)"},{"question":"class BookInventory: A class to manage the inventory of a bookstore. Methods: - __init__(self): Initializes an empty inventory. - add_book(self, title: str, author: str, quantity: int) -> None: Adds a new book to the inventory or updates the quantity of an existing book. - remove_book(self, title: str) -> bool: Removes a book from the inventory and returns True if successful, or False if the book was not found. - update_quantity(self, title: str, quantity: int) -> bool: Updates the quantity of a specific book and returns True if successful, or False if the book was not found. - get_inventory(self) -> list: Returns a list of dictionaries, each representing a book with its title, author, and quantity. # Define the methods as specified above. import pytest from solution import BookInventory def test_add_book(): inventory = BookInventory() inventory.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 10) assert inventory.get_inventory() == [{'title': \\"The Great Gatsby\\", 'author': \\"F. Scott Fitzgerald\\", 'quantity': 10}] def test_remove_book(): inventory = BookInventory() inventory.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 10) assert inventory.remove_book(\\"The Great Gatsby\\") == True assert inventory.get_inventory() == [] assert inventory.remove_book(\\"The Great Gatsby\\") == False def test_update_quantity(): inventory = BookInventory() inventory.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 10) assert inventory.update_quantity(\\"The Great Gatsby\\", 5) == True assert inventory.get_inventory() == [{'title': \\"The Great Gatsby\\", 'author': \\"F. Scott Fitzgerald\\", 'quantity': 5}] assert inventory.update_quantity(\\"Unknown Book\\", 5) == False def test_get_inventory(): inventory = BookInventory() inventory.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 10) inventory.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 7) expected_output = [ {'title': \\"The Great Gatsby\\", 'author': \\"F. Scott Fitzgerald\\", 'quantity': 10}, {'title': \\"To Kill a Mockingbird\\", 'author': \\"Harper Lee\\", 'quantity': 7} ] assert inventory.get_inventory() == expected_output def test_add_existing_book(): inventory = BookInventory() inventory.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 10) inventory.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 5) assert inventory.get_inventory() == [{'title': \\"The Great Gatsby\\", 'author': \\"F. Scott Fitzgerald\\", 'quantity': 15}] if __name__ == \\"__main__\\": pytest.main()","solution":"class BookInventory: def __init__(self): # Initialize the inventory as an empty dictionary self.inventory = {} def add_book(self, title: str, author: str, quantity: int) -> None: # If the book already exists, update the quantity if title in self.inventory: self.inventory[title]['quantity'] += quantity else: # Add the new book to the inventory self.inventory[title] = {'author': author, 'quantity': quantity} def remove_book(self, title: str) -> bool: # Remove the book if it exists if title in self.inventory: del self.inventory[title] return True return False def update_quantity(self, title: str, quantity: int) -> bool: # Update the quantity if the book exists if title in self.inventory: self.inventory[title]['quantity'] = quantity return True return False def get_inventory(self) -> list: # Return the inventory as a list of dictionaries return [{'title': title, 'author': book['author'], 'quantity': book['quantity']} for title, book in self.inventory.items()]"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression including positive integers, addition (+), subtraction (-) and mixed usage of parentheses (). :param expression: A string representing a valid mathematical expression. :return: The integer result of evaluating the expression. >>> evaluate_expression(\\"1 + 1\\") 2 >>> evaluate_expression(\\"2 - (3 + 4)\\") -5 >>> evaluate_expression(\\"(1 + (2 + 3) - (4 - 5))\\") 7 >>> evaluate_expression(\\"10 + (20 - (10 + 5) + 2)\\") 17","solution":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression including positive integers, +, -, and parentheses. :param expression: A string representing a valid mathematical expression. :return: The integer result of evaluating the expression. def helper(tokens): stack = [] num = 0 sign = 1 while tokens: char = tokens.pop(0) if char.isdigit(): num = int(char) while tokens and tokens[0].isdigit(): num = num * 10 + int(tokens.pop(0)) stack.append(sign * num) num = 0 elif char in \\"+-\\": sign = 1 if char == \\"+\\" else -1 elif char == \\"(\\": stack.append(sign) sign = 1 stack.append(\\"(\\") elif char == \\")\\": num = 0 while stack and isinstance(stack[-1], int): num += stack.pop() if stack.pop() == \\"(\\" and stack and stack[-1] in (1, -1): num *= stack.pop() stack.append(num) return sum(stack) return helper(list(expression.replace(\\" \\", \\"\\")))"},{"question":"def is_valid_password(password: str) -> bool: Check if a given password meets the following criteria: 1. The password must be at least 8 characters long. 2. It must contain at least one lowercase letter. 3. It must contain at least one uppercase letter. 4. It must contain at least one digit. 5. It must contain at least one special character from the set !@#%^&*(). >>> is_valid_password(\\"Password123!\\") == True >>> is_valid_password(\\"password\\") == False >>> is_valid_password(\\"PASSWORD123\\") == False >>> is_valid_password(\\"Pass123\\") == False >>> is_valid_password(\\"Pass!@#\\") == False >>> is_valid_password(\\"P@ssw0rd\\") == True >>> is_valid_password(\\"P@ssword!\\") == True >>> is_valid_password(\\"Pass1234!\\") == True >>> is_valid_password(\\"12345678\\") == False >>> is_valid_password(\\"PASSWORD@1\\") == True","solution":"import re def is_valid_password(password: str) -> bool: Returns True if the password meets the given criteria: - At least 8 characters long - Contains at least one lowercase letter - Contains at least one uppercase letter - Contains at least one digit - Contains at least one special character from !@#%^&*() Otherwise, returns False. if len(password) < 8: return False if not re.search(r'[a-z]', password): return False if not re.search(r'[A-Z]', password): return False if not re.search(r'd', password): return False if not re.search(r'[!@#%^&*()]', password): return False return True"},{"question":"from typing import List def largest_square_submatrix(matrix: List[List[int]]) -> int: Finds the size of the largest square submatrix with all 1s in a given binary matrix. Args: matrix (List[List[int]]): A binary matrix (list of lists) where each element is either 0 or 1. Returns: int: The size of the largest square submatrix with all 1s. Examples: >>> largest_square_submatrix([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) 2 >>> largest_square_submatrix([ ... [0, 1], ... [1, 1] ... ]) 1 >>> largest_square_submatrix([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 3","solution":"from typing import List def largest_square_submatrix(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * cols for _ in range(rows)] max_size = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_size = max(max_size, dp[i][j]) return max_size"},{"question":"from typing import Optional class TreeNode: def __init__(self, val: int, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None): self.val = val self.left = left self.right = right def calculate_depth(root: Optional[TreeNode]) -> int: Calculate the depth of a Binary Search Tree (BST). Args: root (Optional[TreeNode]): The root node of the BST. Returns: int: The depth of the BST. >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> calculate_depth(root) 2 >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) >>> calculate_depth(root) 3","solution":"from typing import Optional class TreeNode: def __init__(self, val: int, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None): self.val = val self.left = left self.right = right def calculate_depth(root: Optional[TreeNode]) -> int: Calculate the depth of a Binary Search Tree (BST). Args: root (Optional[TreeNode]): The root node of the BST. Returns: int: The depth of the BST. if root is None: return 0 left_depth = calculate_depth(root.left) right_depth = calculate_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"def rotate_circular_list(circular_list: list[int], positions: int) -> list[int]: Rotates the circular list by the given number of positions. Parameters: circular_list (list[int]): The list of integers representing the circular buffer. positions (int): The number of positions to rotate the list. Returns: list[int]: The rotated list. pass if __name__ == \\"__main__\\": print(rotate_circular_list([1, 2, 3, 4, 5], 2)) # Output: [4, 5, 1, 2, 3] print(rotate_circular_list([10, 20, 30, 40], 1)) # Output: [40, 10, 20, 30]","solution":"def rotate_circular_list(circular_list: list[int], positions: int) -> list[int]: Rotates the circular list by the given number of positions. Parameters: circular_list (list[int]): The list of integers representing the circular buffer. positions (int): The number of positions to rotate the list. Returns: list[int]: The rotated list. n = len(circular_list) # Normalize positions to be within the range of 0 to n-1 positions %= n return circular_list[-positions:] + circular_list[:-positions]"},{"question":"class TreeNode: def __init__(self, key, value): self.key = key self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, key, value): if self.root is None: self.root = TreeNode(key, value) else: self._insert(self.root, key, value) def _insert(self, node, key, value): if key < node.key: if node.left is None: node.left = TreeNode(key, value) else: self._insert(node.left, key, value) else: if node.right is None: node.right = TreeNode(key, value) else: self._insert(node.right, key, value) def height(self): Calculates and returns the height of the binary search tree. pass def balance(self): Balances the binary search tree to minimize its height. pass def to_array(self): Helper method for testing purposes, returns the nodes of the tree in an in-order array. nodes = [] self._in_order_traversal(self.root, nodes) return [(node.key, node.value) for node in nodes] def _in_order_traversal(self, node, nodes): Helper method for in-order traversal of the tree. if node is not None: self._in_order_traversal(node.left, nodes) nodes.append(node) self._in_order_traversal(node.right, nodes) def test_height(): bst = BinarySearchTree() bst.insert(10, 'value10') bst.insert(5, 'value5') bst.insert(15, 'value15') bst.insert(2, 'value2') bst.insert(7, 'value7') bst.insert(12, 'value12') bst.insert(20, 'value20') assert bst.height() == 2 bst.insert(1, 'value1') assert bst.height() == 3 def test_balance(): bst = BinarySearchTree() bst.insert(10, 'value10') bst.insert(5, 'value5') bst.insert(1, 'value1') bst.insert(7, 'value7') bst.insert(6, 'value6') bst.insert(8, 'value8') bst.insert(15, 'value15') assert bst.height() == 3 bst.balance() assert bst.height() == 2 def test_balance_and_structure(): bst = BinarySearchTree() bst.insert(3, 'value3') bst.insert(1, 'value1') bst.insert(2, 'value2') bst.insert(5, 'value5') bst.insert(4, 'value4') bst.insert(6, 'value6') bst.balance() assert bst.to_array() == [(1, 'value1'), (2, 'value2'), (3, 'value3'), (4, 'value4'), (5, 'value5'), (6, 'value6')] assert bst.height() == 2","solution":"class TreeNode: def __init__(self, key, value): self.key = key self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, key, value): if self.root is None: self.root = TreeNode(key, value) else: self._insert(self.root, key, value) def _insert(self, node, key, value): if key < node.key: if node.left is None: node.left = TreeNode(key, value) else: self._insert(node.left, key, value) else: if node.right is None: node.right = TreeNode(key, value) else: self._insert(node.right, key, value) def height(self): return self._height(self.root) def _height(self, node): if node is None: return -1 left_height = self._height(node.left) right_height = self._height(node.right) return 1 + max(left_height, right_height) def balance(self): nodes = [] self._in_order_traversal(self.root, nodes) self.root = self._build_balanced_bst(nodes, 0, len(nodes) - 1) def _in_order_traversal(self, node, nodes): if node is not None: self._in_order_traversal(node.left, nodes) nodes.append(node) self._in_order_traversal(node.right, nodes) def _build_balanced_bst(self, nodes, start, end): if start > end: return None mid = (start + end) // 2 node = nodes[mid] node.left = self._build_balanced_bst(nodes, start, mid - 1) node.right = self._build_balanced_bst(nodes, mid + 1, end) return node def to_array(self): # for testing purposes nodes = [] self._in_order_traversal(self.root, nodes) return [(node.key, node.value) for node in nodes]"},{"question":"def generate_primes(n: int) -> List[int]: Generate a list of prime numbers up to and including the given number n using the Sieve of Eratosthenes algorithm. :param n: A non-negative integer :return: A list of prime numbers less than or equal to n :raises ValueError: If input is not a non-negative integer >>> generate_primes(10) [2, 3, 5, 7] >>> generate_primes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> generate_primes(0) [] >>> generate_primes(1) [] >>> generate_primes(50) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] >>> generate_primes(-5) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer >>> generate_primes(15.5) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer >>> generate_primes(\\"100\\") Traceback (most recent call last): ... ValueError: Input must be a non-negative integer","solution":"from typing import List def generate_primes(n: int) -> List[int]: Generate a list of prime numbers up to and including the given number n using the Sieve of Eratosthenes algorithm. :param n: A non-negative integer :return: A list of prime numbers less than or equal to n :raises ValueError: If input is not a non-negative integer if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n < 2: return [] is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False # 0 and 1 are not prime numbers for start in range(2, int(n**0.5) + 1): if is_prime[start]: for multiple in range(start*start, n + 1, start): is_prime[multiple] = False return [num for num in range(2, n + 1) if is_prime[num]]"},{"question":"import numpy as np def matrix_factorization(interaction_matrix, user_features, item_features, latent_dim, learning_rate, iterations): Implements Matrix Factorization using Stochastic Gradient Descent (SGD) to decompose the user-item interaction matrix. Args: interaction_matrix: 2D list or array representing user-item interactions. Dimensions: (num_users, num_items). user_features: 2D list or array representing user features. Dimensions: (num_users, num_user_features). item_features: 2D list or array representing item features. Dimensions: (num_items, num_item_features). latent_dim: Integer, the number of latent dimensions for user and item factors. learning_rate: Float value, learning rate for SGD. iterations: Integer, the number of iterations for SGD. Returns: Tuple (user_latent_factors, item_latent_factors) representing the optimized latent factors for users and items. pass # Example usage: interaction_matrix = [ [5, 3, 0, 1], [4, 0, 0, 1], [1, 1, 0, 5], [1, 0, 0, 4], [0, 1, 5, 4], ] user_features = [ [0.2, 0.8], [0.5, 0.5], [0.9, 0.1], [0.4, 0.6], [0.1, 0.9], ] item_features = [ [0.3, 0.7], [0.6, 0.4], [0.7, 0.3], [0.8, 0.2], ] latent_dim = 3 learning_rate = 0.01 iterations = 1000 user_latent_factors, item_latent_factors = matrix_factorization( interaction_matrix, user_features, item_features, latent_dim, learning_rate, iterations ) print(user_latent_factors) print(item_latent_factors) import numpy as np def test_matrix_factorization_output_shape(): user_latent_factors, item_latent_factors = matrix_factorization( interaction_matrix, user_features, item_features, latent_dim, learning_rate, iterations ) assert user_latent_factors.shape == (len(interaction_matrix), latent_dim) assert item_latent_factors.shape == (len(interaction_matrix[0]), latent_dim) def test_matrix_factorization_convergence(): user_latent_factors, item_latent_factors = matrix_factorization( interaction_matrix, user_features, item_features, latent_dim, learning_rate, iterations ) reconstructed_matrix = np.dot(user_latent_factors, item_latent_factors.T) original_non_zero = np.array(interaction_matrix) > 0 original_values = np.array(interaction_matrix)[original_non_zero] reconstructed_values = reconstructed_matrix[original_non_zero] # Allow reconstruction with a reasonable error margin assert np.allclose(original_values, reconstructed_values, atol=1.0) def test_matrix_factorization_learning_rate(): user_latent_factors, item_latent_factors = matrix_factorization( interaction_matrix, user_features, item_features, latent_dim, learning_rate, iterations ) user_latent_factors_high_lr, item_latent_factors_high_lr = matrix_factorization( interaction_matrix, user_features, item_features, latent_dim, learning_rate * 10, iterations ) assert not np.allclose(user_latent_factors, user_latent_factors_high_lr) assert not np.allclose(item_latent_factors, item_latent_factors_high_lr)","solution":"import numpy as np def matrix_factorization(interaction_matrix, user_features, item_features, latent_dim, learning_rate, iterations): num_users, num_items = len(interaction_matrix), len(interaction_matrix[0]) user_features = np.array(user_features) item_features = np.array(item_features) interaction_matrix = np.array(interaction_matrix) # Initialize user and item latent factors randomly user_latent_factors = np.random.rand(num_users, latent_dim) item_latent_factors = np.random.rand(num_items, latent_dim) for iteration in range(iterations): for i in range(num_users): for j in range(num_items): if interaction_matrix[i][j] > 0: # Calculate the error of the prediction prediction = np.dot(user_latent_factors[i,:], item_latent_factors[j,:]) error = interaction_matrix[i][j] - prediction # Update user and item latent factors for k in range(latent_dim): user_latent_factors[i][k] += learning_rate * (2 * error * item_latent_factors[j][k]) item_latent_factors[j][k] += learning_rate * (2 * error * user_latent_factors[i][k]) return user_latent_factors, item_latent_factors"},{"question":"def num_ways_to_climb(n: int) -> int: Calculates the number of ways to climb to the top of a ladder with \`n\` rungs, where you can take either one, two, or three steps at a time using dynamic programming. >>> num_ways_to_climb(4) 7 >>> num_ways_to_climb(5) 13","solution":"def num_ways_to_climb(n: int) -> int: Returns the number of ways to climb a ladder with \`n\` rungs, where you can take either one, two, or three steps at a time. if n == 1: return 1 elif n == 2: return 2 elif n == 3: return 4 # Initialize ways to climb 0, 1, 2, and 3 rungs ways = [0] * (n + 1) ways[1], ways[2], ways[3] = 1, 2, 4 # Fill the ways array for all rungs from 4 to n for i in range(4, n + 1): ways[i] = ways[i - 1] + ways[i - 2] + ways[i - 3] return ways[n]"},{"question":"def is_leap_year(year: int) -> bool: Determine if a given year is a leap year. A year is a leap year if: - It is divisible by 4, and: - It is not a century year (i.e., not divisible by 100) unless it is also divisible by 400. Args: year (int): The year to check. Should be between 1 and 9999 (inclusive). Returns: bool: True if the year is a leap year, False otherwise. >>> is_leap_year(2020) True >>> is_leap_year(2019) False >>> is_leap_year(2000) True >>> is_leap_year(1900) False >>> is_leap_year(1600) True >>> is_leap_year(1700) False >>> is_leap_year(2400) True","solution":"def is_leap_year(year: int) -> bool: Determine if a given year is a leap year. A year is a leap year if: - It is divisible by 4, and: - It is not a century year (i.e., not divisible by 100) unless it is also divisible by 400. Args: year (int): The year to check. Should be between 1 and 9999 (inclusive). Returns: bool: True if the year is a leap year, False otherwise. if year < 1 or year > 9999: raise ValueError(\\"Year must be between 1 and 9999 (inclusive)\\") if (year % 4 == 0) and (year % 100 != 0 or year % 400 == 0): return True return False"},{"question":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in a string. If no such character exists, returns an empty string. >>> first_non_repeating_character(\\"stress\\") == \\"t\\" >>> first_non_repeating_character(\\"loveleetcode\\") == \\"v\\" >>> first_non_repeating_character(\\"aabbcc\\") == \\"\\" >>> first_non_repeating_character(\\"a\\") == \\"a\\" >>> first_non_repeating_character(\\"\\") == \\"\\"","solution":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the given string. If no such character exists, returns an empty string. # Dictionary to store counts of each character char_count = {} # Populate the dictionary with character counts for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character with a count of 1 for char in s: if char_count[char] == 1: return char # If no non-repeating character is found, return an empty string return \\"\\""},{"question":"from typing import List, Dict, Tuple def find_bridges(graph: Dict[int, List[int]]) -> List[Tuple[int, int]]: Identifies all bridges in an undirected graph. A bridge (or cut-edge) is an edge which, when removed, increases the number of connected components in the graph. >>> graph = {0: [1, 2], 1: [0, 2], 2: [0, 1, 3, 5], 3: [2, 4], 4: [3], 5: [2, 6, 8], 6: [5, 7], 7: [6, 8], 8: [5, 7]} >>> find_bridges(graph) [(2, 3), (2, 5), (3, 4)] pass def test_example_case(): graph = { 0: [1, 2], 1: [0, 2], 2: [0, 1, 3, 5], 3: [2, 4], 4: [3], 5: [2, 6, 8], 6: [5, 7], 7: [6, 8], 8: [5, 7], } assert sorted(find_bridges(graph)) == sorted([(2, 3), (2, 5), (3, 4)]) def test_no_bridges(): graph = { 0: [1, 2, 3], 1: [0, 2, 3], 2: [0, 1, 3], 3: [0, 1, 2] } assert find_bridges(graph) == [] def test_single_bridge(): graph = {0: [1], 1: [0]} assert find_bridges(graph) == [(0, 1)] def test_disconnected_graph(): graph = { 0: [1], 1: [0], 2: [3], 3: [2] } assert sorted(find_bridges(graph)) == sorted([(0, 1), (2, 3)]) def test_large_graph_with_multiple_bridges(): graph = { 0: [1, 2], 1: [0, 2, 3], 2: [0, 1, 4], 3: [1], 4: [2, 5], 5: [4, 6, 7], 6: [5], 7: [5] } assert sorted(find_bridges(graph)) == sorted([(1, 3), (2, 4), (4, 5), (5, 6), (5, 7)])","solution":"from typing import List, Dict, Tuple def find_bridges(graph: Dict[int, List[int]]) -> List[Tuple[int, int]]: def dfs(u, parent): nonlocal timer vis[u] = True tin[u] = low[u] = timer timer += 1 for v in graph[u]: if v == parent: continue if vis[v]: # Back edge low[u] = min(low[u], tin[v]) else: # Tree edge dfs(v, u) low[u] = min(low[u], low[v]) if low[v] > tin[u]: bridges.append((u, v)) n = len(graph) timer = 0 tin = [-1] * n low = [-1] * n vis = [False] * n bridges = [] for i in graph: if not vis[i]: dfs(i, -1) return bridges"},{"question":"def get_attribute(records: dict, record_id: str, attr_key: str) -> any: Fetches the value of an attribute for a given record. Args: records (dict): The dictionary containing the records. record_id (str): The ID of the record. attr_key (str): The key of the attribute to retrieve. Returns: any: The value of the attribute. Raises: KeyError: If the \`record_id\` or \`attr_key\` does not exist. pass def update_attribute(records: dict, record_id: str, attr_key: str, attr_value: any) -> None: Updates the value of an attribute for a given record. Args: records (dict): The dictionary containing the records. record_id (str): The ID of the record. attr_key (str): The key of the attribute to update. attr_value (any): The new value of the attribute. Returns: None Raises: KeyError: If the \`record_id\` or \`attr_key\` does not exist. pass import pytest def test_get_existing_attribute(): records = { \\"ID1\\": { \\"name\\": \\"Alice\\", \\"age\\": 30, \\"attributes\\": { \\"height\\": 165, \\"weight\\": 68, \\"hobbies\\": [\\"reading\\", \\"swimming\\"] } } } assert get_attribute(records, \\"ID1\\", \\"height\\") == 165 def test_get_nonexistent_record(): records = { \\"ID1\\": { \\"name\\": \\"Alice\\", \\"age\\": 30, \\"attributes\\": { \\"height\\": 165, \\"weight\\": 68, \\"hobbies\\": [\\"reading\\", \\"swimming\\"] } } } with pytest.raises(KeyError, match=\\"The record ID 'ID2' does not exist.\\"): get_attribute(records, \\"ID2\\", \\"height\\") def test_get_nonexistent_attribute(): records = { \\"ID1\\": { \\"name\\": \\"Alice\\", \\"age\\": 30, \\"attributes\\": { \\"height\\": 165, \\"weight\\": 68, \\"hobbies\\": [\\"reading\\", \\"swimming\\"] } } } with pytest.raises(KeyError, match=\\"The attribute 'unknown_attr' does not exist within record 'ID1'.\\"): get_attribute(records, \\"ID1\\", \\"unknown_attr\\") def test_update_existing_attribute(): records = { \\"ID1\\": { \\"name\\": \\"Alice\\", \\"age\\": 30, \\"attributes\\": { \\"height\\": 165, \\"weight\\": 68, \\"hobbies\\": [\\"reading\\", \\"swimming\\"] } } } update_attribute(records, \\"ID1\\", \\"weight\\", 70) assert records[\\"ID1\\"][\\"attributes\\"][\\"weight\\"] == 70 def test_update_nonexistent_record(): records = { \\"ID1\\": { \\"name\\": \\"Alice\\", \\"age\\": 30, \\"attributes\\": { \\"height\\": 165, \\"weight\\": 68, \\"hobbies\\": [\\"reading\\", \\"swimming\\"] } } } with pytest.raises(KeyError, match=\\"The record ID 'ID2' does not exist.\\"): update_attribute(records, \\"ID2\\", \\"weight\\", 70) def test_update_nonexistent_attribute(): records = { \\"ID1\\": { \\"name\\": \\"Alice\\", \\"age\\": 30, \\"attributes\\": { \\"height\\": 165, \\"weight\\": 68, \\"hobbies\\": [\\"reading\\", \\"swimming\\"] } } } with pytest.raises(KeyError, match=\\"The attribute 'unknown_attr' does not exist within record 'ID1'.\\"): update_attribute(records, \\"ID1\\", \\"unknown_attr\\", 80)","solution":"def get_attribute(records, record_id: str, attr_key: str): Fetches the value of an attribute for a given record. Args: records (dict): The dictionary containing the records. record_id (str): The ID of the record. attr_key (str): The key of the attribute to retrieve. Returns: any: The value of the attribute. Raises: KeyError: If the \`record_id\` or \`attr_key\` does not exist. if record_id not in records: raise KeyError(f\\"The record ID '{record_id}' does not exist.\\") if attr_key not in records[record_id][\\"attributes\\"]: raise KeyError(f\\"The attribute '{attr_key}' does not exist within record '{record_id}'.\\") return records[record_id][\\"attributes\\"][attr_key] def update_attribute(records, record_id: str, attr_key: str, attr_value: any) -> None: Updates the value of an attribute for a given record. Args: records (dict): The dictionary containing the records. record_id (str): The ID of the record. attr_key (str): The key of the attribute to update. attr_value (any): The new value of the attribute. Returns: None Raises: KeyError: If the \`record_id\` or \`attr_key\` does not exist. if record_id not in records: raise KeyError(f\\"The record ID '{record_id}' does not exist.\\") if attr_key not in records[record_id][\\"attributes\\"]: raise KeyError(f\\"The attribute '{attr_key}' does not exist within record '{record_id}'.\\") records[record_id][\\"attributes\\"][attr_key] = attr_value"},{"question":"def validate_expression(expression: str) -> bool: Validate if the given expression has balanced brackets. Supports (), [], {} brackets. >>> validate_expression(\\"{[()]}\\") True >>> validate_expression(\\"{[(])}\\") False >>> validate_expression(\\"[({})](]\\") False >>> validate_expression(\\"\\") True >>> validate_expression(\\"a[b(c)d]{e}\\") True >>> validate_expression(\\"(\\") False >>> validate_expression(\\")\\") False >>> validate_expression(\\"{[}\\") False >>> validate_expression(\\"(((())))\\") True >>> validate_expression(\\"(((()))\\") False pass","solution":"def validate_expression(expression): Validate if the given expression has balanced brackets. Supports (), [], {} brackets. stack = [] bracket_map = {')': '(', ']': '[', '}': '{'} for char in expression: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return False return stack == []"},{"question":"def most_frequent_product(transactions: list) -> str: Identifies the product with the highest frequency of sales. In case of a tie, returns the product that appears first in the list. Example: >>> most_frequent_product(['apple', 'banana', 'apple', 'orange', 'banana', 'apple']) 'apple' >>> most_frequent_product(['toy', 'book', 'toy', 'pen', 'pen', 'book']) 'toy'","solution":"def most_frequent_product(transactions: list) -> str: Identifies the product with the highest frequency of sales. In case of a tie, returns the product that appears first in the list. from collections import defaultdict # Record the frequency count and the first occurrence index of each product product_count = defaultdict(int) product_first_index = {} for i, product in enumerate(transactions): if product not in product_first_index: product_first_index[product] = i product_count[product] += 1 # Determine the product with the highest frequency and earliest first occurrence in case of tie most_frequent = None highest_count = 0 for product, count in product_count.items(): if count > highest_count or (count == highest_count and product_first_index[product] < product_first_index[most_frequent]): highest_count = count most_frequent = product return most_frequent"},{"question":"from typing import List def sum_of_products(arrays: List[List[int]]) -> int: Compute the sum of all possible products formed by picking one element from each of the given integer arrays. >>> sum_of_products([[1, 2], [3, 4]]) # 1*3 + 1*4 + 2*3 + 2*4 21 >>> sum_of_products([[1], [2], [3]]) # 1*2*3 6 >>> sum_of_products([[-1, 1], [-2, 2]]) # -1*-2 + -1*2 + 1*-2 + 1*2 0 def test_example_case_1(): assert sum_of_products([[1, 2], [3, 4]]) == 21 def test_example_case_2(): assert sum_of_products([[1], [2], [3]]) == 6 def test_example_case_3(): assert sum_of_products([[-1, 1], [-2, 2]]) == 0 def test_single_element_arrays(): assert sum_of_products([[1], [1]]) == 1 def test_mixed_sign_numbers(): assert sum_of_products([[1, -1], [1, -1]]) == 0 def test_zero_in_array(): assert sum_of_products([[0], [1, 2, 3], [4, 5]]) == 0 def test_large_numbers(): assert sum_of_products([[10**3], [10**3], [10**3]]) == 10**9 def test_minimum_and_maximum_elements(): assert sum_of_products([[-1000, 1000], [1000, -1000]]) == 0","solution":"from typing import List def sum_of_products(arrays: List[List[int]]) -> int: from itertools import product total_sum = 0 for combination in product(*arrays): current_product = 1 for num in combination: current_product *= num total_sum += current_product return total_sum"},{"question":"class URLShortener: A class to simulate a simple URL shortening service. Methods: encode(long_url: str) -> str: Takes a long URL and returns a unique shortened URL. decode(short_url: str) -> str: Takes a shortened URL and returns the original long URL. >>> shortener = URLShortener() >>> short_url = shortener.encode(\\"https://www.example.com\\") >>> short_url.startswith(\\"http://short.url/\\") True >>> shortener.decode(short_url) == \\"https://www.example.com\\" True def __init__(self): self.url_to_code = {} self.code_to_url = {} self.base_url = \\"http://short.url/\\" self.counter = 0 def encode(self, long_url: str) -> str: pass def decode(self, short_url: str) -> str: pass def _int_to_code(self, num: int) -> str: pass def test_encode_decode(): shortener = URLShortener() url = \\"https://www.example.com\\" short_url = shortener.encode(url) assert short_url.startswith(\\"http://short.url/\\") decoded_url = shortener.decode(short_url) assert decoded_url == url def test_consistent_shortening(): shortener = URLShortener() url = \\"https://www.example.com\\" short_url1 = shortener.encode(url) short_url2 = shortener.encode(url) assert short_url1 == short_url2 def test_different_urls(): shortener = URLShortener() url1 = \\"https://www.example1.com\\" url2 = \\"https://www.example2.com\\" short_url1 = shortener.encode(url1) short_url2 = shortener.encode(url2) assert short_url1 != short_url2 assert shortener.decode(short_url1) == url1 assert shortener.decode(short_url2) == url2 def test_edge_case_empty_url(): shortener = URLShortener() url = \\"\\" short_url = shortener.encode(url) assert short_url.startswith(\\"http://short.url/\\") decoded_url = shortener.decode(short_url) assert decoded_url == url","solution":"import hashlib class URLShortener: def __init__(self): self.url_to_code = {} self.code_to_url = {} self.base_url = \\"http://short.url/\\" self.counter = 0 def encode(self, long_url: str) -> str: if long_url in self.url_to_code: return self.url_to_code[long_url] # Generate a unique code using the counter value self.counter += 1 unique_code = self._int_to_code(self.counter) short_url = self.base_url + unique_code self.url_to_code[long_url] = short_url self.code_to_url[unique_code] = long_url return short_url def decode(self, short_url: str) -> str: unique_code = short_url.split(\\"/\\")[-1] return self.code_to_url.get(unique_code, \\"\\") def _int_to_code(self, num: int) -> str: chars = \\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\" base = len(chars) code = [] while num > 0: code.append(chars[num % base]) num //= base return \\"\\".join(reversed(code)) # Example usage shortener = URLShortener() short_url = shortener.encode(\\"https://www.example.com\\") print(short_url) # E.g., \\"http://short.url/1\\" original_url = shortener.decode(short_url) print(original_url) # \\"https://www.example.com\\""},{"question":"from typing import List def sort_books(titles: List[str]) -> List[str]: Sorts a list of book titles in alphabetical order (case-insensitive). Parameters: - titles (List[str]): A list of book titles where each title is a non-empty string. Returns: - List[str]: A list of book titles sorted alphabetically (case-insensitive). pass def test_sort_books_basic(): titles = [\\"The Great Gatsby\\", \\"Moby Dick\\", \\"Hamlet\\", \\"War and Peace\\"] sorted_titles = sort_books(titles) expected = ['Hamlet', 'Moby Dick', 'The Great Gatsby', 'War and Peace'] assert sorted_titles == expected def test_sort_books_case_insensitive(): titles = [\\"A Tale of Two Cities\\", \\"a tale of two cities\\", \\"Pride and Prejudice\\"] sorted_titles = sort_books(titles) expected = ['A Tale of Two Cities', 'a tale of two cities', 'Pride and Prejudice'] assert sorted_titles == expected def test_sort_books_mixed_case(): titles = [\\"zoo\\", \\"Alpha\\", \\"Bravo\\", \\"charlie\\"] sorted_titles = sort_books(titles) expected = ['Alpha', 'Bravo', 'charlie', 'zoo'] def test_sort_books_with_spaces(): titles = [\\"The Quick Brown Fox\\", \\"Jumps Over\\", \\"The Lazy Dog\\", \\"Running Fast\\"] sorted_titles = sort_books(titles) expected = [\\"Jumps Over\\", \\"Running Fast\\", \\"The Lazy Dog\\", \\"The Quick Brown Fox\\"] assert sorted_titles == expected def test_sort_books_single_book(): titles = [\\"An Only Book\\"] sorted_titles = sort_books(titles) expected = [\\"An Only Book\\"] assert sorted_titles == expected def test_sort_books_identical_books(): titles = [\\"Same Book\\", \\"Same Book\\", \\"Same Book\\"] sorted_titles = sort_books(titles) expected = [\\"Same Book\\", \\"Same Book\\", \\"Same Book\\"] assert sorted_titles == expected","solution":"from typing import List def sort_books(titles: List[str]) -> List[str]: Sorts a list of book titles in alphabetical order (case-insensitive). Parameters: - titles (List[str]): A list of book titles where each title is a non-empty string. Returns: - List[str]: A list of book titles sorted alphabetically (case-insensitive). return sorted(titles, key=lambda title: title.lower())"},{"question":"def build_flow_graph(vertices, edges): Build a graph from given vertices and edges for flow calculations. :param vertices: List of vertex identifiers :param edges: List of edges represented as tuples (vertex1, vertex2, capacity) :return: Representation of the graph suitable for flow calculations def ford_fulkerson_max_flow(graph, source, sink): Apply the Ford-Fulkerson algorithm to find the maximum flow from source to sink. :param graph: The graph as constructed by build_flow_graph :param source: The source vertex identifier :param sink: The sink vertex identifier :return: An integer representing the maximum flow value def test_single_path(): vertices = [0, 1] edges = [(0, 1, 10)] source = 0 sink = 1 graph = build_flow_graph(vertices, edges) assert ford_fulkerson_max_flow(graph, source, sink) == 10 def test_two_parallel_paths(): vertices = [0, 1, 2, 3] edges = [(0, 1, 10), (0, 2, 10), (1, 3, 10), (2, 3, 10)] source = 0 sink = 3 graph = build_flow_graph(vertices, edges) assert ford_fulkerson_max_flow(graph, source, sink) == 20 def test_bottleneck_in_graph(): vertices = [0, 1, 2, 3, 4] edges = [(0, 1, 20), (1, 2, 30), (2, 3, 10), (3, 4, 20)] source = 0 sink = 4 graph = build_flow_graph(vertices, edges) assert ford_fulkerson_max_flow(graph, source, sink) == 10 def test_multiple_paths_with_different_capacities(): vertices = [0, 1, 2, 3] edges = [(0, 1, 15), (0, 2, 10), (1, 3, 10), (2, 3, 5)] source = 0 sink = 3 graph = build_flow_graph(vertices, edges) assert ford_fulkerson_max_flow(graph, source, sink) == 15 def test_cyclic_graph(): vertices = [0, 1, 2] edges = [(0, 1, 10), (1, 2, 5), (2, 0, 7)] source = 0 sink = 2 graph = build_flow_graph(vertices, edges) assert ford_fulkerson_max_flow(graph, source, sink) == 5","solution":"def build_flow_graph(vertices, edges): Build a graph from given vertices and edges for flow calculations. :param vertices: List of vertex identifiers :param edges: List of edges represented as tuples (vertex1, vertex2, capacity) :return: Representation of the graph suitable for flow calculations graph = {vertex: {} for vertex in vertices} for v1, v2, capacity in edges: if v2 not in graph[v1]: graph[v1][v2] = 0 if v1 not in graph[v2]: graph[v2][v1] = 0 graph[v1][v2] += capacity return graph def ford_fulkerson_max_flow(graph, source, sink): Apply the Ford-Fulkerson algorithm to find the maximum flow from source to sink. :param graph: The graph as constructed by build_flow_graph :param source: The source vertex identifier :param sink: The sink vertex identifier :return: An integer representing the maximum flow value def dfs(source, sink, visited): stack = [(source, float('Inf'))] paths = {source: []} while stack: u, flow = stack.pop() for v in graph[u]: if v not in visited and graph[u][v] > 0: visited.add(v) stack.append((v, min(flow, graph[u][v]))) paths[v] = paths[u] + [(u, v)] if v == sink: return paths[v], stack[-1][1] return None, 0 max_flow = 0 visited = set() path, path_flow = dfs(source, sink, visited) while path is not None: max_flow += path_flow # Update the capacities in the reverse direction: for u, v in path: graph[u][v] -= path_flow graph[v][u] += path_flow visited = set() path, path_flow = dfs(source, sink, visited) return max_flow"},{"question":"def first_recurring_character(s: str) -> str: Determine the first recurring character in a string. Returns the first recurring character in the string 's'. If no characters recur, returns None. Validates that the input is a string and raises a TypeError otherwise. >>> first_recurring_character(\\"acbbac\\") 'b' >>> first_recurring_character(\\"abcdef\\") None >>> first_recurring_character(\\"aabbcc\\") 'a' >>> first_recurring_character(12345) Traceback (most recent call last): ... TypeError: Input must be a string","solution":"def first_recurring_character(s): Returns the first recurring character in the string 's'. If no characters recur, returns None. if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") seen = set() for char in s: if char in seen: return char seen.add(char) return None"},{"question":"def next_palindrome(number: int) -> int: Finds the smallest palindrome integer greater than the input integer. Args: number (int): The input integer. Returns: int: The smallest palindrome integer greater than the given number. Raises: ValueError: If number is not an integer or if number is negative. Examples: >>> next_palindrome(123) 131 >>> next_palindrome(99) 101 >>> next_palindrome(121) 131 >>> next_palindrome(1001) 1111 >>> next_palindrome(0) 1 >>> next_palindrome(-10) Traceback (most recent call last): ... ValueError: Expected a non-negative integer, but got -10 >>> next_palindrome(\\"123\\") Traceback (most recent call last): ... ValueError: Expected an integer input, but got <class 'str'>","solution":"def next_palindrome(number: int) -> int: Finds the smallest palindrome integer greater than the input integer. Args: number (int): The input integer. Returns: int: The smallest palindrome integer greater than the given number. if not isinstance(number, int): raise ValueError(f\\"Expected an integer input, but got {type(number)}\\") if number < 0: raise ValueError(f\\"Expected a non-negative integer, but got {number}\\") def is_palindrome(n): return str(n) == str(n)[::-1] number += 1 while not is_palindrome(number): number += 1 return number"},{"question":"class BalancedBST: def __init__(self): Initialize an empty balanced binary search tree. pass def insert(self, key: int) -> None: Insert a key into the balanced binary search tree. Parameters: key (int): The key to be inserted. pass def delete(self, key: int) -> None: Delete a key from the balanced binary search tree. Parameters: key (int): The key to be deleted. Raises: KeyError: When the key is not found in the tree. pass def search(self, key: int) -> bool: Search for a key in the balanced binary search tree. Parameters: key (int): The key to search for. Returns: bool: True if the key is found, otherwise False. pass # Test Cases def test_insert(): tree = BalancedBST() tree.insert(10) tree.insert(20) tree.insert(5) assert tree.search(10) assert tree.search(20) assert tree.search(5) assert not tree.search(15) def test_delete(): tree = BalancedBST() tree.insert(10) tree.insert(20) tree.insert(5) tree.delete(10) assert not tree.search(10) assert tree.search(20) assert tree.search(5) def test_search(): tree = BalancedBST() assert not tree.search(10) tree.insert(30) tree.insert(40) tree.insert(35) assert tree.search(40) tree.delete(40) assert not tree.search(40) tree.insert(25) assert tree.search(25) def test_multiple_operations(): tree = BalancedBST() tree.insert(10) tree.insert(5) tree.insert(15) tree.delete(10) assert not tree.search(10) assert tree.search(5) assert tree.search(15) tree.insert(20) tree.insert(2) assert tree.search(20) assert tree.search(2) tree.delete(5) assert not tree.search(5) tree.delete(20) assert not tree.search(20) def test_key_error_on_delete_non_existing(): tree = BalancedBST() try: tree.delete(10) except KeyError: passed = True else: passed = False assert passed","solution":"class Node: def __init__(self, key, left=None, right=None): self.key = key self.left = left self.right = right self.height = 1 class BalancedBST: def __init__(self): self.root = None def insert(self, key: int) -> None: self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return Node(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._right_rotate(node) if balance < -1 and key > node.right.key: return self._left_rotate(node) if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def delete(self, key: int) -> None: self.root, _ = self._delete(self.root, key) def _delete(self, node, key): if not node: raise KeyError(\\"Key not found\\") if key < node.key: node.left, deleted_node = self._delete(node.left, key) elif key > node.key: node.right, deleted_node = self._delete(node.right, key) else: deleted_node = node if not node.left: return node.right, deleted_node elif not node.right: return node.left, deleted_node temp = self._get_min_value_node(node.right) node.key = temp.key node.right, _ = self._delete(node.right, temp.key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and self._get_balance(node.left) >= 0: return self._right_rotate(node), deleted_node if balance > 1 and self._get_balance(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node), deleted_node if balance < -1 and self._get_balance(node.right) <= 0: return self._left_rotate(node), deleted_node if balance < -1 and self._get_balance(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node), deleted_node return node, deleted_node def search(self, key: int) -> bool: return self._search(self.root, key) def _search(self, node, key): if not node: return False if key == node.key: return True elif key < node.key: return self._search(node.left, key) else: return self._search(node.right, key) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) return x def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left)"},{"question":"from typing import Optional class CircularQueue: A fixed-size, efficient, circular queue data structure for data processing. Methods: __init__(self, capacity: int) -> None: Initializes the circular queue with the given capacity. enqueue(self, value: int) -> bool: Adds a value to the queue. Returns True if the operation is successful, or False if the queue is full. dequeue(self) -> Optional[int]: Removes and returns the front element from the queue. Returns None if the queue is empty. is_empty(self) -> bool: Checks if the queue is empty. Returns True if empty, False otherwise. is_full(self) -> bool: Checks if the queue is full. Returns True if full, False otherwise. Example: >>> cq = CircularQueue(3) >>> cq.enqueue(10) True >>> cq.enqueue(20) True >>> cq.enqueue(30) True >>> cq.enqueue(40) False # Queue is full >>> cq.dequeue() 10 >>> cq.dequeue() 20 >>> cq.is_empty() False >>> cq.is_full() False >>> cq.enqueue(50) True >>> cq.dequeue() 30 >>> cq.dequeue() 50 >>> cq.dequeue() None # Queue is empty def __init__(self, capacity: int) -> None: pass def enqueue(self, value: int) -> bool: pass def dequeue(self) -> Optional[int]: pass def is_empty(self) -> bool: pass def is_full(self) -> bool: pass def test_circular_queue_operations(): cq = CircularQueue(3) assert cq.is_empty() == True assert cq.is_full() == False assert cq.enqueue(10) == True assert cq.enqueue(20) == True assert cq.enqueue(30) == True assert cq.enqueue(40) == False assert cq.dequeue() == 10 assert cq.dequeue() == 20 assert cq.is_empty() == False assert cq.is_full() == False assert cq.enqueue(50) == True assert cq.dequeue() == 30 assert cq.dequeue() == 50 assert cq.dequeue() == None assert cq.is_empty() == True assert cq.is_full() == False def test_circular_queue_edge_cases(): cq = CircularQueue(1) assert cq.is_empty() == True assert cq.is_full() == False assert cq.enqueue(10) == True assert cq.is_full() == True assert cq.is_empty() == False assert cq.enqueue(20) == False assert cq.dequeue() == 10 assert cq.dequeue() == None assert cq.is_empty() == True assert cq.is_full() == False def test_circular_queue_wrap_around(): cq = CircularQueue(3) assert cq.enqueue(1) == True assert cq.enqueue(2) == True assert cq.enqueue(3) == True assert cq.is_full() == True assert cq.dequeue() == 1 assert cq.dequeue() == 2 assert cq.enqueue(4) == True assert cq.enqueue(5) == True assert cq.is_full() == True assert cq.dequeue() == 3 assert cq.dequeue() == 4 assert cq.dequeue() == 5 assert cq.dequeue() == None","solution":"from typing import Optional class CircularQueue: def __init__(self, capacity: int) -> None: self.capacity = capacity self.queue = [0] * capacity self.head = -1 self.tail = -1 self.size = 0 def enqueue(self, value: int) -> bool: if self.is_full(): return False if self.is_empty(): self.head = 0 self.tail = (self.tail + 1) % self.capacity self.queue[self.tail] = value self.size += 1 return True def dequeue(self) -> Optional[int]: if self.is_empty(): return None value = self.queue[self.head] self.queue[self.head] = 0 # Optional: Reset the value for debugging purposes if self.head == self.tail: # Queue becomes empty self.head = -1 self.tail = -1 else: self.head = (self.head + 1) % self.capacity self.size -= 1 return value def is_empty(self) -> bool: return self.size == 0 def is_full(self) -> bool: return self.size == self.capacity"},{"question":"def union_of_sets(list1: list, list2: list) -> list: Compute the union of two lists, sort the result in ascending order, and remove any duplicates. Parameters: - list1 (list): A list of integers. - list2 (list): Another list of integers. Returns: - list: A sorted list of the union of the input lists with duplicates removed. Examples: >>> union_of_sets([1, 2, 3, 5, 7], [3, 4, 5, 6]) [1, 2, 3, 4, 5, 6, 7] >>> union_of_sets([10, 20, 30, 40], [30, 40, 50, 60]) [10, 20, 30, 40, 50, 60] >>> union_of_sets([], [1, 2, 3]) [1, 2, 3] >>> union_of_sets([4, 5, 6], []) [4, 5, 6] pass # Unit tests def test_union_with_overlapping_lists(): assert union_of_sets([1, 2, 3, 5, 7], [3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6, 7] def test_union_with_non_overlapping_lists(): assert union_of_sets([10, 20, 30, 40], [30, 40, 50, 60]) == [10, 20, 30, 40, 50, 60] def test_union_with_empty_and_non_empty_lists(): assert union_of_sets([], [1, 2, 3]) == [1, 2, 3] assert union_of_sets([4, 5, 6], []) == [4, 5, 6] def test_union_with_both_empty_lists(): assert union_of_sets([], []) == [] def test_union_with_duplicates_in_lists(): assert union_of_sets([1, 2, 2, 3], [3, 4, 4, 5]) == [1, 2, 3, 4, 5] def test_union_with_large_numbers(): assert union_of_sets([10**6, -10**6], [-10**6, 10**6 + 1]) == [-10**6, 10**6, 10**6 + 1]","solution":"def union_of_sets(list1: list, list2: list) -> list: Compute the union of two lists, sort the result in ascending order, and remove any duplicates. Parameters: - list1 (list): A list of integers. - list2 (list): Another list of integers. Returns: - list: A sorted list of the union of the input lists with duplicates removed. result_set = set(list1).union(set(list2)) sorted_list = sorted(result_set) return sorted_list"},{"question":"import os from datetime import datetime from typing import List, Dict, Union def fetch_file_metadata(filepaths: List[str]) -> Dict[str, Union[Dict[str, Union[int, str]], str]]: Implement a function to read and interpret metadata from a series of files, returning the relevant metadata in a structured format. Args: filepaths (List[str]): A list of file paths. Returns: Dict[str, Union[Dict[str, Union[int, str]], str]]: A dictionary containing the file paths as keys and their metadata as values. The metadata dictionary has the following keys: - size (int): Size of the file in bytes. - creation_date (str): Creation date of the file in ISO 8601 format. - modification_date (str): Last modification date of the file in ISO 8601 format. - type (str): File type (e.g., \\"text\\", \\"image\\", \\"video\\"). If the file path is invalid, the value will be \\"File not found or inaccessible.\\" >>> fetch_file_metadata([\\"/path/to/file1.txt\\", \\"/path/to/nonexistentfile\\", \\"/path/to/file2.jpg\\"]) { \\"/path/to/file1.txt\\": { \\"size\\": 1024, \\"creation_date\\": \\"2023-01-15T08:30:25Z\\", \\"modification_date\\": \\"2023-05-10T14:12:01Z\\", \\"type\\": \\"text\\" }, \\"/path/to/file2.jpg\\": { \\"size\\": 2048, \\"creation_date\\": \\"2022-11-09T17:45:00Z\\", \\"modification_date\\": \\"2023-04-22T19:24:45Z\\", \\"type\\": \\"image\\" }, \\"/path/to/nonexistentfile\\": \\"File not found or inaccessible.\\" } >>> fetch_file_metadata([\\"\\"]) {} >>> fetch_file_metadata([\\"/path/to/file3.mp4\\", None]) { \\"/path/to/file3.mp4\\": { \\"size\\": 5000000, \\"creation_date\\": \\"2021-12-01T12:05:00Z\\", \\"modification_date\\": \\"2023-01-15T09:10:10Z\\", \\"type\\": \\"video\\" } } pass","solution":"import os import mimetypes from datetime import datetime def fetch_file_metadata(filepaths: list) -> dict: def get_file_metadata(filepath): if not os.path.exists(filepath): return \\"File not found or inaccessible.\\" try: size = os.path.getsize(filepath) creation_date = datetime.utcfromtimestamp(os.path.getctime(filepath)).isoformat() + 'Z' modification_date = datetime.utcfromtimestamp(os.path.getmtime(filepath)).isoformat() + 'Z' file_type, _ = mimetypes.guess_type(filepath) file_type = file_type.split('/')[0] if file_type else 'unknown' return { \\"size\\": size, \\"creation_date\\": creation_date, \\"modification_date\\": modification_date, \\"type\\": file_type } except Exception as e: return f\\"Error reading file: {e}\\" metadata_dict = {} for filepath in filepaths: if filepath: metadata_dict[filepath] = get_file_metadata(filepath) return metadata_dict"},{"question":"def moving_average_filter(numbers: List[float], window_size: int) -> List[float]: Computes the moving average of the input list with a specified window size. Parameters: numbers (List[float]): A list of floating-point numbers representing the input signal. window_size (int): An integer defining the size of the moving window. Returns: List[float]: A list of floating-point numbers where each element is the moving average of the corresponding window in the input list. Examples: >>> moving_average_filter([1, 2, 3, 4, 5], 3) [2.0, 3.0, 4.0] >>> moving_average_filter([5, 6, 7, 8, 9, 10], 2) [5.5, 6.5, 7.5, 8.5, 9.5] >>> moving_average_filter([10, 20, 30, 40], 4) [25.0]","solution":"from typing import List def moving_average_filter(numbers: List[float], window_size: int) -> List[float]: Computes the moving average of the input list with a specified window size. Parameters: numbers (List[float]): A list of floating-point numbers representing the input signal. window_size (int): An integer defining the size of the moving window. Returns: List[float]: A list of floating-point numbers where each element is the moving average of the corresponding window in the input list. if not numbers or window_size <= 0 or window_size > len(numbers): return [] moving_averages = [] window_sum = sum(numbers[:window_size]) moving_averages.append(window_sum / window_size) for i in range(window_size, len(numbers)): window_sum = window_sum - numbers[i - window_size] + numbers[i] moving_averages.append(window_sum / window_size) return moving_averages"},{"question":"from typing import List def kth_smallest_element(arr: List[int], k: int) -> int: Find the k-th smallest element in the array. >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 3) 7 >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 4) 10 >>> kth_smallest_element([1, 2, 3, 4, 5], 1) 1 >>> kth_smallest_element([5, 4, 3, 2, 1], 5) 5 >>> kth_smallest_element([1, 1, 2, 3, 3, 3, 4, 5], 4) 3 >>> kth_smallest_element([-10, 0, 10, -5, 5], 2) -5 >>> kth_smallest_element([1], 1) 1 >>> kth_smallest_element([2, 2, 2, 2, 2], 3) 2 >>> kth_smallest_element([3, 2, 1, 5, 6, 4], 2) 2 pass","solution":"def kth_smallest_element(arr, k): Function to find the k-th smallest element in an array. Args: arr : List[int] - The list of integers. k : int - The k-th position (1-based index) to find the smallest element. Returns: int - The k-th smallest element in the array. def partition(low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i+1], arr[high] = arr[high], arr[i+1] return i+1 def quickselect(low, high, k): if low == high: return arr[low] pivot_index = partition(low, high) if k == pivot_index: return arr[k] elif k < pivot_index: return quickselect(low, pivot_index - 1, k) else: return quickselect(pivot_index + 1, high, k) return quickselect(0, len(arr) - 1, k - 1)"},{"question":"def depth_first_search(graph: dict, start_node: int) -> list: Perform Depth-First Search (DFS) on a graph represented as an adjacency list. Return a list of nodes in the order they are first visited. >>> graph = { ... 0: [1, 2], ... 1: [0, 3, 4], ... 2: [0, 5, 6], ... 3: [1], ... 4: [1], ... 5: [2], ... 6: [2] ... } >>> start_node = 0 >>> depth_first_search(graph, start_node) [0, 1, 3, 4, 2, 5, 6]","solution":"def depth_first_search(graph: dict, start_node: int) -> list: visited = [] stack = [start_node] while stack: node = stack.pop() if node not in visited: visited.append(node) # Add neighbors in reverse order to visit them in the correct sequence stack.extend(reversed(graph.get(node, []))) return visited"},{"question":"# Matrix Rotation Challenge Objective Implement a function that rotates a given NxN matrix by 90 degrees clockwise. The function should modify the matrix in place, meaning that you should not use extra space for another matrix. Function Signature def rotate_matrix(mat: list[list[int]]) -> None: pass Unit Test: from solution import rotate_matrix def test_3x3_matrix(): mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(mat) expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert mat == expected def test_4x4_matrix(): mat = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_matrix(mat) expected = [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] assert mat == expected def test_1x1_matrix(): mat = [ [1] ] rotate_matrix(mat) expected = [ [1] ] assert mat == expected def test_2x2_matrix(): mat = [ [1, 2], [3, 4] ] rotate_matrix(mat) expected = [ [3, 1], [4, 2] ] assert mat == expected def test_5x5_matrix(): mat = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] rotate_matrix(mat) expected = [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ] assert mat == expected","solution":"def rotate_matrix(mat: list[list[int]]) -> None: Rotates the given NxN matrix by 90 degrees clockwise in place. n = len(mat) # Transpose the matrix for i in range(n): for j in range(i, n): mat[i][j], mat[j][i] = mat[j][i], mat[i][j] # Reverse each row for i in range(n): mat[i].reverse()"},{"question":"def find_first_occurrence(nums: list[int], target: int) -> int: Finds the first occurrence of the target in the sorted list nums. Parameters: nums (list[int]): A list of integers sorted in non-decreasing order. target (int): The target integer to search for. Returns: int: The index of the first occurrence of target, or -1 if target is not present. Example Usage: >>> find_first_occurrence([1, 2, 2, 3, 4, 5], 2) 1 >>> find_first_occurrence([1, 2, 2, 3, 4, 5], 3) 3 >>> find_first_occurrence([1, 2, 3, 4, 5], 6) -1 >>> find_first_occurrence([], 3) -1","solution":"def find_first_occurrence(nums: list[int], target: int) -> int: Finds the first occurrence of the target in the sorted list nums. Parameters: nums (list[int]): A list of integers sorted in non-decreasing order. target (int): The target integer to search for. Returns: int: The index of the first occurrence of target, or -1 if target is not present. left, right = 0, len(nums) - 1 result = -1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: result = mid right = mid - 1 # Look in the left half elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"from typing import List class PatternMatcher: @staticmethod def find_pattern(pattern: str, s: str) -> List[int]: Given a pattern and a string, return a list of the starting indices of all occurrences of the pattern in the string. >>> pm = PatternMatcher() >>> pm.find_pattern('abc', 'abcabcabc') [0, 3, 6] >>> pm.find_pattern('a', 'ababab') [0, 2, 4] >>> pm.find_pattern('ab', 'ababab') [0, 2, 4] >>> pm.find_pattern('xyz', 'abcabcabc') [] # Your code here def test_find_pattern(): pm = PatternMatcher() # Test case 1: Basic match result = pm.find_pattern('abc', 'abcabcabc') assert result == [0, 3, 6] # Test case 2: Single character match result = pm.find_pattern('a', 'ababab') assert result == [0, 2, 4] # Test case 3: Substring match result = pm.find_pattern('ab', 'ababab') assert result == [0, 2, 4] # Test case 4: No match result = pm.find_pattern('xyz', 'abcabcabc') assert result == [] # Test case 5: Pattern equals string result = pm.find_pattern('abcabcabc', 'abcabcabc') assert result == [0] # Test case 6: Empty string or pattern result = pm.find_pattern('', 'abcabcabc') assert result == [] result = pm.find_pattern('abc', '') assert result == [] result = pm.find_pattern('', '') assert result == [] # Test case 7: Overlapping patterns result = pm.find_pattern('aa', 'aaaaa') assert result == [0, 1, 2, 3] # Test case 8: Large input test result = pm.find_pattern('a', 'a' * 100000) assert result == list(range(100000))","solution":"from typing import List class PatternMatcher: @staticmethod def find_pattern(pattern: str, s: str) -> List[int]: Given a pattern and a string, return a list of the starting indices of all occurrences of the pattern in the string. if not pattern or not s: return [] # KMP algorithm to find all occurrences def compute_lps_array(pat: str) -> List[int]: Compute the longest prefix suffix (LPS) array to be used in KMP algorithm. lps = [0] * len(pat) length = 0 # length of the previous longest prefix suffix i = 1 while i < len(pat): if pat[i] == pat[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps pat_len = len(pattern) str_len = len(s) lps = compute_lps_array(pattern) indices = [] i = 0 # index for s j = 0 # index for pattern while i < str_len: if pattern[j] == s[i]: i += 1 j += 1 if j == pat_len: indices.append(i - j) j = lps[j - 1] elif i < str_len and pattern[j] != s[i]: if j != 0: j = lps[j - 1] else: i += 1 return indices"},{"question":"def execute_query(query: str, table: list[dict[str, str]]) -> list[dict[str, str]]: Process a query string on a given table and return the result as specified. >>> query = \\"SELECT name, age FROM table WHERE age = '30' AND city = 'Wonderland'\\" >>> table = [ ... {\\"id\\": \\"1\\", \\"name\\": \\"Alice\\", \\"age\\": \\"30\\", \\"city\\": \\"Wonderland\\"}, ... {\\"id\\": \\"2\\", \\"name\\": \\"Bob\\", \\"age\\": \\"25\\", \\"city\\": \\"Builderland\\"}, ... {\\"id\\": \\"3\\", \\"name\\": \\"Charlie\\", \\"age\\": \\"35\\", \\"city\\": \\"Chocolatetown\\"}, ... {\\"id\\": \\"4\\", \\"name\\": \\"David\\", \\"age\\": \\"30\\", \\"city\\": \\"Desertville\\"} ... ] >>> execute_query(query, table) [{'name': 'Alice', 'age': '30'}] >>> query = \\"SELECT id, name FROM table WHERE age = '25'\\" >>> execute_query(query, table) [{'id': '2', 'name': 'Bob'}] >>> query = \\"SELECT city FROM table WHERE name = 'Charlie'\\" >>> execute_query(query, table) [{'city': 'Chocolatetown'}] >>> query = \\"SELECT name, age FROM table WHERE age = '40' AND city = 'Nowhere'\\" >>> execute_query(query, table) [] >>> query = \\"SELECT name, city FROM table WHERE age = '30'\\" >>> table.append({\\"id\\": \\"5\\", \\"name\\": \\"Eve\\", \\"age\\": \\"30\\", \\"city\\": \\"Wonderland\\"}) >>> execute_query(query, table) [{'name': 'Alice', 'city': 'Wonderland'}, {'name': 'David', 'city': 'Desertville'}, {'name': 'Eve', 'city': 'Wonderland'}]","solution":"def execute_query(query: str, table: list[dict[str, str]]) -> list[dict[str, str]]: # Split query into parts select_part, rest = query.split(' FROM ') from_part, where_part = rest.split(' WHERE ') # Process SELECT clause columns = select_part.replace('SELECT ', '').split(', ') # Process WHERE clause conditions = where_part.split(' AND ') condition_dict = {} for condition in conditions: column, value = condition.split(\\" = \\") condition_dict[column] = value.strip(\\"'\\") # Filter rows result = [] for row in table: match = True for column, value in condition_dict.items(): if row[column] != value: match = False break if match: filtered_row = {col: row[col] for col in columns} result.append(filtered_row) return result"},{"question":"def rotate_array(nums: list[int], k: int) -> list[int]: Rotates the elements of the input array nums by k steps to the right and returns the modified array. >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 8) [3, 4, 5, 1, 2] >>> rotate_array([1], 10) [1] >>> rotate_array([-1, -100, 3, 99], 2) [3, 99, -1, -100]","solution":"def rotate_array(nums, k): Rotates the elements of the array nums by k steps to the right. :param nums: List[int] - list of integers to be rotated :param k: int - number of steps to rotate the array :return: List[int] - rotated array n = len(nums) k = k % n # To handle cases where k is greater than the length of nums return nums[-k:] + nums[:-k]"},{"question":"def fibonacci_basic(n: int) -> int: Returns the n-th Fibonacci number using a direct recursive method. >>> fibonacci_basic(0) 0 >>> fibonacci_basic(10) 55 pass def fibonacci_optimized(n: int) -> int: Returns the n-th Fibonacci number using memoization. >>> fibonacci_optimized(50) 12586269025 >>> fibonacci_optimized(100000) # Should return a large number within a few seconds pass","solution":"def fibonacci_basic(n: int) -> int: Returns the n-th Fibonacci number using a direct recursive method. if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n == 0: return 0 if n == 1: return 1 return fibonacci_basic(n - 1) + fibonacci_basic(n - 2) def fibonacci_optimized(n: int) -> int: Returns the n-th Fibonacci number using memoization. if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") fib_cache = {0: 0, 1: 1} def helper(x): if x in fib_cache: return fib_cache[x] fib_cache[x] = helper(x - 1) + helper(x - 2) return fib_cache[x] return helper(n)"},{"question":"import requests class PaymentProvider: def __init__(self, name, api_url, api_key): self.name = name self.api_url = api_url self.api_key = api_key def execute_payment(self, payment_details): try: response = requests.post(self.api_url, json=payment_details, headers={'Authorization': f'Bearer {self.api_key}'}) response.raise_for_status() return response.json() except requests.exceptions.RequestException as e: return {'status': 'error', 'message': str(e)} providers_config = { 'Stripe': PaymentProvider('Stripe', 'https://api.stripe.com/v1/charges', 'YOUR_STRIPE_API_KEY'), 'PayPal': PaymentProvider('PayPal', 'https://api.paypal.com/v1/payments/payment', 'YOUR_PAYPAL_API_KEY') } def validate_payment_details(payment_details): Validate the payment details. >>> validate_payment_details({'card_number': '1234567812345678', 'expiry_date': '12/23', 'cvv': '123', 'amount': 100.0, 'currency': 'USD'}) (True, \\"\\") >>> validate_payment_details({'card_number': '', 'expiry_date': '12/23', 'cvv': '123', 'amount': 100.0, 'currency': 'USD'}) (False, \\"Missing or empty field: card_number\\") >>> validate_payment_details({'card_number': '1234567812345678', 'expiry_date': '12/23', 'cvv': '1234', 'amount': 100.0, 'currency': 'USD'}) (False, \\"Invalid CVV length\\") pass def process_payment(payment_details, provider_name, retry_limit): Process the payment with the given details and provider. >>> process_payment({'card_number': '1234567812345678', 'expiry_date': '12/23', 'cvv': '123', 'amount': 100.0, 'currency': 'USD'}, 'Stripe', 3) \\"Payment successful: Payment processed\\" >>> process_payment({'card_number': '', 'expiry_date': '12/23', 'cvv': '123', 'amount': 100.0, 'currency': 'USD'}, 'Stripe', 3) \\"Validation Error: Missing or empty field: card_number\\" >>> process_payment({'card_number': '1234567812345678', 'expiry_date': '12/23', 'cvv': '123', 'amount': 100.0, 'currency': 'USD'}, 'Dummy', 3) \\"Error: Unsupported provider Dummy\\" pass","solution":"import requests class PaymentProvider: def __init__(self, name, api_url, api_key): self.name = name self.api_url = api_url self.api_key = api_key def execute_payment(self, payment_details): try: response = requests.post(self.api_url, json=payment_details, headers={'Authorization': f'Bearer {self.api_key}'}) response.raise_for_status() return response.json() except requests.exceptions.RequestException as e: return {'status': 'error', 'message': str(e)} # Dummy configurations for Stripe and PayPal providers_config = { 'Stripe': PaymentProvider('Stripe', 'https://api.stripe.com/v1/charges', 'YOUR_STRIPE_API_KEY'), 'PayPal': PaymentProvider('PayPal', 'https://api.paypal.com/v1/payments/payment', 'YOUR_PAYPAL_API_KEY') } def validate_payment_details(payment_details): required_fields = ['card_number', 'expiry_date', 'cvv', 'amount', 'currency'] for field in required_fields: if field not in payment_details or not payment_details[field]: return (False, f\\"Missing or empty field: {field}\\") # Placeholder for more advanced validation logic if len(str(payment_details['cvv'])) != 3: return (False, \\"Invalid CVV length\\") return (True, \\"\\") def process_payment(payment_details, provider_name, retry_limit): is_valid, validation_message = validate_payment_details(payment_details) if not is_valid: return f\\"Validation Error: {validation_message}\\" provider = providers_config.get(provider_name) if not provider: return f\\"Error: Unsupported provider {provider_name}\\" for attempt in range(retry_limit): result = provider.execute_payment(payment_details) if result.get('status') == 'success': return f\\"Payment successful: {result.get('message', '')}\\" else: error_message = result.get('message', 'Unknown error') continue return f\\"Payment failed after {retry_limit} attempts: {error_message}\\""},{"question":"from collections import deque class MovingSum: def __init__(self, n: int) -> None: Initializes the MovingSum with a specified window size n. def add(self, num: int) -> None: Adds a new number to the stream and updates the moving sum. def get_sum(self) -> int: Returns the current moving sum of the last n elements.","solution":"from collections import deque class MovingSum: def __init__(self, n: int): Initializes the MovingSum with a specified window size n. self.n = n self.window = deque() self.current_sum = 0 def add(self, num: int) -> None: Adds a new number to the stream and updates the moving sum. self.window.append(num) self.current_sum += num # Remove the oldest element if window exceeds size n if len(self.window) > self.n: self.current_sum -= self.window.popleft() def get_sum(self) -> int: Returns the current moving sum of the last n elements. return self.current_sum"},{"question":"class Node: def __init__(self, name, children=None): self.name = name self.children = children if children is not None else [] def find_lowest_common_manager(employee_tree: Node, employee1: str, employee2: str) -> str: Given the structure of a company hierarchy using a tree where each node represents an employee, find the lowest common manager (LCM) for any two employees. The LCM is defined as the lowest node in the tree that has both employees as descendants (a node can be a descendant of itself). Args: employee_tree (Node): The root node of the company hierarchy tree. employee1 (str): The name of the first employee. employee2 (str): The name of the second employee. Returns: str: The name of the lowest common manager. Example: >>> tree = Node(\\"CEO\\", [ Node(\\"CTO\\", [ Node(\\"Eng1\\", [ Node(\\"Intern\\") ]), Node(\\"Eng2\\") ]), Node(\\"CFO\\", [ Node(\\"Fin1\\") ]) ]) >>> find_lowest_common_manager(tree, \\"Eng1\\", \\"Fin1\\") 'CEO' >>> find_lowest_common_manager(tree, \\"Intern\\", \\"Eng2\\") 'CTO' def test_find_lowest_common_manager(): # Construct the hierarchy tree tree = Node(\\"CEO\\", [ Node(\\"CTO\\", [ Node(\\"Eng1\\", [ Node(\\"Intern\\") ]), Node(\\"Eng2\\") ]), Node(\\"CFO\\", [ Node(\\"Fin1\\") ]) ]) # Test case 1: Employees \\"Eng1\\" and \\"Fin1\\" assert find_lowest_common_manager(tree, \\"Eng1\\", \\"Fin1\\") == \\"CEO\\", \\"Test case 1 failed\\" # Test case 2: Employees \\"Intern\\" and \\"Eng2\\" assert find_lowest_common_manager(tree, \\"Intern\\", \\"Eng2\\") == \\"CTO\\", \\"Test case 2 failed\\" # Test case 3: Employees \\"Eng1\\" and \\"Intern\\" assert find_lowest_common_manager(tree, \\"Eng1\\", \\"Intern\\") == \\"Eng1\\", \\"Test case 3 failed\\" # Test case 4: Employees \\"CEO\\" and \\"Intern\\" assert find_lowest_common_manager(tree, \\"CEO\\", \\"Intern\\") == \\"CEO\\", \\"Test case 4 failed\\" # Test case 5: Employees \\"CTO\\" and \\"Eng2\\" assert find_lowest_common_manager(tree, \\"CTO\\", \\"Eng2\\") == \\"CTO\\", \\"Test case 5 failed\\"","solution":"class Node: def __init__(self, name, children=None): self.name = name self.children = children if children is not None else [] def find_lowest_common_manager(employee_tree, employee1, employee2): def lca_helper(node): if not node: return None if node.name == employee1 or node.name == employee2: return node matched_nodes = [] for child in node.children: result = lca_helper(child) if result: matched_nodes.append(result) if len(matched_nodes) == 2: return node elif len(matched_nodes) == 1: return matched_nodes[0] else: return None lca_node = lca_helper(employee_tree) return lca_node.name if lca_node else None"},{"question":"class Node: def __init__(self, value, prev=None, next=None): Initialises a node with the given value. self.value = value self.prev = prev self.next = next class Queue: def __init__(self): Initializes an empty queue. def appendleft(self, value): Inserts an element at the front of the queue. def append(self, value): Inserts an element at the end of the queue. def popleft(self): Removes and returns the element from the front of the queue. def pop(self): Removes and returns the element from the end of the queue. def __len__(self): Returns the number of elements in the queue. def __str__(self): Returns a string representation of the queue for debugging. # Unit Tests def test_append_and_appendleft(): q = Queue() q.append(1) q.append(2) q.appendleft(0) assert str(q) == \\"[0, 1, 2]\\" assert len(q) == 3 def test_pop_and_popleft(): q = Queue() q.append(1) q.append(2) q.appendleft(0) assert q.popleft() == 0 assert q.pop() == 2 assert str(q) == \\"[1]\\" assert len(q) == 1 def test_empty_queue_operations(): q = Queue() try: q.popleft() assert False, \\"Expected IndexError for popleft from empty queue\\" except IndexError: assert True try: q.pop() assert False, \\"Expected IndexError for pop from empty queue\\" except IndexError: assert True def test_edge_case_single_element(): q = Queue() q.append(1) assert q.pop() == 1 q.appendleft(2) assert q.popleft() == 2 assert len(q) == 0 def test_multiple_operations(): q = Queue() q.appendleft(3) q.append(4) q.appendleft(2) q.append(5) assert str(q) == \\"[2, 3, 4, 5]\\" assert q.popleft() == 2 assert q.pop() == 5 assert len(q) == 2 assert str(q) == \\"[3, 4]\\" def test_len(): q = Queue() assert len(q) == 0 q.append(1) q.append(2) assert len(q) == 2 q.popleft() assert len(q) == 1 q.pop() assert len(q) == 0","solution":"class Node: def __init__(self, value, prev=None, next=None): self.value = value self.prev = prev self.next = next class Queue: def __init__(self): self.head = None self.tail = None self._size = 0 def appendleft(self, value): new_node = Node(value, next=self.head) if self.head: self.head.prev = new_node self.head = new_node if not self.tail: self.tail = new_node self._size += 1 def append(self, value): new_node = Node(value, prev=self.tail) if self.tail: self.tail.next = new_node self.tail = new_node if not self.head: self.head = new_node self._size += 1 def popleft(self): if not self.head: raise IndexError(\\"popleft from an empty queue\\") value = self.head.value self.head = self.head.next if self.head: self.head.prev = None else: self.tail = None self._size -= 1 return value def pop(self): if not self.tail: raise IndexError(\\"pop from an empty queue\\") value = self.tail.value self.tail = self.tail.prev if self.tail: self.tail.next = None else: self.head = None self._size -= 1 return value def __len__(self): return self._size def __str__(self): values = [] current = self.head while current: values.append(current.value) current = current.next return str(values)"},{"question":"import heapq from typing import Any, List, Optional, Tuple class PriorityQueue: Implementation of a Priority Queue using a max-heap. The elements in the max-heap are stored as tuples of the form (priority, data). def __init__(self): Initializes the priority queue as empty. pass def insert(self, priority: int, data: Any) -> None: Adds an element with a given priority to the priority queue. Args: priority (int): The priority of the element to be added. data (Any): The data element to be added. pass def extract_max(self) -> Optional[Tuple[int, Any]]: Removes and returns the element with the highest priority. Returns: Optional[Tuple[int, Any]]: The element with the highest priority, or None if the queue is empty. pass def max(self) -> Optional[Tuple[int, Any]]: Returns the element with the highest priority without removing it. Returns: Optional[Tuple[int, Any]]: The element with the highest priority, or None if the queue is empty. pass def is_empty(self) -> bool: Checks if the priority queue is empty. Returns: bool: True if the queue is empty, False otherwise. pass def __len__(self) -> int: Returns the number of elements in the priority queue. Returns: int: The number of elements in the queue. pass # Unit tests def test_priority_queue_initially_empty(): pq = PriorityQueue() assert pq.is_empty() == True assert len(pq) == 0 def test_insert_and_len(): pq = PriorityQueue() pq.insert(3, 'A') pq.insert(5, 'B') assert len(pq) == 2 def test_max(): pq = PriorityQueue() pq.insert(3, 'A') pq.insert(5, 'B') pq.insert(1, 'C') assert pq.max() == (5, 'B') def test_extract_max(): pq = PriorityQueue() pq.insert(3, 'A') pq.insert(5, 'B') pq.insert(1, 'C') assert pq.extract_max() == (5, 'B') assert len(pq) == 2 assert pq.max() == (3, 'A') def test_extract_max_empty_queue(): pq = PriorityQueue() assert pq.extract_max() == None def test_max_empty_queue(): pq = PriorityQueue() assert pq.max() == None def test_priority_queue_is_not_empty_after_operations(): pq = PriorityQueue() pq.insert(3, 'A') pq.insert(5, 'B') pq.extract_max() assert pq.is_empty() == False assert len(pq) == 1","solution":"import heapq from typing import Any, List, Optional, Tuple class PriorityQueue: def __init__(self): self._heap: List[Tuple[int, Any]] = [] self._count = 0 def insert(self, priority: int, data: Any) -> None: # Insert element into the heap heapq.heappush(self._heap, (-priority, data)) self._count += 1 def extract_max(self) -> Optional[Tuple[int, Any]]: if self.is_empty(): return None # Remove and return the element with the highest priority self._count -= 1 priority, data = heapq.heappop(self._heap) return -priority, data def max(self) -> Optional[Tuple[int, Any]]: if self.is_empty(): return None # Return the element with the highest priority without removing it priority, data = self._heap[0] return -priority, data def is_empty(self) -> bool: return self._count == 0 def __len__(self) -> int: return self._count"},{"question":"def count_words(sentence: str) -> dict: Count the occurrences of each word in a given sentence. This function is case-insensitive and ignores punctuation. Args: sentence (str): A string containing a sentence. Returns: dict: A dictionary where the keys are words and the values are their respective counts. Examples: >>> count_words(\\"Hello world! hello!\\") {'hello': 2, 'world': 1} >>> count_words(\\"This is a test. This test is only a test.\\") {'this': 2, 'is': 2, 'a': 2, 'test': 3, 'only': 1} >>> count_words(\\"Python is amazing. Python, indeed, is amazing.\\") {'python': 2, 'is': 2, 'amazing': 2, 'indeed': 1}","solution":"import re from collections import defaultdict def count_words(sentence): Returns a dictionary with the count of each word in the sentence. Words are considered case-insensitive and punctuation is ignored. # Convert the sentence to lowercase sentence = sentence.lower() # Remove punctuation using regex sentence = re.sub(r'[^ws]', '', sentence) # Split the sentence into words words = sentence.split() # Use defaultdict to keep count of each word word_count = defaultdict(int) for word in words: word_count[word] += 1 return dict(word_count)"},{"question":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transposes the given 2D matrix. Params: - matrix (List[List[int]]): A 2D list representing the matrix. Returns: - List[List[int]]: A 2D list representing the transposed matrix. pass def sum_transposed_matrix(matrix: List[List[int]]) -> int: Computes the sum of all elements in the transposed matrix. Params: - matrix (List[List[int]]): A 2D list representing the matrix. Returns: - int: The sum of all elements in the transposed matrix. pass def test_transpose_matrix(): matrix_1 = [ [1, 2, 3], [4, 5, 6] ] assert transpose_matrix(matrix_1) == [[1, 4], [2, 5], [3, 6]] matrix_2 = [ [7] ] assert transpose_matrix(matrix_2) == [[7]] matrix_3 = [ [1, 4], [2, 5], [3, 6] ] assert transpose_matrix(matrix_3) == [[1, 2, 3], [4, 5, 6]] def test_sum_transposed_matrix(): matrix_1 = [ [1, 2, 3], [4, 5, 6] ] assert sum_transposed_matrix(matrix_1) == 21 matrix_2 = [ [7] ] assert sum_transposed_matrix(matrix_2) == 7 matrix_3 = [ [1, -2], [-3, 4] ] assert sum_transposed_matrix(matrix_3) == 0 matrix_4 = [ [5, 10], [15, 20], [25, 30] ] assert sum_transposed_matrix(matrix_4) == 105","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transposes the given 2D matrix. Params: - matrix (List[List[int]]): A 2D list representing the matrix. Returns: - List[List[int]]: A 2D list representing the transposed matrix. return [list(row) for row in zip(*matrix)] def sum_transposed_matrix(matrix: List[List[int]]) -> int: Computes the sum of all elements in the transposed matrix. Params: - matrix (List[List[int]]): A 2D list representing the matrix. Returns: - int: The sum of all elements in the transposed matrix. transposed = transpose_matrix(matrix) return sum(sum(row) for row in transposed)"},{"question":"def fibonacci_iterative(n: int) -> int: Returns the n-th Fibonacci number using an iterative approach. >>> fibonacci_iterative(10) == 55 True >>> fibonacci_iterative(1) == 1 True >>> fibonacci_iterative(2) == 1 True >>> fibonacci_iterative(20) == 6765 True pass def sum_of_even_fibonacci(n: int) -> int: Returns the sum of all even Fibonacci numbers up to the n-th Fibonacci number. >>> sum_of_even_fibonacci(10) == 44 True >>> sum_of_even_fibonacci(1) == 0 True >>> sum_of_even_fibonacci(3) == 2 True >>> sum_of_even_fibonacci(6) == 10 True pass def fibonacci_position(f: int) -> int: Returns the position of the Fibonacci number f in the Fibonacci sequence. >>> fibonacci_position(1) == 1 True >>> fibonacci_position(55) == 10 True >>> fibonacci_position(21) == 8 True pass def test_fibonacci_iterative(): assert fibonacci_iterative(1) == 1 assert fibonacci_iterative(2) == 1 assert fibonacci_iterative(3) == 2 assert fibonacci_iterative(10) == 55 assert fibonacci_iterative(20) == 6765 def test_sum_of_even_fibonacci(): assert sum_of_even_fibonacci(10) == 44 # (2 + 8 + 34) assert sum_of_even_fibonacci(1) == 0 assert sum_of_even_fibonacci(2) == 0 assert sum_of_even_fibonacci(3) == 2 assert sum_of_even_fibonacci(6) == 10 # (2 + 8) def test_fibonacci_position(): assert fibonacci_position(1) == 1 assert fibonacci_position(55) == 10 assert fibonacci_position(1) == 1 # Though there are two 1s, both are at position 1 (position of the first 1) assert fibonacci_position(21) == 8 def test_fibonacci_inputs(): try: fibonacci_iterative(0) assert False # Shouldn't get here except ValueError: assert True try: sum_of_even_fibonacci(0) assert False # Shouldn't get here except ValueError: assert True try: fibonacci_position(0) assert False # Shouldn't get here except ValueError: assert True try: fibonacci_position(4) # Not a Fibonacci number assert False # Shouldn't get here except ValueError: assert True","solution":"def fibonacci_iterative(n): Returns the n-th Fibonacci number using an iterative approach. if n <= 0: raise ValueError(\\"n must be a positive integer\\") if n == 1: return 1 if n == 2: return 1 a, b = 1, 1 for _ in range(3, n + 1): a, b = b, a + b return b def sum_of_even_fibonacci(n): Returns the sum of all even Fibonacci numbers up to the n-th Fibonacci number. if n <= 0: raise ValueError(\\"n must be a positive integer\\") a, b = 0, 1 even_sum = 0 for _ in range(n): a, b = b, a + b if a % 2 == 0: even_sum += a return even_sum def fibonacci_position(f): Returns the position of the Fibonacci number f in the Fibonacci sequence. if f <= 0: raise ValueError(\\"f must be a positive integer\\") a, b = 1, 1 position = 2 # because we've already covered f1 = 1 and f2 = 1 if f == 1: return 1 # since there are two positions (1 and 2) both equal to 1 in the sequence while b < f: a, b = b, a + b position += 1 if b == f: return position else: raise ValueError(f\\"{f} is not a Fibonacci number\\")"},{"question":"from collections import deque class MultiStackQueue: A data structure that can function as both a stack and a queue. Users can dynamically switch between modes. def __init__(self): Initialize the data structure. self.data = deque() self.mode = 'stack' def push(self, value): Adds an element to the data structure. :param value: Element to be added to the data structure pass def pop(self): Removes and returns an element based on the current mode. :return: The next element based on the current mode :raises IndexError: if the data structure is empty pass def switch_mode(self, mode): Changes the current mode. :param mode: Mode to switch to, either 'stack' or 'queue' :raises ValueError: if the mode is not 'stack' or 'queue' pass def current_mode(self): Returns the current mode of the data structure. :return: Current mode ('stack' or 'queue') pass # Unit tests for the MultiStackQueue class def test_initial_mode(): msq = MultiStackQueue() assert msq.current_mode() == 'stack' def test_push_pop_stack_mode(): msq = MultiStackQueue() msq.push(1) msq.push(2) msq.push(3) assert msq.pop() == 3 assert msq.pop() == 2 assert msq.pop() == 1 def test_push_pop_queue_mode(): msq = MultiStackQueue() msq.switch_mode('queue') msq.push(1) msq.push(2) msq.push(3) assert msq.pop() == 1 assert msq.pop() == 2 assert msq.pop() == 3 def test_switch_modes(): msq = MultiStackQueue() msq.push(1) msq.push(2) msq.switch_mode('queue') assert msq.current_mode() == 'queue' assert msq.pop() == 1 msq.push(3) assert msq.pop() == 2 msq.switch_mode('stack') assert msq.pop() == 3 def test_empty_pop(): msq = MultiStackQueue() try: msq.pop() assert False, \\"Expected an IndexError when popping from an empty MultiStackQueue\\" except IndexError: pass def test_invalid_mode_switch(): msq = MultiStackQueue() try: msq.switch_mode('invalid_mode') assert False, \\"Expected a ValueError when switching to an invalid mode\\" except ValueError: pass def test_mixed_operations(): msq = MultiStackQueue() msq.push(1) msq.push(2) msq.push(3) msq.switch_mode('queue') msq.push(4) assert msq.pop() == 1 assert msq.pop() == 2 msq.switch_mode('stack') assert msq.pop() == 4 assert msq.pop() == 3","solution":"from collections import deque class MultiStackQueue: def __init__(self): Initialize data structure to maintain stack and queue modes. self.data = deque() self.mode = 'stack' # default mode is 'stack' def push(self, value): Adds value to data structure. self.data.append(value) def pop(self): Removes and returns element based on current mode. if not self.data: raise IndexError(\\"pop from an empty MultiStackQueue\\") if self.mode == 'stack': return self.data.pop() else: # mode is 'queue' return self.data.popleft() def switch_mode(self, mode): Switches the current mode to either 'stack' or 'queue'. if mode not in {'stack', 'queue'}: raise ValueError(\\"mode must be either 'stack' or 'queue'\\") self.mode = mode def current_mode(self): Returns the current mode. return self.mode"},{"question":"class BankingSystem: def __init__(self, number_of_accounts: int) -> None: Initialize the banking system with a given number of accounts. ... def deposit(self, account_id: int, amount: int) -> None: Deposit the specified amount into the account with the given account_id. >>> bank_system = BankingSystem(3) >>> bank_system.deposit(0, 100) >>> bank_system.deposit(1, 200) >>> bank_system.balance(0) 100 >>> bank_system.balance(1) 200 ... def withdraw(self, account_id: int, amount: int) -> bool: Withdraw the specified amount from the account with the given account_id. If the account has insufficient funds, the operation should fail and return False. >>> bank_system = BankingSystem(3) >>> bank_system.deposit(1, 200) >>> bank_system.withdraw(1, 50) True >>> bank_system.balance(1) 150 >>> bank_system.withdraw(1, 300) False ... def balance(self, account_id: int) -> int: Return the current balance of the account with the given account_id. >>> bank_system = BankingSystem(3) >>> bank_system.deposit(2, 300) >>> bank_system.balance(2) 300 >>> bank_system.balance(3) -1 ...","solution":"class BankingSystem: def __init__(self, number_of_accounts: int) -> None: self.accounts = [0] * number_of_accounts def deposit(self, account_id: int, amount: int) -> None: if 0 <= account_id < len(self.accounts): self.accounts[account_id] += amount def withdraw(self, account_id: int, amount: int) -> bool: if 0 <= account_id < len(self.accounts): if self.accounts[account_id] >= amount: self.accounts[account_id] -= amount return True else: return False return False def balance(self, account_id: int) -> int: if 0 <= account_id < len(self.accounts): return self.accounts[account_id] return -1 # An invalid account_id should return an invalid balance"},{"question":"def char_frequency(text: str) -> dict: Determine how often each character appears in a string and return the results as a dictionary where the keys are characters and the values are the count of how often each character appears in the string. Raises a ValueError if the input text is empty. :param text: non-empty string consisting of any printable ASCII characters :return: dictionary with character frequency >>> char_frequency(\\"hello\\") {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> char_frequency(\\"apple\\") {'a': 1, 'p': 2, 'l': 1, 'e': 1} >>> char_frequency(\\"123321\\") {'1': 2, '2': 2, '3': 2} >>> char_frequency(\\"AaBbCc\\") {'A': 1, 'a': 1, 'B': 1, 'b': 1, 'C': 1, 'c': 1} if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def char_frequency(text: str) -> dict: Returns a dictionary with the frequency of each character in the input text. Raises a ValueError if the input text is empty. :param text: non-empty string consisting of any printable ASCII characters :return: dictionary with character frequency if not text: raise ValueError(\\"Input text must be non-empty\\") frequency = {} for char in text: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"[Completion Task in Python] **Task**: \`diagonal_sum\` Complete the function \`diagonal_sum(matrix: list[list[int]]) -> int:\` to calculate the sum of the main diagonal elements of an \`n x n\` matrix, skipping any elements that are negative. **Input** - \`matrix\` (list[list[int]]): A square matrix (i.e., the number of rows is equal to the number of columns). The matrix will contain integers. **Output** - \`int\`: Return the sum of the diagonal elements, excluding any that are negative. **Constraints** 1. The matrix must be non-empty. If it is empty, raise a \`ValueError\` with the message \\"Matrix cannot be empty.\\" 2. The matrix must be square (i.e., the number of rows equals the number of columns). If it is not, raise a \`ValueError\` with the message \\"Matrix must be square.\\" **Example** diagonal_sum([[1, 2, 3], [4, 5, -6], [7, -8, 9]]) # Returns 15 (1 + 5 + 9) diagonal_sum([[10, -2], [-3, 20]]) # Returns 30 (10 + 20) diagonal_sum([[5]]) # Returns 5 diagonal_sum([[-5]]) # Returns 0 diagonal_sum([]) # Raises ValueError: Matrix cannot be empty diagonal_sum([[1, 2], [3]]) # Raises ValueError: Matrix must be square def diagonal_sum(matrix: list[list[int]]) -> int: Calculate the sum of the main diagonal elements of a square matrix, skipping any negative elements. Parameters: - matrix: list[list[int]], a square matrix (n x n). Returns: - int, the sum of the main diagonal elements excluding negative elements. Raises: - ValueError: if the matrix is empty or not square. if not matrix: raise ValueError(\\"Matrix cannot be empty\\") n = len(matrix) for row in matrix: if len(row) != n: raise ValueError(\\"Matrix must be square\\") return sum(matrix[i][i] for i in range(n) if matrix[i][i] >= 0)","solution":"def diagonal_sum(matrix: list[list[int]]) -> int: Calculate the sum of the main diagonal elements of a square matrix, skipping any negative elements. Parameters: - matrix: list[list[int]], a square matrix (n x n). Returns: - int, the sum of the main diagonal elements excluding negative elements. Raises: - ValueError: if the matrix is empty or not square. if not matrix: raise ValueError(\\"Matrix cannot be empty\\") n = len(matrix) for row in matrix: if len(row) != n: raise ValueError(\\"Matrix must be square\\") return sum(matrix[i][i] for i in range(n) if matrix[i][i] >= 0)"},{"question":"from typing import List, Tuple, Dict def count_unique_indexes(records: List[Tuple[str, str]]) -> Dict[str, int]: Returns a dictionary with the count of unique indexes for each category. :param records: A list of tuples, where each tuple contains a category and an index. :type records: List[Tuple[str, str]] :return: A dictionary with categories as keys and counts of unique indexes as values. :rtype: Dict[str, int] >>> count_unique_indexes([ ... (\\"fruit\\", \\"apple\\"), ... (\\"fruit\\", \\"banana\\"), ... (\\"fruit\\", \\"apple\\"), ... (\\"tech\\", \\"laptop\\"), ... (\\"tech\\", \\"phone\\"), ... (\\"fruit\\", \\"cherry\\"), ... (\\"tech\\", \\"phone\\"), ... ]) == {\\"fruit\\": 3, \\"tech\\": 2} >>> count_unique_indexes([ ... (\\"book\\", \\"fiction\\"), ... (\\"book\\", \\"fantasy\\"), ... (\\"music\\", \\"rock\\"), ... (\\"music\\", \\"jazz\\"), ... (\\"book\\", \\"fiction\\"), ... (\\"music\\", \\"jazz\\"), ... (\\"book\\", \\"non-fiction\\"), ... (\\"music\\", \\"pop\\"), ... ]) == {\\"book\\": 3, \\"music\\": 3} def test_count_unique_indexes_example_1(): records = [ (\\"fruit\\", \\"apple\\"), (\\"fruit\\", \\"banana\\"), (\\"fruit\\", \\"apple\\"), (\\"tech\\", \\"laptop\\"), (\\"tech\\", \\"phone\\"), (\\"fruit\\", \\"cherry\\"), (\\"tech\\", \\"phone\\"), ] assert count_unique_indexes(records) == {\\"fruit\\": 3, \\"tech\\": 2} def test_count_unique_indexes_example_2(): records = [ (\\"book\\", \\"fiction\\"), (\\"book\\", \\"fantasy\\"), (\\"music\\", \\"rock\\"), (\\"music\\", \\"jazz\\"), (\\"book\\", \\"fiction\\"), (\\"music\\", \\"jazz\\"), (\\"book\\", \\"non-fiction\\"), (\\"music\\", \\"pop\\"), ] assert count_unique_indexes(records) == {\\"book\\": 3, \\"music\\": 3} def test_count_unique_indexes_empty(): records = [] assert count_unique_indexes(records) == {} def test_count_unique_indexes_single_record(): records = [(\\"technology\\", \\"AI\\")] assert count_unique_indexes(records) == {\\"technology\\": 1} def test_count_unique_indexes_multiple_categories_same_index(): records = [ (\\"fruit\\", \\"apple\\"), (\\"tech\\", \\"apple\\"), (\\"veggie\\", \\"apple\\"), (\\"fruit\\", \\"banana\\"), ] assert count_unique_indexes(records) == {\\"fruit\\": 2, \\"tech\\": 1, \\"veggie\\": 1} def test_count_unique_indexes_all_duplicates(): records = [ (\\"fruit\\", \\"apple\\"), (\\"fruit\\", \\"apple\\"), (\\"fruit\\", \\"apple\\"), ] assert count_unique_indexes(records) == {\\"fruit\\": 1}","solution":"def count_unique_indexes(records): Returns a dictionary with the count of unique indexes for each category. :param records: A list of tuples, where each tuple contains a category and an index. :type records: List[Tuple[str, str]] :return: A dictionary with categories as keys and counts of unique indexes as values. :rtype: Dict[str, int] from collections import defaultdict category_to_indexes = defaultdict(set) for category, index in records: category_to_indexes[category].add(index) return {category: len(indexes) for category, indexes in category_to_indexes.items()}"},{"question":"from collections import deque class ConveyorBelt: def __init__(self): self.queue = deque() def add_object(self, weight: int, process_time: int) -> None: Adds an object with the given weight and processing time to the conveyor belt. pass def process_objects(self) -> int: Processes all objects in the queue and returns the total processing time in seconds. pass # Example usage: belt = ConveyorBelt() belt.add_object(200, 120) belt.add_object(150, 300) belt.add_object(500, 180) total_time = belt.process_objects() print(total_time) # Output: 600 (120 + 300 + 180)","solution":"from collections import deque class ConveyorBelt: def __init__(self): self.queue = deque() def add_object(self, weight: int, process_time: int) -> None: Adds an object with the given weight and processing time to the conveyor belt. self.queue.append((weight, process_time)) def process_objects(self) -> int: Processes all objects in the queue and returns the total processing time in seconds. total_time = 0 while self.queue: weight, process_time = self.queue.popleft() total_time += process_time return total_time"},{"question":"def delivery_schedule(packages: List[int], limit: int) -> int: Determines the minimum number of days necessary to deliver all packages within their respective deadlines. >>> delivery_schedule([1, 2, 1, 2, 3, 3], 2) 3 >>> delivery_schedule([1, 2, 1, 2, 3, 3], 3) 3 >>> delivery_schedule([1, 2, 3, 4, 5], 1) 5 >>> delivery_schedule([1], 1) 1 >>> delivery_schedule([5, 5, 5], 1) 7 >>> delivery_schedule([3, 1, 2, 2], 2) 3 >>> delivery_schedule([1, 1, 1, 1], 1) 4 >>> delivery_schedule([365, 365, 365], 1) 367","solution":"def delivery_schedule(packages, limit): packages.sort() days_needed = 0 current_load = 0 for deadline in packages: if current_load < limit: current_load += 1 else: days_needed += 1 current_load = 1 days_needed = max(days_needed, deadline) return days_needed"},{"question":"class ParkingLot: Design a parking lot system with the following capabilities: 1. Park a Vehicle: Allow a vehicle to park in a specific slot if available. 2. Free a Slot: Free up a slot when a vehicle leaves. 3. Check Available Slots: Return a list of available slots. >>> parking_lot = ParkingLot(3) >>> parking_lot.park_vehicle(\\"ABC123\\") True >>> parking_lot.park_vehicle(\\"XYZ789\\") True >>> parking_lot.available_slots() [3] >>> parking_lot.free_slot(2) True >>> parking_lot.available_slots() [2, 3] >>> parking_lot.park_vehicle(\\"LMN456\\") True >>> parking_lot.available_slots() [3] >>> parking_lot.free_slot(5) False def __init__(self, num_slots: int): Initializes the parking lot with the given number of slots. def park_vehicle(self, license_plate: str) -> bool: Parks a vehicle with the given license plate in the first available slot and returns True. If no slots are available, returns False. def free_slot(self, slot_number: int) -> bool: Frees the slot with the given slot number and returns True. If the slot is already free or invalid, returns False. def available_slots(self) -> list: Returns a list of all available slots.","solution":"class ParkingLot: def __init__(self, num_slots: int): Initializes the parking lot with the given number of slots. self.num_slots = num_slots self.slots = [None] * num_slots def park_vehicle(self, license_plate: str) -> bool: Parks a vehicle with the given license plate in the first available slot and returns True. If no slots are available, returns False. for i in range(self.num_slots): if self.slots[i] is None: self.slots[i] = license_plate return True return False def free_slot(self, slot_number: int) -> bool: Frees the slot with the given slot number and returns True. If the slot is already free or invalid, returns False. if 1 <= slot_number <= self.num_slots and self.slots[slot_number - 1] is not None: self.slots[slot_number - 1] = None return True return False def available_slots(self) -> list: Returns a list of all available slots. return [i + 1 for i in range(self.num_slots) if self.slots[i] is None]"},{"question":"def compress_string(data: str) -> str: Perform string compression by identifying sequences of repeated characters in the string and representing them with a single character followed by the count of its repetitions. >>> compress_string(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> compress_string(\\"abcd\\") \\"abcd\\" >>> compress_string(\\"abccCaaa\\") \\"abccCaaa\\" >>> compress_string(\\"\\") \\"\\" >>> compress_string(\\"a\\") \\"a\\"","solution":"def compress_string(data: str) -> str: if not data: return \\"\\" compressed = [] count = 1 for i in range(1, len(data)): if data[i] == data[i - 1]: count += 1 else: compressed.append(data[i - 1]) compressed.append(str(count)) count = 1 compressed.append(data[-1]) compressed.append(str(count)) compressed_str = ''.join(compressed) return compressed_str if len(compressed_str) < len(data) else data"},{"question":"def calculate_apr(principal: float, interest: float) -> float: Calculate the annual percentage rate (APR) for a loan. Args: principal (float): The total principal amount of the loan (dollars). interest (float): The yearly interest rate as a percentage. Returns: float: The annual percentage rate (APR) rounded to two decimal places. Raises: ValueError: If the principal is zero or negative. Examples: >>> calculate_apr(10000, 500) 5.0 >>> calculate_apr(15000, 750) 5.0 >>> calculate_apr(25000, -1000) -4.0 >>> calculate_apr(50000, 2000) 4.0 >>> calculate_apr(10000, 0) 0.0 # Unit tests import pytest def test_calculate_apr_positive_interest(): assert calculate_apr(10000, 500) == 5.0 assert calculate_apr(15000, 750) == 5.0 assert calculate_apr(50000, 2000) == 4.0 def test_calculate_apr_negative_interest(): assert calculate_apr(25000, -1000) == -4.0 def test_calculate_apr_zero_interest(): assert calculate_apr(10000, 0) == 0.0 def test_calculate_apr_small_principal(): assert calculate_apr(1, 1) == 100.0 def test_calculate_apr_large_principal(): assert calculate_apr(1000000, 10000) == 1.0 def test_calculate_apr_invalid_principal(): with pytest.raises(ValueError, match=\\"The principal must be a positive number\\"): calculate_apr(0, 100) with pytest.raises(ValueError, match=\\"The principal must be a positive number\\"): calculate_apr(-100, 100)","solution":"def calculate_apr(principal: float, interest: float) -> float: Calculate the annual percentage rate (APR) for a loan. Args: principal (float): The total principal amount of the loan (dollars). interest (float): The yearly interest rate as a percentage. Returns: float: The annual percentage rate (APR) rounded to two decimal places. Raises: ValueError: If the principal is zero or negative. if principal <= 0: raise ValueError(\\"The principal must be a positive number\\") apr = (interest * 100) / principal return round(apr, 2)"},{"question":"def sparse_string_matching(sparse_text: list[str], search_term: str) -> int: Implements a function to optimize searching for a substring in a large sparse text using a binary search technique. Args: sparse_text: A list of strings where empty strings represent gaps in the sparse text document. search_term: A string representing the substring you need to find in the \`sparse_text\`. Returns: An integer representing the index of the first occurrence of \`search_term\` in \`sparse_text\`. Returns \`-1\` if \`search_term\` is not found. Example: >>> sparse_string_matching([\\"\\", \\"\\", \\"\\", \\"this\\", \\"\\", \\"is\\", \\"\\", \\"\\", \\"a\\", \\"simple\\", \\"\\", \\"example\\"], \\"simple\\") 9 >>> sparse_string_matching([\\"\\", \\"\\", \\"\\", \\"linear\\", \\"\\", \\"\\", \\"search\\", \\"\\"], \\"search\\") 6 >>> sparse_string_matching([\\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\"], \\"text\\") -1 >>> sparse_string_matching([\\"\\", \\"\\", \\"find\\", \\"\\", \\"me\\"], \\"find\\") 2 >>> sparse_string_matching([\\"search\\", \\"\\", \\"\\", \\"in\\", \\"\\", \\"\\", \\"sparse\\", \\"text\\", \\"\\"], \\"text\\") 7 # Your implementation here pass # Example Test Cases: def test_sparse_string_matching(): sparse_text_1 = [\\"\\", \\"\\", \\"\\", \\"this\\", \\"\\", \\"is\\", \\"\\", \\"\\", \\"a\\", \\"simple\\", \\"\\", \\"example\\"] search_term_1 = \\"simple\\" assert sparse_string_matching(sparse_text_1, search_term_1) == 9 sparse_text_2 = [\\"\\", \\"\\", \\"\\", \\"linear\\", \\"\\", \\"\\", \\"search\\", \\"\\"] search_term_2 = \\"search\\" assert sparse_string_matching(sparse_text_2, search_term_2) == 6 sparse_text_3 = [\\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\"] search_term_3 = \\"text\\" assert sparse_string_matching(sparse_text_3, search_term_3) == -1 sparse_text_4 = [\\"\\", \\"\\", \\"find\\", \\"\\", \\"me\\"] search_term_4 = \\"find\\" assert sparse_string_matching(sparse_text_4, search_term_4) == 2 sparse_text_5 = [\\"search\\", \\"\\", \\"\\", \\"in\\", \\"\\", \\"\\", \\"sparse\\", \\"text\\", \\"\\"] search_term_5 = \\"text\\" assert sparse_string_matching(sparse_text_5, search_term_5) == 7 # Additional Test Cases sparse_text_6 = [\\"\\", \\"\\", \\"\\", \\"apple\\", \\"\\", \\"banana\\", \\"\\", \\"\\", \\"cherry\\"] search_term_6 = \\"banana\\" assert sparse_string_matching(sparse_text_6, search_term_6) == 5 sparse_text_7 = [\\"\\", \\"\\", \\"search\\", \\"\\", \\"\\", \\"in\\", \\"a\\", \\"\\", \\"massive\\", \\"\\", \\"sparse\\", \\"array\\"] search_term_7 = \\"sparse\\" assert sparse_string_matching(sparse_text_7, search_term_7) == 10 sparse_text_8 = [\\"find\\", \\"\\", \\"\\", \\"in\\", \\"\\", \\"\\", \\"empty\\", \\"\\", \\"spaces\\"] search_term_8 = \\"find\\" assert sparse_string_matching(sparse_text_8, search_term_8) == 0 sparse_text_9 = [\\"cat\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"dog\\"] search_term_9 = \\"elephant\\" assert sparse_string_matching(sparse_text_9, search_term_9) == -1 sparse_text_10 = [\\"a\\", \\"\\", \\"b\\", \\"\\", \\"c\\", \\"\\", \\"d\\", \\"\\", \\"e\\"] search_term_10 = \\"d\\" assert sparse_string_matching(sparse_text_10, search_term_10) == 6","solution":"def sparse_string_matching(sparse_text, search_term): Uses a modified binary search to find the first occurrence of search_term in sparse_text. Skips over empty strings in sparse_text. low, high = 0, len(sparse_text) - 1 while low <= high: mid = (low + high) // 2 # Find the nearest non-empty string to the right left, right = mid, mid while left >= low and sparse_text[left] == \\"\\": left -= 1 while right <= high and sparse_text[right] == \\"\\": right += 1 # Determine the closer non-empty midpoint if left < low and right > high: return -1 # no non-empty strings in range mid = right if left < low or (right <= high and mid - left > right - mid) else left # Perform the comparison to adjust binary search range if sparse_text[mid] == search_term: return mid elif sparse_text[mid] < search_term: low = mid + 1 else: high = mid - 1 return -1"},{"question":"class LibrarySystem: def __init__(self): self.books = {} # hash table to store books with their status def add_book(self, book_id: int, title: str) -> None: Adds a book with the given \`book_id\` and \`title\`. def check_out_book(self, book_id: int) -> bool: Marks the book with \`book_id\` as checked out. Returns \`True\` if successful, or \`False\` if the book is already checked out or doesn't exist. def return_book(self, book_id: int) -> bool: Marks the book with \`book_id\` as available. Returns \`True\` if successful, or \`False\` if the book is already available or doesn't exist. def get_book_status(self, book_id: int) -> str: Returns 'available' or 'checked out' depending on the status of the book with \`book_id\`. If the book does not exist, returns 'not found'. def list_available_books(self) -> list: Returns a list of titles of all available books. # Unit Tests def test_add_book(): library = LibrarySystem() library.add_book(1, \\"The Great Gatsby\\") assert 1 in library.books assert library.books[1]['title'] == \\"The Great Gatsby\\" assert library.books[1]['status'] == 'available' def test_check_out_book(): library = LibrarySystem() library.add_book(1, \\"The Great Gatsby\\") assert library.check_out_book(1) == True assert library.get_book_status(1) == 'checked out' assert library.check_out_book(1) == False # book already checked out def test_return_book(): library = LibrarySystem() library.add_book(1, \\"The Great Gatsby\\") library.check_out_book(1) assert library.return_book(1) == True assert library.get_book_status(1) == 'available' assert library.return_book(1) == False # book already available def test_get_book_status(): library = LibrarySystem() library.add_book(1, \\"The Great Gatsby\\") assert library.get_book_status(1) == 'available' library.check_out_book(1) assert library.get_book_status(1) == 'checked out' assert library.get_book_status(2) == 'not found' def test_list_available_books(): library = LibrarySystem() library.add_book(1, \\"The Great Gatsby\\") library.add_book(2, \\"1984\\") library.add_book(3, \\"To Kill a Mockingbird\\") library.check_out_book(1) assert set(library.list_available_books()) == {\\"1984\\", \\"To Kill a Mockingbird\\"} library.return_book(1) assert set(library.list_available_books()) == {\\"The Great Gatsby\\", \\"1984\\", \\"To Kill a Mockingbird\\"}","solution":"class LibrarySystem: def __init__(self): self.books = {} # hash table to store books with their status def add_book(self, book_id: int, title: str) -> None: Adds a book with the given \`book_id\` and \`title\`. self.books[book_id] = {'title': title, 'status': 'available'} def check_out_book(self, book_id: int) -> bool: Marks the book with \`book_id\` as checked out. Returns \`True\` if successful, or \`False\` if the book is already checked out or doesn't exist. if book_id in self.books and self.books[book_id]['status'] == 'available': self.books[book_id]['status'] = 'checked out' return True return False def return_book(self, book_id: int) -> bool: Marks the book with \`book_id\` as available. Returns \`True\` if successful, or \`False\` if the book is already available or doesn't exist. if book_id in self.books and self.books[book_id]['status'] == 'checked out': self.books[book_id]['status'] = 'available' return True return False def get_book_status(self, book_id: int) -> str: Returns 'available' or 'checked out' depending on the status of the book with \`book_id\`. If the book does not exist, returns 'not found'. if book_id in self.books: return self.books[book_id]['status'] return 'not found' def list_available_books(self) -> list: Returns a list of titles of all available books. return [book['title'] for book in self.books.values() if book['status'] == 'available']"},{"question":"class Graph: A class to represent an undirected weighted graph and to find the Minimum Spanning Tree (MST) using Kruskal's algorithm. The graph is initialized with a list of edges where each edge is represented by a tuple (v1, v2, weight). Methods ------- __init__(self, edges: List[Tuple[int, int, int]]) -> None: Initializes the graph with a list of edges. add_edge(self, v1: int, v2: int, weight: int) -> None: Adds a new edge to the graph. find_mst(self) -> List[Tuple[int, int, int]]: Constructs the MST using Kruskal's algorithm and returns a list of edges included in the MST. def __init__(self, edges: List[Tuple[int, int, int]]) -> None: Initializes the graph with a list of edges. pass def add_edge(self, v1: int, v2: int, weight: int) -> None: Adds a new edge to the graph. pass def find_mst(self) -> List[Tuple[int, int, int]]: Constructs the MST using Kruskal's algorithm and returns a list of edges included in the MST. pass import pytest def test_single_edge(): edges = [(0, 1, 1)] g = Graph(edges) mst = g.find_mst() assert mst == [(0, 1, 1)] def test_multiple_edges(): edges = [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)] g = Graph(edges) mst = g.find_mst() assert mst == [(2, 3, 4), (0, 3, 5), (0, 1, 10)] def test_add_edge(): edges = [(0, 1, 10), (0, 2, 6), (0, 3, 5)] g = Graph(edges) g.add_edge(1, 3, 15) g.add_edge(2, 3, 4) mst = g.find_mst() assert mst == [(2, 3, 4), (0, 3, 5), (0, 1, 10)] def test_no_edges(): edges = [] g = Graph(edges) mst = g.find_mst() assert mst == [] def test_disconnected_graph(): edges = [(0, 1, 10), (2, 3, 5), (4, 5, 2)] g = Graph(edges) mst = g.find_mst() assert mst == [(4, 5, 2), (2, 3, 5), (0, 1, 10)]","solution":"class Graph: def __init__(self, edges): Initializes the graph with a list of edges. Each edge is represented as a tuple (v1, v2, weight). self.edges = edges def add_edge(self, v1, v2, weight): Adds a new edge to the graph. self.edges.append((v1, v2, weight)) def find_mst(self): Constructs the MST using Kruskal's algorithm and returns the list of edges. # Sort edges based on weight self.edges.sort(key=lambda edge: edge[2]) parent = dict() rank = dict() def find(v): if parent[v] != v: parent[v] = find(parent[v]) return parent[v] def union(v1, v2): root1 = find(v1) root2 = find(v2) if root1 != root2: if rank[root1] > rank[root2]: parent[root2] = root1 else: parent[root1] = root2 if rank[root1] == rank[root2]: rank[root2] += 1 # Initialize disjoint sets for v1, v2, weight in self.edges: if v1 not in parent: parent[v1] = v1 rank[v1] = 0 if v2 not in parent: parent[v2] = v2 rank[v2] = 0 mst = [] for v1, v2, weight in self.edges: if find(v1) != find(v2): union(v1, v2) mst.append((v1, v2, weight)) return mst"},{"question":"Implement a class \`BankSystem\` that manages multiple bank accounts and supports the following operations: 1. **create_account(account_id: int, initial_balance: int) -> None**: Creates a new account with a given \`account_id\` and \`initial_balance\`. 2. **deposit(account_id: int, amount: int) -> None**: Deposits the specified \`amount\` of money into the account with \`account_id\`. 3. **withdraw(account_id: int, amount: int) -> None**: Withdraws the specified \`amount\` of money from the account with \`account_id\` if the balance permits. 4. **transfer(from_account_id: int, to_account_id: int, amount: int) -> None**: Transfers the specified \`amount\` of money from \`from_account_id\` to \`to_account_id\` if the balance permits. 5. **get_balance(account_id: int) -> int**: Returns the current balance of the account with \`account_id\`. 6. **transaction_history(account_id: int) -> list**: Returns the list of transactions associated with the \`account_id\` in the format \`[(timestamp, transaction_type, amount, other_account)]\`.","solution":"class BankSystem: def __init__(self): self.accounts = {} # {account_id: balance} self.transactions = {} # {account_id: [(timestamp, transaction_type, amount, other_account)]} self.transaction_id = 1 def create_account(self, account_id: int, initial_balance: int) -> None: if account_id in self.accounts: raise ValueError(\\"Account already exists.\\") self.accounts[account_id] = initial_balance self.transactions[account_id] = [(self.transaction_id, 'create', initial_balance, None)] self.transaction_id += 1 def deposit(self, account_id: int, amount: int) -> None: if account_id not in self.accounts: raise ValueError(\\"Invalid account ID.\\") self.accounts[account_id] += amount self.transactions[account_id].append((self.transaction_id, 'deposit', amount, None)) self.transaction_id += 1 def withdraw(self, account_id: int, amount: int) -> None: if account_id not in self.accounts: raise ValueError(\\"Invalid account ID.\\") if self.accounts[account_id] < amount: raise ValueError(\\"Insufficient funds.\\") self.accounts[account_id] -= amount self.transactions[account_id].append((self.transaction_id, 'withdraw', amount, None)) self.transaction_id += 1 def transfer(self, from_account_id: int, to_account_id: int, amount: int) -> None: if from_account_id not in self.accounts or to_account_id not in self.accounts: raise ValueError(\\"Invalid account ID.\\") if self.accounts[from_account_id] < amount: raise ValueError(\\"Insufficient funds.\\") self.accounts[from_account_id] -= amount self.accounts[to_account_id] += amount self.transactions[from_account_id].append((self.transaction_id, 'transfer', amount, to_account_id)) self.transactions[to_account_id].append((self.transaction_id, 'receive', amount, from_account_id)) self.transaction_id += 1 def get_balance(self, account_id: int) -> int: if account_id not in self.accounts: raise ValueError(\\"Invalid account ID.\\") return self.accounts[account_id] def transaction_history(self, account_id: int) -> list: if account_id not in self.transactions: raise ValueError(\\"Invalid account ID.\\") return self.transactions[account_id]"},{"question":"def remove_adjacent_duplicates(message: str) -> str: Function to remove adjacent duplicate characters from a message. Args: message (str): The input string containing the message. Returns: str: A new string with all adjacent duplicate characters removed. Examples: >>> remove_adjacent_duplicates(\\"aabbcc\\") 'abc' >>> remove_adjacent_duplicates(\\"abbaca\\") 'abaca' >>> remove_adjacent_duplicates(\\"mississippi\\") 'misisipi' >>> remove_adjacent_duplicates(\\"bookkeeper\\") 'bokeper' >>> remove_adjacent_duplicates(\\"\\") ''","solution":"def remove_adjacent_duplicates(message: str) -> str: Function to remove adjacent duplicate characters from a message. Args: message (str): The input string containing the message. Returns: str: A new string with all adjacent duplicate characters removed. if not message: return \\"\\" result = [message[0]] for char in message[1:]: if char != result[-1]: result.append(char) return \\"\\".join(result)"},{"question":"def has_pair_with_sum(numbers: list[int], target: int) -> bool: Determines if there exists a pair of numbers in the list that adds up to the target sum. :param numbers: List of integers. :param target: Target sum. :return: True if a pair is found that adds up to the target, else False. >>> has_pair_with_sum([2, 7, 11, 15], 9) True >>> has_pair_with_sum([3, 3], 6) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False >>> has_pair_with_sum([-1, -2, -3, -4, -5], -10) False","solution":"def has_pair_with_sum(numbers, target): Determines if there exists a pair of numbers in the list that adds up to the target sum. :param numbers: List of integers. :param target: Target sum. :return: True if a pair is found that adds up to the target, else False. seen = set() for number in numbers: complement = target - number if complement in seen: return True seen.add(number) return False"},{"question":"from typing import List from collections import Counter, defaultdict def recommend_additional_items(past_orders: List[List[str]], current_cart: List[str]) -> List[str]: Recommends additional items based on past orders and the current cart content. Args: - past_orders (List[List[str]]): A list of past orders, each order is a list of items. - current_cart (List[str]): A list of items currently in the customer's cart. Returns: - List[str]: A list of up to 5 recommended items based on the current cart. Examples: >>> past_orders = [ >>> ['bread', 'butter', 'jam'], >>> ['bread', 'butter'], >>> ['bread', 'jam'], >>> ['coffee', 'pastry'], >>> ['coffee', 'bread'], >>> ['pastry', 'jam'] >>> ] >>> recommend_additional_items(past_orders, ['bread']) ['butter', 'jam', 'coffee'] >>> recommend_additional_items(past_orders, ['coffee']) ['pastry', 'bread'] >>> recommend_additional_items(past_orders, []) []","solution":"from collections import Counter, defaultdict from itertools import combinations def recommend_additional_items(past_orders, current_cart): Recommends additional items based on past orders and the current cart content. Args: - past_orders (List[List[str]]): A list of past orders, each order is a list of items. - current_cart (List[str]): A list of items currently in the customer's cart. Returns: - List[str]: A list of up to 5 recommended items based on the current cart. # Edge case: Empty cart should return an empty list if not current_cart: return [] # Create a dictionary to count co-occurrences of items item_counter = defaultdict(Counter) # Populate the co-occurrence dictionary for order in past_orders: for item1, item2 in combinations(order, 2): item_counter[item1][item2] += 1 item_counter[item2][item1] += 1 # Count the potential recommendations recommendation_counter = Counter() for item in current_cart: for other_item, count in item_counter[item].items(): if other_item not in current_cart: recommendation_counter[other_item] += count # Get the top 5 most common recommendations, sorted alphabetically in case of tie most_common_recommendations = recommendation_counter.most_common() sorted_recommendations = sorted(most_common_recommendations, key=lambda x: (-x[1], x[0])) return [item for item, count in sorted_recommendations[:5]]"},{"question":"import sqlite3 def initialize_database(db_name: str) -> None: Creates a SQLite database with the given name and a table named \`user_settings\` with columns: \`user_id\` (INTEGER), \`preference_key\` (TEXT), \`preference_value\` (TEXT), \`last_updated\` (TEXT). >>> initialize_database(\\"settings.db\\") def insert_user_setting(db_name: str, user_id: int, preference_key: str, preference_value: str, last_updated: str) -> None: Inserts a user setting into the \`user_settings\` table or updates it if it already exists. >>> insert_user_setting(\\"settings.db\\", 1, \\"theme\\", \\"dark\\", \\"2023-10-01\\") def retrieve_user_setting(db_name: str, user_id: int, preference_key: str) -> str: Retrieves the \`preference_value\` for the given \`user_id\` and \`preference_key\`. >>> retrieve_user_setting(\\"settings.db\\", 1, \\"theme\\") 'dark' import os import pytest DB_NAME = \\"test_settings.db\\" def setup_module(module): Setup function to initialize the database before running tests. initialize_database(DB_NAME) def teardown_module(module): Teardown function to remove the test database after running tests. if os.path.exists(DB_NAME): os.remove(DB_NAME) def test_initialize_database(): Test the initialization of the database. assert os.path.exists(DB_NAME) == True def test_insert_user_setting_new(): Test inserting a new user setting. insert_user_setting(DB_NAME, 1, \\"theme\\", \\"dark\\", \\"2023-10-01\\") assert retrieve_user_setting(DB_NAME, 1, \\"theme\\") == \\"dark\\" def test_insert_user_setting_update(): Test updating an existing user setting. insert_user_setting(DB_NAME, 1, \\"theme\\", \\"light\\", \\"2023-10-02\\") assert retrieve_user_setting(DB_NAME, 1, \\"theme\\") == \\"light\\" def test_retrieve_user_setting_non_existent(): Test retrieving a non-existent user setting. assert retrieve_user_setting(DB_NAME, 2, \\"theme\\") is None","solution":"import sqlite3 def initialize_database(db_name: str) -> None: Creates a SQLite database with the given name and a table named \`user_settings\`. conn = sqlite3.connect(db_name) cursor = conn.cursor() cursor.execute(''' CREATE TABLE IF NOT EXISTS user_settings ( user_id INTEGER, preference_key TEXT, preference_value TEXT, last_updated TEXT, PRIMARY KEY (user_id, preference_key) ) ''') conn.commit() conn.close() def insert_user_setting(db_name: str, user_id: int, preference_key: str, preference_value: str, last_updated: str) -> None: Inserts a user setting into the \`user_settings\` table or updates it if it already exists. conn = sqlite3.connect(db_name) cursor = conn.cursor() cursor.execute(''' INSERT INTO user_settings (user_id, preference_key, preference_value, last_updated) VALUES (?, ?, ?, ?) ON CONFLICT(user_id, preference_key) DO UPDATE SET preference_value=excluded.preference_value, last_updated=excluded.last_updated ''', (user_id, preference_key, preference_value, last_updated)) conn.commit() conn.close() def retrieve_user_setting(db_name: str, user_id: int, preference_key: str) -> str: Retrieves the \`preference_value\` for the given \`user_id\` and \`preference_key\`. conn = sqlite3.connect(db_name) cursor = conn.cursor() cursor.execute(''' SELECT preference_value FROM user_settings WHERE user_id = ? AND preference_key = ? ''', (user_id, preference_key)) result = cursor.fetchone() conn.close() return result[0] if result else None"},{"question":"def shortest_travel_time(connections, start, destination): Calculates the shortest travel time between two cities. Parameters: connections (list): A list of connections where each connection is represented as a tuple. - Each tuple consists of (origin: str, destination: str, travel_time: int). start (str): The starting city. destination (str): The destination city. Returns: int: The shortest travel time from start to destination. pass def test_shortest_travel_time_basic(): assert shortest_travel_time( [(\\"A\\", \\"B\\", 50), (\\"A\\", \\"C\\", 40), (\\"B\\", \\"D\\", 30), (\\"C\\", \\"D\\", 20), (\\"A\\", \\"D\\", 100)], \\"A\\", \\"D\\") == 60 def test_shortest_travel_time_with_alternate_paths(): assert shortest_travel_time( [(\\"A\\", \\"B\\", 10), (\\"A\\", \\"C\\", 60), (\\"B\\", \\"D\\", 20), (\\"C\\", \\"D\\", 10), (\\"B\\", \\"C\\", 50)], \\"A\\", \\"D\\") == 30 def test_shortest_travel_time_various(): assert shortest_travel_time( [(\\"A\\", \\"B\\", 5), (\\"B\\", \\"C\\", 5), (\\"C\\", \\"D\\", 5), (\\"A\\", \\"E\\", 100), (\\"E\\", \\"D\\", 5)], \\"A\\", \\"D\\") == 15 def test_shortest_travel_time_unreachable(): assert shortest_travel_time( [(\\"A\\", \\"B\\", 15), (\\"B\\", \\"C\\", 20), (\\"C\\", \\"D\\", 30)], \\"A\\", \\"E\\") == -1 def test_shortest_travel_time_all_same(): assert shortest_travel_time( [(\\"A\\", \\"B\\", 10), (\\"A\\", \\"B\\", 10), (\\"A\\", \\"B\\", 10)], \\"A\\", \\"B\\") == 10 def test_shortest_travel_time_direct_route(): assert shortest_travel_time( [(\\"A\\", \\"B\\", 10), (\\"B\\", \\"C\\", 10)], \\"A\\", \\"C\\") == 20 def test_shortest_travel_time_start_equals_destination(): assert shortest_travel_time( [(\\"A\\", \\"B\\", 10), (\\"B\\", \\"C\\", 10)], \\"A\\", \\"A\\") == 0","solution":"import heapq def shortest_travel_time(connections, start, destination): Calculates the shortest travel time between two cities. Parameters: connections (list): A list of connections where each connection is represented as a tuple. - Each tuple consists of (origin: str, destination: str, travel_time: int). start (str): The starting city. destination (str): The destination city. Returns: int: The shortest travel time from start to destination. graph = {} for origin, dest, time in connections: if origin not in graph: graph[origin] = [] graph[origin].append((dest, time)) pq = [(0, start)] shortest_times = {start: 0} while pq: curr_time, curr_city = heapq.heappop(pq) if curr_city == destination: return curr_time if curr_city in graph: for neighbor, travel_time in graph[curr_city]: new_time = curr_time + travel_time if neighbor not in shortest_times or new_time < shortest_times[neighbor]: shortest_times[neighbor] = new_time heapq.heappush(pq, (new_time, neighbor)) return -1"},{"question":"def task_scheduler(tasks: str) -> bool: Returns True if it's possible to schedule the tasks without any task repeating without a gap of at least one task in between, otherwise False. >>> task_scheduler(\\"abac\\") True >>> task_scheduler(\\"aa\\") False >>> task_scheduler(\\"abcabc\\") True >>> task_scheduler(\\"ab\\") True >>> task_scheduler(\\"aaa\\") False","solution":"def task_scheduler(tasks: str) -> bool: Returns True if it's possible to schedule the tasks without any task repeating without a gap of at least one task in between, otherwise False. from collections import Counter task_count = Counter(tasks) max_freq = max(task_count.values()) # Calculate number of potential slots between the most frequent task occurrences required_slots = (max_freq - 1) # Calculate number of tasks left excluding the most frequent task slots_fillable = len(tasks) - max_freq return slots_fillable >= required_slots"},{"question":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def add_word(self, word): Add a word into the Trie. def search_word(self, word): Check if a word exists in the Trie (return True if exists, False otherwise). def suggest_corrections(self, word, max_edit_distance=2): Given a potentially misspelled word, return a list of words in the Trie that are within a given edit distance from the input word. from solution import Trie def test_add_and_search_word(): trie = Trie() trie.add_word('hello') assert trie.search_word('hello') == True assert trie.search_word('hell') == False assert trie.search_word('helloo') == False def test_suggest_corrections_with_edit_distance_1(): trie = Trie() trie.add_word('hello') trie.add_word('helps') trie.add_word('hero') trie.add_word('hell') suggestions = trie.suggest_corrections('hellp', max_edit_distance=1) assert 'hell' in suggestions assert 'hello' in suggestions assert len(suggestions) == 2 def test_suggest_corrections_with_edit_distance_2(): trie = Trie() trie.add_word('hello') trie.add_word('helps') trie.add_word('hero') trie.add_word('heroine') trie.add_word('helicopter') suggestions = trie.suggest_corrections('helo', max_edit_distance=2) assert 'hello' in suggestions assert 'helps' in suggestions assert len(suggestions) >= 2 def test_suggest_corrections_no_suggestions(): trie = Trie() trie.add_word('hello') trie.add_word('world') suggestions = trie.suggest_corrections('abc', max_edit_distance=2) assert len(suggestions) == 0","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def add_word(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search_word(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def suggest_corrections(self, word, max_edit_distance=2): results = [] def dfs(current_node, current_word, index, max_distance, current_edits): if current_edits > max_distance: return if index == len(word): if current_node.is_end_of_word: results.append(current_word) return for char in current_node.children: if char == word[index]: dfs(current_node.children[char], current_word + char, index + 1, max_distance, current_edits) else: # Substitution dfs(current_node.children[char], current_word + char, index + 1, max_distance, current_edits + 1) # Deletion dfs(current_node, current_word, index + 1, max_distance, current_edits + 1) # Insertion for char in current_node.children: dfs(current_node.children[char], current_word + char, index, max_distance, current_edits + 1) dfs(self.root, '', 0, max_edit_distance, 0) return results"},{"question":"import json class TaskManager: def __init__(self, file_path: str): self.file_path = file_path def list_tasks(self, status: str = None) -> list[dict]: List all tasks, optionally filtered by status pass def add_task(self, title: str, description: str, status: str = \\"pending\\"): Add a new task to the JSON file pass def delete_task(self, title: str): Delete a task by its title pass def update_task(self, title: str, new_title: str = None, new_description: str = None, new_status: str = None): Update the details of a task pass import pytest import json import os from tempfile import TemporaryDirectory @pytest.fixture def temp_task_manager(): with TemporaryDirectory() as tmpdir: file_path = os.path.join(tmpdir, 'tasks.json') yield TaskManager(file_path) def test_add_task(temp_task_manager): temp_task_manager.add_task(\\"Test Task\\", \\"Description\\", \\"pending\\") tasks = temp_task_manager.list_tasks() assert len(tasks) == 1 assert tasks[0]['title'] == \\"Test Task\\" assert tasks[0]['description'] == \\"Description\\" assert tasks[0]['status'] == \\"pending\\" def test_add_task_duplicate_title(temp_task_manager): temp_task_manager.add_task(\\"Test Task\\", \\"Description\\", \\"pending\\") with pytest.raises(ValueError): temp_task_manager.add_task(\\"Test Task\\", \\"Another Description\\") def test_list_tasks(temp_task_manager): temp_task_manager.add_task(\\"Completed Task\\", \\"Description\\", \\"completed\\") temp_task_manager.add_task(\\"Pending Task\\", \\"Description\\", \\"pending\\") all_tasks = temp_task_manager.list_tasks() completed_tasks = temp_task_manager.list_tasks(status=\\"completed\\") pending_tasks = temp_task_manager.list_tasks(status=\\"pending\\") assert len(all_tasks) == 2 assert len(completed_tasks) == 1 assert len(pending_tasks) == 1 assert completed_tasks[0]['title'] == \\"Completed Task\\" assert pending_tasks[0]['title'] == \\"Pending Task\\" def test_delete_task(temp_task_manager): temp_task_manager.add_task(\\"Test Task\\", \\"Description\\", \\"pending\\") temp_task_manager.delete_task(\\"Test Task\\") tasks = temp_task_manager.list_tasks() assert len(tasks) == 0 def test_update_task(temp_task_manager): temp_task_manager.add_task(\\"Old Task\\", \\"Old Description\\", \\"pending\\") temp_task_manager.update_task(\\"Old Task\\", new_title=\\"New Task\\", new_description=\\"New Description\\", new_status=\\"completed\\") tasks = temp_task_manager.list_tasks() assert len(tasks) == 1 task = tasks[0] assert task['title'] == \\"New Task\\" assert task['description'] == \\"New Description\\" assert task['status'] == \\"completed\\" def test_update_nonexistent_task(temp_task_manager): with pytest.raises(ValueError): temp_task_manager.update_task(\\"Nonexistent Task\\", new_title=\\"New\\")","solution":"import json import os class TaskManager: def __init__(self, file_path: str): self.file_path = file_path self._ensure_file() def _ensure_file(self): if not os.path.exists(self.file_path): with open(self.file_path, 'w') as f: json.dump([], f) def _read_tasks(self): with open(self.file_path, 'r') as f: return json.load(f) def _write_tasks(self, tasks): with open(self.file_path, 'w') as f: json.dump(tasks, f, indent=4) def list_tasks(self, status: str = None) -> list[dict]: tasks = self._read_tasks() if status: return [task for task in tasks if task.get('status') == status] return tasks def add_task(self, title: str, description: str, status: str = \\"pending\\"): tasks = self._read_tasks() if any(task['title'] == title for task in tasks): raise ValueError(\\"Task with this title already exists\\") tasks.append({\\"title\\": title, \\"description\\": description, \\"status\\": status}) self._write_tasks(tasks) def delete_task(self, title: str): tasks = self._read_tasks() tasks = [task for task in tasks if task['title'] != title] self._write_tasks(tasks) def update_task(self, title: str, new_title: str = None, new_description: str = None, new_status: str = None): tasks = self._read_tasks() for task in tasks: if task['title'] == title: if new_title: task['title'] = new_title if new_description: task['description'] = new_description if new_status: task['status'] = new_status break else: raise ValueError(\\"Task with this title does not exist\\") self._write_tasks(tasks)"},{"question":"from typing import List def count_distinct_authors(books: List[str]) -> int: Returns the number of distinct authors in a list of books. Each book is in the format \\"Title by Author\\". >>> count_distinct_authors([\\"The Great Gatsby by F. Scott Fitzgerald\\", \\"To Kill a Mockingbird by Harper Lee\\", \\"1984 by George Orwell\\", \\"Go Set a Watchman by Harper Lee\\"]) 3 >>> count_distinct_authors([\\"In Search of Lost Time by Marcel Proust\\", \\"Ulysses by James Joyce\\", \\"Don Quixote by Miguel de Cervantes\\", \\"One Hundred Years of Solitude by Gabriel Garcia Marquez\\"]) 4 >>> count_distinct_authors([]) 0 >>> count_distinct_authors([\\"Sample Book by Sample Author\\", \\"Another Book by Sample Author\\"]) 1 >>> count_distinct_authors([\\"Book One by Author\\", \\"Book Two by author\\"]) 2 >>> count_distinct_authors([\\"Book One by A. Author\\", \\"Book Two by A.Author\\", \\"Book Three by A. Author\\"]) 3","solution":"from typing import List def count_distinct_authors(books: List[str]) -> int: Returns the number of distinct authors in a list of books. Each book is in the format \\"Title by Author\\". authors = set() for book in books: title, author = book.rsplit(\\" by \\", 1) authors.add(author) return len(authors)"},{"question":"def has_cycle(graph: dict) -> bool: Detects if a directed graph has a cycle. Args: - graph (dict): The adjacency list representation of the directed graph where keys are node labels, and values are lists of nodes to which the key node has a directed edge. Returns: - bool: True if there is a cycle, otherwise False >>> has_cycle({0: [1], 1: [2], 2: [0]}) True >>> has_cycle({0: [1, 2], 1: [2], 2: []}) False >>> has_cycle({0: []}) False >>> has_cycle({}) False >>> has_cycle({0: [0]}) True >>> has_cycle({0: [1, 2], 1: [2], 2: [5], 3: [4], 4: [3], 5: []}) True >>> has_cycle({ 0: [1, 2, 3], 1: [4, 5], 2: [6], 3: [], 4: [], 5: [], 6: [] }) False","solution":"def has_cycle(graph: dict) -> bool: Detects if a directed graph has a cycle. Args: - graph (dict): The adjacency list representation of the directed graph Returns: - bool: True if there is a cycle, otherwise False def visit(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph.get(node, []): if visit(neighbor): return True visiting.remove(node) visited.add(node) return False visited = set() visiting = set() for node in graph: if visit(node): return True return False"},{"question":"def find_substring_occurrences(text: str, substring: str) -> int: Computes the number of times a given substring appears within a larger text. Args: text (str): A large string representing the text where the search will be performed. substring (str): A smaller string representing the substring whose occurrences need to be counted. Returns: int: The number of times \`substring\` appears in \`text\`. Examples: >>> find_substring_occurrences(\\"banana\\", \\"na\\") 2 >>> find_substring_occurrences(\\"aaaaaa\\", \\"aa\\") 5 >>> find_substring_occurrences(\\"abcdef\\", \\"gh\\") 0","solution":"def find_substring_occurrences(text: str, substring: str) -> int: Returns the number of times the substring appears within the text including overlapping occurrences. count = start = 0 while True: start = text.find(substring, start) if start == -1: break count += 1 start += 1 # Move to the next position to allow overlapping matches return count"},{"question":"def max_consecutive_increasing_length(nums: List[int]) -> int: Returns the length of the longest consecutive increasing subsequence. >>> max_consecutive_increasing_length([1, 2, 4, 7, 8, 9]) 3 >>> max_consecutive_increasing_length([3, 10, 2, 1, 9, 8]) 1","solution":"def max_consecutive_increasing_length(nums): Returns the length of the longest consecutive increasing subsequence. if not nums: return 0 max_length = 1 current_length = 1 for i in range(1, len(nums)): if nums[i] == nums[i-1] + 1: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"from typing import List def can_match_arrays(arr1: List[int], arr2: List[int]) -> bool: Determines if two arrays can be made equal by adding zero or more elements to one or both arrays, so they eventually contain the same elements, regardless of order and frequency. >>> can_match_arrays([1, 2, 3], [3, 1, 2]) True >>> can_match_arrays([1, 2, 2, 3], [1, 3, 2, 2]) True >>> can_match_arrays([1, 2, 3], [1, 2]) False >>> can_match_arrays([1], [1, 1]) False","solution":"from collections import Counter def can_match_arrays(arr1: list[int], arr2: list[int]) -> bool: Determines if two arrays can be made equal by adding zero or more elements to one or both arrays, so they eventually contain the same elements, regardless of order and frequency. counter1 = Counter(arr1) counter2 = Counter(arr2) return counter1 == counter2"},{"question":"from typing import List class CommandHistory: def __init__(self, limit: int): Initializes the CommandHistory object with a fixed limit on the number of commands to track. :param limit: The maximum number of commands to retain in history. def execute(self, command: str) -> None: Adds a new command to the history. :param command: The command to be added to the history. def get_history(self) -> List[str]: Returns the list of commands in the history, in the order they were executed, up to the specified limit. :return: A list of commands. # Example usage: # h = CommandHistory(3) # h.execute(\\"mkdir new_folder\\") # h.execute(\\"cd new_folder\\") # h.execute(\\"touch file.txt\\") # print(h.get_history()) # Output: [\\"mkdir new_folder\\", \\"cd new_folder\\", \\"touch file.txt\\"] # h.execute(\\"ls\\") # print(h.get_history()) # Output: [\\"cd new_folder\\", \\"touch file.txt\\", \\"ls\\"]","solution":"class CommandHistory: def __init__(self, limit: int): self.limit = limit self.history = [] def execute(self, command: str) -> None: if len(self.history) >= self.limit: self.history.pop(0) self.history.append(command) def get_history(self) -> list: return self.history"},{"question":"from collections import deque from typing import Dict, List def bfs_traversal(graph: Dict[int, List[int]], start_node: int) -> List[int]: Perform BFS traversal from a given starting node in a graph. >>> graph = {0: [1, 2], 1: [0, 3, 4], 2: [0], 3: [1], 4: [1, 5], 5: [4]} >>> bfs_traversal(graph, 0) [0, 1, 2, 3, 4, 5] >>> graph = {0: [1], 1: [0], 2: [3], 3: [2]} >>> bfs_traversal(graph, 0) [0, 1] pass def shortest_path_bfs(graph: Dict[int, List[int]], start_node: int, target_node: int) -> List[int]: Find the shortest path between two nodes using BFS in a graph. >>> graph = {0: [1, 2], 1: [0, 3, 4], 2: [0], 3: [1], 4: [1, 5], 5: [4]} >>> shortest_path_bfs(graph, 0, 5) [0, 1, 4, 5] >>> graph = {0: [1], 1: [0], 2: [3], 3: [2]} >>> shortest_path_bfs(graph, 0, 3) [] >>> graph = {0: [1, 2], 1: [0, 3, 4], 2: [0], 3: [1], 4: [1, 5], 5: [4]} >>> shortest_path_bfs(graph, 0, 0) [0] >>> graph = {0: [1, 2], 1: [0, 3], 2: [0], 3: [1]} >>> shortest_path_bfs(graph, 0, 1) [0, 1] pass","solution":"from collections import deque from typing import Dict, List def bfs_traversal(graph: Dict[int, List[int]], start_node: int) -> List[int]: visited = set() traversal_order = [] queue = deque([start_node]) while queue: node = queue.popleft() if node not in visited: visited.add(node) traversal_order.append(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return traversal_order def shortest_path_bfs(graph: Dict[int, List[int]], start_node: int, target_node: int) -> List[int]: if start_node == target_node: return [start_node] visited = set() queue = deque([(start_node, [start_node])]) while queue: current_node, path = queue.popleft() visited.add(current_node) for neighbor in graph[current_node]: if neighbor == target_node: return path + [neighbor] if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return []"},{"question":"from typing import List def moving_average_filter(signal: List[float], window_size: int) -> List[float]: Applies a simple moving average filter to the input signal. Parameters: signal (List[float]): The input signal data points. window_size (int): The size of the moving average window. Returns: List[float]: The denoised signal after applying the moving average filter. Examples: >>> moving_average_filter([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) [2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0] >>> moving_average_filter([10, 20, 30, 40, 50], 2) [15.0, 25.0, 35.0, 45.0] >>> moving_average_filter([-1, 0, 1, 0, -1], 1) [-1.0, 0.0, 1.0, 0.0, -1.0]","solution":"from typing import List def moving_average_filter(signal: List[float], window_size: int) -> List[float]: Applies a simple moving average filter to the input signal. Parameters: signal (List[float]): The input signal data points. window_size (int): The size of the moving average window. Returns: List[float]: The denoised signal after applying the moving average filter. # Length of the signal n = len(signal) # List to store the resulting smoothed signal smoothed_signal = [] # Compute the moving average filter for i in range(n - window_size + 1): window = signal[i:i + window_size] average = sum(window) / window_size smoothed_signal.append(average) return smoothed_signal"},{"question":"def find_pairs_with_sum(arr: list[int], k: int) -> int: Returns the number of unique pairs in the array such that their sum is equal to k. >>> find_pairs_with_sum([1, 2, 3, 4, 3], 6) 2 >>> find_pairs_with_sum([1, 1, 1, 1], 2) 1 >>> find_pairs_with_sum([-1, -2, 3, 7], 6) 1 >>> find_pairs_with_sum([1], 2) 0 >>> find_pairs_with_sum([1, 2, 3, 4], 8) 0 >>> find_pairs_with_sum([], 5) 0 >>> find_pairs_with_sum([1000000, 999999, -1000000, 1], 0) 1 >>> find_pairs_with_sum([10, -10, 20, -20, 30, -30, 40, -40, 50, -50], 0) 5","solution":"def find_pairs_with_sum(arr: list[int], k: int) -> int: Returns the number of unique pairs in the array such that their sum is equal to k. seen = set() pairs = set() for number in arr: target = k - number if target in seen: pairs.add((min(number, target), max(number, target))) seen.add(number) return len(pairs)"},{"question":"def odd_even_sort(arr): Sort the array such that all odd numbers appear before all even numbers, while maintaining the relative order among odd and even numbers. :param arr: list of integers :return: sorted list of integers odd_numbers = [x for x in arr if x % 2 != 0] even_numbers = [x for x in arr if x % 2 == 0] sorted_arr = odd_numbers + even_numbers return sorted_arr def test_odd_even_sort(): Test function for the odd-even sort. assert odd_even_sort([8, 13, 17, 2, 7, 4, 1]) == [13, 17, 7, 1, 8, 2, 4] assert odd_even_sort([2, 4, 6, 8, 10, 11, 1]) == [11, 1, 2, 4, 6, 8, 10] assert odd_even_sort([1, 3, 5, 7, 9, 2, 4]) == [1, 3, 5, 7, 9, 2, 4] assert odd_even_sort([]) == [] assert odd_even_sort([1, 2, 3, 4, 5]) == [1, 3, 5, 2, 4] assert odd_even_sort([7, 11, 9, 3, 6, 2, 4]) == [7, 11, 9, 3, 6, 2, 4] assert odd_even_sort([4, 2, 8]) == [4, 2, 8] print(\\"All tests passed.\\") if __name__ == \\"__main__\\": test_odd_even_sort()","solution":"def odd_even_sort(arr): Sort the array such that all odd numbers appear before all even numbers, while maintaining the relative order among odd and even numbers. :param arr: list of integers :return: sorted list of integers # Separate the odd and even numbers while maintaining the relative order odd_numbers = [x for x in arr if x % 2 != 0] even_numbers = [x for x in arr if x % 2 == 0] # Concatenate odd and even numbers sorted_arr = odd_numbers + even_numbers return sorted_arr"},{"question":"def array_product_except_self(nums: list) -> list: Construct an array 'output' such that output[i] is the product of all the elements of nums except nums[i]. >>> array_product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> array_product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> array_product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] pass","solution":"def array_product_except_self(nums: list) -> list: Construct an array 'output' such that output[i] is the product of all the elements of nums except nums[i]. Args: nums (list): input list of integers Returns: list: list of products except self n = len(nums) output = [1] * n # Calculate left products left_product = 1 for i in range(n): output[i] = left_product left_product *= nums[i] # Calculate right products and multiply with left products right_product = 1 for i in range(n - 1, -1, -1): output[i] *= right_product right_product *= nums[i] return output"},{"question":"def first_duplicate(array: list[int]) -> int | None: Returns the first duplicated element in the array. If no duplicates are found, returns None. >>> first_duplicate([2, 1, 3, 5, 3, 2]) 3 >>> first_duplicate([1, 2, 3, 1, 3, 2]) 1 >>> first_duplicate([2, 1, 3, 5]) None >>> first_duplicate([7, 8, 9, 10]) None >>> first_duplicate([1]) None >>> first_duplicate([]) None >>> arr = list(range(1000)) + [499] >>> first_duplicate(arr) 499","solution":"def first_duplicate(array): Returns the first duplicate element in the array. If no duplicates are found, returns None. seen = set() for element in array: if element in seen: return element seen.add(element) return None"},{"question":"def largest_non_repeated_subsequence(s: str) -> int: Returns the length of the longest subsequence with no repeated characters. >>> largest_non_repeated_subsequence(\\"aabbcc\\") 3 >>> largest_non_repeated_subsequence(\\"abcdefg\\") 7 >>> largest_non_repeated_subsequence(\\"aa\\") 1 >>> largest_non_repeated_subsequence(\\"z\\") 1 >>> largest_non_repeated_subsequence(\\"\\") 0","solution":"def largest_non_repeated_subsequence(s: str) -> int: Returns the length of the longest subsequence with no repeated characters. unique_characters = set(s) return len(unique_characters)"},{"question":"def max_profit(prices: list[int]) -> int: Compute the maximum profit achievable from an array of stock prices, where you are allowed to buy and sell the stock only once. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([7, 1, 5, 3, 6, 4, 10]) 9 >>> max_profit([]) 0 # Your implementation here","solution":"def max_profit(prices: list[int]) -> int: # If the list is empty or has only one element, no profit can be achieved if not prices or len(prices) < 2: return 0 # Initialize the minimum price to the first element and max profit to 0 min_price = prices[0] max_profit = 0 # Iterate through prices starting from the second element for price in prices[1:]: # Update the minimum price if a lower price is found if price < min_price: min_price = price # Calculate the potential profit by selling at the current price potential_profit = price - min_price # Update max profit if the current potential profit is greater if potential_profit > max_profit: max_profit = potential_profit return max_profit"},{"question":"# Function Signature def sort_students(students: List[Tuple[str, int, float]]) -> List[Tuple[str, int, float]]: Sorts a list of student records based on GPA (descending), then age (ascending), then name (alphabetical). Args: students (List[Tuple[str, int, float]]): List of student records, each containing name (str), age (int), and GPA (float). Returns: List[Tuple[str, int, float]]: Sorted list of student records. return sorted(students, key=lambda x: (-x[2], x[1], x[0])) # Unit Tests from solution import sort_students def test_sort_students(): students = [ (\\"John\\", 21, 3.5), (\\"Jane\\", 20, 3.8), (\\"Dave\\", 21, 3.8), (\\"Doe\\", 20, 3.5) ] expected = [ (\\"Jane\\", 20, 3.8), (\\"Dave\\", 21, 3.8), (\\"Doe\\", 20, 3.5), (\\"John\\", 21, 3.5) ] assert sort_students(students) == expected def test_sort_students_same_gpa_different_age(): students = [ (\\"Alice\\", 22, 3.7), (\\"Bob\\", 20, 3.7), (\\"Charlie\\", 21, 3.7) ] expected = [ (\\"Bob\\", 20, 3.7), (\\"Charlie\\", 21, 3.7), (\\"Alice\\", 22, 3.7) ] assert sort_students(students) == expected def test_sort_students_same_gpa_same_age(): students = [ (\\"Alice\\", 22, 3.7), (\\"Charlie\\", 22, 3.7), (\\"Bob\\", 22, 3.7) ] expected = [ (\\"Alice\\", 22, 3.7), (\\"Bob\\", 22, 3.7), (\\"Charlie\\", 22, 3.7) ] assert sort_students(students) == expected def test_sort_students_mixed(): students = [ (\\"John\\", 23, 3.5), (\\"Jane\\", 20, 4.0), (\\"Dave\\", 21, 3.5), (\\"Doe\\", 19, 4.0), (\\"Alice\\", 21, 3.9) ] expected = [ (\\"Doe\\", 19, 4.0), (\\"Jane\\", 20, 4.0), (\\"Alice\\", 21, 3.9), (\\"Dave\\", 21, 3.5), (\\"John\\", 23, 3.5) ] assert sort_students(students) == expected","solution":"from typing import List, Tuple def sort_students(students: List[Tuple[str, int, float]]) -> List[Tuple[str, int, float]]: Sorts a list of student records based on GPA (descending), then age (ascending), then name (alphabetical). Args: students (List[Tuple[str, int, float]]): List of student records, each containing name (str), age (int), and GPA (float). Returns: List[Tuple[str, int, float]]: Sorted list of student records. return sorted(students, key=lambda x: (-x[2], x[1], x[0]))"},{"question":"def merge_sort(collection: list[int]) -> list[int]: Implement the merge sort algorithm to sort an array of integers in ascending order. >>> merge_sort([4, 2, 7, 1, 3]) [1, 2, 3, 4, 7] >>> merge_sort([]) [] >>> merge_sort([1, 1, 1, 1, 1, 1]) [1, 1, 1, 1, 1, 1]","solution":"def merge_sort(collection: list[int]) -> list[int]: if len(collection) <= 1: return collection def merge(left: list[int], right: list[int]) -> list[int]: sorted_list = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list mid = len(collection) // 2 left_half = merge_sort(collection[:mid]) right_half = merge_sort(collection[mid:]) return merge(left_half, right_half)"},{"question":"def max_subarray_sum(price_changes: list[int]) -> int: Finds the maximum sum of any contiguous subarray. :param price_changes: List of integers representing daily price changes. :return: Maximum sum of any contiguous subarray. Example: >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([4, -1, 2, 1]) 6 >>> max_subarray_sum([]) 0 def test_max_subarray_sum_example_case1(): assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 def test_max_subarray_sum_all_positive(): assert max_subarray_sum([1, 2, 3, 4, 5]) == 15 def test_max_subarray_sum_all_negative(): assert max_subarray_sum([-1, -2, -3, -4, -5]) == -1 def test_max_subarray_sum_mixed(): assert max_subarray_sum([4, -1, 2, 1]) == 6 def test_max_subarray_sum_empty(): assert max_subarray_sum([]) == 0 def test_max_subarray_sum_single_positive(): assert max_subarray_sum([3]) == 3 def test_max_subarray_sum_single_negative(): assert max_subarray_sum([-3]) == -3 def test_max_subarray_sum_mixed_2(): assert max_subarray_sum([1, -2, 3, -1, 2, -3, 1]) == 4 def test_max_subarray_sum_zigzag(): assert max_subarray_sum([1, -2, 3, 4, -5, 8]) == 10","solution":"def max_subarray_sum(price_changes: list[int]) -> int: Finds the maximum sum of any contiguous subarray. :param price_changes: List of integers representing daily price changes. :return: Maximum sum of any contiguous subarray. if not price_changes: # Edge case for empty list return 0 max_current = max_global = price_changes[0] for change in price_changes[1:]: max_current = max(change, max_current + change) if max_current > max_global: max_global = max_current return max_global"},{"question":"from collections import defaultdict from typing import List, Tuple, Dict def analyze_sales_trends(sales_records: List[Tuple[str, int, float]]) -> Dict[Tuple[int, int], Dict[int, float]]: Analyzes sales data to find average sales per product per month. Parameters: sales_records (list): A list of tuples where each tuple consists of a date (str), a product ID (int), and a sales amount (float). Returns: dict: A dictionary where the keys are tuples representing the month and year (in the format (YYYY, MM)). Each value is another dictionary that maps product IDs to their average sales amount for that month. >>> sales_records = [ ... ('2022-01-15', 101, 150.0), ... ('2022-01-20', 102, 200.0), ... ('2022-02-15', 101, 300.0), ... ('2022-02-15', 102, 400.0), ... ('2022-01-25', 101, 250.0), ... ('2022-02-25', 101, 100.0) ... ] >>> analyze_sales_trends(sales_records) {(2022, 1): {101: 200.0, 102: 200.0}, (2022, 2): {101: 200.0, 102: 400.0}} >>> sales_records = [ ... ('2022-03-10', 201, 100.0), ... ('2022-03-15', 201, 300.0), ... ('2022-03-20', 202, 400.0) ... ] >>> analyze_sales_trends(sales_records) {(2022, 3): {201: 200.0, 202: 400.0}} >>> sales_records = [] >>> analyze_sales_trends(sales_records) {} >>> sales_records = [ ... ('2022-04-01', 303, 150.0), ... ('2022-04-01', 303, 250.0), ... ('2022-04-01', 304, 300.0) ... ] >>> analyze_sales_trends(sales_records) {(2022, 4): {303: 200.0, 304: 300.0}}","solution":"from collections import defaultdict from statistics import mean def analyze_sales_trends(sales_records): Analyzes sales data to find average sales per product per month. Parameters: sales_records (list): A list of tuples where each tuple consists of a date (str), a product ID (int), and a sales amount (float). Returns: dict: A dictionary where the keys are tuples representing the month and year (in the format (YYYY, MM)). Each value is another dictionary that maps product IDs to their average sales amount for that month. sales_data = defaultdict(lambda: defaultdict(list)) for record in sales_records: date, product_id, sales_amount = record year, month, _ = map(int, date.split('-')) sales_data[(year, month)][product_id].append(sales_amount) # Calculate the average sales for each product per month result = {} for ym, products in sales_data.items(): result[ym] = {pid: mean(amounts) for pid, amounts in products.items()} return result"},{"question":"class AVLNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def insert(self, root, key): # Implement insert functionality for AVL Tree pass def delete(self, root, key): # Implement delete functionality for AVL Tree pass def leftRotate(self, z): # Implement left rotation for AVL Tree pass def rightRotate(self, z): # Implement right rotation for AVL Tree pass def getHeight(self, root): # Implement function to get height of a node pass def getBalance(self, root): # Implement function to get balance factor of a node pass def getMinValueNode(self, root): # Implement function to get node with minimum value in the tree pass def inOrder(self, root): # Implement in-order traversal of the tree pass def avl_tree_operations(n: int, operations: list): Implement an AVL Tree with insertion and deletion operations. Args: n : int : number of operations operations : list of str : list of operations (e.g., \\"insert x\\", \\"delete x\\") This program should print the in-order traversal of the AVL Tree after each operation. If the tree is empty after an operation, it should print \\"Tree is empty\\". Example: >>> avl_tree_operations(7, [\\"insert 10\\", \\"insert 20\\", \\"insert 30\\", \\"delete 20\\", \\"insert 40\\", \\"insert 50\\", \\"delete 30\\"]) 10 10 20 10 20 30 10 30 10 30 40 10 30 40 50 10 40 50 # Initialize AVL Tree and perform operations pass","solution":"class AVLNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def insert(self, root, key): if not root: return AVLNode(key) elif key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.getHeight(root.left), self.getHeight(root.right)) balance = self.getBalance(root) if balance > 1 and key < root.left.key: return self.rightRotate(root) if balance < -1 and key > root.right.key: return self.leftRotate(root) if balance > 1 and key > root.left.key: root.left = self.leftRotate(root.left) return self.rightRotate(root) if balance < -1 and key < root.right.key: root.right = self.rightRotate(root.right) return self.leftRotate(root) return root def delete(self, root, key): if not root: return root if key < root.key: root.left = self.delete(root.left, key) elif key > root.key: root.right = self.delete(root.right, key) else: if root.left is None: temp = root.right root = None return temp elif root.right is None: temp = root.left root = None return temp temp = self.getMinValueNode(root.right) root.key = temp.key root.right = self.delete(root.right, temp.key) if root is None: return root root.height = 1 + max(self.getHeight(root.left), self.getHeight(root.right)) balance = self.getBalance(root) if balance > 1 and self.getBalance(root.left) >= 0: return self.rightRotate(root) if balance < -1 and self.getBalance(root.right) <= 0: return self.leftRotate(root) if balance > 1 and self.getBalance(root.left) < 0: root.left = self.leftRotate(root.left) return self.rightRotate(root) if balance < -1 and self.getBalance(root.right) > 0: root.right = self.rightRotate(root.right) return self.leftRotate(root) return root def leftRotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right)) y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right)) return y def rightRotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right)) y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right)) return y def getHeight(self, root): if not root: return 0 return root.height def getBalance(self, root): if not root: return 0 return self.getHeight(root.left) - self.getHeight(root.right) def getMinValueNode(self, root): if root is None or root.left is None: return root return self.getMinValueNode(root.left) def inOrder(self, root): res = [] if root: res = self.inOrder(root.left) res.append(root.key) res = res + self.inOrder(root.right) return res def avl_tree_operations(n, operations): avltree = AVLTree() root = None for operation in operations: operation = operation.split() if operation[0] == \\"insert\\": root = avltree.insert(root, int(operation[1])) elif operation[0] == \\"delete\\": root = avltree.delete(root, int(operation[1])) in_order_traversal = avltree.inOrder(root) if in_order_traversal: print(\\" \\".join(map(str, in_order_traversal))) else: print(\\"Tree is empty\\")"},{"question":"from typing import List def reorder_list(nums: List[int]) -> List[int]: Reorders the list such that the first element is the maximum value, the second element is the minimum value, the third element is the second maximum, the fourth element is the second minimum, and so on. >>> reorder_list([1, 3, 2, 5, 4]) == [5, 1, 4, 2, 3] >>> reorder_list([10, -1, 2, 11, -5]) == [11, -5, 10, -1, 2] >>> reorder_list([3]) == [3] >>> reorder_list([]) == [] >>> reorder_list([5, 5, 5, 5]) == [5, 5, 5, 5] >>> reorder_list([-3, -1, -2, -5, -4]) == [-1, -5, -2, -4, -3] >>> reorder_list(list(range(1, 10001))) == [10000, 1, 9999, 2, 9998, 3, ...]","solution":"from typing import List def reorder_list(nums: List[int]) -> List[int]: Reorders the list such that the first element is the maximum value, the second element is the minimum value, the third element is the second maximum, the fourth element is the second minimum, and so on. if not nums: return [] nums.sort() result = [] left, right = 0, len(nums) - 1 while left <= right: if left == right: result.append(nums[left]) else: result.append(nums[right]) result.append(nums[left]) left += 1 right -= 1 return result"},{"question":"def vigenere_encrypt(keyword: str, plaintext: str) -> str: Encrypts the plaintext using the Vigenre cipher. :param keyword: The keyword used for encryption. :param plaintext: The plaintext to be encrypted. :return: The ciphertext as a string. pass def vigenere_decrypt(keyword: str, ciphertext: str) -> str: Decrypts the ciphertext using the Vigenre cipher. :param keyword: The keyword used for decryption. :param ciphertext: The ciphertext to be decrypted. :return: The plaintext as a string. pass def test_vigenere_encrypt(): assert vigenere_encrypt(\\"LEMON\\", \\"ATTACKATDAWN\\") == \\"LXFOPVEFRNHR\\" assert vigenere_encrypt(\\"KEY\\", \\"HELLO\\") == \\"RIJVS\\" assert vigenere_encrypt(\\"ABC\\", \\"HELLO\\") == \\"HFNLP\\" def test_vigenere_decrypt(): assert vigenere_decrypt(\\"LEMON\\", \\"LXFOPVEFRNHR\\") == \\"ATTACKATDAWN\\" assert vigenere_decrypt(\\"KEY\\", \\"RIJVS\\") == \\"HELLO\\" assert vigenere_decrypt(\\"ABC\\", \\"HFNLP\\") == \\"HELLO\\" def test_vigenere_cipher_round_trip(): keyword = \\"KEYWORD\\" plaintext = \\"HELLOVIGENERE\\" encrypted = vigenere_encrypt(keyword, plaintext) decrypted = vigenere_decrypt(keyword, encrypted) assert decrypted == plaintext, f\\"Expected: {plaintext}, Got: {decrypted}\\" keyword2 = \\"SECRET\\" plaintext2 = \\"VIGENERECIPHER\\" encrypted2 = vigenere_encrypt(keyword2, plaintext2) decrypted2 = vigenere_decrypt(keyword2, encrypted2) assert decrypted2 == plaintext2, f\\"Expected: {plaintext2}, Got: {decrypted2}\\"","solution":"def vigenere_encrypt(keyword: str, plaintext: str) -> str: Encrypts the plaintext using the Vigenre cipher. :param keyword: The keyword used for encryption. :param plaintext: The plaintext to be encrypted. :return: The ciphertext as a string. keyword = keyword.upper() plaintext = plaintext.upper() keyword_repeated = (keyword * ((len(plaintext) // len(keyword)) + 1))[:len(plaintext)] ciphertext = \\"\\" for p_letter, k_letter in zip(plaintext, keyword_repeated): shift = ord(k_letter) - ord('A') encrypted_letter = chr(((ord(p_letter) - ord('A') + shift) % 26) + ord('A')) ciphertext += encrypted_letter return ciphertext def vigenere_decrypt(keyword: str, ciphertext: str) -> str: Decrypts the ciphertext using the Vigenre cipher. :param keyword: The keyword used for decryption. :param ciphertext: The ciphertext to be decrypted. :return: The plaintext as a string. keyword = keyword.upper() ciphertext = ciphertext.upper() keyword_repeated = (keyword * ((len(ciphertext) // len(keyword)) + 1))[:len(ciphertext)] plaintext = \\"\\" for c_letter, k_letter in zip(ciphertext, keyword_repeated): shift = ord(k_letter) - ord('A') decrypted_letter = chr(((ord(c_letter) - ord('A') - shift + 26) % 26) + ord('A')) plaintext += decrypted_letter return plaintext"},{"question":"from typing import List def number_of_islands(grid: List[List[str]]) -> int: Determine the number of distinct islands in a given 2D grid map. >>> grid = [ ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ... ] >>> number_of_islands(grid) 3 >>> grid = [ ... [\\"1\\",\\"0\\",\\"1\\",\\"0\\"], ... [\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"1\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ... ] >>> number_of_islands(grid) 3","solution":"from typing import List def number_of_islands(grid: List[List[str]]) -> int: if not grid: return 0 rows = len(grid) cols = len(grid[0]) count = 0 def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == '0': return grid[r][c] = '0' # Mark the land as visited by turning it into water # Check all four directions (up, down, left, right) dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) for r in range(rows): for c in range(cols): if grid[r][c] == '1': count += 1 dfs(r, c) return count"},{"question":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def invert_binary_tree(root: Node) -> Node: Invert a binary tree by swapping the left and right children of every node. >>> root = Node(4) >>> root.left = Node(2) >>> root.right = Node(7) >>> root.left.left = Node(1) >>> root.left.right = Node(3) >>> root.right.left = Node(6) >>> root.right.right = Node(9) >>> inverted_root = invert_binary_tree(root) >>> inverted_root.value 4 >>> inverted_root.left.value 7 >>> inverted_root.right.value 2 >>> inverted_root.left.left.value 9 >>> inverted_root.left.right.value 6 >>> inverted_root.right.left.value 3 >>> inverted_root.right.right.value 1","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def invert_binary_tree(root: Node) -> Node: if root is None: return None # Swap the left and right children root.left, root.right = invert_binary_tree(root.right), invert_binary_tree(root.left) return root"},{"question":"class FileSharingSystem: def __init__(self): # Initializes the file sharing tracking system. pass def track_sharing(self, file_id: int, sender: int, receiver: int): Tracks the sharing of a file between users. Args: file_id (int): Identifier for the file being shared. sender (int): The user ID of the sender. receiver (int): The user ID of the receiver. Raises: ValueError: If file_id, sender, or receiver is not a positive integer, or if sender and receiver are the same. pass def unique_sharers(self, file_id: int) -> int: Returns the number of unique users that a file has been shared with, excluding the original sender. Args: file_id (int): Identifier for the file. Returns: int: Number of unique users the file has been shared with. Raises: ValueError: If file_id is not a positive integer. pass # Example usage: # fs_system = FileSharingSystem() # fs_system.track_sharing(1, 1001, 1002) # fs_system.track_sharing(1, 1002, 1003) # fs_system.track_sharing(1, 1003, 1004) # print(fs_system.unique_sharers(1)) # Expected Output: 3","solution":"class FileSharingSystem: def __init__(self): # Initialize the tracking mechanism self.sharing_log = {} def track_sharing(self, file_id: int, sender: int, receiver: int): if file_id <= 0 or sender <= 0 or receiver <= 0: raise ValueError(\\"File ID and user IDs must be positive integers.\\") if sender == receiver: raise ValueError(\\"Sender and receiver must be different users.\\") if file_id not in self.sharing_log: self.sharing_log[file_id] = set() self.sharing_log[file_id].add(receiver) def unique_sharers(self, file_id: int) -> int: if file_id <= 0: raise ValueError(\\"File ID must be a positive integer.\\") if file_id not in self.sharing_log: return 0 return len(self.sharing_log[file_id])"},{"question":"def max_product(nums: list[int]) -> int: Calculate the maximum product of two distinct elements in an array. >>> max_product([1, 2, 3, 4]) 12 >>> max_product([-10, -20, 1, 2, 3]) 200 >>> max_product([5, 6, 2, 7, 4]) 42 >>> max_product([-1, -3, -4, 2, 0]) 12 >>> max_product([1, 0, -1, -3, -5]) 15","solution":"def max_product(nums: list[int]) -> int: Returns the maximum product of any two distinct elements in the list. if len(nums) < 2: raise ValueError(\\"The list must contain at least two elements\\") # Initialize two smallest and two largest elements smallest = float('inf') second_smallest = float('inf') largest = float('-inf') second_largest = float('-inf') for num in nums: # Update smallest and second smallest if num <= smallest: second_smallest = smallest smallest = num elif num < second_smallest: second_smallest = num # Update largest and second largest if num >= largest: second_largest = largest largest = num elif num > second_largest: second_largest = num return max(smallest * second_smallest, largest * second_largest)"},{"question":"def two_sum(nums: list, target: int) -> list: Returns the indices of the two numbers such that they add up to the target. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([], 0) [] >>> two_sum([5], 5) [] >>> two_sum([1000000, 500000, -500000], 0) [1, 2] >>> two_sum([-3, 4, 3, 90], 0) [0, 2] >>> nums = list(range(1, 1000001)) >>> two_sum(nums, 1999999) [999998, 999999]","solution":"def two_sum(nums, target): Returns the indices of the two numbers such that they add up to the target. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return []"},{"question":"import re def validate_and_format_email(email: str) -> str: Validate and format an email address according to the specified rules. :param email: str: The email address to validate and format. :return: str: The formatted email address if valid. :raises ValueError: If the email address is invalid. Examples: >>> validate_and_format_email(\\"EXAMPLE@DOMAIN.COM\\") 'example@domain.com' >>> validate_and_format_email(\\" example@domain.com \\") 'example@domain.com' >>> validate_and_format_email(\\"user.name+alias@domain.co.in\\") 'user.name+alias@domain.co.in' >>> validate_and_format_email(\\"username@.domain.com\\") Traceback (most recent call last): ... ValueError: Invalid email address format >>> validate_and_format_email(\\"username@domain.c\\") Traceback (most recent call last): ... ValueError: Invalid email address format >>> validate_and_format_email(\\"@domain.com\\") Traceback (most recent call last): ... ValueError: Invalid email address format >>> validate_and_format_email(\\"username@domaincom\\") Traceback (most recent call last): ... ValueError: Invalid email address format","solution":"import re def validate_and_format_email(email: str) -> str: Validate and format an email address according to the specified rules. :param email: str: The email address to validate and format. :return: str: The formatted email address if valid. :raises ValueError: If the email address is invalid. Examples: >>> validate_and_format_email(\\"EXAMPLE@DOMAIN.COM\\") 'example@domain.com' >>> validate_and_format_email(\\" example@domain.com \\") 'example@domain.com' >>> validate_and_format_email(\\"user.name+alias@domain.co.in\\") 'user.name+alias@domain.co.in' >>> validate_and_format_email(\\"username@.domain.com\\") Traceback (most recent call last): ... ValueError: Invalid email address format >>> validate_and_format_email(\\"username@domain.c\\") Traceback (most recent call last): ... ValueError: Invalid email address format >>> validate_and_format_email(\\"@domain.com\\") Traceback (most recent call last): ... ValueError: Invalid email address format >>> validate_and_format_email(\\"username@domaincom\\") Traceback (most recent call last): ... ValueError: Invalid email address format email = email.strip().lower() if not email: raise ValueError(\\"Empty string provided as email address\\") # Email validation regex pattern pattern = re.compile( r\\"^(?P<local>[a-zA-Z0-9._%+-]+)@(?P<domain>[a-zA-Z0-9.-]+.[a-zA-Z]{2,6})\\" ) match = pattern.match(email) if not match: raise ValueError(\\"Invalid email address format\\") local_part = match.group(\\"local\\") domain_part = match.group(\\"domain\\") # Validate local part if len(local_part) == 0: raise ValueError(\\"Invalid local part in email address\\") # Validate domain part if len(domain_part.split(\\".\\")[-1]) < 2 or len(domain_part.split(\\".\\")[-1]) > 6: raise ValueError(\\"Invalid domain part in email address\\") return email"},{"question":"def sum_of_distinct_elements(arr: list) -> int: Returns the sum of all distinct elements in the array. >>> sum_of_distinct_elements([2, 4, 5, 7, 5, 4, 7, 2, 8]) 26 >>> sum_of_distinct_elements([1, 2, 3, 4, 5]) 15 >>> sum_of_distinct_elements([1, -1, 1, -1, 0]) 0 >>> sum_of_distinct_elements([]) 0 >>> sum_of_distinct_elements([10, 10, 10]) 10 >>> sum_of_distinct_elements([-1, -2, -3, -2, -1]) -6 >>> sum_of_distinct_elements([0]) 0 >>> sum_of_distinct_elements([1000000, -1000000]) 0 >>> sum_of_distinct_elements([1]) 1 >>> sum_of_distinct_elements(list(range(100000))) 4999950000","solution":"def sum_of_distinct_elements(arr: list) -> int: Returns the sum of all distinct elements in the array. return sum(set(arr))"},{"question":"def process_queries(queries: list[tuple[str, int]]) -> list[int]: Process a sequence of query operations to manipulate a dynamic array and output results of specific query types. >>> process_queries([(\\"Insert\\", 10), (\\"Insert\\", 5), (\\"GetMax\\",)]) [10] >>> process_queries([(\\"Insert\\", 10), (\\"Insert\\", 5), (\\"GetMax\\",), (\\"Delete\\", 10), (\\"GetMax\\",)]) [10, 5] >>> process_queries([(\\"Insert\\", -1), (\\"Insert\\", -2), (\\"Insert\\", -3), (\\"GetMax\\",), (\\"Delete\\", -1), (\\"GetMax\\",)]) [-1, -2] >>> process_queries([(\\"GetMax\\",)]) [None]","solution":"def process_queries(queries): from collections import deque dynamic_array = deque() results = [] for query in queries: if query[0] == \\"Insert\\": dynamic_array.append(query[1]) elif query[0] == \\"Delete\\": try: dynamic_array.remove(query[1]) except ValueError: pass elif query[0] == \\"GetMax\\": if dynamic_array: results.append(max(dynamic_array)) else: results.append(None) return results"},{"question":"def compress_and_decompress_fibonacci(start1: int, start2: int, length: int) -> list[int]: Generates a Fibonacci sequence of the specified length starting with start1 and start2. Parameters: - start1: The first number of the Fibonacci sequence. - start2: The second number of the Fibonacci sequence. - length: The number of terms to generate in the sequence. Returns: - A list of integers representing the regenerated Fibonacci sequence of the specified length. >>> compress_and_decompress_fibonacci(3, 5, 6) [3, 5, 8, 13, 21, 34] >>> compress_and_decompress_fibonacci(0, 1, 5) [0, 1, 1, 2, 3] >>> compress_and_decompress_fibonacci(2, 3, 2) [2, 3] >>> compress_and_decompress_fibonacci(8, 13, 7) [8, 13, 21, 34, 55, 89, 144] >>> compress_and_decompress_fibonacci(4, 6, 5) [4, 6, 10, 16, 26] >>> compress_and_decompress_fibonacci(1, 1, 1) Traceback (most recent call last): ... ValueError: Length should be at least 2.","solution":"def compress_and_decompress_fibonacci(start1: int, start2: int, length: int) -> list[int]: Generates a Fibonacci sequence of the specified length starting with start1 and start2. Parameters: - start1: The first number of the Fibonacci sequence. - start2: The second number of the Fibonacci sequence. - length: The number of terms to generate in the sequence. Returns: - A list of integers representing the regenerated Fibonacci sequence of the specified length. if length < 2: raise ValueError(\\"Length should be at least 2.\\") # Initialize the sequence with the first two numbers fibonacci_sequence = [start1, start2] # Generate the rest of the sequence for _ in range(2, length): next_term = fibonacci_sequence[-1] + fibonacci_sequence[-2] fibonacci_sequence.append(next_term) return fibonacci_sequence"},{"question":"import math def sum_of_factorial_digits(n: int) -> int: Finds the sum of all digits in the factorial of a given number. :param n: The number whose factorial's digit sum is to be computed. :return: The sum of all digits in n! Example: >>> sum_of_factorial_digits(5) 3 >>> sum_of_factorial_digits(10) 27 >>> sum_of_factorial_digits(0) 1 # Implementation here def test_sum_of_factorial_digits_zero(): assert sum_of_factorial_digits(0) == 1 # Since 0! = 1 def test_sum_of_factorial_digits_one(): assert sum_of_factorial_digits(1) == 1 # Since 1! = 1 def test_sum_of_factorial_digits_small(): assert sum_of_factorial_digits(5) == 3 # Since 5! = 120, and 1 + 2 + 0 = 3 def test_sum_of_factorial_digits_medium(): assert sum_of_factorial_digits(10) == 27 # Since 10! = 3628800, and 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27 def test_sum_of_factorial_digits_large(): # Check the sum of digits for the factorial of a larger number # Test example: 20! = 2432902008176640000, sum of digits = 54 assert sum_of_factorial_digits(20) == 54 def test_sum_of_factorial_digits_very_large(): # Check the sum of digits for the factorial of a very large number # Test example: 50! expected_sum = sum(int(digit) for digit in str(math.factorial(50))) assert sum_of_factorial_digits(50) == expected_sum def test_sum_of_factorial_digits_boundary(): # Check the sum of digits for the factorial of the upper boundary number 100 expected_sum = sum(int(digit) for digit in str(math.factorial(100))) assert sum_of_factorial_digits(100) == expected_sum","solution":"import math def sum_of_factorial_digits(n: int) -> int: Computes the sum of all digits in the factorial of n. :param n: The number whose factorial's digit sum is to be computed. :return: The sum of all digits in n! factorial_result = math.factorial(n) return sum(int(digit) for digit in str(factorial_result))"},{"question":"from typing import List, Tuple def permute_recursive(s: str) -> Tuple[List[str], int]: Generate all unique permutations of the input string using a recursive method. Args: s (str): Input string. Returns: (List[str], int): A tuple with a list of unique permutations and the count of unique permutations. >>> permute_recursive(\\"abc\\") (['abc', 'acb', 'bac', 'bca', 'cab', 'cba'], 6) >>> permute_recursive(\\"aab\\") (['aab', 'aba', 'baa'], 3) # Your code here def permute_iterative(s: str) -> Tuple[List[str], int]: Generate all unique permutations of the input string using an iterative method. Args: s (str): Input string. Returns: (List[str], int): A tuple with a list of unique permutations and the count of unique permutations. >>> permute_iterative(\\"abc\\") (['abc', 'acb', 'bac', 'bca', 'cab', 'cba'], 6) >>> permute_iterative(\\"aab\\") (['aab', 'aba', 'baa'], 3) # Your code here","solution":"from typing import List, Tuple from itertools import permutations def permute_recursive(s: str) -> Tuple[List[str], int]: Generate all unique permutations of the input string using a recursive method. Args: s (str): Input string. Returns: (List[str], int): A tuple with a list of unique permutations and the count of unique permutations. def permute_helper(remaining: str, path: str, result: set): if not remaining: result.add(path) return for i in range(len(remaining)): permute_helper(remaining[:i] + remaining[i+1:], path + remaining[i], result) result_set = set() permute_helper(s, \\"\\", result_set) result_list = sorted(list(result_set)) return (result_list, len(result_list)) def permute_iterative(s: str) -> Tuple[List[str], int]: Generate all unique permutations of the input string using an iterative method. Args: s (str): Input string. Returns: (List[str], int): A tuple with a list of unique permutations and the count of unique permutations. perm_set = set(permutations(s)) result_list = sorted([\\"\\".join(p) for p in perm_set]) return (result_list, len(result_list))"},{"question":"from typing import List def primary_diagonal_sum(matrix: List[List[int]]) -> int: Returns the sum of the primary diagonal elements of the matrix. >>> primary_diagonal_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 15 >>> primary_diagonal_sum([[4]]) == 4 >>> primary_diagonal_sum([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) == 34 >>> primary_diagonal_sum([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) == -15 pass def secondary_diagonal_sum(matrix: List[List[int]]) -> int: Returns the sum of the secondary diagonal elements of the matrix. >>> secondary_diagonal_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 15 >>> secondary_diagonal_sum([[4]]) == 4 >>> secondary_diagonal_sum([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) == 34 >>> secondary_diagonal_sum([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) == -15 pass","solution":"def primary_diagonal_sum(matrix): Returns the sum of the primary diagonal elements of the matrix. return sum(matrix[i][i] for i in range(len(matrix))) def secondary_diagonal_sum(matrix): Returns the sum of the secondary diagonal elements of the matrix. n = len(matrix) return sum(matrix[i][n - 1 - i] for i in range(n))"},{"question":"def process_tickets(tickets): Processes event tickets based on their arrival times. Parameters: tickets (list of tuples): List of tuples where each tuple contains a ticket_id and an arrival_time. Returns: list of int: List of ticket IDs in the order they are processed. Examples: >>> process_tickets([(1, 3), (2, 1), (3, 2)]) [2, 3, 1] >>> process_tickets([(10, 0), (2, 4), (3, 0), (5, 2)]) [10, 3, 5, 2] # Your implementation here pass","solution":"def process_tickets(tickets): Processes event tickets based on their arrival times. Parameters: tickets (list of tuples): List of tuples where each tuple contains ticket_id and arrival_time. Returns: list of int: List of ticket IDs in the order they are processed. # Sort the tickets based on their arrival_time sorted_tickets = sorted(tickets, key=lambda x: x[1]) # Extract the ticket IDs in the order they are processed processed_order = [ticket_id for ticket_id, arrival_time in sorted_tickets] return processed_order"},{"question":"def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: Given a 2-dimensional list (matrix), return its transpose. >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[]]) [[]] >>> transpose_matrix([]) [] from solution import transpose_matrix def test_square_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] transposed = [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] assert transpose_matrix(matrix) == transposed def test_rectangular_matrix(): matrix = [ [1, 2, 3], [4, 5, 6] ] transposed = [ [1, 4], [2, 5], [3, 6] ] assert transpose_matrix(matrix) == transposed def test_empty_matrix(): assert transpose_matrix([]) == [] def test_single_element_matrix(): matrix = [[1]] transposed = [[1]] assert transpose_matrix(matrix) == transposed def test_single_row_matrix(): matrix = [[1, 2, 3, 4]] transposed = [[1], [2], [3], [4]] assert transpose_matrix(matrix) == transposed def test_single_column_matrix(): matrix = [[1], [2], [3], [4]] transposed = [[1, 2, 3, 4]] assert transpose_matrix(matrix) == transposed def test_irregular_matrix(): matrix = [ [1, 2], [3, 4], [5, 6], [7, 8] ] transposed = [ [1, 3, 5, 7], [2, 4, 6, 8] ] assert transpose_matrix(matrix) == transposed","solution":"def transpose_matrix(matrix): Given a 2-dimensional list (matrix), return its transpose. if not matrix: return [] m, n = len(matrix), len(matrix[0]) transpose = [[None]*m for _ in range(n)] for i in range(m): for j in range(n): transpose[j][i] = matrix[i][j] return transpose"},{"question":"def contains_special_letters(text: str) -> bool: Checks if the input text contains any special letters (i.e., uppercase vowels A, E, I, O, U). :param text: A string of characters. :return: Boolean value indicating the presence of at least one special letter. >>> contains_special_letters(\\"AmazIngAdventUre\\") True >>> contains_special_letters(\\"HelloWorld\\") False >>> contains_special_letters(\\"1234!@#\\") False >>> contains_special_letters(\\"U\\") True >>> contains_special_letters(\\"\\") False >>> contains_special_letters(\\"AEIOU\\") True >>> contains_special_letters(\\"A2E!3IOUo@\\") True","solution":"def contains_special_letters(text: str) -> bool: Checks if the input text contains any special letters (i.e., uppercase vowels A, E, I, O, U). :param text: A string of characters. :return: Boolean value indicating the presence of at least one special letter. special_letters = {'A', 'E', 'I', 'O', 'U'} return any(char in special_letters for char in text)"},{"question":"def can_partition_into_palindromes(s: str, k: int) -> bool: Determine if the string can be partitioned into at most k palindromic substrings. Parameters: - s (str): The input string. Must contain only lowercase English letters. - k (int): The maximum number of palindromic partitions. Must be a positive integer. Returns: - bool: True if the string can be partitioned into at most k palindromic substrings, False otherwise. Raises: - ValueError: If the input string contains non-lowercase English letters or if k is not a positive integer. Examples: >>> can_partition_into_palindromes(\\"aab\\", 2) True >>> can_partition_into_palindromes(\\"aab\\", 1) False >>> can_partition_into_palindromes(\\"racecar\\", 1) True >>> can_partition_into_palindromes(\\"racecar\\", 3) True >>> can_partition_into_palindromes(\\"noon\\", 2) True >>> can_partition_into_palindromes(\\"cat\\", 2) False >>> can_partition_into_palindromes(\\"aab\\", 0) Traceback (most recent call last): ... ValueError: k must be a positive integer. >>> can_partition_into_palindromes(\\"AaB\\", 2) Traceback (most recent call last): ... ValueError: Input string must contain only lowercase English letters.","solution":"def can_partition_into_palindromes(s: str, k: int) -> bool: Determine if the string can be partitioned into at most k palindromic substrings. Parameters: - s (str): The input string. Must contain only lowercase English letters. - k (int): The maximum number of palindromic partitions. Must be a positive integer. Returns: - bool: True if the string can be partitioned into at most k palindromic substrings, False otherwise. Raises: - ValueError: If the input string contains non-lowercase English letters or if k is not a positive integer. # Check for invalid input cases if not isinstance(k, int) or k <= 0: raise ValueError(\\"k must be a positive integer.\\") if not s.islower() or not s.isalpha(): raise ValueError(\\"Input string must contain only lowercase English letters.\\") # Helper function to check if a string is a palindrome def is_palindrome(sub): return sub == sub[::-1] # Edge cases if k >= len(s): # Maximum k can be the length of the string return True if k == 1: return is_palindrome(s) # Dynamic programming approach n = len(s) dp = [[False] * n for _ in range(n)] # Initialize single letter palindromes for i in range(n): dp[i][i] = True # Initialize two letter palindromes for i in range(n - 1): dp[i][i + 1] = s[i] == s[i + 1] # Fill dp array for substrings longer than two letters for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 dp[i][j] = dp[i + 1][j - 1] and s[i] == s[j] # Min cuts needed for palindrome partitioning cuts = [0] * n for i in range(n): min_cut = i # Maximum cuts needed for j in range(i + 1): if dp[j][i]: min_cut = 0 if j == 0 else min(min_cut, cuts[j - 1] + 1) cuts[i] = min_cut return cuts[-1] + 1 <= k"},{"question":"class ConsistentHashing: def __init__(self, virtual_nodes=100) -> None: Initializes the consistent hashing with an empty hash ring. Parameters: virtual_nodes (int): Number of virtual nodes per server. pass def add_server(self, server: str) -> None: Adds a new server to the hash ring with virtual nodes. Parameters: server (str): The identifier of the server to be added. >>> ch = ConsistentHashing(virtual_nodes=10) >>> ch.add_server(\\"server1\\") >>> \\"server1\\" in ch.servers True >>> len(ch.ring) == 10 True pass def remove_server(self, server: str) -> None: Removes a server from the hash ring. Parameters: server (str): The identifier of the server to be removed. >>> ch = ConsistentHashing(virtual_nodes=10) >>> ch.add_server(\\"server1\\") >>> ch.remove_server(\\"server1\\") >>> \\"server1\\" not in ch.servers True >>> len(ch.ring) == 0 True pass def get_server(self, key: str) -> str: Finds the server responsible for the given key. Parameters: key (str): The key to be looked up. Returns: str: The server responsible for the key. >>> ch = ConsistentHashing(virtual_nodes=10) >>> ch.add_server(\\"server1\\") >>> ch.get_server(\\"my_key1\\") 'server1' pass","solution":"class ConsistentHashing: def __init__(self, virtual_nodes=100) -> None: Initializes the consistent hashing with an empty hash ring. Parameters: virtual_nodes (int): Number of virtual nodes per server. self.ring = {} self.servers = {} self.virtual_nodes = virtual_nodes def add_server(self, server: str) -> None: Adds a new server to the hash ring with virtual nodes. Parameters: server (str): The identifier of the server to be added. for i in range(self.virtual_nodes): virtual_node_key = f'{server}-{i}' virtual_node_hash = hash(virtual_node_key) self.ring[virtual_node_hash] = server self.servers[server] = self.virtual_nodes self._sort_ring() def remove_server(self, server: str) -> None: Removes a server from the hash ring. Parameters: server (str): The identifier of the server to be removed. if server in self.servers: for i in range(self.servers[server]): virtual_node_key = f'{server}-{i}' virtual_node_hash = hash(virtual_node_key) if virtual_node_hash in self.ring: del self.ring[virtual_node_hash] del self.servers[server] self._sort_ring() def get_server(self, key: str) -> str: Finds the server responsible for the given key. Parameters: key (str): The key to be looked up. Returns: str: The server responsible for the key. key_hash = hash(key) for node_hash in self.ring: if key_hash <= node_hash: return self.ring[node_hash] return self.ring[sorted(self.ring.keys())[0]] # Wrap-around case def _sort_ring(self): Sorts the hash ring keys for consistent traversal. self.ring = dict(sorted(self.ring.items()))"},{"question":"def integer_sqrt(n: int) -> int: Calculate the integer square root of a given non-negative integer. Returns the largest integer whose square is less than or equal to \`n\`. Args: n (int): A non-negative integer (0 <= n <= 10^18) Returns: int: The integer square root of \`n\` Examples: >>> integer_sqrt(16) 4 >>> integer_sqrt(15) 3 >>> integer_sqrt(1000000000000000000) 1000000000","solution":"def integer_sqrt(n: int) -> int: if n < 2: return n left, right = 1, n while left <= right: mid = (left + right) // 2 if mid * mid == n: return mid elif mid * mid < n: left = mid + 1 else: right = mid - 1 return right"},{"question":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False def build_trie(words: list[str]) -> TrieNode: Build a Trie from a given list of words. Arguments: words -- a list of strings representing the words. Returns: The root TrieNode of the constructed Trie. pass def autocomplete(prefix: str, root: TrieNode) -> list[str]: Return all the words in the Trie that start with a given prefix. Arguments: prefix -- a string representing the prefix to search for. root -- the root TrieNode of the Trie. Returns: A list of strings that are the words in the Trie starting with the given prefix. pass def search_helper(node: TrieNode, prefix: str, result: list[str]) -> None: Helper function to perform DFS for finding words with a given prefix. Arguments: node -- the current TrieNode. prefix -- the current prefix string. result -- a list containing the words found. pass","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False def build_trie(words): root = TrieNode() for word in words: current = root for letter in word: if letter not in current.children: current.children[letter] = TrieNode() current = current.children[letter] current.is_end_of_word = True return root def autocomplete(prefix, root): current = root for letter in prefix: if letter not in current.children: return [] current = current.children[letter] result = [] search_helper(current, prefix, result) return result def search_helper(node, prefix, result): if node.is_end_of_word: result.append(prefix) for letter, next_node in node.children.items(): search_helper(next_node, prefix + letter, result)"},{"question":"from typing import List def longest_consecutive(nums: List[int]) -> int: Returns the length of the longest consecutive sequence of integers in the list nums. >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive([1, 2, 0, 1]) 3 >>> longest_consecutive([7, 8, 9, 4, 5, 6]) 6 >>> longest_consecutive([]) 0","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive sequence of integers in the list nums. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: # Check if it is the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transposes the given N x M matrix. if not matrix or not matrix[0]: return [] rows = len(matrix) cols = len(matrix[0]) # Initialize the transposed matrix with dimensions MxN transposed_matrix = [[0 for _ in range(rows)] for _ in range(cols)] for i in range(rows): for j in range(cols): transposed_matrix[j][i] = matrix[i][j] return transposed_matrix","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transposes the given N x M matrix. if not matrix or not matrix[0]: return [] rows = len(matrix) cols = len(matrix[0]) # Initialize the transposed matrix with dimensions MxN transposed_matrix = [[0 for _ in range(rows)] for _ in range(cols)] for i in range(rows): for j in range(cols): transposed_matrix[j][i] = matrix[i][j] return transposed_matrix"},{"question":"def sum_of_digits(number: int) -> int: Returns the sum of the digits of a given positive integer. :param number: A positive integer whose digits' sum needs to be calculated. :return: An integer representing the sum of the digits. :raises ValueError: If the input number is not a positive integer. >>> sum_of_digits(12345) 15 >>> sum_of_digits(9876) 30 >>> sum_of_digits(1) 1","solution":"def sum_of_digits(number: int) -> int: Returns the sum of the digits of a given positive integer. :param number: A positive integer whose digits' sum needs to be calculated. :return: An integer representing the sum of the digits. :raises ValueError: If the input number is not a positive integer. if number <= 0: raise ValueError(\\"Input must be a positive integer\\") sum_digits = 0 while number: sum_digits += number % 10 number //= 10 return sum_digits"},{"question":"import os from typing import Dict, Any def generate_filesystem_report(root_dir: str) -> Dict[str, Any]: Given a root directory, generate a summary report of its contents. Parameters: root_dir (str): The root directory to start the exploration. Returns: Dict[str, Any]: A dictionary containing the counts of each file type and the total number of directories. >>> input_dir = \\"/path/to/test_directory\\" >>> expected_output = { >>> \\"txt\\": 10, >>> \\"jpg\\": 5, >>> \\"pdf\\": 3, >>> \\"directories\\": 4 >>> } >>> generate_filesystem_report(input_dir) == expected_output import os import shutil import tempfile from typing import Dict, Any def setup_test_directory_structure(base_dir): os.makedirs(os.path.join(base_dir, \\"dir1\\")) os.makedirs(os.path.join(base_dir, \\"dir2\\")) os.makedirs(os.path.join(base_dir, \\"dir2\\", \\"subdir1\\")) with open(os.path.join(base_dir, \\"file1.txt\\"), \\"w\\") as f: f.write(\\"sample text file 1\\") with open(os.path.join(base_dir, \\"file2.txt\\"), \\"w\\") as f: f.write(\\"sample text file 2\\") with open(os.path.join(base_dir, \\"file3.jpg\\"), \\"w\\") as f: f.write(\\"sample jpg file\\") with open(os.path.join(base_dir, \\"dir1\\", \\"file4.pdf\\"), \\"w\\") as f: f.write(\\"sample pdf file\\") with open(os.path.join(base_dir, \\"dir2\\", \\"subdir1\\", \\"file5.doc\\"), \\"w\\") as f: f.write(\\"sample doc file\\") with open(os.path.join(base_dir, \\"dir2\\", \\"subdir1\\", \\"file6\\"), \\"w\\") as f: f.write(\\"sample file with no extension\\") def test_generate_filesystem_report(): temp_dir = tempfile.mkdtemp() try: setup_test_directory_structure(temp_dir) expected_output = { \\"txt\\": 2, \\"jpg\\": 1, \\"pdf\\": 1, \\"doc\\": 1, \\"no_extension\\": 1, \\"directories\\": 3, } result = generate_filesystem_report(temp_dir) assert result == expected_output finally: shutil.rmtree(temp_dir) def test_generate_filesystem_report_empty_directory(): temp_dir = tempfile.mkdtemp() try: expected_output = { \\"directories\\": 0 } result = generate_filesystem_report(temp_dir) assert result == expected_output finally: shutil.rmtree(temp_dir) def test_generate_filesystem_report_no_files(): temp_dir = tempfile.mkdtemp() try: os.makedirs(os.path.join(temp_dir, \\"dir1\\")) os.makedirs(os.path.join(temp_dir, \\"dir2\\")) expected_output = { \\"directories\\": 2 } result = generate_filesystem_report(temp_dir) assert result == expected_output finally: shutil.rmtree(temp_dir) def test_generate_filesystem_report_with_only_files(): temp_dir = tempfile.mkdtemp() try: with open(os.path.join(temp_dir, \\"file1.txt\\"), \\"w\\") as f: f.write(\\"sample text file 1\\") with open(os.path.join(temp_dir, \\"file2.jpg\\"), \\"w\\") as f: f.write(\\"sample jpg file\\") expected_output = { \\"txt\\": 1, \\"jpg\\": 1, \\"directories\\": 0 } result = generate_filesystem_report(temp_dir) assert result == expected_output finally: shutil.rmtree(temp_dir) def test_generate_filesystem_report_invalid_directory(): try: generate_filesystem_report(\\"/invalid/directory/path\\") except FileNotFoundError as e: assert str(e).startswith(\\"[Errno 2] No such file or directory\\")","solution":"import os from collections import defaultdict from typing import Dict, Any def generate_filesystem_report(root_dir: str) -> Dict[str, Any]: Given a root directory, generate a summary report of its contents. Parameters: root_dir (str): The root directory to start the exploration. Returns: Dict[str, Any]: A dictionary containing the counts of each file type and the total number of directories. report = defaultdict(int) for root, dirs, files in os.walk(root_dir): report[\\"directories\\"] += len(dirs) for file in files: file_extension = os.path.splitext(file)[1][1:] # get file extension without the dot if file_extension: report[file_extension] += 1 else: report[\\"no_extension\\"] += 1 return dict(report)"},{"question":"from typing import List, Tuple class BookStore: A class to manage the inventory of books in an online bookstore. >>> initial_books = [(\\"Pride and Prejudice\\", \\"Jane Austen\\", 10), ... (\\"1984\\", \\"George Orwell\\", 5), ... (\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 8)] >>> bookstore = BookStore(initial_books) >>> bookstore.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 3) >>> bookstore.sell_book(\\"1984\\", 2) True >>> bookstore.sell_book(\\"1984\\", 4) False >>> bookstore.books_by_author(\\"George Orwell\\") ['1984'] >>> bookstore.books_by_author(\\"F. Scott Fitzgerald\\") ['The Great Gatsby'] >>> bookstore.total_inventory() 26 def __init__(self, books: List[Tuple[str, str, int]]): pass def add_book(self, title: str, author: str, copies: int): pass def sell_book(self, title: str, copies: int) -> bool: pass def books_by_author(self, author: str) -> List[str]: pass def total_inventory(self) -> int: pass # Unit Tests import pytest def test_initial_inventory(): initial_books = [ (\\"Pride and Prejudice\\", \\"Jane Austen\\", 10), (\\"1984\\", \\"George Orwell\\", 5), (\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 8) ] bookstore = BookStore(initial_books) assert bookstore.total_inventory() == 23 def test_add_book(): initial_books = [(\\"1984\\", \\"George Orwell\\", 5)] bookstore = BookStore(initial_books) bookstore.add_book(\\"1984\\", \\"George Orwell\\", 5) bookstore.add_book(\\"Brave New World\\", \\"Aldous Huxley\\", 3) assert bookstore.total_inventory() == 13 def test_sell_book(): initial_books = [(\\"1984\\", \\"George Orwell\\", 5)] bookstore = BookStore(initial_books) assert bookstore.sell_book(\\"1984\\", 2) == True assert bookstore.total_inventory() == 3 assert bookstore.sell_book(\\"1984\\", 4) == False def test_books_by_author(): initial_books = [ (\\"1984\\", \\"George Orwell\\", 5), (\\"Animal Farm\\", \\"George Orwell\\", 8) ] bookstore = BookStore(initial_books) assert set(bookstore.books_by_author(\\"George Orwell\\")) == {\\"1984\\", \\"Animal Farm\\"} def test_total_inventory(): initial_books = [ (\\"Pride and Prejudice\\", \\"Jane Austen\\", 10), (\\"1984\\", \\"George Orwell\\", 5), (\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 8) ] bookstore = BookStore(initial_books) assert bookstore.total_inventory() == 23","solution":"from typing import List, Tuple, Dict class BookStore: def __init__(self, books: List[Tuple[str, str, int]]): self.inventory = {} # Store books by title self.authors = {} # Store authors and their books for title, author, copies in books: self.add_book(title, author, copies) def add_book(self, title: str, author: str, copies: int): if title in self.inventory: self.inventory[title][1] += copies else: self.inventory[title] = [author, copies] if author in self.authors: self.authors[author].append(title) else: self.authors[author] = [title] def sell_book(self, title: str, copies: int) -> bool: if title in self.inventory and self.inventory[title][1] >= copies: self.inventory[title][1] -= copies return True return False def books_by_author(self, author: str) -> List[str]: return self.authors.get(author, []) def total_inventory(self) -> int: return sum(copies for _, copies in self.inventory.values())"},{"question":"import math def find_missing_side(side1: float, side2: float, hypotenuse: bool) -> float: Compute the missing side of a right triangle using the Pythagorean theorem. Args: side1 (float): One of the sides of the triangle. side2 (float): Another side of the triangle. hypotenuse (bool): Whether the missing side is the hypotenuse or not. Returns: float: The length of the missing side. Raises: ValueError: If any of the side lengths are non-positive. Examples: >>> find_missing_side(3, 4, True) 5.0 >>> find_missing_side(6, 8, True) 10.0 >>> find_missing_side(5, 12, True) 13.0 >>> find_missing_side(13, 5, False) 12.0 >>> find_missing_side(-3, 4, True) ValueError(\\"All side lengths must be positive\\") >>> find_missing_side(5, 0, True) ValueError(\\"All side lengths must be positive\\")","solution":"import math def find_missing_side(side1: float, side2: float, hypotenuse: bool) -> float: if side1 <= 0 or side2 <= 0: raise ValueError(\\"All side lengths must be positive\\") if hypotenuse: return math.sqrt(side1**2 + side2**2) else: # side1 and side2 should form right-angle sides, hence # one should be larger (the hypotenuse) and one smaller return math.sqrt(abs(side1**2 - side2**2))"},{"question":"def hamming_distance(x: int, y: int) -> int: Calculates the Hamming distance between two non-negative integers. :param x: First non-negative integer :param y: Second non-negative integer :return: The Hamming distance between x and y >>> hamming_distance(1, 4) 2 >>> hamming_distance(3, 1) 1 >>> hamming_distance(0, 0) 0 >>> hamming_distance(7, 10) 3","solution":"def hamming_distance(x: int, y: int) -> int: Calculates the Hamming distance between two non-negative integers. :param x: First non-negative integer :param y: Second non-negative integer :return: The Hamming distance between x and y xor = x ^ y distance = 0 while xor: distance += xor & 1 xor >>= 1 return distance"},{"question":"class BookNotFoundError(Exception): pass class Bookstore: A simple inventory management system for a bookstore. Methods: def add_book(title: str, author: str, quantity: int) -> None: Adds a new book with the given title, author, and initial stock quantity to the inventory. def update_stock(title: str, author: str, quantity: int) -> None: Updates the stock quantity for a book with the given title and author. Raises an error if the book does not exist. def check_stock(title: str, author: str) -> int: Returns the current stock quantity for the book with the given title and author. Returns 0 if the book does not exist. def __init__(self): pass def add_book(self, title: str, author: str, quantity: int) -> None: pass def update_stock(self, title: str, author: str, quantity: int) -> None: pass def check_stock(self, title: str, author: str) -> int: pass import pytest def test_add_new_book(): store = Bookstore() store.add_book(\\"Book A\\", \\"Author A\\", 10) assert store.check_stock(\\"Book A\\", \\"Author A\\") == 10 def test_add_existing_book(): store = Bookstore() store.add_book(\\"Book A\\", \\"Author A\\", 10) store.add_book(\\"Book A\\", \\"Author A\\", 5) assert store.check_stock(\\"Book A\\", \\"Author A\\") == 15 def test_update_stock_existing_book(): store = Bookstore() store.add_book(\\"Book B\\", \\"Author B\\", 5) store.update_stock(\\"Book B\\", \\"Author B\\", 3) assert store.check_stock(\\"Book B\\", \\"Author B\\") == 8 def test_update_stock_non_existing_book(): store = Bookstore() with pytest.raises(BookNotFoundError): store.update_stock(\\"Non-existing Book\\", \\"Unknown Author\\", 1) def test_check_stock_non_existing_book(): store = Bookstore() assert store.check_stock(\\"Non-existing Book\\", \\"Unknown Author\\") == 0 def test_case_sensitivity(): store = Bookstore() store.add_book(\\"Book A\\", \\"Author A\\", 10) store.add_book(\\"book A\\", \\"author A\\", 5) assert store.check_stock(\\"Book A\\", \\"Author A\\") == 10 assert store.check_stock(\\"book A\\", \\"author A\\") == 5","solution":"class BookNotFoundError(Exception): pass class Bookstore: def __init__(self): self.inventory = {} def add_book(self, title: str, author: str, quantity: int) -> None: key = (title, author) if key in self.inventory: self.inventory[key] += quantity else: self.inventory[key] = quantity def update_stock(self, title: str, author: str, quantity: int) -> None: key = (title, author) if key in self.inventory: self.inventory[key] += quantity else: raise BookNotFoundError(f\\"Book '{title}' by '{author}' not found.\\") def check_stock(self, title: str, author: str) -> int: key = (title, author) return self.inventory.get(key, 0)"},{"question":"def find_word_indices(text: str, target_word: str) -> list[int]: Returns a list of starting indices where the target_word is found in the text. :param text: str: The text in which to search for the target word. :param target_word: str: The word to search for in the text. :return: list[int]: List of starting indices where the target_word is found. >>> find_word_indices(\\"hello world, hello universe\\", \\"hello\\") [0, 13] >>> find_word_indices(\\"abracadabra\\", \\"abra\\") [0, 7] >>> find_word_indices(\\"abracadabra\\", \\"cad\\") [4] >>> find_word_indices(\\"aaaaa\\", \\"aa\\") [0, 1, 2, 3] def test_find_word_indices(): assert find_word_indices(\\"hello world, hello universe\\", \\"hello\\") == [0, 13] assert find_word_indices(\\"abracadabra\\", \\"abra\\") == [0, 7] assert find_word_indices(\\"abracadabra\\", \\"cad\\") == [4] assert find_word_indices(\\"aaaaa\\", \\"aa\\") == [0, 1, 2, 3] assert find_word_indices(\\"\\", \\"a\\") == [] assert find_word_indices(\\"short\\", \\"longerword\\") == [] assert find_word_indices(\\"abababababa\\", \\"aba\\") == [0, 2, 4, 6, 8] assert find_word_indices(\\"aaaaa\\", \\"aaaaa\\") == [0] assert find_word_indices(\\"aaaaa\\", \\"ab\\") == [] # Running tests test_find_word_indices()","solution":"def find_word_indices(text: str, target_word: str) -> list[int]: Returns a list of starting indices where the target_word is found in the text. :param text: str: The text in which to search for the target word. :param target_word: str: The word to search for in the text. :return: list[int]: List of starting indices where the target_word is found. indices = [] target_len = len(target_word) text_len = len(text) # Iterate through the text while checking for match with target_word for i in range(text_len - target_len + 1): if text[i:i + target_len] == target_word: indices.append(i) return indices"},{"question":"from typing import List, Dict, Tuple def longest_increasing_subsequence(arr: List[int]) -> int: Compute the length of the longest increasing subsequence in a given list of integers using memoization for optimization. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) == 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) == 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5, 6, 7, 8]) == 8 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) == 1","solution":"from typing import List, Dict, Tuple def longest_increasing_subsequence(arr: List[int]) -> int: def lis_ending_at(index: int, prev_index: int, memo: Dict[Tuple[int, int], int]) -> int: if index == len(arr): return 0 if (index, prev_index) in memo: return memo[(index, prev_index)] take = 0 if prev_index == -1 or arr[index] > arr[prev_index]: take = 1 + lis_ending_at(index + 1, index, memo) not_take = lis_ending_at(index + 1, prev_index, memo) memo[(index, prev_index)] = max(take, not_take) return memo[(index, prev_index)] return lis_ending_at(0, -1, {})"},{"question":"def monthly_summary(transactions: list) -> dict: Calculate the total income, total expenses, and the net balance from a list of transactions. Args: transactions (list): A list of tuples, where each tuple contains a float (transaction amount) and a string (description). Returns: dict: A dictionary with keys 'total_income', 'total_expenses', and 'net_balance' containing the respective calculated values. Example: >>> transactions = [ ... (1500.00, \\"Salary\\"), ... (-50.75, \\"Groceries\\"), ... (-100.00, \\"Internet Bill\\"), ... (200.00, \\"Freelance Work\\"), ... (-20.00, \\"Lunch\\"), ... ] >>> monthly_summary(transactions) {'total_income': 1700.00, 'total_expenses': -170.75, 'net_balance': 1529.25} from solution import monthly_summary def test_monthly_summary_example(): transactions = [ (1500.00, \\"Salary\\"), (-50.75, \\"Groceries\\"), (-100.00, \\"Internet Bill\\"), (200.00, \\"Freelance Work\\"), (-20.00, \\"Lunch\\"), ] expected_output = { \\"total_income\\": 1700.00, \\"total_expenses\\": -170.75, \\"net_balance\\": 1529.25 } assert monthly_summary(transactions) == expected_output def test_monthly_summary_all_positive(): transactions = [ (1000.00, \\"Salary\\"), (500.00, \\"Freelance Work\\"), ] expected_output = { \\"total_income\\": 1500.00, \\"total_expenses\\": 0.00, \\"net_balance\\": 1500.00 } assert monthly_summary(transactions) == expected_output def test_monthly_summary_all_negative(): transactions = [ (-200.00, \\"Rent\\"), (-100.00, \\"Utilities\\"), ] expected_output = { \\"total_income\\": 0.00, \\"total_expenses\\": -300.00, \\"net_balance\\": -300.00 } assert monthly_summary(transactions) == expected_output def test_monthly_summary_mixed_transactions(): transactions = [ (500.00, \\"Freelance Work\\"), (-50.00, \\"Groceries\\"), (1000.00, \\"Salary\\"), (-200.00, \\"Rent\\") ] expected_output = { \\"total_income\\": 1500.00, \\"total_expenses\\": -250.00, \\"net_balance\\": 1250.00, } assert monthly_summary(transactions) == expected_output def test_monthly_summary_with_zeros(): transactions = [ (0.00, \\"Nothing\\"), (-0.00, \\"Nothing\\"), (100.00, \\"Gift\\"), (-50.00, \\"Food\\") ] expected_output = { \\"total_income\\": 100.00, \\"total_expenses\\": -50.00, \\"net_balance\\": 50.00 } assert monthly_summary(transactions) == expected_output","solution":"def monthly_summary(transactions): Calculate the total income, total expenses, and the net balance from a list of transactions. Args: transactions (list): A list of tuples, where each tuple contains a float (amount) and a string (description). Returns: dict: A dictionary with keys 'total_income', 'total_expenses', and 'net_balance' containing the respective calculated values. total_income = sum(amount for amount, desc in transactions if amount > 0) total_expenses = sum(amount for amount, desc in transactions if amount < 0) net_balance = total_income + total_expenses return { \\"total_income\\": total_income, \\"total_expenses\\": total_expenses, \\"net_balance\\": net_balance }"},{"question":"from collections import namedtuple import math Point2D = namedtuple(\\"Point2D\\", \\"x y\\") PolarCoord = namedtuple(\\"PolarCoord\\", \\"r theta\\") def cartesian_to_polar(points: list[Point2D]) -> list[PolarCoord]: Convert a list of Cartesian coordinates to polar coordinates. Args: points (list[Point2D]): A list of points in Cartesian coordinates. Returns: list[PolarCoord]: A list of points in polar coordinates. Raises: ValueError: If the list of points is empty. Example: >>> cartesian_to_polar([Point2D(x=3, y=4), Point2D(x=1, y=1), Point2D(x=0, y=0)]) [PolarCoord(r=5.0, theta=0.93), PolarCoord(r=1.41, theta=0.79), PolarCoord(r=0.0, theta=0.0)] >>> cartesian_to_polar([]) # Should raise a ValueError","solution":"from collections import namedtuple import math Point2D = namedtuple(\\"Point2D\\", \\"x y\\") PolarCoord = namedtuple(\\"PolarCoord\\", \\"r theta\\") def cartesian_to_polar(points): if not points: raise ValueError(\\"No points provided\\") polar_coords = [] for point in points: r = math.sqrt(point.x ** 2 + point.y ** 2) theta = math.atan2(point.y, point.x) polar_coords.append(PolarCoord(r, theta)) return polar_coords"},{"question":"from typing import List def max_stock_price_increase(prices: List[float]) -> float: Determines the maximum percentage increase between any two consecutive days in the list of stock prices. >>> max_stock_price_increase([5.0, 10.0, 5.5, 11.0]) 100.0 >>> max_stock_price_increase([8.0, 8.1, 8.3, 8.7, 9.0]) 4.82","solution":"from typing import List def max_stock_price_increase(prices: List[float]) -> float: Determines the maximum percentage increase between any two consecutive days in the list of stock prices. max_increase = 0.0 for i in range(1, len(prices)): increase = (prices[i] - prices[i-1]) / prices[i-1] * 100 if increase > max_increase: max_increase = increase return round(max_increase, 2)"},{"question":"from collections import deque def shortest_path(graph: dict, start: int, end: int) -> list: Compute the shortest path between two nodes in an undirected graph using BFS. :param graph: Adjacency list representation of the graph. :param start: The starting node. :param end: The destination node. :return: A list representing the shortest path from the start node to the end node, inclusive. If no path exists, return an empty list. >>> graph = { ... 1: [2, 3], ... 2: [1, 4], ... 3: [1, 4], ... 4: [2, 3, 5], ... 5: [4] ... } >>> shortest_path(graph, 1, 5) [1, 2, 4, 5] >>> shortest_path(graph, 1, 1) [1] >>> graph = { ... 1: [2], ... 2: [1], ... 3: [] ... } >>> shortest_path(graph, 1, 3) []","solution":"from collections import deque def shortest_path(graph: dict, start: int, end: int) -> list: Compute the shortest path between two nodes in an undirected graph using BFS. :param graph: Adjacency list representation of the graph. :param start: The starting node. :param end: The destination node. :return: A list representing the shortest path from the start node to the end node, inclusive. If no path exists, return an empty list. if start == end: return [start] queue = deque([[start]]) visited = set() while queue: path = queue.popleft() node = path[-1] if node not in visited: neighbours = graph.get(node, []) for neighbour in neighbours: new_path = list(path) new_path.append(neighbour) queue.append(new_path) if neighbour == end: return new_path visited.add(node) return []"},{"question":"def reorder_even_odd(input_list: list) -> list: Returns a new list with all even numbers before all odd numbers while maintaining the relative order of both even and odd numbers from the original list. >>> reorder_even_odd([1, 2, 3, 4, 5]) [2, 4, 1, 3, 5] >>> reorder_even_odd([1, 2, 2, 3, 3, 4, 5]) [2, 2, 4, 1, 3, 3, 5] >>> reorder_even_odd([4, 3, 2, 1]) [4, 2, 3, 1] >>> reorder_even_odd([]) []","solution":"def reorder_even_odd(input_list: list) -> list: Returns a new list with all even numbers before all odd numbers while maintaining the relative order of both even and odd numbers from the original list. if not input_list: return [] even_numbers = [num for num in input_list if num % 2 == 0] odd_numbers = [num for num in input_list if num % 2 != 0] return even_numbers + odd_numbers"},{"question":"def str_reverse(s: str) -> str: Reverse a given string. >>> str_reverse(\\"hello\\") \\"olleh\\" >>> str_reverse(\\"\\") \\"\\" >>> str_reverse(\\"a\\") \\"a\\" def str_remove_vowels(s: str) -> str: Remove all vowels from a given string. >>> str_remove_vowels(\\"hello\\") \\"hll\\" >>> str_remove_vowels(\\"AEIOUaeiou\\") \\"\\" >>> str_remove_vowels(\\"bcdfgh\\") \\"bcdfgh\\" def str_capitalize_words(s: str) -> str: Capitalize the words in a given string. >>> str_capitalize_words(\\"hello world\\") \\"Hello World\\" >>> str_capitalize_words(\\"HELLO WORLD\\") \\"Hello World\\" >>> str_capitalize_words(\\"\\") \\"\\" def str_encode_caesar_cipher(s: str, shift: int) -> str: Encode a string using a Caesar cipher with a given shift value. >>> str_encode_caesar_cipher(\\"abc\\", 1) \\"bcd\\" >>> str_encode_caesar_cipher(\\"xyz\\", 3) \\"abc\\" >>> str_encode_caesar_cipher(\\"Hello, World!\\", 5) \\"Mjqqt, Btwqi!\\" def str_is_palindrome(s: str) -> bool: Check if a given string is a palindrome. >>> str_is_palindrome(\\"racecar\\") True >>> str_is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> str_is_palindrome(\\"hello\\") False def str_is_anagram(s1: str, s2: str) -> bool: Check if two given strings are anagrams. >>> str_is_anagram(\\"listen\\", \\"silent\\") True >>> str_is_anagram(\\"evil\\", \\"vile\\") True >>> str_is_anagram(\\"hello\\", \\"world\\") False def str_is_substring(s1: str, s2: str) -> bool: Check if one string is a substring of another. >>> str_is_substring(\\"hello\\", \\"hello world\\") True >>> str_is_substring(\\"world\\", \\"hello\\") False >>> str_is_substring(\\"\\", \\"anything\\") True","solution":"def str_reverse(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"str_reverse() only accepts strings\\") return s[::-1] def str_remove_vowels(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"str_remove_vowels() only accepts strings\\") vowels = \\"aeiouAEIOU\\" return ''.join(char for char in s if char not in vowels) def str_capitalize_words(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"str_capitalize_words() only accepts strings\\") return ' '.join(word.capitalize() for word in s.split()) def str_encode_caesar_cipher(s: str, shift: int) -> str: if not isinstance(s, str) or not isinstance(shift, int): raise TypeError(\\"str_encode_caesar_cipher() only accepts a string and an integer\\") def shift_char(c): if 'a' <= c <= 'z': return chr((ord(c) - ord('a') + shift) % 26 + ord('a')) elif 'A' <= c <= 'Z': return chr((ord(c) - ord('A') + shift) % 26 + ord('A')) return c return ''.join(shift_char(c) for c in s) def str_is_palindrome(s: str) -> bool: if not isinstance(s, str): raise TypeError(\\"str_is_palindrome() only accepts strings\\") stripped = ''.join(e for e in s if e.isalnum()).lower() return stripped == stripped[::-1] def str_is_anagram(s1: str, s2: str) -> bool: if not isinstance(s1, str) or not isinstance(s2, str): raise TypeError(\\"str_is_anagram() only accepts strings\\") return sorted(s1) == sorted(s2) def str_is_substring(s1: str, s2: str) -> bool: if not isinstance(s1, str) or not isinstance(s2, str): raise TypeError(\\"str_is_substring() only accepts strings\\") return s1 in s2"},{"question":"def matrix_multiplication(matrix_a, matrix_b): Multiplies two matrices and returns the resulting matrix. Handles both dense and sparse matrices efficiently. >>> matrix_a = [ ... [1, 0, 0], ... [0, 2, 0], ... [0, 0, 3] ... ] >>> matrix_b = [ ... [4, 5, 6], ... [7, 8, 9], ... [1, 2, 3] ... ] >>> matrix_multiplication(matrix_a, matrix_b) [ [4, 5, 6], [14, 16, 18], [3, 6, 9] ] pass # Example test cases to be used to verify the correctness of the function def test_matrix_multiplication_dense(): matrix_a = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] matrix_b = [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] expected = [ [30, 24, 18], [84, 69, 54], [138, 114, 90] ] assert matrix_multiplication(matrix_a, matrix_b) == expected def test_matrix_multiplication_sparse(): matrix_a = [ [1, 0, 0], [0, 2, 0], [0, 0, 3] ] matrix_b = [ [4, 5, 6], [7, 8, 9], [1, 2, 3] ] expected = [ [4, 5, 6], [14, 16, 18], [3, 6, 9] ] assert matrix_multiplication(matrix_a, matrix_b) == expected def test_matrix_multiplication_mixed(): matrix_a = [ [0, 2, 0], [3, 0, 1], [0, 0, 0] ] matrix_b = [ [5, 8, 1], [0, 6, 3], [4, 1, 0] ] expected = [ [0, 12, 6], [19, 25, 3], [0, 0, 0] ] assert matrix_multiplication(matrix_a, matrix_b) == expected def test_empty_matrices(): try: result = matrix_multiplication([], []) except ValueError as e: assert str(e) == \\"Input matrices cannot be empty.\\" def test_incompatible_matrices(): matrix_a = [ [1, 2], [3, 4] ] matrix_b = [ [1, 2, 3] ] try: result = matrix_multiplication(matrix_a, matrix_b) except ValueError as e: assert str(e) == \\"Number of columns of matrix_a must be equal to number of rows of matrix_b.\\"","solution":"def matrix_multiplication(matrix_a, matrix_b): Multiplies two matrices and returns the resulting matrix. if not matrix_a or not matrix_b: raise ValueError(\\"Input matrices cannot be empty.\\") m, n = len(matrix_a), len(matrix_a[0]) n_b, p = len(matrix_b), len(matrix_b[0]) if n != n_b: raise ValueError(\\"Number of columns of matrix_a must be equal to number of rows of matrix_b.\\") # Prepare the result matrix with zeros result = [[0] * p for _ in range(m)] # Sparse representation of matrix_a and matrix_b sparse_a = {} sparse_b = {} for i in range(m): for j in range(n): if matrix_a[i][j] != 0: if i not in sparse_a: sparse_a[i] = {} sparse_a[i][j] = matrix_a[i][j] for i in range(n): for j in range(p): if matrix_b[i][j] != 0: if i not in sparse_b: sparse_b[i] = {} sparse_b[i][j] = matrix_b[i][j] # Perform multiplication for i in sparse_a: for k in sparse_a[i]: if k in sparse_b: for j in sparse_b[k]: result[i][j] += sparse_a[i][k] * sparse_b[k][j] return result"},{"question":"def min_bounding_rectangle(points: list[tuple[int, int]]) -> tuple[tuple[int, int], tuple[int, int]]: Determines the minimum bounding rectangle (MBR) that encompasses all given points. Parameters: points (list[tuple[int, int]]): A list of tuples where each tuple represents a point (x, y) in 2D space. Returns: tuple[tuple[int, int], tuple[int, int]]: The bottom-left and top-right corners of the MBR. >>> min_bounding_rectangle([(1, 2), (4, 6), (2, 3), (5, 8)]) == ((1, 2), (5, 8)) >>> min_bounding_rectangle([(-5, -3), (0, 0), (10, 2)]) == ((-5, -3), (10, 2)) >>> min_bounding_rectangle([(3, 3)]) == ((3, 3), (3, 3)) >>> min_bounding_rectangle([]) == None >>> min_bounding_rectangle([(0, 0), (1, 1), (2, 2), (3, 3)]) == ((0, 0), (3, 3)) >>> min_bounding_rectangle([(-3, -3), (-1, -1), (-2, -2)]) == ((-3, -3), (-1, -1)) >>> min_bounding_rectangle([(-10**9, -10**9), (10**9, 10**9)]) == ((-10**9, -10**9), (10**9, 10**9))","solution":"def min_bounding_rectangle(points): Determines the minimum bounding rectangle (MBR) that encompasses all given points. Parameters: points (list[tuple[int, int]]): A list of tuples where each tuple represents a point (x, y) in 2D space. Returns: tuple[tuple[int, int], tuple[int, int]]: The bottom-left and top-right corners of the MBR. if not points: return None # Return None if points list is empty min_x = min(point[0] for point in points) max_x = max(point[0] for point in points) min_y = min(point[1] for point in points) max_y = max(point[1] for point in points) return (min_x, min_y), (max_x, max_y)"},{"question":"def is_subsequence(subsequence: list, main_sequence: list) -> bool: Checks if the elements of one list are a subsequence of another list. >>> is_subsequence([1, 3, 4], [1, 2, 3, 4, 5]) True >>> is_subsequence([\\"A\\", \\"C\\", \\"E\\"], [\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\"]) True >>> is_subsequence([3, 4, 1], [1, 2, 3, 4, 5]) False >>> is_subsequence([], [1, 2, 3, 4, 5]) True >>> is_subsequence([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) True >>> is_subsequence([1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5]) False >>> is_subsequence([1, 5], [1, 2, 3, 4, 5]) True >>> is_subsequence([6, 7, 8], [1, 2, 3, 4, 5]) False","solution":"def is_subsequence(subsequence: list, main_sequence: list) -> bool: Checks if the elements of \`subsequence\` are a subsequence of \`main_sequence\`. subseq_index = 0 main_seq_index = 0 while subseq_index < len(subsequence) and main_seq_index < len(main_sequence): if subsequence[subseq_index] == main_sequence[main_seq_index]: subseq_index += 1 main_seq_index += 1 return subseq_index == len(subsequence)"},{"question":"import heapq from typing import List, Tuple, Dict class Graph: def __init__(self, n: int): Initialize the graph with n nodes. self.graph = {i: [] for i in range(n)} def add_edge(self, u: int, v: int, w: int): Add an edge from node u to node v with weight w. self.graph[u].append((v, w)) def dijkstra(self, start: int) -> Dict[int, int]: Perform Dijkstra's algorithm to find the shortest paths from the start node. Args: start (int): The starting node. Returns: dict: A dictionary where keys are node indices and values are the shortest distance from the start node. distances = {node: float('inf') for node in self.graph} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in self.graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def shortest_paths(n: int, edges: List[Tuple[int, int, int]], start: int) -> Dict[int, int]: Find the shortest paths from the start node to all other nodes in a weighted graph using Dijkstra's Algorithm. Args: n (int): Number of nodes in the graph. edges (list): List of tuples where each tuple represents an edge (u, v, w), with u and v as nodes and w as the weight. start (int): The starting node. Returns: dict: A dictionary where keys are node indices and values are the shortest paths from the start node. Examples: >>> shortest_paths(5, [(0, 1, 10), (0, 4, 5), (1, 2, 1), (2, 3, 4), (4, 3, 2), (4, 1, 3)], 0) {0: 0, 1: 8, 2: 9, 3: 7, 4: 5} >>> shortest_paths(3, [(0, 1, 1), (1, 2, 2)], 0) {0: 0, 1: 1, 2: 3} >>> shortest_paths(4, [(0, 1, 1), (1, 2, 2), (1, 3, 5)], 1) {0: inf, 1: 0, 2: 2, 3: 5} graph = Graph(n) for u, v, w in edges: graph.add_edge(u, v, w) return graph.dijkstra(start)","solution":"import heapq class Graph: def __init__(self, n): self.graph = {i: [] for i in range(n)} def add_edge(self, u, v, w): self.graph[u].append((v, w)) def dijkstra(self, start): distances = {node: float('inf') for node in self.graph} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in self.graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def shortest_paths(n, edges, start): graph = Graph(n) for u, v, w in edges: graph.add_edge(u, v, w) return graph.dijkstra(start)"},{"question":"class BankAccount: def __init__(self): Initialize a new bank account with a balance of zero. pass def deposit(self, amount: int) -> None: Deposit a specified amount into the account. Example usage: >>> account = BankAccount() >>> account.deposit(100) >>> account.balance() 100 pass def withdraw(self, amount: int) -> bool: Withdraw a specified amount from the account if sufficient funds are available. Returns True if the withdrawal is successful, False otherwise. Example usage: >>> account = BankAccount() >>> account.deposit(100) >>> account.withdraw(50) True >>> account.balance() 50 pass def balance(self) -> int: Returns the current balance of the bank account. Example usage: >>> account = BankAccount() >>> account.balance() 0 pass # Example Usage: # account = BankAccount() # account.deposit(100) # print(account.balance()) # Outputs: 100 # result = account.withdraw(50) # print(result) # Outputs: True # print(account.balance()) # Outputs: 50 # result = account.withdraw(60) # print(result) # Outputs: False # print(account.balance()) # Outputs: 50","solution":"class BankAccount: def __init__(self): self._balance = 0 def deposit(self, amount: int) -> None: if amount > 0: self._balance += amount def withdraw(self, amount: int) -> bool: if 0 < amount <= self._balance: self._balance -= amount return True else: return False def balance(self) -> int: return self._balance"},{"question":"class LRUCache: Implement an LRU (Least Recently Used) Cache. Attributes: capacity: An integer representing the maximum number of items the cache can hold. Methods: __init__(self, capacity: int): Constructor to initialize the cache capacity. get(self, key: int) -> int: Return the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(self, key: int, value: int) -> None: Insert a key-value pair into the cache. If the cache exceeds its capacity, it should invalid the least recently used item. def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass # Test cases def test_cache_operations(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 cache.put(3, 3) assert cache.get(2) == -1 cache.put(4, 4) assert cache.get(1) == -1 assert cache.get(3) == 3 assert cache.get(4) == 4 def test_cache_eviction(): cache = LRUCache(1) cache.put(1, 1) assert cache.get(1) == 1 cache.put(2, 2) assert cache.get(1) == -1 assert cache.get(2) == 2 def test_cache_update(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(2, 3) assert cache.get(2) == 3 cache.put(3, 3) assert cache.get(1) == -1 assert cache.get(3) == 3 assert cache.get(2) == 3 def test_cache_capacity(): cache = LRUCache(0) cache.put(1, 1) assert cache.get(1) == -1 def test_mixed_operations(): cache = LRUCache(2) assert cache.get(2) == -1 cache.put(2, 6) assert cache.get(1) == -1 cache.put(1, 5) cache.put(1, 2) assert cache.get(1) == 2 assert cache.get(2) == 6","solution":"class Node: def __init__(self, key=None, value=None): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} # Dummy head and tail nodes to avoid empty states self.head = Node() self.tail = Node() self.head.next = self.tail self.tail.prev = self.head def _add_node(self, node: Node): # Always add the new node right after head node.prev = self.head node.next = self.head.next self.head.next.prev = node self.head.next = node def _remove_node(self, node: Node): # Remove an existing node from the linked list prev = node.prev new = node.next prev.next = new new.prev = prev def _move_to_head(self, node: Node): # Move certain node to the head (as most recently used) self._remove_node(node) self._add_node(node) def _pop_tail(self) -> Node: # Pop the current tail (least recently used) node = self.tail.prev self._remove_node(node) return node def get(self, key: int) -> int: node = self.cache.get(key, None) if node is None: return -1 # Move the accessed node to the head self._move_to_head(node) return node.value def put(self, key: int, value: int) -> None: node = self.cache.get(key) if node is None: # Create a new node newNode = Node(key, value) self.cache[key] = newNode self._add_node(newNode) if len(self.cache) > self.capacity: # Pop the tail tail = self._pop_tail() del self.cache[tail.key] else: # Update the value node.value = value self._move_to_head(node)"},{"question":"def sum_of_digits(s: str) -> int: Given a string composed of digits, find the sum of all its digits. Parameters: s (str): Input string composed of digits (1  len(s)  10^6). Returns: int: Sum of all digits in the string. >>> sum_of_digits(\\"123456789\\") == 45 >>> sum_of_digits(\\"000123\\") == 6 from solution import sum_of_digits def test_sum_of_digits_single_digit(): assert sum_of_digits(\\"5\\") == 5 def test_sum_of_digits_multiple_digits(): assert sum_of_digits(\\"123456789\\") == 45 def test_sum_of_digits_with_zeros(): assert sum_of_digits(\\"000123\\") == 6 def test_sum_of_digits_larger_numbers(): assert sum_of_digits(\\"9876543210\\") == 45 def test_sum_of_digits_repeated_digit(): assert sum_of_digits(\\"11111\\") == 5 def test_sum_of_digits_mixed_digits(): assert sum_of_digits(\\"104937\\") == 24 def test_sum_of_digits_large_input(): large_input = \\"1\\" * 1000000 # 1 million '1's assert sum_of_digits(large_input) == 1000000","solution":"def sum_of_digits(s: str) -> int: Returns the sum of all digits in the input string. Parameters: s (str): Input string composed of digits. Returns: int: Sum of all digits in the string. total = 0 for char in s: total += int(char) return total"},{"question":"from typing import List def split_array_minimized_max_sum(arr: List[int], k: int) -> int: Split the array into \`k\` non-empty subarrays such that the largest sum among those subarrays is minimized. >>> split_array_minimized_max_sum([7, 2, 5, 10, 8], 2) 18 >>> split_array_minimized_max_sum([1, 2, 3, 4, 5], 2) 9 >>> split_array_minimized_max_sum([1, 4, 4], 3) 4 >>> split_array_minimized_max_sum([1, 2, 3, 4, 5], 1) 15","solution":"from typing import List def can_partition(nums: List[int], k: int, max_sum: int) -> bool: current_sum = 0 count = 1 for num in nums: if current_sum + num > max_sum: count += 1 current_sum = num if count > k: return False else: current_sum += num return True def split_array_minimized_max_sum(arr: List[int], k: int) -> int: left, right = max(arr), sum(arr) result = right while left <= right: mid = (left + right) // 2 if can_partition(arr, k, mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"from typing import List def can_solve_maze(maze: List[List[int]]) -> bool: Checks whether there is a path from the start point to the end point in a given maze represented by a grid. Args: maze (List[List[int]]): A 2D grid representing the maze. Returns: bool: True if there is a path from the start to the end, otherwise False. Examples: >>> maze = [ ... [0, 1, 1, 0], ... [0, 0, 1, 0], ... [1, 0, 1, 1], ... [1, 0, 0, 0] ... ] >>> can_solve_maze(maze) True >>> maze = [ ... [0, 1, 1, 1], ... [1, 1, 1, 0], ... [1, 1, 1, 1], ... [0, 0, 0, 0] ... ] >>> can_solve_maze(maze) False >>> maze = [ ... [0, 0, 1], ... [1, 0, 1], ... [0, 0, 0] ... ] >>> can_solve_maze(maze) True pass","solution":"from typing import List def can_solve_maze(maze: List[List[int]]) -> bool: n = len(maze) m = len(maze[0]) # directions: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and maze[x][y] == 0 def dfs(x, y): if x == n - 1 and y == m - 1: return True maze[x][y] = 1 # Mark visited for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and dfs(nx, ny): return True return False return dfs(0, 0)"},{"question":"from typing import List def generate_subsets(input_set: List[int]) -> List[List[int]]: Generates all possible subsets of a given set of unique integers. >>> generate_subsets([]) == [[]] True >>> generate_subsets([1]) == [[], [1]] True >>> generate_subsets([1, 2]) == [[], [1], [2], [1, 2]] True >>> generate_subsets([1, 2, 3]) == [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] True","solution":"from typing import List def generate_subsets(input_set: List[int]) -> List[List[int]]: if not isinstance(input_set, list) or any(not isinstance(i, int) for i in input_set): raise TypeError(\\"Input must be a list of integers.\\") subsets = [[]] for num in input_set: new_subsets = [current + [num] for current in subsets] subsets.extend(new_subsets) return subsets"},{"question":"def calculate_optimal_route(start: tuple, destinations: list) -> list: Determine the optimal delivery route starting and ending at the warehouse. Parameters: start (tuple): Coordinates of the starting location (latitude, longitude). destinations (list): List of tuples representing the coordinates of the delivery destinations. Returns: list: List of coordinates representing the optimal delivery route. >>> calculate_optimal_route((34.0522, -118.2437), [(34.0522, -118.2537), (34.0322, -118.2437), (34.0422, -118.2137)]) [(34.0522, -118.2437), (34.0322, -118.2437), (34.0422, -118.2137), (34.0522, -118.2537), (34.0522, -118.2437)] >>> calculate_optimal_route((34.0522, -118.2437), []) [(34.0522, -118.2437), (34.0522, -118.2437)] pass def test_calculate_optimal_route_no_destinations(): start = (34.0522, -118.2437) destinations = [] result = calculate_optimal_route(start, destinations) assert result == [(34.0522, -118.2437), (34.0522, -118.2437)] def test_calculate_optimal_route_single_destination(): start = (34.0522, -118.2437) destinations = [(34.0522, -118.2537)] result = calculate_optimal_route(start, destinations) assert result == [(34.0522, -118.2437), (34.0522, -118.2537), (34.0522, -118.2437)] def test_calculate_optimal_route_multiple_destinations(): start = (34.0522, -118.2437) destinations = [ (34.0522, -118.2537), (34.0322, -118.2437), (34.0422, -118.2137) ] result = calculate_optimal_route(start, destinations) assert result[0] == (34.0522, -118.2437) assert result[-1] == (34.0522, -118.2437) assert all(destination in result[1:-1] for destination in destinations) def test_calculate_optimal_route_complex_route(): start = (34.0522, -118.2437) destinations = [ (34.0522, -118.2537), (34.0322, -118.2437), (34.0422, -118.2137), (34.0622, -118.2337), (34.0122, -118.2237) ] result = calculate_optimal_route(start, destinations) assert result[0] == (34.0522, -118.2437) assert result[-1] == (34.0522, -118.2437) assert all(destination in result[1:-1] for destination in destinations) def test_calculate_optimal_route_duplicates(): start = (34.0522, -118.2437) destinations = [ (34.0422, -118.2137), (34.0422, -118.2137) ] result = calculate_optimal_route(start, destinations) assert result == [ (34.0522, -118.2437), (34.0422, -118.2137), (34.0422, -118.2137), (34.0522, -118.2437) ]","solution":"import math def euclidean_distance(point1, point2): Calculate the Euclidean distance between two points in 2D space. return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) def calculate_optimal_route(start, destinations): Determine the optimal delivery route starting and ending at the warehouse. Parameters: start (tuple): Coordinates of the starting location (latitude, longitude). destinations (list): List of tuples representing the coordinates of the delivery destinations. Returns: list: List of coordinates representing the optimal delivery route. if not destinations: return [start, start] # Create a copy of the destinations to manipulate remaining_destinations = destinations.copy() # Start the route with the starting point route = [start] current_location = start while remaining_destinations: # Find the nearest neighbor nearest_neighbor = min(remaining_destinations, key=lambda x: euclidean_distance(current_location, x)) route.append(nearest_neighbor) current_location = nearest_neighbor remaining_destinations.remove(nearest_neighbor) # Return to the starting point route.append(start) return route"},{"question":"def sum_primes_up_to(n: int) -> int: Returns the sum of all prime numbers less than or equal to n. >>> sum_primes_up_to(10) == 17 >>> sum_primes_up_to(30) == 129 >>> sum_primes_up_to(2) == 2 >>> sum_primes_up_to(29) == 129 >>> sum_primes_up_to(1000000) == 37550402023","solution":"def sum_primes_up_to(n: int) -> int: Returns the sum of all prime numbers less than or equal to n. if n < 2: return 0 sieve = [True] * (n + 1) sieve[0] = sieve[1] = False for start in range(2, int(n ** 0.5) + 1): if sieve[start]: for multiple in range(start * start, n + 1, start): sieve[multiple] = False prime_sum = sum(index for index, is_prime in enumerate(sieve) if is_prime) return prime_sum"},{"question":"import numpy as np class DecisionTree: def __init__(self, max_depth=10): Initialize the Decision Tree with a maximum depth. pass def fit(self, data): Fit the Decision Tree model using training data. Parameters: data (np.ndarray): Training data with the last column as class labels. pass def predict(self, X): Predict class labels for given test data. Parameters: X (np.ndarray): Test data without class labels. Returns: np.ndarray: Predicted class labels for the test data. pass def _build_tree(self, data, depth): Recursively build the Decision Tree. pass def _create_leaf(self, data): Create a leaf node. pass def _find_best_split(self, data): Find the best feature and value to split the data on. pass def _gini_impurity(self, left_data, right_data): Calculate the Gini impurity for a split. pass def _predict_single(self, x, tree): Predict the class label for a single sample. pass def test_decision_tree(): train_data = np.array([ [2, 3, 0], [3, 4, 0], [1, 1, 1], [2, 2, 1] ]) test_samples = np.array([ [3, 3], [1, 2] ]) expected_predictions = np.array([0, 1]) decision_tree = DecisionTree(max_depth=3) decision_tree.fit(train_data) predictions = decision_tree.predict(test_samples) assert np.array_equal(predictions, expected_predictions) def test_decision_tree_single_class(): train_data = np.array([ [2, 3, 0], [3, 4, 0], [2, 2, 0] ]) test_samples = np.array([ [1, 1], [4, 5] ]) expected_predictions = np.array([0, 0]) decision_tree = DecisionTree(max_depth=3) decision_tree.fit(train_data) predictions = decision_tree.predict(test_samples) assert np.array_equal(predictions, expected_predictions) def test_decision_tree_complex(): train_data = np.array([ [2, 3, 0], [3, 4, 0], [1, 1, 1], [2, 2, 1], [5, 5, 1], [6, 6, 0], [3, 1, 1], [6, 2, 0] ]) test_samples = np.array([ [3, 3], [4, 5], [2, 1] ]) expected_predictions = np.array([0, 1, 1]) decision_tree = DecisionTree(max_depth=3) decision_tree.fit(train_data) predictions = decision_tree.predict(test_samples) assert np.array_equal(predictions, expected_predictions)","solution":"import numpy as np class DecisionTree: def __init__(self, max_depth=10): self.max_depth = max_depth self.tree = None def fit(self, data): self.tree = self._build_tree(data, depth=0) def predict(self, X): return np.array([self._predict_single(x, self.tree) for x in X]) def _build_tree(self, data, depth): if len(set(data[:, -1])) == 1 or depth == self.max_depth: return self._create_leaf(data) split_column, split_value, left_data, right_data = self._find_best_split(data) if len(left_data) == 0 or len(right_data) == 0: return self._create_leaf(data) left_branch = self._build_tree(left_data, depth + 1) right_branch = self._build_tree(right_data, depth + 1) return (split_column, split_value, left_branch, right_branch) def _create_leaf(self, data): labels, counts = np.unique(data[:, -1], return_counts=True) return labels[np.argmax(counts)] def _find_best_split(self, data): best_gini = float('inf') best_column = None best_value = None best_splits = (None, None) n_columns = data.shape[1] - 1 # exclude label for column in range(n_columns): values = data[:, column] for value in np.unique(values): left_mask = data[:, column] <= value right_mask = ~left_mask if left_mask.sum() == 0 or right_mask.sum() == 0: continue left_data = data[left_mask] right_data = data[right_mask] gini = self._gini_impurity(left_data, right_data) if gini < best_gini: best_gini = gini best_column = column best_value = value best_splits = (left_data, right_data) return best_column, best_value, best_splits[0], best_splits[1] def _gini_impurity(self, left_data, right_data): total_samples = len(left_data) + len(right_data) def calculate_gini(data): labels, counts = np.unique(data[:, -1], return_counts=True) impurity = 1.0 for count in counts: prob = count / len(data) impurity -= prob ** 2 return impurity gini_left = calculate_gini(left_data) gini_right = calculate_gini(right_data) weighted_gini = (len(left_data) / total_samples) * gini_left + (len(right_data) / total_samples) * gini_right return weighted_gini def _predict_single(self, x, tree): if not isinstance(tree, tuple): return tree column, value, left, right = tree if x[column] <= value: return self._predict_single(x, left) else: return self._predict_single(x, right)"},{"question":"[Completion Task in Python] class CircularQueue: def __init__(self, capacity): self._data = [None] * capacity self._capacity = capacity self._size = 0 self._front = 0 self._rear = 0 def enqueue(self, item): if self._size == self._capacity: raise OverflowError(\\"Queue is full\\") self._data[self._rear] = item self._rear = (self._rear + 1) % self._capacity self._size += 1 def dequeue(self): if self._size == 0: raise IndexError(\\"Queue is empty\\") item = self._data[self._front] self._data[self._front] = None # Clear reference self._front = (self._front + 1) % self._capacity self._size -= 1 return item def __len__(self): return self._size","solution":"class CircularQueue: def __init__(self, capacity): self._data = [None] * capacity self._capacity = capacity self._size = 0 self._front = 0 self._rear = 0 def enqueue(self, item): if self._size == self._capacity: raise OverflowError(\\"Queue is full\\") self._data[self._rear] = item self._rear = (self._rear + 1) % self._capacity self._size += 1 def dequeue(self): if self._size == 0: raise IndexError(\\"Queue is empty\\") item = self._data[self._front] self._data[self._front] = None # Clear reference self._front = (self._front + 1) % self._capacity self._size -= 1 return item def __len__(self): return self._size"},{"question":"class MenuItem: def navigate(self, choice: str) -> 'MenuItem': pass class Menu(MenuItem): def __init__(self, name: str): self.name = name self.submenus = {} self.actions = {} def navigate(self, choice: str) -> 'MenuItem': Navigate through the menu and perform specified actions at any given menu level. >>> connect_to_representative() Connecting to a representative... >>> play_information() Playing information... # Implement this method def add_submenu(self, choice: str, submenu: 'Menu'): self.submenus[choice] = submenu def add_action(self, choice: str, action: callable): self.actions[choice] = action def connect_to_representative(): print(\\"Connecting to a representative...\\") def play_information(): print(\\"Playing information...\\") import pytest def test_menu_navigation(): main_menu = Menu(\\"Main Menu\\") billing_menu = Menu(\\"Billing Menu\\") technical_support_menu = Menu(\\"Technical Support Menu\\") main_menu.add_submenu(\\"1\\", billing_menu) main_menu.add_submenu(\\"2\\", technical_support_menu) main_menu.add_action(\\"0\\", connect_to_representative) billing_menu.add_action(\\"1\\", play_information) current_menu = main_menu # Test navigating to billing menu current_menu = current_menu.navigate(\\"1\\") assert current_menu.name == \\"Billing Menu\\" # Test invalid choice in billing menu current_menu = current_menu.navigate(\\"invalid\\") assert current_menu.name == \\"Billing Menu\\" # Test play information action in billing menu current_menu = current_menu.navigate(\\"1\\") assert current_menu.name == \\"Billing Menu\\" # Should stay in billing menu after action # Test navigating back to main menu current_menu = main_menu.navigate(\\"2\\") assert current_menu.name == \\"Technical Support Menu\\" # Test connecting to representative current_menu = main_menu.navigate(\\"0\\") assert current_menu.name == \\"Main Menu\\" # Should stay in main menu after action def test_case_insensitivity_and_whitespace(): main_menu = Menu(\\"Main Menu\\") billing_menu = Menu(\\"Billing Menu\\") main_menu.add_submenu(\\"1\\", billing_menu) main_menu.add_action(\\"0\\", connect_to_representative) # Test case insensitivity and whitespace current_menu = main_menu.navigate(\\" 1 \\") assert current_menu.name == \\"Billing Menu\\" current_menu = main_menu.navigate(\\" 0 \\") assert current_menu.name == \\"Main Menu\\" def test_invalid_choice(): main_menu = Menu(\\"Main Menu\\") billing_menu = Menu(\\"Billing Menu\\") technical_support_menu = Menu(\\"Technical Support Menu\\") main_menu.add_submenu(\\"1\\", billing_menu) main_menu.add_submenu(\\"2\\", technical_support_menu) main_menu.add_action(\\"0\\", connect_to_representative) # Test invalid choice handling current_menu = main_menu.navigate(\\"invalid\\") assert current_menu.name == \\"Main Menu\\" # Should stay in main menu","solution":"class MenuItem: def navigate(self, choice: str) -> 'MenuItem': pass class Menu(MenuItem): def __init__(self, name: str): self.name = name self.submenus = {} self.actions = {} def navigate(self, choice: str) -> 'MenuItem': choice = choice.strip().lower() if choice in self.actions: self.actions[choice]() return self elif choice in self.submenus: return self.submenus[choice] else: print(\\"Invalid choice, please try again.\\") return self def add_submenu(self, choice: str, submenu: 'Menu'): self.submenus[choice.strip().lower()] = submenu def add_action(self, choice: str, action: callable): self.actions[choice.strip().lower()] = action def connect_to_representative(): print(\\"Connecting to a representative...\\") def play_information(): print(\\"Playing information...\\")"},{"question":"from typing import List, Tuple def manage_tasks(commands: List[Tuple[str, int, int]]) -> List[Tuple[int, int]]: Simulates managing a collection of tasks using priority queues. Each task can be added with a specific priority and can be dynamically updated or removed based on incoming commands. Takes a list of commands and processes them to manage the tasks. Each command is a tuple consisting of a string indicating the operation ('add', 'remove', 'update'), the task ID, and the task priority. Returns a list of task IDs sorted by their priorities in descending order. >>> manage_tasks([('add', 1, 10), ('add', 2, 20), ('update', 1, 15), ('remove', 2, 0)]) [(1, 15)] >>> manage_tasks([('add', 1, 10), ('add', 2, 20), ('remove', 1, 0)]) [(2, 20)] >>> manage_tasks([('add', 1, 10), ('add', 2, 20), ('update', 1, 25)]) [(1, 25), (2, 20)] >>> manage_tasks([]) [] >>> manage_tasks([('add', 1, 10), ('update', 2, 20)]) [(1, 10)] # Task 2 does not exist, so it should not be updated","solution":"from typing import List, Tuple def manage_tasks(commands: List[Tuple[str, int, int]]) -> List[Tuple[int, int]]: tasks = {} for command in commands: operation, task_id, priority = command if operation == 'add': tasks[task_id] = priority elif operation == 'remove': if task_id in tasks: del tasks[task_id] elif operation == 'update': if task_id in tasks: tasks[task_id] = priority # Sort tasks by priority in descending order and return as a list of tuples return sorted(tasks.items(), key=lambda x: x[1], reverse=True)"},{"question":"def compress_text_file(input_file: str, output_file: str) -> bool: Compress the contents of a text file using Run-Length Encoding (RLE) and save the result to an output file. Args: input_file (str): Path to the input text file to be compressed. output_file (str): Path to the output file where compressed content will be saved. Returns: bool: Returns True if compression is successful, False otherwise. try: with open(input_file, 'r') as f: content = f.read() compressed_content = \\"\\" count = 1 for i in range(1, len(content)): if content[i] == content[i - 1]: count += 1 else: compressed_content += content[i - 1] + str(count) count = 1 compressed_content += content[-1] + str(count) # last character with open(output_file, 'w') as f: f.write(compressed_content) return True except Exception as e: print(f\\"Error: {e}\\") return False def decompress_text_file(input_file: str, output_file: str) -> bool: Decompress a text file that was compressed using Run-Length Encoding (RLE) and save the restored content to an output file. Args: input_file (str): Path to the compressed text file to be decompressed. output_file (str): Path to the output file where decompressed content will be saved. Returns: bool: Returns True if decompression is successful, False otherwise. try: with open(input_file, 'r') as f: content = f.read() decompressed_content = \\"\\" i = 0 while i < len(content): char = content[i] j = i + 1 count = 0 while j < len(content) and content[j].isdigit(): count = count * 10 + int(content[j]) j += 1 decompressed_content += char * count i = j with open(output_file, 'w') as f: f.write(decompressed_content) return True except Exception as e: print(f\\"Error: {e}\\") return False","solution":"def compress_text_file(input_file: str, output_file: str) -> bool: try: with open(input_file, 'r') as f: content = f.read() if not content: # Handle the case of empty files with open(output_file, 'w') as f: f.write(\\"\\") return True compressed_content = \\"\\" count = 1 for i in range(1, len(content)): if content[i] == content[i - 1]: count += 1 else: compressed_content += content[i - 1] + str(count) count = 1 compressed_content += content[-1] + str(count) # last character with open(output_file, 'w') as f: f.write(compressed_content) return True except Exception as e: print(f\\"Error: {e}\\") return False def decompress_text_file(input_file: str, output_file: str) -> bool: try: with open(input_file, 'r') as f: content = f.read() if not content: # Handle the case of empty files with open(output_file, 'w') as f: f.write(\\"\\") return True decompressed_content = \\"\\" i = 0 while i < len(content): char = content[i] j = i + 1 count = 0 while j < len(content) and content[j].isdigit(): count = count * 10 + int(content[j]) j += 1 decompressed_content += char * count i = j with open(output_file, 'w') as f: f.write(decompressed_content) return True except Exception as e: print(f\\"Error: {e}\\") return False"},{"question":"def shortest_path(n: int, m: int) -> int: Function to calculate the number of distinct shortest paths from the top-left corner to the bottom-right corner of an n x m grid. You can only move right or down at any point in time. Args: n (int): number of rows in the grid (1 <= n <= 1000) m (int): number of columns in the grid (1 <= m <= 1000) Returns: int: number of distinct shortest paths from top-left to bottom-right corner Examples: >>> shortest_path(2, 2) 2 >>> shortest_path(3, 3) 6 >>> shortest_path(2, 3) 3 >>> shortest_path(4, 5) 35 # Add your code here def test_shortest_path_2x2(): assert shortest_path(2, 2) == 2 def test_shortest_path_3x3(): assert shortest_path(3, 3) == 6 def test_shortest_path_2x3(): assert shortest_path(2, 3) == 3 def test_shortest_path_4x5(): assert shortest_path(4, 5) == 35 def test_shortest_path_5x5(): assert shortest_path(5, 5) == 70 def test_shortest_path_1x1(): assert shortest_path(1, 1) == 1 def test_shortest_path_1xN(): assert shortest_path(1, 10) == 1 def test_shortest_path_Nx1(): assert shortest_path(10, 1) == 1 def test_shortest_path_large_case(): assert shortest_path(10, 10) == 48620","solution":"def shortest_path(n: int, m: int) -> int: Function to calculate the number of distinct shortest paths from the top-left corner to the bottom-right corner of an n x m grid. You can only move right or down at any point in time. # Create a 2D list to store the count of paths at each cell dp = [[0] * m for _ in range(n)] # We know the following: # There is only 1 way to reach any cell in the first row (only right moves) for i in range(m): dp[0][i] = 1 # There is only 1 way to reach any cell in the first column (only down moves) for i in range(n): dp[i][0] = 1 # Fill out the rest of the grid using previous computed values for i in range(1, n): for j in range(1, m): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[n-1][m-1]"},{"question":"def update_inventory(books: list[str], transactions: list[tuple[str, str]]) -> list[str]: Update the inventory of books based on the transactions. :param books: list[str] - List of books initially in the library. :param transactions: list[tuple[str, str]] - List of tuples where each tuple contains the book title and the transaction type ('borrow' or 'return'). :return: list[str] - Updated list of books currently available in the library.","solution":"def update_inventory(books: list[str], transactions: list[tuple[str, str]]) -> list[str]: Update the inventory of books based on the transactions. :param books: list[str] - List of books initially in the library. :param transactions: list[tuple[str, str]] - List of tuples where each tuple contains the book title and the transaction type ('borrow' or 'return'). :return: list[str] - Updated list of books currently available in the library. available_books = set(books) for title, action in transactions: if action == 'borrow': available_books.discard(title) elif action == 'return': available_books.add(title) return sorted(list(available_books))"},{"question":"from typing import List, Tuple def balance_alert(balances: List[Tuple[str, float]], threshold: float) -> List[str]: Evaluates the balance data and returns the dates when the balance exceeded the given threshold. :param balances: List of tuples with date and balance :param threshold: Float representing the threshold balance value :return: List of dates when the balance exceeded the given threshold >>> balance_alert([(\\"2023-01-01\\", 1500.00), (\\"2023-01-02\\", 2500.50), (\\"2023-01-03\\", 1200.00), (\\"2023-01-04\\", 1000.00)], 2000.00) ['2023-01-02'] >>> balance_alert([(\\"2023-01-01\\", 2500.00), (\\"2023-01-02\\", 3000.00), (\\"2023-01-03\\", 1000.00), (\\"2023-01-04\\", 2200.00)], 2000.00) ['2023-01-01', '2023-01-02', '2023-01-04'] >>> balance_alert([(\\"2023-01-01\\", 1500.00), (\\"2023-01-02\\", 1800.00), (\\"2023-01-03\\", 1200.00), (\\"2023-01-04\\", 1000.00)], 2000.00) [] >>> balance_alert([(\\"2023-01-01\\", 2500.00), (\\"2023-01-02\\", 2700.00), (\\"2023-01-03\\", 3000.00), (\\"2023-01-04\\", 4000.00)], 2000.00) ['2023-01-01', '2023-01-02', '2023-01-03', '2023-01-04'] >>> balance_alert([], 2000.00) [] >>> balance_alert([(\\"2023-01-01\\", -1500.00), (\\"2023-01-02\\", -500.00), (\\"2023-01-03\\", 2500.00), (\\"2023-01-04\\", 1000.00)], 2000.00) ['2023-01-03']","solution":"from typing import List, Tuple def balance_alert(balances: List[Tuple[str, float]], threshold: float) -> List[str]: Evaluates the balance data and returns the dates when the balance exceeded the given threshold. :param balances: List of tuples with date and balance :param threshold: Float representing the threshold balance value :return: List of dates when the balance exceeded the given threshold exceeded_dates = [date for date, balance in balances if balance > threshold] return exceeded_dates"},{"question":"def smallest_integer_product(d: int) -> int: Calculate the smallest positive integer x such that the product of its digits equals d. >>> smallest_integer_product(36) 49 >>> smallest_integer_product(10) 25 >>> smallest_integer_product(15) 35 >>> smallest_integer_product(1) 1 >>> smallest_integer_product(0) -1","solution":"def smallest_integer_product(d: int) -> int: if d == 1: return 1 if d == 0: return -1 factors = [] # Decompose d into its prime factors from 9 to 2 for i in range(9, 1, -1): while d % i == 0: factors.append(i) d //= i # If d is not 1 after factorization, then it's not possible if d != 1: return -1 # Sort factors to create the smallest possible number factors.sort() # Combine these factors to form the smallest possible number result = int(''.join(map(str, factors))) return result"},{"question":"from typing import List, Union, Callable, Optional def optimized_transform( data: List[Union[float, int]], transform1: Optional[Callable[[float], float]] = None, transform2: Optional[Callable[[float], float]] = None, transform3: Optional[Callable[[float], float]] = None, transform4: Optional[Callable[[float], float]] = None, inPlace: bool = False ) -> Optional[List[Union[float, int]]]: Applies up to four transformations to the list of numbers. Parameters: - data: List of numbers (floats or integers) - transform1, transform2, transform3, transform4: Optional transformation functions - inPlace: If True, modifies the original list; otherwise, returns a new list Returns: - Transformed list if \`inPlace\` is False; otherwise, returns None >>> def scale(x: float) -> float: return x * 2 >>> def shift(x: float) -> float: return x + 3 >>> data = [1, 2, 3, 4, 5] >>> optimized_transform(data, transform1=scale, transform2=shift, inPlace=False) [5, 7, 9, 11, 13] >>> optimized_transform(data, transform1=scale, transform2=shift, inPlace=True) None >>> data [5, 7, 9, 11, 13] >>> def square(x: float) -> float: return x * x >>> optimized_transform([1, 2, 3, 4], transform1=square) [1.0, 4.0, 9.0, 16.0] >>> def invalid_transform(x: float) -> float: raise ValueError(\\"Invalid transformation\\") >>> try: optimized_transform([1, 2, 3], transform1=invalid_transform) ... except ValueError: pass","solution":"from typing import List, Union, Callable, Optional def optimized_transform( data: List[Union[float, int]], transform1: Optional[Callable[[float], float]] = None, transform2: Optional[Callable[[float], float]] = None, transform3: Optional[Callable[[float], float]] = None, transform4: Optional[Callable[[float], float]] = None, inPlace: bool = False ) -> Optional[List[Union[float, int]]]: Applies up to four transformations to the list of numbers. Parameters: - data: List of numbers (floats or integers) - transform1, transform2, transform3, transform4: Optional transformation functions - inPlace: If True, modifies the original list; otherwise, returns a new list Returns: - Transformed list if \`inPlace\` is False; otherwise, returns None def apply_transforms(value): for transform in (transform1, transform2, transform3, transform4): if transform is not None: value = transform(value) return value if inPlace: for i in range(len(data)): data[i] = apply_transforms(float(data[i])) return None else: return [apply_transforms(float(x)) for x in data]"},{"question":"from typing import List def find_unique_element(arr: List[int]) -> int: Given an array of integers where each element appears twice except for one element which appears only once, find that unique element. Args: arr (List[int]): List of integers with exactly one unique element. Returns: int: The unique element that appears only once. Examples: >>> find_unique_element([2, 3, 5, 4, 5, 3, 4]) 2 >>> find_unique_element([1, 2, 3, 2, 3]) 1 >>> find_unique_element([0, 1, 0]) 1","solution":"from typing import List def find_unique_element(arr: List[int]) -> int: Returns the unique element that appears only once in the array. unique_element = 0 # XOR all elements. The duplicates will cancel out leaving the unique element. for num in arr: unique_element ^= num return unique_element"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = TreeNode(key) else: self._insert(root.left, key) else: if root.right is None: root.right = TreeNode(key) else: self._insert(root.right, key) def height(self): Compute the height of the binary search tree. >>> bst = BinarySearchTree() >>> bst.insert(10) >>> bst.insert(5) >>> bst.insert(15) >>> bst.height() 1 >>> bst = BinarySearchTree() >>> bst.height() -1 pass def in_order_traversal(self): Perform an in-order traversal of the tree and return the elements in sorted order. >>> bst = BinarySearchTree() >>> bst.insert(10) >>> bst.insert(5) >>> bst.insert(15) >>> bst.in_order_traversal() [5, 10, 15] >>> bst = BinarySearchTree() >>> bst.in_order_traversal() [] pass def test_height(): bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) bst.insert(12) bst.insert(20) assert bst.height() == 2 def test_in_order_traversal(): bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) bst.insert(12) bst.insert(20) assert bst.in_order_traversal() == [3, 5, 7, 10, 12, 15, 20] def test_height_empty_tree(): bst = BinarySearchTree() assert bst.height() == -1 def test_in_order_traversal_empty_tree(): bst = BinarySearchTree() assert bst.in_order_traversal() == [] def test_height_single_node(): bst = BinarySearchTree() bst.insert(10) assert bst.height() == 0 def test_in_order_traversal_single_node(): bst = BinarySearchTree() bst.insert(10) assert bst.in_order_traversal() == [10]","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = TreeNode(key) else: self._insert(root.left, key) else: if root.right is None: root.right = TreeNode(key) else: self._insert(root.right, key) def height(self): return self._height(self.root) def _height(self, node): if node is None: return -1 left_height = self._height(node.left) right_height = self._height(node.right) return 1 + max(left_height, right_height) def in_order_traversal(self): elements = [] self._in_order_traversal(self.root, elements) return elements def _in_order_traversal(self, root, elements): if root: self._in_order_traversal(root.left, elements) elements.append(root.val) self._in_order_traversal(root.right, elements)"},{"question":"class Inventory: Manages the inventory of books in a bookstore chain. Methods: - add_book: Adds a new book to the inventory or updates the quantity if the book already exists. - update_stock: Updates the stock quantity of a given book in a specific store. - get_stock: Retrieves the current stock of a given book in a specific store. - transfer_stock: Transfers a certain quantity of books from one store to another. def __init__(self): # Initializes an empty inventory pass def add_book(self, isbn: str, title: str, author: str, store: str, quantity: int): Adds a new book to the inventory or updates the quantity if the book already exists. pass def update_stock(self, isbn: str, store: str, quantity: int): Updates the stock quantity of a given book in a specific store. pass def get_stock(self, isbn: str, store: str) -> int: Retrieves the current stock of a given book in a specific store. pass def transfer_stock(self, isbn: str, from_store: str, to_store: str, quantity: int): Transfers a certain quantity of books from one store to another. pass # Unit Tests def test_add_book(): inventory = Inventory() inventory.add_book(\\"978-3-16-148410-0\\", \\"Book Title\\", \\"Author Name\\", \\"Store A\\", 10) assert inventory.get_stock(\\"978-3-16-148410-0\\", \\"Store A\\") == 10 def test_update_stock(): inventory = Inventory() inventory.add_book(\\"978-3-16-148410-0\\", \\"Book Title\\", \\"Author Name\\", \\"Store A\\", 10) inventory.update_stock(\\"978-3-16-148410-0\\", \\"Store A\\", 5) assert inventory.get_stock(\\"978-3-16-148410-0\\", \\"Store A\\") == 15 # Decrease the stock inventory.update_stock(\\"978-3-16-148410-0\\", \\"Store A\\", -3) assert inventory.get_stock(\\"978-3-16-148410-0\\", \\"Store A\\") == 12 def test_transfer_stock(): inventory = Inventory() inventory.add_book(\\"978-3-16-148410-0\\", \\"Book Title\\", \\"Author Name\\", \\"Store A\\", 10) inventory.add_book(\\"978-3-16-148410-0\\", \\"Book Title\\", \\"Author Name\\", \\"Store B\\", 5) inventory.transfer_stock(\\"978-3-16-148410-0\\", \\"Store A\\", \\"Store B\\", 3) assert inventory.get_stock(\\"978-3-16-148410-0\\", \\"Store A\\") == 7 assert inventory.get_stock(\\"978-3-16-148410-0\\", \\"Store B\\") == 8 def test_negative_quantity_transfer(): inventory = Inventory() inventory.add_book(\\"978-3-16-148410-0\\", \\"Book Title\\", \\"Author Name\\", \\"Store A\\", 10) try: inventory.transfer_stock(\\"978-3-16-148410-0\\", \\"Store A\\", \\"Store B\\", 11) except ValueError as e: assert str(e) == \\"Stock for 978-3-16-148410-0 in Store A cannot be negative\\" def test_invalid_isbn_store(): inventory = Inventory() inventory.add_book(\\"978-3-16-148410-0\\", \\"Book Title\\", \\"Author Name\\", \\"Store A\\", 10) try: inventory.get_stock(\\"123-4-56-789012-3\\", \\"Store A\\") except ValueError as e: assert str(e) == \\"Book with ISBN 123-4-56-789012-3 not in the inventory or store Store A does not exist\\" try: inventory.update_stock(\\"978-3-16-148410-0\\", \\"Store B\\", 5) except ValueError as e: assert str(e) == \\"Book with ISBN 978-3-16-148410-0 not in the inventory or store Store B does not exist\\"","solution":"class Inventory: def __init__(self): self.inventory = {} def add_book(self, isbn: str, title: str, author: str, store: str, quantity: int): if isbn not in self.inventory: self.inventory[isbn] = { 'title': title, 'author': author, 'stores': {} } if store not in self.inventory[isbn]['stores']: self.inventory[isbn]['stores'][store] = 0 self.inventory[isbn]['stores'][store] += quantity def update_stock(self, isbn: str, store: str, quantity: int): if isbn in self.inventory and store in self.inventory[isbn]['stores']: new_quantity = self.inventory[isbn]['stores'][store] + quantity if new_quantity < 0: raise ValueError(f\\"Stock for {isbn} in {store} cannot be negative\\") self.inventory[isbn]['stores'][store] = new_quantity else: raise ValueError(f\\"Book with ISBN {isbn} not in the inventory or store {store} does not exist\\") def get_stock(self, isbn: str, store: str) -> int: if isbn in self.inventory and store in self.inventory[isbn]['stores']: return self.inventory[isbn]['stores'][store] else: raise ValueError(f\\"Book with ISBN {isbn} not in the inventory or store {store} does not exist\\") def transfer_stock(self, isbn: str, from_store: str, to_store: str, quantity: int): if quantity < 0: raise ValueError(\\"Quantity must be a positive integer\\") self.update_stock(isbn, from_store, -quantity) self.update_stock(isbn, to_store, quantity)"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Calculates the maximum profit from one buy and one sell transaction. If no profit can be made, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([7, 1, 5, 3, 6, 4, 8]) 7 >>> max_profit([1]) 0 >>> max_profit([]) 0 >>> max_profit([2, 3, 1, 8, 10, 7, 13]) 12 >>> max_profit([10, 7, 8, 9, 1, 6, 9]) 8","solution":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved from a single buy and sell transaction. If no profit can be made, returns 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root: Optional[TreeNode]) -> List[int]: Given a binary tree, return the values of the nodes you can see ordered from top to bottom. >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, None, TreeNode(6))) >>> right_side_view(root) [1, 3, 6] >>> root = TreeNode(1, TreeNode(2, None, TreeNode(5)), TreeNode(3)) >>> right_side_view(root) [1, 3, 5] >>> root = TreeNode(1) >>> right_side_view(root) [1]","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root: Optional[TreeNode]) -> List[int]: if not root: return [] queue = deque([root]) right_side = [] while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() if i == level_length - 1: # last node in the current level right_side.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return right_side"},{"question":"class Polynomial: def __init__(self, coefficients: list): Initializes the polynomial with the given coefficients. def add(self, other: 'Polynomial') -> 'Polynomial': Adds two polynomials and returns a new polynomial. >>> p1 = Polynomial([1, 2, 3]) >>> p2 = Polynomial([3, 4]) >>> p3 = p1.add(p2) >>> p3.coefficients [4, 6, 3] def multiply(self, other: 'Polynomial') -> 'Polynomial': Multiplies two polynomials and returns a new polynomial. >>> p1 = Polynomial([1, 2, 3]) >>> p2 = Polynomial([3, 4]) >>> p3 = p1.multiply(p2) >>> p3.coefficients [3, 10, 17, 12] def __str__(self) -> str: Returns the polynomial as a formatted string. >>> p = Polynomial([1, 2, 3]) >>> str(p) '1 + 2x + 3x^2'","solution":"class Polynomial: def __init__(self, coefficients: list): self.coefficients = coefficients def add(self, other: 'Polynomial') -> 'Polynomial': max_len = max(len(self.coefficients), len(other.coefficients)) # Extend shorter list with zeros new_coeffs = [0] * max_len for i in range(max_len): if i < len(self.coefficients): new_coeffs[i] += self.coefficients[i] if i < len(other.coefficients): new_coeffs[i] += other.coefficients[i] return Polynomial(new_coeffs) def multiply(self, other: 'Polynomial') -> 'Polynomial': result_len = len(self.coefficients) + len(other.coefficients) - 1 new_coeffs = [0] * result_len for i in range(len(self.coefficients)): for j in range(len(other.coefficients)): new_coeffs[i + j] += self.coefficients[i] * other.coefficients[j] return Polynomial(new_coeffs) def __str__(self) -> str: terms = [] for i, coef in enumerate(self.coefficients): if coef != 0: if i == 0: terms.append(f\\"{coef}\\") else: terms.append(f\\"{coef}x^{i}\\" if i > 1 else f\\"{coef}x\\") return \\" + \\".join(terms) if terms else \\"0\\""},{"question":"from typing import List, Optional def max_product_of_three(arr: List[int]) -> Optional[int]: Find the maximum product of any three numbers in the array. >>> max_product_of_three([1, 2, 3, 4]) 24 >>> max_product_of_three([-10, -10, 5, 2]) 500 >>> max_product_of_three([1, 2, 3]) 6 >>> max_product_of_three([-1, -2, -3, -4]) -6 >>> max_product_of_three([1]) None","solution":"from typing import List, Optional def max_product_of_three(arr: List[int]) -> Optional[int]: if len(arr) < 3: return None arr.sort() return max(arr[0] * arr[1] * arr[-1], arr[-1] * arr[-2] * arr[-3]) # Examples given in the problem statement: assert max_product_of_three([1, 2, 3, 4]) == 24 assert max_product_of_three([-10, -10, 5, 2]) == 500 assert max_product_of_three([1, 2, 3]) == 6 assert max_product_of_three([-1, -2, -3, -4]) == -6 assert max_product_of_three([1]) == None"},{"question":"def letter_combinations(digits: str) -> list: Return all possible letter combinations that the input number could represent. >>> letter_combinations(\\"\\") [] >>> letter_combinations(\\"2\\") [\\"a\\", \\"b\\", \\"c\\"] >>> letter_combinations(\\"23\\") [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] >>> letter_combinations(\\"234\\") [\\"adg\\", \\"adh\\", \\"adi\\", \\"aeg\\", \\"aeh\\", \\"aei\\", \\"afg\\", \\"afh\\", \\"afi\\", \\"bdg\\", \\"bdh\\", \\"bdi\\", \\"beg\\", \\"beh\\", \\"bei\\", \\"bfg\\", \\"bfh\\", \\"bfi\\", \\"cdg\\", \\"cdh\\", \\"cdi\\", \\"ceg\\", \\"ceh\\", \\"cei\\", \\"cfg\\", \\"cfh\\", \\"cfi\\"] >>> letter_combinations(\\"2345\\") [\\"adgj\\", \\"adgk\\", \\"adgl\\", \\"adhj\\", \\"adhk\\", \\"adhl\\", \\"adij\\", \\"adik\\", \\"adil\\", \\"aegj\\", \\"aegk\\", \\"aegl\\", \\"aehj\\", \\"aehk\\", \\"aehl\\", \\"aeij\\", \\"aeik\\", \\"aeil\\", \\"afgj\\", \\"afgk\\", \\"afgl\\", \\"afhj\\", \\"afhk\\", \\"afhl\\", \\"afij\\", \\"afik\\", \\"afil\\", \\"bdgj\\", \\"bdgk\\", \\"bdgl\\", \\"bdhj\\", \\"bdhk\\", \\"bdhl\\", \\"bdij\\", \\"bdik\\", \\"bdil\\", \\"begj\\", \\"begk\\", \\"begl\\", \\"behj\\", \\"behk\\", \\"behl\\", \\"beij\\", \\"beik\\", \\"beil\\", \\"bfgj\\", \\"bfgk\\", \\"bfgl\\", \\"bfhj\\", \\"bfhk\\", \\"bfhl\\", \\"bfij\\", \\"bfik\\", \\"bfil\\", \\"cdgj\\", \\"cdgk\\", \\"cdgl\\", \\"cdhj\\", \\"cdhk\\", \\"cdhl\\", \\"cdij\\", \\"cdik\\", \\"cdil\\", \\"cegj\\", \\"cegk\\", \\"cegl\\", \\"cehj\\", \\"cehk\\", \\"cehl\\", \\"ceij\\", \\"ceik\\", \\"ceil\\", \\"cfgj\\", \\"cfgk\\", \\"cfgl\\", \\"cfhj\\", \\"cfhk\\", \\"cfhl\\", \\"cfij\\", \\"cfik\\", \\"cfil\\"]","solution":"def letter_combinations(digits: str) -> list: if not digits: return [] # Mapping of digits to corresponding letters phone_map = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } def backtrack(index, path): # If the current combination path has the same length as digits, we found a combination if len(path) == len(digits): combinations.append(\\"\\".join(path)) return # Get the letters that the current digit maps to, and loop through them possible_letters = phone_map[digits[index]] for letter in possible_letters: # Add the letter to the current combination path path.append(letter) # Move on to the next digit backtrack(index + 1, path) # Backtrack by removing the letter before moving onto the next path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"from typing import List, Tuple def shortest_delivery_route(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Find the shortest route to visit all delivery points once and return to the starting point using the nearest neighbor heuristic. Args: points (List[Tuple[int, int]]): A list of tuples representing the (x, y) coordinates of the delivery points. Returns: List[Tuple[int, int]]: A list of tuples representing the coordinates of the points in the order of the shortest route. >>> shortest_delivery_route([(0, 0), (1, 1), (2, 2)]) [(0, 0), (1, 1), (2, 2), (0, 0)] >>> shortest_delivery_route([(2, 3), (5, 4), (1, 1)]) [(2, 3), (1, 1), (5, 4), (2, 3)] >>> shortest_delivery_route([(0, 0), (2, 2), (2, 0), (0, 2)]) [(0, 0), (2, 0), (2, 2), (0, 2), (0, 0)]","solution":"from typing import List, Tuple import math def distance(point1: Tuple[int, int], point2: Tuple[int, int]) -> float: return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) def shortest_delivery_route(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: if len(points) <= 1: return points + points start = points[0] route = [start] remaining_points = set(points) remaining_points.remove(start) current_point = start while remaining_points: next_point = min(remaining_points, key=lambda point: distance(current_point, point)) route.append(next_point) remaining_points.remove(next_point) current_point = next_point route.append(start) # Return to the starting point return route"},{"question":"def in_place_merge_sort(arr: list[int]) -> None: In-Place Merge Sort Implementation. Merge sort is a divide-and-conquer algorithm that divides the input array into two halves, recursively sorts them, and then merges the two sorted halves in place without using extra space. Args: arr (list[int]): The array of integers to be sorted. Returns: None: The array is sorted in place. Examples: >>> arr = [5, 2, 7] >>> in_place_merge_sort(arr) >>> print(arr) [2, 5, 7] >>> arr = [1, 1, 2, 2, 3] >>> in_place_merge_sort(arr) >>> print(arr) [1, 1, 2, 2, 3] >>> arr = [10, 9, 8, 7, 6] >>> in_place_merge_sort(arr) >>> print(arr) [6, 7, 8, 9, 10] >>> arr = [15, 10, 20, 5, 3, 8, 12, 25] >>> in_place_merge_sort(arr) >>> print(arr) [3, 5, 8, 10, 12, 15, 20, 25]","solution":"def merge(arr, start, mid, end): start2 = mid + 1 if arr[mid] <= arr[start2]: # Already in place return while start <= mid and start2 <= end: if arr[start] <= arr[start2]: start += 1 else: value = arr[start2] index = start2 while index != start: arr[index] = arr[index - 1] index -= 1 arr[start] = value start += 1 mid += 1 start2 += 1 def in_place_merge_sort_helper(arr, l, r): if l < r: m = l + (r - l) // 2 in_place_merge_sort_helper(arr, l, m) in_place_merge_sort_helper(arr, m + 1, r) merge(arr, l, m, r) def in_place_merge_sort(arr): if not arr or len(arr) == 1: return in_place_merge_sort_helper(arr, 0, len(arr) - 1)"},{"question":"def find_anagram_pairs(strings: list) -> list: Given a list of strings, find all pairs of strings that are anagrams of each other. >>> find_anagram_pairs([]) [] >>> find_anagram_pairs(['abc']) [] >>> find_anagram_pairs(['abc', 'bca']) [('abc', 'bca')] >>> find_anagram_pairs(['abc', 'bca', 'xyz', 'yxz', 'zxy']) [('abc', 'bca'), ('xyz', 'yxz'), ('xyz', 'zxy'), ('yxz', 'zxy')] >>> find_anagram_pairs(['abc', 'def', 'ghi']) []","solution":"def find_anagram_pairs(strings): Given a list of strings, find all pairs of strings that are anagrams of each other. Args: strings (list of str): A list containing n strings. Returns: list of tuples: A list containing tuples, where each tuple has two strings that are anagrams of each other. # Helper function to check if two strings are anagrams def are_anagrams(s1, s2): return sorted(s1) == sorted(s2) anagram_pairs = [] length = len(strings) for i in range(length): for j in range(i + 1, length): if are_anagrams(strings[i], strings[j]): anagram_pairs.append((strings[i], strings[j])) return anagram_pairs"},{"question":"import json from typing import Dict, Any def analyze_logs(file_path: str) -> Dict[str, Any]: Analyze application error logs and summarize the information. Args: file_path (str): The path to the log file. Returns: dict: A dictionary with the following keys: - total_entries: Total number of log entries processed. - error_counts: A dictionary where keys are error codes and values are the count of occurrences of each error code. - most_common_error: The error code that appears the most frequently, and the number of times it appears. Examples: >>> content = ''' ... {\\"timestamp\\": \\"2023-10-01T12:00:00Z\\", \\"error_code\\": \\"ERR001\\", \\"message\\": \\"Null pointer exception\\"} ... {\\"timestamp\\": \\"2023-10-01T12:05:00Z\\", \\"error_code\\": \\"ERR002\\", \\"message\\": \\"Index out of range\\"} ... {\\"timestamp\\": \\"2023-10-01T12:10:00Z\\", \\"error_code\\": \\"ERR001\\", \\"message\\": \\"Null pointer exception\\"} ... {\\"timestamp\\": \\"2023-10-01T12:15:00Z\\", \\"error_code\\": \\"ERR003\\", \\"message\\": \\"Database connection error\\"} ... ''' >>> with open('logs.txt', 'w') as f: ... f.write(content) >>> analyze_logs('logs.txt') { \\"total_entries\\": 4, \\"error_counts\\": { \\"ERR001\\": 2, \\"ERR002\\": 1, \\"ERR003\\": 1 }, \\"most_common_error\\": (\\"ERR001\\", 2) }","solution":"import json from collections import defaultdict def analyze_logs(file_path: str) -> dict: total_entries = 0 error_counts = defaultdict(int) try: with open(file_path, 'r') as file: for line in file: total_entries += 1 log_entry = json.loads(line) if 'error_code' in log_entry: error_counts[log_entry['error_code']] += 1 if not error_counts: most_common_error = None else: most_common_error = max(error_counts.items(), key=lambda item: item[1]) return { \\"total_entries\\": total_entries, \\"error_counts\\": dict(error_counts), \\"most_common_error\\": most_common_error } except FileNotFoundError: return { \\"total_entries\\": 0, \\"error_counts\\": {}, \\"most_common_error\\": None } except json.JSONDecodeError: return { \\"total_entries\\": total_entries, \\"error_counts\\": dict(error_counts), \\"most_common_error\\": None }"},{"question":"def rotate_matrix(matrix: list[list[int]], direction: str) -> list[list[int]]: Rotate an NxN matrix by 90 degrees in the given direction. Args: matrix (list[list[int]]): The NxN matrix to be rotated. direction (str): The direction of rotation; either 'clockwise' or 'counterclockwise'. Returns: list[list[int]]: The rotated matrix. >>> rotate_matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ], \\"clockwise\\") [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ], \\"counterclockwise\\") [[3, 6, 9], [2, 5, 8], [1, 4, 7]]","solution":"def rotate_matrix(matrix: list[list[int]], direction: str) -> list[list[int]]: Rotate an NxN matrix by 90 degrees in the given direction. Args: matrix (list[list[int]]): The NxN matrix to be rotated. direction (str): The direction of rotation; either 'clockwise' or 'counterclockwise'. Returns: list[list[int]]: The rotated matrix. N = len(matrix) rotated_matrix = [[0] * N for _ in range(N)] if direction == \\"clockwise\\": for i in range(N): for j in range(N): rotated_matrix[j][N-1-i] = matrix[i][j] elif direction == \\"counterclockwise\\": for i in range(N): for j in range(N): rotated_matrix[N-1-j][i] = matrix[i][j] else: raise ValueError(\\"Invalid direction. Use 'clockwise' or 'counterclockwise'.\\") return rotated_matrix"},{"question":"from typing import List def longest_decreasing_subsequence(arr: List[int]) -> int: Determine the length of the longest subsequence such that the numbers in the subsequence are strictly in decreasing order. >>> longest_decreasing_subsequence([9, 4, 3, 2, 5, 4, 3, 2]) 5 >>> longest_decreasing_subsequence([1, 2, 3, 4, 5]) 1 >>> longest_decreasing_subsequence([5, 3, 4, 4, 2]) 3","solution":"from typing import List def longest_decreasing_subsequence(arr: List[int]) -> int: if not arr: return 0 n = len(arr) dp = [1] * n # Each element is a subsequence of length 1 by itself for i in range(1, n): for j in range(i): if arr[j] > arr[i]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"import numpy as np def polynomial_regression_predict(train_X, train_Y, val_X, val_Y, degree=2): Predict the exam score based on the number of study hours using Polynomial Regression. :param train_X: List[float] - Study Hours feature for training :param train_Y: List[float] - Exam Scores target for training :param val_X: List[float] - Study Hours feature for validation :param val_Y: List[float] - Exam Scores target for validation :param degree: int - Degree of the polynomial to fit :return: float - Mean absolute error on validation data >>> train_X = [1, 2, 3, 4, 5] >>> train_Y = [55, 60, 65, 70, 75] >>> val_X = [6, 8] >>> val_Y = [80, 90] >>> polynomial_regression_predict(train_X, train_Y, val_X, val_Y, degree=2) < 5 >>> train_X = [1, 2, 3, 4, 5] >>> train_Y = [2, 4, 6, 8, 10] >>> val_X = [6, 7, 8] >>> val_Y = [12, 14, 16] >>> polynomial_regression_predict(train_X, train_Y, val_X, val_Y, degree=1) < 1e-5 >>> train_X = [1, 2, 3, 4, 5] >>> train_Y = [1, 4, 9, 16, 25] >>> val_X = [6, 7] >>> val_Y = [36, 49] >>> polynomial_regression_predict(train_X, train_Y, val_X, val_Y, degree=2) < 1e-5 >>> train_X = [1, 2, 3, 4, 5] >>> train_Y = [1.1, 3.9, 9.2, 15.8, 25.1] >>> val_X = [6, 7] >>> val_Y = [36, 49] >>> polynomial_regression_predict(train_X, train_Y, val_X, val_Y, degree=2) < 2 >>> train_X = [1, 2, 3, 4, 5] >>> train_Y = [2, 4, 6, 8, 10] >>> val_X = [6, 7, 8] >>> val_Y = [12, 14, 16] >>> polynomial_regression_predict(train_X, train_Y, val_X, val_Y, degree=3) < 1e-5 # Implementation here","solution":"import numpy as np def polynomial_regression_predict(train_X, train_Y, val_X, val_Y, degree=2): :param train_X: List[float] - Study Hours feature for training :param train_Y: List[float] - Exam Scores target for training :param val_X: List[float] - Study Hours feature for validation :param val_Y: List[float] - Exam Scores target for validation :param degree: int - Degree of the polynomial to fit :return: float - Mean absolute error on validation data # Convert lists to numpy arrays train_X = np.array(train_X) train_Y = np.array(train_Y) val_X = np.array(val_X) val_Y = np.array(val_Y) # Create polynomial features for training data X_poly = np.vander(train_X, degree + 1, increasing=True) # Calculate weights using normal equation method theta = np.linalg.inv(X_poly.T.dot(X_poly)).dot(X_poly.T).dot(train_Y) # Create polynomial features for validation data val_X_poly = np.vander(val_X, degree + 1, increasing=True) # Predict on validation data val_pred = val_X_poly.dot(theta) # Calculate Mean Absolute Error (MAE) mae = np.mean(np.abs(val_pred - val_Y)) return mae"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given \`n x n\` matrix by 90 degrees clockwise. Parameters: matrix (List[List[int]]): The input \`n x n\` matrix to be rotated. Returns: List[List[int]]: The rotated matrix. Raises: ValueError: If the input matrix is not \`n x n\`. Example: >>> matrix1 = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix1) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix2 = [ ... [5, 1, 9, 11], ... [2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotate_matrix(matrix2) [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] pass def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix(matrix) == expected def test_rotate_4x4_matrix(): matrix = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] expected = [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] assert rotate_matrix(matrix) == expected def test_rotate_1x1_matrix(): matrix = [ [1] ] expected = [ [1] ] assert rotate_matrix(matrix) == expected def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] expected = [ [3, 1], [4, 2] ] assert rotate_matrix(matrix) == expected def test_invalid_input_not_nxn(): import pytest with pytest.raises(ValueError): rotate_matrix([[1, 2, 3], [4, 5, 6]])","solution":"def rotate_matrix(matrix): Rotates the given \`n x n\` matrix by 90 degrees clockwise. Parameters: matrix (List[List[int]]): The input \`n x n\` matrix to be rotated. Returns: List[List[int]]: The rotated matrix. Raises: ValueError: If the input matrix is not \`n x n\`. if not matrix or not matrix[0] or len(matrix) != len(matrix[0]): raise ValueError(\\"The input matrix is not an n x n matrix.\\") n = len(matrix) for layer in range(n // 2): first = layer last = n - layer - 1 for i in range(first, last): offset = i - first top = matrix[first][i] # Move left to top matrix[first][i] = matrix[last - offset][first] # Move bottom to left matrix[last - offset][first] = matrix[last][last - offset] # Move right to bottom matrix[last][last - offset] = matrix[i][last] # Move top to right matrix[i][last] = top return matrix"},{"question":"def custom_sort(lst: list, criteria: list) -> list: Given a list of integers, perform multiple sorting operations based on the given criteria and then concatenate the results. >>> custom_sort([4, 5, 3, 2, 8, 1, 7], [(1, 3, True), (0, 4, False), (5, 6, True)]) [2, 3, 5, 8, 5, 4, 3, 2, 1, 7] >>> custom_sort([10, 9, 8, 7, 6], [(0, 4, True)]) [6, 7, 8, 9, 10] >>> custom_sort([1, 2, 3, 4, 5], [(0, 4, False)]) [5, 4, 3, 2, 1] >>> custom_sort([10, 20, 30, 40, 50, 60], [(1, 2, True), (3, 5, True)]) [20, 30, 40, 50, 60] >>> custom_sort([100, 90, 80, 70, 60, 50], [(0, 1, False), (4, 5, False)]) [100, 90, 60, 50] >>> custom_sort([13, 42, 8, 23, 17, 9, 3], [(0, 2, True), (3, 6, False)]) [8, 13, 42, 23, 17, 9, 3]","solution":"def custom_sort(lst: list, criteria: list) -> list: sorted_sublists = [] for start_index, end_index, ascending in criteria: sublist = lst[start_index:end_index+1] sublist.sort(reverse=not ascending) sorted_sublists.extend(sublist) return sorted_sublists"},{"question":"from typing import List, Dict def detect_cycle(nodes: List[str], dependencies: Dict[str, List[str]]) -> bool: Detect if there is a cycle in the task graph. Given a list of tasks and their dependencies, determine if there is a circular dependency. Args: nodes (List[str]): A list of task labels. dependencies (Dict[str, List[str]]): A dictionary where keys are task labels and values are lists of dependencies. Returns: bool: True if there is a cycle, otherwise False. >>> nodes = [\\"Task1\\", \\"Task2\\", \\"Task3\\", \\"Task4\\"] >>> dependencies = { \\"Task1\\": [\\"Task2\\"], \\"Task2\\": [\\"Task3\\"], \\"Task3\\": [\\"Task4\\"], \\"Task4\\": [\\"Task1\\"] # This creates a cycle } >>> detect_cycle(nodes, dependencies) True >>> nodes = [\\"Task1\\", \\"Task2\\", \\"Task3\\"] >>> dependencies = { \\"Task1\\": [\\"Task2\\"], \\"Task2\\": [\\"Task3\\"], \\"Task3\\": [] } >>> detect_cycle(nodes, dependencies) False pass def test_no_cycle(): nodes = [\\"Task1\\", \\"Task2\\", \\"Task3\\"] dependencies = { \\"Task1\\": [\\"Task2\\"], \\"Task2\\": [\\"Task3\\"], \\"Task3\\": [] } assert detect_cycle(nodes, dependencies) == False def test_with_cycle(): nodes = [\\"Task1\\", \\"Task2\\", \\"Task3\\", \\"Task4\\"] dependencies = { \\"Task1\\": [\\"Task2\\"], \\"Task2\\": [\\"Task3\\"], \\"Task3\\": [\\"Task4\\"], \\"Task4\\": [\\"Task1\\"] # This creates a cycle } assert detect_cycle(nodes, dependencies) == True def test_disconnected_graph_with_no_cycle(): nodes = [\\"Task1\\", \\"Task2\\", \\"Task3\\", \\"Task4\\", \\"Task5\\"] dependencies = { \\"Task1\\": [\\"Task2\\"], \\"Task3\\": [\\"Task4\\"], \\"Task5\\": [] } assert detect_cycle(nodes, dependencies) == False def test_disconnected_graph_with_cycle(): nodes = [\\"Task1\\", \\"Task2\\", \\"Task3\\", \\"Task4\\", \\"Task5\\"] dependencies = { \\"Task1\\": [\\"Task2\\"], \\"Task2\\": [\\"Task3\\"], \\"Task3\\": [\\"Task1\\"], # Cycle here \\"Task4\\": [\\"Task5\\"] } assert detect_cycle(nodes, dependencies) == True def test_no_dependencies(): nodes = [\\"Task1\\", \\"Task2\\", \\"Task3\\"] dependencies = {} assert detect_cycle(nodes, dependencies) == False","solution":"from typing import List, Dict def detect_cycle(nodes: List[str], dependencies: Dict[str, List[str]]) -> bool: Detect if there is a cycle in the task graph. Returns True if there is a cycle, otherwise False. def dfs(node, visited, rec_stack): if visited[node] == False: visited[node] = True rec_stack[node] = True for neighbor in dependencies.get(node, []): if visited[neighbor] == False: if dfs(neighbor, visited, rec_stack) == True: return True elif rec_stack[neighbor] == True: return True rec_stack[node] = False return False visited = {node: False for node in nodes} rec_stack = {node: False for node in nodes} for node in nodes: if visited[node] == False: if dfs(node, visited, rec_stack) == True: return True return False"},{"question":"import time from enum import Enum class LightState(Enum): RED = \\"Red\\" YELLOW = \\"Yellow\\" GREEN = \\"Green\\" class TrafficLightController: def __init__(self, time_interval: int): self.time_interval = time_interval self.ns_state = LightState.GREEN self.ew_state = LightState.RED def start(self) -> None: # Simulate the traffic light switching logic here pass def stop(self) -> None: # Stop the simulation pass def get_current_state(self) -> dict: # Return the current state of NS and EW traffic lights pass # Unit Tests def test_initial_state(): controller = TrafficLightController(10) state = controller.get_current_state() assert state == {'NS': 'Green', 'EW': 'Red'} def test_light_switching(): controller = TrafficLightController(1) controller.start() # Allow traffic lights to switch time.sleep(2.5) state = controller.get_current_state() controller.stop() assert state in [{'NS': 'Yellow', 'EW': 'Red'}, {'NS': 'Red', 'EW': 'Green'}, {'NS': 'Yellow', 'EW': 'Green'}] def test_multiple_switches(): controller = TrafficLightController(1) controller.start() # Allow multiple switches time.sleep(7) state = controller.get_current_state() controller.stop() # Given the time interval of 1 second and the first cycle taking 3 seconds to complete, # 7 seconds should end up with 'NS': 'Green', 'EW': 'Red' or 'NS': 'Red', 'EW': 'Green' assert state in [{'NS': 'Green', 'EW': 'Red'}, {'NS': 'Red', 'EW': 'Green'}] def test_stop_function(): controller = TrafficLightController(1) controller.start() # Stop after 1 second time.sleep(1) controller.stop() state = controller.get_current_state() assert state in [{'NS': 'Green', 'EW': 'Red'}, {'NS': 'Yellow', 'EW': 'Red'}, {'NS': 'Red', 'EW': 'Green'}, {'NS': 'Red', 'EW': 'Yellow'}]","solution":"import time from enum import Enum from threading import Thread, Event class LightState(Enum): RED = \\"Red\\" YELLOW = \\"Yellow\\" GREEN = \\"Green\\" class TrafficLightController: def __init__(self, time_interval: int): self.time_interval = time_interval self.ns_state = LightState.GREEN self.ew_state = LightState.RED self.stop_event = Event() self.thread = None def start(self) -> None: self.thread = Thread(target=self._run) self.thread.start() def stop(self) -> None: self.stop_event.set() self.thread.join() def get_current_state(self) -> dict: return { 'NS': self.ns_state.value, 'EW': self.ew_state.value } def _run(self): while not self.stop_event.is_set(): time.sleep(self.time_interval) self._switch_lights() def _switch_lights(self): if self.ns_state == LightState.GREEN: self.ns_state = LightState.YELLOW elif self.ns_state == LightState.YELLOW: self.ns_state = LightState.RED self.ew_state = LightState.GREEN elif self.ew_state == LightState.GREEN: self.ew_state = LightState.YELLOW elif self.ew_state == LightState.YELLOW: self.ew_state = LightState.RED self.ns_state = LightState.GREEN"},{"question":"def reverse_words(sentence: str) -> str: This function takes a sentence and reverses the order of the words. pass # TODO: Write the implementation here def reverse_each_word(sentence: str) -> str: This function takes a sentence and reverses each word in place. pass # TODO: Write the implementation here # Test Cases def test_reverse_words_with_multiple_words(): assert reverse_words('Hello World') == 'World Hello' assert reverse_words('Programming is fun') == 'fun is Programming' def test_reverse_words_with_single_word(): assert reverse_words('Python') == 'Python' def test_reverse_words_with_varied_word_lengths(): assert reverse_words('I love Python programming language') == 'language programming Python love I' def test_reverse_each_word_with_multiple_words(): assert reverse_each_word('Hello World') == 'olleH dlroW' assert reverse_each_word('Programming is fun') == 'gnimmargorP si nuf' def test_reverse_each_word_with_single_word(): assert reverse_each_word('Python') == 'nohtyP' def test_reverse_each_word_with_varied_word_lengths(): assert reverse_each_word('I love Python programming language') == 'I evol nohtyP gnimmargorp egaugnal'","solution":"def reverse_words(sentence: str) -> str: This function takes a sentence and reverses the order of the words. return ' '.join(sentence.split()[::-1]) def reverse_each_word(sentence: str) -> str: This function takes a sentence and reverses each word in place. return ' '.join(word[::-1] for word in sentence.split())"},{"question":"def simulate_worms(width: int, height: int, num_worms: int, steps: int): Simulates worms moving on a grid and prints the final state of the board. >>> simulate_worms(5, 5, 1, 10) ... >>> simulate_worms(10, 10, 2, 20) ... >>> simulate_worms(50, 50, 5, 50) ... >>> simulate_worms(5, 5, 1, 25) ...","solution":"import random def simulate_worms(width, height, num_worms, steps): Simulates worms moving on a grid and prints the final state of the board. # Initialize the board board = [['.' for _ in range(width)] for _ in range(height)] # Directions for the movement patterns directions = { 'A': (0, 1), # Move right 'B': (1, 0), # Move down 'C': [(1, 1), (-1, 1)], # Zig-zag (down-right, up-right) 'D': [(0, 1), (1, 0), (0, -1), (-1, 0)] # Square pattern (right, down, left, up) } # Initialize worms with random positions and patterns worms = [] for _ in range(num_worms): x = random.randint(0, height-1) y = random.randint(0, width-1) pattern = random.choice(['A', 'B', 'C', 'D']) worms.append((x, y, pattern)) def move(worm, direction): x, y, pattern = worm if pattern == 'C': dx, dy = direction[random.randint(0, 1)] elif pattern == 'D': dx, dy = direction[random.randint(0, 3)] else: dx, dy = direction new_x = (x + dx) % height new_y = (y + dy) % width return (new_x, new_y, pattern) for _ in range(steps): new_worms = [] for worm in worms: x, y, pattern = worm board[x][y] = '*' worm = move(worm, directions[pattern]) new_worms.append(worm) worms = new_worms # Print the final board state for row in board: print(''.join(row))"},{"question":"def staircase_tiles(n: int) -> int: Calculates the total number of tiles required for a staircase with n steps. The number of tiles in each step is a perfect square starting from 1^2. Args: n (int): The number of steps in the staircase. Returns: int: The total number of tiles needed. pass def test_staircase_tiles_one_step(): assert staircase_tiles(1) == 1 def test_staircase_tiles_two_steps(): assert staircase_tiles(2) == 5 def test_staircase_tiles_three_steps(): assert staircase_tiles(3) == 14 def test_staircase_tiles_four_steps(): assert staircase_tiles(4) == 30 def test_staircase_tiles_large_step(): assert staircase_tiles(1000) == 333833500 def test_staircase_tiles_upper_bound(): assert staircase_tiles(10**6) == 333333833333500000 def test_staircase_tiles_edge_case(): assert staircase_tiles(0) == 0 # should handle minimum step value (though n is given to be  1)","solution":"def staircase_tiles(n: int) -> int: Calculates the total number of tiles required for a staircase with n steps. The number of tiles in each step is a perfect square starting from 1^2. Args: n (int): The number of steps in the staircase. Returns: int: The total number of tiles needed. return n * (n + 1) * (2 * n + 1) // 6"},{"question":"def median_stream(numbers_iter: Iterator[float]) -> Iterator[float]: Compute the median of numbers from a stream. Parameters: numbers_iter (Iterator[float]): An iterator providing a sequence of numbers. Returns: Iterator[float]: An iterator that yields the median for each added number in the input sequence. >>> list(median_stream(iter([2.0, 5, 3, 8, 6, 9, 10]))) [2.0, 3.5, 3.0, 4.0, 5.0, 5.5, 6.0] >>> list(median_stream(iter([1.0, 3.0, 2.0, 4.0]))) [1.0, 2.0, 2.0, 2.5] >>> list(median_stream(iter([10.0]))) [10.0] pass # Test cases from solution import median_stream def test_median_stream_single_number(): assert list(median_stream(iter([10.0]))) == [10.0] def test_median_stream_even_count(): inputs = [1.0, 3.0, 2.0, 4.0] expected = [1.0, 2.0, 2.0, 2.5] assert list(median_stream(iter(inputs))) == expected def test_median_stream_odd_count(): inputs = [1.0, 3.0, 2.0, 4.0, 5.0] expected = [1.0, 2.0, 2.0, 2.5, 3.0] assert list(median_stream(iter(inputs))) == expected def test_median_stream_mixed_numbers(): inputs = [2.0, 5.0, 3.0, 8.0, 6.0, 9.0, 10.0] expected = [2.0, 3.5, 3.0, 4.0, 5.0, 5.5, 6.0] assert list(median_stream(iter(inputs))) == expected def test_median_stream_with_duplicates(): inputs = [3.0, 1.0, 3.0, 1.0, 3.0] expected = [3.0, 2.0, 3.0, 2.0, 3.0] assert list(median_stream(iter(inputs))) == expected def test_median_stream_large_numbers(): inputs = [1000.0, 2000.0, 3000.0] expected = [1000.0, 1500.0, 2000.0] assert list(median_stream(iter(inputs))) == expected def test_median_stream_negative_numbers(): inputs = [-1.0, -3.0, -2.0, -4.0] expected = [-1.0, -2.0, -2.0, -2.5] assert list(median_stream(iter(inputs))) == expected","solution":"import heapq from typing import Iterator def median_stream(numbers_iter: Iterator[float]) -> Iterator[float]: min_heap = [] max_heap = [] medians = [] def add_number(num: float): if len(max_heap) == 0 or num <= -max_heap[0]: heapq.heappush(max_heap, -num) else: heapq.heappush(min_heap, num) if len(max_heap) > len(min_heap) + 1: heapq.heappush(min_heap, -heapq.heappop(max_heap)) elif len(min_heap) > len(max_heap): heapq.heappush(max_heap, -heapq.heappop(min_heap)) def get_median() -> float: if len(max_heap) == len(min_heap): return (-max_heap[0] + min_heap[0]) / 2.0 else: return -max_heap[0] for number in numbers_iter: add_number(number) medians.append(get_median()) return iter(medians)"},{"question":"def solve_sudoku(puzzle: list[list[int]]) -> bool: Solves the given Sudoku puzzle using backtracking algorithm. Modifies the puzzle in place and returns True if a solution is found. If the puzzle cannot be solved, returns False. # Implementation goes here def find_empty_location(puzzle: list[list[int]]) -> tuple[int, int] | None: Finds the next empty cell in the puzzle (denoted by 0). Returns a tuple (row, col) if an empty cell is found, or None if there are no empty cells. # Implementation goes here def is_valid(puzzle: list[list[int]], row: int, col: int, num: int) -> bool: Checks if placing the number \`num\` in the cell (row, col) is a valid move. Returns True if valid, else False. # Implementation goes here def test_solve_sudoku(): puzzle = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] solved_puzzle = [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] assert solve_sudoku(puzzle) == True assert puzzle == solved_puzzle","solution":"def solve_sudoku(puzzle: list[list[int]]) -> bool: Solves the given Sudoku puzzle using backtracking algorithm. Modifies the puzzle in place and returns True if a solution is found. If the puzzle cannot be solved, returns False. empty_location = find_empty_location(puzzle) if not empty_location: return True # Puzzle is solved row, col = empty_location for num in range(1, 10): if is_valid(puzzle, row, col, num): puzzle[row][col] = num if solve_sudoku(puzzle): return True puzzle[row][col] = 0 # Backtrack return False def find_empty_location(puzzle: list[list[int]]) -> tuple[int, int] | None: Finds the next empty cell in the puzzle (denoted by 0). Returns a tuple (row, col) if an empty cell is found, or None if there are no empty cells. for i in range(9): for j in range(9): if puzzle[i][j] == 0: return (i, j) return None def is_valid(puzzle: list[list[int]], row: int, col: int, num: int) -> bool: Checks if placing the number \`num\` in the cell (row, col) is a valid move. Returns True if valid, else False. # Check row if any(puzzle[row][j] == num for j in range(9)): return False # Check column if any(puzzle[i][col] == num for i in range(9)): return False # Check 3x3 sub-grid start_row, start_col = 3 * (row // 3), 3 * (col // 3) if any(puzzle[i][j] == num for i in range(start_row, start_row + 3) for j in range(start_col, start_col + 3)): return False return True"},{"question":"def sum_ascii_values(s: str) -> int: Computes the sum of the ASCII values of the characters in the given string. Parameters: s (str): The input string containing alphabetical characters. Returns: int: The sum of the ASCII values of the characters in the string. pass def test_sum_ascii_values(): assert sum_ascii_values('ABC') == 198 assert sum_ascii_values('abc') == 294 assert sum_ascii_values('Hello') == 500 assert sum_ascii_values('Python') == 642 assert sum_ascii_values('Z') == 90 def test_sum_ascii_values_single_character(): assert sum_ascii_values('A') == 65 assert sum_ascii_values('z') == 122 def test_sum_ascii_values_mixed_case(): assert sum_ascii_values('aA') == 162 assert sum_ascii_values('Aa') == 162 def test_sum_ascii_values_long_string(): assert sum_ascii_values('a'*1000) == 97000 assert sum_ascii_values('A'*1000) == 65000","solution":"def sum_ascii_values(s: str) -> int: Computes the sum of the ASCII values of the characters in the given string. Parameters: s (str): The input string containing alphabetical characters. Returns: int: The sum of the ASCII values of the characters in the string. return sum(ord(char) for char in s)"},{"question":"Implement an Efficient Roman to Integer Converter You are given a string representing a Roman numeral. Your task is to convert this Roman numeral string into its equivalent integer value in an efficient manner. def roman_to_int(s: str) -> int: >>> roman_to_int(\\"III\\") 3 >>> roman_to_int(\\"IV\\") 4 >>> roman_to_int(\\"IX\\") 9 >>> roman_to_int(\\"LVIII\\") 58 >>> roman_to_int(\\"MCMXCIV\\") 1994 roman_numerals = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_numerals[char] if value < prev_value: total -= value else: total += value prev_value = value return total","solution":"def roman_to_int(s: str) -> int: roman_numerals = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_numerals[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"Find the least squares polynomial fit of a given degree for the provided data points. Function Signature: def least_squares_poly_fit(x_values, y_values, degree): Find the least squares polynomial fit of a given degree for the provided data points. :param x_values: List of x-coordinates of the data points. :param y_values: List of y-coordinates of the data points. :param degree: Degree of the polynomial to fit. :return: List of coefficients of the best-fit polynomial, from the highest degree to the lowest.","solution":"import numpy as np def least_squares_poly_fit(x_values, y_values, degree): Find the least squares polynomial fit of a given degree for the provided data points. :param x_values: List of x-coordinates of the data points. :param y_values: List of y-coordinates of the data points. :param degree: Degree of the polynomial to fit. :return: List of coefficients of the best-fit polynomial, from the highest degree to the lowest. if len(x_values) != len(y_values): raise ValueError(\\"x_values and y_values must have the same length\\") if len(x_values) <= degree: raise ValueError(\\"Not enough data points to fit the requested degree of polynomial\\") X = np.vander(x_values, degree + 1) y = np.array(y_values) coeffs, _, _, _ = np.linalg.lstsq(X, y, rcond=None) return coeffs.tolist()"},{"question":"def transform_to_roman(num: int) -> str: Convert an integer to its Roman numeral representation. Args: - num: An integer (1 <= num <= 3999). Returns: - A string representing the Roman numeral of the given integer. Raises: - ValueError: If the number is outside the range 1 to 3999. Example: >>> transform_to_roman(4) 'IV' >>> transform_to_roman(3999) 'MMMCMXCIX' >>> transform_to_roman(0) ValueError: The number must be between 1 and 3999. pass # Your code here def test_transform_to_roman(): assert transform_to_roman(1) == \\"I\\" assert transform_to_roman(4) == \\"IV\\" assert transform_to_roman(9) == \\"IX\\" assert transform_to_roman(58) == \\"LVIII\\" assert transform_to_roman(1994) == \\"MCMXCIV\\" assert transform_to_roman(3999) == \\"MMMCMXCIX\\" def test_transform_to_roman_out_of_range_low(): try: transform_to_roman(0) except ValueError as e: assert str(e) == \\"The number must be between 1 and 3999.\\" def test_transform_to_roman_out_of_range_high(): try: transform_to_roman(4000) except ValueError as e: assert str(e) == \\"The number must be between 1 and 3999.\\" def test_transform_to_roman_edge_cases(): assert transform_to_roman(1) == \\"I\\" assert transform_to_roman(3999) == \\"MMMCMXCIX\\"","solution":"def transform_to_roman(num: int) -> str: Convert an integer to its Roman numeral representation. Args: - num: An integer (1 <= num <= 3999). Returns: - A string representing the Roman numeral of the given integer. Raises: - ValueError: If the number is outside the range 1 to 3999. if not (1 <= num <= 3999): raise ValueError(\\"The number must be between 1 and 3999.\\") value_mappings = [ (1000, \\"M\\"), (900, \\"CM\\"), (500, \\"D\\"), (400, \\"CD\\"), (100, \\"C\\"), (90, \\"XC\\"), (50, \\"L\\"), (40, \\"XL\\"), (10, \\"X\\"), (9, \\"IX\\"), (5, \\"V\\"), (4, \\"IV\\"), (1, \\"I\\") ] roman_numeral = [] for value, numeral in value_mappings: while num >= value: roman_numeral.append(numeral) num -= value return \\"\\".join(roman_numeral)"},{"question":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> longest_unique_substring(\\"abcabcbb\\") == 3 >>> longest_unique_substring(\\"bbbbb\\") == 1 >>> longest_unique_substring(\\"pwwkew\\") == 3 >>> longest_unique_substring(\\"\\") == 0 >>> longest_unique_substring(\\"abcdefg\\") == 7 >>> longest_unique_substring(\\"aab\\") == 2 >>> large_string = \\"a\\" * (10**6) + \\"b\\" >>> longest_unique_substring(large_string) == 2 pass","solution":"def longest_unique_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 char_set = set() left = 0 max_len = 0 for right in range(n): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_len = max(max_len, right - left + 1) return max_len"},{"question":"import numpy as np class KNearestNeighborsClassifier: KNearestNeighborsClassifier implements the basic KNN functionality from scratch. Methods: - __init__(self, n_neighbors: int = 3): Initialize the classifier with the number of neighbors. - fit(self, features: np.ndarray, target: np.ndarray) -> None: Store the given features and target as training data. - predict(self, features: np.ndarray) -> np.ndarray: Predict the classes for the input data by finding the most common class among the nearest neighbors. - distance(self, point1: np.ndarray, point2: np.ndarray) -> float: Compute the Euclidean distance between two data points. def __init__(self, n_neighbors: int = 3): self.n_neighbors = n_neighbors def fit(self, features: np.ndarray, target: np.ndarray) -> None: pass # Implement this method def predict(self, features: np.ndarray) -> np.ndarray: pass # Implement this method def _predict_single(self, sample: np.ndarray) -> int: pass # Implement this method def distance(self, point1: np.ndarray, point2: np.ndarray) -> float: pass # Implement this method # Example usage: # from sklearn.datasets import load_iris # from sklearn.model_selection import train_test_split # from sklearn.metrics import accuracy_score # iris = load_iris() # X, y = iris.data, iris.target # Convert to binary classification (class 0 vs classes 1 and 2) # X = X[y != 2] # y = y[y != 2] # Split data into training and testing sets # X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Create and train KNN classifier # knn = KNearestNeighborsClassifier(n_neighbors=3) # knn.fit(X_train, y_train) # Make predictions and evaluate the model # y_pred = knn.predict(X_test) # accuracy = accuracy_score(y_test, y_pred) # print(f\\"Accuracy: {accuracy:.2f}\\")","solution":"import numpy as np class KNearestNeighborsClassifier: def __init__(self, n_neighbors: int = 3): self.n_neighbors = n_neighbors def fit(self, features: np.ndarray, target: np.ndarray) -> None: self.features = features self.target = target def predict(self, features: np.ndarray) -> np.ndarray: return np.array([self._predict_single(sample) for sample in features]) def _predict_single(self, sample: np.ndarray) -> int: distances = [self.distance(sample, train_sample) for train_sample in self.features] neighbors_indices = np.argsort(distances)[:self.n_neighbors] neighbor_votes = self.target[neighbors_indices] return np.bincount(neighbor_votes).argmax() def distance(self, point1: np.ndarray, point2: np.ndarray) -> float: return np.sqrt(np.sum((point1 - point2) ** 2))"},{"question":"import heapq class Node: def __init__(self, frequency: int, character: str = '') -> None: Initialization function for a Node object. Args: frequency (int): Frequency of the character. character (str, optional): The character the node represents. Default is empty string. # Your code here def __lt__(self, other): Comparator for priority queue. Args: other (Node): The other node to compare. # Your code here class HuffmanCoding: def __init__(self) -> None: Initialization function for HuffmanCoding object. # Your code here def build_huffman_tree(self, data: str) -> Node: Builds the Huffman Tree and returns the root node. Args: data (str): The input string to build the Huffman Tree from. Returns: Node: The root node of the Huffman Tree. # Your code here def generate_codes(self, root: Node) -> dict[str, str]: Generates and returns the Huffman codes from the tree. Args: root (Node): The root node of the Huffman Tree. Returns: dict[str, str]: Dictionary mapping characters to their Huffman codes. # Your code here def encode(self, data: str) -> str: Encodes the input data string using the Huffman codes. Args: data (str): The input string to encode. Returns: str: The encoded string. # Your code here def decode(self, encoded_data: str) -> str: Decodes the encoded data string using the Huffman Tree. Args: encoded_data (str): The encoded string to decode. Returns: str: The original string before encoding. # Your code here # Unit tests def test_huffman_tree_structure(): data = \\"aaabbc\\" huffman = HuffmanCoding() root = huffman.build_huffman_tree(data) assert root.frequency == 6 # Total frequency should be the length of data assert root.left.frequency + root.right.frequency == 6 def test_generate_codes(): data = \\"aaabbc\\" huffman = HuffmanCoding() root = huffman.build_huffman_tree(data) codes = huffman.generate_codes(root) assert len(codes) == 3 # Only three unique characters assert 'a' in codes assert 'b' in codes assert 'c' in codes def test_encode(): data = \\"aaabbc\\" huffman = HuffmanCoding() root = huffman.build_huffman_tree(data) huffman.generate_codes(root) encoded_data = huffman.encode(data) assert isinstance(encoded_data, str) assert len(encoded_data) > 0 def test_decode(): data = \\"aaabbc\\" huffman = HuffmanCoding() root = huffman.build_huffman_tree(data) huffman.generate_codes(root) encoded_data = huffman.encode(data) decoded_data = huffman.decode(encoded_data) assert decoded_data == data def test_full_workflow(): data = \\"this is an example for huffman encoding\\" huffman = HuffmanCoding() root = huffman.build_huffman_tree(data) huffman.generate_codes(root) encoded_data = huffman.encode(data) decoded_data = huffman.decode(encoded_data) assert decoded_data == data","solution":"import heapq class Node: def __init__(self, frequency, character=''): self.frequency = frequency self.character = character self.left = None self.right = None # Define comparators for the priority queue def __lt__(self, other): return self.frequency < other.frequency class HuffmanCoding: def __init__(self): self.codes = {} self.reverse_mapping = {} def build_huffman_tree(self, data): if not data: return None frequency = {} for char in data: if char not in frequency: frequency[char] = 0 frequency[char] += 1 priority_queue = [Node(frequency[char], char) for char in frequency] heapq.heapify(priority_queue) while len(priority_queue) > 1: node1 = heapq.heappop(priority_queue) node2 = heapq.heappop(priority_queue) merged = Node(node1.frequency + node2.frequency) merged.left = node1 merged.right = node2 heapq.heappush(priority_queue, merged) return priority_queue[0] def generate_codes_helper(self, root, current_code): if root is None: return if root.character != '': self.codes[root.character] = current_code self.reverse_mapping[current_code] = root.character self.generate_codes_helper(root.left, current_code + \\"0\\") self.generate_codes_helper(root.right, current_code + \\"1\\") def generate_codes(self, root): current_code = \\"\\" self.generate_codes_helper(root, current_code) return self.codes def encode(self, data): encoded_text = \\"\\" for char in data: encoded_text += self.codes[char] return encoded_text def decode(self, encoded_data): current_code = \\"\\" decoded_text = \\"\\" for bit in encoded_data: current_code += bit if current_code in self.reverse_mapping: character = self.reverse_mapping[current_code] decoded_text += character current_code = \\"\\" return decoded_text"},{"question":"def can_form_palindrome(string: str) -> bool: Determines if a string can be rearranged to form a palindrome. Args: string (str): The string to analyze Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. Examples: >>> can_form_palindrome('Tact Coa') True >>> can_form_palindrome('apple') False >>> can_form_palindrome('racecar') True","solution":"def can_form_palindrome(string: str) -> bool: Determines if a string can be rearranged to form a palindrome. Args: string (str): The string to analyze Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. from collections import Counter # Clean the string: ignore spaces, convert to lowercase cleaned_string = string.replace(\\" \\", \\"\\").lower() # Count the frequency of each character char_count = Counter(cleaned_string) # Check the number of characters with an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if it has at most one odd frequency character return odd_count <= 1"},{"question":"from typing import List def does_return_to_origin(moves: str) -> bool: Determine if a robot returns to the origin after a sequence of moves. Parameters: moves (str): A sequence of characters representing the moves of the robot ('U', 'D', 'L', 'R'). Returns: bool: True if the robot returns to the origin, False otherwise. Examples: >>> does_return_to_origin(\\"UD\\") True >>> does_return_to_origin(\\"LL\\") False >>> does_return_to_origin(\\"URDLURDL\\") True >>> does_return_to_origin(\\"UUDDL\\") False","solution":"def does_return_to_origin(moves: str) -> bool: Determine if a robot returns to the origin after a sequence of moves. Parameters: moves (str): A sequence of characters representing the moves of the robot ('U', 'D', 'L', 'R'). Returns: bool: True if the robot returns to the origin, False otherwise. x, y = 0, 0 for move in moves: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return x == 0 and y == 0"},{"question":"def multiply_complex_numbers(num1: str, num2: str) -> str: Multiply two complex numbers represented as strings in the form \\"a+bi\\". >>> multiply_complex_numbers(\\"1+1i\\", \\"1+1i\\") '0+2i' >>> multiply_complex_numbers(\\"1+-1i\\", \\"1+-1i\\") '0+-2i' >>> multiply_complex_numbers(\\"3+2i\\", \\"1+-4i\\") '11+-10i' >>> multiply_complex_numbers(\\"0+0i\\", \\"5+3i\\") '0+0i'","solution":"def multiply_complex_numbers(num1: str, num2: str) -> str: def parse_complex(num: str): parts = num[:-1].split('+') real = int(parts[0]) imag = int(parts[1]) return real, imag real1, imag1 = parse_complex(num1) real2, imag2 = parse_complex(num2) real_result = real1 * real2 - imag1 * imag2 imag_result = real1 * imag2 + imag1 * real2 return f\\"{real_result}+{imag_result}i\\""},{"question":"from typing import List def merge_sorted_files(file_paths: List[str], output_path: str): Merge multiple sorted text files into a single sorted file. :param file_paths: List of file paths to be merged. :param output_path: The path of the output file. # Implementation goes here # Example usage: # merge_sorted_files(['file1.txt', 'file2.txt', 'file3.txt'], 'output.txt')","solution":"from typing import List import heapq def merge_sorted_files(file_paths: List[str], output_path: str): Merge multiple sorted text files into a single sorted file. :param file_paths: List of file paths to be merged. :param output_path: The path of the output file. # Open all files open_files = [open(file_path, 'r') for file_path in file_paths] min_heap = [] # Initialize the heap with the first line from each file for i, f in enumerate(open_files): line = f.readline().strip() if line: heapq.heappush(min_heap, (int(line), i)) with open(output_path, 'w') as output_file: # Process the heap while min_heap: smallest, file_index = heapq.heappop(min_heap) output_file.write(f\\"{smallest}n\\") next_line = open_files[file_index].readline().strip() if next_line: heapq.heappush(min_heap, (int(next_line), file_index)) # Close all input files for f in open_files: f.close()"},{"question":"from typing import List class LoadBalancer: def __init__(self, servers: List[str]) -> None: Initializes the load balancer with a list of server IDs. >>> lb = LoadBalancer([\\"server1\\", \\"server2\\", \\"server3\\"]) pass def next_server(self) -> str: Returns the ID of the next server in the round-robin sequence. >>> lb = LoadBalancer([\\"server1\\", \\"server2\\", \\"server3\\"]) >>> lb.next_server() 'server1' >>> lb.next_server() 'server2' >>> lb.next_server() 'server3' >>> lb.next_server() 'server1' pass def print_servers(self) -> None: Prints the current order of servers. >>> lb = LoadBalancer([\\"server1\\", \\"server2\\", \\"server3\\"]) >>> lb.print_servers() ['server1', 'server2', 'server3'] >>> lb.next_server() >>> lb.next_server() >>> lb.print_servers() ['server3', 'server1', 'server2'] pass","solution":"from typing import List class LoadBalancer: def __init__(self, servers: List[str]) -> None: self.servers = servers def next_server(self) -> str: next_server = self.servers.pop(0) self.servers.append(next_server) return next_server def print_servers(self) -> None: print(self.servers)"},{"question":"def combination_sum(nums: list[int], target: int) -> list[list[int]]: Find all unique combinations of numbers in \`nums\` where the chosen numbers sum to \`target\`. Each number in \`nums\` can be used an unlimited number of times. The combinations should be returned in lexicographical order. Args: nums (list[int]): A list of integers where each integer is greater than 0. target (int): An integer representing the target sum. Returns: list[list[int]]: A list of lists containing all unique combinations where the numbers sum to \`target\`. Constraints: - All input integers in \`nums\` are positive and distinct. - The length of \`nums\` will be at most 30. - The target will be at most 500. Example: >>> combination_sum([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> combination_sum([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]]","solution":"def combination_sum(nums: list[int], target: int) -> list[list[int]]: def backtrack(start, current_combination, current_sum): if current_sum == target: result.append(list(current_combination)) return if current_sum > target: return for i in range(start, len(nums)): current_combination.append(nums[i]) backtrack(i, current_combination, current_sum + nums[i]) current_combination.pop() nums.sort() result = [] backtrack(0, [], 0) return result"},{"question":"def sum_multiples_3_and_5(n: int) -> int: Calculate the sum of all multiples of 3 and 5 up to and including a given number \`n\`. Args: n (int): The given number up to which we need to find the sum of multiples of 3 and 5. Returns: int: The sum of all multiples of 3 and 5 from 1 to \`n\`. Examples: >>> sum_multiples_3_and_5(10) 33 >>> sum_multiples_3_and_5(15) 60 >>> sum_multiples_3_and_5(1) 0 >>> sum_multiples_3_and_5(0) 0","solution":"def sum_multiples_3_and_5(n: int) -> int: Returns the sum of all multiples of 3 and 5 up to and including n. total_sum = 0 for i in range(1, n + 1): if i % 3 == 0 or i % 5 == 0: total_sum += i return total_sum"},{"question":"from typing import List def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two sorted lists into one sorted list. Example usage: >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([10, 20, 30], [5, 15, 25, 35]) [5, 10, 15, 20, 25, 30, 35] >>> merge_sorted_lists([-5, 0, 5], [-10, -1, 3, 7]) [-10, -5, -1, 0, 3, 5, 7] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([], []) [] # Your implementation here # Test cases def test_merge_sorted_lists_both_non_empty(): assert merge_sorted_lists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] assert merge_sorted_lists([10, 20, 30], [5, 15, 25, 35]) == [5, 10, 15, 20, 25, 30, 35] assert merge_sorted_lists([-5, 0, 5], [-10, -1, 3, 7]) == [-10, -5, -1, 0, 3, 5, 7] def test_merge_sorted_lists_one_empty(): assert merge_sorted_lists([], [1, 2, 3]) == [1, 2, 3] assert merge_sorted_lists([1, 2, 3], []) == [1, 2, 3] def test_merge_sorted_lists_both_empty(): assert merge_sorted_lists([], []) == [] def test_merge_sorted_lists_with_duplicates(): assert merge_sorted_lists([1, 2, 2, 4], [2, 3, 4, 4, 5]) == [1, 2, 2, 2, 3, 4, 4, 4, 5] assert merge_sorted_lists([1, 1, 1, 1], [1, 1, 1, 1]) == [1, 1, 1, 1, 1, 1, 1, 1] assert merge_sorted_lists([1], [1]) == [1, 1] def test_merge_sorted_lists_negative_numbers(): assert merge_sorted_lists([-3, -2, -1], [-5, -4]) == [-5, -4, -3, -2, -1] assert merge_sorted_lists([-10, -5, 0], [-20, -15, 5]) == [-20, -15, -10, -5, 0, 5]","solution":"from typing import List def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two sorted lists into one sorted list. Example usage: >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([10, 20, 30], [5, 15, 25, 35]) [5, 10, 15, 20, 25, 30, 35] >>> merge_sorted_lists([-5, 0, 5], [-10, -1, 3, 7]) [-10, -5, -1, 0, 3, 5, 7] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([], []) [] merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Add the remaining elements from list1 or list2 (if any) while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def find_rotation_index(original: str, rotated: str) -> int: Determines the index by which a string has been rotated. Parameters: original (str): The original string. rotated (str): The rotated version of the original string. Returns: int: The number of characters that have been moved from the beginning of the original string to the end to form the rotated string. Returns -1 if the rotated string is not a valid rotation of the original string. >>> find_rotation_index(\\"abcde\\", \\"cdeab\\") 2 >>> find_rotation_index(\\"hello\\", \\"lohel\\") 3 >>> find_rotation_index(\\"rotation\\", \\"rotation\\") 0 >>> find_rotation_index(\\"abc\\", \\"acb\\") -1 >>> find_rotation_index(\\"abcdef\\", \\"efabcd\\") 4 >>> find_rotation_index(\\"abcdef\\", \\"ghijkl\\") -1 >>> find_rotation_index(\\"a\\", \\"a\\") 0 >>> find_rotation_index(\\"rotation\\", \\"itionrot\\") 4","solution":"def find_rotation_index(original: str, rotated: str) -> int: Determines the index by which a string has been rotated. Parameters: original (str): The original string. rotated (str): The rotated version of the original string. Returns: int: The number of characters that have been moved from the beginning of the original string to the end to form the rotated string. Returns -1 if the rotated string is not a valid rotation of the original string. # Check if the rotated string is a valid rotation of the original string if len(original) != len(rotated): return -1 if original == rotated: return 0 # Concatenate the original string with itself concatenated = original + original # Try to find the rotated string in the concatenated string index = concatenated.find(rotated) # If the rotated string is found, return the index # Otherwise, return -1 (invalid rotation) return index if index != -1 else -1"},{"question":"from typing import List def count_matching_words(s: str, words: List[str]) -> int: Count how many words from the list can be formed by deleting some characters of the given string \`s\` without changing the order of the remaining characters. >>> count_matching_words(\\"abpcplea\\", [\\"ale\\", \\"apple\\", \\"monkey\\", \\"plea\\"]) == 3 >>> count_matching_words(\\"abpcplea\\", [\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) == 3 >>> count_matching_words(\\"abcdefgh\\", [\\"abc\\", \\"bcd\\", \\"cde\\", \\"def\\"]) == 4 >>> count_matching_words(\\"abcdefgh\\", [\\"xyz\\", \\"ghijk\\", \\"mnop\\"]) == 0","solution":"from typing import List def count_matching_words(s: str, words: List[str]) -> int: def is_subsequence(word: str, s: str) -> bool: it = iter(s) return all(char in it for char in word) return sum(1 for word in words if is_subsequence(word, s))"},{"question":"from typing import List, Dict class TextAnalyzer: def __init__(self, text: str): Initializes the TextAnalyzer with the given text. pass def word_frequency(self, word: str) -> int: Returns the frequency of the specified word in the text. pass def top_k_frequent_words(self, k: int) -> List[str]: Returns a list of the \`k\` most frequent words in the text in descending order of their frequency. >>> analyzer = TextAnalyzer(\\"apple apple banana banana orange apple banana orange orange orange\\") >>> analyzer.top_k_frequent_words(2) ['orange', 'apple'] >>> analyzer.top_k_frequent_words(3) ['orange', 'apple', 'banana'] >>> analyzer.top_k_frequent_words(1) ['orange'] >>> analyzer.top_k_frequent_words(0) [] >>> analyzer.top_k_frequent_words(5) ['orange', 'apple', 'banana'] pass # Example initialization and method calls (for reference in tests) # text = \\"This is a test. This test is only a test. If this had been an actual emergency, you would have been instructed where to tune in your area. This is only a test.\\" # analyzer = TextAnalyzer(text) # print(analyzer.word_frequency(\\"test\\")) # Expected Output: 4 # print(analyzer.word_frequency(\\"this\\")) # Expected Output: 3 # print(analyzer.top_k_frequent_words(3)) # Expected Output: ['test', 'is', 'a'] # print(analyzer.top_k_frequent_words(5)) # Expected Output: ['test', 'is', 'a', 'been', 'if'] # print(analyzer.top_k_frequent_words(1)) # Expected Output: ['test'] # print(analyzer.top_k_frequent_words(0)) # Expected Output: []","solution":"from typing import List, Dict from collections import Counter import re class TextAnalyzer: def __init__(self, text: str): self.word_freq = self._process_text(text) def _process_text(self, text: str) -> Dict[str, int]: # Convert to lower case and find all words words = re.findall(r'bw+b', text.lower()) return dict(Counter(words)) def word_frequency(self, word: str) -> int: return self.word_freq.get(word.lower(), 0) def top_k_frequent_words(self, k: int) -> List[str]: if k <= 0: return [] sorted_words = sorted(self.word_freq.items(), key=lambda item: (-item[1], item[0])) return [word for word, freq in sorted_words[:k]]"},{"question":"from typing import List def column_sum(matrix: List[List[int]], column_index: int) -> int: Computes the sum of all the elements in a specified column of a given matrix. Args: matrix (List[List[int]]): The matrix as a list of lists of integers. column_index (int): The column index for which the sum needs to be calculated. Returns: int: The sum of the elements in the specified column. >>> column_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1) 15 >>> column_sum([[1], [2], [3]], 0) 6 >>> column_sum([[0, 1], [1, 2], [2, 3]], 0) 3 def test_column_sum_single_column_matrix(): matrix = [[1], [2], [3]] assert column_sum(matrix, 0) == 6 def test_column_sum_single_row_matrix(): matrix = [[1, 2, 3]] assert column_sum(matrix, 0) == 1 assert column_sum(matrix, 1) == 2 assert column_sum(matrix, 2) == 3 def test_column_sum_multiple_columns(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert column_sum(matrix, 0) == 12 assert column_sum(matrix, 1) == 15 assert column_sum(matrix, 2) == 18 def test_column_sum_with_zeros(): matrix = [ [0, 1], [1, 2], [2, 3] ] assert column_sum(matrix, 0) == 3 assert column_sum(matrix, 1) == 6 def test_column_sum_with_negative_numbers(): matrix = [ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ] assert column_sum(matrix, 0) == -12 assert column_sum(matrix, 1) == -15 assert column_sum(matrix, 2) == -18 def test_column_sum_large_numbers(): matrix = [ [10**3, -10**3, 0], [10**3, -10**3, 0], [10**3, -10**3, 0] ] assert column_sum(matrix, 0) == 3000 assert column_sum(matrix, 1) == -3000 assert column_sum(matrix, 2) == 0","solution":"from typing import List def column_sum(matrix: List[List[int]], column_index: int) -> int: Computes the sum of all the elements in a specified column of a given matrix. Args: matrix (List[List[int]]): The matrix as a list of lists of integers. column_index (int): The column index for which the sum needs to be calculated. Returns: int: The sum of the elements in the specified column. return sum(row[column_index] for row in matrix)"},{"question":"def process_pipeline(data: list, stages: list) -> list: Simulates the processing of data through several stages. >>> def increment(x): >>> return x + 1 >>> def multiply_by_two(x): >>> return x * 2 >>> data = [1, 2, 3, 4, 5] >>> stages = [increment, multiply_by_two] >>> process_pipeline(data, stages) [4, 6, 8, 10, 12] # Define sample stage functions for testing def increment(x): return x + 1 def multiply_by_two(x): return x * 2 def square(x): return x * x # Unit tests if __name__ == \\"__main__\\": data = [1, 2, 3, 4, 5] stages = [increment] assert process_pipeline(data, stages) == [2, 3, 4, 5, 6] stages = [multiply_by_two] assert process_pipeline(data, stages) == [2, 4, 6, 8, 10] stages = [increment, multiply_by_two] assert process_pipeline(data, stages) == [4, 6, 8, 10, 12] stages = [square] assert process_pipeline(data, stages) == [1, 4, 9, 16, 25] stages = [increment, multiply_by_two, square] assert process_pipeline(data, stages) == [16, 36, 64, 100, 144]","solution":"def process_pipeline(data: list, stages: list) -> list: for stage in stages: data = [stage(item) for item in data] return data # Sample stage functions def increment(x): return x + 1 def multiply_by_two(x): return x * 2 def square(x): return x * x"},{"question":"def longest_consecutive_sequence(s: str) -> int: Determine the length of the longest sequence of consecutive, identical characters in a given string. >>> longest_consecutive_sequence(\\"aaabbccccdd\\") 4 >>> longest_consecutive_sequence(\\"a\\") 1 >>> longest_consecutive_sequence(\\"abcde\\") 1 >>> longest_consecutive_sequence(\\"aabbbcccddeee\\") 3 >>> longest_consecutive_sequence(\\"abbbbccd\\") 4 >>> longest_consecutive_sequence(\\"\\") 0 >>> longest_consecutive_sequence(\\"bbbbb\\") 5 >>> longest_consecutive_sequence(\\"aabbccdd\\") 2","solution":"def longest_consecutive_sequence(s: str) -> int: if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 else: current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"import random import math from typing import List, Tuple class TSPProblem: def __init__(self, cities: List[Tuple[float, float]]): self.cities = cities def initial_population(self, population_size: int) -> List[List[int]]: Generate the initial population of solutions. >>> len(TSPProblem([(0, 0), (1, 1), (2, 2)]).initial_population(10)) == 10 True pass def fitness(self, solution: List[int]) -> float: Calculate the fitness of a solution. >>> math.isclose(TSPProblem([(0, 0), (0, 1), (1, 1), (1, 0)]).fitness([0, 1, 2, 3]), 4.0, rel_tol=1e-5) True pass def selection(self, population, fitnesses, tournament_size: int) -> List[int]: Select a solution from the population using tournament selection. pass def crossover(self, parent1: List[int], parent2: List[int]) -> List[int]: Perform crossover between two parent solutions. >>> set(TSPProblem([(0, 0), (1, 1), (2, 2), (3, 3)]).crossover([0, 1, 2, 3], [3, 2, 1, 0])) == {0, 1, 2, 3} True pass def mutate(self, solution: List[int], mutation_rate: float) -> List[int]: Mutate a solution based on the mutation rate. pass def genetic_algorithm_tsp( tsp_prob: TSPProblem, population_size: int, generations: int, mutation_rate: float, tournament_size: int ) -> Tuple[List[int], float]: Solve the Traveling Salesperson Problem using a genetic algorithm. >>> cities = [(0, 0), (0, 1), (1, 1), (1, 0)] >>> tsp_problem = TSPProblem(cities) >>> best_solution, best_distance = genetic_algorithm_tsp(tsp_problem, 10, 10, 0.01, 2) >>> len(best_solution) == len(cities) True >>> set(best_solution) == set(range(len(cities))) True >>> best_distance > 0.0 True pass","solution":"import random import math from typing import List, Tuple class TSPProblem: def __init__(self, cities: List[Tuple[float, float]]): self.cities = cities def initial_population(self, population_size: int) -> List[List[int]]: population = [] for _ in range(population_size): individual = list(range(len(self.cities))) random.shuffle(individual) population.append(individual) return population def fitness(self, solution: List[int]) -> float: distance = 0.0 for i in range(len(solution)): city1 = self.cities[solution[i]] city2 = self.cities[solution[(i + 1) % len(solution)]] distance += math.dist(city1, city2) return distance def selection(self, population, fitnesses, tournament_size: int) -> List[int]: selected = random.choices( population, weights=[1.0 / fitness for fitness in fitnesses], k=tournament_size ) return min(selected, key=lambda ind: self.fitness(ind)) def crossover(self, parent1: List[int], parent2: List[int]) -> List[int]: start, end = sorted(random.sample(range(len(parent1)), 2)) child_p1 = parent1[start:end + 1] child_p2 = [city for city in parent2 if city not in child_p1] return child_p2[:start] + child_p1 + child_p2[start:] def mutate(self, solution: List[int], mutation_rate: float) -> List[int]: for i in range(len(solution)): if random.random() < mutation_rate: j = random.randint(0, len(solution) - 1) solution[i], solution[j] = solution[j], solution[i] return solution def genetic_algorithm_tsp( tsp_prob: TSPProblem, population_size: int, generations: int, mutation_rate: float, tournament_size: int ) -> Tuple[List[int], float]: population = tsp_prob.initial_population(population_size) for generation in range(generations): fitnesses = [tsp_prob.fitness(individual) for individual in population] new_population = [] for _ in range(population_size): parent1 = tsp_prob.selection(population, fitnesses, tournament_size) parent2 = tsp_prob.selection(population, fitnesses, tournament_size) child = tsp_prob.crossover(parent1, parent2) child = tsp_prob.mutate(child, mutation_rate) new_population.append(child) population = new_population best_solution = min(population, key=lambda ind: tsp_prob.fitness(ind)) best_distance = tsp_prob.fitness(best_solution) return best_solution, best_distance"},{"question":"def pascal_triangle_memoized(n: int, memo: dict = None) -> list[int]: Generate the nth row of Pascal's Triangle using memoization to optimize performance. :param n: The row index (0-based) of Pascal's Triangle. :param memo: A dictionary to store previously computed values of Pascal's Triangle. :return: A list containing the binomial coefficients in the nth row of Pascal's Triangle. if memo is None: memo = {} def get_pascal_value(row: int, col: int) -> int: if (row, col) in memo: return memo[(row, col)] if col == 0 or col == row: return 1 memo[(row, col)] = get_pascal_value(row - 1, col - 1) + get_pascal_value(row - 1, col) return memo[(row, col)] return [get_pascal_value(n, k) for k in range(n + 1)]","solution":"def pascal_triangle_memoized(n: int, memo: dict = None) -> list[int]: if memo is None: memo = {} def get_pascal_value(row: int, col: int) -> int: if (row, col) in memo: return memo[(row, col)] if col == 0 or col == row: return 1 memo[(row, col)] = get_pascal_value(row - 1, col - 1) + get_pascal_value(row - 1, col) return memo[(row, col)] return [get_pascal_value(n, k) for k in range(n + 1)]"},{"question":"from typing import Tuple, Union def line_segment_intersection(segment1: Tuple[Tuple[float, float], Tuple[float, float]], segment2: Tuple[Tuple[float, float], Tuple[float, float]]) -> Union[Tuple[float, float], str]: Calculate the intersection point of two line segments in 2D space. Return the coordinates of the intersection point if the segments intersect, or a message indicating no intersection. Parameters: segment1: A tuple of two tuples, each containing two floats, representing the endpoints (x1, y1) and (x2, y2) of the first line segment. segment2: A tuple of two tuples, each containing two floats, representing the endpoints (x3, y3) and (x4, y4) of the second line segment. Returns: A tuple containing two floats representing the coordinates (x, y) of the intersection point rounded to two decimal places, or a string indicating no intersection. >>> line_segment_intersection(((1, 1), (4, 4)), ((1, 8), (2, 4))) (1.8, 1.8) >>> line_segment_intersection(((1, 1), (4, 4)), ((1, 4), (4, 1))) (2.5, 2.5) >>> line_segment_intersection(((1, 1), (4, 4)), ((5, 5), (6, 6))) 'No intersection' >>> line_segment_intersection(((0, 0), (0, 0)), ((1, 1), (2, 2))) Traceback (most recent call last): ... ValueError: A line segment must have distinct endpoints","solution":"from typing import Tuple, Union def line_segment_intersection(segment1: Tuple[Tuple[float, float], Tuple[float, float]], segment2: Tuple[Tuple[float, float], Tuple[float, float]]) -> Union[Tuple[float, float], str]: def ccw(A, B, C): return (C[1]-A[1]) * (B[0]-A[0]) > (B[1]-A[1]) * (C[0]-A[0]) def intersect(A, B, C, D): return ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D) def det(a, b, c, d): return a * d - b * c (x1, y1), (x2, y2) = segment1 (x3, y3), (x4, y4) = segment2 # Validate that the lines have distinct endpoints if (x1 == x2 and y1 == y2) or (x3 == x4 and y3 == y4): raise ValueError(\\"A line segment must have distinct endpoints\\") if not intersect((x1, y1), (x2, y2), (x3, y3), (x4, y4)): return \\"No intersection\\" # Solve for the intersection point using determinants denom = det(x1 - x2, x3 - x4, y1 - y2, y3 - y4) if denom == 0: return \\"No intersection\\" intersect_x = det(det(x1, y1, x2, y2), x1 - x2, det(x3, y3, x4, y4), x3 - x4) / denom intersect_y = det(det(x1, y1, x2, y2), y1 - y2, det(x3, y3, x4, y4), y3 - y4) / denom return (round(intersect_x, 2), round(intersect_y, 2))"},{"question":"def dijkstra(n: int, edges: list[tuple[int, int, int]], src: int) -> list[int]: Implement Dijkstra's Algorithm to find the shortest path from the source node to all other nodes in a weighted graph. Args: n (int): Number of nodes in the graph. edges (list[tuple[int, int, int]]): A list of tuples representing directed edges (u, v, w) with weights. src (int): The source node. Returns: list[int]: Shortest distance from the source node to every other node. If a node is not reachable, its distance should be float('inf'). Examples: >>> dijkstra(5, [(0, 1, 10), (0, 4, 5), (1, 2, 1), (1, 4, 2), (2, 3, 4), (3, 0, 7), (3, 2, 6), (4, 1, 3), (4, 2, 9), (4, 3, 2)], 0) [0, 8, 9, 7, 5] >>> dijkstra(3, [(0, 1, 5), (1, 2, 2)], 0) [0, 5, 7] >>> dijkstra(3, [(0, 2, 5), (2, 1, 2)], 1) [float('inf'), 0, float('inf')]","solution":"import heapq def dijkstra(n, edges, src): graph = {i: [] for i in range(n)} for u, v, w in edges: graph[u].append((v, w)) distances = [float('inf')] * n distances[src] = 0 priority_queue = [(0, src)] while priority_queue: current_distance, u = heapq.heappop(priority_queue) if current_distance > distances[u]: continue for v, weight in graph[u]: distance = current_distance + weight if distance < distances[v]: distances[v] = distance heapq.heappush(priority_queue, (distance, v)) return distances"},{"question":"import heapq from typing import List, Tuple, Dict def create_graph(graph_data: List[Tuple[str, str, int]]) -> Dict[str, List[Tuple[str, int]]]: Create a graph representation from the provided input data. Args: graph_data (list of tuples): Each tuple contains source, destination, and distance. Returns: dict: Adjacency list representation of the graph. graph = {} for source, destination, distance in graph_data: if source not in graph: graph[source] = [] if destination not in graph: graph[destination] = [] graph[source].append((destination, distance)) graph[destination].append((source, distance)) return graph def dijkstra(graph: Dict[str, List[Tuple[str, int]]], start_node: str) -> Dict[str, int]: Implement Dijkstra's algorithm to compute the shortest paths from the start node. Args: graph (dict): Adjacency list representation of the graph. start_node (str): The starting node for Dijkstra's algorithm. Returns: dict: Shortest distances from the start node to each node in the graph. pq = [] heapq.heappush(pq, (0, start_node)) distances = {node: float('inf') for node in graph} distances[start_node] = 0 visited = set() while pq: current_distance, current_node = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances def main(): graph_data = [ ('A', 'B', 4), ('A', 'C', 2), ('B', 'C', 5), ('B', 'D', 10), ('C', 'E', 3), ('D', 'F', 11), ('E', 'D', 4) ] start_node = 'A' graph = create_graph(graph_data) shortest_distances = dijkstra(graph, start_node) print(\\"Shortest distances from the start node:\\") for node in shortest_distances: print(f\\"Distance to {node}: {shortest_distances[node]}\\") if __name__ == \\"__main__\\": main()","solution":"import heapq def create_graph(graph_data): Create a graph representation from the provided input data. Args: graph_data (list of tuples): Each tuple contains source, destination, and distance. Returns: dict: Adjacency list representation of the graph. graph = {} for source, destination, distance in graph_data: if source not in graph: graph[source] = [] if destination not in graph: graph[destination] = [] graph[source].append((destination, distance)) graph[destination].append((source, distance)) return graph def dijkstra(graph, start_node): Implement Dijkstra's algorithm to compute the shortest paths from the start node. Args: graph (dict): Adjacency list representation of the graph. start_node: The starting node for Dijkstra's algorithm. Returns: dict: Shortest distances from the start node to each node in the graph. pq = [] heapq.heappush(pq, (0, start_node)) distances = {node: float('inf') for node in graph} distances[start_node] = 0 visited = set() while pq: current_distance, current_node = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances def main(): graph_data = [ ('A', 'B', 4), ('A', 'C', 2), ('B', 'C', 5), ('B', 'D', 10), ('C', 'E', 3), ('D', 'F', 11), ('E', 'D', 4) ] start_node = 'A' graph = create_graph(graph_data) shortest_distances = dijkstra(graph, start_node) print(\\"Shortest distances from the start node:\\") for node in shortest_distances: print(f\\"Distance to {node}: {shortest_distances[node]}\\") if __name__ == \\"__main__\\": main()"},{"question":"def are_parentheses_balanced(s: str) -> bool: Verify whether the parentheses in an input string are properly matched. Handles round (), square [], and curly {} parentheses. Args: s (str): The input string containing any printable ASCII characters. Returns: bool: True if the parentheses are matched correctly, False otherwise. >>> are_parentheses_balanced(\\"([{}])\\") True >>> are_parentheses_balanced(\\"([{}]))\\") False >>> are_parentheses_balanced(\\"([)]\\") False >>> are_parentheses_balanced(\\"({[a+b]*c}/d)\\") True","solution":"def are_parentheses_balanced(s: str) -> bool: stack = [] opening = {'(': ')', '[': ']', '{': '}'} closing = {')': '(', ']': '[', '}': '{'} for char in s: if char in opening: stack.append(char) elif char in closing: if not stack or stack[-1] != closing[char]: return False stack.pop() return len(stack) == 0"},{"question":"class LRUCache: A simple LRU (Least Recently Used) cache. >>> cache = LRUCache(2) >>> cache.set(1, 10) >>> cache.set(2, 20) >>> cache.get(1) 10 >>> cache.set(3, 30) # Evicts key 2 >>> cache.get(2) -1 >>> cache.set(4, 40) # Evicts key 1 >>> cache.get(1) -1 >>> cache.get(3) 30 >>> cache.get(4) 40 def __init__(self, capacity: int) -> None: # Implement this method pass def get(self, key: int) -> int: # Implement this method pass def set(self, key: int, value: int) -> None: # Implement this method pass","solution":"class LRUCache: def __init__(self, capacity: int) -> None: self.cache = {} self.capacity = capacity self.order = [] def get(self, key: int) -> int: if key in self.cache: self.order.remove(key) self.order.append(key) return self.cache[key] else: return -1 def set(self, key: int, value: int) -> None: if key in self.cache: self.order.remove(key) elif len(self.cache) >= self.capacity: oldest = self.order.pop(0) del self.cache[oldest] self.cache[key] = value self.order.append(key)"},{"question":"def validate_strings(strings: list, valid_chars: set) -> list: Validates each string in the list to contain only characters from valid_chars. >>> validate_strings([\\"hello\\", \\"hey\\"], {'h', 'e', 'l', 'o', 'y'}) == [True, True] >>> validate_strings([\\"hello\\", \\"world\\"], {'h', 'e', 'l', 'o'}) == [True, False] # Your implementation here def reverse_vowels(s: str) -> str: Reverses only the vowels in the input string s. >>> reverse_vowels(\\"hello\\") == \\"holle\\" >>> reverse_vowels(\\"hEllO\\") == \\"hOllE\\" # Your implementation here def test_validate_strings_all_valid(): assert validate_strings([\\"hello\\", \\"hey\\"], {'h', 'e', 'l', 'o', 'y'}) == [True, True] def test_validate_strings_some_invalid(): assert validate_strings([\\"hello\\", \\"world\\"], {'h', 'e', 'l', 'o'}) == [True, False] def test_validate_strings_all_invalid(): assert validate_strings([\\"abc\\", \\"def\\"], {'h', 'e', 'l', 'o'}) == [False, False] def test_reverse_vowels_general_case(): assert reverse_vowels(\\"hello\\") == \\"holle\\" def test_reverse_vowels_mixed_case(): assert reverse_vowels(\\"hEllO\\") == \\"hOllE\\" def test_reverse_vowels_no_vowels(): assert reverse_vowels(\\"bcdfg\\") == \\"bcdfg\\" def test_reverse_vowels_only_vowels(): assert reverse_vowels(\\"aeiouAEIOU\\") == \\"UOIEAuoiea\\" def test_reverse_vowels_single_vowel(): assert reverse_vowels(\\"a\\") == \\"a\\"","solution":"def validate_strings(strings: list, valid_chars: set) -> list: Validates each string in the list to contain only characters from valid_chars. return [all(char in valid_chars for char in s) for s in strings] def reverse_vowels(s: str) -> str: Reverses only the vowels in the input string s. vowels = \\"aeiouAEIOU\\" s_list = list(s) left, right = 0, len(s) - 1 while left < right: if s_list[left] not in vowels: left += 1 elif s_list[right] not in vowels: right += 1 else: s_list[left], s_list[right] = s_list[right], s_list[left] left += 1 right -= 1 return \\"\\".join(s_list)"},{"question":"from typing import List def find_position(nums: List[int], target: int) -> int: Function to perform binary search to find the target in a sorted list of integers \`nums\`. If the target is not found, returns the index where it would be inserted in sorted order. Args: nums (List[int]): A sorted list of integers. target (int): The target integer to find. Returns: int: The index of the target if found, or the index where it should be inserted to maintain the sorted order. Examples: >>> find_position([1, 3, 5, 6], 5) 2 >>> find_position([1, 3, 5, 6], 2) 1 >>> find_position([1, 3, 5, 6], 7) 4 >>> find_position([1, 3, 5, 6], 0) 0 >>> find_position([], 5) 0 import unittest class TestFindPosition(unittest.TestCase): def test_find_position_found(self): self.assertEqual(find_position([1, 3, 5, 6], 5), 2) self.assertEqual(find_position([1, 3, 5, 6], 6), 3) def test_find_position_not_found(self): self.assertEqual(find_position([1, 3, 5, 6], 2), 1) self.assertEqual(find_position([1, 3, 5, 6], 7), 4) self.assertEqual(find_position([1, 3, 5, 6], 0), 0) def test_find_position_empty_list(self): self.assertEqual(find_position([], 5), 0) def test_find_position_single_element(self): self.assertEqual(find_position([5], 5), 0) self.assertEqual(find_position([5], 6), 1) self.assertEqual(find_position([5], 4), 0) def test_find_position_large_elements(self): self.assertEqual(find_position([-10**6, 0, 10**6], -10**6), 0) self.assertEqual(find_position([-10**6, 0, 10**6], 0), 1) self.assertEqual(find_position([-10**6, 0, 10**6], 10**6), 2) self.assertEqual(find_position([-10**6, 0, 10**6], 500000), 2) self.assertEqual(find_position([-10**6, 0, 10**6], -500000), 1) if __name__ == \\"__main__\\": unittest.main()","solution":"from typing import List def find_position(nums: List[int], target: int) -> int: Function to perform binary search to find target in sorted list nums. If target is not found, returns the index where it would be inserted in sorted order. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"class InventoryTracker: Inventory Tracker class to manage item quantities over time and find maximum quantity in a given time interval. Example Usage: >>> tracker = InventoryTracker() >>> tracker.add_item(\\"item1\\", 50, 10) >>> tracker.add_item(\\"item2\\", 20, 15) >>> tracker.add_item(\\"item3\\", 35, 20) >>> tracker.add_item(\\"item1\\", 75, 25) >>> tracker.add_item(\\"item2\\", 40, 30) >>> tracker.max_quantity_between(10, 20) 50 >>> tracker.max_quantity_between(15, 25) 75 >>> tracker.max_quantity_between(5, 40) 75 def __init__(self): # Implement the initialization def add_item(self, name: str, quantity: int, time: int) -> None: # Implement add_item def max_quantity_between(self, start_time: int, end_time: int) -> int: # Implement max_quantity_between # Example Unit Test def test_add_item_and_query(): tracker = InventoryTracker() tracker.add_item(\\"item1\\", 50, 10) tracker.add_item(\\"item2\\", 20, 15) tracker.add_item(\\"item3\\", 35, 20) tracker.add_item(\\"item1\\", 75, 25) tracker.add_item(\\"item2\\", 40, 30) assert tracker.max_quantity_between(10, 20) == 50 assert tracker.max_quantity_between(15, 25) == 75 assert tracker.max_quantity_between(5, 40) == 75 def test_empty_tracker(): tracker = InventoryTracker() assert tracker.max_quantity_between(1, 10) == 0 def test_single_item(): tracker = InventoryTracker() tracker.add_item(\\"item1\\", 25, 5) assert tracker.max_quantity_between(1, 10) == 25 def test_multiple_items_same_time(): tracker = InventoryTracker() tracker.add_item(\\"item1\\", 30, 5) tracker.add_item(\\"item2\\", 50, 5) tracker.add_item(\\"item3\\", 20, 5) assert tracker.max_quantity_between(5, 5) == 50 assert tracker.max_quantity_between(1, 10) == 50 def test_no_items_in_interval(): tracker = InventoryTracker() tracker.add_item(\\"item1\\", 30, 5) tracker.add_item(\\"item2\\", 50, 15) tracker.add_item(\\"item3\\", 20, 25) assert tracker.max_quantity_between(10, 12) == 0 assert tracker.max_quantity_between(20, 23) == 0","solution":"import bisect class InventoryTracker: def __init__(self): self.data = [] def add_item(self, name: str, quantity: int, time: int) -> None: bisect.insort(self.data, (time, quantity)) def max_quantity_between(self, start_time: int, end_time: int) -> int: left_index = bisect.bisect_left(self.data, (start_time, float('-inf'))) right_index = bisect.bisect_right(self.data, (end_time, float('inf'))) max_quantity = 0 for i in range(left_index, right_index): max_quantity = max(max_quantity, self.data[i][1]) return max_quantity"},{"question":"import re def extract_emails(text: str) -> List[str]: Extracts and returns all valid email addresses from the input text. >>> extract_emails(\\"Please contact us at support@example.com or sales@example.org for more information.\\") ['support@example.com', 'sales@example.org'] >>> extract_emails(\\"There are no email addresses in this string.\\") [] >>> extract_emails(\\"Contact support@example.com or sales@example.org for support, or admin@site.net for administrative queries.\\") ['support@example.com', 'sales@example.org', 'admin@site.net']","solution":"import re def extract_emails(text): Extracts and returns all valid email addresses from the input text. email_pattern = re.compile(r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}') return email_pattern.findall(text)"},{"question":"import re from typing import List def extract_ipv4_addresses(text: str) -> List[str]: Extract all valid IPv4 addresses from a given string. A valid IPv4 address consists of four octets, each ranging from 0 to 255, separated by dots ('.'). Each octet cannot have leading zeros unless it is zero. >>> extract_ipv4_addresses(\\"Sample text 192.168.0.1 with IP addresses 255.255.255.255 and some 999.999.999.999 invalid 10.0.10.01 addresses\\") [\\"192.168.0.1\\", \\"255.255.255.255\\"] >>> extract_ipv4_addresses(\\"No valid IP here 256.256.256.256\\") [] >>> extract_ipv4_addresses(\\"Text with multiple valid IPs: 1.1.1.1 , 172.16.254.1. More text.\\") [\\"1.1.1.1\\", \\"172.16.254.1\\"] >>> extract_ipv4_addresses(\\"Another text with 0.0.0.0, 8.8.8.8, 172.16.254.1, and invalid 300.300.300.300 IPs\\") [\\"0.0.0.0\\", \\"8.8.8.8\\", \\"172.16.254.1\\"]","solution":"import re from typing import List def extract_ipv4_addresses(text: str) -> List[str]: Extract all valid IPv4 addresses from given text. ipv4_pattern = r'b(?:[0-9]{1,3}.){3}[0-9]{1,3}b' candidate_ips = re.findall(ipv4_pattern, text) valid_ips = [] for ip in candidate_ips: octets = ip.split('.') if all(octet.isdigit() and 0 <= int(octet) <= 255 and str(int(octet)) == octet for octet in octets): valid_ips.append(ip) return valid_ips"},{"question":"class Node: def __init__(self, start, end, min_val, second_min_val): self.start = start self.end = end self.min_val = min_val self.second_min_val = second_min_val self.left = None self.right = None def build_segment_tree(arr: List[int]) -> Node: Build the Segment Tree from an array of integers. >>> build_segment_tree([1, 3, 2, 7, 5, 4]).min_val 1 >>> build_segment_tree([1, 3, 2, 7, 5, 4]).second_min_val 2 ... def second_min_query(node: Node | None, left: int, right: int) -> int: Returns the second minimum value of the numbers in the range [left, right] of the array represented by the Segment Tree. >>> root = build_segment_tree([7, 3, 1, 5, 9, 0, 2, 4, 6, 8]) >>> second_min_query(root, 0, 5) 1 >>> second_min_query(root, 3, 8) 3 >>> second_min_query(root, 0, 1) 7 >>> second_min_query(root, 4, 4) -1 ... from typing import List def test_build_segment_tree(): root = build_segment_tree([1, 3, 2, 7, 5, 4]) assert root.min_val == 1 assert root.second_min_val == 2 def test_second_min_single_element(): root = build_segment_tree([1, 3, 2, 7, 5, 4]) assert second_min_query(root, 1, 1) == -1 def test_second_min_entire_range(): root = build_segment_tree([1, 3, 2, 7, 5, 4]) assert second_min_query(root, 0, 5) == 2 def test_second_min_sub_range(): root = build_segment_tree([1, 3, 2, 7, 5, 4]) assert second_min_query(root, 2, 4) == 5 def test_second_min_with_duplicates(): root = build_segment_tree([1, 1, 1, 1, 2, 2, 1]) assert second_min_query(root, 0, 6) == 2 def test_second_min_partial_overlap(): root = build_segment_tree([1, 2, 3, 4, 5, 6]) assert second_min_query(root, 1, 4) == 3 def test_second_min_no_second_min(): root = build_segment_tree([1]) assert second_min_query(root, 0, 0) == -1","solution":"class Node: def __init__(self, start, end, min_val, second_min_val): self.start = start self.end = end self.min_val = min_val self.second_min_val = second_min_val self.left = None self.right = None def build_segment_tree(arr): def build(start, end): if start == end: return Node(start, end, arr[start], float('inf')) mid = (start + end) // 2 left_child = build(start, mid) right_child = build(mid + 1, end) min_val = min(left_child.min_val, right_child.min_val) second_min_candidates = [] for node in [left_child, right_child]: if node.min_val > min_val: second_min_candidates.append(node.min_val) if node.second_min_val != float('inf'): second_min_candidates.append(node.second_min_val) second_min_val = min(second_min_candidates) if second_min_candidates else float('inf') root = Node(start, end, min_val, second_min_val) root.left = left_child root.right = right_child return root return build(0, len(arr) - 1) def second_min_query(node, left, right): if node.start > right or node.end < left: return float('inf'), float('inf') if left <= node.start and node.end <= right: return node.min_val, node.second_min_val left_min, left_second_min = second_min_query(node.left, left, right) right_min, right_second_min = second_min_query(node.right, left, right) min_val = min(left_min, right_min) second_min_candidates = set() for val in [left_min, left_second_min, right_min, right_second_min]: if val > min_val: second_min_candidates.add(val) second_min_val = min(second_min_candidates) if second_min_candidates else float('inf') return min_val, second_min_val def second_min(node, left, right): min_val, second_min_val = second_min_query(node, left, right) return second_min_val if second_min_val != float('inf') else -1"},{"question":"from typing import List def longest_balanced_subarray(arr: List[int]) -> int: Write a function that takes a list of integers as input and returns the length of the longest contiguous subarray with an equal number of 0s and 1s. Parameters: arr (List[int]): A list of integers where each integer is either 0 or 1. Returns: int: Length of the longest contiguous subarray with equal numbers of 0s and 1s. Example: >>> longest_balanced_subarray([0, 1, 0, 1, 0, 1]) 6 >>> longest_balanced_subarray([0, 1, 1, 0, 1, 0, 0]) 6 >>> longest_balanced_subarray([0, 0, 1, 1, 0]) 4 # Your code goes here... # Unit Tests import pytest def test_longest_balanced_subarray_all_balanced(): assert longest_balanced_subarray([0, 1, 0, 1, 0, 1]) == 6 assert longest_balanced_subarray([0, 1, 1, 0, 1, 0, 0]) == 6 def test_longest_balanced_subarray_partial_balanced(): assert longest_balanced_subarray([0, 0, 1, 1, 0]) == 4 def test_longest_balanced_subarray_no_balanced(): assert longest_balanced_subarray([0, 0, 0, 0]) == 0 assert longest_balanced_subarray([1, 1, 1, 1]) == 0 def test_longest_balanced_subarray_mixed_cases(): assert longest_balanced_subarray([0, 1, 0]) == 2 assert longest_balanced_subarray([0, 1, 1, 0, 0, 1, 1, 0]) == 8 assert longest_balanced_subarray([1, 0, 0, 1, 1, 0, 0, 0, 1, 1]) == 10 def test_empty_and_single_element_array(): assert longest_balanced_subarray([]) == 0 assert longest_balanced_subarray([0]) == 0 assert longest_balanced_subarray([1]) == 0 def test_long_unbalanced_with_one_zero(): assert longest_balanced_subarray([1]*50 + [0]) == 2 assert longest_balanced_subarray([0] + [1]*50) == 2 def test_more_complex_cases(): assert longest_balanced_subarray([0, 1, 0, 1, 0, 0, 1, 1]) == 8 assert longest_balanced_subarray([1, 0, 1, 0, 1, 0, 1, 0]) == 8 pytest.main()","solution":"def longest_balanced_subarray(arr): Returns the length of the longest contiguous subarray with equal numbers of 0s and 1s. # Convert all 0s to -1 for easier calculations arr = [-1 if x == 0 else 1 for x in arr] # This dictionary will store the first occurrence of each prefix sum sum_index_map = {} max_len = 0 prefix_sum = 0 for i in range(len(arr)): prefix_sum += arr[i] # If prefix sum is 0, we found a balanced subarray from start to i if prefix_sum == 0: max_len = i + 1 if prefix_sum in sum_index_map: max_len = max(max_len, i - sum_index_map[prefix_sum]) else: sum_index_map[prefix_sum] = i return max_len"},{"question":"from typing import List, Dict, Any def generate_sales_report(sales_data: List[Dict[str, Any]]) -> str: Generate a summary report from a list of dictionaries representing sales data. Each dictionary in the list should contain the following keys: - product (str): The name of the product. - quantity (int): The number of units sold. The function should aggregate the total quantity sold for each unique product and generate a summary report. Args: sales_data (List[Dict[str, Any]]): A list of dictionaries, where each dictionary represents a sale record. Returns: str: A formatted string representing the summary report. Each line in the report should have the product name and its total quantity sold, separated by a colon. >>> sales_data = [ ... {\\"product\\": \\"apple\\", \\"quantity\\": 10}, ... {\\"product\\": \\"banana\\", \\"quantity\\": 5}, ... {\\"product\\": \\"apple\\", \\"quantity\\": 7}, ... {\\"product\\": \\"orange\\", \\"quantity\\": 3} ... ] >>> generate_sales_report(sales_data) 'apple: 17nbanana: 5norange: 3' >>> sales_data = [] >>> generate_sales_report(sales_data) 'No sales data available.' >>> sales_data = [ ... {\\"product\\": \\"apple\\", \\"quantity\\": -10}, ... {\\"product\\": \\"banana\\", \\"quantity\\": 5} ... ] >>> generate_sales_report(sales_data) 'Invalid sales data encountered.' >>> sales_data = [ ... {\\"product\\": 123, \\"quantity\\": 10}, ... {\\"product\\": \\"banana\\", \\"quantity\\": 5} ... ] >>> generate_sales_report(sales_data) 'Invalid sales data encountered.' >>> sales_data = [ ... {\\"product\\": \\"apple\\", \\"quantity\\": 10}, ... {\\"product\\": \\"apple\\", \\"quantity\\": 5}, ... {\\"product\\": \\"banana\\", \\"quantity\\": 3}, ... {\\"product\\": \\"banana\\", \\"quantity\\": 7}, ... {\\"product\\": \\"orange\\", \\"quantity\\": 8} ... ] >>> generate_sales_report(sales_data) 'apple: 15nbanana: 10norange: 8'","solution":"from typing import List, Dict, Any def generate_sales_report(sales_data: List[Dict[str, Any]]) -> str: # Check for empty sales data if not sales_data: return \\"No sales data available.\\" # Dictionary to store aggregated quantities of each product product_totals = {} # Iterate through each sale record in the list for sale in sales_data: product = sale.get(\\"product\\") quantity = sale.get(\\"quantity\\", 0) # Validate data: Ensure product is a string and quantity is a non-negative integer if not isinstance(product, str) or not isinstance(quantity, int) or quantity < 0: return \\"Invalid sales data encountered.\\" # Accumulate quantity for each product if product in product_totals: product_totals[product] += quantity else: product_totals[product] = quantity # Generate report string report_lines = [f\\"{product}: {quantity}\\" for product, quantity in product_totals.items()] return \\"n\\".join(report_lines)"},{"question":"from typing import List def knapsack(W: int, weights: List[int], values: List[int]) -> int: Solve the knapsack problem to find the maximum total value of items that can fit into the knapsack. Parameters: W (int): Capacity of the knapsack weights (list): List of weights of the items values (list): List of values of the items Returns: int: The maximum total value that can be accommodated in the knapsack pass def test_knapsack_example_1(): W = 4 weights = [1, 2, 3] values = [10, 15, 40] assert knapsack(W, weights, values) == 50 def test_knapsack_example_2(): W = 5 weights = [2, 3, 4] values = [4, 5, 7] assert knapsack(W, weights, values) == 9 def test_knapsack_single_item_fits(): W = 3 weights = [2] values = [10] assert knapsack(W, weights, values) == 10 def test_knapsack_single_item_does_not_fit(): W = 1 weights = [2] values = [10] assert knapsack(W, weights, values) == 0 def test_knapsack_multiple_items(): W = 50 weights = [10, 20, 30] values = [60, 100, 120] assert knapsack(W, weights, values) == 220 def test_knapsack_full_capacity(): W = 7 weights = [1, 3, 4, 5] values = [1, 4, 5, 7] assert knapsack(W, weights, values) == 9 def test_knapsack_no_capacity(): W = 0 weights = [1, 3, 4, 5] values = [1, 4, 5, 7] assert knapsack(W, weights, values) == 0","solution":"def knapsack(W, weights, values): Solve the knapsack problem to find the maximum total value of items that can fit into the knapsack. Parameters: W (int): Capacity of the knapsack weights (list): List of weights of the items values (list): List of values of the items Returns: int: The maximum total value that can be accommodated in the knapsack n = len(weights) dp = [[0] * (W + 1) for _ in range(n + 1)] for i in range(1, n + 1): for w in range(W + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: dp[i][w] = dp[i - 1][w] return dp[n][W]"},{"question":"# Reversible Rotated Array In this exercise, you will implement the \`find_original\` function which identifies the original sorted array from a rotated array, where the rotation is unknown. The function takes as input a rotated array and returns the original sorted array. Your implementation should handle various edge cases and ensure efficient performance. Function Signature def find_original(rotated: list[int]) -> list[int]: Input: - \`rotated\`: A list of integers that represents a rotated sorted array. The array is sorted in ascending order, then rotated at some pivot. Output: - A list of integers representing the original sorted array. Constraints: 1. The input list should contain at least one element and no more than 10,000 elements. 2. The original list has unique elements and the rotation is arbitrary. Performance Requirements: - The solution should run in O(n) time complexity, where n is the number of elements in the list. - It should handle cases where the rotation makes all elements appear shifted. # Example Usage: # Example 1: Simple rotation rotated = [5, 6, 7, 1, 2, 3, 4] print(find_original(rotated)) # Expected output: [1, 2, 3, 4, 5, 6, 7] # Example 2: Rotation at midpoint rotated = [10, 11, 12, 3, 4, 5, 6, 7, 8, 9] print(find_original(rotated)) # Expected output: [3, 4, 5, 6, 7, 8, 9, 10, 11, 12] # Example 3: Rotated at the last element rotated = [20, 1, 2, 3] print(find_original(rotated)) # Expected output: [1, 2, 3, 20] # Example 4: Already sorted array rotated = [1, 2, 3, 4, 5] print(find_original(rotated)) # Expected output: [1, 2, 3, 4, 5] # Implementation Notes: - Your function should identify the pivot point where the rotation occurs. - Reconstruct the original sorted array by splitting and combining the segments of the rotated array. - Ensure to handle different edge cases, such as arrays with minimal rotation or no rotation. Unit Test: def test_find_original_simple_rotation(): assert find_original([5, 6, 7, 1, 2, 3, 4]) == [1, 2, 3, 4, 5, 6, 7] def test_find_original_rotation_at_midpoint(): assert find_original([10, 11, 12, 3, 4, 5, 6, 7, 8, 9]) == [3, 4, 5, 6, 7, 8, 9, 10, 11, 12] def test_find_original_rotation_at_last_element(): assert find_original([20, 1, 2, 3]) == [1, 2, 3, 20] def test_find_original_already_sorted(): assert find_original([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_find_original_single_element(): assert find_original([42]) == [42] def test_find_original_two_elements_rotated(): assert find_original([2, 1]) == [1, 2] def test_find_original_two_elements_sorted(): assert find_original([1, 2]) == [1, 2] def test_find_original_handle_empty_array(): assert find_original([]) == [] def test_find_original_large_array(): rotated = list(range(5000, 10000)) + list(range(5000)) expected = list(range(10000)) assert find_original(rotated) == expected Solution: def find_original(rotated: list[int]) -> list[int]: Identifies the original sorted array from a rotated array. if not rotated: return [] n = len(rotated) # Finding the index of the smallest element low, high = 0, n - 1 while low < high: mid = (low + high) // 2 if rotated[mid] > rotated[high]: low = mid + 1 else: high = mid # The array is rotated around the smallest element pivot = low # Reconstruct the original sorted array return rotated[pivot:] + rotated[:pivot]","solution":"def find_original(rotated: list[int]) -> list[int]: Identifies the original sorted array from a rotated array. if not rotated: return [] n = len(rotated) # Finding the index of the smallest element low, high = 0, n - 1 while low < high: mid = (low + high) // 2 if rotated[mid] > rotated[high]: low = mid + 1 else: high = mid # The array is rotated around the smallest element pivot = low # Reconstruct the original sorted array return rotated[pivot:] + rotated[:pivot]"},{"question":"def synchronize_changes(doc_id: str, changes: list) -> dict: Applies changes from different users to a document and resolves conflicts. Args: doc_id (str): Unique identifier for the document. changes (list): A list of dictionaries, each containing keys: - user_id (str): Identifier of the user who made the changes. - edit (str): The new text to be applied. - timestamp (int): Unix timestamp of when the edit was made. Returns: dict: The final state of the document with keys: - doc_id (str): the unique document ID. - content (str): the final text content of the document. >>> synchronize_changes(\\"doc_1\\", []) {\\"doc_id\\": \\"doc_1\\", \\"content\\": \\"\\"} >>> synchronize_changes(\\"doc_1\\", [{\\"user_id\\": \\"user1\\", \\"edit\\": \\"Hello\\", \\"timestamp\\": 1625077761}]) {\\"doc_id\\": \\"doc_1\\", \\"content\\": \\"Hello\\"} >>> synchronize_changes(\\"doc_1\\", [{\\"user_id\\": \\"user1\\", \\"edit\\": \\"Hello\\", \\"timestamp\\": 1625077761}, {\\"user_id\\": \\"user2\\", \\"edit\\": \\"Hello, world!\\", \\"timestamp\\": 1625077765}]) {\\"doc_id\\": \\"doc_1\\", \\"content\\": \\"Hello, world!\\"} >>> synchronize_changes(\\"doc_1\\", [{\\"user_id\\": \\"user1\\", \\"edit\\": \\"Hello\\", \\"timestamp\\": 1625077761}, {\\"user_id\\": \\"user3\\", \\"edit\\": \\"Hello, everyone!\\", \\"timestamp\\": 1625077763}, {\\"user_id\\": \\"user2\\", \\"edit\\": \\"Hello, world!\\", \\"timestamp\\": 1625077765}]) {\\"doc_id\\": \\"doc_1\\", \\"content\\": \\"Hello, world!\\"} >>> synchronize_changes(\\"doc_1\\", [{\\"user_id\\": \\"user1\\", \\"edit\\": \\"Hello\\"}, {\\"user_id\\": \\"user2\\", \\"edit\\": \\"Hello, world!\\", \\"timestamp\\": 1625077765}]) {\\"doc_id\\": \\"doc_1\\", \\"content\\": \\"Hello, world!\\"} >>> synchronize_changes(\\"doc_1\\", [{\\"user_id\\": \\"user1\\", \\"edit\\": \\"Hello\\"}, {\\"user_id\\": \\"user2\\", \\"edit\\": \\"Hello, world!\\"}]) {\\"doc_id\\": \\"doc_1\\", \\"content\\": \\"\\"} pass def test_empty_changes(): result = synchronize_changes(\\"doc_1\\", []) assert result == {\\"doc_id\\": \\"doc_1\\", \\"content\\": \\"\\"} def test_single_change(): changes = [{\\"user_id\\": \\"user1\\", \\"edit\\": \\"Hello\\", \\"timestamp\\": 1625077761}] result = synchronize_changes(\\"doc_1\\", changes) assert result == {\\"doc_id\\": \\"doc_1\\", \\"content\\": \\"Hello\\"} def test_multiple_changes_without_conflict(): changes = [ {\\"user_id\\": \\"user1\\", \\"edit\\": \\"Hello\\", \\"timestamp\\": 1625077761}, {\\"user_id\\": \\"user2\\", \\"edit\\": \\"Hello, world!\\", \\"timestamp\\": 1625077765} ] result = synchronize_changes(\\"doc_1\\", changes) assert result == {\\"doc_id\\": \\"doc_1\\", \\"content\\": \\"Hello, world!\\"} def test_multiple_changes_with_conflict(): changes = [ {\\"user_id\\": \\"user1\\", \\"edit\\": \\"Hello\\", \\"timestamp\\": 1625077761}, {\\"user_id\\": \\"user3\\", \\"edit\\": \\"Hello, everyone!\\", \\"timestamp\\": 1625077763}, {\\"user_id\\": \\"user2\\", \\"edit\\": \\"Hello, world!\\", \\"timestamp\\": 1625077765} ] result = synchronize_changes(\\"doc_1\\", changes) assert result == {\\"doc_id\\": \\"doc_1\\", \\"content\\": \\"Hello, world!\\"} def test_changes_with_missing_timestamps(): changes = [ {\\"user_id\\": \\"user1\\", \\"edit\\": \\"Hello\\"}, {\\"user_id\\": \\"user2\\", \\"edit\\": \\"Hello, world!\\", \\"timestamp\\": 1625077765} ] result = synchronize_changes(\\"doc_1\\", changes) assert result == {\\"doc_id\\": \\"doc_1\\", \\"content\\": \\"Hello, world!\\"} def test_all_changes_missing_timestamps(): changes = [ {\\"user_id\\": \\"user1\\", \\"edit\\": \\"Hello\\"}, {\\"user_id\\": \\"user2\\", \\"edit\\": \\"Hello, world!\\"} ] result = synchronize_changes(\\"doc_1\\", changes) assert result == {\\"doc_id\\": \\"doc_1\\", \\"content\\": \\"\\"}","solution":"def synchronize_changes(doc_id: str, changes: list) -> dict: Applies changes from different users to a document and resolves conflicts. Args: doc_id (str): Unique identifier for the document. changes (list): A list of dictionaries, each containing keys: - user_id (str): Identifier of the user who made the changes. - edit (str): The new text to be applied. - timestamp (int): Unix timestamp of when the edit was made. Returns: dict: The final state of the document. if not changes: return {\\"doc_id\\": doc_id, \\"content\\": \\"\\"} # Resolve conflicts by considering the latest edit based on timestamp changes = [change for change in changes if \\"timestamp\\" in change] if not changes: return {\\"doc_id\\": doc_id, \\"content\\": \\"\\"} latest_change = max(changes, key=lambda change: change['timestamp']) return {\\"doc_id\\": doc_id, \\"content\\": latest_change['edit']}"},{"question":"from typing import List def binary_search(arr: List[int], target: int) -> int: Binary Search in a Sorted Array. Given a sorted array of integers, return the index of the target value if it exists, otherwise return -1. >>> binary_search([1, 2, 3, 4, 5, 6], 4) 3 >>> binary_search([1, 2, 3, 4, 5, 6], 7) -1 >>> binary_search([-10, -5, 0, 5, 10], -5) 1 >>> binary_search([2, 4, 6, 8, 10, 12, 14], 10) 4 pass def test_binary_search_found(): assert binary_search([1, 2, 3, 4, 5, 6], 4) == 3 def test_binary_search_not_found(): assert binary_search([1, 2, 3, 4, 5, 6], 7) == -1 def test_binary_search_with_negative_numbers(): assert binary_search([-10, -5, 0, 5, 10], -5) == 1 def test_binary_search_even_sized_array(): assert binary_search([2, 4, 6, 8, 10, 12, 14], 10) == 4 def test_binary_search_single_element_found(): assert binary_search([5], 5) == 0 def test_binary_search_single_element_not_found(): assert binary_search([5], 3) == -1 def test_binary_search_target_is_first_element(): assert binary_search([1, 3, 5, 7, 9], 1) == 0 def test_binary_search_target_is_last_element(): assert binary_search([2, 4, 6, 8, 10], 10) == 4 def test_binary_search_empty_array(): assert binary_search([], 4) == -1","solution":"from typing import List def binary_search(arr: List[int], target: int) -> int: left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"from typing import List import math def calculate_tfidf(word: str, document: str, corpus: List[str]) -> float: Calculate the TF-IDF score of a word in a document relative to a corpus. Parameters: - word (str): The word for which TF-IDF score is to be calculated. - document (str): The document in which the word's frequency is to be measured. - corpus (List[str]): A list of strings representing the collection of documents. Returns: - float: The TF-IDF score of the word in the document. >>> word = \\"example\\" >>> document = \\"this is an example document with example word\\" >>> corpus = [\\"this is the first document\\", \\"this is an example document with example word\\", \\"another example document\\"] >>> calculate_tfidf(word, document, corpus) <expected_output> >>> word = \\"unique\\" >>> document = \\"another example document with unique word\\" >>> corpus = [\\"this is the first document\\", \\"this is an example document with example word\\", \\"another example document\\", \\"one more document\\"] >>> calculate_tfidf(word, document, corpus) <expected_output> >>> word = \\"is\\" >>> document = \\"this is an example document with example word\\" >>> corpus = [\\"this is the first document\\", \\"this is an example document with example word\\", \\"another example document\\"] >>> calculate_tfidf(word, document, corpus) <expected_output> >>> word = \\"once\\" >>> document = \\"word appears only once in this document\\" >>> corpus = [\\"this is the first document\\", \\"this is an example document\\", \\"word appears only once in this document\\"] >>> calculate_tfidf(word, document, corpus) <expected_output> >>> word = \\"single\\" >>> document = \\"single document only\\" >>> corpus = [\\"single document only\\"] >>> calculate_tfidf(word, document, corpus) <expected_output>","solution":"from typing import List import math def calculate_tfidf(word: str, document: str, corpus: List[str]) -> float: Calculate the TF-IDF score of a word in a document relative to a corpus. Parameters: - word (str): The word for which TF-IDF score is to be calculated. - document (str): The document in which the word's frequency is to be measured. - corpus (List[str]): A list of strings representing the collection of documents. Returns: - float: The TF-IDF score of the word in the document. # Calculate Term Frequency (TF) in the document words_in_document = document.split() term_count = words_in_document.count(word) tf = term_count / len(words_in_document) # Calculate Inverse Document Frequency (IDF) in the corpus num_documents_with_word = sum(1 for doc in corpus if word in doc.split()) idf = math.log(len(corpus) / (1 + num_documents_with_word)) # Calculate TF-IDF tfidf = tf * idf return tfidf"},{"question":"def dijkstra(graph: dict, start: int) -> dict: Uses Dijkstra's algorithm to find the shortest path from the start node to every other node in the graph. Parameters: graph (dict): A dictionary of dictionaries representing the graph. start (int): The starting node. Returns: dict: A dictionary where keys are the section numbers and values are the shortest travel times from the start section. pass def test_dijkstra_example(): graph = { 0: {1: 4, 2: 1}, 1: {3: 1}, 2: {1: 2, 3: 5}, 3: {} } start = 0 expected = {0: 0, 1: 3, 2: 1, 3: 4} assert dijkstra(graph, start) == expected def test_dijkstra_single_node(): graph = { 0: {} } start = 0 expected = {0: 0} assert dijkstra(graph, start) == expected def test_dijkstra_disconnected_nodes(): graph = { 0: {1: 4}, 1: {2: 3}, 2: {}, 3: {4: 2}, 4: {} } start = 0 expected = {0: 0, 1: 4, 2: 7, 3: float('inf'), 4: float('inf')} assert dijkstra(graph, start) == expected def test_dijkstra_no_edges(): graph = { 0: {}, 1: {}, 2: {} } start = 0 expected = {0: 0, 1: float('inf'), 2: float('inf')} assert dijkstra(graph, start) == expected def test_dijkstra_complex_graph(): graph = { 0: {1: 1, 2: 4}, 1: {2: 2, 3: 5}, 2: {3: 1}, 3: {4: 3}, 4: {} } start = 0 expected = {0: 0, 1: 1, 2: 3, 3: 4, 4: 7} assert dijkstra(graph, start) == expected","solution":"import heapq def dijkstra(graph, start): Uses Dijkstra's algorithm to find the shortest path from the start node to every other node in the graph. Parameters: graph (dict): A dictionary of dictionaries representing the graph. start (int): The starting node. Returns: dict: A dictionary where keys are the section numbers and values are the shortest travel times from the start section. # Initialize distances with infinity and set the distance to the start node to be 0 distances = {node: float('inf') for node in graph} distances[start] = 0 # Priority queue to store (distance, node) tuples priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the current distance is greater than the recorded shortest distance, skip this node if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node].items(): distance = current_distance + weight # Only consider this new path if it's better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"import re from typing import List, Dict def count_occurrences(document: str, words: List[str]) -> Dict[str, int]: Counts the occurrences of each word in the list \`words\` within the given \`document\`. >>> count_occurrences(\\"hello world, hello\\", [\\"hello\\", \\"world\\"]) {'hello': 2, 'world': 1} >>> count_occurrences(\\"\\", [\\"test\\"]) {'test': 0} from solution import count_occurrences def test_count_occurrences_example(): assert count_occurrences(\\"hello world, hello\\", [\\"hello\\", \\"world\\"]) == {'hello': 2, 'world': 1} def test_count_occurrences_empty_document(): assert count_occurrences(\\"\\", [\\"test\\"]) == {'test': 0} def test_count_occurrences_word_not_in_document(): assert count_occurrences(\\"The quick brown fox.\\", [\\"dog\\", \\"lion\\"]) == {'dog': 0, 'lion': 0} def test_count_occurrences_case_insensitivity(): assert count_occurrences(\\"Hello HELLO HeLlO\\", [\\"hello\\"]) == {'hello': 3} def test_count_occurrences_with_punctuation(): assert count_occurrences(\\"hello! world? hello.\\", [\\"hello\\", \\"world\\"]) == {'hello': 2, 'world': 1} def test_count_occurrences_multiple_words(): document = \\"one fish two fish red fish blue fish\\" words = [\\"fish\\", \\"red\\", \\"blue\\", \\"green\\"] assert count_occurrences(document, words) == {'fish': 4, 'red': 1, 'blue': 1, 'green': 0} def test_count_occurrences_no_target_word(): assert count_occurrences(\\"Some random text here.\\", []) == {} def test_count_occurrences_large_input(): document = \\"word \\" * 10**6 # large document words = [\\"word\\", \\"missing\\"] assert count_occurrences(document, words) == {'word': 10**6, 'missing': 0}","solution":"def count_occurrences(document, words): Counts the occurrences of each word in the list \`words\` within the given \`document\`. Parameters: - document (str): The text to be searched. - words (list): List of words to count in the document. Returns: dict: Dictionary with words as keys and their counts as values. # Initialize a dictionary to store the counts of each word word_counts = {word: 0 for word in words} # Convert the document into individual words, ignoring punctuation and case sensitivity import re document_words = re.findall(r'bw+b', document.lower()) # Count each word in the document for word in document_words: if word in word_counts: word_counts[word] += 1 return word_counts"},{"question":"def binary_search(arr: list[int], target: int) -> int: Searches for a target value in a sorted array using the binary search algorithm. Args: arr (list[int]): A sorted array of integers. target (int): The value to search for. Returns: int: The index of the target value if present, otherwise -1. Examples: >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) 4 >>> binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 11) -1 >>> binary_search([], 5) -1 >>> binary_search([3, 5, 7, 9, 11, 13], 7) 2 >>> binary_search([3, 5, 7, 9, 11, 13], 6) -1","solution":"def binary_search(arr, target): Searches for a target value in a sorted array using the binary search algorithm. Args: arr (list[int]): A sorted array of integers. target (int): The value to search for. Returns: int: The index of the target value if present, otherwise -1. left, right = 0, len(arr) - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def can_transform_via_swaps(s: str, t: str) -> bool: Determines if string \`s\` can be transformed into string \`t\` using only adjacent swaps. >>> can_transform_via_swaps(\\"abc\\", \\"bca\\") == True >>> can_transform_via_swaps(\\"aa\\", \\"bb\\") == False >>> can_transform_via_swaps(\\"aab\\", \\"bba\\") == False >>> can_transform_via_swaps(\\"ab\\", \\"ba\\") == True >>> can_transform_via_swaps(\\"xyz\\", \\"zyx\\") == True","solution":"def can_transform_via_swaps(s: str, t: str) -> bool: Determines if string \`s\` can be transformed into string \`t\` using only adjacent swaps. # To transform s to t using adjacent swaps, # both strings must have the same characters with the same frequencies. return sorted(s) == sorted(t)"},{"question":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, val): Insert an integer value into the BST. If the value already exists, ignore the insertion. pass def delete(self, val): Delete a node with the given integer value from the BST. If the value does not exist, do nothing. pass def search(self, val): Search for an integer value in the BST. Return True if the value exists, otherwise return False. pass def inorder_traversal(self): Return a list of all elements in the BST in in-order sequence. pass def find_lca(self, val1, val2): Find the lowest common ancestor (LCA) of two nodes containing the given integer values. Return the value of the LCA. If either value does not exist, return None. pass # Example usage if __name__ == \\"__main__\\": bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) bst.insert(12) bst.insert(18) print(bst.inorder_traversal()) # Output: [3, 5, 7, 10, 12, 15, 18] print(bst.search(7)) # Output: True print(bst.search(8)) # Output: False bst.delete(5) print(bst.inorder_traversal()) # Output: [3, 7, 10, 12, 15, 18] print(bst.find_lca(3, 7)) # Output: 10 print(bst.find_lca(12, 18)) # Might Output: 15","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, val): if self.root is None: self.root = Node(val) else: self._insert(self.root, val) def _insert(self, root, val): if val < root.val: if root.left is None: root.left = Node(val) else: self._insert(root.left, val) elif val > root.val: if root.right is None: root.right = Node(val) else: self._insert(root.right, val) def delete(self, val): self.root = self._delete(self.root, val) def _delete(self, root, val): if root is None: return root if val < root.val: root.left = self._delete(root.left, val) elif val > root.val: root.right = self._delete(root.right, val) else: if root.left is None: return root.right elif root.right is None: return root.left min_val_node = self._get_min(root.right) root.val = min_val_node.val root.right = self._delete(root.right, min_val_node.val) return root def _get_min(self, root): current = root while current.left is not None: current = current.left return current def search(self, val): return self._search(self.root, val) def _search(self, root, val): if root is None: return False if val == root.val: return True elif val < root.val: return self._search(root.left, val) else: return self._search(root.right, val) def inorder_traversal(self): result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, root, result): if root: self._inorder_traversal(root.left, result) result.append(root.val) self._inorder_traversal(root.right, result) def find_lca(self, val1, val2): return self._find_lca(self.root, val1, val2) def _find_lca(self, root, val1, val2): if root is None: return None if val1 < root.val and val2 < root.val: return self._find_lca(root.left, val1, val2) if val1 > root.val and val2 > root.val: return self._find_lca(root.right, val1, val2) if self._search(root, val1) and self._search(root, val2): return root.val else: return None"},{"question":"import numpy as np def normalize_features(train_x, test_x): Normalizes the training and test datasets to have zero mean and unit variance. @param train_x: A 2D numpy array of training features. @param test_x: A 2D numpy array of test features. @return: Two 2D numpy arrays: the normalized training features and test features. >>> train_x = np.array([[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]]) >>> test_x = np.array([[2.0, 3.0], [4.0, 5.0]]) >>> normalize_features(train_x, test_x) (array([[-1.22474487, -1.22474487], [ 0. , 0. ], [ 1.22474487, 1.22474487]]), array([[-0.61237244, -0.61237244], [ 0.61237244, 0.61237244]])) # Your code here pass","solution":"import numpy as np def normalize_features(train_x, test_x): Normalizes the training and test datasets to have zero mean and unit variance. @param train_x: A 2D numpy array of training features. @param test_x: A 2D numpy array of test features. @return: Two 2D numpy arrays: the normalized training features and test features. # Calculate mean and standard deviation from the training data mean = np.mean(train_x, axis=0) std = np.std(train_x, axis=0) # Avoid division by zero by setting std to 1 where it is zero std[std == 0] = 1 # Normalize both training and test sets train_x_normalized = (train_x - mean) / std test_x_normalized = (test_x - mean) / std return train_x_normalized, test_x_normalized"},{"question":"from typing import List, Dict def classify_books(books: List[Dict[str, str]]) -> Dict[str, List[str]]: Classify books into various categories based on given condition. 1. Books by authors with names containing digits. 2. Books classified as \\"fiction\\". 3. Books whose titles contain special characters (such as \`!\`, \`@\`, \`#\`, etc.). 4. Books published in the 21st century (from the year 2000 onwards). 5. Books with titles starting with the letter \\"A\\". >>> books = [ ... {\\"title\\": \\"A Tale of Two Cities\\", \\"author\\": \\"Charles Dickens\\", \\"genre\\": \\"fiction\\", \\"year\\": \\"1859\\"}, ... {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"genre\\": \\"fiction\\", \\"year\\": \\"1949\\"}, ... {\\"title\\": \\"Br@ve New World\\", \\"author\\": \\"Aldous Huxley\\", \\"genre\\": \\"fiction\\", \\"year\\": \\"1932\\"}, ... {\\"title\\": \\"Dracula\\", \\"author\\": \\"Bram Stoker\\", \\"genre\\": \\"horror\\", \\"year\\": \\"1897\\"}, ... {\\"title\\": \\"The Catcher in the Rye\\", \\"author\\": \\"J.D. Salinger\\", \\"genre\\": \\"fiction\\", \\"year\\": \\"1951\\"}, ... {\\"title\\": \\"The Road\\", \\"author\\": \\"Cormac McCarthy\\", \\"genre\\": \\"fiction\\", \\"year\\": \\"2006\\"}, ... {\\"title\\": \\"A00000\\", \\"author\\": \\"Author7\\", \\"genre\\": \\"drama\\", \\"year\\": \\"2000\\"}, ... ] >>> expected_output = { ... \\"author_digits\\": [\\"A00000\\"], ... \\"fiction\\": [\\"A Tale of Two Cities\\", \\"1984\\", \\"Br@ve New World\\", \\"The Catcher in the Rye\\", \\"The Road\\"], ... \\"special_characters\\": [\\"Br@ve New World\\"], ... \\"21st_century\\": [\\"The Road\\", \\"A00000\\"], ... \\"title_starts_with_A\\": [\\"A Tale of Two Cities\\", \\"A00000\\"], ... } >>> result = classify_books(books) >>> assert result == expected_output >>> books = [] >>> expected_output = { ... \\"author_digits\\": [], ... \\"fiction\\": [], ... \\"special_characters\\": [], ... \\"21st_century\\": [], ... \\"title_starts_with_A\\": [] ... } >>> result = classify_books(books) >>> assert result == expected_output >>> books = [ ... {\\"title\\": \\"Good Omens\\", \\"author\\": \\"Neil Gaiman\\", \\"genre\\": \\"fiction\\", \\"year\\": \\"\\"}, ... {\\"title\\": \\"The Silent Patient\\", \\"author\\": \\"Alex Michaelides\\", \\"genre\\": \\"thriller\\", \\"year\\": \\"2019\\"}, ... {\\"title\\": \\"Dr@cula\\", \\"author\\": \\"Bram Stoker\\", \\"genre\\": \\"horror\\", \\"year\\": \\"1897\\"}, ... {\\"title\\": \\"\\", \\"author\\": \\"\\", \\"genre\\": \\"\\", \\"year\\": \\"2020\\"}, ... {\\"title\\": \\"\\", \\"author\\": \\"Unknown\\", \\"genre\\": \\"non-fiction\\", \\"year\\": \\"2000\\"} ... ] >>> expected_output = { ... \\"author_digits\\": [], ... \\"fiction\\": [], ... \\"special_characters\\": [\\"Dr@cula\\"], ... \\"21st_century\\": [\\"The Silent Patient\\"], ... \\"title_starts_with_A\\": [] ... } >>> result = classify_books(books) >>> assert result == expected_output >>> books = [ ... {\\"title\\": \\"A@ Tale! of Two Cities\\", \\"author\\": \\"Charles Dickens\\", \\"genre\\": \\"fiction\\", \\"year\\": \\"1859\\"}, ... {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"genre\\": \\"fiction\\", \\"year\\": \\"1949\\"}, ... ] >>> expected_output = { ... \\"author_digits\\": [], ... \\"fiction\\": [\\"A@ Tale! of Two Cities\\", \\"1984\\"], ... \\"special_characters\\": [\\"A@ Tale! of Two Cities\\"], ... \\"21st_century\\": [], ... \\"title_starts_with_A\\": [\\"A@ Tale! of Two Cities\\"] ... } >>> result = classify_books(books) >>> assert result == expected_output pass","solution":"import re from typing import List, Dict def classify_books(books: List[Dict[str, str]]) -> Dict[str, List[str]]: classified_books = { \\"author_digits\\": [], \\"fiction\\": [], \\"special_characters\\": [], \\"21st_century\\": [], \\"title_starts_with_A\\": [] } for book in books: title = book.get(\\"title\\", \\"\\") author = book.get(\\"author\\", \\"\\") genre = book.get(\\"genre\\", \\"\\") year = book.get(\\"year\\", \\"\\") if not title or not author or not genre or not year or not (year.isdigit() and len(year) == 4): continue year = int(year) if re.search(r'd', author): classified_books[\\"author_digits\\"].append(title) if genre.lower() == \\"fiction\\": classified_books[\\"fiction\\"].append(title) if re.search(r'[!@#%^&*()_+-=[]{}|:;\\"',<>./?]', title): classified_books[\\"special_characters\\"].append(title) if year >= 2000: classified_books[\\"21st_century\\"].append(title) if title.startswith(\\"A\\"): classified_books[\\"title_starts_with_A\\"].append(title) return classified_books"},{"question":"def make_palindrome(input_text: str) -> str: This function checks if the input_text is a palindrome. If it is not a palindrome, it modifies the string by appending the minimum number of characters to make it a palindrome and returns the modified string. >>> make_palindrome(\\"race\\") 'racecar' >>> make_palindrome(\\"madam\\") 'madam' >>> make_palindrome(\\"abc\\") 'abcba'","solution":"def make_palindrome(input_text: str) -> str: This function checks if the input_text is a palindrome, and if it is not, modifies it to be a palindrome by adding the minimum number of characters at the end. if input_text == input_text[::-1]: return input_text # Function to find the longest palindromic suffix def longest_palindromic_suffix(text): n = len(text) for i in range(n): if text[i:] == text[i:][::-1]: return text[i:] return \\"\\" lps = longest_palindromic_suffix(input_text) return input_text + input_text[::-1][len(lps):]"},{"question":"def search_matrix(matrix: list[list[int]], target: int) -> tuple[int, int]: Returns the position (row, column) of target in the matrix if it exists, otherwise returns (-1, -1). The matrix is sorted in ascending order both row-wise and column-wise. Examples: >>> search_matrix([[1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]], 5) (1, 1) >>> search_matrix([[1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]], 20) (-1, -1) >>> search_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 9) (2, 2) >>> search_matrix([[1]], 1) (0, 0) >>> search_matrix([[]], 1) (-1, -1)","solution":"def search_matrix(matrix: list[list[int]], target: int) -> tuple[int, int]: Returns the position (row, column) of target in the matrix if it exists, otherwise returns (-1, -1). The matrix is sorted in ascending order both row-wise and column-wise. if not matrix or not matrix[0]: return (-1, -1) rows = len(matrix) cols = len(matrix[0]) row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return (row, col) elif matrix[row][col] > target: col -= 1 else: row += 1 return (-1, -1)"},{"question":"def kebab_to_camel_case(input_str: str) -> str: Converts a kebab-case string to camelCase. Parameters: input_str (str): The input string in kebab-case. Returns: str: The converted string in camelCase. Raises: ValueError: If the input is not a string. pass # Test cases def test_kebab_to_camel_case(): assert kebab_to_camel_case(\\"kebab-case-example\\") == \\"kebabCaseExample\\" assert kebab_to_camel_case(\\"another-thing-to-test\\") == \\"anotherThingToTest\\" assert kebab_to_camel_case(\\"some-random-string-here\\") == \\"someRandomStringHere\\" assert kebab_to_camel_case(\\"400-kebab-case\\") == \\"400KebabCase\\" def test_empty_string(): assert kebab_to_camel_case(\\"\\") == \\"\\" def test_single_word(): assert kebab_to_camel_case(\\"singleword\\") == \\"singleword\\" def test_multiple_hyphens(): assert kebab_to_camel_case(\\"multiple--hyphens\\") == \\"multipleHyphens\\" def test_numeric_parts(): assert kebab_to_camel_case(\\"123-abc\\") == \\"123Abc\\" assert kebab_to_camel_case(\\"abc-123\\") == \\"abc123\\" def test_uppercase_input(): assert kebab_to_camel_case(\\"UPPER-CASE\\") == \\"upperCase\\" def test_invalid_input_type(): try: kebab_to_camel_case(123) # this should raise a ValueError except ValueError as e: assert str(e) == \\"Expected a string, but got int\\" def test_long_string(): long_kebab_case = \\"a\\" + \\"-word\\" * 25000 expected_camel_case = \\"a\\" + \\"\\".join(\\"Word\\" for _ in range(25000)) assert kebab_to_camel_case(long_kebab_case) == expected_camel_case","solution":"def kebab_to_camel_case(input_str: str) -> str: Converts a kebab-case string to camelCase. Parameters: input_str (str): The input string in kebab-case. Returns: str: The converted string in camelCase. Raises: ValueError: If the input is not a string. if not isinstance(input_str, str): raise ValueError(f\\"Expected a string, but got {type(input_str).__name__}\\") words = input_str.split('-') camel_case_list = [words[0].lower()] + [word.capitalize() for word in words[1:]] return ''.join(camel_case_list)"},{"question":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotate the array to the right by k positions. arr: List[int] - A list of integers to be rotated k: int - The number of positions to rotate the array to the right returns: A new list of integers rotated by k positions >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3], 4) [3, 1, 2] >>> rotate_array([], 3) [] >>> rotate_array([1], 5) [1] >>> rotate_array([1, 2, 3], 0) [1, 2, 3] >>> rotate_array([1, 2, 3, 4], 4) [1, 2, 3, 4] >>> rotate_array([1, 2, 3, 4], 8) [1, 2, 3, 4] >>> rotate_array([1, 2, 3, 4], 12) [1, 2, 3, 4]","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotate the array to the right by k positions. arr: List[int] - A list of integers to be rotated k: int - The number of positions to rotate the array to the right returns: A new list of integers rotated by k positions if not arr: return [] n = len(arr) k = k % n # Use modulus to handle cases where k > len(arr) return arr[-k:] + arr[:-k]"},{"question":"def is_picnic_day(weather: dict) -> bool: Determines if the weather conditions are suitable for an outdoor picnic. Parameters: weather (dict): A dictionary containing the following keys: - \\"temperature\\": float, the temperature in degrees Celsius - \\"humidity\\": float, the humidity percentage - \\"chance_of_rain\\": float, the chance of rain percentage Returns: bool: True if the day is suitable for a picnic, False otherwise. Example: >>> is_picnic_day({ ... \\"temperature\\": 25.0, ... \\"humidity\\": 45.0, ... \\"chance_of_rain\\": 10.0 ... }) True >>> is_picnic_day({ ... \\"temperature\\": 35.0, ... \\"humidity\\": 40.0, ... \\"chance_of_rain\\": 10.0 ... }) False","solution":"def is_picnic_day(weather: dict) -> bool: Determines if the weather conditions are suitable for an outdoor picnic. Parameters: weather (dict): A dictionary containing the following keys: - \\"temperature\\": float, the temperature in degrees Celsius - \\"humidity\\": float, the humidity percentage - \\"chance_of_rain\\": float, the chance of rain percentage Returns: bool: True if the day is suitable for a picnic, False otherwise. temperature = weather.get(\\"temperature\\") humidity = weather.get(\\"humidity\\") chance_of_rain = weather.get(\\"chance_of_rain\\") if 20 <= temperature <= 30 and humidity < 60 and chance_of_rain < 20: return True return False"},{"question":"from typing import List def top_k_frequent_books(transactions: List[str], k: int) -> List[str]: Returns the k most frequently borrowed book titles from the transactions list. If there are ties, the titles are sorted alphabetically. >>> transactions = [ \\"To Kill a Mockingbird\\", \\"1984\\", \\"Harry Potter and the Philosopher's Stone\\", \\"To Kill a Mockingbird\\", \\"1984\\", \\"Harry Potter and the Philosopher's Stone\\", \\"To Kill a Mockingbird\\" ] >>> k = 2 >>> top_k_frequent_books(transactions, k) [\\"To Kill a Mockingbird\\", \\"1984\\"] >>> transactions = [\\"The Great Gatsby\\", \\"The Great Gatsby\\", \\"Crime and Punishment\\", \\"Crime and Punishment\\", \\"War and Peace\\"] >>> k = 2 >>> top_k_frequent_books(transactions, k) [\\"Crime and Punishment\\", \\"The Great Gatsby\\"] pass","solution":"from typing import List from collections import Counter def top_k_frequent_books(transactions: List[str], k: int) -> List[str]: Returns the k most frequently borrowed book titles from the transactions list. If there are ties, the titles are sorted alphabetically. :param transactions: List of book titles in transactions. :param k: The number of top frequent books to return. :returns: List of k most frequent book titles in descending order of frequency. # Count the frequency of each book title count = Counter(transactions) # Sort the books first by frequency (descending) and then alphabetically sorted_books = sorted(count.items(), key=lambda x: (-x[1], x[0])) # Extract the top k book titles top_k_books = [book for book, freq in sorted_books[:k]] return top_k_books"},{"question":"Complete the function \`find_shortest_path\` to determine the shortest path between a start node and an end node in an undirected graph represented by an adjacency matrix. The function should use Breadth-First Search (BFS). # Parameters: - \`graph\` (List[List[int]]): An adjacency matrix representing the undirected graph, where \`graph[i][j]\` is \`1\` if there is an edge between node \`i\` and node \`j\`, and \`0\` otherwise (0  i, j < n, n  100). - \`start\` (int): The starting node (0  start < n). - \`end\` (int): The destination node (0  end < n). # Returns: - The shortest path as a list of node indices from the \`start\` node to the \`end\` node if a path exists. - The string \\"No Path Available\\" if no path exists. # Example: def find_shortest_path(graph: List[List[int]], start: int, end: int) -> List[int]: # Your code here pass # Example usage: graph = [ [0, 1, 0, 0, 1], [1, 0, 1, 0, 0], [0, 1, 0, 1, 1], [0, 0, 1, 0, 1], [1, 0, 1, 1, 0] ] print(find_shortest_path(graph, 0, 3)) # Output: [0, 4, 3] or [0, 4, 2, 3] print(find_shortest_path(graph, 3, 4)) # Output: [3, 4] print(find_shortest_path(graph, 1, 4)) # Output: [1, 2, 4] print(find_shortest_path(graph, 2, 0)) # Output: [2, 1, 0] # Hints: 1. Utilize a queue to implement BFS and keep track of the nodes visited. 2. Maintain a dictionary or list to reconstruct the path from the start node to the end node. 3. Check all nodes from the start node by marking them as visited to avoid cycles. # Additional Notes: - Assume the graph is connected and contains no negative weight cycles. - Node indices are zero-based. from typing import List, Union from collections import deque, defaultdict def find_shortest_path(graph: List[List[int]], start: int, end: int) -> Union[List[int], str]: Determine the shortest path between start and end nodes using BFS. Parameters: - graph: adjacency matrix representing the undirected graph - start: starting node - end: destination node Returns: - the shortest path as a list of node indices if a path exists - \\"No Path Available\\" if no path exists if start == end: return [start] n = len(graph) visited = [False] * n parent = [-1] * n queue = deque([start]) visited[start] = True while queue: current = queue.popleft() for neighbor in range(n): if graph[current][neighbor] == 1 and not visited[neighbor]: visited[neighbor] = True parent[neighbor] = current queue.append(neighbor) if neighbor == end: path = [] while neighbor != -1: path.insert(0, neighbor) neighbor = parent[neighbor] return path return \\"No Path Available\\"","solution":"from typing import List, Union from collections import deque, defaultdict def find_shortest_path(graph: List[List[int]], start: int, end: int) -> Union[List[int], str]: Determine the shortest path between start and end nodes using BFS. Parameters: - graph: adjacency matrix representing the undirected graph - start: starting node - end: destination node Returns: - the shortest path as a list of node indices if a path exists - \\"No Path Available\\" if no path exists if start == end: return [start] n = len(graph) visited = [False] * n parent = [-1] * n queue = deque([start]) visited[start] = True while queue: current = queue.popleft() for neighbor in range(n): if graph[current][neighbor] == 1 and not visited[neighbor]: visited[neighbor] = True parent[neighbor] = current queue.append(neighbor) if neighbor == end: path = [] while neighbor != -1: path.insert(0, neighbor) neighbor = parent[neighbor] return path return \\"No Path Available\\""},{"question":"def min_flips_to_same_face(coins: list[int]) -> int: Given a list of integers, where each integer is either 0 (heads) or 1 (tails), returns the minimum number of flips required to make all elements in the list the same. Returns an integer representing the minimum number of coin flips. Examples: >>> min_flips_to_same_face([0, 1, 1, 0, 1]) 2 >>> min_flips_to_same_face([1, 1, 1, 1, 1]) 0 >>> min_flips_to_same_face([0, 0, 0, 0, 1]) 1 >>> min_flips_to_same_face([0]) 0","solution":"def min_flips_to_same_face(coins): Given a list of integers, where each integer is either 0 (heads) or 1 (tails), returns the minimum number of flips required to make all elements in the list the same. Returns an integer representing the minimum number of coin flips. # Count the number of heads (0s) and tails (1s) in the coins list count_heads = coins.count(0) count_tails = len(coins) - count_heads # The minimum number of flips will be the lesser count of heads or tails return min(count_heads, count_tails)"},{"question":"def deep_copy(data: list) -> list: Return a deep copy of the input list. The function takes a list, which may contain nested lists, integers, floats, and strings, and returns a new list that is a deep copy of the input list. Args: data (list): A list that may contain integers, floats, strings, and other nested lists. Returns: list: A new list that is a deep copy of the input list. Raises: TypeError: If the input is not a list. Examples: >>> data = [[1, 2, [3, 4]], 5, \\"hello\\"] >>> copy_data = deep_copy(data) >>> assert copy_data == data >>> assert copy_data is not data # Ensure it is a new list >>> assert copy_data[0] is not data[0] # Ensure nested lists are also new >>> data[0][2][0] = 99 >>> assert copy_data != data # Ensure the copy is not affected by changes to the original >>> # Test with an empty list >>> assert deep_copy([]) == [] >>> # Test with a flat list >>> assert deep_copy([1, 2, 3]) == [1, 2, 3] >>> assert deep_copy([1, 2, 3]) is not [1, 2, 3] >>> # Test with a list of strings >>> assert deep_copy([\\"a\\", \\"b\\", \\"c\\"]) == [\\"a\\", \\"b\\", \\"c\\"] >>> assert deep_copy([\\"a\\", \\"b\\", \\"c\\"]) is not [\\"a\\", \\"b\\", \\"c\\"] >>> try: >>> deep_copy(\\"not a list\\") >>> except TypeError: >>> pass # This is expected","solution":"def deep_copy(data): Return a deep copy of the input list. if not isinstance(data, list): raise TypeError(\\"Input must be a list\\") def copy_recursive(item): if isinstance(item, list): return [copy_recursive(sub_item) for sub_item in item] return item return copy_recursive(data)"},{"question":"def pascal_triangle_row_sum(n: int, k: int) -> int: Returns the sum of the elements in the k-th row of Pascal's Triangle. >>> pascal_triangle_row_sum(5, 2) 4 >>> pascal_triangle_row_sum(10, 3) 8 >>> pascal_triangle_row_sum(6, 0) 1","solution":"def pascal_triangle_row_sum(n: int, k: int) -> int: Returns the sum of the elements in the k-th row of Pascal's Triangle. # The sum of the elements in the k-th row of Pascal's Triangle is 2^k return 2 ** k"},{"question":"# Consecutive Sum Checker **Objective**: Write a function to determine if a given number can be expressed as the sum of two or more consecutive positive integers, adhering to specific constraints and requirements. Function Signature def is_consecutive_sum(number: int) -> bool: Returns True if the number can be expressed as a sum of two or more consecutive integers, False otherwise. pass # Example def is_consecutive_sum(number: int) -> bool: if not isinstance(number, int) or number <= 0: raise TypeError(\\"Input must be a positive integer\\") # Check for any k (number of terms) such that k*(k+1)/2 + k*n for some n >= 0 equals the number for k in range(2, int((2 * number) ** 0.5) + 1): if (number - k * (k - 1) // 2) % k == 0: return True return False # Unit Test from solution import is_consecutive_sum def test_valid_consecutive_sum_cases(): assert is_consecutive_sum(15) == True # 1+2+3+4+5 or 4+5+6 assert is_consecutive_sum(21) == True # 6+7+8 or 1+2+3+4+5+6 assert is_consecutive_sum(10) == True # 1+2+3+4 or 1+2+3+4 assert is_consecutive_sum(5050) == True # 1+2+3+...+100 or similar def test_invalid_consecutive_sum_cases(): assert is_consecutive_sum(16) == False # No such consecutive sum exists assert is_consecutive_sum(4) == False # No such consecutive sum exists assert is_consecutive_sum(1) == False # Single number only def test_large_numbers(): assert is_consecutive_sum(1000000000000) == True # Example of large number def test_type_error(): try: is_consecutive_sum(-10) except TypeError: assert True else: assert False, \\"Expected a TypeError\\" try: is_consecutive_sum(0) except TypeError: assert True else: assert False, \\"Expected a TypeError\\" try: is_consecutive_sum(\\"string\\") except TypeError: assert True else: assert False, \\"Expected a TypeError\\" try: is_consecutive_sum(10.5) except TypeError: assert True else: assert False, \\"Expected a TypeError\\"","solution":"def is_consecutive_sum(number: int) -> bool: if not isinstance(number, int) or number <= 0: raise TypeError(\\"Input must be a positive integer\\") # Check for any k (number of terms) such that k*(k+1)/2 + k*n for some n >= 0 equals the number for k in range(2, int((2 * number) ** 0.5) + 1): if (number - k * (k - 1) // 2) % k == 0: return True return False"},{"question":"from typing import List def find_longest_increasing_subsequence(prices: List[int]) -> List[int]: Find and return the longest increasing subsequence in a list of integers. >>> find_longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) [10, 22, 33, 50, 60, 80] >>> find_longest_increasing_subsequence([3, 10, 2, 1, 20]) [3, 10, 20] >>> find_longest_increasing_subsequence([1]) [1] >>> find_longest_increasing_subsequence([]) [] >>> find_longest_increasing_subsequence([7, 7, 7, 7, 7]) [7] >>> find_longest_increasing_subsequence([5, 4, 3, 2, 1]) [5] >>> find_longest_increasing_subsequence([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5]","solution":"from typing import List def find_longest_increasing_subsequence(prices: List[int]) -> List[int]: if not prices: return [] n = len(prices) lengths = [1] * n predecessors = [-1] * n for i in range(1, n): for j in range(i): if prices[i] > prices[j] and lengths[i] < lengths[j] + 1: lengths[i] = lengths[j] + 1 predecessors[i] = j # Find the index of the maximum length LIS max_length = max(lengths) max_index = lengths.index(max_length) # Reconstruct the longest increasing subsequence lis = [] while max_index != -1: lis.append(prices[max_index]) max_index = predecessors[max_index] return lis[::-1]"},{"question":"def sum_of_digits(number: str) -> int: Compute the sum of the digits of the provided large integer. def max_sum_of_digits(filename: str = \\"numbers.txt\\") -> int: Compute the maximum sum of digits among all numbers in the given file. # Example: Given an example file \\"example.txt\\" with the following contents: 123456789 987654321 1111111111111111111111111111111111 Running \`max_sum_of_digits(\\"example.txt\\")\` should return \`34\`. # Unit Test: from solution import sum_of_digits, max_sum_of_digits import tempfile def test_sum_of_digits(): assert sum_of_digits(\\"123456789\\") == 45 assert sum_of_digits(\\"987654321\\") == 45 assert sum_of_digits(\\"1111111111111111111111111111111111\\") == 34 assert sum_of_digits(\\"0\\") == 0 assert sum_of_digits(\\"9999999999\\") == 90 def test_max_sum_of_digits(): # Create a temporary file for testing with tempfile.NamedTemporaryFile(mode='w+', delete=False) as temp_file: temp_file.write(\\"123456789n\\") temp_file.write(\\"987654321n\\") temp_file.write(\\"1111111111111111111111111111111111n\\") temp_file.write(\\"9999999999n\\") temp_file.write(\\"0n\\") temp_file_name = temp_file.name assert max_sum_of_digits(temp_file_name) == 90","solution":"def sum_of_digits(number: str) -> int: Compute the sum of the digits of the provided large integer. return sum(int(digit) for digit in number) def max_sum_of_digits(filename: str = \\"numbers.txt\\") -> int: Compute the maximum sum of digits among all numbers in the given file. with open(filename, \\"r\\") as file: max_sum = 0 for line in file: line = line.strip() current_sum = sum_of_digits(line) if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def contains_palindromic_substring(s: str) -> bool: Check if the given string contains a palindromic substring of length greater than 1. Params: s (str): The input string to be checked. Returns: bool: Returns True if the input string contains a palindromic substring of length greater than 1, otherwise False. Example: >>> contains_palindromic_substring(\\"abac\\") True >>> contains_palindromic_substring(\\"abcdef\\") False >>> contains_palindromic_substring(\\"aabbcc\\") True","solution":"def contains_palindromic_substring(s: str) -> bool: Check if the given string contains a palindromic substring of length greater than 1. Params: s (str): The input string to be checked. Returns: bool: Returns True if the input string contains a palindromic substring of length greater than 1, otherwise False. # Check if there is any palindrome longer than 1 n = len(s) for i in range(n-1): # Check for even length palindromes if s[i] == s[i + 1]: return True # Check for odd length palindromes l, r = i, i + 2 while l >= 0 and r < n and s[l] == s[r]: return True l -= 1 r += 1 return False"},{"question":"def is_palindrome(message: str) -> bool: Checks if a given message is a palindrome. A palindrome is a string that reads the same backward as forward, ignoring spaces, punctuation, and capitalization. >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> is_palindrome(\\"Hello, World!\\") False","solution":"import re def is_palindrome(message: str) -> bool: Checks if a given message is a palindrome. A palindrome is a string that reads the same backward as forward, ignoring spaces, punctuation, and capitalization. # Remove non-alphanumeric characters and convert to lowercase filtered_message = re.sub(r'[^A-Za-z0-9]', '', message).lower() # Check if the filtered message is a palindrome return filtered_message == filtered_message[::-1]"},{"question":"from typing import Union, List def validate_password(password: str) -> Union[bool, List[str]]: Validates the given password based on specific criteria to be considered strong. Parameters: - password: A string representing the password to validate. Returns: - True if the password meets all criteria. - A list of feedback strings indicating which criteria are not met if the password is not strong. >>> validate_password(\\"Abc123\\") ['Password must be at least 8 characters long'] >>> validate_password(\\"abc123%\\") ['Password must contain at least one uppercase letter'] >>> validate_password(\\"Password123\\") ['Password must contain at least one special character from the set: !@#%^&*()-_+='] >>> validate_password(\\"StrongPassw0rd!\\") True","solution":"from typing import Union, List def validate_password(password: str) -> Union[bool, List[str]]: Validates the given password based on specific criteria to be considered strong. Parameters: - password: A string representing the password to validate. Returns: - True if the password meets all criteria. - A list of feedback strings indicating which criteria are not met if the password is not strong. criteria = [ (len(password) >= 8, \\"Password must be at least 8 characters long\\"), (any(c.isupper() for c in password), \\"Password must contain at least one uppercase letter\\"), (any(c.islower() for c in password), \\"Password must contain at least one lowercase letter\\"), (any(c.isdigit() for c in password), \\"Password must contain at least one digit\\"), (any(c in \\"!@#%^&*()-_+=\\" for c in password), \\"Password must contain at least one special character from the set: !@#%^&*()-_+=\\") ] feedback = [msg for valid, msg in criteria if not valid] if not feedback: return True else: return feedback"},{"question":"def can_form_palindrome(s: str) -> bool: Returns True if any permutation of the given string can form a palindrome, otherwise returns False. >>> can_form_palindrome(\\"\\") True >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"ab\\") False >>> can_form_palindrome(\\"aab\\") True >>> can_form_palindrome(\\"carerac\\") True >>> can_form_palindrome(\\"code\\") False >>> can_form_palindrome(\\"aabbccdd\\") True >>> can_form_palindrome(\\"abcabcabc\\") False","solution":"def can_form_palindrome(s: str) -> bool: Returns True if any permutation of the given string can form a palindrome, otherwise returns False. # Dictionary to count the occurrences of each character. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Checking the counts of characters to determine if a palindrome is possible. odd_count = 0 for count in char_count.values(): if count % 2 == 1: odd_count += 1 # More than one odd count means it can't form a palindrome. if odd_count > 1: return False return True"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Given a binary tree, return the level order traversal of its nodes' values. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> level_order_traversal(root) [[3], [9, 20], [15, 7]] >>> level_order_traversal(None) [] >>> root = TreeNode(1) >>> level_order_traversal(root) [[1]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> level_order_traversal(root) [[1], [2], [3]] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> level_order_traversal(root) [[1], [2], [3]]","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = [root] while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.pop(0) level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"from typing import List from collections import defaultdict def max_fruit_collected(fruits: List[int]) -> int: Returns the maximum number of fruits collected with up to two different types of fruits at any point. Example: >>> max_fruit_collected([1, 2, 1]) 3 >>> max_fruit_collected([0, 1, 2, 2]) 3 >>> max_fruit_collected([1, 2, 3, 2, 2]) 4 >>> max_fruit_collected([3, 3, 3, 1, 2, 1, 1, 2, 3, 3, 4]) 5","solution":"from collections import defaultdict def max_fruit_collected(fruits): Returns the maximum number of fruits collected with up to two different types of fruits at any point. basket = defaultdict(int) left = 0 max_fruits = 0 for right in range(len(fruits)): basket[fruits[right]] += 1 while len(basket) > 2: basket[fruits[left]] -= 1 if basket[fruits[left]] == 0: del basket[fruits[left]] left += 1 max_fruits = max(max_fruits, right - left + 1) return max_fruits"},{"question":"import numpy as np def initialize_population(pop_size: int, num_items: int) -> np.ndarray: Initializes a population of potential solutions. pass def fitness(solution: np.ndarray, item_weights: np.ndarray, item_values: np.ndarray, capacity: int) -> float: Evaluates the fitness of a given solution, considering total weight and value. pass def selection(population: np.ndarray, fitnesses: np.ndarray, num_parents: int) -> np.ndarray: Selects a subset of solutions to be parents based on their fitness values. pass def crossover(parents: np.ndarray, num_offspring: int) -> np.ndarray: Generates new offspring solutions by crossing over pairs of parent solutions. pass def mutation(offspring: np.ndarray, mutation_rate: float) -> np.ndarray: Applies random mutations to offspring solutions for genetic diversity. pass def genetic_algorithm(knapsack_capacity: int, item_weights: np.ndarray, item_values: np.ndarray, pop_size: int, num_generations: int, mutation_rate: float) -> np.ndarray: Orchestrates the genetic algorithm to evolve the population and return the best solution found. pass # Unit tests def test_initialize_population(): pop_size = 10 num_items = 5 population = initialize_population(pop_size, num_items) assert population.shape == (pop_size, num_items) assert np.all(np.logical_or(population == 0, population == 1)) def test_fitness(): solution = np.array([1, 0, 1]) item_weights = np.array([10, 20, 30]) item_values = np.array([60, 100, 120]) capacity = 50 assert fitness(solution, item_weights, item_values, capacity) == 180 solution = np.array([1, 1, 1]) assert fitness(solution, item_weights, item_values, capacity) == 0 def test_selection(): population = np.array([[1, 0, 1], [0, 1, 0], [1, 1, 0], [0, 0, 1]]) fitnesses = np.array([180, 100, 140, 120]) num_parents = 2 parents = selection(population, fitnesses, num_parents) assert np.array_equal(parents, np.array([[1, 1, 0], [1, 0, 1]])) def test_crossover(): parents = np.array([[1, 0, 1], [0, 1, 0]]) num_offspring = 2 offspring = crossover(parents, num_offspring) assert offspring.shape == (num_offspring, parents.shape[1]) assert np.array_equal(offspring[0], np.array([1, 0, 0])) or np.array_equal(offspring[0], np.array([1, 1, 0])) assert np.array_equal(offspring[1], np.array([0, 0, 1])) or np.array_equal(offspring[1], np.array([0, 1, 1])) def test_mutation(): offspring = np.array([[1, 0, 1], [0, 1, 0]]) mutation_rate = 0.5 mutated_offspring = mutation(offspring, mutation_rate) assert mutated_offspring.shape == offspring.shape def test_genetic_algorithm(): item_weights = np.array([2, 3, 4, 5]) item_values = np.array([3, 4, 5, 6]) knapsack_capacity = 5 pop_size = 10 num_generations = 20 mutation_rate = 0.01 best_solution = genetic_algorithm(knapsack_capacity, item_weights, item_values, pop_size, num_generations, mutation_rate) assert len(best_solution) == len(item_weights) assert np.all(np.logical_or(best_solution == 0, best_solution == 1)) derived_weights = np.sum(best_solution * item_weights) derived_values = np.sum(best_solution * item_values) assert derived_weights <= knapsack_capacity","solution":"import numpy as np def initialize_population(pop_size: int, num_items: int) -> np.ndarray: return np.random.randint(0, 2, (pop_size, num_items)) def fitness(solution: np.ndarray, item_weights: np.ndarray, item_values: np.ndarray, capacity: int) -> float: total_weight = np.sum(solution * item_weights) if total_weight > capacity: return 0 return np.sum(solution * item_values) def selection(population: np.ndarray, fitnesses: np.ndarray, num_parents: int) -> np.ndarray: parents_index = np.argsort(fitnesses)[-num_parents:] return population[parents_index] def crossover(parents: np.ndarray, num_offspring: int) -> np.ndarray: offspring = np.empty((num_offspring, parents.shape[1]), dtype=int) crossover_point = np.uint8(parents.shape[1] / 2) for k in range(num_offspring): parent1_idx = k % parents.shape[0] parent2_idx = (k + 1) % parents.shape[0] offspring[k, :crossover_point] = parents[parent1_idx, :crossover_point] offspring[k, crossover_point:] = parents[parent2_idx, crossover_point:] return offspring def mutation(offspring: np.ndarray, mutation_rate: float) -> np.ndarray: for idx in range(offspring.shape[0]): if np.random.rand() < mutation_rate: mutation_index = np.random.randint(offspring.shape[1]) offspring[idx, mutation_index] = 1 - offspring[idx, mutation_index] return offspring def genetic_algorithm(knapsack_capacity: int, item_weights: np.ndarray, item_values: np.ndarray, pop_size: int, num_generations: int, mutation_rate: float) -> np.ndarray: num_items = len(item_weights) population = initialize_population(pop_size, num_items) for generation in range(num_generations): fitnesses = np.array([fitness(sol, item_weights, item_values, knapsack_capacity) for sol in population]) parents = selection(population, fitnesses, pop_size // 2) offspring = crossover(parents, pop_size - parents.shape[0]) offspring = mutation(offspring, mutation_rate) population = np.vstack((parents, offspring)) best_fitness_index = np.argmax([fitness(sol, item_weights, item_values, knapsack_capacity) for sol in population]) return population[best_fitness_index]"},{"question":"from typing import List def count_connected_components(graph: List[List[int]]) -> int: Computes and returns the number of connected components in an undirected graph represented by an adjacency list. >>> count_connected_components([[1,2], [0,3], [0,3], [1,2]]) 1 >>> count_connected_components([[1], [0], [3], [2]]) 2 >>> count_connected_components([[], []]) 2 >>> count_connected_components([[], [2], [1, 3], [2]]) 2","solution":"def count_connected_components(graph): Returns the number of connected components in an undirected graph represented by an adjacency list. def dfs(node, visited): stack = [node] while stack: current = stack.pop() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) visited = set() num_components = 0 for i in range(len(graph)): if i not in visited: num_components += 1 visited.add(i) dfs(i, visited) return num_components"},{"question":"def extract_and_sort_unique_numbers(numbers: list[int]) -> list[int]: Extracts all unique numbers from the input list and returns them sorted in ascending order. Parameters: numbers (list[int]): The input list of integers. Returns: list[int]: A sorted list of unique integers. Examples: >>> extract_and_sort_unique_numbers([4, 3, 2, 7, 8, 2, 3, 1]) [1, 2, 3, 4, 7, 8] >>> extract_and_sort_unique_numbers([10, 20, 10, 30, 20]) [10, 20, 30] >>> extract_and_sort_unique_numbers([]) [] >>> extract_and_sort_unique_numbers([-1, -2, -3, -1, -2]) [-3, -2, -1] >>> extract_and_sort_unique_numbers([5, 4, 3, 5, 4, 3, 2, 1, 0]) [0, 1, 2, 3, 4, 5] pass # Unit Tests def test_extract_and_sort_unique_numbers_with_duplicates(): assert extract_and_sort_unique_numbers([4, 3, 2, 7, 8, 2, 3, 1]) == [1, 2, 3, 4, 7, 8] def test_extract_and_sort_unique_numbers_all_unique(): assert extract_and_sort_unique_numbers([10, 20, 30]) == [10, 20, 30] def test_extract_and_sort_unique_numbers_empty(): assert extract_and_sort_unique_numbers([]) == [] def test_extract_and_sort_unique_numbers_with_negatives(): assert extract_and_sort_unique_numbers([-1, -2, -3, -1, -2]) == [-3, -2, -1] def test_extract_and_sort_unique_numbers_mixed(): assert extract_and_sort_unique_numbers([5, 4, 3, 5, 4, 3, 2, 1, 0]) == [0, 1, 2, 3, 4, 5] def test_extract_and_sort_unique_numbers_large_range(): assert extract_and_sort_unique_numbers(list(range(-100000, 100001))) == list(range(-100000, 100001)) def test_extract_and_sort_unique_numbers_single_element(): assert extract_and_sort_unique_numbers([42]) == [42]","solution":"def extract_and_sort_unique_numbers(numbers: list[int]) -> list[int]: Extracts all unique numbers from the input list and returns them sorted in ascending order. Parameters: numbers (list[int]): The input list of integers. Returns: list[int]: A sorted list of unique integers. return sorted(set(numbers))"},{"question":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): Initialize the Trie with an empty root node. self.root = TrieNode() def insert(self, word: str): Insert a word into the Trie. :param word: Word to be inserted in the Trie. pass def autocomplete(self, prefix: str) -> list: Return a list of all words in the Trie that start with the given prefix. :param prefix: The prefix to search for in the Trie. :return: A list of words with the given prefix. Example Usage: >>> trie = Trie() >>> trie.insert('hello') >>> trie.insert('hell') >>> trie.insert('heaven') >>> trie.insert('heavy') >>> trie.autocomplete('he') == ['hello', 'hell', 'heaven', 'heavy'] >>> trie.autocomplete('hell') == ['hello', 'hell'] >>> trie.autocomplete('heav') == ['heaven', 'heavy'] >>> trie.autocomplete('ho') == [] >>> trie.autocomplete('') == ['hello', 'hell', 'heaven', 'heavy'] pass # Test cases def test_insert_and_autocomplete(): trie = Trie() # Insert words words = [\\"hello\\", \\"hell\\", \\"heaven\\", \\"heavy\\"] for word in words: trie.insert(word) # Test autocomplete assert set(trie.autocomplete(\\"he\\")) == {\\"hello\\", \\"hell\\", \\"heaven\\", \\"heavy\\"} assert set(trie.autocomplete(\\"hell\\")) == {\\"hello\\", \\"hell\\"} assert set(trie.autocomplete(\\"heav\\")) == {\\"heaven\\", \\"heavy\\"} assert trie.autocomplete(\\"ho\\") == [] assert set(trie.autocomplete(\\"\\")) == {\\"hello\\", \\"hell\\", \\"heaven\\", \\"heavy\\"} def test_edge_cases(): trie = Trie() # Test empty trie assert trie.autocomplete(\\"hello\\") == [] assert trie.autocomplete(\\"\\") == [] # Insert one word trie.insert(\\"test\\") assert trie.autocomplete(\\"te\\") == [\\"test\\"] assert trie.autocomplete(\\"t\\") == [\\"test\\"] assert trie.autocomplete(\\"test\\") == [\\"test\\"] assert trie.autocomplete(\\"testing\\") == [] def test_mixed_length_words(): trie = Trie() words = [\\"a\\", \\"to\\", \\"tea\\", \\"ted\\", \\"ten\\", \\"i\\", \\"in\\", \\"inn\\"] for word in words: trie.insert(word) assert set(trie.autocomplete(\\"t\\")) == {\\"to\\", \\"tea\\", \\"ted\\", \\"ten\\"} assert trie.autocomplete(\\"to\\") == [\\"to\\"] assert set(trie.autocomplete(\\"te\\")) == {\\"tea\\", \\"ted\\", \\"ten\\"} assert set(trie.autocomplete(\\"in\\")) == {\\"in\\", \\"inn\\"} assert trie.autocomplete(\\"a\\") == [\\"a\\"] def test_repeated_words(): trie = Trie() words = [\\"hello\\", \\"hello\\", \\"hello\\"] for word in words: trie.insert(word) assert trie.autocomplete(\\"he\\") == [\\"hello\\"] assert trie.autocomplete(\\"hello\\") == [\\"hello\\"] assert trie.autocomplete(\\"hell\\") == [\\"hello\\"]","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def autocomplete(self, prefix: str) -> list: def dfs(node, prefix, results): if node.is_end_of_word: results.append(prefix) for char, child_node in node.children.items(): dfs(child_node, prefix + char, results) node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] results = [] dfs(node, prefix, results) return results"},{"question":"import os import zipfile from datetime import datetime def compress_files(directory, include_extensions=None, exclude_extensions=None): Compresses files in the specified directory into a ZIP archive with selective inclusion or exclusion of file extensions. Args: - directory (str): Path to the directory whose files are to be compressed. - include_extensions (list of str, optional): List of file extensions to include in the compression. - exclude_extensions (list of str, optional): List of file extensions to exclude from the compression. Returns: - None Example: >>> compress_files(\\"/path/to/directory\\", include_extensions=[\\".txt\\", \\".md\\"]) Compressed: /path/to/directory/file1.txt Compressed: /path/to/directory/file2.md Compression complete. Archive created at /path/to/directory/compressed_<timestamp>.zip pass def setup_test_directory(base_path): Set up a testing directory structure with sample files os.makedirs(base_path, exist_ok=True) with open(os.path.join(base_path, \\"file1.txt\\"), \\"w\\") as f: f.write(\\"This is a test file.\\") with open(os.path.join(base_path, \\"file2.md\\"), \\"w\\") as f: f.write(\\"This is another test file.\\") with open(os.path.join(base_path, \\"file3.py\\"), \\"w\\") as f: f.write(\\"print('Hello, world!')\\") def test_compress_with_include_extensions(tmpdir): testing_dir = tmpdir.mkdir(\\"testing_dir\\") setup_test_directory(testing_dir) compress_files(testing_dir, include_extensions=[\\".txt\\", \\".md\\"]) zip_files = [file for file in os.listdir(testing_dir) if file.endswith(\\".zip\\")] assert len(zip_files) == 1 with zipfile.ZipFile(os.path.join(testing_dir, zip_files[0]), 'r') as zipf: names = zipf.namelist() assert \\"file1.txt\\" in names assert \\"file2.md\\" in names assert \\"file3.py\\" not in names def test_compress_with_exclude_extensions(tmpdir): testing_dir = tmpdir.mkdir(\\"testing_dir\\") setup_test_directory(testing_dir) compress_files(testing_dir, exclude_extensions=[\\".py\\"]) zip_files = [file for file in os.listdir(testing_dir) if file.endswith(\\".zip\\")] assert len(zip_files) == 1 with zipfile.ZipFile(os.path.join(testing_dir, zip_files[0]), 'r') as zipf: names = zipf.namelist() assert \\"file1.txt\\" in names assert \\"file2.md\\" in names assert \\"file3.py\\" not in names def test_compress_all_files(tmpdir): testing_dir = tmpdir.mkdir(\\"testing_dir\\") setup_test_directory(testing_dir) compress_files(testing_dir) zip_files = [file for file in os.listdir(testing_dir) if file.endswith(\\".zip\\")] assert len(zip_files) == 1 with zipfile.ZipFile(os.path.join(testing_dir, zip_files[0]), 'r') as zipf: names = zipf.namelist() assert \\"file1.txt\\" in names assert \\"file2.md\\" in names assert \\"file3.py\\" in names","solution":"import os import zipfile import time from datetime import datetime def compress_files(directory, include_extensions=None, exclude_extensions=None): Compresses files in the specified directory into a ZIP archive with selective inclusion or exclusion of file extensions. Args: - directory (str): Path to the directory whose files are to be compressed. - include_extensions (list of str, optional): List of file extensions to include in the compression. - exclude_extensions (list of str, optional): List of file extensions to exclude from the compression. # Get the current timestamp for naming the zip file timestamp = datetime.now().strftime(\\"%Y%m%d%H%M%S\\") zip_filename = os.path.join(directory, f\\"compressed_{timestamp}.zip\\") with zipfile.ZipFile(zip_filename, 'w') as zipf: for root, _, files in os.walk(directory): for file in files: file_path = os.path.join(root, file) file_extension = os.path.splitext(file)[1] # Check inclusion/exclusion criteria if include_extensions and file_extension not in include_extensions: continue if exclude_extensions and file_extension in exclude_extensions: continue try: zipf.write(file_path, os.path.relpath(file_path, directory)) print(f\\"Compressed: {file_path}\\") except Exception as e: print(f\\"Error compressing {file_path}: {e}\\") print(f\\"Compression complete. Archive created at {zip_filename}\\")"},{"question":"def char_frequency(s: str) -> dict[str, int]: Returns a dictionary where the keys are characters and the values are their respective frequencies in the string. Raises a ValueError if the input string contains characters that are not lowercase alphabets. Example: >>> char_frequency(\\"aabc\\") == {'a': 2, 'b': 1, 'c': 1} >>> char_frequency(\\"zzxyzz\\") == {'z': 4, 'x': 1, 'y': 1} >>> try: ... char_frequency(\\"hello1world\\") ... except ValueError as e: ... print(e) # Expected output: Input string must only contain lowercase alphabets","solution":"def char_frequency(s: str) -> dict[str, int]: Returns a dictionary where the keys are characters and the values are their respective frequencies in the string. Raises a ValueError if the input string contains characters that are not lowercase alphabets. if any(char < 'a' or char > 'z' for char in s): raise ValueError(\\"Input string must only contain lowercase alphabets\\") frequency_dict = {} for char in s: if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 return frequency_dict"},{"question":"def normalize_path(path: str) -> str: Normalize the given UNIX-like file system path by removing redundant components. :param path: An absolute UNIX path in string format. :return: The canonical path as a string. from solution import normalize_path def test_normal_path_no_redundant(): assert normalize_path(\\"/home/\\") == \\"/home\\" assert normalize_path(\\"/home/user\\") == \\"/home/user\\" def test_normal_path_with_dots(): assert normalize_path(\\"/../\\") == \\"/\\" assert normalize_path(\\"/home/./\\") == \\"/home\\" assert normalize_path(\\"/a/./b/../../c/\\") == \\"/c\\" def test_normal_path_with_double_slash(): assert normalize_path(\\"/home//foo/\\") == \\"/home/foo\\" assert normalize_path(\\"/a/b//c///d/\\") == \\"/a/b/c/d\\" def test_combined_cases(): assert normalize_path(\\"/a/./b/./c/./d/\\") == \\"/a/b/c/d\\" assert normalize_path(\\"/a/../b/../c/../d/\\") == \\"/d\\" assert normalize_path(\\"/a////b////c/../d/\\") == \\"/a/b/d\\" assert normalize_path(\\"/a//b/./c/../d/\\") == \\"/a/b/d\\" def test_edge_cases(): assert normalize_path(\\"/\\") == \\"/\\" assert normalize_path(\\"/.\\") == \\"/\\" assert normalize_path(\\"/..\\") == \\"/\\" assert normalize_path(\\"/././././\\") == \\"/\\" assert normalize_path(\\"/../../\\") == \\"/\\"","solution":"def normalize_path(path: str) -> str: Normalize the given UNIX-like file system path by removing redundant components. :param path: An absolute UNIX path in string format. :return: The canonical path as a string. parts = path.split('/') stack = [] for part in parts: if part == '' or part == '.': continue elif part == '..': if stack: stack.pop() else: stack.append(part) normalized = '/' + '/'.join(stack) return normalized"},{"question":"def is_palindrome(s: str) -> bool: Check if a given string is a palindrome. def rotate_string(s: str, n: int) -> str: Rotate a string s to the left by n positions. def is_rotated_palindrome(s: str) -> bool: Check if any rotation of the given string is a palindrome. >>> is_rotated_palindrome(\\"aabb\\") True >>> is_rotated_palindrome(\\"abcde\\") False >>> is_rotated_palindrome(\\"aba\\") True >>> is_rotated_palindrome(\\"abcabc\\") False","solution":"def is_palindrome(s: str) -> bool: Check if a given string is a palindrome. return s == s[::-1] def rotate_string(s: str, n: int) -> str: Rotate a string s to the left by n positions. return s[n:] + s[:n] def is_rotated_palindrome(s: str) -> bool: Check if any rotation of the given string is a palindrome. for i in range(len(s)): if is_palindrome(rotate_string(s, i)): return True return False"},{"question":"def is_prime(number: int) -> bool: Determines if a number is a prime number. Parameters: number (int): An integer for which the primality needs to be checked. Returns: bool: True if the given number is a prime number, otherwise False. Raises: TypeError: If the input value is not an integer. >>> is_prime(0) False >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(25) False >>> is_prime(7919) True >>> is_prime(17.5) Traceback (most recent call last): ... TypeError: Input value must be an 'int' type","solution":"def is_prime(number: int) -> bool: Determines if the input integer number is a prime number. Parameters: - number (int): The integer to check for primality. Returns: - bool: True if number is prime, False otherwise. Raises: - TypeError: If the input is not an integer. if not isinstance(number, int): raise TypeError(\\"Input value must be an 'int' type\\") if number < 2: return False if number == 2 or number == 3: return True if number % 2 == 0 or number % 3 == 0: return False i = 5 while i * i <= number: if number % i == 0 or number % (i + 2) == 0: return False i += 6 return True"},{"question":"class MedianFinder: A data structure that supports adding new numbers from a data stream and finding the median of all numbers added so far. Example: >>> mf = MedianFinder() >>> mf.addNum(1) >>> print(mf.findMedian()) # Output: 1.0 >>> mf.addNum(2) >>> print(mf.findMedian()) # Output: 1.5 >>> mf.addNum(3) >>> print(mf.findMedian()) # Output: 2.0 def __init__(self): pass def addNum(self, num: int) -> None: pass def findMedian(self) -> float: pass","solution":"import heapq class MedianFinder: def __init__(self): # Two heaps: one max-heap for the lower half and one min-heap for the upper half self.small = [] # max-heap (inverted min-heap) self.large = [] # min-heap def addNum(self, num: int) -> None: # Maintain the order: small heap has the smaller half and large heap has the larger half heapq.heappush(self.small, -num) # Ensure the smallest number in \`large\` is greater than or equal to the largest number in \`small\` if self.small and self.large and (-self.small[0]) > self.large[0]: val = -heapq.heappop(self.small) heapq.heappush(self.large, val) # Balance the sizes of the heaps (small can have 1 more element than large) if len(self.small) > len(self.large) + 1: val = -heapq.heappop(self.small) heapq.heappush(self.large, val) if len(self.large) > len(self.small): val = heapq.heappop(self.large) heapq.heappush(self.small, -val) def findMedian(self) -> float: if len(self.small) > len(self.large): return -self.small[0] return (-self.small[0] + self.large[0]) / 2.0"},{"question":"def polynomial_derivative(coefficients: list) -> list: Computes the derivative of a polynomial represented by a list of its coefficients. :param coefficients: List of coefficients where the i-th element is the coefficient of x^i. :return: List of coefficients for the derivative of the polynomial. Examples: >>> polynomial_derivative([3, 2, 1]) [2, 2] >>> polynomial_derivative([1, 0, -3, 2]) [0, -6, 6] >>> polynomial_derivative([5]) [] >>> polynomial_derivative([0, 0, 0]) [0, 0] >>> polynomial_derivative([0]) [] >>> polynomial_derivative([-1, 3, -5, 2]) [3, -10, 6] >>> polynomial_derivative([0, 4]) [4] >>> polynomial_derivative([1.5, 0.0, 2.3]) [0.0, 4.6]","solution":"def polynomial_derivative(coefficients): Computes the derivative of a polynomial represented by a list of its coefficients. :param coefficients: List of coefficients where the i-th element is the coefficient of x^i. :return: List of coefficients for the derivative of the polynomial. if len(coefficients) <= 1: return [] derivative = [] for i in range(1, len(coefficients)): derivative.append(i * coefficients[i]) return derivative"},{"question":"import re def is_palindrome(s: str) -> bool: Check if the input string is a palindrome, considering only alphabetical characters and ignoring spaces, punctuation, and case. s = re.sub(r'[^a-zA-Z]', '', s).lower() return s == s[::-1] def find_longest_palindrome(strings: list) -> str: Find the longest palindrome among a list of strings. >>> find_longest_palindrome([\\"racecar\\", \\"Madam\\", \\"Step on no pets\\", \\"hello\\"]) 'Step on no pets' >>> find_longest_palindrome([\\"hello\\", \\"world\\"]) '' >>> find_longest_palindrome([\\"abc\\", \\"madamimadam\\", \\"No lemon, no melon\\", \\"civic\\"]) 'madamimadam'","solution":"import re def is_palindrome(s: str) -> bool: Check if the input string is a palindrome, considering only alphabetical characters and ignoring spaces, punctuation, and case. s = re.sub(r'[^a-zA-Z]', '', s).lower() return s == s[::-1] def find_longest_palindrome(strings: list) -> str: Finds the longest palindrome in a list of strings. longest_pal = \\"\\" for s in strings: if is_palindrome(s) and len(s) > len(longest_pal): longest_pal = s return longest_pal"},{"question":"def total_annual_sales(monthly_sales): Returns the total annual sales from a list of monthly sales figures. >>> total_annual_sales([1000.0, 1100.5, 1200.0, 1300.3, 1400.2, 1500.6, 1600.1, 1700.4, 1800.9, 1900.8, 2000.0, 2100.7]) 18604.5 >>> total_annual_sales([0.0] * 12) 0.0 def average_monthly_sales(monthly_sales): Returns the average monthly sales from a list of monthly sales figures. >>> average_monthly_sales([1000.0, 1100.5, 1200.0, 1300.3, 1400.2, 1500.6, 1600.1, 1700.4, 1800.9, 1900.8, 2000.0, 2100.7]) 1550.375 >>> average_monthly_sales([0.0] * 12) 0.0","solution":"def total_annual_sales(monthly_sales): Returns the total annual sales from a list of monthly sales figures. if len(monthly_sales) != 12: raise ValueError(\\"monthly_sales must contain exactly 12 elements.\\") if any(type(sale) is not float or sale < 0 for sale in monthly_sales): raise ValueError(\\"Monthly sales figures must be non-negative floats.\\") return sum(monthly_sales) def average_monthly_sales(monthly_sales): Returns the average monthly sales from a list of monthly sales figures. if len(monthly_sales) != 12: raise ValueError(\\"monthly_sales must contain exactly 12 elements.\\") if any(type(sale) is not float or sale < 0 for sale in monthly_sales): raise ValueError(\\"Monthly sales figures must be non-negative floats.\\") total_sales = sum(monthly_sales) return total_sales / 12"},{"question":"import requests import time from typing import NamedTuple class WeatherData(NamedTuple): temperature: float description: str humidity: int # In-memory cache weather_cache = {} def get_weather(city: str, api_key: str, cache_duration: int = 600) -> WeatherData: Fetch and display current weather conditions for a specified city using the OpenWeatherMap API. >>> get_weather(\\"New York\\", \\"your_api_key_here\\") WeatherData(temperature=22.5, description=\\"clear sky\\", humidity=50) >>> get_weather(\\"Tokyo\\", \\"your_api_key_here\\") WeatherData(temperature=30.0, description=\\"sunny\\", humidity=60) # Implement the function to fetch weather data with caching and error handling here.","solution":"import requests import time from typing import NamedTuple class WeatherData(NamedTuple): temperature: float description: str humidity: int # In-memory cache weather_cache = {} def get_weather(city: str, api_key: str, cache_duration: int = 600) -> WeatherData: current_time = time.time() # Check for cached data if city in weather_cache: cached_data, timestamp = weather_cache[city] if current_time - timestamp < cache_duration: return cached_data # Fetch fresh data url = f\\"http://api.openweathermap.org/data/2.5/weather\\" params = { 'q': city, 'appid': api_key, 'units': 'metric' } try: response = requests.get(url, params=params) response.raise_for_status() data = response.json() temperature = data['main']['temp'] description = data['weather'][0]['description'] humidity = data['main']['humidity'] weather_data = WeatherData(temperature, description, humidity) # Update cache weather_cache[city] = (weather_data, current_time) return weather_data except requests.exceptions.HTTPError as http_err: raise Exception(f\\"HTTP error occurred: {http_err}\\") except Exception as err: raise Exception(f\\"Other error occurred: {err}\\")"},{"question":"def roman_to_int(roman: str) -> int: Converts a Roman numeral to an integer. >>> roman_to_int(\\"IX\\") 9 >>> roman_to_int(\\"XLII\\") 42 pass def int_to_roman(num: int) -> str: Converts an integer to a Roman numeral. >>> int_to_roman(9) \\"IX\\" >>> int_to_roman(42) \\"XLII\\" pass","solution":"def roman_to_int(roman: str) -> int: Converts a Roman numeral to an integer. roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000} total = 0 prev_value = 0 for char in reversed(roman): value = roman_values[char] if value < prev_value: total -= value else: total += value prev_value = value return total def int_to_roman(num: int) -> str: Converts an integer to a Roman numeral. value_map = [ (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I') ] roman = \\"\\" for value, symbol in value_map: while num >= value: roman += symbol num -= value return roman"},{"question":"def longest_repeating_sequence(text: str) -> int: Identify and return the length of the longest sequence of consecutive repeating characters in the input string. >>> longest_repeating_sequence(\\"aaaaabbbaaaccc\\") 5 >>> longest_repeating_sequence(\\"abcde\\") 1 >>> longest_repeating_sequence(\\"abCCcDdDD\\") 2 >>> longest_repeating_sequence(\\"1111222333444\\") 4 >>> longest_repeating_sequence(\\"xyz\\") 1 >>> longest_repeating_sequence(\\"\\") Traceback (most recent call last): ... ValueError: Input must be a non-empty string >>> longest_repeating_sequence(12345) Traceback (most recent call last): ... ValueError: Input must be a non-empty string >>> longest_repeating_sequence([1, 2, 3, 4, 5]) Traceback (most recent call last): ... ValueError: Input must be a non-empty string pass","solution":"def longest_repeating_sequence(text: str) -> int: if not isinstance(text, str) or text == \\"\\": raise ValueError(\\"Input must be a non-empty string\\") max_count = 0 current_count = 1 for i in range(1, len(text)): if text[i] == text[i - 1]: current_count += 1 max_count = max(max_count, current_count) else: current_count = 1 return max(max_count, current_count)"},{"question":"class Directory: A class to manage a collection of files in a directory. Each file has a unique name, a size in bytes, and a creation date. Methods ------- add_file(name: str, size: int, creation_date: int) -> None: Adds a file with the specified \`name\`, \`size\`, and \`creation_date\`. get_largest_file() -> tuple | None: Returns a tuple \`(name, size, creation_date)\` of the largest file by size if present, else returns \`None\`. remove_file(name: str) -> bool: Removes the file with the specified \`name\`. Returns \`True\` if the file was successfully removed, otherwise returns \`False\`. get_files_sorted_by_date() -> list: Returns a list of file names sorted by their creation date. def __init__(self): pass # Implement the constructor to initialize your data structures def add_file(self, name: str, size: int, creation_date: int) -> None: pass # Implement this method def get_largest_file(self) -> tuple | None: pass # Implement this method def remove_file(self, name: str) -> bool: pass # Implement this method def get_files_sorted_by_date(self) -> list: pass # Implement this method def test_add_file_and_largest_file(): directory = Directory() directory.add_file(\\"file1.txt\\", 500, 20220101) directory.add_file(\\"file2.txt\\", 1500, 20220102) directory.add_file(\\"file3.txt\\", 1000, 20220101) assert directory.get_largest_file() == (\\"file2.txt\\", 1500, 20220102) def test_remove_file(): directory = Directory() directory.add_file(\\"file1.txt\\", 500, 20220101) directory.add_file(\\"file2.txt\\", 1500, 20220102) assert directory.remove_file(\\"file1.txt\\") == True assert directory.remove_file(\\"nonexistent.txt\\") == False assert directory.get_largest_file() == (\\"file2.txt\\", 1500, 20220102) def test_get_files_sorted_by_date(): directory = Directory() directory.add_file(\\"file1.txt\\", 500, 20220101) directory.add_file(\\"file3.txt\\", 1000, 20220101) directory.add_file(\\"file2.txt\\", 1500, 20220102) assert directory.get_files_sorted_by_date() == [\\"file1.txt\\", \\"file3.txt\\", \\"file2.txt\\"] def test_edge_cases(): directory = Directory() assert directory.get_largest_file() == None assert directory.remove_file(\\"file1.txt\\") == False assert directory.get_files_sorted_by_date() == []","solution":"class Directory: def __init__(self): self.files = {} self.sorted_files_by_date = [] def add_file(self, name: str, size: int, creation_date: int) -> None: self.files[name] = (size, creation_date) self.sorted_files_by_date.append((creation_date, name)) self.sorted_files_by_date.sort() def get_largest_file(self) -> tuple | None: if not self.files: return None largest_file = max(self.files.items(), key=lambda file: file[1][0]) return largest_file[0], largest_file[1][0], largest_file[1][1] def remove_file(self, name: str) -> bool: if name not in self.files: return False self.files.pop(name) self.sorted_files_by_date = [entry for entry in self.sorted_files_by_date if entry[1] != name] return True def get_files_sorted_by_date(self) -> list: return [entry[1] for entry in self.sorted_files_by_date]"},{"question":"# Completion Task Implement the following functions: 1. \`normalize_book_title(book_title: str) -> str\`: A function that standardizes book titles by converting all characters to lowercase and replacing non-alphanumeric characters (excluding spaces) with a space. Input: - A string representing the original book title. Output: - A string representing the normalized book title that retains only alphanumeric characters and single spaces. def normalize_book_title(book_title: str) -> str: import re # Convert to lowercase book_title = book_title.lower() # Replace non-alphanumeric characters with spaces book_title = re.sub(r'[^a-z0-9s]', ' ', book_title) # Merge consecutive spaces book_title = re.sub(r's+', ' ', book_title).strip() return book_title 2. \`sort_books_by_id(book_ids: List[str]) -> List[str]\`: A function that sorts a list of book IDs based on multiple numerical parts, ensuring numerical sorting within each part. Input: - A list of strings that represent the book IDs in a multi-part numerical format. Output: - A sorted list of book IDs. from typing import List import re def sort_books_by_id(book_ids: List[str]) -> List[str]: def validate_and_convert(book_id: str) -> List[int]: if not re.fullmatch(r'(d+(.d+)*)', book_id): raise ValueError(f\\"Invalid book ID format '{book_id}'\\") return [int(part) for part in book_id.split('.')] # Convert and validate all book IDs converted_ids = [validate_and_convert(book_id) for book_id in book_ids] # Sort the book IDs based on the numerical parts sorted_ids = sorted(book_ids, key=lambda book_id: validate_and_convert(book_id)) return sorted_ids # Unit Test def test_normalize_book_title(): assert normalize_book_title(\\"The Adventures of Sherlock Holmes!\\") == 'the adventures of sherlock holmes' assert normalize_book_title(\\"Python Programming 101: A Beginner's Guide\\") == 'python programming 101 a beginner s guide' assert normalize_book_title(\\"Multiple Spaces\\") == 'multiple spaces' assert normalize_book_title(\\"Special@Characters#Everywhere!\\") == 'special characters everywhere' assert normalize_book_title(\\"123 ABC abc\\") == '123 abc abc' assert normalize_book_title(\\"\\") == '' def test_sort_books_by_id(): assert sort_books_by_id([\\"1.10.3\\", \\"1.2.3\\", \\"2.0.1\\", \\"1.10.1\\"]) == ['1.2.3', '1.10.1', '1.10.3', '2.0.1'] assert sort_books_by_id([\\"1.10\\", \\"1.2\\", \\"10.1\\", \\"1.10.1\\", \\"1.10.3\\"]) == ['1.2', '1.10', '1.10.1', '1.10.3', '10.1'] assert sort_books_by_id([\\"10.4\\", \\"2.0\\", \\"3.3.3\\", \\"10.3\\", \\"1.1.1.1\\"]) == ['1.1.1.1', '2.0', '3.3.3', '10.3', '10.4'] assert sort_books_by_id([\\"5.5.5\\", \\"2.2\\", \\"4.4\\", \\"3.3.3.3\\", \\"1.1.1.1.1\\"]) == ['1.1.1.1.1', '2.2', '3.3.3.3', '4.4', '5.5.5'] import pytest def test_sort_books_by_id_invalid(): with pytest.raises(ValueError, match=\\"Invalid book ID format '1..2.3'\\"): sort_books_by_id([\\"1.10.3\\", \\"1..2.3\\", \\"2.0.1\\", \\"1.10.1\\"]) with pytest.raises(ValueError, match=\\"Invalid book ID format '1.1.'\\"): sort_books_by_id([\\"1.10.3\\", \\"1.1.\\", \\"2.0.1\\", \\"1.10.1\\"]) with pytest.raises(ValueError, match=\\"Invalid book ID format '.1.2'\\"): sort_books_by_id([\\"1.10.3\\", \\".1.2\\", \\"2.0.1\\", \\"1.10.1\\"])","solution":"import re from typing import List def normalize_book_title(book_title: str) -> str: Standardizes book titles by converting all characters to lowercase, and replacing any non-alphanumeric characters (excluding spaces) with a space. Consecutive spaces are merged into a single space. # Convert to lowercase book_title = book_title.lower() # Replace non-alphanumeric characters with spaces book_title = re.sub(r'[^a-z0-9s]', ' ', book_title) # Merge consecutive spaces book_title = re.sub(r's+', ' ', book_title).strip() return book_title def sort_books_by_id(book_ids: List[str]) -> List[str]: Sorts a list of book IDs based on multiple numerical parts, ensuring numerical sorting within each part. Raises a ValueError if any book ID is in an invalid format. def validate_and_convert(book_id: str) -> List[int]: Validates and converts a book ID into a list of integers. Raises a ValueError if the book ID is not in a valid format. if not re.fullmatch(r'(d+(.d+)*)', book_id): raise ValueError(f\\"Invalid book ID format '{book_id}'\\") return [int(part) for part in book_id.split('.')] # Convert and validate all book IDs converted_ids = [validate_and_convert(book_id) for book_id in book_ids] # Sort the book IDs based on the numerical parts sorted_ids = sorted(book_ids, key=lambda book_id: validate_and_convert(book_id)) return sorted_ids"},{"question":"from typing import List def word_distance(words: List[str], word1: str, word2: str) -> int: Computes the shortest distance between two words in a list. >>> word_distance([\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\", \\"hello\\", \\"world\\"], \\"hello\\", \\"world\\") 1 >>> word_distance([\\"practice\\", \\"makes\\", \\"perfect\\", \\"coding\\", \\"makes\\"], \\"coding\\", \\"practice\\") 3 >>> word_distance([\\"a\\", \\"b\\", \\"a\\", \\"b\\", \\"a\\"], \\"a\\", \\"b\\") 1 >>> word_distance([\\"quick\\", \\"brown\\", \\"fox\\", \\"quick\\"], \\"quick\\", \\"fox\\") 1 >>> word_distance([\\"apple\\", \\"banana\\", \\"cherry\\"], \\"apple\\", \\"grape\\") Traceback (most recent call last): ... ValueError: Invalid input: words must contain both word1 and word2","solution":"def word_distance(words, word1, word2): Computes the shortest distance between two words in a list. if not words or word1 not in words or word2 not in words: raise ValueError(\\"Invalid input: words must contain both word1 and word2\\") min_distance = float('inf') index1, index2 = -1, -1 for i, word in enumerate(words): if word == word1: index1 = i if index2 != -1: min_distance = min(min_distance, abs(index1 - index2)) elif word == word2: index2 = i if index1 != -1: min_distance = min(min_distance, abs(index2 - index1)) return min_distance"},{"question":"def discrete_convolution(lst1: list[int], lst2: list[int]) -> list[int]: Calculates the discrete convolution of two lists of integers. The discrete convolution operation should produce a new list which is the linear convolution of the input lists. Args: lst1 (list[int]): A list of integers representing the first sequence. lst2 (list[int]): A list of integers representing the second sequence. Returns: list[int]: A list of integers representing the convolution of the two input lists. Constraints: Both input lists will have at least one and at most 1000 elements. Each integer in the lists will be between -1000 and 1000 inclusive. Example: >>> discrete_convolution([1, 2, 3], [0, 1, 0.5]) [0.0, 1.0, 2.5, 4.0, 1.5] pass","solution":"def discrete_convolution(lst1: list[int], lst2: list[int]) -> list[int]: Calculates the discrete convolution of two lists of integers. n = len(lst1) m = len(lst2) result = [0] * (n + m - 1) for i in range(n): for j in range(m): result[i + j] += lst1[i] * lst2[j] return result"},{"question":"import gzip import shutil import os def gzip_utility(operation: str, filename: str): Compresses or decompresses files using the gzip format based on the specified operation. Parameters: operation (str): The operation to perform ('compress' or 'decompress'). filename (str): The name of the file to compress or decompress. Returns: None. The function creates the compressed or decompressed file on the disk. Example Usage: >>> gzip_utility('compress', 'example.txt') >>> gzip_utility('decompress', 'example.txt.gz') # Your code here # Unit Tests def test_gzip_utility(): # test_compress create_file('testfile.txt', 'This is a test file') gzip_utility('compress', 'testfile.txt') assert os.path.isfile('testfile.txt.gz') with gzip.open('testfile.txt.gz', 'rt') as f: assert f.read() == 'This is a test file' remove_file('testfile.txt') remove_file('testfile.txt.gz') # test_decompress create_file('testfile.txt', 'This is a test file') with open('testfile.txt', 'rb') as f_in: with gzip.open('testfile.txt.gz', 'wb') as f_out: shutil.copyfileobj(f_in, f_out) gzip_utility('decompress', 'testfile.txt.gz') assert os.path.isfile('testfile.txt') with open('testfile.txt', 'r') as f: assert f.read() == 'This is a test file' remove_file('testfile.txt') remove_file('testfile.txt.gz') # test_invalid_operation try: gzip_utility('invalid', 'testfile.txt') except ValueError as e: assert str(e) == \\"Invalid operation. Use 'compress' or 'decompress'.\\" # test_file_not_found try: gzip_utility('compress', 'nonexistentfile.txt') except FileNotFoundError as e: assert str(e) == \\"The file 'nonexistentfile.txt' does not exist or is not a regular file.\\" # test_decompress_without_gz_extension create_file('testfile.txt.gz', 'This is a test file') try: gzip_utility('decompress', 'testfile.txt') except ValueError as e: assert str(e) == \\"The file to decompress must have a '.gz' extension.\\" remove_file('testfile.txt.gz') def create_file(filename, content): with open(filename, 'w') as f: f.write(content) def remove_file(filename): if os.path.isfile(filename): os.remove(filename)","solution":"import gzip import shutil import os def gzip_utility(operation: str, filename: str): Compresses or decompresses files using the gzip format based on the specified operation. Parameters: operation (str): The operation to perform ('compress' or 'decompress'). filename (str): The name of the file to compress or decompress. Returns: None. The function creates the compressed or decompressed file on the disk. try: if operation == \\"compress\\": if not os.path.isfile(filename): raise FileNotFoundError(f\\"The file '{filename}' does not exist or is not a regular file.\\") with open(filename, 'rb') as f_in: with gzip.open(filename + '.gz', 'wb') as f_out: shutil.copyfileobj(f_in, f_out) elif operation == \\"decompress\\": if not filename.endswith('.gz'): raise ValueError(\\"The file to decompress must have a '.gz' extension.\\") with gzip.open(filename, 'rb') as f_in: with open(filename[:-3], 'wb') as f_out: shutil.copyfileobj(f_in, f_out) else: raise ValueError(\\"Invalid operation. Use 'compress' or 'decompress'.\\") except FileNotFoundError as fnf_error: print(fnf_error) except PermissionError as perm_error: print(perm_error) except Exception as error: print(f\\"An error occurred: {error}\\")"},{"question":"def monthly_payment(principal: float, annual_interest_rate: float, loan_term_years: float) -> float: Calculate the monthly payment to be made over the term of the loan. Input: principal (float): The initial amount of the loan. annual_interest_rate (float): The annual interest rate. loan_term_years (float): The duration of the loan in years. Output: float: The amount to be paid monthly. Constraints: principal must be greater than 0. annual_interest_rate must be non-negative. loan_term_years must be greater than 0. def total_payment(principal: float, annual_interest_rate: float, loan_term_years: float) -> float: Calculate the total payment made over the loan term. Input: principal (float): The initial amount of the loan. annual_interest_rate (float): The annual interest rate. loan_term_years (float): The duration of the loan in years. Output: float: The total amount paid after all payments are made. Constraints: principal must be greater than 0. annual_interest_rate must be non-negative. loan_term_years must be greater than 0. def repayment_schedule(principal: float, annual_interest_rate: float, loan_term_years: float): Calculate the repayment schedule showing monthly breakdown of interest paid vs. principal repaid. Input: principal (float): The initial amount of the loan. annual_interest_rate (float): The annual interest rate. loan_term_years (float): The duration of the loan in years. Output: List[Tuple[float, float, float]]: A list, where each tuple contains: month (int): The month number. interest_payment (float): The amount of the payment that goes towards interest. principal_payment (float): The amount of the payment that goes towards the principal. Constraints: principal must be greater than 0. annual_interest_rate must be non-negative. loan_term_years must be greater than 0. import pytest from solution import monthly_payment, total_payment, repayment_schedule def test_monthly_payment(): assert pytest.approx(monthly_payment(100000, 5, 30), 0.01) == 536.82 assert pytest.approx(monthly_payment(200000, 3.5, 15), 0.01) == 1427.53 assert pytest.approx(monthly_payment(150000, 0, 30), 0.01) == 416.67 with pytest.raises(ValueError): monthly_payment(-100000, 5, 30) with pytest.raises(ValueError): monthly_payment(100000, -5, 30) with pytest.raises(ValueError): monthly_payment(100000, 5, -30) def test_total_payment(): assert pytest.approx(total_payment(100000, 5, 30), 0.01) == 536.82 * 30 * 12 assert pytest.approx(total_payment(200000, 3.5, 15), 0.01) == 1427.53 * 15 * 12 assert pytest.approx(total_payment(150000, 0, 30), 0.01) == 416.67 * 30 * 12 with pytest.raises(ValueError): total_payment(-100000, 5, 30) with pytest.raises(ValueError): total_payment(100000, -5, 30) with pytest.raises(ValueError): total_payment(100000, 5, -30) def test_repayment_schedule(): schedule = repayment_schedule(100000, 5, 30) assert len(schedule) == 30 * 12 assert pytest.approx(schedule[0][1], 0.01) == 416.67 assert pytest.approx(schedule[0][2], 0.01) == 120.15 with pytest.raises(ValueError): repayment_schedule(-100000, 5, 30) with pytest.raises(ValueError): repayment_schedule(100000, -5, 30) with pytest.raises(ValueError): repayment_schedule(100000, 5, -30)","solution":"def monthly_payment(principal: float, annual_interest_rate: float, loan_term_years: float) -> float: Calculate the monthly loan payment. :param principal: The initial amount of the loan. :param annual_interest_rate: The annual interest rate as a percentage. :param loan_term_years: The duration of the loan in years. :return: The monthly payment amount. if principal <= 0: raise ValueError(\\"Principal must be greater than 0\\") if annual_interest_rate < 0: raise ValueError(\\"Annual interest rate must be non-negative\\") if loan_term_years <= 0: raise ValueError(\\"Loan term years must be greater than 0\\") monthly_interest_rate = annual_interest_rate / 12 / 100 number_of_payments = loan_term_years * 12 if monthly_interest_rate == 0: return principal / number_of_payments return principal * (monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments) / ((1 + monthly_interest_rate) ** number_of_payments - 1) def total_payment(principal: float, annual_interest_rate: float, loan_term_years: float) -> float: Calculate the total payment over the loan term. :param principal: The initial amount of the loan. :param annual_interest_rate: The annual interest rate as a percentage. :param loan_term_years: The duration of the loan in years. :return: The total payment amount. return monthly_payment(principal, annual_interest_rate, loan_term_years) * loan_term_years * 12 def repayment_schedule(principal: float, annual_interest_rate: float, loan_term_years: float): Calculate the repayment schedule showing monthly breakdown of interest and principal. :param principal: The initial amount of the loan. :param annual_interest_rate: The annual interest rate as a percentage. :param loan_term_years: The duration of the loan in years. :return: A list of tuples containing month number, interest payment, and principal payment. schedule = [] monthly_interest_rate = annual_interest_rate / 12 / 100 number_of_payments = loan_term_years * 12 fixed_monthly_payment = monthly_payment(principal, annual_interest_rate, loan_term_years) current_principal = principal for month in range(1, number_of_payments + 1): interest_payment = current_principal * monthly_interest_rate principal_payment = fixed_monthly_payment - interest_payment current_principal -= principal_payment schedule.append((month, interest_payment, principal_payment)) return schedule"},{"question":"def evaluate_postfix(expression: str) -> float: Evaluate a given postfix expression and return the final result. >>> abs(evaluate_postfix(\\"3 4 +\\") - 7.0) < 1e-9 True >>> abs(evaluate_postfix(\\"5 1 2 + 4 * + 3 -\\") - 14.0) < 1e-9 True >>> abs(evaluate_postfix(\\"10 2 8 * + 3 -\\") - 23.0) < 1e-9 True >>> abs(evaluate_postfix(\\"6 2 /\\") - 3.0) < 1e-9 True >>> abs(evaluate_postfix(\\"1 2 + 3 4 * + 5 -\\") - 10.0) < 1e-9 True pass","solution":"def evaluate_postfix(expression: str) -> float: stack = [] for token in expression.split(): if token.isdigit() or (token[1:].isdigit() and token[0] == '-'): stack.append(float(token)) else: b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': stack.append(a / b) return stack.pop() # Example usage print(evaluate_postfix(\\"5 1 2 + 4 * + 3 -\\")) # Should print 14.0"},{"question":"class StudentRecords: def __init__(self, records): Initialize the StudentRecords object with a list of student records where each record is a dictionary with keys 'first_name', 'last_name', and 'grade'. pass def add_record(self, first_name, last_name, grade): Add a new student record to the list. Raise a ValueError for invalid grades or duplicate records. pass def remove_record(self, first_name, last_name): Remove a student record from the list by matching the first and last name. Raise a ValueError if the student is not found. pass def get_grades(self, first_name, last_name): Retrieve the grade of the student by their first and last name. Raise a ValueError if the student is not found. pass def average_grade(self): Calculate the average grade of all students in the list. Return 0.00 if there are no records. pass # Unit Tests import pytest def test_add_record(): sr = StudentRecords([]) sr.add_record(\\"John\\", \\"Doe\\", 85) assert sr.get_grades(\\"John\\", \\"Doe\\") == 85 def test_add_record_invalid_grade(): sr = StudentRecords([]) with pytest.raises(ValueError, match=\\"Grade must be an integer between 0 and 100.\\"): sr.add_record(\\"John\\", \\"Doe\\", 105) def test_remove_record(): records = [{\\"first_name\\": \\"John\\", \\"last_name\\": \\"Doe\\", \\"grade\\": 85}] sr = StudentRecords(records) sr.remove_record(\\"John\\", \\"Doe\\") with pytest.raises(ValueError, match=\\"Student John Doe not found.\\"): sr.get_grades(\\"John\\", \\"Doe\\") def test_remove_record_not_found(): sr = StudentRecords([]) with pytest.raises(ValueError, match=\\"Student John Doe not found.\\"): sr.remove_record(\\"John\\", \\"Doe\\") def test_get_grades(): records = [{\\"first_name\\": \\"Jane\\", \\"last_name\\": \\"Smith\\", \\"grade\\": 92}] sr = StudentRecords(records) assert sr.get_grades(\\"Jane\\", \\"Smith\\") == 92 def test_get_grades_not_found(): sr = StudentRecords([]) with pytest.raises(ValueError, match=\\"Student John Doe not found.\\"): sr.get_grades(\\"John\\", \\"Doe\\") def test_average_grade(): records = [ {\\"first_name\\": \\"John\\", \\"last_name\\": \\"Doe\\", \\"grade\\": 85}, {\\"first_name\\": \\"Jane\\", \\"last_name\\": \\"Smith\\", \\"grade\\": 92} ] sr = StudentRecords(records) assert sr.average_grade() == 88.50 def test_average_grade_empty(): sr = StudentRecords([]) assert sr.average_grade() == 0.00 def test_duplicate_record(): records = [{\\"first_name\\": \\"John\\", \\"last_name\\": \\"Doe\\", \\"grade\\": 85}] sr = StudentRecords(records) with pytest.raises(ValueError, match=\\"Duplicate student record.\\"): sr.add_record(\\"John\\", \\"Doe\\", 90) def test_add_multiple_records(): sr = StudentRecords([]) sr.add_record(\\"John\\", \\"Doe\\", 85) sr.add_record(\\"Jane\\", \\"Smith\\", 90) assert sr.get_grades(\\"John\\", \\"Doe\\") == 85 assert sr.get_grades(\\"Jane\\", \\"Smith\\") == 90 def test_empty_initial_records(): sr = StudentRecords([]) assert sr.records == []","solution":"class StudentRecords: def __init__(self, records): self.records = records def add_record(self, first_name, last_name, grade): if not isinstance(grade, int) or not (0 <= grade <= 100): raise ValueError(\\"Grade must be an integer between 0 and 100.\\") for record in self.records: if record[\\"first_name\\"] == first_name and record[\\"last_name\\"] == last_name: raise ValueError(\\"Duplicate student record.\\") self.records.append({\\"first_name\\": first_name, \\"last_name\\": last_name, \\"grade\\": grade}) def remove_record(self, first_name, last_name): for record in self.records: if record[\\"first_name\\"] == first_name and record[\\"last_name\\"] == last_name: self.records.remove(record) return raise ValueError(f\\"Student {first_name} {last_name} not found.\\") def get_grades(self, first_name, last_name): for record in self.records: if record[\\"first_name\\"] == first_name and record[\\"last_name\\"] == last_name: return record[\\"grade\\"] raise ValueError(f\\"Student {first_name} {last_name} not found.\\") def average_grade(self): if not self.records: return 0.00 total_grade = sum(record[\\"grade\\"] for record in self.records) return round(total_grade / len(self.records), 2)"},{"question":"from typing import Tuple def max_consecutive_char_info(s: str) -> Tuple[str, int]: Given a string, identifies the most frequently occurring character and the length of its consecutive appearances. Args: s (str): The input string. Returns: Tuple[str, int]: A tuple consisting of the character with the highest frequency of consecutive appearances and the length of its consecutive appearances. Raises: ValueError: If the input string is empty. Examples: >>> max_consecutive_char_info(\\"aaabbcccd\\") ('a', 3) >>> max_consecutive_char_info(\\"fffeeeedddccc\\") ('e', 4) >>> max_consecutive_char_info(\\"xyz\\") ('x', 1) >>> max_consecutive_char_info(\\"aabbbccdddd\\") ('d', 4)","solution":"from typing import Tuple def max_consecutive_char_info(s: str) -> Tuple[str, int]: if not s: raise ValueError(\\"Input string must not be empty\\") max_char = s[0] max_count = 1 current_char = s[0] current_count = 1 for i in range(1, len(s)): if s[i] == current_char: current_count += 1 else: if current_count > max_count or (current_count == max_count and current_char < max_char): max_char = current_char max_count = current_count current_char = s[i] current_count = 1 if current_count > max_count or (current_count == max_count and current_char < max_char): max_char = current_char max_count = current_count return max_char, max_count"},{"question":"def most_frequent_word(text): Returns the most frequently occurring word in the given text. If there is a tie, returns one of the most frequent words. Raises a TypeError if input is not a string. pass import pytest def test_single_most_frequent(): assert most_frequent_word(\\"the quick brown fox jumps over the lazy dog\\") == \\"the\\" def test_multiple_most_frequent(): assert most_frequent_word(\\"hello world hello again\\") == \\"hello\\" def test_tie_frequent_words(): assert most_frequent_word(\\"one two two three three three\\") == \\"three\\" def test_frequent_in_mixed_text(): assert most_frequent_word(\\"a b c d e f g a b c d e a b c\\") == \\"a\\" def test_empty_string(): assert most_frequent_word(\\"\\") == \\"\\" def test_case_insensitivity(): assert most_frequent_word(\\"Python Python python\\") == \\"python\\" def test_non_string_input(): with pytest.raises(TypeError): most_frequent_word(['this', 'is', 'not', 'a', 'string'])","solution":"def most_frequent_word(text): Returns the most frequently occurring word in the given text. if not isinstance(text, str): raise TypeError(\\"Input must be a string\\") if text == \\"\\": return \\"\\" word_count = {} words = text.lower().split() for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 max_count = max(word_count.values()) for word, count in word_count.items(): if count == max_count: return word"},{"question":"ref_counts = {} def inc_ref(obj: str) -> None: Increment the reference count for the given object. If the object is not already tracked, initialize its reference count to 1. >>> inc_ref(\\"object1\\") >>> inc_ref(\\"object1\\") >>> dec_ref(\\"object1\\") >>> ref_counts {\\"object1\\": 1} def dec_ref(obj: str) -> None: Decrement the reference count for the given object. If the reference count drops to 0, the object should be marked for garbage collection. >>> inc_ref(\\"object1\\") >>> dec_ref(\\"object1\\") >>> ref_counts {} def collect_garbage() -> None: Remove all objects marked for garbage collection from memory. >>> inc_ref(\\"object1\\") >>> dec_ref(\\"object1\\") >>> collect_garbage() >>> ref_counts {}","solution":"ref_counts = {} def inc_ref(obj: str) -> None: global ref_counts if obj in ref_counts: ref_counts[obj] += 1 else: ref_counts[obj] = 1 def dec_ref(obj: str) -> None: global ref_counts if obj in ref_counts: ref_counts[obj] -= 1 if ref_counts[obj] == 0: collect_garbage() else: raise ValueError(\\"Object not found in reference counter.\\") def collect_garbage() -> None: global ref_counts to_delete = [obj for obj, count in ref_counts.items() if count == 0] for obj in to_delete: del ref_counts[obj]"},{"question":"def fibonacci_recursive(n): Naive recursive approach to generate the first n terms of the Fibonacci sequence. >>> fibonacci_recursive(0) [] >>> fibonacci_recursive(1) [0] >>> fibonacci_recursive(2) [0, 1] >>> fibonacci_recursive(5) [0, 1, 1, 2, 3] >>> fibonacci_recursive(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] pass def fibonacci_iterative(n): Iterative approach to generate the first n terms of the Fibonacci sequence. >>> fibonacci_iterative(0) [] >>> fibonacci_iterative(1) [0] >>> fibonacci_iterative(2) [0, 1] >>> fibonacci_iterative(5) [0, 1, 1, 2, 3] >>> fibonacci_iterative(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] pass def fibonacci_memoized(n, memo=None): Optimized recursive approach using memoization to generate the first n terms of the Fibonacci sequence. >>> fibonacci_memoized(0) [] >>> fibonacci_memoized(1) [0] >>> fibonacci_memoized(2) [0, 1] >>> fibonacci_memoized(5) [0, 1, 1, 2, 3] >>> fibonacci_memoized(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] pass","solution":"def fibonacci_recursive(n): Naive recursive approach to generate the first n terms of the Fibonacci sequence. if n == 0: return [] elif n == 1: return [0] elif n == 2: return [0, 1] return fibonacci_recursive(n-1) + [fibonacci_recursive(n-1)[-1] + fibonacci_recursive(n-1)[-2]] def fibonacci_iterative(n): Iterative approach to generate the first n terms of the Fibonacci sequence. if n == 0: return [] elif n == 1: return [0] sequence = [0, 1] while len(sequence) < n: sequence.append(sequence[-1] + sequence[-2]) return sequence def fibonacci_memoized(n, memo=None): Optimized recursive approach using memoization to generate the first n terms of the Fibonacci sequence. if memo is None: memo = {0: [], 1: [0], 2: [0, 1]} if n in memo: return memo[n] else: result = fibonacci_memoized(n-1, memo) + [fibonacci_memoized(n-1, memo)[-1] + fibonacci_memoized(n-1, memo)[-2]] memo[n] = result return result"},{"question":"from typing import Any, List, Tuple class KeyValueStore: def __init__(self): self.store = {} def set(self, key: Any, value: Any) -> None: Set the value for the specified key in the key-value store. pass def get(self, key: Any) -> Any: Retrieve the value for the specified key. If the key does not exist, return None. pass def delete(self, key: Any) -> None: Delete the specified key from the key-value store. pass def execute_commands(commands: List[Tuple[str, Any, Any]]) -> List[Any]: Execute a sequence of commands on the key-value store and return the results of 'get' operations. Commands: (\\"set\\", key, value) - Sets the key to the specified value. (\\"get\\", key) - Retrieves the value for the specified key. (\\"delete\\", key) - Removes the key from the store. Returns: List of results for 'get' operations in the order they appear in the input. Example: >>> commands = [(\\"set\\", 1, \\"a\\"), (\\"set\\", \\"b\\", 2), (\\"get\\", 1), (\\"delete\\", \\"b\\"), (\\"get\\", \\"b\\")] >>> execute_commands(commands) [\\"a\\", None] results = [] kv_store = KeyValueStore() for command in commands: operation = command[0] if operation == \\"set\\": kv_store.set(command[1], command[2]) elif operation == \\"get\\": results.append(kv_store.get(command[1])) elif operation == \\"delete\\": kv_store.delete(command[1]) return results","solution":"from typing import Any, List, Tuple class KeyValueStore: def __init__(self): self.store = {} def set(self, key: Any, value: Any) -> None: self.store[key] = value def get(self, key: Any) -> Any: return self.store.get(key) def delete(self, key: Any) -> None: if key in self.store: del self.store[key] def execute_commands(commands: List[Tuple[str, Any, Any]]) -> List[Any]: kv_store = KeyValueStore() results = [] for command in commands: if command[0] == \\"set\\": kv_store.set(command[1], command[2]) elif command[0] == \\"get\\": results.append(kv_store.get(command[1])) elif command[0] == \\"delete\\": kv_store.delete(command[1]) return results"},{"question":"from typing import List, Dict def extract_hashtags(tweets: List[str]) -> Dict[str, int]: Extract and count the occurrences of hashtags in a list of tweets. >>> extract_hashtags([\\"Loving the #Python and #DataScience community!\\"]) {'#python': 1, '#datascience': 1} >>> extract_hashtags([\\"#Python is great! Loving #python and #DataScience\\"]) {'#python': 2, '#datascience': 1} >>> extract_hashtags([\\"Loving the community!\\"]) {}","solution":"from typing import List, Dict import re from collections import defaultdict def extract_hashtags(tweets: List[str]) -> Dict[str, int]: hashtag_counts = defaultdict(int) hashtag_pattern = re.compile(r'#w+') for tweet in tweets: hashtags = hashtag_pattern.findall(tweet) for hashtag in hashtags: normalized_hashtag = hashtag.lower() hashtag_counts[normalized_hashtag] += 1 return dict(hashtag_counts)"},{"question":"import heapq class MedianFinder: def __init__(self): Initializes the MedianFinder object. def add_num(self, num: int) -> None: Adds a number to the data structure. :param num: An integer to be added. def find_median(self) -> float: Finds the median of the current elements in the data structure. :return: The median as a float. # Example medianFinder = MedianFinder() medianFinder.add_num(-1) medianFinder.add_num(-2) print(medianFinder.find_median()) # Output: -1.5 medianFinder.add_num(-3) print(medianFinder.find_median()) # Output: -2 # Test Cases def test_median_finder(): mf = MedianFinder() mf.add_num(1) assert mf.find_median() == 1.0 mf.add_num(2) assert mf.find_median() == 1.5 mf.add_num(3) assert mf.find_median() == 2.0 mf.add_num(4) assert mf.find_median() == 2.5 mf.add_num(5) assert mf.find_median() == 3.0 def test_median_finder_with_negative_numbers(): mf = MedianFinder() mf.add_num(-1) mf.add_num(-2) assert mf.find_median() == -1.5 mf.add_num(-3) assert mf.find_median() == -2.0 def test_median_finder_mixed_numbers(): mf = MedianFinder() mf.add_num(5) mf.add_num(-5) assert mf.find_median() == 0.0 mf.add_num(2) assert mf.find_median() == 2.0 mf.add_num(1) assert mf.find_median() == 1.5 mf.add_num(-1) assert mf.find_median() == 1.0","solution":"import heapq class MedianFinder: def __init__(self): self.small = [] # Max-heap for the lower half self.large = [] # Min-heap for the upper half def add_num(self, num: int) -> None: heapq.heappush(self.small, -num) # Ensuring the max-heap property of small and min-heap property of large if self.small and self.large and (-self.small[0] > self.large[0]): heapq.heappush(self.large, -heapq.heappop(self.small)) # Balance the two halves if len(self.small) > len(self.large) + 1: heapq.heappush(self.large, -heapq.heappop(self.small)) elif len(self.large) > len(self.small): heapq.heappush(self.small, -heapq.heappop(self.large)) def find_median(self) -> float: if len(self.small) > len(self.large): return float(-self.small[0]) return (-self.small[0] + self.large[0]) / 2.0"},{"question":"def longest_anagram_free_substring(s: str) -> int: Returns the length of the longest anagram-free substring in the given string \`s\`. Args: s (str): A string composed of lowercase English letters. Returns: int: The length of the longest anagram-free substring. Examples: >>> longest_anagram_free_substring(\\"abcde\\") 5 >>> longest_anagram_free_substring(\\"abba\\") 2 >>> longest_anagram_free_substring(\\"abcdabc\\") 4 # Your code here","solution":"def longest_anagram_free_substring(s: str) -> int: Returns the length of the longest anagram-free substring in the given string \`s\`. max_len = 0 start = 0 char_freq = {} for end in range(len(s)): char = s[end] if char not in char_freq: char_freq[char] = 0 char_freq[char] += 1 while char_freq[char] > 1: char_freq[s[start]] -= 1 if char_freq[s[start]] == 0: del char_freq[s[start]] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"# Function Completion def autocomplete_book_titles(titles: list[str], prefix: str) -> list[str]: class TrieNode: def __init__(self): self.children = {} self.is_end_of_title = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, title: str) -> None: node = self.root for char in title: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_title = True def search_with_prefix(self, prefix: str): node = self.root for char in prefix: if (char not in node.children): return [] node = node.children[char] # Perform DFS from this node to get all titles with this prefix result = [] self._dfs(node, prefix, result) return result def _dfs(self, node, prefix, result): if node.is_end_of_title: result.append(prefix) for char, next_node in node.children.items(): self._dfs(next_node, prefix + char, result) trie = Trie() for title in titles: trie.insert(title) # Search for titles with the given prefix results = trie.search_with_prefix(prefix) # Return sorted results return sorted(results)","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_title = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, title: str) -> None: node = self.root for char in title: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_title = True def search_with_prefix(self, prefix: str): node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] # Perform DFS from this node to get all titles with this prefix result = [] self._dfs(node, prefix, result) return result def _dfs(self, node, prefix, result): if node.is_end_of_title: result.append(prefix) for char, next_node in node.children.items(): self._dfs(next_node, prefix + char, result) def autocomplete_book_titles(titles: list[str], prefix: str) -> list[str]: trie = Trie() for title in titles: trie.insert(title) # Search for titles with the given prefix results = trie.search_with_prefix(prefix) # Return sorted results return sorted(results)"},{"question":"import numpy as np import csv def sum_real_roots(filename: str) -> float: Reads a csv file containing polynomial coefficients, finds the real roots of each polynomial, and returns the sum of the absolute values of all the real roots found. Args: filename (str): The path to the csv file containing the polynomial coefficients. Returns: float: The sum of the absolute values of all the real roots. Examples: >>> sum_real_roots(\\"polynomials.csv\\") 5.0 total_sum_abs_roots = 0.0 with open(filename, 'r') as file: reader = csv.reader(file) for row in reader: # Convert the row into a list of floats (coefficients) coefficients = list(map(float, row)) # Find all roots of the polynomial roots = np.roots(coefficients) # Filter out the real roots and take their absolute values real_roots = [root.real for root in roots if np.isclose(root.imag, 0)] sum_abs_real_roots = sum(map(abs, real_roots)) # Add to the total sum total_sum_abs_roots += sum_abs_real_roots return total_sum_abs_roots # Unit Tests def create_temp_csv(filename, rows): with open(filename, 'w', newline='') as file: writer = csv.writer(file) writer.writerows(rows) def test_sum_real_roots_single_polynomial(): create_temp_csv('temp1.csv', [['1.0', '-3.0', '2.0']]) # Roots: 1, 2 assert np.isclose(sum_real_roots('temp1.csv'), 3.0) def test_sum_real_roots_multiple_polynomials(): create_temp_csv('temp2.csv', [['1.0', '-3.0', '2.0'], ['1.0', '0.0', '-4.0']]) # Roots: 1, 2 and 2 assert np.isclose(sum_real_roots('temp2.csv'), 7.0) def test_sum_real_roots_no_real_roots(): create_temp_csv('temp3.csv', [['1.0', '0.0', '1.0']]) # Roots: i (imaginary) assert np.isclose(sum_real_roots('temp3.csv'), 0.0) def test_sum_real_roots_mixed_roots(): create_temp_csv('temp4.csv', [['1.0', '-2.0', '1.0'], ['1.0', '0.0', '0.0', '-1.0']]) # Roots: 1, 1 and 0, -1 assert np.isclose(sum_real_roots('temp4.csv'), 3.0) def test_sum_real_roots_large_input(): # A polynomial with a large number of coefficients create_temp_csv('temp5.csv', [['1.0'] + ['0.0'] * 99 + ['-1.0']]) # Roots: degree 100, only 1 assert np.isclose(sum_real_roots('temp5.csv'), 2.0)","solution":"import numpy as np import csv def sum_real_roots(filename: str) -> float: Reads a csv file containing polynomial coefficients, finds the real roots of each polynomial, and returns the sum of the absolute values of all the real roots found. total_sum_abs_roots = 0.0 with open(filename, 'r') as file: reader = csv.reader(file) for row in reader: # Convert the row into a list of floats (coefficients) coefficients = list(map(float, row)) # Find all roots of the polynomial roots = np.roots(coefficients) # Filter out the real roots and take their absolute values real_roots = [root.real for root in roots if np.isclose(root.imag, 0)] sum_abs_real_roots = sum(map(abs, real_roots)) # Add to the total sum total_sum_abs_roots += sum_abs_real_roots return total_sum_abs_roots"},{"question":"[Completion Task in Python] # Objective Write a function to determine the minimal number of operations required to transform one binary tree into another. The allowed operations are insertions, deletions, and changes of values of nodes. # Specifications * **Function Name**: min_operations_to_transform_tree * **Input**: * \`root1\` (TreeNode): The root node of the first binary tree. * \`root2\` (TreeNode): The root node of the second binary tree. * **Output**: * (int): The minimal number of operations required. # Constraints * The number of nodes in either tree will not exceed 1000. * The value of each node in the trees is an integer. # Performance * The implementation should aim to be efficient, ideally operating within a time complexity of O(n * m), where n and m represent the number of nodes in the respective trees. # Example class TreeNode: def __init__(val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_operations_to_transform_tree(root1: TreeNode, root2: TreeNode) -> int: def min_operations(n1, n2): if not n1 and not n2: return 0 if not n1: return 1 + min_operations(None, n2.left) + min_operations(None, n2.right) if not n2: return 1 + min_operations(n1.left, None) + min_operations(n1.right, None) if n1.val != n2.val: op_replace = 1 + min_operations(n1.left, n2.left) + min_operations(n1.right, n2.right) else: op_replace = min_operations(n1.left, n2.left) + min_operations(n1.right, n2.right) op_insert_delete = 1 + min_operations(None, n2.left) + min_operations(None, n2.right) op_insert_delete += 1 + min_operations(n1.left, None) + min_operations(n1.right, None) return min(op_replace, op_insert_delete) return min_operations(root1, root2) # Example Usage # Tree 1: Tree 2: # 1 1 # / / # 2 3 4 5 # Tree1: root1 = TreeNode(1, TreeNode(2), TreeNode(3)) # Tree2: root2 = TreeNode(1, TreeNode(4), TreeNode(5)) root1 = TreeNode(1, TreeNode(2), TreeNode(3)) root2 = TreeNode(1, TreeNode(4), TreeNode(5)) print(min_operations_to_transform_tree(root1, root2)) # Output: 2 # Tree 1: Tree 2: # 1 1 # # 3 2 root1 = TreeNode(1, None, TreeNode(3)) root2 = TreeNode(1, None, TreeNode(2)) print(min_operations_to_transform_tree(root1, root2)) # Output: 1 # Additional Notes 1. Ensure your solution can handle edge cases, such as when one or both of the trees are empty. 2. Pay careful attention to both the structure and the values of nodes in the trees during your transformations.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_operations_to_transform_tree(root1: TreeNode, root2: TreeNode) -> int: def min_operations(n1, n2): if not n1 and not n2: return 0 if not n1: return 1 + min_operations(None, n2.left) + min_operations(None, n2.right) if not n2: return 1 + min_operations(n1.left, None) + min_operations(n1.right, None) if n1.val != n2.val: op_replace = 1 + min_operations(n1.left, n2.left) + min_operations(n1.right, n2.right) else: op_replace = min_operations(n1.left, n2.left) + min_operations(n1.right, n2.right) op_insert_delete = 1 + min_operations(None, n2.left) + min_operations(None, n2.right) op_insert_delete += 1 + min_operations(n1.left, None) + min_operations(n1.right, None) return min(op_replace, op_insert_delete) return min_operations(root1, root2)"},{"question":"def update_inventory(initial_inventory: dict, transactions: list) -> dict: Updates the initial inventory based on the transactions provided. Parameters: initial_inventory (dict): A dictionary where keys are item names (strings) and values are quantities (integers). transactions (list): A list of transactions where each transaction is a tuple of the form (item_name: str, change_in_qty: int). Returns: dict: The updated inventory after applying all transactions. Examples: >>> update_inventory({'apples': 10, 'bananas': 5, 'oranges': 8}, [('apples', -3), ('bananas', 2), ('oranges', -5), ('kiwis', 7)]) {'apples': 7, 'bananas': 7, 'oranges': 3, 'kiwis': 7} >>> update_inventory({'notebooks': 20, 'pens': 50}, [('notebooks', -10), ('pens', -25), ('markers', 12)]) {'notebooks': 10, 'pens': 25, 'markers': 12} >>> update_inventory({}, [('bottles', 5), ('cans', 3)]) {'bottles': 5, 'cans': 3}","solution":"def update_inventory(initial_inventory: dict, transactions: list) -> dict: Updates the initial inventory based on the transactions provided. Parameters: initial_inventory (dict): A dictionary where keys are item names (strings) and values are quantities (integers). transactions (list): A list of transactions where each transaction is a tuple of the form (item_name: str, change_in_qty: int). Returns: dict: The updated inventory after applying all transactions. updated_inventory = initial_inventory.copy() for item_name, change_in_qty in transactions: if item_name in updated_inventory: updated_inventory[item_name] += change_in_qty else: updated_inventory[item_name] = change_in_qty return updated_inventory"},{"question":"import re from collections import defaultdict from typing import List, Dict def generate_word_histogram(text_corpus: str, stop_words: List[str]) -> Dict[str, int]: Generate a histogram of word frequencies excluding specified stop words. Args: text_corpus: A string containing the text data to be analyzed. stop_words: A list of words to be excluded from the histogram. Returns: A dictionary where keys are words and values are their corresponding frequencies in the text_corpus. pass def test_generate_word_histogram_basic(): text_corpus = \\"Wow! This product is amazing. I have never used something so great, absolutely love it.\\" stop_words = [\\"is\\", \\"have\\", \\"so\\", \\"it\\"] expected_output = { 'wow': 1, 'this': 1, 'product': 1, 'amazing': 1, 'i': 1, 'never': 1, 'used': 1, 'something': 1, 'great': 1, 'absolutely': 1, 'love': 1 } assert generate_word_histogram(text_corpus, stop_words) == expected_output def test_generate_word_histogram_empty_corpus(): text_corpus = \\"\\" stop_words = [\\"is\\", \\"have\\", \\"so\\", \\"it\\"] assert generate_word_histogram(text_corpus, stop_words) == {} def test_generate_word_histogram_all_stop_words(): text_corpus = \\"Wow! This product is amazing. I have never used something so great, absolutely love it.\\" stop_words = [\\"wow\\", \\"this\\", \\"product\\", \\"is\\", \\"amazing\\", \\"i\\", \\"have\\", \\"never\\", \\"used\\", \\"something\\", \\"so\\", \\"great\\", \\"absolutely\\", \\"love\\", \\"it\\"] assert generate_word_histogram(text_corpus, stop_words) == {} def test_generate_word_histogram_no_stop_words(): text_corpus = \\"Wow! This product is amazing. I have never used something so great, absolutely love it.\\" stop_words = [] expected_output = { 'wow': 1, 'this': 1, 'product': 1, 'is': 1, 'amazing': 1, 'i': 1, 'have': 1, 'never': 1, 'used': 1, 'something': 1, 'so': 1, 'great': 1, 'absolutely': 1, 'love': 1, 'it': 1 } assert generate_word_histogram(text_corpus, stop_words) == expected_output def test_generate_word_histogram_mixed_case(): text_corpus = \\"Wow! This product IS amazing. I HAVE never used something so great, absolutely love IT.\\" stop_words = [\\"is\\", \\"have\\", \\"so\\", \\"it\\"] expected_output = { 'wow': 1, 'this': 1, 'product': 1, 'amazing': 1, 'i': 1, 'never': 1, 'used': 1, 'something': 1, 'great': 1, 'absolutely': 1, 'love': 1 } assert generate_word_histogram(text_corpus, stop_words) == expected_output","solution":"import re from collections import defaultdict from typing import List, Dict def generate_word_histogram(text_corpus: str, stop_words: List[str]) -> Dict[str, int]: Generate a histogram of word frequencies excluding specified stop words. Args: text_corpus: A string containing the text data to be analyzed. stop_words: A list of words to be excluded from the histogram. Returns: A dictionary where keys are words and values are their corresponding frequencies in the text_corpus. # Normalize case and remove punctuation using regex text_corpus = text_corpus.lower() # Convert text corpus to lowercase text_corpus = re.sub(r'[^ws]', ' ', text_corpus) # Replace punctuation with space # Split the text into words words = text_corpus.split() # Create a set for stop words for O(1) average time complexity on lookups stop_words_set = set(stop_words) # Initialize a default dictionary to count word frequencies histogram = defaultdict(int) # Count frequencies of non-stop words for word in words: if word not in stop_words_set: histogram[word] += 1 return dict(histogram)"},{"question":"def add_book(library: dict[int, list[str]], book_title: str) -> None: Adds a book to the library, distributing books evenly across shelves. >>> library = {} >>> add_book(library, \\"Harry Potter\\") >>> add_book(library, \\"The Hobbit\\") >>> library == {0: [\\"Harry Potter\\"], 1: [\\"The Hobbit\\"]} True def find_book(library: dict[int, list[str]], book_title: str) -> int: Finds a book by its title and returns its shelf index or -1 if not found. >>> library = {0: [\\"Harry Potter\\", \\"1984\\"], 1: [\\"The Hobbit\\", \\"Moby Dick\\"]} >>> find_book(library, \\"Harry Potter\\") 0 >>> find_book(library, \\"The Hobbit\\") 1 >>> find_book(library, \\"The Catcher in the Rye\\") -1","solution":"def add_book(library: dict[int, list[str]], book_title: str) -> None: Adds a book to the library, distributing books evenly across shelves. if not library: library[0] = [book_title] else: # Find the shelf with the fewest books min_shelf = min(library, key=lambda k: len(library[k])) library[min_shelf].append(book_title) def find_book(library: dict[int, list[str]], book_title: str) -> int: Finds a book by its title and returns its shelf index or -1 if not found. for shelf, books in library.items(): if book_title in books: return shelf return -1"},{"question":"import numpy as np class SignalProcessing: def __init__(self, signal): Initializes the SignalProcessing object with the given signal. :param signal: A 1-dimensional numpy array representing the signal. self.signal = signal def moving_average_filter(self, window_size): Reduces noise in the signal using a simple moving average filter. :param window_size: Size of the moving window (must be an odd positive integer) :return: Smoothed signal as a numpy array # Implement the method here # Unit Tests import pytest def test_moving_average_filter_basic(): signal = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9]) sp = SignalProcessing(signal) result = sp.moving_average_filter(3) expected = np.array([2., 3., 4., 5., 6., 7., 8.]) assert np.allclose(result, expected) def test_moving_average_filter_edge_case(): signal = np.array([1, 2, 3, 4, 5]) sp = SignalProcessing(signal) result = sp.moving_average_filter(5) expected = np.array([3.]) assert np.allclose(result, expected) def test_moving_average_filter_large_window(): signal = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) sp = SignalProcessing(signal) result = sp.moving_average_filter(7) expected = np.array([4., 5., 6., 7.]) assert np.allclose(result, expected) def test_moving_average_filter_invalid_window_size(): signal = np.array([1, 2, 3, 4, 5]) sp = SignalProcessing(signal) with pytest.raises(ValueError): sp.moving_average_filter(4) # window_size must be odd with pytest.raises(ValueError): sp.moving_average_filter(0) # window_size must be positive with pytest.raises(ValueError): sp.moving_average_filter(-3) # window_size must be positive def test_moving_average_filter_single_element_signal(): signal = np.array([5]) sp = SignalProcessing(signal) result = sp.moving_average_filter(1) expected = np.array([5.]) assert np.allclose(result, expected)","solution":"import numpy as np class SignalProcessing: def __init__(self, signal): Initializes the SignalProcessing object with the given signal. :param signal: A 1-dimensional numpy array representing the signal. self.signal = signal def moving_average_filter(self, window_size): Reduces noise in the signal using a simple moving average filter. :param window_size: Size of the moving window (must be an odd positive integer) :return: Smoothed signal as a numpy array if window_size % 2 == 0 or window_size < 1: raise ValueError(\\"window_size must be an odd positive integer\\") return np.convolve(self.signal, np.ones(window_size)/window_size, mode='valid')"},{"question":"def find_connected_components(graph): Finds all connected components in an undirected graph. :param graph: A dictionary where the keys are vertex identifiers and the values are lists of adjacent vertices. :return: A list of lists, where each inner list represents a connected component containing vertex identifiers. # Example usage: graph = { 0: [1, 2], 1: [0, 2], 2: [0, 1], 3: [4], 4: [3], 5: [] } def test_single_component(): graph = { 0: [1, 2], 1: [0, 2], 2: [0, 1] } result = find_connected_components(graph) assert result == [[0, 1, 2]] or result == [[1, 0, 2]] or result == [[2, 0, 1]] def test_multiple_components(): graph = { 0: [1, 2], 1: [0, 2], 2: [0, 1], 3: [4], 4: [3], 5: [] } result = find_connected_components(graph) assert sorted(result) == sorted([[0, 1, 2], [3, 4], [5]]) def test_no_edges(): graph = { 0: [], 1: [], 2: [] } result = find_connected_components(graph) assert sorted(result) == sorted([[0], [1], [2]]) def test_disconnected_nodes(): graph = { 0: [1], 1: [0], 2: [], 3: [4], 4: [3] } result = find_connected_components(graph) assert sorted(result) == sorted([[0, 1], [2], [3, 4]]) def test_fully_connected_graph(): graph = { 0: [1, 2, 3], 1: [0, 2, 3], 2: [0, 1, 3], 3: [0, 1, 2] } result = find_connected_components(graph) assert result == [[0, 1, 2, 3]] or result == [[1, 0, 2, 3]] or result == [[2, 0, 1, 3]] or result == [[3, 0, 1, 2]] def test_empty_graph(): graph = {} result = find_connected_components(graph) assert result == [] print(find_connected_components(graph)) # Expected Output: # [[0, 1, 2], [3, 4], [5]]","solution":"def find_connected_components(graph): Finds all connected components in an undirected graph. :param graph: A dictionary where the keys are vertex identifiers and the values are lists of adjacent vertices. :return: A list of lists, where each inner list represents a connected component containing vertex identifiers. def dfs(node, visited, component): visited.add(node) component.append(node) for neighbor in graph[node]: if neighbor not in visited: dfs(neighbor, visited, component) visited = set() components = [] for vertex in graph: if vertex not in visited: component = [] dfs(vertex, visited, component) components.append(component) return components"},{"question":"from typing import List, Callable def custom_sort(arr: List[int], compare: Callable[[int, int], bool]) -> List[int]: Sort a list of integers based on a custom comparison function. Args: arr: A list of integers that need to be sorted. compare: A comparison function that takes two integers and returns True if the first integer should come before the second and False otherwise. Returns: A list of integers sorted based on the custom comparison. Example: >>> def compare_desc(a, b): ... return a > b >>> custom_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], compare_desc) [9, 6, 5, 5, 5, 4, 3, 3, 2, 1, 1] >>> def compare_asc(a, b): ... return a < b >>> custom_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], compare_asc) [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] >>> def compare_even_first(a, b): ... if a % 2 == 0 and b % 2 != 0: ... return True ... if a % 2 != 0 and b % 2 == 0: ... return False ... return a < b >>> custom_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], compare_even_first) [2, 4, 6, 1, 1, 3, 3, 5, 5, 5, 9]","solution":"from typing import List, Callable from functools import cmp_to_key def custom_sort(arr: List[int], compare: Callable[[int, int], bool]) -> List[int]: def custom_compare(a, b): # Comparator function that converts boolean compare into -1, 0, 1 for sorting if compare(a, b): return -1 elif compare(b, a): return 1 else: return 0 sorted_arr = sorted(arr, key=cmp_to_key(custom_compare)) return sorted_arr"},{"question":"def matrix_multiplication(matrix_a, matrix_b): Performs matrix multiplication on two given matrices. Args: matrix_a: list of lists of floats - The first matrix, where each sublist is a row of the matrix. matrix_b: list of lists of floats - The second matrix, where each sublist is a row of the matrix. Returns: A list of lists of floats representing the resulting matrix after multiplying matrix_a by matrix_b. >>> matrix_a = [ ... [1, 2], ... [3, 4] ... ] >>> matrix_b = [ ... [5, 6], ... [7, 8] ... ] >>> matrix_multiplication(matrix_a, matrix_b) [[19.0, 22.0], [43.0, 50.0]] >>> matrix_a = [ ... [2.5, 0.5], ... [1.0, 1.5] ... ] >>> matrix_b = [ ... [3.0, 1.0], ... [4.0, 2.0] ... ] >>> matrix_multiplication(matrix_a, matrix_b) [[9.5, 3.5], [9.0, 4.0]]","solution":"def matrix_multiplication(matrix_a, matrix_b): Returns the result of matrix multiplication of matrix_a and matrix_b. Args: matrix_a: list of lists of floats - The first matrix, where each sublist is a row of the matrix. matrix_b: list of lists of floats - The second matrix, where each sublist is a row of the matrix. Returns: A list of lists of floats representing the resulting matrix after multiplying matrix_a by matrix_b. # Number of rows of matrix_a rows_a = len(matrix_a) # Number of columns of matrix_a cols_a = len(matrix_a[0]) # Number of rows of matrix_b rows_b = len(matrix_b) # Number of columns of matrix_b cols_b = len(matrix_b[0]) # Initialize the result matrix with zeros result = [[0.0 for _ in range(cols_b)] for _ in range(rows_a)] for i in range(rows_a): for j in range(cols_b): sum_product = 0.0 for k in range(cols_a): sum_product += matrix_a[i][k] * matrix_b[k][j] result[i][j] = sum_product return result"},{"question":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: Push element val onto the stack. def pop(self) -> None: Removes the element on the top of the stack. def top(self) -> int: Get the top element. def get_min(self) -> int: Retrieve the minimum element in the stack. def validate_min_stack_operations(operations: list[str], values: list[list[int]]) -> list[int]: Validates a sequence of operations on a MinStack and returns the results of top and get_min operations. >>> validate_min_stack_operations([\\"MinStack\\", \\"push\\", \\"push\\", \\"get_min\\", \\"top\\"], [[], [1], [2], [], []]) [1, 2] >>> validate_min_stack_operations([\\"MinStack\\", \\"push\\", \\"push\\", \\"push\\", \\"get_min\\", \\"pop\\", \\"get_min\\"], [[], [1], [-1], [2], [], [], []]) [-1, 1] results = [] min_stack = None for operation, value in zip(operations, values): if operation == \\"MinStack\\": min_stack = MinStack() elif operation == \\"push\\": min_stack.push(value[0]) elif operation == \\"pop\\": min_stack.pop() elif operation == \\"top\\": results.append(min_stack.top()) elif operation == \\"get_min\\": results.append(min_stack.get_min()) return results","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() self.stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] return None # Assuming None for top on an empty stack for this example def get_min(self) -> int: if self.min_stack: return self.min_stack[-1] return None # Assuming None for get_min on an empty stack for this example def validate_min_stack_operations(operations: list[str], values: list[list[int]]) -> list[int]: results = [] min_stack = None for operation, value in zip(operations, values): if operation == \\"MinStack\\": min_stack = MinStack() elif operation == \\"push\\": min_stack.push(value[0]) elif operation == \\"pop\\": min_stack.pop() elif operation == \\"top\\": results.append(min_stack.top()) elif operation == \\"get_min\\": results.append(min_stack.get_min()) return results"},{"question":"def calculate_trapped_rainwater(heights: list[int]) -> int: This function calculates the total amount of rainwater that can be trapped between buildings. Parameters: heights (list[int]): The list of heights of the buildings. Returns: int: The total amount of trapped rainwater. # Your implementation here def test_calculate_trapped_rainwater(): assert calculate_trapped_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 assert calculate_trapped_rainwater([4, 2, 0, 3, 2, 5]) == 9 assert calculate_trapped_rainwater([1, 1, 1, 1]) == 0 assert calculate_trapped_rainwater([1, 0, 1]) == 1 assert calculate_trapped_rainwater([2, 0, 2]) == 2 assert calculate_trapped_rainwater([]) == 0 assert calculate_trapped_rainwater([0]) == 0 assert calculate_trapped_rainwater([0, 0, 0, 0]) == 0 assert calculate_trapped_rainwater([5, 4, 1, 2]) == 1","solution":"def calculate_trapped_rainwater(heights): This function calculates the total amount of rainwater that can be trapped between buildings. Parameters: heights (list[int]): The list of heights of the buildings. Returns: int: The total amount of trapped rainwater. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Calculate left max for each position left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Calculate right max for each position right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the total amount of trapped rainwater total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water"},{"question":"def schedule_events(events, dependencies): Compute and return a valid schedule order of events, adhering to their dependencies. :param events: list, a list of strings representing the events :param dependencies: list, a list of tuples representing the dependencies between events :return: list, a list of events in a valid schedule order from collections import defaultdict, deque def test_schedule_no_dependencies(): events = [\\"A\\", \\"B\\", \\"C\\"] dependencies = [] result = schedule_events(events, dependencies) assert set(result) == set(events) def test_schedule_linear_dependencies(): events = [\\"A\\", \\"B\\", \\"C\\"] dependencies = [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\")] result = schedule_events(events, dependencies) assert result == [\\"A\\", \\"B\\", \\"C\\"] def test_schedule_multiple_dependencies(): events = [\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\", \\"F\\"] dependencies = [(\\"A\\", \\"B\\"), (\\"A\\", \\"C\\"), (\\"B\\", \\"D\\"), (\\"C\\", \\"E\\"), (\\"D\\", \\"F\\"), (\\"E\\", \\"F\\")] result = schedule_events(events, dependencies) assert result in [[\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\", \\"F\\"], [\\"A\\", \\"C\\", \\"B\\", \\"E\\", \\"D\\", \\"F\\"]] def test_schedule_with_independent_events(): events = [\\"A\\", \\"B\\", \\"C\\", \\"D\\"] dependencies = [(\\"A\\", \\"B\\"), (\\"C\\", \\"D\\")] result = schedule_events(events, dependencies) assert result in [[\\"A\\", \\"C\\", \\"B\\", \\"D\\"], [\\"C\\", \\"A\\", \\"D\\", \\"B\\"]] def test_schedule_no_valid_schedule(): events = [\\"A\\", \\"B\\", \\"C\\"] dependencies = [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"A\\")] # circular dependency result = schedule_events(events, dependencies) assert result == [] def test_schedule_isolated_nodes(): events = [\\"A\\", \\"B\\", \\"C\\", \\"D\\"] dependencies = [(\\"A\\", \\"B\\")] result = schedule_events(events, dependencies) assert result[0] == \\"A\\" and result.index(\\"B\\") > result.index(\\"A\\") assert set(result) == set(events)","solution":"from collections import defaultdict, deque def schedule_events(events, dependencies): Compute and return a valid schedule order of events, adhering to their dependencies. :param events: list, a list of strings representing the events :param dependencies: list, a list of tuples representing the dependencies between events :return: list, a list of events in a valid schedule order # Create an adjacency list and in-degree list adj_list = defaultdict(list) in_degree = {event: 0 for event in events} # Fill the adjacency list and in-degrees for pre, post in dependencies: adj_list[pre].append(post) in_degree[post] += 1 # Initialize a queue and add all events with an in-degree of 0 queue = deque([event for event in events if in_degree[event] == 0]) # List to store the result order of events schedule_order = [] # Process the queue while queue: current_event = queue.popleft() schedule_order.append(current_event) # Decrease the in-degree of neighboring nodes for neighbor in adj_list[current_event]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Check if we have scheduled all events if len(schedule_order) == len(events): return schedule_order else: return []"},{"question":"def sum_of_unique_digits(number: int) -> int: Determines the sum of all unique digits in a given integer. :param number: A non-negative integer. :return: An integer that is the sum of all unique digits in the given number. >>> sum_of_unique_digits(12345) 15 >>> sum_of_unique_digits(11111) 1 >>> sum_of_unique_digits(91234934) 19 >>> sum_of_unique_digits(0) 0","solution":"def sum_of_unique_digits(number: int) -> int: Returns the sum of all unique digits in the given number. :param number: A non-negative integer. :return: An integer that is the sum of all unique digits in the given number. unique_digits = set(str(number)) return sum(int(digit) for digit in unique_digits)"},{"question":"from typing import List, Tuple def graham_scan(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Compute the convex hull of a set of 2D points using the Graham scan method. Args: points: A list of tuples where each tuple represents a point on a 2D plane in the form (x, y). Returns: A list of tuples representing the vertices of the convex hull in counterclockwise order. Example: >>> graham_scan([(0,0), (1,1), (2,2), (2,0), (1,2)]) [(0, 0), (2, 0), (2, 2), (1, 2)] def test_graham_scan_general_case(): points = [(0,0), (1,1), (2,2), (2,0), (1,2)] assert graham_scan(points) == [(0, 0), (2, 0), (2, 2), (1, 2)] def test_graham_scan_multiple_collinear_points(): points = [(0,0), (1,1), (2,2), (3,3), (4,4), (2,0)] assert graham_scan(points) == [(0, 0), (2, 0), (4, 4)] def test_graham_scan_minimal_points(): points = [(0,0), (2,2), (2,0)] assert graham_scan(points) == [(0, 0), (2, 0), (2, 2)] def test_graham_scan_square_shape(): points = [(0,0), (0,1), (1,1), (1,0)] assert graham_scan(points) == [(0, 0), (1, 0), (1, 1), (0, 1)] def test_graham_scan_with_duplicates(): points = [(0,0), (1,1), (2,2), (2,0), (1,2), (2,0), (1,2)] assert graham_scan(points) == [(0, 0), (2, 0), (2, 2), (1, 2)]","solution":"from typing import List, Tuple def graham_scan(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: # Step 1: Find the point with the lowest y-coordinate (pivot point) pivot = min(points, key=lambda p: (p[1], p[0])) # Step 2: Sort points based on the polar angle with pivot def polar_angle(p): import math y_span, x_span = p[1] - pivot[1], p[0] - pivot[0] return math.atan2(y_span, x_span) sorted_points = sorted(points, key=lambda p: (polar_angle(p), (pivot[0] - p[0]) ** 2 + (pivot[1] - p[1]) ** 2)) # Step 3: Handle collinear points by keeping the farthest one if there are duplicate angles filtered_points = [sorted_points[0]] for p in sorted_points[1:]: while len(filtered_points) > 1 and polar_angle(filtered_points[-1]) == polar_angle(p) and (pivot[0] - filtered_points[-1][0]) ** 2 + (pivot[1] - filtered_points[-1][1]) ** 2 < (pivot[0] - p[0]) ** 2 + (pivot[1] - p[1]) ** 2: filtered_points.pop() filtered_points.append(p) # Step 4: Process points to construct convex hull hull = [] for p in filtered_points: while len(hull) > 1 and cross_product(hull[-2], hull[-1], p) <= 0: hull.pop() hull.append(p) return hull def cross_product(o, a, b): return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])"},{"question":"from typing import List, Dict def search_notes(notes: List[Dict[str, str]], keyword: str) -> List[Dict[str, str]]: Search through notes for a given keyword. Args: notes (List[Dict[str, str]]): List of notes where each note is a dictionary with 'title' and 'content' as keys. keyword (str): The keyword to search for within the notes. Returns: List[Dict[str, str]]: List of dictionaries that contain the keyword in either the title or content. def test_search_notes_case_insensitive(): notes = [ {'title': 'Meeting Notes', 'content': 'Discuss quarterly fiscal report'}, {'title': 'Shopping List', 'content': 'Milk, Bread, Eggs, Butter'}, {'title': 'Trip Plan', 'content': 'Visit museum, art gallery, and historical sites'} ] result = search_notes(notes, 'list') assert result == [{'title': 'Shopping List', 'content': 'Milk, Bread, Eggs, Butter'}] def test_search_notes_keyword_in_title(): notes = [ {'title': 'Meeting Notes', 'content': 'Discuss quarterly fiscal report'}, {'title': 'Shopping List', 'content': 'Milk, Bread, Eggs, Butter'}, {'title': 'Trip Plan', 'content': 'Visit museum, art gallery, and historical sites'} ] result = search_notes(notes, 'Trip Plan') assert result == [{'title': 'Trip Plan', 'content': 'Visit museum, art gallery, and historical sites'}] def test_search_notes_keyword_in_content(): notes = [ {'title': 'Meeting Notes', 'content': 'Discuss quarterly fiscal report'}, {'title': 'Shopping List', 'content': 'Milk, Bread, Eggs, Butter'}, {'title': 'Trip Plan', 'content': 'Visit museum, art gallery, and historical sites'} ] result = search_notes(notes, 'museum') assert result == [{'title': 'Trip Plan', 'content': 'Visit museum, art gallery, and historical sites'}] def test_search_notes_no_match(): notes = [ {'title': 'Meeting Notes', 'content': 'Discuss quarterly fiscal report'}, {'title': 'Shopping List', 'content': 'Milk, Bread, Eggs, Butter'}, {'title': 'Trip Plan', 'content': 'Visit museum, art gallery, and historical sites'} ] result = search_notes(notes, 'sports') assert result == [] def test_search_notes_multiple_matches(): notes = [ {'title': 'Meeting List', 'content': 'Discuss quarterly fiscal report'}, {'title': 'Shopping List', 'content': 'Milk, Bread, Eggs, Butter'}, {'title': 'Packing List', 'content': 'Get the backpack ready with all essentials'} ] result = search_notes(notes, 'List') assert result == [ {'title': 'Meeting List', 'content': 'Discuss quarterly fiscal report'}, {'title': 'Shopping List', 'content': 'Milk, Bread, Eggs, Butter'}, {'title': 'Packing List', 'content': 'Get the backpack ready with all essentials'} ]","solution":"from typing import List, Dict def search_notes(notes: List[Dict[str, str]], keyword: str) -> List[Dict[str, str]]: Search through notes for a given keyword. Args: notes (List[Dict[str, str]]): List of notes where each note is a dictionary with 'title' and 'content' as keys. keyword (str): The keyword to search for within the notes. Returns: List[Dict[str, str]]: List of dictionaries that contain the keyword in either the title or content. keyword_lower = keyword.lower() matching_notes = [] for note in notes: title_lower = note['title'].lower() content_lower = note['content'].lower() if keyword_lower in title_lower or keyword_lower in content_lower: matching_notes.append(note) return matching_notes"},{"question":"from typing import List def evaluate_rpn(expression: List[str]) -> int: Evaluate an expression written in Lukasiewicz's Polish notation (Reverse Polish Notation, RPN). >>> evaluate_rpn([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]) == 9 >>> evaluate_rpn([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"]) == 6 >>> evaluate_rpn([\\"10\\", \\"6\\", \\"9\\", \\"3\\", \\"+\\", \\"-11\\", \\"*\\", \\"/\\", \\"*\\", \\"17\\", \\"+\\", \\"5\\", \\"+\\"]) == 22","solution":"from typing import List def evaluate_rpn(expression: List[str]) -> int: stack = [] for token in expression: if token in \\"+-*/\\": op2 = stack.pop() op1 = stack.pop() if token == '+': stack.append(op1 + op2) elif token == '-': stack.append(op1 - op2) elif token == '*': stack.append(op1 * op2) elif token == '/': # Perform integer division that truncates toward zero stack.append(int(op1 / op2)) else: stack.append(int(token)) return stack[0]"},{"question":"def find_words(grid: List[List[str]], words: List[str]) -> List[str]: def build_trie(words: List[str]): trie = {} for word in words: node = trie for char in word: if char not in node: node[char] = {} node = node[char] node['#'] = word return trie def dfs(row: int, col: int, node, visited: Set): if (row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]) or (row, col) in visited or grid[row][col] not in node): return char = grid[row][col] next_node = node[char] visited.add((row, col)) if '#' in next_node: found_words.add(next_node['#']) del next_node['#'] for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(row + dx, col + dy, next_node, visited) visited.remove((row, col)) # Build a trie from the list of words trie = build_trie(words) # Set of words found in the grid found_words = set() # Iterate through each starting point in the grid, perform DFS for row in range(len(grid)): for col in range(len(grid[0])): dfs(row, col, trie, set()) # Return the found words preserving the order from the input list return [word for word in words if word in found_words]","solution":"from typing import List, Set def find_words(grid: List[List[str]], words: List[str]) -> List[str]: def build_trie(words: List[str]): trie = {} for word in words: node = trie for char in word: if char not in node: node[char] = {} node = node[char] node['#'] = word return trie def dfs(row: int, col: int, node, visited: Set): if (row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]) or (row, col) in visited or grid[row][col] not in node): return char = grid[row][col] next_node = node[char] visited.add((row, col)) if '#' in next_node: found_words.add(next_node['#']) del next_node['#'] for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(row + dx, col + dy, next_node, visited) visited.remove((row, col)) # Build a trie from the list of words trie = build_trie(words) # Set of words found in the grid found_words = set() # Iterate through each starting point in the grid, perform DFS for row in range(len(grid)): for col in range(len(grid[0])): dfs(row, col, trie, set()) # Return the found words preserving the order from the input list return [word for word in words if word in found_words]"},{"question":"def odd_even_sort(arr: list) -> list: Sorts an array of integers using the Odd-Even Sort algorithm. This algorithm repeatedly performs two types of passes: 1. Odd Pass: Compare and swap elements at odd indices. 2. Even Pass: Compare and swap elements at even indices. It continues performing these passes until the array is sorted. Args: arr (list): A list of integers to be sorted. Returns: list: A sorted list of integers in ascending order. Examples: >>> odd_even_sort([34, 2, 78, 1, 45, 99]) [1, 2, 34, 45, 78, 99] >>> odd_even_sort([10, -2, 0, 3, 20]) [-2, 0, 3, 10, 20]","solution":"def odd_even_sort(arr): Sorts an array of integers using the Odd-Even Sort algorithm. n = len(arr) is_sorted = False while not is_sorted: is_sorted = True for i in range(1, n-1, 2): # Perform the odd pass if arr[i] > arr[i+1]: arr[i], arr[i+1] = arr[i+1], arr[i] is_sorted = False for i in range(0, n-1, 2): # Perform the even pass if arr[i] > arr[i+1]: arr[i], arr[i+1] = arr[i+1], arr[i] is_sorted = False return arr"},{"question":"from typing import List def prims_algorithm(adjacency_matrix: List[List[int]]) -> int: Finds the weight of the Minimum Spanning Tree (MST) of an undirected graph using Prim's Algorithm. :param adjacency_matrix: A 2D list where adjacency_matrix[i][j] represents the weight of the edge between node i and node j. A value of 0 indicates no direct edge between nodes i and j. :return: The total weight of the edges in the Minimum Spanning Tree. >>> adjacency_matrix = [ ... [0, 2, 0, 6, 0], ... [2, 0, 3, 8, 5], ... [0, 3, 0, 0, 7], ... [6, 8, 0, 0, 9], ... [0, 5, 7, 9, 0] ... ] >>> prims_algorithm(adjacency_matrix) 16 >>> adjacency_matrix = [ ... [0, 1], ... [1, 0] ... ] >>> prims_algorithm(adjacency_matrix) 1 >>> adjacency_matrix = [ ... [0, 2, 0], ... [2, 0, 0], ... [0, 0, 0] ... ] >>> try: ... prims_algorithm(adjacency_matrix) ... except ValueError as e: ... str(e) == \\"The graph is not connected.\\" True >>> adjacency_matrix = [ ... [0, 1], ... [1, 0, 2] ... ] >>> try: ... prims_algorithm(adjacency_matrix) ... except ValueError as e: ... str(e) == \\"Adjacency matrix must be square.\\" True >>> adjacency_matrix = [ ... [0, 1, 0, 0, 2], ... [1, 0, 4, 3, 0], ... [0, 4, 0, 5, 6], ... [0, 3, 5, 0, 7], ... [2, 0, 6, 7, 0] ... ] >>> prims_algorithm(adjacency_matrix) 10","solution":"from typing import List def prims_algorithm(adjacency_matrix: List[List[int]]) -> int: import heapq n = len(adjacency_matrix) if any(len(row) != n for row in adjacency_matrix): raise ValueError(\\"Adjacency matrix must be square.\\") visited = [False] * n min_heap = [(0, 0)] # (cost, vertex) total_weight = 0 while min_heap: weight, u = heapq.heappop(min_heap) if visited[u]: continue visited[u] = True total_weight += weight for v, cost in enumerate(adjacency_matrix[u]): if cost != 0 and not visited[v]: heapq.heappush(min_heap, (cost, v)) if not all(visited): raise ValueError(\\"The graph is not connected.\\") return total_weight"},{"question":"def find_max_length(nums: list[int]) -> int: Given a list of integers \`nums\`, return the maximum length of a contiguous subarray with an equal number of 1s and 0s. >>> find_max_length([0, 1, 0]) 2 >>> find_max_length([0, 1, 0, 1]) 4 >>> find_max_length([0, 1, 1, 0, 1, 0, 1]) 6 >>> find_max_length([1, 1, 1, 1]) 0","solution":"def find_max_length(nums): Returns the maximum length of a contiguous subarray with an equal number of 1s and 0s. # Dictionary to store the first occurrence of each count count_dict = {0: -1} max_length = 0 count = 0 for i, num in enumerate(nums): # Increment count for 1, decrement for 0 count += 1 if num == 1 else -1 if count in count_dict: max_length = max(max_length, i - count_dict[count]) else: count_dict[count] = i return max_length"},{"question":"from typing import List def max_subarray_sum_with_limit(arr: List[int], limit: int) -> int: Find the maximum subarray sum such that the sum does not exceed the given limit. >>> max_subarray_sum_with_limit([1, 2, 5, -1, 7], 8) 8 >>> max_subarray_sum_with_limit([-2, 3, -1, 5], 4) 4 >>> max_subarray_sum_with_limit([5, 6, 7, 8], 4) 0 >>> max_subarray_sum_with_limit([3], 3) 3 >>> max_subarray_sum_with_limit([5], 4) 0 >>> max_subarray_sum_with_limit([4, -1, 2, 1, 6], 7) 7 >>> max_subarray_sum_with_limit([4, -1, 2, 1, 6], 5) 5 >>> max_subarray_sum_with_limit([-1, -2, -3, -4], 4) 0 pass","solution":"from typing import List def max_subarray_sum_with_limit(arr: List[int], limit: int) -> int: Find the maximum subarray sum such that the sum does not exceed the given limit. max_sum = 0 current_sum = 0 start = 0 for end in range(len(arr)): current_sum += arr[end] while current_sum > limit and start <= end: current_sum -= arr[start] start += 1 if current_sum <= limit: max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def check_leap_years(years: list[int]) -> list[bool]: Determine if the given years are leap years. Parameters: years (list[int]): A list of years to check. Returns: list[bool]: A list of boolean values, where True indicates the corresponding year is a leap year and False otherwise. >>> check_leap_years([2020, 2021, 1900, 2000]) [True, False, False, True] >>> check_leap_years([1600, 1700, 1800, 1900, 2000]) [True, False, False, False, True] >>> check_leap_years([2016, 2017, 2018, 2019, 2024]) [True, False, False, False, True] >>> check_leap_years([1, 4, 104, 400, 9999]) [False, True, True, True, False]","solution":"def check_leap_years(years: list[int]) -> list[bool]: Determine if the given years are leap years. Parameters: years (list[int]): A list of years to check. Returns: list[bool]: A list of boolean values, where True indicates the corresponding year is a leap year and False otherwise. def is_leap_year(year): if year % 4 == 0: if year % 100 == 0: if year % 400 == 0: return True else: return False else: return True else: return False return [is_leap_year(year) for year in years]"},{"question":"def generate_binary_ones_sequence(count: int) -> str: Generates a binary sequence filled with a specific number of '1's. :param count: Number of '1's in the binary sequence. :return: A string representing a binary number composed entirely of '1's. >>> generate_binary_ones_sequence(1) '1' >>> generate_binary_ones_sequence(5) '11111' >>> generate_binary_ones_sequence(16) '1111111111111111' >>> generate_binary_ones_sequence(32) '11111111111111111111111111111111' pass","solution":"def generate_binary_ones_sequence(count: int) -> str: Generates a binary sequence filled with a specific number of '1's. :param count: Number of '1's in the binary sequence. :return: A string representing a binary number composed entirely of '1's. return '1' * count"},{"question":"from typing import List def can_form_consecutive_sequence(lst: List[int]) -> bool: Determines if a given list of integers can be rearranged to form a consecutive sequence. Args: lst (List[int]): A list of integers. Returns: bool: True if the list can be rearranged to form a consecutive sequence, False otherwise. Examples: >>> can_form_consecutive_sequence([1, 2, 3, 4, 5]) True >>> can_form_consecutive_sequence([4, 2, 3, 1, 6]) False >>> can_form_consecutive_sequence([10, 13, 14, 11, 12]) True >>> can_form_consecutive_sequence([7, 7, 7]) False >>> can_form_consecutive_sequence([]) False","solution":"from typing import List def can_form_consecutive_sequence(lst: List[int]) -> bool: if not lst: return False if len(lst) != len(set(lst)): return False return max(lst) - min(lst) + 1 == len(lst)"},{"question":"import numpy as np def rolling_average(prices, window_size): Returns the rolling averages of stock prices over the specified window size. :param prices: List of floats representing daily stock prices. :param window_size: Integer representing the window size. :return: List of floats representing the rolling averages. >>> rolling_average([1, 2, 3, 4, 5], 3) [2.0, 3.0, 4.0] >>> rolling_average([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 4) [25.0, 35.0, 45.0, 55.0, 65.0, 75.0, 85.0] >>> rolling_average([5.5, 6.7, 8.2, 9.0, 7.3, 6.8], 2) [6.1, 7.45, 8.6, 8.15, 7.05]","solution":"import numpy as np def rolling_average(prices, window_size): Returns the rolling averages of stock prices over the specified window size. :param prices: List of floats representing daily stock prices. :param window_size: Integer representing the window size. :return: List of floats representing the rolling averages. if window_size > len(prices): return [] rolling_averages = [] window_sum = sum(prices[:window_size]) rolling_averages.append(round(window_sum / window_size, 2)) for i in range(window_size, len(prices)): window_sum += prices[i] - prices[i - window_size] rolling_averages.append(round(window_sum / window_size, 2)) return rolling_averages"},{"question":"import numpy as np from scipy.ndimage import convolve class CustomConvolution: def __init__(self, image: np.ndarray, filter: np.ndarray) -> None: Initialize the CustomConvolution with an image and a custom filter. Args: image (np.ndarray): The grayscale image to be processed. filter (np.ndarray): The custom convolution filter to apply. self.image = image self.filter = filter def apply_filter(self) -> np.ndarray: Apply the custom convolution filter to the image. Returns: np.ndarray: The filtered image. pass def edge_detection(self) -> np.ndarray: Apply an edge detection filter to the image. Returns: np.ndarray: The edge-detected image. pass def sharpen(self) -> np.ndarray: Apply a sharpening filter to the image. Returns: np.ndarray: The sharpened image. pass def blur(self) -> np.ndarray: Apply a blurring filter to the image. Returns: np.ndarray: The blurred image. pass # Test the implementation def test_apply_custom_filter(): test_image = np.array([ [100, 100, 100, 100, 100], [100, 50, 50, 50, 100], [100, 50, 25, 50, 100], [100, 50, 50, 50, 100], [100, 100, 100, 100, 100], ], dtype=np.float64) custom_filter = np.array([ [0, -1, 0], [-1, 4, -1], [0, -1, 0] ], dtype=np.float64) custom_conv = CustomConvolution(test_image, custom_filter) expected_output = convolve(test_image, custom_filter) assert np.allclose(custom_conv.apply_filter(), expected_output) def test_edge_detection_filter(): test_image = np.array([ [100, 100, 100, 100, 100], [100, 50, 50, 50, 100], [100, 50, 25, 50, 100], [100, 50, 50, 50, 100], [100, 100, 100, 100, 100], ], dtype=np.float64) edge_filter = np.array([ [0, -1, 0], [-1, 4, -1], [0, -1, 0] ], dtype=np.float64) custom_conv = CustomConvolution(test_image, edge_filter) expected_output = convolve(test_image, edge_filter) assert np.allclose(custom_conv.edge_detection(), expected_output) def test_sharpen_filter(): test_image = np.array([ [100, 100, 100, 100, 100], [100, 50, 50, 50, 100], [100, 50, 25, 50, 100], [100, 50, 50, 50, 100], [100, 100, 100, 100, 100], ], dtype=np.float64) sharpen_filter = np.array([ [0, -1, 0], [-1, 5, -1], [0, -1, 0] ], dtype=np.float64) custom_conv = CustomConvolution(test_image, sharpen_filter) expected_output = convolve(test_image, sharpen_filter) assert np.allclose(custom_conv.sharpen(), expected_output) def test_blur_filter(): test_image = np.array([ [100, 100, 100, 100, 100], [100, 50, 50, 50, 100], [100, 50, 25, 50, 100], [100, 50, 50, 50, 100], [100, 100, 100, 100, 100], ], dtype=np.float64) blur_filter = np.array([ [1, 1, 1], [1, 1, 1], [1, 1, 1], ], dtype=np.float64) / 9.0 custom_conv = CustomConvolution(test_image, blur_filter) expected_output = convolve(test_image, blur_filter) assert np.allclose(custom_conv.blur(), expected_output)","solution":"import numpy as np from scipy.ndimage import convolve class CustomConvolution: def __init__(self, image: np.ndarray, filter: np.ndarray) -> None: self.image = image self.filter = filter def apply_filter(self) -> np.ndarray: return convolve(self.image, self.filter) def edge_detection(self) -> np.ndarray: edge_filter = np.array([ [0, -1, 0], [-1, 4, -1], [0, -1, 0] ], dtype=np.float64) return convolve(self.image, edge_filter) def sharpen(self) -> np.ndarray: sharpen_filter = np.array([ [0, -1, 0], [-1, 5, -1], [0, -1, 0] ], dtype=np.float64) return convolve(self.image, sharpen_filter) def blur(self) -> np.ndarray: blur_filter = np.array([ [1, 1, 1], [1, 1, 1], [1, 1, 1], ], dtype=np.float64) / 9.0 return convolve(self.image, blur_filter)"},{"question":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Find the maximum sum of a contiguous subarray using the divide and conquer approach. Args: nums (List[int]): List of integers Returns: int: Maximum sum of the contiguous subarray >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1]) -1 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([2, -1, 2, 3, 4, -5]) 10 >>> max_subarray_sum([1] * 100000) 100000 >>> max_subarray_sum([]) 0","solution":"from typing import List def max_crossing_sum(nums: List[int], low: int, mid: int, high: int) -> int: left_sum = float('-inf') total = 0 for i in range(mid, low - 1, -1): total += nums[i] if total > left_sum: left_sum = total right_sum = float('-inf') total = 0 for i in range(mid + 1, high + 1): total += nums[i] if total > right_sum: right_sum = total return left_sum + right_sum def max_subarray_sum_divide_and_conquer(nums: List[int], low: int, high: int) -> int: if low == high: return nums[low] mid = (low + high) // 2 left_sum = max_subarray_sum_divide_and_conquer(nums, low, mid) right_sum = max_subarray_sum_divide_and_conquer(nums, mid + 1, high) cross_sum = max_crossing_sum(nums, low, mid, high) return max(left_sum, right_sum, cross_sum) def max_subarray_sum(nums: List[int]) -> int: if not nums: return 0 return max_subarray_sum_divide_and_conquer(nums, 0, len(nums) - 1)"},{"question":"def sum_missing_numbers(nums: list, n: int) -> int: Computes the sum of all integers from 1 to n that are missing in the input list nums. >>> sum_missing_numbers([1, 2, 4], 5) 8 >>> sum_missing_numbers([2, 3, 7, 4], 7) 12 >>> sum_missing_numbers([1, 2, 3, 4, 5], 5) 0 >>> sum_missing_numbers([10, 1, 2, 5, 6], 10) 31","solution":"def sum_missing_numbers(nums: list, n: int) -> int: Computes the sum of all integers from 1 to n that are missing in the input list nums. total_sum = n * (n + 1) // 2 actual_sum = sum(set(nums)) return total_sum - actual_sum"},{"question":"def find_majority_element(nums): Returns the majority element in a non-empty list of integers. The majority element is the element that appears more than n / 2 times. Args: nums: A list of integers where a majority element always exists. Returns: The majority element. Examples: >>> find_majority_element([3, 2, 3]) 3 >>> find_majority_element([2, 2, 1, 1, 1, 2, 2]) 2 >>> find_majority_element([1, 2, 1, 1, 3, 1, 1]) 1","solution":"def find_majority_element(nums): Returns the majority element in a non-empty list of integers. The majority element is the element that appears more than n / 2 times. Args: nums: A list of integers where a majority element always exists. Returns: The majority element. # Implementing Moore's Voting Algorithm count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate"},{"question":"def rotate_list(arr: list[int], k: int) -> list[int]: Rotates the elements of the list to the right by k positions. Parameters: arr (list): List of integers to rotate. k (int): Number of positions to rotate the list by. Returns: list: The rotated list. Example: >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_list([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_list([], 3) []","solution":"def rotate_list(arr: list[int], k: int) -> list[int]: Rotates the elements of the list to the right by k positions. Parameters: arr (list): List of integers to rotate. k (int): Number of positions to rotate the list by. Returns: list: The rotated list. if not isinstance(arr, list): raise TypeError(\\"Input must be a list of integers\\") if not isinstance(k, int): raise TypeError(\\"Rotation count must be an integer\\") n = len(arr) if n == 0: return [] k = k % n # handle cases where k is larger than the length of the list rotated_list = arr[-k:] + arr[:-k] return rotated_list"},{"question":"def all_paths_dag(N: int, edges: list[tuple[int, int]], start: int, end: int) -> list[list[int]]: Finds all possible paths from a given start node to a given end node in a Directed Acyclic Graph (DAG). >>> all_paths_dag(4, [(1, 2), (1, 3), (2, 4), (3, 4)], 1, 4) == [[1, 2, 4], [1, 3, 4]] >>> all_paths_dag(4, [(1, 2), (1, 3), (2, 4), (3, 4)], 1, 3) == [[1, 3]]","solution":"def all_paths_dag(N, edges, start, end): from collections import defaultdict # Build the graph as an adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) all_paths = [] def dfs(current, path): if current == end: all_paths.append(path) return for neighbor in graph[current]: dfs(neighbor, path + [neighbor]) dfs(start, [start]) return all_paths"},{"question":"def is_permutation(s1: str, s2: str) -> bool: Determines whether one string is a permutation of the other. >>> is_permutation(\\"abc\\", \\"cab\\") True >>> is_permutation(\\"hello\\", \\"bello\\") False >>> is_permutation(\\"Dormitory\\", \\"dirty room\\") False >>> is_permutation(\\"Listen\\", \\"Silent\\") False","solution":"def is_permutation(s1, s2): Determines whether one string is a permutation of the other. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s1 is a permutation of s2, False otherwise. if len(s1) != len(s2): return False return sorted(s1) == sorted(s2)"},{"question":"class BalancedBST: Implement a Binary Search Tree (BST) with an additional feature to balance the tree. Methods: __init__(self): Initialize an empty BST. insert(self, value: int) -> None: Insert the given integer value into the BST. delete(self, value: int) -> None: Remove the given integer value from the BST. search(self, value: int) -> bool: Search for the given integer value in the BST. balance(self) -> None: Rebalance the BST. print_in_order(self) -> list[int]: Return the elements of the BST in in-order traversal. print_pre_order(self) -> list[int]: Return the elements of the BST in pre-order traversal. print_post_order(self) -> list[int]: Return the elements of the BST in post-order traversal. >>> bst = BalancedBST() >>> bst.insert(10) >>> bst.insert(5) >>> bst.insert(20) >>> bst.insert(3) >>> bst.insert(7) >>> bst.insert(30) >>> bst.search(7) True >>> bst.delete(5) >>> bst.balance() >>> bst.print_in_order() [3, 7, 10, 20, 30] >>> bst.print_pre_order() [10, 3, 7, 20, 30] >>> bst.print_post_order() [3, 7, 30, 20, 10] def __init__(self): pass def insert(self, value: int) -> None: pass def delete(self, value: int) -> None: pass def search(self, value: int) -> bool: pass def balance(self) -> None: pass def print_in_order(self) -> list[int]: pass def print_pre_order(self) -> list[int]: pass def print_post_order(self) -> list[int]: pass def test_balanced_bst_insertion(): bst = BalancedBST() bst.insert(10) bst.insert(5) bst.insert(20) bst.insert(3) bst.insert(7) bst.insert(30) assert bst.print_in_order() == [3, 5, 7, 10, 20, 30] def test_balanced_bst_deletion(): bst = BalancedBST() bst.insert(10) bst.insert(5) bst.insert(20) bst.insert(3) bst.insert(7) bst.insert(30) bst.delete(5) assert bst.print_in_order() == [3, 7, 10, 20, 30] def test_balanced_bst_search(): bst = BalancedBST() bst.insert(10) bst.insert(5) bst.insert(20) bst.insert(3) bst.insert(7) bst.insert(30) assert bst.search(7) == True assert bst.search(100) == False def test_balanced_bst_balance(): bst = BalancedBST() elements = [10, 5, 20, 3, 7, 30, 15] for el in elements: bst.insert(el) bst.balance() in_order = bst.print_in_order() pre_order = bst.print_pre_order() post_order = bst.print_post_order() assert in_order == [3, 5, 7, 10, 15, 20, 30] assert pre_order == [10, 5, 3, 7, 20, 15, 30] assert post_order == [3, 7, 5, 15, 30, 20, 10] def test_balanced_bst_empty(): bst = BalancedBST() assert bst.print_in_order() == [] assert bst.print_pre_order() == [] assert bst.print_post_order() == [] assert bst.search(10) == False","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BalancedBST: def __init__(self): self.root = None def insert(self, value): self.root = self._insert(self.root, value) def _insert(self, node, value): if node is None: return TreeNode(value) elif value < node.value: node.left = self._insert(node.left, value) else: node.right = self._insert(node.right, value) return node def delete(self, value): self.root = self._delete(self.root, value) def _delete(self, node, value): if node is None: return node if value < node.value: node.left = self._delete(node.left, value) elif value > node.value: node.right = self._delete(node.right, value) else: if node.left is None: return node.right elif node.right is None: return node.left min_larger_node = self._get_min(node.right) node.value = min_larger_node.value node.right = self._delete(node.right, min_larger_node.value) return node def search(self, value): return self._search(self.root, value) is not None def _search(self, node, value): if node is None or node.value == value: return node if value < node.value: return self._search(node.left, value) return self._search(node.right, value) def balance(self): values = self.print_in_order() self.root = self._build_balanced_tree(values) def _build_balanced_tree(self, values): if not values: return None mid = len(values) // 2 node = TreeNode(values[mid]) node.left = self._build_balanced_tree(values[:mid]) node.right = self._build_balanced_tree(values[mid+1:]) return node def print_in_order(self): res = [] self._in_order(self.root, res) return res def _in_order(self, node, res): if node: self._in_order(node.left, res) res.append(node.value) self._in_order(node.right, res) def print_pre_order(self): res = [] self._pre_order(self.root, res) return res def _pre_order(self, node, res): if node: res.append(node.value) self._pre_order(node.left, res) self._pre_order(node.right, res) def print_post_order(self): res = [] self._post_order(self.root, res) return res def _post_order(self, node, res): if node: self._post_order(node.left, res) self._post_order(node.right, res) res.append(node.value) def _get_min(self, node): while node.left: node = node.left return node"},{"question":"# Dictionary to simulate in-memory storage of user accounts user_database = {} def is_valid_username(username: str) -> bool: Validates if the given username meets the criteria: - Between 3 to 20 characters long - Only contains alphanumeric characters Args: username (str): The username to validate. Returns: bool: True if valid, False otherwise. # Your code goes here pass def is_valid_password(password: str) -> bool: Validates if the given password meets the criteria: - At least 8 characters long - Contains at least one uppercase letter - Contains at least one lowercase letter - Contains at least one digit Args: password (str): The password to validate. Returns: bool: True if valid, False otherwise. # Your code goes here pass def register_user(username: str, password: str) -> int: Registers a new user with the given username and password. Args: username (str): The username for the new account. password (str): The password for the new account. Returns: int: Status code indicating the result of the registration attempt. 0 - Successful registration 1 - Username already taken 2 - Invalid username 3 - Invalid password # Your code goes here pass def test_register_user(): Unit tests for the register_user function. >>> register_user(\\"JohnDoe\\", \\"Password1\\") 0 >>> register_user(\\"JohnDoe\\", \\"AnotherPassword1\\") 1 >>> register_user(\\"John\\", \\"pass\\") 3 >>> register_user(\\"John*Doe\\", \\"Password1\\") 2 pass","solution":"# Dictionary to simulate in-memory storage of user accounts user_database = {} def is_valid_username(username: str) -> bool: if 3 <= len(username) <= 20 and username.isalnum(): return True return False def is_valid_password(password: str) -> bool: if len(password) < 8: return False if not any(char.islower() for char in password): return False if not any(char.isupper() for char in password): return False if not any(char.isdigit() for char in password): return False return True def register_user(username: str, password: str) -> int: Registers a new user with the given username and password. Returns: int: status code 0 - Successful registration 1 - Username already taken 2 - Invalid username 3 - Invalid password global user_database if username in user_database: return 1 if not is_valid_username(username): return 2 if not is_valid_password(password): return 3 user_database[username] = password return 0"},{"question":"class CircularDeque: Implement a data structure, \`CircularDeque\`, which supports operations on a double-ended queue with a fixed maximum size in a circular manner. >>> circularDeque = CircularDeque(3) # set the size to be 3 >>> circularDeque.insertLast(1) # return true >>> circularDeque.insertLast(2) # return true >>> circularDeque.insertFront(3) # return true >>> circularDeque.insertFront(4) # return false, the queue is full >>> circularDeque.getRear() # return 2 >>> circularDeque.isFull() # return true >>> circularDeque.deleteLast() # return true >>> circularDeque.insertFront(4) # return true >>> circularDeque.getFront() # return 4 def __init__(self, k: int): pass def insertFront(self, value: int) -> bool: pass def insertLast(self, value: int) -> bool: pass def deleteFront(self) -> bool: pass def deleteLast(self) -> bool: pass def getFront(self) -> int: pass def getRear(self) -> int: pass def isEmpty(self) -> bool: pass def isFull(self) -> bool: pass def test_initial_state(): deque = CircularDeque(3) assert deque.isEmpty() == True assert deque.isFull() == False assert deque.getFront() == -1 assert deque.getRear() == -1 def test_insertLast(): deque = CircularDeque(3) assert deque.insertLast(1) == True assert deque.insertLast(2) == True assert deque.insertLast(3) == True assert deque.insertLast(4) == False # should be full now assert deque.isFull() == True def test_insertFront(): deque = CircularDeque(3) assert deque.insertFront(1) == True assert deque.insertFront(2) == True assert deque.insertFront(3) == True assert deque.insertFront(4) == False # should be full now assert deque.isFull() == True def test_deleteFront(): deque = CircularDeque(3) deque.insertLast(1) deque.insertLast(2) assert deque.deleteFront() == True assert deque.deleteFront() == True assert deque.deleteFront() == False # should be empty now assert deque.isEmpty() == True def test_deleteLast(): deque = CircularDeque(3) deque.insertLast(1) deque.insertLast(2) assert deque.deleteLast() == True assert deque.deleteLast() == True assert deque.deleteLast() == False # should be empty now assert deque.isEmpty() == True def test_getFront(): deque = CircularDeque(3) deque.insertLast(1) deque.insertLast(2) assert deque.getFront() == 1 deque.deleteFront() assert deque.getFront() == 2 def test_getRear(): deque = CircularDeque(3) deque.insertLast(1) deque.insertLast(2) assert deque.getRear() == 2 deque.deleteLast() assert deque.getRear() == 1","solution":"class CircularDeque: def __init__(self, k: int): self.size = k self.deque = [0] * k self.front = -1 self.rear = -1 self.count = 0 def insertFront(self, value: int) -> bool: if self.isFull(): return False if self.isEmpty(): self.front = self.rear = 0 else: self.front = (self.front - 1) % self.size self.deque[self.front] = value self.count += 1 return True def insertLast(self, value: int) -> bool: if self.isFull(): return False if self.isEmpty(): self.front = self.rear = 0 else: self.rear = (self.rear + 1) % self.size self.deque[self.rear] = value self.count += 1 return True def deleteFront(self) -> bool: if self.isEmpty(): return False if self.front == self.rear: self.front = self.rear = -1 else: self.front = (self.front + 1) % self.size self.count -= 1 return True def deleteLast(self) -> bool: if self.isEmpty(): return False if self.front == self.rear: self.front = self.rear = -1 else: self.rear = (self.rear - 1) % self.size self.count -= 1 return True def getFront(self) -> int: if self.isEmpty(): return -1 return self.deque[self.front] def getRear(self) -> int: if self.isEmpty(): return -1 return self.deque[self.rear] def isEmpty(self) -> bool: return self.count == 0 def isFull(self) -> bool: return self.count == self.size"},{"question":"from datetime import datetime, timedelta def longest_commit_streak(timestamps: list[str]) -> int: Determine the length of the longest streak of consecutive days with commits for a given list of timestamps. Args: timestamps (list[str]): A non-empty list of strings where each string is a timestamp in the format 'YYYY-MM-DD'. Returns: int: The length of the longest streak of consecutive days with commits. Examples: >>> longest_commit_streak([\\"2023-01-01\\", \\"2023-01-02\\", \\"2023-01-04\\", \\"2023-01-05\\", \\"2023-01-06\\"]) 3 >>> longest_commit_streak([\\"2023-03-01\\", \\"2023-03-02\\", \\"2023-03-05\\", \\"2023-03-07\\"]) 2 pass","solution":"from datetime import datetime, timedelta def longest_commit_streak(timestamps: list[str]) -> int: # Convert the string timestamps to datetime objects for easier manipulation. dates = [datetime.strptime(date, '%Y-%m-%d') for date in timestamps] # Initialize variables for tracking the longest streak. max_streak = 1 current_streak = 1 # Traverse through the list of dates. for i in range(1, len(dates)): # Check if the current date is exactly one day after the previous date. if dates[i] - dates[i - 1] == timedelta(days=1): current_streak += 1 else: # Update the maximum streak and reset the current streak. max_streak = max(max_streak, current_streak) current_streak = 1 # Ensure the last streak is considered. max_streak = max(max_streak, current_streak) return max_streak"},{"question":"def top_sales_reps( sales_data: dict[str, list[float]], n: int ) -> list[tuple[str, float]]: Compute the top \`n\` sales representatives based on their total sales across all quarters. Args: sales_data (dict): A dictionary where keys are sales representative names (strings) and values are lists of sales figures (floats) for various quarters. n (int): The number of top performers to return. Must be positive. Returns: list: A list of tuples, each containing the name of the sales representative and their total sales, limited to the top \`n\` performers, sorted in descending order of total sales. Raises: ValueError: If \`n\` is non-positive or if any sales figure is negative. Example: >>> top_sales_reps( ... sales_data={ ... \\"Alice\\": [1200.50, 3000.75, 2500.00], ... \\"Bob\\": [800.00, 1500.25, 900.50], ... \\"Carol\\": [3000.00, 4500.75, 5200.25] ... }, ... n=2 ... ) [('Carol', 12701.0), ('Alice', 6701.25)] pass import pytest def test_top_sales_reps_basic(): sales_data = { \\"Alice\\": [1200.50, 3000.75, 2500.00], \\"Bob\\": [800.00, 1500.25, 900.50], \\"Carol\\": [3000.00, 4500.75, 5200.25] } n = 2 result = top_sales_reps(sales_data, n) assert result == [(\\"Carol\\", 12701.0), (\\"Alice\\", 6701.25)] def test_top_sales_reps_not_enough_reps(): sales_data = { \\"Dave\\": [1500.00, 1300.00], \\"Eve\\": [2000.00, 1800.50, 2100.75], \\"Frank\\": [], \\"Grace\\": [300.00, 400.25, 500.00] } n = 3 result = top_sales_reps(sales_data, n) assert result == [(\\"Eve\\", 5901.25), (\\"Dave\\", 2800.0), (\\"Grace\\", 1200.25)] def test_top_sales_reps_negative_sales(): sales_data = { \\"Henry\\": [1000.00, 2000.00], \\"Ivy\\": [1500.00, 2500.00], \\"Jack\\": [2000.00, -1000.00] } n = 2 with pytest.raises(ValueError): top_sales_reps(sales_data, n) def test_top_sales_reps_n_greater_than_reps(): sales_data = { \\"Alice\\": [1200.50, 3000.75, 2500.00], \\"Bob\\": [800.00, 1500.25, 900.50], \\"Carol\\": [3000.00, 4500.75, 5200.25] } n = 5 result = top_sales_reps(sales_data, n) assert result == [(\\"Carol\\", 12701.0), (\\"Alice\\", 6701.25), (\\"Bob\\", 3200.75)] def test_top_sales_reps_zero_n(): sales_data = { \\"Alice\\": [1200.50, 3000.75, 2500.00], \\"Bob\\": [800.00, 1500.25, 900.50], \\"Carol\\": [3000.00, 4500.75, 5200.25] } n = 0 with pytest.raises(ValueError): top_sales_reps(sales_data, n) def test_top_sales_reps_empty_sales(): sales_data = { \\"Alice\\": [], \\"Bob\\": [], \\"Carol\\": [] } n = 2 result = top_sales_reps(sales_data, n) assert result == [(\\"Alice\\", 0), (\\"Bob\\", 0)]","solution":"def top_sales_reps(sales_data: dict[str, list[float]], n: int) -> list[tuple[str, float]]: if n <= 0: raise ValueError(\\"The number of top performers 'n' must be a positive integer.\\") for sales in sales_data.values(): if any(sale < 0 for sale in sales): raise ValueError(\\"Sales figures can not be negative.\\") total_sales = {rep: sum(sales) for rep, sales in sales_data.items()} sorted_sales = sorted(total_sales.items(), key=lambda x: x[1], reverse=True) return sorted_sales[:n]"},{"question":"from typing import Dict, List, Tuple, Optional class NetworkRouter: def __init__(self, graph: Dict[int, List[Tuple[int, int]]]): Initialize the NetworkRouter with the network graph. Args: graph (dict): A dictionary where keys are integers representing routers, and values are lists of tuples. Each tuple contains two integers (neighbor, weight) representing a neighboring router and the latency to that neighbor. pass def shortest_path(self, start: int, goal: int) -> Optional[List[int]]: Find the shortest path from start to goal using Dijkstra's algorithm. Args: start (int): The source router. goal (int): The destination router. Returns: list: A list of integers representing the sequence of routers in the shortest path. If no path exists, return None. Example: >>> graph = { >>> 0: [(1, 2), (2, 4)], >>> 1: [(3, 1)], >>> 2: [(3, 2)], >>> 3: [] >>> } >>> network_router = NetworkRouter(graph) >>> network_router.shortest_path(0, 3) [0, 1, 3] from solution import NetworkRouter def test_shortest_path_basic(): graph = {0: [(1, 2), (2, 4)], 1: [(3, 1)], 2: [(3, 2)], 3: []} network_router = NetworkRouter(graph) assert network_router.shortest_path(0, 3) == [0, 1, 3] def test_shortest_path_no_path(): graph = {0: [(1, 2)], 1: [(3, 1)], 2: [(3, 2)], 3: []} network_router = NetworkRouter(graph) assert network_router.shortest_path(0, 2) == None def test_shortest_path_single_node(): graph = {0: []} network_router = NetworkRouter(graph) assert network_router.shortest_path(0, 0) == [0] def test_shortest_path_direct_path(): graph = {0: [(1, 2)], 1: [], 2: [(3, 2)], 3: []} network_router = NetworkRouter(graph) assert network_router.shortest_path(0, 1) == [0, 1] def test_shortest_path_multiple_paths(): graph = {0: [(1, 2), (2, 1)], 1: [(2, 2), (3, 3)], 2: [(3, 1)], 3: []} network_router = NetworkRouter(graph) assert network_router.shortest_path(0, 3) == [0, 2, 3] def test_shortest_path_complex(): graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [(4, 3)], 4: [] } network_router = NetworkRouter(graph) assert network_router.shortest_path(0, 4) == [0, 2, 1, 3, 4]","solution":"import heapq from typing import Dict, List, Tuple, Optional class NetworkRouter: def __init__(self, graph: Dict[int, List[Tuple[int, int]]]): self.graph = graph def shortest_path(self, start: int, goal: int) -> Optional[List[int]]: distances = {node: float('infinity') for node in self.graph} previous_nodes = {node: None for node in self.graph} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If we found the goal, construct and return the path if current_node == goal: path = [] while previous_nodes[current_node] is not None: path.insert(0, current_node) current_node = previous_nodes[current_node] path.insert(0, start) # add the start node manually return path if current_distance > distances[current_node]: continue for neighbor, weight in self.graph.get(current_node, []): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) return None"},{"question":"import re from collections import defaultdict def word_frequency(text: str) -> dict: Analyzes the frequency of each word in the given paragraph of text. Parameters: text (str): A paragraph of text. Returns: dict: A dictionary where the keys are unique words (in lowercase) and the values are the frequency of those words in the text. >>> word_frequency(\\"Hello, hello! How are you? Are you doing fine? Yes, I am fine.\\") {'hello': 2, 'how': 1, 'are': 2, 'you': 2, 'doing': 1, 'fine': 2, 'yes': 1, 'i': 1, 'am': 1} >>> word_frequency(\\"This is a test. This test is only a test.\\") {'this': 2, 'is': 2, 'a': 2, 'test': 3, 'only': 1}","solution":"import re from collections import defaultdict def word_frequency(text: str) -> dict: Analyzes the frequency of each word in the given paragraph of text. Parameters: text (str): A paragraph of text. Returns: dict: A dictionary where the keys are unique words (in lowercase) and the values are the frequency of those words in the text. # Remove punctuation and convert text to lowercase clean_text = re.sub(r'[^ws]', '', text).lower() # Split the text into words words = clean_text.split() # Use defaultdict to count the frequency of each word frequency = defaultdict(int) for word in words: frequency[word] += 1 return dict(frequency)"},{"question":"def calculate_total_sales(sales: List[Tuple[int, int, int]]) -> Dict[int, int]: Computes the total quantity of each product sold across all stores. Parameters: sales (List[Tuple[int, int, int]]): A list of sales records, where each record is a tuple of three integers: The first integer represents the store ID. The second integer represents the product ID. The third integer represents the quantity of the product sold. Returns: Dict[int, int]: A dictionary where the keys are product IDs and the values are the total quantities sold. pass from typing import List, Tuple, Dict def test_calculate_total_sales_single_product(): sales_records = [ (1, 1001, 5), (2, 1001, 3), (3, 1001, 2), ] assert calculate_total_sales(sales_records) == {1001: 10} def test_calculate_total_sales_multiple_products(): sales_records = [ (1, 1001, 5), (2, 1001, 3), (1, 1002, 7), (3, 1001, 2), (2, 1003, 10), ] assert calculate_total_sales(sales_records) == {1001: 10, 1002: 7, 1003: 10} def test_calculate_total_sales_empty_list(): assert calculate_total_sales([]) == {} def test_calculate_total_sales_one_record(): sales_records = [ (1, 1001, 5), ] assert calculate_total_sales(sales_records) == {1001: 5} def test_calculate_total_sales_large_input(): sales_records = [(i % 1000, i % 50, i) for i in range(10 ** 4)] total_sales = calculate_total_sales(sales_records) assert total_sales[0] == sum(range(0, 10 ** 4, 50)) assert total_sales[49] == sum(range(49, 10 ** 4, 50))","solution":"from typing import List, Tuple, Dict def calculate_total_sales(sales: List[Tuple[int, int, int]]) -> Dict[int, int]: Computes the total quantity of each product sold across all stores. Parameters: sales (List[Tuple[int, int, int]]): A list of sales records, where each record is a tuple of three integers: The first integer represents the store ID. The second integer represents the product ID. The third integer represents the quantity of the product sold. Returns: Dict[int, int]: A dictionary where the keys are product IDs and the values are the total quantities sold. total_sales = {} for store_id, product_id, quantity in sales: if product_id in total_sales: total_sales[product_id] += quantity else: total_sales[product_id] = quantity return total_sales"},{"question":"def recursive_quick_sort(arr: list[int]) -> list[int]: Implement the quick sort algorithm using recursion. Given a list of integers, return the list sorted in ascending order using a recursive quick sort. >>> recursive_quick_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] >>> recursive_quick_sort([]) [] >>> recursive_quick_sort([1]) [1] >>> recursive_quick_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> recursive_quick_sort([4, 2, 2, 4, 3, 3, 1, 1]) [1, 1, 2, 2, 3, 3, 4, 4] >>> recursive_quick_sort([-10, 7, 4, -3, 0, -1, 8, -4]) [-10, -4, -3, -1, 0, 4, 7, 8] pass","solution":"def recursive_quick_sort(arr: list[int]) -> list[int]: if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return recursive_quick_sort(left) + middle + recursive_quick_sort(right)"},{"question":"def max_non_overlapping_intervals(intervals): Returns the maximum number of non-overlapping intervals that can be scheduled. :param intervals: List[Tuple[int, int]] - A list of intervals represented as tuples of (start, end) :return: int - The maximum number of non-overlapping intervals that can be scheduled pass # Unit tests for max_non_overlapping_intervals def test_no_intervals(): assert max_non_overlapping_intervals([]) == 0 def test_single_interval(): assert max_non_overlapping_intervals([(1, 2)]) == 1 def test_non_overlapping_intervals(): assert max_non_overlapping_intervals([(1, 2), (2, 3), (3, 4)]) == 3 def test_all_overlapping_intervals(): assert max_non_overlapping_intervals([(1, 3), (2, 4), (3, 5)]) == 2 def test_mixed_intervals(): assert max_non_overlapping_intervals([(1, 3), (3, 5), (2, 4), (5, 7), (6, 8)]) == 3 def test_intervals_with_same_end_time(): assert max_non_overlapping_intervals([(1, 3), (2, 3), (3, 5), (4, 6)]) == 2 def test_large_input(): intervals = [(i, i + 1) for i in range(0, 10000, 2)] assert max_non_overlapping_intervals(intervals) == 5000","solution":"def max_non_overlapping_intervals(intervals): Returns the maximum number of non-overlapping intervals that can be scheduled. :param intervals: List[Tuple[int, int]] - A list of intervals represented as tuples of (start, end) :return: int - The maximum number of non-overlapping intervals that can be scheduled if not intervals: return 0 # Sort intervals by their end times intervals.sort(key=lambda x: x[1]) count = 0 last_end_time = float('-inf') for start, end in intervals: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"def find_k_largest(nums: list[int], k: int) -> list[int]: Returns the k largest elements from the list \`nums\` in descending order. If the list has fewer than k elements, returns all elements sorted in descending order. Args: nums (list[int]): The list of integers to find the k largest elements from. k (int): The number of largest elements to find. Returns: list[int]: A list of k largest elements sorted in descending order. Examples: >>> find_k_largest([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], 3) [9, 6, 5] >>> find_k_largest([], 3) [] >>> find_k_largest([1, 2, 3], 5) [3, 2, 1] >>> find_k_largest([5, 5, 5, 5, 5], 3) [5, 5, 5] >>> find_k_largest([1, 2, 3], 0) [] >>> find_k_largest([-1, -2, -3, -4, -5], 2) [-1, -2] >>> find_k_largest([-1, 2, 3, -2, 5], 4) [5, 3, 2, -1] >>> find_k_largest([4], 1) [4] >>> find_k_largest([4], 3) [4]","solution":"def find_k_largest(nums: list[int], k: int) -> list[int]: Returns the k largest elements from the list \`nums\` in descending order. If the list has fewer than k elements, returns all elements sorted in descending order. if not nums or k <= 0: return [] # Ensure k does not exceed the length of nums k = min(k, len(nums)) # Use a heap to efficiently find the k largest elements import heapq largest_elements = heapq.nlargest(k, nums) # Sort the resulting elements in descending order largest_elements.sort(reverse=True) return largest_elements"},{"question":"def find_smallest_missing_positive(arr: List[int]) -> int: Finds the smallest missing positive integer in the given array. Args: arr (List[int]): Input list of integers. Returns: int: The smallest missing positive integer. >>> find_smallest_missing_positive([3, 4, -1, 1]) 2 >>> find_smallest_missing_positive([1, 2, 0]) 3 >>> find_smallest_missing_positive([7, 8, 9, 11, 12]) 1 # Implement the function here def test_find_smallest_missing_positive_all_positive(): assert find_smallest_missing_positive([3, 4, -1, 1]) == 2 def test_find_smallest_missing_positive_sequential(): assert find_smallest_missing_positive([1, 2, 0]) == 3 def test_find_smallest_missing_positive_large_gap(): assert find_smallest_missing_positive([7, 8, 9, 11, 12]) == 1 def test_find_smallest_missing_positive_already_sequential(): assert find_smallest_missing_positive([1, 2, 3, 4, 5, 6]) == 7 def test_find_smallest_missing_positive_only_negatives(): assert find_smallest_missing_positive([-1, -2, -3, -4]) == 1 def test_find_smallest_missing_positive_mixed(): assert find_smallest_missing_positive([3, 4, 2, 1, 5, -1, 7, 6, -2, 8]) == 9 def test_find_smallest_missing_positive_empty(): assert find_smallest_missing_positive([]) == 1 def test_find_smallest_missing_positive_single_element(): assert find_smallest_missing_positive([1]) == 2 assert find_smallest_missing_positive([2]) == 1 assert find_smallest_missing_positive([-1]) == 1 def test_find_smallest_missing_positive_duplicates(): assert find_smallest_missing_positive([1, 1, 1, 1]) == 2 assert find_smallest_missing_positive([3, 4, 4, 4, 1]) == 2 def test_find_smallest_missing_positive_large_input(): large_input = list(range(1, 100001)) assert find_smallest_missing_positive(large_input) == 100001","solution":"def find_smallest_missing_positive(arr): Finds the smallest missing positive integer in the given array. Args: arr (List[int]): Input list of integers. Returns: int: The smallest missing positive integer. n = len(arr) # Step 1: Mark non-positive and out of bound numbers for i in range(n): if arr[i] <= 0 or arr[i] > n: arr[i] = n + 1 # Step 2: Use the index as a hash key and mark corresponding positions as visited for i in range(n): num = abs(arr[i]) if num <= n: arr[num - 1] = -abs(arr[num - 1]) # Step 3: The first index which has a positive number, the index+1 is missing for i in range(n): if arr[i] > 0: return i + 1 # Step 4: If no positive index found, return n + 1 (all numbers 1 to n are present) return n + 1"},{"question":"def are_transactions_valid(transactions: list, lower_bound: float, upper_bound: float) -> bool: Verify if all transactions fall within a given range. >>> are_transactions_valid([50.0, 20.0, 30.0], 10.0, 50.0) # True >>> are_transactions_valid([5.0, 100.0, 30.0], 10.0, 90.0) # False pass def sum_of_valid_transactions(transactions: list, lower_bound: float, upper_bound: float) -> float: Compute the sum of transactions within the specified range. >>> sum_of_valid_transactions([50.0, 20.0, 30.0], 10.0, 50.0) # 100.0 >>> sum_of_valid_transactions([5.0, 100.0, 30.0], 10.0, 90.0) # 30.0 >>> sum_of_valid_transactions([], 0.0, 100.0) # 0.0 pass","solution":"def are_transactions_valid(transactions: list, lower_bound: float, upper_bound: float) -> bool: # Check if the input is a list and it's not empty if not isinstance(transactions, list) or not transactions: raise ValueError('Input must be a non-empty list of transactions.') # Check if all transactions are within the given range return all(lower_bound <= transaction <= upper_bound for transaction in transactions) def sum_of_valid_transactions(transactions: list, lower_bound: float, upper_bound: float) -> float: # Check if the input is a list if not isinstance(transactions, list): raise ValueError('Input must be a list of transactions.') # Sum of transactions that are within the given range return sum(transaction for transaction in transactions if lower_bound <= transaction <= upper_bound)"},{"question":"from typing import List def average_interval(timestamps: List[str]) -> float: Calculate the average interval between consecutive timestamps in the list. Parameters: timestamps (List[str]): A list of timestamp strings in the format \\"YYYY-MM-DD HH:MM:SS\\". Returns: float: The average interval in seconds. Examples: >>> average_interval([\\"2023-01-01 00:00:00\\", \\"2023-01-01 00:00:10\\", \\"2023-01-01 00:00:20\\", \\"2023-01-01 00:00:30\\"]) 10.0 >>> average_interval([\\"2023-01-01 00:00:00\\", \\"2023-01-01 00:00:05\\", \\"2023-01-01 00:10:05\\", \\"2023-01-01 01:00:00\\"]) 866.6666666666666","solution":"from typing import List from datetime import datetime def average_interval(timestamps: List[str]) -> float: Calculate the average interval between consecutive timestamps in the list. Parameters: timestamps (List[str]): A list of timestamp strings in the format \\"YYYY-MM-DD HH:MM:SS\\". Returns: float: The average interval in seconds. total_interval = 0 num_intervals = len(timestamps) - 1 for i in range(num_intervals): t1 = datetime.strptime(timestamps[i], '%Y-%m-%d %H:%M:%S') t2 = datetime.strptime(timestamps[i + 1], '%Y-%m-%d %H:%M:%S') interval = (t2 - t1).total_seconds() total_interval += interval average_interval = total_interval / num_intervals return average_interval"},{"question":"def unique_characters(string: str) -> bool: Checks if all characters in the string are unique, ignoring case. Parameters: string (str): The string to be checked. Returns: bool: True if all characters are unique when case is ignored, False otherwise. Examples: >>> unique_characters(\\"abcdefg\\") True >>> unique_characters(\\"aAbBcCdD\\") False >>> unique_characters(\\"Alphabet\\") False >>> unique_characters(\\"\\") True >>> unique_characters(\\"AaBbCcDdE\\") False","solution":"def unique_characters(string: str) -> bool: Checks if all characters in the string are unique, ignoring case. Parameters: string (str): The string to be checked. Returns: bool: True if all characters are unique, False otherwise. # Convert string to lowercase to ignore case string = string.lower() # Create a set to track unique characters seen_chars = set() # Iterate over each character in the string for char in string: # If character is already in set, return False if char in seen_chars: return False # Add character to set seen_chars.add(char) # If no duplicates were found, return True return True"},{"question":"class UndirectedGraph: def __init__(self): self.adjacency_list = {} def add_pair(self, u, v): Adds an undirected edge between node u and node v. if u not in self.adjacency_list: self.adjacency_list[u] = [] if v not in self.adjacency_list: self.adjacency_list[v] = [] self.adjacency_list[u].append(v) self.adjacency_list[v].append(u) def dfs_traversal(self, s): Perform Depth-First Search (DFS) traversal starting from node s. Args: s (int): Starting node for the DFS traversal. Returns: List[int]: Order of nodes visited during the DFS traversal. >>> graph = UndirectedGraph() >>> graph.add_pair(0, 1) >>> graph.add_pair(0, 2) >>> graph.add_pair(1, 3) >>> graph.add_pair(1, 4) >>> graph.add_pair(2, 5) >>> graph.add_pair(2, 6) >>> graph.dfs_traversal(0) # Output could be [0, 1, 3, 4, 2, 5, 6] or any DFS valid order # Your implementation here pass","solution":"class UndirectedGraph: def __init__(self): self.adjacency_list = {} def add_pair(self, u, v): if u not in self.adjacency_list: self.adjacency_list[u] = [] if v not in self.adjacency_list: self.adjacency_list[v] = [] self.adjacency_list[u].append(v) self.adjacency_list[v].append(u) def dfs_traversal(self, s): visited = set() stack = [s] order = [] while stack: node = stack.pop() if node not in visited: visited.add(node) order.append(node) # Add nodes in reverse order to visit them as per DFS nature (LIFO) for neighbor in reversed(self.adjacency_list[node]): if neighbor not in visited: stack.append(neighbor) return order"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a simple mathematical expression passed as a string. The expression will contain non-negative integers, +, -, *, /, and parentheses ( ). Returns the evaluated result as a float if the expression is valid. Returns None if the input expression is invalid. >>> evaluate_expression(\\"3 + 5 * 2\\") 13.0 >>> evaluate_expression(\\"10 / 2 - 1\\") 4.0 >>> evaluate_expression(\\"(2 + 3) * 4\\") 20.0 >>> evaluate_expression(\\"10 + 2 / (5 - 3)\\") 11.0 >>> evaluate_expression(\\"3 + (2 * (4 - 1))\\") 9.0 >>> evaluate_expression(\\"10 + a - 3\\") None >>> evaluate_expression(\\"10 + 5) - 3\\") None >>> evaluate_expression(\\"\\") None","solution":"def evaluate_expression(expression: str) -> float: Evaluates a simple mathematical expression passed as a string. The expression will contain non-negative integers, +, -, *, /, and parentheses ( ). Returns the evaluated result as a float if the expression is valid. Returns None if the input expression is invalid. # Check for empty string if not expression: return None # Check for invalid characters if not expression.replace(' ', '').replace('+', '').replace('-', '').replace('*', '').replace('/', '').replace('(', '').replace(')', '').isdigit(): return None # Check for mismatched parentheses open_parens = 0 for char in expression: if char == '(': open_parens += 1 elif char == ')': open_parens -= 1 if open_parens < 0: return None if open_parens != 0: return None try: # Evaluate the expression result = eval(expression) return float(result) except Exception as e: # If an error occurs during evaluation return None"},{"question":"def remove_duplicates(sentence: str) -> str: Removes duplicate words from a sentence while maintaining the order of their first appearance. Parameters: sentence (str): The input sentence from which duplicate words should be removed. Returns: str: A string representing the sentence with all duplicate words removed. Examples: >>> remove_duplicates(\\"hello world hello\\") 'hello world' >>> remove_duplicates(\\"this is a test test is a\\") 'this is a test' >>> remove_duplicates(\\"unique words only\\") 'unique words only' >>> remove_duplicates(\\"\\") '' # Your implementation here pass def test_remove_duplicates_with_duplicates(): assert remove_duplicates(\\"hello world hello\\") == \\"hello world\\" def test_remove_duplicates_no_duplicates(): assert remove_duplicates(\\"unique words only\\") == \\"unique words only\\" def test_remove_duplicates_all_duplicates(): assert remove_duplicates(\\"test test test test\\") == \\"test\\" def test_remove_duplicates_mixed(): assert remove_duplicates(\\"this is a test test is a\\") == \\"this is a test\\" def test_remove_duplicates_empty(): assert remove_duplicates(\\"\\") == \\"\\" def test_remove_duplicates_single_word(): assert remove_duplicates(\\"hello\\") == \\"hello\\" def test_remove_duplicates_two_word_repeats(): assert remove_duplicates(\\"hello hello world world\\") == \\"hello world\\" # Running the tests test_remove_duplicates_with_duplicates() test_remove_duplicates_no_duplicates() test_remove_duplicates_all_duplicates() test_remove_duplicates_mixed() test_remove_duplicates_empty() test_remove_duplicates_single_word() test_remove_duplicates_two_word_repeats()","solution":"def remove_duplicates(sentence: str) -> str: Removes duplicate words from a sentence while maintaining the order of their first appearance. Parameters: sentence (str): The input sentence from which duplicate words should be removed. Returns: str: A string representing the sentence with all duplicate words removed. Examples: >>> remove_duplicates(\\"hello world hello\\") 'hello world' >>> remove_duplicates(\\"this is a test test is a\\") 'this is a test' >>> remove_duplicates(\\"unique words only\\") 'unique words only' >>> remove_duplicates(\\"\\") '' seen = set() result = [] for word in sentence.split(): if word not in seen: seen.add(word) result.append(word) return \\" \\".join(result)"},{"question":"def min_insertions_to_palindrome(s: str) -> int: Returns the minimum number of insertions needed to make the input string a palindrome. >>> min_insertions_to_palindrome(\\"race\\") 3 >>> min_insertions_to_palindrome(\\"google\\") 2 >>> min_insertions_to_palindrome(\\"madam\\") 0 >>> min_insertions_to_palindrome(\\"ab\\") 1","solution":"def min_insertions_to_palindrome(s: str) -> int: Returns the minimum number of insertions needed to make the input string a palindrome. n = len(s) # Create a table to store the results of subproblems dp = [[0] * n for _ in range(n)] # Fill in the table for gap in range(1, n): l = 0 for h in range(gap, n): if s[l] == s[h]: dp[l][h] = dp[l+1][h-1] else: dp[l][h] = min(dp[l][h-1], dp[l+1][h]) + 1 l += 1 # The result is the minimum number of insertions needed for the entire string return dp[0][n-1]"},{"question":"from typing import List def transform_list(nums: List[int]) -> List[int]: Transforms a list of integers such that: - Each even number is doubled. - Each odd number is replaced with its negation. Args: nums (List[int]): The list of integers to be transformed. Returns: List[int]: The list of transformed integers. Examples: >>> transform_list([1, 2, 3, 4, 5]) [-1, 4, -3, 8, -5] >>> transform_list([10, 15, 20]) [20, -15, 40] >>> transform_list([]) [] >>> transform_list([0, -1, -2]) [0, 1, -4] >>> transform_list([99, 100, -101]) [-99, 200, 101]","solution":"from typing import List def transform_list(nums: List[int]) -> List[int]: Transforms the input list of integers based on specific criteria. - Each integer is doubled if it is an even number. - Each integer is replaced with its negation if it is an odd number. Args: nums (List[int]): The list of integers to be transformed. Returns: List[int]: The transformed list of integers. return [x * 2 if x % 2 == 0 else -x for x in nums]"},{"question":"def largest_rectangle_area(heights: list) -> int: Calculate the largest rectangular area in a histogram. :param heights: List of integers representing the heights of the histogram bars. :return: The area of the largest rectangle that can be formed within the histogram. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 4]) 4 >>> largest_rectangle_area([]) 0 >>> largest_rectangle_area([0, 0, 0]) 0 >>> largest_rectangle_area([1]) 1 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12","solution":"def largest_rectangle_area(heights: list) -> int: Calculate the largest rectangular area in a histogram. :param heights: List of integers representing the heights of the histogram bars. :return: The area of the largest rectangle that can be formed within the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() height = heights[top_of_stack] width = index if not stack else index - stack[-1] - 1 max_area = max(max_area, height * width) while stack: top_of_stack = stack.pop() height = heights[top_of_stack] width = index if not stack else index - stack[-1] - 1 max_area = max(max_area, height * width) return max_area"},{"question":"class FileSystem: def __init__(self): Initialize the FileSystem with an empty dictionary to store path-value pairs. self.paths = {} def create(self, path: str, value: int) -> bool: Creates a new path with the given value. Args: - path (str): the path to be created. - value (int): the value to associate with the path. Returns: - bool: True if the path was successfully created, False otherwise. pass def get(self, path: str) -> int | None: Returns the value associated with the given path. Args: - path (str): the path to look up. Returns: - int: The value associated with the path, or None if the path does not exist. pass # Unit Tests import pytest def test_create_root_path(): fs = FileSystem() assert fs.create(\\"/\\", 1) == False # root path cannot be created def test_create_single_level_path(): fs = FileSystem() assert fs.create(\\"/a\\", 1) == True assert fs.get(\\"/a\\") == 1 def test_create_multi_level_path(): fs = FileSystem() assert fs.create(\\"/a\\", 1) == True assert fs.create(\\"/a/b\\", 2) == True assert fs.get(\\"/a/b\\") == 2 def test_create_path_with_no_parent(): fs = FileSystem() assert fs.create(\\"/b/c\\", 3) == False # parent \\"/b\\" does not exist def test_get_non_existent_path(): fs = FileSystem() assert fs.get(\\"/nonexistent\\") == None def test_duplicate_create(): fs = FileSystem() assert fs.create(\\"/a\\", 1) == True assert fs.create(\\"/a\\", 2) == False # duplicate path creation should fail def test_create_path_with_existing_sibling(): fs = FileSystem() assert fs.create(\\"/a\\", 1) == True assert fs.create(\\"/a/b\\", 2) == True assert fs.create(\\"/a/c\\", 3) == True assert fs.get(\\"/a/c\\") == 3","solution":"class FileSystem: def __init__(self): Initialize the FileSystem with an empty dictionary to store path-value pairs. self.paths = {\\"/\\": None} def create(self, path: str, value: int) -> bool: Creates a new path with the given value. Args: - path (str): the path to be created. - value (int): the value to associate with the path. Returns: - bool: True if the path was successfully created, False otherwise. if path in self.paths: return False parent = \\"/\\".join(path.split(\\"/\\")[:-1]) if not parent: parent = \\"/\\" if parent not in self.paths: return False self.paths[path] = value return True def get(self, path: str) -> int | None: Returns the value associated with the given path. Args: - path (str): the path to look up. Returns: - int: The value associated with the path, or None if the path does not exist. return self.paths.get(path, None)"},{"question":"from typing import List def longest_word_in_grid(grid: List[List[str]], word_list: List[str]) -> str: Finds the longest word that exists in a given dictionary (word_list) and can be traced in the grid. A word can be traced in any direction (up, down, left, right, or diagonals). The same cell in the grid cannot be used more than once for the same word. >>> grid = [ ... ['o', 'a', 'a', 'n'], ... ['e', 't', 'a', 'e'], ... ['i', 'h', 'k', 'r'], ... ['i', 'f', 'l', 'v'] ... ] >>> word_list = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] ... longest_word_in_grid(grid, word_list) \\"oath\\" >>> grid = [['a']] ... word_list = [\\"a\\", \\"b\\", \\"aa\\"] ... longest_word_in_grid(grid, word_list) \\"a\\" >>> grid = [ ... ['x', 'y', 'z'], ... ['w', 'v', 'u'], ... ['t', 's', 'r'] ... ] >>> word_list = [\\"hello\\", \\"world\\"] ... longest_word_in_grid(grid, word_list) \\"\\" >>> grid = [ ... ['g', 'o', 'o'], ... ['g', 'g', 'o'], ... ['g', 'o', 'd'] ... ] >>> word_list = [\\"good\\", \\"god\\", \\"go\\"] ... result = longest_word_in_grid(grid, word_list) ... assert result in [\\"good\\", \\"god\\"] >>> grid = [ ... ['a', 'b'], ... ['c', 'd'] ... ] >>> word_list = [\\"abcd\\", \\"ab\\", \\"ad\\", \\"cba\\"] ... longest_word_in_grid(grid, word_list) \\"abcd\\"","solution":"from typing import List def longest_word_in_grid(grid: List[List[str]], word_list: List[str]) -> str: def dfs(x, y, word, index): if index == len(word): return True if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] != word[index]: return False temp = grid[x][y] grid[x][y] = \\"#\\" found = dfs(x+1, y, word, index+1) or dfs(x-1, y, word, index+1) or dfs(x, y+1, word, index+1) or dfs(x, y-1, word, index+1) or dfs(x+1, y+1, word, index+1) or dfs(x+1, y-1, word, index+1) or dfs(x-1, y+1, word, index+1) or dfs(x-1, y-1, word, index+1) grid[x][y] = temp return found longest_word = \\"\\" for word in word_list: word_found = False for i in range(len(grid)): for j in range(len(grid[0])): if dfs(i, j, word, 0): word_found = True break if word_found: break if word_found and len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"from typing import List def find_min_time_difference(times: List[str]) -> int: Find the minimum difference in minutes between any two given times in a 24-hour format. >>> find_min_time_difference([\\"23:59\\", \\"00:00\\"]) 1 >>> find_min_time_difference([\\"01:24\\", \\"03:48\\", \\"00:23\\"]) 61 >>> find_min_time_difference([]) 0 >>> find_min_time_difference([\\"12:00\\"]) 0 >>> find_min_time_difference([\\"00:00\\", \\"06:00\\", \\"12:00\\", \\"18:00\\", \\"23:59\\"]) 1 >>> find_min_time_difference([\\"05:31\\", \\"22:08\\", \\"05:30\\", \\"21:45\\"]) 1 >>> find_min_time_difference([\\"21:00\\", \\"04:00\\", \\"08:00\\", \\"16:00\\"]) 240 >>> find_min_time_difference([\\"23:58\\", \\"23:59\\", \\"00:00\\", \\"00:01\\"]) 1 >>> find_min_time_difference([\\"00:00\\", \\"12:00\\"]) 720 >>> find_min_time_difference([\\"00:00\\", \\"24:00\\"]) 0","solution":"from typing import List def find_min_time_difference(times: List[str]) -> int: if len(times) < 2: return 0 def time_to_minutes(t: str) -> int: h, m = map(int, t.split(':')) return h * 60 + m minutes = sorted(time_to_minutes(t) for t in times) minutes.append(minutes[0] + 24 * 60) # Account for the wrap-around scenario min_diff = float('inf') for i in range(1, len(minutes)): min_diff = min(min_diff, minutes[i] - minutes[i-1]) return min_diff"},{"question":"def count_jumping_ways(n: int) -> int: Calculates and returns the number of ways to reach the top of a staircase of \`n\` steps following the peculiar jumping style. Parameters: - n (int): The number of steps in the staircase. Returns: - int: The number of ways to reach the top following the jumping pattern. >>> count_jumping_ways(4) 5 >>> count_jumping_ways(5) 8 >>> count_jumping_ways(10) 89","solution":"def count_jumping_ways(n: int) -> int: Calculates and returns the number of ways to reach the top of a staircase of \`n\` steps following the peculiar jumping style. if n == 1: return 1 # dp[i] will store the number of ways to reach step i with 1 or 2 step jumps. dp = [0] * (n + 1) dp[0] = 1 # 1 way to stay at the ground level (do nothing) dp[1] = 1 # 1 way to reach step 1 for i in range(2, n + 1): # Number of ways to reach step i by jumping 1 dp_1 = dp[i - 1] # Number of ways to reach step i by jumping 2 if i is greater than or equal to 2 dp_2 = dp[i - 2] dp[i] = dp_1 + dp_2 return dp[n]"},{"question":"def password_strength(password: str) -> str: Evaluates the strength of a given password based on various criteria. Strength categories: - Length < 8 characters: Weak - Length 8-14 characters: Medium - Length > 14 characters: Strong - Contains both uppercase and lowercase letters: Add 1 to score - Contains at least one numerical digit: Add 1 to score - Contains at least one special character: Add 1 to score Final classification based on score: - Score 0-2: Weak - Score 3: Medium - Score 4: Strong >>> password_strength(\\"12345\\") 'Weak' >>> password_strength(\\"StrongPass1\\") 'Medium' >>> password_strength(\\"VeryStrongPassword@123\\") 'Strong' >>> password_strength(\\"weak\\") 'Weak'","solution":"def password_strength(password: str) -> str: length_score = 0 if len(password) < 8: length_score = 0 elif len(password) <= 14: length_score = 1 else: length_score = 2 has_upper = any(c.isupper() for c in password) has_lower = any(c.islower() for c in password) has_digit = any(c.isdigit() for c in password) has_special = any(not c.isalnum() for c in password) score = length_score if has_upper and has_lower: score += 1 if has_digit: score += 1 if has_special: score += 1 if score <= 2: return \\"Weak\\" elif score == 3: return \\"Medium\\" else: return \\"Strong\\""},{"question":"def max_subsequence_sum(arr: list) -> int: Analyzes a given list of integers and identifies the subsequence with the maximum sum. A subsequence can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Parameters: arr (list): A list of integers. Returns: int: The maximum sum of a subsequence of the input list. Examples: >>> max_subsequence_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 10 >>> max_subsequence_sum([3, -2, 5, -1]) 8","solution":"def max_subsequence_sum(arr): Returns the maximum sum of a subsequence of the input array. # The maximum sum of a subsequence is achieved by summing all positive numbers max_sum = sum(x for x in arr if x > 0) # If max_sum is 0, it means there were no positive numbers. So, we should return the max number in the list. return max_sum if max_sum > 0 else max(arr)"},{"question":"def can_form_array(arr: List[int], pieces: List[List[int]]) -> bool: Determine whether arr can be formed by concatenating subarrays in pieces in any order. >>> arr = [85, 1, 5, 11, 7, 41] >>> pieces = [[1, 5, 11], [85], [7, 41]] >>> can_form_array(arr, pieces) True >>> arr = [49, 18, 16] >>> pieces = [[16, 18, 49]] >>> can_form_array(arr, pieces) False","solution":"def can_form_array(arr, pieces): arr_index_map = {num: idx for idx, num in enumerate(arr)} for piece in pieces: if piece[0] not in arr_index_map: return False start_idx = arr_index_map[piece[0]] for i in range(len(piece)): if start_idx + i >= len(arr) or arr[start_idx + i] != piece[i]: return False return True"},{"question":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number. :param n: The position in the Fibonacci sequence (0-indexed) :return: The nth Fibonacci number >>> fibonacci(0) == 0 >>> fibonacci(1) == 1 >>> fibonacci(10) == 55 >>> fibonacci(50) == 12586269025 >>> fibonacci(100) == 354224848179261915075 from solution import fibonacci def test_fibonacci_0(): assert fibonacci(0) == 0 def test_fibonacci_1(): assert fibonacci(1) == 1 def test_fibonacci_2(): assert fibonacci(2) == 1 def test_fibonacci_10(): assert fibonacci(10) == 55 def test_fibonacci_20(): assert fibonacci(20) == 6765 def test_fibonacci_50(): assert fibonacci(50) == 12586269025 def test_fibonacci_100(): assert fibonacci(100) == 354224848179261915075 def test_fibonacci_large(): assert fibonacci(100000) is not None","solution":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number. :param n: The position in the Fibonacci sequence (0-indexed) :return: The nth Fibonacci number if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def count_paths(m: int, n: int) -> int: Returns the number of distinct paths from the top-left corner to the bottom-right corner of an MxN grid. >>> count_paths(3, 7) 28 >>> count_paths(3, 2) 3 >>> count_paths(1, 1) 1 >>> count_paths(1, 100) 1 >>> count_paths(100, 1) 1 >>> count_paths(2, 2) 2 >>> count_paths(3, 3) 6 >>> count_paths(100, 100) 22750883079422934966181954039568885395604168260154104734000","solution":"def count_paths(m: int, n: int) -> int: Returns the number of distinct paths from the top-left corner to the bottom-right corner of an MxN grid. # Edge case for smallest grid if m == 1 or n == 1: return 1 # Initializing a 2D list to store the number of ways to reach each cell dp = [[0] * n for _ in range(m)] # There's exactly one way to reach any cell in the first row or first column for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Filling the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"import heapq class MedianFinder: def __init__(self): Initialize your data structure here. # Max-heap to store the smaller half of the numbers self.max_heap = [] # Min-heap to store the larger half of the numbers self.min_heap = [] def add_num(self, num: int) -> None: Adds a number into the data structure. # Implementation here ... def find_median(self) -> float: Returns the median of current data stream. # Implementation here ... def test_median_finder(): mf = MedianFinder() mf.add_num(1) assert mf.find_median() == 1.0 mf.add_num(2) assert mf.find_median() == 1.5 mf.add_num(3) assert mf.find_median() == 2.0 mf.add_num(4) assert mf.find_median() == 2.5 mf.add_num(5) assert mf.find_median() == 3.0 mf2 = MedianFinder() mf2.add_num(-1) mf2.add_num(-2) mf2.add_num(-3) mf2.add_num(-4) mf2.add_num(-5) assert mf2.find_median() == -3.0 mf3 = MedianFinder() mf3.add_num(5) mf3.add_num(15) mf3.add_num(1) mf3.add_num(3) assert mf3.find_median() == 4.0","solution":"import heapq class MedianFinder: def __init__(self): Initialize your data structure here. # Max-heap to store the smaller half of the numbers self.max_heap = [] # Min-heap to store the larger half of the numbers self.min_heap = [] def add_num(self, num: int) -> None: Adds a number into the data structure. # Negate the number for max-heap functionality (since Python has only min-heap) heapq.heappush(self.max_heap, -num) # Ensure the largest number in max_heap is less than or equal to the smallest in min_heap if self.max_heap and self.min_heap and (-self.max_heap[0] > self.min_heap[0]): val = -heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, val) # Balance the sizes of the two heaps so that max_heap is always the same size or 1 element larger if len(self.max_heap) > len(self.min_heap) + 1: val = -heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, val) if len(self.min_heap) > len(self.max_heap): val = heapq.heappop(self.min_heap) heapq.heappush(self.max_heap, -val) def find_median(self) -> float: Returns the median of current data stream. # If the number of elements is odd, the median is the top of the max_heap # If the number of elements is even, the median is the average of the tops of both heaps if len(self.max_heap) > len(self.min_heap): return -self.max_heap[0] return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"def filter_and_sort_numbers(numbers: list[int], threshold: int) -> list[int]: Filters a list of integers by removing duplicates, excluding integers below a certain threshold, and then sorting the remaining integers. Parameters: numbers (list of int): The list of integers to be processed. threshold (int): The minimum value an integer must have to be included in the output list. Returns: list of int: A sorted list of unique integers that are greater than or equal to the threshold. >>> filter_and_sort_numbers([5, 3, 7, 3, 9, 1, 5, 8, 6, 4], 5) [5, 6, 7, 8, 9] >>> filter_and_sort_numbers([1, 2, 3, 4], 5) [] >>> filter_and_sort_numbers([5, 6, 7, 8, 9], 5) [5, 6, 7, 8, 9] >>> filter_and_sort_numbers([-5, -3, -7, 0, 3, 7, 10], 0) [0, 3, 7, 10] >>> filter_and_sort_numbers([1000000000, 999999999, -1000000000, 500, 200], 200) [200, 500, 999999999, 1000000000] >>> filter_and_sort_numbers([5, 3, 7, 9, 1, 8, 6, 4], 10) [] >>> filter_and_sort_numbers([], 5) [] >>> filter_and_sort_numbers([3, 9, 2, 8, 1, 7], 3) [3, 7, 8, 9]","solution":"def filter_and_sort_numbers(numbers: list[int], threshold: int) -> list[int]: Filters a list of integers by removing duplicates, excluding integers below a certain threshold, and then sorting the remaining integers. Parameters: numbers (list of int): The list of integers to be processed. threshold (int): The minimum value an integer must have to be included in the output list. Returns: list of int: A sorted list of unique integers that are greater than or equal to the threshold. # Remove duplicates by converting the list to a set unique_numbers = set(numbers) # Filter out numbers below the threshold filtered_numbers = [num for num in unique_numbers if num >= threshold] # Sort the resulting list in ascending order sorted_numbers = sorted(filtered_numbers) return sorted_numbers"},{"question":"def max_non_overlapping_tasks(tasks): Returns the maximum number of non-overlapping tasks that can be scheduled. Args: tasks (list): A list of tuples where each tuple represents a task's start and end time (start_time, end_time). Returns: int: Maximum number of non-overlapping tasks. >>> max_non_overlapping_tasks([(1, 3), (2, 5), (4, 6)]) == 2 >>> max_non_overlapping_tasks([(1, 2), (3, 4), (0, 6), (5, 7), (8, 9)]) == 4 >>> max_non_overlapping_tasks([(1, 2), (2, 3), (3, 4), (4, 5)]) == 4 >>> max_non_overlapping_tasks([(3, 5), (1, 2), (2, 4), (5, 6)]) == 3 >>> max_non_overlapping_tasks([]) == 0 >>> max_non_overlapping_tasks([(1, 3), (2, 3), (3, 4), (3, 5)]) == 2 >>> max_non_overlapping_tasks([(1, 100), (2, 3), (4, 5), (6, 7)]) == 3 >>> max_non_overlapping_tasks([(1, 3)]) == 1","solution":"def max_non_overlapping_tasks(tasks): Returns the maximum number of non-overlapping tasks that can be scheduled. Args: tasks (list): A list of tuples where each tuple represents a task's start and end time (start_time, end_time). Returns: int: Maximum number of non-overlapping tasks. # Sort tasks by their ending times tasks.sort(key=lambda x: x[1]) # Initialize variables max_tasks = 0 last_end_time = 0 # Iterate over sorted tasks for start, end in tasks: if start >= last_end_time: # If the current task starts after or when the last selected task ended, choose it max_tasks += 1 last_end_time = end # Update the last end time to the current task's end time return max_tasks"},{"question":"def manage_library(actions: list[tuple[str, str, str]]) -> dict[str, list[str]]: Manages the borrowing and returning of books in a library. The function accepts a list of actions in the format (action, user, book) and returns a dictionary where the keys are user IDs and the values are lists of books currently checked out by that user. :param actions: A list of tuples where each tuple represents an action. An action tuple consists of: ('borrow' or 'return', user ID, book title). :return: A dictionary with user IDs as keys and lists of books currently checked out as values. Example: >>> actions = [ (\\"borrow\\", \\"user_1\\", \\"Book A\\"), (\\"borrow\\", \\"user_2\\", \\"Book B\\"), (\\"return\\", \\"user_1\\", \\"Book A\\"), (\\"borrow\\", \\"user_2\\", \\"Book A\\") ] >>> manage_library(actions) {'user_2': ['Book B', 'Book A']} def test_manage_library(): actions = [ (\\"borrow\\", \\"user_1\\", \\"Book A\\"), (\\"borrow\\", \\"user_2\\", \\"Book B\\"), (\\"return\\", \\"user_1\\", \\"Book A\\"), (\\"borrow\\", \\"user_2\\", \\"Book A\\") ] expected = {'user_2': ['Book B', 'Book A']} assert manage_library(actions) == expected def test_borrow_and_return(): actions = [ (\\"borrow\\", \\"user_1\\", \\"Book A\\"), (\\"borrow\\", \\"user_1\\", \\"Book B\\"), (\\"return\\", \\"user_1\\", \\"Book A\\"), (\\"borrow\\", \\"user_2\\", \\"Book A\\"), (\\"return\\", \\"user_1\\", \\"Book B\\"), (\\"borrow\\", \\"user_3\\", \\"Book B\\") ] expected = {'user_2': ['Book A'], 'user_3': ['Book B']} assert manage_library(actions)== expected def test_invalid_return(): actions = [ (\\"borrow\\", \\"user_1\\", \\"Book A\\"), (\\"return\\", \\"user_2\\", \\"Book A\\"), (\\"borrow\\", \\"user_2\\", \\"Book B\\") ] expected = {'user_1': ['Book A'], 'user_2': ['Book B']} assert manage_library(actions)== expected def test_already_borrowed_book(): actions = [ (\\"borrow\\", \\"user_1\\", \\"Book A\\"), (\\"borrow\\", \\"user_2\\", \\"Book A\\") ] expected = {'user_1': ['Book A']} assert manage_library(actions)== expected def test_all_books_returned(): actions = [ (\\"borrow\\", \\"user_1\\", \\"Book A\\"), (\\"borrow\\", \\"user_1\\", \\"Book B\\"), (\\"return\\", \\"user_1\\", \\"Book A\\"), (\\"return\\", \\"user_1\\", \\"Book B\\") ] expected = {} assert manage_library(actions)== expected","solution":"def manage_library(actions): Manages the borrowing and returning of books in a library. The function accepts a list of actions in the format (action, user, book) and returns a dictionary where the keys are user IDs and the values are lists of books currently checked out by that user. :param actions: A list of tuples where each tuple represents an action. An action tuple consists of: ('borrow' or 'return', user ID, book title). :return: A dictionary with user IDs as keys and lists of books currently checked out as values. borrowed_books = {} user_books = {} for action, user, book in actions: if action == \\"borrow\\": if book not in borrowed_books: borrowed_books[book] = user if user not in user_books: user_books[user] = [] user_books[user].append(book) elif action == \\"return\\": if book in borrowed_books and borrowed_books[book] == user: borrowed_books.pop(book) user_books[user].remove(book) if not user_books[user]: user_books.pop(user) return user_books"},{"question":"def is_perfect_number(n: int) -> bool: Check if a number is a perfect number. A perfect number is a positive integer that is equal to the sum of its proper divisors, excluding itself. :param n: int, a positive integer (1 <= n <= 10^6) :return: bool, True if n is a perfect number, otherwise False Examples: >>> is_perfect_number(6) True >>> is_perfect_number(28) True >>> is_perfect_number(12) False >>> is_perfect_number(1) False","solution":"def is_perfect_number(n: int) -> bool: Returns True if n is a perfect number, otherwise False. A perfect number is a positive integer that is equal to the sum of its proper divisors, excluding itself. :param n: int, a positive integer (1 <= n <= 10^6) :return: bool if n <= 1: return False sum_of_divisors = 1 sqrt_n = int(n ** 0.5) for i in range(2, sqrt_n + 1): if n % i == 0: sum_of_divisors += i if i != n // i: sum_of_divisors += n // i return sum_of_divisors == n"},{"question":"def find_closest_ages(ages: list[int], target: int) -> tuple[int, int]: Returns a tuple of two ages from the list that sum up to the value closest to the target without exceeding it. If no such pair exists, returns (-1, -1). >>> find_closest_ages([20, 30, 40, 50, 60], 90) (30, 60) >>> find_closest_ages([5, 10, 12], 15) (5, 10) >>> find_closest_ages([0, 120], 120) (0, 120) >>> find_closest_ages([100, 110, 120], 240) (110, 120) >>> find_closest_ages([1, 2, 3], 1) (-1, -1) >>> find_closest_ages([1, 2, 2, 3, 3], 5) (2, 3) >>> find_closest_ages(list(range(1, 10001)), 19999) (9999, 10000)","solution":"def find_closest_ages(ages, target): Returns a tuple of two ages from the list that sum up to the value closest to the target without exceeding it. If no such pair exists, returns (-1, -1). if len(ages) < 2: return (-1, -1) ages.sort() closest_sum = -1 closest_pair = (-1, -1) left = 0 right = len(ages) - 1 while left < right: current_sum = ages[left] + ages[right] if current_sum <= target: if current_sum > closest_sum: closest_sum = current_sum closest_pair = (ages[left], ages[right]) left += 1 else: right -= 1 return closest_pair"},{"question":"class BinaryTree: def __init__(self, values): self.values = values def find_path_to_node(self, target: int) -> List[int]: Returns the path from the root to a target node in the binary tree. >>> bt = BinaryTree([5, 3, 8, 2, 4, 7, 9]) >>> bt.find_path_to_node(7) [5, 8, 7] >>> bt.find_path_to_node(10) [] # Node with value 10 is not present in the tree","solution":"class BinaryTree: def __init__(self, values): self.values = values def find_path_to_node(self, target: int): def dfs(index, path): if index >= len(self.values) or self.values[index] is None: return False path.append(self.values[index]) if self.values[index] == target: return True # Left child index is 2 * index + 1 # Right child index is 2 * index + 2 if dfs(2 * index + 1, path) or dfs(2 * index + 2, path): return True path.pop() return False path = [] if dfs(0, path): return path return []"},{"question":"def is_unique(s: str) -> bool: Determine if all characters in a given string are unique. >>> is_unique(\\"\\") True >>> is_unique(\\"a\\") True >>> is_unique(\\"abcdefg\\") True >>> is_unique(\\"12345\\") True >>> is_unique(\\"AaBbCc\\") True >>> is_unique(\\"aabbcc\\") False >>> is_unique(\\"112233\\") False >>> is_unique(\\"aAaA\\") False >>> is_unique(\\"a\\" * 129) False","solution":"def is_unique(s: str) -> bool: Determine if all characters in a given string are unique. if len(s) > 128: # There are only 128 unique ASCII characters return False for i in range(len(s)): for j in range(i + 1, len(s)): if s[i] == s[j]: return False return True"},{"question":"def find_median_sorted_arrays(nums1: list[int], nums2: list[int]) -> float: Finds the median of two sorted arrays \`nums1\` and \`nums2\`. The overall time complexity should be O(log(min(n, m))). >>> find_median_sorted_arrays([1, 3], [2]) 2.0 >>> find_median_sorted_arrays([1, 2], [3, 4]) 2.5 >>> find_median_sorted_arrays([], [1]) 1.0","solution":"def find_median_sorted_arrays(nums1, nums2): Finds the median of two sorted arrays \`nums1\` and \`nums2\`. The overall time complexity should be O(log(min(n, m))). if len(nums1) > len(nums2): nums1, nums2 = nums2, nums1 x, y = len(nums1), len(nums2) low, high = 0, x while low <= high: partitionX = (low + high) // 2 partitionY = (x + y + 1) // 2 - partitionX maxX = float('-inf') if partitionX == 0 else nums1[partitionX - 1] minX = float('inf') if partitionX == x else nums1[partitionX] maxY = float('-inf') if partitionY == 0 else nums2[partitionY - 1] minY = float('inf') if partitionY == y else nums2[partitionY] if maxX <= minY and maxY <= minX: if (x + y) % 2 == 0: return (max(maxX, maxY) + min(minX, minY)) / 2.0 else: return max(maxX, maxY) elif maxX > minY: high = partitionX - 1 else: low = partitionX + 1 raise ValueError(\\"Input arrays are not sorted.\\")"},{"question":"from typing import List def is_transpose(matrix1: List[List[int]], matrix2: List[List[int]]) -> bool: Returns True if matrix2 is the transpose of matrix1, otherwise False. >>> is_transpose([[1, 2, 3], [4, 5, 6]], [[1, 4], [2, 5], [3, 6]]) True >>> is_transpose([[1, 2], [3, 4]], [[1, 3], [2, 5]]) False >>> is_transpose([[1]], [[1]]) True >>> is_transpose([[1, 2], [3, 4]], [[1, 3], [2, 4]]) True >>> is_transpose([[1, 2, 3]], [[1], [2], [3]]) True","solution":"from typing import List def is_transpose(matrix1: List[List[int]], matrix2: List[List[int]]) -> bool: Returns True if matrix2 is the transpose of matrix1, otherwise False. if len(matrix1) == 0 and len(matrix2) == 0: return True if len(matrix1) == 0 or len(matrix2) == 0 or len(matrix1[0]) != len(matrix2) or len(matrix2[0]) != len(matrix1): return False for i in range(len(matrix1)): for j in range(len(matrix1[0])): if matrix1[i][j] != matrix2[j][i]: return False return True"},{"question":"def validate_unicode_anagrams(s1: str, s2: str) -> bool: Checks if two strings are anagrams of each other, ignoring case. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if the strings are anagrams, False otherwise. Examples: >>> validate_unicode_anagrams(\\"\\", \\"\\") True >>> validate_unicode_anagrams(\\"\\", \\"\\") True >>> validate_unicode_anagrams(\\"abc\\", \\"abcd\\") False >>> validate_unicode_anagrams(\\"rsum\\", \\"sumr\\") True","solution":"def validate_unicode_anagrams(s1: str, s2: str) -> bool: Checks if two strings are anagrams of each other, ignoring case. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if the strings are anagrams, False otherwise. # Normalize by converting both strings to lower case s1 = s1.lower() s2 = s2.lower() # If lengths are different, they cannot be anagrams if len(s1) != len(s2): return False # Count characters in both strings and compare from collections import Counter return Counter(s1) == Counter(s2)"},{"question":"def format_json(json_string: str, indent: int) -> str: Formats a JSON string with proper indentation. Args: json_string (str): A multiline string representing JSON data. indent (int): Number of spaces to be used for each level of indentation. Returns: str: A properly formatted JSON string with correct indentation. Example: >>> json_data = ''' { \\"name\\": \\"John\\", \\"age\\": 30, \\"children\\": [ \\"Ann\\", \\"Billy\\" ], \\"address\\": { \\"city\\": \\"New York\\", \\"zip\\": \\"10001\\" } } ''' >>> format_json(json_data, 4) ''' { \\"name\\": \\"John\\", \\"age\\": 30, \\"children\\": [ \\"Ann\\", \\"Billy\\" ], \\"address\\": { \\"city\\": \\"New York\\", \\"zip\\": \\"10001\\" } } '''","solution":"import json def format_json(json_string: str, indent: int) -> str: Formats a JSON string with proper indentation. Args: json_string (str): A multiline string representing JSON data. indent (int): Number of spaces to be used for each level of indentation. Returns: str: A properly formatted JSON string with correct indentation. # Parse the JSON string into a Python object json_object = json.loads(json_string) # Convert the Python object back into a JSON string with the specified indentation formatted_json_string = json.dumps(json_object, indent=indent) return formatted_json_string"},{"question":"[Completion Task in Python] class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root: TreeNode, val: int) -> TreeNode: Insert a new value into the Binary Search Tree. Args: root (TreeNode): The root node of the BST. val (int): The integer value to be inserted into the BST. Returns: TreeNode: The root node of the BST after insertion. pass def delete_from_bst(root: TreeNode, val: int) -> TreeNode: Delete a value from the Binary Search Tree. Args: root (TreeNode): The root node of the BST. val (int): The integer value to be deleted from the BST. Returns: TreeNode: The root node of the BST after deletion. pass def search_bst(root: TreeNode, val: int) -> bool: Search for a value in the Binary Search Tree. Args: root (TreeNode): The root node of the BST. val (int): The integer value to search for in the BST. Returns: bool: True if the value exists in the BST, otherwise False. pass def find_min(root: TreeNode) -> int: Find the minimum value in the Binary Search Tree. Args: root (TreeNode): The root node of the BST. Returns: int: The minimum value in the BST. pass def find_max(root: TreeNode) -> int: Find the maximum value in the Binary Search Tree. Args: root (TreeNode): The root node of the BST. Returns: int: The maximum value in the BST. pass # You may utilize the test cases provided in the following main function. def main(): # Create an initial BST root = TreeNode(10) root = insert_into_bst(root, 5) root = insert_into_bst(root, 15) root = insert_into_bst(root, 3) root = insert_into_bst(root, 7) root = insert_into_bst(root, 12) root = insert_into_bst(root, 18) # Test search operation assert search_bst(root, 7) == True assert search_bst(root, 20) == False # Test find minimum and maximum assert find_min(root) == 3 assert find_max(root) == 18 # Test delete operation and search again root = delete_from_bst(root, 5) assert search_bst(root, 5) == False print(\\"All test cases passed!\\") if __name__ == \\"__main__\\": main()","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root, val): if root is None: return TreeNode(val) if val < root.val: root.left = insert_into_bst(root.left, val) else: root.right = insert_into_bst(root.right, val) return root def delete_from_bst(root, val): if root is None: return root if val < root.val: root.left = delete_from_bst(root.left, val) elif val > root.val: root.right = delete_from_bst(root.right, val) else: if root.left is None: return root.right elif root.right is None: return root.left min_larger_node = get_min(root.right) root.val = min_larger_node.val root.right = delete_from_bst(root.right, root.val) return root def search_bst(root, val): if root is None: return False if root.val == val: return True elif val < root.val: return search_bst(root.left, val) else: return search_bst(root.right, val) def find_min(root): current = root while current.left is not None: current = current.left return current.val def find_max(root): current = root while current.right is not None: current = current.right return current.val def get_min(node): current = node while current.left is not None: current = current.left return current"},{"question":"from bisect import bisect_left def longest_increasing_subsequence(sequence: list[int]) -> int: Find the length of the longest increasing subsequence in a list of integers. >>> longest_increasing_subsequence([]) == 0 >>> longest_increasing_subsequence([10]) == 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) == 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) == 1 >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> longest_increasing_subsequence([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6","solution":"from bisect import bisect_left def longest_increasing_subsequence(sequence: list[int]) -> int: if not sequence: return 0 sub = [] for num in sequence: i = bisect_left(sub, num) if i < len(sub): sub[i] = num else: sub.append(num) return len(sub)"},{"question":"def roman_to_integer(s: str) -> int: Converts a Roman numeral to an integer. Parameters: s (str): A string representing the Roman numeral. Returns: int: The integer equivalent of the Roman numeral. >>> roman_to_integer('III') 3 >>> roman_to_integer('IV') 4 >>> roman_to_integer('IX') 9 >>> roman_to_integer('LVIII') 58 >>> roman_to_integer('MCMXCIV') 1994 >>> roman_to_integer('MMMDCCCLXXXVIII') 3888 >>> roman_to_integer('CDXLIV') 444 def integer_to_roman(num: int) -> str: Converts an integer to a Roman numeral. Parameters: num (int): An integer between 1 and 3999 (inclusive). Returns: str: The Roman numeral representation of the integer. >>> integer_to_roman(3) 'III' >>> integer_to_roman(4) 'IV' >>> integer_to_roman(9) 'IX' >>> integer_to_roman(58) 'LVIII' >>> integer_to_roman(1994) 'MCMXCIV' >>> integer_to_roman(3888) 'MMMDCCCLXXXVIII' >>> integer_to_roman(444) 'CDXLIV'","solution":"def roman_to_integer(s: str) -> int: Converts a Roman numeral to an integer. Parameters: s (str): A string representing the Roman numeral. Returns: int: The integer equivalent of the Roman numeral. roman_to_int_map = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_to_int_map[char] if value < prev_value: total -= value else: total += value prev_value = value return total def integer_to_roman(num: int) -> str: Converts an integer to a Roman numeral. Parameters: num (int): An integer between 1 and 3999 (inclusive). Returns: str: The Roman numeral representation of the integer. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] symbols = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = \\"\\" i = 0 while num > 0: for _ in range(num // val[i]): roman_numeral += symbols[i] num -= val[i] i += 1 return roman_numeral"},{"question":"from typing import List def minPathSum(grid: List[List[int]]) -> int: Returns the minimum cost to get from the top-left to the bottom-right cell. >>> minPathSum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> minPathSum([ ... [1, 2, 3], ... [4, 5, 6] ... ]) 12 >>> minPathSum([[5]]) 5 >>> minPathSum([[1, 2], [1, 1]]) 3 >>> grid = [[1 for _ in range(50)] for _ in range(50)] ... minPathSum(grid) 99 >>> minPathSum([ ... [4, 7, 8, 6, 4], ... [6, 7, 3, 9, 2], ... [3, 8, 1, 2, 4], ... [7, 1, 7, 3, 7], ... [2, 9, 8, 9, 3] ... ]) 36","solution":"from typing import List def minPathSum(grid: List[List[int]]) -> int: Returns the minimum cost to get from the top-left to the bottom-right cell. n = len(grid) m = len(grid[0]) # Create a 2D DP table initialised to 0. dp = [[0] * m for _ in range(n)] # Initialize the first cell with the grid's first cell value. dp[0][0] = grid[0][0] # Initialize the first row of the DP table. for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize the first column of the DP table. for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the DP table. for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[n - 1][m - 1]"},{"question":"def bubble_sort(arr: list[int]) -> list[int]: Sorts the list using the Bubble Sort algorithm and returns the sorted list. >>> bubble_sort([64, 34, 25, 12, 22, 11, 90]) [11, 12, 22, 25, 34, 64, 90] >>> bubble_sort([5, 1, 4, 2, 8]) [1, 2, 4, 5, 8] # Your code here def insertion_sort(arr: list[int]) -> list[int]: Sorts the list using the Insertion Sort algorithm and returns the sorted list. >>> insertion_sort([64, 34, 25, 12, 22, 11, 90]) [11, 12, 22, 25, 34, 64, 90] >>> insertion_sort([5, 1, 4, 2, 8]) [1, 2, 4, 5, 8] # Your code here def merge_sort(arr: list[int]) -> list[int]: Sorts the list using the Merge Sort algorithm and returns the sorted list. >>> merge_sort([64, 34, 25, 12, 22, 11, 90]) [11, 12, 22, 25, 34, 64, 90] >>> merge_sort([5, 1, 4, 2, 8]) [1, 2, 4, 5, 8] # Your code here def multi_stage_sort(arr: list[int]) -> list[int]: Takes an unsorted list of integers and uses Bubble Sort, Insertion Sort, and Merge Sort in sequence to sort the list. >>> multi_stage_sort([64, 25, 12, 22, 11]) [11, 12, 22, 25, 64] >>> multi_stage_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] # Your code here","solution":"def bubble_sort(arr): Sorts the list using the Bubble Sort algorithm and returns the sorted list. n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if not swapped: break return arr def insertion_sort(arr): Sorts the list using the Insertion Sort algorithm and returns the sorted list. n = len(arr) for i in range(1, n): key = arr[i] j = i-1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def merge_sort(arr): Sorts the list using the Merge Sort algorithm and returns the sorted list. if len(arr) > 1: mid = len(arr) // 2 left_half = arr[:mid] right_half = arr[mid:] merge_sort(left_half) merge_sort(right_half) i = j = k = 0 while i < len(left_half) and j < len(right_half): if left_half[i] < right_half[j]: arr[k] = left_half[i] i += 1 else: arr[k] = right_half[j] j += 1 k += 1 while i < len(left_half): arr[k] = left_half[i] i += 1 k += 1 while j < len(right_half): arr[k] = right_half[j] j += 1 k += 1 return arr def multi_stage_sort(arr): Takes an unsorted list of integers and uses Bubble Sort, Insertion Sort, and Merge Sort in sequence to sort the list. arr = bubble_sort(arr) arr = insertion_sort(arr) arr = merge_sort(arr) return arr"},{"question":"# Problem Statement: You are working on a file system analysis tool to help users understand their disk usage. Your tool should analyze a directory structure and compute the size of each directory, taking into account all files and subdirectories within it. # Objective: Write a function \`directory_size_analysis\` that accepts the following parameters: 1. **root_directory**: str - The path to the root directory from which the analysis should start. The function performs the following tasks: 1. Traverse the directory structure starting from the \`root_directory\`. 2. Compute the total size of each directory by summing the sizes of all files contained within it and its subdirectories. 3. Return a dictionary where the keys are directory paths and the values are their corresponding sizes in bytes. Constraints: 1. If a directory is empty, its size should be 0. 2. Account for hidden files and directories as well. 3. Handle possible errors gracefully, e.g., permissions issues, by skipping directories that cannot be accessed but continuing the analysis. 4. Symlinks may be ignored for simplicity. # Input/Output: Input: * A single string representing the root directory path. Output: * Dictionary: The keys are the directory paths (str) discovered during the traversal, and the values are their sizes (int) in bytes. # Example: # Assuming the following directory structure and sizes: # /root # |-- /subdir1 # | |-- file1.txt (100 bytes) # | |-- file2.txt (200 bytes) # |-- /subdir2 # | |-- file3.txt (300 bytes) # | |-- /subsubdir1 # | |-- file4.txt (400 bytes) # |-- file5.txt (500 bytes) result = directory_size_analysis(\\"/root\\") print(result) # Expected output: # { # \\"/root\\": 1500, # \\"/root/subdir1\\": 300, # \\"/root/subdir2\\": 700, # \\"/root/subdir2/subsubdir1\\": 400 # } # Your Task: Write the function \`directory_size_analysis\` that implements the specification detailed above.","solution":"import os def directory_size_analysis(root_directory): Computes the size of each directory starting from the root directory. Parameters: - root_directory (str): The path to the root directory from which the analysis starts. Returns: - dict: A dictionary where the keys are directory paths and the values are their corresponding sizes in bytes. directory_sizes = {} def calculate_directory_size(directory): total_size = 0 try: for entry in os.scandir(directory): if entry.is_dir(follow_symlinks=False): # Recursively calculate the size of the subdirectory total_size += calculate_directory_size(entry.path) elif entry.is_file(follow_symlinks=False): # Add file size total_size += entry.stat().st_size except PermissionError: # Skip directories that cannot be accessed due to permissions return 0 directory_sizes[directory] = total_size return total_size calculate_directory_size(root_directory) return directory_sizes"},{"question":"from typing import List def calculate_waiting_times(priorities: List[int], duration_times: List[int]) -> List[int]: Calculate the waiting times for each task based on their priority and duration times. Input: priorities (List[int]): The priority of each task. duration_times (List[int]): The duration times for each task. Output: List[int]: The waiting times for each task. >>> calculate_waiting_times([2, 1, 3], [5, 10, 15]) [10, 0, 15] >>> calculate_waiting_times([1, 2, 1], [7, 5, 8]) [0, 15, 7] pass def calculate_turnaround_times(duration_times: List[int], waiting_times: List[int]) -> List[int]: Calculate the turnaround times for each task based on their duration times and waiting times. Input: duration_times (List[int]): The duration times for each task. waiting_times (List[int]): The waiting times for each task. Output: List[int]: The turnaround times for each task. >>> calculate_turnaround_times([5, 10, 15], [10, 0, 15]) [15, 10, 30] >>> calculate_turnaround_times([7, 5, 8], [0, 15, 7]) [7, 20, 15] pass def calculate_average_turnaround_time(turnaround_times: List[int]) -> float: Calculate the average turnaround time from a list of turnaround times. Input: turnaround_times (List[int]): The turnaround times for each task. Output: float: The average turnaround time. >>> calculate_average_turnaround_time([15, 10, 30]) 18.333333333333332 >>> calculate_average_turnaround_time([7, 20, 15]) 14.0 pass def calculate_average_waiting_time(waiting_times: List[int]) -> float: Calculate the average waiting time from a list of waiting times. Input: waiting_times (List[int]): The waiting times for each task. Output: float: The average waiting time. >>> calculate_average_waiting_time([10, 0, 15]) 8.333333333333334 >>> calculate_average_waiting_time([0, 15, 7]) 7.333333333333333 pass","solution":"from typing import List def calculate_waiting_times(priorities: List[int], duration_times: List[int]) -> List[int]: indexed_tasks = list(enumerate(zip(priorities, duration_times))) sorted_tasks = sorted(indexed_tasks, key=lambda x: (x[1][0], x)) waiting_times = [0] * len(priorities) elapsed_time = 0 for index, (_, duration) in sorted_tasks: waiting_times[index] = elapsed_time elapsed_time += duration return waiting_times def calculate_turnaround_times(duration_times: List[int], waiting_times: List[int]) -> List[int]: return [d + w for d, w in zip(duration_times, waiting_times)] def calculate_average_turnaround_time(turnaround_times: List[int]) -> float: return sum(turnaround_times) / len(turnaround_times) def calculate_average_waiting_time(waiting_times: List[int]) -> float: return sum(waiting_times) / len(waiting_times)"},{"question":"from typing import List, Dict def classify_weights(weights: List[float]) -> Dict[str, int]: Classifies the given weights into 'Light', 'Medium', 'Heavy', and 'Very Heavy' categories. >>> classify_weights([0.5, 1.0, 9.9, 10.0, 24.5, 30.0]) {'Light': 1, 'Medium': 2, 'Heavy': 2, 'Very Heavy': 1} >>> classify_weights([15.0, 25.0, 25.5, 0.5, 10.0, 5.5, 35.0]) {'Light': 1, 'Medium': 2, 'Heavy': 2, 'Very Heavy': 2}","solution":"from typing import List, Dict def classify_weights(weights: List[float]) -> Dict[str, int]: Classifies the given weights into 'Light', 'Medium', 'Heavy', and 'Very Heavy' categories. categories = { 'Light': 0, 'Medium': 0, 'Heavy': 0, 'Very Heavy': 0 } for weight in weights: if weight < 1: categories['Light'] += 1 elif 1 <= weight < 10: categories['Medium'] += 1 elif 10 <= weight < 25: categories['Heavy'] += 1 else: categories['Very Heavy'] += 1 return categories"},{"question":"from typing import List def most_set_bits(numbers: List[str]) -> int: Given a list of strings representing integers, determine which binary representation of these numbers contains the most set bits (1s). If there is a tie, return the smallest integer among them. >>> most_set_bits(['1', '2', '3', '4', '7']) 7 >>> most_set_bits(['10', '15', '20', '30']) 15 >>> most_set_bits(['8', '16', '32', '64']) 8 >>> most_set_bits(['5', '6', '9', '10']) 9","solution":"from typing import List def most_set_bits(numbers: List[str]) -> int: def count_set_bits(n: int) -> int: return bin(n).count('1') max_set_bits = -1 result = float('inf') for num_str in numbers: num = int(num_str) set_bits = count_set_bits(num) if set_bits > max_set_bits or (set_bits == max_set_bits and num < result): max_set_bits = set_bits result = num return result"},{"question":"# Implement a class \`AlertManager\` using a priority queue data structure to efficiently manage alerts. The queue must support the following operations: 1. **Add an alert**: Insert an alert with its timestamp and priority into the system. 2. **Deactivate highest priority**: Remove and return the oldest alert with the highest priority. 3. **Get current highest priority**: Retrieve but do not remove the oldest alert with the highest priority. Alerts consist of a description string, a timestamp, and a priority value. Implement methods with the following signatures: class AlertManager: def add_alert(self, description: str, timestamp: int, priority: int) -> None: pass def deactivate_highest_priority(self) -> str: pass def get_current_highest_priority(self) -> str: pass # Example manager = AlertManager() manager.add_alert(\\"Alert1\\", 1000, 5) manager.add_alert(\\"Alert2\\", 2000, 10) manager.add_alert(\\"Alert3\\", 1500, 5) print(manager.get_current_highest_priority()) # Output: \\"Alert2\\" print(manager.deactivate_highest_priority()) # Output: \\"Alert2\\" print(manager.get_current_highest_priority()) # Output: \\"Alert1\\" Use the following unit tests to validate your solution: from solution import AlertManager def test_add_alert(): manager = AlertManager() manager.add_alert(\\"Alert1\\", 1000, 5) assert len(manager.heap) == 1 assert manager.heap[0] == (-5, 1000, \\"Alert1\\") def test_deactivate_highest_priority(): manager = AlertManager() manager.add_alert(\\"Alert1\\", 1000, 5) manager.add_alert(\\"Alert2\\", 2000, 10) manager.add_alert(\\"Alert3\\", 1500, 5) assert manager.deactivate_highest_priority() == \\"Alert2\\" assert manager.deactivate_highest_priority() == \\"Alert1\\" assert manager.deactivate_highest_priority() == \\"Alert3\\" assert manager.deactivate_highest_priority() is None def test_get_current_highest_priority(): manager = AlertManager() manager.add_alert(\\"Alert1\\", 1000, 5) manager.add_alert(\\"Alert2\\", 2000, 10) manager.add_alert(\\"Alert3\\", 1500, 5) assert manager.get_current_highest_priority() == \\"Alert2\\" manager.deactivate_highest_priority() assert manager.get_current_highest_priority() == \\"Alert1\\" manager.deactivate_highest_priority() assert manager.get_current_highest_priority() == \\"Alert3\\" manager.deactivate_highest_priority() assert manager.get_current_highest_priority() is None def test_priority_with_same_priority(): manager = AlertManager() manager.add_alert(\\"Alert1\\", 1000, 5) manager.add_alert(\\"Alert3\\", 1500, 5) manager.add_alert(\\"Alert2\\", 2000, 5) assert manager.get_current_highest_priority() == \\"Alert1\\" assert manager.deactivate_highest_priority() == \\"Alert1\\" assert manager.get_current_highest_priority() == \\"Alert3\\" assert manager.deactivate_highest_priority() == \\"Alert3\\" assert manager.get_current_highest_priority() == \\"Alert2\\" assert manager.deactivate_highest_priority() == \\"Alert2\\" assert manager.get_current_highest_priority() is None","solution":"import heapq class AlertManager: def __init__(self): # Use a min-heap where each element is a tuple (-priority, timestamp, description) # We use -priority to simulate a max-heap self.heap = [] def add_alert(self, description: str, timestamp: int, priority: int) -> None: heapq.heappush(self.heap, (-priority, timestamp, description)) def deactivate_highest_priority(self) -> str: if not self.heap: return None return heapq.heappop(self.heap)[2] def get_current_highest_priority(self) -> str: if not self.heap: return None return self.heap[0][2]"},{"question":"def is_rotation(array1: list[int], array2: list[int]) -> bool: Checks if array2 is a rotation of array1. Parameters: - array1 (list[int]): The original array. - array2 (list[int]): The array to check if it is a rotation of the original array. Returns: - bool: True if array2 is a rotation of array1, False otherwise. >>> is_rotation([1, 2, 3, 4, 5], [3, 4, 5, 1, 2]) True >>> is_rotation([1, 2, 3, 4, 5], [3, 4, 5, 6, 2]) False","solution":"def is_rotation(array1: list[int], array2: list[int]) -> bool: Checks if array2 is a rotation of array1. if len(array1) != len(array2): return False # Concatenate array1 to itself concatenated = array1 + array1 # Convert lists to strings to use substring check str_concat = '-'.join(map(str, concatenated)) str_array2 = '-'.join(map(str, array2)) return str_array2 in str_concat"},{"question":"from typing import List def format_names(names: List[str]) -> str: Reformats a list of names into 'Last, First' format, sorts them alphabetically, and joins them with semicolons. >>> format_names([\\"John Doe\\"]) \\"Doe, John\\" >>> format_names([\\"John Doe\\", \\"Jane Smith\\", \\"Alice Johnson\\", \\"Michael Jordan\\"]) \\"Doe, John; Johnson, Alice; Jordan, Michael; Smith, Jane\\" >>> format_names([\\"John Zane\\", \\"Michael Young\\", \\"Alice Adams\\"]) \\"Adams, Alice; Young, Michael; Zane, John\\" >>> format_names([\\"John Doe\\", \\"Jane Doe\\"]) \\"Doe, Jane; Doe, John\\" >>> format_names([\\"John Doe\\", \\"John Doe\\"]) \\"Doe, John; Doe, John\\"","solution":"from typing import List def format_names(names: List[str]) -> str: Reformats a list of names into 'Last, First' format, sorts them alphabetically, and joins them with semicolons. formatted_names = [] for name in names: first_name, last_name = name.split() formatted_names.append(f\\"{last_name}, {first_name}\\") sorted_names = sorted(formatted_names) return \\"; \\".join(sorted_names)"},{"question":"import numpy as np from typing import Tuple def k_means_clustering(data: np.ndarray, k: int, max_iter: int = 300) -> Tuple[np.ndarray, np.ndarray]: Perform K-Means clustering on a dataset. Args: - data (np.ndarray): A 2D numpy array of shape (n_samples, n_features), where n_samples is the number of customers and n_features is the number of attributes for each customer. - k (int): An integer representing the number of clusters. - max_iter (int): An optional integer representing the maximum number of iterations. Default is 300. Returns: - A tuple containing: - centroids (np.ndarray): A 2D numpy array of shape (k, n_features) containing the final centroids of the clusters. - labels (np.ndarray): A 1D numpy array of shape (n_samples,) where each element is the cluster label (ranging from 0 to k-1) for the corresponding customer. >>> import numpy as np >>> data = np.array([[25, 50000], [34, 60000], [22, 52000], [27, 58000], [30, 61000], [26, 50000], [29, 69000], [35, 72000]]) >>> k = 3 >>> centroids, labels = k_means_clustering(data, k) >>> centroids.shape == (k, data.shape[1]) True >>> labels.shape == (data.shape[0],) True","solution":"import numpy as np from typing import Tuple def k_means_clustering(data: np.ndarray, k: int, max_iter: int = 300) -> Tuple[np.ndarray, np.ndarray]: def initialize_centroids(data, k): indices = np.random.choice(data.shape[0], k, replace=False) return data[indices] def compute_distances(data, centroids): distances = np.zeros((data.shape[0], centroids.shape[0])) for i in range(centroids.shape[0]): distances[:, i] = np.linalg.norm(data - centroids[i], axis=1) return distances def assign_clusters(distances): return np.argmin(distances, axis=1) def compute_centroids(data, labels, k): centroids = np.zeros((k, data.shape[1])) for i in range(k): centroids[i] = data[labels == i].mean(axis=0) return centroids centroids = initialize_centroids(data, k) for i in range(max_iter): old_centroids = centroids distances = compute_distances(data, centroids) labels = assign_clusters(distances) centroids = compute_centroids(data, labels, k) if np.all(centroids == old_centroids): # If centroids do not change, break break return centroids, labels"},{"question":"def sum_of_unique_squares(numbers: list[int]) -> int: Returns the sum of squares of the unique integers in the list. :param numbers: A list of integers. :return: Sum of squares of unique integers in the list. :raises TypeError: If the input is not a list of integers. Examples: >>> sum_of_unique_squares([1, 2, 2, 3]) 10 >>> sum_of_unique_squares([0, 0, -1, 1]) 2 >>> sum_of_unique_squares([1, 1, 1, 1, 1]) 0 >>> sum_of_unique_squares([-2, -1, 1, 2, -2]) 6 >>> sum_of_unique_squares([]) 0","solution":"def sum_of_unique_squares(numbers: list[int]) -> int: Returns the sum of squares of the unique integers in the list. :param numbers: A list of integers. :return: Sum of squares of unique integers in the list. :raises TypeError: If the input is not a list of integers. if not isinstance(numbers, list): raise TypeError(\\"Input must be a list.\\") for num in numbers: if not isinstance(num, int): raise TypeError(\\"All elements in the list must be integers.\\") from collections import Counter counter = Counter(numbers) unique_integers = [num for num, count in counter.items() if count == 1] return sum(num ** 2 for num in unique_integers)"},{"question":"def find_longest_word(text: str) -> str: Finds the longest unique word in the input text. If multiple words have the same maximum length, return the first one encountered. The search is case-insensitive but retains the original casing for the result. >>> find_longest_word(\\"The quick brown fox jumped over the lazy dogs.\\") == \\"jumped\\" >>> find_longest_word(\\"Hello! Is anyone there? This is a text... with various delimiters.\\") == \\"delimiters\\" >>> find_longest_word(\\"He said, 'Its an emergency!' and left.\\") == \\"emergency\\" >>> find_longest_word(\\"Life, liberty and the pursuit of happiness.\\") == \\"happiness\\"","solution":"import re def find_longest_word(text): Finds the longest unique word in the input text. If multiple words have the same maximum length, return the first one encountered. The search is case-insensitive but retains the original casing for the result. Parameters: text (str): A string of characters, possibly including punctuation and whitespace. Returns: str: The longest unique word. # Use regex to find all words (sequences of alphabetic characters) words = re.findall(r'[a-zA-Z]+', text) # Create a set for uniqueness and transform words to lower case for comparison seen = set() longest_word = \\"\\" for word in words: lower_word = word.lower() if lower_word not in seen: seen.add(lower_word) if len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"class Node: def __init__(self, value: int, priority: int): Initialize a Node with a value and priority. pass class PriorityQueue: def __init__(self): Initialize an empty Priority Queue. pass def add_node(self, value: int, priority: int) -> None: Adds a node with the given value and priority to the priority queue. >>> pq = PriorityQueue() >>> pq.add_node(10, 3) >>> pq.add_node(15, 4) >>> pq.add_node(5, 1) >>> pq.add_node(20, 2) pass def peek(self) -> int: Retrieves the value of the node with the highest priority without removing it. >>> pq = PriorityQueue() >>> pq.add_node(15, 4) >>> pq.peek() 15 Raises: Exception: If the queue is empty. pass def extract(self) -> int: Retrieves and removes the node with the highest priority from the priority queue. >>> pq = PriorityQueue() >>> pq.add_node(15, 4) >>> pq.extract() 15 Raises: Exception: If the queue is empty. pass","solution":"class Node: def __init__(self, value, priority): self.value = value self.priority = priority class PriorityQueue: def __init__(self): self.heap = [] def add_node(self, value, priority): new_node = Node(value, priority) self.heap.append(new_node) self._sift_up(len(self.heap) - 1) def peek(self): if not self.heap: raise Exception(\\"Priority queue is empty\\") return self.heap[0].value def extract(self): if not self.heap: raise Exception(\\"Priority queue is empty\\") if len(self.heap) == 1: return self.heap.pop().value root_value = self.heap[0].value self.heap[0] = self.heap.pop() self._sift_down(0) return root_value def _sift_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index].priority > self.heap[parent_index].priority: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._sift_up(parent_index) def _sift_down(self, index): left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 largest = index if (left_child_index < len(self.heap) and self.heap[left_child_index].priority > self.heap[largest].priority): largest = left_child_index if (right_child_index < len(self.heap) and self.heap[right_child_index].priority > self.heap[largest].priority): largest = right_child_index if largest != index: self.heap[index], self.heap[largest] = self.heap[largest], self.heap[index] self._sift_down(largest)"},{"question":"from typing import List, Tuple def find_shortest_path(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> List[Tuple[int, int]]: Find the shortest path in a 2D grid using A* algorithm. Args: grid (List[List[int]]): A 2D list of integers representing the grid where 0 is a walkable cell and 1 is an obstacle. start (Tuple[int, int]): A tuple (x, y) representing the starting coordinates. target (Tuple[int, int]): A tuple (x, y) representing the target coordinates. Returns: List[Tuple[int, int]]: A list of tuples representing the shortest path from the start to the target, inclusive of both. Returns an empty list if no path exists. Examples: >>> find_shortest_path([[0, 0], [0, 0]], (0, 0), (1, 1)) [(0, 0), (0, 1), (1, 1)] or [(0, 0), (1, 0), (1, 1)] >>> find_shortest_path([[0, 1], [1, 0]], (0, 0), (1, 1)) [] pass def test_simple_case(): grid = [ [0, 0], [0, 0] ] start = (0, 0) target = (1, 1) assert find_shortest_path(grid, start, target) == [(0, 0), (0, 1), (1, 1)] or find_shortest_path(grid, start, target) == [(0, 0), (1, 0), (1, 1)] def test_with_obstacles(): grid = [ [0, 1], [1, 0] ] start = (0, 0) target = (1, 1) assert find_shortest_path(grid, start, target) == [] def test_complex_path(): grid = [ [0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] start = (0, 0) target = (4, 4) result = find_shortest_path(grid, start, target) expected = [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (2, 3), (2, 4), (3, 4), (4, 4)] assert result == expected or result == [(0, 0), (1, 2), (2, 2), (3, 2), (4, 3), (4, 4)] def test_start_is_target(): grid = [ [0, 0], [0, 0] ] start = (0, 0) target = (0, 0) assert find_shortest_path(grid, start, target) == [(0, 0)] def test_no_possible_path(): grid = [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ] start = (0, 0) target = (2, 2) assert find_shortest_path(grid, start, target) == []","solution":"from typing import List, Tuple import heapq def find_shortest_path(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> List[Tuple[int, int]]: def h(pos: Tuple[int, int]) -> int: # Heuristic function: Manhattan distance to the target return abs(pos[0] - target[0]) + abs(pos[1] - target[1]) def get_neighbors(pos: Tuple[int, int]) -> List[Tuple[int, int]]: x, y = pos neighbors = [] for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 0: neighbors.append((nx, ny)) return neighbors open_set = [] came_from = {} g_score = {start: 0} f_score = {start: h(start)} heapq.heappush(open_set, (f_score[start], start)) while open_set: _, current = heapq.heappop(open_set) if current == target: # Reconstruct path path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) return path[::-1] for neighbor in get_neighbors(current): tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + h(neighbor) if all(neighbor != item[1] for item in open_set): heapq.heappush(open_set, (f_score[neighbor], neighbor)) return []"},{"question":"from typing import List class Matrix: def __init__(self, data: List[List[float]]): Initializes the matrix with the given data, which is a two-dimensional list of floats. pass def transpose(self) -> 'Matrix': Returns the transpose of the matrix. pass def determinant(self) -> float: Returns the determinant of the matrix. If the matrix is not square, it should raise a ValueError with a descriptive message. pass def add(self, other: 'Matrix') -> 'Matrix': Adds the current matrix with another matrix and returns the resultant matrix. If the dimensions do not match, it should raise a ValueError with a descriptive message. pass def multiply(self, other: 'Matrix') -> 'Matrix': Multiplies the current matrix with another matrix and returns the resultant matrix. If the dimensions do not allow matrix multiplication, it should raise a ValueError with a descriptive message. pass def test_matrix_init(): data = [[1, 2], [3, 4]] matrix = Matrix(data) assert matrix.data == data def test_matrix_transpose(): data = [[1, 2], [3, 4]] matrix = Matrix(data) transposed = matrix.transpose() assert transposed.data == [[1, 3], [2, 4]] def test_matrix_determinant(): data = [[1, 2], [3, 4]] matrix = Matrix(data) assert matrix.determinant() == -2.0 def test_matrix_determinant_3x3(): data = [[6, 1, 1], [4, -2, 5], [2, 8, 7]] matrix = Matrix(data) assert matrix.determinant() == -306.0 def test_matrix_add(): data1 = [[1, 2], [3, 4]] data2 = [[5, 6], [7, 8]] matrix1 = Matrix(data1) matrix2 = Matrix(data2) added = matrix1.add(matrix2) assert added.data == [[6, 8], [10, 12]] def test_matrix_multiply(): data1 = [[1, 2], [3, 4]] data2 = [[5, 6], [7, 8]] matrix1 = Matrix(data1) matrix2 = Matrix(data2) product = matrix1.multiply(matrix2) assert product.data == [[19, 22], [43, 50]] def test_invalid_matrix_data(): try: Matrix([[1, 2], [3]]) except ValueError as e: assert str(e) == \\"Invalid matrix data\\" def test_non_square_determinant(): try: non_square_matrix = Matrix([[1, 2, 3], [4, 5, 6]]) non_square_matrix.determinant() except ValueError as e: assert str(e) == \\"Determinant can only be calculated for square matrices\\" def test_mismatched_matrix_addition(): try: matrix1 = Matrix([[1, 2], [3, 4]]) mismatched_matrix = Matrix([[1, 2, 3], [4, 5, 6]]) matrix1.add(mismatched_matrix) except ValueError as e: assert str(e) == \\"Matrices must have the same dimensions for addition\\" def test_incompatible_matrix_multiplication(): try: matrix1 = Matrix([[1, 2], [3, 4]]) incompatible_matrix = Matrix([[1], [2], [3]]) matrix1.multiply(incompatible_matrix) except ValueError as e: assert str(e) == \\"Matrices have incompatible dimensions for multiplication\\"","solution":"from typing import List class Matrix: def __init__(self, data: List[List[float]]): # Validate the matrix row_len = len(data[0]) for row in data: if len(row) != row_len: raise ValueError(\\"Invalid matrix data\\") self.data = data self.rows = len(data) self.cols = len(data[0]) def transpose(self) -> 'Matrix': transposed_data = [[self.data[j][i] for j in range(self.rows)] for i in range(self.cols)] return Matrix(transposed_data) def determinant(self) -> float: if self.rows != self.cols: raise ValueError(\\"Determinant can only be calculated for square matrices\\") return self._calculate_determinant(self.data) def _calculate_determinant(self, matrix: List[List[float]]) -> float: # base case for 2x2 matrix if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] determinant = 0 for c in range(len(matrix)): sub_matrix = [row[:c] + row[c+1:] for row in matrix[1:]] sign = (-1) ** c determinant += sign * matrix[0][c] * self._calculate_determinant(sub_matrix) return determinant def add(self, other: 'Matrix') -> 'Matrix': if self.rows != other.rows or self.cols != other.cols: raise ValueError(\\"Matrices must have the same dimensions for addition\\") added_data = [[self.data[i][j] + other.data[i][j] for j in range(self.cols)] for i in range(self.rows)] return Matrix(added_data) def multiply(self, other: 'Matrix') -> 'Matrix': if self.cols != other.rows: raise ValueError(\\"Matrices have incompatible dimensions for multiplication\\") product_data = [[sum(self.data[i][k] * other.data[k][j] for k in range(self.cols)) for j in range(other.cols)] for i in range(self.rows)] return Matrix(product_data)"},{"question":"def can_form_palindrome(s: str) -> bool: Determine if a given string can be rearranged to form a palindrome using a dictionary-based approach. >>> can_form_palindrome(\\"civic!\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"A man, a plan, a canal: Panama\\") True def can_form_palindrome_bit(s: str) -> bool: Determine if a given string can be rearranged to form a palindrome using a bit manipulation approach. >>> can_form_palindrome_bit(\\"civic!\\") True >>> can_form_palindrome_bit(\\"ivicc\\") True >>> can_form_palindrome_bit(\\"hello\\") False >>> can_form_palindrome_bit(\\"A man, a plan, a canal: Panama\\") True def benchmark_palindrome() -> None: Benchmark the performance of the two implementations for large strings.","solution":"import time from collections import Counter def can_form_palindrome(s: str) -> bool: Determine if a given string can be rearranged to form a palindrome using a dictionary-based approach. s = ''.join(filter(str.isalpha, s)).lower() count = Counter(s) odd_count = sum(1 for cnt in count.values() if cnt % 2 != 0) return odd_count <= 1 def can_form_palindrome_bit(s: str) -> bool: Determine if a given string can be rearranged to form a palindrome using a bit manipulation approach. s = ''.join(filter(str.isalpha, s)).lower() bit_vector = 0 for char in s: mask = 1 << (ord(char) - ord('a')) bit_vector ^= mask # check if at most one bit is set in bit_vector return bit_vector == 0 or (bit_vector & (bit_vector - 1)) == 0 def benchmark_palindrome() -> None: Benchmark the performance of the two implementations for large strings. strings = [ \\"a\\" * 50000 + \\"b\\" * 50000, \\"ab\\" * 25000 + \\"cd\\" * 25000 + \\"efg\\" * 10000, ''.join(chr(65 + (i % 58)) for i in range(100000)) # Random string of length 100,000 ] for i, s in enumerate(strings, 1): print(f\\"Benchmarking string {i} of length {len(s)}\\") start = time.time() res_dict = can_form_palindrome(s) time_dict = time.time() - start start = time.time() res_bit = can_form_palindrome_bit(s) time_bit = time.time() - start assert res_dict == res_bit, \\"Results do not match between the two methods\\" print(f\\"Dict-based approach: {time_dict:.5f} sec\\") print(f\\"Bit-based approach: {time_bit:.5f} sec\\")"},{"question":"from typing import List def max_non_adjacent_sum(nums: List[int]) -> int: Calculate the maximum sum of non-adjacent elements in a list of integers. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([3, 2, 7, 10]) 13 >>> max_non_adjacent_sum([5, 5, 10, 100, 10, 5]) 110 >>> max_non_adjacent_sum([-2, 1, 3, -4, 5]) 8 >>> max_non_adjacent_sum([5, 1, 1, 5]) 10 pass def test_single_element(): assert max_non_adjacent_sum([5]) == 5 assert max_non_adjacent_sum([-1]) == 0 def test_two_elements(): assert max_non_adjacent_sum([3, 2]) == 3 assert max_non_adjacent_sum([2, 3]) == 3 def test_multiple_elements(): assert max_non_adjacent_sum([3, 2, 5, 10, 7]) == 15 assert max_non_adjacent_sum([3, 2, 7, 10]) == 13 assert max_non_adjacent_sum([5, 5, 10, 100, 10, 5]) == 110 assert max_non_adjacent_sum([-2, 1, 3, -4, 5]) == 8 assert max_non_adjacent_sum([5, 1, 1, 5]) == 10 def test_large_input(): large_input = [1000] * 100000 assert max_non_adjacent_sum(large_input) == 50000 * 1000 def test_edge_cases(): assert max_non_adjacent_sum([]) == 0 assert max_non_adjacent_sum([0]) == 0 assert max_non_adjacent_sum([-1, -2, -3]) == 0 assert max_non_adjacent_sum([1, 2, 3, 4, 5]) == 9","solution":"from typing import List def max_non_adjacent_sum(nums: List[int]) -> int: if not nums: return 0 if len(nums) == 1: return max(0, nums[0]) inclusive = 0 exclusive = 0 for num in nums: new_exclusive = max(inclusive, exclusive) inclusive = exclusive + num exclusive = new_exclusive return max(inclusive, exclusive)"},{"question":"import heapq from typing import List def find_kth_largest(nums: List[int], k: int) -> int: Finds the k-th largest element in the array nums. :param nums: List[int] - The array of integers. :param k: int - The k-th largest position to find. :return: int - The k-th largest element. >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4 pass def test_find_kth_largest_example1(): assert find_kth_largest([3, 2, 1, 5, 6, 4], 2) == 5 def test_find_kth_largest_example2(): assert find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) == 4 def test_find_kth_largest_single_element(): assert find_kth_largest([1], 1) == 1 def test_find_kth_largest_all_duplicates(): assert find_kth_largest([2, 2, 2, 2, 2], 3) == 2 def test_find_kth_largest_large_k(): assert find_kth_largest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == 1 def test_find_kth_largest_various_elements(): assert find_kth_largest([5, 3, 7, 6, 9, 8], 3) == 7 def test_find_kth_largest_negative_numbers(): assert find_kth_largest([-1, -2, -3, -4, -5], 2) == -2","solution":"import heapq def find_kth_largest(nums, k): Finds the k-th largest element in the array nums. :param nums: List[int] - The array of integers. :param k: int - The k-th largest position to find. :return: int - The k-th largest element. # Using a min-heap to maintain the k largest elements found so far min_heap = nums[:k] heapq.heapify(min_heap) for num in nums[k:]: if num > min_heap[0]: heapq.heapreplace(min_heap, num) return min_heap[0]"},{"question":"def paginate(items: list, page_number: int, page_size: int) -> list: Simulates a basic pagination system for a list of items. Args: items (list): A list of items (strings). page_number (int): The current page number (1-based). page_size (int): The number of items to display per page. Returns: list: A list of strings representing the items on the specified page. Example: >>> items = [\\"item1\\", \\"item2\\", \\"item3\\", \\"item4\\", \\"item5\\", \\"item6\\", \\"item7\\"] >>> paginate(items, 2, 3) [\\"item4\\", \\"item5\\", \\"item6\\"] >>> paginate(items, 1, 3) [\\"item1\\", \\"item2\\", \\"item3\\"] >>> paginate(items, 3, 3) [\\"item7\\"] >>> paginate(items, 5, 3) [] >>> paginate(items, 2, -1) [] >>> paginate(items, 0, 3) [] >>> paginate(items, 2, 0) [] >>> paginate([], 1, 3) [] >>> paginate([\\"item1\\", \\"item2\\", \\"item3\\"], 1, 5) [\\"item1\\", \\"item2\\", \\"item3\\"] >>> paginate([\\"item1\\", \\"item2\\", \\"item3\\", \\"item4\\", \\"item5\\"], 3, 2) [\\"item5\\"]","solution":"def paginate(items: list, page_number: int, page_size: int) -> list: if page_number <= 0 or page_size <= 0: return [] start_index = (page_number - 1) * page_size end_index = start_index + page_size return items[start_index:end_index]"},{"question":"def find_unique(collection): :param collection: sorted list of integers :return: single integer that appears only once # Implement your binary search logic here pass # Unit Tests def test_find_unique_single_element(): assert find_unique([1]) == 1 def test_find_unique_basic(): assert find_unique([1, 1, 2, 2, 3, 3, 4, 4, 5]) == 5 assert find_unique([0, 0, 1, 1, 2, 2, 3]) == 3 def test_find_unique_varied_positions(): assert find_unique([1, 1, 3, 3, 4, 5, 5]) == 4 assert find_unique([1, 1, 2, 3, 3, 4, 4]) == 2 assert find_unique([1, 2, 2, 3, 3, 4, 4]) == 1 assert find_unique([0, 1, 1, 2, 2, 3, 3]) == 0 def test_find_unique_large_input(): input_data = list(range(1, 100000)) * 2 + [100000] input_data.sort() assert find_unique(input_data) == 100000","solution":"def find_unique(collection): Find the single integer in the sorted list that appears only once. :param collection: sorted list of integers :return: single integer that appears only once left, right = 0, len(collection) - 1 while left < right: mid = (left + right) // 2 # Ensure mid is even so pairs start at even indices if mid % 2 == 1: mid -= 1 if collection[mid] == collection[mid + 1]: left = mid + 2 else: right = mid return collection[left]"},{"question":"def minimize_servers(tasks: List[int], capacity: int) -> int: Returns the minimum number of servers required to handle all the tasks without exceeding the capacity of any server. :param tasks: List[int] - A list of positive integers representing the load of each task. :param capacity: int - A positive integer representing the maximum capacity of each server. :return: int - The minimum number of servers needed. >>> minimize_servers([1, 2, 3, 4, 5, 6, 7, 8, 9], 10) 5 >>> minimize_servers([9, 9, 9, 9, 9], 10) 5 >>> minimize_servers([1, 2, 3, 4, 5], 15) 1 def test_example_cases(): assert minimize_servers([1, 2, 3, 4, 5, 6, 7, 8, 9], 10) == 5 assert minimize_servers([9, 9, 9, 9, 9], 10) == 5 assert minimize_servers([1, 2, 3, 4, 5], 15) == 1 def test_edge_cases(): assert minimize_servers([10], 10) == 1 # Single task exactly equal to capacity assert minimize_servers([1], 10) == 1 # Single task much less than capacity assert minimize_servers([5, 5, 5, 5, 5], 5) == 5 # Tasks equal to half of capacity, each need separate server def test_large_input(): tasks = [1] * 100000 # 100000 tasks with load 1 each capacity = 10000 assert minimize_servers(tasks, capacity) == 10 # Should take 10 servers def test_mixed_large_input(): tasks = [500, 5000, 1000, 2000, 3000, 4000, 6000, 7000, 8000, 9000, 10000] * 10 capacity = 10000 assert minimize_servers(tasks, capacity) # This should utilize servers efficiently def test_all_equal_to_capacity(): assert minimize_servers([10, 10, 10, 10, 10], 10) == 5 # Each task is exactly the capacity assert minimize_servers([20, 20, 20, 20, 20], 20) == 5 # Each task is exactly the capacity","solution":"def minimize_servers(tasks, capacity): Returns the minimum number of servers required to handle all the tasks without exceeding the capacity of any server. :param tasks: List[int] - A list of positive integers representing the load of each task. :param capacity: int - A positive integer representing the maximum capacity of each server. :return: int - The minimum number of servers needed. tasks.sort(reverse=True) # Sort tasks in descending order servers = [] for task in tasks: placed = False for i, server in enumerate(servers): if server + task <= capacity: servers[i] += task placed = True break if not placed: servers.append(task) return len(servers)"},{"question":"def replace_negatives(matrix: list[list[int]]) -> list[list[int]]: Replace negative numbers in a 2D list with zero. :param matrix: List of lists of integers :return: Modified list with negatives replaced by zero >>> replace_negatives([[1, -2, 3], [-4, 5], [6, -7, 8], []]) [[1, 0, 3], [0, 5], [6, 0, 8], []] >>> replace_negatives([[-10, 20], [30, -40]]) [[0, 20], [30, 0]] >>> replace_negatives([[0, 0], [-1, -1]]) [[0, 0], [0, 0]] >>> replace_negatives([[]]) [[]] >>> replace_negatives([[100, -500, 400], [-300, 200, -100]]) [[100, 0, 400], [0, 200, 0]]","solution":"def replace_negatives(matrix: list[list[int]]) -> list[list[int]]: Replace negative numbers in a 2D list with zero. :param matrix: List of lists of integers :return: Modified list with negatives replaced by zero >>> replace_negatives([[1, -2, 3], [-4, 5], [6, -7, 8], []]) [[1, 0, 3], [0, 5], [6, 0, 8], []] >>> replace_negatives([[-10, 20], [30, -40]]) [[0, 20], [30, 0]] >>> replace_negatives([[0, 0], [-1, -1]]) [[0, 0], [0, 0]] >>> replace_negatives([[]]) [[]] >>> replace_negatives([[100, -500, 400], [-300, 200, -100]]) [[100, 0, 400], [0, 200, 0]] for i in range(len(matrix)): for j in range(len(matrix[i])): if matrix[i][j] < 0: matrix[i][j] = 0 return matrix"},{"question":"import re from collections import Counter def sanitize_text(text: str) -> str: Remove punctuation from the text and convert it to lowercase. >>> sanitize_text(\\"Hello, world!\\") \\"hello world\\" >>> sanitize_text(\\"Good Morning! How's everything?\\") \\"good morning hows everything\\" pass def word_frequency(text: str) -> dict: Count the frequency of each word in the sanitized text. >>> word_frequency(\\"hello world hello\\") {'hello': 2, 'world': 1} >>> word_frequency(\\"good morning good morning\\") {'good': 2, 'morning': 2} pass def most_common_words(text: str, n: int) -> list: Return the n most common words in the sanitized text. >>> most_common_words(\\"hello world hello\\", 1) [('hello', 2)] >>> most_common_words(\\"good morning good morning\\", 2) [('good', 2), ('morning', 2)] pass","solution":"import re from collections import Counter def sanitize_text(text: str) -> str: Remove punctuation from the text and convert it to lowercase. # Convert to lowercase text = text.lower() # Remove punctuation using regex sanitized = re.sub(r'[^ws]', '', text) return sanitized def word_frequency(text: str) -> dict: Count the frequency of each word in the sanitized text. words = text.split() frequency = Counter(words) return dict(frequency) def most_common_words(text: str, n: int) -> list: Return the n most common words in the sanitized text. frequency = word_frequency(text) most_common = Counter(frequency).most_common(n) return most_common # Example usage: # text = \\"Hello, world! Hello everyone. This is a simple text, with punctuation.\\" # sanitized = sanitize_text(text) # word_freq = word_frequency(sanitized) # print(word_freq) # most_common = most_common_words(sanitized, 3) # print(most_common)"},{"question":"def sort_coordinates_by_distance(lst: list[tuple[int, int]]) -> list[tuple[int, int]]: Sort a list of (x, y) coordinate pairs based on their distance from the origin (0, 0). If two points have the same distance, sort by their x-coordinate, and if their x-coordinates are the same, then by their y-coordinate. >>> sort_coordinates_by_distance([(1, 2), (0, 0), (5, 5), (3, 1)]) [(0, 0), (1, 2), (3, 1), (5, 5)] >>> sort_coordinates_by_distance([(2, 3), (3, 2), (1, 1)]) [(1, 1), (2, 3), (3, 2)] >>> sort_coordinates_by_distance([(10, 10), (7, 24), (-3, 4)]) [(-3, 4), (10, 10), (7, 24)] :param lst: A list containing tuples representing (x, y) coordinate pairs. :return: A new list of coordinate pairs sorted based on their distance from the origin.","solution":"def sort_coordinates_by_distance(lst): from math import sqrt def distance_from_origin(pt): x, y = pt return sqrt(x**2 + y**2) sorted_lst = sorted(lst, key=lambda pt: (distance_from_origin(pt), pt[0], pt[1])) return sorted_lst"},{"question":"def find_unique_number(nums: list[int]) -> int: Returns the integer that appears exactly once in the list. >>> find_unique_number([2, 3, 3, 4, 4, 2, 5]) 5 >>> find_unique_number([10, 14, 10, 22, 22]) 14 >>> find_unique_number([7, 7, 8, 8, 9]) 9 >>> find_unique_number([1, 1, 2, 2, 3]) 3 >>> find_unique_number([4, 5, 5, 4, 6]) 6 >>> find_unique_number([99]) 99","solution":"def find_unique_number(nums: list[int]) -> int: Returns the integer that appears exactly once in the list. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"import re from collections import Counter def tokenize_sentence(sentence: str) -> list: Tokenizes a sentence into a list of words, removing punctuation, converting to lowercase, and handling extra spaces. >>> tokenize_sentence(\\"Hello, world! Welcome to the new world.\\") [\\"hello\\", \\"world\\", \\"welcome\\", \\"to\\", \\"the\\", \\"new\\", \\"world\\"] >>> tokenize_sentence(\\"This is a test. This test is only a test.\\") [\\"this\\", \\"is\\", \\"a\\", \\"test\\", \\"this\\", \\"test\\", \\"is\\", \\"only\\", \\"a\\", \\"test\\"] >>> tokenize_sentence(\\"\\") [] >>> tokenize_sentence(\\"!!! ... ,,, ???\\") [] pass def word_frequency(tokens: list) -> dict: Computes the frequency of each word in the provided list. >>> tokens = [\\"hello\\", \\"world\\", \\"welcome\\", \\"to\\", \\"the\\", \\"new\\", \\"world\\"] >>> word_frequency(tokens) {'hello': 1, 'world': 2, 'welcome': 1, 'to': 1, 'the': 1, 'new': 1} >>> tokens = [\\"this\\", \\"is\\", \\"a\\", \\"test\\", \\"this\\", \\"test\\", \\"is\\", \\"only\\", \\"a\\", \\"test\\"] >>> word_frequency(tokens) {'this': 2, 'is': 2, 'a': 2, 'test': 3, 'only': 1} >>> word_frequency([]) {} >>> tokens = [\\"test\\"] >>> word_frequency(tokens) {'test': 1} pass","solution":"import re from collections import Counter def tokenize_sentence(sentence: str) -> list: Tokenizes a sentence into a list of words, removing punctuation, converting to lowercase, and handling extra spaces. Args: sentence (str): The input sentence. Returns: list: List of words (tokens). # Remove punctuation and convert to lowercase sentence = re.sub(r'[^ws]', '', sentence).lower() # Split into tokens and filter out empty strings tokens = [word for word in sentence.split() if word.strip()] return tokens def word_frequency(tokens: list) -> dict: Computes the frequency of each word in the provided list. Args: tokens (list): The list of words (tokens). Returns: dict: Dictionary where keys are words and values are their frequencies. frequency_dict = Counter(tokens) return dict(frequency_dict)"},{"question":"Define a function \`find_lowest_common_ancestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode\` that takes a binary tree root, and two nodes, p and q, and finds the lowest common ancestor of the two nodes in a binary search tree. class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_lowest_common_ancestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: Finds the lowest common ancestor (LCA) of two given nodes in a binary search tree. :param root: TreeNode - The root node of the binary search tree. :param p: TreeNode - One node in the binary search tree. :param q: TreeNode - Another node in the binary search tree. :return: TreeNode - The lowest common ancestor node of p and q. while root: # If both nodes p and q are greater than root, move to the right subtree if p.value > root.value and q.value > root.value: root = root.right # If both nodes p and q are lesser than root, move to the left subtree elif p.value < root.value and q.value < root.value: root = root.left else: # We have found the split point, i.e., the LCA node. return root Example # Definition for a binary tree node. class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right # Example Tree: # 6 # / # 2 8 # / / # 0 4 7 9 # / # 3 5 root = TreeNode(6) root.left = TreeNode(2) root.right = TreeNode(8) root.left.left = TreeNode(0) root.left.right = TreeNode(4) root.right.left = TreeNode(7) root.right.right = TreeNode(9) root.left.right.left = TreeNode(3) root.left.right.right = TreeNode(5) assert find_lowest_common_ancestor(root, root.left, root.right).value == 6 assert find_lowest_common_ancestor(root, root.left.left, root.left.right.right).value == 2 assert find_lowest_common_ancestor(root, root.right.left, root.right.right).value == 8","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_lowest_common_ancestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: Finds the lowest common ancestor (LCA) of two given nodes in a binary search tree. :param root: TreeNode - The root node of the binary search tree. :param p: TreeNode - One node in the binary search tree. :param q: TreeNode - Another node in the binary search tree. :return: TreeNode - The lowest common ancestor node of p and q. while root: # If both nodes p and q are greater than root, move to the right subtree if p.value > root.value and q.value > root.value: root = root.right # If both nodes p and q are lesser than root, move to the left subtree elif p.value < root.value and q.value < root.value: root = root.left else: # We have found the split point, i.e., the LCA node. return root"},{"question":"# Polynomial Coefficient Extraction Implement the function below to extract the coefficient of the term with a given power from a polynomial represented as a string in the form \\"ax^n + bx^(n-1) + ... + cx + d\\". Function Signature def extract_coefficient(polynomial: str, term_power: int) -> int: import re # Prepare the regex pattern to match individual terms term_pattern = re.compile(r'([+-]?[^-+]+)') # Split polynomial into terms terms = term_pattern.findall(polynomial.replace(' ', '')) for term in terms: if 'x' in term: parts = term.split('x') if '^' in parts[1]: power = int(parts[1].replace('^', '')) else: power = 1 if parts[0] in ('+', '-', ''): coefficient = int(parts[0] + '1') else: coefficient = int(parts[0]) else: power = 0 coefficient = int(term) if power == term_power: return coefficient return 0 # Examples >>> extract_coefficient(\\"3x^2 + 5x - 6\\", 2) 3 >>> extract_coefficient(\\"3x^2 + 5x - 6\\", 1) 5 >>> extract_coefficient(\\"3x^2 + 5x - 6\\", 0) -6 >>> extract_coefficient(\\"3x^2 + 5x - 6\\", 3) 0 >>> extract_coefficient(\\"7x^5 - 2x^3 + x + 1\\", 3) -2 >>> extract_coefficient(\\"7x^5 - 2x^3 + x + 1\\", 5) 7 # Unit Tests def test_extract_coefficient_case1(): assert extract_coefficient(\\"3x^2 + 5x - 6\\", 2) == 3 def test_extract_coefficient_case2(): assert extract_coefficient(\\"3x^2 + 5x - 6\\", 1) == 5 def test_extract_coefficient_case3(): assert extract_coefficient(\\"3x^2 + 5x - 6\\", 0) == -6 def test_extract_coefficient_case4(): assert extract_coefficient(\\"3x^2 + 5x - 6\\", 3) == 0 def test_extract_coefficient_case5(): assert extract_coefficient(\\"7x^5 - 2x^3 + x + 1\\", 3) == -2 def test_extract_coefficient_case6(): assert extract_coefficient(\\"7x^5 - 2x^3 + x + 1\\", 5) == 7 def test_extract_coefficient_case7(): assert extract_coefficient(\\"5x + 3\\", 2) == 0 def test_extract_coefficient_case8(): assert extract_coefficient(\\"-4x^3 + 2x^2 - x + 6\\", -1) == 0 # Invalid term power, should return 0 def test_extract_coefficient_case9(): assert extract_coefficient(\\"-4x^3 + 2x^2 - x + 6\\", 4) == 0 # Non-existent power def test_extract_coefficient_case10(): assert extract_coefficient(\\"0\\", 0) == 0 # Only a zero constant def test_extract_coefficient_case11(): assert extract_coefficient(\\"4x - 8\\", 1) == 4 def test_extract_coefficient_case12(): assert extract_coefficient(\\"+7x^5 +2x^3 - x +8\\", 3) == 2","solution":"def extract_coefficient(polynomial: str, term_power: int) -> int: import re # Prepare the regex pattern to match individual terms term_pattern = re.compile(r'([+-]?[^-+]+)') # Split polynomial into terms terms = term_pattern.findall(polynomial.replace(' ', '')) for term in terms: if 'x' in term: parts = term.split('x') if '^' in parts[1]: power = int(parts[1].replace('^', '')) else: power = 1 if parts[0] in ('+', '-', ''): coefficient = int(parts[0] + '1') else: coefficient = int(parts[0]) else: power = 0 coefficient = int(term) if power == term_power: return coefficient return 0"},{"question":"from typing import List def custom_sort(addresses: List[str]) -> List[str]: Sorts a list of delivery addresses based on specific criteria: 1. Addresses starting with a digit come first, sorted lexicographically. 2. Followed by addresses starting with an uppercase letter, sorted lexicographically. 3. Finally, addresses starting with a lowercase letter, sorted lexicographically. >>> custom_sort([ \\"123 Main St\\", \\"45 Apple Rd\\", \\"apple orchard\\", \\"Zebra Lane\\", \\"678 Pine St\\", \\"zebra cave\\", \\"Almond Ave\\", \\"49 zebra plaza\\" ]) [\\"123 Main St\\", \\"45 Apple Rd\\", \\"49 zebra plaza\\", \\"678 Pine St\\", \\"Almond Ave\\", \\"Zebra Lane\\", \\"apple orchard\\", \\"zebra cave\\"] >>> custom_sort([\\"1 Apple St\\"]) [\\"1 Apple St\\"] >>> custom_sort([]) []","solution":"from typing import List def custom_sort(addresses: List[str]) -> List[str]: def sorting_key(address: str): if address[0].isdigit(): return (0, address) elif address[0].isupper(): return (1, address) else: return (2, address) return sorted(addresses, key=sorting_key)"},{"question":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in the array. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1 pass","solution":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in the array. if not arr: # Edge case: empty array return 0 # Stores the largest possible value for the minimum ending value # of an increasing subsequence of length i at tails[i - 1] tails = [] for num in arr: # Binary search for the smallest number in tails such that tails[i] >= num left, right = 0, len(tails) while left < right: mid = (left + right) // 2 if tails[mid] < num: left = mid + 1 else: right = mid # If left points to the end of tails, it means num is greater than # any element in tails, so we append it to extend the subsequence. if left == len(tails): tails.append(num) else: tails[left] = num return len(tails)"},{"question":"def allocate_meeting_rooms(meetings: list[tuple[int, int]]) -> int: Determine the minimum number of meeting rooms required to accommodate all the meetings without overlapping. >>> allocate_meeting_rooms([(0, 30), (5, 10), (15, 20)]) 2 >>> allocate_meeting_rooms([(1, 5), (2, 6), (3, 8), (4, 9)]) 4 >>> allocate_meeting_rooms([(10, 15), (12, 20), (20, 30)]) 2 >>> allocate_meeting_rooms([(1, 10)]) 1 >>> allocate_meeting_rooms([]) 0","solution":"def allocate_meeting_rooms(meetings): if not meetings: return 0 # Separate and sort start and end times start_times = sorted([meeting[0] for meeting in meetings]) end_times = sorted([meeting[1] for meeting in meetings]) # Initialize pointers and variables to track maximum rooms required start_pointer, end_pointer = 0, 0 used_rooms = 0 max_rooms = 0 # Process until all the meetings are checked while start_pointer < len(meetings): if start_times[start_pointer] < end_times[end_pointer]: # A new meeting starts before the last one ends used_rooms += 1 start_pointer += 1 else: # A meeting ends before the next one starts used_rooms -= 1 end_pointer += 1 # Update the maximum number of rooms required max_rooms = max(max_rooms, used_rooms) return max_rooms"},{"question":"import heapq def find_kth_largest(num_list: list[int], k: int) -> int: Finds the k-th largest element in an unsorted list of integers. :param num_list: A list of integers. :param k: An integer representing which largest element to find. :return: The k-th largest element if found, otherwise None. >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([1, 9, 8, 7, 5, 6], 4) 6 >>> find_kth_largest([1, 9, 8, 7, 5, 6], 7) None","solution":"import heapq def find_kth_largest(num_list: list[int], k: int) -> int: Finds the k-th largest element in an unsorted list of integers. :param num_list: A list of integers. :param k: An integer representing which largest element to find. :return: The k-th largest element if found, otherwise None. if k > len(num_list): return None # Using a min-heap of size k min_heap = num_list[:k] heapq.heapify(min_heap) for num in num_list[k:]: if num > min_heap[0]: # Compare with the smallest element in the min-heap heapq.heapreplace(min_heap, num) return min_heap[0]"},{"question":"from typing import List def hybrid_sort(arr: List[int]) -> List[int]: Hybrid sort function that combines Quick Sort and Insertion Sort to optimize performance. Initially uses Quick Sort for overall efficiency and switches to Insertion Sort for subarrays smaller than a given threshold. Args: arr (List[int]): List of integers to be sorted. Returns: List[int]: Sorted list of integers. >>> hybrid_sort([10, 7, 8, 9, 1, 5]) [1, 5, 7, 8, 9, 10] >>> hybrid_sort([4, 3, 2, 1]) [1, 2, 3, 4] >>> hybrid_sort([5]) [5] >>> hybrid_sort([0, -1, 5, -10, 8]) [-10, -1, 0, 5, 8] >>> hybrid_sort([1, 1, 1, 1]) [1, 1, 1, 1] >>> hybrid_sort([2, 3, 5, 3, 5, 0]) [0, 2, 3, 3, 5, 5]","solution":"from typing import List def hybrid_sort(arr: List[int]) -> List[int]: def insertion_sort(subarray: List[int], start: int, end: int): for i in range(start + 1, end + 1): key = subarray[i] j = i - 1 while j >= start and key < subarray[j]: subarray[j + 1] = subarray[j] j -= 1 subarray[j + 1] = key def quick_sort_helper(arr: List[int], low: int, high: int): if low < high: if high - low <= threshold: insertion_sort(arr, low, high) else: pi = partition(arr, low, high) quick_sort_helper(arr, low, pi - 1) quick_sort_helper(arr, pi + 1, high) def partition(arr: List[int], low: int, high: int) -> int: pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 threshold = 10 quick_sort_helper(arr, 0, len(arr) - 1) return arr"},{"question":"class TextEditor: def __init__(self): self.text = \\"\\" self.history = [] def insert(self, pos: int, substring: str) -> None: Inserts a substring into the text at the given position. Parameters: pos (int): Position to insert the substring. substring (str): Substring to be inserted. pass # Your implementation here def delete(self, pos: int, length: int) -> None: Deletes a substring from the text starting at the given position with the specified length. Parameters: pos (int): Starting position of the deletion. length (int): Number of characters to delete. pass # Your implementation here def undo(self) -> None: Reverts the text to the state before the last insert or delete operation. pass # Your implementation here import pytest @pytest.mark.parametrize(\\"operations, final_text\\", [ ([ (\\"insert\\", 0, \\"hello\\"), (\\"insert\\", 5, \\" world\\"), (\\"delete\\", 5, 6), (\\"undo\\",), (\\"undo\\",) ], \\"hello\\"), ([ (\\"insert\\", 0, \\"hi\\"), (\\"delete\\", 1, 1), (\\"undo\\",) ], \\"hi\\") ]) def test_text_editor(operations, final_text): editor = TextEditor() for operation in operations: if operation[0] == \\"insert\\": editor.insert(operation[1], operation[2]) elif operation[0] == \\"delete\\": editor.delete(operation[1], operation[2]) elif operation[0] == \\"undo\\": editor.undo() assert editor.text == final_text def test_complex_operations(): editor = TextEditor() editor.insert(0, \\"a\\") editor.insert(1, \\"b\\") editor.insert(2, \\"c\\") editor.delete(1, 1) assert editor.text == \\"ac\\" editor.undo() assert editor.text == \\"abc\\" editor.undo() assert editor.text == \\"ab\\" editor.undo() assert editor.text == \\"a\\" editor.undo() assert editor.text == \\"\\"","solution":"class TextEditor: def __init__(self): self.text = \\"\\" self.history = [] def insert(self, pos: int, substring: str) -> None: Inserts a substring into the text at the given position. self.history.append(self.text) self.text = self.text[:pos] + substring + self.text[pos:] def delete(self, pos: int, length: int) -> None: Deletes a substring from the text starting at the given position with the specified length. self.history.append(self.text) self.text = self.text[:pos] + self.text[pos + length:] def undo(self) -> None: Reverts the text to the state before the last insert or delete operation. if self.history: self.text = self.history.pop()"},{"question":"def three_sum(nums: [int], target: int) -> bool: Returns True if there exist three numbers in the list that add up to the target value, otherwise False. >>> three_sum([1, 2, 3, 4, 5], 9) True >>> three_sum([1, 2, 3, 4, 5], 20) False","solution":"def three_sum(nums, target): Returns True if there are three numbers in nums that add up to target, otherwise False. nums.sort() n = len(nums) for i in range(n - 2): # Avoid duplicates if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"from typing import List def first_missing_positive(nums: List[int]) -> int: Finds the smallest positive integer that is missing from an unsorted array. >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 >>> first_missing_positive([]) 1 >>> first_missing_positive([1, 100, 1000]) 2","solution":"from typing import List def first_missing_positive(nums: List[int]) -> int: n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def top_students(scores: list[dict], n: int) -> dict[str, list[str]]: Determine the top students in each subject based on their scores. Args: scores (list[dict]): A list of dictionaries where each dictionary represents a student's scores in various subjects. n (int): The number of top students to return for each subject. Returns: dict[str, list[str]]: A dictionary where each key is a subject, and the value is a list of students' names who are the top \`n\` scorers in that subject. Example: >>> scores = [ ... {\\"name\\": \\"Alice\\", \\"math\\": 95, \\"science\\": 90}, ... {\\"name\\": \\"Bob\\", \\"math\\": 85, \\"science\\": 80}, ... {\\"name\\": \\"Charlie\\", \\"math\\": 95, \\"science\\": 85} ... ] >>> n = 2 >>> top_students(scores, n) {'math': ['Alice', 'Charlie'], 'science': ['Alice', 'Charlie']} from collections import defaultdict subject_scores = defaultdict(list) for student in scores: name = student.pop(\\"name\\") for subject, score in student.items(): subject_scores[subject].append((score, name)) top_students_dict = {} for subject, students in subject_scores.items(): students.sort(key=lambda x: x[0], reverse=True) top_students = [name for score, name in students[:n]] top_students_dict[subject] = top_students return top_students_dict def test_top_students_basic(): scores = [ {\\"name\\": \\"Alice\\", \\"math\\": 95, \\"science\\": 90}, {\\"name\\": \\"Bob\\", \\"math\\": 85, \\"science\\": 80}, {\\"name\\": \\"Charlie\\", \\"math\\": 95, \\"science\\": 85} ] n = 2 expected_output = { \\"math\\": [\\"Alice\\", \\"Charlie\\"], \\"science\\": [\\"Alice\\", \\"Charlie\\"] } assert top_students(scores, n) == expected_output def test_top_students_single_subject(): scores = [ {\\"name\\": \\"Alice\\", \\"math\\": 95}, {\\"name\\": \\"Bob\\", \\"math\\": 85}, {\\"name\\": \\"Charlie\\", \\"math\\": 90} ] n = 1 expected_output = { \\"math\\": [\\"Alice\\"] } assert top_students(scores, n) == expected_output def test_top_students_tie(): scores = [ {\\"name\\": \\"Alice\\", \\"math\\": 90}, {\\"name\\": \\"Bob\\", \\"math\\": 85}, {\\"name\\": \\"Charlie\\", \\"math\\": 85}, {\\"name\\": \\"David\\", \\"math\\": 80} ] n = 2 expected_output = { \\"math\\": [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] } assert top_students(scores, n) == expected_output def test_top_students_multiple_subjects(): scores = [ {\\"name\\": \\"Alice\\", \\"math\\": 90, \\"science\\": 80}, {\\"name\\": \\"Bob\\", \\"math\\": 85, \\"science\\": 85}, {\\"name\\": \\"Charlie\\", \\"math\\": 85, \\"science\\": 90}, {\\"name\\": \\"David\\", \\"math\\": 80, \\"science\\": 85} ] n = 3 expected_output = { \\"math\\": [\\"Alice\\", \\"Bob\\", \\"Charlie\\"], \\"science\\": [\\"Charlie\\", \\"Bob\\", \\"David\\"] } assert top_students(scores, n) == expected_output def test_top_students_all_students(): scores = [ {\\"name\\": \\"Alice\\", \\"math\\": 88}, {\\"name\\": \\"Bob\\", \\"math\\": 95}, {\\"name\\": \\"Charlie\\", \\"math\\": 92}, {\\"name\\": \\"David\\", \\"math\\": 91}, {\\"name\\": \\"Eve\\", \\"math\\": 89} ] n = 5 expected_output = { \\"math\\": [\\"Bob\\", \\"Charlie\\", \\"David\\", \\"Eve\\", \\"Alice\\"] } assert top_students(scores, n) == expected_output","solution":"def top_students(scores: list[dict], n: int) -> dict[str, list[str]]: from collections import defaultdict # Dictionary to hold scores for each subject subject_scores = defaultdict(list) # Populate the subject_scores dictionary for student in scores: name = student[\\"name\\"] for subject, score in student.items(): if subject != \\"name\\": subject_scores[subject].append((score, name)) # Dictionary to hold the top students for each subject top_students_dict = {} # Determine the top students for each subject for subject, students in subject_scores.items(): # Sort students based on score in descending order students.sort(key=lambda x: x[0], reverse=True) # Get the top n scores top_students = [name for score, name in students[:n]] # Include students with the same score if there is a tie additional_students = set() if len(students) > n: top_n_score = students[n-1][0] for i in range(n, len(students)): if students[i][0] == top_n_score: additional_students.add(students[i][1]) else: break top_students += list(additional_students) top_students_dict[subject] = top_students return top_students_dict"},{"question":"class NumberSeries: Custom class for a series of numbers with methods to add numbers, get median, and reset series. Methods: - __init__(self) -> None: Initializes an empty series. - add_number(self, number: int | float) -> None: Adds a number to the series. - get_median(self) -> int | float | None: Returns the median of the series. If the series is empty, return None. - reset(self) -> None: Resets the series to an empty state. Examples: >>> series = NumberSeries() >>> series.add_number(3) >>> series.add_number(1) >>> series.get_median() 2.0 >>> series.add_number(4) >>> series.get_median() 3.0 >>> series.reset() >>> series.get_median() None","solution":"import bisect class NumberSeries: def __init__(self): self.numbers = [] def add_number(self, number): bisect.insort(self.numbers, number) def get_median(self): n = len(self.numbers) if n == 0: return None elif n % 2 == 1: return self.numbers[n // 2] else: mid1, mid2 = n // 2 - 1, n // 2 return (self.numbers[mid1] + self.numbers[mid2]) / 2 def reset(self): self.numbers.clear()"},{"question":"def brute_force_nearest(points: list[tuple[int, int]], target: tuple[int, int]) -> tuple[int, int]: Find the nearest neighbor to the target point using brute force approach. if not points: return None min_distance = float('inf') nearest_point = None for point in points: distance = math.dist(point, target) if distance < min_distance: min_distance = distance nearest_point = point return nearest_point class KDTreeNode: def __init__(self, point, left=None, right=None): self.point = point self.left = left self.right = right def kd_tree_nearest(points: list[tuple[int, int]], target: tuple[int, int]) -> tuple[int, int]: Find the nearest neighbor to the target point using KD-Tree. if not points: return None def build_kd_tree(points, depth=0): if not points: return None k = len(points[0]) # assumes all points have the same dimension axis = depth % k points.sort(key=lambda x: x[axis]) median = len(points) // 2 return KDTreeNode( point=points[median], left=build_kd_tree(points[:median], depth + 1), right=build_kd_tree(points[median + 1:], depth + 1) ) def kd_tree_nearest_rec(node, target, depth=0, best_node=None, best_dist=float('inf')): if node is None: return best_node, best_dist k = len(target) axis = depth % k point = node.point d = math.dist(point, target) if d < best_dist: best_dist = d best_node = point diff = target[axis] - point[axis] if diff <= 0: best_node, best_dist = kd_tree_nearest_rec(node.left, target, depth + 1, best_node, best_dist) if abs(diff) < best_dist: best_node, best_dist = kd_tree_nearest_rec(node.right, target, depth + 1, best_node, best_dist) else: best_node, best_dist = kd_tree_nearest_rec(node.right, target, depth + 1, best_node, best_dist) if abs(diff) < best_dist: best_node, best_dist = kd_tree_nearest_rec(node.left, target, depth + 1, best_node, best_dist) return best_node, best_dist kd_tree_root = build_kd_tree(points) nearest_point, _ = kd_tree_nearest_rec(kd_tree_root, target) return nearest_point","solution":"import math def brute_force_nearest(points, target): Find the nearest neighbor to the target point using brute force approach. if not points: return None min_distance = float('inf') nearest_point = None for point in points: distance = math.dist(point, target) if distance < min_distance: min_distance = distance nearest_point = point return nearest_point class KDTreeNode: def __init__(self, point, left=None, right=None): self.point = point self.left = left self.right = right def kd_tree_nearest(points, target): Find the nearest neighbor to the target point using KD-Tree. if not points: return None def build_kd_tree(points, depth=0): if not points: return None k = len(points[0]) # assumes all points have the same dimension axis = depth % k points.sort(key=lambda x: x[axis]) median = len(points) // 2 return KDTreeNode( point=points[median], left=build_kd_tree(points[:median], depth + 1), right=build_kd_tree(points[median + 1:], depth + 1) ) def kd_tree_nearest_rec(node, target, depth=0, best_node=None, best_dist=float('inf')): if node is None: return best_node, best_dist k = len(target) axis = depth % k point = node.point d = math.dist(point, target) if d < best_dist: best_dist = d best_node = point diff = target[axis] - point[axis] if diff <= 0: best_node, best_dist = kd_tree_nearest_rec(node.left, target, depth + 1, best_node, best_dist) if abs(diff) < best_dist: best_node, best_dist = kd_tree_nearest_rec(node.right, target, depth + 1, best_node, best_dist) else: best_node, best_dist = kd_tree_nearest_rec(node.right, target, depth + 1, best_node, best_dist) if abs(diff) < best_dist: best_node, best_dist = kd_tree_nearest_rec(node.left, target, depth + 1, best_node, best_dist) return best_node, best_dist kd_tree_root = build_kd_tree(points) nearest_point, _ = kd_tree_nearest_rec(kd_tree_root, target) return nearest_point"},{"question":"def vigenere_encrypt(key: str, message: str) -> str: Encrypts the message using the Vigenre cipher with the given key. >>> vigenere_encrypt(\\"KEY\\", \\"HELLO WORLD\\") # e.g., \\"RIJVS UYVJN\\" pass def vigenere_decrypt(key: str, message: str) -> str: Decrypts the message using the Vigenre cipher with the given key. >>> vigenere_decrypt(\\"KEY\\", \\"RIJVS UYVJN\\") \\"HELLO WORLD\\" pass def test_vigenere_encrypt(): key = \\"KEY\\" message = \\"HELLO WORLD\\" assert vigenere_encrypt(key, message) == \\"RIJVS UYVJN\\" def test_vigenere_decrypt(): key = \\"KEY\\" encrypted_message = \\"RIJVS UYVJN\\" assert vigenere_decrypt(key, encrypted_message) == \\"HELLO WORLD\\" def test_encrypt_with_empty_key(): key = \\"\\" message = \\"HELLO\\" try: vigenere_encrypt(key, message) except ValueError as e: assert str(e) == \\"Key must contain only alphabetical characters.\\" def test_encrypt_with_non_alpha_key(): key = \\"KEY123\\" message = \\"HELLO\\" try: vigenere_encrypt(key, message) except ValueError as e: assert str(e) == \\"Key must contain only alphabetical characters.\\" def test_encrypt_with_non_alpha_message(): key = \\"KEY\\" message = \\"HELLO123\\" try: vigenere_encrypt(key, message) except ValueError as e: assert str(e) == \\"Message must contain only alphabetical characters and spaces.\\" def test_decrypt_with_empty_key(): key = \\"\\" encrypted_message = \\"RIJVS\\" try: vigenere_decrypt(key, encrypted_message) except ValueError as e: assert str(e) == \\"Key must contain only alphabetical characters.\\" def test_decrypt_with_non_alpha_key(): key = \\"KEY123\\" encrypted_message = \\"RIJVS\\" try: vigenere_decrypt(key, encrypted_message) except ValueError as e: assert str(e) == \\"Key must contain only alphabetical characters.\\" def test_decrypt_with_non_alpha_message(): key = \\"KEY\\" encrypted_message = \\"RIJVS123\\" try: vigenere_decrypt(key, encrypted_message) except ValueError as e: assert str(e) == \\"Message must contain only alphabetical characters and spaces.\\"","solution":"def vigenere_encrypt(key: str, message: str) -> str: Encrypts the message using the Vigenre cipher with the given key. if not key.isalpha(): raise ValueError(\\"Key must contain only alphabetical characters.\\") if not all(char.isalpha() or char.isspace() for char in message): raise ValueError(\\"Message must contain only alphabetical characters and spaces.\\") key = key.upper() message = message.upper() encrypted_message = [] key_length = len(key) key_index = 0 for char in message: if char.isspace(): encrypted_message.append(char) else: shift = ord(key[key_index % key_length]) - ord('A') encrypted_char = chr(((ord(char) - ord('A') + shift) % 26) + ord('A')) encrypted_message.append(encrypted_char) key_index += 1 return ''.join(encrypted_message) def vigenere_decrypt(key: str, message: str) -> str: Decrypts the message using the Vigenre cipher with the given key. if not key.isalpha(): raise ValueError(\\"Key must contain only alphabetical characters.\\") if not all(char.isalpha() or char.isspace() for char in message): raise ValueError(\\"Message must contain only alphabetical characters and spaces.\\") key = key.upper() message = message.upper() decrypted_message = [] key_length = len(key) key_index = 0 for char in message: if char.isspace(): decrypted_message.append(char) else: shift = ord(key[key_index % key_length]) - ord('A') decrypted_char = chr(((ord(char) - ord('A') - shift + 26) % 26) + ord('A')) decrypted_message.append(decrypted_char) key_index += 1 return ''.join(decrypted_message)"},{"question":"def min_path_sum(matrix): Function to compute the minimum path sum from the top-left to the bottom-right corner of a given matrix. Args: matrix (List[List[int]]): The input matrix of integers. Returns: int: The minimum path sum from the top-left to the bottom-right corner. Example: >>> matrix = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> min_path_sum(matrix) 7 >>> matrix = [ ... [1, 2], ... [1, 1] ... ] >>> min_path_sum(matrix) 3","solution":"def min_path_sum(matrix): Function to compute the minimum path sum from the top-left to the bottom-right corner of a given matrix. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = matrix[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + matrix[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + matrix[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = matrix[i][j] + min(dp[i-1][j], dp[i][j-1]) return dp[m-1][n-1]"},{"question":"def longest_subsequence_without_repeat(s: str) -> int: Given a string, find the length of the longest subsequence (not necessarily contiguous) in the string that does not contain any repeating characters. Args: s (str): A string consisting of lowercase English letters. Returns: int: The length of the longest subsequence without repeating characters. Examples: >>> longest_subsequence_without_repeat(\\"abcabcbb\\") 3 >>> longest_subsequence_without_repeat(\\"bbbbb\\") 1 >>> longest_subsequence_without_repeat(\\"pwwkew\\") 4 >>> longest_subsequence_without_repeat(\\"abcdef\\") 6 pass def test_longest_subsequence_without_repeat(): assert longest_subsequence_without_repeat(\\"abcabcbb\\") == 3 assert longest_subsequence_without_repeat(\\"bbbbb\\") == 1 assert longest_subsequence_without_repeat(\\"pwwkew\\") == 4 assert longest_subsequence_without_repeat(\\"abcdef\\") == 6 assert longest_subsequence_without_repeat(\\"aabbccdd\\") == 4 assert longest_subsequence_without_repeat(\\"a\\") == 1 assert longest_subsequence_without_repeat(\\"\\") == 0 def test_longest_subsequence_without_repeat_all_unique(): assert longest_subsequence_without_repeat(\\"abcdefghijklmnopqrstuvwxyz\\") == 26 def test_longest_subsequence_without_repeat_single_char(): assert longest_subsequence_without_repeat(\\"jjjj\\") == 1 def test_longest_subsequence_without_repeat_mixed(): assert longest_subsequence_without_repeat(\\"abacabadabacaba\\") == 4 assert longest_subsequence_without_repeat(\\"qwertyuiopasdfghjklzxcvbnm\\") == 26","solution":"def longest_subsequence_without_repeat(s: str) -> int: Returns the length of the longest subsequence of s that does not contain any repeating characters. # Use a set to track unique characters unique_chars = set(s) return len(unique_chars)"},{"question":"from typing import Tuple, Union def solve_quadratic(a: float, b: float, c: float) -> Union[str, Tuple[Union[float, None], Union[float, None]]]: Solve quadratic equations of the form ax^2 + bx + c = 0 with validation. >>> solve_quadratic(1, -3, 2) == (2.0, 1.0) >>> solve_quadratic(1, -2, 1) == (1.0, 1.0) >>> solve_quadratic(0, 2, -8) == (4.0, None) >>> solve_quadratic(1, 0, 1) == \\"No real solutions\\" >>> solve_quadratic(0, 0, 8) == \\"Invalid input: Not a valid equation.\\" >>> solve_quadratic(2, 3, 8) == \\"No real solutions\\" >>> solve_quadratic(1, -1, -6) == (3.0, -2.0) >>> solve_quadratic(1, 'b', 1) == \\"Invalid input: Coefficients must be real numbers.\\" >>> solve_quadratic('a', 2, 3) == \\"Invalid input: Coefficients must be real numbers.\\" >>> solve_quadratic(1, 2, 'c') == \\"Invalid input: Coefficients must be real numbers.\\"","solution":"from typing import Tuple, Union import math def solve_quadratic(a: float, b: float, c: float) -> Union[str, Tuple[Union[float, None], Union[float, None]]]: Solves the quadratic equation ax^2 + bx + c = 0. Returns: A tuple of two floats representing the roots of the equation. If there is only one root, both elements of the tuple will be the same. If there are no real roots, returns the string \\"No real solutions\\". If the input is invalid or not a quadratic equation, returns an appropriate error message. # Ensure coefficients are real numbers if not all(isinstance(i, (int, float)) for i in [a, b, c]): return \\"Invalid input: Coefficients must be real numbers.\\" # Handle non-quadratic case if a == 0: if b == 0: return \\"Invalid input: Not a valid equation.\\" else: # Linear case bx + c = 0 return -c / b, None # Calculate the discriminant discriminant = b ** 2 - 4 * a * c if discriminant > 0: # Two distinct real roots root1 = (-b + math.sqrt(discriminant)) / (2 * a) root2 = (-b - math.sqrt(discriminant)) / (2 * a) return (root1, root2) elif discriminant == 0: # One real root (a perfect square) root = -b / (2 * a) return (root, root) else: # No real roots return \\"No real solutions\\""},{"question":"def optimize_capacities(capacities, items): Returns the maximum variety of items that can be present in any single container after redistributing within capacity constraints. >>> optimize_capacities([5, 8, 3], [3, 7, 2]) Returns 2 >>> optimize_capacities([10], [3, 4, 5]) Returns 2 >>> optimize_capacities([5, 5, 5], [3, 3, 3]) Returns 1 >>> optimize_capacities([2, 2, 2], [3, 3, 3]) Returns 0 >>> optimize_capacities([100] * 1000, [1] * 1000) Returns 100 >>> optimize_capacities([10, 2, 5], [5, 5, 1]) Returns 2 # Your code here. pass","solution":"def optimize_capacities(capacities, items): Returns the maximum variety of items that can be present in any single container after redistributing within capacity constraints. sorted_items = sorted(items, reverse=True) max_different_items = 0 for capacity in capacities: different_items = 0 remaining_capacity = capacity for item in sorted_items: if remaining_capacity >= item: remaining_capacity -= item different_items += 1 max_different_items = max(max_different_items, different_items) return max_different_items"},{"question":"def memoized_fibonacci(n: int) -> int: Calculate the nth Fibonacci number using memoization to improve performance. >>> memoized_fibonacci(0) 0 >>> memoized_fibonacci(1) 1 >>> memoized_fibonacci(10) 55 >>> memoized_fibonacci(50) 12586269025 def test_memoized_fibonacci_base_cases(): assert memoized_fibonacci(0) == 0 assert memoized_fibonacci(1) == 1 def test_memoized_fibonacci_small_numbers(): assert memoized_fibonacci(2) == 1 assert memoized_fibonacci(3) == 2 assert memoized_fibonacci(10) == 55 def test_memoized_fibonacci_large_numbers(): assert memoized_fibonacci(30) == 832040 assert memoized_fibonacci(50) == 12586269025 def test_memoized_fibonacci_edge_case(): assert memoized_fibonacci(1000) == 43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875","solution":"def memoized_fibonacci(n, cache={0: 0, 1: 1}): Returns the nth Fibonacci number using memoization. Parameters: n (int): The position in the Fibonacci sequence (0  n  1000) Returns: int: The nth Fibonacci number. if n in cache: return cache[n] cache[n] = memoized_fibonacci(n - 1, cache) + memoized_fibonacci(n - 2, cache) return cache[n]"},{"question":"import heapq from typing import List, Tuple def min_meeting_rooms(meetings: List[Tuple[int, int]]) -> int: Calculate the minimum number of meeting rooms required to accommodate all meetings. Args: meetings (list of tuple): A list of tuples where each tuple consists of two integers representing the start and end times of a meeting. Returns: int: The minimum number of meeting rooms required. >>> min_meeting_rooms([(0, 30), (5, 10), (15, 20)]) 2 >>> min_meeting_rooms([(7, 10), (2, 4)]) 1 >>> min_meeting_rooms([]) 0 >>> min_meeting_rooms([(1, 5), (8, 9), (8, 9), (5, 6)]) 2 >>> min_meeting_rooms([(5, 10), (10, 15), (15, 20)]) 1 >>> min_meeting_rooms([(1, 10), (2, 7), (3, 19), (8, 12), (10, 20), (11, 30)]) 4 >>> min_meeting_rooms([(1, 5), (1, 5), (1, 5)]) 3 >>> min_meeting_rooms([(1, 5), (2, 6), (7, 8), (9, 10)]) 2 pass","solution":"import heapq def min_meeting_rooms(meetings): Calculate the minimum number of meeting rooms required to accommodate all meetings. Args: meetings (list of tuple): A list of tuples where each tuple consists of two integers representing the start and end times of a meeting. Returns: int: The minimum number of meeting rooms required. if not meetings: return 0 # Sort meetings based on start time meetings.sort(key=lambda x: x[0]) # Initialize a min heap to keep track of end times of meetings heap = [] # Add the end time of the first meeting heapq.heappush(heap, meetings[0][1]) # Iterate through the remaining meetings for meeting in meetings[1:]: # If the room due to free up next is free before the next meeting starts if heap[0] <= meeting[0]: heapq.heappop(heap) # Add the current meeting's end time to the heap heapq.heappush(heap, meeting[1]) # The size of the heap is the number of rooms required return len(heap)"},{"question":"import random def generate_unique_randoms(n: int, m: int) -> list: Generates a list of \`n\` unique random integers between 1 and \`m\`. If \`n\` is greater than \`m\`, returns a shuffled list of numbers from 1 to \`m\`. Parameters: - n (int): Number of unique random integers to generate. - m (int): Upper bound of the range (inclusive). Returns: - list of \`n\` unique random integers between 1 and \`m\`. >>> len(generate_unique_randoms(5, 10)) == 5 True >>> len(set(generate_unique_randoms(15, 10))) == 10 True","solution":"import random def generate_unique_randoms(n: int, m: int) -> list: Generates a list of \`n\` unique random integers between 1 and \`m\`. If \`n\` is greater than \`m\`, returns a shuffled list of numbers from 1 to \`m\`. Parameters: - n (int): Number of unique random integers to generate. - m (int): Upper bound of the range (inclusive). Returns: - list of \`n\` unique random integers between 1 and \`m\`. if n >= m: return random.sample(range(1, m + 1), m) return random.sample(range(1, m + 1), n)"},{"question":"from typing import List def remove_duplicates(nums: List[int]) -> List[int]: Removes all duplicates from the list while preserving the original order of the first occurrences. Args: nums (List[int]): A list of integers in arbitrary order. Returns: List[int]: A list with duplicates removed maintaining the original order of first occurrences. Example: >>> remove_duplicates([4, 5, 9, 4, 6, 7, 9, 6, 1]) [4, 5, 9, 6, 7, 1] >>> remove_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([1, 1, 1, 1, 1]) [1] >>> remove_duplicates([]) [] >>> remove_duplicates([1]) [1] >>> remove_duplicates([1, 2, 1, 3, 2, 4, 3, 5, 4, 6, 5, 7, 6, 8, 7, 9, 8, 9, 10]) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]","solution":"from typing import List def remove_duplicates(nums: List[int]) -> List[int]: Removes all duplicates from the list while preserving the original order of the first occurrences. Args: nums (List[int]): A list of integers in arbitrary order. Returns: List[int]: A list with duplicates removed maintaining the original order of first occurrences. seen = set() result = [] for num in nums: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"from typing import List def unique_combinations(s: str) -> List[str]: Generate all unique combinations of characters in the given string. >>> unique_combinations(\\"aab\\") [\\"\\", \\"a\\", \\"aa\\", \\"aab\\", \\"ab\\", \\"b\\"] >>> unique_combinations(\\"abc\\") [\\"\\", \\"a\\", \\"ab\\", \\"abc\\", \\"ac\\", \\"b\\", \\"bc\\", \\"c\\"] >>> unique_combinations(\\"aaa\\") [\\"\\", \\"a\\", \\"aa\\", \\"aaa\\"] pass # Test Cases def test_unique_combinations_example_1(): assert unique_combinations(\\"aab\\") == [\\"\\", \\"a\\", \\"aa\\", \\"aab\\", \\"ab\\", \\"b\\"] def test_unique_combinations_example_2(): assert unique_combinations(\\"abc\\") == [\\"\\", \\"a\\", \\"ab\\", \\"abc\\", \\"ac\\", \\"b\\", \\"bc\\", \\"c\\"] def test_unique_combinations_example_3(): assert unique_combinations(\\"aaa\\") == [\\"\\", \\"a\\", \\"aa\\", \\"aaa\\"] def test_unique_combinations_single_character(): assert unique_combinations(\\"a\\") == [\\"\\", \\"a\\"] def test_unique_combinations_two_identical_characters(): assert unique_combinations(\\"aa\\") == [\\"\\", \\"a\\", \\"aa\\"] def test_unique_combinations_empty_string(): assert unique_combinations(\\"\\") == [\\"\\"] def test_unique_combinations_longer_string(): result = unique_combinations(\\"aabc\\") expected = [\\"\\", \\"a\\", \\"aa\\", \\"aab\\", \\"aabc\\", \\"aac\\", \\"ab\\", \\"abc\\", \\"ac\\", \\"b\\", \\"bc\\", \\"c\\"] assert result == expected, f\\"Expected {expected}, but got {result}\\" def test_unique_combinations_with_duplicates(): result = unique_combinations(\\"abca\\") expected = [\\"\\", \\"a\\", \\"aa\\", \\"aab\\", \\"aabc\\", \\"aac\\", \\"ab\\", \\"abc\\", \\"ac\\", \\"b\\", \\"bc\\", \\"c\\"] assert result == expected, f\\"Expected {expected}, but got {result}\\"","solution":"from itertools import combinations from typing import List def unique_combinations(s: str) -> List[str]: Generate all unique combinations of characters in the given string. :param s: Input string :return: List of all unique combinations, sorted lexicographically # Sort the string to ensure lexicographical order in combinations s = ''.join(sorted(s)) # Use a set to avoid duplicate combinations unique_combos = set() # Generate combinations of all lengths for i in range(len(s) + 1): for combo in combinations(s, i): unique_combos.add(''.join(combo)) # Return the sorted list of unique combinations return sorted(unique_combos)"},{"question":"def max_difference(arr: list) -> int: Computes the maximum difference between any two elements in an array. Args: arr: list of integers Returns: int: The maximum difference Examples: >>> max_difference([1, 2, 3, 4, 5]) 4 >>> max_difference([-10, -5, 0, 5, 10]) 20 >>> max_difference([7, -2, 5, -6, 8]) 14 >>> max_difference([1, 1, 1, 1]) 0 >>> max_difference([100, 50, 0, -50, -100]) 200 >>> max_difference([5, 5]) 0","solution":"def max_difference(arr: list) -> int: Computes the maximum difference between any two elements in an array. Args: arr: list of integers Returns: int: The maximum difference # Finding the minimum and maximum values in the list min_val = min(arr) max_val = max(arr) # The maximum difference will be the difference between max and min values return max_val - min_val"},{"question":"from typing import List, Tuple def custom_comparator(a: Tuple[int, int], b: Tuple[int, int]) -> int: Comparator function to compare the second elements of tuples. >>> custom_comparator((1, 3), (2, 4)) == -1 >>> custom_comparator((1, 5), (2, 4)) == 1 >>> custom_comparator((1, 3), (2, 3)) == 0 def sort_tuples(tuples_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Sorts a list of tuples based on their second elements using the custom comparator. >>> sort_tuples([(1, 3), (2, 1), (3, 2)]) == [(2, 1), (3, 2), (1, 3)] >>> sort_tuples([(1, -3), (2, 4), (3, 0)]) == [(1, -3), (3, 0), (2, 4)] >>> sort_tuples([]) == [] def validate_sorting(original_list: List[Tuple[int, int]], sorted_list: List[Tuple[int, int]]) -> bool: Validate if the manually sorted list matches the Python-sorted list. >>> original = [(1, 3), (2, 1), (3, 2)] >>> sorted_list = sort_tuples(original) >>> validate_sorting(original, sorted_list) == True >>> original = [(4, -2), (1, -1), (2, -3), (3, 1)] >>> sorted_list = sort_tuples(original) >>> validate_sorting(original, sorted_list) == True >>> original = [(1, 2), (2, 2), (3, 1)] >>> sorted_list = [(3, 1), (1, 2), (2, 2)] >>> validate_sorting(original, sorted_list) == True >>> sorted_list = [(1, 2), (2, 2), (3, 3)] >>> validate_sorting(original, sorted_list) == False","solution":"from typing import List, Tuple def custom_comparator(a: Tuple[int, int], b: Tuple[int, int]) -> int: if a[1] < b[1]: return -1 elif a[1] > b[1]: return 1 else: return 0 def sort_tuples(tuples_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]: return sorted(tuples_list, key=lambda x: x[1]) def validate_sorting(original_list: List[Tuple[int, int]], sorted_list: List[Tuple[int, int]]) -> bool: manually_sorted_list = sorted(original_list, key=lambda x: x[1]) return manually_sorted_list == sorted_list"},{"question":"def verify_data_alignment( array1: List[float], array2: List[float], tolerance: float ) -> bool: Verifies if the data in array1 aligns with the data in array2 within the given tolerance. Parameters: array1 (List[float]): The first list of floating-point numbers. array2 (List[float]): The second list of floating-point numbers. tolerance (float): The maximum allowable difference between corresponding elements in the two arrays. Returns: bool: True if the absolute difference between each corresponding element in array1 and array2 does not exceed the tolerance, else False. pass import pytest from solution import verify_data_alignment def test_verify_data_alignment_exact_match(): assert verify_data_alignment([1.0, 2.0, 3.0], [1.0, 2.0, 3.0], 0.0) == True def test_verify_data_alignment_within_tolerance(): assert verify_data_alignment([1.0, 2.0, 3.0], [1.1, 2.1, 3.1], 0.15) == True def test_verify_data_alignment_outside_tolerance(): assert verify_data_alignment([1.0, 2.0, 3.0], [1.2, 2.1, 3.1], 0.15) == False def test_verify_data_alignment_all_within_tolerance(): assert verify_data_alignment([1.0, 2.0, 3.0, 4.0], [1.05, 2.05, 3.00, 4.10], 0.1) == True def test_verify_data_alignment_single_element(): assert verify_data_alignment([1.0], [2.0], 2.0) == True def test_verify_data_alignment_single_element_outside_tolerance(): assert verify_data_alignment([1.0], [3.0], 1.0) == False def test_verify_data_alignment_different_lengths(): assert verify_data_alignment([1.0, 2.0], [1.0], 0.1) == False","solution":"from typing import List def verify_data_alignment(array1: List[float], array2: List[float], tolerance: float) -> bool: Verifies if the data in array1 aligns with the data in array2 within the given tolerance. Parameters: array1 (List[float]): The first list of floating-point numbers. array2 (List[float]): The second list of floating-point numbers. tolerance (float): The maximum allowable difference between corresponding elements in the two arrays. Returns: bool: True if the absolute difference between each corresponding element in array1 and array2 does not exceed the tolerance, else False. if len(array1) != len(array2): return False for a, b in zip(array1, array2): if abs(a - b) > tolerance: return False return True"},{"question":"from typing import List def generate_power_set(nums: List[int]) -> List[List[int]]: Given a list of integers, return the power set (all possible subsets). >>> generate_power_set([1, 2, 3]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] >>> generate_power_set([4, 4]) [[], [4], [4, 4]] >>> generate_power_set([]) [[]] pass","solution":"from typing import List def generate_power_set(nums: List[int]) -> List[List[int]]: Given a list of integers, return the power set (all possible subsets). power_set = [[]] for num in nums: power_set += [curr + [num] for curr in power_set] return power_set"},{"question":"import threading class DiningPhilosophers: def __init__(self): Initialize the forks to be used by the philosophers. # Your initialization code here def wants_to_eat(self, philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork): Simulate the dining philosophers problem to avoid deadlock and starvation. Parameters: philosopher (int): The philosopher number from 0 to 4. pickLeftFork (function): An action to pick the left fork. pickRightFork (function): An action to pick the right fork. eat (function): An action to eat. putLeftFork (function): An action to put the left fork down. putRightFork (function): An action to put the right fork down. # Your code here if __name__ == \\"__main__\\": def pickLeftFork(): print(\\"picked left fork\\") def pickRightFork(): print(\\"picked right fork\\") def eat(): print(\\"eating\\") def putLeftFork(): print(\\"put left fork\\") def putRightFork(): print(\\"put right fork\\") philosophers = DiningPhilosophers() def philosopher_thread(id): philosophers.wants_to_eat(id, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork) for i in range(5): threading.Thread(target=philosopher_thread, args=(i,)).start() import threading import time def test_wants_to_eat(): philosophers = DiningPhilosophers() output = [] condition = threading.Condition() def pickLeftFork(): with condition: output.append(\\"picked left fork\\") condition.notify_all() def pickRightFork(): with condition: output.append(\\"picked right fork\\") condition.notify_all() def eat(): with condition: output.append(\\"eating\\") condition.notify_all() def putLeftFork(): with condition: output.append(\\"put left fork\\") condition.notify_all() def putRightFork(): with condition: output.append(\\"put right fork\\") condition.notify_all() def philosopher_thread(id): philosophers.wants_to_eat(id, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork) threads = [] for i in range(5): thread = threading.Thread(target=philosopher_thread, args=(i,)) threads.append(thread) thread.start() for thread in threads: thread.join() assert output == sorted(output, key=lambda x: output.count(x)) def test_concurrent_eating(): philosophers = DiningPhilosophers() eating = [0] * 5 def pickLeftFork(): pass def pickRightFork(): pass def eat(): eating[0] += 1 def putLeftFork(): pass def putRightFork(): pass def philosopher_thread(id): for _ in range(5): philosophers.wants_to_eat(id, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork) threads = [] for i in range(5): thread = threading.Thread(target=philosopher_thread, args=(i,)) threads.append(thread) thread.start() for thread in threads: thread.join() assert sum(eating) == 25","solution":"import threading class DiningPhilosophers: def __init__(self): self.forks = [threading.Lock() for _ in range(5)] self.lock = threading.Lock() def wants_to_eat(self, philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork): leftFork = philosopher rightFork = (philosopher + 1) % 5 with self.lock: self.forks[leftFork].acquire() self.forks[rightFork].acquire() pickLeftFork() pickRightFork() eat() putLeftFork() putRightFork() self.forks[rightFork].release() self.forks[leftFork].release()"},{"question":"def manage_permissions(commands, permissions): Manages the file permissions based on commands to grant or revoke permissions for users on files. :param commands: List of tuples where each tuple represents a command in the format (operation, username, filename). operation can be 'grant' or 'revoke'. :param permissions: A set of permissions to be granted or revoked, where each permission is one of 'read', 'write', 'execute'. :return: A dictionary where the keys are filenames, and the values are dictionaries themselves containing usernames as keys and a set of current permissions as values. from solution import manage_permissions def test_manage_permissions_grant_and_revoke(): commands = [('grant', 'alice', 'file1'), ('grant', 'bob', 'file2'), ('revoke', 'alice', 'file1')] permissions = {'read', 'write'} expected = { 'file1': {}, 'file2': {'bob': {'read', 'write'}} } assert manage_permissions(commands, permissions) == expected def test_manage_permissions_grant_and_revoke_single_permission(): commands = [('grant', 'charlie', 'file3'), ('grant', 'alice', 'file3'), ('revoke', 'alice', 'file3')] permissions = {'execute'} expected = { 'file3': {'charlie': {'execute'}} } assert manage_permissions(commands, permissions) == expected def test_manage_permissions_grant_only(): commands = [('grant', 'alice', 'file1'), ('grant', 'alice', 'file2'), ('grant', 'bob', 'file1')] permissions = {'read'} expected = { 'file1': {'alice': {'read'}, 'bob': {'read'}}, 'file2': {'alice': {'read'}} } assert manage_permissions(commands, permissions) == expected def test_manage_permissions_revoke_nonexistent_permission(): commands = [('revoke', 'alice', 'file1')] permissions = {'execute'} expected = { 'file1': {} } assert manage_permissions(commands, permissions) == expected def test_manage_permissions_grant_existing_permission(): commands = [('grant', 'alice', 'file1'), ('grant', 'alice', 'file1')] permissions = {'read'} expected = { 'file1': {'alice': {'read'}} } assert manage_permissions(commands, permissions) == expected def test_manage_permissions_revoke_existing_permissions(): commands = [('grant', 'alice', 'file1'), ('grant', 'bob', 'file1'), ('grant', 'alice', 'file1'), ('grant', 'bob', 'file1'), ('revoke', 'alice', 'file1'), ('revoke', 'bob', 'file1')] permissions = {'read'} expected = { 'file1': {} } assert manage_permissions(commands, permissions) == expected","solution":"def manage_permissions(commands, permissions): Manages the file permissions based on commands to grant or revoke permissions for users on files. :param commands: List of tuples where each tuple represents a command in the format (operation, username, filename). operation can be 'grant' or 'revoke'. :param permissions: A set of permissions to be granted or revoked, where each permission is one of 'read', 'write', 'execute'. :return: A dictionary where the keys are filenames, and the values are dictionaries themselves containing usernames as keys and a set of current permissions as values. result = {} for operation, username, filename in commands: if filename not in result: result[filename] = {} if username not in result[filename]: result[filename][username] = set() if operation == 'grant': result[filename][username].update(permissions) elif operation == 'revoke': result[filename][username].difference_update(permissions) if not result[filename][username]: del result[filename][username] return result"},{"question":"class ExpressionTree: A class to represent an Expression Tree constructed from a postfix expression. Attributes: ----------- root : Node The root node of the expression tree. Methods: -------- __init__(self, postfix_expr: str) -> None Initializes the ExpressionTree with a given postfix expression string. evaluate(self) -> float Evaluates the expression tree and returns the result. class Node: def __init__(self, value): self.value = value self.left = None self.right = None def __init__(self, postfix_expr: str) -> None: pass def evaluate(self) -> float: pass # Example usage: # tree = ExpressionTree(\\"3 4 + 2 * 7 /\\") # print(tree.evaluate()) # Output: 2.0 # Unit tests def test_expression_tree_1(): tree = ExpressionTree(\\"3 4 + 2 * 7 /\\") assert tree.evaluate() == 2.0 def test_expression_tree_2(): tree = ExpressionTree(\\"5 1 2 + 4 * + 3 -\\") assert tree.evaluate() == 14 def test_expression_tree_3(): tree = ExpressionTree(\\"2 3 * 5 4 * +\\") assert tree.evaluate() == 26 def test_expression_tree_single_operand(): tree = ExpressionTree(\\"5\\") assert tree.evaluate() == 5 def test_expression_tree_more_complex(): tree = ExpressionTree(\\"2 3 + 4 * 5 -\\") assert tree.evaluate() == 15 def test_expression_tree_division(): tree = ExpressionTree(\\"6 3 /\\") assert tree.evaluate() == 2.0 def test_expression_tree_subtraction(): tree = ExpressionTree(\\"10 4 - 3 +\\") assert tree.evaluate() == 9","solution":"class ExpressionTree: class Node: def __init__(self, value): self.value = value self.left = None self.right = None def __init__(self, postfix_expr: str) -> None: self.root = self.construct_tree(postfix_expr.split()) def construct_tree(self, postfix_expr: list): stack = [] for token in postfix_expr: if token in \\"+-*/\\": node = self.Node(token) node.right = stack.pop() node.left = stack.pop() else: node = self.Node(int(token)) stack.append(node) return stack.pop() def evaluate(self) -> float: return self.evaluate_node(self.root) def evaluate_node(self, node): if isinstance(node.value, int): return node.value left_val = self.evaluate_node(node.left) right_val = self.evaluate_node(node.right) if node.value == '+': return left_val + right_val elif node.value == '-': return left_val - right_val elif node.value == '*': return left_val * right_val elif node.value == '/': return left_val / right_val"},{"question":"def find_substring_pattern(text: str, pattern: str) -> int: Locate the starting index of the first occurrence of the specified substring pattern within the provided text. Returns -1 if the pattern does not exist within the text. >>> find_substring_pattern(\\"abdabcababc\\", \\"abc\\") 3 >>> find_substring_pattern(\\"abcdefg\\", \\"hij\\") -1 >>> find_substring_pattern(\\"aaaaaaa\\", \\"aa\\") 0 >>> find_substring_pattern(\\"mississippi\\", \\"issip\\") 4","solution":"def build_lps(pattern): Builds the Longest Prefix Suffix (LPS) array used in the KMP algorithm. lps = [0] * len(pattern) length = 0 # length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def find_substring_pattern(text, pattern): Finds the starting index of the first occurrence of the pattern in the text using the KMP algorithm. if not pattern: return 0 if text else -1 if not text: return -1 lps = build_lps(pattern) i = j = 0 # indices for text and pattern while i < len(text): if text[i] == pattern[j]: i += 1 j += 1 if j == len(pattern): return i - j elif i < len(text) and text[i] != pattern[j]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"from collections import deque def max_sliding_window(nums: list, k: int) -> list: Find the maximum value in each sliding window of size \`k\` in the array \`nums\`. Args: nums (list): List of integers. k (int): Size of the sliding window. Returns: list: List of integers representing the maximum value in each sliding window. Examples: >>> max_sliding_window([10, -2, 4, 8, 6], 3) [10, 8, 8] >>> max_sliding_window([], 3) [] >>> max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3) [3, 3, 5, 5, 6, 7] >>> max_sliding_window([1], 1) [1] >>> max_sliding_window([1, 2, 3, 4, 5], 5) [5]","solution":"from collections import deque def max_sliding_window(nums, k): Find the maximum value in each sliding window of size \`k\` in the array \`nums\`. Args: nums (list): List of integers. k (int): Size of the sliding window. Returns: list: List of integers representing the maximum value in each sliding window. if not nums or k == 0: return [] deque_index = deque() max_values = [] for i, num in enumerate(nums): # Remove indices that are out of the current window if deque_index and deque_index[0] == i - k: deque_index.popleft() # Remove elements that are less than the current element from the deque while deque_index and nums[deque_index[-1]] < num: deque_index.pop() # Append current element's index to the deque deque_index.append(i) # Add the maximum for the current window to the result list if i >= k - 1: max_values.append(nums[deque_index[0]]) return max_values"},{"question":"[Completion Task in Python] Implement a function \`filter_and_multiply(arr: List[int], k: int) -> List[int]\` that filters out numbers from the array not divisible by \`k\` and multiplies the remaining numbers by a factor of \`k\`. def filter_and_multiply(arr: List[int], k: int) -> List[int]: Filters out numbers from the array not divisible by k and multiplies the remaining numbers by a factor of k. Parameters: arr (List[int]): A list of integers. k (int): A positive integer. Returns: List[int]: A new list where each element is divisible by k and multiplied by k. return [x * k for x in arr if x % k == 0]","solution":"from typing import List def filter_and_multiply(arr: List[int], k: int) -> List[int]: Filters out numbers from the array not divisible by k and multiplies the remaining numbers by a factor of k. Parameters: arr (List[int]): A list of integers. k (int): A positive integer. Returns: List[int]: A new list where each element is divisible by k and multiplied by k. return [x * k for x in arr if x % k == 0]"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self, values=None): self.head = None if values: self.head = ListNode(values[0]) current = self.head for value in values[1:]: current.next = ListNode(value) current = current.next def __iter__(self): current = self.head while current: yield current.value current = current.next def partition(self, x: int) -> None: Partition linked list based on value x. :param x: The partitioning value.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self, values=None): self.head = None if values: self.head = ListNode(values[0]) current = self.head for value in values[1:]: current.next = ListNode(value) current = current.next def __iter__(self): current = self.head while current: yield current.value current = current.next def partition(self, x): left_dummy = ListNode(0) # Starting point of the less than x list right_dummy = ListNode(0) # Starting point of the greater/equal to x list left = left_dummy # Pointer to form the list of nodes less than x right = right_dummy # Pointer to form the list of nodes greater/equal to x current = self.head while current: if current.value < x: left.next = current left = left.next else: right.next = current right = right.next current = current.next right.next = None # End the list greater/equal to x left.next = right_dummy.next # Combine the two lists self.head = left_dummy.next # Head of the modified list"},{"question":"def sort_employees(employees: list) -> list: Sorts a list of employees first by age (ascending) and then by experience (descending). >>> sort_employees([('Alice', 30, 5), ('Bob', 25, 10), ('Charlie', 30, 10), ('Dave', 25, 8)]) [('Bob', 25, 10), ('Dave', 25, 8), ('Charlie', 30, 10), ('Alice', 30, 5)] >>> sort_employees([('Eve', 22, 2), ('Frank', 22, 3), ('Grace', 35, 10), ('Heidi', 35, 9)]) [('Frank', 22, 3), ('Eve', 22, 2), ('Grace', 35, 10), ('Heidi', 35, 9)] >>> sort_employees([('Ivy', 40, 15), ('Judy', 40, 15)]) [('Ivy', 40, 15), ('Judy', 40, 15)] >>> sort_employees([('Ivan', 28, 2), ('Oscar', 28, 5), ('Nancy', 20, 12)]) [('Nancy', 20, 12), ('Oscar', 28, 5), ('Ivan', 28, 2)] >>> sort_employees([]) [] >>> sort_employees([('Alice', 30, 5)]) [('Alice', 30, 5)]","solution":"def sort_employees(employees): Sorts a list of employees first by age (ascending) and then by experience (descending). Parameters: employees (list): A list of tuples, where each tuple contains a string (employee name), an integer (age), and an integer (experience). Returns: list: A sorted list of employees. # Sort by age ascending and then by experience descending return sorted(employees, key=lambda emp: (emp[1], -emp[2]))"},{"question":"def custom_sort(data: list, keys: list) -> list: Sort a list of dictionaries based on multiple keys. Args: data (list): A list of dictionaries to be sorted. keys (list): A list of keys to sort the dictionaries by. Returns: list: The sorted list of dictionaries. Example: >>> data = [{\\"name\\": \\"Alice\\", \\"age\\": 34, \\"score\\": 88}, {\\"name\\": \\"Bob\\", \\"age\\": 23, \\"score\\": 95}, {\\"name\\": \\"Charlie\\", \\"age\\": 45, \\"score\\": 77}, {\\"name\\": \\"Dave\\", \\"age\\": 23}] >>> keys = [\\"age\\", \\"score\\"] >>> custom_sort(data, keys) [ {\\"name\\": \\"Dave\\", \\"age\\": 23}, {\\"name\\": \\"Bob\\", \\"age\\": 23, \\"score\\": 95}, {\\"name\\": \\"Alice\\", \\"age\\": 34, \\"score\\": 88}, {\\"name\\": \\"Charlie\\", \\"age\\": 45, \\"score\\": 77} ] >>> keys = [\\"score\\", \\"age\\"] >>> custom_sort(data, keys) [ {\\"name\\": \\"Dave\\", \\"age\\": 23}, {\\"name\\": \\"Charlie\\", \\"age\\": 45, \\"score\\": 77}, {\\"name\\": \\"Alice\\", \\"age\\": 34, \\"score\\": 88}, {\\"name\\": \\"Bob\\", \\"age\\": 23, \\"score\\": 95} ]","solution":"def custom_sort(data: list, keys: list) -> list: Sort a list of dictionaries based on multiple keys. Args: data (list): A list of dictionaries to be sorted. keys (list): A list of keys to sort the dictionaries by. Returns: list: The sorted list of dictionaries. for key in reversed(keys): data.sort(key=lambda x: x.get(key, -float('inf'))) return data"},{"question":"def validate_credit_card(card_num: str) -> str: Validate and format the credit card number using the Luhn algorithm. :param card_num: str : Credit card number to be validated and formatted :return: str : Formatted credit card number if valid :raises ValueError: If card number is invalid or input is not as expected # Tests for the validate_credit_card function def test_valid_credit_card(): assert validate_credit_card(\\"1234567812345670\\") == \\"1234 5678 1234 5670\\" assert validate_credit_card(\\"4485275742308327\\") == \\"4485 2757 4230 8327\\" def test_invalid_length_credit_card(): import pytest with pytest.raises(ValueError, match=\\"Card number must be exactly 16 digits long and contain only numeric characters.\\"): validate_credit_card(\\"1234 5678 1234 567\\") with pytest.raises(ValueError, match=\\"Card number must be exactly 16 digits long and contain only numeric characters.\\"): validate_credit_card(\\"123456781234567\\") def test_invalid_chars_credit_card(): import pytest with pytest.raises(ValueError, match=\\"Card number must be exactly 16 digits long and contain only numeric characters.\\"): validate_credit_card(\\"1234 5678 1234 abcd\\") with pytest.raises(ValueError, match=\\"Card number must be exactly 16 digits long and contain only numeric characters.\\"): validate_credit_card(\\"abcdabcdabcdabcd\\") def test_invalid_luhn_credit_card(): import pytest with pytest.raises(ValueError, match=\\"Invalid credit card number.\\"): validate_credit_card(\\"1234567812345678\\") with pytest.raises(ValueError, match=\\"Invalid credit card number.\\"): validate_credit_card(\\"4485275742308328\\") # Run all tests if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"def validate_credit_card(card_num): Validate and format the credit card number using the Luhn algorithm. :param card_num: str : Credit card number to be validated and formatted :return: str : Formatted credit card number if valid :raises ValueError: If card number is invalid or input is not as expected # Check if card number is of valid length and contains only digits if len(card_num) != 16 or not card_num.isdigit(): raise ValueError(\\"Card number must be exactly 16 digits long and contain only numeric characters.\\") # Luhn algorithm to validate the credit card number def luhn_checksum(card_num): def digits_of(n): return [int(d) for d in str(n)] digits = digits_of(card_num) odd_digits = digits[-1::-2] even_digits = digits[-2::-2] checksum = sum(odd_digits) for d in even_digits: checksum += sum(digits_of(d * 2)) return checksum % 10 if luhn_checksum(card_num) != 0: raise ValueError(\\"Invalid credit card number.\\") # Format the card number into groups of four digits separated by spaces formatted_card_num = \\" \\".join([card_num[i:i+4] for i in range(0, 16, 4)]) return formatted_card_num"},{"question":"from typing import List def find_combinations(nums: List[int], target: int) -> List[List[int]]: Return all unique combinations of numbers from the input list \`nums\` that add up to the target value. Each number in \`nums\` may be used once in the combination. Examples: >>> find_combinations([2, 3, 6, 7], 7) [[7]] >>> find_combinations([2, 3, 5], 8) [[3, 5]] >>> find_combinations([10, 1, 2, 7, 6, 1, 5], 8) [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]] >>> find_combinations([2, 4, 6], 7) [] pass","solution":"from typing import List def find_combinations(nums: List[int], target: int) -> List[List[int]]: def backtrack(start, path, remaining): if remaining == 0: result.append(list(path)) return if remaining < 0: return for i in range(start, len(nums)): if i > start and nums[i] == nums[i-1]: continue path.append(nums[i]) backtrack(i + 1, path, remaining - nums[i]) path.pop() nums.sort() result = [] backtrack(0, [], target) return result"},{"question":"def median_rating(ratings: list[int]) -> float: Returns the median rating of the given list of ratings. If the list is empty, return 0.0. Parameters: ratings (list[int]): List of integers where each integer is a rating between 1 and 5. Returns: float: The median rating of the product. Examples: >>> median_rating([5, 3, 4, 2, 1]) 3.0 >>> median_rating([5, 3, 4, 4, 2, 1]) 3.5 >>> median_rating([4, 4, 4, 4]) 4.0 >>> median_rating([1]) 1.0 >>> median_rating([]) 0.0","solution":"def median_rating(ratings: list[int]) -> float: Returns the median rating of the given list of ratings. Parameters: ratings (list[int]): List of integers where each integer is a rating between 1 and 5. Returns: float: The median rating of the product. if len(ratings) == 0: return 0.0 # Sort the ratings sorted_ratings = sorted(ratings) n = len(sorted_ratings) # Calculate the median if n % 2 == 1: return float(sorted_ratings[n // 2]) else: mid1 = n // 2 mid2 = mid1 - 1 return (sorted_ratings[mid1] + sorted_ratings[mid2]) / 2.0"},{"question":"def calculate_moving_average(data: List[float], window_size: int) -> List[float]: Compute the moving average of the data points. The moving average for each point is defined as the average of the elements in the window of the specified size, centered at that point. For simplicity, if the window extends beyond the boundaries of the list, consider the missing values as zero. Parameters: data (List[float]): A list of floating-point numbers representing the time-series data. window_size (int): An odd integer representing the size of the window for which the moving average is calculated. Returns: List[float]: A list of floating-point numbers representing the moving average of the input data. >>> calculate_moving_average([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0], 3) [1.0, 2.0, 3.0, 4.0, 5.0, 5.5, 4.0] >>> calculate_moving_average([1.0, 3.0, 5.0, 7.0, 9.0], 3) [2.0, 3.0, 5.0, 7.0, 8.0] pass","solution":"from typing import List def calculate_moving_average(data: List[float], window_size: int) -> List[float]: n = len(data) half_window = window_size // 2 moving_average = [] for i in range(n): start = max(0, i - half_window) end = min(n, i + half_window + 1) window_sum = sum(data[start:end]) norm_factor = end - start moving_average.append(window_sum / norm_factor) return moving_average"},{"question":"def diagonal_sum(matrix: list) -> int: Returns the sum of the elements in both the main diagonal and the secondary diagonal of a given square matrix, ensuring no element is counted twice. >>> diagonal_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 25 >>> diagonal_sum([]) == 0 >>> diagonal_sum([ ... [2] ... ]) == 2 >>> diagonal_sum([ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ]) == 5 pass","solution":"def diagonal_sum(matrix: list) -> int: Returns the sum of the elements in both the main diagonal and the secondary diagonal of a given square matrix, ensuring no element is counted twice. if not matrix: return 0 n = len(matrix) total_sum = 0 for i in range(n): total_sum += matrix[i][i] # main diagonal total_sum += matrix[i][n - 1 - i] # secondary diagonal # If n is odd, subtract the middle element which was added twice if n % 2 == 1: total_sum -= matrix[n // 2][n // 2] return total_sum"}]`),F={name:"App",components:{PoemCard:R},data(){return{searchQuery:"",visibleCount:4,poemsData:E,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},C={class:"search-container"},z={class:"card-container"},I={key:0,class:"empty-state"},S=["disabled"],j={key:0},D={key:1};function P(i,e,l,f,n,a){const m=h("PoemCard");return r(),s("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"prompts chat")])],-1)),t("div",C,[e[3]||(e[3]=t("span",{class:"search-icon"},"",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>n.searchQuery=o),placeholder:"Search..."},null,512),[[b,n.searchQuery]]),n.searchQuery?(r(),s("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>n.searchQuery="")},"  ")):d("",!0)]),t("div",z,[(r(!0),s(y,null,v(a.displayedPoems,(o,p)=>(r(),x(m,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(r(),s("div",I,' No results found for "'+u(n.searchQuery)+'". ',1)):d("",!0)]),a.hasMorePoems?(r(),s("button",{key:0,class:"load-more-button",disabled:n.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[n.isLoading?(r(),s("span",D,"Loading...")):(r(),s("span",j,"See more"))],8,S)):d("",!0)])}const B=c(F,[["render",P],["__scopeId","data-v-c0524bdd"]]),O=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/30.md","filePath":"library/30.md"}'),M={name:"library/30.md"},U=Object.assign(M,{setup(i){return(e,l)=>(r(),s("div",null,[w(B)]))}});export{O as __pageData,U as default};
