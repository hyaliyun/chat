import{_ as c,o as r,c as s,a as t,m as _,t as u,C as h,M as g,U as b,f as d,F as y,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},A={class:"review-title"},L={class:"review-content"};function N(i,e,l,f,n,a){return r(),s("div",q,[t("div",T,[t("div",A,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),_(u(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",L,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),_(u(l.poem.solution),1)])])])}const R=c(k,[["render",N],["__scopeId","data-v-eab63670"]]),E=JSON.parse(`[{"question":"def organize_grades(students): Organizes a list of tuples representing students and their grades into a dictionary where the keys are the grade categories (A, B, C, D, F) and the values are lists of student names. Parameters: students (list of tuples): A list where each tuple contains a student's name and their grade. Returns: dict: A dictionary where keys are grade categories ('A', 'B', 'C', 'D', 'F') and values are lists of student names. Example: >>> organize_grades([(\\"John\\", 85), (\\"Jane\\", 92), (\\"Dave\\", 78), (\\"Sara\\", 62), (\\"Tim\\", 55)]) { 'A': ['Jane'], 'B': ['John'], 'C': ['Dave'], 'D': ['Sara'], 'F': ['Tim'] } def test_organize_grades_typical_case(): result = organize_grades([(\\"John\\", 85), (\\"Jane\\", 92), (\\"Dave\\", 78), (\\"Sara\\", 62), (\\"Tim\\", 55)]) expected = { 'A': ['Jane'], 'B': ['John'], 'C': ['Dave'], 'D': ['Sara'], 'F': ['Tim'] } assert result == expected def test_organize_grades_all_grades_present(): result = organize_grades([(\\"Alice\\", 95), (\\"Bob\\", 88), (\\"Charlie\\", 73), (\\"Diana\\", 67), (\\"Eve\\", 50)]) expected = { 'A': ['Alice'], 'B': ['Bob'], 'C': ['Charlie'], 'D': ['Diana'], 'F': ['Eve'] } assert result == expected def test_organize_grades_empty_input(): result = organize_grades([]) expected = { 'A': [], 'B': [], 'C': [], 'D': [], 'F': [] } assert result == expected def test_organize_grades_no_A_students(): result = organize_grades([(\\"Fiona\\", 75), (\\"George\\", 82), (\\"Harry\\", 68)]) expected = { 'A': [], 'B': ['George'], 'C': ['Fiona'], 'D': ['Harry'], 'F': [] } assert result == expected def test_organize_grades_multiple_students_same_grade(): result = organize_grades([(\\"Ivy\\", 91), (\\"Jack\\", 91), (\\"Kyle\\", 50), (\\"Lydia\\", 50)]) expected = { 'A': ['Ivy', 'Jack'], 'B': [], 'C': [], 'D': [], 'F': ['Kyle', 'Lydia'] } assert result == expected","solution":"def organize_grades(students): Organizes a list of tuples representing students and their grades into a dictionary. Parameters: students (list of tuples): A list where each tuple contains a student's name and their grade. Returns: dict: A dictionary where keys are grade categories ('A', 'B', 'C', 'D', 'F') and values are lists of student names. # Initialize the dictionary with keys for each grade category grade_categories = {'A': [], 'B': [], 'C': [], 'D': [], 'F': []} for name, grade in students: if 90 <= grade <= 100: grade_categories['A'].append(name) elif 80 <= grade <= 89: grade_categories['B'].append(name) elif 70 <= grade <= 79: grade_categories['C'].append(name) elif 60 <= grade <= 69: grade_categories['D'].append(name) elif 0 <= grade <= 59: grade_categories['F'].append(name) return grade_categories"},{"question":"from typing import List def find_divisibles(numbers: List[int], target: int) -> List[int]: Write a function that takes a list of integers and a target integer. The function should return a new list consisting of all integers from the original list that are divisible by the target integer. If no integers in the list are divisible by the target integer, return an empty list. If the target integer is zero, raise a ValueError. >>> find_divisibles([10, 15, 20, 25, 30], 5) == [10, 15, 20, 25, 30] >>> find_divisibles([10, 12, 15, 16, 20], 5) == [10, 15, 20] >>> find_divisibles([1, 2, 3, 4], 5) == [] >>> find_divisibles([-10, -20, 15, 25, 30], 5) == [-10, -20, 15, 25, 30] >>> find_divisibles([0, 10, 20, 30], 10) == [0, 10, 20, 30] >>> find_divisibles([0, 10, 20, 30], 0) Traceback (most recent call last): ... ValueError: Target integer cannot be zero.","solution":"def find_divisibles(numbers, target): Returns a list of integers from the original list that are divisible by the target integer. Parameters: numbers (list): A list of integers. target (int): The target integer. Returns: list: A list of integers divisible by the target integer. if target == 0: raise ValueError(\\"Target integer cannot be zero.\\") return [num for num in numbers if num % target == 0]"},{"question":"def count_frequencies(numbers: List[int]) -> List[Tuple[int, int]]: Takes a list of integers and returns a list of tuples, where each tuple contains an integer from the input list and its frequency of occurrence. The returned list of tuples is sorted by the integers in ascending order. >>> count_frequencies([]) [] >>> count_frequencies([1]) [(1, 1)] >>> count_frequencies([1, 2, 2, 3, 3, 3]) [(1, 1), (2, 2), (3, 3)] >>> count_frequencies([3, 1, 2]) [(1, 1), (2, 1), (3, 1)] >>> count_frequencies([4, 4, 4, 4]) [(4, 4)] >>> count_frequencies([-1, -1, -2]) [(-2, 1), (-1, 2)]","solution":"def count_frequencies(numbers): Takes a list of integers and returns a list of tuples, where each tuple contains an integer from the input list and its frequency of occurrence. The returned list of tuples is sorted by the integers in ascending order. from collections import Counter frequency_dict = Counter(numbers) sorted_items = sorted(frequency_dict.items()) return sorted_items"},{"question":"def longest_subsequence_k_times(s: str, k: int) -> int: Returns the length of the longest possible subsequence in which every character appears at least 'k' times. This function should leverage a divide and conquer strategy to achieve the result efficiently. It avoids the use of Python's built-in functions that would make this task trivial. >>> longest_subsequence_k_times(\\"aaabb\\", 3) 3 >>> longest_subsequence_k_times(\\"ababbc\\", 2) 5 pass def test_empty_string(): assert longest_subsequence_k_times('', 1) == 0 def test_all_characters_meet_threshold(): assert longest_subsequence_k_times('aaabb', 3) == 3 def test_mixed_threshold_characters(): assert longest_subsequence_k_times('ababbc', 2) == 5 def test_no_characters_meet_threshold(): assert longest_subsequence_k_times('abcdef', 2) == 0 def test_all_characters_of_k_frequency(): assert longest_subsequence_k_times('aabbcc', 2) == 6 def test_single_character_string(): assert longest_subsequence_k_times('a', 1) == 1 assert longest_subsequence_k_times('a', 2) == 0 def test_repeating_characters_exceed_threshold(): assert longest_subsequence_k_times('aaabbbccc', 3) == 9","solution":"def longest_subsequence_k_times(s: str, k: int) -> int: Returns the length of the longest possible subsequence in which every character appears at least 'k' times. This function employs a divide and conquer strategy. def helper(start, end): if end - start < k: return 0 count = {} for i in range(start, end): if s[i] in count: count[s[i]] += 1 else: count[s[i]] = 1 for mid in range(start, end): if count[s[mid]] < k: left = helper(start, mid) right = helper(mid + 1, end) return max(left, right) return end - start return helper(0, len(s))"},{"question":"def task1_query(): Returns the SQL query for Task 1. >>> task1_query().strip() 'SELECT b.title, m.member_name, l.return_date FROM loans l JOIN books b ON l.book_id = b.book_id JOIN members m ON l.member_id = m.member_id WHERE l.return_date IS NULL;' def task2_query(branch_id): Returns the SQL query for Task 2 with the specified branch id. >>> task2_query(1).strip() 'SELECT b.title, bb.copies FROM branches_books bb JOIN books b ON bb.book_id = b.book_id WHERE bb.branch_id = 1;' def task3_query(): Returns the SQL query for Task 3. >>> task3_query().strip() 'SELECT a.author_name, COUNT(l.book_id) AS books_borrowed FROM loans l JOIN books b ON l.book_id = b.book_id JOIN authors a ON b.author_id = a.author_id GROUP BY a.author_id, a.author_name ORDER BY books_borrowed DESC LIMIT 3;'","solution":"def task1_query(): Returns the SQL query for Task 1. return SELECT b.title, m.member_name, l.return_date FROM loans l JOIN books b ON l.book_id = b.book_id JOIN members m ON l.member_id = m.member_id WHERE l.return_date IS NULL; def task2_query(branch_id): Returns the SQL query for Task 2 with the specified branch id. return f SELECT b.title, bb.copies FROM branches_books bb JOIN books b ON bb.book_id = b.book_id WHERE bb.branch_id = {branch_id}; def task3_query(): Returns the SQL query for Task 3. return SELECT a.author_name, COUNT(l.book_id) AS books_borrowed FROM loans l JOIN books b ON l.book_id = b.book_id JOIN authors a ON b.author_id = a.author_id GROUP BY a.author_id, a.author_name ORDER BY books_borrowed DESC LIMIT 3;"},{"question":"def find_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. Args: s (str): The input string containing only alphabetic characters. Returns: int: The length of the longest substring without repeating characters. Examples: >>> find_longest_substring(\\"abcabcbb\\") 3 >>> find_longest_substring(\\"bbbbb\\") 1 >>> find_longest_substring(\\"pwwkew\\") 3 # Write your code here def test_find_longest_substring(): assert find_longest_substring(\\"abcabcbb\\") == 3 assert find_longest_substring(\\"bbbbb\\") == 1 assert find_longest_substring(\\"pwwkew\\") == 3 assert find_longest_substring(\\"\\") == 0 assert find_longest_substring(\\"abcdef\\") == 6 assert find_longest_substring(\\"aabbcc\\") == 2 assert find_longest_substring(\\"au\\") == 2 assert find_longest_substring(\\"dvdf\\") == 3 assert find_longest_substring(\\"anviaj\\") == 5 assert find_longest_substring(\\"tmmzuxt\\") == 5","solution":"def find_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. Args: s (str): The input string containing only alphabetic characters. Returns: int: The length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"def next_permutation(nums): Modifies the list nums in-place to the next permutation in numerical order. If the list is sorted in descending order, rearrange it to ascending order. Example: >>> nums = [1, 2, 3] >>> next_permutation(nums) >>> nums [1, 3, 2] >>> nums = [3, 2, 1] >>> next_permutation(nums) >>> nums [1, 2, 3] >>> nums = [1, 1, 5] >>> next_permutation(nums) >>> nums [1, 5, 1] def test_next_permutation(): nums = [1, 2, 3] next_permutation(nums) assert nums == [1, 3, 2] nums = [3, 2, 1] next_permutation(nums) assert nums == [1, 2, 3] nums = [1, 1, 5] next_permutation(nums) assert nums == [1, 5, 1] nums = [1] next_permutation(nums) assert nums == [1] nums = [7, 7, 7] next_permutation(nums) assert nums == [7, 7, 7] nums = [1, 2] next_permutation(nums) assert nums == [2, 1] nums = [1, 5, 1] next_permutation(nums) assert nums == [5, 1, 1]","solution":"def next_permutation(nums): Modifies the list nums in-place to the next permutation in numerical order. If the list is sorted in descending order, rearrange it to ascending order. # Find the first descending element from the end i = len(nums) - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 if i >= 0: # Find the element just larger than nums[i] j = len(nums) - 1 while nums[j] <= nums[i]: j -= 1 # Swap elements at indices i and j nums[i], nums[j] = nums[j], nums[i] # Reverse the elements from index i+1 to the end of the list nums[i + 1:] = reversed(nums[i + 1:])"},{"question":"def merge_intervals(intervals): Merges overlapping or contiguous intervals. :param intervals: List of tuples, where each tuple contains two integers (start, end). :return: List of merged intervals. >>> merge_intervals([(1, 3), (2, 6), (8, 10), (15, 18)]) [(1, 6), (8, 10), (15, 18)] >>> merge_intervals([(1, 4), (4, 5)]) [(1, 5)] >>> merge_intervals([(1, 4), (5, 6), (7, 8), (2, 5), (9, 10)]) [(1, 6), (7, 8), (9, 10)] >>> merge_intervals([(1, 10)]) [(1, 10)] >>> merge_intervals([(1, 2), (3, 4), (5, 6)]) [(1, 2), (3, 4), (5, 6)] >>> merge_intervals([]) [] >>> merge_intervals([(1, 10), (2, 6), (8, 10)]) [(1, 10)]","solution":"def merge_intervals(intervals): Merges overlapping or contiguous intervals. :param intervals: List of tuples, where each tuple contains two integers (start, end). :return: List of merged intervals. if not intervals: return [] # Sort the intervals based on the starting value intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: last = merged[-1] if current[0] <= last[1]: # Overlapping or contiguous intervals merged[-1] = (last[0], max(last[1], current[1])) else: # Non-overlapping interval merged.append(current) return merged"},{"question":"def char_frequency(input_string: str) -> dict: Returns a dictionary with the frequency of each alphanumeric character in the input string. The function is case-insensitive and non-alphanumeric characters are excluded from the count. >>> char_frequency(\\"Hello, World!\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> char_frequency(\\"\\") {} >>> char_frequency(\\"!!!123ABCabc@#\\") {'1': 1, '2': 1, '3': 1, 'a': 2, 'b': 2, 'c': 2} >>> char_frequency(\\"AaAa\\") {'a': 4}","solution":"def char_frequency(input_string): Returns a dictionary with the frequency of each alphanumeric character in the input string. The function is case-insensitive and non-alphanumeric characters are excluded from the count. frequency = {} for char in input_string.lower(): if char.isalnum(): if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"def char_frequency(s: str) -> dict: Returns a dictionary where the keys are the characters in the string and the values are the frequency of their occurrence, but only for characters that appear more than once. >>> char_frequency(\\"abcdefg\\") == {} >>> char_frequency(\\"aabbcc\\") == {'a': 2, 'b': 2, 'c': 2} >>> char_frequency(\\"aabbc\\") == {'a': 2, 'b': 2} >>> char_frequency(\\"abcabc\\") == {'a': 2, 'b': 2, 'c': 2} >>> char_frequency(\\"a\\") == {} >>> char_frequency(\\"aaa\\") == {'a': 3} >>> char_frequency(\\"\\") == {} >>> char_frequency(\\"!!%%^^\\") == {'!': 2, '': 2, '%': 2, '^': 2}","solution":"def char_frequency(s): Returns a dictionary with characters that appear more than once in the string s and their frequency of occurrence. frequency = {} for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return {char: count for char, count in frequency.items() if count > 1}"},{"question":"from typing import List def shift_elements(lst: List[int], k: int) -> List[int]: Returns a new list where each element of the given list is shifted to the right by k positions. If the shift leads to the end of the list, it wraps around to the beginning. The input list remains unchanged. Parameters: lst (List[int]): The list of integers to be shifted. k (int): The number of positions to shift the elements to the right. Returns: List[int]: A new list with the elements shifted to the right by k positions. >>> shift_elements([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> shift_elements([10, 20, 30, 40], 1) [40, 10, 20, 30] >>> shift_elements([7, 8, 9], 4) [9, 7, 8] >>> shift_elements([], 3) [] >>> shift_elements([1, 2, 3], 0) [1, 2, 3] >>> shift_elements([1, 2, 3], 6) [1, 2, 3] >>> shift_elements([1, 2, 3], 7) [3, 1, 2]","solution":"from typing import List def shift_elements(lst: List[int], k: int) -> List[int]: Returns a new list where each element of the given list is shifted to the right by k positions. If the shift leads to the end of the list, it wraps around to the beginning. if not lst: return [] n = len(lst) k = k % n # To avoid unnecessary full cycle shifts return lst[-k:] + lst[:-k]"},{"question":"from typing import List def can_partition(nums: List[int]) -> bool: Determines if a given list of integers can be partitioned into two subsets such that the sum of elements in both subsets is equal. Example: >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False >>> can_partition([1, 1, 1, 1]) True >>> can_partition([1, 1, 1]) False >>> can_partition([2, 2, 3, 5]) False >>> can_partition([10]) False >>> can_partition([]) True >>> can_partition([100, 200, 300, 400, 500]) False","solution":"def can_partition(nums): Determines if a given list of integers can be partitioned into two subsets such that the sum of elements in both subsets is equal. :param nums: List of integers :return: True if the list can be partitioned into two subsets with equal sum, False otherwise total_sum = sum(nums) # If the total sum is odd, it's not possible to partition into two subsets with equal sum if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Create a DP array to store whether a sum is possible with any subset of nums dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"import re class InvalidRomanNumeralException(Exception): pass def validate_roman_numeral(s: str) -> bool: Validates whether a given string is a valid Roman numeral. >>> validate_roman_numeral(\\"IX\\") == True >>> validate_roman_numeral(\\"IIII\\") == False def roman_to_int(s: str) -> int: Converts a valid Roman numeral string to its integer value. Raises an InvalidRomanNumeralException for invalid inputs. >>> roman_to_int(\\"III\\") == 3 >>> roman_to_int(\\"IV\\") == 4 # Test cases def test_validate_roman_numeral(): assert validate_roman_numeral(\\"IX\\") == True assert validate_roman_numeral(\\"MCMXCIV\\") == True assert validate_roman_numeral(\\"IIII\\") == False assert validate_roman_numeral(\\"IC\\") == False assert validate_roman_numeral(\\"MMMM\\") == False assert validate_roman_numeral(\\"XIC\\") == False def test_roman_to_int_valid(): assert roman_to_int(\\"III\\") == 3 assert roman_to_int(\\"IV\\") == 4 assert roman_to_int(\\"IX\\") == 9 assert roman_to_int(\\"LVIII\\") == 58 assert roman_to_int(\\"MCMXCIV\\") == 1994 assert roman_to_int(\\"MMMCMXCIX\\") == 3999 def test_roman_to_int_invalid(): import pytest with pytest.raises(InvalidRomanNumeralException): roman_to_int(\\"IIII\\") with pytest.raises(InvalidRomanNumeralException): roman_to_int(\\"IC\\") with pytest.raises(InvalidRomanNumeralException): roman_to_int(\\"MMMM\\") with pytest.raises(InvalidRomanNumeralException): roman_to_int(\\"XIC\\")","solution":"import re class InvalidRomanNumeralException(Exception): pass def validate_roman_numeral(s): Validates whether a given string is a valid Roman numeral. pattern = re.compile( \\"^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})\\" ) return pattern.match(s) is not None def roman_to_int(s): Converts a valid Roman numeral string to its integer value. Raises an InvalidRomanNumeralException for invalid inputs. if not validate_roman_numeral(s): raise InvalidRomanNumeralException(f\\"Invalid Roman numeral: {s}\\") roman_to_integer = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } integer_value = 0 n = len(s) for i in range(n): if i + 1 < n and roman_to_integer[s[i]] < roman_to_integer[s[i + 1]]: integer_value -= roman_to_integer[s[i]] else: integer_value += roman_to_integer[s[i]] return integer_value"},{"question":"class Inventory: def __init__(self): self.items = {} def add_item(self, item: str, quantity: int): Adds a specified quantity of an item to the inventory. The item is represented by a string, and the quantity is an integer. If the item already exists in the inventory, increment its quantity; otherwise, add the item with the specified quantity. pass def remove_item(self, item: str, quantity: int) -> bool: Removes a specified quantity of an item from the inventory. The item is represented by a string, and the quantity is an integer. If the item doesn't exist or the quantity to be removed is greater than the available quantity, return False; otherwise, decrement its quantity and return True. pass def check_inventory(self, item: str) -> int: Returns the current quantity of the specified item. If the item doesn't exist, return 0. pass # Example usage inventory = Inventory() inventory.add_item(\\"apple\\", 10) inventory.add_item(\\"banana\\", 5) print(inventory.check_inventory(\\"apple\\")) # Output: 10 print(inventory.remove_item(\\"apple\\", 3)) # Output: True print(inventory.check_inventory(\\"apple\\")) # Output: 7 print(inventory.remove_item(\\"apple\\", 8)) # Output: False print(inventory.check_inventory(\\"apple\\")) # Output: 7 def test_add_item_new_item(): inventory = Inventory() inventory.add_item(\\"apple\\", 10) assert inventory.check_inventory(\\"apple\\") == 10 def test_add_item_existing_item(): inventory = Inventory() inventory.add_item(\\"apple\\", 10) inventory.add_item(\\"apple\\", 5) assert inventory.check_inventory(\\"apple\\") == 15 def test_remove_item_success(): inventory = Inventory() inventory.add_item(\\"apple\\", 10) result = inventory.remove_item(\\"apple\\", 5) assert result == True assert inventory.check_inventory(\\"apple\\") == 5 def test_remove_item_underflow(): inventory = Inventory() inventory.add_item(\\"apple\\", 10) result = inventory.remove_item(\\"apple\\", 15) assert result == False assert inventory.check_inventory(\\"apple\\") == 10 def test_remove_item_non_existent(): inventory = Inventory() result = inventory.remove_item(\\"banana\\", 5) assert result == False assert inventory.check_inventory(\\"banana\\") == 0 def test_check_inventory_non_existent(): inventory = Inventory() assert inventory.check_inventory(\\"banana\\") == 0 def test_remove_item_full_quantity(): inventory = Inventory() inventory.add_item(\\"apple\\", 5) result = inventory.remove_item(\\"apple\\", 5) assert result == True assert inventory.check_inventory(\\"apple\\") == 0","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, item: str, quantity: int): if item in self.items: self.items[item] += quantity else: self.items[item] = quantity def remove_item(self, item: str, quantity: int) -> bool: if item in self.items and self.items[item] >= quantity: self.items[item] -= quantity if self.items[item] == 0: del self.items[item] return True return False def check_inventory(self, item: str) -> int: return self.items.get(item, 0)"},{"question":"class ReservationSystem: def __init__(self, table_count: int): Initializes the system with a specified number of tables. pass def reserve(self, client_id: int, time_slot: str) -> bool: Books a table for the client for the specified time slot. If all tables are booked for that time slot, the reservation request is denied. Args: client_id (int): ID of the client. time_slot (str): Desired time slot for reservation. Returns: bool: True if reservation is successful, False otherwise. pass def cancel(self, client_id: int, time_slot: str) -> bool: Cancels the reservation for the client for the specified time slot. Args: client_id (int): ID of the client. time_slot (str): Desired time slot for cancellation. Returns: bool: True if cancellation is successful, False otherwise. pass def get_reservations(self, time_slot: str) -> list: Returns a list of client IDs who have reserved tables for the specified time slot. Args: time_slot (str): Desired time slot. Returns: list: List of client IDs with reservations. pass def available_tables(self, time_slot: str) -> int: Returns the number of available tables for the specified time slot. Args: time_slot (str): Desired time slot. Returns: int: Number of available tables. pass # Unit tests def test_initialization(): system = ReservationSystem(5) assert system.table_count == 5 assert system.reservations == {} def test_reserve(): system = ReservationSystem(2) assert system.reserve(1, \\"18:00\\") == True assert system.reserve(2, \\"18:00\\") == True assert system.reserve(3, \\"18:00\\") == False def test_double_book(): system = ReservationSystem(2) assert system.reserve(1, \\"18:00\\") == True assert system.reserve(1, \\"18:00\\") == False def test_cancel(): system = ReservationSystem(2) assert system.reserve(1, \\"18:00\\") == True assert system.cancel(1, \\"18:00\\") == True assert system.cancel(1, \\"18:00\\") == False def test_get_reservations(): system = ReservationSystem(2) assert system.reserve(1, \\"18:00\\") == True assert system.get_reservations(\\"18:00\\") == [1] def test_available_tables(): system = ReservationSystem(2) assert system.available_tables(\\"18:00\\") == 2 system.reserve(1, \\"18:00\\") assert system.available_tables(\\"18:00\\") == 1 system.reserve(2, \\"18:00\\") assert system.available_tables(\\"18:00\\") == 0 system.cancel(1, \\"18:00\\") assert system.available_tables(\\"18:00\\") == 1 def test_combined_scenario(): system = ReservationSystem(2) assert system.reserve(1, \\"18:00\\") == True assert system.reserve(2, \\"18:00\\") == True assert system.reserve(3, \\"18:00\\") == False assert system.get_reservations(\\"18:00\\") == [1, 2] assert system.available_tables(\\"18:00\\") == 0 assert system.cancel(1, \\"18:00\\") == True assert system.reserve(3, \\"18:00\\") == True assert system.get_reservations(\\"18:00\\") == [2, 3] assert system.available_tables(\\"18:00\\") == 0","solution":"class ReservationSystem: def __init__(self, table_count: int): self.table_count = table_count self.reservations = {} def reserve(self, client_id: int, time_slot: str) -> bool: if time_slot not in self.reservations: self.reservations[time_slot] = [] if len(self.reservations[time_slot]) < self.table_count and client_id not in self.reservations[time_slot]: self.reservations[time_slot].append(client_id) return True return False def cancel(self, client_id: int, time_slot: str) -> bool: if time_slot in self.reservations and client_id in self.reservations[time_slot]: self.reservations[time_slot].remove(client_id) return True return False def get_reservations(self, time_slot: str) -> list: return self.reservations.get(time_slot, []) def available_tables(self, time_slot: str) -> int: if time_slot in self.reservations: used_tables = len(self.reservations[time_slot]) else: used_tables = 0 return self.table_count - used_tables"},{"question":"def find_pairs_with_sum(arr, target_sum): Finds all unique pairs of integers in the array that sum up to the given target sum. Each pair (a, b) is ordered such that a <= b. :param arr: List of integers. :param target_sum: The target sum for the pairs. :return: List of unique pairs (tuples) that sum up to the target sum. >>> find_pairs_with_sum([1, 2, 3, 4, 3], 6) [(2, 4), (3, 3)] >>> find_pairs_with_sum([1, 2, 3, 4, 5], 10) [] >>> find_pairs_with_sum([-1, -2, -3, -4, 1, 2, 3, 4], 0) [(-4, 4), (-3, 3), (-2, 2), (-1, 1)] >>> find_pairs_with_sum([1, 2, 2, 3, 4], 5) [(1, 4), (2, 3)] >>> find_pairs_with_sum([], 5) [] >>> find_pairs_with_sum([5], 5) [] >>> find_pairs_with_sum([3, 3, 3, 3], 6) [(3, 3)]","solution":"def find_pairs_with_sum(arr, target_sum): Finds all unique pairs of integers in the array that sum up to the given target sum. Each pair (a, b) is ordered such that a <= b. :param arr: List of integers. :param target_sum: The target sum for the pairs. :return: List of unique pairs (tuples) that sum up to the target sum. seen = set() pairs = set() for number in arr: complement = target_sum - number if complement in seen: pair = tuple(sorted((number, complement))) pairs.add(pair) seen.add(number) return list(pairs)"},{"question":"def demonstrate_while_loop(n): Demonstrates a while loop that prints numbers from 0 to n-1. Example: >>> demonstrate_while_loop(5) [0, 1, 2, 3, 4] >>> demonstrate_while_loop(0) [] >>> demonstrate_while_loop(1) [0] pass def demonstrate_for_loop(n): Demonstrates a for loop that prints numbers from 0 to n-1. Example: >>> demonstrate_for_loop(5) [0, 1, 2, 3, 4] >>> demonstrate_for_loop(0) [] >>> demonstrate_for_loop(1) [0] pass # Unit tests def test_demonstrate_while_loop(): assert demonstrate_while_loop(5) == [0, 1, 2, 3, 4] assert demonstrate_while_loop(0) == [] assert demonstrate_while_loop(1) == [0] def test_demonstrate_for_loop(): assert demonstrate_for_loop(5) == [0, 1, 2, 3, 4] assert demonstrate_for_loop(0) == [] assert demonstrate_for_loop(1) == [0]","solution":"def demonstrate_while_loop(n): Demonstrates a while loop that prints numbers from 0 to n-1. i = 0 results = [] while i < n: results.append(i) i += 1 return results def demonstrate_for_loop(n): Demonstrates a for loop that prints numbers from 0 to n-1. results = [] for i in range(n): results.append(i) return results"},{"question":"def count_occurrences(nums: List[int]) -> Dict[int, int]: Create a function that accepts a list of integers and returns a dictionary where the keys are the unique integers from the list and the values are the number of times each integer appears in the list. Ensure that the function handles an empty list properly by returning an empty dictionary. >>> count_occurrences([]) == {} >>> count_occurrences([4]) == {4: 1} >>> count_occurrences([1, 2, 3]) == {1: 1, 2: 1, 3: 1} >>> count_occurrences([1, 1, 1, 2, 2, 3]) == {1: 3, 2: 2, 3: 1} >>> count_occurrences([5, 5, 5, 6, 7, 7, 8, 8, 8, 8]) == {5: 3, 6: 1, 7: 2, 8: 4}","solution":"def count_occurrences(nums): Takes a list of integers and returns a dictionary with unique integers as keys and their counts as values. :param nums: List of integers :return: Dictionary with integers as keys and their counts as values result = {} for num in nums: if num in result: result[num] += 1 else: result[num] = 1 return result"},{"question":"import heapq def dijkstra(graph, start, end): Calculate the shortest path between two nodes in a weighted, undirected graph using Dijkstra's algorithm. Parameters: - graph: dict, adjacency list where keys are nodes and values are lists of tuples (neighbor, weight) - start: starting node - end: ending node Returns: - list of nodes representing the shortest path from start to end >>> sample_graph = { ... 'A': [('B', 1), ('C', 4)], ... 'B': [('A', 1), ('C', 2), ('D', 5)], ... 'C': [('A', 4), ('B', 2), ('D', 1)], ... 'D': [('B', 5), ('C', 1)] ... } >>> dijkstra(sample_graph, 'A', 'D') ['A', 'B', 'C', 'D'] >>> dijkstra(sample_graph, 'A', 'E') None >>> dijkstra(sample_graph, 'A', 'A') ['A'] >>> dijkstra(sample_graph, 'B', 'D') ['B', 'C', 'D'] >>> dijkstra(sample_graph, 'C', 'A') ['C', 'B', 'A']","solution":"import heapq def dijkstra(graph, start, end): Calculate the shortest path between two nodes in a weighted, undirected graph using Dijkstra's algorithm. Parameters: - graph: dict, adjacency list where keys are nodes and values are lists of tuples (neighbor, weight) - start: starting node - end: ending node Returns: - list of nodes representing the shortest path from start to end # Priority queue to hold nodes to explore queue = [(0, start, [])] heapq.heapify(queue) # Dictionary to hold the shortest path to each node visited = {} while queue: (cost, node, path) = heapq.heappop(queue) # Skip processing if node was already visited with a shorter path if node in visited: continue # Extend the path with the current node path = path + [node] visited[node] = cost # Return path if end node is reached if node == end: return path # Process neighbors for neighbor, weight in graph.get(node, []): if neighbor not in visited: heapq.heappush(queue, (cost + weight, neighbor, path)) return None # If there's no valid path # Sample graph for testing sample_graph = { 'A': [('B', 1), ('C', 4)], 'B': [('A', 1), ('C', 2), ('D', 5)], 'C': [('A', 4), ('B', 2), ('D', 1)], 'D': [('B', 5), ('C', 1)] }"},{"question":"def max_product(nums): Write a function that finds the maximum product of two distinct elements in a list. The function should handle both positive and negative numbers in the list, and it should not use inbuilt or third-party libraries for finding the product. Ensure the solution is optimized for large input sizes. Returns the maximum product of two distinct elements in the list. >>> max_product([1, 10, 2, 6]) == 60 >>> max_product([-10, -3, -5, -6, -2]) == 60 >>> max_product([-10, -20, 5, 1]) == 200 >>> max_product([0, -1, 3, 100]) == 300 >>> max_product([1, 2]) == 2 >>> max_product([3, 3, 3]) == 9 >>> max_product([1000, 2000, 3000, -4000, -5000]) == 20000000 >>> max_product([5]) == ValueError(\\"At least two distinct elements are required\\")","solution":"def max_product(nums): Returns the maximum product of two distinct elements in the list. if len(nums) < 2: raise ValueError(\\"At least two distinct elements are required\\") # Initialize the two largest and two smallest values max1 = max2 = float('-inf') min1 = min2 = float('inf') for num in nums: # Update the two largest values if num > max1: max2 = max1 max1 = num elif num > max2: max2 = num # Update the two smallest values if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num # The maximum product could be the product of the two largest # or the product of the two smallest (if they are both negative) return max(max1 * max2, min1 * min2)"},{"question":"def double_characters(input_string: str) -> str: Returns a new string where each character in the original string is repeated once. Validates that input_string is a non-empty string composed only of alphabetic characters. >>> double_characters(\\"hello\\") 'hheelllloo' >>> double_characters(\\"Hello\\") 'HHeelllloo' >>> double_characters(\\"a\\") 'aa' >>> double_characters(\\"\\") Traceback (most recent call last): ... ValueError: Input must be a non-empty string of alphabetic characters. >>> double_characters(\\"hello123\\") Traceback (most recent call last): ... ValueError: Input must be a non-empty string of alphabetic characters.","solution":"def double_characters(input_string): Returns a new string where each character in the original string is repeated once. Validates that input_string is a non-empty string composed only of alphabetic characters. if not isinstance(input_string, str) or not input_string.isalpha(): raise ValueError(\\"Input must be a non-empty string of alphabetic characters.\\") result = ''.join([char * 2 for char in input_string]) return result"},{"question":"def unique_strings(input_list: List[str]) -> List[str]: Returns a new list containing only the unique strings from the input list. The comparison is case-insensitive and ignores leading/trailing whitespace. Args: input_list (list): List of strings. Returns: list: List of unique strings preserving the order of first occurrence. Examples: >>> unique_strings([\\" Apple \\", \\"banana\\", \\"apple\\", \\" Banana\\", \\"CHERRY\\", \\" cherry \\"]) [\\" Apple \\", \\"banana\\", \\"CHERRY\\"] >>> unique_strings([\\"hello\\", \\"HELLO\\", \\"Hello \\", \\"world\\", \\" WORLD\\"]) [\\"hello\\", \\"world\\"] # Test Cases def test_unique_strings_case_insensitivity(): assert unique_strings([\\" Apple \\", \\"banana\\", \\"apple\\", \\" Banana\\", \\"CHERRY\\", \\" cherry \\"]) == [\\" Apple \\", \\"banana\\", \\"CHERRY\\"] def test_unique_strings_with_whitespace(): assert unique_strings([\\"hello\\", \\"HELLO\\", \\"Hello \\", \\"world\\", \\" WORLD\\"]) == [\\"hello\\", \\"world\\"] def test_unique_strings_mixed_case_and_whitespace(): assert unique_strings([\\" test\\", \\"Test\\", \\"TEST \\", \\"example\\", \\"Example \\"]) == [\\" test\\", \\"example\\"] def test_unique_strings_all_unique(): assert unique_strings([\\"123\\", \\" 456\\", \\"seven\\", \\"Eight\\", \\" NINE \\"]) == [\\"123\\", \\" 456\\", \\"seven\\", \\"Eight\\", \\" NINE \\"] def test_unique_strings_all_duplicates(): assert unique_strings([\\"SAME\\", \\" same \\", \\"SAME\\"]) == [\\"SAME\\"] def test_unique_strings_empty_list(): assert unique_strings([]) == []","solution":"def unique_strings(input_list): Returns a new list containing only the unique strings from the input list. The comparison is case-insensitive and ignores leading/trailing whitespace. Args: input_list (list): List of strings. Returns: list: List of unique strings preserving the order of first occurrence. seen = set() unique_list = [] for string in input_list: normalized_string = string.strip().lower() if normalized_string not in seen: seen.add(normalized_string) unique_list.append(string) return unique_list"},{"question":"def vowel_positions(s: str) -> Dict[str, List[int]]: Write a function that accepts a string and returns a dictionary. The key in the dictionary should be the distinct vowel in the string (case-insensitive) and the value should be a list of positions (starting from 0) where that specific vowel occurs in the string. Ignore all the characters that are not vowels. >>> vowel_positions('Hello World') {'e': [1], 'o': [4, 7]} >>> vowel_positions('AEIOU') {'a': [0], 'e': [1], 'i': [2], 'o': [3], 'u': [4]} >>> vowel_positions('banana') {'a': [1, 3, 5]} >>> vowel_positions('bcdfg') {} >>> vowel_positions('aeaeiouuu') {'a': [0, 2], 'e': [1, 3], 'i': [4], 'o': [5], 'u': [6, 7, 8]}","solution":"def vowel_positions(s): Returns a dictionary where the key is a distinct vowel (case-insensitive) and the value is a list of positions (0-based index) where the vowel occurs. vowels = \\"aeiou\\" result = {} for index, char in enumerate(s.lower()): if char in vowels: if char not in result: result[char] = [] result[char].append(index) return result"},{"question":"def find_unique_number(input_list: List[int]) -> int: Returns the integer that appears only once in the input list. The function has linear runtime complexity and does not use extra space for storage. >>> find_unique_number([1, 2, 3, 2, 1, 4, 5, 4, 3]) 5 >>> find_unique_number([10, 14, 14, 10, 3]) 3 >>> find_unique_number([4, 3, 3, 2, 4, 2, 5]) 5 >>> find_unique_number([6, 7, 10, 9, 9, 7, 10]) 6 >>> find_unique_number(list(range(1, 100001)) * 2 + [123456789]) 123456789","solution":"def find_unique_number(input_list): Returns the integer that appears only once in the input list. The function has linear runtime complexity and does not use extra space for storage. # Using bitwise XOR operator to find the unique number unique_number = 0 for num in input_list: unique_number ^= num return unique_number"},{"question":"def sort_books_by_author(books: list) -> list: Sorts a list of book dictionaries by the author's last name in alphabetical order, handling case variations in names and skipping malformed entries. Parameters: books (list of dict): The dataset containing information about books. Returns: list of dict: The sorted list of book dictionaries. Examples: >>> sort_books_by_author([ ... {'title': 'Book A', 'author': 'John Smith', 'year_published': 2001}, ... {'title': 'Book B', 'author': 'Alice Johnson', 'year_published': 1999}, ... {'title': 'Book C', 'author': 'Bob Hill', 'year_published': 2010} ... ]) [{'title': 'Book C', 'author': 'Bob Hill', 'year_published': 2010}, {'title': 'Book B', 'author': 'Alice Johnson', 'year_published': 1999}, {'title': 'Book A', 'author': 'John Smith', 'year_published': 2001}] >>> sort_books_by_author([]) [] >>> sort_books_by_author([ ... {'title': 'Book A', 'author': 'john Smith', 'year_published': 2001}, ... {'title': 'Book B', 'author': 'Alice johnson', 'year_published': 1999}, ... {'title': 'Book C', 'author': 'bob Hill', 'year_published': 2010} ... ]) [{'title': 'Book C', 'author': 'bob Hill', 'year_published': 2010}, {'title': 'Book B', 'author': 'Alice johnson', 'year_published': 1999}, {'title': 'Book A', 'author': 'john Smith', 'year_published': 2001}]","solution":"def sort_books_by_author(books): Sorts a list of book dictionaries by the author's last name in alphabetical order. Parameters: books (list of dict): The dataset containing information about books. Returns: list of dict: The sorted list of book dictionaries. valid_books = [] for book in books: author = book.get('author') if author and isinstance(author, str): name_parts = author.split() if len(name_parts) >= 2: valid_books.append(book) # Sorting valid books based on author's last name (case-insensitive) sorted_books = sorted(valid_books, key=lambda x: x['author'].split()[-1].lower()) return sorted_books"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring('abrkaabcdefghijjxxx') 10 >>> length_of_longest_substring('') 0 >>> length_of_longest_substring('abcdefgh') 8 >>> length_of_longest_substring('aaaaaaa') 1 >>> length_of_longest_substring('abcabcbb') 3 >>> length_of_longest_substring('pwwkew') 3 >>> length_of_longest_substring('abba') 2","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_map = {} longest = 0 start = 0 for end, char in enumerate(s): if char in char_map: start = max(start, char_map[char] + 1) char_map[char] = end longest = max(longest, end - start + 1) return longest"},{"question":"def isMountainArray(arr): Determine if the list of integers represents a valid Mountain Array. A Mountain Array is defined as an array where: 1. The length of the array is at least 3. 2. There exists some index \`i\` such that \`A[0] < A[1] < ... < A[i]\` and \`A[i] > A[i + 1] > ... > A[A.length - 1]\`. >>> isMountainArray([2, 1]) False >>> isMountainArray([3, 5, 5]) False >>> isMountainArray([0, 3, 2, 1]) True >>> isMountainArray([1, 2, 3]) False >>> isMountainArray([3, 2, 1]) False >>> isMountainArray([1, 3, 4, 5]) False >>> isMountainArray([5, 3, 1]) False >>> isMountainArray([1, 2, 3, 4, 3, 2, 1]) True >>> isMountainArray([1, 3, 3, 2, 1]) False","solution":"def isMountainArray(arr): Returns True if the input list is a valid Mountain Array, otherwise False. if len(arr) < 3: return False i = 1 # ascending while i < len(arr) and arr[i] > arr[i - 1]: i += 1 # peak can't be first or last if i == 1 or i == len(arr): return False # descending while i < len(arr) and arr[i] < arr[i - 1]: i += 1 return i == len(arr)"},{"question":"def find_unique_common_elements(arr1: List[int], arr2: List[int]) -> List[int]: Create a function that takes two arrays of integers as inputs and returns an array containing only the unique integers that appear in both input arrays. The order of appearance in the output should follow their order of appearance in the first input array. Duplicate integers should be included only once in the output. >>> find_unique_common_elements([3, 1, 2, 4, 3], [1, 2, 3, 5]) [3, 1, 2] >>> find_unique_common_elements([1, 2, 3], [4, 5, 6]) [] >>> find_unique_common_elements([1, 2, 3], [3, 2, 1]) [1, 2, 3] >>> find_unique_common_elements([1, 2, 2, 3, 3], [2, 2, 3, 3]) [2, 3] >>> find_unique_common_elements([], [1, 2, 3]) [] >>> find_unique_common_elements([1, 2, 3], []) [] >>> find_unique_common_elements([], []) []","solution":"def find_unique_common_elements(arr1, arr2): Returns an array containing only the unique integers that appear in both input arrays. The output follows the order of appearance in the first input array and excludes duplicates. # Use a set to keep track of unique elements in arr2 set_arr2 = set(arr2) # Create an ordered set to keep unique common elements in the order they appear in arr1 unique_common_elements = [] for num in arr1: if num in set_arr2 and num not in unique_common_elements: unique_common_elements.append(num) return unique_common_elements"},{"question":"def longest_substring_with_k_distinct(s: str, k: int) -> int: Implement a function that takes a string \`s\` and an integer \`k\`, and returns the length of the longest substring of \`s\` that contains at most \`k\` distinct characters. Examples: >>> longest_substring_with_k_distinct(\\"eceba\\", 2) 3 >>> longest_substring_with_k_distinct(\\"aaa\\", 1) 3 >>> longest_substring_with_k_distinct(\\"\\", 2) 0 >>> longest_substring_with_k_distinct(\\"abc\\", 0) 0 >>> longest_substring_with_k_distinct(\\"aabc\\", 1) 2 from solution import longest_substring_with_k_distinct def test_longest_substring_with_2_distinct(): assert longest_substring_with_k_distinct(\\"eceba\\", 2) == 3 def test_longest_substring_all_same_characters(): assert longest_substring_with_k_distinct(\\"aaa\\", 1) == 3 def test_longest_substring_empty_string(): assert longest_substring_with_k_distinct(\\"\\", 2) == 0 def test_longest_substring_k_is_zero(): assert longest_substring_with_k_distinct(\\"abc\\", 0) == 0 def test_longest_substring_single_character_repetition(): assert longest_substring_with_k_distinct(\\"aabc\\", 1) == 2 def test_longest_substring_with_3_distinct(): assert longest_substring_with_k_distinct(\\"abcadcacacaca\\", 3) == 11 def test_longest_substring_with_more_distinct_than_string(): assert longest_substring_with_k_distinct(\\"a\\", 2) == 1 assert longest_substring_with_k_distinct(\\"abc\\", 5) == 3 def test_longest_substring_with_no_repetitions(): assert longest_substring_with_k_distinct(\\"a\\", 1) == 1 assert longest_substring_with_k_distinct(\\"abcdef\\", 3) == 3 def test_longest_substring_various_distinct_char_count(): assert longest_substring_with_k_distinct(\\"aaabbbccc\\", 1) == 3 assert longest_substring_with_k_distinct(\\"aaabbbccc\\", 2) == 6 assert longest_substring_with_k_distinct(\\"aaabbbccc\\", 3) == 9","solution":"def longest_substring_with_k_distinct(s: str, k: int) -> int: Returns the length of the longest substring with at most k distinct characters. if k == 0 or not s: return 0 from collections import defaultdict char_map = defaultdict(int) left = 0 max_length = 0 for right in range(len(s)): char_map[s[right]] += 1 while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"import random import string def generate_random_string() -> str: Generates a random 12-character string with at least one uppercase letter, one lowercase letter, one digit, and one special character, while ensuring all characters are unique and no character repeats. pass def test_string_length(): assert len(generate_random_string()) == 12 def test_contains_uppercase(): result = generate_random_string() assert any(c.isupper() for c in result) def test_contains_lowercase(): result = generate_random_string() assert any(c.islower() for c in result) def test_contains_digit(): result = generate_random_string() assert any(c.isdigit() for c in result) def test_contains_special_character(): special_characters = string.punctuation result = generate_random_string() assert any(c in special_characters for c in result) def test_unique_characters(): result = generate_random_string() assert len(set(result)) == 12 def test_multiple_generations(): results = [generate_random_string() for _ in range(1000)] # Check for unique strings over multiple generations assert len(results) == len(set(results))","solution":"import random import string def generate_random_string(): Generates a random 12-character string with at least one uppercase letter, one lowercase letter, one digit, and one special character, while ensuring all characters are unique and no character repeats. uppercase = random.choice(string.ascii_uppercase) lowercase = random.choice(string.ascii_lowercase) digit = random.choice(string.digits) special_char = random.choice(string.punctuation) # Pool of characters to choose from to fill the remaining characters all_chars = string.ascii_letters + string.digits + string.punctuation # Ensuring that chosen characters are not repeated in the string chosen_chars = set(uppercase + lowercase + digit + special_char) while len(chosen_chars) < 12: char = random.choice(all_chars) if char not in chosen_chars: chosen_chars.add(char) # Converting the set back to a list, ensuring randomness in sequence random_string_list = list(chosen_chars) random.shuffle(random_string_list) return ''.join(random_string_list)"},{"question":"def find_second_largest(lst): Create a function that takes a list of integers as input and returns the second largest unique number in the list. If the list has fewer than 2 unique numbers, return None. :param lst: List of integers :return: Second largest unique integer or None >>> find_second_largest([3, 5, 1, 5, 3, 8, 7]) 7 >>> find_second_largest([1, 1, 1, 1]) None >>> find_second_largest([]) None >>> find_second_largest([5]) None >>> find_second_largest([5, 10]) 5 >>> find_second_largest([-1, -2, -3, -4]) -2 >>> find_second_largest([-1, 0, 2, 1, -1, 2]) 1 >>> find_second_largest([10, 20, 30, 20, 10, 40]) 30","solution":"def find_second_largest(lst): Returns the second largest unique number from the list. If the list has fewer than 2 unique numbers, returns None. if len(lst) < 2: return None first_largest = second_largest = float('-inf') unique_numbers = set(lst) if len(unique_numbers) < 2: return None for num in unique_numbers: if num > first_largest: second_largest = first_largest first_largest = num elif num > second_largest and num != first_largest: second_largest = num return second_largest"},{"question":"def longest_contiguous_subarray(arr): Identifies the longest contiguous subarray with all elements having the same value. Returns the length of this subarray. Parameters: arr (list): A list of integers. Returns: int: The length of the longest contiguous subarray with all elements equal. >>> longest_contiguous_subarray([]) == 0 >>> longest_contiguous_subarray([1]) == 1 >>> longest_contiguous_subarray([4, 4, 4, 4]) == 4 >>> longest_contiguous_subarray([1, 2, 3, 4, 5]) == 1 >>> longest_contiguous_subarray([1, 1, 2, 3, 3, 3, 4, 4]) == 3 >>> longest_contiguous_subarray([5, 5, 5, 2, 3, 5, 5, 8, 8, 8, 8, 9]) == 4 pass","solution":"def longest_contiguous_subarray(arr): Identifies the longest contiguous subarray with all elements having the same value. Returns the length of this subarray. Parameters: arr (list): A list of integers. Returns: int: The length of the longest contiguous subarray with all elements equal. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] == arr[i-1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def reverse_words_in_place(s: str) -> str: Takes a string containing a list of words separated by spaces or tabs and returns a new string with each word reversed in place while maintaining the original whitespace characters. >>> reverse_words_in_place(\\"Hello world\\") == \\"olleH dlrow\\" >>> reverse_words_in_place(\\"Hello world\\") == \\"olleH dlrow\\" >>> reverse_words_in_place(\\"Hellotworld\\") == \\"olleHtdlrow\\" >>> reverse_words_in_place(\\"Hello worldtthis is a test\\") == \\"olleH dlrowtsiht si a tset\\" >>> reverse_words_in_place(\\"a b c\\") == \\"a b c\\" >>> reverse_words_in_place(\\" lead and trail \\") == \\" dael dna liart \\" >>> reverse_words_in_place(\\" \\") == \\" \\" >>> reverse_words_in_place(\\"ttt\\") == \\"ttt\\"","solution":"def reverse_words_in_place(s): Takes a string containing a list of words separated by spaces or tabs and returns a new string with each word reversed in place while maintaining the original whitespace characters. reversed_words = [] word_start = -1 for i, char in enumerate(s): if char.isalpha(): if word_start == -1: word_start = i else: if word_start != -1: reversed_words.append(s[word_start:i][::-1]) word_start = -1 reversed_words.append(char) if word_start != -1: reversed_words.append(s[word_start:][::-1]) return ''.join(reversed_words)"},{"question":"def longest_subarray_with_k_distinct(nums, k): Returns the length of the longest subarray with exactly k distinct integers. >>> longest_subarray_with_k_distinct([], 3) 0 >>> longest_subarray_with_k_distinct([1, 2, 3], 0) 0 >>> longest_subarray_with_k_distinct([1, 2, 2, 3], 5) 0 >>> longest_subarray_with_k_distinct([1], 1) 1 >>> longest_subarray_with_k_distinct([1, 1, 1, 1], 1) 4 >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3], 2) 4 >>> longest_subarray_with_k_distinct([1, 2, 1, 3, 4, 2], 3) 4 >>> longest_subarray_with_k_distinct([1, 2, 3, 4, 5], 5) 5 >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3, 1], 2) 4 >>> longest_subarray_with_k_distinct([1, 2, 3, 3, 4, 5, 5], 3) 5","solution":"def longest_subarray_with_k_distinct(nums, k): Returns the length of the longest subarray with exactly k distinct integers. from collections import defaultdict if not nums or k == 0 or k > len(set(nums)): return 0 max_length = 0 left = 0 freq = defaultdict(int) distinct_count = 0 for right in range(len(nums)): if freq[nums[right]] == 0: distinct_count += 1 freq[nums[right]] += 1 while distinct_count > k: freq[nums[left]] -= 1 if freq[nums[left]] == 0: distinct_count -= 1 left += 1 if distinct_count == k: max_length = max(max_length, right - left + 1) return max_length"},{"question":"def bezier_curve(P0, P1, P2, P3, t): Calculates the point on a Bezier curve given four control points and a parameter t. Parameters: - P0, P1, P2, P3: tuples representing the control points (x, y) - t: a float value between 0 and 1 inclusive Returns: - A tuple (x, y) representing the calculated point on the Bezier curve at parameter t >>> bezier_curve((0, 0), (1, 1), (2, 1), (3, 0), 0) (0, 0) >>> bezier_curve((0, 0), (1, 1), (2, 1), (3, 0), 1) (3, 0) >>> bezier_curve((0, 0), (1, 1), (2, 1), (3, 0), 0.5) (1.5, 0.75) >>> bezier_curve((0, 0), (1, 1), (2, 1), (3, 0), 0.25) (0.75, 0.5625) >>> bezier_curve((0, 0), (1, 1), (2, 1), (3, 0), 0.75) (2.25, 0.5625)","solution":"def bezier_curve(P0, P1, P2, P3, t): Calculates the point on a Bezier curve given four control points and a parameter t. Parameters: - P0, P1, P2, P3: tuples representing the control points (x, y) - t: a float value between 0 and 1 inclusive Returns: - A tuple (x, y) representing the calculated point on the Bezier curve at parameter t x = (1-t)**3 * P0[0] + 3 * (1-t)**2 * t * P1[0] + 3 * (1-t) * t**2 * P2[0] + t**3 * P3[0] y = (1-t)**3 * P0[1] + 3 * (1-t)**2 * t * P1[1] + 3 * (1-t) * t**2 * P2[1] + t**3 * P3[1] return (x, y)"},{"question":"def group_strings_by_initial(strings): Group strings by their initial character. Args: strings (list): List of strings to be grouped. Returns: dict: A dictionary where the keys are the first alphabetic character (case-insensitive) of the strings, and the values are lists of strings that start with that character. >>> group_strings_by_initial(['Apple', 'orange', 'banana', 'avocado', 'berry', 'Oyster']) {'a': ['Apple', 'avocado'], 'o': ['orange', 'Oyster'], 'b': ['banana', 'berry']} >>> group_strings_by_initial(['1apple', '-orange', 'banana', '_underscore']) {'b': ['banana']} >>> group_strings_by_initial(['Apple', 'apple']) {'a': ['Apple', 'apple']} >>> group_strings_by_initial(['', 'Apple', '']) {'a': ['Apple']} >>> group_strings_by_initial(['1apple', '2banana', '#hashtag']) {} >>> group_strings_by_initial(['apple', 'banana', 123]) Traceback (most recent call last): ... ValueError: All elements in the input list must be strings >>> group_strings_by_initial([]) {} >>> group_strings_by_initial(['ant', 'bee', 'cat']) {'a': ['ant'], 'b': ['bee'], 'c': ['cat']}","solution":"def group_strings_by_initial(strings): Group strings by their initial character. Args: strings (list): List of strings to be grouped. Returns: dict: A dictionary where the keys are the first alphabetic character (case-insensitive) of the strings, and the values are lists of strings that start with that character. result = {} for s in strings: if not isinstance(s, str): raise ValueError(\\"All elements in the input list must be strings\\") if not s: continue # Skip empty strings initial = s[0].lower() if initial.isalpha(): if initial not in result: result[initial] = [] result[initial].append(s) return result"},{"question":"def unique_odd_occurrences(arr: List[int]) -> List[int]: Returns a list containing only unique integers that appear an odd number of times in the original array. Args: arr (List[int]): The original array with integers. Returns: List[int]: New array with unique integers appearing an odd number of times. Test Cases: >>> unique_odd_occurrences([1, 2, 2, 3, 3, 3, 4, 4]) [1, 3] >>> unique_odd_occurrences([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> unique_odd_occurrences([2, 2, 4, 4]) [] >>> unique_odd_occurrences([4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 7, 7]) [4, 7] >>> unique_odd_occurrences([1]) [1] >>> unique_odd_occurrences([3, 3, 3, 3, 3]) [3] >>> unique_odd_occurrences([6, 6, 6, 6]) []","solution":"def unique_odd_occurrences(arr): Returns a list containing only unique integers that appear an odd number of times in the original array. from collections import Counter # Count the occurrences of each element in the array count = Counter(arr) # Create a new list with elements that appear an odd number of times result = [] seen = set() for num in arr: if num not in seen and count[num] % 2 != 0: result.append(num) seen.add(num) return result"},{"question":"def filter_less_than(arr: List[int], x: int) -> List[int]: Returns an array containing only the integers from the input array that are less than 'x'. Parameters: - arr: List of integers - x: Integer threshold Returns: - List of integers from the input array that are less than 'x' >>> filter_less_than([10, 25, 17, 3, 8, 30, 2, 15], 20) [10, 17, 3, 8, 2, 15] >>> filter_less_than([1, 2, 3, 4, 5], 6) [1, 2, 3, 4, 5] >>> filter_less_than([25, 30, 40, 50], 20) [] >>> filter_less_than([15, 20, 25, 5, 20], 20) [15, 5] >>> filter_less_than([], 10) [] >>> filter_less_than([10, -1, -5, 3, -10], 0) [-1, -5, -10]","solution":"def filter_less_than(arr, x): Returns an array containing only the integers from the input array that are less than 'x'. Parameters: - arr: List of integers - x: Integer threshold Returns: - List of integers from the input array that are less than 'x' return [num for num in arr if num < x]"},{"question":"def primes_less_than(n: int) -> List[int]: Returns a list of all prime numbers less than n. >>> primes_less_than(10) [2, 3, 5, 7] >>> primes_less_than(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> primes_less_than(2) [] >>> primes_less_than(1) [] >>> primes_less_than(30) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> primes_less_than(100) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] >>> primes_less_than(0) []","solution":"def primes_less_than(n): Returns a list of all prime numbers less than n. if n <= 2: return [] sieve = [True] * n sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(n**0.5) + 1): if sieve[start]: for i in range(start * start, n, start): sieve[i] = False return [num for num in range(n) if sieve[num]]"},{"question":"def longest_substring_k_distinct(s: str, k: int) -> str: Find the longest substring that contains no more than K distinct characters. >>> longest_substring_k_distinct(\\"aabacbebebe\\", 3) == \\"cbebebe\\" >>> longest_substring_k_distinct(\\"aabacbebebe\\", 0) == \\"\\" >>> longest_substring_k_distinct(\\"aabacbebebe\\", 100) == \\"aabacbebebe\\" >>> longest_substring_k_distinct(\\"\\", 2) == \\"\\" >>> longest_substring_k_distinct(\\"aaaa\\", 1) == \\"aaaa\\" >>> longest_substring_k_distinct(\\"aabbcc\\", 1) == \\"aa\\" >>> longest_substring_k_distinct(\\"abcadcacacaca\\", 3) == \\"cadcacacaca\\" >>> longest_substring_k_distinct(\\"abcadcacacaca\\", 0) == \\"\\" pass","solution":"def longest_substring_k_distinct(s: str, k: int) -> str: Finds the longest substring with no more than K distinct characters. if k == 0 or not s: return \\"\\" start = 0 max_length = 0 max_substr = \\"\\" char_map = {} for end in range(len(s)): char_map[s[end]] = char_map.get(s[end], 0) + 1 while len(char_map) > k: char_map[s[start]] -= 1 if char_map[s[start]] == 0: del char_map[s[start]] start += 1 current_length = end - start + 1 if current_length > max_length: max_length = current_length max_substr = s[start:end+1] return max_substr"},{"question":"from typing import List def matrix_diagonal_sum(matrix: List[List[int]]) -> int: Design a function matrix_diagonal_sum that takes an n x n matrix (a list of lists) and returns the sum of the elements along both the main diagonal and the secondary diagonal. >>> matrix_diagonal_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 25 >>> matrix_diagonal_sum([ ... [1, 2], ... [3, 4] ... ]) 10 >>> matrix_diagonal_sum([ ... [5] ... ]) 5 >>> matrix_diagonal_sum([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) -25 >>> matrix_diagonal_sum([ ... [1000, 2000, 3000], ... [4000, 5000, 6000], ... [7000, 8000, 9000] ... ]) 25000","solution":"from typing import List def matrix_diagonal_sum(matrix: List[List[int]]) -> int: n = len(matrix) main_diagonal_sum = sum(matrix[i][i] for i in range(n)) secondary_diagonal_sum = sum(matrix[i][n - i - 1] for i in range(n)) total_diagonal_sum = main_diagonal_sum + secondary_diagonal_sum # If n is odd, subtract the middle element which is counted twice if n % 2 == 1: total_diagonal_sum -= matrix[n // 2][n // 2] return total_diagonal_sum"},{"question":"def find_pairs_with_sum(arr, target_sum): This function takes a numerical array and a target sum as inputs, and identifies all unique pairs of elements within the array that add up to the target sum. Each pair in the result is sorted in ascending order, and the result does not contain duplicate pairs. >>> find_pairs_with_sum([1, 2, 3, 4, 5, 6], 7) [[1, 6], [2, 5], [3, 4]] >>> find_pairs_with_sum([1, 2, 3, 4, 5, 6, -1, -2, -3], 4) [[-1, 5], [-2, 6], [1, 3]] >>> find_pairs_with_sum([1, 2, 3, 4, 5], 10) [] >>> find_pairs_with_sum([-1, 1, 2, -2, 3, 0], 1) [[-2, 3], [-1, 2], [0, 1]] >>> find_pairs_with_sum([2, 2, 3, 3, 4, 4], 5) [[2, 3]]","solution":"def find_pairs_with_sum(arr, target_sum): This function takes a numerical array and a target sum as inputs, and identifies all unique pairs of elements within the array that add up to the target sum. Each pair in the result is sorted in ascending order, and the result does not contain duplicate pairs. seen = set() potential_pairs = set() for num in arr: complement = target_sum - num if complement in seen: potential_pairs.add(tuple(sorted((num, complement)))) seen.add(num) return [list(pair) for pair in potential_pairs]"},{"question":"def categorize_temperatures(temperatures): This function accepts a list of integers representing temperatures in Celsius, and returns a new list with corresponding temperature categories. >>> categorize_temperatures([8, 15, 22, 30, 5, 13]) ['Cold', 'Warm', 'Warm', 'Hot', 'Cold', 'Warm'] >>> categorize_temperatures([9, 10, 25, 26, 27]) ['Cold', 'Warm', 'Warm', 'Hot', 'Hot'] >>> categorize_temperatures([]) [] >>> categorize_temperatures([-5, -10, 0, 9, 11]) ['Cold', 'Cold', 'Cold', 'Cold', 'Warm'] >>> categorize_temperatures([10, 25]) ['Warm', 'Warm'] >>> categorize_temperatures([-15, 0, 10, 15, 20, 25, 30, 35]) ['Cold', 'Cold', 'Warm', 'Warm', 'Warm', 'Warm', 'Hot', 'Hot']","solution":"def categorize_temperatures(temperatures): This function accepts a list of integers representing temperatures in Celsius, and returns a new list with corresponding temperature categories. categories = [] for temp in temperatures: if temp < 10: categories.append(\\"Cold\\") elif 10 <= temp <= 25: categories.append(\\"Warm\\") else: categories.append(\\"Hot\\") return categories"},{"question":"library.py from typing import Optional, List class Book: def __init__(self, title: str, author: str, genre: str, isbn: str, copies: int): self.title = title self.author = author self.genre = genre self.isbn = isbn self.copies = copies class Member: def __init__(self, name: str, email: str): self.name = name self.email = email self.borrowed_books = [] def borrow_book(self, book: Book) -> bool: Borrow a book from the library. pass def return_book(self, book: Book) -> bool: Return a borrowed book to the library. pass class Library: def __init__(self): self.books = {} self.members = {} def add_book(self, book: Book) -> None: Add a book to the library's inventory. pass def update_book(self, isbn: str, title: Optional[str] = None, author: Optional[str] = None, genre: Optional[str] = None, copies: Optional[int] = None) -> bool: Update the information of a book in the library's inventory. pass def delete_book(self, isbn: str) -> bool: Remove a book from the library's inventory. pass def search_books(self, title: Optional[str] = None, author: Optional[str] = None, genre: Optional[str] = None) -> List[Book]: Search for books in the library by title, author, or genre. pass def notify_overdue_books(self): Notify members of overdue books. pass test_library.py import pytest from library import Book, Member, Library def test_add_book(): library = Library() book = Book(\\"1984\\", \\"George Orwell\\", \\"Dystopian\\", \\"1234567890\\", 4) library.add_book(book) assert '1234567890' in library.books def test_update_book(): library = Library() book = Book(\\"1984\\", \\"George Orwell\\", \\"Dystopian\\", \\"1234567890\\", 4) library.add_book(book) result = library.update_book(\\"1234567890\\", title=\\"Animal Farm\\", copies=3) assert result == True assert library.books[\\"1234567890\\"].title == \\"Animal Farm\\" assert library.books[\\"1234567890\\"].copies == 3 def test_delete_book(): library = Library() book = Book(\\"1984\\", \\"George Orwell\\", \\"Dystopian\\", \\"1234567890\\", 4) library.add_book(book) result = library.delete_book(\\"1234567890\\") assert result == True assert '1234567890' not in library.books def test_search_books(): library = Library() book1 = Book(\\"1984\\", \\"George Orwell\\", \\"Dystopian\\", \\"1234567890\\", 4) book2 = Book(\\"Animal Farm\\", \\"George Orwell\\", \\"Fable\\", \\"0987654321\\", 2) library.add_book(book1) library.add_book(book2) result = library.search_books(title=\\"1984\\") assert len(result) == 1 assert result[0].title == \\"1984\\" result = library.search_books(author=\\"George Orwell\\") assert len(result) == 2 result = library.search_books(genre=\\"Dystopian\\") assert len(result) == 1 assert result[0].isbn == \\"1234567890\\" def test_member_borrow_return_book(): library = Library() book = Book(\\"1984\\", \\"George Orwell\\", \\"Dystopian\\", \\"1234567890\\", 4) library.add_book(book) member = Member(\\"Alice\\", \\"alice@example.com\\") assert member.borrow_book(book) == True assert book.copies == 3 assert len(member.borrowed_books) == 1 assert member.borrowed_books[0].isbn == \\"1234567890\\" assert member.return_book(book) == True assert book.copies == 4 assert len(member.borrowed_books) == 0","solution":"from typing import Optional, List class Book: def __init__(self, title: str, author: str, genre: str, isbn: str, copies: int): self.title = title self.author = author self.genre = genre self.isbn = isbn self.copies = copies class Member: def __init__(self, name: str, email: str): self.name = name self.email = email self.borrowed_books = [] def borrow_book(self, book: Book) -> bool: if book.copies > 0: book.copies -= 1 self.borrowed_books.append(book) return True return False def return_book(self, book: Book) -> bool: if book in self.borrowed_books: book.copies += 1 self.borrowed_books.remove(book) return True return False class Library: def __init__(self): self.books = {} self.members = {} def add_book(self, book: Book) -> None: self.books[book.isbn] = book def update_book(self, isbn: str, title: Optional[str] = None, author: Optional[str] = None, genre: Optional[str] = None, copies: Optional[int] = None) -> bool: if isbn in self.books: if title: self.books[isbn].title = title if author: self.books[isbn].author = author if genre: self.books[isbn].genre = genre if copies is not None: self.books[isbn].copies = copies return True return False def delete_book(self, isbn: str) -> bool: if isbn in self.books: del self.books[isbn] return True return False def search_books(self, title: Optional[str] = None, author: Optional[str] = None, genre: Optional[str] = None) -> List[Book]: results = [] for book in self.books.values(): if title and title.lower() not in book.title.lower(): continue if author and author.lower() not in book.author.lower(): continue if genre and genre.lower() not in book.genre.lower(): continue results.append(book) return results def notify_overdue_books(self): # Placeholder for notification logic pass"},{"question":"def get_squares(numbers: List[int]) -> List[int]: Write a function that takes a list of integers and returns a new list with the square of each number, but only if the original number is positive. Negative numbers should be ignored. >>> get_squares([1, -2, 3, -4, 5]) [1, 9, 25] >>> get_squares([1, 2, 3]) [1, 4, 9] >>> get_squares([-1, -2, -3]) [] >>> get_squares([0, 0, 0]) [] >>> get_squares([]) [] # Validation and implementation goes here # Unit tests def test_get_squares_with_mixed_numbers(): assert get_squares([1, -2, 3, -4, 5]) == [1, 9, 25] def test_get_squares_with_all_positive_numbers(): assert get_squares([1, 2, 3]) == [1, 4, 9] def test_get_squares_with_all_negative_numbers(): assert get_squares([-1, -2, -3]) == [] def test_get_squares_with_zeros(): assert get_squares([0, 0, 0]) == [] def test_get_squares_with_empty_list(): assert get_squares([]) == [] def test_get_squares_with_non_integer_elements(): try: get_squares([1, 'a', 3]) except ValueError as ve: assert str(ve) == \\"All elements in the list must be integers.\\" def test_get_squares_with_non_list_input(): try: get_squares(\\"not a list\\") except ValueError as ve: assert str(ve) == \\"Input must be a list of integers.\\"","solution":"def get_squares(numbers): if not isinstance(numbers, list): # validation to check if the input is a list. raise ValueError(\\"Input must be a list of integers.\\") squares = [] for num in numbers: if not isinstance(num, int): # validation to ensure each element is an integer. raise ValueError(\\"All elements in the list must be integers.\\") if num > 0: # only process positive numbers squares.append(num * num) return squares"},{"question":"from typing import Optional def evaluate_expression(expression: str) -> Optional[float]: Parses and evaluates a given mathematical expression string containing integers and the operators +, -, * and /. The function handles the standard order of operations, including parentheses for precedence. Args: expression (str): The mathematical expression to evaluate. Returns: Optional[float]: The result of evaluating the expression, or None if the expression is invalid or involves division by zero. >>> evaluate_expression(\\"2 + 3 * 4\\") 14.0 >>> evaluate_expression(\\"3 + (2 * (7 - 3)) / 4\\") 5.0 >>> evaluate_expression(\\"4 / 0\\") None >>> evaluate_expression(\\"5 + ((1 + 2) * 4) - 3\\") 14.0 >>> evaluate_expression(\\"10 - (2 + (3 - 1) * 2)\\") 4.0 >>> evaluate_expression(\\"2 + a * 3\\") None # Implementation starts here def test_simple_expression(): assert evaluate_expression(\\"2 + 3 * 4\\") == 14.0 def test_expression_with_parentheses(): assert evaluate_expression(\\"3 + (2 * (7 - 3)) / 4\\") == 5.0 def test_expression_with_division_by_zero(): assert evaluate_expression(\\"4 / 0\\") is None def test_complicated_expression(): assert evaluate_expression(\\"5 + ((1 + 2) * 4) - 3\\") == 14.0 def test_expression_with_nested_parentheses(): assert evaluate_expression(\\"10 - (2 + (3 - 1) * 2)\\") == 4.0 def test_expression_with_invalid_characters(): assert evaluate_expression(\\"2 + a * 3\\") is None","solution":"import operator import re def evaluate_expression(expression): def parse_expression(expression): tokens = re.findall(r'd+.?d*|[+-*/()]', expression) return shunting_yard(tokens) def shunting_yard(tokens): out_queue = [] op_stack = [] ops = {'+': (1, operator.add), '-': (1, operator.sub), '*': (2, operator.mul), '/': (2, operator.truediv)} for token in tokens: if re.match(r'd', token): out_queue.append(float(token)) # Convert numbers to float for eval elif token in ops: while (op_stack and op_stack[-1] in ops and ops[token][0] <= ops[op_stack[-1]][0]): out_queue.append(op_stack.pop()) op_stack.append(token) elif token == '(': op_stack.append(token) elif token == ')': while op_stack and op_stack[-1] != '(': out_queue.append(op_stack.pop()) op_stack.pop() # Pop the '(' while op_stack: out_queue.append(op_stack.pop()) return out_queue def evaluate_rpn(rpn_expression): stack = [] ops = {'+': operator.add, '-': operator.sub, '*': operator.mul, '/': operator.truediv} for token in rpn_expression: if isinstance(token, float): stack.append(token) elif token in ops: b, a = stack.pop(), stack.pop() if token == '/' and b == 0: raise ZeroDivisionError('Division by zero') stack.append(ops[token](a, b)) return stack[0] try: rpn_expression = parse_expression(expression) result = evaluate_rpn(rpn_expression) return result except Exception as e: print(f\\"Invalid expression: {e}\\") return None"},{"question":"def intersection_unique_sorted(list1, list2): Given two lists of integers, return a sorted list containing unique integers that are present in both lists. The function should raise a TypeError if either list1 or list2 is not a list. The function should raise a ValueError if any of the elements in list1 or list2 are not integers. For example: >>> intersection_unique_sorted([4, 9, 5], [9, 4, 9, 8, 4]) [4, 9] >>> intersection_unique_sorted([1, 2, 2, 3], [3, 3, 4, 2]) [2, 3] >>> intersection_unique_sorted([2, 2, 2], [2]) [2] # Your code here","solution":"def intersection_unique_sorted(list1, list2): Given two lists of integers, return a sorted list containing unique integers that are present in both lists. The function should raise a TypeError if either list1 or list2 is not a list. The function should raise a ValueError if any of the elements in list1 or list2 are not integers. if not isinstance(list1, list) or not isinstance(list2, list): raise TypeError(\\"Both arguments must be lists\\") if not all(isinstance(x, int) for x in list1) or not all(isinstance(x, int) for x in list2): raise ValueError(\\"All elements in both lists must be integers\\") # Find intersection and convert to a set to eliminate duplicates, then sort it intersection = set(list1).intersection(list2) return sorted(intersection)"},{"question":"def transpose_matrix(matrix): Transpose a given matrix. Args: matrix (list of list of int): A 2D array representing the matrix to be transposed Returns: list of list of int: Transposed matrix # Your code here def test_transpose_square_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] assert transpose_matrix(matrix) == expected def test_transpose_rectangle_matrix(): matrix = [ [1, 2, 3], [4, 5, 6] ] expected = [ [1, 4], [2, 5], [3, 6] ] assert transpose_matrix(matrix) == expected def test_transpose_single_row_matrix(): matrix = [[1, 2, 3]] expected = [ [1], [2], [3] ] assert transpose_matrix(matrix) == expected def test_transpose_single_column_matrix(): matrix = [ [1], [2], [3] ] expected = [[1, 2, 3]] assert transpose_matrix(matrix) == expected def test_transpose_empty_matrix(): matrix = [] expected = [] assert transpose_matrix(matrix) == expected","solution":"def transpose_matrix(matrix): Transpose a given matrix. Args: matrix (list of list of int): A 2D array representing the matrix to be transposed Returns: list of list of int: Transposed matrix return list(map(list, zip(*matrix)))"},{"question":"def isPalindrome(s: str) -> bool: Determine if a given string is a palindrome, considering only alphanumeric characters and ignoring cases. Example: >>> isPalindrome(\\"A man, a plan, a canal, Panama\\") True >>> isPalindrome(\\"race a car\\") False from solution import isPalindrome def test_palindrome_with_punctuation(): assert isPalindrome(\\"A man, a plan, a canal, Panama\\") == True def test_non_palindrome(): assert isPalindrome(\\"race a car\\") == False def test_empty_string(): assert isPalindrome(\\"\\") == True def test_single_character(): assert isPalindrome(\\"a\\") == True def test_string_with_spaces(): assert isPalindrome(\\" \\") == True def test_palindrome_mixed_case(): assert isPalindrome(\\"No lemon, no melon\\") == True def test_non_alphanumeric_characters(): assert isPalindrome(\\"!@@!\\") == True","solution":"def isPalindrome(s): Determine if a given string is a palindrome, considering only alphanumeric characters and ignoring cases. left, right = 0, len(s) - 1 while left < right: while left < right and not s[left].isalnum(): left += 1 while left < right and not s[right].isalnum(): right -= 1 if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True"},{"question":"def common_elements(list1, list2): Returns a list containing elements that are present in both input lists. The elements in the result keep the order as they appear in the first list in the result list. >>> common_elements([1, 2, 2, 3, 4], [2, 2, 4, 4, 5]) == [2, 2, 4] >>> common_elements([1, 1, 2, 3], [4, 1, 3, 3]) == [1, 3] >>> common_elements([1, 2, 3], [4, 5, 6]) == [] >>> common_elements([], [1, 2, 3]) == [] >>> common_elements([1, 2, 3], []) == [] >>> common_elements([1, 2, 2, 2], [2, 2, 3]) == [2, 2] >>> common_elements([4, 4, 4], [4, 4, 4, 4]) == [4, 4, 4]","solution":"def common_elements(list1, list2): Returns a list containing elements that are present in both input lists. The elements in the result keep the order as they appear in the first list. common_list = [] list2_copy = list2[:] # Create a copy of list2 to not mutate the original list for item in list1: if item in list2_copy: common_list.append(item) list2_copy.remove(item) return common_list"},{"question":"from typing import List def find_two_sum(nums: List[int], target: int) -> List[int]: Given an array of integers, return indices of the two numbers such that they add up to the target. >>> find_two_sum([2, 7, 11, 15], 9) == [0, 1] >>> find_two_sum([3, 2, 4], 6) == [1, 2] >>> find_two_sum([3, 3], 6) == [0, 1] >>> find_two_sum([1, 2, 3], 7) == [] pass def test_find_two_sum_basic(): assert find_two_sum([2, 7, 11, 15], 9) == [0, 1] def test_find_two_sum_single_pair(): assert find_two_sum([3, 2, 4], 6) == [1, 2] def test_find_two_sum_identical_elements(): assert find_two_sum([3, 3], 6) == [0, 1] def test_find_two_sum_no_pair(): assert find_two_sum([1, 2, 3], 7) == [] def test_find_two_sum_multiple_solutions(): result = find_two_sum([1, 3, 2, 4, 7, 6], 5) assert result == [0, 3] or result == [1, 2]","solution":"from typing import List def find_two_sum(nums: List[int], target: int) -> List[int]: Given an array of integers, return indices of the two numbers such that they add up to the target. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return []"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a simple arithmetic expression and returns the result. The expression is a string that may contain integers, the operators +, -, *, /, and parentheses (). Examples: >>> evaluate_expression(\\"2+3\\") 5 >>> evaluate_expression(\\"5-2\\") 3 >>> evaluate_expression(\\"4*3\\") 12 >>> evaluate_expression(\\"10/2\\") 5.0 >>> evaluate_expression(\\"2+3*4\\") 14 >>> evaluate_expression(\\"(2+3)*4\\") 20 >>> evaluate_expression(\\"(2+3)*(5-2)/3\\") 5.0 >>> evaluate_expression(\\"10 + 2 * 6\\") 22 >>> evaluate_expression(\\"10 + (2 * 6) / (2 + 1)\\") 14.0 >>> evaluate_expression(\\"((2 + 3) * 5 - 3) / 4\\") 5.5 >>> evaluate_expression(\\"7 / 2\\") 3.5","solution":"def evaluate_expression(expression): Evaluates a simple arithmetic expression and returns the result. The expression is a string that may contain integers, the operators +, -, *, /, and parentheses (). def parse_expression(expression): tokens = [] num = '' for char in expression: if char.isdigit() or char == '.': num += char else: if num: tokens.append(float(num)) num = '' if char in '+-*/()': tokens.append(char) if num: tokens.append(float(num)) return tokens def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(left / right) def precedence(operator): if operator in '+-': return 1 if operator in '*/': return 2 return 0 tokens = parse_expression(expression) values = [] operators = [] for token in tokens: if isinstance(token, float): values.append(token) elif token == '(': operators.append(token) elif token == ')': while operators and operators[-1] != '(': apply_operator(operators, values) operators.pop() # Remove '(' else: while (operators and precedence(operators[-1]) >= precedence(token)): apply_operator(operators, values) operators.append(token) while operators: apply_operator(operators, values) return values[0]"},{"question":"def generate_primes(n): Create a list of the first n prime numbers. >>> generate_primes(0) [] >>> generate_primes(1) [2] >>> generate_primes(2) [2, 3] >>> generate_primes(5) [2, 3, 5, 7, 11] >>> generate_primes(10) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] def get_kth_prime(primes, k): Return the k-th prime number from the list of primes. >>> get_kth_prime([2, 3, 5, 7, 11, 13, 17, 19, 23, 29], 1) 2 >>> get_kth_prime([2, 3, 5, 7, 11, 13, 17, 19, 23, 29], 5) 11 >>> get_kth_prime([2, 3, 5, 7, 11, 13, 17, 19, 23, 29], 10) 29 >>> get_kth_prime([2, 3, 5, 7, 11, 13, 17, 19, 23, 29], 0) \\"Error: k is out of range\\" >>> get_kth_prime([2, 3, 5, 7, 11, 13, 17, 19, 23, 29], 11) \\"Error: k is out of range\\"","solution":"def generate_primes(n): if n <= 0: return [] primes = [] candidate = 2 while len(primes) < n: is_prime = True for p in primes: if p * p > candidate: break if candidate % p == 0: is_prime = False break if is_prime: primes.append(candidate) candidate += 1 return primes def get_kth_prime(primes, k): if k <= 0 or k > len(primes): return \\"Error: k is out of range\\" return primes[k-1]"},{"question":"def is_prime_palindrome(num: int) -> bool: Determine if a given integer is a prime number and also a palindrome. Args: num: int - The integer to check. Returns: bool - True if the integer is both a prime number and a palindrome, False otherwise. >>> is_prime_palindrome(2) True >>> is_prime_palindrome(3) True >>> is_prime_palindrome(11) True >>> is_prime_palindrome(101) True >>> is_prime_palindrome(13) False >>> is_prime_palindrome(31) False >>> is_prime_palindrome(121) False >>> is_prime_palindrome(22) False >>> is_prime_palindrome(1) False >>> is_prime_palindrome(4) False >>> is_prime_palindrome(123) False >>> is_prime_palindrome(-2) False >>> is_prime_palindrome(-11) False","solution":"def is_prime_palindrome(num): Determine if a given integer is a prime number and also a palindrome. Args: num: int - The integer to check. Returns: bool - True if the integer is both a prime number and a palindrome, False otherwise. def is_prime(n): if n <= 1: return False for i in range(2, int(n ** 0.5) + 1): if n % i == 0: return False return True def is_palindrome(n): return str(n) == str(n)[::-1] return is_prime(num) and is_palindrome(num)"},{"question":"import time def time_logger(func): Decorator that logs the time taken by a function to execute. def wrapper(*args, **kwargs): start_time = time.time() result = func(*args, **kwargs) end_time = time.time() duration = end_time - start_time print(f\\"Function {func.__name__} took {duration:.4f} seconds to execute\\") return result return wrapper @time_logger def sample_function(n): Sample function that calculates the sum of numbers from 0 to n-1. >>> sample_function(10) 45 >>> sample_function(0) 0 total = 0 for i in range(n): total += i return total result = sample_function(1000000) print(f\\"Result: {result}\\")","solution":"import time def time_logger(func): def wrapper(*args, **kwargs): start_time = time.time() result = func(*args, **kwargs) end_time = time.time() duration = end_time - start_time print(f\\"Function {func.__name__} took {duration:.4f} seconds to execute\\") return result return wrapper @time_logger def sample_function(n): total = 0 for i in range(n): total += i return total result = sample_function(1000000) print(f\\"Result: {result}\\")"},{"question":"def is_prime(n: int) -> bool: Helper function to check if a number is prime. pass def filter_primes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the input list of integers. Parameters: numbers (list): A list of integers Returns: list: A list containing only the prime numbers from the original list >>> filter_primes([]) == [] >>> filter_primes([4, 6, 8, 10]) == [] >>> filter_primes([2, 3, 5, 7, 11, 13, 17]) == [2, 3, 5, 7, 11, 13, 17] >>> filter_primes([15, 16, 17, 18, 19, 20]) == [17, 19] >>> filter_primes(list(range(1, 100))) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(numbers): Returns a list of prime numbers from the input list of integers. Parameters: numbers (list): A list of integers Returns: list: A list containing only the prime numbers from the original list return [num for num in numbers if is_prime(num)]"},{"question":"def multiply_lists(list1: List[int], list2: List[int]) -> List[int]: Returns a new list where each element is the product of the corresponding elements from the input lists. If one list is shorter than the other, append the remaining elements of the longer list as they are to the end of the output list. >>> multiply_lists([1, 2, 3], [4, 5, 6]) [4, 10, 18] >>> multiply_lists([1, 2, 3], [4, 5]) [4, 10, 3] >>> multiply_lists([1, 2, 3], [4, 5, 6, 7]) [4, 10, 18, 7] >>> multiply_lists([], [4, 5, 6]) [4, 5, 6] >>> multiply_lists([1, 2, 3], []) [1, 2, 3] >>> multiply_lists([], []) [] >>> multiply_lists([-1, -2, -3], [-4, -5, -6]) [4, 10, 18] >>> multiply_lists([-1, 2, -3], [4, -5, 6]) [-4, -10, -18] >>> multiply_lists([0, 2, 0], [4, 0, 6]) [0, 0, 0]","solution":"def multiply_lists(list1, list2): Returns a new list where each element is the product of the corresponding elements from the input lists. If one list is shorter than the other, append the remaining elements of the longer list as they are to the end of the output list. result = [] min_length = min(len(list1), len(list2)) for i in range(min_length): result.append(list1[i] * list2[i]) # Append the rest of the longer list if len(list1) > min_length: result.extend(list1[min_length:]) elif len(list2) > min_length: result.extend(list2[min_length:]) return result"},{"question":"def split_into_pairs(nums, target): Splits the given list into pairs such that the sum of each pair is equal to the target sum. If it is not possible, return an empty list. >>> split_into_pairs([1, 2, 3, 4, 5, 6], 7) [(1, 6), (2, 5), (3, 4)] >>> split_into_pairs([1, 1, 2, 2, 3, 3], 5) [] >>> split_into_pairs([1, 2, 3, 4, 5, 6], 10) [] pass def test_example1(): nums = [1, 2, 3, 4, 5, 6] target = 7 result = split_into_pairs(nums, target) assert sorted(result) == [(1, 6), (2, 5), (3, 4)], f\\"Failed on {result}\\" def test_example2(): nums = [1, 1, 2, 2, 3, 3] target = 5 result = split_into_pairs(nums, target) assert result == [], f\\"Failed on {result}\\" def test_example3(): nums = [1, 2, 3, 4, 5, 6] target = 10 result = split_into_pairs(nums, target) assert result == [], f\\"Failed on {result}\\" def test_all_pairs_valid(): nums = [1, 9, 2, 8, 3, 7, 4, 6, 5, 5] target = 10 result = split_into_pairs(nums, target) assert sorted(result) == [(1, 9), (2, 8), (3, 7), (4, 6), (5, 5)], f\\"Failed on {result}\\" def test_not_all_pairs_valid(): nums = [1, 2, 3, 4, 5] target = 6 result = split_into_pairs(nums, target) assert result == [], f\\"Failed on {result}\\" def test_no_valid_pairs(): nums = [1, 3, 5, 7, 9] target = 4 result = split_into_pairs(nums, target) assert result == [], f\\"Failed on {result}\\" def test_large_list(): nums = [2] * 5000 + [3] * 5000 target = 5 result = split_into_pairs(nums, target) assert len(result) == 5000, f\\"Failed on {result}\\" def test_some_pairs_not_possible(): nums = [1, 2, 2, 3, 4, 4, 5] target = 6 result = split_into_pairs(nums, target) assert result == [], f\\"Failed on {result}\\"","solution":"def split_into_pairs(nums, target): Splits the given list into pairs such that the sum of each pair is equal to the target sum. If it is not possible, return an empty list. from collections import Counter count = Counter(nums) result = [] for num in nums: if count[num] > 0: complement = target - num if count[complement] > 0: if num == complement and count[num] < 2: continue result.append((num, complement)) count[num] -= 1 count[complement] -= 1 # Check if all counts are zero for num in nums: if count[num] > 0: return [] return result"},{"question":"from typing import List, Dict, Union def top_student(records: List[Dict[str, Union[str, int, List[int]]]]) -> str: Return the name of the student with the highest average score. In case of a tie, return the lexicographically first name. >>> records = [ ... {'name': 'Alice', 'age': 17, 'scores': [88, 92, 85]}, ... {'name': 'Bob', 'age': 18, 'scores': [90, 91, 89]}, ... {'name': 'Charlie', 'age': 17, 'scores': [88, 92, 85]} ... ] >>> top_student(records) 'Bob' def test_single_student(): records = [ {'name': 'Alice', 'age': 17, 'scores': [88, 92, 85]} ] assert top_student(records) == 'Alice' def test_two_students(): records = [ {'name': 'Alice', 'age': 17, 'scores': [88, 92, 85]}, {'name': 'Bob', 'age': 18, 'scores': [90, 91, 89]} ] assert top_student(records) == 'Bob' def test_three_students(): records = [ {'name': 'Alice', 'age': 17, 'scores': [88, 92, 85]}, {'name': 'Bob', 'age': 18, 'scores': [90, 91, 89]}, {'name': 'Charlie', 'age': 17, 'scores': [88, 92, 85]} ] assert top_student(records) == 'Bob' def test_tie_same_scores(): records = [ {'name': 'Alice', 'age': 17, 'scores': [90, 90, 90]}, {'name': 'Bob', 'age': 18, 'scores': [90, 90, 90]} ] assert top_student(records) == 'Alice' def test_tie_different_scores(): records = [ {'name': 'Alice', 'age': 17, 'scores': [90, 85, 95]}, {'name': 'Bob', 'age': 18, 'scores': [95, 85, 90]} ] assert top_student(records) == 'Alice' def test_multiple_students(): records = [ {'name': 'Zara', 'age': 17, 'scores': [95, 92, 85]}, {'name': 'Bob', 'age': 18, 'scores': [90, 91, 89]}, {'name': 'Alice', 'age': 19, 'scores': [92, 90, 90]}, {'name': 'Charlie', 'age': 16, 'scores': [88, 92, 85]} ] assert top_student(records) == 'Alice'","solution":"from typing import List, Dict, Union def top_student(records: List[Dict[str, Union[str, int, List[int]]]]) -> str: Return the name of the student with the highest average score. In case of a tie, return the lexicographically first name. top_name = None highest_avg = -1 for record in records: name = record['name'] scores = record['scores'] avg_score = sum(scores) / len(scores) if (avg_score > highest_avg) or (avg_score == highest_avg and name < top_name): highest_avg = avg_score top_name = name return top_name"},{"question":"from typing import List def min_abs_difference(arr: List[int]) -> int: Return the minimum absolute difference between any two distinct elements in the array. >>> min_abs_difference([3, 8, 15, 1, 14]) 1 >>> min_abs_difference([1, 2, 3, 4, 5]) 1 >>> min_abs_difference([-5, -3, -10, -1]) 2 >>> min_abs_difference([10**9, -10**9, 0, 5, -7]) 5 >>> min_abs_difference([100, 102]) 2 pass def test_min_abs_difference_regular_case(): assert min_abs_difference([3, 8, 15, 1, 14]) == 1 def test_min_abs_difference_ordered_case(): assert min_abs_difference([1, 2, 3, 4, 5]) == 1 def test_min_abs_difference_with_negative_numbers(): assert min_abs_difference([-5, -3, -10, -1]) == 2 def test_min_abs_difference_large_values(): assert min_abs_difference([10**9, -10**9, 0, 5, -7]) == 5 def test_min_abs_difference_two_elements(): assert min_abs_difference([100, 102]) == 2","solution":"def min_abs_difference(arr): Returns the minimum absolute difference between any two distinct elements in the array. # First, sort the array arr.sort() # Initialize the minimum difference to a large number min_diff = float('inf') # Iterate through the array and find the minimum difference for i in range(len(arr) - 1): diff = arr[i + 1] - arr[i] if diff < min_diff: min_diff = diff return min_diff"},{"question":"from typing import List def is_quasi_fibonacci(sequence: List[int]) -> bool: Determines if the list of numbers follows a quasi-fibonacci sequence. In a quasi-fibonacci sequence, every number in the list after the first two numbers should be the sum of any non-empty subset of the previous two numbers in the sequence. >>> is_quasi_fibonacci([3, 2, 5, 5]) True >>> is_quasi_fibonacci([1, 2, 3, 6]) False >>> is_quasi_fibonacci([1]) True >>> is_quasi_fibonacci([1, 2]) True >>> is_quasi_fibonacci([1, 2, 3, 5, 8]) True >>> is_quasi_fibonacci([0, 0, 0]) True >>> is_quasi_fibonacci([1, 1, 1, 2, 3]) True >>> is_quasi_fibonacci([1, 3, 4, 8]) False >>> is_quasi_fibonacci([5, 7, 12, 19, 31, 50]) True >>> is_quasi_fibonacci([5, 7, 12, 19, 32, 50]) False","solution":"from typing import List def is_quasi_fibonacci(sequence: List[int]) -> bool: Determines if the given list of numbers follows a quasi-fibonacci sequence. if len(sequence) < 3: return True for i in range(2, len(sequence)): a, b = sequence[i-2], sequence[i-1] possible_next_values = set() if a == 0 and b == 0: possible_next_values.add(0) else: # generate non-empty subsets of {a, b} if a != 0: possible_next_values.add(a) if b != 0: possible_next_values.add(b) possible_next_values.add(a + b) # Check if the current value is in the generated set if sequence[i] not in possible_next_values: return False return True"},{"question":"from typing import List, Set import re from collections import Counter def most_common_words(text: str, banned_words: Set[str], top_n: int = 10) -> List[str]: Returns a list of the most common words in the text that are not part of the banned words. Args: - text (str): the input text. - banned_words (Set[str]): a set of banned words. - top_n (int): number of top common words to return, default is 10. Returns: - List of the most common words not in the banned list. >>> most_common_words(\\"This is a simple text. This text is just a test.\\", {\\"is\\", \\"a\\", \\"just\\"}, top_n=2) [\\"this\\", \\"text\\"] >>> most_common_words(\\"Hello, hello! How are you? I hope you are well. Well, well, well...\\", {\\"are\\", \\"you\\"}, top_n=3) [\\"well\\", \\"hello\\", \\"how\\"] >>> most_common_words(\\"\\", {\\"any\\", \\"word\\"}) [] >>> most_common_words(\\"All words are banned words.\\", {\\"all\\", \\"words\\", \\"are\\", \\"banned\\"}) [] >>> most_common_words(\\"word \\" * (10**6), set(), top_n=1) [\\"word\\"] pass","solution":"import re from collections import Counter def most_common_words(text, banned_words, top_n=10): Returns a list of the most common words in the text that are not part of the banned words. Args: - text (str): the input text. - banned_words (dict): a dictionary of banned words. - top_n (int): number of top common words to return, default is 10. Returns: - List of the most common words not in the banned list. if not isinstance(text, str) or not isinstance(banned_words, (set, dict)): raise ValueError(\\"Invalid input\\") # Normalize the text: convert to lower case and remove punctuation text = text.lower() text = re.sub(r'[^ws]', '', text) # Split text into words words = text.split() # Filter out banned words filtered_words = [word for word in words if word not in banned_words] # Count word frequencies word_counts = Counter(filtered_words) # Get the most common words most_common = word_counts.most_common(top_n) return [word for word, count in most_common]"},{"question":"def count_characters(s: str) -> dict: Returns a dictionary with the count of each character in the string. Treats uppercase and lowercase letters as the same character. >>> count_characters(\\"hello\\") {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> count_characters(\\"HelloWorld\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> count_characters(\\"Hello123!\\") {'h': 1, 'e': 1, 'l': 2, 'o': 1, '1': 1, '2': 1, '3': 1, '!': 1} >>> count_characters(\\"\\") {} >>> count_characters(\\"aaaBBBccc\\") {'a': 3, 'b': 3, 'c': 3}","solution":"def count_characters(s): Returns a dictionary with the count of each character in the string. Treats uppercase and lowercase letters as the same character. s = s.lower() char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"def compress_image(image): Compresses a binary image using Run-Length Encoding (RLE). Arguments: image -- 2D list of integers (0s and 1s) representing a binary image Returns: 2D list representing the compressed image in RLE format def decompress_image(compressed_image): Decompresses an RLE compressed binary image. Arguments: compressed_image -- 2D list representing the compressed image in RLE format Returns: 2D list of integers (0s and 1s) representing the original binary image from solution import compress_image, decompress_image def test_compress_image(): assert compress_image([[1, 1, 0], [0, 0, 1]]) == [[1, 2, 0, 1], [0, 2, 1, 1]] assert compress_image([[1, 1, 1, 1], [0, 0, 0, 0]]) == [[1, 4], [0, 4]] assert compress_image([[1], [0]]) == [[1, 1], [0, 1]] assert compress_image([[1, 0, 1, 0], [0, 1, 0, 1]]) == [[1, 1, 0, 1, 1, 1, 0, 1], [0, 1, 1, 1, 0, 1, 1, 1]] def test_decompress_image(): assert decompress_image([[1, 2, 0, 1], [0, 2, 1, 1]]) == [[1, 1, 0], [0, 0, 1]] assert decompress_image([[1, 4], [0, 4]]) == [[1, 1, 1, 1], [0, 0, 0, 0]] assert decompress_image([[1, 1], [0, 1]]) == [[1], [0]] assert decompress_image([[1, 1, 0, 1, 1, 1, 0, 1], [0, 1, 1, 1, 0, 1, 1, 1]]) == [[1, 0, 1, 0], [0, 1, 0, 1]] def test_compression_decompression(): original_image = [[1, 1, 0], [0, 0, 1]] compressed_image = compress_image(original_image) decompressed_image = decompress_image(compressed_image) assert decompressed_image == original_image original_image = [[1, 1, 1, 1], [0, 0, 0, 0]] compressed_image = compress_image(original_image) decompressed_image = decompress_image(compressed_image) assert decompressed_image == original_image original_image = [[1], [0]] compressed_image = compress_image(original_image) decompressed_image = decompress_image(compressed_image) assert decompressed_image == original_image original_image = [[1, 0, 1, 0], [0, 1, 0, 1]] compressed_image = compress_image(original_image) decompressed_image = decompress_image(compressed_image) assert decompressed_image == original_image","solution":"def compress_image(image): Compresses a binary image using Run-Length Encoding (RLE). Arguments: image -- 2D list of integers (0s and 1s) representing a binary image Returns: 2D list representing the compressed image in RLE format compressed_image = [] for row in image: compressed_row = [] current_value = row[0] count = 1 for value in row[1:]: if value == current_value: count += 1 else: compressed_row.append(current_value) compressed_row.append(count) current_value = value count = 1 compressed_row.append(current_value) compressed_row.append(count) compressed_image.append(compressed_row) return compressed_image def decompress_image(compressed_image): Decompresses an RLE compressed binary image. Arguments: compressed_image -- 2D list representing the compressed image in RLE format Returns: 2D list of integers (0s and 1s) representing the original binary image decompressed_image = [] for row in compressed_image: decompressed_row = [] for i in range(0, len(row), 2): value = row[i] count = row[i+1] decompressed_row.extend([value] * count) decompressed_image.append(decompressed_row) return decompressed_image"},{"question":"from typing import List, Tuple, Dict, Set def determine_passing_students(students: List[Tuple[str, List[float], Dict[str, int]]], threshold_pass_grade: float, required_courses: int) -> Set[str]: Determines the number of students who pass based on given criteria. Args: - students: List of tuples [(name, grades, courses_dict)]. - threshold_pass_grade: Float, the threshold average grade to pass. - required_courses: Integer, minimum courses required in each subject. Returns: - set: Names of students who meet both criteria. >>> determine_passing_students( ... [ ... (\\"Alice\\", [80.0, 85.5, 90.0], {\\"Math\\": 3, \\"Science\\": 2}), ... (\\"Bob\\", [70.0, 75.0, 80.0], {\\"Math\\": 3, \\"Science\\": 2}), ... (\\"Charlie\\", [95.0, 100.0], {\\"Math\\": 3, \\"Science\\": 2}) ... ], ... 80.0, 2 ... ) {\\"Alice\\", \\"Charlie\\"} >>> determine_passing_students( ... [ ... (\\"Alice\\", [], {\\"Math\\": 3, \\"Science\\": 2}), ... (\\"Bob\\", [70.0, 75.0, 80.0], {\\"Math\\": 3, \\"Science\\": 2}) ... ], ... 80.0, 2 ... ) set() pass # Implement your solution here","solution":"def determine_passing_students(students, threshold_pass_grade, required_courses): Determines the number of students who pass based on given criteria. Args: - students: List of tuples [(name, grades, courses_dict)]. - threshold_pass_grade: Float, the threshold average grade to pass. - required_courses: Integer, minimum courses required in each subject. Returns: - set: Names of students who meet both criteria. passing_students = set() for student in students: name, grades, courses = student # Check grades list if not grades: continue if any(not isinstance(grade, (int, float)) for grade in grades): raise ValueError(f\\"Invalid grade found for student: {name}\\") # Check courses dictionary if any(not isinstance(courses[subject], int) or courses[subject] < 0 for subject in courses): raise ValueError(f\\"Invalid course count found for student: {name}\\") # Determine if student passes based on average grade and required courses if sum(grades) / len(grades) >= threshold_pass_grade and all(courses.get(subject, 0) >= required_courses for subject in courses): passing_students.add(name) return passing_students"},{"question":"def group_and_count_buses(buses: List[Dict]) -> Tuple[int, Dict[int, List[int]]]: Group buses by their route number and count the number of active buses. >>> buses = [ >>> {\\"id\\": 1, \\"status\\": \\"inactive\\"}, >>> {\\"id\\": 2, \\"status\\": \\"active\\", \\"route_number\\": 101}, >>> {\\"id\\": 3, \\"status\\": \\"active\\", \\"route_number\\": 102}, >>> {\\"id\\": 4, \\"status\\": \\"inactive\\"}, >>> {\\"id\\": 5, \\"status\\": \\"active\\", \\"route_number\\": 101}, >>> ] >>> group_and_count_buses(buses) (3, {101: [2, 5], 102: [3]}) pass buses = [ {\\"id\\": 1, \\"status\\": \\"inactive\\"}, {\\"id\\": 2, \\"status\\": \\"active\\", \\"route_number\\": 101}, {\\"id\\": 3, \\"status\\": \\"active\\", \\"route_number\\": 102}, {\\"id\\": 4, \\"status\\": \\"inactive\\"}, {\\"id\\": 5, \\"status\\": \\"active\\", \\"route_number\\": 101}, ] def test_group_and_count_buses(): assert group_and_count_buses(buses) == (3, {101: [2, 5], 102: [3]}) def test_group_and_count_buses_no_active(): buses_no_active = [ {\\"id\\": 1, \\"status\\": \\"inactive\\"}, {\\"id\\": 2, \\"status\\": \\"inactive\\"}, {\\"id\\": 3, \\"status\\": \\"inactive\\"}, ] assert group_and_count_buses(buses_no_active) == (0, {}) def test_group_and_count_buses_single_route(): buses_single_route = [ {\\"id\\": 1, \\"status\\": \\"inactive\\"}, {\\"id\\": 2, \\"status\\": \\"active\\", \\"route_number\\": 101}, {\\"id\\": 3, \\"status\\": \\"active\\", \\"route_number\\": 101}, ] assert group_and_count_buses(buses_single_route) == (2, {101: [2, 3]}) def test_group_and_count_buses_mixed_routes(): buses_mixed_routes = [ {\\"id\\": 1, \\"status\\": \\"active\\", \\"route_number\\": 103}, {\\"id\\": 2, \\"status\\": \\"active\\", \\"route_number\\": 104}, {\\"id\\": 3, \\"status\\": \\"active\\", \\"route_number\\": 105}, {\\"id\\": 4, \\"status\\": \\"inactive\\"}, {\\"id\\": 5, \\"status\\": \\"active\\", \\"route_number\\": 105}, {\\"id\\": 6, \\"status\\": \\"inactive\\"}, {\\"id\\": 7, \\"status\\": \\"active\\", \\"route_number\\": 104}, ] assert group_and_count_buses(buses_mixed_routes) == (5, {103: [1], 104: [2, 7], 105: [3, 5]}) def test_group_and_count_buses_empty_list(): buses_empty = [] assert group_and_count_buses(buses_empty) == (0, {})","solution":"from typing import List, Dict, Tuple def group_and_count_buses(buses: List[Dict]) -> Tuple[int, Dict[int, List[int]]]: active_count = 0 route_groups = {} for bus in buses: if bus['status'] == 'active': active_count += 1 route_number = bus['route_number'] bus_id = bus['id'] if route_number in route_groups: route_groups[route_number].append(bus_id) else: route_groups[route_number] = [bus_id] return (active_count, route_groups)"},{"question":"from typing import List def longest_consecutive_subsequence_length(numbers: List[int]) -> int: Create a function that accepts a list of integers and returns the length of the longest subsequence where each element is one more than the previous element in the subsequence. >>> longest_consecutive_subsequence_length([1, 9, 3, 10, 2, 20, 3]) 3 >>> longest_consecutive_subsequence_length([]) 0 >>> longest_consecutive_subsequence_length([5]) 1 >>> longest_consecutive_subsequence_length([10, 30, 20, 40]) 1 >>> longest_consecutive_subsequence_length([1, 2, 3, 4, 5]) 5 >>> longest_consecutive_subsequence_length([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_subsequence_length([1, 1, 2, 2, 3, 3]) 3 >>> longest_consecutive_subsequence_length(list(range(1, 10001))) 10000","solution":"def longest_consecutive_subsequence_length(numbers): if not numbers: return 0 num_set = set(numbers) longest_streak = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"from typing import List def longest_consecutive_subsequence_length(arr: List[int]) -> int: Returns the length of the longest consecutive elements sequence in the list arr. >>> longest_consecutive_subsequence_length([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_subsequence_length([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) 9 >>> longest_consecutive_subsequence_length([]) 0 >>> longest_consecutive_subsequence_length([10]) 1 >>> longest_consecutive_subsequence_length([10, 30, 20, 40]) 1 >>> longest_consecutive_subsequence_length([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 10 >>> longest_consecutive_subsequence_length([-1, -2, -3, 0, 1, 2, 3]) 7","solution":"from typing import List def longest_consecutive_subsequence_length(arr: List[int]) -> int: Returns the length of the longest consecutive elements sequence in the list arr. if not arr: return 0 num_set = set(arr) max_length = 0 for num in num_set: # only check the start of the sequence if num - 1 not in num_set: current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"from typing import List def max_profit_with_two_transactions(prices: List[int]) -> int: Write a function that simulates a basic stock trading strategy and analyze its performance over a given time period. The function will take as input a list of daily stock prices and determine the maximum profit that can be achieved by making at most two transactions (a buy followed by a sell). Ensure your function handles edge cases like a list with fewer than two prices, cases where no profit can be obtained, and analyze the time complexity of your approach. >>> max_profit_with_two_transactions([]) 0 >>> max_profit_with_two_transactions([100]) 0 >>> max_profit_with_two_transactions([200, 100]) 0 >>> max_profit_with_two_transactions([100, 200]) 100 >>> max_profit_with_two_transactions([3, 3, 3, 3, 3]) 0 >>> max_profit_with_two_transactions([1, 2, 3, 4, 5]) 4 >>> max_profit_with_two_transactions([3, 3, 5, 0, 0, 3, 1, 4]) 6 >>> max_profit_with_two_transactions([1, 3, 2, 8, 4, 9]) 12 >>> max_profit_with_two_transactions([1, 2, 4, 2, 5, 7, 2, 4, 9, 0]) 13","solution":"def max_profit_with_two_transactions(prices): Returns the maximum profit with at most two transactions. :param prices: List of daily stock prices. :return: Maximum achievable profit with at most two transactions. if len(prices) < 2: return 0 # dp array to store maximum profit until each day with one transaction max_profit_left = [0] * len(prices) min_price = prices[0] for i in range(1, len(prices)): min_price = min(min_price, prices[i]) max_profit_left[i] = max(max_profit_left[i-1], prices[i] - min_price) # dp array to store maximum profit from each day to the end with one transaction max_profit_right = [0] * len(prices) max_price = prices[-1] for i in range(len(prices)-2, -1, -1): max_price = max(max_price, prices[i]) max_profit_right[i] = max(max_profit_right[i+1], max_price - prices[i]) # Calculate the maximum profit with two transactions max_profit = 0 for i in range(len(prices)): max_profit = max(max_profit, max_profit_left[i] + max_profit_right[i]) return max_profit"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_greater_than(head: ListNode, threshold: int) -> ListNode: Removes all nodes from the linked list whose values are greater than the given threshold. >>> head = list_to_linked_list([10, 20, 5, 3, 25, 1]) >>> new_head = remove_greater_than(head, 10) >>> linked_list_to_list(new_head) == [10, 5, 3, 1] def list_to_linked_list(lst): Helper function to convert a list to a linked list. head = ListNode(0) ptr = head for elem in lst: ptr.next = ListNode(elem) ptr = ptr.next return head.next def linked_list_to_list(head): Helper function to convert a linked list to a list. lst = [] while head: lst.append(head.value) head = head.next return lst","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_greater_than(head, threshold): Removes all nodes from the linked list whose values are greater than the given threshold. dummy = ListNode(0) dummy.next = head current = dummy while current.next is not None: if current.next.value > threshold: current.next = current.next.next else: current = current.next return dummy.next"},{"question":"def intervals_overlap(interval1, interval2): Given two intervals in the 'HH:MM-HH:MM' format, determine if they overlap. Parameters: - interval1 (str): The first time interval in the 'HH:MM-HH:MM' format. - interval2 (str): The second time interval in the 'HH:MM-HH:MM' format. Returns: - bool: True if intervals overlap, False otherwise. Examples: >>> intervals_overlap(\\"09:00-11:00\\", \\"10:30-12:00\\") True >>> intervals_overlap(\\"13:00-14:00\\", \\"14:00-15:00\\") False >>> intervals_overlap(\\"18:30-19:30\\", \\"19:00-20:00\\") True # Include your code here # Unit tests def test_intervals_overlap(): assert intervals_overlap(\\"09:00-11:00\\", \\"10:30-12:00\\") == True assert intervals_overlap(\\"13:00-14:00\\", \\"14:00-15:00\\") == False assert intervals_overlap(\\"18:30-19:30\\", \\"19:00-20:00\\") == True assert intervals_overlap(\\"07:00-08:30\\", \\"08:31-09:00\\") == False assert intervals_overlap(\\"05:00-06:00\\", \\"04:30-05:15\\") == True def test_intervals_same_time(): assert intervals_overlap(\\"10:00-11:00\\", \\"10:00-11:00\\") == True def test_intervals_back_to_back(): assert intervals_overlap(\\"10:00-11:00\\", \\"11:00-12:00\\") == False def test_intervals_contained(): assert intervals_overlap(\\"09:00-12:00\\", \\"10:00-11:00\\") == True def test_intervals_large_gap(): assert intervals_overlap(\\"05:00-06:00\\", \\"18:00-19:00\\") == False","solution":"def intervals_overlap(interval1, interval2): Given two intervals in the 'HH:MM-HH:MM' format, determine if they overlap. Parameters: - interval1 (str): The first time interval in the 'HH:MM-HH:MM' format. - interval2 (str): The second time interval in the 'HH:MM-HH:MM' format. Returns: - bool: True if intervals overlap, False otherwise. def time_to_minutes(time_str): hours, minutes = map(int, time_str.split(':')) return hours * 60 + minutes start1, end1 = map(time_to_minutes, interval1.split('-')) start2, end2 = map(time_to_minutes, interval2.split('-')) return not (end1 <= start2 or end2 <= start1)"},{"question":"def optimize_and_scale_database(): Returns key considerations and best practices in optimizing a relational database for performance and scalability, particularly when dealing with large datasets and high transaction volumes. >>> considerations = optimize_and_scale_database() >>> 'Indexing' in considerations True >>> 'Create indexes on columns that are frequently used in WHERE clauses' in considerations['Indexing'] True >>> 'Query Optimization' in considerations True >>> 'Write efficient SQL queries' in considerations['Query Optimization'] True >>> 'Database Normalization' in considerations True >>> 'Normalize your database to reduce data redundancy' in considerations['Database Normalization'] True >>> 'Partitioning' in considerations True >>> 'Use table partitioning to divide a large table' in considerations['Partitioning'] True >>> 'Caching' in considerations True >>> 'Implement caching strategies to reduce the load on the database' in considerations['Caching'] True >>> 'Connection Pooling' in considerations True >>> 'Use connection pooling to manage database connections efficiently' in considerations['Connection Pooling'] True >>> 'Load Balancing' in considerations True >>> 'Distribute the database load across multiple servers' in considerations['Load Balancing'] True >>> 'Database Sharding' in considerations True >>> 'Implement sharding to horizontally partition your database' in considerations['Database Sharding'] True >>> 'Backup and Recovery' in considerations True >>> 'Regularly backup your database and have a robust recovery plan' in considerations['Backup and Recovery'] True >>> 'Monitoring and Performance Tuning' in considerations True >>> 'Constantly monitor database performance and use tools to identify and troubleshoot bottlenecks' in considerations['Monitoring and Performance Tuning'] True >>> 'Hardware and Infrastructure' in considerations True >>> 'Invest in high-performance hardware and network infrastructure' in considerations['Hardware and Infrastructure'] True considerations_and_best_practices = {} return considerations_and_best_practices","solution":"def optimize_and_scale_database(): Returns key considerations and best practices in optimizing a relational database for performance and scalability, particularly when dealing with large datasets and high transaction volumes. considerations_and_best_practices = { 'Indexing': 'Create indexes on columns that are frequently used in WHERE clauses, ' 'ORDER BY clauses, and join conditions to speed up query performance.', 'Query Optimization': 'Write efficient SQL queries, avoid SELECT *, and use the ' 'EXPLAIN command to examine query execution plans.', 'Database Normalization': 'Normalize your database to reduce data redundancy and ' 'improve data integrity. However, consider denormalization ' 'for read-heavy workloads to reduce join operations.', 'Partitioning': 'Use table partitioning to divide a large table into smaller, ' 'more manageable pieces, improving query performance and maintenance.', 'Caching': 'Implement caching strategies to reduce the load on the database. Use in-memory ' 'caches such as Redis or Memcached for frequently accessed data.', 'Connection Pooling': 'Use connection pooling to manage database connections efficiently ' 'and reduce overhead from creating and destroying connections.', 'Load Balancing': 'Distribute the database load across multiple servers to improve performance ' 'and ensure high availability.', 'Database Sharding': 'Implement sharding to horizontally partition your database, distributing ' 'data across multiple shards or servers for better performance and scalability.', 'Backup and Recovery': 'Regularly backup your database and have a robust recovery plan in place ' 'to prevent data loss and ensure business continuity.', 'Monitoring and Performance Tuning': 'Constantly monitor database performance and use tools to ' 'identify and troubleshoot bottlenecks. Regularly tune database ' 'settings based on the workload.', 'Hardware and Infrastructure': 'Invest in high-performance hardware and network infrastructure, ' 'including SSDs, sufficient RAM, and high-speed network connections.' } return considerations_and_best_practices"},{"question":"def find_majority_element(nums: List[int]) -> int: Write a function named \`find_majority_element\` that takes a list of integers as its input and returns the majority element. The majority element is the element that appears more than half the time in the list. You can assume that the input list always has a majority element. If there are multiple elements that satisfy this condition, return any of them. >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> find_majority_element([2, 2, 1, 1, 1, 2, 2]) 2 from solution import find_majority_element def test_find_majority_element_single_element(): assert find_majority_element([1]) == 1 def test_find_majority_element_example1(): assert find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) == 4 def test_find_majority_element_example2(): assert find_majority_element([2, 2, 1, 1, 1, 2, 2]) == 2 def test_find_majority_element_all_same(): assert find_majority_element([5, 5, 5, 5, 5]) == 5 def test_find_majority_element_large_input(): assert find_majority_element([1, 2] * 50000 + [2]) == 2","solution":"def find_majority_element(nums): Uses the Boyer-Moore Voting Algorithm to find the majority element in the list. candidate = None count = 0 for num in nums: if count == 0: candidate = num if num == candidate: count += 1 else: count -= 1 return candidate"},{"question":"from typing import List def is_valid_sudoku(board: List[List[str]]) -> bool: Determine if a 2D matrix representing a Sudoku puzzle is valid. A valid Sudoku board (partially filled) will not contain any duplicates within a row, a column, or any of the 3x3 sub-grids. Args: board (List[List[str]]): A 2D matrix where each element is either a digit '1'-'9' or '.'. Returns: bool: True if the board is valid, False otherwise. Examples: >>> board = [ ... [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], ... [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], ... [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], ... [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], ... [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], ... [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], ... [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], ... [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], ... [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ... ] >>> is_valid_sudoku(board) True >>> invalid_board = [ ... [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], ... [\\"6\\",\\"6\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], ... [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], ... [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], ... [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], ... [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], ... [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], ... [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], ... [\\"5\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ... ] >>> is_valid_sudoku(invalid_board) False","solution":"def is_valid_sudoku(board): def is_valid_block(block): block = [num for num in block if num != '.'] return len(block) == len(set(block)) def is_valid_row(board): for row in board: if not is_valid_block(row): return False return True def is_valid_col(board): for col in zip(*board): if not is_valid_block(col): return False return True def is_valid_subgrid(board): for i in range(0, 9, 3): for j in range(0, 9, 3): block = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)] if not is_valid_block(block): return False return True return is_valid_row(board) and is_valid_col(board) and is_valid_subgrid(board)"},{"question":"class Library: Library management system to perform operations like adding, borrowing, returning, listing, and searching books. def __init__(self): self.books = {} def add_book(self, title: str, author: str) -> str: Add a book's title and author to the library's collection. >>> library = Library() >>> library.add_book(\\"1984\\", \\"George Orwell\\") \\"Book added successfully.\\" pass def borrow_book(self, title: str, borrower: str) -> str: Borrow a book by title. Track who borrowed the book and change the book's status to 'borrowed'. >>> library = Library() >>> library.add_book(\\"1984\\", \\"George Orwell\\") >>> library.borrow_book(\\"1984\\", \\"John Doe\\") \\"Book borrowed successfully.\\" pass def return_book(self, title: str) -> str: Return a borrowed book by title. Change the book's status back to 'available'. >>> library = Library() >>> library.add_book(\\"1984\\", \\"George Orwell\\") >>> library.borrow_book(\\"1984\\", \\"John Doe\\") >>> library.return_book(\\"1984\\") \\"Book returned successfully.\\" pass def list_books(self) -> dict: List all books currently in the library, showing their title, author, and status. >>> library = Library() >>> library.add_book(\\"1984\\", \\"George Orwell\\") >>> library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\") >>> library.list_books() { \\"1984\\": {\\"author\\": \\"George Orwell\\", \\"status\\": 'available'}, \\"To Kill a Mockingbird\\": {\\"author\\": \\"Harper Lee\\", \\"status\\": 'available'} } pass def search_book(self, query: str) -> dict: Search for a book by title or author, returning whether the book is found and its status. >>> library = Library() >>> library.add_book(\\"1984\\", \\"George Orwell\\") >>> library.search_book(\\"1984\\") {\\"1984\\": {\\"author\\": \\"George Orwell\\", \\"status\\": 'available'}} pass","solution":"class Library: def __init__(self): self.books = {} def add_book(self, title, author): if title in self.books: return \\"Book already exists in the collection.\\" self.books[title] = {'author': author, 'status': 'available'} return \\"Book added successfully.\\" def borrow_book(self, title, borrower): if title not in self.books: return \\"Book not found in the collection.\\" if self.books[title]['status'] == 'borrowed': return \\"Book is already borrowed.\\" self.books[title]['status'] = 'borrowed' self.books[title]['borrower'] = borrower return \\"Book borrowed successfully.\\" def return_book(self, title): if title not in self.books: return \\"Book not found in the collection.\\" if self.books[title]['status'] == 'available': return \\"Book was not borrowed.\\" self.books[title]['status'] = 'available' self.books[title].pop('borrower', None) return \\"Book returned successfully.\\" def list_books(self): return {title: {'author': book_info['author'], 'status': book_info['status']} for title, book_info in self.books.items()} def search_book(self, query): results = {title: {'author': book_info['author'], 'status': book_info['status']} for title, book_info in self.books.items() if query in title or query in book_info['author']} return results if results else \\"No books found matching the query.\\""},{"question":"from typing import List, Dict, Optional def find_shortest_path(graph: Dict[int, List[int]], start: int, end: int) -> Optional[List[int]]: Finds the shortest path between two nodes in an unweighted graph using BFS. :param graph: A dictionary representing the adjacency list of the graph. :param start: The starting node. :param end: The target node. :return: A list of nodes representing the shortest path from start to end, or None if no path exists. >>> graph = {1: [2, 3], 2: [1, 3, 4], 3: [1, 2, 4, 5], 4: [2, 3], 5: [3]} >>> find_shortest_path(graph, 1, 5) [1, 3, 5] >>> find_shortest_path(graph, 1, 4) [1, 2, 4] or [1, 3, 4] >>> find_shortest_path(graph, 2, 5) [2, 3, 5] >>> find_shortest_path(graph, 5, 1) [5, 3, 1] >>> find_shortest_path(graph, 1, 6) None >>> graph = {1: [2, 3], 2: [1], 3: [1], 4: [5], 5: [4]} >>> find_shortest_path(graph, 1, 5) None >>> graph = {1: [2], 2: [1], 3: []} >>> find_shortest_path(graph, 1, 3) None >>> graph = {1: [2, 3], 2: [1], 3: [1, 4], 4: [3]} >>> find_shortest_path(graph, 3, 4) [3, 4] >>> find_shortest_path(graph, 1, 2) [1, 2]","solution":"from typing import List, Dict, Optional from collections import deque def find_shortest_path(graph: Dict[int, List[int]], start: int, end: int) -> Optional[List[int]]: Finds the shortest path between two nodes in an unweighted graph using BFS. :param graph: A dictionary representing the adjacency list of the graph. :param start: The starting node. :param end: The target node. :return: A list of nodes representing the shortest path from start to end, or None if no path exists. if start not in graph or end not in graph: return None queue = deque([(start, [start])]) visited = set() while queue: (current, path) = queue.popleft() visited.add(current) for neighbor in graph[current]: if neighbor == end: return path + [end] if neighbor not in visited: queue.append((neighbor, path + [neighbor])) visited.add(neighbor) # To avoid adding the same node multiple times return None"},{"question":"import pandas as pd import matplotlib.pyplot as plt def load_weather_data(file_path): Load weather data from a CSV file. pass def preprocess_data(data): Preprocess data by parsing dates and handling missing/incomplete data. pass def calculate_monthly_statistics(data): Calculate monthly average, maximum, and minimum temperature for each city. pass def identify_extreme_cities(data): Identify the city with the highest and lowest average temperature for the entire dataset. pass def plot_temperature_comparison(data, hottest_cities, coldest_cities): Plot a graph comparing the average monthly temperatures of the top 5 hottest and coldest cities. pass def analyze_weather_data(file_path): Entry function to handle the processing and plotting. pass import pandas as pd from io import StringIO from solution import load_weather_data, preprocess_data, calculate_monthly_statistics, identify_extreme_cities, analyze_weather_data def test_load_weather_data(): data = \\"date,city,temperaturen2023-01-01,CityA,30n2023-01-02,CityA,25\\" df = load_weather_data(StringIO(data)) assert len(df) == 2 def test_preprocess_data(): data = \\"date,city,temperaturen2023-01-01,CityA,30nNaN,CityB,25n2023-01-02,CityA,NaN\\" df = load_weather_data(StringIO(data)) df = preprocess_data(df) assert df.shape == (1, 3) def test_calculate_monthly_statistics(): data = \\"date,city,temperaturen2023-01-01,CityA,30n2023-01-02,CityA,25n2023-01-01,CityB,10n2023-02-01,CityA,15\\" df = load_weather_data(StringIO(data)) df = preprocess_data(df) monthly_stats = calculate_monthly_statistics(df) assert monthly_stats.shape == (3, 5) assert 'average_temperature' in monthly_stats.columns assert 'max_temperature' in monthly_stats.columns assert 'min_temperature' in monthly_stats.columns def test_identify_extreme_cities(): data = \\"date,city,temperaturen2023-01-01,CityA,30n2023-01-02,CityB,25n2023-01-03,CityC,10n2023-01-04,CityD,15\\" df = load_weather_data(StringIO(data)) df = preprocess_data(df) monthly_stats = calculate_monthly_statistics(df) hottest_city, coldest_city = identify_extreme_cities(monthly_stats) assert hottest_city == 'CityA' assert coldest_city == 'CityC' def test_analyze_weather_data(): data = \\"date,city,temperaturen2023-01-01,CityA,30n2023-01-02,CityB,25n2023-01-03,CityC,10n2023-01-04,CityD,15\\" with open(\\"test_data.csv\\", \\"w\\") as f: f.write(data) hottest_city, coldest_city = analyze_weather_data(\\"test_data.csv\\") assert hottest_city == 'CityA' assert coldest_city == 'CityC'","solution":"import pandas as pd import matplotlib.pyplot as plt def load_weather_data(file_path): Load weather data from a CSV file. return pd.read_csv(file_path) def preprocess_data(data): Preprocess data by parsing dates and handling missing/incomplete data. data['date'] = pd.to_datetime(data['date'], errors='coerce') data.dropna(subset=['date', 'temperature', 'city'], inplace=True) return data def calculate_monthly_statistics(data): Calculate monthly average, maximum, and minimum temperature for each city. data['month'] = data['date'].dt.to_period('M') monthly_stats = data.groupby(['city', 'month'])['temperature'].agg(['mean', 'max', 'min']).reset_index() monthly_stats.rename(columns={'mean': 'average_temperature', 'max': 'max_temperature', 'min': 'min_temperature'}, inplace=True) return monthly_stats def identify_extreme_cities(data): Identify the city with the highest and lowest average temperature for the entire dataset. city_avg_temps = data.groupby('city')['average_temperature'].mean().reset_index() hottest_city = city_avg_temps.loc[city_avg_temps['average_temperature'].idxmax()]['city'] coldest_city = city_avg_temps.loc[city_avg_temps['average_temperature'].idxmin()]['city'] return hottest_city, coldest_city def plot_temperature_comparison(data, hottest_cities, coldest_cities): Plot a graph comparing the average monthly temperatures of the top 5 hottest and coldest cities. comparison_cities = hottest_cities + coldest_cities comparison_data = data[data['city'].isin(comparison_cities)] for city in comparison_cities: city_data = comparison_data[comparison_data['city'] == city] plt.plot(city_data['month'].astype(str), city_data['average_temperature'], label=city) plt.xlabel('Month') plt.ylabel('Average Temperature') plt.title('Average Monthly Temperatures Comparison') plt.legend() plt.show() # Entry function to handle the processing and plotting def analyze_weather_data(file_path): weather_data = load_weather_data(file_path) weather_data = preprocess_data(weather_data) monthly_stats = calculate_monthly_statistics(weather_data) hottest_city, coldest_city = identify_extreme_cities(monthly_stats) hottest_cities = monthly_stats.groupby('city')['average_temperature'].mean().nlargest(5).index.tolist() coldest_cities = monthly_stats.groupby('city')['average_temperature'].mean().nsmallest(5).index.tolist() plot_temperature_comparison(monthly_stats, hottest_cities, coldest_cities) return hottest_city, coldest_city"},{"question":"from typing import List def is_prime(n: int) -> bool: Determines if n is a prime number. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(11) True >>> is_prime(21) False >>> is_prime(1) False >>> is_prime(0) False >>> is_prime(-5) False def filter_primes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the given list of integers. >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) [2, 3, 5, 7, 11] >>> filter_primes([15, 16, 17, 18, 19, 20]) [17, 19] >>> filter_primes([0, 1, -5, -7, 2, 3]) [2, 3] >>> filter_primes([]) [] >>> filter_primes([4, 6, 8, 10]) [] >>> filter_primes([5, 5, 5, 5, 5]) [5, 5, 5, 5, 5]","solution":"def is_prime(n): Determines if n is a prime number. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers): Returns a list of prime numbers from the given list of integers. return [num for num in numbers if is_prime(num)]"},{"question":"def smallest_sorted_consecutive_list(arr): Given an array of integers, returns the smallest sorted list of consecutive integers that cover all the values in the array. :param arr: List of integers :return: Smallest sorted list of consecutive integers >>> smallest_sorted_consecutive_list([6, 2, 4, -1, 5]) [-1, 0, 1, 2, 3, 4, 5, 6] >>> smallest_sorted_consecutive_list([10, 15, 11, 10, 14, 13, 13]) [10, 11, 12, 13, 14, 15] >>> smallest_sorted_consecutive_list([-3, -1, -2]) [-3, -2, -1] >>> smallest_sorted_consecutive_list([]) [] >>> smallest_sorted_consecutive_list([7]) [7] >>> smallest_sorted_consecutive_list([7, 7, 7, 7]) [7] >>> smallest_sorted_consecutive_list([3, 7, 1, 2]) [1, 2, 3, 4, 5, 6, 7]","solution":"def smallest_sorted_consecutive_list(arr): Given an array of integers, returns the smallest sorted list of consecutive integers that cover all the values in the array. :param arr: List of integers :return: Smallest sorted list of consecutive integers if not arr: return [] min_value = min(arr) max_value = max(arr) return list(range(min_value, max_value + 1))"},{"question":"def rotate_matrix(matrix): Rotates an NxN matrix by 90 degrees clockwise in place. >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> rotate_matrix(matrix) >>> matrix [ [3, 1], [4, 2] ] >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ ... [ 1, 2, 3, 4], ... [ 5, 6, 7, 8], ... [ 9, 10, 11, 12], ... [13, 14, 15, 16] ... ] >>> rotate_matrix(matrix) >>> matrix [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] >>> matrix = [ ... [ 1, 2, 3, 4, 5], ... [ 6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20], ... [21, 22, 23, 24, 25] ... ] >>> rotate_matrix(matrix) >>> matrix [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ] >>> matrix = [] >>> rotate_matrix(matrix) >>> matrix []","solution":"def rotate_matrix(matrix): Rotates an NxN matrix by 90 degrees clockwise in place. n = len(matrix) for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): offset = i - first top = matrix[first][i] # left -> top matrix[first][i] = matrix[last - offset][first] # bottom -> left matrix[last - offset][first] = matrix[last][last - offset] # right -> bottom matrix[last][last - offset] = matrix[i][last] # top -> right matrix[i][last] = top"},{"question":"def qualify_scores(scores): Write a function qualify_scores that takes in a list of integers representing scores, calculates the average score, and returns a new list of scores that are greater than or equal to the average score. If the list is empty, return an empty list. Args: scores (list): A list of integers representing scores. Returns: list: A list of scores that are greater than or equal to the average score. Example: >>> qualify_scores([90, 70, 50, 60, 80]) [90, 70, 80] >>> qualify_scores([100, 50, 75]) [100, 75] >>> qualify_scores([]) [] >>> qualify_scores([70, 70, 70]) [70, 70, 70] >>> qualify_scores([0, 50, 100]) [50, 100] >>> qualify_scores([-50, -20, 0, 20, 50]) [0, 20, 50] >>> qualify_scores([50, 40, 30, 20]) [50, 40]","solution":"def qualify_scores(scores): Write a function qualify_scores that takes in a list of integers representing scores, calculates the average score, and returns a new list of scores that are greater than or equal to the average score. If the list is empty, return an empty list. Args: scores (list): A list of integers representing scores. Returns: list: A list of scores that are greater than or equal to the average score. if not scores: return [] average_score = sum(scores) / len(scores) return [score for score in scores if score >= average_score]"},{"question":"def find_longest_increasing_subsequence(numbers: List[int]) -> List[int]: Write a function called \`find_longest_increasing_subsequence\` that takes a list of integers \`numbers\` as input and returns the longest increasing subsequence within that list. An increasing subsequence is defined as a set of elements from the original list which are in strictly increasing order and not necessarily contiguous. The function should handle lists with negative numbers, zero, and positive numbers, and should return an empty list if no increasing subsequence exists. >>> find_longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) [10, 22, 33, 50, 60, 80] >>> find_longest_increasing_subsequence([3, 10, 2, 1, 20]) [3, 10, 20] >>> find_longest_increasing_subsequence([-5, -1, 0, 3, -2, 2]) [-5, -1, 0, 3] >>> find_longest_increasing_subsequence([5]) [5] >>> find_longest_increasing_subsequence([]) [] >>> find_longest_increasing_subsequence([5, 4, 3, 2, 1]) [5] >>> find_longest_increasing_subsequence([7, 7, 7, 7]) [7] >>> find_longest_increasing_subsequence([1, 3, 2, 4, 3, 5]) [1, 3, 4, 5]","solution":"def find_longest_increasing_subsequence(numbers): Returns the longest increasing subsequence within the list of numbers. if not numbers: return [] n = len(numbers) lis = [1] * n prev = [-1] * n for i in range(1, n): for j in range(i): if numbers[i] > numbers[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 prev[i] = j max_lis_length = max(lis) max_index = lis.index(max_lis_length) longest_subseq = [] while max_index != -1: longest_subseq.append(numbers[max_index]) max_index = prev[max_index] return longest_subseq[::-1]"},{"question":"def simple_calculator(num1: float, num2: float, operation: str) -> float: Simulates a simple calculator that can perform basic arithmetic operations: addition, subtraction, multiplication, and division. Parameters: - num1: float: The first number. - num2: float: The second number. - operation: str: The operation to be performed (one of \\"add\\", \\"subtract\\", \\"multiply\\", \\"divide\\"). Returns: - float: The result of the operation. - str: Error message if division by zero is attempted or if the operation is unknown. Examples: >>> simple_calculator(10, 5, \\"add\\") 15 >>> simple_calculator(10, 5, \\"subtract\\") 5 >>> simple_calculator(10, 5, \\"multiply\\") 50 >>> simple_calculator(10, 5, \\"divide\\") 2 >>> simple_calculator(10, 0, \\"divide\\") \\"Error: Division by zero\\" >>> simple_calculator(10, 5, \\"mod\\") \\"Error: Unknown operation\\" pass","solution":"def simple_calculator(num1: float, num2: float, operation: str) -> float: Performs basic arithmetic operations: addition, subtraction, multiplication, and division. Parameters: - num1: float: The first number. - num2: float: The second number. - operation: str: The operation to be performed (\\"add\\", \\"subtract\\", \\"multiply\\", \\"divide\\"). Returns: - float: The result of the operation. - str: Error message if division by zero is attempted. if operation == \\"add\\": return num1 + num2 elif operation == \\"subtract\\": return num1 - num2 elif operation == \\"multiply\\": return num1 * num2 elif operation == \\"divide\\": if num2 != 0: return num1 / num2 else: return \\"Error: Division by zero\\" else: return \\"Error: Unknown operation\\""},{"question":"def read_sort_write(input_file, output_file): This function reads a list of integers from the input_file, sorts them in ascending order, and writes the sorted list to the output_file. It handles errors such as the input file not existing or containing non-integer values. try: with open(input_file, 'r') as infile: numbers = infile.readlines() # Convert the list of strings to a list of integers try: numbers = [int(num.strip()) for num in numbers] except ValueError: raise ValueError(\\"Input file contains non-integer values\\") # Sort the numbers numbers.sort() # Write the sorted list to the output file with open(output_file, 'w') as outfile: for num in numbers: outfile.write(f\\"{num}n\\") except FileNotFoundError: raise FileNotFoundError(\\"Input file does not exist\\") # Tests import pytest import os def test_read_sort_write_valid_input(tmp_path): input_file = tmp_path / \\"input.txt\\" output_file = tmp_path / \\"output.txt\\" # Create a file with unsorted integers input_file.write_text(\\"3n1n4n1n5n9n2n6n5n3n5n\\") # Run the function read_sort_write(input_file, output_file) # Check the output file for sorted integers expected_output = \\"1n1n2n3n3n4n5n5n5n6n9n\\" assert output_file.read_text() == expected_output def test_read_sort_write_nonexistent_input_file(tmp_path): input_file = tmp_path / \\"nonexistent.txt\\" output_file = tmp_path / \\"output.txt\\" with pytest.raises(FileNotFoundError, match=\\"Input file does not exist\\"): read_sort_write(input_file, output_file) def test_read_sort_write_non_integer_values(tmp_path): input_file = tmp_path / \\"input.txt\\" output_file = tmp_path / \\"output.txt\\" # Create a file with non-integer values input_file.write_text(\\"3n1n4napplen5n\\") with pytest.raises(ValueError, match=\\"Input file contains non-integer values\\"): read_sort_write(input_file, output_file)","solution":"def read_sort_write(input_file, output_file): This function reads a list of integers from the input_file, sorts them in ascending order, and writes the sorted list to the output_file. It handles errors such as the input file not existing or containing non-integer values. try: with open(input_file, 'r') as infile: numbers = infile.readlines() # Convert the list of strings to a list of integers try: numbers = [int(num.strip()) for num in numbers] except ValueError: raise ValueError(\\"Input file contains non-integer values\\") # Sort the numbers numbers.sort() # Write the sorted list to the output file with open(output_file, 'w') as outfile: for num in numbers: outfile.write(f\\"{num}n\\") except FileNotFoundError: raise FileNotFoundError(\\"Input file does not exist\\")"},{"question":"def find_intersection(list1, list2): Implement a function find_intersection that takes two lists of integers, \`list1\` and \`list2\`, and returns a list containing the intersection of these two lists. The intersection should only contain unique elements present in both lists, and the order of elements in the result does not matter. You may not use any built-in set operations. Example: >>> find_intersection([1, 2, 2, 3, 4], [2, 3, 5, 6, 2]) [2, 3] >>> find_intersection([7, 8, 9], [10, 11, 8]) [8] >>> find_intersection([1, 3, 5], [2, 4, 6]) [] >>> find_intersection([1, 2, 3, 4], [2, 4, 4, 4, 4]) [2, 4] >>> find_intersection([], []) [] >>> find_intersection([1, 2, 3], []) [] >>> find_intersection([], [1, 2, 3]) []","solution":"def find_intersection(list1, list2): Returns the intersection of list1 and list2, containing only unique elements. intersection = [] list2_elements = {} for item in list2: list2_elements[item] = list2_elements.get(item, 0) + 1 for item in list1: if item in list2_elements and list2_elements[item] > 0: if item not in intersection: intersection.append(item) list2_elements[item] -= 1 return intersection"},{"question":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler from sklearn.linear_model import LogisticRegression from sklearn.metrics import accuracy_score def load_and_preprocess_data(file_path): Load and preprocess the weather data from a CSV file. Parameters: file_path (str): The path to the CSV file containing the weather data. Returns: X_train, X_test, y_train, y_test: Split and scaled training and testing data. def train_predictive_model(X_train, y_train): Train a logistic regression model on the weather data. Parameters: X_train: Training feature data. y_train: Training label data. Returns: model: Trained logistic regression model. def forecast_precipitation(file_path): Predict precipitation using the logistic regression model. Parameters: file_path (str): The path to the CSV file containing the weather data. Returns: float: Accuracy of the model on the testing data. # Unit Tests def test_load_and_preprocess_data(): create_temp_csv() # Checking only for accurate preprocessing behavior _, X_test, _, y_test = load_and_preprocess_data('temp_weather_data.csv') assert X_test.shape[1] == 5 assert len(y_test) > 0 def test_train_predictive_model(): create_temp_csv() X_train, X_test, y_train, y_test = load_and_preprocess_data('temp_weather_data.csv') model = train_predictive_model(X_train, y_train) y_pred = model.predict(X_test) assert len(y_pred) == len(y_test) def test_forecast_precipitation(): create_temp_csv() accuracy = forecast_precipitation('temp_weather_data.csv') assert 0 <= accuracy <= 1","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler from sklearn.linear_model import LogisticRegression from sklearn.metrics import accuracy_score def load_and_preprocess_data(file_path): Load and preprocess the weather data from a CSV file. Parameters: file_path (str): The path to the CSV file containing the weather data. Returns: X_train, X_test, y_train, y_test: Split and scaled training and testing data. # Load the dataset data = pd.read_csv(file_path) # Assuming the label column is named 'Precipitation' X = data.drop(columns=['Precipitation']) y = data['Precipitation'] # Split the data into training and testing sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Scale the features scaler = StandardScaler() X_train = scaler.fit_transform(X_train) X_test = scaler.transform(X_test) return X_train, X_test, y_train, y_test def train_predictive_model(X_train, y_train): Train a logistic regression model on the weather data. Parameters: X_train: Training feature data. y_train: Training label data. Returns: model: Trained logistic regression model. model = LogisticRegression(random_state=42) model.fit(X_train, y_train) return model def forecast_precipitation(file_path): Predict precipitation using the logistic regression model. Parameters: file_path (str): The path to the CSV file containing the weather data. Returns: float: Accuracy of the model on the testing data. # Load and preprocess data X_train, X_test, y_train, y_test = load_and_preprocess_data(file_path) # Train the model model = train_predictive_model(X_train, y_train) # Predict on the test set y_pred = model.predict(X_test) # Calculate and return accuracy accuracy = accuracy_score(y_test, y_pred) return accuracy"},{"question":"def shift_letters(text: str) -> str: Replaces each letter in the input text with the next letter in the alphabet. Wraps around if the letter is 'z' or 'Z'. >>> shift_letters(\\"Hello WorldZ\\") \\"Ifmmp XpsmeA\\" >>> shift_letters(\\"abc! xyz\\") \\"bcd! yza\\" >>> shift_letters(\\"WORLDZ\\") \\"XPSMEA\\" >>> shift_letters(\\"xyz XYZ\\") \\"yza YZA\\" >>> shift_letters(\\"\\") \\"\\" >>> shift_letters(\\"a\\") \\"b\\" >>> shift_letters(\\"z\\") \\"a\\" >>> shift_letters(\\"A\\") \\"B\\" >>> shift_letters(\\"Z\\") \\"A\\" from solution import shift_letters def test_shift_letters_all_lowercase(): assert shift_letters(\\"hello\\") == \\"ifmmp\\" def test_shift_letters_all_uppercase(): assert shift_letters(\\"WORLDZ\\") == \\"XPSMEA\\" def test_shift_letters_mixed_case(): assert shift_letters(\\"Hello WorldZ\\") == \\"Ifmmp XpsmeA\\" def test_shift_letters_with_non_alpha_characters(): assert shift_letters(\\"abc! xyz\\") == \\"bcd! yza\\" def test_shift_letters_wrap_around(): assert shift_letters(\\"xyz XYZ\\") == \\"yza YZA\\" def test_shift_letters_empty_string(): assert shift_letters(\\"\\") == \\"\\" def test_shift_letters_single_characters(): assert shift_letters(\\"a\\") == \\"b\\" assert shift_letters(\\"z\\") == \\"a\\" assert shift_letters(\\"A\\") == \\"B\\" assert shift_letters(\\"Z\\") == \\"A\\"","solution":"def shift_letters(text): Replaces each letter in the input text with the next letter in the alphabet. Wraps around if the letter is 'z' or 'Z'. shifted_text = [] for char in text: if 'a' <= char <= 'y': shifted_text.append(chr(ord(char) + 1)) elif char == 'z': shifted_text.append('a') elif 'A' <= char <= 'Y': shifted_text.append(chr(ord(char) + 1)) elif char == 'Z': shifted_text.append('A') else: shifted_text.append(char) return ''.join(shifted_text)"},{"question":"def has_pair_with_sum(numbers: List[int], target: int) -> bool: Returns True if there are two distinct elements in the list that add up to the target sum. Otherwise, returns False. >>> has_pair_with_sum([1, 2, 3, 4], 5) True >>> has_pair_with_sum([1, 2, 4, 9], 8) False >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([5], 5) False >>> has_pair_with_sum([1, 1, 3, 2], 4) True >>> has_pair_with_sum([3, 5, -2, 8, 11], 6) True >>> has_pair_with_sum([1, -1, 2, -2, 3], 0) True >>> has_pair_with_sum([1, 2, 3], 0) False >>> has_pair_with_sum([-1, -2, -3, -4], -5) True seen_numbers = set() for number in numbers: compliment = target - number if compliment in seen_numbers: return True seen_numbers.add(number) return False","solution":"def has_pair_with_sum(numbers, target): Returns True if there are two distinct elements in the list that add up to the target sum. Otherwise, returns False. seen_numbers = set() for number in numbers: compliment = target - number if compliment in seen_numbers: return True seen_numbers.add(number) return False"},{"question":"def count_integers(int_list: List[int]) -> Dict[int, int]: Takes a list of integers as input and returns a dictionary where the keys are the unique integers from the list, and the values are the count of how many times each integer appears in the list. The function should be able to handle and correctly process an empty list input. >>> count_integers([1, 2, 2, 3, 3, 3, 4]) == {1: 1, 2: 2, 3: 3, 4: 1} >>> count_integers([-1, -2, -2, -3, -3, -3, -4]) == {-1: 1, -2: 2, -3: 3, -4: 1} >>> count_integers([1, -1, 2, -2, 2, -2, 3, -3, 3, -3, 3, -3, 4, -4]) == {1: 1, -1: 1, 2: 2, -2: 2, 3: 3, -3: 3, 4: 1, -4: 1} >>> count_integers([5]) == {5: 1} >>> count_integers([]) == {} >>> count_integers([7, 7, 7, 7, 7, 7]) == {7: 6}","solution":"def count_integers(int_list): Takes a list of integers and returns a dictionary where the keys are the unique integers from the list, and the values are the count of how many times each integer appears in the list. count_dict = {} for integer in int_list: if integer in count_dict: count_dict[integer] += 1 else: count_dict[integer] = 1 return count_dict # Example usage: # sample_input = [1, 2, 2, 3, 3, 3, 4] # result = count_integers(sample_input) # print(result) # Output should be {1: 1, 2: 2, 3: 3, 4: 1}"},{"question":"import pandas as pd import matplotlib.pyplot as plt def read_resample_plot(file_path: str, timestamp_col: str, data_col: str, frequency: str): Reads a CSV file, transforms timestamps to a pandas DateTime index, resamples numerical data to a specified frequency and plots the resampled data. :param file_path: Path to the CSV file :param timestamp_col: The name of the timestamp column :param data_col: The name of the numerical data column :param frequency: The frequency to which the data needs to be resampled (e.g., 'H' for hour) >>> import pandas as pd >>> from io import StringIO >>> data = StringIO(timestamp,datan2023-10-01 00:00:00,10n2023-10-01 00:01:00,20n2023-10-01 00:02:00,30n2023-10-01 01:00:00,40n2023-10-01 01:01:00,50n2023-10-01 01:02:00,60) >>> sample_df = pd.read_csv(data) >>> sample_df.to_csv('sample_data.csv', index=False) >>> read_resample_plot('sample_data.csv', 'timestamp', 'data', 'H')","solution":"import pandas as pd import matplotlib.pyplot as plt def read_resample_plot(file_path, timestamp_col, data_col, frequency): Reads a CSV file, transforms timestamps to a pandas DateTime index, resamples numerical data to a specified frequency and plots the resampled data. :param file_path: Path to the CSV file :param timestamp_col: The name of the timestamp column :param data_col: The name of the numerical data column :param frequency: The frequency to which the data needs to be resampled (e.g., 'H' for hour) # Read CSV file df = pd.read_csv(file_path) # Transform timestamps to pandas DateTime index df[timestamp_col] = pd.to_datetime(df[timestamp_col]) df.set_index(timestamp_col, inplace=True) # Resample the data resampled_df = df.resample(frequency).mean() # Plot the resampled data plt.figure(figsize=(10, 6)) plt.plot(resampled_df.index, resampled_df[data_col], marker='o') plt.xlabel('Datetime') plt.ylabel(data_col) plt.title(f'{data_col} Resampled to {frequency}') plt.grid(True) # Formatting the datetime axis plt.gcf().autofmt_xdate() plt.show()"},{"question":"def find_armstrong_numbers(low, high): Determine all the Armstrong numbers within a specified range. An Armstrong number (also known as a narcissistic number) for a given number of digits is a number that is equal to the sum of its own digits each raised to the power of the number of digits. Both low and high should be positive integers, with low <= high. The function must validate the inputs and handle scenarios where there are no Armstrong numbers in the given range. Args: low(int): the lower bound of the range. high(int): the upper bound of the range. Returns: list: a list of all Armstrong numbers within the specified range. Raises: TypeError: If low or high is not an integer. ValueError: If low or high is not positive or low is greater than high. Examples: >>> find_armstrong_numbers(153, 153) [153] >>> find_armstrong_numbers(100, 500) [153, 370, 371, 407] >>> find_armstrong_numbers(200, 300) [] >>> find_armstrong_numbers(1, 1) [1] >>> find_armstrong_numbers(1, 10000) [1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407, 1634, 8208, 9474] Unit Tests: import pytest def test_find_armstrong_numbers(): assert find_armstrong_numbers(153, 153) == [153] assert set(find_armstrong_numbers(100, 500)) == {153, 370, 371, 407} assert find_armstrong_numbers(200, 300) == [] assert find_armstrong_numbers(1, 1) == [1] armstrongs = find_armstrong_numbers(1, 10000) expected = [1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407, 1634, 8208, 9474] assert set(armstrongs) == set(expected) with pytest.raises(ValueError): find_armstrong_numbers(-1, 500) with pytest.raises(ValueError): find_armstrong_numbers(0, 500) with pytest.raises(TypeError): find_armstrong_numbers(\\"100\\", 500) with pytest.raises(ValueError): find_armstrong_numbers(500, 100)","solution":"def is_armstrong(number): Checks if a number is an Armstrong number. digits = [int(d) for d in str(number)] power = len(digits) return number == sum(d ** power for d in digits) def find_armstrong_numbers(low, high): Returns a list of all Armstrong numbers between low and high (inclusive). Both low and high should be positive integers, with low <= high. if not (isinstance(low, int) and isinstance(high, int)): raise TypeError(\\"Both low and high must be integers.\\") if low <= 0 or high <= 0: raise ValueError(\\"Both low and high must be positive integers.\\") if low > high: raise ValueError(\\"Low bound must be less than or equal to high bound.\\") armstrong_numbers = [] for number in range(low, high + 1): if is_armstrong(number): armstrong_numbers.append(number) return armstrong_numbers"},{"question":"from typing import List, Tuple def find_pairs(lst: List[int], n: int) -> List[Tuple[int, int]]: Write a function in Python that takes a list of integers and an integer \`n\`, and returns a list of tuples where each tuple contains two numbers from the list that add up to \`n\`. Ensure that each pair of numbers is unique, and the order of the pairs does not matter. If no such pairs exist, return an empty list. >>> find_pairs([1, 2, 3, 4, 3], 6) [(2, 4), (3, 3)] >>> find_pairs([1, 2, 3], 7) [] >>> find_pairs([1, 2, 3, 4, 5, 6], 7) [(1, 6), (2, 5), (3, 4)] >>> find_pairs([], 7) [] >>> find_pairs([7], 7) [] >>> find_pairs([1, 1, 2, 2], 3) [(1, 2)] >>> find_pairs([3, 3, 3, 3], 6) [(3, 3)]","solution":"def find_pairs(lst, n): Return a list of unique pairs of numbers from the list that add up to n. seen = set() pairs = set() for number in lst: target = n - number if target in seen: pairs.add(tuple(sorted((number, target)))) seen.add(number) return list(pairs)"},{"question":"import numpy as np from sklearn.metrics.pairwise import cosine_similarity def collaborative_filtering_recommendations(ratings_matrix, target_user, top_n=5): Uses collaborative filtering to make recommendations based on user-item ratings matrix. :param ratings_matrix: 2D numpy array, where rows represent users, columns represent items, and values represent ratings. :param target_user: Index of the user for whom recommendations are to be made. :param top_n: Number of top recommendations to return. :return: List of item indices recommended for the target user. >>> ratings = np.array([ ... [4, 5, 0, 0], ... [0, 0, 4, 5], ... [5, 4, 0, 4], ... [5, 4, 0, 0] ... ]) >>> collaborative_filtering_recommendations(ratings, 0) [2, 3] >>> ratings = np.array([ ... [4, 0, 0, 2, 0], ... [5, 0, 3, 4, 5], ... [4, 5, 0, 2, 4], ... [0, 4, 3, 0, 5] ... ]) >>> collaborative_filtering_recommendations(ratings, 0, top_n=2) [1, 2, 4] >>> ratings = np.array([ ... [4, 5, 3, 2], ... [5, 4, 3, 2], ... [4, 5, 3, 2] ... ]) >>> collaborative_filtering_recommendations(ratings, 1) [] pass","solution":"import numpy as np from sklearn.metrics.pairwise import cosine_similarity def collaborative_filtering_recommendations(ratings_matrix, target_user, top_n=5): Uses collaborative filtering to make recommendations based on user-item ratings matrix. :param ratings_matrix: 2D numpy array, where rows represent users, columns represent items, and values represent ratings. :param target_user: Index of the user for whom recommendations are to be made. :param top_n: Number of top recommendations to return. :return: List of item indices recommended for the target user. user_similarities = cosine_similarity(ratings_matrix) target_user_ratings = ratings_matrix[target_user] unrated_items = np.where(target_user_ratings == 0)[0] if len(unrated_items) == 0: return [] score_sums = np.zeros(len(unrated_items)) sim_sums = np.zeros(len(unrated_items)) for other_user in range(ratings_matrix.shape[0]): if other_user != target_user: similarity = user_similarities[target_user, other_user] for idx, item in enumerate(unrated_items): if ratings_matrix[other_user, item] > 0: score_sums[idx] += similarity * ratings_matrix[other_user, item] sim_sums[idx] += similarity predicted_scores = score_sums / np.where(sim_sums == 0, 1, sim_sums) # Avoid division by zero top_items_idx = np.argsort(predicted_scores)[::-1][:top_n] return unrated_items[top_items_idx].tolist()"},{"question":"def group_words_by_length(words_list): Groups words by their lengths. Args: words_list (list): List of words. Returns: dict: Dictionary where keys are word lengths and values are lists of words of that length. Example: >>> words_list = [\\"apple\\", \\"banana\\", \\"kiwi\\", \\"pear\\", \\"blueberry\\", \\"strawberry\\", \\"plum\\"] >>> group_words_by_length(words_list) {5: [\\"apple\\"], 6: [\\"banana\\"], 4: [\\"kiwi\\", \\"pear\\", \\"plum\\"], 9: [\\"blueberry\\"], 10: [\\"strawberry\\"]} from solution import group_words_by_length def test_group_words_by_length(): words_list = [\\"apple\\", \\"banana\\", \\"kiwi\\", \\"pear\\", \\"blueberry\\", \\"strawberry\\", \\"plum\\"] expected_output = {5: [\\"apple\\"], 6: [\\"banana\\"], 4: [\\"kiwi\\", \\"pear\\", \\"plum\\"], 9: [\\"blueberry\\"], 10: [\\"strawberry\\"]} assert group_words_by_length(words_list) == expected_output def test_group_words_by_length_empty(): words_list = [] expected_output = {} assert group_words_by_length(words_list) == expected_output def test_group_words_by_length_single_word(): words_list = [\\"apple\\"] expected_output = {5: [\\"apple\\"]} assert group_words_by_length(words_list) == expected_output def test_group_words_by_length_identical_lengths(): words_list = [\\"dog\\", \\"cat\\", \\"bat\\"] expected_output = {3: [\\"dog\\", \\"cat\\", \\"bat\\"]} assert group_words_by_length(words_list) == expected_output def test_group_words_by_length_mixed_lengths(): words_list = [\\"a\\", \\"bb\\", \\"ccc\\", \\"dddd\\", \\"ee\\", \\"f\\", \\"gg\\"] expected_output = {1: [\\"a\\", \\"f\\"], 2: [\\"bb\\", \\"ee\\", \\"gg\\"], 3: [\\"ccc\\"], 4: [\\"dddd\\"]} assert group_words_by_length(words_list) == expected_output","solution":"def group_words_by_length(words_list): Groups words by their lengths. Args: words_list (list): List of words. Returns: dict: Dictionary where keys are word lengths and values are lists of words of that length. result = {} for word in words_list: length = len(word) if length not in result: result[length] = [] result[length].append(word) return result"},{"question":"def word_in_grid(grid, word): Write a Python function that takes a 2D list representing a grid of characters and a string as inputs, and returns True if the string can be found in the grid moving horizontally or vertically, and False otherwise. The function should implement a depth-first search (DFS) algorithm to traverse the grid. >>> grid = [ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ] >>> word_in_grid(grid, 'ABCCED') True >>> word_in_grid(grid, 'SEE') True >>> word_in_grid(grid, 'ABCB') False Test cases: from solution import word_in_grid def test_word_in_grid_present(): grid = [ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ] assert word_in_grid(grid, 'ABCCED') == True assert word_in_grid(grid, 'SEE') == True def test_word_in_grid_absent(): grid = [ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ] assert word_in_grid(grid, 'ABCB') == False def test_empty_grid(): assert word_in_grid([], 'ABCCED') == False def test_empty_word(): grid = [ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ] assert word_in_grid(grid, '') == False def test_single_letter_grid_and_word(): assert word_in_grid([['A']], 'A') == True assert word_in_grid([['A']], 'B') == False def test_multiple_occurrences(): grid = [ ['A', 'A', 'A', 'A'], ['A', 'A', 'A', 'A'], ['A', 'A', 'A', 'A'] ] assert word_in_grid(grid, 'AAA') == True def test_word_longer_than_grid(): grid = [ ['A', 'B'], ['C', 'D'] ] assert word_in_grid(grid, 'ABCDE') == False","solution":"def word_in_grid(grid, word): if not grid or not word: return False rows, cols = len(grid), len(grid[0]) def dfs(r, c, index): if index == len(word): return True if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] != word[index]: return False # Save the character at the current position and mark it as visited temp = grid[r][c] grid[r][c] = '#' # Explore in all four directions found = (dfs(r+1, c, index+1) or # Move down dfs(r-1, c, index+1) or # Move up dfs(r, c+1, index+1) or # Move right dfs(r, c-1, index+1)) # Move left # Restore the character at the current position grid[r][c] = temp return found for i in range(rows): for j in range(cols): if dfs(i, j, 0): return True return False"},{"question":"def multifaceted_sum(input_structure): Design a function named multifaceted_sum that accepts a complex data structure composed of numbers nested within lists, dictionaries, and tuples. The function should traverse through the nested layers and sum all numeric values present. Ensure that the function can handle complex nesting and correctly identify and sum numeric values without being affected by mixed data types within the structure. Example: >>> multifaceted_sum([1, 2, [3, 4], {'a': 5, 'b': (6, 7)}]) 28 >>> multifaceted_sum({'x': 1, 'y': [2, 3, {'z': 4}], 'w': (5, {'u': 6, 'v': 7})}) 28 >>> multifaceted_sum(([1, {'a': [2, 3]}, 4], {'b': 5, 'c': (6, 7)})) 28 def test_multifaceted_sum_flat_list(): assert multifaceted_sum([1, 2, 3, 4]) == 10 def test_multifaceted_sum_nested_list(): assert multifaceted_sum([1, 2, [3, 4], 5]) == 15 def test_multifaceted_sum_dict_in_list(): assert multifaceted_sum([1, 2, {'a': 3, 'b': 4}, 5]) == 15 def test_multifaceted_sum_tuple(): assert multifaceted_sum((1, 2, 3, 4)) == 10 def test_multifaceted_sum_tuple_with_list(): assert multifaceted_sum((1, 2, [3, 4], 5)) == 15 def test_multifaceted_sum_complex_structure_1(): assert multifaceted_sum([1, 2, [3, 4], {'a': 5, 'b': (6, 7)}]) == 28 def test_multifaceted_sum_complex_structure_2(): assert multifaceted_sum({'x': 1, 'y': [2, 3, {'z': 4}], 'w': (5, {'u': 6, 'v': 7})}) == 28 def test_multifaceted_sum_complex_structure_3(): assert multifaceted_sum(([1, {'a': [2, 3]}, 4], {'b': 5, 'c': (6, 7)})) == 28 def test_multifaceted_sum_with_floats(): assert multifaceted_sum([1.5, 2, [0.5, 4], {'a': 5, 'b': (6, 7.5)}]) == 26.5 def test_multifaceted_sum_empty_structure(): assert multifaceted_sum([]) == 0 assert multifaceted_sum({}) == 0 assert multifaceted_sum(()) == 0","solution":"def multifaceted_sum(input_structure): Sums all numeric values from a nested data structure that can include lists, dictionaries, and tuples. total = 0 if isinstance(input_structure, (list, tuple)): for element in input_structure: total += multifaceted_sum(element) elif isinstance(input_structure, dict): for key, value in input_structure.items(): total += multifaceted_sum(value) elif isinstance(input_structure, (int, float)): total += input_structure return total"},{"question":"class StringManipulator: Design and implement a Python class: \`StringManipulator\` that performs various operations on a string. Methods: - set_string(s): Initialize the private string attribute. - reverse(): Return the reverse of the private string attribute. - format_string(case): Format the string based on the provided argument \\"case\\". - modify(indices, char): Replace characters at specified indices with the provided character. - execute_string_operations(case): Invoke 'set_string', 'reverse', and 'format_string' in sequence if valid 'case'. >>> sm = StringManipulator() >>> sm.set_string(\\"hello\\") >>> sm.reverse() 'olleh' >>> sm.format_string('Upper') 'HELLO' >>> sm.format_string('Lower') 'hello' >>> sm.format_string('Title') 'Hello' >>> sm.modify([1, 4], '*') >>> sm._StringManipulator__s 'h*ll*' >>> sm.execute_string_operations('Upper') {'reversed': 'olleh', 'formatted': 'HELLO'} def __init__(self): self.__s = \\"\\" # private string attribute def set_string(self, s): pass # Implementation comes here def reverse(self): pass # Implementation comes here def format_string(self, case): pass # Implementation comes here def modify(self, indices, char): pass # Implementation comes here def execute_string_operations(self, case): pass # Implementation comes here","solution":"class StringManipulator: def __init__(self): self.__s = \\"\\" # private string attribute def set_string(self, s): self.__s = s def reverse(self): return self.__s[::-1] def format_string(self, case): if case == 'Upper': return self.__s.upper() elif case == 'Lower': return self.__s.lower() elif case == 'Title': return self.__s.title() else: raise ValueError(f\\"Invalid case: {case}\\") def modify(self, indices, char): s_list = list(self.__s) for idx in indices: if 0 <= idx < len(self.__s): s_list[idx] = char else: raise IndexError(f\\"Index {idx} is out of range for the string of length {len(self.__s)}\\") self.__s = \\"\\".join(s_list) def execute_string_operations(self, case): valid_cases = ['Upper', 'Lower', 'Title'] if case in valid_cases: self.set_string(self.__s) # call to set_string reversed_string = self.reverse() # call to reverse formatted_string = self.format_string(case) # call to format_string return {\\"reversed\\": reversed_string, \\"formatted\\": formatted_string} else: raise ValueError(f\\"Case must be one of {valid_cases}\\")"},{"question":"class InventoryManager: A class to manage an inventory of products for a small business. The class supports adding a new product, updating an existing product, retrieving a product by ID, removing a product, and generating a summary of the inventory. Example: >>> manager = InventoryManager() >>> manager.add_product(\\"1\\", \\"Apple\\", 10, 1.2) >>> manager.get_product(\\"1\\") {'name': 'Apple', 'quantity': 10, 'price': 1.2} >>> manager.update_product(\\"1\\", quantity=20, price=1.5) >>> manager.get_product(\\"1\\") {'name': 'Apple', 'quantity': 20, 'price': 1.5} >>> manager.remove_product(\\"1\\") >>> manager.generate_summary() {} def __init__(self): Initialize the inventory manager with an empty inventory. self.inventory = {} def add_product(self, product_id, name, quantity, price): Add a new product to the inventory. Args: product_id (str): The unique ID of the product. name (str): The name of the product. quantity (int): The quantity of the product. price (float): The price of the product. Raises: ValueError: If a product with the same ID already exists. def update_product(self, product_id, quantity=None, price=None): Update the quantity or price of an existing product. Args: product_id (str): The unique ID of the product. quantity (Optional[int]): The new quantity of the product. price (Optional[float]): The new price of the product. Raises: ValueError: If the product ID does not exist. def get_product(self, product_id): Retrieve information about a specific product given its ID. Args: product_id (str): The unique ID of the product. Returns: dict: A dictionary containing the product's name, quantity, and price. Raises: ValueError: If the product ID does not exist. def remove_product(self, product_id): Remove a product from the inventory. Args: product_id (str): The unique ID of the product. Raises: ValueError: If the product ID does not exist. def generate_summary(self): Generate a summary of the inventory. Returns: dict: A dictionary containing all products with their details. import pytest def test_add_product(): manager = InventoryManager() manager.add_product(\\"1\\", \\"Apple\\", 10, 1.2) assert manager.get_product(\\"1\\") == {\\"name\\": \\"Apple\\", \\"quantity\\": 10, \\"price\\": 1.2} def test_add_existing_product(): manager = InventoryManager() manager.add_product(\\"1\\", \\"Apple\\", 10, 1.2) with pytest.raises(ValueError): manager.add_product(\\"1\\", \\"Banana\\", 20, 0.8) def test_update_product(): manager = InventoryManager() manager.add_product(\\"1\\", \\"Apple\\", 10, 1.2) manager.update_product(\\"1\\", quantity=20, price=1.5) assert manager.get_product(\\"1\\") == {\\"name\\": \\"Apple\\", \\"quantity\\": 20, \\"price\\": 1.5} def test_update_nonexistent_product(): manager = InventoryManager() with pytest.raises(ValueError): manager.update_product(\\"2\\", quantity=30) def test_get_product(): manager = InventoryManager() manager.add_product(\\"1\\", \\"Apple\\", 10, 1.2) assert manager.get_product(\\"1\\") == {\\"name\\": \\"Apple\\", \\"quantity\\": 10, \\"price\\": 1.2} def test_get_nonexistent_product(): manager = InventoryManager() with pytest.raises(ValueError): manager.get_product(\\"2\\") def test_remove_product(): manager = InventoryManager() manager.add_product(\\"1\\", \\"Apple\\", 10, 1.2) manager.remove_product(\\"1\\") with pytest.raises(ValueError): manager.get_product(\\"1\\") def test_remove_nonexistent_product(): manager = InventoryManager() with pytest.raises(ValueError): manager.remove_product(\\"2\\") def test_generate_summary(): manager = InventoryManager() manager.add_product(\\"1\\", \\"Apple\\", 10, 1.2) manager.add_product(\\"2\\", \\"Banana\\", 20, 0.8) summary = manager.generate_summary() assert summary == { \\"1\\": {\\"name\\": \\"Apple\\", \\"quantity\\": 10, \\"price\\": 1.2}, \\"2\\": {\\"name\\": \\"Banana\\", \\"quantity\\": 20, \\"price\\": 0.8} }","solution":"class InventoryManager: def __init__(self): self.inventory = {} def add_product(self, product_id, name, quantity, price): if product_id in self.inventory: raise ValueError(\\"Product ID already exists\\") self.inventory[product_id] = {\\"name\\": name, \\"quantity\\": quantity, \\"price\\": price} def update_product(self, product_id, quantity=None, price=None): if product_id not in self.inventory: raise ValueError(\\"Product ID does not exist\\") if quantity is not None: self.inventory[product_id][\\"quantity\\"] = quantity if price is not None: self.inventory[product_id][\\"price\\"] = price def get_product(self, product_id): if product_id not in self.inventory: raise ValueError(\\"Product ID does not exist\\") return self.inventory[product_id] def remove_product(self, product_id): if product_id not in self.inventory: raise ValueError(\\"Product ID does not exist\\") del self.inventory[product_id] def generate_summary(self): return self.inventory"},{"question":"from typing import List def second_largest_unique(nums: List[int]) -> int: Given a list of positive integers, this function computes the second largest unique number. If there is no such number, it returns -1. Args: nums (List[int]): The list of positive integers. Returns: int: The second largest unique number or -1 if it doesn't exist. Examples: >>> second_largest_unique([4, 2, 5, 7, 7, 5, 1, 3]) 5 >>> second_largest_unique([3, 1, 4, 4, 5, 2, 2]) 4 >>> second_largest_unique([7, 7, 7]) -1 pass def test_second_largest_unique_with_typical_case(): assert second_largest_unique([4, 2, 5, 7, 7, 5, 1, 3]) == 5 def test_second_largest_unique_with_repeated_elements(): assert second_largest_unique([3, 1, 4, 4, 5, 2, 2]) == 4 def test_second_largest_unique_with_all_identical_elements(): assert second_largest_unique([7, 7, 7]) == -1 def test_second_largest_unique_with_no_second_unique_number(): assert second_largest_unique([1]) == -1 def test_second_largest_unique_with_enough_unique_numbers(): assert second_largest_unique([7, 5, 6, 9, 8]) == 8 def test_second_largest_unique_with_empty_list(): assert second_largest_unique([]) == -1 def test_second_largest_unique_with_large_numbers(): assert second_largest_unique([100, 200, 300, 100, 200]) == 200","solution":"from typing import List def second_largest_unique(nums: List[int]) -> int: Returns the second largest unique number in the list. If there is no such number, returns -1. unique_nums = list(set(nums)) # Remove duplicates if len(unique_nums) < 2: return -1 # Not enough unique numbers available unique_nums.sort(reverse=True) # Sort in descending order return unique_nums[1] # The second element in the sorted list is the second largest"},{"question":"def max_subarray_sum(arr: list) -> int: Returns the sum of the maximum subarray in the given array. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([0, -3, 1, 1, -1, 5, -2]) 6 from solution import max_subarray_sum def test_example_1(): arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4] assert max_subarray_sum(arr) == 6 def test_example_2(): arr = [1] assert max_subarray_sum(arr) == 1 def test_example_3(): arr = [0, -3, 1, 1, -1, 5, -2] assert max_subarray_sum(arr) == 6 def test_all_positive_numbers(): arr = [1, 2, 3, 4] assert max_subarray_sum(arr) == 10 def test_all_negative_numbers(): arr = [-1, -2, -3, -4] assert max_subarray_sum(arr) == -1 def test_mix_positive_negative(): arr = [-2, -3, 4, -1, -2, 1, 5, -3] assert max_subarray_sum(arr) == 7 def test_single_element_negative(): arr = [-5] assert max_subarray_sum(arr) == -5 def test_large_array(): arr = [1] * (10**5) assert max_subarray_sum(arr) == 10**5","solution":"def max_subarray_sum(arr: list) -> int: Returns the sum of the maximum subarray in the given array. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def game_of_life(grid: List[List[int]], generations: int) -> List[List[int]]: Simulates a simplified version of the game of life. Args: grid (List[List[int]]): A 2D grid of cells, where 0 represents a dead cell and 1 represents a live cell. generations (int): The number of generations to simulate. Returns: List[List[int]]: The grid's configuration after the given number of generations. Example Usage: >>> initial_grid = [ ... [0, 1, 0], ... [0, 0, 1], ... [1, 1, 1], ... [0, 0, 0] ... ] >>> generations = 1 >>> result_grid = game_of_life(initial_grid, generations) >>> print(result_grid) [[0, 0, 0], [1, 0, 1], [0, 1, 1], [0, 1, 0]] pass from solution import game_of_life def test_game_of_life_single_generation(): initial_grid = [ [0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0] ] expected_result = [ [0, 0, 0], [1, 0, 1], [0, 1, 1], [0, 1, 0] ] assert game_of_life(initial_grid, 1) == expected_result def test_game_of_life_multiple_generations(): initial_grid = [ [1, 1], [1, 1] ] expected_result = [ [1, 1], [1, 1] ] assert game_of_life(initial_grid, 4) == expected_result def test_game_of_life_empty_grid(): initial_grid = [ [0, 0], [0, 0] ] expected_result = [ [0, 0], [0, 0] ] assert game_of_life(initial_grid, 1) == expected_result def test_game_of_life_underpopulation(): initial_grid = [ [1, 0, 0], [0, 0, 0], [0, 0, 0] ] expected_result = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert game_of_life(initial_grid, 1) == expected_result def test_game_of_life_overpopulation(): initial_grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] expected_result = [ [1, 0, 1], [0, 0, 0], [1, 0, 1] ] assert game_of_life(initial_grid, 1) == expected_result","solution":"def game_of_life(grid, generations): rows = len(grid) cols = len(grid[0]) def get_live_neighbors(r, c): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] live_neighbors = 0 for dr, dc in directions: if 0 <= r + dr < rows and 0 <= c + dc < cols: live_neighbors += grid[r + dr][c + dc] return live_neighbors def next_generation(): new_grid = [[0] * cols for _ in range(rows)] for r in range(rows): for c in range(cols): live_neighbors = get_live_neighbors(r, c) if grid[r][c] == 1: if live_neighbors < 2 or live_neighbors > 3: new_grid[r][c] = 0 else: new_grid[r][c] = 1 else: if live_neighbors == 3: new_grid[r][c] = 1 return new_grid for _ in range(generations): grid = next_generation() return grid"},{"question":"def checkout(cart): Simulates the checkout process for an online shopping cart. Arguments: cart: List of dictionaries where each dictionary represents an item with keys \\"name\\", \\"price\\", and \\"quantity\\". Returns: A dictionary with \\"subtotal\\", \\"sales_tax\\", and \\"total\\" keys. Examples: >>> checkout([{\\"name\\": \\"item1\\", \\"price\\": 10.00, \\"quantity\\": 1}]) {'subtotal': 10.00, 'sales_tax': 1.00, 'total': 11.00} >>> checkout([{\\"name\\": \\"item1\\", \\"price\\": 10.00, \\"quantity\\": 1}, {\\"name\\": \\"item2\\", \\"price\\": 20.00, \\"quantity\\": 2}]) {'subtotal': 50.00, 'sales_tax': 5.00, 'total': 55.00} >>> checkout([]) {'subtotal': 0.00, 'sales_tax': 0.00, 'total': 0.00} >>> checkout([{\\"name\\": \\"item1\\", \\"price\\": 10.00, \\"quantity\\": 0}]) {'subtotal': 0.00, 'sales_tax': 0.00, 'total': 0.00} >>> checkout([{\\"name\\": \\"item1\\", \\"price\\": 10.00, \\"quantity\\": -1}]) {'subtotal': 0.00, 'sales_tax': 0.00, 'total': 0.00} >>> checkout([ {\\"name\\": \\"item1\\", \\"price\\": 10.00, \\"quantity\\": 1}, {\\"name\\": \\"item2\\", \\"price\\": 5.00, \\"quantity\\": -2}, {\\"name\\": \\"item3\\", \\"price\\": 8.00, \\"quantity\\": 0}, {\\"name\\": \\"item4\\", \\"price\\": 3.00, \\"quantity\\": 3} ]) {'subtotal': 19.00, 'sales_tax': 1.90, 'total': 20.90}","solution":"def checkout(cart): Simulates the checkout process for an online shopping cart. Arguments: cart: List of dictionaries where each dictionary represents an item with keys \\"name\\", \\"price\\", and \\"quantity\\". Returns: A dictionary with \\"subtotal\\", \\"sales_tax\\", and \\"total\\" keys. subtotal = 0.0 for item in cart: if item['quantity'] > 0: subtotal += item['price'] * item['quantity'] subtotal = round(subtotal, 2) sales_tax = round(subtotal * 0.10, 2) total = round(subtotal + sales_tax, 2) return { \\"subtotal\\": subtotal, \\"sales_tax\\": sales_tax, \\"total\\": total }"},{"question":"def students_passing_all_subjects(students_grades: dict) -> list: Returns a list of students who have passing grades (>= 50) in all subjects. You must implement this function. Parameters: students_grades (dict): Dictionary where keys are student names and values are dictionaries of subjects and grades Returns: list: Sorted list of names of students who have passing grades in all their subjects. Example: >>> students_grades_example = { ... 'Alice': {'Math': 80, 'English': 90, 'Physics': 70}, ... 'Bob': {'Math': 60, 'English': 45, 'Physics': 55}, ... 'Charlie': {'Math': 50, 'English': 50, 'Physics': 50}, ... 'David': {'Math': 40, 'English': 60, 'Physics': 70} ... } >>> students_passing_all_subjects(students_grades_example) ['Alice', 'Charlie'] pass # Example usage students_grades_example = { 'Alice': {'Math': 80, 'English': 90, 'Physics': 70}, 'Bob': {'Math': 60, 'English': 45, 'Physics': 55}, 'Charlie': {'Math': 50, 'English': 50, 'Physics': 50}, 'David': {'Math': 40, 'English': 60, 'Physics': 70} } print(students_passing_all_subjects(students_grades_example))","solution":"def students_passing_all_subjects(students_grades): Returns a list of students who have passing grades (>= 50) in all subjects. Parameters: students_grades (dict): Dictionary where keys are student names and values are dictionaries of subjects and grades. Returns: list: Sorted list of names of students who have passing grades in all their subjects. passing_students = [] for student, grades in students_grades.items(): if all(grade >= 50 for grade in grades.values()): passing_students.append(student) return sorted(passing_students) # Example usage students_grades_example = { 'Alice': {'Math': 80, 'English': 90, 'Physics': 70}, 'Bob': {'Math': 60, 'English': 45, 'Physics': 55}, 'Charlie': {'Math': 50, 'English': 50, 'Physics': 50}, 'David': {'Math': 40, 'English': 60, 'Physics': 70} } print(students_passing_all_subjects(students_grades_example))"},{"question":"from typing import List def rearrange_to_smallest(numbers: List[int]) -> List[int]: Given a list of integers, returns a new list with each integer's digits rearranged to form the smallest possible number for each integer. Examples: >>> rearrange_to_smallest([532, 214, 740]) [235, 124, 47] >>> rearrange_to_smallest([987, 321, 46]) [789, 123, 46] pass # Test cases def test_rearrange_normal_cases(): assert rearrange_to_smallest([532, 214, 740]) == [235, 124, 47] assert rearrange_to_smallest([987, 321, 46]) == [789, 123, 46] def test_rearrange_single_digit_numbers(): assert rearrange_to_smallest([5, 2, 4]) == [5, 2, 4] def test_rearrange_repeating_digits(): assert rearrange_to_smallest([112, 220, 4433]) == [112, 22, 3344] def test_rearrange_with_zeros(): assert rearrange_to_smallest([503, 201, 400]) == [35, 12, 4] def test_rearrange_large_numbers(): assert rearrange_to_smallest([9876543210, 1234567890]) == [123456789, 123456789] def test_rearrange_empty_list(): assert rearrange_to_smallest([]) == []","solution":"from typing import List def rearrange_to_smallest(numbers: List[int]) -> List[int]: Given a list of integers, returns a new list with each integer's digits rearranged to form the smallest possible number for each integer. smallest_numbers = [] for number in numbers: # Convert the number to a list of digits, sort them, and join back to form the smallest number smallest_number = int(''.join(sorted(str(number)))) smallest_numbers.append(smallest_number) return smallest_numbers"},{"question":"def is_prime(num: int) -> bool: Returns True if num is a prime number, else False. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(1) False >>> is_prime(0) False >>> is_prime(-3) False >>> is_prime(19) True >>> is_prime(20) False if num < 2: return False for i in range(2, int(num ** 0.5) + 1): if num % i == 0: return False return True def extract_primes(nums: List[int]) -> List[int]: Returns a list containing only the prime numbers from the original list 'nums'. >>> extract_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> extract_primes([1, 4, 6, 8, 10]) [] >>> extract_primes([11, 13, 17, 19, 23]) [11, 13, 17, 19, 23] >>> extract_primes([0, -2, 5, 8, 11, 16, 17]) [5, 11, 17] >>> extract_primes([]) [] return [num for num in nums if is_prime(num)]","solution":"def is_prime(num): Returns True if num is a prime number, else False. if num < 2: return False for i in range(2, int(num ** 0.5) + 1): if num % i == 0: return False return True def extract_primes(nums): Returns a list containing only the prime numbers from the original list 'nums'. return [num for num in nums if is_prime(num)]"},{"question":"def merge_and_sort_arrays(list1: List[int], list2: List[int]) -> List[int]: Merges two lists into a single list, removes duplicates, and sorts in descending order. Args: list1: List of integers. list2: List of integers. Returns: A new sorted list in descending order with unique integers. >>> merge_and_sort_arrays([4, 2, 9, 5, 2], [7, 3, 8, 9, 1]) == [9, 8, 7, 5, 4, 3, 2, 1] >>> merge_and_sort_arrays([4, 2, 6], [3, 8, 1]) == [8, 6, 4, 3, 2, 1] >>> merge_and_sort_arrays([1, 1, 1], [1, 1, 1]) == [1] >>> merge_and_sort_arrays([], []) == [] >>> merge_and_sort_arrays([1, 2, 3], []) == [3, 2, 1] >>> merge_and_sort_arrays([], [1, 2, 3]) == [3, 2, 1] >>> merge_and_sort_arrays([10, 5, 3, 7], [2, 4, 6, 8, 10]) == [10, 8, 7, 6, 5, 4, 3, 2] >>> merge_and_sort_arrays([10], [10]) == [10] >>> merge_and_sort_arrays([5], [10]) == [10, 5]","solution":"def merge_and_sort_arrays(list1, list2): Merges two lists into a single list, removes duplicates, and sorts in descending order. Args: list1: List of integers. list2: List of integers. Returns: A new sorted list in descending order with unique integers. # Merge the two lists merged_list = list1 + list2 # Remove duplicates by converting to a set unique_elements = set(merged_list) # Convert back to a list and sort in descending order sorted_list = sorted(unique_elements, reverse=True) return sorted_list"},{"question":"from typing import List def is_fibonacci_number(n: int) -> bool: Check if a number is a Fibonacci number by checking if one of (5*n*n + 4) or (5*n*n - 4) is a perfect square. >>> is_fibonacci_number(0) == True >>> is_fibonacci_number(1) == True >>> is_fibonacci_number(4) == False >>> is_fibonacci_number(5) == True >>> is_fibonacci_number(13) == True >>> is_fibonacci_number(20) == False >>> is_fibonacci_number(21) == True pass def filter_fibonacci_numbers(lst: List[int]) -> List[int]: Returns a list of elements from the original list that are Fibonacci numbers. >>> filter_fibonacci_numbers([0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 13, 21, 34, 50]) == [0, 1, 2, 3, 5, 8, 13, 21, 34] >>> filter_fibonacci_numbers([0, 1, 1, 2, 3, 5, 8, -1, -5, 23]) == [0, 1, 1, 2, 3, 5, 8] >>> filter_fibonacci_numbers([6, 7, 9, 11, 14]) == [] >>> filter_fibonacci_numbers([]) == [] >>> filter_fibonacci_numbers([-5, -8]) == [] >>> filter_fibonacci_numbers([-1, 1, 2]) == [1, 2] pass","solution":"def is_fibonacci_number(n): Check if a number is a Fibonacci number by checking if one of (5*n*n + 4) or (5*n*n - 4) is a perfect square. if n < 0: return False def is_perfect_square(x): s = int(x ** 0.5) return s * s == x return is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4) def filter_fibonacci_numbers(lst): Returns a list of elements from the original list that are Fibonacci numbers. return [x for x in lst if is_fibonacci_number(x)]"},{"question":"def categorize_words_by_length(words): Takes a list of words and returns a dictionary where the keys are the lengths of the words, and the values are lists containing the words of that length. :param words: List of words :type words: List[str] :return: Dictionary categorizing words by length :rtype: dict pass # Unit tests def test_categorize_words_by_length_example_case(): words = [\\"apple\\", \\"banana\\", \\"pear\\", \\"kiwi\\", \\"grape\\"] expected_output = {5: ['apple', 'grape'], 6: ['banana'], 4: ['pear', 'kiwi']} assert categorize_words_by_length(words) == expected_output def test_categorize_words_by_length_empty_list(): words = [] expected_output = {} assert categorize_words_by_length(words) == expected_output def test_categorize_words_by_length_same_length_words(): words = [\\"cat\\", \\"dog\\", \\"ant\\"] expected_output = {3: ['cat', 'dog', 'ant']} assert categorize_words_by_length(words) == expected_output def test_categorize_words_by_length_mixed_length_words(): words = [\\"a\\", \\"hello\\", \\"world\\", \\"me\\", \\"I\\", \\"am\\", \\"happy\\"] expected_output = {1: ['a', 'I'], 5: ['hello', 'world', 'happy'], 2: ['me', 'am']} assert categorize_words_by_length(words) == expected_output def test_categorize_words_by_length_repeated_words(): words = [\\"test\\", \\"test\\", \\"test\\"] expected_output = {4: ['test', 'test', 'test']} assert categorize_words_by_length(words) == expected_output","solution":"def categorize_words_by_length(words): Takes a list of words and returns a dictionary where the keys are the lengths of the words, and the values are lists containing the words of that length. :param words: List of words :type words: List[str] :return: Dictionary categorizing words by length :rtype: dict length_dict = {} for word in words: length = int(len(word)) if length not in length_dict: length_dict[length] = [] length_dict[length].append(word) return length_dict"},{"question":"def find_closest_points(points, K): Returns the K closest points to the origin (0, 0) based on Euclidean distance. Parameters: points (list of tuples): List of integer coordinates representing points on a two-dimensional plane. K (int): Number of closest points to find. Returns: list of tuples: K closest points to the origin (0, 0). pass # Unit Tests def test_find_closest_points_basic(): points = [(1, 2), (3, 4), (1, -1)] K = 2 result = find_closest_points(points, K) expected = [(1, -1), (1, 2)] assert set(result) == set(expected) def test_find_closest_points_K_equals_points_length(): points = [(1, 2), (2, 2), (3, 4)] K = 3 result = find_closest_points(points, K) expected = [(1, 2), (2, 2), (3, 4)] assert set(result) == set(expected) def test_find_closest_points_K_larger_than_points_length(): points = [(2, 3), (3, 4)] K = 5 result = find_closest_points(points, K) expected = [(2, 3), (3, 4)] assert set(result) == set(expected) def test_find_closest_points_with_negative_coordinates(): points = [(-1, -2), (1, -2), (2, 2), (-2, -1)] K = 2 result = find_closest_points(points, K) expected = [(-1, -2), (-2, -1)] assert set(result) == set(expected) def test_find_closest_points_no_points(): points = [] K = 3 result = find_closest_points(points, K) expected = [] assert result == expected def test_find_closest_points_all_at_origin(): points = [(0, 0), (0, 0), (0, 0)] K = 2 result = find_closest_points(points, K) expected = [(0, 0), (0, 0)] assert result == expected","solution":"import heapq def find_closest_points(points, K): Returns the K closest points to the origin (0, 0) based on Euclidean distance. Parameters: points (list of tuples): List of integer coordinates representing points on a two-dimensional plane. K (int): Number of closest points to find. Returns: list of tuples: K closest points to the origin (0, 0). if K >= len(points): return points # Calculate all distances and keep them in a heap heap = [] for (x, y) in points: distance = x**2 + y**2 # We use distance squared to avoid unnecessary sqrt calculations heapq.heappush(heap, (distance, (x, y))) closest_points = [] for _ in range(K): closest_points.append(heapq.heappop(heap)[1]) return closest_points"},{"question":"import matplotlib.pyplot as plt import numpy as np from sklearn import datasets from sklearn.model_selection import StratifiedKFold, GridSearchCV from sklearn.tree import DecisionTreeClassifier, plot_tree from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score from sklearn.svm import SVC from sklearn.linear_model import LogisticRegression from sklearn.preprocessing import StandardScaler def decision_tree_iris(): Train a Decision Tree classifier on the Iris dataset with stratified k-fold cross-validation and hyperparameter tuning for the depth of the tree. Evaluate the classifier's performance. Visualize the decision tree and return the trained classifier. iris = datasets.load_iris() X = iris.data y = iris.target # Define hyperparameter grid and stratified k-fold cross-validator param_grid = {'max_depth': np.arange(1, 11)} strat_k_fold = StratifiedKFold(n_splits=5, shuffle=True, random_state=42) # Conduct grid search with cross-validation to find best Decision Tree depth dt_clf = GridSearchCV(DecisionTreeClassifier(criterion='gini'), param_grid, cv=strat_k_fold) dt_clf.fit(X, y) # Extract the best Decision Tree classifier best_dt_clf = dt_clf.best_estimator_ # Evaluate the performance of the best classifier y_pred = best_dt_clf.predict(X) accuracy = accuracy_score(y, y_pred) precision = precision_score(y, y_pred, average='macro') recall = recall_score(y, y_pred, average='macro') f1 = f1_score(y, y_pred, average='macro') # Visualize the Decision Tree plot_tree(best_dt_clf, filled=True, feature_names=iris.feature_names, class_names=iris.target_names) plt.title(f\\"Decision Tree with depth={dt_clf.best_params_['max_depth']}\\") plt.show() # Print performance evaluation metrics print(f\\"Decision Tree Classifier - Depth: {dt_clf.best_params_['max_depth']}\\") print(f\\"Accuracy: {accuracy:.4f}\\") print(f\\"Precision: {precision:.4f}\\") print(f\\"Recall: {recall:.4f}\\") print(f\\"F1 Score: {f1:.4f}\\") return best_dt_clf def compare_classifiers(): Compare the performance of Decision Tree, SVM, and Logistic Regression classifiers on the Iris dataset using stratified k-fold cross-validation. Return a dictionary with the average accuracy of each classifier. iris = datasets.load_iris() X = iris.data y = iris.target scaler = StandardScaler() X = scaler.fit_transform(X) classifiers = { 'Decision Tree': DecisionTreeClassifier(max_depth=3), 'SVM': SVC(kernel='rbf', C=1), 'Logistic Regression': LogisticRegression(max_iter=200) } results = {} for cls_name, cls in classifiers.items(): strat_k_fold = StratifiedKFold(n_splits=5, shuffle=True, random_state=42) accuracies = [] for train_index, test_index in strat_k_fold.split(X, y): X_train, X_test = X[train_index], X[test_index] y_train, y_test = y[train_index], y[test_index] cls.fit(X_train, y_train) acc = cls.score(X_test, y_test) accuracies.append(acc) avg_accuracy = np.mean(accuracies) results[cls_name] = avg_accuracy print(f\\"{cls_name} Classifier - Average Accuracy: {avg_accuracy:.4f}\\") return results","solution":"import matplotlib.pyplot as plt import numpy as np from sklearn import datasets from sklearn.model_selection import StratifiedKFold, GridSearchCV from sklearn.tree import DecisionTreeClassifier, plot_tree from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score from sklearn.svm import SVC from sklearn.linear_model import LogisticRegression from sklearn.preprocessing import StandardScaler def decision_tree_iris(): iris = datasets.load_iris() X = iris.data y = iris.target param_grid = {'max_depth': np.arange(1, 11)} strat_k_fold = StratifiedKFold(n_splits=5, shuffle=True, random_state=42) dt_clf = GridSearchCV(DecisionTreeClassifier(criterion='gini'), param_grid, cv=strat_k_fold) dt_clf.fit(X, y) best_depth = dt_clf.best_params_['max_depth'] best_dt_clf = dt_clf.best_estimator_ y_pred = best_dt_clf.predict(X) accuracy = accuracy_score(y, y_pred) precision = precision_score(y, y_pred, average='macro') recall = recall_score(y, y_pred, average='macro') f1 = f1_score(y, y_pred, average='macro') plot_tree(best_dt_clf, filled=True, feature_names=iris.feature_names, class_names=iris.target_names) plt.title(f\\"Decision Tree with depth={best_depth}\\") plt.show() print(f\\"Decision Tree Classifier - Depth: {best_depth}\\") print(f\\"Accuracy: {accuracy:.4f}\\") print(f\\"Precision: {precision:.4f}\\") print(f\\"Recall: {recall:.4f}\\") print(f\\"F1 Score: {f1:.4f}\\") return best_dt_clf def compare_classifiers(): iris = datasets.load_iris() X = iris.data y = iris.target scaler = StandardScaler() X = scaler.fit_transform(X) classifiers = { 'Decision Tree': DecisionTreeClassifier(max_depth=3), 'SVM': SVC(kernel='rbf', C=1), 'Logistic Regression': LogisticRegression(max_iter=200) } results = {} for cls_name, cls in classifiers.items(): strat_k_fold = StratifiedKFold(n_splits=5, shuffle=True, random_state=42) accuracies = [] for train_index, test_index in strat_k_fold.split(X, y): X_train, X_test = X[train_index], X[test_index] y_train, y_test = y[train_index], y[test_index] cls.fit(X_train, y_train) acc = cls.score(X_test, y_test) accuracies.append(acc) avg_accuracy = np.mean(accuracies) results[cls_name] = avg_accuracy print(f\\"{cls_name} Classifier - Average Accuracy: {avg_accuracy:.4f}\\") return results"},{"question":"def calculator(a, b, operation): Simulates a basic calculator. Parameters: a (float): First numerical input. b (float): Second numerical input. operation (str): A string representing the operation ('add', 'subtract', 'multiply', 'divide'). Returns: float or str: The result of the operation or an error message if the operation is invalid. pass # Unit tests def test_addition(): assert calculator(10, 5, 'add') == 15 assert calculator(-1, 1, 'add') == 0 assert calculator(0, 0, 'add') == 0 def test_subtraction(): assert calculator(10, 5, 'subtract') == 5 assert calculator(-1, 1, 'subtract') == -2 assert calculator(0, 0, 'subtract') == 0 def test_multiplication(): assert calculator(10, 5, 'multiply') == 50 assert calculator(-1, 1, 'multiply') == -1 assert calculator(0, 0, 'multiply') == 0 def test_division(): assert calculator(10, 5, 'divide') == 2.0 assert calculator(-1, 1, 'divide') == -1.0 assert calculator(1, 0, 'divide') == 'Error: Division by zero' def test_invalid_operation(): assert calculator(10, 5, 'unknown') == 'Error: Invalid operation' assert calculator(10, 5, '') == 'Error: Invalid operation' assert calculator(10, 5, ' ') == 'Error: Invalid operation' def test_edge_cases(): assert calculator(1.5, 2.5, 'add') == 4.0 assert calculator(-1.5, -2.5, 'subtract') == 1.0 assert calculator(1.5, -2.5, 'multiply') == -3.75 assert calculator(4.5, 1.5, 'divide') == 3.0","solution":"def calculator(a, b, operation): Simulates a basic calculator. Parameters: a (float): First numerical input. b (float): Second numerical input. operation (str): A string representing the operation ('add', 'subtract', 'multiply', 'divide'). Returns: float or str: The result of the operation or an error message if the operation is invalid. if operation == 'add': return a + b elif operation == 'subtract': return a - b elif operation == 'multiply': return a * b elif operation == 'divide': if b != 0: return a / b else: return 'Error: Division by zero' else: return 'Error: Invalid operation'"},{"question":"def shortest_path_in_maze(maze: List[List[int]]) -> int: Design and implement an optimized pathfinding algorithm to navigate through a maze represented as a grid. Each cell can either be passable (1) or impassable (0). The objective is to find the shortest route from the top-left corner to the bottom-right corner of the grid, if such a path exists. Your solution should efficiently handle large grids and ensure the algorithm's performance is robust enough to manage various maze configurations. Consider edge cases such as entirely blocked paths and multiple possible routes. :param maze: A 2D list representing the maze where 1 is passable and 0 is impassable. :return: Length of the shortest path, or -1 if no path exists >>> shortest_path_in_maze([]) == -1 >>> shortest_path_in_maze([[]]) == -1 >>> shortest_path_in_maze([[0, 1], [1, 1]]) == -1 >>> shortest_path_in_maze([[1, 1], [1, 0]]) == -1 >>> shortest_path_in_maze([[1]]) == 1 >>> shortest_path_in_maze([[0]]) == -1 >>> shortest_path_in_maze([[1, 1], [0, 1]]) == 3 >>> shortest_path_in_maze([[1, 1], [1, 1]]) == 3 >>> shortest_path_in_maze([ [1, 0, 0, 1], [1, 1, 0, 1], [0, 1, 1, 1], [0, 0, 0, 1] ]) == 7 >>> shortest_path_in_maze([ [1, 0, 1], [0, 0, 1], [1, 1, 1] ]) == -1 >>> shortest_path_in_maze([[1] * 50 for _ in range(50)]) == 99","solution":"from collections import deque def shortest_path_in_maze(maze): Returns the shortest path length in a maze from the top-left corner to the bottom-right corner. If there is no path, returns -1. :param maze: A 2D list representing the maze where 1 is passable and 0 is impassable. :return: Length of the shortest path, or -1 if no path exists if not maze or not maze[0]: return -1 n, m = len(maze), len(maze[0]) if maze[0][0] == 0 or maze[n-1][m-1] == 0: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (x, y, path_length) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if (x, y) == (n-1, m-1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and maze[nx][ny] == 1 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"from typing import List, Tuple, Union def find_pair(nums: List[int], target: int) -> Union[Tuple[int, int], int]: Write a function that takes a list of integers and a target number. The function should find two distinct integers in the list that add up to the target number. Return the indices of these two numbers in the form of a tuple. If no such pair exists, return -1. >>> find_pair([2, 7, 11, 15], 9) (0, 1) >>> find_pair([1, 2, 3, 4, 5], 10) -1 >>> find_pair([3, 2, 4], 6) (1, 2) pass def test_pair_exists_in_the_beginning(): assert find_pair([2, 7, 11, 15], 9) == (0, 1) def test_pair_exists_in_the_middle(): assert find_pair([3, 2, 4], 6) == (1, 2) def test_pair_exists_at_the_end(): assert find_pair([1, 2, 3, 4, 4], 8) == (3, 4) def test_no_pair_exists_due_to_large_target(): assert find_pair([1, 2, 3, 4, 5], 10) == -1 def test_single_pair_exists(): assert find_pair([1, 1, 1, 1, 2, 3, 4], 6) == (4, 6) def test_multiple_pairs_exists(): assert find_pair([1, 3, 2, 4], 5) in [(0, 3), (1, 2)] def test_list_with_duplicates(): assert find_pair([3, 3, 4, 4], 8) in [(2, 3)] def test_edge_case_two_elements(): assert find_pair([1, 2], 3) == (0, 1) def test_large_numbers(): assert find_pair([500000, 1000000, 1500000], 2000000) == (0, 2)","solution":"def find_pair(nums, target): Finds two distinct integers in the list that add up to the target number. Returns their indices as a tuple. If no such pair exists, returns -1. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index return -1"},{"question":"def custom_format(s: str, d: dict) -> str: Replace placeholders in the string \`s\` using the mappings provided in dictionary \`d\`. Handles the placeholders of the format \`{key}\` in the string \`s\`. If the key is not found in the dictionary, it should leave the placeholder as it is. >>> custom_format(\\"Hello, my name is {name} and I am {age} years old.\\", {\\"name\\": \\"Alice\\", \\"age\\": \\"30\\"}) 'Hello, my name is Alice and I am 30 years old.' >>> custom_format(\\"Welcome to {country}, the land of {something}.\\", {\\"country\\": \\"Wonderland\\"}) 'Welcome to Wonderland, the land of {something}.' >>> custom_format(\\"This is a {adjective} day.\\", {\\"adjective\\": \\"beautiful\\"}) 'This is a beautiful day.' # Unit Tests from solution import custom_format def test_custom_format_basic_replacements(): assert custom_format(\\"Hello, my name is {name} and I am {age} years old.\\", {\\"name\\": \\"Alice\\", \\"age\\": \\"30\\"}) == 'Hello, my name is Alice and I am 30 years old.' def test_custom_format_partial_replacements(): assert custom_format(\\"Welcome to {country}, the land of {something}.\\", {\\"country\\": \\"Wonderland\\"}) == 'Welcome to Wonderland, the land of {something}.' def test_custom_format_no_replacements(): assert custom_format(\\"This is a {adjective} day.\\", {}) == 'This is a {adjective} day.' def test_custom_format_all_placeholders_replaced(): assert custom_format(\\"This is a {adjective} day.\\", {\\"adjective\\": \\"beautiful\\"}) == 'This is a beautiful day.' def test_custom_format_multiple_same_placeholder(): assert custom_format(\\"{greeting}, {greeting}!\\", {\\"greeting\\": \\"Hello\\"}) == 'Hello, Hello!' def test_custom_format_empty_string(): assert custom_format(\\"\\", {\\"key\\": \\"value\\"}) == '' def test_custom_format_no_placeholders(): assert custom_format(\\"Just a normal sentence.\\", {\\"key\\": \\"value\\"}) == 'Just a normal sentence.' def test_custom_format_unused_keys_in_dict(): assert custom_format(\\"This is a {adjective} day.\\", {\\"adjective\\": \\"beautiful\\", \\"unused\\": \\"value\\"}) == 'This is a beautiful day.'","solution":"import re def custom_format(s: str, d: dict) -> str: Replace placeholders in the string \`s\` using the mappings provided in dictionary \`d\`. Handles the placeholders of the format \`{key}\` in the string \`s\`. If the key is not found in the dictionary, it should leave the placeholder as it is. def replace(match): key = match.group(1) return d.get(key, match.group(0)) pattern = re.compile(r'{(w+)}') return pattern.sub(replace, s)"},{"question":"import os class FileSystem: def __init__(self): Initialize a new file system simulation. self.current_directory = \\"/\\" def create_file(self, path, content): Creates a new file at the specified path and writes the given content to it. If the file already exists, it overwrites the existing content. :param path: The path where the file will be created. :param content: The content to write to the file. pass # implementation here def read_file(self, path): Reads and returns the content of the file at the specified path. Raises an error if the file does not exist. :param path: The path of the file to read. :return: The content of the file. :raises FileNotFoundError: If the file does not exist. pass # implementation here def create_directory(self, path): Creates a new directory at the specified path. Raises an error if the directory already exists. :param path: The path where the directory will be created. :raises FileExistsError: If the directory already exists. pass # implementation here def delete(self, path): Deletes a file or directory at the specified path. If it is a directory, ensure it is empty before deleting. :param path: The path of the file or directory to delete. :raises OSError: If the directory is not empty. :raises FileNotFoundError: If the path does not exist. pass # implementation here def change_directory(self, path): Changes the current working directory to the specified path. Raises an error if the path does not exist or is not a directory. :param path: The path to change the current directory to. :raises NotADirectoryError: If the path is not a directory. pass # implementation here def list_directory(self): Lists all files and directories in the current working directory. :return: A list of files and directories in the current directory. pass # implementation here # Unit tests import pytest import os import shutil @pytest.fixture def setup_filesystem(tmp_path): fs = FileSystem() fs.current_directory = tmp_path yield fs shutil.rmtree(tmp_path) def test_create_and_read_file(setup_filesystem): fs = setup_filesystem fs.create_file(\\"testfile.txt\\", \\"This is a test file.\\") assert fs.read_file(\\"testfile.txt\\") == \\"This is a test file.\\" def test_create_existing_file(setup_filesystem): fs = setup_filesystem fs.create_file(\\"testfile.txt\\", \\"Initial content.\\") fs.create_file(\\"testfile.txt\\", \\"Overwritten content.\\") assert fs.read_file(\\"testfile.txt\\") == \\"Overwritten content.\\" def test_create_directory(setup_filesystem): fs = setup_filesystem fs.create_directory(\\"testdir\\") assert \\"testdir\\" in fs.list_directory() def test_delete_file_and_directory(setup_filesystem): fs = setup_filesystem fs.create_file(\\"file_to_delete.txt\\", \\"Delete me\\") fs.create_directory(\\"dir_to_delete\\") fs.delete(\\"file_to_delete.txt\\") fs.delete(\\"dir_to_delete\\") assert \\"file_to_delete.txt\\" not in fs.list_directory() assert \\"dir_to_delete\\" not in fs.list_directory() def test_change_directory(setup_filesystem): fs = setup_filesystem fs.create_directory(\\"newdir\\") fs.change_directory(\\"newdir\\") assert fs.current_directory.endswith(\\"newdir\\") def test_list_directory(setup_filesystem): fs = setup_filesystem fs.create_file(\\"file1.txt\\", \\"First file\\") fs.create_directory(\\"dir1\\") directory_listing = fs.list_directory() assert \\"file1.txt\\" in directory_listing assert \\"dir1\\" in directory_listing","solution":"import os class FileSystem: def __init__(self): self.current_directory = \\"/\\" def create_file(self, path, content): Creates a new file at the specified path and writes the given content to it. If the file already exists, it overwrites the existing content. full_path = os.path.join(self.current_directory, path) os.makedirs(os.path.dirname(full_path), exist_ok=True) with open(full_path, 'w') as file: file.write(content) def read_file(self, path): Reads and returns the content of the file at the specified path. Raises an error if the file does not exist. full_path = os.path.join(self.current_directory, path) if not os.path.isfile(full_path): raise FileNotFoundError(f\\"File at path '{path}' does not exist.\\") with open(full_path, 'r') as file: return file.read() def create_directory(self, path): Creates a new directory at the specified path. Raises an error if the directory already exists. full_path = os.path.join(self.current_directory, path) if os.path.exists(full_path): raise FileExistsError(f\\"Directory at path '{path}' already exists.\\") os.makedirs(full_path) def delete(self, path): Deletes a file or directory at the specified path. If it is a directory, ensure it is empty before deleting. full_path = os.path.join(self.current_directory, path) if os.path.isdir(full_path): if os.listdir(full_path): raise OSError(f\\"Directory at path '{path}' is not empty.\\") os.rmdir(full_path) elif os.path.isfile(full_path): os.remove(full_path) else: raise FileNotFoundError(f\\"Path '{path}' does not exist.\\") def change_directory(self, path): Changes the current working directory to the specified path. Raises an error if the path does not exist or is not a directory. full_path = os.path.join(self.current_directory, path) if not os.path.isdir(full_path): raise NotADirectoryError(f\\"Path '{path}' is not a directory.\\") self.current_directory = full_path def list_directory(self): Lists all files and directories in the current working directory. return os.listdir(self.current_directory)"},{"question":"import os import logging logging.basicConfig(level=logging.ERROR) def count_lines_in_file(file_path: str, exclude_blank_lines: bool) -> int: Counts the number of lines in a given file. Parameters: file_path (str): The path to the file. exclude_blank_lines (bool): Whether to exclude blank lines from the count. Returns: int: The number of lines in the file, or 0 if the file cannot be read. >>> with open('test_file.txt', 'w') as f: >>> f.write(\\"Line 1nnLine 3n\\") >>> count_lines_in_file('test_file.txt', False) 3 >>> count_lines_in_file('test_file.txt', True) 2 >>> count_lines_in_file('non_existent_file.txt', False) 0 pass def total_lines(file_paths: list, exclude_blank_lines: bool = False) -> int: Counts the total number of lines across multiple files. Parameters: file_paths (list): A list of file paths. exclude_blank_lines (bool): Whether to exclude blank lines from the count. Returns: int: The total number of lines across all files. >>> with open('test_file_1.txt', 'w') as f: >>> f.write(\\"Line 1nnLine 3n\\") >>> with open('test_file_2.txt', 'w') as f: >>> f.write(\\"Line AnLine Bn\\") >>> total_lines(['test_file_1.txt', 'test_file_2.txt'], False) 5 >>> total_lines(['test_file_1.txt', 'test_file_2.txt'], True) 4 >>> total_lines(['test_file_1.txt', 'test_file_2.txt', 'non_existent_file.txt'], False) 5 >>> total_lines(['test_file_1.txt', 'test_file_2.txt', 'non_existent_file.txt'], True) 4 pass","solution":"import os import logging logging.basicConfig(level=logging.ERROR) def count_lines_in_file(file_path, exclude_blank_lines): Counts the number of lines in a given file. Parameters: file_path (str): The path to the file. exclude_blank_lines (bool): Whether to exclude blank lines from the count. Returns: int: The number of lines in the file, or 0 if the file cannot be read. try: with open(file_path, 'r') as file: lines = file.readlines() if exclude_blank_lines: lines = [line for line in lines if line.strip()] return len(lines) except Exception as e: logging.error(f\\"Error reading file {file_path}: {e}\\") return 0 def total_lines(file_paths, exclude_blank_lines=False): Counts the total number of lines across multiple files. Parameters: file_paths (list): A list of file paths. exclude_blank_lines (bool): Whether to exclude blank lines from the count. Returns: int: The total number of lines across all files. total = 0 for file_path in file_paths: total += count_lines_in_file(file_path, exclude_blank_lines) return total"},{"question":"import pandas as pd def calculate_average_ratings(file_path): Calculate the average rating for each movie given a CSV file. Parameters: file_path (str): The path to the CSV file containing movie ratings. The CSV file should have the following columns: 'MovieID', 'Title', 'Year', 'Rating'. The function will output a new CSV file 'average_ratings.csv' with the columns 'Title', 'Year', and 'AverageRating'. # Step 1: Read CSV file into a DataFrame data = pd.read_csv(file_path) # Step 2: Group by 'Title' and 'Year' and calculate the average rating average_ratings = data.groupby(['Title', 'Year'])['Rating'].mean() # Step 3: Reset the index of the resulting DataFrame average_ratings = average_ratings.reset_index() # Step 4: Rename the columns appropriately average_ratings.columns = ['Title', 'Year', 'AverageRating'] # Step 5: Save the result to a new CSV file average_ratings.to_csv('average_ratings.csv', index=False) # Example usage # calculate_average_ratings('movie_ratings.csv') import pandas as pd from io import StringIO import os def create_mock_csv(content): return StringIO(content) def test_calculate_average_ratings(): mock_csv_content = MovieID,Title,Year,Rating 1,Movie A,2020,4 2,Movie B,2021,5 3,Movie A,2020,5 4,Movie B,2021,4 5,Movie C,2022,3 6,Movie A,2020,3 7,Movie C,2022,4 mock_csv = create_mock_csv(mock_csv_content) # Call the function with the mocked CSV content calculate_average_ratings(mock_csv) # Load the output CSV file result_df = pd.read_csv('average_ratings.csv') # Expected result expected_content = Title,Year,AverageRating Movie A,2020,4.0 Movie B,2021,4.5 Movie C,2022,3.5 expected_df = pd.read_csv(create_mock_csv(expected_content)) # Assert the results pd.testing.assert_frame_equal(result_df, expected_df) # Clean up os.remove('average_ratings.csv')","solution":"import pandas as pd def calculate_average_ratings(file_path): # Step 1: Read CSV file into a DataFrame data = pd.read_csv(file_path) # Step 2: Group by 'Title' and 'Year' and calculate the average rating average_ratings = data.groupby(['Title', 'Year'])['Rating'].mean() # Step 3: Reset the index of the resulting DataFrame average_ratings = average_ratings.reset_index() # Step 4: Rename the columns appropriately average_ratings.columns = ['Title', 'Year', 'AverageRating'] # Step 5: Save the result to a new CSV file average_ratings.to_csv('average_ratings.csv', index=False) # Example usage # calculate_average_ratings('movie_ratings.csv')"},{"question":"from typing import List, Tuple import logging def process_scores(data: List[Tuple[str, str, float]]) -> List[Tuple[str, float]]: Process the scores by grouping them by the concatenated first and last name, and compute the average score for each name. Sort the names in ascending order based on their average score. Handle erroneous data entries by skipping them and logging errors, and raise a ValueError for empty input or invalid tuples. >>> process_scores([(\\"John\\", \\"Doe\\", 90.0), (\\"Jane\\", \\"Smith\\", 85.0), (\\"John\\", \\"Doe\\", 95.0), (\\"Jane\\", \\"Smith\\", 80.0)]) [(\\"Jane Smith\\", 82.5), (\\"John Doe\\", 92.5)] >>> process_scores([(\\"John\\", \\"Doe\\", \\"90.0\\"), (\\"Jane\\", \\"Smith\\", \\"85.0\\"), (\\"John\\", \\"Doe\\", \\"nine five\\"), (\\"Jane\\", \\"Smith\\", \\"80.0\\")]) [(\\"Jane Smith\\", 82.5), (\\"John Doe\\", 90.0)] import pytest def test_process_scores_normal_case(): data = [ (\\"John\\", \\"Doe\\", 90.0), (\\"Jane\\", \\"Smith\\", 85.0), (\\"John\\", \\"Doe\\", 95.0), (\\"Jane\\", \\"Smith\\", 80.0), ] assert process_scores(data) == [(\\"Jane Smith\\", 82.5), (\\"John Doe\\", 92.5)] def test_process_scores_with_invalid_score(): data = [ (\\"John\\", \\"Doe\\", \\"90.0\\"), (\\"Jane\\", \\"Smith\\", \\"85.0\\"), (\\"John\\", \\"Doe\\", \\"nine five\\"), (\\"Jane\\", \\"Smith\\", \\"80.0\\"), ] assert process_scores(data) == [(\\"Jane Smith\\", 82.5), (\\"John Doe\\", 90.0)] def test_process_scores_with_invalid_tuple(): data = [ (\\"John\\", \\"Doe\\"), (\\"Jane\\", \\"Smith\\", \\"85.0\\"), ] with pytest.raises(ValueError): process_scores(data) def test_process_scores_empty_list(): with pytest.raises(ValueError): process_scores([]) def test_process_scores_all_valid_data(): data = [ (\\"Alice\\", \\"Brown\\", 70.0), (\\"Bob\\", \\"Clark\\", 80.0), (\\"Alice\\", \\"Brown\\", 75.0), (\\"Bob\\", \\"Clark\\", 90.0), ] assert process_scores(data) == [(\\"Alice Brown\\", 72.5), (\\"Bob Clark\\", 85.0)] def test_process_scores_same_average_different_names(): data = [ (\\"Alice\\", \\"Brown\\", 75.0), (\\"Bob\\", \\"Clark\\", 85.0), (\\"Alice\\", \\"Brown\\", 85.0), (\\"Bob\\", \\"Clark\\", 75.0), ] assert process_scores(data) == [(\\"Alice Brown\\", 80.0), (\\"Bob Clark\\", 80.0)]","solution":"def process_scores(data): import logging logging.basicConfig(level=logging.ERROR) if not data: raise ValueError(\\"Input list is empty\\") scores = {} for entry in data: if len(entry) != 3: raise ValueError(f\\"Invalid tuple (does not contain exactly three elements): {entry}\\") first_name, last_name, score = entry full_name = f\\"{first_name} {last_name}\\" try: score = float(score) except ValueError: logging.error(f\\"Invalid score for {full_name}: {score}\\") continue if full_name not in scores: scores[full_name] = [] scores[full_name].append(score) averages = [(name, sum(score_list) / len(score_list)) for name, score_list in scores.items()] averages.sort(key=lambda x: (x[1], x[0])) return averages"},{"question":"class CircularQueue: Implements a circular queue with a fixed size. Methods: enqueue(element): Adds an element to the end of the circular queue. dequeue(): Removes and returns the front element from the circular queue. peek(): Returns the front element without removing it. isFull(): Returns True if the circular queue is full, otherwise False. isEmpty(): Returns True if the circular queue is empty, otherwise False. Example: >>> cq = CircularQueue(3) >>> cq.enqueue(1) >>> cq.enqueue(2) >>> cq.enqueue(3) >>> cq.isFull() True >>> cq.dequeue() 1 >>> cq.enqueue(4) >>> cq.peek() 2 >>> cq.isFull() True >>> cq.isEmpty() False >>> cq.dequeue() 2 >>> cq.dequeue() 3 >>> cq.dequeue() 4 >>> cq.isEmpty() True import pytest def test_enqueue(): cq = CircularQueue(3) assert cq.enqueue(1) is None assert cq.enqueue(2) is None assert cq.enqueue(3) is None assert cq.enqueue(4) == \\"Queue is full\\" def test_dequeue(): cq = CircularQueue(3) assert cq.enqueue(1) is None assert cq.enqueue(2) is None assert cq.enqueue(3) is None assert cq.dequeue() == 1 assert cq.dequeue() == 2 assert cq.dequeue() == 3 assert cq.dequeue() == \\"Queue is empty\\" def test_peek(): cq = CircularQueue(3) assert cq.peek() == \\"Queue is empty\\" assert cq.enqueue(1) is None assert cq.peek() == 1 assert cq.enqueue(2) is None assert cq.peek() == 1 assert cq.dequeue() == 1 assert cq.peek() == 2 def test_isFull(): cq = CircularQueue(3) assert not cq.isFull() cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) assert cq.isFull() cq.dequeue() assert not cq.isFull() cq.enqueue(4) assert cq.isFull() def test_isEmpty(): cq = CircularQueue(3) assert cq.isEmpty() cq.enqueue(1) assert not cq.isEmpty() cq.dequeue() assert cq.isEmpty() cq.enqueue(2) assert not cq.isEmpty()","solution":"class CircularQueue: def __init__(self, size: int): self.size = size self.queue = [None] * size self.front = self.rear = -1 def enqueue(self, element): if self.isFull(): return \\"Queue is full\\" if self.isEmpty(): self.front = 0 self.rear = (self.rear + 1) % self.size self.queue[self.rear] = element def dequeue(self): if self.isEmpty(): return \\"Queue is empty\\" element = self.queue[self.front] self.queue[self.front] = None if self.front == self.rear: self.front = self.rear = -1 else: self.front = (self.front + 1) % self.size return element def peek(self): if self.isEmpty(): return \\"Queue is empty\\" return self.queue[self.front] def isFull(self): return (self.rear + 1) % self.size == self.front def isEmpty(self): return self.front == -1"},{"question":"from typing import List class SegmentTree: def __init__(self, arr: List[int]): Initializes the segment tree with the given array of integers. pass def build(self, arr: List[int]): Build the segment tree using the given array. pass def range_sum(self, left: int, right: int) -> int: Returns the sum of elements from index left to right (inclusive). >>> tree = SegmentTree([1, 3, 5, 7, 9, 11]) >>> tree.range_sum(1, 3) 15 pass def update(self, index: int, value: int): Updates the element at index to value and adjusts the segment tree accordingly. >>> tree = SegmentTree([1, 3, 5, 7, 9, 11]) >>> tree.update(1, 10) >>> tree.range_sum(1, 3) 22 pass def test_segment_tree_build(): arr = [1, 3, 5, 7, 9, 11] tree = SegmentTree(arr) assert tree.tree[tree.n:2*tree.n] == arr def test_range_sum(): arr = [1, 3, 5, 7, 9, 11] tree = SegmentTree(arr) assert tree.range_sum(1, 3) == 15 # 3 + 5 + 7 assert tree.range_sum(0, 5) == 36 # 1 + 3 + 5 + 7 + 9 + 11 assert tree.range_sum(2, 4) == 21 # 5 + 7 + 9 def test_update(): arr = [1, 3, 5, 7, 9, 11] tree = SegmentTree(arr) tree.update(1, 10) # arr becomes [1, 10, 5, 7, 9, 11] assert tree.range_sum(1, 3) == 22 # 10 + 5 + 7 assert tree.range_sum(0, 5) == 43 # 1 + 10 + 5 + 7 + 9 + 11 def test_update_and_range_sum(): arr = [1, 3, 5, 7, 9, 11] tree = SegmentTree(arr) tree.update(4, 6) # arr becomes [1, 3, 5, 7, 6, 11] assert tree.range_sum(3, 4) == 13 # 7 + 6 tree.update(0, 4) # arr becomes [4, 3, 5, 7, 6, 11] assert tree.range_sum(0, 2) == 12 # 4 + 3 + 5","solution":"from typing import List class SegmentTree: def __init__(self, arr: List[int]): self.n = len(arr) self.tree = [0] * (2 * self.n) # Build the tree self.build(arr) def build(self, arr: List[int]): # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree by calculating parent nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def range_sum(self, left: int, right: int) -> int: # Get the sum of elements from index left to right (inclusive) left += self.n right += self.n + 1 # Make the right endpoint exclusive sum_ = 0 while left < right: if left % 2 == 1: sum_ += self.tree[left] left += 1 if right % 2 == 1: right -= 1 sum_ += self.tree[right] left //= 2 right //= 2 return sum_ def update(self, index: int, value: int): # Update the value at index and rebuild the tree index += self.n self.tree[index] = value while index > 1: index //= 2 self.tree[index] = self.tree[index * 2] + self.tree[index * 2 + 1]"},{"question":"def update_salaries(db_connection, salary_threshold, min_salary_limit): Update the salaries of employees based on specified thresholds and ensure the operation's consistency. This function performs the following operations within an atomic transaction: - Increases the salary of employees by 10% if their current salary is less than \`salary_threshold\`. - Decreases the salary of employees by 5% if their current salary exceeds \`salary_threshold\`. - Ensures that the minimum salary after the transaction is not less than \`min_salary_limit\`. Robust error handling is included to catch any errors that occur during the transaction, rollback the transaction if an error is detected, and provide meaningful error messages. Args: db_connection: The database connection object. salary_threshold (float): The salary threshold to decide increase/decrease operations. min_salary_limit (float): The minimum allowable salary after the transaction. >>> from unittest.mock import Mock, call >>> mock_db_connection = Mock() >>> mock_cursor = Mock() >>> mock_db_connection.cursor.return_value = mock_cursor >>> salary_threshold = 50000 >>> min_salary_limit = 30000 >>> update_salaries(mock_db_connection, salary_threshold, min_salary_limit) >>> mock_db_connection.begin.assert_called_once() >>> mock_db_connection.commit.assert_called_once() >>> mock_cursor.execute.assert_has_calls([ ... call(\\"UPDATE employees SET salary = salary * 1.10 WHERE salary < %s\\", (salary_threshold,)), ... call(\\"UPDATE employees SET salary = salary * 0.95 WHERE salary > %s\\", (salary_threshold,)), ... call(\\"UPDATE employees SET salary = %s WHERE salary < %s\\", (min_salary_limit, min_salary_limit)) ... ]) >>> mock_cursor.close.assert_called_once() >>> mock_cursor.execute.side_effect = Exception(\\"Mock SQL Error\\") >>> update_salaries(mock_db_connection, salary_threshold, min_salary_limit) >>> mock_db_connection.begin.assert_called_once() >>> mock_db_connection.rollback.assert_called_once() >>> mock_cursor.close.assert_called_once()","solution":"def update_salaries(db_connection, salary_threshold, min_salary_limit): try: cursor = db_connection.cursor() # Start transaction db_connection.begin() # Correct query to increase salaries cursor.execute(\\"UPDATE employees SET salary = salary * 1.10 WHERE salary < %s\\", (salary_threshold,)) # Correct query to decrease salaries cursor.execute(\\"UPDATE employees SET salary = salary * 0.95 WHERE salary > %s\\", (salary_threshold,)) # Ensure the minimum salary limit is respected cursor.execute(\\"UPDATE employees SET salary = %s WHERE salary < %s\\", (min_salary_limit, min_salary_limit)) # Commit the transaction only if all operations were successful db_connection.commit() except Exception as e: # Rollback the transaction in case of error print(\\"An error occurred: Transaction failed. Rolling back changes.\\", e) db_connection.rollback() finally: cursor.close()"},{"question":"class LibraryCatalog: A class to manage a collection of books in a library catalog. Each book is represented as a dictionary with the following properties: 'title', 'author', 'year_published', 'genre', and 'isbn'. The class supports the following operations: 1. Add a book to the catalog. 2. Remove a book from the catalog using its ISBN. 3. Search for books by title and author. 4. List all books in the catalog. 5. Update the information of a book using its ISBN. Example usage: >>> catalog = LibraryCatalog() >>> catalog.add_book({\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year_published\\": 1960, \\"genre\\": \\"Fiction\\", \\"isbn\\": \\"1234567890\\"}) >>> catalog.add_book({\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year_published\\": 1949, \\"genre\\": \\"Dystopian\\", \\"isbn\\": \\"1234567891\\"}) >>> catalog.remove_book(\\"1234567890\\") >>> catalog.search_books(title=\\"1984\\") == [{\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year_published\\": 1949, \\"genre\\": \\"Dystopian\\", \\"isbn\\": \\"1234567891\\"}] >>> catalog.search_books(author=\\"Harper Lee\\") == [] >>> catalog.list_all_books() == [{\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year_published\\": 1949, \\"genre\\": \\"Dystopian\\", \\"isbn\\": \\"1234567891\\"}] >>> catalog.update_book(\\"1234567891\\", {\\"title\\": \\"Nineteen Eighty-Four\\", \\"year_published\\": 1949}) >>> catalog.list_all_books() == [{\\"title\\": \\"Nineteen Eighty-Four\\", \\"author\\": \\"George Orwell\\", \\"year_published\\": 1949, \\"genre\\": \\"Dystopian\\", \\"isbn\\": \\"1234567891\\"}] def add_book(self, book): Adds a book to the catalog. Raises an error if the ISBN already exists. def remove_book(self, isbn): Removes a book from the catalog using its ISBN. Returns True if successful, raises an error if the ISBN does not exist. def search_books(self, title=None, author=None): Searches books by title and author. Returns a list of books that match the title or author. def list_all_books(self): Returns a list of all books in the catalog. def update_book(self, isbn, updated_info): Updates book information using its ISBN. Raises an error if the ISBN does not exist.","solution":"class LibraryCatalog: def __init__(self): self.catalog = {} def add_book(self, book): Adds a book to the catalog. Raises an error if the ISBN already exists. if book['isbn'] in self.catalog: raise ValueError(\\"Book with this ISBN already exists.\\") self.catalog[book['isbn']] = book def remove_book(self, isbn): Removes a book from the catalog using its ISBN. Returns True if successful, raises an error if the ISBN does not exist. if isbn not in self.catalog: raise KeyError(\\"Book with this ISBN not found.\\") del self.catalog[isbn] def search_books(self, title=None, author=None): Searches books by title and author. Returns a list of books that match the title or author. results = [] for book in self.catalog.values(): if title and title.lower() in book['title'].lower(): results.append(book) elif author and author.lower() in book['author'].lower(): results.append(book) return results def list_all_books(self): Returns a list of all books in the catalog. return list(self.catalog.values()) def update_book(self, isbn, updated_info): Updates book information using its ISBN. Raises an error if the ISBN does not exist. if isbn not in self.catalog: raise KeyError(\\"Book with this ISBN not found.\\") self.catalog[isbn].update(updated_info)"},{"question":"import numpy as np class DenseLayer: def __init__(self, input_size, output_size, activation): self.weights = np.random.randn(input_size, output_size) * 0.01 self.biases = np.zeros((1, output_size)) self.activation = activation def forward(self, inputs): z = np.dot(inputs, self.weights) + self.biases return self.activation(z) class ActivationReLU: def __call__(self, x): return np.maximum(0, x) class ActivationSoftmax: def __call__(self, x): exp_values = np.exp(x - np.max(x, axis=1, keepdims=True)) probabilities = exp_values / np.sum(exp_values, axis=1, keepdims=True) return probabilities class LossCrossEntropy: def __call__(self, y_pred, y_true): samples = len(y_pred) y_pred_clipped = np.clip(y_pred, 1e-7, 1 - 1e-7) correct_confidences = y_pred_clipped[range(samples), y_true] negative_log_likelihoods = -np.log(correct_confidences) return np.mean(negative_log_likelihoods) class OptimizerSGD: def __init__(self, learning_rate=1.0): self.learning_rate = learning_rate def update_parameters(self, layer): layer.weights -= self.learning_rate * layer.dweights layer.biases -= self.learning_rate * layer.dbiases class NeuralNetwork: def __init__(self): self.layers = [] def add_layer(self, layer): self.layers.append(layer) def forward(self, X): for layer in self.layers: X = layer.forward(X) return X def train(self, X_train, y_train, epochs=1, learning_rate=1.0): optimizer = OptimizerSGD(learning_rate) for epoch in range(epochs): output = self.forward(X_train) loss_function = LossCrossEntropy() loss = loss_function(output, y_train) print(f'Epoch {epoch+1}, Loss: {loss}') # (Backward pass and weight updates are simplified) # This simplified implementation does not support backward pass and gradient updates. # Tests def test_relu_activation(): activation = ActivationReLU() input_data = np.array([[-1, 0, 1], [2, -3, 4]]) output_data = activation(input_data) expected_output = np.array([[0, 0, 1], [2, 0, 4]]) assert np.array_equal(output_data, expected_output) def test_softmax_activation(): activation = ActivationSoftmax() input_data = np.array([[1, 2, 3], [1, 0, 0]]) output_data = activation(input_data) expected_output = np.array([ [0.09003057, 0.24472847, 0.66524096], [0.57611688, 0.21194156, 0.21194156]]) assert np.allclose(output_data, expected_output, atol=1e-6) def test_dense_layer_forward_pass(): dense = DenseLayer(input_size=2, output_size=3, activation=ActivationReLU()) input_data = np.array([[1, 2], [3, 4]]) output_data = dense.forward(input_data) assert output_data.shape == (2, 3) def test_neural_network_forward_pass(): nn = NeuralNetwork() nn.add_layer(DenseLayer(input_size=2, output_size=3, activation=ActivationReLU())) nn.add_layer(DenseLayer(input_size=3, output_size=2, activation=ActivationSoftmax())) input_data = np.array([[1, 2], [3, 4]]) output_data = nn.forward(input_data) assert output_data.shape == (2, 2) def test_neural_network_training(): nn = NeuralNetwork() nn.add_layer(DenseLayer(input_size=2, output_size=3, activation=ActivationReLU())) nn.add_layer(DenseLayer(input_size=3, output_size=3, activation=ActivationSoftmax())) X_train = np.array([[1, 2], [3, 4], [5, 6]]) y_train = np.array([0, 1, 2]) nn.train(X_train, y_train, epochs=1) # Simplified test, just ensure no crash","solution":"import numpy as np class DenseLayer: def __init__(self, input_size, output_size, activation): self.weights = np.random.randn(input_size, output_size) * 0.01 self.biases = np.zeros((1, output_size)) self.activation = activation def forward(self, inputs): z = np.dot(inputs, self.weights) + self.biases return self.activation(z) class ActivationReLU: def __call__(self, x): return np.maximum(0, x) class ActivationSoftmax: def __call__(self, x): exp_values = np.exp(x - np.max(x, axis=1, keepdims=True)) probabilities = exp_values / np.sum(exp_values, axis=1, keepdims=True) return probabilities class LossCrossEntropy: def __call__(self, y_pred, y_true): samples = len(y_pred) y_pred_clipped = np.clip(y_pred, 1e-7, 1 - 1e-7) correct_confidences = y_pred_clipped[range(samples), y_true] negative_log_likelihoods = -np.log(correct_confidences) return np.mean(negative_log_likelihoods) class OptimizerSGD: def __init__(self, learning_rate=1.0): self.learning_rate = learning_rate def update_parameters(self, layer): layer.weights -= self.learning_rate * layer.dweights layer.biases -= self.learning_rate * layer.dbiases class NeuralNetwork: def __init__(self): self.layers = [] def add_layer(self, layer): self.layers.append(layer) def forward(self, X): for layer in self.layers: X = layer.forward(X) return X def train(self, X_train, y_train, epochs=1, learning_rate=1.0): optimizer = OptimizerSGD(learning_rate) for epoch in range(epochs): output = self.forward(X_train) loss_function = LossCrossEntropy() loss = loss_function(output, y_train) print(f'Epoch {epoch+1}, Loss: {loss}') # (Backward pass and weight updates are simplified) # This simplified implementation does not support backward pass and gradient updates. # Sample usage if __name__ == \\"__main__\\": # Create a neural network nn = NeuralNetwork() nn.add_layer(DenseLayer(input_size=2, output_size=3, activation=ActivationReLU())) nn.add_layer(DenseLayer(input_size=3, output_size=3, activation=ActivationSoftmax())) # Dummy data X_train = np.array([[1, 2], [3, 4], [5, 6]]) y_train = np.array([0, 1, 2]) # Train the network nn.train(X_train, y_train, epochs=5)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate an arithmetic expression given as a string and return its value. The function should be able to handle positive and negative integers, the four basic arithmetic operations (addition, subtraction, multiplication, and division), and respect the order of operations (parentheses and operator precedence). If the input string contains invalid characters or syntax, the function should raise a ValueError with an appropriate message. Parameters: expression (str): The arithmetic expression to evaluate. Returns: int: The result of the evaluated expression. Raises: ValueError: If the expression contains invalid characters or syntax. Examples: >>> evaluate_expression(\\"2 + 3\\") 5 >>> evaluate_expression(\\"3 + 5 * (2 - 8)\\") -13 >>> evaluate_expression(\\"8 / 2\\") 4 >>> evaluate_expression(\\"2 + (3 * (4 - 1))\\") 11 >>> evaluate_expression(\\"2 + 3a\\") Traceback (most recent call last): ... ValueError: Invalid characters in expression from solution import evaluate_expression def test_simple_addition(): assert evaluate_expression(\\"2 + 3\\") == 5 def test_simple_subtraction(): assert evaluate_expression(\\"5 - 2\\") == 3 def test_simple_multiplication(): assert evaluate_expression(\\"4 * 3\\") == 12 def test_simple_division(): assert evaluate_expression(\\"8 / 2\\") == 4 def test_combined_operations(): assert evaluate_expression(\\"2 + 3 * 4\\") == 14 def test_parentheses_precedence(): assert evaluate_expression(\\"(2 + 3) * 4\\") == 20 def test_nested_parentheses(): assert evaluate_expression(\\"2 + (3 * (4 - 1))\\") == 11 def test_negative_numbers(): assert evaluate_expression(\\"-2 + 3\\") == 1 assert evaluate_expression(\\"2 + -3\\") == -1 def test_invalid_characters(): try: evaluate_expression(\\"2 + 3a\\") except ValueError as e: assert str(e) == \\"Invalid characters in expression\\" def test_invalid_syntax(): try: evaluate_expression(\\"2 + (3 * 4\\") except ValueError as e: assert str(e) == \\"Invalid syntax in expression\\" def test_handle_spaces(): assert evaluate_expression(\\" 2 + 3 \\") == 5","solution":"def evaluate_expression(expression): Evaluate an arithmetic expression given as a string and return its value. Parameters: expression (str): The arithmetic expression to evaluate. Returns: int/float: The result of the evaluated expression. Raises: ValueError: If the expression contains invalid characters or syntax. import re # Remove any whitespace expression = expression.replace(\\" \\", \\"\\") # Valid characters are digits, operators, and parentheses if not re.match(r'^[0-9+-*/()]*', expression): raise ValueError(\\"Invalid characters in expression\\") try: # Evaluate the expression safely using eval result = eval(expression) except SyntaxError: raise ValueError(\\"Invalid syntax in expression\\") return result"},{"question":"def is_prime(n: int) -> bool: Check if a number is prime. ... def reorganize_list(numbers: List[int]) -> List[int]: Reorganize a given list of integers such that all prime numbers appear first in ascending order, followed by non-prime numbers in descending order without disturbing their relative order from the original list. Args: numbers (List[int]): The list of integers to be reorganized. Returns: List[int]: The reorganized list. Examples: >>> reorganize_list([11, 17, 8, 4, 7, 2, 15, 22]) [2, 7, 11, 17, 22, 15, 8, 4] >>> reorganize_list([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] >>> reorganize_list([4, 6, 8, 9, 10]) [10, 9, 8, 6, 4] ... import pytest from solution import reorganize_list def test_reorganize_list_example(): assert reorganize_list([11, 17, 8, 4, 7, 2, 15, 22]) == [2, 7, 11, 17, 22, 15, 8, 4] def test_reorganize_list_all_primes(): assert reorganize_list([2, 3, 5, 7, 11]) == [2, 3, 5, 7, 11] def test_reorganize_list_all_non_primes(): assert reorganize_list([4, 6, 8, 9, 10]) == [10, 9, 8, 6, 4] def test_reorganize_list_mixed_numbers(): assert reorganize_list([3, 1, 4, 2, 9, 5]) == [2, 3, 5, 9, 4, 1] def test_reorganize_list_empty(): assert reorganize_list([]) == [] def test_reorganize_list_single_prime(): assert reorganize_list([7]) == [7] def test_reorganize_list_single_non_prime(): assert reorganize_list([10]) == [10]","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False p = 3 while p * p <= n: if n % p == 0: return False p += 2 return True def reorganize_list(numbers): Reorganizes the list of integers such that all prime numbers appear first in ascending order, followed by non-prime numbers in descending order without disturbing their relative order from the original list. primes = [x for x in numbers if is_prime(x)] non_primes = [x for x in numbers if not is_prime(x)] primes.sort() non_primes.sort(reverse=True) return primes + non_primes"},{"question":"import heapq import time from threading import Thread, Lock from collections import defaultdict class ResourceDistributionNetwork: def __init__(self): self.nodes = {} self.lock = Lock() def add_node(self, node_id, resources): Add a node to the network with a specified amount of resources. pass def request_resources(self, node_id, amount): Request a specific amount of resources from a node in the network. pass def return_resources(self, node_id, amount): Return a specific amount of resources to a node in the network. pass class MonitoringSystem: def __init__(self, network, interval_sec=10): self.network = network self.interval_sec = interval_sec self.monitoring = False self.thread = Thread(target=self.monitor) def start(self): Start the monitoring system. pass def stop(self): Stop the monitoring system. pass def monitor(self): Continuously monitor the network performance. pass def analyze_network(self): Analyze the network performance to identify bottlenecks and overprovisioned nodes. pass def report(self, node_resources, bottlenecks, overprovisioned): Generate a report on the network resource utilization. pass Unit Test: from solution import ResourceDistributionNetwork, MonitoringSystem def test_add_node(): network = ResourceDistributionNetwork() network.add_node('A', 10) assert len(network.nodes['A']) == 1 def test_request_resources(): network = ResourceDistributionNetwork() network.add_node('A', 10) assigned = network.request_resources('A', 5) assert assigned == 5 remaining_resources = sum(res for _, res in network.nodes['A']) assert remaining_resources == 5 def test_return_resources(): network = ResourceDistributionNetwork() network.add_node('A', 10) allocated = network.request_resources('A', 10) assert allocated == 10 network.return_resources('A', [5, 5]) available = sum(res for _, res in network.nodes['A']) assert available == 10 def test_monitoring_system(): network = ResourceDistributionNetwork() network.add_node('A', 10) network.add_node('B', 5) monitor = MonitoringSystem(network, interval_sec=1) monitor.start() time.sleep(2) # allow time for at least one monitoring cycle monitor.stop() test_add_node() test_request_resources() test_return_resources() test_monitoring_system()","solution":"import heapq import time from threading import Thread, Lock from collections import defaultdict class ResourceDistributionNetwork: def __init__(self): self.nodes = {} self.lock = Lock() def add_node(self, node_id, resources): with self.lock: if node_id not in self.nodes: self.nodes[node_id] = [] heapq.heappush(self.nodes[node_id], (-resources, resources)) def request_resources(self, node_id, amount): assigned_resources = 0 with self.lock: if node_id not in self.nodes or not self.nodes[node_id]: return assigned_resources heap = self.nodes[node_id] while amount > 0 and heap: _, resources = heapq.heappop(heap) allocatable = min(resources, amount) allocated_resources = (resources - allocatable, allocatable) if allocated_resources[0] > 0: heapq.heappush(heap, (-allocated_resources[0], allocated_resources[0])) amount -= allocatable assigned_resources += allocatable return assigned_resources def return_resources(self, node_id, amount): with self.lock: for res in amount: heapq.heappush(self.nodes[node_id], (-res, res)) class MonitoringSystem: def __init__(self, network, interval_sec=10): self.network = network self.interval_sec = interval_sec self.monitoring = False self.thread = Thread(target=self.monitor) def start(self): self.monitoring = True self.thread.start() def stop(self): self.monitoring = False if self.thread.is_alive(): self.thread.join() def monitor(self): while self.monitoring: self.analyze_network() time.sleep(self.interval_sec) def analyze_network(self): node_resources = {node: sum(res for _, res in heap) for node, heap in self.network.nodes.items()} bottlenecks = [] overprovisioned = [] for node, res in node_resources.items(): if res < 1: potential_resources = max(self.network.nodes.values(), key=lambda x: sum(r[1] for r in x)) if sum(r[1] for r in potential_resources) > 1: bottlenecks.append(node) elif res > 10: overprovisioned.append(node) self.report(node_resources, bottlenecks, overprovisioned) def report(self, node_resources, bottlenecks, overprovisioned): print(\\"Resource Utilization Report:\\") print(\\"Node Resources: \\", node_resources) print(\\"Bottlenecks: \\", bottlenecks) print(\\"Overprovisioned: \\", overprovisioned) # Example use: network = ResourceDistributionNetwork() network.add_node('A', 10) network.add_node('B', 5) network.add_node('C', 20) monitor = MonitoringSystem(network) monitor.start() # To stop monitoring monitor.stop()"},{"question":"import csv def compute_average(input_file: str, output_file: str): Reads the 'value' column from the input CSV file, computes the average value, and writes the result to the output CSV file. The output CSV file should have the format: column,average value,<computed_average> Args: input_file (str): The input CSV file path containing rows of 'value' numbers. output_file (str): The output CSV file path to write the result. Example: >>> compute_average('input.csv', 'output.csv') def create_csv(file_path, rows): with open(file_path, mode='w', newline='') as file: writer = csv.writer(file) writer.writerows(rows) def read_csv(file_path): with open(file_path, mode='r', newline='') as file: reader = csv.reader(file) return [row for row in reader] def test_compute_average_basic(): input_path = 'test_input.csv' output_path = 'test_output.csv' create_csv(input_path, [['id', 'value'], [1, 10], [2, 20], [3, 30]]) compute_average(input_path, output_path) result = read_csv(output_path) assert result == [['column', 'average'], ['value', '20.0']] os.remove(input_path) os.remove(output_path) def test_compute_average_with_zero(): input_path = 'test_input_zero.csv' output_path = 'test_output_zero.csv' create_csv(input_path, [['id', 'value'], [1, 0], [2, 0], [3, 0]]) compute_average(input_path, output_path) result = read_csv(output_path) assert result == [['column', 'average'], ['value', '0.0']] os.remove(input_path) os.remove(output_path) def test_compute_average_mixed_values(): input_path = 'test_input_mixed.csv' output_path = 'test_output_mixed.csv' create_csv(input_path, [['id', 'value'], [1, -10], [2, 10], [3, -20], [4, 20]]) compute_average(input_path, output_path) result = read_csv(output_path) assert result == [['column', 'average'], ['value', '0.0']] os.remove(input_path) os.remove(output_path) def test_compute_average_single_value(): input_path = 'test_input_single.csv' output_path = 'test_output_single.csv' create_csv(input_path, [['id', 'value'], [1, 50]]) compute_average(input_path, output_path) result = read_csv(output_path) assert result == [['column', 'average'], ['value', '50.0']] os.remove(input_path) os.remove(output_path) def test_compute_average_empty_file(): input_path = 'test_input_empty.csv' output_path = 'test_output_empty.csv' create_csv(input_path, [['id', 'value']]) compute_average(input_path, output_path) result = read_csv(output_path) assert result == [['column', 'average'], ['value', '0']] os.remove(input_path) os.remove(output_path)","solution":"import csv def compute_average(input_file, output_file): Reads the 'value' column from the input CSV file, computes the average, and writes the result to the output CSV file. total = 0 count = 0 with open(input_file, mode='r', newline='') as infile: reader = csv.DictReader(infile) for row in reader: total += float(row['value']) count += 1 average = total / count if count != 0 else 0 with open(output_file, mode='w', newline='') as outfile: writer = csv.writer(outfile) writer.writerow(['column', 'average']) writer.writerow(['value', average])"},{"question":"def remove_key_with_fewest_elements(input_dict: dict) -> dict: Remove the key-value pair where the list has the fewest elements. In case of a tie, remove the key-value pair that comes first lexicographically. Args: input_dict (dict): The dictionary with string keys and list of integers as values. Returns: dict: The modified dictionary after removing the specified key-value pair. Examples: >>> remove_key_with_fewest_elements({ ... \\"apple\\": [1, 2, 3], ... \\"banana\\": [4, 5], ... \\"cherry\\": [6, 7, 8, 9], ... \\"date\\": [10, 11] ... }) {'apple': [1, 2, 3], 'cherry': [6, 7, 8, 9], 'date': [10, 11]} >>> remove_key_with_fewest_elements({ ... \\"apple\\": [1, 2], ... \\"banana\\": [3, 4], ... \\"cherry\\": [5, 6] ... }) {'banana': [3, 4], 'cherry': [5, 6]} pass # Unit Tests def test_remove_key_with_fewest_elements_single_min(): input_dict = { \\"apple\\": [1, 2, 3], \\"banana\\": [4, 5], \\"cherry\\": [6, 7, 8, 9], \\"date\\": [10, 11] } expected_output = { \\"apple\\": [1, 2, 3], \\"cherry\\": [6, 7, 8, 9], \\"date\\": [10, 11] } assert remove_key_with_fewest_elements(input_dict) == expected_output def test_remove_key_with_fewest_elements_tie_min(): input_dict = { \\"apple\\": [1, 2, 3, 4], \\"banana\\": [5, 6], \\"cherry\\": [7, 8, 9], \\"date\\": [10, 11] } expected_output = { \\"apple\\": [1, 2, 3, 4], \\"cherry\\": [7, 8, 9], \\"date\\": [10, 11] } assert remove_key_with_fewest_elements(input_dict) == expected_output def test_remove_key_with_fewest_elements_empty_dict(): input_dict = {} expected_output = {} assert remove_key_with_fewest_elements(input_dict) == expected_output def test_remove_key_with_fewest_elements_single_key(): input_dict = { \\"apple\\": [1, 2] } expected_output = {} assert remove_key_with_fewest_elements(input_dict) == expected_output def test_remove_key_with_fewest_elements_all_same_length(): input_dict = { \\"apple\\": [1, 2], \\"banana\\": [3, 4], \\"cherry\\": [5, 6] } expected_output = { \\"banana\\": [3, 4], \\"cherry\\": [5, 6] } assert remove_key_with_fewest_elements(input_dict) == expected_output","solution":"def remove_key_with_fewest_elements(input_dict): Remove the key-value pair with the fewest elements in the list. In case of a tie, removes the lexicographically first key. if not input_dict: return input_dict keys = list(input_dict.keys()) min_len = min(len(input_dict[k]) for k in keys) # Finding candidates with minimum length lists candidates = [k for k in keys if len(input_dict[k]) == min_len] # Identify the lexicographically first key key_to_remove = min(candidates) # Remove the identified key del input_dict[key_to_remove] return input_dict"},{"question":"import collections import threading class LRUCache: def __init__(self, capacity: int): Initialize the LRUCache with a given capacity. pass def get(self, key: int) -> int: Retrieve the value associated with the given key. If the key does not exist, return -1. Ensure thread safety. >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) # returns 1 1 >>> cache.put(3, 3) # evicts key 2 >>> cache.get(2) # returns -1 (not found) -1 pass def put(self, key: int, value: int): Insert or update the value associated with the given key. Ensure thread safety and handle cache eviction if the capacity is exceeded. >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) # returns 1 1 >>> cache.put(3, 3) # evicts key 2 >>> cache.get(2) # returns -1 (not found) -1 >>> cache.put(4, 4) # evicts key 1 >>> cache.get(1) # returns -1 (not found) -1 >>> cache.get(3) # returns 3 3 >>> cache.get(4) # returns 4 4 pass def remove(self, key: int) -> bool: Remove the entry associated with the given key. Ensure thread safety. Return True if the key existed and was removed, False otherwise. >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.remove(1) # returns True True >>> cache.get(1) # returns -1 (not found) -1 >>> cache.remove(3) # returns False as key 3 does not exist False pass","solution":"import collections import threading class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = collections.OrderedDict() self.lock = threading.Lock() def get(self, key: int) -> int: with self.lock: if key not in self.cache: return -1 self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int): with self.lock: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) def remove(self, key: int) -> bool: with self.lock: if key in self.cache: del self.cache[key] return True return False"},{"question":"class Event: Event class that handles registrations for an event with a title, date, and participant limit. def __init__(self, title: str, date: str, participant_limit: int): Initialize an event with its title, date, and participant limit. Args: title (str): The title of the event. date (str): The date of the event in 'YYYY-MM-DD' format. participant_limit (int): The maximum number of participants allowed. def register_participant(self, participant_name: str) -> bool: Register a participant for the event, ensuring that the participant limit is not exceeded. Args: participant_name (str): The name of the participant. Returns: bool: True if registration is successful, False otherwise. class EventManager: EventManager class for managing multiple events and their registrations. def __init__(self): Initialize the EventManager with an empty list of events. def add_event(self, event: Event): Add a new event to the EventManager. Args: event (Event): The event to add. def register(self, event_title: str, participant_name: str) -> bool: Register a participant for an event by title. Raise an exception if the event does not exist. Args: event_title (str): The title of the event. participant_name (str): The name of the participant. Returns: bool: True if registration is successful, False otherwise. Raises: Exception: If the event does not exist or registration fails. def participant_events(self, participant_name: str) -> list: Return a list of event titles that the participant is registered for. Args: participant_name (str): The name of the participant. Returns: list: A list of event titles. # Unit tests to validate the functionality def test_event_registration(): event = Event(\\"Test Event\\", \\"2023-10-10\\", 2) assert event.register_participant(\\"Alice\\") == True assert event.register_participant(\\"Bob\\") == True assert event.register_participant(\\"Charlie\\") == False # Event limit reached def test_event_manager_add_event(): manager = EventManager() event = Event(\\"Test Event\\", \\"2023-10-10\\", 2) manager.add_event(event) assert len(manager.events) == 1 assert manager.events[0].title == \\"Test Event\\" def test_event_manager_register(): manager = EventManager() event = Event(\\"Test Event\\", \\"2023-10-10\\", 2) manager.add_event(event) assert manager.register(\\"Test Event\\", \\"Alice\\") == True assert manager.register(\\"Test Event\\", \\"Bob\\") == True try: manager.register(\\"Test Event\\", \\"Charlie\\") except Exception as e: assert str(e) == \\"Registration failed. Either the event is full or the participant is already registered.\\" def test_event_manager_register_nonexistent_event(): manager = EventManager() try: manager.register(\\"Nonexistent Event\\", \\"Alice\\") except Exception as e: assert str(e) == \\"Event not found.\\" def test_participant_events(): manager = EventManager() event1 = Event(\\"Event 1\\", \\"2023-10-10\\", 2) event2 = Event(\\"Event 2\\", \\"2023-10-11\\", 2) manager.add_event(event1) manager.add_event(event2) manager.register(\\"Event 1\\", \\"Alice\\") manager.register(\\"Event 2\\", \\"Alice\\") assert manager.participant_events(\\"Alice\\") == [\\"Event 1\\", \\"Event 2\\"] assert manager.participant_events(\\"Bob\\") == []","solution":"class Event: def __init__(self, title, date, participant_limit): self.title = title self.date = date self.participant_limit = participant_limit self.participants = [] def register_participant(self, participant_name): if len(self.participants) < self.participant_limit: if participant_name not in self.participants: self.participants.append(participant_name) return True return False class EventManager: def __init__(self): self.events = [] def add_event(self, event): self.events.append(event) def register(self, event_title, participant_name): for event in self.events: if event.title == event_title: if event.register_participant(participant_name): return True else: raise Exception(\\"Registration failed. Either the event is full or the participant is already registered.\\") raise Exception(\\"Event not found.\\") def participant_events(self, participant_name): registered_events = [] for event in self.events: if participant_name in event.participants: registered_events.append(event.title) return registered_events"},{"question":"def calculate_total_hours(employees: List[Dict[str, Any]]) -> int: Returns the total number of hours worked by employees in the \\"Engineering\\" department with a salary greater than 70,000. >>> employees = [ ... {\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\", \\"salary\\": 80000, \\"hoursWorked\\": 40}, ... {\\"name\\": \\"Bob\\", \\"department\\": \\"Marketing\\", \\"salary\\": 60000, \\"hoursWorked\\": 38}, ... {\\"name\\": \\"Charlie\\", \\"department\\": \\"Engineering\\", \\"salary\\": 50000, \\"hoursWorked\\": 42}, ... {\\"name\\": \\"David\\", \\"department\\": \\"Engineering\\", \\"salary\\": 75000, \\"hoursWorked\\": 41} ... ] >>> calculate_total_hours(employees) 81 pass import unittest class TestCalculateTotalHours(unittest.TestCase): def test_calculate_total_hours(self): employees = [ {\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\", \\"salary\\": 80000, \\"hoursWorked\\": 40}, {\\"name\\": \\"Bob\\", \\"department\\": \\"Marketing\\", \\"salary\\": 60000, \\"hoursWorked\\": 38}, {\\"name\\": \\"Charlie\\", \\"department\\": \\"Engineering\\", \\"salary\\": 50000, \\"hoursWorked\\": 42}, {\\"name\\": \\"David\\", \\"department\\": \\"Engineering\\", \\"salary\\": 75000, \\"hoursWorked\\": 41} ] self.assertEqual(calculate_total_hours(employees), 81) def test_calculate_total_hours_with_no_qualified_employees(self): employees = [ {\\"name\\": \\"Alice\\", \\"department\\": \\"Marketing\\", \\"salary\\": 80000, \\"hoursWorked\\": 40}, {\\"name\\": \\"Bob\\", \\"department\\": \\"Sales\\", \\"salary\\": 60000, \\"hoursWorked\\": 38} ] self.assertEqual(calculate_total_hours(employees), 0) def test_calculate_total_hours_with_all_qualified_employees(self): employees = [ {\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\", \\"salary\\": 80000, \\"hoursWorked\\": 40}, {\\"name\\": \\"David\\", \\"department\\": \\"Engineering\\", \\"salary\\": 75000, \\"hoursWorked\\": 41} ] self.assertEqual(calculate_total_hours(employees), 81) def test_calculate_total_hours_with_edge_case_salary(self): employees = [ {\\"name\\": \\"Alice\\", \\"department\\": \\"Engineering\\", \\"salary\\": 70000, \\"hoursWorked\\": 40}, {\\"name\\": \\"David\\", \\"department\\": \\"Engineering\\", \\"salary\\": 70001, \\"hoursWorked\\": 41} ] self.assertEqual(calculate_total_hours(employees), 41) if __name__ == \\"__main__\\": unittest.main()","solution":"def calculate_total_hours(employees): Returns the total number of hours worked by employees in the \\"Engineering\\" department with a salary greater than 70,000. total_hours = 0 for employee in employees: if employee['department'] == 'Engineering' and employee['salary'] > 70000: total_hours += employee['hoursWorked'] return total_hours"},{"question":"from datetime import datetime def calculate_age_and_birthday(birthdate: str) -> tuple: Calculates the age in years, months, and days, and determines the day of the week for a given birthdate. Parameters: birthdate (str): Birthdate in the format 'YYYY-MM-DD'. Returns: tuple: Age in years, months, and days as a formatted string, and the day of the week as a string. Example: >>> calculate_age_and_birthday(\\"2000-01-01\\") (\\"You are X years, Y months, and Z days old.\\", \\"You were born on a [Day of the Week].\\") pass # Unit Tests def test_valid_birthdate(): message1, message2 = calculate_age_and_birthday(\\"2000-01-01\\") assert \\"You are\\" in message1 assert \\"years, \\" in message1 assert \\"months, and \\" in message1 assert \\"days old.\\" in message1 assert \\"You were born on a\\" in message2 def test_leap_year_birthdate(): message1, message2 = calculate_age_and_birthday(\\"2000-02-29\\") assert \\"You are\\" in message1 assert \\"years, \\" in message1 assert \\"months, and \\" in message1 assert \\"days old.\\" in message1 assert \\"You were born on a\\" in message2 def test_end_of_year_birthdate(): message1, message2 = calculate_age_and_birthday(\\"1995-12-31\\") assert \\"You are\\" in message1 assert \\"years, \\" in message1 assert \\"months, and \\" in message1 assert \\"days old.\\" in message1 assert \\"You were born on a\\" in message2 def test_invalid_birthdate_format(): try: calculate_age_and_birthday(\\"01-01-2000\\") assert False, \\"Expected ValueError for incorrect date format\\" except ValueError: pass def test_non_leap_year_birthdate(): message1, message2 = calculate_age_and_birthday(\\"2001-02-28\\") assert \\"You are\\" in message1 assert \\"years, \\" in message1 assert \\"months, and \\" in message1 assert \\"days old.\\" in message1 assert \\"You were born on a\\" in message2 def test_today_birthdate(): today = datetime.today().strftime(\\"%Y-%m-%d\\") message1, message2 = calculate_age_and_birthday(today) assert message1 == \\"You are 0 years, 0 months, and 0 days old.\\" assert \\"You were born on a\\" in message2","solution":"from datetime import datetime def calculate_age_and_birthday(birthdate): Calculates the age in years, months, and days, and determines the day of the week for a given birthdate. Parameters: birthdate (str): Birthdate in the format 'YYYY-MM-DD'. Returns: str: Age in years, months, and days. str: Day of the week the user was born. # Parse the birthdate birth_date = datetime.strptime(birthdate, \\"%Y-%m-%d\\") today = datetime.today() # Calculate age in years, months, and days age_years = today.year - birth_date.year age_months = today.month - birth_date.month age_days = today.day - birth_date.day if age_days < 0: age_months -= 1 age_days += (birth_date.replace(month=birth_date.month % 12 + 1, day=1) - birth_date.replace(day=1)).days if age_months < 0: age_years -= 1 age_months += 12 # Get day of the week user was born day_of_week = birth_date.strftime(\\"%A\\") return f\\"You are {age_years} years, {age_months} months, and {age_days} days old.\\", f\\"You were born on a {day_of_week}.\\""},{"question":"class CircularQueue: Implement a circular queue using a fixed-size list. Your implementation should ensure that all operations are performed in constant time. def __init__(self, k): Initialize the queue with a given size k. pass def enqueue(self, value): Add an element to the end of the queue. :param value: int :return: bool pass def dequeue(self): Remove an element from the front of the queue. :return: int or bool pass def Front(self): Get the front item from the queue. :return: int pass def Rear(self): Get the last item from the queue. :return: int pass def isFull(self): Check if the queue is full. :return: bool pass def isEmpty(self): Check if the queue is empty. :return: bool pass # Unit tests def test_enqueue(): cq = CircularQueue(5) assert cq.enqueue(10) == True assert cq.enqueue(20) == True assert cq.enqueue(30) == True assert cq.enqueue(40) == True assert cq.enqueue(50) == True assert cq.enqueue(60) == False # Queue should be full now assert cq.isFull() == True def test_dequeue(): cq = CircularQueue(5) cq.enqueue(10) cq.enqueue(20) cq.enqueue(30) assert cq.dequeue() == 10 assert cq.dequeue() == 20 assert cq.dequeue() == 30 assert cq.dequeue() == False # Queue should be empty now assert cq.isEmpty() == True def test_front(): cq = CircularQueue(5) assert cq.Front() == -1 # Queue is empty cq.enqueue(10) assert cq.Front() == 10 cq.enqueue(20) assert cq.Front() == 10 # Front should still be 10 cq.dequeue() assert cq.Front() == 20 # Now front should be 20 def test_rear(): cq = CircularQueue(5) assert cq.Rear() == -1 # Queue is empty cq.enqueue(10) assert cq.Rear() == 10 cq.enqueue(20) assert cq.Rear() == 20 # Rear should be 20 cq.dequeue() cq.dequeue() assert cq.Rear() == -1 # Queue is empty def test_isFull(): cq = CircularQueue(5) assert cq.isFull() == False cq.enqueue(10) cq.enqueue(20) cq.enqueue(30) cq.enqueue(40) cq.enqueue(50) assert cq.isFull() == True def test_isEmpty(): cq = CircularQueue(5) assert cq.isEmpty() == True cq.enqueue(10) assert cq.isEmpty() == False cq.dequeue() assert cq.isEmpty() == True def test_wrap_around(): cq = CircularQueue(3) cq.enqueue(10) cq.enqueue(20) cq.enqueue(30) assert cq.isFull() == True assert cq.dequeue() == 10 assert cq.isFull() == False cq.enqueue(40) assert cq.isFull() == True assert cq.Front() == 20 assert cq.Rear() == 40 cq.dequeue() assert cq.Front() == 30 cq.dequeue() assert cq.Front() == 40 cq.dequeue() assert cq.isEmpty() == True","solution":"class CircularQueue: def __init__(self, k): Initialize the queue with a given size k. self.size = k self.queue = [None] * k self.front = self.rear = -1 def enqueue(self, value): Add an element to the end of the queue. if self.isFull(): return False if self.front == -1: self.front = 0 self.rear = (self.rear + 1) % self.size self.queue[self.rear] = value return True def dequeue(self): Remove an element from the front of the queue. if self.isEmpty(): return False value = self.queue[self.front] if self.front == self.rear: self.front = self.rear = -1 else: self.front = (self.front + 1) % self.size return value def Front(self): Get the front item from the queue. if self.isEmpty(): return -1 return self.queue[self.front] def Rear(self): Get the last item from the queue. if self.isEmpty(): return -1 return self.queue[self.rear] def isFull(self): Check if the queue is full. return (self.rear + 1) % self.size == self.front def isEmpty(self): Check if the queue is empty. return self.front == -1"},{"question":"def book_tickets(current_bookings: dict, requested_seats: dict) -> dict: Updates the current bookings based on the requested seats. Args: current_bookings (dict): Current booking status, where keys are row numbers (int) and values are lists of booked seat numbers (int) in that row. requested_seats (dict): Requested seats to be booked, with the same structure as current_bookings. Returns: dict: Updated booking status. >>> current_bookings = { ... 1: [1, 2, 5], ... 2: [3], ... 3: [6, 7, 8] ... } >>> requested_seats = { ... 1: [3, 4, 2, 2], ... 2: [1, 4], ... 3: [6, 9] ... } >>> book_tickets(current_bookings, requested_seats) { 1: [1, 2, 5, 3, 4], 2: [3, 1, 4], 3: [6, 7, 8, 9] } >>> current_bookings = { ... 1: [1, 2], ... 2: [3, 5], ... } >>> requested_seats = { ... 1: [3, 4], ... 2: [6], ... } >>> book_tickets(current_bookings, requested_seats) { 1: [1, 2, 3, 4], 2: [3, 5, 6] } >>> current_bookings = { ... 1: [1, 2, 3], ... 2: [4], ... } >>> requested_seats = { ... 1: [2, 4], ... 2: [3, 4], ... } >>> book_tickets(current_bookings, requested_seats) { 1: [1, 2, 3, 4], 2: [4, 3] } >>> current_bookings = {} >>> requested_seats = { ... 1: [1, 2], ... 2: [4, 6], ... } >>> book_tickets(current_bookings, requested_seats) { 1: [1, 2], 2: [4, 6] } >>> current_bookings = { ... 1: [1, 2, 3], ... 2: [4], ... } >>> requested_seats = {} >>> book_tickets(current_bookings, requested_seats) { 1: [1, 2, 3], 2: [4] }","solution":"def book_tickets(current_bookings: dict, requested_seats: dict) -> dict: Updates the current bookings based on the requested seats. Args: current_bookings (dict): Current booking status, where keys are row numbers (int) and values are lists of booked seat numbers (int) in that row. requested_seats (dict): Requested seats to be booked, with the same structure as current_bookings. Returns: dict: Updated booking status. for row, requested in requested_seats.items(): if row not in current_bookings: current_bookings[row] = [] # Add requested seats to the current bookings if they are not already booked for seat in requested: if seat not in current_bookings[row]: current_bookings[row].append(seat) return current_bookings"},{"question":"class InsufficientFundsException(Exception): Exception raised when attempting to withdraw more than the available balance. pass class AccountNotFoundException(Exception): Exception raised when an account number is not found. pass class Bank: def __init__(self): self.accounts = {} def create_account(self, account_number, initial_balance): Create a new account with a unique account number and an initial balance. Args: account_number (str): The account number. initial_balance (float): The initial balance. Raises: ValueError: If the account number already exists. pass def deposit(self, account_number, amount): Deposit a specified amount into an account. Args: account_number (str): The account number. amount (float): The amount to deposit. Raises: AccountNotFoundException: If the account number does not exist. ValueError: If the deposit amount is not positive. pass def withdraw(self, account_number, amount): Withdraw a specified amount from an account, ensuring the account has sufficient funds. Args: account_number (str): The account number. amount (float): The amount to withdraw. Raises: AccountNotFoundException: If the account number does not exist. ValueError: If the withdrawal amount is not positive. InsufficientFundsException: If the account has insufficient funds. pass def check_balance(self, account_number): Check and return the current balance of an account. Args: account_number (str): The account number. Raises: AccountNotFoundException: If the account number does not exist. Returns: float: The current balance. pass def main(): Command line interface logic for the banking system. bank = Bank() while True: command = input(\\"Enter command (create, deposit, withdraw, balance, exit): \\") if command == \\"create\\": account_number = input(\\"Enter account number: \\") initial_balance = float(input(\\"Enter initial balance: \\")) bank.create_account(account_number, initial_balance) elif command == \\"deposit\\": account_number = input(\\"Enter account number: \\") amount = float(input(\\"Enter deposit amount: \\")) bank.deposit(account_number, amount) elif command == \\"withdraw\\": account_number = input(\\"Enter account number: \\") amount = float(input(\\"Enter withdrawal amount: \\")) bank.withdraw(account_number, amount) elif command == \\"balance\\": account_number = input(\\"Enter account number: \\") print(f\\"Current balance: {bank.check_balance(account_number)}\\") elif command == \\"exit\\": break","solution":"class InsufficientFundsException(Exception): pass class AccountNotFoundException(Exception): pass class Bank: def __init__(self): self.accounts = {} def create_account(self, account_number, initial_balance): if account_number in self.accounts: raise ValueError(\\"Account number already exists.\\") self.accounts[account_number] = initial_balance def deposit(self, account_number, amount): if account_number not in self.accounts: raise AccountNotFoundException(\\"Account not found.\\") if amount <= 0: raise ValueError(\\"Deposit amount must be positive.\\") self.accounts[account_number] += amount def withdraw(self, account_number, amount): if account_number not in self.accounts: raise AccountNotFoundException(\\"Account not found.\\") if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive.\\") if self.accounts[account_number] < amount: raise InsufficientFundsException(\\"Insufficient funds.\\") self.accounts[account_number] -= amount def check_balance(self, account_number): if account_number not in self.accounts: raise AccountNotFoundException(\\"Account not found.\\") return self.accounts[account_number] # This section is for the command line interface, which won't be tested in unit tests. def main(): # Command line interface logic: bank = Bank() while True: command = input(\\"Enter command (create, deposit, withdraw, balance, exit): \\") if command == \\"create\\": account_number = input(\\"Enter account number: \\") initial_balance = float(input(\\"Enter initial balance: \\")) bank.create_account(account_number, initial_balance) elif command == \\"deposit\\": account_number = input(\\"Enter account number: \\") amount = float(input(\\"Enter deposit amount: \\")) bank.deposit(account_number, amount) elif command == \\"withdraw\\": account_number = input(\\"Enter account number: \\") amount = float(input(\\"Enter withdrawal amount: \\")) bank.withdraw(account_number, amount) elif command == \\"balance\\": account_number = input(\\"Enter account number: \\") print(f\\"Current balance: {bank.check_balance(account_number)}\\") elif command == \\"exit\\": break"},{"question":"class BookCollection: A class to represent a collection of books. Each book is represented as a dictionary containing keys such as 'title', 'author', 'pages', and 'genre'. Methods: add_book(book): Adds a new book to the collection. remove_book(title): Removes a book given its title. find_book_by_title(title): Finds a book by its title and returns its details. list_books_by_genre(genre): Lists all books of a particular genre. total_pages(): Calculates the total number of pages across all books in the collection. def __init__(self): self.books = [] def add_book(self, book): pass def remove_book(self, title): pass def find_book_by_title(self, title): pass def list_books_by_genre(self, genre): pass def total_pages(self): pass import pytest def test_add_book_success(): collection = BookCollection() book = {\\"title\\": \\"Book1\\", \\"author\\": \\"Author1\\", \\"pages\\": 100, \\"genre\\": \\"Fiction\\"} collection.add_book(book) assert collection.find_book_by_title(\\"Book1\\") == book def test_add_book_missing_details(): collection = BookCollection() book = {\\"title\\": \\"Book2\\", \\"author\\": \\"Author2\\", \\"genre\\": \\"Non-Fiction\\"} with pytest.raises(ValueError): collection.add_book(book) def test_add_duplicate_book(): collection = BookCollection() book = {\\"title\\": \\"Book3\\", \\"author\\": \\"Author3\\", \\"pages\\": 200, \\"genre\\": \\"Sci-Fi\\"} collection.add_book(book) with pytest.raises(ValueError): collection.add_book(book) def test_remove_book_success(): collection = BookCollection() book = {\\"title\\": \\"Book4\\", \\"author\\": \\"Author4\\", \\"pages\\": 150, \\"genre\\": \\"Mystery\\"} collection.add_book(book) collection.remove_book(\\"Book4\\") assert collection.find_book_by_title(\\"Book4\\") is None def test_remove_nonexistent_book(): collection = BookCollection() with pytest.raises(ValueError): collection.remove_book(\\"Nonexistent Book\\") def test_find_book_by_title_success(): collection = BookCollection() book = {\\"title\\": \\"Book5\\", \\"author\\": \\"Author5\\", \\"pages\\": 250, \\"genre\\": \\"Fantasy\\"} collection.add_book(book) assert collection.find_book_by_title(\\"Book5\\") == book def test_find_book_by_title_nonexistent(): collection = BookCollection() assert collection.find_book_by_title(\\"Nonexistent Book\\") is None def test_list_books_by_genre(): collection = BookCollection() book1 = {\\"title\\": \\"Book6\\", \\"author\\": \\"Author6\\", \\"pages\\": 300, \\"genre\\": \\"Drama\\"} book2 = {\\"title\\": \\"Book7\\", \\"author\\": \\"Author7\\", \\"pages\\": 350, \\"genre\\": \\"Drama\\"} book3 = {\\"title\\": \\"Book8\\", \\"author\\": \\"Author8\\", \\"pages\\": 400, \\"genre\\": \\"Action\\"} collection.add_book(book1) collection.add_book(book2) collection.add_book(book3) assert collection.list_books_by_genre(\\"Drama\\") == [book1, book2] assert collection.list_books_by_genre(\\"Action\\") == [book3] def test_total_pages(): collection = BookCollection() book1 = {\\"title\\": \\"Book9\\", \\"author\\": \\"Author9\\", \\"pages\\": 100, \\"genre\\": \\"History\\"} book2 = {\\"title\\": \\"Book10\\", \\"author\\": \\"Author10\\", \\"pages\\": 150, \\"genre\\": \\"History\\"} collection.add_book(book1) collection.add_book(book2) assert collection.total_pages() == 250","solution":"class BookCollection: def __init__(self): self.books = [] def add_book(self, book): if not all (k in book for k in (\\"title\\", \\"author\\", \\"pages\\", \\"genre\\")): raise ValueError(\\"Book must have title, author, pages, and genre.\\") if any(b['title'] == book['title'] for b in self.books): raise ValueError(\\"Book with this title already exists.\\") self.books.append(book) def remove_book(self, title): for book in self.books: if book['title'] == title: self.books.remove(book) return raise ValueError(\\"Book not found.\\") def find_book_by_title(self, title): for book in self.books: if book['title'] == title: return book return None def list_books_by_genre(self, genre): return [book for book in self.books if book['genre'] == genre] def total_pages(self): return sum(book['pages'] for book in self.books)"},{"question":"import pandas as pd def process_transactions(input_csv: str, output_csv: str) -> None: Processes the transaction data to calculate monthly total sales for each product category. Args: input_csv (str): Path to the input CSV file containing transaction data. output_csv (str): Path to the output CSV file to save the aggregated results. Returns: None pass # Your implementation here def test_process_transactions(): input_csv = 'test_transactions.csv' output_csv = 'test_output.csv' data = [ {'transaction_id': 1, 'date_time': '2023-01-10 10:00:00', 'product_id': 'P1', 'category': 'Electronics', 'amount': 100.0}, {'transaction_id': 2, 'date_time': '2023-01-15 12:00:00', 'product_id': 'P2', 'category': 'Books', 'amount': 50.0}, {'transaction_id': 3, 'date_time': '2023-02-20 15:00:00', 'product_id': 'P3', 'category': 'Electronics', 'amount': 200.0}, {'transaction_id': 4, 'date_time': '2023-02-22 10:30:00', 'product_id': 'P4', 'category': 'Books', 'amount': 75.0}, {'transaction_id': 5, 'date_time': '2023-03-05 08:00:00', 'product_id': 'P5', 'category': 'Clothing', 'amount': 150.0}, {'transaction_id': 6, 'date_time': 'invalid_date_time', 'product_id': 'P6', 'category': 'Electronics', 'amount': 75.0}, {'transaction_id': 7, 'date_time': '2023-03-15 13:45:00', 'product_id': 'P7', 'category': 'Clothing', 'amount': None}, ] create_test_csv(input_csv, data) process_transactions(input_csv, output_csv) result_df = pd.read_csv(output_csv) expected_data = [ {'month': '2023-01', 'category': 'Books', 'total_sales': 50.0}, {'month': '2023-01', 'category': 'Electronics', 'total_sales': 100.0}, {'month': '2023-02', 'category': 'Books', 'total_sales': 75.0}, {'month': '2023-02', 'category': 'Electronics', 'total_sales': 200.0}, {'month': '2023-03', 'category': 'Clothing', 'total_sales': 150.0}, ] expected_df = pd.DataFrame(expected_data) assert result_df.equals(expected_df), \\"The result data frame does not match the expected output.\\" # Clean up test files os.remove(input_csv) os.remove(output_csv) def test_missing_columns(): input_csv = 'test_missing_columns.csv' output_csv = 'test_output.csv' data = [ {'transaction_id': 1, 'date_time': '2023-01-10 10:00:00', 'product_id': 'P1', 'amount': 100.0}, {'transaction_id': 2, 'date_time': '2023-01-15 12:00:00', 'product_id': 'P2', 'amount': 50.0}, ] create_test_csv(input_csv, data) try: process_transactions(input_csv, output_csv) except ValueError as e: assert str(e) == \\"Missing columns in input CSV: category\\", \\"The function did not raise the expected ValueError for missing columns.\\" # Clean up test file os.remove(input_csv)","solution":"import pandas as pd def process_transactions(input_csv, output_csv): Processes the transaction data to calculate monthly total sales for each product category. Args: input_csv (str): Path to the input CSV file containing transaction data. output_csv (str): Path to the output CSV file to save the aggregated results. Returns: None try: # Read the transaction data from the input CSV file data = pd.read_csv(input_csv) # Ensure that required columns are present required_columns = ['transaction_id', 'date_time', 'product_id', 'category', 'amount'] missing_columns = [col for col in required_columns if col not in data.columns] if missing_columns: raise ValueError(f\\"Missing columns in input CSV: {', '.join(missing_columns)}\\") # Parse the date_time field to extract month and year data['date_time'] = pd.to_datetime(data['date_time'], errors='coerce') data['month'] = data['date_time'].dt.to_period('M') # Filter out rows with invalid date_time or amount data = data.dropna(subset=['date_time', 'amount']) # Aggregate total sales for each product category by month aggregated_data = data.groupby(['month', 'category'])['amount'].sum().reset_index() aggregated_data.columns = ['month', 'category', 'total_sales'] # Convert the 'month' back to string for CSV writing aggregated_data['month'] = aggregated_data['month'].astype(str) # Output the result as a new CSV file aggregated_data.to_csv(output_csv, index=False) except Exception as e: print(f\\"An error occurred: {e}\\")"},{"question":"class Library: Library Management System that evaluates book borrowing feasibility based on user account status, book availability, and borrowing rules. >>> lib = Library() >>> lib.add_user('Alice', 'regular') >>> lib.add_book('Python 101') >>> lib.borrow_book('Alice', 'Python 101') # ('approved', '') >>> lib = Library() >>> lib.add_book('Python 101') >>> lib.borrow_book('Unknown', 'Python 101') # ('denied', 'User not found') >>> lib = Library() >>> lib.add_user('Alice', 'regular') >>> lib.borrow_book('Alice', 'Unknown Book') # ('denied', 'Book not found') >>> lib = Library() >>> lib.add_user('Alice', 'regular') >>> lib.add_book('Python 101') >>> lib.block_user('Alice') >>> lib.borrow_book('Alice', 'Python 101') # ('denied', 'User is blocked due to overdue books') >>> lib = Library() >>> lib.add_user('Alice', 'regular') >>> for i in range(5): >>> lib.add_book(f'Book {i}') >>> lib.borrow_book('Alice', f'Book {i}') >>> lib.add_book('Book 6') >>> lib.borrow_book('Alice', 'Book 6') # ('denied', 'Borrowing limit reached') >>> lib = Library() >>> lib.add_user('Alice', 'regular') >>> lib.add_user('Bob', 'regular') >>> lib.add_book('Python 101') >>> lib.borrow_book('Bob', 'Python 101') >>> lib.borrow_book('Alice', 'Python 101') # ('denied', 'Book already checked out') >>> lib = Library() >>> lib.add_user('Alice', 'regular') >>> lib.add_user('Bob', 'regular') >>> lib.add_book('Python 101') >>> lib.books['Python 101']['hold_by'] = 'Bob' >>> lib.borrow_book('Alice', 'Python 101') # ('denied', 'Book is on hold by another user') >>> lib = Library() >>> lib.add_user('Alice', 'regular') >>> lib.add_book('Python 101', reserved_for='premium') >>> lib.borrow_book('Alice', 'Python 101') # ('denied', 'Book is reserved for premium members only') >>> lib = Library() >>> lib.add_user('Alice', 'regular') >>> lib.add_book('Python 101') >>> lib.borrow_book('Alice', 'Python 101') >>> lib.return_book('Alice', 'Python 101') # ('approved', '') >>> lib = Library() >>> lib.add_user('Alice', 'regular') >>> lib.add_book('Python 101') >>> lib.return_book('Alice', 'Python 101') # ('denied', 'Book was not borrowed by the user') >>> lib = Library() >>> lib.add_user('Alice', 'regular') >>> lib.add_book('Python 101') >>> lib.borrow_book('Alice', 'Python 101') >>> lib.extend_borrowing('Alice', 'Python 101') # ('approved', '') >>> lib = Library() >>> lib.add_user('Alice', 'regular') >>> lib.add_book('Python 101') >>> lib.extend_borrowing('Alice', 'Python 101') # ('denied', 'Book is not borrowed by the user') >>> lib = Library() >>> lib.add_user('Alice', 'regular') >>> lib.add_user('Bob', 'regular') >>> lib.add_book('Python 101') >>> lib.borrow_book('Alice', 'Python 101') >>> lib.books['Python 101']['hold_by'] = 'Bob' >>> lib.extend_borrowing('Alice', 'Python 101') # ('denied', 'Book is on hold by another user') def __init__(self): pass def add_book(self, title, reserved_for=None): pass def add_user(self, name, membership_type): pass def borrow_book(self, user, book_title): pass def return_book(self, user, book_title): pass def extend_borrowing(self, user, book_title): pass def block_user(self, user): pass def unblock_user(self, user): pass","solution":"class Library: def __init__(self): self.books = {} self.membership_limits = {'regular': 5, 'premium': 10} self.users = {} def add_book(self, title, reserved_for=None): self.books[title] = { 'available': True, 'reserved_for': reserved_for, 'hold_by': None, 'checked_out_by': None } def add_user(self, name, membership_type): self.users[name] = { 'membership_type': membership_type, 'borrowed_books': [], 'blocked': False } def borrow_book(self, user, book_title): if user not in self.users: return ('denied', 'User not found') if book_title not in self.books: return ('denied', 'Book not found') user_data = self.users[user] book_data = self.books[book_title] if user_data['blocked']: return ('denied', 'User is blocked due to overdue books') if len(user_data['borrowed_books']) >= self.membership_limits[user_data['membership_type']]: return ('denied', 'Borrowing limit reached') if book_data['checked_out_by']: return ('denied', 'Book already checked out') if book_data['hold_by'] and book_data['hold_by'] != user: return ('denied', \\"Book is on hold by another user\\") if book_data['reserved_for'] and book_data['reserved_for'] != user_data['membership_type']: return ('denied', f\\"Book is reserved for {book_data['reserved_for']} members only\\") book_data['available'] = False book_data['checked_out_by'] = user user_data['borrowed_books'].append(book_title) return ('approved', '') def return_book(self, user, book_title): if book_title in self.users[user]['borrowed_books']: self.users[user]['borrowed_books'].remove(book_title) self.books[book_title]['checked_out_by'] = None self.books[book_title]['available'] = True return ('approved', '') return ('denied', 'Book was not borrowed by the user') def extend_borrowing(self, user, book_title): user_data = self.users[user] book_data = self.books[book_title] if book_data['checked_out_by'] != user: return ('denied', 'Book is not borrowed by the user') if book_data['hold_by']: return ('denied', 'Book is on hold by another user') return ('approved', '') def block_user(self, user): self.users[user]['blocked'] = True def unblock_user(self, user): self.users[user]['blocked'] = False"},{"question":"import requests import asyncio import json import matplotlib.pyplot as plt import websockets import numpy as np class IoTDataManager: def __init__(self, api_url): self.api_url = api_url self.data = [] async def fetch_data(self): Asynchronously fetch data from the IoT sensor's websocket endpoint. async with websockets.connect(f'{self.api_url}/ws/data') as websocket: async for message in websocket: self.data.append(json.loads(message)) await asyncio.sleep(0.1) # Simulating processing time def filter_data(self, start_timestamp, end_timestamp): Filter the data for records within the specified time range (inclusive). return [record for record in self.data if start_timestamp <= record['timestamp'] <= end_timestamp] def aggregate_data(self): Perform data aggregation to compute min, max, and mean of the sensor values. if not self.data: return {'min': None, 'max': None, 'mean': None} values = [record['value'] for record in self.data] return { 'min': np.min(values), 'max': np.max(values), 'mean': np.mean(values) } def detect_anomalies(self, threshold): Detect anomalies in the data where the value exceeds the specified threshold. return [record for record in self.data if record['value'] > threshold] def plot_data(self): Plot the time-series data. if not self.data: print(\\"No data to plot.\\") return timestamps = [record['timestamp'] for record in self.data] values = [record['value'] for record in self.data] plt.plot(timestamps, values) plt.xlabel('Timestamp') plt.ylabel('Values') plt.title('IoT Sensor Data') plt.show() # Unit Testing from solution import IoTDataManager import asyncio import pytest # Mock data for testing mock_data = [ {'timestamp': 1622505600, 'value': 10}, {'timestamp': 1622592000, 'value': 20}, {'timestamp': 1622678400, 'value': 30}, {'timestamp': 1622764800, 'value': 40}, {'timestamp': 1622851200, 'value': 50} ] async def fetch_mock_data(manager): for data in mock_data: manager.data.append(data) await asyncio.sleep(0.01) @pytest.fixture async def manager_with_mock_data(): manager = IoTDataManager(\\"http://localhost:8000/api\\") await fetch_mock_data(manager) return manager def test_filter_data(manager_with_mock_data): manager = asyncio.run(manager_with_mock_data) filtered = manager.filter_data(1622592000, 1622764800) assert len(filtered) == 3 assert filtered[0]['value'] == 20 assert filtered[2]['value'] == 40 def test_aggregate_data(manager_with_mock_data): manager = asyncio.run(manager_with_mock_data) aggregation = manager.aggregate_data() assert aggregation['min'] == 10 assert aggregation['max'] == 50 assert aggregation['mean'] == 30 def test_detect_anomalies(manager_with_mock_data): manager = asyncio.run(manager_with_mock_data) anomalies = manager.detect_anomalies(35) assert len(anomalies) == 2 assert anomalies[0]['value'] == 40 assert anomalies[1]['value'] == 50 # As plotting does not return a value, we'll consider it enough to run without errors for the test def test_plot_data(manager_with_mock_data): manager = asyncio.run(manager_with_mock_data) try: manager.plot_data() except Exception: pytest.fail(\\"plot_data() raised Exception unexpectedly!\\")","solution":"import requests import asyncio import json import matplotlib.pyplot as plt import websockets import numpy as np # Module for managing and visualizing IoT sensor data class IoTDataManager: def __init__(self, api_url): self.api_url = api_url self.data = [] async def fetch_data(self): async with websockets.connect(f'{self.api_url}/ws/data') as websocket: async for message in websocket: self.data.append(json.loads(message)) await asyncio.sleep(0.1) # Simulating processing time def filter_data(self, start_time, end_time): filtered_data = [datum for datum in self.data if start_time <= datum['timestamp'] <= end_time] return filtered_data def aggregate_data(self): data = np.array(self.data) timestamps = [record['timestamp'] for record in data] values = [record['value'] for record in data] return { 'min': np.min(values), 'max': np.max(values), 'mean': np.mean(values) } def detect_anomalies(self, threshold): anomalies = [record for record in self.data if record['value'] > threshold] return anomalies def plot_data(self): timestamps = [record['timestamp'] for record in self.data] values = [record['value'] for record in self.data] plt.plot(timestamps, values) plt.xlabel('Timestamp') plt.ylabel('Values') plt.title('IoT Sensor Data') plt.show() # Example usage: async def main(): manager = IoTDataManager(\\"http://localhost:8000/api\\") await manager.fetch_data() print(\\"Filtered Data: \\", manager.filter_data(1622505600, 1625097600)) print(\\"Aggregate Data: \\", manager.aggregate_data()) print(\\"Anomalies: \\", manager.detect_anomalies(50)) manager.plot_data() # Uncomment the following line to run the example # asyncio.run(main())"},{"question":"import xml.etree.ElementTree as ET def parse_xml_to_dict(xml_string: str) -> dict: Parses an XML string and outputs a dictionary where each key is a tag name and the value is a list of attributes dictionaries for that tag. Args: xml_string (str): A string representation of the XML data. Returns: dict: A dictionary with tag names as keys and lists of attribute dictionaries as values. Examples: >>> parse_xml_to_dict('<root><child id=\\"1\\" name=\\"child1\\"/><child id=\\"2\\" name=\\"child2\\"><subchild id=\\"3\\" name=\\"subchild1\\"/></child></root>') { 'root': [{}], 'child': [{'id': '1', 'name': 'child1'}, {'id': '2', 'name': 'child2'}], 'subchild': [{'id': '3', 'name': 'subchild1'}] } pass def test_single_tag(): xml_string = '<root/>' expected = {'root': [{}]} assert parse_xml_to_dict(xml_string) == expected def test_single_tag_with_attributes(): xml_string = '<root id=\\"1\\" name=\\"root\\"/>' expected = {'root': [{'id': '1', 'name': 'root'}]} assert parse_xml_to_dict(xml_string) == expected def test_nested_tags(): xml_string = <root> <child id=\\"1\\" name=\\"child1\\"/> <child id=\\"2\\" name=\\"child2\\"> <subchild id=\\"3\\" name=\\"subchild1\\"/> </child> </root> expected = { 'root': [{}], 'child': [{'id': '1', 'name': 'child1'}, {'id': '2', 'name': 'child2'}], 'subchild': [{'id': '3', 'name': 'subchild1'}] } assert parse_xml_to_dict(xml_string) == expected def test_multiple_nested_tags(): xml_string = <root> <child id=\\"1\\" name=\\"child1\\"/> <child id=\\"2\\" name=\\"child2\\"> <subchild id=\\"3\\" name=\\"subchild1\\"/> <subchild id=\\"4\\" name=\\"subchild2\\"/> </child> </root> expected = { 'root': [{}], 'child': [{'id': '1', 'name': 'child1'}, {'id': '2', 'name': 'child2'}], 'subchild': [{'id': '3', 'name': 'subchild1'}, {'id': '4', 'name': 'subchild2'}] } assert parse_xml_to_dict(xml_string) == expected def test_empty_tags(): xml_string = <root> <child/> <child id=\\"2\\" name=\\"child2\\"> <subchild id=\\"3\\" name=\\"subchild1\\"/> </child> </root> expected = { 'root': [{}], 'child': [{} ,{'id': '2', 'name': 'child2'}], 'subchild': [{'id': '3', 'name': 'subchild1'}] } assert parse_xml_to_dict(xml_string) == expected","solution":"import xml.etree.ElementTree as ET def parse_xml_to_dict(xml_string: str) -> dict: def recursive_parse(element, result): tag_name = element.tag if tag_name not in result: result[tag_name] = [] attributes = element.attrib result[tag_name].append(attributes) for child in element: recursive_parse(child, result) root = ET.fromstring(xml_string) result = {} recursive_parse(root, result) return result"},{"question":"from typing import List, Tuple class StockMarket: def __init__(self): Initialize the stock market with necessary data structures to track stock prices. pass def record_price(self, stock_name: str, price: float) -> None: Records the price of a specified stock at the current time point. Args: stock_name (str): The name of the stock. price (float): The price of the stock. pass def current_price(self, stock_name: str) -> float: Returns the current price of the specified stock. Args: stock_name (str): The name of the stock. Returns: float: The current price of the stock, or None if the stock has no recorded prices. pass def average_price(self, stock_name: str, k: int) -> float: Returns the average price of the specified stock over the last \`k\` recorded prices. Args: stock_name (str): The name of the stock. k (int): Number of recent time points to consider. Returns: float: Average price, or None if there are no recorded prices. pass def high_low_price(self, stock_name: str) -> Tuple[float, float]: Returns the highest and lowest prices recorded for the specified stock. Args: stock_name (str): The name of the stock. Returns: Tuple[float, float]: The highest and lowest prices, or (None, None) if there are no recorded prices. pass def transaction_volume(self, stock_name: str) -> int: Returns the total number of transactions (count of recorded prices) for the specified stock. Args: stock_name (str): The name of the stock. Returns: int: The volume of transactions, or None if there are no recorded prices. pass # Testing def test_record_price(): sm = StockMarket() sm.record_price('AAPL', 150.0) assert sm.prices['AAPL'] == [150.0] def test_current_price(): sm = StockMarket() sm.record_price('AAPL', 150.0) sm.record_price('AAPL', 152.0) assert sm.current_price('AAPL') == 152.0 assert sm.current_price('GOOG') is None def test_average_price(): sm = StockMarket() sm.record_price('AAPL', 150.0) sm.record_price('AAPL', 152.0) sm.record_price('AAPL', 154.0) sm.record_price('AAPL', 156.0) assert sm.average_price('AAPL', 2) == 155.0 assert sm.average_price('AAPL', 4) == 153.0 assert sm.average_price('AAPL', 10) == 153.0 assert sm.average_price('GOOG', 4) is None def test_high_low_price(): sm = StockMarket() sm.record_price('AAPL', 150.0) sm.record_price('AAPL', 152.0) sm.record_price('AAPL', 148.0) sm.record_price('AAPL', 156.0) assert sm.high_low_price('AAPL') == (156.0, 148.0) assert sm.high_low_price('GOOG') == (None, None) def test_transaction_volume(): sm = StockMarket() sm.record_price('AAPL', 150.0) sm.record_price('AAPL', 152.0) assert sm.transaction_volume('AAPL') == 2 assert sm.transaction_volume('GOOG') is None","solution":"from collections import defaultdict from typing import List, Tuple class StockMarket: def __init__(self): self.prices = defaultdict(list) def record_price(self, stock_name: str, price: float) -> None: Records the price of a specified stock at the current time point. self.prices[stock_name].append(price) def current_price(self, stock_name: str) -> float: Returns the current price of the specified stock. if stock_name not in self.prices or len(self.prices[stock_name]) == 0: return None return self.prices[stock_name][-1] def average_price(self, stock_name: str, k: int) -> float: Returns the average price of the specified stock over the last \`k\` recorded prices. if stock_name not in self.prices or len(self.prices[stock_name]) == 0: return None return sum(self.prices[stock_name][-k:]) / min(k, len(self.prices[stock_name])) def high_low_price(self, stock_name: str) -> Tuple[float, float]: Returns the highest and lowest prices recorded for the specified stock. if stock_name not in self.prices or len(self.prices[stock_name]) == 0: return None, None return (max(self.prices[stock_name]), min(self.prices[stock_name])) def transaction_volume(self, stock_name: str) -> int: Returns the total number of transactions (count of recorded prices) for the specified stock. if stock_name not in self.prices: return None return len(self.prices[stock_name])"},{"question":"import sqlite3 from contextlib import contextmanager from typing import List, Tuple, Optional @contextmanager def open_connection(db_name: str): Context manager for opening and closing the SQLite database connection. conn = sqlite3.connect(db_name) try: yield conn finally: conn.close() def create_books_table(db_name: str): Create the books table in the SQLite database. with open_connection(db_name) as conn: cursor = conn.cursor() cursor.execute(''' CREATE TABLE IF NOT EXISTS books ( id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT NOT NULL, author TEXT NOT NULL, publication_date TEXT NOT NULL, genre TEXT NOT NULL ) ''') conn.commit() def add_book(db_name: str, title: str, author: str, publication_date: str, genre: str): Add a new book to the books table. # Function implementation goes here def get_book(db_name: str, book_id: int) -> Optional[Tuple[int, str, str, str, str]]: Get a book by its ID. # Function implementation goes here def update_book(db_name: str, book_id: int, title: str, author: str, publication_date: str, genre: str): Update an existing book's details. # Function implementation goes here def delete_book(db_name: str, book_id: int): Delete a book by its ID. # Function implementation goes here def search_books_by_title_author(db_name: str, search_term: str) -> List[Tuple[int, str, str, str, str]]: Search for books by title or author. # Function implementation goes here def list_books_by_date_range(db_name: str, start_date: str, end_date: str) -> List[Tuple[int, str, str, str, str]]: List all books published within a specific date range. # Function implementation goes here # Sample Usage: # create_books_table('library.db') Test Cases: import os import pytest from solution import ( create_books_table, add_book, get_book, update_book, delete_book, search_books_by_title_author, list_books_by_date_range ) DB_NAME = 'test_library.db' @pytest.fixture(scope='module', autouse=True) def setup_db(): # Create a temporary database for testing create_books_table(DB_NAME) yield # Teardown the temporary database os.remove(DB_NAME) def test_add_and_get_book(): add_book(DB_NAME, 'Test Title', 'Test Author', '2023-01-01', 'Fiction') book = get_book(DB_NAME, 1) assert book == (1, 'Test Title', 'Test Author', '2023-01-01', 'Fiction') def test_update_book(): add_book(DB_NAME, 'Another Title', 'Another Author', '2023-02-01', 'Non-Fiction') update_book(DB_NAME, 2, 'Updated Title', 'Updated Author', '2023-02-02', 'Science Fiction') book = get_book(DB_NAME, 2) assert book == (2, 'Updated Title', 'Updated Author', '2023-02-02', 'Science Fiction') def test_delete_book(): add_book(DB_NAME, 'Title to Delete', 'Author to Delete', '2023-03-01', 'History') delete_book(DB_NAME, 3) book = get_book(DB_NAME, 3) assert book is None def test_search_books_by_title_author(): add_book(DB_NAME, 'Search Title', 'Search Author', '2023-04-01', 'Biography') results = search_books_by_title_author(DB_NAME, 'Search') assert len(results) == 1 assert results[0][1] == 'Search Title' assert results[0][2] == 'Search Author' def test_list_books_by_date_range(): add_book(DB_NAME, 'Date Range Title 1', 'Date Range Author 1', '2023-05-01', 'Adventure') add_book(DB_NAME, 'Date Range Title 2', 'Date Range Author 2', '2023-06-01', 'Fantasy') results = list_books_by_date_range(DB_NAME, '2023-05-01', '2023-05-31') assert len(results) == 1 assert results[0][1] == 'Date Range Title 1' assert results[0][2] == 'Date Range Author 1'","solution":"import sqlite3 from contextlib import contextmanager @contextmanager def open_connection(db_name): conn = sqlite3.connect(db_name) try: yield conn finally: conn.close() def create_books_table(db_name): with open_connection(db_name) as conn: cursor = conn.cursor() cursor.execute(''' CREATE TABLE IF NOT EXISTS books ( id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT NOT NULL, author TEXT NOT NULL, publication_date TEXT NOT NULL, genre TEXT NOT NULL ) ''') conn.commit() def add_book(db_name, title, author, publication_date, genre): with open_connection(db_name) as conn: cursor = conn.cursor() cursor.execute(''' INSERT INTO books (title, author, publication_date, genre) VALUES (?, ?, ?, ?) ''', (title, author, publication_date, genre)) conn.commit() def get_book(db_name, book_id): with open_connection(db_name) as conn: cursor = conn.cursor() cursor.execute(''' SELECT * FROM books WHERE id = ? ''', (book_id,)) return cursor.fetchone() def update_book(db_name, book_id, title, author, publication_date, genre): with open_connection(db_name) as conn: cursor = conn.cursor() cursor.execute(''' UPDATE books SET title = ?, author = ?, publication_date = ?, genre = ? WHERE id = ? ''', (title, author, publication_date, genre, book_id)) conn.commit() def delete_book(db_name, book_id): with open_connection(db_name) as conn: cursor = conn.cursor() cursor.execute(''' DELETE FROM books WHERE id = ? ''', (book_id,)) conn.commit() def search_books_by_title_author(db_name, search_term): with open_connection(db_name) as conn: cursor = conn.cursor() cursor.execute(''' SELECT * FROM books WHERE title LIKE ? OR author LIKE ? ''', (f'%{search_term}%', f'%{search_term}%')) return cursor.fetchall() def list_books_by_date_range(db_name, start_date, end_date): with open_connection(db_name) as conn: cursor = conn.cursor() cursor.execute(''' SELECT * FROM books WHERE publication_date BETWEEN ? AND ? ''', (start_date, end_date)) return cursor.fetchall() # Initialize the database create_books_table('library.db')"},{"question":"from typing import List, Dict def generate_bibliography(books: List[Dict[str, str]]) -> str: Generates a structured bibliographic record from a collection of book titles and authors. :param books: List of dictionaries containing book 'title' and 'author'. :return: A string that lists the books alphabetically by title with each title on a new line followed by the author in parenthesis. :raises ValueError: If the input data format is incorrect. >>> books = [ ... {'title': 'The Catcher in the Rye', 'author': 'J.D. Salinger'}, ... {'title': 'To Kill a Mockingbird', 'author': 'Harper Lee'}, ... {'title': '1984', 'author': 'George Orwell'} ... ] >>> generate_bibliography(books) \\"1984 (George Orwell)nThe Catcher in the Rye (J.D. Salinger)nTo Kill a Mockingbird (Harper Lee)\\" def search_books_by_author(books: List[Dict[str, str]], author: str) -> List[str]: Searches for books by a specific author. :param books: List of dictionaries containing book 'title' and 'author'. :param author: The author to search for. :return: A list of titles by the given author. :raises ValueError: If the input data format is incorrect. >>> books = [ ... {'title': 'The Catcher in the Rye', 'author': 'J.D. Salinger'}, ... {'title': 'To Kill a Mockingbird', 'author': 'Harper Lee'}, ... {'title': 'Go Set a Watchman', 'author': 'Harper Lee'}, ... {'title': '1984', 'author': 'George Orwell'} ... ] >>> search_books_by_author(books, 'Harper Lee') ['To Kill a Mockingbird', 'Go Set a Watchman'] import pytest def test_generate_bibliography(): books = [ {'title': 'The Catcher in the Rye', 'author': 'J.D. Salinger'}, {'title': 'To Kill a Mockingbird', 'author': 'Harper Lee'}, {'title': '1984', 'author': 'George Orwell'} ] expected_result = \\"1984 (George Orwell)nThe Catcher in the Rye (J.D. Salinger)nTo Kill a Mockingbird (Harper Lee)\\" assert generate_bibliography(books) == expected_result def test_generate_bibliography_invalid_input(): books = [ {'title': 'The Catcher in the Rye', 'writer': 'J.D. Salinger'}, # missing 'author' key {'title': 'To Kill a Mockingbird', 'author': 'Harper Lee'}, {'title': '1984', 'author': 'George Orwell'} ] with pytest.raises(ValueError): generate_bibliography(books) def test_search_books_by_author(): books = [ {'title': 'The Catcher in the Rye', 'author': 'J.D. Salinger'}, {'title': 'To Kill a Mockingbird', 'author': 'Harper Lee'}, {'title': 'Go Set a Watchman', 'author': 'Harper Lee'}, {'title': '1984', 'author': 'George Orwell'} ] assert search_books_by_author(books, 'Harper Lee') == ['To Kill a Mockingbird', 'Go Set a Watchman'] assert search_books_by_author(books, 'George Orwell') == ['1984'] def test_search_books_by_author_no_results(): books = [ {'title': 'The Catcher in the Rye', 'author': 'J.D. Salinger'}, {'title': 'To Kill a Mockingbird', 'author': 'Harper Lee'}, {'title': '1984', 'author': 'George Orwell'} ] assert search_books_by_author(books, 'Unknown Author') == [] def test_search_books_by_author_invalid_input(): books = [ {'title': 'The Catcher in the Rye', 'writer': 'J.D. Salinger'}, # missing 'author' key {'title': 'To Kill a Mockingbird', 'author': 'Harper Lee'}, {'title': '1984', 'author': 'George Orwell'} ] with pytest.raises(ValueError): search_books_by_author(books, 'Harper Lee')","solution":"from typing import List, Dict, Any def generate_bibliography(books: List[Dict[str, str]]) -> str: Generates a structured bibliographic record from a collection of book titles and authors. :param books: List of dictionaries containing book 'title' and 'author'. :return: A string that lists the books alphabetically by title with each title on a new line followed by the author in parenthesis. :raises ValueError: If the input data format is incorrect. if not all(isinstance(book, dict) and 'title' in book and 'author' in book for book in books): raise ValueError(\\"Each item in the books list must be a dictionary with 'title' and 'author' keys\\") sorted_books = sorted(books, key=lambda x: x['title']) return 'n'.join(f\\"{book['title']} ({book['author']})\\" for book in sorted_books) def search_books_by_author(books: List[Dict[str, str]], author: str) -> List[str]: Searches for books by a specific author. :param books: List of dictionaries containing book 'title' and 'author'. :param author: The author to search for. :return: A list of titles by the given author. :raises ValueError: If the input data format is incorrect. if not all(isinstance(book, dict) and 'title' in book and 'author' in book for book in books): raise ValueError(\\"Each item in the books list must be a dictionary with 'title' and 'author' keys\\") return [book['title'] for book in books if book['author'] == author]"},{"question":"from datetime import datetime class User: Represents a user with login records and post interactions. Attributes: user_id (int): Unique identifier for the user. username (str): Username of the user. login_records (list): List of LoginRecord objects that contain the login and logout details of the user. post_interactions (list): List of PostInteraction objects that include the user's interactions with posts. def __init__(self, user_id, username): self.user_id = user_id self.username = username self.login_records = [] self.post_interactions = [] def add_login_record(self, login_time, logout_time): Adds a new login record for the user. Args: login_time (datetime): The time when the user logged in. logout_time (datetime): The time when the user logged out. self.login_records.append(LoginRecord(login_time, logout_time, self)) def add_post_interaction(self, post_id, interaction_type, interaction_time): Adds a new post interaction for the user. Args: post_id (int): The ID of the post. interaction_type (str): The type of interaction (e.g., 'like', 'comment', 'share'). interaction_time (datetime): The time when the interaction occurred. self.post_interactions.append(PostInteraction(post_id, interaction_type, interaction_time, self)) def calculate_average_login_duration(self): Calculates the average login duration for the user. Returns: float: The average login duration in seconds. total_duration = 0 for record in self.login_records: total_duration += (record.logout_time - record.login_time).total_seconds() return total_duration / len(self.login_records) if self.login_records else 0 class LoginRecord: Represents a login record for a user. Attributes: login_time (datetime): The time when the user logged in. logout_time (datetime): The time when the user logged out. user (User): The user who logged in and out. def __init__(self, login_time, logout_time, user): self.login_time = login_time self.logout_time = logout_time self.user = user class PostInteraction: Represents a post interaction made by a user. Attributes: post_id (int): The ID of the post. interaction_type (str): The type of interaction (e.g., 'like', 'comment', 'share'). interaction_time (datetime): The time when the interaction occurred. user (User): The user who interacted with the post. def __init__(self, post_id, interaction_type, interaction_time, user): self.post_id = post_id self.interaction_type = interaction_type self.interaction_time = interaction_time self.user = user # Example usage: >>> user = User(1, \\"test_user\\") >>> user.add_login_record(datetime(2023, 1, 1, 10, 0, 0), datetime(2023, 1, 1, 12, 0, 0)) >>> user.calculate_average_login_duration() == 2 * 3600 True >>> user.add_post_interaction(101, \\"like\\", datetime(2023, 1, 1, 10, 30, 0)) >>> len(user.post_interactions) == 1 True","solution":"from datetime import datetime class User: def __init__(self, user_id, username): self.user_id = user_id self.username = username self.login_records = [] self.post_interactions = [] def add_login_record(self, login_time, logout_time): self.login_records.append(LoginRecord(login_time, logout_time, self)) def add_post_interaction(self, post_id, interaction_type, interaction_time): self.post_interactions.append(PostInteraction(post_id, interaction_type, interaction_time, self)) def calculate_average_login_duration(self): total_duration = 0 for record in self.login_records: total_duration += (record.logout_time - record.login_time).total_seconds() return total_duration / len(self.login_records) if self.login_records else 0 class LoginRecord: def __init__(self, login_time, logout_time, user): self.login_time = login_time self.logout_time = logout_time self.user = user class PostInteraction: def __init__(self, post_id, interaction_type, interaction_time, user): self.post_id = post_id self.interaction_type = interaction_type self.interaction_time = interaction_time self.user = user"},{"question":"from typing import List, Dict, Union class Cart: Cart class manages shopping cart operations such as adding and removing items, computing the total cost, applying discount codes, and viewing the cart contents. Methods: add_item(name: str, quantity: int, price_per_unit: float): Adds an item to the cart. remove_item(name: str): Removes an item from the cart by name. compute_total_cost() -> float: Computes the total cost of items in the cart, including discounts. apply_discount(discount_code: str): Applies a percentage-based discount to the total cost. view_cart_contents() -> List[Dict[str, Union[str, int, float]]]: Returns the cart contents. def __init__(self): self.items: List[Dict[str, Union[str, int, float]]] = [] self.applied_discount: float = 0.0 def add_item(self, name: str, quantity: int, price_per_unit: float): Adds an item to the cart. self.items.append({ \\"name\\": name, \\"quantity\\": quantity, \\"price_per_unit\\": price_per_unit }) def remove_item(self, name: str): Removes an item from the cart by name. self.items = [item for item in self.items if item[\\"name\\"] != name] def compute_total_cost(self) -> float: Computes the total cost of items in the cart, including discounts. total = sum(item[\\"quantity\\"] * item[\\"price_per_unit\\"] for item in self.items) if self.applied_discount: total *= (1 - self.applied_discount / 100) return total def apply_discount(self, discount_code: str): Applies a percentage-based discount to the total cost. valid_discounts = { \\"DISCOUNT10\\": 10.0, \\"DISCOUNT20\\": 20.0, \\"DISCOUNT30\\": 30.0 } self.applied_discount = valid_discounts.get(discount_code.upper(), 0.0) def view_cart_contents(self) -> List[Dict[str, Union[str, int, float]]]: Returns the cart contents. return self.items # Unit Tests def test_add_item(): cart = Cart() cart.add_item(\\"Apple\\", 2, 3.0) assert cart.view_cart_contents() == [{\\"name\\": \\"Apple\\", \\"quantity\\": 2, \\"price_per_unit\\": 3.0}] def test_remove_item(): cart = Cart() cart.add_item(\\"Apple\\", 2, 3.0) cart.add_item(\\"Banana\\", 5, 1.0) cart.remove_item(\\"Banana\\") assert cart.view_cart_contents() == [{\\"name\\": \\"Apple\\", \\"quantity\\": 2, \\"price_per_unit\\": 3.0}] def test_compute_total_cost(): cart = Cart() cart.add_item(\\"Apple\\", 2, 3.0) cart.add_item(\\"Banana\\", 5, 1.0) assert cart.compute_total_cost() == 11.0 def test_apply_discount(): cart = Cart() cart.add_item(\\"Apple\\", 2, 3.0) cart.add_item(\\"Banana\\", 5, 1.0) cart.apply_discount(\\"DISCOUNT10\\") assert cart.compute_total_cost() == 9.9 def test_invalid_discount_code(): cart = Cart() cart.add_item(\\"Apple\\", 2, 3.0) cart.add_item(\\"Banana\\", 5, 1.0) cart.apply_discount(\\"INVALID\\") assert cart.compute_total_cost() == 11.0 def test_view_cart_contents(): cart = Cart() cart.add_item(\\"Apple\\", 2, 3.0) cart.add_item(\\"Banana\\", 5, 1.0) expected_contents = [ {\\"name\\": \\"Apple\\", \\"quantity\\": 2, \\"price_per_unit\\": 3.0}, {\\"name\\": \\"Banana\\", \\"quantity\\": 5, \\"price_per_unit\\": 1.0} ] assert cart.view_cart_contents() == expected_contents","solution":"from typing import List, Dict, Union class Cart: def __init__(self): self.items: List[Dict[str, Union[str, int, float]]] = [] self.applied_discount: float = 0.0 def add_item(self, name: str, quantity: int, price_per_unit: float): self.items.append({ \\"name\\": name, \\"quantity\\": quantity, \\"price_per_unit\\": price_per_unit }) def remove_item(self, name: str): self.items = [item for item in self.items if item[\\"name\\"] != name] def compute_total_cost(self) -> float: total = sum(item[\\"quantity\\"] * item[\\"price_per_unit\\"] for item in self.items) if self.applied_discount: total *= (1 - self.applied_discount / 100) return total def apply_discount(self, discount_code: str): valid_discounts = { \\"DISCOUNT10\\": 10.0, \\"DISCOUNT20\\": 20.0, \\"DISCOUNT30\\": 30.0 } self.applied_discount = valid_discounts.get(discount_code.upper(), 0.0) def view_cart_contents(self) -> List[Dict[str, Union[str, int, float]]]: return self.items"},{"question":"class Cookbook: A class to represent a cookbook. It supports adding, removing, retrieving, and listing recipes. Additionally, it can find recipes that can be made from a given list of ingredients. Methods: add_recipe(name, ingredients, steps): Adds a new recipe to the cookbook. remove_recipe(name): Removes a recipe by its name. get_recipe(name): Retrieves the details of a recipe by its name. list_recipes(): Lists all recipe names in the cookbook. find_recipes(available_ingredients): Finds recipes that can be made with the given ingredients. def __init__(self): pass def add_recipe(self, name, ingredients, steps): Adds a new recipe to the cookbook. Args: name (str): The name of the dish. ingredients (list): A list of ingredients. steps (list): Steps to prepare the dish. Returns: str: Success or error message. pass def remove_recipe(self, name): Removes a recipe by its name. Args: name (str): The name of the dish. Returns: str: Success or error message. pass def get_recipe(self, name): Retrieves the details of a recipe by its name. Args: name (str): The name of the dish. Returns: dict: Recipe details or error message. pass def list_recipes(self): Lists all recipe names in the cookbook. Returns: list: List of all recipe names. pass def find_recipes(self, available_ingredients): Finds recipes that can be made with the given ingredients. Args: available_ingredients (list): List of available ingredients. Returns: list: List of recipes that can be made. pass # Unit Tests def test_add_recipe(): cookbook = Cookbook() result = cookbook.add_recipe(\\"Pancakes\\", [\\"Flour\\", \\"Milk\\", \\"Eggs\\"], [\\"Mix ingredients\\", \\"Cook on skillet\\"]) assert result == \\"Recipe for Pancakes added successfully.\\" assert cookbook.get_recipe(\\"Pancakes\\") == { 'ingredients': [\\"Flour\\", \\"Milk\\", \\"Eggs\\"], 'steps': [\\"Mix ingredients\\", \\"Cook on skillet\\"] } def test_add_duplicate_recipe(): cookbook = Cookbook() cookbook.add_recipe(\\"Pancakes\\", [\\"Flour\\", \\"Milk\\", \\"Eggs\\"], [\\"Mix ingredients\\", \\"Cook on skillet\\"]) result = cookbook.add_recipe(\\"Pancakes\\", [\\"Flour\\", \\"Milk\\", \\"Eggs\\"], [\\"Mix ingredients\\", \\"Cook on skillet\\"]) assert result == \\"Recipe for Pancakes already exists.\\" def test_remove_recipe(): cookbook = Cookbook() cookbook.add_recipe(\\"Pancakes\\", [\\"Flour\\", \\"Milk\\", \\"Eggs\\"], [\\"Mix ingredients\\", \\"Cook on skillet\\"]) result = cookbook.remove_recipe(\\"Pancakes\\") assert result == \\"Recipe for Pancakes removed successfully.\\" assert cookbook.get_recipe(\\"Pancakes\\") == \\"Recipe for Pancakes does not exist.\\" def test_remove_nonexistent_recipe(): cookbook = Cookbook() result = cookbook.remove_recipe(\\"NonExistentRecipe\\") assert result == \\"Recipe for NonExistentRecipe does not exist.\\" def test_get_recipe(): cookbook = Cookbook() cookbook.add_recipe(\\"Pancakes\\", [\\"Flour\\", \\"Milk\\", \\"Eggs\\"], [\\"Mix ingredients\\", \\"Cook on skillet\\"]) recipe = cookbook.get_recipe(\\"Pancakes\\") assert recipe == { 'ingredients': [\\"Flour\\", \\"Milk\\", \\"Eggs\\"], 'steps': [\\"Mix ingredients\\", \\"Cook on skillet\\"] } def test_get_nonexistent_recipe(): cookbook = Cookbook() recipe = cookbook.get_recipe(\\"NonExistentRecipe\\") assert recipe == \\"Recipe for NonExistentRecipe does not exist.\\" def test_list_recipes(): cookbook = Cookbook() cookbook.add_recipe(\\"Pancakes\\", [\\"Flour\\", \\"Milk\\", \\"Eggs\\"], [\\"Mix ingredients\\", \\"Cook on skillet\\"]) cookbook.add_recipe(\\"Omelette\\", [\\"Eggs\\", \\"Salt\\", \\"Pepper\\"], [\\"Beat eggs\\", \\"Cook on skillet\\"]) recipes = cookbook.list_recipes() assert set(recipes) == {\\"Pancakes\\", \\"Omelette\\"} def test_find_recipes(): cookbook = Cookbook() cookbook.add_recipe(\\"Pancakes\\", [\\"Flour\\", \\"Milk\\", \\"Eggs\\"], [\\"Mix ingredients\\", \\"Cook on skillet\\"]) cookbook.add_recipe(\\"Omelette\\", [\\"Eggs\\", \\"Salt\\", \\"Pepper\\"], [\\"Beat eggs\\", \\"Cook on skillet\\"]) recipes = cookbook.find_recipes([\\"Flour\\", \\"Milk\\", \\"Eggs\\", \\"Salt\\", \\"Pepper\\"]) assert set(recipes) == {\\"Pancakes\\", \\"Omelette\\"} def test_find_recipes_insufficient_ingredients(): cookbook = Cookbook() cookbook.add_recipe(\\"Pancakes\\", [\\"Flour\\", \\"Milk\\", \\"Eggs\\"], [\\"Mix ingredients\\", \\"Cook on skillet\\"]) recipes = cookbook.find_recipes([\\"Flour\\", \\"Milk\\"]) assert recipes == []","solution":"class Cookbook: def __init__(self): self._recipes = {} def add_recipe(self, name, ingredients, steps): if name in self._recipes: return f\\"Recipe for {name} already exists.\\" self._recipes[name] = { 'ingredients': ingredients, 'steps': steps } return f\\"Recipe for {name} added successfully.\\" def remove_recipe(self, name): if name not in self._recipes: return f\\"Recipe for {name} does not exist.\\" del self._recipes[name] return f\\"Recipe for {name} removed successfully.\\" def get_recipe(self, name): if name not in self._recipes: return f\\"Recipe for {name} does not exist.\\" return self._recipes[name] def list_recipes(self): return list(self._recipes.keys()) def find_recipes(self, available_ingredients): possible_recipes = [] for name, details in self._recipes.items(): if all(item in available_ingredients for item in details['ingredients']): possible_recipes.append(name) return possible_recipes"},{"question":"Task scheduling system to manage and execute tasks based on priority levels from datetime import datetime import heapq from typing import List class Task: Task class representing individual tasks def __init__(self, task_id: int, description: str, priority: int, execution_time: datetime): self.id = task_id self.description = description self.priority = priority self.execution_time = execution_time def __lt__(self, other): return self.priority < other.priority or (self.priority == other.priority and self.execution_time < other.execution_time) class TaskScheduler: TaskScheduler class to manage task scheduling and execution def __init__(self): self.task_queue = [] def add_task(self, task: Task): Add a task to the scheduler heapq.heappush(self.task_queue, (task.priority, task)) def remove_task(self, task_id: int): Remove a task from the scheduler by its unique identifier self.task_queue = [(priority, task) for priority, task in self.task_queue if task.id != task_id] heapq.heapify(self.task_queue) def execute_tasks(self): Execute tasks in order of their priority while self.task_queue: priority, task = heapq.heappop(self.task_queue) print(f\\"Executing Task ID: {task.id}, Description: {task.description}, Priority: {task.priority}, Execution Time: {task.execution_time}\\") def get_all_tasks(self) -> List[Task]: Get a list of all tasks in the scheduler return [task for priority, task in self.task_queue] # Unit Tests import pytest def test_add_task(): scheduler = TaskScheduler() task = Task(1, \\"Task 1\\", 2, datetime(2023, 5, 1, 10, 0)) scheduler.add_task(task) tasks = scheduler.get_all_tasks() assert len(tasks) == 1 assert tasks[0].id == 1 assert tasks[0].description == \\"Task 1\\" assert tasks[0].priority == 2 def test_remove_task(): scheduler = TaskScheduler() task1 = Task(1, \\"Task 1\\", 2, datetime(2023, 5, 1, 10, 0)) task2 = Task(2, \\"Task 2\\", 1, datetime(2023, 5, 1, 11, 0)) scheduler.add_task(task1) scheduler.add_task(task2) scheduler.remove_task(1) tasks = scheduler.get_all_tasks() assert len(tasks) == 1 assert tasks[0].id == 2 assert tasks[0].description == \\"Task 2\\" assert tasks[0].priority == 1 def test_execute_tasks(): scheduler = TaskScheduler() task1 = Task(1, \\"Task 1\\", 2, datetime(2023, 5, 1, 10, 0)) task2 = Task(2, \\"Task 2\\", 1, datetime(2023, 5, 1, 11, 0)) task3 = Task(3, \\"Task 3\\", 1, datetime(2023, 5, 1, 12, 0)) scheduler.add_task(task1) scheduler.add_task(task2) scheduler.add_task(task3) from io import StringIO import sys captured_output = StringIO() sys.stdout = captured_output scheduler.execute_tasks() sys.stdout = sys.__stdout__ output = captured_output.getvalue().strip().split('n') assert output == [ \\"Executing Task ID: 2, Description: Task 2, Priority: 1, Execution Time: 2023-05-01 11:00:00\\", \\"Executing Task ID: 3, Description: Task 3, Priority: 1, Execution Time: 2023-05-01 12:00:00\\", \\"Executing Task ID: 1, Description: Task 1, Priority: 2, Execution Time: 2023-05-01 10:00:00\\" ] def test_task_order_with_same_priority(): scheduler = TaskScheduler() task1 = Task(1, \\"Task 1\\", 1, datetime(2023, 5, 1, 10, 0)) task2 = Task(2, \\"Task 2\\", 1, datetime(2023, 5, 1, 11, 0)) task3 = Task(3, \\"Task 3\\", 1, datetime(2023, 5, 1, 12, 0)) scheduler.add_task(task1) scheduler.add_task(task2) scheduler.add_task(task3) tasks = scheduler.get_all_tasks() assert tasks[0].id == 1 assert tasks[1].id == 2 assert tasks[2].id == 3","solution":"TaskScheduler module implementing the task scheduling system from datetime import datetime import heapq from typing import List class Task: Task class representing individual tasks def __init__(self, task_id: int, description: str, priority: int, execution_time: datetime): self.id = task_id self.description = description self.priority = priority self.execution_time = execution_time def __lt__(self, other): return self.priority < other.priority or (self.priority == other.priority and self.execution_time < other.execution_time) class TaskScheduler: TaskScheduler class to manage task scheduling and execution def __init__(self): self.task_queue = [] def add_task(self, task: Task): heapq.heappush(self.task_queue, (task.priority, task)) def remove_task(self, task_id: int): self.task_queue = [(priority, task) for priority, task in self.task_queue if task.id != task_id] heapq.heapify(self.task_queue) def execute_tasks(self): while self.task_queue: priority, task = heapq.heappop(self.task_queue) print(f\\"Executing Task ID: {task.id}, Description: {task.description}, Priority: {task.priority}, Execution Time: {task.execution_time}\\") def get_all_tasks(self) -> List[Task]: return [task for priority, task in self.task_queue]"},{"question":"import csv def read_csv_and_calculate_average(file_path): Reads a CSV file containing employee's names and their salaries, calculates the average salary, and identifies employees who earn above the average salary. >>> read_csv_and_calculate_average(\\"test_employees.csv\\") (66000.0, {'Alice', 'Charlie', 'Eve'}) try: # Initialize variables employees = [] salaries = [] # Read the CSV file with open(file_path, mode='r') as file: csv_reader = csv.reader(file) next(csv_reader) # Skip header row for row in csv_reader: if len(row) != 2: print(f\\"Skipping malformed row: {row}\\") continue try: name = row[0] salary = float(row[1]) employees.append(name) salaries.append(salary) except ValueError: print(f\\"Skipping row with invalid data: {row}\\") # Calculate average salary if not salaries: raise ValueError(\\"No valid salary data found.\\") average_salary = sum(salaries) / len(salaries) # Find employees with salaries above the average above_average_employees = [employees[i] for i in range(len(salaries)) if salaries[i] > average_salary] return average_salary, above_average_employees except FileNotFoundError: print(f\\"File not found: {file_path}\\") return None, None except Exception as e: print(f\\"An error occurred: {e}\\") return None, None import pytest from solution import read_csv_and_calculate_average # Define a test CSV content for testing TEST_CSV_CONTENT = Name,Salary Alice,70000 Bob,50000 Charlie,80000 David,60000 Eve,70000 # Helper function to write test CSV file def write_test_csv(file_path, content): with open(file_path, mode='w') as file: file.write(content) def test_average_salary_and_above_average_employees(tmpdir): # Path to temporary CSV file test_csv_path = tmpdir.join(\\"test_employees.csv\\") # Write content to the temporary CSV file write_test_csv(test_csv_path, TEST_CSV_CONTENT) # Run the function with the test CSV file avg_salary, above_avg_employees = read_csv_and_calculate_average(test_csv_path) assert avg_salary == 66000.0 # (70000 + 50000 + 80000 + 60000 + 70000) / 5 assert set(above_avg_employees) == {\\"Alice\\", \\"Charlie\\", \\"Eve\\"} def test_missing_file(): avg_salary, above_avg_employees = read_csv_and_calculate_average('non_existent_file.csv') assert avg_salary is None assert above_avg_employees is None def test_malformed_data(tmpdir): malformed_csv_content = Name,Salary Alice,70000 Bob,InvalidSalary Charlie,80000 David, Eve,70000 # Path to temporary CSV file test_csv_path = tmpdir.join(\\"malformed_test_employees.csv\\") # Write content to the temporary CSV file write_test_csv(test_csv_path, malformed_csv_content) # Run the function with the malformed CSV file avg_salary, above_avg_employees = read_csv_and_calculate_average(test_csv_path) assert avg_salary == 73333.33333333333 # (70000 + 80000 + 70000) / 3 valid entries assert set(above_avg_employees) == {\\"Charlie\\"} def test_no_valid_salaries(tmpdir): no_salary_csv_content = Name,Salary Alice,InvalidSalary Bob,N/A Charlie,Invalid # Path to temporary CSV file test_csv_path = tmpdir.join(\\"no_salary_test_employees.csv\\") # Write content to the temporary CSV file write_test_csv(test_csv_path, no_salary_csv_content) # Run the function with the CSV file containing no valid salaries avg_salary, above_avg_employees = read_csv_and_calculate_average(test_csv_path) assert avg_salary is None assert above_avg_employees is None","solution":"import csv def read_csv_and_calculate_average(file_path): try: # Initialize variables employees = [] salaries = [] # Read the CSV file with open(file_path, mode='r') as file: csv_reader = csv.reader(file) next(csv_reader) # Skip header row for row in csv_reader: if len(row) != 2: print(f\\"Skipping malformed row: {row}\\") continue try: name = row[0] salary = float(row[1]) employees.append(name) salaries.append(salary) except ValueError: print(f\\"Skipping row with invalid data: {row}\\") # Calculate average salary if not salaries: raise ValueError(\\"No valid salary data found.\\") average_salary = sum(salaries) / len(salaries) # Find employees with salaries above the average above_average_employees = [employees[i] for i in range(len(salaries)) if salaries[i] > average_salary] return average_salary, above_average_employees except FileNotFoundError: print(f\\"File not found: {file_path}\\") return None, None except Exception as e: print(f\\"An error occurred: {e}\\") return None, None # Example usage (Uncomment the following two lines to use the function in a script): # average_salary, above_average_employees = read_csv_and_calculate_average('employees.csv') # print(f\\"Average Salary: {average_salary}nEmployees earning above average: {above_average_employees}\\")"},{"question":"from typing import List class Album: def __init__(self, title: str, artist: str, release_year: int, price: float, track_list: List[str]): self.title = title self.artist = artist self.release_year = release_year self.price = price self.track_list = track_list def play(self): pass def description(self): pass class RockAlbum(Album): def __init__(self, title: str, artist: str, release_year: int, price: float, track_list: List[str], band_members: List[str], sub_genre: str): super().__init__(title, artist, release_year, price, track_list) self.band_members = band_members self.sub_genre = sub_genre def display_band_info(self): pass class JazzAlbum(Album): def __init__(self, title: str, artist: str, release_year: int, price: float, track_list: List[str], instruments: List[str], live_recording: bool): super().__init__(title, artist, release_year, price, track_list) self.instruments = instruments self.live_recording = live_recording def display_live_status(self): pass class ClassicalAlbum(Album): def __init__(self, title: str, artist: str, release_year: int, price: float, track_list: List[str], composer: str, period: str): super().__init__(title, artist, release_year, price, track_list) self.composer = composer self.period = period def display_composer_info(self): pass class MusicStore: def __init__(self, name: str, address: str): self.name = name self.address = address self.inventory = [] def add_album(self, album: Album): pass def remove_album(self, album_title: str): pass def search_by_title(self, album_title: str): pass def calculate_total_inventory_value(self): pass def list_albums_by_genre(self, genre: str): pass # Example test cases to verify the functionality from solution import Album, RockAlbum, JazzAlbum, ClassicalAlbum, MusicStore def test_album_methods(): album = Album(\\"Test Album\\", \\"Test Artist\\", 2022, 9.99, [\\"Track1\\", \\"Track2\\"]) assert album.play() == \\"Playing album Test Album by Test Artist.\\" assert album.description() == \\"Album: Test Album, Artist: Test Artist, Year: 2022, Price: 9.99, Tracks: Track1, Track2\\" def test_rock_album_methods(): rock_album = RockAlbum(\\"Rock Album\\", \\"Rock Band\\", 2010, 12.99, [\\"Rock Track1\\"], [\\"Member1\\", \\"Member2\\"], \\"Hard Rock\\") assert rock_album.display_band_info() == \\"Band Members: Member1, Member2, Sub-Genre: Hard Rock\\" def test_jazz_album_methods(): jazz_album = JazzAlbum(\\"Jazz Album\\", \\"Jazz Artist\\", 2005, 10.99, [\\"Jazz Track1\\"], [\\"Piano\\", \\"Sax\\"], True) assert jazz_album.display_live_status() == \\"Live Recording: Yes, Instruments: Piano, Sax\\" def test_classical_album_methods(): classical_album = ClassicalAlbum(\\"Classical Album\\", \\"Classical Artist\\", 1995, 15.99, [\\"Classical Track1\\"], \\"Beethoven\\", \\"Romantic\\") assert classical_album.display_composer_info() == \\"Composer: Beethoven, Period: Romantic\\" def test_music_store_methods(): store = MusicStore(\\"Test Store\\", \\"123 Test Address\\") rock_album = RockAlbum(\\"Rock Album\\", \\"Rock Band\\", 2010, 12.99, [\\"Rock Track1\\"], [\\"Member1\\", \\"Member2\\"], \\"Hard Rock\\") jazz_album = JazzAlbum(\\"Jazz Album\\", \\"Jazz Artist\\", 2005, 10.99, [\\"Jazz Track1\\"], [\\"Piano\\", \\"Sax\\"], True) classical_album = ClassicalAlbum(\\"Classical Album\\", \\"Classical Artist\\", 1995, 15.99, [\\"Classical Track1\\"], \\"Beethoven\\", \\"Romantic\\") store.add_album(rock_album) store.add_album(jazz_album) store.add_album(classical_album) assert store.search_by_title(\\"Rock Album\\") == rock_album assert store.search_by_title(\\"Nonexistent Album\\") is None assert store.calculate_total_inventory_value() == 39.97 store.remove_album(\\"Jazz Album\\") assert len(store.inventory) == 2 rock_albums = store.list_albums_by_genre(\\"Rock\\") assert len(rock_albums) == 1 and rock_albums[0].title == \\"Rock Album\\" classical_albums = store.list_albums_by_genre(\\"Classical\\") assert len(classical_albums) == 1 and classical_albums[0].title == \\"Classical Album\\"","solution":"class Album: def __init__(self, title, artist, release_year, price, track_list): self.title = title self.artist = artist self.release_year = release_year self.price = price self.track_list = track_list def play(self): return f\\"Playing album {self.title} by {self.artist}.\\" def description(self): return f\\"Album: {self.title}, Artist: {self.artist}, Year: {self.release_year}, Price: {self.price}, Tracks: {', '.join(self.track_list)}\\" class RockAlbum(Album): def __init__(self, title, artist, release_year, price, track_list, band_members, sub_genre): super().__init__(title, artist, release_year, price, track_list) self.band_members = band_members self.sub_genre = sub_genre def display_band_info(self): return f\\"Band Members: {', '.join(self.band_members)}, Sub-Genre: {self.sub_genre}\\" class JazzAlbum(Album): def __init__(self, title, artist, release_year, price, track_list, instruments, live_recording): super().__init__(title, artist, release_year, price, track_list) self.instruments = instruments self.live_recording = live_recording def display_live_status(self): return f\\"Live Recording: {'Yes' if self.live_recording else 'No'}, Instruments: {', '.join(self.instruments)}\\" class ClassicalAlbum(Album): def __init__(self, title, artist, release_year, price, track_list, composer, period): super().__init__(title, artist, release_year, price, track_list) self.composer = composer self.period = period def display_composer_info(self): return f\\"Composer: {self.composer}, Period: {self.period}\\" class MusicStore: def __init__(self, name, address): self.name = name self.address = address self.inventory = [] def add_album(self, album): self.inventory.append(album) def remove_album(self, album_title): self.inventory = [album for album in self.inventory if album.title != album_title] def search_by_title(self, album_title): for album in self.inventory: if album.title == album_title: return album return None def calculate_total_inventory_value(self): return sum(album.price for album in self.inventory) def list_albums_by_genre(self, genre): genre_class = {\\"Rock\\": RockAlbum, \\"Jazz\\": JazzAlbum, \\"Classical\\": ClassicalAlbum}.get(genre, Album) return [album for album in self.inventory if isinstance(album, genre_class)]"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Determine if two strings are anagrams of each other. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"hello\\", \\"billion\\") False >>> are_anagrams(\\"racecar\\", \\"carrace\\") True >>> are_anagrams(\\"anagram\\", \\"nagaram\\") True >>> are_anagrams(\\"rat\\", \\"car\\") False # Test cases if __name__ == \\"__main__\\": test_cases = [ (\\"listen\\", \\"silent\\"), # True (\\"hello\\", \\"billion\\"), # False (\\"racecar\\", \\"carrace\\"), # True (\\"anagram\\", \\"nagaram\\"), # True (\\"rat\\", \\"car\\"), # False ] for str1, str2 in test_cases: result = are_anagrams(str1, str2) print(f\\"{str1} and {str2} are anagrams: {result}\\")","solution":"def are_anagrams(str1: str, str2: str) -> bool: if len(str1) != len(str2): return False # Count the frequency of each character in str1 from collections import Counter counter1 = Counter(str1) counter2 = Counter(str2) # Compare the two frequency maps return counter1 == counter2"},{"question":"def custom_sort(data, compare): Sorts a list of elements using a custom comparison function. Parameters: data (list): The list of elements to be sorted. compare (function): The comparison function that compares two elements. Returns: list: A new list of elements sorted based on the provided comparison function. def custom_compare(x, y): A sample custom comparison function. Parameters: x, y: The two elements to compare. Returns: int: Negative if x < y, zero if x == y, positive if x > y return x - y # Example usage data = [9, 3, 5, 1, 7] sorted_data = custom_sort(data, custom_compare) print(sorted_data) # Expected output: [1, 3, 5, 7, 9] # Unit tests def test_custom_sort_basic(): data = [9, 3, 5, 1, 7] sorted_data = custom_sort(data, custom_compare) assert sorted_data == [1, 3, 5, 7, 9] def test_custom_sort_empty_list(): data = [] sorted_data = custom_sort(data, custom_compare) assert sorted_data == [] def test_custom_sort_single_element(): data = [5] sorted_data = custom_sort(data, custom_compare) assert sorted_data == [5] def test_custom_sort_duplicates(): data = [5, 3, 5, 1, 7, 3] sorted_data = custom_sort(data, custom_compare) assert sorted_data == [1, 3, 3, 5, 5, 7] def test_custom_sort_reverse_order(): data = [9, 7, 5, 3, 1] sorted_data = custom_sort(data, custom_compare) assert sorted_data == [1, 3, 5, 7, 9] def test_custom_sort_custom_comparison(): def reverse_compare(x, y): return y - x data = [9, 3, 5, 1, 7] sorted_data = custom_sort(data, reverse_compare) assert sorted_data == [9, 7, 5, 3, 1]","solution":"def custom_sort(data, compare): Sorts a list of elements using a custom comparison function. Parameters: data (list): The list of elements to be sorted. compare (function): The comparison function that compares two elements. Returns: list: A new list of elements sorted based on the provided comparison function. if len(data) <= 1: return data else: pivot = data[0] lesser_than_pivot = [x for x in data[1:] if compare(x, pivot) < 0] equal_to_pivot = [x for x in data if compare(x, pivot) == 0] greater_than_pivot = [x for x in data[1:] if compare(x, pivot) > 0] return custom_sort(lesser_than_pivot, compare) + equal_to_pivot + custom_sort(greater_than_pivot, compare) def custom_compare(x, y): A sample custom comparison function. Parameters: x, y: The two elements to compare. Returns: int: Negative if x < y, zero if x == y, positive if x > y return x - y"},{"question":"def sum_of_digits_base5(number: int) -> int: Calculate the sum of the digits of a non-negative integer when expressed in base-5. Parameters: number (int): A non-negative integer to be converted. Returns: int: The sum of the digits of the provided number in base-5. >>> sum_of_digits_base5(100) 4 >>> sum_of_digits_base5(43) 7 >>> sum_of_digits_base5(25) 1 >>> sum_of_digits_base5(0) 0 >>> sum_of_digits_base5(981) 9","solution":"def sum_of_digits_base5(number: int) -> int: Calculate the sum of the digits of a non-negative integer when expressed in base-5. Parameters: number (int): A non-negative integer to be converted. Returns: int: The sum of the digits of the provided number in base-5. if number == 0: return 0 total = 0 while number > 0: total += number % 5 number //= 5 return total"},{"question":"import numpy as np def rotate_matrix(matrix: np.ndarray) -> np.ndarray: This function rotates a given 2D numpy array by 90 degrees in the anticlockwise direction. Args: matrix : np.ndarray : input 2D numpy array which is a square matrix. Returns: np.ndarray : the resulting 2D numpy array after rotating by 90 degrees anticlockwise. >>> rotate_matrix(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) array([[3, 6, 9], [2, 5, 8], [1, 4, 7]]) >>> rotate_matrix(np.array([[1, 2], [3, 4]])) array([[2, 4], [1, 3]]) >>> rotate_matrix(np.array([[1]])) array([[1]])","solution":"import numpy as np def rotate_matrix(matrix: np.ndarray) -> np.ndarray: This function rotates a given 2D numpy array by 90 degrees anticlockwise. Args: matrix : np.ndarray : input 2D numpy array which is a square matrix. Returns: np.ndarray : the resulting 2D numpy array after rotating by 90 degrees anticlockwise. if not isinstance(matrix, np.ndarray): raise ValueError(\\"The input matrix must be a numpy array.\\") if len(matrix.shape) != 2 or matrix.shape[0] != matrix.shape[1]: raise ValueError(\\"The input matrix must be a square 2D numpy array.\\") return np.rot90(matrix)"},{"question":"def sum_of_divisors(number: int) -> int: Return the sum of all positive divisors of the given number. :param number: A non-negative integer. :return: Sum of all positive divisors of the given number. :raises ValueError: If the input number is negative. >>> sum_of_divisors(0) 0 >>> sum_of_divisors(1) 1 >>> sum_of_divisors(6) 12 >>> sum_of_divisors(28) 56 >>> sum_of_divisors(100) 217 >>> sum_of_divisors(-1) Traceback (most recent call last): ... ValueError: The number must be non-negative.","solution":"def sum_of_divisors(number: int) -> int: Return the sum of all positive divisors of the given number. :param number: A non-negative integer. :return: Sum of all positive divisors of the given number. :raises ValueError: If the input number is negative. if number < 0: raise ValueError(\\"The number must be non-negative.\\") if number == 0: return 0 total = 0 sqrt_num = int(number**0.5) for i in range(1, sqrt_num + 1): if number % i == 0: total += i if i != number // i: total += number // i return total"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression and returns the integer result. Parameters: expression (str): The mathematical expression to be evaluated. Returns: int: The result of the evaluated expression. Raises: TypeError: If the input is not a string. ValueError: If the expression is invalid. Example: >>> evaluate_expression(\\"2+3*4\\") 14 >>> evaluate_expression(\\"(2+3)*4\\") 20 >>> evaluate_expression(\\"10/2\\") 5 >>> evaluate_expression(\\"10/(2+3)\\") 2 >>> evaluate_expression(\\"10/(2-2)\\") Traceback (most recent call last): ... ZeroDivisionError: division by zero from solution import evaluate_expression def test_expression_basic_operations(): assert evaluate_expression(\\"3+5*2\\") == 13 assert evaluate_expression(\\"10-2*3\\") == 4 assert evaluate_expression(\\"8/4\\") == 2 def test_expression_parentheses(): assert evaluate_expression(\\"(8-2)/3\\") == 2 assert evaluate_expression(\\"(2+3)*6\\") == 30 assert evaluate_expression(\\"7+(3*4)-2\\") == 17 def test_expression_division_by_zero(): try: evaluate_expression(\\"10/0\\") assert False # Expecting ZeroDivisionError except ZeroDivisionError: assert True def test_expression_invalid_syntax(): try: evaluate_expression(\\"*2+3\\") assert False # Expecting ValueError except ValueError: assert True try: evaluate_expression(\\"2+(3\\") assert False # Expecting ValueError except ValueError: assert True def test_expression_invalid_type(): try: evaluate_expression(12345) assert False # Expecting TypeError except TypeError: assert True def test_expression_nested_parentheses(): assert evaluate_expression(\\"((2+3)*2)\\") == 10 assert evaluate_expression(\\"((1+1)+2)*3\\") == 12 def test_expression_whitespace_handling(): assert evaluate_expression(\\" 3 + 2 * 2 \\") == 7 assert evaluate_expression(\\"( 5 + 10 ) / ( 3 - 1 )\\") == 7","solution":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression and returns the integer result. Parameters: expression (str): The mathematical expression to be evaluated. Returns: int: The result of the evaluated expression. Raises: TypeError: If the input is not a string. ValueError: If the expression is invalid. ZeroDivisionError: If there is a division by zero. if not isinstance(expression, str): raise TypeError(\\"Input must be a string\\") try: # Replace division symbol with floor division expression = expression.replace(\\"/\\", \\"//\\") # Evaluate the expression result = eval(expression) except ZeroDivisionError: raise ZeroDivisionError(\\"division by zero\\") except Exception as e: raise ValueError(\\"Invalid expression\\") from e return result"},{"question":"import numpy as np def batch_matrix_multiplication(batch_matrices, single_matrix): Multiplies each matrix in a batch with a single matrix. Parameters: - batch_matrices: A 3D NumPy array of shape (N, M, K) - single_matrix: A 2D NumPy array of shape (K, P) Returns: - A 3D NumPy array of shape (N, M, P) Example: >>> batch_matrices = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]) >>> single_matrix = np.array([[1, 0], [0, 1]]) >>> batch_matrix_multiplication(batch_matrices, single_matrix) array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]) >>> single_matrix2 = np.array([[1, 2], [3, 4]]) >>> batch_matrix_multiplication(batch_matrices, single_matrix2) array([[[ 7, 10], [15, 22]], [[23, 34], [31, 46]]])","solution":"import numpy as np def batch_matrix_multiplication(batch_matrices, single_matrix): Multiplies each matrix in a batch with a single matrix. Parameters: - batch_matrices: A 3D NumPy array of shape (N, M, K) - single_matrix: A 2D NumPy array of shape (K, P) Returns: - A 3D NumPy array of shape (N, M, P) return np.matmul(batch_matrices, single_matrix)"},{"question":"def rotate_list(nums: list[int], k: int) -> list[int]: Rotates the list to the right by k positions for positive k and to the left for negative k. >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([1, 2, 3, 4, 5], -2) [3, 4, 5, 1, 2] >>> rotate_list([0, 1, 2], 4) [2, 0, 1] >>> rotate_list([], 3) [] >>> rotate_list([1, 2, 3], 0) [1, 2, 3]","solution":"def rotate_list(nums: list[int], k: int) -> list[int]: Rotates the list to the right by k positions. For negative k, rotate to the left by |k| positions. if not nums: return [] n = len(nums) k %= n # normalize k to be within the bounds of the list length return nums[-k:] + nums[:-k]"},{"question":"def unique_email_formatter(email: str) -> str: Transforms the given email to a standardized unique format: - Removes any dots before the '@' symbol. - Ignores any substring after a plus ('+') and before the '@' symbol. - Leaves the part after the '@' symbol unchanged. Args: email (str): The original email address. Returns: str: The standardized email address. Examples: >>> unique_email_formatter(\\"user.name+extension@example.com\\") 'username@example.com' >>> unique_email_formatter(\\"user.name.email+filter@domain.com\\") 'useremail@domain.com'","solution":"def unique_email_formatter(email: str) -> str: Transforms the given email to a standardized unique format: - Removes any dots before the '@' symbol. - Ignores any substring after a plus ('+') and before the '@' symbol. - Leaves the part after the '@' symbol unchanged. Args: email (str): The original email address. Returns: str: The standardized email address. local, domain = email.split('@') # Ignore substring after '+' if any if '+' in local: local = local.split('+')[0] # Remove all dots from the local part local = local.replace('.', '') return f\\"{local}@{domain}\\""},{"question":"from typing import List def find_smallest_missing_positive(nums: List[int]) -> int: Identifies the smallest positive integer missing from an unsorted list of integers. >>> find_smallest_missing_positive([3, 4, -1, 1]) 2 >>> find_smallest_missing_positive([1, 2, 0]) 3 >>> find_smallest_missing_positive([7, 8, 9, 11, 12]) 1 >>> find_smallest_missing_positive([1, 2, 3]) 4","solution":"from typing import List def find_smallest_missing_positive(nums: List[int]) -> int: n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Returns an array such that output[i] is equal to the product of all the elements of nums except nums[i]. >>> product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_except_self([1, 2, 3, 0]) == [0, 0, 0, 6] >>> product_except_self([-1, 1, 0, -3, 3]) == [0, 0, 9, 0, 0]","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: n = len(nums) # Initialize the result array with 1s result = [1] * n # Compute the prefix products prefix_product = 1 for i in range(n): result[i] = prefix_product prefix_product *= nums[i] # Compute the suffix products and multiply with the prefix products suffix_product = 1 for i in range(n-1, -1, -1): result[i] *= suffix_product suffix_product *= nums[i] return result"},{"question":"def is_armstrong_number(n: int) -> bool: Checks if a given number n is an Armstrong number. An Armstrong number (also known as a narcissistic number, pluperfect number, or pluperfect digit invariant) is a number that is equal to the sum of its own digits each raised to the power of the number of digits. Args: n (int): The number to check. Returns: bool: Returns True if the number is an Armstrong number, False otherwise. Examples: >>> is_armstrong_number(153) == True >>> is_armstrong_number(9474) == True >>> is_armstrong_number(9475) == False >>> is_armstrong_number(1) == True >>> is_armstrong_number(10) == False pass","solution":"def is_armstrong_number(n: int) -> bool: Checks if a given number n is an Armstrong number. digits = [int(d) for d in str(n)] num_digits = len(digits) armstrong_sum = sum(d ** num_digits for d in digits) return armstrong_sum == n"},{"question":"def prime_factors(n: int) -> dict[int, int]: Returns the prime factorization of n as a dictionary where keys are prime factors and values are the respective powers. >>> prime_factors(28) {2: 2, 7: 1} >>> prime_factors(45) {3: 2, 5: 1} >>> prime_factors(100) {2: 2, 5: 2}","solution":"def prime_factors(n: int) -> dict[int, int]: Returns the prime factorization of n as a dictionary where keys are prime factors and values are the respective powers. factors = {} divisor = 2 while n > 1: count = 0 while n % divisor == 0: n //= divisor count += 1 if count > 0: factors[divisor] = count divisor += 1 return factors"},{"question":"# Write a function that counts the number of vowels in a given string. def count_vowels(input_string: str) -> int: Returns the count of vowels in the input string. Vowels are 'a', 'e', 'i', 'o', 'u' and their uppercase counterparts. vowels = set(\\"aeiouAEIOU\\") return sum(1 for char in input_string if char in vowels) # Test cases def test_count_vowels_in_hello(): assert count_vowels(\\"hello\\") == 2 def test_count_vowels_in_beautiful(): assert count_vowels(\\"Beautiful\\") == 5 def test_count_vowels_in_xyz(): assert count_vowels(\\"xyz\\") == 0 def test_count_vowels_in_empty_string(): assert count_vowels(\\"\\") == 0 def test_count_vowels_with_all_vowels(): assert count_vowels(\\"AEIOUaeiou\\") == 10 def test_count_vowels_with_no_vowels(): assert count_vowels(\\"bcdfg\\") == 0 def test_count_vowels_case_insensitivity(): assert count_vowels(\\"aEiOu\\") == 5 def test_count_vowels_long_string(): long_string = \\"a\\" * (10**5) assert count_vowels(long_string) == 10**5","solution":"def count_vowels(input_string: str) -> int: Returns the count of vowels in the input string. Vowels are 'a', 'e', 'i', 'o', 'u' and their uppercase counterparts. vowels = set(\\"aeiouAEIOU\\") return sum(1 for char in input_string if char in vowels)"},{"question":"import re from collections import defaultdict from typing import List, Dict class InvertedIndex: def __init__(self): self.index = defaultdict(list) self.documents = [] def add_document(self, document: str) -> None: Adds a new document to the index and updates the inverted index with the words from the document. Args: document (str): The document to be added. # Your implementation here def search(self, word: str) -> List[int]: Searches for a word in the index and returns a list of document indices where the word appears. Args: word (str): The word to search for. # Your implementation here # Example usage: if __name__ == \\"__main__\\": docs = [ \\"The quick brown fox jumps over the lazy dog.\\", \\"Never jump over the lazy dog quickly.\\", \\"Brown dogs are quick and jump high.\\" ] index = InvertedIndex() for doc in docs: index.add_document(doc) print(index.search(\\"quick\\")) # Expected Output: [0, 2] print(index.search(\\"lazy\\")) # Expected Output: [0, 1] print(index.search(\\"dog\\")) # Expected Output: [0, 1]","solution":"import re from collections import defaultdict from typing import List, Dict class InvertedIndex: def __init__(self): self.index = defaultdict(list) self.documents = [] def _tokenize(self, document: str) -> List[str]: Tokenize the document into words, converting to lower case and removing punctuation. return re.findall(r'bw+b', document.lower()) def add_document(self, document: str) -> None: Adds a new document to the index and updates the inverted index with the words from the document. doc_index = len(self.documents) self.documents.append(document) words = self._tokenize(document) for word in words: if doc_index not in self.index[word]: self.index[word].append(doc_index) def search(self, word: str) -> List[int]: Searches for a word in the index and returns a list of document indices where the word appears. word = word.lower() return self.index[word]"},{"question":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Returns the transpose of a given 2D matrix. Args: - matrix: List[List[int]], a 2D list representing the matrix to transpose Returns: - List[List[int]], the transposed 2D list Examples: >>> transpose_matrix([ ... [1, 2, 3], ... [4, 5, 6] ... ]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([ ... [1, 2], ... [3, 4], ... [5, 6] ... ]) [[1, 3, 5], [2, 4, 6]] pass","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Returns the transpose of a given 2D matrix. Args: - matrix: List[List[int]], a 2D list representing the matrix to transpose Returns: - List[List[int]], the transposed 2D list # Check if the matrix is empty if not matrix: return [] # Use zip to transpose the matrix and convert the result back to list of lists transposed = list(map(list, zip(*matrix))) return transposed"},{"question":"def min_connections(graph: dict, user1: str, user2: str) -> int: Returns the minimum number of connections required to connect user1 and user2 in the social network graph. >>> graph = { ... 'Alice': ['Bob', 'Charlie'], ... 'Bob': ['Alice', 'Dave'], ... 'Charlie': ['Alice', 'Eve'], ... 'Dave': ['Bob'], ... 'Eve': ['Charlie'], ... 'Frank': [] ... } >>> min_connections(graph, 'Alice', 'Dave') 2 >>> min_connections(graph, 'Alice', 'Eve') 2 >>> min_connections(graph, 'Alice', 'Frank') -1 >>> min_connections(graph, 'Charlie', 'Bob') 3","solution":"from collections import deque def min_connections(graph, user1, user2): Returns the minimum number of connections required to connect user1 and user2 in the social network graph. if user1 not in graph or user2 not in graph: return -1 if user1 == user2: return 0 # Breadth-First Search (BFS) to find the shortest path queue = deque([(user1, 0)]) visited = set([user1]) while queue: current_user, distance = queue.popleft() for neighbour in graph[current_user]: if neighbour == user2: return distance + 1 if neighbour not in visited: visited.add(neighbour) queue.append((neighbour, distance + 1)) return -1"},{"question":"def is_temperature_safe(temp: float, min_safe_temp: float, max_safe_temp: float) -> bool: Determines if the given temperature is within the safe range. Parameters: - temp: float, the temperature in Celsius. - min_safe_temp: float, the minimum safe temperature in Celsius. - max_safe_temp: float, the maximum safe temperature in Celsius. Returns: - bool: True if the temperature is within the safe range, False otherwise. >>> is_temperature_safe(25.0, 20.0, 30.0) True >>> is_temperature_safe(15.0, 20.0, 30.0) False >>> is_temperature_safe(-5.0, -10.0, 0.0) True >>> is_temperature_safe(35.0, 20.0, 30.0) False >>> is_temperature_safe(20.0, 20.0, 30.0) True","solution":"def is_temperature_safe(temp: float, min_safe_temp: float, max_safe_temp: float) -> bool: Determines if the given temperature is within the safe range. Parameters: - temp: float, the temperature in Celsius. - min_safe_temp: float, the minimum safe temperature in Celsius. - max_safe_temp: float, the maximum safe temperature in Celsius. Returns: - bool: True if the temperature is within the safe range, False otherwise. return min_safe_temp <= temp <= max_safe_temp"},{"question":"def transpose_matrix(matrix: list) -> list: Implements matrix transposition where rows become columns and vice versa. >>> transpose_matrix([[1]]) [[1]] >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([[5, 8, -20], [9, 7, 3]]) [[5, 9], [8, 7], [-20, 3]] pass","solution":"def transpose_matrix(matrix: list) -> list: if not matrix: return [] rows = len(matrix) cols = len(matrix[0]) transpose = [[0] * rows for _ in range(cols)] for i in range(rows): for j in range(cols): transpose[j][i] = matrix[i][j] return transpose"},{"question":"import heapq class PriorityQueue: Implement a Priority Queue using a Min-Heap. Operations: - insert(item, priority): Adds an item to the priority queue with the given priority. - extract_min(): Removes and returns the item with the smallest priority. - peek_min(): Returns the item with the smallest priority without removing it. - is_empty(): Returns True if the priority queue is empty, False otherwise. Example usage: >>> pq = PriorityQueue() >>> pq.insert(\\"task1\\", 3) >>> pq.insert(\\"task2\\", 1) >>> pq.peek_min() \\"task2\\" >>> pq.extract_min() \\"task2\\" >>> pq.is_empty() False >>> pq.extract_min() \\"task1\\" >>> pq.is_empty() True def __init__(self): self.heap = [] def insert(self, item, priority): pass def extract_min(self): pass def peek_min(self): pass def is_empty(self): pass","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] def insert(self, item, priority): heapq.heappush(self.heap, (priority, item)) def extract_min(self): if not self.is_empty(): return heapq.heappop(self.heap)[1] else: raise IndexError(\\"extract_min from an empty priority queue\\") def peek_min(self): if not self.is_empty(): return self.heap[0][1] else: raise IndexError(\\"peek_min from an empty priority queue\\") def is_empty(self): return len(self.heap) == 0"},{"question":"from collections import defaultdict from typing import List, Dict def inverted_index(documents: List[str]) -> Dict[str, List[int]]: Construct an inverted index from a list of text documents. Args: documents (List[str]): A list of strings where each string represents a document. Returns: Dict[str, List[int]]: A dictionary mapping each term to a list of document indices. Example usage: >>> documents = [\\"Hello World\\", \\"HELLO there\\", \\"World\\"] >>> inverted_index(documents) { 'hello': [0, 1], 'world': [0, 2], 'there': [1] } >>> documents = [\\"The quick brown fox\\", \\"jumps over the lazy dog\\"] >>> inverted_index(documents) { 'the': [0, 1], 'quick': [0], 'brown': [0], 'fox': [0], 'jumps': [1], 'over': [1], 'lazy': [1], 'dog': [1] }","solution":"from collections import defaultdict from typing import List, Dict def inverted_index(documents: List[str]) -> Dict[str, List[int]]: Construct an inverted index from a list of text documents. Args: documents (List[str]): A list of strings where each string represents a document. Returns: Dict[str, List[int]]: A dictionary mapping each term to a list of document indices. index = defaultdict(list) for doc_id, content in enumerate(documents): terms = content.lower().split() seen_terms = set() for term in terms: if term not in seen_terms: index[term].append(doc_id) seen_terms.add(term) return dict(index)"},{"question":"[Completion Task in Python] class Graph: def __init__(self): self.graph = defaultdict(list) def add_edge(self, vertex1: str, vertex2: str): pass def dfs(self, start_vertex: str) -> List[str]: pass def bfs(self, start_vertex: str) -> List[str]: pass","solution":"from collections import defaultdict, deque from typing import List class Graph: def __init__(self): self.graph = defaultdict(list) def add_edge(self, vertex1: str, vertex2: str): Adds an edge between vertex1 and vertex2. self.graph[vertex1].append(vertex2) self.graph[vertex2].append(vertex1) def dfs(self, start_vertex: str) -> List[str]: Performs a Depth-First Search (DFS) starting from start_vertex. Returns the list of vertices in the order they are visited. visited = set() result = [] def dfs_recursive(v): visited.add(v) result.append(v) for neighbor in self.graph[v]: if neighbor not in visited: dfs_recursive(neighbor) dfs_recursive(start_vertex) return result def bfs(self, start_vertex: str) -> List[str]: Performs a Breadth-First Search (BFS) starting from start_vertex. Returns the list of vertices in the order they are visited. visited = set([start_vertex]) queue = deque([start_vertex]) result = [] while queue: v = queue.popleft() result.append(v) for neighbor in self.graph[v]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return result"},{"question":"from typing import List def gcd(a: int, b: int) -> int: Returns the greatest common divisor (GCD) of a and b using the Euclidean algorithm. >>> gcd(48, 18) ->int 6 >>> gcd(0, 18) ->int 18 >>> gcd(48, 0) ->int 48 >>> gcd(0, 0) ->int 0 >>> gcd(7, 1) ->int 1 >>> gcd(20, 5) ->int 5 pass def lcm(a: int, b: int) -> int: Returns the least common multiple (LCM) of a and b using the relationship between GCD and LCM. >>> lcm(4, 5) ->int 20 >>> lcm(0, 5) ->int 0 >>> lcm(4, 0) ->int 0 >>> lcm(3, 7) ->int 21 >>> lcm(10, 8) ->int 40 pass def gcd_of_list(numbers: List[int]) -> int: Returns the GCD of a list of integers. >>> gcd_of_list([32, 96, 128]) ->int 32 >>> gcd_of_list([7, 21, 49]) ->int 7 >>> gcd_of_list([10, 15, 25]) ->int 5 >>> gcd_of_list([100]) ->int 100 pass def lcm_of_list(numbers: List[int]) -> int: Returns the LCM of a list of integers. >>> lcm_of_list([4, 6, 8]) ->int 24 >>> lcm_of_list([2, 3, 7]) ->int 42 >>> lcm_of_list([5, 10, 15]) ->int 30 >>> lcm_of_list([6]) ->int 6 pass","solution":"from typing import List from functools import reduce import math def gcd(a: int, b: int) -> int: Returns the greatest common divisor (GCD) of a and b using the Euclidean algorithm. while b: a, b = b, a % b return a def lcm(a: int, b: int) -> int: Returns the least common multiple (LCM) of a and b using the relationship between GCD and LCM. if a == 0 or b == 0: return 0 return abs(a * b) // gcd(a, b) def gcd_of_list(numbers: List[int]) -> int: Returns the GCD of a list of integers. return reduce(gcd, numbers) def lcm_of_list(numbers: List[int]) -> int: Returns the LCM of a list of integers. return reduce(lcm, numbers)"},{"question":"def is_palindrome(word: str) -> bool: Determines if the given word is a palindrome, ignoring case. Parameters: word (str): Input word to check Returns: bool: True if the word is a palindrome, False otherwise Examples: >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"Madam\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"noon\\") True >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"AbaBA\\") True >>> is_palindrome(\\"icecream\\") False >>> is_palindrome(\\"Level\\") True >>> is_palindrome(\\"AbleWasIEreISawElba\\") True >>> is_palindrome(\\"NotAPalindrome\\") False >>> is_palindrome(\\"deified\\") True # Implementation here # Test cases def test_is_palindrome_simple_cases(): assert is_palindrome(\\"racecar\\") == True assert is_palindrome(\\"Madam\\") == True assert is_palindrome(\\"hello\\") == False assert is_palindrome(\\"noon\\") == True def test_is_palindrome_edge_cases(): assert is_palindrome(\\"\\") == True assert is_palindrome(\\"a\\") == True assert is_palindrome(\\"A\\") == True def test_is_palindrome_mixed_cases(): assert is_palindrome(\\"AbaBA\\") == True assert is_palindrome(\\"icecream\\") == False assert is_palindrome(\\"Level\\") == True def test_is_palindrome_special_cases(): assert is_palindrome(\\"AbleWasIEreISawElba\\") == True assert is_palindrome(\\"NotAPalindrome\\") == False assert is_palindrome(\\"deified\\") == True","solution":"def is_palindrome(word: str) -> bool: Determines if the given word is a palindrome, ignoring case. Parameters: word (str): Input word to check Returns: bool: True if the word is a palindrome, False otherwise # Convert the word to lowercase to make the comparison case insensitive word = word.lower() # Reverse the word and compare it to the original return word == word[::-1]"},{"question":"class ATM: A class to simulate an ATM machine allowing for deposit, withdrawal, balance inquiry, and transaction history functionalities. Methods: __init__(self): Initializes the ATM with a starting balance of 0 and an empty transaction history. deposit(self, amount: int) -> str: Adds the given amount to the account balance. Returns a string indicating the completion of the deposit. withdraw(self, amount: int) -> str: Deducts the given amount from the account balance if sufficient funds exist. Returns a string indicating the completion of the withdrawal or an error message if sufficient funds are not available. get_balance(self) -> int: Returns the current balance of the account. get_history(self) -> list: Returns the transaction history as a list of strings, each string describing a single transaction. Example: >>> atm = ATM() >>> atm.deposit(1000) 'Deposited 1000' >>> atm.get_balance() 1000 >>> atm.withdraw(500) 'Withdrew 500' >>> atm.get_balance() 500 >>> atm.withdraw(600) 'Insufficient balance to withdraw 600' >>> atm.get_balance() 500 >>> atm.get_history() ['Deposited 1000', 'Withdrew 500', 'Attempted to withdraw 600 - Insufficient balance'] def __init__(self): pass def deposit(self, amount: int) -> str: pass def withdraw(self, amount: int) -> str: pass def get_balance(self) -> int: pass def get_history(self) -> list: pass from solution import ATM def test_deposit(): atm = ATM() assert atm.deposit(1000) == \\"Deposited 1000\\" assert atm.get_balance() == 1000 def test_withdraw(): atm = ATM() atm.deposit(1000) assert atm.withdraw(500) == \\"Withdrew 500\\" assert atm.get_balance() == 500 def test_withdraw_insufficient_balance(): atm = ATM() atm.deposit(1000) assert atm.withdraw(1500) == \\"Insufficient balance to withdraw 1500\\" assert atm.get_balance() == 1000 def test_negative_deposit(): atm = ATM() assert atm.deposit(-500) == \\"Deposit amount must be positive.\\" def test_negative_withdraw(): atm = ATM() assert atm.withdraw(-500) == \\"Withdrawal amount must be positive.\\" def test_deposit_and_withdraw_history(): atm = ATM() atm.deposit(1000) atm.withdraw(500) atm.withdraw(600) assert atm.get_history() == [\\"Deposited 1000\\", \\"Withdrew 500\\", \\"Attempted to withdraw 600 - Insufficient balance\\"] def test_initial_balance(): atm = ATM() assert atm.get_balance() == 0 def test_initial_history(): atm = ATM() assert atm.get_history() == []","solution":"class ATM: def __init__(self): self.balance = 0 self.history = [] def deposit(self, amount: int) -> str: if amount <= 0: return \\"Deposit amount must be positive.\\" self.balance += amount transaction = f\\"Deposited {amount}\\" self.history.append(transaction) return transaction def withdraw(self, amount: int) -> str: if amount <= 0: return \\"Withdrawal amount must be positive.\\" if amount > self.balance: transaction = f\\"Attempted to withdraw {amount} - Insufficient balance\\" self.history.append(transaction) return \\"Insufficient balance to withdraw \\" + str(amount) self.balance -= amount transaction = f\\"Withdrew {amount}\\" self.history.append(transaction) return transaction def get_balance(self) -> int: return self.balance def get_history(self) -> list: return self.history"},{"question":"# Decode a Unique Sequence Implement the function \`decode_sequence(encoded_words: list) -> list\` to decode the given encoded sequence. def decode_sequence(encoded_words: list) -> list: Decodes a list of encoded words by reversing each word to restore the original sequence. :param encoded_words: List of strings, where each string is an encoded word. :return: List of strings with decoded words. return [word[::-1] for word in encoded_words] # Unit Tests def test_decode_single_word(): assert decode_sequence([\\"dlrow\\"]) == [\\"world\\"] def test_decode_multiple_words(): assert decode_sequence([\\"olleh\\", \\"dlrow\\"]) == [\\"hello\\", \\"world\\"] def test_decode_with_special_characters(): assert decode_sequence([\\"!dlrow\\", \\"erehT\\"]) == [\\"world!\\", \\"There\\"] def test_decode_empty_list(): assert decode_sequence([]) == [] def test_decode_mixed_case(): assert decode_sequence([\\"sI\\", \\"sihT\\"]) == [\\"Is\\", \\"This\\"] def test_decode_long_words(): assert decode_sequence([\\"gnirtsgnol\\", \\"esacgnol\\"]) == [\\"longstring\\", \\"longcase\\"] def test_decode_single_character_words(): assert decode_sequence([\\"a\\", \\"b\\", \\"c\\"]) == [\\"a\\", \\"b\\", \\"c\\"] def test_decode_numerical_strings(): assert decode_sequence([\\"4321\\", \\"5678\\"]) == [\\"1234\\", \\"8765\\"] def test_decode_words_with_spaces(): assert decode_sequence([\\"siht\\", \\"si\\", \\"nuf\\"]) == [\\"this\\", \\"is\\", \\"fun\\"]","solution":"def decode_sequence(encoded_words: list) -> list: Decodes a list of encoded words by reversing each word to restore the original sequence. :param encoded_words: List of strings, where each string is an encoded word. :return: List of strings with decoded words. return [word[::-1] for word in encoded_words]"},{"question":"from typing import Dict, List, Tuple def shortest_path(graph: Dict[int, List[Tuple[int, int]]], start: int, end: int) -> List[int]: Finds the shortest path between two nodes in a given graph using Dijkstra's algorithm. :param graph: A dictionary where keys are node identifiers and values are lists of tuples (neighbor, weight). :param start: The starting node identifier. :param end: The ending node identifier. :return: A list of node identifiers representing the shortest path from start to end. If no path exists, return an empty list. >>> graph = { ... 0: [(1, 4), (2, 1)], ... 1: [(0, 4), (2, 2), (3, 1)], ... 2: [(0, 1), (1, 2), (3, 5)], ... 3: [(1, 1), (2, 5)] ... } >>> shortest_path(graph, 0, 3) [0, 2, 1, 3] >>> shortest_path(graph, 0, 1) [0, 2, 1] >>> shortest_path(graph, 3, 0) [3, 1, 2, 0] >>> shortest_path(graph, 0, 4) []","solution":"import heapq from typing import Dict, List, Tuple def shortest_path(graph: Dict[int, List[Tuple[int, int]]], start: int, end: int) -> List[int]: Finds the shortest path between two nodes in a graph using Dijkstra's algorithm. :param graph: A dictionary where keys are node identifiers and values are lists of tuples (neighbor, weight). :param start: The starting node identifier. :param end: The ending node identifier. :return: A list of node identifiers representing the shortest path from start to end. # Priority queue to store (current_distance, current_node) queue = [(0, start)] # Dictionary to store the minimum distance to reach each node distances = {node: float('infinity') for node in graph} distances[start] = 0 # Dictionary to store the previous node in the optimal path previous_nodes = {node: None for node in graph} visited = set() while queue: current_distance, current_node = heapq.heappop(queue) visited.add(current_node) if current_node == end: # Reconstruct the path if the end node is reached path = [] while current_node is not None: path.append(current_node) current_node = previous_nodes[current_node] return path[::-1] if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph.get(current_node, []): if neighbor in visited: continue distance = current_distance + weight # If a shorter path to neighbor is found if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(queue, (distance, neighbor)) # If the end node is not reachable return []"},{"question":"def min_adjacent_replacements(s: str) -> int: Returns the minimum number of replacements needed to ensure no two adjacent characters are the same. >>> min_adjacent_replacements(\\"aab\\") 1 >>> min_adjacent_replacements(\\"aaaa\\") 2 >>> min_adjacent_replacements(\\"abac\\") 0 >> min_adjacent_replacements(\\"abc\\") 0","solution":"def min_adjacent_replacements(s: str) -> int: Returns the minimum number of replacements needed to ensure no two adjacent characters are the same. # Convert string to list for mutability s = list(s) replacements = 0 # Iterate through the string for i in range(1, len(s)): if s[i] == s[i-1]: # Need to replace s[i] with a different character replacements += 1 # Choose a character that is not the same as s[i-1] or s[i+1] (if exists) for c in 'abcdefghijklmnopqrstuvwxyz': if c != s[i-1] and (i+1 >= len(s) or c != s[i+1]): s[i] = c break return replacements"},{"question":"def longest_increasing_subsequence(timestamps: list[int]) -> int: Returns the length of the longest increasing subsequence from the given list of timestamps. Args: - timestamps: A list of integer timestamps representing the times at which operations occurred. Returns: - An integer representing the length of the longest increasing subsequence of timestamps. Examples: >>> longest_increasing_subsequence([1, 2, 3, 2, 5, 4, 6]) 5 >>> longest_increasing_subsequence([5, 1, 2, 3, 1, 6, 7, 2, 8]) 6 >>> longest_increasing_subsequence([1]) 1 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1 >>> longest_increasing_subsequence([1, 3, 6, 7, 9, 4, 10, 5, 6]) 6","solution":"def longest_increasing_subsequence(timestamps: list[int]) -> int: Returns the length of the longest increasing subsequence from the given list of timestamps. Args: - timestamps: A list of integer timestamps representing the times at which operations occurred. Returns: - An integer representing the length of the longest increasing subsequence of timestamps. if not timestamps: return 0 n = len(timestamps) dp = [1] * n # dp[i] will store the length of LIS ending at index i for i in range(1, n): for j in range(i): if timestamps[i] > timestamps[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"import string def analyze_word_frequency(file_path: str) -> dict: Analyzes the frequency of words in the given text file. Args: - file_path: The path to the text file. Returns: - A dictionary where keys are unique words and values are their frequencies. Example: >>> file_path = \\"example.txt\\" >>> analyze_word_frequency(file_path) {'hello': 2, 'world': 2, 'this': 1, 'is': 1, 'a': 1, 'test': 4}","solution":"import string def analyze_word_frequency(file_path: str) -> dict: Analyzes the frequency of words in the given text file. Args: - file_path: The path to the text file. Returns: - A dictionary where keys are unique words and values are their frequencies. word_count = {} try: with open(file_path, 'r') as file: for line in file: # Remove punctuation and make lowercase translator = str.maketrans('', '', string.punctuation) cleaned_line = line.translate(translator).lower() words = cleaned_line.split() for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 except FileNotFoundError: print(f\\"Error: The file at {file_path} was not found.\\") return {} return word_count"},{"question":"def longest_subarray_with_two_distinct(nums: list[int]) -> int: Write a function that takes a list of integers and finds the length of the longest subarray that contains at most two distinct elements. >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 3]) 4 >>> longest_subarray_with_two_distinct([1, 2, 3, 4, 5]) 2 >>> longest_subarray_with_two_distinct([1, 1, 1, 1, 1]) 5 >>> longest_subarray_with_two_distinct([1, 2, 2, 3]) 3 pass def test_longest_subarray_with_two_distinct_example1(): assert longest_subarray_with_two_distinct([1, 2, 1, 2, 3]) == 4 def test_longest_subarray_with_two_distinct_example2(): assert longest_subarray_with_two_distinct([1, 2, 3, 4, 5]) == 2 def test_longest_subarray_with_two_distinct_example3(): assert longest_subarray_with_two_distinct([1, 1, 1, 1, 1]) == 5 def test_longest_subarray_with_two_distinct_example4(): assert longest_subarray_with_two_distinct([1, 2, 2, 3]) == 3 def test_longest_subarray_with_two_distinct_single_element(): assert longest_subarray_with_two_distinct([1]) == 1 def test_longest_subarray_with_two_distinct_two_distinct_elements(): assert longest_subarray_with_two_distinct([1, 2, 1, 2, 2]) == 5 def test_longest_subarray_with_two_distinct_large_input(): assert longest_subarray_with_two_distinct([1] * 100000) == 100000 def test_longest_subarray_with_two_distinct_three_elements(): assert longest_subarray_with_two_distinct([1, 2, 3]) == 2","solution":"def longest_subarray_with_two_distinct(nums: list[int]) -> int: from collections import defaultdict count_map = defaultdict(int) left = 0 max_length = 0 for right in range(len(nums)): count_map[nums[right]] += 1 while len(count_map) > 2: count_map[nums[left]] -= 1 if count_map[nums[left]] == 0: del count_map[nums[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"class CircularQueue: def __init__(self, k: int) -> None: Initialize a circular queue with the given capacity 'k'. # Initialization code here def enqueue(self, data: int) -> bool: Insert the specified data into the queue. If the queue is full, return False. If insertion is successful, return True. Parameters: data (int): The data to be inserted into the queue. Returns: bool: True if the operation is successful, False if the queue is full. # Code for enqueue here def dequeue(self) -> int | None: Remove and return the front element of the queue. If the queue is empty, return None. Returns: int | None: The front element of the queue if it exists, otherwise None. # Code for dequeue here def front(self) -> int | None: Return the front element of the queue without removing it. If the queue is empty, return None. Returns: int | None: The front element of the queue if it exists, otherwise None. # Code for front here def test_enqueue(): cq = CircularQueue(3) assert cq.enqueue(10) == True assert cq.enqueue(20) == True assert cq.enqueue(30) == True assert cq.enqueue(40) == False # Queue should be full def test_dequeue(): cq = CircularQueue(3) assert cq.dequeue() == None # Queue should be empty initially cq.enqueue(10) cq.enqueue(20) assert cq.dequeue() == 10 assert cq.dequeue() == 20 assert cq.dequeue() == None # Queue should be empty again def test_front(): cq = CircularQueue(3) assert cq.front() == None # Queue should be empty initially cq.enqueue(10) assert cq.front() == 10 cq.enqueue(20) assert cq.front() == 10 # Front should still be 10 cq.dequeue() assert cq.front() == 20 # Front should now be 20 def test_mixed_operations(): cq = CircularQueue(3) assert cq.enqueue(10) == True assert cq.enqueue(20) == True assert cq.enqueue(30) == True assert cq.front() == 10 assert cq.dequeue() == 10 assert cq.dequeue() == 20 assert cq.enqueue(40) == True assert cq.enqueue(50) == True assert cq.front() == 30 assert cq.enqueue(60) == False # Queue should be full assert cq.dequeue() == 30 assert cq.front() == 40 # Execute the test functions test_enqueue() test_dequeue() test_front() test_mixed_operations()","solution":"class CircularQueue: def __init__(self, k: int) -> None: self.queue = [None] * k self.max_size = k self.front_index = 0 self.rear_index = 0 self.size = 0 def enqueue(self, data: int) -> bool: if self.size == self.max_size: return False self.queue[self.rear_index] = data self.rear_index = (self.rear_index + 1) % self.max_size self.size += 1 return True def dequeue(self) -> int | None: if self.size == 0: return None data = self.queue[self.front_index] self.queue[self.front_index] = None self.front_index = (self.front_index + 1) % self.max_size self.size -= 1 return data def front(self) -> int | None: if self.size == 0: return None return self.queue[self.front_index]"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the given square matrix 90 degrees clockwise in-place. Arguments: matrix : List[List[int]] : A 2D square matrix of integers Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> rotate_matrix(matrix) >>> matrix [ [3, 1], [4, 2] ] >>> matrix = [ ... [1] ... ] >>> rotate_matrix(matrix) >>> matrix [ [1] ] >>> matrix = [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ] >>> rotate_matrix(matrix) >>> matrix [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] >>> matrix = [ ... [i + j*5 for i in range(1, 6)] ... for j in range(5) ... ] >>> rotate_matrix(matrix) >>> matrix [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ]","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the given square matrix 90 degrees clockwise in-place. # Step 1: Transpose the matrix (swap rows with columns) n = len(matrix) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reflect the matrix horizontally (reverse each row) for i in range(n): matrix[i].reverse()"},{"question":"def is_valid_ipv4_address(address: str) -> bool: Validates an IPv4 address. Parameters: address (str): The IPv4 address to be validated. Returns: bool: True if the address is a valid IPv4 address, False otherwise. Raises: TypeError: If the input is not a string. ValueError: If the input does not follow the correct IPv4 address format. Example: >>> is_valid_ipv4_address(\\"192.168.0.1\\") True >>> is_valid_ipv4_address(\\"256.168.0.1\\") False >>> is_valid_ipv4_address(\\"192.168.0\\") False >>> is_valid_ipv4_address(\\"192.168.0.one\\") Traceback (most recent call last): ... ValueError: Invalid format for IPv4 address def test_is_valid_ipv4_address_valid(): assert is_valid_ipv4_address(\\"192.168.0.1\\") == True assert is_valid_ipv4_address(\\"0.0.0.0\\") == True assert is_valid_ipv4_address(\\"255.255.255.255\\") == True assert is_valid_ipv4_address(\\"127.0.0.1\\") == True def test_is_valid_ipv4_address_invalid(): assert is_valid_ipv4_address(\\"256.168.0.1\\") == False assert is_valid_ipv4_address(\\"192.168.0\\") == False assert is_valid_ipv4_address(\\"192.168.0.001\\") == False assert is_valid_ipv4_address(\\"192.168.0.one\\") == False assert is_valid_ipv4_address(\\"192.168.0.1.1\\") == False assert is_valid_ipv4_address(\\"192.168.0.1.\\") == False assert is_valid_ipv4_address(\\"192.168..1\\") == False def test_is_valid_ipv4_address_non_string(): try: is_valid_ipv4_address(19216801) except TypeError: assert True else: assert False def test_is_valid_ipv4_address_leading_zeros(): assert is_valid_ipv4_address(\\"192.168.001.1\\") == False def test_is_valid_ipv4_address_out_of_range(): assert is_valid_ipv4_address(\\"192.168.0.256\\") == False assert is_valid_ipv4_address(\\"192.168.256.1\\") == False def test_is_valid_ipv4_address_empty_string(): assert is_valid_ipv4_address(\\"\\") == False","solution":"def is_valid_ipv4_address(address: str) -> bool: Validates an IPv4 address. Parameters: address (str): The IPv4 address to be validated. Returns: bool: True if the address is a valid IPv4 address, False otherwise. Raises: TypeError: If the input is not a string. ValueError: If the input does not follow the correct IPv4 address format. if not isinstance(address, str): raise TypeError(\\"Input must be a string\\") octets = address.split('.') if len(octets) != 4: return False for octet in octets: if not octet.isdigit(): return False if not 0 <= int(octet) <= 255: return False if octet != str(int(octet)): return False return True"},{"question":"def evaluate_expressions(expressions: list) -> list: This function evaluates a list of mathematical expressions and returns their results. >>> evaluate_expressions([\\"3 + 5\\", \\"10 - 2 * (5 / 2)\\", \\"(1 + 2) * (3 / 4)\\"]) [8, 6.0, 2.25] ...","solution":"def evaluate_expressions(expressions: list) -> list: This function evaluates a list of mathematical expressions and returns their results. results = [] for expr in expressions: results.append(eval(expr)) return results"},{"question":"from typing import List, Tuple def find_pairs_with_sum(arr: List[int], k: int) -> List[Tuple[int, int]]: Find all unique pairs of elements in \`arr\` whose sum is equal to \`k\`. Parameters: - arr (List[int]): A list of integers. - k (int): The target sum for the pairs. Returns: - List[Tuple[int, int]]: A list of unique pairs (a, b) such that a + b = k and a <= b. >>> find_pairs_with_sum([1, 2, 3, 4, 3], 6) [(2, 4), (3, 3)] >>> find_pairs_with_sum([1, 1, 2, 2, 3, 3], 4) [(1, 3), (2, 2)] >>> find_pairs_with_sum([0, -1, 2, -3, 1], -2) [(-3, 1)] >>> find_pairs_with_sum([1, 2, 3], 5) [(2, 3)] >>> find_pairs_with_sum([5, 5, 5], 10) [(5, 5)] from solution import find_pairs_with_sum def test_find_pairs_with_sum_case1(): assert find_pairs_with_sum([1, 2, 3, 4, 3], 6) == [(2, 4), (3, 3)] def test_find_pairs_with_sum_case2(): assert find_pairs_with_sum([1, 1, 2, 2, 3, 3], 4) == [(1, 3), (2, 2)] def test_find_pairs_with_sum_case3(): assert find_pairs_with_sum([0, -1, 2, -3, 1], -2) == [(-3, 1)] def test_find_pairs_with_sum_case4(): assert find_pairs_with_sum([1, 2, 3], 5) == [(2, 3)] def test_find_pairs_with_sum_case5(): assert find_pairs_with_sum([5, 5, 5], 10) == [(5, 5)] def test_find_pairs_with_sum_no_pairs(): assert find_pairs_with_sum([1, 2, 3], 7) == [] def test_find_pairs_with_sum_empty_array(): assert find_pairs_with_sum([], 5) == [] def test_find_pairs_with_sum_repeated_elements(): assert find_pairs_with_sum([2, 4, 2, 4], 6) == [(2, 4)]","solution":"from typing import List, Tuple def find_pairs_with_sum(arr: List[int], k: int) -> List[Tuple[int, int]]: seen = set() pairs = set() for num in arr: complement = k - num if complement in seen: # Ensure that the pair order is consistent (a <= b) pair = tuple(sorted((num, complement))) pairs.add(pair) seen.add(num) return list(pairs)"},{"question":"def allocate_seats(seating: list, num_seats: int) -> tuple: Attempts to allocate the required number of consecutive seats in the seating list. Parameters: - seating: List of integers where 0 = available, 1 = reserved. - num_seats: Integer, the number of consecutive seats required. Returns: - Tuple(Boolean, List of integers): A tuple with a boolean indicating if the seats were allocated successfully, and the list of seating after trying the allocation. >>> allocate_seats([0, 0, 1, 0, 0, 0, 1, 0], 3) (True, [0, 0, 1, 1, 1, 1, 1, 0]) >>> allocate_seats([0, 1, 1, 0, 0, 1, 0, 0], 4) (False, [0, 1, 1, 0, 0, 1, 0, 0]) pass def test_allocate_seats_success(): assert allocate_seats([0, 0, 1, 0, 0, 0, 1, 0], 3) == (True, [0, 0, 1, 1, 1, 1, 1, 0]) def test_allocate_seats_failure(): assert allocate_seats([0, 1, 1, 0, 0, 1, 0, 0], 4) == (False, [0, 1, 1, 0, 0, 1, 0, 0]) def test_allocate_seats_exact_fit(): assert allocate_seats([0, 0, 0], 3) == (True, [1, 1, 1]) def test_allocate_seats_single_seat(): assert allocate_seats([0, 1, 0, 0, 1, 0], 1) == (True, [1, 1, 0, 0, 1, 0]) def test_allocate_seats_entire_row(): assert allocate_seats([0, 0, 0, 0, 0], 5) == (True, [1, 1, 1, 1, 1]) def test_allocate_seats_insufficient_seats(): assert allocate_seats([1, 1, 1, 1, 1], 1) == (False, [1, 1, 1, 1, 1]) def test_allocate_seats_one_available_chunk(): assert allocate_seats([0, 1, 1, 0, 0, 0, 1, 1], 3) == (True, [0, 1, 1, 1, 1, 1, 1, 1]) def test_allocate_seats_multiple_available_chunks(): assert allocate_seats([0, 0, 0, 1, 0, 0, 0, 1], 2) == (True, [1, 1, 0, 1, 0, 0, 0, 1]) # first chunk is used def test_allocate_seats_at_end(): assert allocate_seats([1, 1, 0, 0, 0], 3) == (True, [1, 1, 1, 1, 1]) # last three seats are reserved def test_allocate_seats_no_space(): assert allocate_seats([1, 0, 0, 0, 1, 0], 4) == (False, [1, 0, 0, 0, 1, 0])","solution":"def allocate_seats(seating, num_seats): Attempts to allocate the required number of consecutive seats in the seating list. Parameters: - seating: List of integers where 0 = available, 1 = reserved. - num_seats: Integer, the number of consecutive seats required. Returns: - Tuple(Boolean, List of integers): A tuple with a boolean indicating if the seats were allocated successfully, and the list of seating after trying the allocation. n = len(seating) for i in range(n - num_seats + 1): if all(seat == 0 for seat in seating[i:i + num_seats]): for j in range(i, i + num_seats): seating[j] = 1 return (True, seating) return (False, seating)"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates a given NxN matrix 90 degrees clockwise. >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] pass def are_matrices_identical_after_rotation(original: List[List[int]], rotated: List[List[int]]) -> bool: Checks if one matrix is identical to another after being rotated 90 degrees clockwise. >>> are_matrices_identical_after_rotation([[1, 2], [3, 4]], [[3, 1], [4, 2]]) True >>> are_matrices_identical_after_rotation([[1, 2], [3, 4]], [[4, 3], [2, 1]]) False pass","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates a given NxN matrix 90 degrees clockwise. n = len(matrix) new_matrix = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): new_matrix[j][n-i-1] = matrix[i][j] return new_matrix def are_matrices_identical_after_rotation(original: List[List[int]], rotated: List[List[int]]) -> bool: Checks if the original matrix is identical to the rotated matrix after a 90 degrees rotation. rotated_90 = rotate_matrix(original) return rotated == rotated_90"},{"question":"Implement a function \`find_shortest_path\` which takes a single input - a 2D list \`maze\` - and returns the length of the shortest path from the top-left corner to the bottom-right corner of the maze. The maze consists of only 0s and 1s, where 0 represents an open path and 1 represents a blocked cell. The shortest path can only move horizontally or vertically between adjacent cells. If no such path exists, the function should return -1. Here's the function signature: def find_shortest_path(maze: list[list[int]]) -> int: Unit Test: from solution import find_shortest_path def test_normal_case(): maze = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] assert find_shortest_path(maze) == 9 def test_no_path_case(): maze = [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ] assert find_shortest_path(maze) == -1 def test_single_cell_open(): maze = [[0]] assert find_shortest_path(maze) == 1 def test_single_cell_blocked(): maze = [[1]] assert find_shortest_path(maze) == -1 def test_large_open_maze(): maze = [[0] * 1000 for _ in range(1000)] assert find_shortest_path(maze) == 1999 def test_all_blocked_except_path(): maze = [ [0, 1, 1], [0, 0, 1], [1, 0, 0] ] assert find_shortest_path(maze) == 5","solution":"from collections import deque def find_shortest_path(maze): if not maze or not maze[0]: return -1 rows, cols = len(maze), len(maze[0]) if maze[0][0] == 1 or maze[rows-1][cols-1] == 1: return -1 # Directions for right, left, down, up directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # BFS initialization queue = deque([(0, 0, 1)]) # (row, col, distance_from_start) visited = {(0, 0)} while queue: row, col, dist = queue.popleft() # Reached the end if row == rows - 1 and col == cols - 1: return dist # Explore neighbors for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and maze[new_row][new_col] == 0: visited.add((new_row, new_col)) queue.append((new_row, new_col, dist + 1)) return -1"},{"question":"from typing import List, Tuple def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Finds the shortest path in a grid from start to end using BFS. Args: grid (List[List[int]]): The grid representation (2D list) of the map. start (Tuple[int, int]): Starting position in the grid. end (Tuple[int, int]): Ending position in the grid. Returns: int: The length of the shortest path, or -1 if no path exists. Examples: >>> grid = [ ... [0, 0, 0, 0, 1], ... [1, 1, 1, 0, 1], ... [0, 0, 0, 0, 0], ... [0, 1, 1, 1, 0], ... [0, 0, 0, 1, 0] ... ] >>> shortest_path(grid, (0, 0), (4, 4)) 8 >>> grid = [ ... [0, 1], ... [1, 0] ... ] >>> shortest_path(grid, (0, 0), (1, 1)) -1","solution":"from typing import List, Tuple from collections import deque def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Finds the shortest path in a grid from start to end using BFS. Args: grid (List[List[int]]): The grid representation (2D list) of the map. start (Tuple[int, int]): Starting position in the grid. end (Tuple[int, int]): Ending position in the grid. Returns: int: The length of the shortest path, or -1 if no path exists. # Helper function to check if a cell is within grid bounds and passable def is_valid(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 0 # Directions we can move in the grid: (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initialize queue for BFS queue = deque([(start, 0)]) visited = set() visited.add(start) while queue: (current_x, current_y), dist = queue.popleft() # Check if we have reached the end if (current_x, current_y) == end: return dist # Explore all possible neighboring cells for direction in directions: new_x, new_y = current_x + direction[0], current_y + direction[1] if is_valid(new_x, new_y) and (new_x, new_y) not in visited: visited.add((new_x, new_y)) queue.append(((new_x, new_y), dist + 1)) # If we finished our BFS without finding the end, return -1 return -1"},{"question":"def num_unique_bst(n: int) -> int: Given an integer \`n\`, return the number of structurally unique Binary Search Trees (BSTs) that can be formed using values 1 to \`n\`. Args: n (int): The number of nodes. Returns: int: The number of unique BSTs. Examples: >>> num_unique_bst(1) 1 >>> num_unique_bst(2) 2 >>> num_unique_bst(3) 5 >>> num_unique_bst(4) 14 >>> num_unique_bst(19) 1767263190","solution":"def num_unique_bst(n: int) -> int: # Initialize a list to store the number of unique BSTs for each count of nodes dp = [0] * (n + 1) dp[0] = 1 # An empty tree is one unique BST for nodes in range(1, n + 1): total = 0 for root in range(1, nodes + 1): left = root - 1 # Nodes on the left side of the root right = nodes - root # Nodes on the right side of the root total += dp[left] * dp[right] dp[nodes] = total return dp[n]"},{"question":"def roman_to_integer(roman: str) -> int: Validate the input string as a Roman numeral and convert it to an integer. >>> roman_to_integer(\\"III\\") 3 >>> roman_to_integer(\\"IV\\") 4 >>> roman_to_integer(\\"IX\\") 9 >>> roman_to_integer(\\"LVIII\\") 58 >>> roman_to_integer(\\"MCMXCIV\\") 1994 >>> roman_to_integer(\\"\\") -1 >>> roman_to_integer(\\"IIII\\") -1 >>> roman_to_integer(\\"VV\\") -1 pass","solution":"def roman_to_integer(roman: str) -> int: roman_to_int_map = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } # Rules for valid Roman Numeral valid_subtractive_combinations = ['IV', 'IX', 'XL', 'XC', 'CD', 'CM'] # Validation for an empty string if not roman: return -1 # Step 1: Validate input string is a valid Roman numeral for char in roman: if char not in roman_to_int_map: return -1 # Check valid repetition of characters if 'IIII' in roman or 'VV' in roman or 'XXXX' in roman or 'LL' in roman or 'CCCC' in roman or 'DD' in roman or 'MMMM' in roman: return -1 # Check valid subtractive combinations and non-valid combinations index = 0 while index < len(roman): if index + 1 < len(roman) and (roman[index] + roman[index + 1]) not in valid_subtractive_combinations: if roman[index + 1] in roman_to_int_map and roman_to_int_map[roman[index]] < roman_to_int_map[roman[index + 1]]: return -1 index += 1 # Step 2: Conversion result = 0 i = 0 while i < len(roman): # If this is a subtractive combination if i + 1 < len(roman) and (roman[i] + roman[i + 1]) in valid_subtractive_combinations: result += roman_to_int_map[roman[i + 1]] - roman_to_int_map[roman[i]] i += 2 # Otherwise, just add the value else: result += roman_to_int_map[roman[i]] i += 1 return result"},{"question":"import heapq def shortest_path(graph: dict, start: int) -> dict: Find the shortest path to all nodes from the start node in a weighted undirected graph. Parameters: graph (dict): An adjacency list representation of the graph where keys are vertices and values are lists of tuples (neighbor, weight). start (int): The starting vertex. Returns: dict: A dictionary where keys are nodes and values are the shortest path distances from the start node. # Implement the Dijkstra's algorithm here return {} def test_shortest_path(): test_graph_1 = { 0: [(1, 4), (2, 1)], 1: [(0, 4), (2, 2), (3, 5)], 2: [(0, 1), (1, 2), (3, 8)], 3: [(1, 5), (2, 8)] } assert shortest_path(test_graph_1, 0) == {0: 0, 1: 3, 2: 1, 3: 8} test_graph_2 = { 0: [(1, 10)], 1: [(0, 10), (2, 5)], 2: [(1, 5), (3, 2)], 3: [(2, 2)] } assert shortest_path(test_graph_2, 0) == {0: 0, 1: 10, 2: 15, 3: 17} # Test single node graph test_graph_3 = { 0: [] } assert shortest_path(test_graph_3, 0) == {0: 0} # Test graph with disconnected nodes test_graph_4 = { 0: [(1, 2)], 1: [(0, 2)], 2: [(3, 1)], 3: [(2, 1)] } assert shortest_path(test_graph_4, 0) == {0: 0, 1: 2, 2: float('infinity'), 3: float('infinity')} # Test graph with negative edges (edge case where Dijkstra should not be used in such scenario) test_graph_5 = { 0: [(1, 4)], 1: [(2, -2)], 2: [(3, 3)], 3: [] } assert shortest_path(test_graph_5, 0) == {0: 0, 1: 4, 2: 2, 3: 5} # Dijkstra can handle positive distance propagation correctly test_shortest_path()","solution":"import heapq def shortest_path(graph, start): Find the shortest path to all nodes from the start node in a weighted undirected graph. Parameters: graph (dict): An adjacency list representation of the graph where keys are vertices and values are lists of tuples (neighbor, weight). start (int): The starting vertex. Returns: dict: A dictionary where keys are nodes and values are the shortest path distances from the start node. # Initialize distances to infinity and set distance to start node as 0 distances = {vertex: float('infinity') for vertex in graph} distances[start] = 0 # Priority queue to store vertices to visit priority_queue = [(0, start)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # Nodes can get added to the priority queue multiple times. We only process a vertex the first time we remove it from the priority queue. if current_distance > distances[current_vertex]: continue # Explore neighbors for neighbor, weight in graph[current_vertex]: distance = current_distance + weight # If found a shorter path to the neighbor, update its shortest path and add to the priority queue if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"class BSTNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root: BSTNode | None, value: int) -> BSTNode: Inserts a new integer value into the BST, ensuring the BST properties are maintained. :param root: BSTNode | None - The root node of the BST. :param value: int - The integer value to be inserted into the BST. :return: BSTNode - The root node of the BST after insertion. >>> root = BSTNode(4, ... BSTNode(2, BSTNode(1), BSTNode(3)), ... BSTNode(6, BSTNode(5), BSTNode(7))) >>> new_value = 8 >>> root = insert_into_bst(root, new_value) >>> root.right.right.right.val == 8 True >>> test_insert_into_empty_bst() >>> test_insert_as_left_child() >>> test_insert_as_right_child() >>> test_insert_more_values() pass def test_insert_into_empty_bst(): root = None new_value = 5 root = insert_into_bst(root, new_value) assert root is not None assert root.val == 5 assert root.left is None assert root.right is None def test_insert_as_left_child(): root = BSTNode(10) new_value = 5 root = insert_into_bst(root, new_value) assert root.left is not None assert root.left.val == 5 assert root.right is None def test_insert_as_right_child(): root = BSTNode(10) new_value = 15 root = insert_into_bst(root, new_value) assert root.right is not None assert root.right.val == 15 assert root.left is None def test_insert_more_values(): root = BSTNode(10) values = [5, 15, 3, 7, 13, 18] for val in values: root = insert_into_bst(root, val) # Check root structure assert root.val == 10 assert root.left.val == 5 assert root.right.val == 15 assert root.left.left.val == 3 assert root.left.right.val == 7 assert root.right.left.val == 13 assert root.right.right.val == 18 # Check that links are maintained properly assert root.left.left.left is None assert root.left.left.right is None assert root.left.right.left is None assert root.left.right.right is None assert root.right.left.left is None assert root.right.left.right is None assert root.right.right.left is None assert root.right.right.right is None","solution":"class BSTNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root, value): Inserts a new value into the BST and returns the root of the BST. :param root: BSTNode | None - The root of the BST. :param value: int - The value to be inserted. :return: BSTNode - The root of the BST after insertion. if root is None: return BSTNode(value) if value < root.val: root.left = insert_into_bst(root.left, value) else: root.right = insert_into_bst(root.right, value) return root"},{"question":"from typing import List def is_valid_triangle(side1: float, side2: float, side3: float) -> bool: Determines if three given side lengths can form a valid triangle using the triangle inequality theorem. Parameters: side1 (float): The length of the first side. side2 (float): The length of the second side. side3 (float): The length of the third side. Returns: bool: True if the sides form a valid triangle, False otherwise. Raises: ValueError: If any of the side lengths is not positive. >>> is_valid_triangle(3, 4, 5) == True >>> is_valid_triangle(1, 1, 2) == False >>> is_valid_triangle(0, 4, 5) Traceback (most recent call last): ... ValueError: Side lengths must be positive. pass","solution":"def is_valid_triangle(side1: float, side2: float, side3: float) -> bool: Determines if three given side lengths can form a valid triangle. Parameters: side1 (float): The length of the first side. side2 (float): The length of the second side. side3 (float): The length of the third side. Returns: bool: True if the sides form a valid triangle, False otherwise. Raises: ValueError: If any of the side lengths is not positive. # Check if all sides are positive if side1 <= 0 or side2 <= 0 or side3 <= 0: raise ValueError(\\"Side lengths must be positive.\\") # Apply the triangle inequality theorem if (side1 + side2 > side3) and (side1 + side3 > side2) and (side2 + side3 > side1): return True else: return False"},{"question":"from typing import List, Union def convert_to_celsius(fahrenheit_temps: List[Union[int, float]]) -> List[float]: Converts a list of temperatures from Fahrenheit to Celsius and returns the list of temperatures in Celsius. Each temperature is rounded to two decimal places. Parameters: fahrenheit_temps (List[Union[int, float]]): List of temperatures in Fahrenheit. Returns: List[float]: List of temperatures in Celsius, rounded to two decimal places. >>> convert_to_celsius([32, 212, 0, -40, 100]) [0.00, 100.00, -17.78, -40.00, 37.78] >>> convert_to_celsius([451, -459.67, 77, 68, 104]) [232.78, -273.15, 25.00, 20.00, 40.00]","solution":"from typing import List, Union def convert_to_celsius(fahrenheit_temps: List[Union[int, float]]) -> List[float]: Converts a list of temperatures from Fahrenheit to Celsius and returns the list of temperatures in Celsius. Each temperature is rounded to two decimal places. Parameters: fahrenheit_temps (List[Union[int, float]]): List of temperatures in Fahrenheit. Returns: List[float]: List of temperatures in Celsius, rounded to two decimal places. celsius_temps = [(5/9) * (temp - 32) for temp in fahrenheit_temps] return [round(c, 2) for c in celsius_temps]"},{"question":"import math def factorial_digit_sum(n: int) -> int: Computes the sum of the digits of the factorial of a given number n. :param n: integer where 0 <= n <= 100 :return: sum of the digits of the factorial of n >>> factorial_digit_sum(5) 3 >>> factorial_digit_sum(10) 27","solution":"import math def factorial_digit_sum(n: int) -> int: Computes the sum of the digits of the factorial of a given number n. :param n: integer where 0 <= n <= 100 :return: sum of the digits of the factorial of n factorial_result = math.factorial(n) digit_sum = sum(int(digit) for digit in str(factorial_result)) return digit_sum"},{"question":"from typing import List def num_islands(grid: List[List[int]]) -> int: Count the number of distinct islands in a given 2D binary matrix. >>> num_islands([ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 0, 1], ... [0, 0, 0, 1, 1], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 1, 1] ... ]) 3 >>> num_islands([ ... [1, 0, 0, 1, 0], ... [1, 1, 1, 1, 0], ... [0, 0, 0, 0, 0], ... [0, 1, 0, 1, 1] ... ]) 2","solution":"from typing import List def num_islands(grid: List[List[int]]) -> int: def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return grid[i][j] = 0 # Mark as visited dfs(grid, i + 1, j) # Down dfs(grid, i - 1, j) # Up dfs(grid, i, j + 1) # Right dfs(grid, i, j - 1) # Left if not grid: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: count += 1 dfs(grid, i, j) return count"},{"question":"import heapq from typing import Any class CustomPriorityQueue: def __init__(self, attribute: str, max_heap: bool = True): ''' Initializes the priority queue. Parameters: attribute (str): The attribute of the elements to base the priority on. max_heap (bool): Whether to implement the priority queue as a max-heap or min-heap (default is max-heap). ''' self.queue = [] self.attribute = attribute self.max_heap = max_heap def _get_priority(self, item: object) -> float: ''' Retrieve the value of the specified attribute to determine the priority. Parameters: item (object): The item whose attribute value is used for priority. Returns: float: The priority value based on the specified attribute. ''' # Retrieve the value of the specified attribute value = getattr(item, self.attribute) # If it's a max-heap, we store negative values to simulate max-heap behavior using min-heap return -value if self.max_heap else value def insert(self, item: object): ''' Inserts a new item into the priority queue. Parameters: item (object): The item to be inserted. ''' heapq.heappush(self.queue, (self._get_priority(item), item)) def extract(self) -> object: ''' Extracts the item with the highest priority from the queue. Returns: object: The item with the highest priority based on the specified attribute. ''' if self.is_empty(): raise IndexError(\\"extract from an empty priority queue\\") return heapq.heappop(self.queue)[1] def is_empty(self) -> bool: ''' Checks if the priority queue is empty. Returns: bool: True if the queue is empty, False otherwise. ''' return len(self.queue) == 0 # Example usage: class Employee: def __init__(self, name: str, age: int, salary: float): self.name = name self.age = age self.salary = salary # Test cases def test_priority_queue_max_heap(): pq = CustomPriorityQueue(attribute='salary') emp1 = Employee('Alice', 30, 50000) emp2 = Employee('Bob', 24, 55000) emp3 = Employee('Charlie', 28, 49000) pq.insert(emp1) pq.insert(emp2) pq.insert(emp3) assert pq.extract().name == 'Bob' assert pq.extract().name == 'Alice' assert pq.is_empty() == False assert pq.extract().name == 'Charlie' assert pq.is_empty() == True def test_priority_queue_min_heap(): pq = CustomPriorityQueue(attribute='salary', max_heap=False) emp1 = Employee('Alice', 30, 50000) emp2 = Employee('Bob', 24, 55000) emp3 = Employee('Charlie', 28, 49000) pq.insert(emp1) pq.insert(emp2) pq.insert(emp3) assert pq.extract().name == 'Charlie' assert pq.extract().name == 'Alice' assert pq.is_empty() == False assert pq.extract().name == 'Bob' assert pq.is_empty() == True def test_is_empty_initially(): pq = CustomPriorityQueue(attribute='salary') assert pq.is_empty() == True def test_is_empty_after_inserts_and_extracts(): pq = CustomPriorityQueue(attribute='salary') emp1 = Employee('Alice', 30, 50000) pq.insert(emp1) assert pq.is_empty() == False pq.extract() assert pq.is_empty() == True def test_extract_from_empty_raises(): pq = CustomPriorityQueue(attribute='salary') try: pq.extract() except IndexError as e: assert str(e) == \\"extract from an empty priority queue\\"","solution":"import heapq class CustomPriorityQueue: def __init__(self, attribute: str, max_heap: bool = True): self.queue = [] self.attribute = attribute self.max_heap = max_heap def _get_priority(self, item: object) -> float: # Retrieve the value of the specified attribute value = getattr(item, self.attribute) # If it's a max-heap, we store negative values to simulate max-heap behavior using min-heap return -value if self.max_heap else value def insert(self, item: object): # Create tuple of priority and item and push to the heap heapq.heappush(self.queue, (self._get_priority(item), item)) def extract(self) -> object: if self.is_empty(): raise IndexError(\\"extract from an empty priority queue\\") # Pop from the heap and return the item return heapq.heappop(self.queue)[1] def is_empty(self) -> bool: return len(self.queue) == 0"},{"question":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, current, key): if key < current.val: if current.left: self._insert(current.left, key) else: current.left = Node(key) else: if current.right: self._insert(current.right, key) else: current.right = Node(key) def in_order_traversal(self): Perform in-order traversal and return a list of node values. >>> bst = BST() >>> bst.insert(5) >>> bst.insert(3) >>> bst.insert(7) >>> bst.insert(2) >>> bst.insert(4) >>> bst.insert(6) >>> bst.insert(8) >>> bst.in_order_traversal() [2, 3, 4, 5, 6, 7, 8] pass def find_kth_smallest(self, k): Find and return the k-th smallest element in the BST. >>> bst = BST() >>> bst.insert(5) >>> bst.insert(3) >>> bst.insert(7) >>> bst.insert(2) >>> bst.insert(4) >>> bst.insert(6) >>> bst.insert(8) >>> bst.find_kth_smallest(3) 4 >>> bst.find_kth_smallest(10) None pass","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, current, key): if key < current.val: if current.left: self._insert(current.left, key) else: current.left = Node(key) else: if current.right: self._insert(current.right, key) else: current.right = Node(key) def in_order_traversal(self): result = [] self._in_order_traversal_helper(self.root, result) return result def _in_order_traversal_helper(self, node, result): if not node: return self._in_order_traversal_helper(node.left, result) result.append(node.val) self._in_order_traversal_helper(node.right, result) def find_kth_smallest(self, k): traversal = self.in_order_traversal() if k <= 0 or k > len(traversal): return None return traversal[k - 1]"},{"question":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BinaryTree: def __init__(self, root=None): self.root = root def level_order_traversal(self): Perform a level order traversal (breadth-first traversal) of the binary tree. Returns a list of the values in level order. Unit Test: from solution import Node, BinaryTree def test_empty_tree(): tree = BinaryTree() assert tree.level_order_traversal() == [] def test_single_node_tree(): root = Node(1) tree = BinaryTree(root) assert tree.level_order_traversal() == [1] def test_balanced_tree(): root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.left = Node(6) root.right.right = Node(7) tree = BinaryTree(root) assert tree.level_order_traversal() == [1, 2, 3, 4, 5, 6, 7] def test_left_skewed_tree(): root = Node(1) root.left = Node(2) root.left.left = Node(3) root.left.left.left = Node(4) tree = BinaryTree(root) assert tree.level_order_traversal() == [1, 2, 3, 4] def test_right_skewed_tree(): root = Node(1) root.right = Node(2) root.right.right = Node(3) root.right.right.right = Node(4) tree = BinaryTree(root) assert tree.level_order_traversal() == [1, 2, 3, 4] def test_mixed_tree(): root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.right.right = Node(5) tree = BinaryTree(root) assert tree.level_order_traversal() == [1, 2, 3, 4, 5]","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BinaryTree: def __init__(self, root=None): self.root = root def level_order_traversal(self): if not self.root: return [] queue = [self.root] result = [] while queue: current_node = queue.pop(0) result.append(current_node.data) if current_node.left: queue.append(current_node.left) if current_node.right: queue.append(current_node.right) return result"},{"question":"def classify_tweet_sentiment(tweet: str, vocabulary: dict) -> str: Classify the sentiment of a tweet based on a predefined vocabulary. Parameters: tweet (str): The text of the tweet. vocabulary (dict): Dictionary with words as keys and sentiment scores as values. Returns: str: The sentiment of the tweet: \\"positive\\", \\"negative\\", or \\"neutral\\". Example Usage: >>> tweet = \\"I love sunny days but I hate rain.\\" >>> vocabulary = { ... \\"love\\": 2, \\"sunny\\": 1, \\"days\\": 0, ... \\"but\\": 0, \\"hate\\": -2, \\"rain\\": -1 ... } >>> classify_tweet_sentiment(tweet, vocabulary) 'neutral'","solution":"import re def classify_tweet_sentiment(tweet, vocabulary): Classify the sentiment of a tweet based on a predefined vocabulary. Parameters: - tweet (str): The text of the tweet. - vocabulary (dict): Dictionary with words as keys and sentiment scores as values. Returns: - str: The sentiment of the tweet: \\"positive\\", \\"negative\\", or \\"neutral\\". words = re.findall(r'bw+b', tweet.lower()) sentiment_score = sum(vocabulary.get(word, 0) for word in words) if sentiment_score > 0: return \\"positive\\" elif sentiment_score < 0: return \\"negative\\" else: return \\"neutral\\""},{"question":"from typing import List def find_median_sorted_arrays(nums1: List[int], nums2: List[int]) -> float: Finds the median of the combined sorted array formed by the two sorted input arrays. >>> find_median_sorted_arrays([1, 3], [2]) 2.0 >>> find_median_sorted_arrays([1, 2], [3, 4]) 2.5 >>> find_median_sorted_arrays([-3, -2], [-1]) -2.0 >>> find_median_sorted_arrays([], [1, 2, 3]) 2.0 >>> find_median_sorted_arrays([1, 2, 3], []) 2.0 >>> find_median_sorted_arrays([], []) Traceback (most recent call last): ... IndexError","solution":"from typing import List def find_median_sorted_arrays(nums1: List[int], nums2: List[int]) -> float: Finds the median of the combined sorted array formed by the two sorted input arrays. nums = sorted(nums1 + nums2) length = len(nums) if length % 2 == 1: return float(nums[length // 2]) else: mid1 = (length // 2) - 1 mid2 = length // 2 return (nums[mid1] + nums[mid2]) / 2"},{"question":"class MinHeap: def __init__(self, capacity: int) -> None: Initializes the Min Heap with a given capacity. pass def is_full(self) -> bool: Returns True if the Min Heap is full, otherwise False. pass def is_empty(self) -> bool: Returns True if the Min Heap is empty, otherwise False. pass def insert(self, item: int) -> None: Inserts an item into the Min Heap. If the heap is full, raise an OverflowError. pass def extract_min(self) -> int: Removes and returns the minimum element from the Min Heap. If the heap is empty, raise an IndexError. pass def peek_min(self) -> int: Returns the minimum element from the Min Heap without removing it. If the heap is empty, raise an IndexError. pass def __str__(self) -> str: Returns a string representation of the heap, where elements are space-separated. pass def test_min_heap_initialization(): mh = MinHeap(5) assert mh.is_empty() == True assert mh.is_full() == False def test_min_heap_insert(): mh = MinHeap(5) mh.insert(10) mh.insert(5) mh.insert(30) assert str(mh) == \\"5 10 30\\" def test_min_heap_extract_min(): mh = MinHeap(5) mh.insert(10) mh.insert(5) mh.insert(30) assert mh.extract_min() == 5 assert str(mh) == \\"10 30\\" def test_min_heap_peek_min(): mh = MinHeap(5) mh.insert(10) mh.insert(5) mh.insert(30) assert mh.peek_min() == 5 def test_min_heap_insert_when_full(): mh = MinHeap(2) mh.insert(10) mh.insert(5) try: mh.insert(1) except OverflowError as e: assert str(e) == \\"Heap is full\\" else: assert False, \\"Expected OverflowError\\" def test_min_heap_extract_when_empty(): mh = MinHeap(5) try: mh.extract_min() except IndexError as e: assert str(e) == \\"Heap is empty\\" else: assert False, \\"Expected IndexError\\" def test_min_heap_peek_when_empty(): mh = MinHeap(5) try: mh.peek_min() except IndexError as e: assert str(e) == \\"Heap is empty\\" else: assert False, \\"Expected IndexError\\" def test_min_heap_is_full(): mh = MinHeap(2) mh.insert(10) mh.insert(5) assert mh.is_full() == True def test_min_heap_is_empty(): mh = MinHeap(2) assert mh.is_empty() == True mh.insert(10) mh.extract_min() assert mh.is_empty() == True","solution":"class MinHeap: def __init__(self, capacity: int) -> None: self.capacity = capacity self.size = 0 self.heap = [0] * capacity def is_full(self) -> bool: return self.size == self.capacity def is_empty(self) -> bool: return self.size == 0 def insert(self, item: int) -> None: if self.is_full(): raise OverflowError(\\"Heap is full\\") self.heap[self.size] = item self.size += 1 self._heapify_up(self.size - 1) def extract_min(self) -> int: if self.is_empty(): raise IndexError(\\"Heap is empty\\") min_item = self.heap[0] self.heap[0] = self.heap[self.size - 1] self.size -= 1 self._heapify_down(0) return min_item def peek_min(self) -> int: if self.is_empty(): raise IndexError(\\"Heap is empty\\") return self.heap[0] def __str__(self) -> str: return ' '.join(map(str, self.heap[:self.size])) def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): smallest = index left_child = 2 * index + 1 right_child = 2 * index + 2 if left_child < self.size and self.heap[left_child] < self.heap[smallest]: smallest = left_child if right_child < self.size and self.heap[right_child] < self.heap[smallest]: smallest = right_child if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest)"},{"question":"def a_star_pathfinding(maze, start, goal): Implements the A* pathfinding algorithm to find the shortest path from start to goal in a grid maze. The maze is represented as a 2D list where \`0\` represents an open cell and \`1\` represents an obstacle. The agent can move horizontally or vertically but not diagonally. The heuristic function is the Manhattan distance. >>> maze = [ ... [0, 1, 0, 0], ... [0, 1, 0, 1], ... [0, 0, 0, 1], ... [1, 1, 0, 0] ... ] >>> start = (0, 0) >>> goal = (2, 2) >>> a_star_pathfinding(maze, start, goal) [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)] >>> maze = [ ... [0, 1, 0, 0], ... [0, 1, 0, 1], ... [0, 1, 0, 1], ... [1, 1, 0, 0] ... ] >>> start = (0, 0) >>> goal = (3, 3) >>> a_star_pathfinding(maze, start, goal) []","solution":"import heapq def heuristic(a, b): Calculate the Manhattan distance between point a and point b. return abs(a[0] - b[0]) + abs(a[1] - b[1]) def a_star_pathfinding(maze, start, goal): Implements the A* pathfinding algorithm to find the shortest path from start to goal in a grid maze. rows, cols = len(maze), len(maze[0]) open_set = [] heapq.heappush(open_set, (0, start)) came_from = {} g_score = {start: 0} f_score = {start: heuristic(start, goal)} while open_set: _, current = heapq.heappop(open_set) if current == goal: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) path.reverse() return path for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: neighbor = (current[0] + dx, current[1] + dy) if 0 <= neighbor[0] < rows and 0 <= neighbor[1] < cols and maze[neighbor[0]][neighbor[1]] == 0: tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal) heapq.heappush(open_set, (f_score[neighbor], neighbor)) return []"},{"question":"from typing import List def longest_balanced_subarray(arr: List[int]) -> int: Find the longest balanced subarray where the sum of its elements is zero. >>> longest_balanced_subarray([1, -1, 3, 2, -2, -3, 6]) 6 >>> longest_balanced_subarray([1, 2, 3, 4, 5]) 0","solution":"from typing import List def longest_balanced_subarray(arr: List[int]) -> int: prefix_sum = 0 prefix_sum_indices = {0: -1} max_length = 0 for index, num in enumerate(arr): prefix_sum += num if prefix_sum in prefix_sum_indices: max_length = max(max_length, index - prefix_sum_indices[prefix_sum]) else: prefix_sum_indices[prefix_sum] = index return max_length"},{"question":"def caesar_cipher(text: str, shift: int, mode: str) -> str: Encrypts or decrypts the given text using the Caesar cipher with the specified shift value. The \`mode\` parameter determines whether the function should perform encryption or decryption. >>> caesar_cipher(\\"Hello, World!\\", 3, \\"encrypt\\") \\"Khoor, Zruog!\\" >>> caesar_cipher(\\"Khoor, Zruog!\\", 3, \\"decrypt\\") \\"Hello, World!\\" >>> caesar_cipher(\\"xyz\\", 3, \\"encrypt\\") \\"abc\\" >>> caesar_cipher(\\"abc\\", 3, \\"decrypt\\") \\"xyz\\" >>> caesar_cipher(\\"1234! @#%\\", 5, \\"encrypt\\") \\"1234! @#%\\" >>> caesar_cipher(\\"1234! @#%\\", 5, \\"decrypt\\") \\"1234! @#%\\"","solution":"def caesar_cipher(text: str, shift: int, mode: str) -> str: def shift_char(c, shift_amount): if c.isalpha(): base = ord('A') if c.isupper() else ord('a') return chr((ord(c) - base + shift_amount) % 26 + base) return c if mode == \\"decrypt\\": shift = -shift result = ''.join(shift_char(c, shift) for c in text) return result"},{"question":"def collect_artifacts(artifacts: list, max_fragility: int) -> tuple: Identifies the best set of artifacts to collect, using dynamic programming, to maximize total power without exceeding the fragility threshold. Parameters: artifacts (list of tuples): Each tuple contains (power, fragility). max_fragility (int): The maximum allowable fragility. Returns: (list of tuples, int): A tuple containing the list of selected artifacts and the total power of the collected artifacts. Example: >>> collect_artifacts([(100, 1), (200, 2), (300, 3), (400, 4), (500, 5)], 5) ([(100, 1), (400, 4)], 500)","solution":"def collect_artifacts(artifacts, max_fragility): Identifies the best set of artifacts to collect, using dynamic programming, to maximize total power without exceeding the fragility threshold. Parameters: artifacts (list of tuples): Each tuple contains (power, fragility). max_fragility (int): The maximum allowable fragility. Returns: (list of tuples, int): A tuple containing the list of selected artifacts and the total power of the collected artifacts. n = len(artifacts) # DP table where dp[i][w] represents the maximum power that can be achieved with the first i artifacts and a maximum fragility of w. dp = [[0 for _ in range(max_fragility + 1)] for _ in range(n + 1)] # Backtracking table to find the selected artifacts keep = [[0 for _ in range(max_fragility + 1)] for _ in range(n + 1)] # Populate DP table and keep table for i in range(1, n + 1): power, fragility = artifacts[i - 1] for w in range(1, max_fragility + 1): if fragility <= w: # Consider taking the artifact if power + dp[i - 1][w - fragility] > dp[i - 1][w]: dp[i][w] = power + dp[i - 1][w - fragility] keep[i][w] = 1 else: dp[i][w] = dp[i - 1][w] else: dp[i][w] = dp[i - 1][w] # Backtrack to find the selected artifacts w = max_fragility selected_artifacts = [] for i in range(n, 0, -1): if keep[i][w] == 1: selected_artifacts.append(artifacts[i - 1]) w -= artifacts[i - 1][1] selected_artifacts.reverse() return selected_artifacts, dp[n][max_fragility]"},{"question":"class NumArray: def __init__(self, nums: List[int]): Preprocess the input array to enable efficient range sum queries. pass def sumRange(self, left: int, right: int) -> int: Return sum of elements between indices left and right inclusive. >>> numArray = NumArray([-2, 0, 3, -5, 2, -1]) >>> numArray.sumRange(0, 2) 1 >>> numArray.sumRange(2, 5) -1 >>> numArray.sumRange(0, 5) -3 pass","solution":"class NumArray: def __init__(self, nums): self.prefix_sums = [0] * (len(nums) + 1) for i in range(len(nums)): self.prefix_sums[i + 1] = self.prefix_sums[i] + nums[i] def sumRange(self, left, right): return self.prefix_sums[right + 1] - self.prefix_sums[left]"},{"question":"from typing import List, Tuple def calculate_shipping_cost(orders: List[Tuple[str, int]]) -> int: Computes the total shipping cost for the given list of orders. The categories and corresponding rates are as follows: - 'standard': 5 per item - 'express': 10 per item - 'bulk-standard': 4 per item - 'bulk-express': 8 per item Bulk rates apply when the quantity of any item is 10 or more. Args: orders (List[Tuple[str, int]]): A list of tuples where each tuple contains a string representing the item category and an integer representing the quantity of items ordered. Returns: int: Total shipping cost. >>> calculate_shipping_cost([('standard', 5), ('express', 2), ('bulk-standard', 12), ('bulk-express', 20)]) 253 >>> calculate_shipping_cost([('standard', 1)]) 5 >>> calculate_shipping_cost([('express', 1)]) 10 >>> calculate_shipping_cost([('standard', 10)]) 40 >>> calculate_shipping_cost([('express', 10)]) 80 >>> calculate_shipping_cost([]) 0 >>> calculate_shipping_cost([('standard', 0), ('express', 0), ('bulk-standard', 0), ('bulk-express', 0)]) 0 >>> calculate_shipping_cost([('bulk-standard', 20)]) 80 >>> calculate_shipping_cost([('bulk-express', 5)]) 40 >>> calculate_shipping_cost([('standard', 9)]) 45 >>> calculate_shipping_cost([('express', 9)]) 90","solution":"from typing import List, Tuple def calculate_shipping_cost(orders: List[Tuple[str, int]]) -> int: Computes the total shipping cost for the given list of orders. Args: orders (List[Tuple[str, int]]): A list of tuples where each tuple contains a string representing the item category and an integer representing the quantity of items ordered. Returns: int: Total shipping cost. total_cost = 0 rates = { 'standard': 5, 'express': 10, 'bulk-standard': 4, 'bulk-express': 8 } for category, quantity in orders: if quantity >= 10: if category == 'standard': rate = rates['bulk-standard'] elif category == 'express': rate = rates['bulk-express'] else: rate = rates[category] else: rate = rates[category] total_cost += rate * quantity return total_cost"},{"question":"def custom_fibonacci(F0: int, F1: int, n: int) -> list: Generates the first n numbers in a custom Fibonacci sequence starting with F0 and F1. Parameters: F0 (int): The first number in the sequence. F1 (int): The second number in the sequence. n (int): The number of terms to generate. Returns: list: A list of the first n terms in the sequence. Examples: >>> custom_fibonacci(0, 1, 5) [0, 1, 1, 2, 3] >>> custom_fibonacci(2, 3, 5) [2, 3, 5, 8, 13] >>> custom_fibonacci(-1, 1, 6) [-1, 1, 0, 1, 1, 2] >>> custom_fibonacci(5, 10, 1) [5] >>> custom_fibonacci(5, 10, 2) [5, 10]","solution":"def custom_fibonacci(F0: int, F1: int, n: int) -> list: Generates the first n numbers in a Fibonacci sequence starting with F0 and F1. Parameters: F0 (int): The first number in the sequence. F1 (int): The second number in the sequence. n (int): The number of terms to generate. Returns: list: A list of the first n terms in the sequence. if n == 1: return [F0] if n == 2: return [F0, F1] sequence = [F0, F1] for i in range(2, n): next_term = sequence[-1] + sequence[-2] sequence.append(next_term) return sequence"},{"question":"def find_max_length(nums: list[int]) -> int: Given a list of integers, find the length of the longest contiguous subarray with an equal number of 0s and 1s. Args: nums (list of int): A list of integers where each element is either 0 or 1. Returns: int: The length of the longest contiguous subarray with an equal number of 0s and 1s. Raises: ValueError: If the input list is empty. Examples: >>> find_max_length([0, 1, 0]) 2 >>> find_max_length([0, 1, 0, 0, 1, 1, 0]) 6 >>> find_max_length([0, 0, 1, 1, 0]) 4 >>> find_max_length([1, 1, 1, 1]) 0 >>> find_max_length([]) Traceback (most recent call last): ... ValueError: Input list cannot be empty","solution":"def find_max_length(nums: list[int]) -> int: if not nums: raise ValueError(\\"Input list cannot be empty\\") # Convert all 0s to -1s to make the problem similar to finding a subarray with sum zero nums = [-1 if num == 0 else 1 for num in nums] max_length = 0 cumulative_sum = 0 sum_indices = {0: -1} # Cumulative sum has been seen at index -1 as initial condition for index, num in enumerate(nums): cumulative_sum += num if cumulative_sum in sum_indices: max_length = max(max_length, index - sum_indices[cumulative_sum]) else: sum_indices[cumulative_sum] = index return max_length"},{"question":"def subtree_sum(values: List[int], edges: List[Tuple[int, int]], target: int) -> int: Compute the sum of the values of all nodes in the subtree rooted at a given target node. >>> values = [1, 2, 3, 4, 5] >>> edges = [(0, 1), (0, 2), (1, 3), (1, 4)] >>> target = 1 >>> subtree_sum(values, edges, target) 11 >>> values = [10] >>> edges = [] >>> target = 0 >>> subtree_sum(values, edges, target) 10 >>> values = [5, 3, 8, 2, 4, 7, 9, 1, 6] >>> edges = [(0, 1), (0, 2), (1, 3), (1, 4), (2, 5), (2, 6), (4, 7), (6, 8)] >>> target = 2 >>> subtree_sum(values, edges, target) 30 >>> values = [5, 3, 8, 2, 4, 7, 9, 1, 6] >>> edges = [(0, 1), (0, 2), (1, 3), (1, 4), (2, 5), (2, 6), (4, 7), (6, 8)] >>> target = 8 >>> subtree_sum(values, edges, target) 6","solution":"from typing import List, Tuple def subtree_sum(values: List[int], edges: List[Tuple[int, int]], target: int) -> int: # Create a dictionary to store the adjacency list of the tree tree = {} for parent, child in edges: if parent in tree: tree[parent].append(child) else: tree[parent] = [child] def dfs(node: int) -> int: # Start with the value of the current node total = values[node] # Add the sum of the values of all sub-nodes recursively if node in tree: for child in tree[node]: total += dfs(child) return total return dfs(target)"},{"question":"def job_match_score(candidate_keywords: set, job_keywords: set) -> float: Calculate the match score of candidate keywords against job keywords. Parameters: - candidate_keywords (set): A set of keywords associated with the job candidate. - job_keywords (set): A set of keywords associated with the job title. Returns: - float: The match score as a percentage. Exceptions: - Raise ValueError if either of the input sets is empty.","solution":"def job_match_score(candidate_keywords: set, job_keywords: set) -> float: Calculate the match score of candidate keywords against job keywords. Parameters: - candidate_keywords (set): A set of keywords associated with the job candidate. - job_keywords (set): A set of keywords associated with the job title. Returns: - float: The match score as a percentage. Exceptions: - Raise ValueError if either of the input sets is empty. # Check for empty sets if not candidate_keywords or not job_keywords: raise ValueError(\\"Input sets must not be empty\\") # Calculate the number of matching keywords matching_keywords = candidate_keywords.intersection(job_keywords) # Calculate the match score as a percentage match_score = (len(matching_keywords) / len(candidate_keywords)) * 100 return match_score"},{"question":"def flatten(nested_list: list) -> list: Flattens a nested list of arbitrary depth into a single list containing all the elements. Parameters: nested_list (list): A nested list of arbitrary depth. Returns: list: A flat list containing all the elements. Raises: TypeError: If the input is not a list. >>> flatten([1, [2, [3, 4], 5], 6]) [1, 2, 3, 4, 5, 6] >>> flatten([1, 2, 3]) [1, 2, 3] >>> flatten([]) [] pass","solution":"def flatten(nested_list: list) -> list: Flattens a nested list of arbitrary depth into a single list containing all the elements. Parameters: nested_list (list): A nested list of arbitrary depth. Returns: list: A flat list containing all the elements. Raises: TypeError: If the input is not a list. if not isinstance(nested_list, list): raise TypeError(\\"Input must be a list\\") flat_list = [] for element in nested_list: if isinstance(element, list): flat_list.extend(flatten(element)) else: flat_list.append(element) return flat_list"},{"question":"def count_unique_elements_in_range(arr: List[int], L: int, R: int) -> int: Returns the count of unique elements in the range [L, R] inclusive in a sorted array. >>> count_unique_elements_in_range([1, 2, 2, 3, 4, 4, 5], 2, 4) 3 >>> count_unique_elements_in_range([-10, -5, 0, 5, 10], -5, 5) 3","solution":"from typing import List import bisect def count_unique_elements_in_range(arr: List[int], L: int, R: int) -> int: Returns the count of unique elements in the range [L, R] inclusive in a sorted array. start_index = bisect.bisect_left(arr, L) # find the first index where arr[index] >= L end_index = bisect.bisect_right(arr, R) # find the first index where arr[index] > R unique_elements = set(arr[start_index:end_index]) return len(unique_elements)"},{"question":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths in an MxN grid from the top-left corner to the bottom-right corner. The robot can move either right or down at each step. Parameters: m (int): The number of rows in the grid. Must be positive. n (int): The number of columns in the grid. Must be positive. Returns: int: The number of unique paths the robot can take to reach the bottom-right corner. Raises: ValueError: If any of the input values for m or n are non-positive. Examples: >>> unique_paths(3, 7) 28 >>> unique_paths(3, 2) 3 >>> unique_paths(7, 3) 28","solution":"def unique_paths(m, n): if m <= 0 or n <= 0: raise ValueError(\\"Both m and n must be positive integers.\\") # Initialize a 2D list dp where dp[i][j] represents the number of unique paths to cell (i, j) dp = [[1] * n for _ in range(m)] # Initially set all cells to 1 for i in range(1, m): for j in range(1, n): # The number of unique paths to cell (i, j) is the sum of the number of unique paths # to the cell directly above (i-1, j) and to the cell directly to the left (i, j-1) dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[-1][-1]"},{"question":"import time class TokenBucket: def __init__(self): self.rate = 0 self.capacity = 0 self.tokens = 0 self.last_time = time.time() def initialize(self, rate: int, capacity: int): self.rate = rate self.capacity = capacity self.tokens = capacity self.last_time = time.time() def consume(self, tokens: int) -> bool: self.add_tokens() if self.tokens >= tokens: self.tokens -= tokens return True return False def add_tokens(self): current_time = time.time() elapsed = current_time - self.last_time tokens_to_add = int(elapsed * self.rate) self.tokens = min(self.capacity, self.tokens + tokens_to_add) self.last_time = current_time def reset(self, rate: int, capacity: int): self.rate = rate self.capacity = capacity self.tokens = capacity self.last_time = time.time() # Instance to use for the functions token_bucket = TokenBucket() def initialize(rate: int, capacity: int): Initializes the token bucket with a specified rate of token addition and a maximum capacity. Args: rate (int): Rate at which tokens are added to the bucket per second. capacity (int): Maximum number of tokens the bucket can hold. token_bucket.initialize(rate, capacity) def consume(tokens: int) -> bool: Tries to consume the specified number of tokens from the bucket. Returns True if tokens were successfully consumed, else False. Args: tokens (int): Number of tokens to consume. Returns: bool: True if tokens were consumed successfully, False otherwise. return token_bucket.consume(tokens) def add_tokens(): Adds tokens to the bucket at the specified rate, up to the maximum capacity. token_bucket.add_tokens() def reset(rate: int, capacity: int): Resets the bucket to a new rate and capacity. Args: rate (int): New rate at which tokens are added to the bucket per second. capacity (int): New maximum number of tokens the bucket can hold. token_bucket.reset(rate, capacity) import pytest import time def test_initialize(): initialize(5, 20) assert consume(5) == True assert consume(20) == False def test_consume(): initialize(10, 10) assert consume(5) == True # Consume 5 tokens, 5 should remain assert consume(6) == False # Not enough tokens to consume 6 assert consume(5) == True # Consume the remaining 5 tokens def test_add_tokens(): initialize(1, 10) assert consume(10) == True # Consume all tokens assert consume(1) == False # No tokens left time.sleep(2) # Wait for 2 seconds to add tokens add_tokens() # Explicitly call add_tokens (normally called periodically) assert consume(2) == True # Tokens should be replenished by 2 def test_reset(): initialize(1, 10) assert consume(10) == True # Consume all tokens reset(5, 15) time.sleep(1) add_tokens() assert consume(5) == True # New rate should add 5 tokens assert consume(10) == True # Should be able to consume additional 10 tokens # Run the tests when this script is executed directly. if __name__ == \\"__main__\\": pytest.main()","solution":"import time class TokenBucket: def __init__(self): self.rate = 0 self.capacity = 0 self.tokens = 0 self.last_time = time.time() def initialize(self, rate: int, capacity: int): self.rate = rate self.capacity = capacity self.tokens = capacity self.last_time = time.time() def consume(self, tokens: int) -> bool: self.add_tokens() if self.tokens >= tokens: self.tokens -= tokens return True return False def add_tokens(self): current_time = time.time() elapsed = current_time - self.last_time tokens_to_add = int(elapsed * self.rate) self.tokens = min(self.capacity, self.tokens + tokens_to_add) self.last_time = current_time def reset(self, rate: int, capacity: int): self.rate = rate self.capacity = capacity self.tokens = capacity self.last_time = time.time() # Instance to use for the functions token_bucket = TokenBucket() def initialize(rate: int, capacity: int): token_bucket.initialize(rate, capacity) def consume(tokens: int) -> bool: return token_bucket.consume(tokens) def add_tokens(): token_bucket.add_tokens() def reset(rate: int, capacity: int): token_bucket.reset(rate, capacity)"},{"question":"from typing import List def are_rotations(list_a: List[int], list_b: List[int]) -> bool: Given two lists of integers, determine if one list is a rotation of the other. >>> are_rotations([1, 2, 3], [3, 1, 2]) True >>> are_rotations([1, 2, 3], [1, 3, 2]) False pass def test_different_length_lists(): assert not are_rotations([1, 2, 3], [1, 2]) def test_identical_lists(): assert are_rotations([1, 2, 3], [1, 2, 3]) def test_single_element_lists(): assert are_rotations([1], [1]) def test_simple_rotation(): assert are_rotations([1, 2, 3], [2, 3, 1]) assert are_rotations([1, 2, 3], [3, 1, 2]) def test_complex_rotation(): assert are_rotations([1, 1, 2], [2, 1, 1]) assert are_rotations([1, 2, 1], [1, 1, 2]) def test_non_rotations(): assert not are_rotations([1, 2, 3], [3, 2, 1]) assert not are_rotations([1, 2, 3], [1, 3, 2]) def test_rotations_of_repeating_elements(): assert are_rotations([2, 2, 2, 2], [2, 2, 2, 2])","solution":"def are_rotations(list_a: list, list_b: list) -> bool: Determine if list_b is a rotation of list_a. if len(list_a) != len(list_b): return False concatenated = list_a + list_a return ' '.join(map(str, list_b)) in ' '.join(map(str, concatenated))"},{"question":"def analyze_grades(grades: list) -> dict: Analyze a list of grades to provide summary statistics. Parameters: grades : list : A list of numerical grades. Returns: dict: A dictionary containing the average, highest, lowest, and median grades. Raises: ValueError: If the \`grades\` list is empty. Example: >>> analyze_grades([85, 92, 76, 88, 100, 69]) {'average': 85.0, 'highest': 100.0, 'lowest': 69.0, 'median': 86.5} >>> analyze_grades([50]) {'average': 50.0, 'highest': 50.0, 'lowest': 50.0, 'median': 50.0} >>> analyze_grades([]) ValueError: The list of grades must not be empty. # Your implementation here pass # Test cases print(analyze_grades([85, 92, 76, 88, 100, 69])) # Output: {'average': 85.0, 'highest': 100.0, 'lowest': 69.0, 'median': 86.5} print(analyze_grades([50])) # Output: {'average': 50.0, 'highest': 50.0, 'lowest': 50.0, 'median': 50.0} print(analyze_grades([70, 80, 90])) # Output: {'average': 80.0, 'highest': 90.0, 'lowest': 70.0, 'median': 80.0}","solution":"def analyze_grades(grades): Analyze a list of grades to provide summary statistics. Parameters: grades : list : A list of numerical grades. Returns: dict: A dictionary containing the average, highest, lowest, and median grades. Raises: ValueError: If the \`grades\` list is empty. if not grades: raise ValueError(\\"The list of grades must not be empty.\\") n = len(grades) grades_sorted = sorted(grades) average = sum(grades) / n highest = max(grades) lowest = min(grades) if n % 2 == 1: median = grades_sorted[n // 2] else: median = (grades_sorted[n // 2 - 1] + grades_sorted[n // 2]) / 2 return { \\"average\\": average, \\"highest\\": highest, \\"lowest\\": lowest, \\"median\\": median }"},{"question":"def flatten_json_structure(nested_dict: dict) -> dict: Flatten a nested dictionary representing a JSON-like structure. The function should traverse the dictionary and produce a flattened version where the keys are the paths from the root to the original key, joined by dots. Args: nested_dict (dict): A nested dictionary to flatten. Returns: dict: A single-level dictionary with dot-separated paths as keys. Example: >>> flatten_json_structure({ ... \\"a\\": { ... \\"b\\": { ... \\"c\\": 1 ... }, ... \\"d\\": 2 ... }, ... \\"e\\": 3 ... }) {'a.b.c': 1, 'a.d': 2, 'e': 3} >>> flatten_json_structure({\\"key1\\": {\\"key2\\": {\\"key3\\": 4}}, \\"key4\\": 5}) {'key1.key2.key3': 4, 'key4': 5} pass","solution":"def flatten_json_structure(nested_dict, parent_key='', sep='.'): items = {} for k, v in nested_dict.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.update(flatten_json_structure(v, new_key, sep=sep)) else: items[new_key] = v return items"},{"question":"def generate_permutations(elements: list, n: int) -> list[tuple]: Generate all possible permutations of length n from the list elements. Args: elements (list): A list containing unique elements to generate permutations from. n (int): The length of each permutation. Returns: list[tuple]: A list containing tuples, each tuple representing a permutation of n elements. >>> generate_permutations([10, 20, 30], 2) [(10, 20), (10, 30), (20, 10), (20, 30), (30, 10), (30, 20)] >>> generate_permutations([1, 2, 3], 1) [(1,), (2,), (3,)] >>> generate_permutations(['a', 'b'], 2) [('a', 'b'), ('b', 'a')] >>> generate_permutations([5], 1) [(5,)] >>> generate_permutations([12, 'x', 15.6], 2) [(12, 'x'), (12, 15.6), ('x', 12), ('x', 15.6), (15.6, 12), (15.6, 'x')] >>> generate_permutations([], 0) [()] >>> generate_permutations([100, 200], 0) [()] >>> generate_permutations([1, 2, 3], 4) [] >>> generate_permutations([1, 2, 3, 4], 3) [(1, 2, 3), (1, 2, 4), (1, 3, 2), (1, 3, 4), (1, 4, 2), (1, 4, 3), (2, 1, 3), (2, 1, 4), (2, 3, 1), (2, 3, 4), (2, 4, 1), (2, 4, 3), (3, 1, 2), (3, 1, 4), (3, 2, 1), (3, 2, 4), (3, 4, 1), (3, 4, 2), (4, 1, 2), (4, 1, 3), (4, 2, 1), (4, 2, 3), (4, 3, 1), (4, 3, 2)]","solution":"def generate_permutations(elements: list, n: int) -> list[tuple]: def backtrack(path, remaining): if len(path) == n: result.append(tuple(path)) return for i in range(len(remaining)): path.append(remaining[i]) backtrack(path, remaining[:i] + remaining[i+1:]) path.pop() if n == 0: return [()] if n > len(elements): return [] result = [] backtrack([], elements) return result"},{"question":"class LRUCache: Implement an LRU (Least Recently Used) Cache. Example usage: cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # returns 1 cache.put(3, 3) # evicts key 2 print(cache.get(2)) # returns -1 (not found) cache.put(4, 4) # evicts key 1 print(cache.get(1)) # returns -1 (not found) print(cache.get(3)) # returns 3 print(cache.get(4)) # returns 4 def __init__(self, capacity: int): Initialize the LRU cache with a given capacity. pass def get(self, key: int) -> int: Return the value of the key if the key exists, otherwise return -1. pass def put(self, key: int, value: int) -> None: Update the value of the key if the key exists, otherwise add the key-value pair to the cache. If the cache reaches its capacity, evict the least recently used item. pass import pytest from solution import LRUCache def test_lru_cache_operations(): cache = LRUCache(2) # Perform put operations cache.put(1, 1) cache.put(2, 2) # Test get operation assert cache.get(1) == 1 # Test put operation causing eviction cache.put(3, 3) # This should evict key 2 assert cache.get(2) == -1 # Key 2 should be evicted, return -1 assert cache.get(3) == 3 # Cache should return 3 # Test evicting another key cache.put(4, 4) # This should evict key 1 assert cache.get(1) == -1 # Key 1 should be evicted, return -1 assert cache.get(3) == 3 # Cache should return 3 assert cache.get(4) == 4 # Cache should return 4 def test_lru_cache_update(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # Update value of an existing key cache.put(1, 10) assert cache.get(1) == 10 # Value should be updated to 10 # Ensure it still respects the LRU policy cache.put(3, 3) # This should evict key 2, not 1 assert cache.get(2) == -1 # Key 2 should be evicted assert cache.get(1) == 10 # Key 1 should return updated value 10 assert cache.get(3) == 3 # Key 3 should return 3 def test_lru_cache_capacity_one(): cache = LRUCache(1) cache.put(1, 1) assert cache.get(1) == 1 cache.put(2, 2) assert cache.get(1) == -1 # Key 1 should be evicted, return -1 assert cache.get(2) == 2 # Key 2 should be present, return 2 def test_lru_cache_no_eviction(): cache = LRUCache(3) cache.put(1, 1) cache.put(2, 2) cache.put(3, 3) assert cache.get(1) == 1 assert cache.get(2) == 2 assert cache.get(3) == 3 cache.put(4, 4) # This should evict key 1 (LRU) assert cache.get(1) == -1 # Key 1 should be evicted assert cache.get(2) == 2 # Key 2 should be present assert cache.get(3) == 3 # Key 3 should be present assert cache.get(4) == 4 # Key 4 should be present","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 # Move the accessed key to the end to mark it as recently used self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: # Update the value and mark it as recently used self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: # Pop the first item from the cache (least recently used) self.cache.popitem(last=False)"},{"question":"import collections class MyStack: def __init__(self): self.queue1 = collections.deque() self.queue2 = collections.deque() def push(self, element: int) -> None: Push an element onto the stack. Args: element (int): The element to be pushed onto the stack. pass def pop(self) -> int: Remove and return the top element from the stack. Returns: int: The top element of the stack. pass def top(self) -> int: Return the top element of the stack without removing it. Returns: int: The top element of the stack. pass def is_empty(self) -> bool: Check if the stack is empty. Returns: bool: True if the stack is empty, False otherwise. pass # Unit Tests def test_stack_push_and_top(): stack = MyStack() stack.push(1) assert stack.top() == 1 stack.push(2) assert stack.top() == 2 stack.push(3) assert stack.top() == 3 def test_stack_pop(): stack = MyStack() stack.push(1) stack.push(2) stack.push(3) assert stack.pop() == 3 assert stack.pop() == 2 assert stack.pop() == 1 def test_stack_empty(): stack = MyStack() assert stack.is_empty() == True stack.push(1) assert stack.is_empty() == False stack.pop() assert stack.is_empty() == True def test_stack_operations_sequence(): stack = MyStack() stack.push(1) stack.push(2) stack.push(3) assert stack.pop() == 3 stack.push(4) assert stack.top() == 4 assert stack.pop() == 4 assert stack.pop() == 2 assert stack.pop() == 1 assert stack.is_empty() == True","solution":"import collections class MyStack: def __init__(self): self.queue1 = collections.deque() self.queue2 = collections.deque() def push(self, element: int) -> None: self.queue1.append(element) def pop(self) -> int: while len(self.queue1) > 1: self.queue2.append(self.queue1.popleft()) top_element = self.queue1.popleft() self.queue1, self.queue2 = self.queue2, self.queue1 return top_element def top(self) -> int: while len(self.queue1) > 1: self.queue2.append(self.queue1.popleft()) top_element = self.queue1.popleft() self.queue2.append(top_element) self.queue1, self.queue2 = self.queue2, self.queue1 return top_element def is_empty(self) -> bool: return len(self.queue1) == 0"},{"question":"def string_interleave(s1: str, s2: str) -> str: Merges two strings by alternating their characters. If one string is longer than the other, append the remaining characters of the longer string at the end of the result. Args: s1 (str): The first input string. s2 (str): The second input string. Returns: str: The interleaved result of s1 and s2. Example: >>> string_interleave(\\"abc\\", \\"123\\") 'a1b2c3' >>> string_interleave(\\"ab\\", \\"123\\") 'a1b23' >>> string_interleave(\\"abcd\\", \\"12\\") 'a1b2cd' >>> string_interleave(\\"\\", \\"xyz\\") 'xyz' >>> string_interleave(\\"hello\\", \\"\\") 'hello'","solution":"def string_interleave(s1: str, s2: str) -> str: Merges two strings by alternating their characters. If one string is longer than the other, append the remaining characters of the longer string at the end of the result. Args: s1 (str): The first input string. s2 (str): The second input string. Returns: str: The interleaved result of s1 and s2. result = [] len1, len2 = len(s1), len(s2) min_len = min(len1, len2) for i in range(min_len): result.append(s1[i]) result.append(s2[i]) # Append remaining part of the longer string if len1 > len2: result.append(s1[min_len:]) elif len2 > len1: result.append(s2[min_len:]) return ''.join(result)"},{"question":"from typing import List, Dict, Union def process_employee_data(employee_data: List[Dict[str, Union[str, int, float]]]) -> Dict[str, Dict[str, Union[int, float]]]: Process a list of employee records to summarize information by department. Args: - employee_data: A list of dictionaries with employee details such as name, department, salary, and years_of_experience. Returns: - A dictionary where keys are department names and values are dictionaries summarizing: * total_employees: Total number of employees in the department. * average_salary: Average salary of employees in the department. * average_experience: Average years of experience of employees in the department. All average values should be rounded to two decimal places. Example: >>> employee_data = [ ... {\\"name\\": \\"Alice Johnson\\", \\"department\\": \\"Engineering\\", \\"salary\\": 80000, \\"years_of_experience\\": 5}, ... {\\"name\\": \\"Bob Smith\\", \\"department\\": \\"HR\\", \\"salary\\": 50000, \\"years_of_experience\\": 3}, ... {\\"name\\": \\"Carol White\\", \\"department\\": \\"Engineering\\", \\"salary\\": 90000, \\"years_of_experience\\": 6}, ... {\\"name\\": \\"David Brown\\", \\"department\\": \\"Sales\\", \\"salary\\": 55000, \\"years_of_experience\\": 4} ... ] >>> process_employee_data(employee_data) { 'Engineering': { 'total_employees': 2, 'average_salary': 85000.0, 'average_experience': 5.5 }, 'HR': { 'total_employees': 1, 'average_salary': 50000.0, 'average_experience': 3.0 }, 'Sales': { 'total_employees': 1, 'average_salary': 55000.0, 'average_experience': 4.0 } }","solution":"from typing import List, Dict, Union def process_employee_data(employee_data: List[Dict[str, Union[str, int, float]]]) -> Dict[str, Dict[str, Union[int, float]]]: Process employee data to summarize information by department. Args: - employee_data: A list of dictionaries containing employee details. Returns: - A dictionary summarizing data by department. department_summary = {} for record in employee_data: department = record['department'] salary = record['salary'] experience = record['years_of_experience'] if department not in department_summary: department_summary[department] = { 'total_employees': 0, 'total_salary': 0.0, 'total_experience': 0 } department_summary[department]['total_employees'] += 1 department_summary[department]['total_salary'] += salary department_summary[department]['total_experience'] += experience result = {} for department, summary in department_summary.items(): total_employees = summary['total_employees'] if total_employees > 0: result[department] = { 'total_employees': total_employees, 'average_salary': round(summary['total_salary'] / total_employees, 2), 'average_experience': round(summary['total_experience'] / total_employees, 2) } return result"},{"question":"class ExpressionEvaluator: def __init__(self): Initialize the ExpressionEvaluator with necessary operators. pass def parse_expression(self, expression: str): Parse the given mathematical expression from string format into a suitable format for evaluation. pass def evaluate_expression(self, parsed_expression) -> float: Evaluate the parsed mathematical expression and return the result. pass def evaluate_math_expression(expression: str) -> float: Parses and evaluates the given mathematical expression. >>> evaluate_math_expression(\\"3 + (2 - 5) * 6 / 3\\") -3.0 >>> evaluate_math_expression(\\"10 + 2 * (6 / 3) - 5\\") 9.0 >>> evaluate_math_expression(\\"(1 + 2) * (3 - 4) / 2\\") -1.5 pass","solution":"import ast import operator class ExpressionEvaluator: def __init__(self): self.operators = { ast.Add: operator.add, ast.Sub: operator.sub, ast.Mult: operator.mul, ast.Div: operator.truediv } def parse_expression(self, expression: str): Parses the mathematical expression into an AST (Abstract Syntax Tree). # Remove whitespaces expression = expression.replace(\\" \\", \\"\\") return ast.parse(expression, mode='eval').body def evaluate_expression(self, node): Evaluates the given AST node recursively. if isinstance(node, ast.Num): # <number> return node.n elif isinstance(node, ast.BinOp): # <left> <operator> <right> left = self.evaluate_expression(node.left) right = self.evaluate_expression(node.right) op = self.operators[type(node.op)] return op(left, right) elif isinstance(node, ast.UnaryOp): # - <operand> operand = self.evaluate_expression(node.operand) if isinstance(node.op, ast.UAdd): return +operand elif isinstance(node.op, ast.USub): return -operand else: raise TypeError(node) def evaluate_math_expression(expression: str) -> float: evaluator = ExpressionEvaluator() parsed_expr = evaluator.parse_expression(expression) return evaluator.evaluate_expression(parsed_expr)"},{"question":"def traffic_lights(start: Tuple[int, int], end: Tuple[int, int]) -> int: Calculate the minimum number of traffic lights a car would encounter traveling between two intersections on a grid. Each intersection has a traffic light, but the start and end intersections do not count as passed lights. Args: start (Tuple[int, int]): Coordinates (x, y) of the starting intersection. end (Tuple[int, int]): Coordinates (x, y) of the ending intersection. Returns: int: The number of traffic lights the car passes through on the shortest path. Examples: >>> traffic_lights((0, 0), (2, 2)) 4 >>> traffic_lights((0, 0), (0, 0)) 0 >>> traffic_lights((0, 0), (-1, -1)) 2 >>> traffic_lights((0, 0), (1, 0)) 1 from typing import Tuple def test_traffic_lights_no_movement(): assert traffic_lights((0, 0), (0, 0)) == 0 def test_traffic_lights_simple_movement(): assert traffic_lights((0, 0), (2, 2)) == 4 assert traffic_lights((1, 1), (3, 3)) == 4 assert traffic_lights((0, 0), (0, 1)) == 1 assert traffic_lights((0, 0), (1, 0)) == 1 def test_traffic_lights_negative_coordinates(): assert traffic_lights((0, 0), (-1, -1)) == 2 assert traffic_lights((-1, -1), (1, 1)) == 4 assert traffic_lights((-2, -3), (2, 3)) == 10 def test_traffic_lights_large_coordinates(): assert traffic_lights((1000, 1000), (0, 0)) == 2000 assert traffic_lights((-1000, -1000), (1000, 1000)) == 4000","solution":"from typing import Tuple def traffic_lights(start: Tuple[int, int], end: Tuple[int, int]) -> int: Returns the minimum number of traffic lights a car would encounter traveling from the start intersection to the end intersection on a grid. start_x, start_y = start end_x, end_y = end # Calculate the total number of intersections between both points. return abs(end_x - start_x) + abs(end_y - start_y)"},{"question":"def find_overlaps(schedules): Find overlapping delivery schedule periods. :param schedules: List[Tuple[int, int]] - List of delivery schedules. :return: List[Tuple[int, int]] - List of overlapping periods. Example: >>> find_overlaps([(1, 5), (4, 8), (10, 12), (11, 13)]) [(4, 5), (11, 12)] >>> find_overlaps([(0, 3), (4, 6), (7, 10)]) [] >>> find_overlaps([(1, 5), (2, 6), (7, 9), (8, 10)]) [(2, 5), (8, 9)]","solution":"def find_overlaps(schedules): Find overlapping delivery schedule periods. :param schedules: List[Tuple[int, int]] - List of delivery schedules. :return: List[Tuple[int, int]] - List of overlapping periods. overlaps = [] schedules.sort() for i in range(len(schedules) - 1): current_start, current_end = schedules[i] next_start, next_end = schedules[i + 1] if current_end > next_start: overlaps.append((next_start, min(current_end, next_end))) return overlaps"},{"question":"from collections import Counter def find_modes(numbers: list) -> list: Finds the mode(s) of a given list of integers. Args: numbers: A list of integers. Returns: A list of the mode(s). pass # Unit Tests def test_find_modes_empty(): assert find_modes([]) == [] def test_find_modes_single_element(): assert find_modes([10]) == [10] def test_find_modes_no_repeats(): assert find_modes([1, 2, 3, 4]) == [1, 2, 3, 4] def test_find_modes_simple_mode(): assert find_modes([1, 2, 2, 3, 3, 4]) == [2, 3] def test_find_modes_with_single_mode(): assert find_modes([4, 5, 6, 6, 5, 5]) == [5] def test_find_modes_multiple_modes(): assert find_modes([1,1,2,2]) == [1, 2] def test_find_modes_negative_numbers(): assert find_modes([-1, -1, -2, -2, -3, -3, -3]) == [-3] def test_find_modes_large_range(): assert find_modes(range(-1000, 1001)) == list(range(-1000, 1001)) def test_find_modes_repeated_large_numbers(): assert find_modes([1000000, 1000000, 999999, 999999, -1000000, -1000000]) == [-1000000, 999999, 1000000]","solution":"from collections import Counter def find_modes(numbers: list) -> list: Finds the mode(s) of a given list of integers. Args: numbers: A list of integers. Returns: A list of the mode(s). if not numbers: return [] count = Counter(numbers) max_frequency = max(count.values()) modes = [number for number, frequency in count.items() if frequency == max_frequency] return sorted(modes)"},{"question":"class QueueUsingStacks: Implement a queue using two stacks. >>> q = QueueUsingStacks() >>> q.enqueue(10) >>> q.enqueue(20) >>> q.dequeue() 10 >>> q.dequeue() 20 >>> q.dequeue() Exception: Queue is empty >>> q.enqueue(30) >>> q.enqueue(40) >>> q.dequeue() 30 >>> q.enqueue(50) >>> q.dequeue() 40 >>> q.dequeue() 50 def __init__(self): pass def enqueue(self, element: int): pass def dequeue(self) -> int: pass","solution":"class QueueUsingStacks: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, element: int): self.stack1.append(element) def dequeue(self) -> int: if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) if not self.stack2: raise Exception(\\"Queue is empty\\") return self.stack2.pop()"},{"question":"def min_stops(locations: List[int], start: int) -> int: Calculate the minimum number of stops required to pick up all passengers. >>> min_stops([1, 2, 3, 4, 5], 0) 6 >>> min_stops([10, 20, 30], 25) 4 >>> min_stops([5, 8, 3, 1], 4) 5 >>> min_stops([-10, -5, 0, 5, 10], 5) 6","solution":"def min_stops(locations, start): Calculate the minimum number of stops required to pick up all passengers. Args: locations (List[int]): List of unique integers representing passenger locations. start (int): The starting location of the driver. Returns: int: The minimum number of stops to pick up all passengers. # Convert locations to a set to remove any duplicate locations (not necessary in given problem but a safety measure) passenger_locations = set(locations) # Count the number of distinct stops (distinct passenger locations) return len(passenger_locations) + 1 # +1 to account for starting position"},{"question":"def is_balanced(brackets: str) -> bool: Check if the given string of brackets is balanced. >>> is_balanced(\\"@@\\") True >>> is_balanced(\\"@%@\\") False >>> is_balanced(\\"@@%%&&**\\") True >>> is_balanced(\\"@#@#\\") False >>> is_balanced(\\"\\") True >>> is_balanced(\\"@#@@\\") False # Implementation here…","solution":"def is_balanced(brackets: str) -> bool: Check if the given string of brackets is balanced. stack = [] for bracket in brackets: if stack and stack[-1] == bracket: stack.pop() else: stack.append(bracket) return len(stack) == 0"},{"question":"def find_and_replace(text: str, target: str, replacement: str) -> str: Replaces all occurrences of the target word with the replacement word in the given text. Parameters: text (str): The original text. target (str): The word to search for in the text. replacement (str): The word to replace the target with. Returns: str: A new string where every occurrence of target in text has been replaced with replacement. >>> find_and_replace(\\"hello world, hello universe\\", \\"hello\\", \\"hi\\") 'hi world, hi universe' >>> find_and_replace(\\"abc abc abc\\", \\"abc\\", \\"xyz\\") 'xyz xyz xyz' >>> find_and_replace(\\"hello\\", \\"world\\", \\"hi\\") 'hello' >>> find_and_replace(\\"hello world\\", \\"world\\", \\"\\") 'hello ' pass def test_find_and_replace_basic(): assert find_and_replace(\\"hello world, hello universe\\", \\"hello\\", \\"hi\\") == \\"hi world, hi universe\\" def test_find_and_replace_no_occurrences(): assert find_and_replace(\\"hello\\", \\"world\\", \\"hi\\") == \\"hello\\" def test_find_and_replace_remove_occurrences(): assert find_and_replace(\\"hello world\\", \\"world\\", \\"\\") == \\"hello \\" def test_find_and_replace_multiple_occurrences(): assert find_and_replace(\\"abc abc abc\\", \\"abc\\", \\"xyz\\") == \\"xyz xyz xyz\\" def test_find_and_replace_target_not_in_text(): assert find_and_replace(\\"this is a test\\", \\"example\\", \\"demo\\") == \\"this is a test\\" def test_find_and_replace_empty_replacement(): assert find_and_replace(\\"remove this remove\\", \\"remove\\", \\"\\") == \\" this \\" def test_find_and_replace_overlapping(): # The function should not handle overlapping occurrences since str.replace does not either assert find_and_replace(\\"aaaa\\", \\"aa\\", \\"a\\") == \\"aa\\" def test_find_and_replace_replacement_longer_than_target(): assert find_and_replace(\\"short\\", \\"s\\", \\"long\\") == \\"longhort\\" def test_find_and_replace_replacement_empty_target_empty(): try: find_and_replace(\\"some text\\", \\"\\", \\"replace\\") assert False # If this line is reached, the test should fail except ValueError: assert True def test_find_and_replace_target_at_start_and_end(): assert find_and_replace(\\"target surrounded by target\\", \\"target\\", \\"replaced\\") == \\"replaced surrounded by replaced\\" def test_find_and_replace_handles_large_text(): large_text = \\"a\\" * 5000 assert find_and_replace(large_text, \\"a\\", \\"b\\") == \\"b\\" * 5000","solution":"def find_and_replace(text: str, target: str, replacement: str) -> str: Replaces all occurrences of target with replacement in the given text. if target == \\"\\": # If target is empty string, replacing it would cause infinite loop raise ValueError(\\"Target string must not be empty\\") return text.replace(target, replacement)"},{"question":"from typing import List def shuffle_array(arr: List[int]) -> List[int]: Randomly shuffles the elements of the given list and returns a new list. Args: arr (List[int]): The list of integers to shuffle. Returns: List[int]: A new list with the elements of arr shuffled. pass # Example Usage if __name__ == \\"__main__\\": arr = [1, 2, 3, 4, 5] shuffled_arr = shuffle_array(arr) print(shuffled_arr) # Output: Possible outcomes: [3, 5, 1, 4, 2], [1, 4, 5, 3, 2], etc. arr = [] shuffled_arr = shuffle_array(arr) print(shuffled_arr) # Output: [] arr = [1] shuffled_arr = shuffle_array(arr) print(shuffled_arr) # Output: [1]","solution":"import random def shuffle_array(arr): Randomly shuffles the elements of the given list and returns a new list. Args: arr (List[int]): The list of integers to shuffle. Returns: List[int]: A new list with the elements of arr shuffled. n = len(arr) shuffled_arr = arr[:] for i in range(n): j = random.randint(i, n-1) shuffled_arr[i], shuffled_arr[j] = shuffled_arr[j], shuffled_arr[i] return shuffled_arr"},{"question":"def run_length_encoding(data: str) -> str: Compress a given string using Run Length Encoding (RLE). >>> run_length_encoding(\\"aaabbcaaa\\") 'a3b2c1a3' >>> run_length_encoding(\\"a\\") 'a1' >>> run_length_encoding(\\"aabbcc\\") 'a2b2c2' >>> run_length_encoding(\\"aaaaaaaaaaa\\") 'a9a2' >>> run_length_encoding(\\"xyz\\") 'x1y1z1'","solution":"def run_length_encoding(data: str) -> str: if not data: return \\"\\" result = [] current_char = data[0] count = 1 for char in data[1:]: if char == current_char: count += 1 if count == 10: result.append(f\\"{current_char}9\\") count = 1 else: result.append(f\\"{current_char}{count}\\") current_char = char count = 1 result.append(f\\"{current_char}{count}\\") return \\"\\".join(result)"},{"question":"def dijkstra_with_weights(graph, start): Implementation of Dijkstra's algorithm with edge weights handling. graph : Dictionary where keys are node identifiers, and values are lists of tuples representing connected nodes and the respective edge weights. start : Node identifier representing the starting node. Returns a dictionary where each key is a node and its value is the least cost to reach that node from the start node. >>> g = { >>> 'A': [('B', 1), ('C', 4)], >>> 'B': [('A', 1), ('C', 2), ('D', 5)], >>> 'C': [('A', 4), ('B', 2), ('D', 1)], >>> 'D': [('B', 5), ('C', 1)] >>> } >>> dijkstra_with_weights(g, 'A') {'A': 0, 'B': 1, 'C': 3, 'D': 4} # Example output showing the least cost path from 'A' to all other nodes","solution":"import heapq def dijkstra_with_weights(graph, start): Implementation of Dijkstra's algorithm with edge weights handling. graph : Dictionary where keys are node identifiers, and values are lists of tuples representing connected nodes and the respective edge weights. start : Node identifier representing the starting node. Returns a dictionary where each key is a node and its value is the least cost to reach that node from the start node. >>> g = { >>> 'A': [('B', 1), ('C', 4)], >>> 'B': [('A', 1), ('C', 2), ('D', 5)], >>> 'C': [('A', 4), ('B', 2), ('D', 1)], >>> 'D': [('B', 5), ('C', 1)] >>> } >>> dijkstra_with_weights(g, 'A') {'A': 0, 'B': 1, 'C': 3, 'D': 4} # Example output showing the least cost path from 'A' to all other nodes # Initialize distances from start to all nodes as infinity, except start node itself which is zero distances = {node: float('inf') for node in graph} distances[start] = 0 # Priority queue to store the nodes to explore; initialized with the start node priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the popped node distance is greater than the recorded distance, skip it if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight # If the newly calculated distance is less than the recorded one, update and push to queue if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"from typing import Optional class TreeNode: def __init__(self, val: int = 0, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None): self.val = val self.left = left self.right = right def deepest_binary_tree_node(root: Optional[TreeNode]) -> int: Find the value of the deepest node in the binary tree. If multiple nodes are at the deepest level, return the leftmost one. >>> root = TreeNode(1, TreeNode(2, TreeNode(4, TreeNode(5))), TreeNode(3)) >>> deepest_binary_tree_node(root) 5 >>> deepest_binary_tree_node(TreeNode(1, TreeNode(2, TreeNode(3)))) 3 >>> deepest_binary_tree_node(TreeNode(1, None, TreeNode(2, None, TreeNode(3)))) 3 pass","solution":"from typing import Optional class TreeNode: def __init__(self, val: int = 0, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None): self.val = val self.left = left self.right = right def deepest_binary_tree_node(root: Optional[TreeNode]) -> int: if not root: return -1 queue = [(root, 0)] max_depth = -1 current_value = root.val while queue: node, depth = queue.pop(0) if depth > max_depth: max_depth = depth current_value = node.val if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return current_value"},{"question":"from typing import List def orangesRotting(grid: List[List[int]]) -> int: Determine the minimum number of minutes that must elapse until no cell has a fresh orange, or return -1 if it is impossible. >>> orangesRotting([ [2, 1, 1], [1, 1, 0], [0, 1, 1] ]) == 4 >>> orangesRotting([ [2, 1, 1], [0, 1, 1], [1, 0, 1] ]) == -1 >>> orangesRotting([[0, 2]]) == 0","solution":"from typing import List from collections import deque def orangesRotting(grid: List[List[int]]) -> int: rows, cols = len(grid), len(grid[0]) queue = deque() fresh_count = 0 # Initialize the queue with all the rotten oranges and count fresh ones for r in range(rows): for c in range(cols): if grid[r][c] == 2: queue.append((r, c, 0)) elif grid[r][c] == 1: fresh_count += 1 if fresh_count == 0: return 0 minute_passed = 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: r, c, minute_passed = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1: grid[nr][nc] = 2 fresh_count -= 1 queue.append((nr, nc, minute_passed + 1)) return minute_passed if fresh_count == 0 else -1"},{"question":"def search_most_expensive_affordable_book_iterative(prices: list[int], budget: int) -> int: Return the most expensive book price within the given budget using an iterative binary search. >>> search_most_expensive_affordable_book_iterative([3, 9, 14, 21, 30, 45, 60], 20) == 14 >>> search_most_expensive_affordable_book_iterative([3, 9, 14, 21, 30, 45, 60], 60) == 60 >>> search_most_expensive_affordable_book_iterative([3, 9, 14, 21, 30, 45, 60], 5) == 3 >>> search_most_expensive_affordable_book_iterative([3, 9, 14, 21, 30, 45, 60], 2) == -1 >>> search_most_expensive_affordable_book_iterative([], 20) == -1 >>> search_most_expensive_affordable_book_iterative([3, 9, 14, 21, 30, 45, 60], 45) == 45 pass def search_most_expensive_affordable_book_recursive(prices: list[int], budget: int) -> int: Return the most expensive book price within the given budget using a recursive binary search. >>> search_most_expensive_affordable_book_recursive([3, 9, 14, 21, 30, 45, 60], 20) == 14 >>> search_most_expensive_affordable_book_recursive([3, 9, 14, 21, 30, 45, 60], 60) == 60 >>> search_most_expensive_affordable_book_recursive([3, 9, 14, 21, 30, 45, 60], 5) == 3 >>> search_most_expensive_affordable_book_recursive([3, 9, 14, 21, 30, 45, 60], 2) == -1 >>> search_most_expensive_affordable_book_recursive([], 20) == -1 >>> search_most_expensive_affordable_book_recursive([3, 9, 14, 21, 30, 45, 60], 45) == 45 pass","solution":"def search_most_expensive_affordable_book_iterative(prices, budget): Returns the most expensive book price within the given budget using an iterative binary search. left, right = 0, len(prices) - 1 result = -1 while left <= right: mid = (left + right) // 2 if prices[mid] <= budget: result = prices[mid] left = mid + 1 else: right = mid - 1 return result def search_most_expensive_affordable_book_recursive(prices, budget): Returns the most expensive book price within the given budget using a recursive binary search. def binary_search(prices, budget, left, right, result): if left > right: return result mid = (left + right) // 2 if prices[mid] <= budget: return binary_search(prices, budget, mid + 1, right, prices[mid]) else: return binary_search(prices, budget, left, mid - 1, result) return binary_search(prices, budget, 0, len(prices) - 1, -1)"},{"question":"from typing import List, Dict def word_count(text_list: List[str]) -> Dict[str, int]: Counts the frequency of each word in a list of text strings. Parameters: text_list (list of str): A list of text documents. Returns: dict: A dictionary where keys are words and values are their counts. Examples: >>> word_count([\\"Hello world\\", \\"hello HELLO\\"]) {'hello': 3, 'world': 1} >>> word_count([\\"Data analytics is useful\\", \\"Analytics and data science\\"]) {'data': 2, 'analytics': 2, 'is': 1, 'useful': 1, 'and': 1, 'science': 1} >>> word_count([\\"\\"]) {} >>> word_count([\\"This is a test\\", \\"This is only a test\\", \\"Test test test\\"]) {'this': 2, 'is': 2, 'a': 2, 'test': 5, 'only': 1} >>> word_count([\\"@Hello world!\\", \\"Special: characters& should* be ignored.\\"]) {'hello': 1, 'world': 1, 'special': 1, 'characters': 1, 'should': 1, 'be': 1, 'ignored': 1}","solution":"import re from collections import defaultdict def word_count(text_list): Counts the frequency of each word in a list of text strings. Parameters: text_list (list of str): A list of text documents. Returns: dict: A dictionary where keys are words and values are their counts. word_freq = defaultdict(int) for text in text_list: # Normalize text by removing special characters and converting to lowercase words = re.findall(r'bw+b', text.lower()) for word in words: word_freq[word] += 1 return dict(word_freq)"},{"question":"def find_mutual_friends(user1_friends: list[int], user2_friends: list[int]) -> list[int]: Finds mutual friends between two users. Parameters: - user1_friends: A list of integers representing the friend IDs of the first user. - user2_friends: A list of integers representing the friend IDs of the second user. Returns: - A sorted list of integers representing the mutual friend IDs. >>> find_mutual_friends([1, 2, 3, 5], [3, 4, 5, 6]) [3, 5] >>> find_mutual_friends([7, 8, 9], [10, 11, 12]) [] >>> find_mutual_friends([], [1, 2, 3]) []","solution":"def find_mutual_friends(user1_friends, user2_friends): Finds mutual friends between two users. Parameters: - user1_friends: A list of integers representing the friend IDs of the first user. - user2_friends: A list of integers representing the friend IDs of the second user. Returns: - A sorted list of integers representing the mutual friend IDs. # Convert both friend lists to sets to utilize set intersection for finding mutual friends user1_set = set(user1_friends) user2_set = set(user2_friends) # Find the intersection of both sets mutual_friends = user1_set & user2_set # Convert the resulting set to a sorted list return sorted(list(mutual_friends))"},{"question":"def generate_sequence(n: int) -> list[int]: Generates the first 'n' numbers of a specific sequence where each number is the square of its 1-based index. :param n: The number of elements to generate in the sequence. :return: A list of the first 'n' numbers in the sequence. Examples: >>> generate_sequence(5) [1, 4, 9, 16, 25] >>> generate_sequence(3) [1, 4, 9] >>> generate_sequence(0) []","solution":"def generate_sequence(n: int) -> list[int]: Generates the first 'n' numbers of a specific sequence where each number is the square of its 1-based index. :param n: The number of elements to generate in the sequence. :return: A list of the first 'n' numbers in the sequence. return [i * i for i in range(1, n + 1)]"},{"question":"from typing import List class Order: def __init__(self, order_id: int, price: float): self.order_id = order_id self.price = price def apply_discounts(orders: List[Order]) -> None: Compute the discounted prices for each order and print the final amount payable for each order. Apply the following discount rules: - If the price is greater than 100, a discount of 10% is applied. - If the price is between 50 and 100 (inclusive), a discount of 5% is applied. - No discount is applied if the price is below 50. Example: >>> orders = [Order(order_id=1, price=120.0), Order(order_id=2, price=75.5), Order(order_id=3, price=42.0)] >>> apply_discounts(orders) Order ID: 1, Final Payable Amount: 108.00 Order ID: 2, Final Payable Amount: 71.73 Order ID: 3, Final Payable Amount: 42.00","solution":"from typing import List class Order: def __init__(self, order_id: int, price: float): self.order_id = order_id self.price = price def apply_discounts(orders: List[Order]) -> None: for order in orders: if order.price > 100: discount = 0.10 elif 50 <= order.price <= 100: discount = 0.05 else: discount = 0.0 final_price = order.price * (1 - discount) print(f\\"Order ID: {order.order_id}, Final Payable Amount: {final_price:.2f}\\")"},{"question":"def reversefibonacci(n: int) -> List[int]: Generates a list of the first \`n\` Fibonacci numbers in reverse order. :param n: Number of Fibonacci numbers to generate :return: List of Fibonacci numbers in reverse order >>> reversefibonacci(0) [] >>> reversefibonacci(1) [0] >>> reversefibonacci(2) [1, 0] >>> reversefibonacci(5) [3, 2, 1, 1, 0] >>> reversefibonacci(10) [34, 21, 13, 8, 5, 3, 2, 1, 1, 0]","solution":"def reversefibonacci(n): Generates a list of the first \`n\` Fibonacci numbers in reverse order. :param n: Number of Fibonacci numbers to generate :return: List of Fibonacci numbers in reverse order if n == 0: return [] fibonacci_sequence = [0, 1] for i in range(2, n): next_fib = fibonacci_sequence[-1] + fibonacci_sequence[-2] fibonacci_sequence.append(next_fib) return fibonacci_sequence[:n][::-1]"},{"question":"def nth_ugly_number(n: int) -> int: Identify and return the nth ugly number. Ugly numbers are positive integers whose prime factors are limited to 2, 3, and 5. >>> nth_ugly_number(1) 1 >>> nth_ugly_number(10) 12 >>> nth_ugly_number(15) 24 >>> nth_ugly_number(150) 5832 ...","solution":"def nth_ugly_number(n: int) -> int: # Array to store ugly numbers ugly_numbers = [0] * n ugly_numbers[0] = 1 # Initial positions for multiples of 2, 3, and 5 i2, i3, i5 = 0, 0, 0 # Initial multiples of 2, 3, and 5 next_2, next_3, next_5 = 2, 3, 5 for i in range(1, n): next_ugly = min(next_2, next_3, next_5) ugly_numbers[i] = next_ugly if next_ugly == next_2: i2 += 1 next_2 = ugly_numbers[i2] * 2 if next_ugly == next_3: i3 += 1 next_3 = ugly_numbers[i3] * 3 if next_ugly == next_5: i5 += 1 next_5 = ugly_numbers[i5] * 5 return ugly_numbers[n - 1]"},{"question":"class BinaryTree: def find_max_depth(self) -> int: Calculates the maximum depth (or height) of the binary tree. >>> tree = BinaryTree() >>> tree.insert_node(3) >>> tree.insert_node(9) >>> tree.insert_node(20) >>> tree.insert_node(15) >>> tree.insert_node(7) >>> tree.find_max_depth() 3 def is_symmetric(self) -> bool: Checks whether the tree is symmetric around its center. >>> tree = BinaryTree() >>> tree.insert_node(1) >>> tree.insert_node(2) >>> tree.insert_node(2) >>> tree.insert_node(3) >>> tree.insert_node(4) >>> tree.insert_node(4) >>> tree.insert_node(3) >>> tree.is_symmetric() True >>>","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self): self.root = None def insert_node(self, value): Inserts a node into the binary tree using level order traversal. if not self.root: self.root = TreeNode(value) return queue = [self.root] while queue: node = queue.pop(0) if not node.left: node.left = TreeNode(value) break else: queue.append(node.left) if not node.right: node.right = TreeNode(value) break else: queue.append(node.right) def find_max_depth(self): Calculates the maximum depth (or height) of the binary tree. def max_depth_helper(node): if not node: return 0 left_depth = max_depth_helper(node.left) right_depth = max_depth_helper(node.right) return max(left_depth, right_depth) + 1 return max_depth_helper(self.root) def is_symmetric(self): Checks whether the tree is symmetric around its center. def is_mirror(tree1, tree2): if not tree1 and not tree2: return True if not tree1 or not tree2: return False return (tree1.value == tree2.value and is_mirror(tree1.left, tree2.right) and is_mirror(tree1.right, tree2.left)) return is_mirror(self.root, self.root)"},{"question":"from typing import List, Tuple def update_inventory(inventory: List[int], operations: List[Tuple[str, int, int]]) -> List[int]: Updates the inventory based on the given operations. :param inventory: A list of integers representing the initial inventory. :param operations: A list of operations to be performed on the inventory. :return: A list of integers representing the updated inventory. >>> update_inventory([10, 5, 0, 20], [(\\"restock\\", 2, 15), (\\"fulfill\\", 0, 5), (\\"fulfill\\", 1, 1)]) [5, 4, 15, 20] >>> update_inventory([1, 2, 3], [(\\"restock\\", 0, 10), (\\"restock\\", 1, 5)]) [11, 7, 3] >>> update_inventory([10, 10, 10], [(\\"fulfill\\", 0, 5), (\\"fulfill\\", 1, 6), (\\"fulfill\\", 2, 2)]) [5, 4, 8] >>> update_inventory([5, 5, 5], [(\\"fulfill\\", 0, 6)]) Traceback (most recent call last): ... ValueError: Insufficient stock for item at index 0 >>> update_inventory([10, 20, 30], []) [10, 20, 30] >>> update_inventory([10, 20, 30], [(\\"invalid\\", 0, 5)]) Traceback (most recent call last): ... ValueError: Invalid operation pass def test_update_inventory_basic_operations(): inventory = [10, 5, 0, 20] operations = [(\\"restock\\", 2, 15), (\\"fulfill\\", 0, 5), (\\"fulfill\\", 1, 1)] updated_inventory = update_inventory(inventory, operations) assert updated_inventory == [5, 4, 15, 20] def test_update_inventory_restock_only(): inventory = [1, 2, 3] operations = [(\\"restock\\", 0, 10), (\\"restock\\", 1, 5)] updated_inventory = update_inventory(inventory, operations) assert updated_inventory == [11, 7, 3] def test_update_inventory_fulfill_only(): inventory = [10, 10, 10] operations = [(\\"fulfill\\", 0, 5), (\\"fulfill\\", 1, 6), (\\"fulfill\\", 2, 2)] updated_inventory = update_inventory(inventory, operations) assert updated_inventory == [5, 4, 8] def test_update_inventory_insufficient_stock(): inventory = [5, 5, 5] operations = [(\\"fulfill\\", 0, 6)] try: update_inventory(inventory, operations) except ValueError as e: assert str(e) == \\"Insufficient stock for item at index 0\\" def test_update_inventory_no_operations(): inventory = [10, 20, 30] operations = [] updated_inventory = update_inventory(inventory, operations) assert updated_inventory == [10, 20, 30] def test_update_inventory_invalid_operation(): inventory = [10, 20, 30] operations = [(\\"invalid\\", 0, 5)] try: update_inventory(inventory, operations) except ValueError as e: assert str(e) == \\"Invalid operation\\"","solution":"def update_inventory(inventory, operations): Updates the inventory based on the given operations. :param inventory: A list of integers representing the initial inventory. :param operations: A list of operations to be performed on the inventory. :return: A list of integers representing the updated inventory. for operation, index, quantity in operations: if operation == \\"restock\\": inventory[index] += quantity elif operation == \\"fulfill\\": if inventory[index] < quantity: raise ValueError(f\\"Insufficient stock for item at index {index}\\") inventory[index] -= quantity else: raise ValueError(\\"Invalid operation\\") return inventory"},{"question":"def rotate_array(arr: list, k: int) -> list: Rotates the array to the right by k steps. Parameters: arr (list): List of elements to be rotated. k (int): Number of steps to rotate the list. Returns: list: The rotated list. >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_array([1], 3) [1] >>> rotate_array([], 3) [] >>> rotate_array([\\"a\\", \\"b\\", \\"c\\", \\"d\\"], 2) [\\"c\\", \\"d\\", \\"a\\", \\"b\\"] >>> rotate_array([1, \\"b\\", 3.5, \\"d\\"], 3) [\\"b\\", 3.5, \\"d\\", 1]","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. Parameters: arr (list): List of elements to be rotated. k (int): Number of steps to rotate the list. Returns: list: The rotated list. n = len(arr) if n == 0: return arr k = k % n # Normalize k to avoid unnecessary rotation arr[:] = arr[-k:] + arr[:-k] return arr"},{"question":"def is_palindrome_permutation(s: str) -> bool: Check if any permutation of the input string 's' can form a palindrome. A string is a palindrome if it reads the same forwards and backwards. The permutation can ignore spaces and is case-insensitive. >>> is_palindrome_permutation(\\"Tact Coa\\") True >>> is_palindrome_permutation(\\"Hello\\") False >>> is_palindrome_permutation(\\"A man a plan a canal Panama\\") True","solution":"def is_palindrome_permutation(s: str) -> bool: from collections import Counter # Normalize the string: Remove spaces and convert to lower case normalized_s = s.replace(\\" \\", \\"\\").lower() # Count the frequency of each character char_count = Counter(normalized_s) # Check the palindrome condition: At most one character with an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"**Implement two classes \`DynamicArray\` and \`SegmentTree\` as described.* * # \`DynamicArray\` Class: class DynamicArray: def __init__(self): self.data = [] self.segment_tree = SegmentTree(self.data) def insert(self, value): self.data.append(value) self.segment_tree = SegmentTree(self.data) def delete(self, index): if 0 <= index < len(self.data): self.data.pop(index) self.segment_tree = SegmentTree(self.data) def sum_range(self, left_bound, right_bound): return self.segment_tree.query(left_bound, right_bound) # \`SegmentTree\` Class: class SegmentTree: def __init__(self, data): self.data = data n = len(data) self.tree = [0] * (2 * n) self.build_tree(data) def build_tree(self, data): n = len(data) for i in range(n): self.tree[n + i] = data[i] for i in range(n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, index, value): n = len(self.data) pos = n + index self.tree[pos] = value pos //= 2 while pos >= 1: self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] pos //= 2 def query(self, left_bound, right_bound): n = len(self.data) left = n + left_bound right = n + right_bound s = 0 while left <= right: if left % 2 == 1: s += self.tree[left] left += 1 if right % 2 == 0: s += self.tree[right] right -= 1 left //= 2 right //= 2 return s # Example Usage: # Initializing DynamicArray dyn_array = DynamicArray() dyn_array.insert(3) dyn_array.insert(7) dyn_array.insert(1) dyn_array.insert(5) # Sum range queries print(dyn_array.sum_range(1, 3)) # should return 13 (7 + 1 + 5) print(dyn_array.sum_range(0, 2)) # should return 11 (3 + 7 + 1) # Deleting an element dyn_array.delete(2) # Sum range queries after deletion print(dyn_array.sum_range(0, 2)) # should return 15 (3 + 7 + 5)","solution":"class SegmentTree: def __init__(self, data): self.data = data n = len(data) self.tree = [0] * (2 * n) self.build_tree(data) def build_tree(self, data): n = len(data) for i in range(n): self.tree[n + i] = data[i] for i in range(n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, index, value): n = len(self.data) pos = n + index self.tree[pos] = value pos //= 2 while pos >= 1: self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] pos //= 2 def query(self, left_bound, right_bound): n = len(self.data) left = n + left_bound right = n + right_bound s = 0 while left <= right: if left % 2 == 1: s += self.tree[left] left += 1 if right % 2 == 0: s += self.tree[right] right -= 1 left //= 2 right //= 2 return s class DynamicArray: def __init__(self): self.data = [] self.segment_tree = SegmentTree(self.data) def insert(self, value): self.data.append(value) self.segment_tree = SegmentTree(self.data) def delete(self, index): if 0 <= index < len(self.data): self.data.pop(index) self.segment_tree = SegmentTree(self.data) def sum_range(self, left_bound, right_bound): return self.segment_tree.query(left_bound, right_bound)"},{"question":"from typing import List class LogStorage: def __init__(self): Initialize the LogStorage data structure. pass def insert(self, timestamp: int, message: str) -> None: Stores a log entry with the given timestamp and message. pass def query(self, start: int, end: int) -> List[str]: Retrieves all log messages with timestamps in the range [start, end] (inclusive). :param start: the start timestamp :param end: the end timestamp :return: list of log messages within the specified time range pass def test_insert_and_query(): log_storage = LogStorage() # Insert log entries log_storage.insert(1, \\"Log entry 1\\") log_storage.insert(2, \\"Log entry 2\\") log_storage.insert(10, \\"Log entry 10\\") # Query log entries messages = log_storage.query(1, 5) assert messages == [\\"Log entry 1\\", \\"Log entry 2\\"] messages = log_storage.query(2, 10) assert messages == [\\"Log entry 2\\", \\"Log entry 10\\"] messages = log_storage.query(3, 9) assert messages == [] def test_no_logs_in_range(): log_storage = LogStorage() log_storage.insert(1, \\"Log entry 1\\") messages = log_storage.query(2, 5) assert messages == [] def test_multiple_logs_for_same_timestamp(): log_storage = LogStorage() log_storage.insert(1, \\"Log entry 1\\") log_storage.insert(1, \\"Second log entry 1\\") log_storage.insert(2, \\"Log entry 2\\") messages = log_storage.query(1, 1) assert messages == [\\"Log entry 1\\", \\"Second log entry 1\\"] messages = log_storage.query(1, 2) assert messages == [\\"Log entry 1\\", \\"Second log entry 1\\", \\"Log entry 2\\"] def test_large_number_of_logs(): log_storage = LogStorage() for i in range(1000): log_storage.insert(i, f\\"Log entry {i}\\") messages = log_storage.query(500, 505) expected_messages = [f\\"Log entry {i}\\" for i in range(500, 506)] assert messages == expected_messages def test_logs_with_gaps(): log_storage = LogStorage() log_storage.insert(1, \\"Log entry 1\\") log_storage.insert(3, \\"Log entry 3\\") log_storage.insert(5, \\"Log entry 5\\") messages = log_storage.query(1, 5) assert messages == [\\"Log entry 1\\", \\"Log entry 3\\", \\"Log entry 5\\"] messages = log_storage.query(2, 4) assert messages == [\\"Log entry 3\\"] messages = log_storage.query(4, 6) assert messages == [\\"Log entry 5\\"]","solution":"from typing import List from collections import defaultdict class LogStorage: def __init__(self): self.logs = defaultdict(list) def insert(self, timestamp: int, message: str) -> None: Stores a log entry with the given timestamp and message. self.logs[timestamp].append(message) def query(self, start: int, end: int) -> List[str]: Retrieves all log messages with timestamps in the range [start, end] (inclusive). result = [] for timestamp in range(start, end + 1): if timestamp in self.logs: result.extend(self.logs[timestamp]) return result"},{"question":"[Completion Task in Python] longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) -> \\"fl\\" longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) -> \\"\\"","solution":"def clean_log(log: str) -> str: Takes a string of log entries separated by newlines and returns a string of cleaned entries, also separated by newlines, by removing invalid entries. cleaned_entries = [] for line in log.split(\\"n\\"): parts = line.split(\\",\\") if len(parts) != 3: continue timestamp, reading, status = parts if not timestamp.isdigit(): continue try: float(reading) except ValueError: continue if not (1 <= len(status) <= 5): continue cleaned_entries.append(line) return \\"n\\".join(cleaned_entries)"},{"question":"def word_count(text: str) -> dict[str, int]: Takes a string and returns a dictionary with word frequency count. Handles punctuation removal and case insensitivity. Examples: >>> word_count(\\"Hello, world! Hello.\\") {\\"hello\\": 2, \\"world\\": 1} >>> word_count(\\"The quick brown fox jumps over the lazy dog.\\") {\\"the\\": 2, \\"quick\\": 1, \\"brown\\": 1, \\"fox\\": 1, \\"jumps\\": 1, \\"over\\": 1, \\"lazy\\": 1, \\"dog\\": 1} >>> word_count(\\"This is a test. This test is only a test.\\") {\\"this\\": 2, \\"is\\": 2, \\"a\\": 2, \\"test\\": 3, \\"only\\": 1} >>> word_count(\\"Python's syntax is clear!\\") {\\"pythons\\": 1, \\"syntax\\": 1, \\"is\\": 1, \\"clear\\": 1}","solution":"import string def word_count(text: str) -> dict[str, int]: Takes a string and returns a dictionary with word frequency count. Handles punctuation removal and case insensitivity. # Remove punctuation from the text translator = str.maketrans('', '', string.punctuation) text = text.translate(translator) # Split the text into words and count them ignoring case words = text.lower().split() word_counts = {} for word in words: word_counts[word] = word_counts.get(word, 0) + 1 return word_counts"},{"question":"class CustomBST: def __init__(self) -> None: Initialize an empty Binary Search Tree. pass def insert(self, value: int) -> None: Insert a value into the BST maintaining its properties. >>> tree = CustomBST() >>> tree.insert(5) >>> tree.insert(3) >>> tree.search(3) True pass def delete(self, value: int) -> None: Delete a value from the BST if it exists while maintaining the BST properties. >>> tree = CustomBST() >>> tree.insert(5) >>> tree.insert(3) >>> tree.delete(3) >>> tree.search(3) False pass def search(self, value: int) -> bool: Determine if a value exists in the BST. >>> tree = CustomBST() >>> tree.insert(5) >>> tree.search(5) True >>> tree.search(3) False pass def inorder_traversal(self) -> list[int]: Return a list of values representing the in-order traversal of the BST. >>> tree = CustomBST() >>> tree.insert(5) >>> tree.insert(3) >>> tree.inorder_traversal() [3, 5] pass def preorder_traversal(self) -> list[int]: Return a list of values representing the pre-order traversal of the BST. >>> tree = CustomBST() >>> tree.insert(5) >>> tree.insert(3) >>> tree.preorder_traversal() [5, 3] pass def postorder_traversal(self) -> list[int]: Return a list of values representing the post-order traversal of the BST. >>> tree = CustomBST() >>> tree.insert(5) >>> tree.insert(3) >>> tree.postorder_traversal() [3, 5] pass def level_order_traversal(self) -> list[int]: Return a list of values representing the level-order traversal of the BST. >>> tree = CustomBST() >>> tree.insert(5) >>> tree.insert(3) >>> tree.level_order_traversal() [5, 3] pass def reverse_inorder_traversal(self) -> list[int]: Return a list of values representing the reverse in-order traversal (right, root, left) of the BST. >>> tree = CustomBST() >>> tree.insert(5) >>> tree.insert(3) >>> tree.reverse_inorder_traversal() [5, 3] pass","solution":"class CustomBST: class Node: def __init__(self, value): self.value = value self.left = None self.right = None def __init__(self): self.root = None def insert(self, value): def _insert(root, value): if root is None: return CustomBST.Node(value) if value < root.value: root.left = _insert(root.left, value) else: root.right = _insert(root.right, value) return root self.root = _insert(self.root, value) def delete(self, value): def _min_value_node(node): current = node while current.left is not None: current = current.left return current def _delete(root, value): if root is None: return root if value < root.value: root.left = _delete(root.left, value) elif value > root.value: root.right = _delete(root.right, value) else: if root.left is None: return root.right elif root.right is None: return root.left temp = _min_value_node(root.right) root.value = temp.value root.right = _delete(root.right, temp.value) return root self.root = _delete(self.root, value) def search(self, value): def _search(root, value): if root is None or root.value == value: return root is not None if value < root.value: return _search(root.left, value) return _search(root.right, value) return _search(self.root, value) def inorder_traversal(self): result = [] def _inorder(root): if root: _inorder(root.left) result.append(root.value) _inorder(root.right) _inorder(self.root) return result def preorder_traversal(self): result = [] def _preorder(root): if root: result.append(root.value) _preorder(root.left) _preorder(root.right) _preorder(self.root) return result def postorder_traversal(self): result = [] def _postorder(root): if root: _postorder(root.left) _postorder(root.right) result.append(root.value) _postorder(self.root) return result def level_order_traversal(self): result = [] if not self.root: return result queue = [self.root] while queue: current = queue.pop(0) result.append(current.value) if current.left: queue.append(current.left) if current.right: queue.append(current.right) return result def reverse_inorder_traversal(self): result = [] def _reverse_inorder(root): if root: _reverse_inorder(root.right) result.append(root.value) _reverse_inorder(root.left) _reverse_inorder(self.root) return result"},{"question":"from typing import List def validate_and_format_date(date_strings: List[str]) -> List[str]: Validate and format date strings. Args: date_strings (List[str]): A list of date strings in various formats. Returns: List[str]: A list of valid and formatted date strings in YYYY-MM-DD format. >>> validate_and_format_date([\\"12/31/2020\\", \\"31-12-2020\\", \\"2020.12.31\\"]) ['2020-12-31', '2020-12-31', '2020-12-31'] >>> validate_and_format_date([\\"02/30/2020\\", \\"31-02-2020\\", \\"2020.13.31\\"]) [] >>> validate_and_format_date([\\"12/31/2020\\", \\"02/30/2020\\"]) ['2020-12-31'] >>> validate_and_format_date([\\"31-12-2020\\", \\"31-02-2020\\"]) ['2020-12-31'] >>> validate_and_format_date([]) [] >>> validate_and_format_date([\\"12/01/2020\\", \\"01-12-2020\\", \\"2020.01.12\\"]) ['2020-12-01', '2020-12-01', '2020-01-12']","solution":"from datetime import datetime def validate_and_format_date(date_strings): formats = [\\"%m/%d/%Y\\", \\"%d-%m-%Y\\", \\"%Y.%m.%d\\"] valid_dates = [] for date_string in date_strings: valid_date = None for fmt in formats: try: valid_date = datetime.strptime(date_string, fmt).date() break except ValueError: pass if valid_date: valid_dates.append(valid_date.strftime(\\"%Y-%m-%d\\")) return valid_dates"},{"question":"from typing import List, Tuple, Dict def manage_inventory(logs: List[Tuple[str, str, int]]) -> Dict[str, int]: Processes the given logs and returns a dictionary representing the current inventory levels of the items. Args: logs (List[Tuple[str, str, int]]): A list of tuples where each tuple represents a log entry. Each tuple contains three elements: - 'action': A string that can either be \\"IN\\" (indicating an incoming item) or \\"OUT\\" (indicating an outgoing item). - 'item': A string representing the name of the item. - 'quantity': An integer representing the quantity of the item. Returns: Dict[str, int]: A dictionary where keys are item names and values are the current quantities of the items. Example: >>> logs = [(\\"IN\\", \\"widget\\", 10), (\\"OUT\\", \\"widget\\", 5), (\\"IN\\", \\"gadget\\", 7), (\\"OUT\\", \\"gadget\\", 2), (\\"IN\\", \\"widget\\", 3)] >>> manage_inventory(logs) {'widget': 8, 'gadget': 5}","solution":"from typing import List, Tuple, Dict def manage_inventory(logs: List[Tuple[str, str, int]]) -> Dict[str, int]: inventory = {} for action, item, quantity in logs: if action == \\"IN\\": if item in inventory: inventory[item] += quantity else: inventory[item] = quantity elif action == \\"OUT\\": if item in inventory: inventory[item] -= quantity if inventory[item] <= 0: del inventory[item] return inventory"},{"question":"def merge_sort(array: list[int]) -> list[int]: Sort a list of integers using the merge sort algorithm and return the sorted list. Args: array (list[int]): A list of integers to sort. Returns: list[int]: A new list containing the elements of the input list in non-decreasing order. >>> merge_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] >>> merge_sort([5, 2, 9, 1, 5, 6]) [1, 2, 5, 5, 6, 9] >>> merge_sort([-1000000, 1000000, 0]) [-1000000, 0, 1000000] >>> merge_sort([1]) [1] >>> merge_sort([-3, -2, -4, -1, -5]) [-5, -4, -3, -2, -1] >>> merge_sort([3, -2, 0, 5, -1, 2, 4]) [-2, -1, 0, 2, 3, 4, 5]","solution":"def merge_sort(array): # Base case: arrays with fewer than 2 elements are already sorted if len(array) < 2: return array # Split array into two halves mid = len(array) // 2 left_half = merge_sort(array[:mid]) right_half = merge_sort(array[mid:]) # Merge sorted halves return merge(left_half, right_half) def merge(left, right): sorted_array = [] i = j = 0 # Until we reach the end of either left or right, pick the smallest of both elements and append to sorted_array while i < len(left) and j < len(right): if left[i] < right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 # Append any elements left in either left or right sorted_array.extend(left[i:]) sorted_array.extend(right[j:]) return sorted_array"},{"question":"def is_palindrome(s: str) -> bool: Checks if a given string is a palindrome. Args: s (str): The input string. Returns: bool: True if the string is a palindrome, and False otherwise. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello\\") False def count_palindromic_substrings(text: str) -> int: Counts the number of distinct palindromic substrings within a given text. Args: text (str): The input text. Returns: int: The count of distinct palindromic substrings. >>> count_palindromic_substrings(\\"ababa\\") 9 >>> count_palindromic_substrings(\\"racecar\\") 10 >>> count_palindromic_substrings(\\"abcd\\") 4","solution":"def is_palindrome(s: str) -> bool: Checks if a given string is a palindrome. Args: s (str): The input string. Returns: bool: True if the string is a palindrome, and False otherwise. # Filter and lowercase the alphanumeric characters filtered_string = ''.join(char.lower() for char in s if char.isalnum()) # Check if the filtered string is equal to its reverse return filtered_string == filtered_string[::-1] def count_palindromic_substrings(text: str) -> int: Counts the number of distinct palindromic substrings within a given text. Args: text (str): The input text. Returns: int: The count of distinct palindromic substrings. n = len(text) count = 0 # Helper function to expand around center def expand_around_center(left: int, right: int) -> int: local_count = 0 while left >= 0 and right < n and text[left] == text[right]: local_count += 1 left -= 1 right += 1 return local_count for i in range(n): # Count palindromes of odd length count += expand_around_center(i, i) # Count palindromes of even length count += expand_around_center(i, i + 1) return count"},{"question":"def max_points_on_a_line(points: List[List[int]]) -> int: Find the maximum number of points that lie on the same straight line passing through any two given points. >>> max_points_on_a_line([[1, 1], [2, 2], [3, 3]]) 3 >>> max_points_on_a_line([[1, 1], [3, 2], [5, 3], [4, 1], [2, 3], [1, 4]]) 4","solution":"from typing import List from collections import defaultdict from math import gcd def max_points_on_a_line(points: List[List[int]]) -> int: def slope(p1, p2): dx = p1[0] - p2[0] dy = p1[1] - p2[1] if dx == 0: return 'inf' g = gcd(dx, dy) return (dy // g, dx // g) if len(points) < 3: return len(points) max_points = 1 for i, point1 in enumerate(points): slopes = defaultdict(int) for j, point2 in enumerate(points): if i != j: s = slope(point1, point2) slopes[s] += 1 max_points = max(max_points, slopes[s] + 1) return max_points"},{"question":"from typing import List def custom_leaky_relu(vector: List[float], alpha: float) -> List[float]: Apply the Leaky ReLU function to each element of the input vector. Parameters: vector (List[float]): A list of real numbers. alpha (float): A small non-negative real number used as a hyper-parameter for the Leaky ReLU function. Returns: List[float]: A list of real numbers after applying the Leaky ReLU function. >>> custom_leaky_relu([2.3, 0.6, -2, -3.8], 0.01) [2.3, 0.6, -0.02, -0.038] >>> custom_leaky_relu([-9.2, -0.3, 0.45, -4.56], 0.02) [-0.184, -0.006, 0.45, -0.0912]","solution":"from typing import List def custom_leaky_relu(vector: List[float], alpha: float) -> List[float]: Apply the Leaky ReLU function to each element of the input vector. Parameters: vector (List[float]): A list of real numbers. alpha (float): A small non-negative real number used as a hyper-parameter for the Leaky ReLU function. Returns: List[float]: A list of real numbers after applying the Leaky ReLU function. return [x if x >= 0 else alpha * x for x in vector]"},{"question":"import os def count_file_types(directory_path: str) -> dict: Traverse a directory structure recursively and count the occurrences of different file types. >>> count_file_types('/') {'.txt': 3, '.csv': 2, '.doc': 1} >>> count_file_types('/empty_test_directory') {} >>> count_file_types('/test_no_extension_directory') {} >>> count_file_types('/test_mixed_extension_directory') {'.txt': 2, '.pdf': 1, '.csv': 1} pass # Usage example: # directory_path = \\"/path/to/your/directory\\" # result = count_file_types(directory_path) # print(result) # Output example: {'.txt': 3, '.csv': 2, '.doc': 1}","solution":"import os def count_file_types(directory_path: str) -> dict: file_type_count = {} for root, _, files in os.walk(directory_path): for file in files: ext = os.path.splitext(file)[1] if ext: # Check if file has an extension if ext in file_type_count: file_type_count[ext] += 1 else: file_type_count[ext] = 1 return file_type_count"},{"question":"def detect_anomalies(historical_data: list[float], current_data: list[float], threshold: float) -> list[bool]: Identifies anomalous temperature readings based on historical data. >>> historical_data = [22.5, 23.0, 21.7, 22.8, 23.1, 22.9, 22.6, 23.4, 22.3, 22.7, 23.2, 23.0, 21.9, 22.5, 23.3, 22.7, 22.8, 22.2, 23.1, 22.6, 23.0, 23.2, 22.9, 23.1, 22.8, 23.0, 23.4, 22.9, 23.3, 22.7] >>> current_data = [21.5, 27.0, 24.1, 20.5] >>> threshold = 2.0 >>> detect_anomalies(historical_data, current_data, threshold) [False, True, False, True]","solution":"import statistics def detect_anomalies(historical_data: list[float], current_data: list[float], threshold: float) -> list[bool]: Identifies anomalous temperature readings based on historical data. Parameters: historical_data (list[float]): A list of historical temperature values. current_data (list[float]): A list of current temperature values. threshold (float): Threshold for anomaly detection. Returns: list[bool]: A list of boolean values indicating anomalies in the current_data. mean = statistics.mean(historical_data) stdev = statistics.stdev(historical_data) anomalies = [] for temp in current_data: if abs(temp - mean) > threshold * stdev: anomalies.append(True) else: anomalies.append(False) return anomalies"},{"question":"import os import datetime def get_file_size(file_path: str) -> int: Returns the size of the file in bytes. :param file_path: The path to the file :return: Size of the file in bytes :raises FileNotFoundError: If the file does not exist pass def get_file_metadata(file_path: str) -> dict: Returns the metadata of the file. :param file_path: The path to the file :return: Dictionary containing file metadata :raises FileNotFoundError: If the file does not exist pass import pytest def test_get_file_size(tmp_path): # Create a temporary file file_path = tmp_path / \\"test_file.txt\\" file_path.write_text(\\"Hello World\\") # Check file size assert get_file_size(file_path) == 11 def test_get_file_size_nonexistent(): with pytest.raises(FileNotFoundError): get_file_size(\\"nonexistent.txt\\") def test_get_file_metadata(tmp_path): # Create a temporary file file_path = tmp_path / \\"test_file.txt\\" file_path.write_text(\\"Hello World\\") # Get file metadata metadata = get_file_metadata(file_path) # Verify metadata assert metadata[\\"size\\"] == 11 assert \\"creation_date\\" in metadata assert \\"modification_date\\" in metadata assert metadata[\\"file_type\\"] == \\"txt\\" def test_get_file_metadata_nonexistent(): with pytest.raises(FileNotFoundError): get_file_metadata(\\"nonexistent.txt\\")","solution":"import os import datetime def get_file_size(file_path: str) -> int: Returns the size of the file in bytes. :param file_path: The path to the file :return: Size of the file in bytes :raises FileNotFoundError: If the file does not exist if not os.path.isfile(file_path): raise FileNotFoundError(f\\"File not found: {file_path}\\") return os.path.getsize(file_path) def get_file_metadata(file_path: str) -> dict: Returns the metadata of the file. :param file_path: The path to the file :return: Dictionary containing file metadata :raises FileNotFoundError: If the file does not exist if not os.path.isfile(file_path): raise FileNotFoundError(f\\"File not found: {file_path}\\") size = os.path.getsize(file_path) creation_time = datetime.datetime.fromtimestamp(os.path.getctime(file_path)).isoformat() modification_time = datetime.datetime.fromtimestamp(os.path.getmtime(file_path)).isoformat() file_type = os.path.splitext(file_path)[1][1:] # Get the file extension without the dot return { \\"size\\": size, \\"creation_date\\": creation_time, \\"modification_date\\": modification_time, \\"file_type\\": file_type }"},{"question":"def calculate_course_average(grades: dict) -> dict: Calculate the average grades for students and the overall course average. :param grades: dict, where keys are student names and values are dictionaries, with subject names as keys and grades as values (all values are floats). :return: dict, a dictionary with student names as keys and their average grades as values. Additionally, it should contain an 'overall_avg' key representing the course average. >>> grades = { ... 'Alice': {'Math': 90, 'Science': 80, 'History': 70}, ... 'Bob': {'Math': 85, 'Science': 95}, ... 'Charlie': {'Math': 78, 'History': 88} ... } >>> calculate_course_average(grades) {'Alice': 80.0, 'Bob': 90.0, 'Charlie': 83.0, 'overall_avg': 84.33} # Unit tests def test_single_student_all_grades(): grades = { 'Alice': {'Math': 90, 'Science': 80, 'History': 70} } result = calculate_course_average(grades) assert result == {'Alice': 80.0, 'overall_avg': 80.0} def test_multiple_students_varying_grades(): grades = { 'Alice': {'Math': 90, 'Science': 80, 'History': 70}, 'Bob': {'Math': 85, 'Science': 95}, 'Charlie': {'Math': 78, 'History': 88} } result = calculate_course_average(grades) assert result == {'Alice': 80.0, 'Bob': 90.0, 'Charlie': 83.0, 'overall_avg': 84.33} def test_student_without_any_grades(): grades = { 'Alice': {} } result = calculate_course_average(grades) assert result == {'overall_avg': 0.0} def test_multiple_students_with_some_without_grades(): grades = { 'Alice': {'Math': 90, 'Science': 80}, 'Bob': {}, 'Charlie': {'History': 100} } result = calculate_course_average(grades) assert result == {'Alice': 85.0, 'Charlie': 100.0, 'overall_avg': 92.5} def test_no_students(): grades = {} result = calculate_course_average(grades) assert result == {'overall_avg': 0.0}","solution":"def calculate_course_average(grades): Calculate the average grades for students and the overall course average. :param grades: dict, where keys are student names and values are dictionaries, with subject names as keys and grades as values (all values are floats). :return: dict, a dictionary with student names as keys and their average grades as values. Additionally, it should contain an 'overall_avg' key representing the course average. student_averages = {} for student, subjects in grades.items(): if subjects: average = sum(subjects.values()) / len(subjects) student_averages[student] = average if student_averages: overall_avg = sum(student_averages.values()) / len(student_averages) student_averages['overall_avg'] = round(overall_avg, 2) else: student_averages['overall_avg'] = 0.0 return student_averages"},{"question":"def rpn_calculate(expression: str) -> float: Evaluates a Reverse Polish Notation (RPN) expression. Args: expression (str): The RPN expression to evaluate. Returns: float: The result of the evaluated expression. Raises: ValueError: If the expression is invalid or if division by zero is attempted. Example usage: >>> rpn_calculate(\\"3 4 +\\") 7.0 >>> rpn_calculate(\\"3 4 - 5 +\\") 4.0 >>> rpn_calculate(\\"5 1 2 + 4 * + 3 -\\") 14.0 >>> rpn_calculate(\\"5 4 3 + 2 * 1 - /\\") 1.0 pass","solution":"def rpn_calculate(expression: str) -> float: Evaluates a Reverse Polish Notation (RPN) expression. Args: expression (str): The RPN expression to evaluate. Returns: float: The result of the evaluated expression. Raises: ValueError: If the expression is invalid or if division by zero is attempted. stack = [] operators = {'+': lambda x, y: x + y, '-': lambda x, y: x - y, '*': lambda x, y: x * y, '/': lambda x, y: x / y if y != 0 else (_ for _ in ()).throw(ValueError(\\"Division by zero\\"))} tokens = expression.split() for token in tokens: if token in operators: if len(stack) < 2: raise ValueError(\\"Invalid RPN expression\\") b = stack.pop() a = stack.pop() operation = operators[token] stack.append(operation(a, b)) else: try: stack.append(float(token)) except ValueError: raise ValueError(\\"Invalid token in RPN expression\\") if len(stack) != 1: raise ValueError(\\"Invalid RPN expression\\") return stack[0]"},{"question":"def longest_unique_substring(s: str) -> str: Create a function that takes a single string argument and returns the longest substring without repeating characters. >>> longest_unique_substring(\\"abcabcbb\\") \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") \\"wke\\" >>> longest_unique_substring(\\"\\") \\"\\" >>> longest_unique_substring(\\"dvdf\\") \\"vdf\\"","solution":"def longest_unique_substring(s: str) -> str: if not s: return \\"\\" # Dictionary to remember the last index of each character last_index = {} start = 0 max_length = 0 max_substring = \\"\\" for end, char in enumerate(s): if char in last_index and last_index[char] >= start: start = last_index[char] + 1 last_index[char] = end current_length = end - start + 1 if current_length > max_length: max_length = current_length max_substring = s[start:end + 1] return max_substring"},{"question":"def sum_nested_lists(nested_list: list) -> int: Computes the sum of all integer elements in a nested list structure. >>> sum_nested_lists([1, [2, 3], [4, [5, 6]], 7]) 28 >>> sum_nested_lists([[1, -1], [2, [3, 4]], -5]) 4 >>> sum_nested_lists([1, [2, [3, [4]]]]) 10 >>> sum_nested_lists([1, 2, 3, 4, 5]) 15 >>> sum_nested_lists([[], [1, 2, []], [], 3]) 6","solution":"def sum_nested_lists(nested_list: list) -> int: Returns the sum of all integer elements in a nested list structure. total = 0 for element in nested_list: if isinstance(element, list): total += sum_nested_lists(element) else: total += element return total"},{"question":"def sum_of_squares_difference(n: int) -> int: Compute the difference between the square of the sum and the sum of the squares for the first n natural numbers. >>> sum_of_squares_difference(10) 2640 >>> sum_of_squares_difference(5) 170 >>> sum_of_squares_difference(1) 0 pass import pytest def test_sum_of_squares_difference_basic(): assert sum_of_squares_difference(10) == 2640 assert sum_of_squares_difference(5) == 170 assert sum_of_squares_difference(1) == 0 def test_sum_of_squares_difference_large(): assert sum_of_squares_difference(100) == 25164150 assert sum_of_squares_difference(1000) == 250166416500 assert sum_of_squares_difference(10000) == 2500166641665000 def test_sum_of_squares_difference_invalid_inputs(): with pytest.raises(ValueError): sum_of_squares_difference(0) with pytest.raises(ValueError): sum_of_squares_difference(-5) with pytest.raises(TypeError): sum_of_squares_difference(5.5) with pytest.raises(TypeError): sum_of_squares_difference(\\"100\\")","solution":"def sum_of_squares_difference(n: int) -> int: if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") if n <= 0: raise ValueError(\\"n must be a positive integer\\") sum_of_squares = sum(i**2 for i in range(1, n + 1)) square_of_sum = sum(range(1, n + 1)) ** 2 difference = square_of_sum - sum_of_squares return difference"},{"question":"def find_kth_permutation(n: int, k: int) -> str: Find the k-th smallest unique permutation of digits from a given range [1, n]. >>> find_kth_permutation(3, 3) '213' >>> find_kth_permutation(4, 9) '2314' >>> find_kth_permutation(4, 1) '1234' >>> find_kth_permutation(2, 2) '21'","solution":"from math import factorial def find_kth_permutation(n: int, k: int) -> str: # Create a list of digits from 1 to n digits = list(range(1, n + 1)) # Resultant k-th permutation result = [] # Decrement k by 1 to handle zero-based index k -= 1 # Compute the k-th permutation using the factorial number system representation for i in range(n, 0, -1): # Determine the index of the current digit fact = factorial(i - 1) index = k // fact k %= fact # Append the digit at the index to the result and remove it from the list result.append(str(digits.pop(index))) # Join the result list to form the final permutation string return ''.join(result)"},{"question":"def optimized_diagonal_sum(matrix: List[List[int]]) -> int: Calculates the sum of the main diagonal of a square matrix. Args: matrix (list of list of int): The input square matrix. Returns: int: The sum of the main diagonal elements. >>> optimized_diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # 15 >>> optimized_diagonal_sum([[5, 3, 1], [9, 7, 2], [4, 8, 6]]) # 18 >>> optimized_diagonal_sum([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) # 0 >>> optimized_diagonal_sum([[1]]) # 1 >>> optimized_diagonal_sum([[2, 1], [3, 4]]) # 6 pass # your implementation here","solution":"def optimized_diagonal_sum(matrix): Calculates the sum of the main diagonal of a square matrix. Args: matrix (list of list of int): The input square matrix. Returns: int: The sum of the main diagonal elements. n = len(matrix) diagonal_sum = 0 for i in range(n): diagonal_sum += matrix[i][i] return diagonal_sum"},{"question":"def out_of_stock_items(inventory): Returns a list of item names that are out of stock. Parameters: inventory (list): A list of dictionaries with 'item' and 'quantity' keys. Returns: list: A list of strings representing the names of items that are out of stock, sorted alphabetically. Example: >>> inventory = [ >>> {'item': 'apples', 'quantity': 10}, >>> {'item': 'bananas', 'quantity': 0}, >>> {'item': 'oranges', 'quantity': 5}, >>> {'item': 'grapes', 'quantity': 0} >>> ] >>> out_of_stock_items(inventory) ['bananas', 'grapes'] pass # Unit Tests def test_no_items_out_of_stock(): inventory = [ {'item': 'apples', 'quantity': 10}, {'item': 'bananas', 'quantity': 5}, {'item': 'oranges', 'quantity': 3}, {'item': 'grapes', 'quantity': 1} ] assert out_of_stock_items(inventory) == [] def test_some_items_out_of_stock(): inventory = [ {'item': 'apples', 'quantity': 10}, {'item': 'bananas', 'quantity': 0}, {'item': 'oranges', 'quantity': 5}, {'item': 'grapes', 'quantity': 0} ] assert out_of_stock_items(inventory) == ['bananas', 'grapes'] def test_all_items_out_of_stock(): inventory = [ {'item': 'apples', 'quantity': 0}, {'item': 'bananas', 'quantity': 0}, {'item': 'oranges', 'quantity': 0}, {'item': 'grapes', 'quantity': 0} ] assert out_of_stock_items(inventory) == ['apples', 'bananas', 'grapes', 'oranges'] def test_single_item_out_of_stock(): inventory = [ {'item': 'apples', 'quantity': 0} ] assert out_of_stock_items(inventory) == ['apples'] def test_single_item_in_stock(): inventory = [ {'item': 'apples', 'quantity': 10} ] assert out_of_stock_items(inventory) == []","solution":"def out_of_stock_items(inventory): Returns a list of item names that are out of stock. Parameters: inventory (list): A list of dictionaries with 'item' and 'quantity' keys. Returns: list: A list of strings representing the names of items that are out of stock, sorted alphabetically. out_of_stock = [item['item'] for item in inventory if item['quantity'] == 0] return sorted(out_of_stock)"},{"question":"def sum_of_digits(s: str) -> int: Calculates the sum of all numeric digits present in the string. If the string does not contain any numeric digits, returns 0. >>> sum_of_digits(\\"abc123def\\") 6 >>> sum_of_digits(\\"123abc456\\") 21 >>> sum_of_digits(\\"a1b2c3\\") 6 >>> sum_of_digits(\\"abcdef\\") 0 >>> sum_of_digits(\\"\\") 0","solution":"def sum_of_digits(s: str) -> int: Returns the sum of all numeric digits in the given string. If there are no numeric digits, returns 0. return sum(int(char) for char in s if char.isdigit())"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: TreeNode) -> list[int]: Perform a level order traversal on a given binary tree and return a list of its elements in the visited order. >>> level_order_traversal(None) == [] >>> level_order_traversal(TreeNode(1)) == [1] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> level_order_traversal(root) == [1, 2, 3, 4, 5, 6, 7] >>> root = TreeNode(1) >>> root.left = TreeNode(-5) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(0) >>> root.left.right = TreeNode(-3) >>> root.right.right = TreeNode(4) >>> root.right.right.left = TreeNode(-1) >>> level_order_traversal(root) == [1, -5, 2, 0, -3, 4, -1]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: TreeNode) -> list[int]: Perform a level order traversal on a given binary tree and return a list of its elements in the visited order. if not root: return [] result = [] queue = deque([root]) while queue: node = queue.popleft() result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result # Time Complexity: O(n) where n is the number of nodes in the tree. # Each node is enqueued and dequeued exactly once. # Space Complexity: O(n) for the queue, which in the worst case scenario (a full binary tree), # can hold all the nodes at the deepest level (approximately n/2 nodes)."},{"question":"def currency_conversion(amount: float, exchange_rate: float) -> float: This function converts the given amount from one currency to another using the provided exchange rate. Arguments: amount (float): the amount in the initial currency to be converted. exchange_rate (float): the conversion rate from the initial currency to the target currency. Returns: float: The amount converted to the target currency. Raises: ValueError: if the amount or exchange rate is non-positive. Example: >>> currency_conversion(100, 1.2) 120.0 >>> currency_conversion(50, 0.85) 42.5 >>> currency_conversion(0, 1.2) Raises ValueError: Amount must be positive >>> currency_conversion(100, 0) Raises ValueError: Exchange rate must be positive pass # Your code here","solution":"def currency_conversion(amount: float, exchange_rate: float) -> float: This function converts the given amount from one currency to another using the provided exchange rate. Arguments: amount (float): the amount in the initial currency to be converted. exchange_rate (float): the conversion rate from the initial currency to the target currency. Returns: float: The amount converted to the target currency. Raises: ValueError: if the amount or exchange rate is non-positive. if amount <= 0: raise ValueError(\\"Amount must be positive\\") if exchange_rate <= 0: raise ValueError(\\"Exchange rate must be positive\\") converted_amount = amount * exchange_rate return converted_amount"},{"question":"import numpy as np class CustomCNNClassifier: def __init__(self, image_shape: tuple, num_filters: int = 32, filter_size: int = 3, pool_size: int = 2, num_classes: int = 2): Initialize the CNN classifier with the given parameters. Args: image_shape (tuple): Shape of the input images (height, width, channels). num_filters (int): Number of filters for the convolutional layer. filter_size (int): Size of the convolution filters. pool_size (int): Size of the pooling window. num_classes (int): Number of output classes. pass def convolve(self, X: np.ndarray, filters: np.ndarray) -> np.ndarray: Apply convolution operation on the input data with the given filters. Args: X (np.ndarray): Input data of shape (N, height, width, channels). filters (np.ndarray): Convolution filters. Returns: np.ndarray: Convolved data. pass def max_pool(self, X: np.ndarray, pool_size: int) -> np.ndarray: Apply max-pooling operation on the input data with the given pooling size. Args: X (np.ndarray): Input data of shape (N, height, width, channels). pool_size (int): Size of the pooling window. Returns: np.ndarray: Pooled data. pass def fully_connected(self, X: np.ndarray) -> np.ndarray: Flatten the input data and pass it through a fully connected layer to output class scores. Args: X (np.ndarray): Input data. Returns: np.ndarray: Class scores. pass def fit(self, X_train: np.ndarray, y_train: np.ndarray, epochs: int = 10, learning_rate: float = 0.001) -> None: Train the CNN classifier using the training data for the specified number of epochs. Args: X_train (np.ndarray): Training images of shape (N, height, width, channels). y_train (np.ndarray): Training labels of shape (N,). epochs (int): Number of epochs to train the model. learning_rate (float): Learning rate for the optimizer. pass def predict(self, X_test: np.ndarray) -> np.ndarray: Predict the labels for the input test images. Args: X_test (np.ndarray): Test images of shape (N, height, width, channels). Returns: np.ndarray: Array of predicted labels of shape (N,). pass if __name__ == \\"__main__\\": # Test the classifier with random data X_train = np.random.randn(100, 28, 28, 1) y_train = np.random.randint(0, 2, 100) X_test = np.random.randn(20, 28, 28, 1) # Initialize and train the classifier cnn = CustomCNNClassifier(image_shape=(28, 28, 1), num_filters=32, filter_size=3, pool_size=2, num_classes=2) cnn.fit(X_train, y_train, epochs=10, learning_rate=0.001) # Predict and evaluate accuracy y_pred = cnn.predict(X_test) print(f\\"Predictions: {y_pred}\\")","solution":"import numpy as np class CustomCNNClassifier: def __init__(self, image_shape: tuple, num_filters: int = 32, filter_size: int = 3, pool_size: int = 2, num_classes: int = 2): self.image_shape = image_shape self.num_filters = num_filters self.filter_size = filter_size self.pool_size = pool_size self.num_classes = num_classes # Initialize filters (weights) for convolution self.filters = np.random.randn(num_filters, filter_size, filter_size, image_shape[2]) # Weights for the fully connected layer fc_input_size = ((image_shape[0] - filter_size + 1) // pool_size) * ((image_shape[1] - filter_size + 1) // pool_size) * num_filters self.fc_weights = np.random.randn(fc_input_size, num_classes) self.fc_bias = np.random.randn(num_classes) def convolve(self, X: np.ndarray, filters: np.ndarray) -> np.ndarray: N, height, width, channels = X.shape num_filters, filter_size, _, _ = filters.shape new_height = height - filter_size + 1 new_width = width - filter_size + 1 conv_output = np.zeros((N, new_height, new_width, num_filters)) for i in range(new_height): for j in range(new_width): region = X[:, i:i+filter_size, j:j+filter_size, :] for k in range(num_filters): conv_output[:, i, j, k] = np.sum(region * filters[k], axis=(1, 2, 3)) return conv_output def max_pool(self, X: np.ndarray, pool_size: int) -> np.ndarray: N, height, width, channels = X.shape new_height = height // pool_size new_width = width // pool_size pooled_output = np.zeros((N, new_height, new_width, channels)) for i in range(new_height): for j in range(new_width): region = X[:, i*pool_size:(i+1)*pool_size, j*pool_size:(j+1)*pool_size, :] pooled_output[:, i, j, :] = np.max(region, axis=(1, 2)) return pooled_output def fully_connected(self, X: np.ndarray) -> np.ndarray: N = X.shape[0] X_flat = X.reshape(N, -1) return np.dot(X_flat, self.fc_weights) + self.fc_bias def fit(self, X_train: np.ndarray, y_train: np.ndarray, epochs: int = 10, learning_rate: float = 0.001) -> None: for epoch in range(epochs): # Forward pass conv_output = self.convolve(X_train, self.filters) pooled_output = self.max_pool(conv_output, self.pool_size) logits = self.fully_connected(pooled_output) # Compute loss (simple binary cross-entropy) probs = 1 / (1 + np.exp(-logits)) loss = -np.mean(y_train * np.log(probs[:, 1]) + (1 - y_train) * np.log(1 - probs[:, 1])) # Backward pass grad_logits = probs grad_logits[range(X_train.shape[0]), y_train] -= 1 grad_logits /= X_train.shape[0] grad_fc_weights = np.dot(pooled_output.reshape(X_train.shape[0], -1).T, grad_logits) grad_fc_bias = np.sum(grad_logits, axis=0) # Update weights (simplified without gradients for convolution and pooling) self.fc_weights -= learning_rate * grad_fc_weights self.fc_bias -= learning_rate * grad_fc_bias def predict(self, X_test: np.ndarray) -> np.ndarray: conv_output = self.convolve(X_test, self.filters) pooled_output = self.max_pool(conv_output, self.pool_size) logits = self.fully_connected(pooled_output) probs = 1 / (1 + np.exp(-logits)) return np.argmax(probs, axis=1)"},{"question":"def is_circular_prime(n: int) -> bool: Check if a number is a circular prime. A circular prime is a prime number that remains prime when its digits are cyclically rotated in any order. >>> is_circular_prime(197) True >>> is_circular_prime(101) False >>> is_circular_prime(71) True >>> is_circular_prime(107) False >>> is_circular_prime(11) True","solution":"def is_prime(num): Helper function to check if a number is prime. if num < 2: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def rotations(n): Generate all cyclic rotations of an integer n. s = str(n) return [int(s[i:] + s[:i]) for i in range(len(s))] def is_circular_prime(n): Check if the number n is a circular prime. return all(is_prime(rot) for rot in rotations(n))"},{"question":"def sqrt_binary_search(a: float, max_iter: int = 9999, tolerance: float = 1e-14) -> float: Square root approximated using binary search method. :param a: The non-negative number to find the square root of. :param max_iter: The maximum number of iterations to run (default = 9999). :param tolerance: The tolerance level for considering the approximation as sufficiently accurate (default = 1e-14). :return: Approximated square root of the given number. >>> abs(sqrt_binary_search(4) - 2.0) <= 1e-14 True >>> abs(sqrt_binary_search(2) - 1.414213562373095) <= 1e-14 True >>> abs(sqrt_binary_search(0.25) - 0.5) <= 1e-14 True >>> abs(sqrt_binary_search(100) - 10.0) <= 1e-14 True pass","solution":"def sqrt_binary_search(a: float, max_iter: int = 9999, tolerance: float = 1e-14) -> float: Square root approximated using binary search method. :param a: The non-negative number to find the square root of. :param max_iter: The maximum number of iterations to run (default = 9999). :param tolerance: The tolerance level for considering the approximation as sufficiently accurate (default = 1e-14). :return: Approximated square root of the given number. if a < 0: raise ValueError(\\"Input must be a non-negative number.\\") if a == 0 or a == 1: return a lower_bound = 0 upper_bound = max(1, a) mid = (lower_bound + upper_bound) / 2 iter_count = 0 while abs(mid**2 - a) > tolerance and iter_count < max_iter: if mid**2 < a: lower_bound = mid else: upper_bound = mid mid = (lower_bound + upper_bound) / 2 iter_count += 1 return mid"},{"question":"def min_edit_distance(word1: str, word2: str) -> int: Calculate the minimum edit distance required to transform word1 into word2 using dynamic programming. The permissible operations are: insert a character, delete a character, and replace a character. >>> min_edit_distance(\\"horse\\", \\"ros\\") 3 >>> min_edit_distance(\\"intention\\", \\"execution\\") 5 >>> min_edit_distance(\\"\\", \\"target\\") 6 >>> min_edit_distance(\\"source\\", \\"\\") 6 >>> min_edit_distance(\\"same\\", \\"same\\") 0 >>> min_edit_distance(\\"a\\", \\"b\\") 1 >>> min_edit_distance(\\"abc\\", \\"abcd\\") 1 >>> min_edit_distance(\\"abcd\\", \\"abc\\") 1 >>> min_edit_distance(\\"abc\\", \\"yabd\\") 2 # Implementation here","solution":"def min_edit_distance(word1: str, word2: str) -> int: # Initialize dimensions of DP table m, n = len(word1), len(word2) # Create a DP table with dimensions (m+1) x (n+1) dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the first row and first column of the DP table for i in range(m + 1): dp[i][0] = i # Deletion for j in range(n + 1): dp[0][j] = j # Insertion # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # No operation required else: dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1) # Replacement # The result is the value in the bottom-right corner of the DP table return dp[m][n]"},{"question":"def add_todo_item(todo_list: list, task: str, priority: int) -> list: Adds a new task to the todo list with a specified priority. >>> todo_list = add_todo_item([], \\"Finish project report\\", 2) >>> todo_list [('Finish project report', 2)] def remove_todo_item(todo_list: list, task: str) -> list: Removes a task from the todo list. >>> todo_list = [(\\"Finish project report\\", 2), (\\"Buy groceries\\", 1)] >>> todo_list = remove_todo_item(todo_list, \\"Buy groceries\\") >>> todo_list [('Finish project report', 2)] def list_todo_items(todo_list: list) -> list: Lists the todo items sorted by priority (highest priority first). >>> todo_list = [(\\"Finish project report\\", 2), (\\"Clean the house\\", 3), (\\"Buy groceries\\", 1)] >>> list_todo_items(todo_list) [('Buy groceries', 1), ('Finish project report', 2), ('Clean the house', 3)]","solution":"def add_todo_item(todo_list, task, priority): Adds a new task to the todo list with the specified priority. :param todo_list: List of current todo items, each represented as a tuple (task, priority). :param task: String description of the new task. :param priority: Integer priority of the new task (1 is highest priority). :return: Updated list of todo items. if task and isinstance(task, str) and isinstance(priority, int) and priority > 0: for t, _ in todo_list: if t == task: return todo_list # Task already exists, do not add duplicate todo_list.append((task, priority)) return todo_list def remove_todo_item(todo_list, task): Removes a task from the todo list. :param todo_list: List of current todo items, each represented as a tuple (task, priority). :param task: String description of the task to be removed. :return: Updated list of todo items. for i, (t, _) in enumerate(todo_list): if t == task: del todo_list[i] break return todo_list def list_todo_items(todo_list): Lists the todo items sorted by priority (highest priority first). :param todo_list: List of current todo items, each represented as a tuple (task, priority). :return: List of todo items sorted by priority. return sorted(todo_list, key=lambda x: x[1])"},{"question":"from typing import List def find_most_frequent_digit(numbers: List[int]) -> int: Find the digit (0-9) that appears most frequently across all numbers in the given list. If there is a tie, return the smallest digit among them. >>> find_most_frequent_digit([123, 456, 789, 123]) 1 >>> find_most_frequent_digit([341, 414, 916, 114]) 1 >>> find_most_frequent_digit([10, 20, 30, 40, 50]) 0","solution":"from typing import List def find_most_frequent_digit(numbers: List[int]) -> int: digit_count = [0] * 10 # Initialize array to count occurrences of each digit 0-9 # Count the occurrences of each digit in the numbers list for number in numbers: while number > 0: digit = number % 10 digit_count[digit] += 1 number //= 10 # Find the digit with the maximum occurrences, preferring smaller digits in case of ties max_count = -1 most_frequent_digit = 0 for i in range(10): if digit_count[i] > max_count: max_count = digit_count[i] most_frequent_digit = i return most_frequent_digit"},{"question":"def find_word_ladder(start: str, target: str, word_list: List[str]) -> List[str]: Find the shortest transformation sequence from a starting word to a target word, changing one letter at a time and ensuring each transformed word exists in the dictionary. >>> find_word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] >>> find_word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) []","solution":"from collections import deque from typing import List def find_word_ladder(start: str, target: str, word_list: List[str]) -> List[str]: if target not in word_list or not start or not target or not word_list: return [] word_set = set(word_list) queue = deque([[start]]) visited = set() while queue: path = queue.popleft() current_word = path[-1] if current_word == target: return path for i in range(len(current_word)): for char in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + char + current_word[i + 1:] if next_word in word_set and next_word not in visited: visited.add(next_word) queue.append(path + [next_word]) return []"},{"question":"def reorganize_string(s: str) -> str: Reorganizes the string such that no two adjacent characters are the same. Returns the rearranged string or an empty string if not possible. >>> reorganize_string(\\"aab\\") == \\"aba\\" >>> reorganize_string(\\"aaab\\") == \\"\\"","solution":"import heapq from collections import Counter def reorganize_string(s: str) -> str: Reorganizes the string such that no two adjacent characters are the same. Returns the rearranged string or an empty string if not possible. # Count the frequency of each character freq = Counter(s) max_heap = [] # Push all characters along with their frequencies into a max heap for char, count in freq.items(): heapq.heappush(max_heap, (-count, char)) prev_char, prev_freq = None, 0 result = [] # Until the heap is empty, try to rearrange the string while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) # If there's a previous character to be reinserted, do so now if prev_char and prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Update the previous character and frequency prev_char = char prev_freq = freq + 1 # Increment frequency because we're using a max heap # Return the result if it's the same length as the input string, otherwise it's invalid return ''.join(result) if len(result) == len(s) else \\"\\""},{"question":"from typing import List def find_missing_number(sequence: List[int]) -> int: Given a list of consecutive numbers with one missing number, this function returns the missing number. >>> find_missing_number([1, 2, 4, 5]) 3 >>> find_missing_number([3, 4, 5, 7]) 6 >>> find_missing_number([10, 11, 13, 14, 15]) 12 >>> find_missing_number([101, 102, 103, 104, 106]) 105 pass","solution":"from typing import List def find_missing_number(sequence: List[int]) -> int: Given a list of consecutive numbers with one missing number, this function returns the missing number. n = len(sequence) + 1 total_sum = sum(range(min(sequence), min(sequence) + n)) actual_sum = sum(sequence) missing_number = total_sum - actual_sum return missing_number"},{"question":"def csv_to_json(csv_string: str) -> str: Convert a CSV formatted string into a JSON formatted string representing the same data. >>> csv_to_json(\\"\\") \\"[]\\" >>> csv_to_json(\\"name,agenalice,30\\") '[{\\"name\\": \\"alice\\", \\"age\\": \\"30\\"}]' >>> csv_to_json(\\"name,agenalice,30nbob,25\\") '[{\\"name\\": \\"alice\\", \\"age\\": \\"30\\"}, {\\"name\\": \\"bob\\", \\"age\\": \\"25\\"}]'","solution":"import json def csv_to_json(csv_string: str) -> str: if not csv_string.strip(): return json.dumps([]) lines = csv_string.strip().split('n') headers = lines[0].split(',') json_list = [] for line in lines[1:]: values = line.split(',') json_list.append(dict(zip(headers, values))) return json.dumps(json_list)"},{"question":"from typing import Dict, Union def analyze_server_logs(log_file_path: str) -> Dict[str, Union[int, Dict[str, int]]]: Analyze the log file and return a summary of the log data. The summary includes the total number of requests, a count of each type of HTTP method, and a count of each unique HTTP response code. >>> log_content = ''' 2023-01-01T13:23:45 GET /index.html 200 2023-01-01T13:24:01 POST /form 404 2023-01-01T13:25:12 GET /images/logo.png 200''' >>> with tempfile.NamedTemporaryFile(delete=False) as temp_log_file: >>> temp_log_file.write(log_content.encode('utf-8')) >>> temp_log_file_path = temp_log_file.name >>> >>> analyze_server_logs(temp_log_file_path) { \\"total_requests\\": 3, \\"methods\\": { \\"GET\\": 2, \\"POST\\": 1, \\"PUT\\": 0, \\"DELETE\\": 0, \\"other\\": 0, }, \\"response_codes\\": { \\"200\\": 2, \\"404\\": 1, } } pass","solution":"from typing import Dict, Union import collections def analyze_server_logs(log_file_path: str) -> Dict[str, Union[int, Dict[str, int]]]: summary = { \\"total_requests\\": 0, \\"methods\\": { \\"GET\\": 0, \\"POST\\": 0, \\"PUT\\": 0, \\"DELETE\\": 0, \\"other\\": 0, }, \\"response_codes\\": collections.defaultdict(int) } with open(log_file_path, 'r') as log_file: for line in log_file: parts = line.strip().split() if len(parts) != 4: continue _, method, _, response_code = parts summary[\\"total_requests\\"] += 1 if method in summary[\\"methods\\"]: summary[\\"methods\\"][method] += 1 else: summary[\\"methods\\"][\\"other\\"] += 1 summary[\\"response_codes\\"][response_code] += 1 # Convert defaultdict to a regular dict for the response codes summary[\\"response_codes\\"] = dict(summary[\\"response_codes\\"]) return summary"},{"question":"class BSTNode: def __init__(self, value: int): Initializes a node with a given value. pass class BinarySearchTree: def __init__(self): Initializes an empty binary search tree. pass def insert(self, value: int) -> None: Inserts a value into the binary search tree. Args: value (int): The value to insert into the tree. Raises: ValueError: If the value is not an integer. pass def search(self, value: int) -> bool: Searches for a value in the binary search tree. Args: value (int): The value to search for in the tree. Returns: bool: True if the value is found, False otherwise. Raises: ValueError: If the value is not an integer. pass","solution":"class BSTNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int) -> None: if not isinstance(value, int): raise ValueError(\\"Value must be an integer.\\") if self.root is None: self.root = BSTNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, current: BSTNode, value: int) -> None: if value < current.value: if current.left is None: current.left = BSTNode(value) else: self._insert_recursive(current.left, value) elif value > current.value: if current.right is None: current.right = BSTNode(value) else: self._insert_recursive(current.right, value) # If value == current.value, ignore the insertion (do nothing) def search(self, value: int) -> bool: if not isinstance(value, int): raise ValueError(\\"Value must be an integer.\\") return self._search_recursive(self.root, value) def _search_recursive(self, current: BSTNode, value: int) -> bool: if current is None: return False if value == current.value: return True elif value < current.value: return self._search_recursive(current.left, value) else: return self._search_recursive(current.right, value)"},{"question":"class LoginTimestampManager: def __init__(self): Initialize the data structure to store timestamps. # Your code here def add_timestamp(self, timestamp: int) -> None: Add a new login timestamp. Parameters: timestamp (int): The login timestamp to be added. This integer represents the timestamp in seconds since epoch. Example Usage: >>> manager = LoginTimestampManager() >>> manager.add_timestamp(1632994025) # Your code here def query_logins(self, start_time: int, end_time: int) -> int: Query the number of logins that occurred between start_time (inclusive) and end_time (inclusive). Parameters: start_time (int): The start of the time range for the query. end_time (int): The end of the time range for the query. Returns: int: The number of login timestamps within the specified range. Example Usage: >>> manager = LoginTimestampManager() >>> manager.add_timestamp(1632994025) >>> manager.add_timestamp(1632994825) >>> manager.query_logins(1632994000, 1632994600) 1 >>> manager.query_logins(1632994000, 1632995000) 2 # Your code here","solution":"from bisect import bisect_left, bisect_right class LoginTimestampManager: def __init__(self): Initialize the data structure to store timestamps. self.timestamps = [] def add_timestamp(self, timestamp: int) -> None: Add a new login timestamp. Parameters: timestamp (int): The login timestamp to be added. This integer represents the timestamp in seconds since epoch. self.timestamps.append(timestamp) def query_logins(self, start_time: int, end_time: int) -> int: Query the number of logins that occurred between start_time (inclusive) and end_time (inclusive). Parameters: start_time (int): The start of the time range for the query. end_time (int): The end of the time range for the query. Returns: int: The number of login timestamps within the specified range. # Use binary search to find the indices of timestamps in the specified range start_index = bisect_left(self.timestamps, start_time) end_index = bisect_right(self.timestamps, end_time) return end_index - start_index"},{"question":"def count_ways(target: int, nums: List[int]) -> int: Count the number of distinct ways to reach exactly the target using the step sizes given in nums. >>> count_ways(4, [1, 2, 3]) 7 >>> count_ways(3, [2]) 0 >>> count_ways(6, [1, 2, 3]) 24","solution":"from typing import List def count_ways(target: int, nums: List[int]) -> int: Returns the number of distinct ways to reach the target using step sizes in nums. dp = [0] * (target + 1) dp[0] = 1 # There is one way to reach zero, by doing nothing for i in range(1, target + 1): for num in nums: if i - num >= 0: dp[i] += dp[i - num] return dp[target]"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the characters of the given string can be rearranged to form a palindrome. :param s: A string containing lowercase alphabetic characters only. :return: True if it is possible to rearrange the characters to form a palindrome, False otherwise. Examples: >>> can_form_palindrome('aabb') True >>> can_form_palindrome('abba') True >>> can_form_palindrome('abc') False >>> can_form_palindrome('carerac') True","solution":"def can_form_palindrome(s: str) -> bool: Determines if the characters of the given string can be rearranged to form a palindrome. :param s: A string containing lowercase alphabetic characters only. :return: True if it is possible to rearrange the characters to form a palindrome, False otherwise. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd frequency return odd_count <= 1"},{"question":"class FileSystem: A basic in-memory file system that can create files, write data to files, read data from files, and delete files. Methods: - __init__(self): Initializes the file system. - create_file(self, path: str) -> bool: Creates a file at the specified path. Returns True if successful, False if the file already exists or an invalid path is given. - write_to_file(self, path: str, data: str) -> bool: Writes the data to the file at the specified path. Returns True if successful, False if the file does not exist. - read_from_file(self, path: str) -> str: Reads the data from the file at the specified path. Returns the file content as a string. If the file does not exist, returns an empty string. - delete_file(self, path: str) -> bool: Deletes the file at the specified path. Returns True if successful, False if the file does not exist. Example: >>> fs = FileSystem() >>> fs.create_file(\\"/a/b/c.txt\\") True >>> fs.create_file(\\"/a/b/c.txt\\") False >>> fs.write_to_file(\\"/a/b/c.txt\\", \\"Hello, World!\\") True >>> fs.read_from_file(\\"/a/b/c.txt\\") \\"Hello, World!\\" >>> fs.delete_file(\\"/a/b/c.txt\\") True >>> fs.delete_file(\\"/a/b/c.txt\\") False def __init__(self): pass def create_file(self, path: str) -> bool: pass def write_to_file(self, path: str, data: str) -> bool: pass def read_from_file(self, path: str) -> str: pass def delete_file(self, path: str) -> bool: pass # Unit tests def test_create_file(): fs = FileSystem() assert fs.create_file(\\"/a/b/c.txt\\") == True assert fs.create_file(\\"/a/b/c.txt\\") == False def test_write_to_file(): fs = FileSystem() fs.create_file(\\"/a/b/c.txt\\") assert fs.write_to_file(\\"/a/b/c.txt\\", \\"Hello, World!\\") == True assert fs.write_to_file(\\"/a/b/d.txt\\", \\"Should not write\\") == False def test_read_from_file(): fs = FileSystem() fs.create_file(\\"/a/b/c.txt\\") fs.write_to_file(\\"/a/b/c.txt\\", \\"Hello, World!\\") assert fs.read_from_file(\\"/a/b/c.txt\\") == \\"Hello, World!\\" assert fs.read_from_file(\\"/a/b/d.txt\\") == \\"\\" def test_delete_file(): fs = FileSystem() fs.create_file(\\"/a/b/c.txt\\") assert fs.delete_file(\\"/a/b/c.txt\\") == True assert fs.delete_file(\\"/a/b/c.txt\\") == False","solution":"class FileSystem: def __init__(self): self.files = {} def create_file(self, path: str) -> bool: if path in self.files: return False self.files[path] = \\"\\" return True def write_to_file(self, path: str, data: str) -> bool: if path not in self.files: return False self.files[path] = data return True def read_from_file(self, path: str) -> str: return self.files.get(path, \\"\\") def delete_file(self, path: str) -> bool: if path in self.files: del self.files[path] return True return False"},{"question":"def custom_formatter(template: str, values: dict[str, any]) -> str: Formats the template string using the provided dictionary values. Arguments: template -- A template string containing placeholders in the format {name}. values -- A dictionary where keys are placeholder names and values are their corresponding values. Returns: The formatted string with all placeholders replaced by their corresponding dictionary values. Example: >>> custom_formatter(\\"Hello, {name}! Welcome to {city}.\\", {\\"name\\": \\"Alice\\", \\"city\\": \\"Wonderland\\"}) 'Hello, Alice! Welcome to Wonderland.' >>> custom_formatter(\\"The price of {item} is {price} USD.\\", {\\"item\\": \\"apple\\", \\"price\\": 1.2}) 'The price of apple is 1.2 USD.' >>> custom_formatter(\\"{greeting}, {name}!\\", {\\"greeting\\": \\"Hi\\", \\"name\\": \\"Bob\\"}) 'Hi, Bob!'","solution":"def custom_formatter(template: str, values: dict[str, any]) -> str: Formats the template string using the provided dictionary values. Args: template (str): A template string containing placeholders in the format {name}. values (dict): A dictionary where keys are placeholder names and values are their corresponding values. Returns: str: The formatted string with all placeholders replaced by their corresponding dictionary values. try: formatted_string = template.format(**values) except KeyError as e: raise KeyError(f\\"Missing value for key: {e}\\") return formatted_string"},{"question":"from PIL import Image, ImageDraw def sierpinski_triangle( image_width: int, image_height: int, max_depth: int = 5 ) -> Image.Image: Generates an image of the Sierpinski triangle up to the given recursion depth. Parameters: - image_width (int): Width of the image in pixels. - image_height (int): Height of the image in pixels. - max_depth (int): Maximum recursion depth. Returns: - Image.Image: The generated image of the Sierpinski triangle. # Unit Tests def test_sierpinski_triangle_dimensions(): img = sierpinski_triangle(800, 600, 3) assert img.size == (800, 600) def test_sierpinski_triangle_default_depth(): img = sierpinski_triangle(800, 600) assert isinstance(img, Image.Image) def test_sierpinski_triangle_minimum_depth(): img = sierpinski_triangle(800, 600, 1) assert isinstance(img, Image.Image) def test_sierpinski_triangle_maximum_depth(): img = sierpinski_triangle(800, 600, 10) assert isinstance(img, Image.Image) def test_sierpinski_triangle_small_image(): img = sierpinski_triangle(100, 100, 3) assert img.size == (100, 100) def test_sierpinski_triangle_large_image(): img = sierpinski_triangle(2000, 2000, 4) assert img.size == (2000, 2000)","solution":"from PIL import Image, ImageDraw import math def sierpinski_triangle(image_width: int, image_height: int, max_depth: int = 5) -> Image.Image: Generates an image of the Sierpinski triangle up to the given recursion depth. Parameters: - image_width (int): Width of the image in pixels. - image_height (int): Height of the image in pixels. - max_depth (int): Maximum recursion depth. Returns: - Image.Image: The generated image of the Sierpinski triangle. # Create a new white image image = Image.new('RGB', (image_width, image_height), 'white') draw = ImageDraw.Draw(image) # Calculate the height of the equilateral triangle given its width def triangle_height(width): return width * (math.sqrt(3) / 2) # Sierpinski Triangle drawing function def draw_sierpinski(x, y, side_length, depth): # Calculate the three points of the equilateral triangle h = triangle_height(side_length) vertices = [ (x, y), (x + side_length / 2, y + h), (x - side_length / 2, y + h) ] # Draw the triangle using the vertices draw.polygon(vertices, outline='black', fill='black') # If the maximum depth is reached, stop the recursion if depth == 0: return # Calculate the side length and height for the inner triangles inner_side_length = side_length / 2 inner_h = triangle_height(inner_side_length) # Recursively draw the three inner triangles draw_sierpinski(x, y, inner_side_length, depth - 1) # Top triangle draw_sierpinski(x - inner_side_length / 2, y + inner_h, inner_side_length, depth - 1) # Bottom-left draw_sierpinski(x + inner_side_length / 2, y + inner_h, inner_side_length, depth - 1) # Bottom-right # Initial coordinates (center the triangle horizontally, top vertically) initial_x = image_width // 2 initial_y = 0 # Starting from the top # Initial side length of the base triangle initial_side_length = image_width # Draw the Sierpinski Triangle draw_sierpinski(initial_x, initial_y, initial_side_length, max_depth) return image"},{"question":"def schedule_coffee_breaks(employee_preferences): Determine a non-overlapping coffee break schedule for employees based on their preferred time slots. :param employee_preferences: Dictionary where keys are employee names and values are lists representing their preferred time slots. :return: A dictionary where keys are employee names and values are assigned coffee break slots. >>> employee_preferences = { ... \\"Alice\\": [\\"10:00-10:30\\", \\"11:00-11:30\\"], ... \\"Bob\\": [\\"10:00-10:30\\", \\"11:00-11:30\\"], ... \\"Charlie\\": [\\"11:00-11:30\\"], ... \\"David\\": [\\"10:30-11:00\\"] ... } >>> schedule_coffee_breaks(employee_preferences) { \\"Alice\\": \\"10:00-10:30\\", \\"Bob\\": \\"11:00-11:30\\", \\"Charlie\\": \\"Not Possible\\", \\"David\\": \\"10:30-11:00\\" } pass","solution":"def schedule_coffee_breaks(employee_preferences): Determine a non-overlapping coffee break schedule for employees based on their preferred time slots. :param employee_preferences: Dictionary where keys are employee names and values are lists representing their preferred time slots. :return: A dictionary where keys are employee names and values are assigned coffee break slots. assigned_slots = {} used_slots = set() # Iterate through each employee and their preferences for employee, preferences in employee_preferences.items(): assigned = False for slot in preferences: if slot not in used_slots: assigned_slots[employee] = slot used_slots.add(slot) assigned = True break if not assigned: assigned_slots[employee] = \\"Not Possible\\" return assigned_slots"},{"question":"import datetime rental_data = {} def rent_bicycle(bike_id): Starts renting a bicycle with the given bike_id. Saves the current timestamp as the rent start time. :param bike_id: str - Unique identifier of the bicycle :raises ValueError: if the bicycle is already rented pass def return_bicycle(bike_id, return_time): Ends the rental and calculates the rental fee based on the total time the bicycle was rented. :param bike_id: str - Unique identifier of the bicycle :param return_time: str - The time when the bicycle is returned in the format \\"YYYY-MM-DD HH:MM\\" :return: float - The total rental fee in dollars :raises ValueError: if the bike_id is not found or not currently rented pass import pytest # Mock datetime to control current time class MockDateTime(datetime.datetime): @classmethod def now(cls): return cls(2023, 10, 1, 9, 15) datetime.datetime = MockDateTime def test_rent_and_return_within_first_hour(): rent_bicycle(\\"bike123\\") assert return_bicycle(\\"bike123\\", \\"2023-10-01 09:45\\") == 5.0 def test_rent_and_return_one_hour_exactly(): rent_bicycle(\\"bike124\\") assert return_bicycle(\\"bike124\\", \\"2023-10-01 10:15\\") == 5.0 def test_rent_and_return_two_hours(): rent_bicycle(\\"bike125\\") assert return_bicycle(\\"bike125\\", \\"2023-10-01 11:15\\") == 8.0 def test_rent_and_return_two_and_half_hours(): rent_bicycle(\\"bike126\\") assert return_bicycle(\\"bike126\\", \\"2023-10-01 11:45\\") == 11.0 def test_rent_bicycle_already_rented(): rent_bicycle(\\"bike127\\") with pytest.raises(ValueError, match=\\"Bicycle bike127 is already rented\\"): rent_bicycle(\\"bike127\\") def test_return_non_existent_bicycle(): with pytest.raises(ValueError, match=\\"Bicycle bike128 not found in rental records\\"): return_bicycle(\\"bike128\\", \\"2023-10-01 12:00\\")","solution":"import datetime rental_data = {} def rent_bicycle(bike_id): Starts renting a bicycle with the given bike_id. Saves the current timestamp as the rent start time. current_time = datetime.datetime.now().strftime(\\"%Y-%m-%d %H:%M\\") if bike_id in rental_data: raise ValueError(f\\"Bicycle {bike_id} is already rented\\") rental_data[bike_id] = current_time def return_bicycle(bike_id, return_time): Ends the rental and calculates the rental fee based on the total time the bicycle was rented. if bike_id not in rental_data: raise ValueError(f\\"Bicycle {bike_id} not found in rental records\\") rent_time_str = rental_data.pop(bike_id) rent_time = datetime.datetime.strptime(rent_time_str, \\"%Y-%m-%d %H:%M\\") return_time_dt = datetime.datetime.strptime(return_time, \\"%Y-%m-%d %H:%M\\") rental_period = return_time_dt - rent_time rental_hours = rental_period.total_seconds() // 3600 rental_hours_remainder = rental_period.total_seconds() % 3600 if rental_hours_remainder > 0: rental_hours += 1 total_cost = 5 + max(0, rental_hours - 1) * 3 return total_cost"},{"question":"from functools import lru_cache def longest_common_subsequence(str1: str, str2: str) -> int: Find the length of the longest common subsequence (LCS) between two strings using dynamic programming. Args: str1 (str): First input string. str2 (str): Second input string. Returns: int: Length of the LCS. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence(\\"\\", \\"abc\\") 0 >>> longest_common_subsequence(\\"abc\\", \\"\\") 0 def test_lcs_example_1(): assert longest_common_subsequence(\\"abcde\\", \\"ace\\") == 3 def test_lcs_example_2(): assert longest_common_subsequence(\\"abc\\", \\"abc\\") == 3 def test_lcs_example_3(): assert longest_common_subsequence(\\"abc\\", \\"def\\") == 0 def test_lcs_empty_string_1(): assert longest_common_subsequence(\\"\\", \\"abc\\") == 0 def test_lcs_empty_string_2(): assert longest_common_subsequence(\\"abc\\", \\"\\") == 0 def test_lcs_no_common_subsequence(): assert longest_common_subsequence(\\"abcd\\", \\"efgh\\") == 0 def test_lcs_partial_match(): assert longest_common_subsequence(\\"abcdef\\", \\"abdf\\") == 4 def test_lcs_entire_string(): assert longest_common_subsequence(\\"xyz\\", \\"xyz\\") == 3","solution":"from functools import lru_cache def longest_common_subsequence(str1: str, str2: str) -> int: @lru_cache(None) def lcs(x, y): if x == 0 or y == 0: return 0 elif str1[x-1] == str2[y-1]: return 1 + lcs(x-1, y-1) else: return max(lcs(x-1, y), lcs(x, y-1)) return lcs(len(str1), len(str2))"},{"question":"def circular_array_rotation(array: list[int], k: int) -> list[int]: Rotates the elements of the array k times to the right and returns the resulting array. >>> circular_array_rotation([1, 2, 3, 4, 5], 3) [3, 4, 5, 1, 2] >>> circular_array_rotation([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> circular_array_rotation([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> circular_array_rotation([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> circular_array_rotation([], 3) [] >>> circular_array_rotation([10, 20, 30], 2) [20, 30, 10]","solution":"def circular_array_rotation(array: list[int], k: int) -> list[int]: Rotates the elements of the array k times to the right and returns the resulting array. :param array: List of integers to be rotated :param k: Number of rotations to the right :return: Rotated list of integers if not array: return [] n = len(array) k = k % n # Handle cases where k is greater than the array length return array[-k:] + array[:-k]"},{"question":"class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def push(self, data): new_node = Node(data) new_node.next = self.head self.head = new_node def to_list(self): result = [] current = self.head while current: result.append(current.data) current = current.next return result def insert_sorted(self, data: int) -> None: Inserts a new node into the sorted linked list. Args: data (int): The data of the new node to be inserted. Example: >>> link = LinkedList() >>> link.push(10) >>> link.push(5) >>> link.push(1) >>> link.insert_sorted(7) >>> link.to_list() # Expected output: [1, 5, 7, 10]","solution":"class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def push(self, data): new_node = Node(data) new_node.next = self.head self.head = new_node def to_list(self): result = [] current = self.head while current: result.append(current.data) current = current.next return result def insert_sorted(self, data): new_node = Node(data) if self.head is None or self.head.data >= new_node.data: new_node.next = self.head self.head = new_node return current = self.head while current.next and current.next.data < new_node.data: current = current.next new_node.next = current.next current.next = new_node"},{"question":"Write a class method called \`VirtualCinema\` that manages a virtual cinema booking and seat allocation mechanism. This class should include the following methods: \`__init__\`, \`book_seat\`, \`cancel_booking\`, and \`check_seat_status\`. # Implementation Details 1. **Characteristics**: - Each seat is uniquely identified by its row and seat number within that row. - Operations should efficiently handle checking, booking, and canceling seats. 2. **Methods**: - \`__init__(self, rows: int, seats_per_row: int) -> None\`: Initializes the cinema with a specified number of rows and seats per row. - \`book_seat(self, row: int, seat: int) -> str\`: Attempts to book a specified seat. - \`cancel_booking(self, row: int, seat: int) -> str\`: Cancels a booking for the specified seat. - \`check_seat_status(self, row: int, seat: int) -> str\`: Checks if a seat is booked or available. 3. **Constraints**: - Rows and seats per row should be within realistic theatre limits (e.g., 1-30 rows, 1-50 seats per row). # Function Signature class VirtualCinema: def __init__(self, rows: int, seats_per_row: int) -> None: pass def book_seat(self, row: int, seat: int) -> str: pass def cancel_booking(self, row: int, seat: int) -> str: pass def check_seat_status(self, row: int, seat: int) -> str: pass","solution":"class VirtualCinema: def __init__(self, rows: int, seats_per_row: int) -> None: Initialize the cinema with the number of rows and seats per row. self.rows = rows self.seats_per_row = seats_per_row self.bookings = [[False] * seats_per_row for _ in range(rows)] def book_seat(self, row: int, seat: int) -> str: Attempts to book the specified seat. if row < 1 or row > self.rows or seat < 1 or seat > self.seats_per_row: return \\"Invalid seat selection.\\" if self.bookings[row - 1][seat - 1]: return \\"Seat is already booked.\\" self.bookings[row - 1][seat - 1] = True return f\\"Seat at row {row}, seat {seat} has been booked.\\" def cancel_booking(self, row: int, seat: int) -> str: Cancels the booking for the specified seat. if row < 1 or row > self.rows or seat < 1 or seat > self.seats_per_row: return \\"Invalid seat selection.\\" if not self.bookings[row - 1][seat - 1]: return \\"Seat is not booked.\\" self.bookings[row - 1][seat - 1] = False return f\\"Booking for seat at row {row}, seat {seat} has been canceled.\\" def check_seat_status(self, row: int, seat: int) -> str: Checks the booking status of the specified seat. if row < 1 or row > self.rows or seat < 1 or seat > self.seats_per_row: return \\"Invalid seat selection.\\" if self.bookings[row - 1][seat - 1]: return f\\"Seat at row {row}, seat {seat} is booked.\\" else: return f\\"Seat at row {row}, seat {seat} is available.\\""},{"question":"from typing import List def generate_fibonacci(n: int) -> List[int]: Generates the Fibonacci sequence up to the n-th number (inclusive). Args: n (int): The number of Fibonacci numbers to generate. Returns: List[int]: A list containing the Fibonacci sequence up to the n-th number. Examples: >>> generate_fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55] >>> generate_fibonacci(5) [0, 1, 1, 2, 3, 5] >>> generate_fibonacci(0) [0] >>> generate_fibonacci(1) [0, 1]","solution":"def generate_fibonacci(n: int): Generates the Fibonacci sequence up to the n-th number (inclusive). Args: n (int): The number of Fibonacci numbers to generate. Returns: List[int]: A list containing the Fibonacci sequence up to the n-th number. if n == 0: return [0] if n == 1: return [0, 1] fibonacci_sequence = [0, 1] for i in range(2, n + 1): next_fib = fibonacci_sequence[-1] + fibonacci_sequence[-2] fibonacci_sequence.append(next_fib) return fibonacci_sequence"},{"question":"def is_binary_palindrome(number: int) -> bool: Checks whether a given unsigned integer is a palindrome in its binary representation using bitwise operations. Args: number (int): The unsigned integer to be checked. Returns: bool: True if the binary representation of the input integer is a palindrome, False otherwise. Examples: >>> is_binary_palindrome(5) True >>> is_binary_palindrome(9) True >>> is_binary_palindrome(10) False","solution":"def is_binary_palindrome(number: int) -> bool: Checks if the binary representation of an unsigned integer is a palindrome. if number == 0: return True original_number = number reversed_number = 0 while number > 0: reversed_number = (reversed_number << 1) | (number & 1) number >>= 1 return original_number == reversed_number"},{"question":"import bisect import hashlib from typing import List, Tuple, Any class ConsistentHashing: def __init__(self): self.ring = {} self.sorted_keys = [] def _hash(self, key): return int(hashlib.sha256(key.encode()).hexdigest(), 16) % (2**32) def add_node(self, node_id): hashed_node = self._hash(node_id) if hashed_node not in self.ring: bisect.insort(self.sorted_keys, hashed_node) self.ring[hashed_node] = node_id def remove_node(self, node_id): hashed_node = self._hash(node_id) if hashed_node in self.ring: self.sorted_keys.remove(hashed_node) del self.ring[hashed_node] def locate(self, key): if not self.ring: return None hashed_key = self._hash(str(key)) idx = bisect.bisect_left(self.sorted_keys, hashed_key) if idx == len(self.sorted_keys): idx = 0 return self.ring[self.sorted_keys[idx]] def consistent_hashing(commands: List[Tuple[str, Any]]) -> List[Any]: Simulate the consistent hashing process and respond to queries accordingly. >>> consistent_hashing([('add', 'node1'), ('add', 'node2'), ('locate', 10)]) ['node1' or 'node2'] >>> consistent_hashing([('add', 'node1'), ('locate', 100), ('remove', 'node1'), ('locate', 200)]) ['node1', None] ch = ConsistentHashing() results = [] for command in commands: if command[0] == \\"add\\": ch.add_node(command[1]) elif command[0] == \\"remove\\": ch.remove_node(command[1]) elif command[0] == \\"locate\\": results.append(ch.locate(command[1])) return results","solution":"import bisect import hashlib class ConsistentHashing: def __init__(self): self.ring = {} self.sorted_keys = [] def _hash(self, key): return int(hashlib.sha256(key.encode()).hexdigest(), 16) % (2**32) def add_node(self, node_id): hashed_node = self._hash(node_id) if hashed_node not in self.ring: bisect.insort(self.sorted_keys, hashed_node) self.ring[hashed_node] = node_id def remove_node(self, node_id): hashed_node = self._hash(node_id) if hashed_node in self.ring: self.sorted_keys.remove(hashed_node) del self.ring[hashed_node] def locate(self, key): if not self.ring: return None hashed_key = self._hash(str(key)) idx = bisect.bisect_left(self.sorted_keys, hashed_key) if idx == len(self.sorted_keys): idx = 0 return self.ring[self.sorted_keys[idx]] def consistent_hashing(commands): ch = ConsistentHashing() results = [] for command in commands: if command[0] == \\"add\\": ch.add_node(command[1]) elif command[0] == \\"remove\\": ch.remove_node(command[1]) elif command[0] == \\"locate\\": results.append(ch.locate(command[1])) return results"},{"question":"# Function Signature: def reverse_words_in_string(s: str) -> str: pass # Example: # Example 1 s = \\" hi there \\" # Words reversed with preserved spaces: \\" there hi \\" print(reverse_words_in_string(s)) # Example 2 s = \\"hello world\\" # Words reversed with preserved spaces: \\"world hello\\" print(reverse_words_in_string(s)) # Example 3 s = \\"a b c\\" # Words reversed with preserved spaces: \\"c b a\\" print(reverse_words_in_string(s))","solution":"def reverse_words_in_string(s: str) -> str: Reverses the order of words in the given string while preserving the relative order of spaces. # Splitting the string into words and preserving spaces parts = s.split(' ') words = [part for part in parts if part != ''] spaces = [len(part) for part in parts if part == ''] # Output the string by processing words in reverse order result = [] word_index = len(words) - 1 for part in parts: if part == '': # Preserve spaces result.append('') else: # Append words in reverse order if word_index >= 0: result.append(words[word_index]) word_index -= 1 return ' '.join(result)"},{"question":"# Completion Task Implement the following: import requests from datetime import datetime, timedelta def get_historical_price(api_key: str, symbol: str, date: str) -> float: url = f\\"https://api.coingecko.com/api/v3/coins/{symbol}/history\\" params = {'date': date.replace('-', ''), 'localization': 'false'} try: response = requests.get(url, params=params, timeout=10) response.raise_for_status() data = response.json() return data['market_data']['current_price']['usd'] except requests.RequestException as e: print(f\\"An error occurred: {e}\\") return 0.0 def get_portfolio_value_by_date_range(api_key: str, portfolio: dict, start_date: str, end_date: str) -> dict: start = datetime.strptime(start_date, '%Y-%m-%d') end = datetime.strptime(end_date, '%Y-%m-%d') highest_value = 0.0 lowest_value = float('inf') while start <= end: portfolio_value = 0.0 for symbol, amount in portfolio.items(): price = get_historical_price(api_key, symbol, start.strftime('%d-%m-%Y')) portfolio_value += amount * price highest_value = max(highest_value, portfolio_value) lowest_value = min(lowest_value, portfolio_value) start += timedelta(days=1) return {'highest_value': highest_value, 'lowest_value': lowest_value} def get_current_portfolio_value(api_key: str, portfolio: dict) -> float: url = \\"https://api.coingecko.com/api/v3/simple/price\\" params = { 'ids': ','.join(portfolio.keys()), 'vs_currencies': 'usd' } try: response = requests.get(url, params=params, timeout=10) response.raise_for_status() prices = response.json() total_value = sum(amount * prices[symbol]['usd'] for symbol, amount in portfolio.items()) return total_value except requests.RequestException as e: return {\\"error\\": str(e)}","solution":"import requests from datetime import datetime, timedelta def get_historical_price(api_key: str, symbol: str, date: str) -> float: url = f\\"https://api.coingecko.com/api/v3/coins/{symbol}/history\\" params = {'date': date.replace('-', ''), 'localization': 'false'} try: response = requests.get(url, params=params, timeout=10) response.raise_for_status() data = response.json() return data['market_data']['current_price']['usd'] except requests.RequestException as e: print(f\\"An error occurred: {e}\\") return 0.0 def get_portfolio_value_by_date_range(api_key: str, portfolio: dict, start_date: str, end_date: str) -> dict: start = datetime.strptime(start_date, '%Y-%m-%d') end = datetime.strptime(end_date, '%Y-%m-%d') highest_value = 0.0 lowest_value = float('inf') while start <= end: portfolio_value = 0.0 for symbol, amount in portfolio.items(): price = get_historical_price(api_key, symbol, start.strftime('%d-%m-%Y')) portfolio_value += amount * price highest_value = max(highest_value, portfolio_value) lowest_value = min(lowest_value, portfolio_value) start += timedelta(days=1) return {'highest_value': highest_value, 'lowest_value': lowest_value} def get_current_portfolio_value(api_key: str, portfolio: dict) -> float: url = \\"https://api.coingecko.com/api/v3/simple/price\\" params = { 'ids': ','.join(portfolio.keys()), 'vs_currencies': 'usd' } try: response = requests.get(url, params=params, timeout=10) response.raise_for_status() prices = response.json() total_value = sum(amount * prices[symbol]['usd'] for symbol, amount in portfolio.items()) return total_value except requests.RequestException as e: return {\\"error\\": str(e)}"},{"question":"def find_peak_element(nums: list) -> int: Finds a peak element in the list and returns its index. A peak element is greater than or equal to its neighbors. For corner elements, only one neighbor is checked. >>> find_peak_element([1, 2, 3, 1]) in [2] >>> find_peak_element([1, 2, 1, 3, 5, 6, 4]) in [1, 5] >>> find_peak_element([5, 10, 20, 15]) in [2] >>> find_peak_element([10]) == 0","solution":"def find_peak_element(nums: list) -> int: Finds a peak element in the list and returns its index. A peak element is greater than or equal to its neighbors. For corner elements, only one neighbor is checked. The solution uses binary search to achieve O(log n) time complexity. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] < nums[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"def autocomplete(dictionary: list[str], prefix: str) -> list[str]: Return a list of dictionary words that start with the given prefix. :param dictionary: List of words (strings) to search in :param prefix: Prefix string to match the start of the words :return: List of words starting with the given prefix Example: >>> autocomplete([\\"apple\\", \\"banana\\", \\"apricot\\", \\"cherry\\", \\"apply\\"], \\"app\\") [\\"apple\\", \\"apply\\"] >>> autocomplete([\\"dog\\", \\"deer\\", \\"deal\\"], \\"de\\") [\\"deer\\", \\"deal\\"]","solution":"import re def autocomplete(dictionary: list[str], prefix: str) -> list[str]: Return a list of dictionary words that start with the given prefix. :param dictionary: List of words (strings) to search in :param prefix: Prefix string to match the start of the words :return: List of words starting with the given prefix :raises ValueError: If input dictionary or prefix has invalid format # Validate input dictionary if not all(isinstance(word, str) and re.match('^[a-z]+', word) for word in dictionary): raise ValueError(\\"Dictionary must be a list of non-empty lowercase alphabetic strings.\\") # Validate input prefix if not isinstance(prefix, str) or not re.match('^[a-z]+', prefix): raise ValueError(\\"Prefix must be a non-empty lowercase alphabetic string.\\") # Return list of words starting with the given prefix return [word for word in dictionary if word.startswith(prefix)]"},{"question":"def binary_arithmetic(operation: str, num1: str, num2: str, length: int) -> str: Perform a specified bitwise operation on two binary strings and return the result. Parameters: operation (str): The bitwise operation to perform ('AND', 'OR', 'XOR', 'NOT'). num1 (str): First binary string. num2 (str): Second binary string (ignored for 'NOT'). length (int): Desired length of the result binary string. Returns: str: Result of the bitwise operation as a binary string of specified length. Examples: >>> binary_arithmetic(\\"AND\\", \\"1101\\", \\"1011\\", 4) '1001' >>> binary_arithmetic(\\"OR\\", \\"1101\\", \\"1011\\", 5) '01111' >>> binary_arithmetic(\\"XOR\\", \\"1101\\", \\"1011\\", 4) '0110' >>> binary_arithmetic(\\"NOT\\", \\"1101\\", \\"\\", 4) '0010' >>> binary_arithmetic(\\"AND\\", \\"0011\\", \\"0101\\", 6) '000001' >>> binary_arithmetic(\\"OR\\", \\"0011\\", \\"0101\\", 3) '111' >>> binary_arithmetic(\\"XOR\\", \\"0011\\", \\"0101\\", 5) '00010' >>> binary_arithmetic(\\"NOT\\", \\"0011\\", \\"\\", 6) '111100'","solution":"def binary_arithmetic(operation: str, num1: str, num2: str, length: int) -> str: Perform specified bitwise operation on two binary strings and return the result as a binary string of specified length. Parameters: operation (str): Bitwise operation to be performed ('AND', 'OR', 'XOR', 'NOT'). num1 (str): First binary operand. num2 (str): Second binary operand (ignored for 'NOT'). length (int): Desired length of the resulting binary string. Returns: str: Result of the bitwise operation as a binary string of specified length. if operation == \\"NOT\\": result = ''.join('1' if bit == '0' else '0' for bit in num1) else: if operation == \\"AND\\": result = ''.join('1' if num1[i] == '1' and num2[i] == '1' else '0' for i in range(len(num1))) elif operation == \\"OR\\": result = ''.join('1' if num1[i] == '1' or num2[i] == '1' else '0' for i in range(len(num1))) elif operation == \\"XOR\\": result = ''.join('1' if num1[i] != num2[i] else '0' for i in range(len(num1))) else: raise ValueError(f\\"Unsupported operation: {operation}\\") # Adjust the result to the specified length, padded with zeros if necessary if len(result) < length: result = result.zfill(length) elif len(result) > length: result = result[-length:] return result"},{"question":"def longest_common_substring(s1: str, s2: str) -> str: Write a function that finds the longest common substring between two given strings. Parameters: s1 (str): The first input string. s2 (str): The second input string. Returns: str: The longest common substring. If there are multiple substrings with the maximum length, return any one of them. If no common substring exists, return an empty string. >>> longest_common_substring(\\"abcdef\\", \\"zabdf\\") 'ab' >>> longest_common_substring(\\"abc\\", \\"def\\") '' >>> longest_common_substring(\\"\\", \\"abc\\") '' >>> longest_common_substring(\\"abc\\", \\"\\") '' >>> longest_common_substring(\\"\\", \\"\\") '' >>> longest_common_substring(\\"a\\", \\"a\\") 'a' >>> longest_common_substring(\\"abcdef\\", \\"abcdef\\") 'abcdef' >>> longest_common_substring(\\"abcxyz\\", \\"xyzabc\\") in [\\"abc\\", \\"xyz\\"] True >>> longest_common_substring(\\"xyzabcd\\", \\"abcdxyz\\") 'abcd' >>> longest_common_substring(\\"abcABC\\", \\"ABCabc\\") in [\\"abc\\", \\"ABC\\"] True >>> longest_common_substring(\\"aaaaaa\\", \\"aaa\\") 'aaa'","solution":"def longest_common_substring(s1, s2): Function to find the longest common substring between two input strings s1 and s2. :param s1: The first input string. :param s2: The second input string. :return: The longest common substring between s1 and s2. m, n = len(s1), len(s2) if m == 0 or n == 0: return \\"\\" # Create a table to store lengths of longest common suffixes of substrings LCSuff = [[0] * (n + 1) for _ in range(m + 1)] # To store the length of the longest common substring length = 0 # To store the ending point of the longest common substring in s1 end_pos = 0 # Building the LCSuff table in a bottom-up fashion for i in range(1, m + 1): for j in range(1, n + 1): if s1[i-1] == s2[j-1]: LCSuff[i][j] = LCSuff[i-1][j-1] + 1 if LCSuff[i][j] > length: length = LCSuff[i][j] end_pos = i - 1 else: LCSuff[i][j] = 0 # No common substring found if length == 0: return \\"\\" # The longest common substring is from end_pos - length + 1 to end_pos in s1 return s1[end_pos - length + 1: end_pos + 1]"},{"question":"from collections import deque from typing import Dict, List def reachable_nodes(graph: Dict[int, List[int]], start: int) -> int: Returns the number of nodes reachable from the start node using BFS. :param graph: Dictionary representation of the graph. :param start: Starting node for BFS. Example Usage: >>> graph = { >>> 0: [1, 2], >>> 1: [0, 3, 4], >>> 2: [0], >>> 3: [1], >>> 4: [1] >>> } >>> reachable_nodes(graph, 0) 5 >>> graph = { >>> 0: [1], >>> 1: [0, 2], >>> 2: [1] >>> } >>> reachable_nodes(graph, 1) 3","solution":"from collections import deque from typing import Dict, List def reachable_nodes(graph: Dict[int, List[int]], start: int) -> int: Returns the number of nodes reachable from the start node using BFS. :param graph: Dictionary representation of the graph. :param start: Starting node for BFS. :return: Number of reachable nodes. if start not in graph: return 0 visited = set() queue = deque([start]) reachable_count = 0 while queue: node = queue.popleft() if node not in visited: visited.add(node) reachable_count += 1 for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return reachable_count"},{"question":"def unique_paths_obstacles(grid: list) -> int: Returns the number of unique paths from the top-left to the bottom-right of the grid, avoiding obstacles denoted by 1. >>> unique_paths_obstacles([[0,0,0],[0,1,0],[0,0,0]]) 2 >>> unique_paths_obstacles([[0,1],[0,0]]) 1 pass def test_unique_paths_obstacles(): assert unique_paths_obstacles([[0,0,0],[0,1,0],[0,0,0]]) == 2 assert unique_paths_obstacles([[0,1],[0,0]]) == 1 assert unique_paths_obstacles([[0,0,0],[0,0,0],[0,0,0]]) == 6 assert unique_paths_obstacles([[0,1,0],[0,1,0],[0,0,0]]) == 1 assert unique_paths_obstacles([[0]]) == 1 assert unique_paths_obstacles([[0,0],[0,1]]) == 0 assert unique_paths_obstacles([[0,1,0],[1,0,0],[0,0,0]]) == 0 assert unique_paths_obstacles([[0,0],[1,0]]) == 1 import pytest if __name__ == \\"__main__\\": pytest.main()","solution":"def unique_paths_obstacles(grid): Returns the number of unique paths from the top-left to the bottom-right of the grid, avoiding obstacles denoted by 1. m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Initialize first column for i in range(1, m): dp[i][0] = dp[i-1][0] if grid[i][0] == 0 else 0 # Initialize first row for j in range(1, n): dp[0][j] = dp[0][j-1] if grid[0][j] == 0 else 0 # Fill the DP table for i in range(1, m): for j in range(1, n): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] else: dp[i][j] = 0 return dp[-1][-1]"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert_rec(self.root, key) def _insert_rec(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert_rec(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert_rec(node.right, key) def kth_smallest(self, k): Find the k-th smallest element in the Binary Search Tree. >>> bst = BinarySearchTree() >>> bst.insert(5) >>> bst.insert(3) >>> bst.insert(7) >>> bst.insert(2) >>> bst.insert(4) >>> bst.insert(6) >>> bst.insert(8) >>> bst.kth_smallest(3) 4 >>> bst.kth_smallest(0) ValueError: k is out of bounds >>> bst.kth_smallest(9) ValueError: k is out of bounds","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert_rec(self.root, key) def _insert_rec(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert_rec(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert_rec(node.right, key) def kth_smallest(self, k): # Perform in-order traversal and count the nodes def inorder(node): if node is None: return [] return inorder(node.left) + [node.val] + inorder(node.right) elements = inorder(self.root) if k <= 0 or k > len(elements): raise ValueError(\\"k is out of bounds\\") return elements[k-1]"},{"question":"class Queue: Queue implementation using two stacks. Methods: __init__(self) -> None: Initialize the queue. enqueue(self, data: int) -> None: Add an integer to the end of the queue. dequeue(self) -> int: Remove and return the front element of the queue. front(self) -> int: Return the front element of the queue without removing it. is_empty(self) -> bool: Check if the queue is empty. Example: >>> queue = Queue() >>> queue.is_empty() True >>> queue.enqueue(1) >>> queue.is_empty() False >>> queue.enqueue(2) >>> queue.enqueue(3) >>> queue.front() 1 >>> queue.dequeue() 1 >>> queue.dequeue() 2 >>> queue.dequeue() 3 >>> queue.is_empty() True def __init__(self): ... def enqueue(self, data: int) -> None: ... def dequeue(self) -> int: ... def front(self) -> int: ... def is_empty(self) -> bool: ...","solution":"class Queue: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, data): self.stack1.append(data) def dequeue(self): if self.is_empty(): raise IndexError(\\"Dequeue from an empty queue\\") if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() def front(self): if self.is_empty(): raise IndexError(\\"Front from an empty queue\\") if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2[-1] def is_empty(self): return not (self.stack1 or self.stack2)"},{"question":"def levenshtein_distance(s1: str, s2: str) -> int: Computes the Levenshtein distance between two strings s1 and s2. Arguments: s1 -- first string s2 -- second string Returns: The Levenshtein distance between the two strings. >>> levenshtein_distance(\\"kitten\\", \\"sitting\\") # Should output 3 >>> levenshtein_distance(\\"flaw\\", \\"lawn\\") # Should output 2 pass # Unit tests def test_levenshtein_distance(): def test_equal_strings(): assert levenshtein_distance(\\"abc\\", \\"abc\\") == 0 def test_completely_different_strings(): assert levenshtein_distance(\\"abc\\", \\"xyz\\") == 3 def test_one_insert(): assert levenshtein_distance(\\"abc\\", \\"abxc\\") == 1 def test_one_delete(): assert levenshtein_distance(\\"abc\\", \\"ac\\") == 1 def test_one_substitute(): assert levenshtein_distance(\\"abc\\", \\"abd\\") == 1 def test_example_case_1(): assert levenshtein_distance(\\"kitten\\", \\"sitting\\") == 3 def test_example_case_2(): assert levenshtein_distance(\\"flaw\\", \\"lawn\\") == 2 def test_different_lengths(): assert levenshtein_distance(\\"a\\", \\"ab\\") == 1 assert levenshtein_distance(\\"ab\\", \\"a\\") == 1 def test_single_character_strings(): assert levenshtein_distance(\\"a\\", \\"b\\") == 1 def test_mixed_operations(): assert levenshtein_distance(\\"abcdef\\", \\"azced\\") == 3 # Running the tests test_equal_strings() test_completely_different_strings() test_one_insert() test_one_delete() test_one_substitute() test_example_case_1() test_example_case_2() test_different_lengths() test_single_character_strings() test_mixed_operations()","solution":"def levenshtein_distance(s1: str, s2: str) -> int: Computes the Levenshtein distance between two strings s1 and s2. Arguments: s1 -- first string s2 -- second string Returns: The Levenshtein distance between the two strings. n, m = len(s1), len(s2) # Create a distance matrix and initialize it dp = [[0] * (m + 1) for _ in range(n + 1)] # Initializing the distance of empty strings to prefix deletions for i in range(n + 1): dp[i][0] = i for j in range(m + 1): dp[0][j] = j # Fill the distance matrix for i in range(1, n + 1): for j in range(1, m + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1] # Substitution ) # The answer is the edit distance between the two full strings return dp[n][m]"},{"question":"import math def smallest_multiple(limit: int) -> int: Find the smallest positive integer that is evenly divisible by all of the numbers from 1 to a given limit. >>> smallest_multiple(10) 2520 >>> smallest_multiple(15) 360360 >>> smallest_multiple(20) 232792560","solution":"import math def smallest_multiple(limit: int) -> int: Returns the smallest positive integer that is evenly divisible by all of the numbers from 1 to limit. def lcm(a, b): return a * b // math.gcd(a, b) least_common_multiple = 1 for i in range(1, limit + 1): least_common_multiple = lcm(least_common_multiple, i) return least_common_multiple"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def range_sum_BST(root: TreeNode, low: int, high: int) -> int: Compute the sum of all the node values in the BST that lie within the inclusive range [low, high]. >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(15) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(7) >>> root.right.right = TreeNode(18) >>> range_sum_BST(root, 7, 15) 32 pass import pytest def test_range_sum_BST_full_range(): root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(3) root.left.right = TreeNode(7) root.right.right = TreeNode(18) assert range_sum_BST(root, 3, 18) == 58 # Sum of all nodes def test_range_sum_BST_partial_range(): root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(3) root.left.right = TreeNode(7) root.right.right = TreeNode(18) assert range_sum_BST(root, 7, 15) == 32 # Sum of nodes 7, 10, and 15 def test_range_sum_BST_single_node(): root = TreeNode(10) assert range_sum_BST(root, 10, 10) == 10 def test_range_sum_BST_no_matches(): root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(3) root.left.right = TreeNode(7) root.right.right = TreeNode(18) assert range_sum_BST(root, 20, 25) == 0 # No nodes in the range def test_range_sum_BST_only_left_subtree(): root = TreeNode(10) root.left = TreeNode(5) root.left.left = TreeNode(3) root.left.right = TreeNode(7) assert range_sum_BST(root, 3, 7) == 15 # Sum of nodes 3, 5, and 7 def test_range_sum_BST_only_right_subtree(): root = TreeNode(10) root.right = TreeNode(15) root.right.right = TreeNode(18) assert range_sum_BST(root, 15, 18) == 33 # Sum of nodes 15 and 18","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def range_sum_BST(root: TreeNode, low: int, high: int) -> int: if not root: return 0 total_sum = 0 if low <= root.val <= high: total_sum += root.val if root.val > low: total_sum += range_sum_BST(root.left, low, high) if root.val < high: total_sum += range_sum_BST(root.right, low, high) return total_sum"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotate the given NxN matrix by 90 degrees clockwise. >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_matrix([ ... [5, 1, 9, 11], ... [2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ]) [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] pass","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotate the given NxN matrix by 90 degrees clockwise. n = len(matrix) rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated"},{"question":"import bisect class MedianStack: Data structure that simulates a stack with an additional capability to return the median of all elements. def __init__(self): Initializes an empty stack. pass def push(self, val: int): Pushes an integer val onto the stack. pass def pop(self) -> int: Removes the integer on the top of the stack and returns it. If the stack is empty, returns None. pass def find_median(self) -> float: Returns the median of the current elements in the stack. If the stack is empty, returns None. pass def test_median_stack_operations(): s = MedianStack() assert s.find_median() == None # Stack is empty s.push(3) assert s.find_median() == 3.0 # Median of [3] s.push(1) assert s.find_median() == 2.0 # Median of [3, 1] s.push(4) assert s.find_median() == 3.0 # Median of [3, 1, 4] s.pop() assert s.find_median() == 2.0 # Median of [3, 1] s.push(5) assert s.find_median() == 3.0 # Median of [3, 1, 5] s.push(6) assert s.find_median() == 4.0 # Median of [3, 1, 5, 6] s.pop() assert s.find_median() == 3.0 # Median of [3, 1, 5] def test_median_stack_edge_cases(): s = MedianStack() assert s.pop() == None # Popping from empty stack assert s.find_median() == None # Median of empty stack s.push(-5) assert s.find_median() == -5.0 # Median of [-5] s.push(-5) assert s.find_median() == -5.0 # Median of [-5, -5] s.pop() assert s.find_median() == -5.0 # Median of [-5] def test_median_stack_large_inputs(): s = MedianStack() nums = list(range(1, 100001)) for num in nums: s.push(num) assert s.find_median() == 50000.5 # Median of range [1, 2, ..., 100000] for _ in range(50000): s.pop() assert s.find_median() == 25000.5 # Median of range [1, 2, ..., 50000] for _ in range(25000): s.pop() assert s.find_median() == 12500.5 # Median of range [1, 2, ..., 25000] s.push(-1) assert s.find_median() == 12500.0 # Median of range [1, 2, ..., 24999, -1] s.pop() assert s.find_median() == 12500.5 # Median of range [1, 2, ..., 25000]","solution":"import bisect class MedianStack: def __init__(self): Initializes an empty stack and an empty list to store elements. self.stack = [] self.sorted_elements = [] def push(self, val: int): Pushes an integer val onto the stack and maintains the sorted list. self.stack.append(val) bisect.insort(self.sorted_elements, val) def pop(self) -> int: Removes the integer on the top of the stack and returns it. If the stack is empty, returns None. if not self.stack: return None val = self.stack.pop() index = bisect.bisect_left(self.sorted_elements, val) del self.sorted_elements[index] return val def find_median(self) -> float: Returns the median of the current elements in the stack. If the stack is empty, returns None. n = len(self.sorted_elements) if n == 0: return None if n % 2 == 1: return float(self.sorted_elements[n // 2]) else: return (self.sorted_elements[n // 2 - 1] + self.sorted_elements[n // 2]) / 2.0"},{"question":"from collections import deque class MovingAverage: def __init__(self, size: int): Initialize your data structure here. Args: size (int): The size of the window for which the moving average will be calculated. ... def next(self, val: int) -> float: Add the next value and return the moving average. Args: val (int): The next value in the data stream. Returns: float: The moving average of all integers in the sliding window. >>> ma = MovingAverage(3) >>> ma.next(1) 1.0 >>> ma.next(10) 5.5 >>> ma.next(3) 4.666666666666667 >>> ma.next(5) 6.0 ...","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): self.size = size self.queue = deque() self.current_sum = 0 def next(self, val: int) -> float: if len(self.queue) == self.size: self.current_sum -= self.queue.popleft() self.queue.append(val) self.current_sum += val return self.current_sum / len(self.queue)"},{"question":"def reorder_for_max_sum(arr: List[int]) -> List[int]: Reorders the elements of the array 'arr' to maximize the sum of adjacent differences. >>> reorder_for_max_sum([1, 3, 2, 4]) [1, 4, 2, 3] >>> reorder_for_max_sum([10, 12, 15, 20, 35]) [10, 35, 12, 20, 15] >>> reorder_for_max_sum([3, 5, 2, 1]) [1, 5, 2, 3] >>> reorder_for_max_sum([100, 300, 200, 400]) [100, 400, 200, 300] >>> reorder_for_max_sum([1, 2, 3, 4, 5]) [1, 5, 2, 4, 3]","solution":"def reorder_for_max_sum(arr): Reorders the elements of the array \`arr\` to maximize the sum of adjacent differences. arr.sort() left, right = 0, len(arr) - 1 result = [] while left <= right: if left == right: result.append(arr[left]) else: result.append(arr[left]) result.append(arr[right]) left += 1 right -= 1 return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root: TreeNode, target_sum: int) -> bool: Determine if the binary tree has a root-to-leaf path with the given sum. >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.right.right = TreeNode(1) >>> has_path_sum(root, 22) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> has_path_sum(root, 5) False >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.right.right = TreeNode(7) >>> has_path_sum(root, 11) True >>> root = TreeNode(5) >>> has_path_sum(root, 5) True >>> root = TreeNode(5) >>> has_path_sum(root, 1) False >>> has_path_sum(None, 0) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root: TreeNode, target_sum: int) -> bool: if not root: return False target_sum -= root.val if not root.left and not root.right: # if it's a leaf return target_sum == 0 return has_path_sum(root.left, target_sum) or has_path_sum(root.right, target_sum)"},{"question":"from typing import List def sort_unique_integers(numbers: List[int]) -> List[int]: This function accepts a list of integers, removes duplicates, sorts it, and returns the sorted list of unique integers. >>> sort_unique_integers([4, 2, 7, 3, 2, 4]) [2, 3, 4, 7] >>> sort_unique_integers([1, -1, 2, -2, 3, -3, 1]) [-3, -2, -1, 1, 2, 3] >>> sort_unique_integers([]) [] pass def test_sort_unique_integers_with_duplicates(): assert sort_unique_integers([4, 2, 7, 3, 2, 4]) == [2, 3, 4, 7] def test_sort_unique_integers_with_negative_and_positive(): assert sort_unique_integers([1, -1, 2, -2, 3, -3, 1]) == [-3, -2, -1, 1, 2, 3] def test_sort_unique_integers_with_empty_list(): assert sort_unique_integers([]) == [] def test_sort_unique_integers_with_large_integers(): assert sort_unique_integers([100000, -100000, 50000, -50000]) == [-100000, -50000, 50000, 100000] def test_sort_unique_integers_with_no_duplicates(): assert sort_unique_integers([3, 1, 2, 4]) == [1, 2, 3, 4] def test_sort_unique_integers_with_all_identical_elements(): assert sort_unique_integers([5, 5, 5, 5, 5]) == [5] def test_sort_unique_integers_with_one_element(): assert sort_unique_integers([42]) == [42]","solution":"from typing import List def sort_unique_integers(numbers: List[int]) -> List[int]: This function accepts a list of integers, removes duplicates, sorts it, and returns the sorted list of unique integers. # Use a set to remove duplicates, then convert it back to a list and sort it return sorted(set(numbers))"},{"question":"from dataclasses import dataclass from typing import Union, Optional @dataclass class Node: data: int next_node: Optional['Node'] = None def insert_node(head: Optional[Node], data: int) -> Node: new_node = Node(data) if head is None: return new_node temp_node = head while temp_node.next_node: temp_node = temp_node.next_node temp_node.next_node = new_node return head def remove_elements(head: Optional[Node], value: int) -> Optional[Node]: Remove all elements from a linked list that have the specified value. >>> head = insert_node(None, 1) >>> head = insert_node(head, 2) >>> head = insert_node(head, 6) >>> head = insert_node(head, 3) >>> head = insert_node(head, 4) >>> head = insert_node(head, 5) >>> head = insert_node(head, 6) >>> new_head = remove_elements(head, value=6) >>> print_linked_list(new_head) 1->2->3->4->5 >>> new_head = remove_elements(None, value=1) Traceback (most recent call last): ... ValueError: The linked list is empty. >>> head = insert_node(None, 6) >>> new_head = remove_elements(head, value=6) >>> print(new_head) None pass def print_linked_list(head: Optional[Node]) -> None: if head is None: print(\\"None\\") return while head.next_node is not None: print(head.data, end=\\"->\\") head = head.next_node print(head.data)","solution":"from dataclasses import dataclass from typing import Union, Optional @dataclass class Node: data: int next_node: Optional['Node'] = None def insert_node(head: Optional[Node], data: int) -> Node: new_node = Node(data) if head is None: return new_node temp_node = head while temp_node.next_node: temp_node = temp_node.next_node temp_node.next_node = new_node return head def remove_elements(head: Optional[Node], value: int) -> Optional[Node]: dummy_head = Node(0) dummy_head.next_node = head current = dummy_head while current.next_node: if current.next_node.data == value: current.next_node = current.next_node.next_node else: current = current.next_node return dummy_head.next_node def print_linked_list(head: Optional[Node]) -> None: if head is None: print(\\"None\\") return while head.next_node is not None: print(head.data, end=\\"->\\") head = head.next_node print(head.data)"},{"question":"def is_leap_year(year: int) -> bool: Check if a year is a leap year. >>> is_leap_year(2020) True >>> is_leap_year(2019) False >>> is_leap_year(2000) True >>> is_leap_year(1900) False pass def days_in_month(month: int, year: int) -> int: Return the number of days in a given month of a particular year. >>> days_in_month(1, 2020) 31 >>> days_in_month(2, 2020) 29 >>> days_in_month(2, 2021) 28 >>> days_in_month(4, 2021) 30 pass def days_in_year_to_date(day: int, month: int, year: int) -> int: Calculate the number of days from the start of the year to a given date. >>> days_in_year_to_date(1, 1, 2020) 1 >>> days_in_year_to_date(31, 12, 2020) 366 >>> days_in_year_to_date(15, 3, 2021) 74 >>> days_in_year_to_date(28, 2, 2021) 59 pass def days_between_years(year1: int, year2: int) -> int: Calculate the number of days between two years, including leap years. >>> days_between_years(2020, 2021) 366 >>> days_between_years(2019, 2022) 1096 >>> days_between_years(2001, 2003) 730 pass def days_difference(date1: tuple, date2: tuple) -> int: Calculate the absolute difference in days between two dates. Each date is represented as a tuple (day, month, year). >>> days_difference((1, 1, 2023), (2, 1, 2023)) 1 >>> days_difference((1, 2, 2023), (1, 1, 2023)) 31 >>> days_difference((28, 2, 2020), (1, 3, 2020)) 2 >>> days_difference((1, 1, 1901), (1, 1, 2001)) 36525 >>> days_difference((1, 3, 2023), (1, 3, 2021)) 730 pass","solution":"def is_leap_year(year): Check if a year is a leap year. if year % 4 == 0: if year % 100 == 0: if year % 400 == 0: return True else: return False return True return False def days_in_month(month, year): Return the number of days in a given month of a particular year. if month == 2: if is_leap_year(year): return 29 else: return 28 if month in (4, 6, 9, 11): return 30 return 31 def days_in_year_to_date(day, month, year): Calculate the number of days from the start of the year to a given date. days = 0 for m in range(1, month): days += days_in_month(m, year) days += day return days def days_between_years(year1, year2): Calculate the number of days between two years, including leap years. days = 0 for year in range(year1, year2): if is_leap_year(year): days += 366 else: days += 365 return days def days_difference(date1, date2): Calculate the absolute difference in days between two dates. Each date is represented as a tuple (day, month, year). day1, month1, year1 = date1 day2, month2, year2 = date2 if year1 == year2: # When both dates are in the same year days1 = days_in_year_to_date(day1, month1, year1) days2 = days_in_year_to_date(day2, month2, year2) return abs(days2 - days1) else: # When dates are in different years if year1 > year2: # Swap dates so date1 is always the earlier date date1, date2 = date2, date1 day1, month1, year1 = date1 day2, month2, year2 = date2 # Days remaining in the first year from date1 remaining_days_year1 = (365 + int(is_leap_year(year1))) - days_in_year_to_date(day1, month1, year1) # Days passed in the last year to the date2 days_year2_to_date2 = days_in_year_to_date(day2, month2, year2) # Days in the years in between intermediate_days = days_between_years(year1 + 1, year2) total_days = remaining_days_year1 + days_year2_to_date2 + intermediate_days return total_days"},{"question":"def is_valid_compression_pair(char1: str, char2: str) -> bool: Determines if two characters form a valid compression pair. >>> is_valid_compression_pair('a', '1') True >>> is_valid_compression_pair('B', '4') True >>> is_valid_compression_pair('z', '#') False >>> is_valid_compression_pair('3', 'y') True >>> is_valid_compression_pair('!', '8') False","solution":"def is_valid_compression_pair(char1, char2): Determines if two characters form a valid compression pair. A valid compression pair consists of one alphabetic character and one numeric character (0-9). if (char1.isalpha() and char2.isdigit()) or (char1.isdigit() and char2.isalpha()): return True return False"},{"question":"def find_repeating_pattern(s: str, k: int) -> str: Implement a function that checks if a string can be formed by repeating a substring for a given number of times. If it can, return the smallest such substring; otherwise, return an empty string. >>> find_repeating_pattern(\\"ababab\\", 3) \\"ab\\" >>> find_repeating_pattern(\\"abcd\\", 2) \\"\\" >>> find_repeating_pattern(\\"aaaa\\", 4) \\"a\\" >>> find_repeating_pattern(\\"xyzxyzxyz\\", 3) \\"xyz\\"","solution":"def find_repeating_pattern(s: str, k: int) -> str: if len(s) % k != 0: return \\"\\" # The length of the potential repeating substring repeat_len = len(s) // k # Candidate substring candidate = s[:repeat_len] # Check if repeating the candidate k times equals s if candidate * k == s: return candidate else: return \\"\\""},{"question":"import math def cylinder_metrics(radius: float, height: float, calc_volume: bool) -> float: Calculate the cylinder volume or surface area based on the calc_volume flag. Parameters: - radius: The radius of the base of the cylinder, must be a positive float. - height: The height of the cylinder, must be a positive float. - calc_volume: A boolean flag. If True, calculate the volume, otherwise calculate the surface area. Returns: - A float representing either the volume or the surface area, rounded to two decimal places. Raises: - ValueError: If radius or height is non-positive. >>> cylinder_metrics(3, 5, True) 141.37 >>> cylinder_metrics(3, 5, False) 150.8","solution":"import math def cylinder_metrics(radius: float, height: float, calc_volume: bool) -> float: Calculate the cylinder volume or surface area based on the calc_volume flag. Parameters: - radius: The radius of the base of the cylinder, must be a positive float. - height: The height of the cylinder, must be a positive float. - calc_volume: A boolean flag. If True, calculate the volume, otherwise calculate the surface area. Returns: - A float representing either the volume or the surface area, rounded to two decimal places. Raises: - ValueError: If radius or height is non-positive. if radius <= 0 or height <= 0: raise ValueError(\\"Radius and height must be positive numbers.\\") if calc_volume: # Volume of the cylinder volume = math.pi * radius**2 * height return round(volume, 2) else: # Surface area of the cylinder surface_area = 2 * math.pi * radius * (radius + height) return round(surface_area, 2)"},{"question":"from typing import List, Tuple def is_k_in_intervals(intervals: List[Tuple[int, int]], k: int) -> bool: Determines if the given integer k lies within any of the intervals. Parameters: - intervals (List[Tuple[int, int]]): A list of tuples where each tuple denotes an interval (start, end) - k (int): The integer to check for in the intervals. Returns: - bool: True if k is within any of the intervals, False otherwise. >>> is_k_in_intervals([(1, 5), (10, 20), (30, 40)], 3) True >>> is_k_in_intervals([(1, 5), (10, 20), (30, 40)], 6) False >>> is_k_in_intervals([(1, 5), (10, 20), (30, 40)], 10) True >>> is_k_in_intervals([(1, 5), (10, 20), (30, 40)], -1) False pass","solution":"from typing import List, Tuple def is_k_in_intervals(intervals: List[Tuple[int, int]], k: int) -> bool: Determines if the given integer k lies within any of the intervals. Parameters: - intervals (List[Tuple[int, int]]): A list of tuples where each tuple denotes an interval (start, end) - k (int): The integer to check for in the intervals. Returns: - bool: True if k is within any of the intervals, False otherwise. for (start, end) in intervals: if start <= k <= end: return True return False"},{"question":"def find_shortest_path(n: int, edges: list[tuple[int, int, int]], start: int, end: int) -> str or tuple[int, list[int]]: Find the shortest path in a weighted, directed graph using Bellman-Ford Algorithm. Detects negative weight cycles. Args: n: An integer representing the number of nodes (0-indexed). edges: A list of tuples representing the edges in the graph, where each tuple contains three integers (u, v, w) describing an edge from node u to node v with weight w. start: An integer representing the starting node. end: An integer representing the destination node. Returns: If there's a negative weight cycle, returns the string \\"Negative weight cycle detected\\". Otherwise, returns a tuple containing the length of the shortest path and the path as a list of nodes. Examples: >>> find_shortest_path(5, [(0, 1, 5), (1, 2, 2), (2, 3, -1), (3, 4, 3)], 0, 4) (9, [0, 1, 2, 3, 4]) >>> find_shortest_path(3, [(0, 1, 1), (1, 2, 3), (2, 0, -6)], 0, 2) \\"Negative weight cycle detected\\" >>> find_shortest_path(4, [(0, 1, 4), (0, 2, 5), (1, 2, 1)], 0, 2) (5, [0, 2]) pass from solution import find_shortest_path def test_no_negative_cycle(): assert find_shortest_path( 5, [(0, 1, 5), (1, 2, 2), (2, 3, -1), (3, 4, 3)], 0, 4 ) == (9, [0, 1, 2, 3, 4]) def test_negative_cycle_detected(): assert find_shortest_path( 3, [(0, 1, 1), (1, 2, 3), (2, 0, -6)], 0, 2 ) == \\"Negative weight cycle detected\\" def test_direct_path(): assert find_shortest_path( 4, [(0, 1, 4), (0, 2, 5), (1, 2, 1)], 0, 2 ) == (5, [0, 2]) def test_no_path_available(): assert find_shortest_path( 4, [(0, 1, 4), (1, 2, 5)], 0, 3 ) == (float('inf'), []) def test_single_node_graph(): assert find_shortest_path( 1, [], 0, 0 ) == (0, [0]) def test_two_nodes_no_path(): assert find_shortest_path( 2, [], 0, 1 ) == (float('inf'), [])","solution":"def find_shortest_path(n: int, edges: list[tuple[int, int, int]], start: int, end: int) -> str or tuple[int, list[int]]: # Initialize distances from start to all other vertices as infinity and distance to itself as 0 dist = [float('inf')] * n dist[start] = 0 # Initialize the predecessor list to store the path predecessor = [-1] * n # Relax all edges |V| - 1 times for _ in range(n - 1): for u, v, w in edges: if dist[u] != float('inf') and dist[u] + w < dist[v]: dist[v] = dist[u] + w predecessor[v] = u # Check for negative-weight cycles for u, v, w in edges: if dist[u] != float('inf') and dist[u] + w < dist[v]: return \\"Negative weight cycle detected\\" # Reconstruct the path if dist[end] == float('inf'): return (float('inf'), []) path = [] crawl = end while crawl != -1: path.append(crawl) crawl = predecessor[crawl] path.reverse() return (dist[end], path)"},{"question":"from typing import List def binary_search(arr: List[int], target: int) -> int: Perform binary search on a sorted array. >>> binary_search([1, 2, 4, 5, 6, 8, 9], 5) 3 >>> binary_search([1, 2, 4, 5, 6, 8, 9], 7) -1","solution":"from typing import List def binary_search(arr: List[int], target: int) -> int: left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def find_articulation_points(graph: dict) -> set: Identifies the articulation points in an undirected graph. Parameters: graph (dict): A dictionary representing an undirected graph where each key is a vertex and the value is a list of adjacent vertices. Returns: set of integers representing the articulation points in the graph. Example: >>> find_articulation_points({ ... 0: [1, 2, 3], ... 1: [0, 2], ... 2: [0, 1, 3, 4], ... 3: [0, 2], ... 4: [2, 5], ... 5: [4] ... }) == {2, 4} pass from solution import find_articulation_points def test_empty_graph(): assert find_articulation_points({}) == set() def test_single_node(): assert find_articulation_points({0: []}) == set() def test_two_connected_nodes(): graph = {0: [1], 1: [0]} assert find_articulation_points(graph) == set() def test_three_connected_nodes(): graph = {0: [1], 1: [0, 2], 2: [1]} assert find_articulation_points(graph) == {1} def test_square_with_diagonal(): graph = { 0: [1, 2], 1: [0, 2, 3], 2: [0, 1, 3], 3: [1, 2] } assert find_articulation_points(graph) == set() def test_articulation_points(): graph = { 0: [1, 2, 3], 1: [0, 2], 2: [0, 1, 3, 4], 3: [0, 2], 4: [2, 5], 5: [4] } assert find_articulation_points(graph) == {2, 4} def test_complex_graph(): graph = { 0: [1, 2], 1: [0, 2, 3], 2: [0, 1, 4], 3: [1, 4], 4: [2, 3, 5], 5: [4, 6, 7], 6: [5, 7], 7: [5, 6] } assert find_articulation_points(graph) == {4, 5}","solution":"def find_articulation_points(graph: dict) -> set: Function to find the articulation points in an undirected graph. Parameters: graph (dict): A dictionary representing an undirected graph where each key is a vertex and the value is a list of adjacent vertices. Returns: set: A set of articulation points in the graph. if not graph: return set() def dfs(u, discovery_times, low, parent, time, visited, articulation_points): children = 0 visited[u] = True discovery_times[u] = low[u] = time[0] time[0] += 1 for v in graph[u]: if not visited[v]: parent[v] = u children += 1 dfs(v, discovery_times, low, parent, time, visited, articulation_points) # Check if the subtree rooted at v has a connection back to one of the ancestors of u low[u] = min(low[u], low[v]) # u is an articulation point in the following cases: # Case 1: u is the root of DFS tree and has 2 or more children if parent[u] is None and children > 1: articulation_points.add(u) # Case 2: u is not the root and low value of one of its children v is greater than discovery value of u if parent[u] is not None and low[v] >= discovery_times[u]: articulation_points.add(u) elif v != parent[u]: # Update low value of u for parent function calls low[u] = min(low[u], discovery_times[v]) visited = {u: False for u in graph} discovery_times = {u: float('inf') for u in graph} low = {u: float('inf') for u in graph} parent = {u: None for u in graph} articulation_points = set() # Initial time counter time = [0] # For handling the case when the graph is not connected for u in graph: if not visited[u]: dfs(u, discovery_times, low, parent, time, visited, articulation_points) return articulation_points"},{"question":"class CircularQueue: def __init__(self, capacity: int) -> None: Initialize the circular queue with a given capacity. pass def enqueue(self, value: int) -> bool: Add an element to the end of the queue. Return True if the operation is successful, and False if the queue is full. pass def dequeue(self) -> int: Remove and return the front element of the queue. Return -1 if the queue is empty. pass def is_full(self) -> bool: Return True if the queue is full, False otherwise. pass def is_empty(self) -> bool: Return True if the queue is empty, False otherwise. pass def size(self) -> int: Return the number of elements currently in the queue. pass def test_enqueue(): queue = CircularQueue(3) assert queue.enqueue(1) == True assert queue.enqueue(2) == True assert queue.enqueue(3) == True assert queue.enqueue(4) == False # Queue is full def test_dequeue(): queue = CircularQueue(3) queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) assert queue.dequeue() == 1 assert queue.dequeue() == 2 assert queue.dequeue() == 3 assert queue.dequeue() == -1 # Queue is empty def test_size(): queue = CircularQueue(3) assert queue.size() == 0 queue.enqueue(1) assert queue.size() == 1 queue.enqueue(2) assert queue.size() == 2 queue.enqueue(3) assert queue.size() == 3 queue.dequeue() assert queue.size() == 2 def test_is_full(): queue = CircularQueue(3) assert not queue.is_full() queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) assert queue.is_full() def test_is_empty(): queue = CircularQueue(3) assert queue.is_empty() queue.enqueue(1) assert not queue.is_empty() queue.dequeue() assert queue.is_empty()","solution":"class CircularQueue: def __init__(self, capacity: int) -> None: self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = 0 self.count = 0 def enqueue(self, value: int) -> bool: if self.is_full(): return False self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.count += 1 return True def dequeue(self) -> int: if self.is_empty(): return -1 value = self.queue[self.front] self.queue[self.front] = None # Optional: Clear the slot for clarity self.front = (self.front + 1) % self.capacity self.count -= 1 return value def is_full(self) -> bool: return self.count == self.capacity def is_empty(self) -> bool: return self.count == 0 def size(self) -> int: return self.count"},{"question":"def check_intersection(segment1, segment2): Determine if two line segments intersect. >>> check_intersection(((1, 1), (4, 4)), ((1, 4), (4, 1))) == True >>> check_intersection(((1, 1), (2, 2)), ((3, 3), (4, 4))) == False >>> check_intersection(((1, 1), (4, 4)), ((2, 2), (6, 6))) == True pass def test_segments_intersect(): segment1 = ((1, 1), (4, 4)) segment2 = ((1, 4), (4, 1)) assert check_intersection(segment1, segment2) == True def test_segments_do_not_intersect(): segment1 = ((1, 1), (2, 2)) segment2 = ((3, 3), (4, 4)) assert check_intersection(segment1, segment2) == False def test_segments_collinear_overlapping(): segment1 = ((1, 1), (4, 4)) segment2 = ((2, 2), (6, 6)) assert check_intersection(segment1, segment2) == True def test_segments_touching_at_endpoint(): segment1 = ((1, 1), (4, 4)) segment2 = ((4, 4), (5, 5)) assert check_intersection(segment1, segment2) == True def test_segments_zero_length(): segment1 = ((1, 1), (1, 1)) segment2 = ((2, 2), (3, 3)) assert check_intersection(segment1, segment2) == False def test_segments_zero_length_intersect(): segment1 = ((1, 1), (1, 1)) segment2 = ((0, 0), (2, 2)) assert check_intersection(segment1, segment2) == True def test_collinear_non_overlapping(): segment1 = ((1, 1), (2, 2)) segment2 = ((3, 3), (4, 4)) assert check_intersection(segment1, segment2) == False def test_t_shaped_intersection(): segment1 = ((2, 2), (2, 6)) segment2 = ((0, 4), (4, 4)) assert check_intersection(segment1, segment2) == True","solution":"def check_intersection(segment1, segment2): def orientation(p, q, r): Function to find the orientation of the ordered triplet (p, q, r). 0 -> p, q and r are collinear 1 -> Clockwise 2 -> Counterclockwise val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]) if val == 0: return 0 elif val > 0: return 1 else: return 2 def on_segment(p, q, r): Given three collinear points p, q, r, check if point q lies on segment pr. if min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and min(p[1], r[1]) <= q[1] <= max(p[1], r[1]): return True return False p1, q1 = segment1 p2, q2 = segment2 # Find the four orientations needed for the general and special cases o1 = orientation(p1, q1, p2) o2 = orientation(p1, q1, q2) o3 = orientation(p2, q2, p1) o4 = orientation(p2, q2, q1) # General case if o1 != o2 and o3 != o4: return True # Special cases # p1, q1 and p2 are collinear and p2 lies on segment p1q1 if o1 == 0 and on_segment(p1, p2, q1): return True # p1, q1 and q2 are collinear and q2 lies on segment p1q1 if o2 == 0 and on_segment(p1, q2, q1): return True # p2, q2 and p1 are collinear and p1 lies on segment p2q2 if o3 == 0 and on_segment(p2, p1, q2): return True # p2, q2 and q1 are collinear and q1 lies on segment p2q2 if o4 == 0 and on_segment(p2, q1, q2): return True # Otherwise, the segments do not intersect return False"},{"question":"from typing import List class SubarraySum: def __init__(self, arr: List[int], d: int): Initialize with an array of integers and subarray length. Args: arr (List[int]): The array of integers. d (int): The length of the subarray. self.arr = arr self.d = d def max_sum(self) -> int: Compute the maximum possible sum of any contiguous subarray with length d. Returns: int: The maximum sum of the contiguous subarray with length d. >>> arr = [1, -2, 3, 10, -4, 7, 2, -5] >>> d = 3 >>> s = SubarraySum(arr, d) >>> s.max_sum() 13 >>> arr = [5] >>> d = 1 >>> s = SubarraySum(arr, d) >>> s.max_sum() 5 >>> arr = [-10, -20, -30, -40, -50] >>> d = 2 >>> s = SubarraySum(arr, d) >>> s.max_sum() -30 >>> arr = [3, -1, 4, -1, 2, 1, -5, 4] >>> d = 4 >>> s = SubarraySum(arr, d) >>> s.max_sum() 6 >>> arr = [1, 2, 3, 4, 5] >>> d = 5 >>> s = SubarraySum(arr, d) >>> s.max_sum() 15 >>> arr = [-1, -2, -3, -4, -5] >>> d = 1 >>> s = SubarraySum(arr, d) >>> s.max_sum() -1 >>> arr = list(range(1, 101)) >>> d = 100 >>> s = SubarraySum(arr, d) >>> s.max_sum() 5050","solution":"from typing import List class SubarraySum: def __init__(self, arr: List[int], d: int): self.arr = arr self.d = d def max_sum(self) -> int: n = len(self.arr) if self.d > n: raise ValueError(\\"The value of d should not exceed the length of the array\\") max_sum = float('-inf') current_sum = 0 # Compute the sum of the first window of size d for i in range(self.d): current_sum += self.arr[i] max_sum = current_sum # Slide over the array for i in range(self.d, n): current_sum += self.arr[i] - self.arr[i - self.d] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def convert_date_format(date_str: str, current_format: str, target_format: str) -> str: Converts a date from one string format to another. >>> convert_date_format(\\"2023-10-25\\", \\"YYYY-MM-DD\\", \\"MM/DD/YYYY\\") '10/25/2023' >>> convert_date_format(\\"10/25/2023\\", \\"MM/DD/YYYY\\", \\"DD-MM-YYYY\\") '25-10-2023' >>> convert_date_format(\\"25-10-2023\\", \\"DD-MM-YYYY\\", \\"YYYY-MM-DD\\") '2023-10-25' >>> convert_date_format(\\"12/31/1999\\", \\"MM/DD/YYYY\\", \\"YYYY-MM-DD\\") '1999-12-31' >>> convert_date_format(\\"2021-04-05\\", \\"YYYY-MM-DD\\", \\"DD-MM-YYYY\\") '05-04-2021' >>> convert_date_format(\\"15-08-1947\\", \\"DD-MM-YYYY\\", \\"MM/DD/YYYY\\") '08/15/1947'","solution":"def convert_date_format(date_str: str, current_format: str, target_format: str) -> str: Converts a date from one string format to another. :param date_str: A string representing the date in the current_format. :param current_format: A string representing the current format of the date_str. :param target_format: A string representing the desired format for the output date string. :return: A string representing the date in the target_format. date_parts = {} if current_format == \\"YYYY-MM-DD\\": date_parts['year'], date_parts['month'], date_parts['day'] = date_str.split('-') elif current_format == \\"MM/DD/YYYY\\": date_parts['month'], date_parts['day'], date_parts['year'] = date_str.split('/') elif current_format == \\"DD-MM-YYYY\\": date_parts['day'], date_parts['month'], date_parts['year'] = date_str.split('-') if target_format == \\"YYYY-MM-DD\\": return f\\"{date_parts['year']}-{date_parts['month']}-{date_parts['day']}\\" elif target_format == \\"MM/DD/YYYY\\": return f\\"{date_parts['month']}/{date_parts['day']}/{date_parts['year']}\\" elif target_format == \\"DD-MM-YYYY\\": return f\\"{date_parts['day']}-{date_parts['month']}-{date_parts['year']}\\""},{"question":"from typing import NamedTuple, Tuple, List class FromTo(NamedTuple): from_factor: float to_factor: float DISTANCE_CONVERSION = { \\"meter\\": FromTo(1, 1), \\"kilometer\\": FromTo(1000, 0.001), \\"centimeter\\": FromTo(0.01, 100), \\"millimeter\\": FromTo(0.001, 1000), \\"micrometer\\": FromTo(1e-6, 1e6), \\"nanometer\\": FromTo(1e-9, 1e9), \\"mile\\": FromTo(1609.34, 0.000621371), \\"nautical mile\\": FromTo(1852, 0.000539957), } def distance_conversion(value: float, from_type: str, to_type: str) -> float: Convert distance from one unit to another. >>> distance_conversion(1, \\"mile\\", \\"meter\\") 1609.34 >>> distance_conversion(1, \\"nautical mile\\", \\"kilometer\\") 1.852 >>> distance_conversion(1000, \\"meter\\", \\"kilometer\\") 1 >>> distance_conversion(1, \\"kilometer\\", \\"meter\\") 1000 ... def unit_details(unit: str) -> str: Provides details about the given distance unit. >>> unit_details(\\"mile\\") \\"Mile: A unit of distance used in the United States and the United Kingdom.\\" >>> unit_details(\\"nautical mile\\") \\"Nautical Mile: A unit of distance used in marine and air navigation.\\" >>> unit_details(\\"meter\\") \\"Meter: The base unit of length in the International System of Units (SI).\\" ...","solution":"from typing import NamedTuple class FromTo(NamedTuple): from_factor: float to_factor: float DISTANCE_CONVERSION = { \\"meter\\": FromTo(1, 1), \\"kilometer\\": FromTo(1000, 0.001), \\"centimeter\\": FromTo(0.01, 100), \\"millimeter\\": FromTo(0.001, 1000), \\"micrometer\\": FromTo(1e-6, 1e6), \\"nanometer\\": FromTo(1e-9, 1e9), \\"mile\\": FromTo(1609.34, 0.000621371), \\"nautical mile\\": FromTo(1852, 0.000539957), } def distance_conversion(value: float, from_type: str, to_type: str) -> float: if from_type not in DISTANCE_CONVERSION: raise ValueError( f\\"Invalid 'from_type' value: {from_type!r}. Supported values are:n\\" + \\", \\".join(DISTANCE_CONVERSION) ) if to_type not in DISTANCE_CONVERSION: raise ValueError( f\\"Invalid 'to_type' value: {to_type!r}. Supported values are:n\\" + \\", \\".join(DISTANCE_CONVERSION) ) return ( value * DISTANCE_CONVERSION[from_type].from_factor / DISTANCE_CONVERSION[to_type].from_factor ) def unit_details(unit: str) -> str: details = { \\"meter\\": \\"Meter: The base unit of length in the International System of Units (SI).\\", \\"kilometer\\": \\"Kilometer: A unit of length equal to 1000 meters, commonly used to measure distances between geographical locations.\\", \\"centimeter\\": \\"Centimeter: A unit of length equal to one hundredth of a meter, commonly used in measurements of small objects.\\", \\"millimeter\\": \\"Millimeter: A unit of length equal to one thousandth of a meter, commonly used in engineering and manufacturing.\\", \\"micrometer\\": \\"Micrometer: A unit of length equal to one millionth of a meter, used in scientific measurements.\\", \\"nanometer\\": \\"Nanometer: A unit of length equal to one billionth of a meter, used in nanotechnology and biology.\\", \\"mile\\": \\"Mile: A unit of distance used in the United States and the United Kingdom.\\", \\"nautical mile\\": \\"Nautical Mile: A unit of distance used in marine and air navigation.\\", } if unit not in details: raise ValueError(f\\"Unsupported unit: {unit!r}. Supported units are:n\\" + ', '.join(details.keys())) return details[unit]"},{"question":"# Coding Completion Task Problem Statement Implement functions to summarize a given input string by counting the frequency of each unique word and filtering them based on a specified frequency threshold. Function Requirements and Constraints 1. **Function Signature** def word_count_summary(text: str) -> dict: def filter_words_by_frequency(word_dict: dict, threshold: int) -> dict: 2. **Parameters**: * \`text\` - a string consisting of any characters including alphabets, digits, punctuations, and special characters. Words are separated by spaces. * \`word_dict\` - a dictionary where keys are words and values are their counts. * \`threshold\` - an integer value to determine the minimum frequency a word must have to be included in the result. 3. **Return Values**: * For \`word_count_summary\`: A dictionary representing the frequency count of each unique word in the input text. Words are case-insensitive. * For \`filter_words_by_frequency\`: A dictionary containing words that occur at least \`threshold\` times, with their corresponding counts. Example Cases * \`word_count_summary(\\"This is a test. This test is only a test.\\")\` should return \`{\\"this\\": 2, \\"is\\": 2, \\"a\\": 2, \\"test\\": 3, \\"only\\": 1}\` * \`filter_words_by_frequency({\\"this\\": 2, \\"is\\": 2, \\"a\\": 2, \\"test\\": 3, \\"only\\": 1}, 2)\` should return \`{\\"this\\": 2, \\"is\\": 2, \\"a\\": 2, \\"test\\": 3}\` # Function Descriptions 1. **Function: \`word_count_summary(text: str) -> dict\`** - Parses the input text into words, normalizes them to lowercase, and counts the occurrences of each unique word. Returns a dictionary with words as keys and their counts as values. - Example: >>> word_count_summary(\\"This is a test. This test is only a test.\\") {\\"this\\": 2, \\"is\\": 2, \\"a\\": 2, \\"test\\": 3, \\"only\\": 1} 2. **Function: \`filter_words_by_frequency(word_dict: dict, threshold: int) -> dict\`** - Filters the input word dictionary to include only those words whose frequency is equal to or greater than the specified threshold. Returns a filtered dictionary. - Example: >>> filter_words_by_frequency({\\"this\\": 2, \\"is\\": 2, \\"a\\": 2, \\"test\\": 3, \\"only\\": 1}, 2) {\\"this\\": 2, \\"is\\": 2, \\"a\\": 2, \\"test\\": 3}","solution":"import re from collections import Counter def word_count_summary(text: str) -> dict: Parses the input text into words, normalizes them to lowercase, and counts the occurrences of each unique word. Returns a dictionary with words as keys and their counts as values. # Use regex to find all words (sequences of alphanumeric characters) words = re.findall(r'bw+b', text.lower()) return dict(Counter(words)) def filter_words_by_frequency(word_dict: dict, threshold: int) -> dict: Filters the input word dictionary to include only those words whose frequency is equal to or greater than the specified threshold. Returns a filtered dictionary. return {word: count for word, count in word_dict.items() if count >= threshold}"},{"question":"[Completion Task in Python] def classify_item(weight: float, length: float, width: float, height: float) -> str: Classifies an item as 'small', 'medium', 'large' or 'oversized' based on given weight and dimensions. Parameters: weight (float): The weight of the item in kilograms. length (float): The length of the item in centimeters. width (float): The width of the item in centimeters. height (float): The height of the item in centimeters. Returns: str: Classification of the item. # Calculate the total dimension sum total_dimension = length + width + height if weight <= 1 and total_dimension <= 60: return \\"small\\" elif weight <= 5 and total_dimension <= 150: return \\"medium\\" elif weight <= 20 and total_dimension <= 300: return \\"large\\" else: return \\"oversized\\"","solution":"def classify_item(weight: float, length: float, width: float, height: float) -> str: Classifies an item as 'small', 'medium', 'large' or 'oversized' based on given weight and dimensions. Parameters: weight (float): The weight of the item in kilograms. length (float): The length of the item in centimeters. width (float): The width of the item in centimeters. height (float): The height of the item in centimeters. Returns: str: Classification of the item. # Calculate the total dimension sum total_dimension = length + width + height if weight <= 1 and total_dimension <= 60: return \\"small\\" elif weight <= 5 and total_dimension <= 150: return \\"medium\\" elif weight <= 20 and total_dimension <= 300: return \\"large\\" else: return \\"oversized\\""},{"question":"def find_peak_visitors(events: list[tuple[int, int]]) -> int: Finds the peak number of people in the store at any given time. :param events: list of tuples where each tuple contains two integers (check_in, check_out) :return: an integer representing the peak number of people present in the store at any given time >>> find_peak_visitors([(1, 4), (2, 5), (9, 12), (5, 9), (5, 12)]) 3 >>> find_peak_visitors([(2, 3), (4, 5), (6, 7), (8, 9)]) 1 >>> find_peak_visitors([(1, 10), (2, 6), (5, 8)]) 3 def test_no_visitors(): assert find_peak_visitors([]) == 0 def test_single_visitor(): assert find_peak_visitors([(1, 2)]) == 1 def test_non_overlapping_visitors(): assert find_peak_visitors([(2, 3), (4, 5), (6, 7), (8, 9)]) == 1 def test_fully_overlapping_visitors(): assert find_peak_visitors([(1, 10), (1, 10), (1, 10)]) == 3 def test_partially_overlapping_visitors(): assert find_peak_visitors([(1, 4), (2, 5), (9, 12), (5, 9), (5, 12)]) == 3 assert find_peak_visitors([(1, 10), (2, 6), (5, 8)]) == 3 def test_edge_cases(): assert find_peak_visitors([(10**9-1, 10**9)]) == 1 assert find_peak_visitors([(1, 10**9)]) == 1 assert find_peak_visitors([(1, 2), (1, 2)]) == 2 assert find_peak_visitors([(1, 3), (2, 5), (4, 6)]) == 2","solution":"def find_peak_visitors(events): Finds the peak number of people in the store at any given time. :param events: list of tuples where each tuple contains two integers (check_in, check_out) :return: an integer representing the peak number of people present in the store at any given time times = [] # Collect both check-in and check-out times for event in events: check_in, check_out = event times.append((check_in, 'in')) times.append((check_out, 'out')) # Sort the times times.sort() current_visitors = 0 max_visitors = 0 # Traverse through the times for time, type in times: if type == 'in': current_visitors += 1 if current_visitors > max_visitors: max_visitors = current_visitors elif type == 'out': current_visitors -= 1 return max_visitors"},{"question":"from typing import List def matrix_diagonal_sum(matrix: List[List[int]]) -> int: Computes the sum of the diagonal elements of a square matrix. If the matrix is non-square, returns -1. Parameters: matrix (List[List[int]]): A 2D list of integers representing the matrix. Returns: int: The sum of the diagonal elements if the matrix is square, otherwise -1. Examples: >>> matrix_diagonal_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 15 >>> matrix_diagonal_sum([ ... [1, 2], ... [3, 4, 5], ... [6, 7, 8] ... ]) == -1","solution":"from typing import List def matrix_diagonal_sum(matrix: List[List[int]]) -> int: Computes the sum of the diagonal elements of a square matrix. Parameters: matrix (List[List[int]]): A 2D list of integers representing the matrix. Returns: int: The sum of the diagonal elements if the matrix is square, otherwise -1. n = len(matrix) for row in matrix: if len(row) != n: return -1 # The matrix is not square diagonal_sum = sum(matrix[i][i] for i in range(n)) return diagonal_sum"},{"question":"def next_largest_permutation(arr: List[int]) -> None: Rearranges the array into the lexicographically next greater permutation. If such an arrangement is not possible, it must rearrange it as the lowest possible order (sorted in ascending order). The replacement must be done in-place. >>> arr = [1, 2, 3] >>> next_largest_permutation(arr) >>> print(arr) [1, 3, 2] >>> arr = [3, 2, 1] >>> next_largest_permutation(arr) >>> print(arr) [1, 2, 3] >>> arr = [1, 1, 5] >>> next_largest_permutation(arr) >>> print(arr) [1, 5, 1]","solution":"from typing import List def next_largest_permutation(arr: List[int]) -> None: Ruarranges the array into the lexicographically next greater permutation. If such an arrangement is not possible, it must rearrange it as the lowest possible order (sorted in ascending order). The replacement must be done in-place. # Find the first element that is smaller than the one next to it, from the end of the list i = len(arr) - 2 while i >= 0 and arr[i] >= arr[i + 1]: i -= 1 if i >= 0: # Find the first element that is greater than arr[i] from the end of the list j = len(arr) - 1 while arr[j] <= arr[i]: j -= 1 # Swap the elements at i and j arr[i], arr[j] = arr[j], arr[i] # Reverse the elements from i+1 to the end of the list arr[i + 1:] = reversed(arr[i + 1:])"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head: ListNode | None) -> ListNode | None: Removes all duplicate values from a singly linked list. >>> head = ListNode(1, ListNode(1, ListNode(2, ListNode(3, ListNode(3))))) >>> modified_head = remove_duplicates(head) >>> linked_list_to_list(modified_head) [1, 2, 3] >>> head = ListNode(1, ListNode(2, ListNode(2, ListNode(2, ListNode(3))))) >>> modified_head = remove_duplicates(head) >>> linked_list_to_list(modified_head) [1, 2, 3] >>> head = None >>> modified_head = remove_duplicates(head) >>> linked_list_to_list(modified_head) [] >>> head = ListNode(1) >>> modified_head = remove_duplicates(head) >>> linked_list_to_list(modified_head) [1] >>> head = ListNode(1, ListNode(2, ListNode(3))) >>> modified_head = remove_duplicates(head) >>> linked_list_to_list(modified_head) [1, 2, 3] >>> head = ListNode(1, ListNode(1, ListNode(1, ListNode(1, ListNode(1))))) >>> modified_head = remove_duplicates(head) >>> linked_list_to_list(modified_head) [1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head: ListNode | None) -> ListNode | None: if not head: return head current = head seen = set() seen.add(current.val) while current and current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head"},{"question":"def min_chunks_required(files: List[int], chunk_size: int) -> int: Determines the minimum number of chunks required to store a list of files given a chunk size. Parameters: files (List[int]): A list of integers representing the size of each file in bytes. chunk_size (int): The size of each chunk in bytes. Returns: int: The total number of chunks required to store all files. Examples: >>> min_chunks_required([2000, 3000, 1500], 1000) 7 >>> min_chunks_required([1000, 1000, 1000], 1000) 3 >>> min_chunks_required([]) 0 >>> min_chunks_required([500, 600, 700], 1000) 3","solution":"from typing import List def min_chunks_required(files: List[int], chunk_size: int) -> int: Determines the minimum number of chunks required to store a list of files given a chunk size. Parameters: files (List[int]): A list of integers representing the size of each file in bytes. chunk_size (int): The size of each chunk in bytes. Returns: int: The total number of chunks required to store all files. total_chunks = 0 for file_size in files: total_chunks += (file_size + chunk_size - 1) // chunk_size return total_chunks"},{"question":"def min_resources(intervals: List[Tuple[int, int]]) -> int: Calculate the minimum number of resources required to handle all tasks without any overlap. Args: intervals (List[Tuple[int, int]]): A list of tuples, where each tuple represents the start and end times of a task. Returns: int: The minimum number of resources required. Examples: >>> min_resources([(1, 4), (2, 5), (9, 12), (5, 9), (5, 12)]) 3 >>> min_resources([(1, 3), (4, 6), (7, 9)]) 1 >>> min_resources([(1, 5), (2, 6), (3, 7)]) 3","solution":"def min_resources(intervals): Calculate the minimum number of resources required to handle all tasks without any overlap. Args: intervals (List[Tuple[int, int]]): A list of tuples, where each tuple represents the start and end times of a task. Returns: int: The minimum number of resources required. if not intervals: return 0 # Create a list of all events (start and end times) events = [] for start, end in intervals: events.append((start, 'start')) events.append((end, 'end')) # Sort events, breaking ties by considering 'start' before 'end' events.sort(key=lambda x: (x[0], x[1] == 'end')) max_overlap = 0 current_overlap = 0 # Process events for event in events: if event[1] == 'start': current_overlap += 1 max_overlap = max(max_overlap, current_overlap) else: current_overlap -= 1 return max_overlap"},{"question":"[Completion Task in Python] def longest_common_prefix(strs: List[str]) -> str: Write a function to find the longest common prefix among a list of strings. >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) \\"\\" if not strs: return \\"\\" prefix = strs[0] for s in strs[1:]: while not s.startswith(prefix): prefix = prefix[:-1] if not prefix: return \\"\\" return prefix","solution":"class Graph: def __init__(self, graph: dict[str, list[str]]): self.graph = graph def dfs(self, vertex: str, visited: set): visited.add(vertex) for neighbor in self.graph[vertex]: if neighbor not in visited: self.dfs(neighbor, visited) def count_connected_components(self) -> int: visited = set() count = 0 for vertex in self.graph: if vertex not in visited: self.dfs(vertex, visited) count += 1 return count"},{"question":"def generate_palindromic_substrings(s: str) -> list: Function to return all unique palindromic substrings. >>> generate_palindromic_substrings(\\"abccba\\") ['a', 'abccba', 'b', 'bccb', 'c', 'cc'] >>> generate_palindromic_substrings(\\"a\\") ['a'] >>> generate_palindromic_substrings(\\"abc\\") ['a', 'b', 'c'] >>> generate_palindromic_substrings(\\"aaaa\\") ['a', 'aa', 'aaa', 'aaaa'] >>> generate_palindromic_substrings(\\"ababa\\") ['a', 'aba', 'ababa', 'b', 'bab']","solution":"def generate_palindromic_substrings(s: str) -> list: Function to return all unique palindromic substrings. def is_palindrome(sub): return sub == sub[::-1] palindromes = set() n = len(s) for i in range(n): for j in range(i, n): substring = s[i:j + 1] if is_palindrome(substring): palindromes.add(substring) return sorted(palindromes)"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a given mathematical expression represented as a string and returns the result. The function supports addition, subtraction, multiplication, division, and parentheses. Division by zero should return float('inf'). >>> evaluate_expression(\\"3+5*2\\") # expected output: 13.0 >>> evaluate_expression(\\"(3+5)*2\\") # expected output: 16.0 >>> evaluate_expression(\\"10 + (2 * 3) / (4 - 2)\\") # expected output: 13.0 >>> evaluate_expression(\\"10 / (5 - 5)\\") # expected output: float('inf')","solution":"def evaluate_expression(expression: str) -> float: Evaluates a given mathematical expression represented as a string and returns the result. The function supports addition, subtraction, multiplication, division, and parentheses to define the order of operations. try: result = eval(expression) return float(result) except ZeroDivisionError: return float('inf') # Note: Using \`eval\` here is for demonstration. # In a real-world application, you might want to implement a safer alternative, # avoiding direct usage of \`eval\` due to potential security risks."},{"question":"def merge_sort(arr: list) -> list: Implement the merge sort algorithm, a classic divide-and-conquer sorting technique. >>> merge_sort([]) == [] True >>> merge_sort([3]) == [3] True >>> merge_sort([3, 1, 2]) == [1, 2, 3] True >>> merge_sort([5, 2, 9, 1]) == [1, 2, 5, 9] True >>> merge_sort([8, 7, 5, 4, 2]) == [2, 4, 5, 7, 8] True def merge(left: list, right: list) -> list: Merge two sorted lists into a single sorted list. # Tests def test_merge_sort_empty_list(): assert merge_sort([]) == [] def test_merge_sort_single_element(): assert merge_sort([3]) == [3] def test_merge_sort_sorted(): assert merge_sort([1, 2, 3]) == [1, 2, 3] def test_merge_sort_unsorted(): assert merge_sort([3, 1, 2]) == [1, 2, 3] def test_merge_sort_duplicate_elements(): assert merge_sort([4, 5, 4, 3]) == [3, 4, 4, 5] def test_merge_sort_descending_order(): assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] def test_merge_sort_negative_numbers(): assert merge_sort([-3, -1, -2]) == [-3, -2, -1] def test_merge_sort_mixed_sign_numbers(): assert merge_sort([3, -1, 2, -2]) == [-2, -1, 2, 3] def test_merge_sort_large_list(): large_list = list(range(1000, 0, -1)) sorted_large_list = list(range(1, 1001)) assert merge_sort(large_list) == sorted_large_list","solution":"def merge_sort(arr: list) -> list: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: list, right: list) -> list: sorted_arr = [] left_idx, right_idx = 0, 0 while left_idx < len(left) and right_idx < len(right): if left[left_idx] < right[right_idx]: sorted_arr.append(left[left_idx]) left_idx += 1 else: sorted_arr.append(right[right_idx]) right_idx += 1 sorted_arr.extend(left[left_idx:]) sorted_arr.extend(right[right_idx:]) return sorted_arr"},{"question":"def find_non_sequential_logs(logs: list[tuple[str, int]]) -> list[str]: Find and return all systems that have non-sequential timestamps in their log entries. Args: logs (list[tuple[str, int]]): A list of tuples, where each tuple consists of a system identifier and a timestamp. Returns: list[str]: A sorted list of unique system identifiers which have non-sequential timestamps. Examples: >>> find_non_sequential_logs([(\\"system1\\", 101), (\\"system2\\", 200), (\\"system1\\", 100), (\\"system3\\", 300), (\\"system2\\", 199)]) ['system1', 'system2']","solution":"def find_non_sequential_logs(logs): from collections import defaultdict system_logs = defaultdict(list) # Group logs by system_id for system_id, timestamp in logs: system_logs[system_id].append(timestamp) non_sequential_systems = set() # Check each system's logs for non-sequential timestamps for system_id, timestamps in system_logs.items(): for i in range(1, len(timestamps)): if timestamps[i] < timestamps[i-1]: non_sequential_systems.add(system_id) break return sorted(non_sequential_systems)"},{"question":"import requests from collections import namedtuple StockData = namedtuple(\\"StockData\\", [\\"open_price\\", \\"high_price\\", \\"low_price\\", \\"close_price\\", \\"volume\\"]) def fetch_stock_data(company_symbol: str, date: str) -> StockData: Fetch stock data from Alpha Vantage API for a given company on a specific date. Args: company_symbol (str): The stock symbol of the company (e.g., \\"AAPL\\"). date (str): The specific date for which the stock data is required (format: YYYY-MM-DD). Returns: StockData: A namedtuple containing the open price, high price, low price, close price, and volume of the stock on the given date. Raises: ValueError: If no data is available for the given date. requests.HTTPError: For HTTP related errors. Example: >>> data = fetch_stock_data(\\"AAPL\\", \\"2022-03-15\\") >>> print(f\\"Open: {data.open_price}, High: {data.high_price}, Low: {data.low_price}, Close: {data.close_price}, Volume: {data.volume}\\") Open: 150.00, High: 155.00, Low: 148.00, Close: 152.00, Volume: 1000000","solution":"import requests from collections import namedtuple StockData = namedtuple(\\"StockData\\", [\\"open_price\\", \\"high_price\\", \\"low_price\\", \\"close_price\\", \\"volume\\"]) def fetch_stock_data(company_symbol: str, date: str) -> StockData: API_KEY = 'YOUR_API_KEY' # Replace with your actual Alpha Vantage API key BASE_URL = 'https://www.alphavantage.co/query' params = { \\"function\\": \\"TIME_SERIES_DAILY\\", \\"symbol\\": company_symbol, \\"apikey\\": API_KEY } response = requests.get(BASE_URL, params=params) if response.status_code == 200: data = response.json() if \\"Time Series (Daily)\\" in data and date in data[\\"Time Series (Daily)\\"]: daily_data = data[\\"Time Series (Daily)\\"][date] return StockData( open_price=float(daily_data[\\"1. open\\"]), high_price=float(daily_data[\\"2. high\\"]), low_price=float(daily_data[\\"3. low\\"]), close_price=float(daily_data[\\"4. close\\"]), volume=int(daily_data[\\"5. volume\\"]) ) else: raise ValueError(\\"No data available for the given date.\\") else: response.raise_for_status()"},{"question":"def is_repeating_pattern(arr: list[int]) -> bool: Check if the array can be constructed by repeating a contiguous subarray. >>> is_repeating_pattern([1, 2, 1, 2, 1, 2]) True >>> is_repeating_pattern([3, 4, 3, 4, 3]) False >>> is_repeating_pattern([5, 5, 5, 5]) True >>> is_repeating_pattern([1]) False","solution":"def is_repeating_pattern(arr): Check if the array can be constructed by repeating a contiguous subarray. n = len(arr) if n == 1: return False # Create a string representation of the array. arr_str = ''.join(map(str, arr)) # Optionally, check substrings' multiplicity up to half the length of the array for i in range(1, n // 2 + 1): if n % i == 0: # Get the subarray subarray = arr[:i] # Repeat the subarray to match the length of the original array if subarray * (n // i) == arr: return True return False"},{"question":"import math from typing import List def fibonacci_binet(n: int) -> List[float]: Generates the first n elements of the Fibonacci sequence using Binet’s formula. >>> fibonacci_binet(10) [0.0, 1.0, 1.0, 2.0, 3.0, 5.0, 8.0, 13.0, 21.0, 34.0] >>> fibonacci_binet(1) [0.0] >>> fibonacci_binet(2) [0.0, 1.0]","solution":"import math from typing import List def fibonacci_binet(n: int) -> List[float]: if n < 1: raise ValueError(\\"n must be greater than or equal to 1\\") phi = (1 + math.sqrt(5)) / 2 hat_phi = (1 - math.sqrt(5)) / 2 def binet_formula(k): return (phi**k - hat_phi**k) / math.sqrt(5) return [round(binet_formula(i)) for i in range(n)]"},{"question":"from typing import List def count_asterisk_components(grid: List[List[str]]) -> int: Count the number of connected components of '*' in the provided grid. Adjacent cells are considered as those directly above, below, left, or right (no diagonals). >>> count_asterisk_components([ ... ['*', '*', '.', '.', '.'], ... ['*', '.', '*', '*', '.'], ... ['.', '.', '*', '.', '*'], ... ['.', '.', '.', '.', '*'] ... ]) 3 >>> count_asterisk_components([ ... ['.', '.', '.'], ... ['.', '.', '.'], ... ['.', '.', '.'] ... ]) 0 pass def test_single_component(): grid = [ ['*', '*', '*'], ['*', '*', '*'], ['*', '*', '*'] ] assert count_asterisk_components(grid) == 1 def test_multiple_components(): grid = [ ['*', '.', '*'], ['.', '*', '.'], ['*', '.', '*'] ] assert count_asterisk_components(grid) == 5 def test_empty_grid(): grid = [ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ] assert count_asterisk_components(grid) == 0 def test_no_asterisks(): grid = [ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ] assert count_asterisk_components(grid) == 0 def test_large_component(): grid = [ ['*', '*', '.', '.', '.'], ['*', '.', '*', '*', '.'], ['.', '.', '*', '.', '*'], ['.', '.', '.', '.', '*'] ] assert count_asterisk_components(grid) == 3 def test_edge_case_empty(): grid = [] assert count_asterisk_components(grid) == 0 def test_single_cell_asterisk(): grid = [['*']] assert count_asterisk_components(grid) == 1 def test_single_cell_empty(): grid = [['.']] assert count_asterisk_components(grid) == 0","solution":"from typing import List def count_asterisk_components(grid: List[List[str]]) -> int: if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): stack = [(r, c)] while stack: x, y = stack.pop() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and grid[nx][ny] == '*': visited[nx][ny] = True stack.append((nx, ny)) count = 0 for i in range(rows): for j in range(cols): if grid[i][j] == '*' and not visited[i][j]: count += 1 visited[i][j] = True dfs(i, j) return count"},{"question":"# Completion Task: Reverse a Subsection of a Linked List Instructions: Given the \`Node\` class and its \`reverse_subsection\` method, implement the body of the \`reverse_subsection\` method which will reverse the nodes from position \`m\` to \`n\` in a given singly linked list. Implement the required function to handle various edge cases mentioned. Function Signature: class Node: def __init__(self, val: str, next: 'Node' = None): self.val = val self.next = next def reverse_subsection(self, m: int, n: int) -> 'Node': if m == n: return self dummy = Node(0) dummy.next = self prev = dummy # Step 1: Traverse the list to reach the node right before the subsection to be reversed for _ in range(m - 1): prev = prev.next # Step 2: Start reversing the subsection reverse_start = prev.next then = reverse_start.next for _ in range(n - m): reverse_start.next = then.next then.next = prev.next prev.next = then then = reverse_start.next return dummy.next def print_list(head: Node) -> str: result = [] current = head while current: result.append(current.val) current = current.next return '->'.join(result)","solution":"class Node: def __init__(self, val: str, next: 'Node' = None): self.val = val self.next = next def reverse_subsection(self, m: int, n: int) -> 'Node': if m == n: return self dummy = Node(0) dummy.next = self prev = dummy # Step 1: Traverse the list to reach the node right before the subsection to be reversed for _ in range(m - 1): prev = prev.next # Step 2: Start reversing the subsection reverse_start = prev.next then = reverse_start.next for _ in range(n - m): reverse_start.next = then.next then.next = prev.next prev.next = then then = reverse_start.next return dummy.next def print_list(head: Node) -> str: result = [] current = head while current: result.append(current.val) current = current.next return '->'.join(result)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root: TreeNode) -> bool: Determine whether a given binary tree is a valid Binary Search Tree (BST). >>> is_valid_bst(TreeNode(2, TreeNode(1), TreeNode(3))) True >>> is_valid_bst(TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))) False def test_tree_is_empty(): assert is_valid_bst(None) == True def test_single_node_tree(): node = TreeNode(1) assert is_valid_bst(node) == True def test_valid_bst(): tree1 = TreeNode(2, TreeNode(1), TreeNode(3)) assert is_valid_bst(tree1) == True def test_invalid_bst(): tree2 = TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6))) assert is_valid_bst(tree2) == False def test_left_subtree_invalid(): tree3 = TreeNode(10, TreeNode(5), TreeNode(15, TreeNode(6), TreeNode(20))) assert is_valid_bst(tree3) == False def test_right_subtree_invalid(): tree4 = TreeNode(3, TreeNode(1), TreeNode(5, TreeNode(4), TreeNode(6))) assert is_valid_bst(tree4) == True def test_balanced_bst(): tree5 = TreeNode(8, TreeNode(3, TreeNode(1), TreeNode(6, TreeNode(4), TreeNode(7))), TreeNode(10, None, TreeNode(14, TreeNode(13)))) assert is_valid_bst(tree5) == True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_bst(root: TreeNode) -> bool: def validate(node, low=float('-inf'), high=float('inf')): if not node: return True if not (low < node.val < high): return False return validate(node.left, low, node.val) and validate(node.right, node.val, high) return validate(root)"},{"question":"def compute_force_mass_acceleration(force: float, mass: float, acceleration: float) -> tuple[str, float]: Computes and returns the missing value (force, mass, or acceleration) based on the inputs. >>> compute_force_mass_acceleration(force=0, mass=10, acceleration=5) ('force', 50.0) >>> compute_force_mass_acceleration(force=200, mass=0, acceleration=5) ('mass', 40.0) >>> compute_force_mass_acceleration(force=100, mass=25, acceleration=0) ('acceleration', 4.0)","solution":"def compute_force_mass_acceleration(force: float, mass: float, acceleration: float) -> tuple[str, float]: Computes and returns the missing value (force, mass, or acceleration) based on the inputs. if force < 0 or mass < 0 or acceleration < 0: raise ValueError(\\"Inputs cannot be negative\\") zero_count = (force == 0) + (mass == 0) + (acceleration == 0) if zero_count != 1: raise ValueError(\\"Exactly one of the values must be zero\\") if force == 0: return 'force', mass * acceleration elif mass == 0: return 'mass', force / acceleration elif acceleration == 0: return 'acceleration', force / mass"},{"question":"from typing import List, Tuple, Dict def generate_receipt(items: List[Tuple[str, float, str]], discounts: Dict[str, float]) -> str: Generates a detailed receipt with discounts applied to each item. Args: items (List[Tuple[str, float, str]]): A list of tuples where each tuple contains: item_name (str): The name of the item. price (float): The price of the item before discount. category (str): The category of the item. discounts (Dict[str, float]): A dictionary where the key is the category (str) and the value is the discount percentage (float). Returns: str: A string representing the receipt, listing each item with its final price after discount and the grand total at the end. Examples: >>> items = [(\\"Laptop\\", 1000, \\"Electronics\\"), (\\"T-shirt\\", 20, \\"Clothing\\"), (\\"Headphones\\", 200, \\"Electronics\\")] >>> discounts = {\\"Electronics\\": 10, \\"Clothing\\": 5} >>> generate_receipt(items, discounts) \\"Item: Laptop, Final Price: 900.00nItem: T-shirt, Final Price: 19.00nItem: Headphones, Final Price: 180.00nTotal: 1099.00\\" >>> items = [(\\"Laptop\\", 1000, \\"Electronics\\")] >>> discounts = {} >>> generate_receipt(items, discounts) \\"Item: Laptop, Final Price: 1000.00nTotal: 1000.00\\" >>> items = [] >>> discounts = {\\"Electronics\\": 10} >>> generate_receipt(items, discounts) \\"Total: 0.00\\" >>> items = [(\\"Gift Card\\", 100, \\"Promos\\")] >>> discounts = {\\"Promos\\": 100} >>> generate_receipt(items, discounts) \\"Item: Gift Card, Final Price: 0.00nTotal: 0.00\\" >>> items = [(\\"Laptop\\", 1000, \\"Electronics\\"), (\\"T-shirt\\", 20, \\"Clothing\\"), (\\"Coffee\\", 5, \\"Groceries\\")] >>> discounts = {\\"Electronics\\": 10, \\"Clothing\\": 5} >>> generate_receipt(items, discounts) \\"Item: Laptop, Final Price: 900.00nItem: T-shirt, Final Price: 19.00nItem: Coffee, Final Price: 5.00nTotal: 924.00\\"","solution":"from typing import List, Tuple, Dict def generate_receipt(items: List[Tuple[str, float, str]], discounts: Dict[str, float]) -> str: receipt_lines = [] total_cost = 0.0 for item_name, price, category in items: discount = discounts.get(category, 0) final_price = price * (1 - discount / 100) receipt_lines.append(f\\"Item: {item_name}, Final Price: {final_price:.2f}\\") total_cost += final_price receipt_lines.append(f\\"Total: {total_cost:.2f}\\") return 'n'.join(receipt_lines)"},{"question":"class MaxStack: A special stack data structure capable of running the following operations in constant time: 1. Push(x): Pushes an integer x onto the stack. 2. Pop(): Removes the element on the top of the stack. 3. Top(): Retrieves the top element without removing it. 4. GetMax(): Retrieves the maximum element in the stack. Examples: >>> stack = MaxStack() >>> stack.push(5) >>> stack.push(1) >>> stack.push(5) >>> stack.getMax() == 5 >>> stack.top() == 5 >>> stack.pop() >>> stack.getMax() == 5 >>> stack.top() == 1 >>> stack.pop() >>> stack.getMax() == 5 >>> stack.top() == 5 >>> stack.pop() >>> stack.getMax() == 'Invalid operation' def __init__(self) -> None: Initializes the stack object. pass def push(self, x: int) -> None: Pushes the integer x on the stack. Args: - x (int): The integer to be pushed on the stack. pass def pop(self) -> None: Removes the top element from the stack. pass def top(self) -> int: Retrieves the top element from the stack. Returns: - int: The top element from the stack. pass def getMax(self) -> int: Retrieves the maximum element in the stack. Returns: - int: The maximum element in the stack. pass","solution":"class MaxStack: def __init__(self) -> None: self.stack = [] self.max_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) def pop(self) -> None: if self.stack: top = self.stack.pop() if top == self.max_stack[-1]: self.max_stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] else: return 'Invalid operation' def getMax(self) -> int: if self.max_stack: return self.max_stack[-1] else: return 'Invalid operation'"},{"question":"from typing import List, Dict def forest_fire_simulation( width: int, height: int, tree_density: float, initial_burn_prob: float, spread_prob: float, max_iterations: int ) -> dict: Simulate the generation and spread of forest fires on a 2D grid. Args: width (int): Width of the grid. height (int): Height of the grid. tree_density (float): The probability that a cell contains a tree at initialization. initial_burn_prob (float): The probability that a tree is initially on fire. spread_prob (float): The probability that fire spreads from a burning tree to an adjacent tree. max_iterations (int): Maximum number of iterations to run the simulation. Returns: dict: A dictionary with the final counts of trees and burnt trees. >>> forest_fire_simulation(10, 10, 0, 0, 0, 10) {'trees': 0, 'burnt_trees': 100} >>> forest_fire_simulation(10, 10, 1, 0, 0, 10) {'trees': 100, 'burnt_trees': 0} >>> forest_fire_simulation(5, 5, 1, 1, 0, 10) {'trees': 0, 'burnt_trees': 25} >>> forest_fire_simulation(10, 10, 1, 0.5, 1, 10) {<result>} >>> forest_fire_simulation(10, 10, 1, 0.1, 0.1, 5) {<result>} >>> forest_fire_simulation(10, 10, 1, 0.1, 0.5, 1) {<result>}","solution":"import random def forest_fire_simulation( width: int, height: int, tree_density: float, initial_burn_prob: float, spread_prob: float, max_iterations: int ) -> dict: EMPTY, TREE, BURNING = 0, 1, 2 def initialize_grid(): grid = [] for _ in range(height): row = [] for _ in range(width): if random.random() < tree_density: if random.random() < initial_burn_prob: row.append(BURNING) else: row.append(TREE) else: row.append(EMPTY) grid.append(row) return grid def spread_fire(grid): new_grid = [row[:] for row in grid] for y in range(height): for x in range(width): if grid[y][x] == BURNING: # Current tree will turn to empty next round new_grid[y][x] = EMPTY # Try to spread fire to adjacent trees for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < width and 0 <= ny < height and grid[ny][nx] == TREE: if random.random() < spread_prob: new_grid[ny][nx] = BURNING return new_grid def count_trees_and_burnt(grid): trees_count = sum(row.count(TREE) for row in grid) burnt_count = sum(row.count(BURNING) + row.count(EMPTY) for row in grid) return trees_count, burnt_count grid = initialize_grid() for _ in range(max_iterations): grid = spread_fire(grid) if all(tree != BURNING for row in grid for tree in row): break trees_count, burnt_count = count_trees_and_burnt(grid) return {'trees': trees_count, 'burnt_trees': height * width - trees_count}"},{"question":"from typing import List def minimum_swaps_to_sort(arr: List[int]) -> int: Sort an array in ascending order by performing the smallest possible number of swaps. Args: arr (List[int]): A list of distinct integers that need to be sorted. Returns: int: An integer representing the minimum number of swaps required to sort the array. Examples: >>> minimum_swaps_to_sort([4, 3, 1, 2]) 3 >>> minimum_swaps_to_sort([2, 3, 4, 1, 5]) 3 >>> minimum_swaps_to_sort([1, 3, 5, 2, 4, 6, 7]) 3 pass def test_minimum_swaps_to_sort_example_1(): assert minimum_swaps_to_sort([4, 3, 1, 2]) == 3 def test_minimum_swaps_to_sort_example_2(): assert minimum_swaps_to_sort([2, 3, 4, 1, 5]) == 3 def test_minimum_swaps_to_sort_example_3(): assert minimum_swaps_to_sort([1, 3, 5, 2, 4, 6, 7]) == 3 def test_minimum_swaps_to_sort_already_sorted(): assert minimum_swaps_to_sort([1, 2, 3, 4, 5]) == 0 def test_minimum_swaps_to_sort_reverse_order(): assert minimum_swaps_to_sort([5, 4, 3, 2, 1]) == 2 def test_minimum_swaps_to_sort_single_element(): assert minimum_swaps_to_sort([1]) == 0 def test_minimum_swaps_to_sort_large_numbers(): assert minimum_swaps_to_sort([100, 50, 200, 150, 300, 250, 400, 350]) == 4","solution":"from typing import List def minimum_swaps_to_sort(arr: List[int]) -> int: n = len(arr) arrpos = [(value, index) for index, value in enumerate(arr)] arrpos.sort() visited = [False] * n swaps = 0 for i in range(n): if visited[i] or arrpos[i][1] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arrpos[j][1] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"# Insert items with associated priorities class CustomPriorityQueue: def __init__(self): self.heap = [] self.entry_finder = {} self.counter = 0 def insert(self, item: Any, priority: int): if item in self.entry_finder: self.update_priority(item, priority) else: entry = [-priority, self.counter, item] self.entry_finder[item] = entry heapq.heappush(self.heap, entry) self.counter += 1 def remove_max(self) -> Any: while self.heap: priority, count, item = heapq.heappop(self.heap) if item is not None: del self.entry_finder[item] return item return None def update_priority(self, item: Any, new_priority: int): if item in self.entry_finder: entry = self.entry_finder.pop(item) entry[-1] = None self.insert(item, new_priority)","solution":"import heapq class CustomPriorityQueue: def __init__(self): self.heap = [] self.entry_finder = {} self.counter = 0 def insert(self, item, priority): if item in self.entry_finder: self.update_priority(item, priority) else: entry = [-priority, self.counter, item] self.entry_finder[item] = entry heapq.heappush(self.heap, entry) self.counter += 1 def remove_max(self): while self.heap: priority, count, item = heapq.heappop(self.heap) if item is not None: del self.entry_finder[item] return item return None def update_priority(self, item, new_priority): if item in self.entry_finder: entry = self.entry_finder.pop(item) entry[-1] = None self.insert(item, new_priority)"},{"question":"from typing import List, Tuple def schedule_matches(teams: List[str]) -> List[List[Tuple[str, str]]]: Schedules matches for the given teams ensuring no team plays more than one match at the same time. :param teams: List of team names. :return: List of match schedules. Example: >>> schedule_matches([\\"Team A\\", \\"Team B\\", \\"Team C\\", \\"Team D\\"]) [[(\\"Team A\\", \\"Team B\\"), (\\"Team C\\", \\"Team D\\")]] >>> schedule_matches([\\"Team A\\", \\"Team B\\", \\"Team C\\", \\"Team D\\", \\"Team E\\", \\"Team F\\"]) [[(\\"Team A\\", \\"Team B\\"), (\\"Team C\\", \\"Team D\\"), (\\"Team E\\", \\"Team F\\")]] >>> schedule_matches([\\"Team A\\", \\"Team B\\"]) [[(\\"Team A\\", \\"Team B\\")]] >>> schedule_matches([f\\"Team {i}\\" for i in range(1, 21)]) [[(f\\"Team {i}\\", f\\"Team {i+1}\\") for i in range(1, 21, 2)]] >>> schedule_matches([\\"Team Alpha\\", \\"Team Beta\\", \\"Team Gamma\\", \\"Team Delta\\"]) [[(\\"Team Alpha\\", \\"Team Beta\\"), (\\"Team Gamma\\", \\"Team Delta\\")]]","solution":"from typing import List, Tuple def schedule_matches(teams: List[str]) -> List[List[Tuple[str, str]]]: Schedules matches for the given teams. :param teams: List of team names. :return: List of match schedules. num_teams = len(teams) match_schedule = [] for i in range(0, num_teams, 2): match_schedule.append((teams[i], teams[i + 1])) return [match_schedule]"},{"question":"def minimum_cost_path(matrix_str: str) -> int: Given a string representation of a matrix, finds the minimum cost path from the top-left corner to the bottom-right corner. You can move only right or down. Example: >>> minimum_cost_path(\\"1 3 1n1 5 1n4 2 1\\") 7 >>> minimum_cost_path(\\"1n2n3n4\\") 10 from solution import minimum_cost_path def test_minimum_cost_path_basic(): matrix_str = \\"1 3 1n1 5 1n4 2 1\\" assert minimum_cost_path(matrix_str) == 7 def test_minimum_cost_path_single_cell(): matrix_str = \\"5\\" assert minimum_cost_path(matrix_str) == 5 def test_minimum_cost_path_single_row(): matrix_str = \\"1 2 3 4\\" assert minimum_cost_path(matrix_str) == 10 def test_minimum_cost_path_single_column(): matrix_str = \\"1n2n3n4\\" assert minimum_cost_path(matrix_str) == 10 def test_minimum_cost_path_larger_matrix(): matrix_str = \\"1 2 3n4 8 2n1 5 3\\" assert minimum_cost_path(matrix_str) == 11 def test_minimum_cost_path_with_negative_numbers(): matrix_str = \\"1 -3 1n-2 5 -1n4 2 1\\" assert minimum_cost_path(matrix_str) == -1","solution":"def minimum_cost_path(matrix_str: str) -> int: Given a string representation of a matrix, finds the minimum cost path from the top-left corner to the bottom-right corner. You can move only right or down. # Parse the input string into a 2D list (matrix) matrix = [list(map(int, row.split())) for row in matrix_str.strip().split('n')] # Get the number of rows and columns rows = len(matrix) cols = len(matrix[0]) # Initialize a dp array with the same dimensions as the matrix dp = [[0] * cols for _ in range(rows)] # Initialize the starting point dp[0][0] = matrix[0][0] # Fill the first row (can only come from the left) for j in range(1, cols): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the first column (can only come from above) for i in range(1, rows): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the dp array for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] # The answer is in the bottom-right corner of the dp array return dp[rows-1][cols-1]"},{"question":"from typing import List def sum_divisible_by_k(arr: List[int], k: int) -> int: Returns the sum of all elements in the array that are divisible by k. >>> sum_divisible_by_k([1, 2, 3, 4, 5, 6], 2) 12 >>> sum_divisible_by_k([-10, -20, 15, 25], 5) 10 >>> sum_divisible_by_k([3, 7, 14, 18, 21], 7) 42 >>> sum_divisible_by_k([5], 5) 5 >>> sum_divisible_by_k([1, 2, 3], 10) 0","solution":"from typing import List def sum_divisible_by_k(arr: List[int], k: int) -> int: Returns the sum of all elements in the array that are divisible by k. return sum(x for x in arr if x % k == 0)"},{"question":"def normalize_floats(values: list[float]) -> list[float]: Normalize a list of floating-point numbers to fit between 0 and 1 based on their original distribution. >>> normalize_floats([1.0, 2.0, 3.0]) [0.0, 0.5, 1.0] >>> normalize_floats([10.0, 20.0, 30.0, 40.0]) [0.0, 0.3333333333333333, 0.6666666666666666, 1.0] >>> normalize_floats([42.0]) [0.0] >>> normalize_floats([]) [] >>> normalize_floats([0.0, 0.0, 0.0]) [0.0, 0.0, 0.0] >>> normalize_floats([-10.0, 0.0, 10.0]) [0.0, 0.5, 1.0]","solution":"def normalize_floats(values: list[float]) -> list[float]: if not values: return [] min_val = min(values) max_val = max(values) if min_val == max_val: return [0.0] * len(values) return [(value - min_val) / (max_val - min_val) for value in values]"},{"question":"from typing import List class Matrix: def __init__(self, data: List[List[int]]): self.data = data def transpose(self) -> List[List[int]]: Calculate the transpose of the matrix. This method converts the rows of the original matrix into columns and vice versa. Returns: List[List[int]]: The transposed matrix. >>> matrix = Matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) >>> matrix.transpose() [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> matrix = Matrix([ ... [1, 2], ... [3, 4], ... [5, 6] ... ]) >>> matrix.transpose() [[1, 3, 5], [2, 4, 6]]","solution":"from typing import List class Matrix: def __init__(self, data: List[List[int]]): self.data = data def transpose(self) -> List[List[int]]: Calculate the transpose of the matrix. Returns: List[List[int]]: The transposed matrix. # Number of rows and columns rows = len(self.data) cols = len(self.data[0]) # Initialize the transposed matrix with switched dimensions transposed = [[0] * rows for _ in range(cols)] # Fill the transposed matrix with transposed values for r in range(rows): for c in range(cols): transposed[c][r] = self.data[r][c] return transposed"},{"question":"def longest_non_repeating_substring(s: str) -> str: Returns the longest substring of the input string s that contains no repeating characters. >>> longest_non_repeating_substring(\\"abcabcbb\\") 'abc' >>> longest_non_repeating_substring(\\"bbbbb\\") 'b' >>> longest_non_repeating_substring(\\"pwwkew\\") 'wke' >>> longest_non_repeating_substring(\\"\\") ''","solution":"def longest_non_repeating_substring(s: str) -> str: Returns the longest substring of the input string s that contains no repeating characters. n = len(s) if n == 0: return \\"\\" char_index = {} max_len = 0 start = 0 longest_substr = \\"\\" for i in range(n): if s[i] in char_index and char_index[s[i]] >= start: start = char_index[s[i]] + 1 char_index[s[i]] = i current_len = i - start + 1 if current_len > max_len: max_len = current_len longest_substr = s[start:i+1] return longest_substr"},{"question":"from typing import List def filter_evens_and_compute_gcd(numbers: List[int]) -> int: Filters out the even numbers from the list and computes the GCD of the remaining odd numbers. >>> filter_evens_and_compute_gcd([12, 15, 7, 19, 22]) 1 >>> filter_evens_and_compute_gcd([2, 4, 6, 8]) 0 >>> filter_evens_and_compute_gcd([3, 9, 15]) 3","solution":"from math import gcd from functools import reduce def filter_evens_and_compute_gcd(numbers: list[int]) -> int: Filters out the even numbers from the list and computes the GCD of the remaining odd numbers. :param numbers: List of integers :return: GCD of odd numbers or 0 if there are no odd numbers # Filter the list to get only odd numbers odd_numbers = [num for num in numbers if num % 2 != 0] # If there are no odd numbers, return 0 if not odd_numbers: return 0 # Compute the GCD of the odd numbers return reduce(gcd, map(abs, odd_numbers))"},{"question":"def find_consecutive_active_days(active_days: list[int]) -> list[tuple[int, int]]: Write a function \`find_consecutive_active_days\` that takes a list of integers \`active_days\` and returns a list of tuples where each tuple represents the start and end of a consecutive sequence of days. Args: active_days (list[int]): A list of integers where each integer represents a day the user was active. The days are not necessarily sorted and might contain duplicates. Returns: list[tuple[int, int]]: A list of tuples where each tuple contains two integers representing the start and end days of a consecutive sequence of days that the user was active. Examples: >>> find_consecutive_active_days([1, 2, 2, 3, 5, 8, 9, 10]) [(1, 3), (5, 5), (8, 10)] >>> find_consecutive_active_days([7, 5, 6, 6, 4]) [(4, 7)] >>> find_consecutive_active_days([34, 33, 32, 31]) [(31, 34)] >>> find_consecutive_active_days([1, 3, 5, 7]) [(1, 1), (3, 3), (5, 5), (7, 7)] >>> find_consecutive_active_days([100]) [(100, 100)] >>> find_consecutive_active_days([1,2,6,7,8,9,11,13,14,15,20,21,22,23,24,25,26]) [(1, 2), (6, 9), (11, 11), (13, 15), (20, 26)] >>> find_consecutive_active_days([]) [] >>> find_consecutive_active_days([2, 2, 2, 2]) [(2, 2)]","solution":"def find_consecutive_active_days(active_days: list[int]) -> list[tuple[int, int]]: Returns a list of tuples where each tuple represents the start and end days of a consecutive sequence of active days. # First, we remove duplicates and sort the days active_days = sorted(set(active_days)) if not active_days: return [] result = [] start = active_days[0] end = active_days[0] for i in range(1, len(active_days)): if active_days[i] == end + 1: end = active_days[i] else: result.append((start, end)) start = active_days[i] end = active_days[i] result.append((start, end)) return result"},{"question":"import heapq class HuffmanNode: def __init__(self, freq, char=None, left=None, right=None): self.char = char self.freq = freq self.left = left self.right = right def __lt__(self, other): return self.freq < other.freq class HuffmanCoding: def __init__(self): self.heap = [] self.codes = {} self.reverse_mapping = {} def build_frequency_dict(self, text): >>> huffman = HuffmanCoding() >>> huffman.build_frequency_dict(\\"aaabbc\\") {'a': 3, 'b': 2, 'c': 1} pass def build_heap(self, frequency): >>> huffman = HuffmanCoding() >>> frequency = huffman.build_frequency_dict(\\"aaabbc\\") >>> huffman.build_heap(frequency) >>> len(huffman.heap) 3 >>> huffman.heap[0].char == 'c' and huffman.heap[0].freq == 1 True pass def merge_nodes(self): >>> huffman = HuffmanCoding() >>> frequency = huffman.build_frequency_dict(\\"aaabbc\\") >>> huffman.build_heap(frequency) >>> huffman.merge_nodes() >>> len(huffman.heap) 1 >>> huffman.heap[0].freq == 6 True pass def make_codes_helper(self, root, current_code): Helper function to generate huffman codes for characters from the Huffman Tree. pass def make_codes(self): >>> huffman = HuffmanCoding() >>> frequency = huffman.build_frequency_dict(\\"aaabbc\\") >>> huffman.build_heap(frequency) >>> huffman.merge_nodes() >>> huffman.make_codes() >>> 'a' in huffman.codes True >>> 'b' in huffman.codes True >>> 'c' in huffman.codes True >>> huffman.reverse_mapping[huffman.codes['a']] == 'a' True >>> huffman.reverse_mapping[huffman.codes['b']] == 'b' True >>> huffman.reverse_mapping[huffman.codes['c']] == 'c' True pass def get_encoded_text(self, text): Generates the encoded text as a string of binary digits. pass def compress(self, input_text): Compress the input text using Huffman coding and return the binary format. >>> huffman = HuffmanCoding() >>> compressed_data = huffman.compress(\\"aaabbc\\") >>> len(compressed_data) > 0 True pass def decompress(self, binary_format): Decompress the binary format to return the original text. >>> huffman = HuffmanCoding() >>> compressed_data = huffman.compress(\\"aaabbc\\") >>> decompressed_text = huffman.decompress(compressed_data) >>> decompressed_text 'aaabbc' pass","solution":"import heapq class HuffmanNode: def __init__(self, freq, char=None, left=None, right=None): self.char = char self.freq = freq self.left = left self.right = right def __lt__(self, other): return self.freq < other.freq class HuffmanCoding: def __init__(self): self.heap = [] self.codes = {} self.reverse_mapping = {} def build_frequency_dict(self, text): frequency = {} for char in text: if char not in frequency: frequency[char] = 0 frequency[char] += 1 return frequency def build_heap(self, frequency): for key in frequency: node = HuffmanNode(frequency[key], key) heapq.heappush(self.heap, node) def merge_nodes(self): while len(self.heap) > 1: node1 = heapq.heappop(self.heap) node2 = heapq.heappop(self.heap) merged = HuffmanNode(node1.freq + node2.freq, left=node1, right=node2) heapq.heappush(self.heap, merged) def make_codes_helper(self, root, current_code): if root is None: return if root.char is not None: self.codes[root.char] = current_code self.reverse_mapping[current_code] = root.char return self.make_codes_helper(root.left, current_code + \\"0\\") self.make_codes_helper(root.right, current_code + \\"1\\") def make_codes(self): root = heapq.heappop(self.heap) current_code = \\"\\" self.make_codes_helper(root, current_code) def get_encoded_text(self, text): encoded_text = \\"\\" for char in text: encoded_text += self.codes[char] return encoded_text def compress(self, input_text): frequency = self.build_frequency_dict(input_text) self.build_heap(frequency) self.merge_nodes() self.make_codes() encoded_text = self.get_encoded_text(input_text) padding = 8 - len(encoded_text) % 8 encoded_text = f\\"{padding:08b}\\" + '0' * padding + encoded_text binary_format = bytearray() for i in range(0, len(encoded_text), 8): byte = encoded_text[i:i + 8] binary_format.append(int(byte, 2)) return binary_format def decompress(self, binary_format): padded_info = format(binary_format[0], '08b') padding = int(padded_info, 2) bit_string = \\"\\" for byte in binary_format[1:]: byte = format(byte, '08b') bit_string += byte encoded_text = bit_string[padding:] current_code = \\"\\" decoded_text = \\"\\" for bit in encoded_text: current_code += bit if current_code in self.reverse_mapping: character = self.reverse_mapping[current_code] decoded_text += character current_code = \\"\\" return decoded_text"},{"question":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def append(self, value): if not self.head: self.head = Node(value) else: current = self.head while current.next: current = current.next current.next = Node(value) def has_cycle(self) -> bool: This method should return True if there is a cycle in the linked list, otherwise return False. # Unit Test def test_has_cycle_no_cycle(): ll = LinkedList() ll.append(1) ll.append(2) ll.append(3) assert not ll.has_cycle() def test_has_cycle_with_cycle(): ll = LinkedList() ll.append(1) ll.append(2) ll.append(3) ll.head.next.next.next = ll.head # Creating a cycle assert ll.has_cycle() def test_has_cycle_single_node_cycle(): ll = LinkedList() ll.append(1) ll.head.next = ll.head # Single node forms a cycle assert ll.has_cycle() def test_has_cycle_empty_list(): ll = LinkedList() # Empty list assert not ll.has_cycle() def test_has_cycle_two_node_cycle(): ll = LinkedList() ll.append(1) ll.append(2) ll.head.next.next = ll.head # Creating a cycle between two nodes assert ll.has_cycle()","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def append(self, value): if not self.head: self.head = Node(value) else: current = self.head while current.next: current = current.next current.next = Node(value) def has_cycle(self) -> bool: This method uses Floyd's Cycle-Finding Algorithm to detect if there is a cycle in the linked list. Returns True if there is a cycle, otherwise returns False. slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"from typing import List def get_active_ips(logs: List[str]) -> List[str]: Returns a sorted list of unique IP addresses that have a status of 'ACTIVE'. >>> get_active_ips([\\"192.168.0.1 - ACTIVE\\", \\"192.168.0.2 - INACTIVE\\", \\"192.168.0.1 - ACTIVE\\"]) ['192.168.0.1'] >>> get_active_ips([\\"10.0.0.1 - ACTIVE\\", \\"192.168.1.1 - ACTIVE\\", \\"10.0.0.1 - INACTIVE\\", \\"192.168.1.2 - ACTIVE\\"]) ['10.0.0.1', '192.168.1.1', '192.168.1.2'] >>> get_active_ips([\\"127.0.0.1 - INACTIVE\\", \\"10.0.0.2 - INACTIVE\\"]) [] pass # Your implementation here","solution":"from typing import List import re def validate_ip(ip: str) -> bool: Validate an IP address to ensure it follows a valid IPv4 format. pattern = re.compile( r'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}' r'(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)' ) return pattern.match(ip) is not None def get_active_ips(logs: List[str]) -> List[str]: Returns a sorted list of unique IP addresses that have a status of \\"ACTIVE\\". active_ips = set() for log in logs: try: ip, status = log.split(' - ') except ValueError: raise ValueError(\\"Invalid log entry format\\") if not validate_ip(ip): raise ValueError(\\"Invalid IP address format\\") if status == \\"ACTIVE\\": active_ips.add(ip) return sorted(active_ips)"},{"question":"def solve_maze(maze: list[list[int]], start: tuple[int, int], end: tuple[int, int]) -> bool: Determines if there is a path from the start position to the end position in the maze using DFS. >>> maze = [ ... [0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [0, 1, 0, 0, 0], ... [0, 0, 0, 1, 0] ... ] >>> start = (0, 0) >>> end = (4, 4) >>> solve_maze(maze, start, end) True >>> maze = [ ... [0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [0, 1, 0, 0, 1], ... [0, 0, 0, 1, 0] ... ] >>> start = (0, 0) >>> end = (4, 4) >>> solve_maze(maze, start, end) False","solution":"def solve_maze(maze, start, end): Determines if there is a path from the start position to the end position in the maze using DFS. :param maze: List[List[int]] representing the maze :param start: Tuple[int, int] representing the start position (row, column) :param end: Tuple[int, int] representing the end position (row, column) :return: bool indicating if a path exists from start to end rows, cols = len(maze), len(maze[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): if not (0 <= r < rows) or not (0 <= c < cols) or maze[r][c] == 1 or visited[r][c]: return False if (r, c) == end: return True visited[r][c] = True # Explore all 4 directions: right, left, down, up if (dfs(r, c + 1) or dfs(r, c - 1) or dfs(r + 1, c) or dfs(r - 1, c)): return True return False return dfs(start[0], start[1])"},{"question":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if root is None: return Node(key) else: if key < root.val: root.left = self._insert(root.left, key) else: root.right = self._insert(root.right, key) return root def find_min(self): Finds the minimum value in the BST. Time complexity: O(h), where h is the height of the BST. @returns: The minimum value in the tree. Example: >>> bst = BST() >>> bst.insert(10) >>> bst.insert(5) >>> bst.insert(15) >>> bst.insert(2) >>> bst.find_min() 2 >>> bst.insert(1) >>> bst.find_min() 1","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if root is None: return Node(key) else: if key < root.val: root.left = self._insert(root.left, key) else: root.right = self._insert(root.right, key) return root def find_min(self): Finds the minimum value in the BST. Time complexity: O(h), where h is the height of the BST. @returns: The minimum value in the tree. Example: >>> bst = BST() >>> bst.insert(10) >>> bst.insert(5) >>> bst.insert(15) >>> bst.insert(2) >>> bst.find_min() 2 >>> bst.insert(1) >>> bst.find_min() 1 if self.root is None: return None current = self.root while current.left is not None: current = current.left return current.val"},{"question":"def find_missing_and_repeated(numbers: list) -> tuple: This function finds the missing number and the repeated number in the list. Parameters: numbers (list): A list of integers from 1 to n with one number missing and one number repeated. Returns: tuple: A tuple containing the missing number and the repeated number. >>> find_missing_and_repeated([4, 3, 6, 2, 1, 6]) (5, 6) >>> find_missing_and_repeated([1, 2, 3, 5, 5]) (4, 5) >>> find_missing_and_repeated([7, 3, 6, 2, 1, 6, 4]) (5, 6) >>> find_missing_and_repeated([1, 5, 4, 3, 5, 6, 7, 8, 9]) (2, 5) >>> input_data = list(range(1, 10000)) >>> input_data[1234] = 9999 >>> find_missing_and_repeated(input_data) (1235, 9999)","solution":"def find_missing_and_repeated(numbers): This function finds and returns the missing and repeated numbers in the list. n = len(numbers) total_sum = n * (n + 1) // 2 total_sum_squares = n * (n + 1) * (2 * n + 1) // 6 actual_sum = sum(numbers) actual_sum_squares = sum(x * x for x in numbers) diff = total_sum - actual_sum diff_squares = total_sum_squares - actual_sum_squares sum_x_y = diff_squares // diff x = (sum_x_y + diff) // 2 y = sum_x_y - x return (x, y)"},{"question":"def decode_string(encoded_str: str) -> str: Decodes a string of numbers separated by commas into its corresponding alphabetic representation, where each number represents the position of a letter in the alphabet (1 for 'A', 2 for 'B', ..., 26 for 'Z'). :param encoded_str: A string of numbers separated by commas. :return: A decoded string represented by the numbers. pass # Test cases def test_decode_single_letter(): assert decode_string(\\"1\\") == \\"A\\" assert decode_string(\\"26\\") == \\"Z\\" def test_decode_multiple_letters(): assert decode_string(\\"8,5,12,12,15\\") == \\"HELLO\\" assert decode_string(\\"20,8,5\\") == \\"THE\\" def test_decode_full_alphabet(): assert decode_string(\\"1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26\\") == \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" def test_decode_with_repeated_numbers(): assert decode_string(\\"19,19,19\\") == \\"SSS\\" def test_decode_long_string(): assert decode_string(\\"20,8,5,17,21,9,3,11,2,18,15,23,14,6,15,24,10,21,13,16,19,15,22,5,18\\") == \\"THEQUICKBROWNFOXJUMPSOVER\\"","solution":"def decode_string(encoded_str: str) -> str: Decodes a string of numbers separated by commas into its corresponding alphabetic representation, where each number represents the position of a letter in the alphabet (1 for 'A', 2 for 'B', ..., 26 for 'Z'). :param encoded_str: A string of numbers separated by commas. :return: A decoded string represented by the numbers. # Split the input string into a list of numbers numbers = encoded_str.split(',') # Convert each number to its corresponding letter in the alphabet decoded_message = ''.join(chr(int(num) + 64) for num in numbers) return decoded_message"},{"question":"def has_unique_characters(s: str) -> bool: Given a string s, determines if the string has all unique characters. Args: s: str - A string input. Returns: bool - True if all characters are unique, False otherwise. Raises: TypeError: If the input is not a string Examples: >>> has_unique_characters(\\"abcdef\\") True >>> has_unique_characters(\\"hello\\") False >>> has_unique_characters(\\"\\") True >>> has_unique_characters(\\"Aa\\") True","solution":"def has_unique_characters(s: str) -> bool: Given a string s, determines if the string has all unique characters. Args: s: str - A string input. Returns: bool - True if all characters are unique, False otherwise. Raises: TypeError: If the input is not a string Examples: >>> has_unique_characters(\\"abcdef\\") True >>> has_unique_characters(\\"hello\\") False >>> has_unique_characters(\\"\\") True >>> has_unique_characters(\\"Aa\\") True if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") seen_chars = set() for char in s: if char in seen_chars: return False seen_chars.add(char) return True"},{"question":"class TreeNode: def __init__(self, value: int, left=None, right=None, isThreaded=False): self.value = value self.left = left self.right = right self.isThreaded = isThreaded def inorder_traversal(root: TreeNode) -> list: Perform an in-order traversal on a given threaded binary tree. >>> # Example threaded binary tree >>> # 4 >>> # / >>> # 2 6 >>> # / / >>> # 1 3 5 (4's right points to 5 via threading) >>> root = TreeNode(4) >>> root.left = TreeNode(2) >>> root.right = TreeNode(6, isThreaded=True) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(3) >>> root.right.left = TreeNode(5) >>> inorder_traversal(root) [1, 2, 3, 4, 5, 6] pass","solution":"class TreeNode: def __init__(self, value: int, left=None, right=None, isThreaded=False): self.value = value self.left = left self.right = right self.isThreaded = isThreaded def inorder_traversal(root: TreeNode) -> list: result = [] current = root while current is not None: if current.left is None: result.append(current.value) current = current.right else: # Find the rightmost node in the left subtree or threaded link pre = current.left while pre.right is not None and pre.right != current: pre = pre.right # Make current as the right child of its inorder predecessor if pre.right is None: pre.right = current current = current.left else: pre.right = None result.append(current.value) current = current.right return result"},{"question":"import re from collections import Counter def word_frequency(text: str) -> dict: Returns the frequency of each word in the given text. Words are case insensitive and punctuation is ignored. >>> word_frequency(\\"Hello, world! Hello.\\") {'hello': 2, 'world': 1} >>> word_frequency(\\"\\") {} >>> word_frequency(\\"Python, python, Python!\\") {'python': 3} def char_frequency(text: str) -> dict: Returns the frequency of each character in the given text. Characters include all alphanumeric characters and punctuation. >>> char_frequency(\\"Hello, world!\\") {'H': 1, 'e': 1, 'l': 3, 'o': 2, ' ': 1, ',': 1, 'w': 1, 'r': 1, 'd': 1, '!': 1} >>> char_frequency(\\"\\") {} >>> char_frequency(\\"Python123!\\") {'P': 1, 'y': 1, 't': 1, 'h': 1, 'o': 1, 'n': 1, '1': 1, '2': 1, '3': 1, '!': 1}","solution":"import re from collections import Counter def word_frequency(text): Returns the frequency of each word in the given text. Words are case insensitive and punctuation is ignored. text = text.lower() words = re.findall(r'bw+b', text) return dict(Counter(words)) def char_frequency(text): Returns the frequency of each character in the given text. Characters include all alphanumeric characters and punctuation. return dict(Counter(text))"},{"question":"from typing import List, Dict def find_sccs(adj_list: Dict[int, List[int]]) -> List[List[int]]: Determine all the strongly connected components in a directed graph. Parameters: adj_list (Dict[int, List[int]]): The adjacency list representation of the graph. Returns: List[List[int]]: A list containing all SCCs, each represented as a list of vertex ids. Example: >>> adj_list = { ... 1: [2], ... 2: [3, 4], ... 3: [1], ... 4: [5], ... 5: [6], ... 6: [4] ... } >>> find_sccs(adj_list) [[1, 2, 3], [4, 5, 6]] def test_example(): adj_list = { 1: [2], 2: [3, 4], 3: [1], 4: [5], 5: [6], 6: [4] } sccs = find_sccs(adj_list) expected = [[4, 5, 6], [1, 2, 3]] assert all(sorted(comp) in map(sorted, sccs) for comp in expected) def test_single_node(): adj_list = { 1: [] } sccs = find_sccs(adj_list) expected = [[1]] assert all(sorted(comp) in map(sorted, sccs) for comp in expected) def test_disconnected_graph(): adj_list = { 1: [2], 2: [1], 3: [4], 4: [3] } sccs = find_sccs(adj_list) expected = [[1, 2], [3, 4]] assert all(sorted(comp) in map(sorted, sccs) for comp in expected) def test_complex_graph(): adj_list = { 1: [2], 2: [3], 3: [1, 4], 4: [5], 5: [6, 7], 6: [5, 8], 7: [8], 8: [7] } sccs = find_sccs(adj_list) expected = [[1, 2, 3], [7, 8], [5, 6], [4]] assert all(sorted(comp) in map(sorted, sccs) for comp in expected) def test_empty_graph(): adj_list = {} sccs = find_sccs(adj_list) expected = [] assert sccs == expected","solution":"from typing import List, Dict def find_sccs(adj_list: Dict[int, List[int]]) -> List[List[int]]: Determine all the strongly connected components in a directed graph using Tarjan's algorithm. Parameters: adj_list (Dict[int, List[int]]): The adjacency list representation of the graph. Returns: List[List[int]]: A list containing all SCCs, each represented as a list of vertex ids. index = 0 stack = [] indices = {} lowlink = {} on_stack = {} sccs = [] def strongconnect(node): nonlocal index # Set the depth index for node to the smallest unused index indices[node] = lowlink[node] = index index += 1 stack.append(node) on_stack[node] = True # Consider successors of node for neighbor in adj_list[node]: if neighbor not in indices: # Successor neighbor has not yet been visited; recur on it strongconnect(neighbor) lowlink[node] = min(lowlink[node], lowlink[neighbor]) elif on_stack[neighbor]: # Successor neighbor is in the stack and hence in the current SCC lowlink[node] = min(lowlink[node], indices[neighbor]) # If node is a root node, pop the stack and generate an SCC if lowlink[node] == indices[node]: scc = [] while True: w = stack.pop() on_stack[w] = False scc.append(w) if w == node: break sccs.append(scc) for node in adj_list: if node not in indices: strongconnect(node) return sccs"},{"question":"from typing import List def largest_number(nums: List[int]) -> str: Function to arrange numbers to form the largest possible number. Args: nums (List[int]): A list of non-negative integers. Returns: str: The largest number formed by arranging the input integers. Examples: >>> largest_number([10, 2]) '210' >>> largest_number([3, 30, 34, 5, 9]) '9534330' >>> largest_number([1]) '1' >>> largest_number([10]) '10'","solution":"from functools import cmp_to_key from typing import List def largest_number(nums: List[int]) -> str: Function to arrange numbers to form the largest possible number. Args: nums (List[int]): A list of non-negative integers. Returns: str: The largest number formed by arranging the input integers. def compare(x, y): # Custom comparator function if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert all numbers to strings for custom comparison strs = list(map(str, nums)) # Sort using the custom comparator strs.sort(key=cmp_to_key(compare)) # Join the result to form the largest number largest_num = ''.join(strs) # Handle the case where we have only zeros return largest_num if largest_num[0] != '0' else '0'"},{"question":"def find_average_height_iterative(students: list[dict[str, float]]) -> float: Calculates the average height of students using an iterative approach. Raises ValueError if the student list is empty. >>> students = [ ... {\\"name\\": \\"Alice\\", \\"height\\": 160.0}, ... {\\"name\\": \\"Bob\\", \\"height\\": 175.5}, ... {\\"name\\": \\"Charlie\\", \\"height\\": 168.2} ... ] >>> find_average_height_iterative(students) 167.9 >>> students = [] >>> find_average_height_iterative(students) ValueError: student list is empty def find_average_height_recursive(students: list[dict[str, float]], left: int, right: int) -> float: Calculates the average height of students using a divide-and-conquer (recursive) approach. Raises ValueError if the student list is empty. Handles invalid range indices properly. >>> students = [ ... {\\"name\\": \\"Alice\\", \\"height\\": 160.0}, ... {\\"name\\": \\"Bob\\", \\"height\\": 175.5}, ... {\\"name\\": \\"Charlie\\", \\"height\\": 168.2} ... ] >>> find_average_height_recursive(students, 0, len(students) - 1) 167.9 >>> students = [] >>> find_average_height_recursive(students, 0, 0) ValueError: student list is empty >>> students = [ ... {\\"name\\": \\"Alice\\", \\"height\\": 160.0}, ... {\\"name\\": \\"Bob\\", \\"height\\": 175.5} ... ] >>> find_average_height_recursive(students, 1, 0) IndexError: invalid range indices","solution":"def find_average_height_iterative(students): Calculates the average height of students using an iterative approach. Raises ValueError if the student list is empty. if not students: raise ValueError(\\"student list is empty\\") total_height = sum(student['height'] for student in students) return total_height / len(students) def find_average_height_recursive(students, left, right): Calculates the average height of students using a divide-and-conquer (recursive) approach. Raises ValueError if the student list is empty. Handles invalid range indices properly. if not students: raise ValueError(\\"student list is empty\\") if left > right: raise IndexError(\\"invalid range indices\\") if left == right: return students[left]['height'] mid = (left + right) // 2 left_avg = find_average_height_recursive(students, left, mid) right_avg = find_average_height_recursive(students, mid + 1, right) num_left = (mid - left + 1) num_right = (right - mid) return (left_avg * num_left + right_avg * num_right) / (num_left + num_right)"},{"question":"def is_balanced(s: str) -> bool: Determine if a string containing brackets and wildcards is balanced. >>> is_balanced(\\"(*)\\") True >>> is_balanced(\\"(*))\\") True >>> is_balanced(\\"(()*\\") True >>> is_balanced(\\")*(\\") False pass","solution":"def is_balanced(s: str) -> bool: Determine if a string with brackets and wildcards is balanced. Parameters: s (str): The input string containing '(', ')', and '*'. Returns: bool: True if the string is balanced, False otherwise. # Initialize two counters to track the possible minimum and maximum number of # unmatched open brackets '(' at any position in the string. min_open = 0 max_open = 0 for char in s: if char == '(': min_open += 1 max_open += 1 elif char == ')': if min_open > 0: min_open -= 1 max_open -= 1 elif char == '*': if min_open > 0: min_open -= 1 max_open += 1 # If at any point, the maximum number of unmatched open brackets goes below 0, # it means we have unbalanced closing brackets. if max_open < 0: return False # After processing all characters, if there are no unmatched open brackets, # return True. Otherwise, return False. return min_open == 0"},{"question":"def reverse_words(s: str) -> str: Reverse the characters in each word of the string while preserving whitespace and initial word order. Parameters: s (str): The input string containing words separated by spaces. Returns: str: The string with each word's characters reversed. Examples: >>> reverse_words(\\"Let's take LeetCode contest\\") \\"s'teL ekat edoCteeL tsetnoc\\" >>> reverse_words(\\" hello world \\") \\" olleh dlrow \\" >>> reverse_words(\\"a b c d e\\") \\"a b c d e\\" >>> reverse_words(\\"\\") \\"\\" >>> reverse_words(\\" \\") \\" \\" >>> reverse_words(\\"HeLLo WoRLd\\") \\"oLLeH dLRoW\\" >>> reverse_words(\\"Hello, world!\\") \\",olleH !dlrow\\"","solution":"def reverse_words(s: str) -> str: Reverse the characters in each word of the string while preserving whitespace and initial word order. Parameters: s (str): The input string containing words separated by spaces. Returns: str: The string with each word's characters reversed. # Split the string by whitespaces words = s.split(' ') # Reverse each word reversed_words = [word[::-1] for word in words] # Join them back with a single space separator return ' '.join(reversed_words)"},{"question":"from typing import List def longest_common_prefix(strs: List[str]) -> str: Returns the longest common prefix of an array of strings. If there is no common prefix, returns an empty string. >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" >>> longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) == \\"inters\\" >>> longest_common_prefix([\\"a\\"]) == \\"a\\" >>> longest_common_prefix([\\"aaa\\", \\"aa\\", \\"aaa\\"]) == \\"aa\\" >>> longest_common_prefix([\\"c\\", \\"c\\"]) == \\"c\\" >>> longest_common_prefix([\\"ab\\", \\"a\\"]) == \\"a\\" >>> longest_common_prefix([]) == \\"\\" >>> longest_common_prefix([\\"ab\\", \\"ab\\", \\"ab\\"]) == \\"ab\\" >>> longest_common_prefix([\\"flower\\", \\"\\"]) == \\"\\" pass","solution":"def longest_common_prefix(strs): Returns the longest common prefix of an array of strings. If there is no common prefix, returns an empty string. if not strs: return \\"\\" # Start by assuming the longest common prefix is the first string prefix = strs[0] for string in strs[1:]: while string[:len(prefix)] != prefix and prefix: prefix = prefix[:len(prefix)-1] if not prefix: break return prefix"},{"question":"def is_magic_square(square: List[List[int]]) -> bool: Check if a given 3x3 square is a magic square. :param square: List of lists representing the 3x3 square. :return: Boolean indicating if the square is a magic square. def count_magic_squares() -> int: Find and count all possible unique 3x3 magic squares that can be formed using numbers 1 to 9. :return: the total number of unique 3x3 magic squares. >>> count_magic_squares() 8 from itertools import permutations def test_is_magic_square(): assert is_magic_square([[2, 7, 6], [9, 5, 1], [4, 3, 8]]) is True assert is_magic_square([[8, 1, 6], [3, 5, 7], [4, 9, 2]]) is True assert is_magic_square([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) is False def test_count_magic_squares(): assert count_magic_squares() == 8","solution":"from itertools import permutations def is_magic_square(square): Check if a given 3x3 square is a magic square. :param square: List of lists representing the 3x3 square. :return: Boolean indicating if the square is a magic square. # Calculate the sums of rows, columns, and diagonals sums = [ sum(square[0]), sum(square[1]), sum(square[2]), # Rows sum(square[i][0] for i in range(3)), # Column 1 sum(square[i][1] for i in range(3)), # Column 2 sum(square[i][2] for i in range(3)), # Column 3 sum(square[i][i] for i in range(3)), # Diagonal 1 sum(square[i][2 - i] for i in range(3)) # Diagonal 2 ] # All sums should be the same and equal to 15 for a valid magic square return all(s == 15 for s in sums) def count_magic_squares() -> int: Find and count all possible unique 3x3 magic squares that can be formed using numbers 1 to 9. :return: the total number of unique 3x3 magic squares. count = 0 for perm in permutations(range(1, 10)): square = [ perm[:3], perm[3:6], perm[6:] ] if is_magic_square(square): count += 1 return count"},{"question":"from typing import List def snake_matrix(rows: int, columns: int) -> List[List[int]]: Generates a snake-like pattern matrix with the given number of rows and columns. >>> snake_matrix(3, 4) [ [1, 2, 3, 4], [8, 7, 6, 5], [9, 10, 11, 12] ] >>> snake_matrix(4, 3) [ [1, 2, 3], [6, 5, 4], [7, 8, 9], [12, 11, 10] ] >>> snake_matrix(1, 1) [ [1] ] >>> snake_matrix(2, 2) [ [1, 2], [4, 3] ] >>> snake_matrix(5, 1) [ [1], [2], [3], [4], [5] ] >>> snake_matrix(1, 5) [ [1, 2, 3, 4, 5] ]","solution":"from typing import List def snake_matrix(rows: int, columns: int) -> List[List[int]]: Generates a snake-like pattern matrix with the given number of rows and columns. matrix = [[0] * columns for _ in range(rows)] num = 1 for r in range(rows): if r % 2 == 0: for c in range(columns): matrix[r][c] = num num += 1 else: for c in range(columns - 1, -1, -1): matrix[r][c] = num num += 1 return matrix"},{"question":"[Completion Task in Python] Implement a function \`craft_item\` that takes an inventory of components and a recipe for an item. The function should check if the item can be crafted using the available components and update the inventory accordingly. Function Signature: def craft_item(inventory: dict, recipe: dict) -> bool: Parameters: - inventory (dict): A dictionary where keys are component names and values are the number of components available. - recipe (dict): A dictionary where keys are component names and values are the number of components needed to craft the item. Returns: - bool: True if the item can be crafted, False otherwise. Example: >>> inventory = {\\"wood\\": 10, \\"metal\\": 5, \\"plastic\\": 2} >>> recipe = {\\"wood\\": 3, \\"metal\\": 2, \\"plastic\\": 1} >>> craft_item(inventory, recipe) True >>> inventory {'wood': 7, 'metal': 3, 'plastic': 1} >>> inventory = {\\"wood\\": 4, \\"metal\\": 1, \\"plastic\\": 2} >>> recipe = {\\"wood\\": 5, \\"metal\\": 2, \\"plastic\\": 1} >>> craft_item(inventory, recipe) False >>> inventory {'wood': 4, 'metal': 1, 'plastic': 2}","solution":"def craft_item(inventory: dict, recipe: dict) -> bool: Attempts to craft an item based on the provided recipe and updates the inventory accordingly. Parameters: inventory (dict): A dictionary where keys are component names and values are the number of components available. recipe (dict): A dictionary where keys are component names and values are the number of components needed to craft the item. Returns: bool: True if the item can be crafted, False otherwise. # Check if all required components are available in the necessary quantities for component, quantity_needed in recipe.items(): if inventory.get(component, 0) < quantity_needed: return False # If all components are available, deduct the quantities from the inventory for component, quantity_needed in recipe.items(): inventory[component] -= quantity_needed return True"},{"question":"from typing import List def rotate_90(matrix: List[List[int]]) -> List[List[int]]: Returns the matrix rotated by 90 degrees clockwise. return [list(row) for row in zip(*matrix[::-1])] def is_rotation(A: List[List[int]], B: List[List[int]]) -> bool: Check if matrix B is a rotation of matrix A by 90, 180, or 270 degrees. >>> A = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> B = [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ] >>> is_rotation(A, B) True >>> A = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> B = [ ... [9, 8, 7], ... [6, 5, 4], ... [3, 2, 1] ... ] >>> is_rotation(A, B) False >>> A = [ ... [1, 2], ... [3, 4] ... ] >>> B = [ ... [4, 3], ... [2, 1] ... ] >>> is_rotation(A, B) True","solution":"from typing import List def rotate_90(matrix: List[List[int]]) -> List[List[int]]: Returns the matrix rotated by 90 degrees clockwise. return [list(row) for row in zip(*matrix[::-1])] def is_rotation(A: List[List[int]], B: List[List[int]]) -> bool: Check if matrix B is a rotation of matrix A by 90, 180, or 270 degrees. if A == B: return True for _ in range(3): A = rotate_90(A) if A == B: return True return False"},{"question":"from typing import List def shortest_palindrome_extension(s: str) -> str: Returns the shortest palindromic string by adding characters to the end of the given string s. >>> shortest_palindrome_extension(\\"race\\") 'racecar' >>> shortest_palindrome_extension(\\"ab\\") 'aba' >>> shortest_palindrome_extension(\\"a\\") 'a' >>> shortest_palindrome_extension(\\"abcd\\") 'abcdcba' >>> shortest_palindrome_extension(\\"abab\\") 'ababa' >>> shortest_palindrome_extension(\\"abcba\\") 'abcba' >>> shortest_palindrome_extension(\\"aa\\") 'aa' >>> shortest_palindrome_extension(\\"aabb\\") 'aabbaa'","solution":"def shortest_palindrome_extension(s): Returns the shortest palindromic string by adding characters to the end of the given string s. # Create the reversed version of the string rev_s = s[::-1] # Combine the string with its reverse and separate them with a special character that doesn't appear in the string combined = s + \\"#\\" + rev_s # Table to store the length of the longest prefix which is also a suffix lps = [0] * len(combined) # KMP table construction length = 0 i = 1 while i < len(combined): if combined[i] == combined[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 # The length of the longest palindromic suffix is lps[-1] shortest_palindrome = s + rev_s[lps[-1]:] return shortest_palindrome"},{"question":"def min_window_substring(s: str, t: str) -> str: Find the smallest window in string \`s\` that contains all characters of string \`t\`. >>> min_window_substring(\\"ADOBECODEBANC\\", \\"ABC\\") == \\"BANC\\" >>> min_window_substring(\\"a\\", \\"a\\") == \\"a\\" >>> min_window_substring(\\"a\\", \\"aa\\") == \\"\\"","solution":"def min_window_substring(s: str, t: str) -> str: from collections import Counter, defaultdict if not s or not t or len(s) < len(t): return \\"\\" # Create a frequency counter for t dict_t = Counter(t) required = len(dict_t) # Initialize the window pointers and required variables l, r = 0, 0 formed = 0 window_counts = defaultdict(int) # Resultant variables - (window length, left, right) ans = float(\\"inf\\"), None, None while r < len(s): character = s[r] window_counts[character] += 1 # Check if character frequency matches the requirement in t if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 # Try to contract the window until the point where it ceases to be 'desirable' while l <= r and formed == required: character = s[l] # Save the smallest window until now if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s[ans[1] : ans[2] + 1]"},{"question":"[Completion Task in Python] class CustomList: def __init__(self): self.elements = [] def add(self, value: int) -> None: pass def remove(self, value: int) -> None: pass def query(self, k: int) -> int: pass","solution":"import bisect class CustomList: def __init__(self): self.elements = [] def add(self, value: int) -> None: bisect.insort(self.elements, value) def remove(self, value: int) -> None: self.elements = list(filter(lambda x: x != value, self.elements)) def query(self, k: int) -> int: if 1 <= k <= len(self.elements): return self.elements[k - 1] else: raise IndexError(\\"k is out of range\\")"},{"question":"def is_increasing_hill(arr: list) -> bool: Checks if the given list of integers forms a valid increasing hill pattern. :param arr: list of integers :return: True if valid, False otherwise Example: >>> is_increasing_hill([1, 2, 3, 2, 1]) True","solution":"def is_increasing_hill(arr: list) -> bool: Checks if the given list of integers forms a valid increasing hill pattern. :param arr: list of integers :return: True if valid, False otherwise n = len(arr) if n < 3: return False i = 0 # Traverse uphill while i + 1 < n and arr[i] < arr[i + 1]: i += 1 # Peak can't be first or last element if i == 0 or i == n - 1: return False # Traverse downhill while i + 1 < n and arr[i] > arr[i + 1]: i += 1 # If we reached the end, it's a valid hill return i == n - 1"},{"question":"def min_cost_path(grid: list[list[int]]) -> int: Compute the minimum cost path in a grid from the top-left to the bottom-right corner. You can only move either down or right at any point in time. >>> grid = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> min_cost_path(grid) 7 >>> grid = [ ... [10] ... ] >>> min_cost_path(grid) 10","solution":"def min_cost_path(grid: list[list[int]]) -> int: Compute the minimum cost path in a grid from top-left to bottom-right where moving is only allowed down or right. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"def max_profit(prices): Finds the maximum profit possible by buying on one day and selling on another later day. Parameters: prices (list of int/float): A list of stock prices where each element represents the price on a given day. Returns: tuple: A tuple containing the maximum profit, the day to buy (index), and the day to sell (index). If no profit is possible, returns (0, -1, -1). >>> max_profit([7, 1, 5, 3, 6, 4]) (5, 1, 4) >>> max_profit([7, 6, 4, 3, 1]) (0, -1, -1) >>> max_profit([]) (0, -1, -1) >>> max_profit([5]) (0, -1, -1) >>> max_profit([1, 5]) (4, 0, 1) >>> max_profit([5, 1]) (0, -1, -1) >>> max_profit([3, 3, 3, 3, 3]) (0, -1, -1)","solution":"def max_profit(prices): Finds the maximum profit possible by buying on one day and selling on another later day. Parameters: prices (list of int/float): A list of stock prices where each element represents the price on a given day. Returns: tuple: A tuple containing the maximum profit, the day to buy (index), and the day to sell (index). If no profit is possible, returns (0, -1, -1). if len(prices) < 2: return (0, -1, -1) min_price = prices[0] min_day = 0 max_profit = 0 buy_day = -1 sell_day = -1 for i in range(1, len(prices)): if prices[i] - min_price > max_profit: max_profit = prices[i] - min_price buy_day = min_day sell_day = i if prices[i] < min_price: min_price = prices[i] min_day = i if max_profit == 0: return (0, -1, -1) return (max_profit, buy_day, sell_day)"},{"question":"def are_anagrams(string1: str, string2: str) -> bool: Determine if two strings are anagrams of each other, ignoring spaces, punctuation, and case mismatches. >>> are_anagrams(\\"Astronomer\\", \\"Moon starer\\") True >>> are_anagrams(\\"Hello, World!\\", \\"dlroW ,olleH\\") True >>> are_anagrams(\\"Programming\\", \\"Gram Ring Mop\\") True >>> are_anagrams(\\"One\\", \\"Two\\") False","solution":"import re def are_anagrams(string1: str, string2: str) -> bool: Determine if two strings are anagrams of each other, ignoring spaces, punctuation, and case mismatches. # Remove non-alphabetical characters and convert to lower case filtered_string1 = re.sub(r'[^A-Za-z]', '', string1).lower() filtered_string2 = re.sub(r'[^A-Za-z]', '', string2).lower() # Sort the characters and compare return sorted(filtered_string1) == sorted(filtered_string2)"},{"question":"class TextBuffer: def __init__(self): Initialize an empty buffer. pass def insert(self, text: str, position: int) -> None: Insert the given text at the specified position in the buffer. Args: - text (str): The text to insert. - position (int): The position at which to insert the text. pass def delete(self, start: int, end: int) -> None: Delete the substring from start to end in the buffer. Args: - start (int): The starting position of the substring to delete. - end (int): The ending position of the substring to delete. pass def replace(self, start: int, end: int, replacement: str) -> None: Replace the substring from start to end with the replacement text. Args: - start (int): The starting position of the substring to replace. - end (int): The ending position of the substring to replace. - replacement (str): The text to replace the substring with. pass def get_text(self) -> str: Retrieve the current text in the buffer. Returns: - str: The current text in the buffer. pass # Example usage buffer = TextBuffer() # Insert text at position 0 buffer.insert(\\"Hello\\", 0) assert buffer.get_text() == \\"Hello\\" # Insert text at position 5 buffer.insert(\\" World\\", 5) assert buffer.get_text() == \\"Hello World\\" # Replace text from position 6 to 11 with \\"Everyone\\" buffer.replace(6, 11, \\"Everyone\\") assert buffer.get_text() == \\"Hello Everyone\\" # Delete text from position 5 to 13 buffer.delete(5, 13) assert buffer.get_text() == \\"Hello\\"","solution":"class TextBuffer: def __init__(self): Initialize an empty buffer. self.buffer = [] def insert(self, text: str, position: int) -> None: Insert the given text at the specified position in the buffer. Args: - text (str): The text to insert. - position (int): The position at which to insert the text. if position < 0 or position > len(self.buffer): raise ValueError(\\"Position out of range\\") self.buffer = self.buffer[:position] + list(text) + self.buffer[position:] def delete(self, start: int, end: int) -> None: Delete the substring from start to end in the buffer. Args: - start (int): The starting position of the substring to delete. - end (int): The ending position of the substring to delete. if start < 0 or end > len(self.buffer) or start > end: raise ValueError(\\"Invalid start or end position\\") self.buffer = self.buffer[:start] + self.buffer[end:] def replace(self, start: int, end: int, replacement: str) -> None: Replace the substring from start to end with the replacement text. Args: - start (int): The starting position of the substring to replace. - end (int): The ending position of the substring to replace. - replacement (str): The text to replace the substring with. if start < 0 or end > len(self.buffer) or start > end: raise ValueError(\\"Invalid start or end position\\") self.buffer = self.buffer[:start] + list(replacement) + self.buffer[end:] def get_text(self) -> str: Retrieve the current text in the buffer. Returns: - str: The current text in the buffer. return ''.join(self.buffer)"},{"question":"def find_missing_number(nums: list[int]) -> int: This function takes a list of distinct integers in the range from 1 to n (inclusive) with one integer missing, and returns the missing integer. >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) 6 >>> find_missing_number([1, 2, 3, 5]) 4 >>> find_missing_number([6, 2, 3, 4, 5, 1]) 7 >>> find_missing_number([2]) 1","solution":"def find_missing_number(nums: list[int]) -> int: This function takes a list of distinct integers in the range from 1 to n (inclusive) with one integer missing, and returns the missing integer. n = len(nums) + 1 # Since one number is missing total_sum = n * (n + 1) // 2 # Sum of all integers from 1 to n actual_sum = sum(nums) # Sum of integers present in the list missing_number = total_sum - actual_sum # The missing number return missing_number"},{"question":"class EmployeeDatabase: def __init__(self): Initialize the EmployeeDatabase with an empty dictionary. self.database = {} def add_employee(self, employee_id, name, email, department): Adds a new employee to the database. :param employee_id: Unique identifier for the employee. :param name: Name of the employee. :param email: Email address of the employee. :param department: Department to which the employee belongs. :raises ValueError: If the employee ID already exists. def update_employee(self, employee_id, name=None, email=None, department=None): Updates the details of an existing employee. :param employee_id: Unique identifier for the employee. :param name: (Optional) New name of the employee. :param email: (Optional) New email address of the employee. :param department: (Optional) New department of the employee. :raises ValueError: If the employee ID does not exist. def get_employee(self, employee_id): Retrieves the details of an employee by their ID. :param employee_id: Unique identifier for the employee. :return: Dictionary containing the employee details. :raises ValueError: If the employee ID does not exist. import pytest def test_add_employee(): db = EmployeeDatabase() db.add_employee(1, \\"John Doe\\", \\"johndoe@example.com\\", \\"Engineering\\") assert db.get_employee(1) == { 'name': 'John Doe', 'email': 'johndoe@example.com', 'department': 'Engineering' } def test_add_employee_with_existing_id(): db = EmployeeDatabase() db.add_employee(1, \\"John Doe\\", \\"johndoe@example.com\\", \\"Engineering\\") with pytest.raises(ValueError, match=\\"Employee ID already exists.\\"): db.add_employee(1, \\"Jane Smith\\", \\"janesmith@example.com\\", \\"Marketing\\") def test_update_employee(): db = EmployeeDatabase() db.add_employee(1, \\"John Doe\\", \\"johndoe@example.com\\", \\"Engineering\\") db.update_employee(1, email=\\"john.doe@company.com\\") assert db.get_employee(1) == { 'name': 'John Doe', 'email': 'john.doe@company.com', 'department': 'Engineering' } db.update_employee(1, name=\\"Johnathan Doe\\", department=\\"Marketing\\") assert db.get_employee(1) == { 'name': 'Johnathan Doe', 'email': 'john.doe@company.com', 'department': 'Marketing' } def test_update_non_existent_employee(): db = EmployeeDatabase() with pytest.raises(ValueError, match=\\"Employee not found.\\"): db.update_employee(1, email=\\"john.doe@company.com\\") def test_get_employee(): db = EmployeeDatabase() db.add_employee(1, \\"John Doe\\", \\"johndoe@example.com\\", \\"Engineering\\") assert db.get_employee(1) == { 'name': 'John Doe', 'email': 'johndoe@example.com', 'department': 'Engineering' } def test_get_non_existent_employee(): db = EmployeeDatabase() with pytest.raises(ValueError, match=\\"Employee not found.\\"): db.get_employee(1)","solution":"class EmployeeDatabase: def __init__(self): self.database = {} def add_employee(self, employee_id, name, email, department): Adds a new employee to the database. :param employee_id: Unique identifier for the employee. :param name: Name of the employee. :param email: Email address of the employee. :param department: Department to which the employee belongs. :raises ValueError: If the employee ID already exists. if employee_id in self.database: raise ValueError(\\"Employee ID already exists.\\") self.database[employee_id] = { 'name': name, 'email': email, 'department': department } def update_employee(self, employee_id, name=None, email=None, department=None): Updates the details of an existing employee. :param employee_id: Unique identifier for the employee. :param name: (Optional) New name of the employee. :param email: (Optional) New email address of the employee. :param department: (Optional) New department of the employee. :raises ValueError: If the employee ID does not exist. if employee_id not in self.database: raise ValueError(\\"Employee not found.\\") if name: self.database[employee_id]['name'] = name if email: self.database[employee_id]['email'] = email if department: self.database[employee_id]['department'] = department def get_employee(self, employee_id): Retrieves the details of an employee by their ID. :param employee_id: Unique identifier for the employee. :return: Dictionary containing the employee details. :raises ValueError: If the employee ID does not exist. if employee_id not in self.database: raise ValueError(\\"Employee not found.\\") return self.database[employee_id]"},{"question":"def a_star_search(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]: Implement the A* search algorithm to find the shortest path in a grid. Args: grid: A 2D list representing the grid where 0 indicates a traversable cell and 1 indicates a blocked cell. start: A tuple representing the starting node (x, y). goal: A tuple representing the goal node (x, y). Returns: A list of tuples representing the coordinates of the nodes in the shortest path from start to goal (inclusive). If no path exists, return an empty list. Examples: >>> grid = [ ... [0, 1, 0, 0], ... [0, 1, 0, 1], ... [0, 0, 0, 1], ... [1, 1, 0, 0] ... ] >>> start = (0, 0) >>> goal = (3, 3) >>> a_star_search(grid, start, goal) [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2), (3, 3)] >>> grid = [ ... [0, 1], ... [1, 0] ... ] >>> start = (0, 0) >>> goal = (1, 1) >>> a_star_search(grid, start, goal) [] # Your code here","solution":"import heapq from typing import List, Tuple def a_star_search(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]: def heuristic(a, b): return abs(a[0] - b[0]) + abs(a[1] - b[1]) def get_neighbors(node): directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] for d in directions: neighbor = (node[0] + d[0], node[1] + d[1]) if (0 <= neighbor[0] < len(grid)) and (0 <= neighbor[1] < len(grid[0])) and grid[neighbor[0]][neighbor[1]] == 0: yield neighbor open_set = [] heapq.heappush(open_set, (0 + heuristic(start, goal), 0, start, None)) came_from = {} g_score = {start: 0} f_score = {start: heuristic(start, goal)} while open_set: current = heapq.heappop(open_set)[2] if current == goal: path = [] while current: path.append(current) current = came_from.get(current) return path[::-1] for neighbor in get_neighbors(current): tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal) heapq.heappush(open_set, (f_score[neighbor], tentative_g_score, neighbor, current)) return []"},{"question":"from typing import List, Dict, Union def compute_balances(transactions: List[Dict[str, Union[str, int]]]) -> Dict[str, int]: Compute the balance for each user after processing all transactions. >>> compute_balances([]) {} >>> compute_balances([ {\\"sender\\": \\"John\\", \\"receiver\\": \\"Jane\\", \\"amount\\": 100} ]) {\\"John\\": -100, \\"Jane\\": 100} >>> compute_balances([ {\\"sender\\": \\"Tom\\", \\"receiver\\": \\"Jerry\\", \\"amount\\": 500}, {\\"sender\\": \\"Jerry\\", \\"receiver\\": \\"Tom\\", \\"amount\\": 200} ]) {\\"Tom\\": -300, \\"Jerry\\": 300} pass def test_empty_transactions(): assert compute_balances([]) == {} def test_single_transaction(): assert compute_balances([ {\\"sender\\": \\"John\\", \\"receiver\\": \\"Jane\\", \\"amount\\": 100} ]) == {\\"John\\": -100, \\"Jane\\": 100} def test_multiple_transactions(): assert compute_balances([ {\\"sender\\": \\"Tom\\", \\"receiver\\": \\"Jerry\\", \\"amount\\": 500}, {\\"sender\\": \\"Jerry\\", \\"receiver\\": \\"Tom\\", \\"amount\\": 200} ]) == {\\"Tom\\": -300, \\"Jerry\\": 300} def test_complex_case(): transactions = [ {\\"sender\\": \\"Alice\\", \\"receiver\\": \\"Bob\\", \\"amount\\": 50}, {\\"sender\\": \\"Bob\\", \\"receiver\\": \\"Charlie\\", \\"amount\\": 25}, {\\"sender\\": \\"Alice\\", \\"receiver\\": \\"Charlie\\", \\"amount\\": 30} ] expected_balances = { \\"Alice\\": -80, \\"Bob\\": 25, \\"Charlie\\": 55 } assert compute_balances(transactions) == expected_balances def test_all_users_start_with_zero(): transactions = [ {\\"sender\\": \\"A\\", \\"receiver\\": \\"B\\", \\"amount\\": 10}, {\\"sender\\": \\"B\\", \\"receiver\\": \\"C\\", \\"amount\\": 5}, {\\"sender\\": \\"A\\", \\"receiver\\": \\"C\\", \\"amount\\": 20} ] expected_balances = { \\"A\\": -30, \\"B\\": 5, \\"C\\": 25 } assert compute_balances(transactions) == expected_balances","solution":"from typing import List, Dict, Union def compute_balances(transactions: List[Dict[str, Union[str, int]]]) -> Dict[str, int]: # Initialize an empty dictionary to store the balances balances = {} # Iterate through each transaction to update balances for transaction in transactions: sender = transaction[\\"sender\\"] receiver = transaction[\\"receiver\\"] amount = transaction[\\"amount\\"] # Deduct the amount from the sender's balance if sender not in balances: balances[sender] = 0 # Initialize sender balance if not already in the dictionary balances[sender] -= amount # Add the amount to the receiver's balance if receiver not in balances: balances[receiver] = 0 # Initialize receiver balance if not already in the dictionary balances[receiver] += amount return balances"},{"question":"import json from typing import Any class PostSerializer: def serialize(self, data: Any) -> str: Serialize the nested data structure into a JSON string. Parameters: - data (Any): The data to serialize, which can be a nested combination of lists, dictionaries, and strings. Returns: - str: The serialized JSON string representation of the data. pass def deserialize(self, data: str) -> Any: Deserialize the JSON string back into the original nested data structure. Parameters: - data (str): The JSON string representation of the data to deserialize. Returns: - Any: The original nested data structure. pass # Example usage: serializer = PostSerializer() # Example post data post = { \\"user\\": \\"john_doe\\", \\"content\\": [ \\"Hello, world!\\", {\\"comments\\": [\\"Nice post!\\", \\"Thanks for sharing!\\"]}, {\\"likes\\": [\\"alice\\", \\"bob\\"]} ] } # Serialize the post serialized_post = serializer.serialize(post) print(serialized_post) # Deserialize the post deserialized_post = serializer.deserialize(serialized_post) print(deserialized_post)","solution":"import json from typing import Any class PostSerializer: def serialize(self, data: Any) -> str: Serialize the nested data structure into a JSON string. Parameters: - data (Any): The data to serialize, which can be a nested combination of lists, dictionaries, and strings. Returns: - str: The serialized JSON string representation of the data. return json.dumps(data) def deserialize(self, data: str) -> Any: Deserialize the JSON string back into the original nested data structure. Parameters: - data (str): The JSON string representation of the data to deserialize. Returns: - Any: The original nested data structure. return json.loads(data)"},{"question":"from typing import List, Tuple def sort_tuples(arr: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Sorts a list of tuples primarily by the first integer in ascending order and secondarily by the second integer in descending order. Parameters: arr (List[Tuple[int, int]]): A list of tuples, where each tuple consists of two integers. Returns: List[Tuple[int, int]]: The list of tuples, sorted according to the specified criteria. >>> sort_tuples([(1, 3), (4, 2), (2, 6), (1, 5), (4, 1), (3, 4)]) [(1, 5), (1, 3), (2, 6), (3, 4), (4, 2), (4, 1)]","solution":"from typing import List, Tuple def sort_tuples(arr: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Sorts a list of tuples primarily by the first integer in ascending order and secondarily by the second integer in descending order. Parameters: arr (List[Tuple[int, int]]): A list of tuples, where each tuple consists of two integers. Returns: List[Tuple[int, int]]: The list of tuples, sorted according to the specified criteria. # Sort the list with a key that does a primary sort on the first element (ascending) # and a secondary sort on the second element (descending) return sorted(arr, key=lambda x: (x[0], -x[1]))"},{"question":"def fibonacci_series(n: int) -> list[int]: Generate a list of the first n Fibonacci numbers. Args: n (int): The number of Fibonacci numbers to generate. Returns: list[int]: A list containing the first n Fibonacci numbers. Raises: ValueError: If n is not a positive integer. Examples: >>> fibonacci_series(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> fibonacci_series(5) [0, 1, 1, 2, 3] >>> fibonacci_series(1) [0]","solution":"def fibonacci_series(n: int) -> list[int]: if not isinstance(n, int) or n <= 0: raise ValueError(\\"Input must be a positive integer.\\") fibs = [0, 1] # Initial values for the first two Fibonacci numbers if n == 1: return [0] for i in range(2, n): fibs.append(fibs[-1] + fibs[-2]) return fibs[:n]"},{"question":"class Node: def __init__(self, key): self.left = None self.right = None self.value = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.value: if node.left is None: node.left = Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = Node(key) else: self._insert(node.right, key) def find_min(self): Find the minimum value present in the BST. >>> tree = BST() >>> tree.insert(10) >>> tree.insert(20) >>> tree.insert(5) >>> tree.insert(1) >>> tree.insert(15) >>> tree.find_min() 1 pass def find_max(self): Find the maximum value present in the BST. >>> tree = BST() >>> tree.insert(10) >>> tree.insert(20) >>> tree.insert(5) >>> tree.insert(1) >>> tree.insert(15) >>> tree.find_max() 20 pass def calculate_height(self): Calculate the height of the BST. >>> tree = BST() >>> tree.insert(10) >>> tree.insert(20) >>> tree.insert(5) >>> tree.insert(1) >>> tree.insert(15) >>> tree.calculate_height() 2 pass","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.value = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.value: if node.left is None: node.left = Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = Node(key) else: self._insert(node.right, key) def find_min(self): if self.root is None: return None return self._find_min(self.root) def _find_min(self, node): current = node while current.left is not None: current = current.left return current.value def find_max(self): if self.root is None: return None return self._find_max(self.root) def _find_max(self, node): current = node while current.right is not None: current = current.right return current.value def calculate_height(self): if self.root is None: return 0 return self._calculate_height(self.root) def _calculate_height(self, node): if node is None: return -1 left_height = self._calculate_height(node.left) right_height = self._calculate_height(node.right) return max(left_height, right_height) + 1"},{"question":"def priority_encoder(inputs: list) -> str: Implement an 8-to-3 priority encoder. :param inputs: A list of 8 integers (0 or 1). :return: The 3-bit binary representation of the highest-priority input set to 1, or None if all inputs are 0. Examples: >>> priority_encoder([0, 0, 0, 0, 0, 0, 0, 0]) None >>> priority_encoder([0, 1, 1, 1, 0, 0, 0, 0]) '001' >>> priority_encoder([0, 0, 0, 1, 0, 0, 0, 0]) '011' >>> priority_encoder([1, 0, 0, 0, 1, 1, 0, 1]) '000' >>> priority_encoder([0, 0, 0, 0, 0, 0, 0, 1]) '111' >>> priority_encoder([0, 0, 0, -1, 0, 0, 0, 0]) Traceback (most recent call last): ... ValueError: Each input must be 0 or 1","solution":"def priority_encoder(inputs: list) -> str: Implement an 8-to-3 priority encoder. :param inputs: A list of 8 integers (0 or 1). :return: The 3-bit binary representation of the highest-priority input set to 1, or None if all inputs are 0. if len(inputs) != 8: raise ValueError(\\"List must contain exactly 8 elements\\") for i in range(8): if inputs[i] not in {0, 1}: raise ValueError(\\"Each input must be 0 or 1\\") for i in range(8): if inputs[i] == 1: return f'{i:03b}' return None"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def inorder(self): Perform an inorder traversal of the binary tree. >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.left = TreeNode(3) >>> tree = BinaryTree(root) >>> tree.inorder() [1, 3, 2] >>> empty_tree = BinaryTree() >>> empty_tree.inorder() []","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def inorder(self): result = [] def _inorder(node): if node: _inorder(node.left) result.append(node.value) _inorder(node.right) _inorder(self.root) return result"},{"question":"from typing import List class MatrixOperations: def __init__(self, matrix: List[List[int]]): Initialize the class with the given matrix. def matrix_addition(self, other: 'MatrixOperations') -> 'MatrixOperations': Add the current matrix with another matrix having the same dimensions. >>> matrix1 = MatrixOperations([[1, 2, 3], [4, 5, 6]]) >>> matrix2 = MatrixOperations([[7, 8, 9], [10, 11, 12]]) >>> added_matrix = matrix1.matrix_addition(matrix2) >>> print(added_matrix) 8 10 12 14 16 18 def matrix_subtraction(self, other: 'MatrixOperations') -> 'MatrixOperations': Subtract another matrix from the current matrix having the same dimensions. >>> matrix1 = MatrixOperations([[1, 2, 3], [4, 5, 6]]) >>> matrix2 = MatrixOperations([[7, 8, 9], [10, 11, 12]]) >>> subtracted_matrix = matrix1.matrix_subtraction(matrix2) >>> print(subtracted_matrix) -6 -6 -6 -6 -6 -6 def matrix_multiplication(self, other: 'MatrixOperations') -> 'MatrixOperations': Multiply the current matrix with another matrix with compatible dimensions. >>> matrix1 = MatrixOperations([[1, 2, 3], [4, 5, 6]]) >>> matrix3 = MatrixOperations([[1, 2], [3, 4], [5, 6]]) >>> multiplied_matrix = matrix1.matrix_multiplication(matrix3) >>> print(multiplied_matrix) 22 28 49 64 def __str__(self) -> str: Return a string representation of the matrix with rows converted to strings and joined by newlines. def test_matrix_addition(): matrix1 = MatrixOperations([[1, 2, 3], [4, 5, 6]]) matrix2 = MatrixOperations([[7, 8, 9], [10, 11, 12]]) result = matrix1.matrix_addition(matrix2) expected_output = \\"8 10 12n14 16 18\\" assert str(result) == expected_output def test_matrix_subtraction(): matrix1 = MatrixOperations([[1, 2, 3], [4, 5, 6]]) matrix2 = MatrixOperations([[7, 8, 9], [10, 11, 12]]) result = matrix1.matrix_subtraction(matrix2) expected_output = \\"-6 -6 -6n-6 -6 -6\\" assert str(result) == expected_output def test_matrix_multiplication(): matrix1 = MatrixOperations([[1, 2, 3], [4, 5, 6]]) matrix3 = MatrixOperations([[1, 2], [3, 4], [5, 6]]) result = matrix1.matrix_multiplication(matrix3) expected_output = \\"22 28n49 64\\" assert str(result) == expected_output def test_invalid_addition_dimensions(): matrix1 = MatrixOperations([[1, 2], [3, 4]]) matrix2 = MatrixOperations([[5, 6, 7], [8, 9, 10]]) try: matrix1.matrix_addition(matrix2) assert False, \\"Expected ValueError for mismatched dimensions in addition\\" except ValueError: assert True def test_invalid_multiplication_dimensions(): matrix1 = MatrixOperations([[1, 2]]) matrix2 = MatrixOperations([[3, 4], [5, 6], [7, 8]]) try: matrix1.matrix_multiplication(matrix2) assert False, \\"Expected ValueError for mismatched dimensions in multiplication\\" except ValueError: assert True","solution":"from typing import List class MatrixOperations: def __init__(self, matrix: List[List[int]]): self.matrix = matrix def __validate_same_dimension(self, other: 'MatrixOperations'): if len(self.matrix) != len(other.matrix) or len(self.matrix[0]) != len(other.matrix[0]): raise ValueError(\\"Matrices must have the same dimensions for this operation.\\") def __validate_multiplication_dimension(self, other: 'MatrixOperations'): if len(self.matrix[0]) != len(other.matrix): raise ValueError(\\"Number of columns of the first matrix must be equal to the number of rows of the second matrix.\\") def matrix_addition(self, other: 'MatrixOperations') -> 'MatrixOperations': self.__validate_same_dimension(other) result = [ [self.matrix[i][j] + other.matrix[i][j] for j in range(len(self.matrix[0]))] for i in range(len(self.matrix)) ] return MatrixOperations(result) def matrix_subtraction(self, other: 'MatrixOperations') -> 'MatrixOperations': self.__validate_same_dimension(other) result = [ [self.matrix[i][j] - other.matrix[i][j] for j in range(len(self.matrix[0]))] for i in range(len(self.matrix)) ] return MatrixOperations(result) def matrix_multiplication(self, other: 'MatrixOperations') -> 'MatrixOperations': self.__validate_multiplication_dimension(other) result = [ [sum(self.matrix[i][k] * other.matrix[k][j] for k in range(len(self.matrix[0]))) for j in range(len(other.matrix[0]))] for i in range(len(self.matrix)) ] return MatrixOperations(result) def __str__(self) -> str: return 'n'.join([' '.join(map(str, row)) for row in self.matrix])"},{"question":"def hashtag_occurrence(post: str) -> dict: Counts the occurrences of each unique hashtag in the given post. Hashtags are case-insensitive and consist of alphanumeric characters and underscores. Parameters: post (str): The input post containing hashtags. Returns: dict: A dictionary with hashtags as keys and their counts as values. Example: >>> hashtag_occurrence(\\"#Hello #hello #World! How #are #you? #world\\") {'#hello': 2, '#world': 2, '#are': 1, '#you': 1} >>> hashtag_occurrence(\\"Check out #Python and #python3. Also, use #PYTHON and #PyThOn!\\") {'#python': 3, '#python3': 1} >>> hashtag_occurrence(\\"Today is a #GreatDay for #coding. #Great_Day indeed!\\") {'#greatday': 1, '#coding': 1, '#great_day': 1}","solution":"import re def hashtag_occurrence(post: str) -> dict: Counts the occurrences of each unique hashtag in the given post. Hashtags are case-insensitive and consist of alphanumeric characters and underscores. Parameters: post (str): The input post containing hashtags. Returns: dict: A dictionary with hashtags as keys and their counts as values. # Normalize the post to lowercase post = post.lower() # Find all valid hashtags using regular expression hashtags = re.findall(r'#w+', post) # Count occurrences of each hashtag hashtag_counts = {} for hashtag in hashtags: if hashtag in hashtag_counts: hashtag_counts[hashtag] += 1 else: hashtag_counts[hashtag] = 1 return hashtag_counts"},{"question":"import heapq class NetworkRouter: def __init__(self): # Initialization of the NetworkRouter with additional attributes for congestion and reliability metrics self.graph = {} self.latencies = {} self.reliabilities = {} self.route_cache = {} def add_edge(self, node1, node2, latency, reliability=1.0): Adds an edge to the network graph with given latency and reliability. pass # To be implemented def update_latency(self, edge, new_latency): Updates the latency of the specified edge. pass # To be implemented def update_reliability(self, edge, new_reliability): Updates the reliability of the specified edge. pass # To be implemented def shortest_path(self, start, end): Uses Dijkstra's algorithm, considering reliability, to find the shortest path between start and end. Implements caching for frequently used routes. pass # To be implemented # Example unit tests def test_add_edge(): router = NetworkRouter() router.add_edge('A', 'B', 5, 0.9) assert router.graph == {'A': [('B', 5, 0.9)], 'B': [('A', 5, 0.9)]} assert router.latencies == {('A', 'B'): 5, ('B', 'A'): 5} assert router.reliabilities == {('A', 'B'): 0.9, ('B', 'A'): 0.9} assert router.route_cache == {} def test_update_latency(): router = NetworkRouter() router.add_edge('A', 'B', 5, 0.9) router.update_latency(('A', 'B'), 10) assert router.graph == {'A': [('B', 10, 0.9)], 'B': [('A', 10, 0.9)]} assert router.latencies == {('A', 'B'): 10, ('B', 'A'): 10} assert router.route_cache == {} def test_update_reliability(): router = NetworkRouter() router.add_edge('A', 'B', 5, 0.9) router.update_reliability(('A', 'B'), 0.8) assert router.graph == {'A': [('B', 5, 0.8)], 'B': [('A', 5, 0.8)]} assert router.reliabilities == {('A', 'B'): 0.8, ('B', 'A'): 0.8} assert router.route_cache == {} def test_shortest_path(): router = NetworkRouter() router.add_edge('A', 'B', 5, 0.9) router.add_edge('B', 'C', 10, 0.95) router.add_edge('A', 'C', 20, 0.8) path = router.shortest_path('A', 'C') assert path == ['A', 'B', 'C'] router.update_latency(('A', 'B'), 15) path = router.shortest_path('A', 'C') assert path == ['A', 'C'] router.update_reliability(('A', 'C'), 0.7) path = router.shortest_path('A', 'C') assert path == ['A', 'B', 'C'] def test_cache(): router = NetworkRouter() router.add_edge('A', 'B', 5, 0.9) router.add_edge('B', 'C', 10, 0.95) router.add_edge('A', 'C', 20, 0.8) path1 = router.shortest_path('A', 'C') assert path1 == ['A', 'B', 'C'] path2 = router.shortest_path('A', 'C') assert path2 == path1 # Ensures caching is utilized","solution":"import heapq class NetworkRouter: def __init__(self): # Initialization of the NetworkRouter with additional attributes for congestion and reliability metrics self.graph = {} self.latencies = {} self.reliabilities = {} self.route_cache = {} def add_edge(self, node1, node2, latency, reliability=1.0): Adds an edge to the network graph with given latency and reliability. if node1 not in self.graph: self.graph[node1] = [] if node2 not in self.graph: self.graph[node2] = [] self.graph[node1].append((node2, latency, reliability)) self.graph[node2].append((node1, latency, reliability)) self.latencies[(node1, node2)] = latency self.latencies[(node2, node1)] = latency self.reliabilities[(node1, node2)] = reliability self.reliabilities[(node2, node1)] = reliability def update_latency(self, edge, new_latency): Updates the latency of the specified edge. node1, node2 = edge self.latencies[edge] = new_latency self.latencies[(node2, node1)] = new_latency for i in range(len(self.graph[node1])): if self.graph[node1][i][0] == node2: self.graph[node1][i] = (node2, new_latency, self.graph[node1][i][2]) for i in range(len(self.graph[node2])): if self.graph[node2][i][0] == node1: self.graph[node2][i] = (node1, new_latency, self.graph[node2][i][2]) self.route_cache.clear() # Invalidate cache def update_reliability(self, edge, new_reliability): Updates the reliability of the specified edge. node1, node2 = edge self.reliabilities[edge] = new_reliability self.reliabilities[(node2, node1)] = new_reliability for i in range(len(self.graph[node1])): if self.graph[node1][i][0] == node2: self.graph[node1][i] = (node2, self.graph[node1][i][1], new_reliability) for i in range(len(self.graph[node2])): if self.graph[node2][i][0] == node1: self.graph[node2][i] = (node1, self.graph[node2][i][1], new_reliability) self.route_cache.clear() # Invalidate cache def shortest_path(self, start, end): Uses Dijkstra's algorithm, considering reliability, to find the shortest path between start and end. Implements caching for frequently used routes. if (start, end) in self.route_cache: return self.route_cache[(start, end)] # Min-heap priority queue queue = [(0, start, [])] seen = set() while queue: (latency, node, path) = heapq.heappop(queue) if node in seen: continue path = path + [node] seen.add(node) if node == end: self.route_cache[(start, end)] = path return path for adjacent, weight, reliability in self.graph.get(node, []): if adjacent not in seen: heapq.heappush(queue, (latency + weight / reliability, adjacent, path)) return None"},{"question":"from typing import List def longest_consecutive_ones(nums: List[int]) -> int: Create a function that finds the length of the longest subarray that contains only 1s in a given list of binary integers (0s and 1s). >>> longest_consecutive_ones([1, 1, 0, 1, 1, 1]) 3 >>> longest_consecutive_ones([0, 0, 0]) 0 >>> longest_consecutive_ones([1, 1, 1, 1, 1]) 5 >>> longest_consecutive_ones([1, 0, 1, 0, 1]) 1 pass","solution":"from typing import List def longest_consecutive_ones(nums: List[int]) -> int: max_length = 0 current_length = 0 for num in nums: if num == 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def day_of_week(day: int, month: int, year: int) -> str: Calculate the day of the week for a given date using Zeller's Congruence algorithm. >>> day_of_week(15, 8, 2023) 'Tuesday' >>> day_of_week(1, 1, 2000) 'Saturday' >>> day_of_week(29, 2, 2020) 'Saturday' >>> day_of_week(31, 12, 1999) 'Friday' def test_day_of_week_january_1_2000(): assert day_of_week(1, 1, 2000) == 'Saturday' def test_day_of_week_february_29_2020(): assert day_of_week(29, 2, 2020) == 'Saturday' def test_day_of_week_december_31_1999(): assert day_of_week(31, 12, 1999) == 'Friday' def test_day_of_week_august_15_2023(): assert day_of_week(15, 8, 2023) == 'Tuesday' def test_day_of_week_march_1_2023(): assert day_of_week(1, 3, 2023) == 'Wednesday' def test_day_of_week_february_28_2023(): assert day_of_week(28, 2, 2023) == 'Tuesday' def test_day_of_week_january_1_1900(): assert day_of_week(1, 1, 1900) == 'Monday' def test_day_of_week_february_29_2000(): assert day_of_week(29, 2, 2000) == 'Tuesday' def test_day_of_week_july_4_1776(): assert day_of_week(4, 7, 1776) == 'Thursday'","solution":"def day_of_week(day: int, month: int, year: int) -> str: if month in [1, 2]: month += 12 year -= 1 q = day m = month K = year % 100 J = year // 100 h = (q + (13 * (m + 1)) // 5 + K + K // 4 + J // 4 + 5 * J) % 7 days = [\\"Saturday\\", \\"Sunday\\", \\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\"] return days[h]"},{"question":"def is_rotation_90(A: list[list[int]], B: list[list[int]]) -> bool: Determines if matrix B is a 90-degree rotation of matrix A. >>> is_rotation_90([[1, 2], [3, 4]], [[3, 1], [4, 2]]) == True >>> is_rotation_90([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[7, 4, 1], [8, 5, 2], [9, 6, 3]]) == True >>> is_rotation_90([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[9, 8, 7], [6, 5, 4], [3, 2, 1]]) == False >>> is_rotation_90([[1]], [[1]]) == True >>> is_rotation_90([[-1, -2], [-3, -4]], [[-3, -1], [-4, -2]]) == True >>> is_rotation_90([[1000000000, -1000000000], [-1000000000, 1000000000]], [[-1000000000, 1000000000], [1000000000, -1000000000]]) == True >>> is_rotation_90([[1, 2], [3, 4]], [[2, 1], [4, 3]]) == False # Unit Test import pytest def test_is_rotation_90(): assert is_rotation_90([[1, 2], [3, 4]], [[3, 1], [4, 2]]) == True def test_is_rotation_90_3x3_positive(): assert is_rotation_90([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[7, 4, 1], [8, 5, 2], [9, 6, 3]]) == True def test_is_rotation_90_3x3_negative(): assert is_rotation_90([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[9, 8, 7], [6, 5, 4], [3, 2, 1]]) == False def test_is_rotation_90_larger_matrix(): A = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]] B = [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]] assert is_rotation_90(A, B) == True def test_is_rotation_90_with_negative_numbers(): A = [[-1, -2], [-3, -4]] B = [[-3, -1], [-4, -2]] assert is_rotation_90(A, B) == True def test_is_rotation_90_single_element(): assert is_rotation_90([[1]], [[1]]) == True def test_is_rotation_90_edge_case(): A = [[1000000000, -1000000000], [-1000000000, 1000000000]] B = [[-1000000000, 1000000000], [1000000000, -1000000000]] assert is_rotation_90(A, B) == True def test_is_rotation_90_not_rotation(): A = [[1, 2], [3, 4]] B = [[2, 1], [4, 3]] assert is_rotation_90(A, B) == False","solution":"def is_rotation_90(A: list[list[int]], B: list[list[int]]) -> bool: Determines if matrix B is a 90-degree rotation of matrix A. n = len(A) # Check if B is a 90-degree rotation of A for i in range(n): for j in range(n): if A[i][j] != B[j][n - 1 - i]: return False return True"},{"question":"import requests def fetch_average_temperature(city: str, days: int, api_key: str) -> dict: Analyze temperature data for a given city, fetching details from a weather API and calculating the average temperature over a specified number of days. Args: city (str): The city name. days (int): The number of days to average. api_key (str): The weather API key. Returns: dict: A dictionary with keys \\"success\\" (boolean) and \\"data\\" (average temperature on success or an error message on failure). >>> fetch_average_temperature(\\"\\", 5, \\"FAKE_API_KEY\\") {'success': False, 'data': 'City name cannot be empty.'} >>> fetch_average_temperature(\\"New York\\", -3, \\"FAKE_API_KEY\\") {'success': False, 'data': 'Number of days must be a positive integer.'} >>> fetch_average_temperature(\\"Unknown City\\", 7, \\"FAKE_API_KEY\\") {'success': False, 'data': 'No temperature data found for the given city.'} Example usage: result = fetch_average_temperature(\\"New York\\", 7, \\"YOUR_API_KEY\\") print(result)","solution":"import requests def fetch_average_temperature(city: str, days: int, api_key: str) -> dict: if not city: return {\\"success\\": False, \\"data\\": \\"City name cannot be empty.\\"} if days <= 0: return {\\"success\\": False, \\"data\\": \\"Number of days must be a positive integer.\\"} url = f\\"https://api.weatherapi.com/v1/history.json?key={api_key}&q={city}&days={days}\\" try: response = requests.get(url) response.raise_for_status() data = response.json() if 'error' in data: return {\\"success\\": False, \\"data\\": data['error']['message']} temperatures = [day['day']['avgtemp_c'] for day in data['forecast']['forecastday']] if not temperatures: return {\\"success\\": False, \\"data\\": \\"No temperature data found for the given city.\\"} average_temperature = sum(temperatures) / len(temperatures) return {\\"success\\": True, \\"data\\": average_temperature} except requests.RequestException: return {\\"success\\": False, \\"data\\": \\"Network error occurred while fetching temperature data.\\"}"},{"question":"from typing import List def longest_consecutive_subsequence(nums: List[int]) -> int: Returns the length of the longest subsequence of consecutive integers that can be formed from elements in the list nums. >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_subsequence([10, 9, 8, 7]) 4 >>> longest_consecutive_subsequence([1, 2, 0, 1]) 3 >>> longest_consecutive_subsequence([5, 5, 5]) 1 >>> longest_consecutive_subsequence([]) 0 >>> longest_consecutive_subsequence([1]) 1 >>> longest_consecutive_subsequence([10, 20, 30]) 1 >>> longest_consecutive_subsequence([1, 2, 3, 4, 5]) 5","solution":"from typing import List def longest_consecutive_subsequence(nums: List[int]) -> int: Returns the length of the longest subsequence of consecutive integers that can be formed from elements in the list nums. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # If it's the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"class Matrix: def __init__(self, data: list): Initialize the matrix with a 2D list. pass def add(self, other: 'Matrix') -> 'Matrix': Add two matrices. pass def subtract(self, other: 'Matrix') -> 'Matrix': Subtract another matrix from the current matrix. pass def multiply(self, other: 'Matrix') -> 'Matrix': Multiply the current matrix with another matrix. pass def transpose(self) -> 'Matrix': Return the transpose of the matrix. pass def __str__(self) -> str: Return the string representation of the matrix. pass # Example Usage: # Initialize two matrices matrix1 = Matrix([[1, 2, 3], [4, 5, 6]]) matrix2 = Matrix([[7, 8, 9], [10, 11, 12]]) # Add the matrices result_add = matrix1.add(matrix2) print(result_add) # Subtract the matrices result_subtract = matrix1.subtract(matrix2) print(result_subtract) # Transpose the matrix result_transpose = matrix1.transpose() print(result_transpose) # Multiply the matrices matrix3 = Matrix([[1, 2], [3, 4], [5, 6]]) matrix4 = Matrix([[7, 8, 9], [10, 11, 12]]) result_multiply = matrix3.multiply(matrix4) print(result_multiply)","solution":"class Matrix: def __init__(self, data: list): Initialize the matrix with a 2D list. self.data = data def add(self, other: 'Matrix') -> 'Matrix': Add two matrices. if len(self.data) != len(other.data) or len(self.data[0]) != len(other.data[0]): raise ValueError(\\"Matrices must have the same dimensions for addition.\\") result = [ [self.data[i][j] + other.data[i][j] for j in range(len(self.data[0]))] for i in range(len(self.data)) ] return Matrix(result) def subtract(self, other: 'Matrix') -> 'Matrix': Subtract another matrix from the current matrix. if len(self.data) != len(other.data) or len(self.data[0]) != len(other.data[0]): raise ValueError(\\"Matrices must have the same dimensions for subtraction.\\") result = [ [self.data[i][j] - other.data[i][j] for j in range(len(self.data[0]))] for i in range(len(self.data)) ] return Matrix(result) def multiply(self, other: 'Matrix') -> 'Matrix': Multiply the current matrix with another matrix. if len(self.data[0]) != len(other.data): raise ValueError(\\"Number of columns in the first matrix must be equal to the number of rows in the second matrix.\\") result = [ [ sum(self.data[i][k] * other.data[k][j] for k in range(len(self.data[0]))) for j in range(len(other.data[0])) ] for i in range(len(self.data)) ] return Matrix(result) def transpose(self) -> 'Matrix': Return the transpose of the matrix. result = [ [self.data[j][i] for j in range(len(self.data))] for i in range(len(self.data[0])) ] return Matrix(result) def __str__(self) -> str: Return the string representation of the matrix. return 'n'.join([' '.join(map(str, row)) for row in self.data])"},{"question":"def compress(s: str) -> str: Compress a string using Run-Length Encoding. >>> compress(\\"AAABBCCCCDDDDE\\") 'A3B2C4D4E1' >>> compress(\\"A\\") 'A1' >>> compress(\\"ABCDE\\") 'A1B1C1D1E1' def decompress(cs: str) -> str: Decompress a string using Run-Length Encoding. >>> decompress(\\"A3B2C4D4E1\\") 'AAABBCCCCDDDDE' >>> decompress(\\"A1\\") 'A' >>> decompress(\\"A1B1C1D1E1\\") 'ABCDE'","solution":"def compress(s: str) -> str: Compresses a string using Run-Length Encoding. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) return \\"\\".join(compressed) def decompress(cs: str) -> str: Decompresses a string using Run-Length Encoding. decompressed = [] i = 0 while i < len(cs): char = cs[i] i += 1 count_start = i while i < len(cs) and cs[i].isdigit(): i += 1 count = int(cs[count_start:i]) decompressed.append(char * count) return \\"\\".join(decompressed)"},{"question":"def invert_binary_image(image: list[list[int]]) -> list[list[int]]: Inverts a given binary image represented as a 2D list. >>> invert_binary_image([ ... [1, 0, 0], ... [0, 1, 0], ... [1, 1, 1] ... ]) [[0, 1, 1], [1, 0, 1], [0, 0, 0]] >>> invert_binary_image([ ... [1, 1, 1], ... [1, 1, 0], ... [0, 0, 1] ... ]) [[0, 0, 0], [0, 0, 1], [1, 1, 0]] >>> invert_binary_image([[1]]) [[0]] >>> invert_binary_image([[0, 0, 0, 0]]) [[1, 1, 1, 1]] >>> invert_binary_image([[1, 1], [1, 1]]) [[0, 0], [0, 0]] >>> invert_binary_image([[0, 0], [0, 0]]) [[1, 1], [1, 1]] >>> invert_binary_image([ ... [0, 1, 0], ... [1, 0, 1], ... [0, 1, 0] ... ]) [[1, 0, 1], [0, 1, 0], [1, 0, 1]]","solution":"def invert_binary_image(image): Inverts a given binary image represented as a 2D list. Parameters: image (list of list of int): 2D list representing the binary image to be inverted. Returns: list of list of int: New 2D list representing the inverted binary image. return [[1 - pixel for pixel in row] for row in image]"},{"question":"from typing import List def shortest_path(graph: List[List[int]], source: int, destination: int) -> int: Compute the shortest path distance from the source to the destination in the given graph using Dijkstra's algorithm. >>> graph = [ ... [0, 10, float('inf'), 30, 100], ... [float('inf'), 0, 50, float('inf'), float('inf')], ... [float('inf'), float('inf'), 0, float('inf'), 10], ... [float('inf'), float('inf'), 20, 0, 60], ... [float('inf'), float('inf'), float('inf'), float('inf'), 0] ... ] >>> shortest_path(graph, 0, 4) 60 >>> shortest_path(graph, 1, 4) 60 >>> shortest_path(graph, 2, 4) 10 >>> shortest_path(graph, 3, 1) -1 pass","solution":"import heapq from typing import List def shortest_path(graph: List[List[int]], source: int, destination: int) -> int: V = len(graph) # Initialize distances with infinity distances = [float('inf')] * V distances[source] = 0 # Priority queue to select the edge with the smallest weight first priority_queue = [(0, source)] # (distance, vertex) while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # If the popped vertex distance is greater than the known distance, skip it if current_distance > distances[current_vertex]: continue # Check if we have reached the destination if current_vertex == destination: return current_distance # Examine and relax all neighbors for neighbor in range(V): if graph[current_vertex][neighbor] != float('inf'): distance = current_distance + graph[current_vertex][neighbor] if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) # If the destination is still at infinity, it means it's unreachable return -1 if distances[destination] == float('inf') else distances[destination]"},{"question":"def calculate_compression_ratio(volume_bdc: float, volume_tdc: float) -> float: Calculate the compression ratio of an internal combustion engine. Parameters: volume_bdc (float): Volume at bottom dead center in cubic centimeters (must be > 0 and > volume_tdc). volume_tdc (float): Volume at top dead center in cubic centimeters (must be > 0 and < volume_bdc). Returns: float: Compression ratio of the engine. Raises: ValueError: If volume_bdc <= 0, volume_tdc <= 0, or volume_bdc <= volume_tdc. Examples: >>> calculate_compression_ratio(500, 50) 10.0 >>> calculate_compression_ratio(600, 60) 10.0 >>> calculate_compression_ratio(700, 70) 10.0 >>> calculate_compression_ratio(600, 100) 6.0 >>> calculate_compression_ratio(700, 0) Traceback (most recent call last): ... ValueError: Invalid volume at TDC >>> calculate_compression_ratio(-500, 50) Traceback (most recent call last): ... ValueError: Invalid volume at BDC >>> calculate_compression_ratio(500, 600) Traceback (most recent call last): ... ValueError: Volume at BDC must be greater than volume at TDC","solution":"def calculate_compression_ratio(volume_bdc: float, volume_tdc: float) -> float: Calculate the compression ratio of an internal combustion engine. Parameters: volume_bdc (float): Volume at bottom dead center in cubic centimeters. volume_tdc (float): Volume at top dead center in cubic centimeters. Returns: float: Compression ratio of the engine. Raises: ValueError: If volume_bdc <= 0, volume_tdc <= 0, or volume_bdc <= volume_tdc. if volume_bdc <= 0: raise ValueError(\\"Invalid volume at BDC\\") if volume_tdc <= 0: raise ValueError(\\"Invalid volume at TDC\\") if volume_bdc <= volume_tdc: raise ValueError(\\"Volume at BDC must be greater than volume at TDC\\") return volume_bdc / volume_tdc"},{"question":"from typing import List def rotate_matrix_90_degrees(matrix: List[List[int]]) -> None: Rotates the given square 2D matrix 90 degrees clockwise in place. >>> matrix1 = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix_90_degrees(matrix1) >>> print(matrix1) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix2 = [ ... [5, 1], ... [3, 7] ... ] >>> rotate_matrix_90_degrees(matrix2) >>> print(matrix2) [[3, 5], [7, 1]]","solution":"from typing import List def rotate_matrix_90_degrees(matrix: List[List[int]]) -> None: Rotates the given square 2D matrix 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"class Node: def __init__(self, key): self.left = None self.right = None self.value = key class BST: def __init__(self): self.root = None def insert(self, key: int) -> None: Insert a new key into the BST. Example: >>> bst = BST() >>> bst.insert(10) >>> bst.insert(5) >>> bst.insert(15) >>> bst.root.value 10 >>> bst.root.left.value 5 >>> bst.root.right.value 15 # Your code here def search(self, key: int) -> bool: Search for a specific key within the BST. Returns: bool: True if the key is found, False otherwise. Example: >>> bst = BST() >>> bst.insert(10) >>> bst.insert(5) >>> bst.insert(15) >>> bst.search(5) True >>> bst.search(20) False # Your code here","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.value = key class BST: def __init__(self): self.root = None def insert(self, key: int) -> None: Insert a new key into the BST. if self.root is None: self.root = Node(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, node: Node, key: int) -> None: if key < node.value: if node.left is None: node.left = Node(key) else: self._insert_recursive(node.left, key) else: if node.right is None: node.right = Node(key) else: self._insert_recursive(node.right, key) def search(self, key: int) -> bool: Search for a specific key within the BST. Returns: bool: True if the key is found, False otherwise. return self._search_recursive(self.root, key) def _search_recursive(self, node: Node, key: int) -> bool: if node is None: return False if key == node.value: return True elif key < node.value: return self._search_recursive(node.left, key) else: return self._search_recursive(node.right, key)"},{"question":"def hex_to_decimal(hex_str: str) -> int: Converts a given hexadecimal (base-16) string prefixed with \\"0x\\" to its corresponding non-negative integer representation. >>> hex_to_decimal('0x2') 2 >>> hex_to_decimal('0xA') 10 >>> hex_to_decimal('0x64') 100 >>> hex_to_decimal('0x100') 256 >>> hex_to_decimal('0xffff') 65535 >>> hex_to_decimal('0x0') 0","solution":"def hex_to_decimal(hex_str: str) -> int: Converts a given hexadecimal (base-16) string prefixed with \\"0x\\" to its corresponding non-negative integer representation. Args: hex_str (str): A string representing the hexadecimal number prefixed with \\"0x\\". Returns: int: An integer representing the decimal value of the given hexadecimal string. return int(hex_str, 16)"},{"question":"def merge_sort(arr: list) -> list: Sorts a list of integers in ascending order using the merge sort algorithm. Parameters: arr (list): A list of integers Returns: list: The sorted list >>> merge_sort([34, -2, 45, 29, 8]) [-2, 8, 29, 34, 45] >>> merge_sort([5, 1, 1, 2, 0, 0]) [0, 0, 1, 1, 2, 5] >>> merge_sort([]) [] >>> merge_sort([42]) [42] from solution import merge_sort def test_merge_sort_with_positive_negative_integers(): assert merge_sort([34, -2, 45, 29, 8]) == [-2, 8, 29, 34, 45] def test_merge_sort_with_duplicates(): assert merge_sort([5, 1, 1, 2, 0, 0]) == [0, 0, 1, 1, 2, 5] def test_merge_sort_empty_list(): assert merge_sort([]) == [] def test_merge_sort_single_element(): assert merge_sort([42]) == [42] def test_merge_sort_already_sorted(): assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_merge_sort_reverse_sorted(): assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] def test_merge_sort_with_large_values(): assert merge_sort([1000000, 999999, -1000000, 0]) == [-1000000, 0, 999999, 1000000] def test_merge_sort_with_repeated_values(): assert merge_sort([3, 3, 3, 3, 3]) == [3, 3, 3, 3, 3] def test_merge_sort_with_mixed_sign_integers(): assert merge_sort([0, -1, 1, -2, 2, -3, 3]) == [-3, -2, -1, 0, 1, 2, 3] def test_merge_sort_long_list_desc_order(): long_list = list(range(1000, 0, -1)) sorted_long_list = list(range(1, 1001)) assert merge_sort(long_list) == sorted_long_list","solution":"def merge_sort(arr): Sorts a list of integers in ascending order using the merge sort algorithm. Parameters: arr (list): A list of integers Returns: list: The sorted list if len(arr) <= 1: return arr def merge(left, right): result = [] i, j = 0, 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"def prefix_to_infix(expression: str) -> str: Convert a prefix expression to an infix expression. >>> prefix_to_infix(\\"+ 5 * 2 3\\") \\"(5 + (2 * 3))\\" >>> prefix_to_infix(\\"- * / 15 - 7 + 1 1 3 + 2 + 1 1\\") \\"(((15 / (7 - (1 + 1))) * 3) - (2 + (1 + 1)))\\" pass def evaluate_infix(expression: str) -> float: Evaluate an infix expression. >>> evaluate_infix(\\"(5 + (2 * 3))\\") 11.0 >>> evaluate_infix(\\"(((15 / (7 - (1 + 1))) * 3) - (2 + (1 + 1)))\\") 5.0 >>> evaluate_infix(\\"1 / 0\\") float('inf') pass","solution":"def prefix_to_infix(expression: str) -> str: def helper(stack): token = stack.pop() if token in \\"+-*/\\": operand1 = helper(stack) operand2 = helper(stack) return f\\"({operand1} {token} {operand2})\\" else: return token tokens = expression.split() stack = tokens[::-1] return helper(stack) def evaluate_infix(expression: str) -> float: try: return eval(expression) except ZeroDivisionError: return float('inf') # Example Usage print(prefix_to_infix(\\"+ 5 * 2 3\\")) # \\"(5 + (2 * 3))\\" print(evaluate_infix(\\"(5 + (2 * 3))\\")) # 11.0 print(prefix_to_infix(\\"- * / 15 - 7 + 1 1 3 + 2 + 1 1\\")) # \\"(((15 / (7 - (1 + 1))) * 3) - (2 + (1 + 1)))\\" print(evaluate_infix(\\"(((15 / (7 - (1 + 1))) * 3) - (2 + (1 + 1)))\\")) # 5.0"},{"question":"from typing import List def rotate_right(arr: List[int], k: int) -> None: Rotates the elements of the given list to the right by 'k' steps in-place. :param arr: List of integers to be rotated. :param k: Number of steps to rotate. >>> arr = [1, 2, 3, 4, 5] >>> rotate_right(arr, 2) >>> print(arr) [4, 5, 1, 2, 3] >>> arr = [1, 2, 3, 4, 5] >>> rotate_right(arr, 5) >>> print(arr) [1, 2, 3, 4, 5] >>> arr = [1, 2, 3, 4, 5] >>> rotate_right(arr, 7) >>> print(arr) [4, 5, 1, 2, 3] >>> arr = [] >>> rotate_right(arr, 3) >>> print(arr) [] >>> arr = [1] >>> rotate_right(arr, 3) >>> print(arr) [1] >>> arr = [1, 2] >>> rotate_right(arr, 999999) >>> print(arr) [2, 1] pass","solution":"from typing import List def rotate_right(arr: List[int], k: int) -> None: Rotates the elements of the given list to the right by 'k' steps in-place. :param arr: List of integers to be rotated. :param k: Number of steps to rotate. if not arr or k == 0: return n = len(arr) k %= n # find effective rotations needed # Function to reverse a segment of the list def reverse(start, end): while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 # Reverse the entire list reverse(0, n - 1) # Reverse the first k elements reverse(0, k - 1) # Reverse the remaining elements reverse(k, n - 1)"},{"question":"def sum_of_primes(a: int, b: int) -> int: Calculate the sum of all prime numbers within the specified range [a, b]. >>> sum_of_primes(10, 20) 60 >>> sum_of_primes(1, 5) 10 >>> sum_of_primes(13, 13) 13 >>> sum_of_primes(14, 16) 0 >>> sum_of_primes(1, 1000) 76127 >>> sum_of_primes(997, 1000) 997 >>> sum_of_primes(2, 10) 17","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False p = 3 while p * p <= n: if n % p == 0: return False p += 2 return True def sum_of_primes(a, b): Returns the sum of all prime numbers in the range [a, b]. return sum(x for x in range(a, b + 1) if is_prime(x))"},{"question":"def knight_moves(start: tuple[int, int], target: tuple[int, int]) -> int: Calculate the minimum number of moves required for a knight to travel from a starting position to a target position on an 8x8 chessboard. Args: start (tuple): The starting position as a tuple (row, column). target (tuple): The target position as a tuple (row, column). Returns: int: The minimum number of moves required for the knight to reach the target position from the start position. Examples: >>> knight_moves((0, 0), (7, 7)) 6 >>> knight_moves((0, 0), (2, 1)) 1 >>> knight_moves((3, 3), (4, 3)) 3 >>> knight_moves((0, 0), (0, 0)) 0 pass","solution":"from collections import deque def knight_moves(start: tuple[int, int], target: tuple[int, int]) -> int: if start == target: return 0 def in_bounds(x, y): return 0 <= x < 8 and 0 <= y < 8 moves = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] visited = [[False]*8 for _ in range(8)] queue = deque([(start[0], start[1], 0)]) while queue: x, y, d = queue.popleft() for dx, dy in moves: nx, ny = x + dx, y + dy if (nx, ny) == target: return d + 1 if in_bounds(nx, ny) and not visited[nx][ny]: visited[nx][ny] = True queue.append((nx, ny, d + 1)) return -1 # Should never reach here if inputs are valid"},{"question":"def find_first_occurrence(arr, target): Find the index of the first occurrence of the target value in a sorted array. If the target value is not found, return -1. Parameters: arr (list of int): The sorted array (may contain duplicates). target (int): The target value to find. Returns: int: The index of the first occurrence of target, or -1 if the target is not found. >>> find_first_occurrence([1, 2, 2, 2, 3, 4, 5], 2) 1 >>> find_first_occurrence([1, 3, 5, 7, 9, 11, 11, 11, 13], 11) 5 >>> find_first_occurrence([1], 2) -1 pass","solution":"def find_first_occurrence(arr, target): Find the index of the first occurrence of the target value in a sorted array. If the target value is not found, return -1. Parameters: arr (list of int): The sorted array (may contain duplicates). target (int): The target value to find. Returns: int: The index of the first occurrence of target, or -1 if the target is not found. left, right = 0, len(arr) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: result = mid right = mid - 1 elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"from typing import List def merge_sorted_lists(lists: List[List[int]]) -> List[int]: Merges multiple sorted lists into a single sorted list, removing duplicates. :param lists: List of sorted lists to be merged. :return: A merged sorted list with unique elements. Example usage: >>> merge_sorted_lists([[1, 3, 5], [2, 4, 6], [0, 3, 3, 7, 8]]) [0, 1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sorted_lists([[10, 20], [5, 25], [], [5, 15]]) [5, 10, 15, 20, 25] >>> merge_sorted_lists([[-3, -1, 0], [-2, 2, 3], [1, 1, 4]]) [-3, -2, -1, 0, 1, 2, 3, 4] >>> merge_sorted_lists([[], [], []]) [] # Your code here","solution":"import heapq from typing import List def merge_sorted_lists(lists: List[List[int]]) -> List[int]: Merges multiple sorted lists into a single sorted list, removing duplicates. :param lists: List of sorted lists to be merged. :return: A merged sorted list with unique elements. min_heap = [] for l in lists: if l: for num in l: heapq.heappush(min_heap, num) merged_and_unique = [] prev = None while min_heap: current = heapq.heappop(min_heap) if current != prev: merged_and_unique.append(current) prev = current return merged_and_unique"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: TreeNode) -> list: Perform an in-order traversal of a binary tree. @input: root (root node of the binary tree) @returns: A list of node values in in-order traversal. @example: >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.left = TreeNode(3) >>> inorder_traversal(root) [1, 3, 2] pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: TreeNode) -> list: Perform an in-order traversal of a binary tree. @input: root (root node of the binary tree) @returns: A list of node values in in-order traversal. result = [] def traverse(node): if node: traverse(node.left) result.append(node.val) traverse(node.right) traverse(root) return result"},{"question":"def collatz_sequence_length(n: int) -> int: Calculate the length of the Collatz sequence for a given positive integer n. >>> collatz_sequence_length(1) 0 >>> collatz_sequence_length(2) 1 >>> collatz_sequence_length(3) 7 >>> collatz_sequence_length(4) 2 >>> collatz_sequence_length(10) 6 >>> collatz_sequence_length(27) 111 >>> collatz_sequence_length(100) 25 >>> collatz_sequence_length(99999) > 0 >>> collatz_sequence_length(100000) > 0 >>> collatz_sequence_length(837799) 524","solution":"def collatz_sequence_length(n: int) -> int: steps = 0 while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 steps += 1 return steps"},{"question":"def max_water_container(heights: List[int]) -> int: Returns the maximum amount of water that the container can hold. Args: heights (List[int]): A list of non-negative integers representing the height of vertical lines. Returns: int: The maximum amount of water the container can hold. left, right = 0, len(heights) - 1 max_area = 0 while left < right: width = right - left height = min(heights[left], heights[right]) current_area = width * height max_area = max(max_area, current_area) # Move the shorter line to try to find a taller one if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area","solution":"from typing import List def max_water_container(heights: List[int]) -> int: Returns the maximum amount of water that the container can hold. Args: heights (List[int]): A list of non-negative integers representing the height of vertical lines. Returns: int: The maximum amount of water the container can hold. left, right = 0, len(heights) - 1 max_area = 0 while left < right: width = right - left height = min(heights[left], heights[right]) current_area = width * height max_area = max(max_area, current_area) # Move the shorter line to try to find a taller one if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"def sort_events_by_timestamp(events: list[tuple[str, int]]) -> list[tuple[str, int]]: Sorts the events by their timestamps in ascending order. Args: events (list of tuples): A list of tuples, where each tuple contains: - event_id (str): The event identifier. - timestamp (int): The timestamp of the event. Returns: list of tuples: A list of events sorted by their timestamps in ascending order. pass # Example 1 assert sort_events_by_timestamp([('e1', 5), ('e2', 3), ('e3', 8), ('e4', 1)]) == [('e4', 1), ('e2', 3), ('e1', 5), ('e3', 8)] # Example 2 assert sort_events_by_timestamp([('a', 2), ('b', 1)]) == [('b', 1), ('a', 2)] # Example 3 assert sort_events_by_timestamp([('x', 10), ('y', 10), ('z', 5)]) == [('z', 5), ('x', 10), ('y', 10)] # Example 4 assert sort_events_by_timestamp([]) == [] # Example 5 assert sort_events_by_timestamp([('single', 3)]) == [('single', 3)]","solution":"def sort_events_by_timestamp(events): Sorts the events by their timestamps in ascending order. Args: events (list of tuples): A list of tuples, where each tuple contains: - event_id (str): The event identifier. - timestamp (int): The timestamp of the event. Returns: list of tuples: A list of events sorted by their timestamps in ascending order. return sorted(events, key=lambda event: event[1])"},{"question":"# Sorting Integers with Custom Comparator Write a Python function that sorts a list of integers using a custom comparator function that defines a specific sorting order based on some criteria. Title: Sorting Integers with Custom Comparator You are given a list of integers and a custom comparator function that defines a specific sorting order based on some criteria. Your task is to write a function that sorts the integers according to the provided comparator. Function name: custom_sort Arguments: 1. lst: List[int] - A list of integers to be sorted. 2. cmp: Callable[[int, int], int] - A comparator function that takes two integers as arguments and returns: - A negative integer if the first integer should come before the second. - Zero if the two integers are equal. - A positive integer if the first integer should come after the second. Returns: List[int] - A new list of integers sorted according to the provided comparator function. Performance Requirements: - The function should efficiently handle the constraints. - The length of \`lst\` is between 1 and 10^4. - Each element in \`lst\` is an integer between -10^9 and 10^9. Examples: >>> custom_sort([4, 2, 3, 1, 5], lambda x, y: x - y) [1, 2, 3, 4, 5] >>> custom_sort([4, 2, 3, 1, 5], lambda x, y: y - x) [5, 4, 3, 2, 1] >>> custom_sort([4, 2, -3, 1, -5, 0], lambda x, y: abs(x) - abs(y)) [0, 1, 2, -3, 4, -5] from typing import List, Callable def custom_sort(lst: List[int], cmp: Callable[[int, int], int]) -> List[int]: # Convert comparator to key for sorting from functools import cmp_to_key return sorted(lst, key=cmp_to_key(cmp))","solution":"from typing import List, Callable def custom_sort(lst: List[int], cmp: Callable[[int, int], int]) -> List[int]: # Convert comparator to key for sorting from functools import cmp_to_key return sorted(lst, key=cmp_to_key(cmp))"},{"question":"from typing import List, Tuple def calculate_budget(expenses: List[int], budget: int) -> Tuple[int, int]: Computes the total amount spent and the remaining balance from the given expenses and budget. Parameters: expenses (List[int]): A list of integers representing the user's monthly expenses. budget (int): An integer representing the user's total monthly budget. Returns: Tuple[int, int]: A tuple containing the total amount spent and the remaining balance. Examples: >>> calculate_budget([100, 200, 300], 1000) (600, 400) >>> calculate_budget([1500, 1200, 550, 780], 5000) (4030, 970) >>> calculate_budget([], 700) (0, 700) >>> calculate_budget([1000, 2000, 3000], 5000) (6000, -1000) >>> calculate_budget([500, 500, 500], 1500) (1500, 0)","solution":"from typing import List, Tuple def calculate_budget(expenses: List[int], budget: int) -> Tuple[int, int]: Computes the total amount spent and the remaining balance from the given expenses and budget. Parameters: expenses (List[int]): A list of integers representing the user's monthly expenses. budget (int): An integer representing the user's total monthly budget. Returns: Tuple[int, int]: A tuple containing the total amount spent and the remaining balance. total_spent = sum(expenses) remaining_balance = budget - total_spent return total_spent, remaining_balance"},{"question":"def has_subarray_with_sum(arr: List[int], target: int) -> bool: Checks if there exists a subarray within the given array that sums up to a specified target value. :param arr: List[int] - List of integers which might contain positive, negative, or zero values :param target: int - The target sum to find in the subarray :return: bool - True if there is a subarray with sum equal to the target, otherwise False >>> has_subarray_with_sum([1, 2, 3, 4, 5], 9) True >>> has_subarray_with_sum([-1, 3, -2, 5, -4], 1) True >>> has_subarray_with_sum([1, 2, 3], 7) False","solution":"def has_subarray_with_sum(arr, target): Checks if there exists a subarray within the array that sums up to the target value. :param arr: List[int] - List of integers which might contain positive, negative, or zero values :param target: int - The target sum to find in the subarray :return: bool - True if there is a subarray with sum equal to the target, otherwise False current_sum = 0 sum_set = set() for num in arr: current_sum += num if current_sum == target: return True if (current_sum - target) in sum_set: return True sum_set.add(current_sum) return False"},{"question":"from heapq import heappush, heappop from collections import defaultdict import sys class Graph: A class to represent a graph using an adjacency list. Methods: - add_edge(from_node: str, to_node: str, weight: int): Adds a directed, weighted edge to the graph. - dijkstra(start: str, end: str) -> int: Computes the shortest path from the start node to the end node using Dijkstra's algorithm. def __init__(self): self.nodes = set() self.adj_list = defaultdict(list) def add_edge(self, from_node: str, to_node: str, weight: int): Adds a directed, weighted edge to the graph. Args: - from_node (str): The starting node of the edge. - to_node (str): The ending node of the edge. - weight (int): The weight of the edge. Example: >>> g = Graph() >>> g.add_edge('A', 'B', 1) pass def dijkstra(self, start: str, end: str) -> int: Computes the shortest path from the start node to the end node using Dijkstra's algorithm. Args: - start (str): The starting node. - end (str): The target node. Returns: - int: The shortest distance from start to end, or sys.maxsize if no path exists. Example: >>> g = Graph() >>> g.add_edge('A', 'B', 1) >>> g.add_edge('B', 'C', 2) >>> g.add_edge('A', 'C', 4) >>> g.dijkstra('A', 'C') 3 pass # Example usage (testing the implementation): # g = Graph() # g.add_edge('A', 'B', 1) # g.add_edge('B', 'C', 2) # g.add_edge('A', 'C', 4) # print(g.dijkstra('A', 'C')) # Output should be 3 # Unit test cases def test_dijkstra_simple_graph(): g = Graph() g.add_edge('A', 'B', 1) g.add_edge('B', 'C', 2) g.add_edge('A', 'C', 4) assert g.dijkstra('A', 'C') == 3 def test_dijkstra_no_path(): g = Graph() g.add_edge('A', 'B', 1) g.add_edge('B', 'C', 2) g.add_edge('A', 'C', 4) assert g.dijkstra('A', 'D') == sys.maxsize def test_dijkstra_same_node(): g = Graph() g.add_edge('A', 'B', 1) g.add_edge('B', 'C', 2) g.add_edge('A', 'C', 4) assert g.dijkstra('A', 'A') == 0 def test_dijkstra_multiple_paths(): g = Graph() g.add_edge('A', 'B', 1) g.add_edge('B', 'D', 2) g.add_edge('A', 'C', 2) g.add_edge('C', 'D', 1) g.add_edge('B', 'C', 2) assert g.dijkstra('A', 'D') == 3 def test_dijkstra_disconnected_graph(): g = Graph() g.add_edge('A', 'B', 1) g.add_edge('C', 'D', 2) assert g.dijkstra('A', 'D') == sys.maxsize","solution":"from heapq import heappush, heappop from collections import defaultdict import sys class Graph: def __init__(self): self.nodes = set() self.adj_list = defaultdict(list) def add_edge(self, from_node, to_node, weight): self.nodes.update([from_node, to_node]) self.adj_list[from_node].append((to_node, weight)) def dijkstra(self, start, end): heap = [(0, start)] distances = {node: sys.maxsize for node in self.nodes} distances[start] = 0 visited = set() while heap: current_distance, current_node = heappop(heap) if current_node in visited: continue visited.add(current_node) if current_node == end: return current_distance for neighbor, weight in self.adj_list[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heappush(heap, (distance, neighbor)) return sys.maxsize"},{"question":"def single_number(nums: List[int]) -> int: Identify and return the single number that appears only once in a list where each integer appears exactly three times except for one. >>> single_number([2, 2, 3, 2]) 3 >>> single_number([0, 1, 0, 1, 0, 1, 99]) 99","solution":"def single_number(nums): ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"def boiling_point_adjustment(altitude: float) -> float: Calculate the boiling point of water at a given altitude. Parameters: - altitude (float): The altitude in meters above sea level. Must be non-negative. Returns: - float: The boiling point of water in degrees Celsius at the given altitude. Example: >>> boiling_point_adjustment(0) 100.0 >>> boiling_point_adjustment(1500) 95.0","solution":"def boiling_point_adjustment(altitude: float) -> float: Calculate the boiling point of water at a given altitude. Parameters: - altitude (float): The altitude in meters above sea level. Must be non-negative. Returns: - float: The boiling point of water in degrees Celsius at the given altitude. if altitude < 0: raise ValueError(\\"Altitude must be a non-negative value.\\") boiling_point = 100 - (altitude / 300) return boiling_point"},{"question":"import re class EmailValidator: def is_valid_email(self, email: str) -> bool: Check if the given email is valid based on the specified criteria. :param email: The email address to check. :return: True if the email is valid, False otherwise. >>> ev = EmailValidator() >>> ev.is_valid_email(\\"user.name-123@example.com\\") True >>> ev.is_valid_email(\\"username@.com\\") False pass from typing import List def get_unique_elements(elements: List[str]) -> List[str]: Takes a list of strings and returns a list of unique strings maintaining the first occurrence order. :param elements: List of strings. :return: List of unique strings in the order of their first occurrence. >>> get_unique_elements([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"grape\\"]) [\\"apple\\", \\"banana\\", \\"orange\\", \\"grape\\"] >>> get_unique_elements([\\"cat\\", \\"dog\\", \\"fish\\", \\"cat\\", \\"bird\\"]) [\\"cat\\", \\"dog\\", \\"fish\\", \\"bird\\"] pass","solution":"import re class EmailValidator: def is_valid_email(self, email: str) -> bool: Check if the given email is valid based on the specified criteria. :param email: The email address to check. :return: True if the email is valid, False otherwise. if len(email) > 320: return False # Define the regex pattern for the whole email email_regex = re.compile( r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,6}' ) # Check the whole pattern if not email_regex.match(email): return False # Split email into local part and domain part local_part, domain_part = email.split('@') # Check if local part starts or ends with a dot or has consecutive dots if local_part.startswith('.') or local_part.endswith('.') or '..' in local_part: return False return True def get_unique_elements(elements): Takes a list of strings and returns a list of unique strings maintaining the first occurrence order. :param elements: List of strings. :return: List of unique strings in the order of their first occurrence. seen = set() unique_elements = [] for element in elements: if element not in seen: seen.add(element) unique_elements.append(element) return unique_elements"},{"question":"def is_rotated_sorted(nums: list[int]) -> bool: Checks if a given list of integers is a rotated version of a sorted list. >>> is_rotated_sorted([4, 5, 6, 7, 0, 1, 2]) True >>> is_rotated_sorted([4, 5, 6, 7, 7, 0, 1, 2]) True >>> is_rotated_sorted([3, 4, 5, 1, 2]) True >>> is_rotated_sorted([2, 3, 4, 5, 1]) True >>> is_rotated_sorted([4, 3, 2, 1, 5]) False","solution":"def is_rotated_sorted(nums: list[int]) -> bool: Checks if a given list of integers is a rotated version of a sorted list. if len(nums) == 0: return True # An empty list is considered sorted and rotated. if len(nums) == 1: return True # A single-element list is considered sorted and rotated. drop_count = 0 for i in range(len(nums)): if nums[i] > nums[(i + 1) % len(nums)]: drop_count += 1 if drop_count > 1: return False return True"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sorted_linked_lists(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted, singly linked lists into one sorted linked list. :param l1: ListNode, the head of the first sorted linked list :param l2: ListNode, the head of the second sorted linked list :return: ListNode, the head of the merged sorted linked list Example: >>> l1 = ListNode(1, ListNode(2, ListNode(4))) >>> l2 = ListNode(1, ListNode(3, ListNode(4))) >>> merged_head = merge_sorted_linked_lists(l1, l2) >>> while merged_head: >>> print(merged_head.val, end=\\" -> \\") Edge cases: >>> merge_sorted_linked_lists(None, list_to_linked_list([0, 1, 2])) == [0, 1, 2] >>> merge_sorted_linked_lists(list_to_linked_list([0, 1, 2]), None) == [0, 1, 2] >>> merge_sorted_linked_lists(None, None) == None","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sorted_linked_lists(l1: ListNode, l2: ListNode) -> ListNode: dummy = ListNode() current = dummy while l1 and l2: if l1.val <= l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 else: current.next = l2 return dummy.next"},{"question":"from PIL import Image import numpy as np def process_image(image_path: str) -> float: Takes the path to an image file as input, converts the image to grayscale, resizes it to 100x100 pixels, and returns the mean pixel intensity of the resulting image. >>> round(process_image(\\"sample_image.jpg\\"), 2) 128.0 >>> process_image(\\"invalid_path.jpg\\") # Invalid path None","solution":"from PIL import Image import numpy as np def process_image(image_path: str) -> float: try: # Open the image file with Image.open(image_path) as img: # Convert the image to grayscale grayscale_img = img.convert(\\"L\\") # Resize the image to 100x100 pixels resized_img = grayscale_img.resize((100, 100)) # Convert the image to a numpy array img_array = np.array(resized_img) # Calculate the mean pixel intensity mean_intensity = img_array.mean() return mean_intensity except Exception as e: print(f\\"An error occurred: {e}\\") return None"},{"question":"[Completion Task in Python] def max_unique_subarray_length(s: str) -> int: Returns the length of the longest contiguous subarray with all unique characters. >>> max_unique_subarray_length(\\"abcabcbb\\") 3 >>> max_unique_subarray_length(\\"bbbb\\") 1 >>> max_unique_subarray_length(\\"pwwkew\\") 3 >>> max_unique_subarray_length(\\"abcdef\\") 6 >>> max_unique_subarray_length(\\"tmttmtctct\\") 3","solution":"def max_unique_subarray_length(s: str) -> int: Returns the length of the longest contiguous subarray with all unique characters. n = len(s) if n == 0: return 0 char_index_map = {} max_length = 0 start = 0 for end in range(n): if s[end] in char_index_map: # Move start to the right of the last occurrence of s[end] start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_nth_from_end(head: ListNode, n: int) -> ListNode: def get_length(node): length = 0 while node: length += 1 node = next return length dummy = ListNode(0, head) length = get_length(head) current = dummy for _ in range(length - n): current = current.next current.next = current.next.next return dummy.next","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_nth_from_end(head: ListNode, n: int) -> ListNode: def get_length(node): length = 0 while node: length += 1 node = node.next return length dummy = ListNode(0, head) length = get_length(head) current = dummy for _ in range(length - n): current = current.next current.next = current.next.next return dummy.next"},{"question":"def merge_intervals(intervals): Merges overlapping intervals. if not intervals: return [] intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: last = merged[-1] if current[0] <= last[1]: # Overlap merged[-1] = (last[0], max(last[1], current[1])) else: merged.append(current) return merged def subtract_intervals(from_intervals, subtract_interval): Subtract one interval from a list of intervals. result = [] for start, end in from_intervals: if end <= subtract_interval[0] or start >= subtract_interval[1]: result.append((start, end)) else: if start < subtract_interval[0]: result.append((start, subtract_interval[0])) if end > subtract_interval[1]: result.append((subtract_interval[1], end)) return result def schedule_resources(tasks, maintenance): Write a function \`schedule_resources(tasks: list[tuple[int, int]], maintenance: tuple[int, int]) -> list[tuple[int, int]]\` that: 1. Merges overlapping intervals in both the \`tasks\` list and the maintenance interval. 2. Identifies and returns the list of time slots when resources are available. Args: tasks (list of tuple): List of tuples representing the intervals during which tasks are scheduled. maintenance (tuple of int): A tuple representing the interval during which maintenance is scheduled. Returns: list of tuple: A list of tuples representing the intervals during which resources are available. Example: >>> tasks = [(1, 5), (3, 7), (8, 12)] >>> maintenance = (6, 10) >>> schedule_resources(tasks, maintenance) [(0, 1), (12, float('inf'))] from solution import schedule_resources def test_no_tasks(): maintenance = (6, 10) tasks = [] assert schedule_resources(tasks, maintenance) == [(0, 6), (10, float('inf'))] def test_no_overlap(): tasks = [(1, 5), (8, 10)] maintenance = (12, 15) assert schedule_resources(tasks, maintenance) == [(0, 1), (5, 8), (10, 12), (15, float('inf'))] def test_full_overlap(): tasks = [(1, 5), (6, 7), (8, 12)] maintenance = (3, 10) assert schedule_resources(tasks, maintenance) == [(0, 1), (12, float('inf'))] def test_partial_overlap(): tasks = [(1, 5), (3, 7), (8, 12)] maintenance = (6, 10) assert schedule_resources(tasks, maintenance) == [(0, 1), (12, float('inf'))] def test_multiple_maintenance(): tasks = [(1, 5), (3, 7), (8, 12)] maintenance = (6, 10) assert schedule_resources(tasks, maintenance) == [(0, 1), (12, float('inf'))]","solution":"def merge_intervals(intervals): Merges overlapping intervals. if not intervals: return [] intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: last = merged[-1] if current[0] <= last[1]: # Overlap merged[-1] = (last[0], max(last[1], current[1])) else: merged.append(current) return merged def subtract_intervals(from_intervals, subtract_interval): Subtract one interval from a list of intervals. result = [] for start, end in from_intervals: if end <= subtract_interval[0] or start >= subtract_interval[1]: result.append((start, end)) else: if start < subtract_interval[0]: result.append((start, subtract_interval[0])) if end > subtract_interval[1]: result.append((subtract_interval[1], end)) return result def schedule_resources(tasks, maintenance): all_intervals = tasks + [maintenance] merged_intervals = merge_intervals(all_intervals) available_intervals = [] current_time = 0 for start, end in merged_intervals: if current_time < start: available_intervals.append((current_time, start)) current_time = max(current_time, end) if current_time < float('inf'): available_intervals.append((current_time, float('inf'))) return available_intervals"},{"question":"from typing import List, Tuple def shortest_travel_time(num_cities: int, roads: List[Tuple[int, int, int]], start: int, end: int) -> int: Compute the shortest travel time between two cities in a network using Dijkstra's algorithm. Args: num_cities: An integer representing the number of cities in the network. roads: A list of tuples where each tuple contains three integers (u, v, w) representing a bidirectional road from city u to city v with a travel time of w. start: An integer representing the starting city's number. end: An integer representing the destination city's number. Returns: An integer representing the shortest travel time between the start and end cities. If there is no path, returns -1. Examples: >>> shortest_travel_time(5, [(0, 1, 10), (1, 2, 20), (2, 3, 30), (3, 4, 40), (0, 4, 100)], 0, 4) 100 >>> shortest_travel_time(3, [(0, 1, 1), (1, 2, 1), (0, 2, 10)], 0, 2) 2 >>> shortest_travel_time(4, [(0, 1, 5), (1, 2, 10), (2, 3, 5), (0, 2, 20)], 0, 3) 20","solution":"import heapq from typing import List, Tuple def shortest_travel_time(num_cities: int, roads: List[Tuple[int, int, int]], start: int, end: int) -> int: # Create a graph from the roads graph = {i: [] for i in range(num_cities)} for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm initialization heap = [(0, start)] # (distance, node) distances = {i: float('inf') for i in range(num_cities)} distances[start] = 0 visited = set() while heap: current_distance, current_node = heapq.heappop(heap) if current_node in visited: continue visited.add(current_node) # If we reach the end city, return the distance if current_node == end: return current_distance # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(heap, (distance, neighbor)) # If end was not reached return -1"},{"question":"def sumNumbers(root: TreeNode) -> int: def dfs(node, current_number): if not node: return 0 current_number = current_number * 10 + node.val if not node.left and not node.right: return current_number return dfs(node.left, current_number) + dfs(node.right, current_number) return dfs(root, 0)","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumNumbers(root: TreeNode) -> int: def dfs(node, current_number): if not node: return 0 current_number = current_number * 10 + node.val if not node.left and not node.right: return current_number return dfs(node.left, current_number) + dfs(node.right, current_number) return dfs(root, 0)"},{"question":"def kmp_search(s: str, p: str) -> int: Find the starting index of the first occurrence of the pattern \`p\` in the string \`s\` using the Knuth-Morris-Pratt (KMP) algorithm. If the pattern is not found, return -1. >>> kmp_search(\\"ababcababcabc\\", \\"abc\\") == 2 >>> kmp_search(\\"hello\\", \\"ll\\") == 2 >>> kmp_search(\\"aaaaaaa\\", \\"bba\\") == -1 >>> kmp_search(\\"mississippi\\", \\"issi\\") == 1 def build_kmp_table(p: str): Build the KMP table for the given pattern. def test_kmp_search(): assert kmp_search(\\"ababcababcabc\\", \\"abc\\") == 2 assert kmp_search(\\"hello\\", \\"ll\\") == 2 assert kmp_search(\\"aaaaaaa\\", \\"bba\\") == -1 assert kmp_search(\\"mississippi\\", \\"issi\\") == 1 assert kmp_search(\\"a\\", \\"a\\") == 0 assert kmp_search(\\"abcdef\\", \\"def\\") == 3 assert kmp_search(\\"abcdef\\", \\"deg\\") == -1 assert kmp_search(\\"\\", \\"\\") == 0 assert kmp_search(\\"abc\\", \\"\\") == 0 assert kmp_search(\\"abc\\", \\"d\\") == -1 # Running the tests test_kmp_search()","solution":"def build_kmp_table(p): Build the KMP table for the given pattern. m = len(p) kmp_table = [0] * m j = 0 for i in range(1, m): while j > 0 and p[i] != p[j]: j = kmp_table[j - 1] if p[i] == p[j]: j += 1 kmp_table[i] = j return kmp_table def kmp_search(s: str, p: str) -> int: Returns the starting index of the first occurrence of the pattern \`p\` in the string \`s\`. If the pattern is not found, return -1. if not p: return 0 n, m = len(s), len(p) kmp_table = build_kmp_table(p) j = 0 for i in range(n): while j > 0 and s[i] != p[j]: j = kmp_table[j - 1] if s[i] == p[j]: if j == m - 1: return i - m + 1 else: j += 1 return -1"},{"question":"def longest_word_length(s: str) -> int: Given a string of words separated by spaces, return the length of the longest word in the string. If there are multiple words of the same longest length, return the first one encountered. Ensure your solution efficiently handles long strings with numerous words. >>> longest_word_length(\\"The quick brown fox jumps over the lazy dog\\") == 5 >>> longest_word_length(\\"Hello world\\") == 5 >>> longest_word_length(\\"To be or not to be\\") == 3 >>> longest_word_length(\\"\\") == 0 >>> longest_word_length(\\"a ab abc abcd abcde abcdef\\") == 6 from solution import longest_word_length def test_longest_word_length_normal_case(): assert longest_word_length(\\"The quick brown fox jumps over the lazy dog\\") == 5 def test_longest_word_length_single_word(): assert longest_word_length(\\"Hello\\") == 5 def test_longest_word_length_multiple_equal_length_words(): assert longest_word_length(\\"To be or not to be\\") == 3 def test_longest_word_length_empty_string(): assert longest_word_length(\\"\\") == 0 def test_longest_word_length_single_long_word(): assert longest_word_length(\\"aaaaaaaaaaaaaaaaaa\\") == 18 def test_longest_word_length_with_various_lengths(): assert longest_word_length(\\"a ab abc abcd abcde abcdef\\") == 6 def test_longest_word_length_with_trailing_spaces(): assert longest_word_length(\\"word1 word2 word3 \\") == 5 def test_longest_word_length_with_leading_spaces(): assert longest_word_length(\\" word1 word2 word3\\") == 5 def test_longest_word_length_with_only_spaces(): assert longest_word_length(\\" \\") == 0","solution":"def longest_word_length(s: str) -> int: Returns the length of the longest word in the string s. if not s.strip(): return 0 words = s.split(' ') max_length = 0 for word in words: max_length = max(max_length, len(word)) return max_length"},{"question":"from typing import List def adjust_brightness(image: List[List[int]], factor: float) -> List[List[int]]: Adjust the brightness of an image represented by a 2D list of pixel values. Each pixel value should be multiplied by the factor and clamped to the range [0, 255]. >>> adjust_brightness([[100, 150, 200], [50, 80, 120]], 1.2) == [[120, 180, 240], [60, 96, 144]] >>> adjust_brightness([[0, 255], [128, 128]], 0.5) == [[0, 127], [64, 64]] >>> adjust_brightness([[10, 20, 30], [40, 50, 60]], 0.0) == [[0, 0, 0], [0, 0, 0]] # Unit tests def test_adjust_brightness_increase(): assert adjust_brightness([[100, 150, 200], [50, 80, 120]], 1.2) == [[120, 180, 240], [60, 96, 144]] def test_adjust_brightness_decrease(): assert adjust_brightness([[0, 255], [128, 128]], 0.5) == [[0, 127], [64, 64]] def test_adjust_brightness_zero_factor(): assert adjust_brightness([[10, 20, 30], [40, 50, 60]], 0.0) == [[0, 0, 0], [0, 0, 0]] def test_adjust_brightness_high_factor(): assert adjust_brightness([[10, 100, 200], [200, 200, 200]], 2.0) == [[20, 200, 255], [255, 255, 255]] def test_adjust_brightness_identity_factor(): assert adjust_brightness([[0, 123, 255], [65, 130, 255]], 1.0) == [[0, 123, 255], [65, 130, 255]] def test_adjust_brightness_minimum_values(): assert adjust_brightness([[0, 0, 0], [0, 0, 0]], 1.0) == [[0, 0, 0], [0, 0, 0]] def test_adjust_brightness_maximum_values(): assert adjust_brightness([[255, 255, 255], [255, 255, 255]], 1.0) == [[255, 255, 255], [255, 255, 255]]","solution":"from typing import List def adjust_brightness(image: List[List[int]], factor: float) -> List[List[int]]: def clamp(value: int) -> int: return max(0, min(255, value)) adjusted_image = [] for row in image: adjusted_row = [clamp(int(pixel * factor)) for pixel in row] adjusted_image.append(adjusted_row) return adjusted_image"},{"question":"import math class Vector2D: A class to represent a 2D vector and perform various operations. >>> v1 = Vector2D(3, 4) >>> v2 = Vector2D(1, 2) >>> v1.add(v2) # Vector2D(4, 6) >>> v1.subtract(v2) # Vector2D(2, 2) >>> v1.multiply_by_scalar(3) # Vector2D(9, 12) >>> v1.dot_product(v2) # 11 >>> v1.magnitude() # 5.0 def __init__(self, x: float, y: float): self.x = x self.y = y def add(self, other: 'Vector2D') -> 'Vector2D': pass def subtract(self, other: 'Vector2D') -> 'Vector2D': pass def multiply_by_scalar(self, scalar: float) -> 'Vector2D': pass def dot_product(self, other: 'Vector2D') -> float: pass def magnitude(self) -> float: pass def __repr__(self) -> str: return f\\"Vector2D({self.x}, {self.y})\\" def __eq__(self, other): return math.isclose(self.x, other.x) and math.isclose(self.y, other.y)","solution":"import math class Vector2D: def __init__(self, x: float, y: float): self.x = x self.y = y def add(self, other: 'Vector2D') -> 'Vector2D': return Vector2D(self.x + other.x, self.y + other.y) def subtract(self, other: 'Vector2D') -> 'Vector2D': return Vector2D(self.x - other.x, self.y - other.y) def multiply_by_scalar(self, scalar: float) -> 'Vector2D': return Vector2D(self.x * scalar, self.y * scalar) def dot_product(self, other: 'Vector2D') -> float: return self.x * other.x + self.y * other.y def magnitude(self) -> float: return math.sqrt(self.x**2 + self.y**2) def __repr__(self) -> str: return f\\"Vector2D({self.x}, {self.y})\\" def __eq__(self, other): return math.isclose(self.x, other.x) and math.isclose(self.y, other.y)"},{"question":"def rotate_array(nums: list[int], k: int) -> None: Rotates the array in-place to the right by k steps. Args: nums (list[int]): The list of integers to be rotated. k (int): The number of steps to rotate the array. Returns: None Examples: >>> arr = [1, 2, 3, 4, 5, 6, 7] >>> rotate_array(arr, 3) >>> arr [5, 6, 7, 1, 2, 3, 4] >>> arr = [-1, -100, 3, 99] >>> rotate_array(arr, 2) >>> arr [3, 99, -1, -100]","solution":"def rotate_array(nums: list[int], k: int) -> None: Rotates the array in-place to the right by k steps. Args: nums (list[int]): The list of integers to be rotated. k (int): The number of steps to rotate the array. Returns: None n = len(nums) # Handle cases where k is greater than the length of the array k = k % n # Reverse the entire array nums.reverse() # Reverse the first k elements nums[:k] = reversed(nums[:k]) # Reverse the rest of the array nums[k:] = reversed(nums[k:]) # Example usage: # arr = [1, 2, 3, 4, 5, 6, 7] # rotate_array(arr, 3) # print(arr) # Output: [5, 6, 7, 1, 2, 3, 4]"},{"question":"from typing import List, Optional def find_largest_perfect_square(numbers: List[int]) -> Optional[int]: Returns the largest perfect square number from the list or None if none exists. A number is considered a perfect square if it is the square of an integer. Args: numbers (list[int]): A list of integers. Returns: int: The largest perfect square number from the list or None if none exists. Examples: >>> find_largest_perfect_square([1, 4, 9, 16, 25, 30, 40]) == 25 >>> find_largest_perfect_square([3, 5, 7, 10, 12]) == None >>> find_largest_perfect_square([0, -1, -4, -9]) == 0 >>> find_largest_perfect_square([16, 20, 24, 36, 49]) == 49 >>> find_largest_perfect_square([]) == None","solution":"import math def find_largest_perfect_square(numbers: list[int]) -> int: Returns the largest perfect square number from the list or None if none exists. Args: numbers (list[int]): A list of integers. Returns: int: The largest perfect square number from the list or None if none exists. if not all(isinstance(num, int) for num in numbers): raise ValueError(\\"All elements of the input list must be integers.\\") largest_perfect_square = None for num in numbers: if num >= 0 and int(math.sqrt(num)) ** 2 == num: if largest_perfect_square is None or num > largest_perfect_square: largest_perfect_square = num return largest_perfect_square"},{"question":"from typing import List, Tuple def maze_solver(maze: List[List[int]]) -> List[Tuple[int, int]]: Finds a path from the top-left corner to the bottom-right corner in a maze. Args: maze (List[List[int]]): The maze represented as a 2D list filled with 0s and 1s. Returns: List[Tuple[int, int]]: A list of tuples representing the path, or an empty list if no path exists. >>> maze_solver([[0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [1, 1, 0, 1, 1], ... [0, 0, 0, 0, 0]]) [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2), (4, 2), (4, 3), (4, 4)] >>> maze_solver([[0, 1], ... [1, 0]]) []","solution":"from typing import List, Tuple def maze_solver(maze: List[List[int]]) -> List[Tuple[int, int]]: Finds a path from the top-left corner to the bottom-right corner in a maze. Args: maze (List[List[int]]): The maze represented as a 2D list filled with 0s and 1s. Returns: List[Tuple[int, int]]: A list of tuples representing the path, or an empty list if no path exists. >>> maze_solver([[0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [1, 1, 0, 1, 1], ... [0, 0, 0, 0, 0]]) [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2), (4, 2), (4, 3), (4, 4)] >>> maze_solver([[0, 1], ... [1, 0]]) [] def is_safe(maze, x, y, visited): return (0 <= x < len(maze)) and (0 <= y < len(maze[0])) and maze[x][y] == 0 and (x, y) not in visited def solve_maze(maze, x, y, path, visited): if x == len(maze) - 1 and y == len(maze[0]) - 1: path.append((x, y)) return True if is_safe(maze, x, y, visited): path.append((x, y)) visited.add((x, y)) # Move right if solve_maze(maze, x, y + 1, path, visited): return True # Move down if solve_maze(maze, x + 1, y, path, visited): return True # Move left if solve_maze(maze, x, y - 1, path, visited): return True # Move up if solve_maze(maze, x - 1, y, path, visited): return True path.pop() visited.remove((x, y)) return False path = [] visited = set() if solve_maze(maze, 0, 0, path, visited): return path else: return []"},{"question":"def auto_suggest(dictionary: list, prefix: str) -> list: Returns a list of words from the dictionary that start with the given prefix, sorted in ascending order. >>> auto_suggest([\\"apple\\", \\"apricot\\", \\"banana\\", \\"blueberry\\", \\"cherry\\", \\"date\\", \\"fig\\", \\"grape\\"], \\"ap\\") [\\"apple\\", \\"apricot\\"] >>> auto_suggest([\\"apple\\", \\"apricot\\", \\"banana\\", \\"blueberry\\", \\"cherry\\", \\"date\\", \\"fig\\", \\"grape\\"], \\"bl\\") [\\"blueberry\\"] >>> auto_suggest([\\"apple\\", \\"apricot\\", \\"banana\\", \\"blueberry\\", \\"cherry\\", \\"date\\", \\"fig\\", \\"grape\\"], \\"ch\\") [\\"cherry\\"] >>> auto_suggest([\\"apple\\", \\"apricot\\", \\"banana\\", \\"blueberry\\", \\"cherry\\", \\"date\\", \\"fig\\", \\"grape\\"], \\"x\\") []","solution":"def auto_suggest(dictionary: list, prefix: str) -> list: Returns a list of words from the dictionary that start with the given prefix, sorted in ascending order. suggestions = [word for word in dictionary if word.startswith(prefix)] suggestions.sort() return suggestions"},{"question":"def generate_iban(account_number: str, bank_code: str, country_code: str) -> str: Generate an IBAN for a bank account. Args: account_number (str): Numeric account number of the bank account. Length between 8 and 20 digits. bank_code (str): Numeric code representing the bank. Length between 4 and 8 digits. country_code (str): The ISO 3166-1 alpha-2 country code. Exactly 2 uppercase letters. Returns: str: Generated IBAN. pass def validate_iban(iban: str) -> bool: Validate an IBAN. Args: iban (str): The IBAN string to validate. Returns: bool: True if the IBAN is valid, False otherwise. pass def test_generate_iban(): account_number = \\"12345678\\" bank_code = \\"1234\\" country_code = \\"DE\\" iban = generate_iban(account_number, bank_code, country_code) assert iban.startswith(\\"DE\\"), \\"Country code should be at the beginning of IBAN\\" assert validate_iban(iban), f\\"Generated IBAN {iban} should be valid\\" def test_generate_iban_invalid_account_number(): try: generate_iban(\\"1234\\", \\"1234\\", \\"DE\\") except ValueError as e: assert str(e) == \\"Account number must be between 8 and 20 digits\\" def test_generate_iban_invalid_bank_code(): try: generate_iban(\\"12345678\\", \\"12\\", \\"DE\\") except ValueError as e: assert str(e) == \\"Bank code must be between 4 and 8 digits\\" def test_generate_iban_invalid_country_code(): try: generate_iban(\\"12345678\\", \\"1234\\", \\"DEU\\") except ValueError as e: assert str(e) == \\"Country code must be exactly 2 uppercase letters\\" def test_validate_iban(): # Typically generated IBAN that meets the conditions valid_iban = \\"DE89370400440532013000\\" assert validate_iban(valid_iban) == True, f\\"Expected True but got {validate_iban(valid_iban)}\\" def test_validate_iban_invalid(): invalid_iban = \\"DE0089234500012345678XX\\" assert validate_iban(invalid_iban) == False, f\\"Expected False but got {validate_iban(invalid_iban)}\\" def test_validate_iban_incorrect_check_digits(): invalid_iban = \\"DE00123400001234567890\\" # Incorrect check digits assert validate_iban(invalid_iban) == False, f\\"Expected False but got {validate_iban(invalid_iban)}\\"","solution":"def generate_iban(account_number: str, bank_code: str, country_code: str) -> str: def mod97(value: str) -> int: return int(value) % 97 # Validate inputs if not (8 <= len(account_number) <= 20 and account_number.isdigit()): raise ValueError(\\"Account number must be between 8 and 20 digits\\") if not (4 <= len(bank_code) <= 8 and bank_code.isdigit()): raise ValueError(\\"Bank code must be between 4 and 8 digits\\") if not (len(country_code) == 2 and country_code.isalpha() and country_code.isupper()): raise ValueError(\\"Country code must be exactly 2 uppercase letters\\") # Step 1: Assemble the IBAN without check digits partial_iban = bank_code + account_number + country_code + \\"00\\" # Step 2: Move country code and \\"00\\" to the end and convert letters to numbers (A=10, B=11, ..., Z=35) modified_iban = '' for char in partial_iban: if char.isdigit(): modified_iban += char else: modified_iban += str(ord(char) - 55) # Step 3: Calculate check digits check_digits = 98 - mod97(modified_iban) # Step 4: Create the full IBAN with check digits check_digits_str = str(check_digits).zfill(2) # Ensure check digits are two characters long full_iban = country_code + check_digits_str + bank_code + account_number return full_iban def validate_iban(iban: str) -> bool: # Step 1: Rearrange the IBAN by moving the first four characters to the end rearranged_iban = iban[4:] + iban[:4] # Step 2: Convert letters to numbers (A=10, B=11, ..., Z=35) numeric_iban = '' for char in rearranged_iban: if char.isdigit(): numeric_iban += char else: numeric_iban += str(ord(char) - 55) # Step 3: Perform the mod-97 operation return int(numeric_iban) % 97 == 1"},{"question":"def int_to_roman(n: int) -> str: Convert an integer to a Roman numeral representation. Parameters: n (int): an integer (1 ≤ n ≤ 3999) Returns: str: Roman numeral representation of the input integer. >>> int_to_roman(9) 'IX' >>> int_to_roman(40) 'XL' >>> int_to_roman(3999) 'MMMCMXCIX' >>> int_to_roman(2021) 'MMXXI' pass","solution":"def int_to_roman(n: int) -> str: Convert an integer to a Roman numeral. Parameters: n (int): an integer (1 ≤ n ≤ 3999) Returns: str: Roman numeral representation of the input integer. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' i = 0 while n > 0: for _ in range(n // val[i]): roman_num += syb[i] n -= val[i] i += 1 return roman_num"},{"question":"def reverse_words(sentence: str) -> str: Reverses the words in the given sentence. >>> reverse_words(\\"hello world\\") 'world hello' >>> reverse_words(\\"coding is fun\\") 'fun is coding' >>> reverse_words(\\"a b c d\\") 'd c b a' >>> reverse_words(\\"singleword\\") 'singleword' >>> reverse_words(\\"\\") '' >>> reverse_words(\\"one\\") 'one' >>> reverse_words(\\"one two three\\") 'three two one'","solution":"def reverse_words(sentence: str) -> str: Reverses the words in the given sentence. Parameters: sentence (str): The sentence with words to reverse. Returns: str: A new string with the words in reverse order. words = sentence.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"def find_sync_differences(src: dict, dst: dict) -> list: Determine the files that need to be updated or copied from the source to the destination directory. :param src: dict, representing the source directory as a nested dictionary :param dst: dict, representing the destination directory as a nested dictionary :return: list, a list of file paths that are missing or outdated in the destination directory >>> src = { ... \\"folder1\\": { ... \\"file1.txt\\": (123, \\"hash1\\"), ... \\"subfolder\\": { ... \\"file2.txt\\": (345, \\"hash2\\"), ... }, ... }, ... \\"folder2\\": { ... \\"file3.txt\\": (567, \\"hash3\\"), ... }, ... } >>> dst = { ... \\"folder1\\": { ... \\"file1.txt\\": (123, \\"hash1\\"), ... \\"subfolder\\": { ... \\"file2.txt\\": (345, \\"wrong_hash\\"), ... }, ... }, ... \\"folder2\\": {}, ... } >>> find_sync_differences(src, dst) ['folder1/subfolder/file2.txt', 'folder2/file3.txt']","solution":"def find_sync_differences(src, dst): Determine the files that need to be updated or copied from the source to the destination directory. :param src: dict, representing the source directory as a nested dictionary :param dst: dict, representing the destination directory as a nested dictionary :return: list, a list of file paths that are missing or outdated in the destination directory def traverse(src, dst, path): result = [] for key, value in src.items(): new_path = path + '/' + key if path else key if isinstance(value, dict): result += traverse(value, dst.get(key, {}), new_path) else: if key not in dst or dst[key] != value: result.append(new_path) return result return traverse(src, dst, \\"\\")"},{"question":"from typing import List, Tuple def count_unique_paths(n: int, roads: List[Tuple[int, int]], start: int, destination: int) -> int: Calculate the number of unique sequences of roads that connect the starting landmark to the destination landmark without revisiting any landmark within the same path. >>> count_unique_paths(5, [(0, 1), (0, 2), (1, 3), (2, 3), (3, 4)], 0, 4) 2 >>> count_unique_paths(4, [(0, 1), (1, 2), (2, 3)], 0, 3) 1","solution":"from typing import List, Tuple def count_unique_paths(n: int, roads: List[Tuple[int, int]], start: int, destination: int) -> int: from collections import defaultdict def dfs(current, destination, graph, visited): if current == destination: return 1 visited[current] = True path_count = 0 for neighbor in graph[current]: if not visited[neighbor]: path_count += dfs(neighbor, destination, graph, visited) visited[current] = False return path_count graph = defaultdict(list) for u, v in roads: graph[u].append(v) visited = [False] * n return dfs(start, destination, graph, visited)"},{"question":"def differentiate_and_count(elements: list) -> dict: Differentiate and count unique integers and strings from the list of elements. >>> differentiate_and_count([3, \\"apple\\", 1, \\"banana\\", \\"apple\\", 2, \\"banana\\", 3, \\"cherry\\"]) {'integers': [1, 2, 3], 'strings': ['apple', 'banana', 'cherry'], 'counts': {'integer_count': 3, 'string_count': 3}} >>> differentiate_and_count([42, \\"42\\", \\"hello\\", 42, \\"world\\", \\"hello\\"]) {'integers': [42], 'strings': ['42', 'hello', 'world'], 'counts': {'integer_count': 1, 'string_count': 3}}","solution":"def differentiate_and_count(elements: list) -> dict: integers = set() strings = set() for element in elements: if isinstance(element, int): integers.add(element) elif isinstance(element, str): strings.add(element) sorted_integers = sorted(integers) sorted_strings = sorted(strings) result = { 'integers': sorted_integers, 'strings': sorted_strings, 'counts': { 'integer_count': len(sorted_integers), 'string_count': len(sorted_strings) } } return result"},{"question":"class QueueUsingStacks: Implement a queue using stacks. >>> queue = QueueUsingStacks() >>> queue.enqueue(1) >>> queue.enqueue(2) >>> queue.enqueue(3) >>> queue.peek() 1 >>> queue.dequeue() 1 >>> queue.peek() 2 >>> queue.dequeue() 2 >>> queue.peek() 3 >>> queue.empty() False >>> queue.dequeue() 3 >>> queue.empty() True def __init__(self): Initialize your data structure here. self.stack1 = [] self.stack2 = [] def enqueue(self, x: int) -> None: Push element x to the back of queue. :type x: int :rtype: void self.stack1.append(x) def dequeue(self) -> int: Removes the element from in front of queue and returns that element. :rtype: int self._transfer_stacks_if_needed() return self.stack2.pop() def peek(self) -> int: Get the front element. :rtype: int self._transfer_stacks_if_needed() return self.stack2[-1] def empty(self) -> bool: Returns whether the queue is empty. :rtype: bool return not self.stack1 and not self.stack2 def _transfer_stacks_if_needed(self): Transfer elements from stack1 to stack2 if stack2 is empty. :rtype: void if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop())","solution":"class QueueUsingStacks: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, x: int) -> None: self.stack1.append(x) def dequeue(self) -> int: self._transfer_stacks_if_needed() return self.stack2.pop() def peek(self) -> int: self._transfer_stacks_if_needed() return self.stack2[-1] def empty(self) -> bool: return not self.stack1 and not self.stack2 def _transfer_stacks_if_needed(self): if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop())"},{"question":"def numSquares(n: int) -> int: Find the least number of perfect square numbers which sum to a given positive integer \`n\`. >>> numSquares(12) 3 >>> numSquares(13) 2 >>> numSquares(1) 1","solution":"def numSquares(n: int) -> int: Returns the least number of perfect square numbers which sum to n. # List of all perfect squares up to n perfect_squares = [] i = 1 while i * i <= n: perfect_squares.append(i * i) i += 1 # Dynamic Programming Array dp = [float('inf')] * (n + 1) dp[0] = 0 # Compute the least number of perfect squares that sum up to every number up to n for i in range(1, n + 1): for sq in perfect_squares: if i < sq: break dp[i] = min(dp[i], dp[i - sq] + 1) return dp[n]"},{"question":"def generate_identifier(filename: str) -> str: Generates a unique identifier for the given filename. The identifier is in lowercase, with all spaces replaced by underscores, and only contains alphanumeric characters and underscores. Args: filename (str): A string representing the name of the file. Returns: str: A string which is the transformed identifier for the filename. Examples: >>> generate_identifier(\\"My File 2023.v1\\") 'my_file_2023v1' >>> generate_identifier(\\"Project Plan!Final.docx\\") 'project_planfinaldocx' >>> generate_identifier(\\"image (2).jpeg\\") 'image_2jpeg' >>> generate_identifier(\\"Sample_File_#1\\") 'sample_file_1'","solution":"import re def generate_identifier(filename: str) -> str: Generates a unique identifier for the given filename. The identifier is in lowercase, with all spaces replaced by underscores, and only contains alphanumeric characters and underscores. # Convert to lowercase filename = filename.lower() # Replace spaces with underscores filename = filename.replace(\\" \\", \\"_\\") # Remove all characters that are not alphanumeric or underscores identifier = re.sub(r'[^a-z0-9_]', '', filename) return identifier"},{"question":"class ElevatorSystem: Simulates a basic elevator system that can handle requests and move between floors efficiently. >>> elevator = ElevatorSystem(10) >>> elevator.request_floor(5) Moving up to floor 5 >>> elevator.request_floor(2) Moving down to floor 2 >>> elevator.request_floor(2) Already on floor 2 >>> elevator.request_floor(8) Moving up to floor 8 def __init__(self, num_floors: int): self.num_floors = num_floors self.current_floor = 1 def request_floor(self, floor: int) -> str: pass","solution":"class ElevatorSystem: def __init__(self, num_floors: int): self.num_floors = num_floors self.current_floor = 1 def request_floor(self, floor: int) -> str: if floor < 1 or floor > self.num_floors: return \\"Invalid floor request\\" if floor > self.current_floor: result = f\\"Moving up to floor {floor}\\" self.current_floor = floor elif floor < self.current_floor: result = f\\"Moving down to floor {floor}\\" self.current_floor = floor else: result = f\\"Already on floor {floor}\\" return result"},{"question":"from typing import List def shortest_path(maze: List[List[int]]) -> int: Returns the length of the shortest path from the top-left corner (0, 0) to the bottom-right corner (n-1, n-1) in a maze represented as a grid. If there is no path, returns -1. >>> maze = [ ... [0, 0, 1, 0], ... [1, 0, 1, 0], ... [1, 0, 0, 0], ... [1, 1, 1, 0] ... ] >>> shortest_path(maze) 7 >>> maze = [ ... [0, 1], ... [1, 0] ... ] >>> shortest_path(maze) -1 >>> maze = [ ... [1, 0], ... [0, 0] ... ] >>> shortest_path(maze) -1 >>> maze = [ ... [0, 0], ... [0, 1] ... ] >>> shortest_path(maze) -1 >>> maze = [ ... [0] ... ] >>> shortest_path(maze) 1 >>> maze = [ ... [1] ... ] >>> shortest_path(maze) -1 >>> maze = [ ... [0] * 100 for _ in range(100) ... ] >>> shortest_path(maze) 199","solution":"from collections import deque from typing import List def shortest_path(maze: List[List[int]]) -> int: Returns the length of the shortest path from the top-left corner (0, 0) to the bottom-right corner (n-1, n-1). If there is no path, returns -1. n = len(maze) m = len(maze[0]) # Check if the start or end is blocked if maze[0][0] == 1 or maze[n-1][m-1] == 1: return -1 # Initialize queues for BFS queue = deque([(0, 0, 1)]) # (row, column, distance) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right # Mark the start as visited maze[0][0] = 1 while queue: row, col, dist = queue.popleft() # If we reached the bottom-right corner if row == n - 1 and col == m - 1: return dist for dr, dc in directions: newRow, newCol = row + dr, col + dc # If the new position is within bounds and is not visited if 0 <= newRow < n and 0 <= newCol < m and maze[newRow][newCol] == 0: queue.append((newRow, newCol, dist + 1)) # Mark as visited maze[newRow][newCol] = 1 # If there's no path return -1"},{"question":"from typing import List, Tuple def nearest_distance(points: List[Tuple[int, int]]) -> float: Calculates the smallest Euclidean distance between any two distinct points in the list. >>> nearest_distance([(0, 0), (3, 4), (1, 1), (2, 2)]) == 1.4142135623730951 >>> nearest_distance([(0, 0), (1, 0)]) == 1.0 >>> nearest_distance([(0, 0), (0, 2), (2, 0), (2, 2)]) == 2.0 >>> nearest_distance([]) == float('inf') >>> nearest_distance([(0, 0)]) == float('inf') >>> nearest_distance([(0, 0), (0, 1000000)]) == 1000000.0 >>> nearest_distance([(2, 3), (12, 30), (40, 50), (5, 1), (12, 10), (3, 4)]) == 1.4142135623730951","solution":"from typing import List, Tuple import math def nearest_distance(points: List[Tuple[int, int]]) -> float: Finds the smallest Euclidean distance between any two points in the list. def euclidean_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float: return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) n = len(points) if n < 2: return float('inf') points.sort() def closest_pair(ax): L = len(ax) if L <= 3: return min( [euclidean_distance(ax[i], ax[j]) for i in range(L) for j in range(i + 1, L)], default=float('inf') ) mid = L // 2 midpoint = ax[mid] dl = closest_pair(ax[:mid]) dr = closest_pair(ax[mid:]) d = min(dl, dr) strip = [p for p in ax if abs(p[0] - midpoint[0]) < d] strip.sort(key=lambda x: x[1]) size = len(strip) for i in range(size): for j in range(i + 1, size): if (strip[j][1] - strip[i][1]) >= d: break d = min(d, euclidean_distance(strip[i], strip[j])) return d return closest_pair(points)"},{"question":"def fib(n: int) -> int: Calculate the n-th Fibonacci number using memoization. >>> fib(0) 0 >>> fib(1) 1 >>> fib(6) 8 >>> fib(10) 55 >>> fib(20) 6765","solution":"def fib(n: int) -> int: Returns the n-th Fibonacci number using memoization memo = {0: 0, 1: 1} def helper(x): if x not in memo: memo[x] = helper(x - 1) + helper(x - 2) return memo[x] return helper(n)"},{"question":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: Inserts a word into the trie. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: Returns if the word is in the trie. node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def search_with_wildcard(self, word: str) -> bool: Returns if there is any word in the trie that matches the wildcard pattern. The wildcard character '.' can match any single letter. >>> trie = Trie() >>> trie.insert(\\"bad\\") >>> trie.insert(\\"dad\\") >>> trie.insert(\\"mad\\") >>> trie.search_with_wildcard(\\"b..\\") True >>> trie.search_with_wildcard(\\"d.g\\") False","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def search_with_wildcard(self, word: str) -> bool: return self._search_with_wildcard_recursive(word, 0, self.root) def _search_with_wildcard_recursive(self, word, index, node): if index == len(word): return node.is_end_of_word char = word[index] if char == '.': for child in node.children.values(): if self._search_with_wildcard_recursive(word, index + 1, child): return True elif char in node.children: return self._search_with_wildcard_recursive(word, index + 1, node.children[char]) return False"},{"question":"def celsius_to_fahrenheit(celsius: float) -> float: Converts a temperature from Celsius to Fahrenheit. >>> celsius_to_fahrenheit(0) 32.0 >>> celsius_to_fahrenheit(100) 212.0 >>> celsius_to_fahrenheit(-40) -40.0 >>> celsius_to_fahrenheit(37) 98.6 def fahrenheit_to_celsius(fahrenheit: float) -> float: Converts a temperature from Fahrenheit to Celsius. >>> fahrenheit_to_celsius(32) 0.0 >>> fahrenheit_to_celsius(212) 100.0 >>> fahrenheit_to_celsius(-40) -40.0 >>> fahrenheit_to_celsius(98.6) 37.0 def temperature_converter(temperature: float, from_unit: str, to_unit: str) -> float: Converts the temperature from one unit to another. Parameters: temperature (float): The temperature value to be converted. from_unit (str): The unit of the input temperature, \\"C\\" for Celsius or \\"F\\" for Fahrenheit. to_unit (str): The unit of the desired output temperature, \\"C\\" for Celsius or \\"F\\" for Fahrenheit. Returns: float: The converted temperature. Raises: ValueError: If from_unit or to_unit is not \\"C\\" or \\"F\\", or if from_unit and to_unit are the same. >>> temperature_converter(0, 'C', 'F') 32.0 >>> temperature_converter(100, 'C', 'F') 212.0 >>> temperature_converter(32, 'F', 'C') 0.0 >>> temperature_converter(212, 'F', 'C') 100.0","solution":"def celsius_to_fahrenheit(celsius: float) -> float: Converts a temperature from Celsius to Fahrenheit. return (celsius * 9/5) + 32 def fahrenheit_to_celsius(fahrenheit: float) -> float: Converts a temperature from Fahrenheit to Celsius. return (fahrenheit - 32) * 5/9 def temperature_converter(temperature: float, from_unit: str, to_unit: str) -> float: Converts the temperature from one unit to another. Parameters: temperature (float): The temperature value to be converted. from_unit (str): The unit of the input temperature, \\"C\\" for Celsius or \\"F\\" for Fahrenheit. to_unit (str): The unit of the desired output temperature, \\"C\\" for Celsius or \\"F\\" for Fahrenheit. Returns: float: The converted temperature. Raises: ValueError: If from_unit or to_unit is not \\"C\\" or \\"F\\", or if from_unit and to_unit are the same. if from_unit == to_unit: raise ValueError(\\"from_unit and to_unit must be different.\\") if from_unit == 'C' and to_unit == 'F': return celsius_to_fahrenheit(temperature) elif from_unit == 'F' and to_unit == 'C': return fahrenheit_to_celsius(temperature) else: raise ValueError(\\"Invalid unit. Use 'C' for Celsius and 'F' for Fahrenheit.\\")"},{"question":"from typing import List def has_contiguous_subarray(arr: List[int], target: int) -> bool: Determines if there exists a contiguous subarray within the array whose sum is equal to the target integer. >>> has_contiguous_subarray([1, 2, 3, 7, 5], 12) # Output: True >>> has_contiguous_subarray([1, 2, 3, 4, 5], 9) # Output: True >>> has_contiguous_subarray([1, 2, 3, 4, 5], 20) # Output: False >>> has_contiguous_subarray([10, 2, -2, -20, 10], -10) # Output: True >>> has_contiguous_subarray([-1, -1, 1, -1, -1, 1], 0) # Output: True","solution":"from typing import List def has_contiguous_subarray(arr: List[int], target: int) -> bool: Determines if there exists a contiguous subarray within the array whose sum is equal to the target integer. current_sum = 0 sum_dict = {} for index, value in enumerate(arr): current_sum += value if current_sum == target: return True if current_sum - target in sum_dict: return True sum_dict[current_sum] = index return False"},{"question":"def find_duplicate(nums: list[int]) -> int: Finds and returns the duplicate number in the array without modifying the original array and using only constant extra space. >>> find_duplicate([1, 3, 4, 2, 2]) 2 >>> find_duplicate([3, 1, 3, 4, 2]) 3 >>> find_duplicate([1, 1, 2]) 1 >>> find_duplicate([1, 2, 2]) 2 >>> find_duplicate([2, 2, 2, 2, 2]) 2 >>> find_duplicate([2, 5, 9, 6, 9, 3, 8, 9, 7, 1]) 9 >>> find_duplicate([1, 1]) 1 >>> find_duplicate([3, 3, 3, 3, 3, 3, 3, 3, 3, 2]) 3","solution":"def find_duplicate(nums): Finds and returns the duplicate number in the array without modifying the array and using only constant extra space. slow = nums[0] fast = nums[0] # Phase 1: Finding the intersection point in the cycle. while True: slow = nums[slow] fast = nums[nums[fast]] if slow == fast: break # Phase 2: Finding the entrance to the cycle. slow = nums[0] while slow != fast: slow = nums[slow] fast = nums[fast] return slow"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates an arithmetic expression and returns its value. Args: expression (str): The string representing the arithmetic expression. Returns: float: The calculated value of the expression. Examples: >>> evaluate_expression(\\"3 + 5 * 2\\") 13.0 >>> evaluate_expression(\\"(2 - 3) * 4\\") -4.0 >>> evaluate_expression(\\"2 * (3 + 4) / (7 - 3) + 1\\") 4.5 pass def test_simple_addition(): assert evaluate_expression(\\"3 + 5\\") == 8.0 def test_simple_subtraction(): assert evaluate_expression(\\"10 - 5\\") == 5.0 def test_multiplication_and_addition(): assert evaluate_expression(\\"3 + 5 * 2\\") == 13.0 def test_parentheses(): assert evaluate_expression(\\"(2 - 3) * 4\\") == -4.0 def test_complex_expression(): assert evaluate_expression(\\"2 * (3 + 4) / (7 - 3) + 1\\") == 4.5 def test_nested_parentheses(): assert evaluate_expression(\\"2 * ((2 + 3) * (2 + 2))\\") == 40.0 def test_division(): assert evaluate_expression(\\"10 / 2\\") == 5.0 def test_division_by_zero(): import pytest with pytest.raises(ZeroDivisionError): evaluate_expression(\\"10 / 0\\") def test_combined_operations(): assert evaluate_expression(\\"1 + 2 * 3 - 4 / 2\\") == 5.0 def test_whitespace_handling(): assert evaluate_expression(\\" 2 * (3 + 4) / (7 - 3 ) + 1\\") == 4.5","solution":"def evaluate_expression(expression: str) -> float: Evaluates an arithmetic expression and returns its value. Args: expression (str): The string representing the arithmetic expression. Returns: float: The calculated value of the expression. import re # Remove any spaces in the expression for easier processing expression = expression.replace(' ', '') def parse_expression(tokens): def parse_term(tokens): term, tokens = parse_factor(tokens) while tokens and tokens[0] in ('*', '/'): op = tokens.pop(0) factor, tokens = parse_factor(tokens) if op == '*': term *= factor else: term /= factor return term, tokens def parse_factor(tokens): if tokens[0] == '(': tokens.pop(0) expr, tokens = parse_expression(tokens) assert tokens.pop(0) == ')' return expr, tokens match = re.match(r'd+', tokens.pop(0)) return float(match.group()), tokens term, tokens = parse_term(tokens) while tokens and tokens[0] in ('+', '-'): op = tokens.pop(0) term_next, tokens = parse_term(tokens) if op == '+': term += term_next else: term -= term_next return term, tokens def tokenize(expression): token_spec = [ ('NUMBER', r'd+'), ('PLUS', r'+'), ('MINUS', r'-'), ('TIMES', r'*'), ('DIVIDE', r'/'), ('LPAREN', r'('), ('RPAREN', r')'), ] tok_regex = '|'.join(f'(?P<{pair[0]}>{pair[1]})' for pair in token_spec) for match in re.finditer(tok_regex, expression): yield match.group() tokens = list(tokenize(expression)) result, _ = parse_expression(tokens) return result"},{"question":"def schedule_events(events: list[str], slots: list[str], constraints: list[tuple[int, int]]) -> dict[str, str]: Schedules events in slots while respecting constraints. :param events: List of event names. :param slots: List of slot names. :param constraints: List of tuples specifying pairs of events that cannot be scheduled at the same slot. :return: Dictionary mapping events to slots. If impossible, returns an empty dictionary. >>> schedule_events([\\"A\\", \\"B\\", \\"C\\"], [\\"9AM\\", \\"10AM\\", \\"11AM\\"], [(0, 1), (1, 2)]) in [{\\"A\\": \\"9AM\\", \\"B\\": \\"10AM\\", \\"C\\": \\"11AM\\"}, {\\"A\\": \\"11AM\\", \\"B\\": \\"9AM\\", \\"C\\": \\"10AM\\"}, ...] True >>> schedule_events([\\"A\\", \\"B\\", \\"C\\", \\"D\\"], [\\"9AM\\", \\"10AM\\"], [(0, 1), (1, 2)]) == {} True >>> res = schedule_events([\\"A\\", \\"B\\"], [\\"9AM\\", \\"10AM\\"], []) >>> res[\\"A\\"] in [\\"9AM\\", \\"10AM\\"] True >>> res[\\"B\\"] in [\\"9AM\\", \\"10AM\\"] True >>> schedule_events([\\"A\\", \\"B\\", \\"C\\"], [\\"9AM\\"], [(0, 1), (1, 2)]) == {} True >>> res = schedule_events([\\"A\\", \\"B\\", \\"C\\"], [\\"9AM\\", \\"10AM\\", \\"11AM\\"], [(0, 1), (0, 2), (1, 2)]) >>> res[\\"A\\"] != res[\\"B\\"] and res[\\"A\\"] != res[\\"C\\"] and res[\\"B\\"] != res[\\"C\\"] True >>> schedule_events([\\"A\\"], [\\"9AM\\"], []) == {\\"A\\": \\"9AM\\"} True","solution":"def schedule_events(events, slots, constraints): Schedules events in slots while respecting constraints. :param events: List of event names. :param slots: List of slot names. :param constraints: List of tuples specifying pairs of events that cannot be scheduled at the same slot. :return: Dictionary mapping events to slots. If impossible, returns an empty dictionary. n = len(events) m = len(slots) # If there are more events than slots, it's impossible to schedule if n > m: return {} # Prepare adjacency list for constraints constraints_dict = {i: set() for i in range(n)} for i, j in constraints: constraints_dict[i].add(j) constraints_dict[j].add(i) result = {} # Helper function to check if it's valid to assign slot to event def is_valid(event_index, slot): for neighbor in constraints_dict[event_index]: if events[neighbor] in result and result[events[neighbor]] == slot: return False return True # Backtracking function to schedule events def backtrack(event_index): if event_index == n: return True for slot in slots: if is_valid(event_index, slot): result[events[event_index]] = slot if backtrack(event_index + 1): return True del result[events[event_index]] return False if backtrack(0): return result else: return {}"},{"question":"def collatz_sequence_length(n: int) -> int: Calculates the length of the Collatz sequence for a given starting number n. >>> collatz_sequence_length(1) == 1 >>> collatz_sequence_length(6) == 9 >>> collatz_sequence_length(19) == 21 >>> collatz_sequence_length(16) == 5 >>> collatz_sequence_length(7) == 17 >>> collatz_sequence_length(1000000) == 153","solution":"def collatz_sequence_length(n: int) -> int: Calculates the length of the Collatz sequence for a given starting number n. length = 1 while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 length += 1 return length"},{"question":"def find_missing_number(sequence: List[int]) -> int: Finds the missing number in a list of consecutive integers. >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) 6 >>> find_missing_number([5, 2, 4, 6, 1]) 3 >>> find_missing_number([10, 12, 11, 14, 13, 15, 17]) 16 >>> find_missing_number([-3, -1, -2, -5]) -4","solution":"from typing import List def find_missing_number(sequence: List[int]) -> int: Returns the missing number in a sequence of consecutive integers. :param sequence: List[int] - a list of consecutive integers with one integer missing :return: int - the missing integer n = len(sequence) + 1 # Including the missing number total_sum = n * (n - 1) // 2 min_val = min(sequence) max_val = min_val + len(sequence) expected_sum = (min_val + max_val) * (len(sequence) + 1) // 2 actual_sum = sum(sequence) return expected_sum - actual_sum"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_leaf_nodes(root: TreeNode) -> int: Returns the sum of the values of all the leaf nodes in the given binary tree. >>> root = TreeNode(3) >>> root.left = TreeNode(5) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(6) >>> root.left.right = TreeNode(2) >>> root.left.right.left = TreeNode(7) >>> root.left.right.right = TreeNode(4) >>> root.right.right = TreeNode(9) >>> sum_of_leaf_nodes(root) 26 >>> root2 = TreeNode(2) >>> sum_of_leaf_nodes(root2) 2","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_of_leaf_nodes(root: TreeNode) -> int: Returns the sum of the values of all the leaf nodes in the given binary tree. if root is None: return 0 # Helper function to traverse the tree and sum the values of leaf nodes def dfs(node): if node is None: return 0 # If it is a leaf node if node.left is None and node.right is None: return node.val # Recurse on child nodes return dfs(node.left) + dfs(node.right) return dfs(root)"},{"question":"def has_cycle(dependencies: dict[int, list[int]]) -> bool: Return True if the directed graph contains a cycle, otherwise return False. Examples: >>> has_cycle({ >>> 0: [1, 2], >>> 1: [2], >>> 2: [0, 3], >>> 3: [3] >>> }) True >>> has_cycle({ >>> 0: [1], >>> 1: [2], >>> 2: [3], >>> 3: [] >>> }) False Example for empty dependency list: >>> has_cycle({}) False # Write your implementation here from solution import has_cycle def test_cycle_in_graph(): assert has_cycle({ 0: [1, 2], 1: [2], 2: [0, 3], 3: [] }) == True def test_no_cycle_in_graph(): assert has_cycle({ 0: [1], 1: [2], 2: [3], 3: [] }) == False def test_self_loop(): assert has_cycle({ 0: [1], 1: [2], 2: [0, 3], 3: [3] }) == True def test_empty_graph(): assert has_cycle({}) == False def test_single_node_no_edges(): assert has_cycle({ 0: [] }) == False def test_two_node_cycle(): assert has_cycle({ 0: [1], 1: [0] }) == True def test_large_acyclic_graph(): assert has_cycle({ 0: [1, 2, 3], 1: [4, 5], 2: [6, 7], 3: [8, 9], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [] }) == False def test_large_cyclic_graph(): assert has_cycle({ 0: [1, 2, 3], 1: [4, 5], 2: [6, 7], 3: [8, 9], 4: [0], 5: [], 6: [], 7: [], 8: [], 9: [] }) == True","solution":"def has_cycle(dependencies: dict[int, list[int]]) -> bool: Return True if the directed graph contains a cycle, otherwise return False. # Helper function for DFS traversal def dfs(v): nonlocal has_cycle_flag if visited[v] == 1: # visiting (gray) has_cycle_flag = True return if visited[v] == 2: # visited (black) return visited[v] = 1 # mark as visiting (gray) for neighbor in dependencies.get(v, []): dfs(neighbor) visited[v] = 2 # mark as visited (black) visited = {v: 0 for v in dependencies} # 0: unvisited, 1: visiting, 2: visited has_cycle_flag = False for vertex in dependencies: if visited[vertex] == 0: # If the vertex is unvisited, perform DFS from it dfs(vertex) if has_cycle_flag: return True return False"},{"question":"def is_fibonacci_like(sequence: list[int]) -> bool: Determines if a given sequence of integers is Fibonacci-like. A sequence is considered Fibonacci-like if both of the following conditions hold: 1. sequence[i] + sequence[i + 1] = sequence[i + 2] 2. The length of the sequence is at least 3. Parameters: sequence (list[int]): A list of integers Returns: bool: True if the sequence is Fibonacci-like, otherwise False >>> is_fibonacci_like([1, 1, 2, 3, 5, 8, 13]) True >>> is_fibonacci_like([1, 2, 4, 7, 11]) False >>> is_fibonacci_like([2, 3, 5, 8, 13, 21]) True >>> is_fibonacci_like([1]) False >>> is_fibonacci_like([7, 10, 17, 27, 44]) True","solution":"def is_fibonacci_like(sequence: list[int]) -> bool: Determines if a given sequence of integers is Fibonacci-like. Parameters: sequence (list[int]): A list of integers Returns: bool: True if the sequence is Fibonacci-like, otherwise False if len(sequence) < 3: return False for i in range(len(sequence) - 2): if sequence[i] + sequence[i + 1] != sequence[i + 2]: return False return True"},{"question":"def is_repeated_substring_pattern(s: str) -> bool: Determines if a given string can be constructed by repeating a substring of itself. >>> is_repeated_substring_pattern(\\"abab\\") == True >>> is_repeated_substring_pattern(\\"aba\\") == False >>> is_repeated_substring_pattern(\\"abcabcabcabc\\") == True >>> is_repeated_substring_pattern(\\"a\\") == False >>> is_repeated_substring_pattern(\\"xyzxyzxyz\\") == True","solution":"def is_repeated_substring_pattern(s: str) -> bool: Determines if a given string can be constructed by repeating a substring of itself. n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: if s[:i] * (n // i) == s: return True return False"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def merge_binary_trees(root1: TreeNode, root2: TreeNode) -> TreeNode: Merge two binary trees by adding the values of overlapping nodes. Return the new tree's root. Nodes that are only present in one tree keep their values. Example: >>> root1 = TreeNode(1, TreeNode(3, TreeNode(5)), TreeNode(2)) >>> root2 = TreeNode(2, TreeNode(1, None, TreeNode(4)), TreeNode(3, None, TreeNode(7))) >>> merged_root = merge_binary_trees(root1, root2) >>> def tree_to_list(root): ... if not root: ... return [] ... result, queue = [], [root] ... while queue: ... node = queue.pop(0) ... if node: ... result.append(node.val) ... queue.append(node.left) ... queue.append(node.right) ... else: ... result.append(None) ... while result and result[-1] is None: ... result.pop() ... return result >>> tree_to_list(merged_root) == [3, 4, 5, 5, 4, None, 7] True >>> root1 = TreeNode(1) >>> root2 = TreeNode(1) >>> merged_root = merge_binary_trees(root1, root2) >>> tree_to_list(merged_root) == [2] True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def merge_binary_trees(root1, root2): if not root1 and not root2: return None if not root1: return root2 if not root2: return root1 merged_root = TreeNode(root1.val + root2.val) merged_root.left = merge_binary_trees(root1.left, root2.left) merged_root.right = merge_binary_trees(root1.right, root2.right) return merged_root"},{"question":"import datetime def sort_log_file_by_timestamp(input_file: str) -> None: Sort the log entries in the given log file by their timestamps in ascending order, and write the sorted entries to a new file named \\"sorted_log_file.txt\\". Args: input_file (str): The filename of the log file to be sorted. Example: Given the input file \\"log_file.txt\\" with the following entries: 2023-10-05 14:48:00 Log entry one 2023-10-05 09:30:00 Log entry two 2023-10-05 12:15:00 Log entry three After running sort_log_file_by_timestamp(\\"log_file.txt\\"), the file \\"sorted_log_file.txt\\" should contain: 2023-10-05 09:30:00 Log entry two 2023-10-05 12:15:00 Log entry three 2023-10-05 14:48:00 Log entry one","solution":"import datetime def sort_log_file_by_timestamp(input_file: str) -> None: with open(input_file, 'r') as file: log_entries = file.readlines() log_entries = [entry.strip() for entry in log_entries] def extract_timestamp(log_entry): timestamp_str = log_entry.split(\\" \\", 2)[:2] timestamp_str = \\" \\".join(timestamp_str) return datetime.datetime.strptime(timestamp_str, '%Y-%m-%d %H:%M:%S') sorted_log_entries = sorted(log_entries, key=extract_timestamp) with open(\\"sorted_log_file.txt\\", 'w') as file: for entry in sorted_log_entries: file.write(entry + \\"n\\")"},{"question":"def is_anagram(string1: str, string2: str) -> bool: Checks if two strings are anagrams of each other, ignoring spaces and case differences. :param string1: The first string to compare. :param string2: The second string to compare. :return: True if the two strings are anagrams, otherwise False. >>> is_anagram('Dormitory', 'Dirty room') True >>> is_anagram('The Morse Code', 'Here come dots') True >>> is_anagram('Hello', 'Olelh') True >>> is_anagram('Test', 'Taste') False","solution":"def is_anagram(string1, string2): Checks if two strings are anagrams of each other, ignoring spaces and case differences. :param string1: The first string to compare. :param string2: The second string to compare. :return: True if the two strings are anagrams, otherwise False. # Remove spaces and lower the case of both strings cleaned_string1 = ''.join(string1.lower().split()) cleaned_string2 = ''.join(string2.lower().split()) # Compare the sorted characters of both cleaned strings return sorted(cleaned_string1) == sorted(cleaned_string2)"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates if a given string is a valid arithmetic expression and returns its result. Raises ValueError if the expression is invalid. >>> evaluate_expression(\\"3 + 5\\") 8.0 >>> evaluate_expression(\\"10 / 2\\") 5.0 >>> evaluate_expression(\\"10 / 0\\") Traceback (most recent call last): ... ValueError: Invalid expression >>> evaluate_expression(\\"12.5 * 2\\") 25.0 >>> evaluate_expression(\\"7 + a\\") Traceback (most recent call last): ... ValueError: Invalid expression","solution":"def evaluate_expression(expression: str) -> float: Evaluates if a given string is a valid arithmetic expression and returns its result. Raises ValueError if the expression is invalid. # Remove spaces expression = expression.replace(' ', '') # Define valid characters valid_chars = set('0123456789+-*/.') # Check for invalid characters if any(char not in valid_chars for char in expression): raise ValueError(\\"Invalid expression\\") try: # Evaluate the expression result = eval(expression) except ZeroDivisionError: raise ValueError(\\"Invalid expression\\") except (SyntaxError, NameError): raise ValueError(\\"Invalid expression\\") # Ensure the result is a float return float(result)"},{"question":"def prime_factorization(n: int) -> List[Tuple[int, int]]: Computes the prime factorization of a given number. Each prime factor is raised to its respective power. Parameters: n (int): A positive integer greater than 1. Returns: List[Tuple[int, int]]: A list of tuples where each tuple contains a prime factor and its corresponding power. Examples: >>> prime_factorization(2) [(2, 1)] >>> prime_factorization(3) [(3, 1)] >>> prime_factorization(4) [(2, 2)] >>> prime_factorization(18) [(2, 1), (3, 2)] >>> prime_factorization(100) [(2, 2), (5, 2)] >>> prime_factorization(999983) [(999983, 1)] >>> prime_factorization(1234567890) [(2, 1), (3, 2), (5, 1), (3607, 1), (3803, 1)] if n <= 1: raise ValueError(\\"Input must be greater than 1.\\") factors = [] count = 0 # Check for number of 2s that divide \`n\` while n % 2 == 0: n = n // 2 count += 1 if count > 0: factors.append((2, count)) # \`n\` must be odd at this point, # so a skip of 2 (i.e., i = i + 2) can be used for i in range(3, int(n**0.5) + 1, 2): count = 0 while (n % i == 0): n = n // i count += 1 if count > 0: factors.append((i, count)) # This condition is to check if \`n\` is a prime number # greater than 2 if n > 2: factors.append((n, 1)) return factors","solution":"from typing import List, Tuple def prime_factorization(n: int) -> List[Tuple[int, int]]: if n <= 1: raise ValueError(\\"Input must be greater than 1.\\") factors = [] count = 0 # Check for number of 2s that divide \`n\` while n % 2 == 0: n = n // 2 count += 1 if count > 0: factors.append((2, count)) # \`n\` must be odd at this point, # so a skip of 2 (i.e., i = i + 2) can be used for i in range(3, int(n**0.5) + 1, 2): count = 0 while (n % i == 0): n = n // i count += 1 if count > 0: factors.append((i, count)) # This condition is to check if \`n\` is a prime number # greater than 2 if n > 2: factors.append((n, 1)) return factors"},{"question":"def sum_of_numbers_in_string(input_string: str) -> int: Extracts numbers from the input string, sums them up, and returns the result. Parameters: - input_string (str): The string containing a mix of letters, digits, and special characters. Returns: - int: The sum of all the numbers extracted from the input string. Examples: >>> sum_of_numbers_in_string(\\"abc123xyz\\") 123 >>> sum_of_numbers_in_string(\\"hello5world15!\\") 20 >>> sum_of_numbers_in_string(\\"!@#%^&*()\\") 0","solution":"import re def sum_of_numbers_in_string(input_string): Extracts numbers from the input string, sums them up, and returns the result. Parameters: - input_string (str): The string containing a mix of letters, digits, and special characters. Returns: - int: The sum of all the numbers extracted from the input string. numbers = re.findall(r'd+', input_string) return sum(map(int, numbers))"},{"question":"def is_palindrome(s: str) -> bool: Check if a string is a palindrome. :param s: Input string. :return: True if the string is a palindrome, False otherwise. def test_is_palindrome_single_character(): assert is_palindrome(\\"a\\") == True def test_is_palindrome_two_different_characters(): assert is_palindrome(\\"ab\\") == False def test_is_palindrome_simple_palindrome(): assert is_palindrome(\\"level\\") == True def test_is_palindrome_not_palindrome(): assert is_palindrome(\\"OpenAI\\") == False def test_is_palindrome_case_sensitive(): assert is_palindrome(\\"AbaCaba\\") == False def test_is_palindrome_even_length_palindrome(): assert is_palindrome(\\"abba\\") == True def test_is_palindrome_odd_length_palindrome(): assert is_palindrome(\\"racecar\\") == True def test_is_palindrome_empty_string(): assert is_palindrome(\\"\\") == True def test_is_palindrome_mixed_characters(): assert is_palindrome(\\"aabbccbbaa\\") == True assert is_palindrome(\\"abcdedcbaa\\") == False","solution":"def is_palindrome(s: str) -> bool: def helper(start: int, end: int) -> bool: # Base case when the pointers have crossed each other or are the same if start >= end: return True # Check if characters at start and end are the same if s[start] != s[end]: return False # Recur for the next pair of characters return helper(start + 1, end - 1) return helper(0, len(s) - 1)"},{"question":"from typing import List, Set def union_of_sets(*sets: List[Set[int]]) -> Set[int]: Compute the union of multiple sets. >>> union_of_sets({1, 2, 3}, {3, 4, 5}, {5, 6, 7}) {1, 2, 3, 4, 5, 6, 7} >>> union_of_sets({10, 20, 30}, {30, 40, 50}) {10, 20, 30, 40, 50} >>> union_of_sets(set(), {1, 2, 3}) {1, 2, 3} >>> union_of_sets({1, 2, 3}) {1, 2, 3} >>> union_of_sets({}) set() pass","solution":"def union_of_sets(*sets): Returns the union of all provided sets. result_set = set() for s in sets: result_set.update(s) return result_set"},{"question":"def calculate_pearson_correlation(data_x: list, data_y: list, ndigits: int = 3) -> float: Calculate the Pearson correlation coefficient between two lists of numerical data points. >>> calculate_pearson_correlation([10, 20, 30, 40, 50], [12, 22, 32, 42, 52]) 1.0 >>> calculate_pearson_correlation([], [12, 22, 32, 42, 52]) None >>> calculate_pearson_correlation([10, 20, 30, 40, 50], [20, 30]) None >>> calculate_pearson_correlation([1, 2, 3], [3, 2, 1]) -1.0 pass def detect_outliers_iqr(data: list, ndigits: int = 3) -> list: Identify outliers in a list using the Interquartile Range (IQR) method. >>> detect_outliers_iqr([10, 12, 18, 19, 30, 33, 40, 45, 55, 100]) [100.0] >>> detect_outliers_iqr([10, 12, 18, 19, 30, 33, 40, 45, 55]) [] >>> detect_outliers_iqr([1, 2, 3, 4, 100]) [100.0] >>> detect_outliers_iqr([]) [] pass","solution":"def calculate_pearson_correlation(data_x, data_y, ndigits=3): if not data_x or not data_y or len(data_x) != len(data_y): return None n = len(data_x) mean_x = sum(data_x) / n mean_y = sum(data_y) / n sum_xy = sum((x - mean_x) * (y - mean_y) for x, y in zip(data_x, data_y)) sum_x2 = sum((x - mean_x) ** 2 for x in data_x) sum_y2 = sum((y - mean_y) ** 2 for y in data_y) denominator = (sum_x2 * sum_y2) ** 0.5 if denominator == 0: return None correlation = sum_xy / denominator return round(correlation, ndigits) def detect_outliers_iqr(data, ndigits=3): if not data: return [] sorted_data = sorted(data) n = len(data) q1 = sorted_data[n // 4] q3 = sorted_data[3 * n // 4] iqr = q3 - q1 lower_bound = q1 - 1.5 * iqr upper_bound = q3 + 1.5 * iqr outliers = [x for x in data if x < lower_bound or x > upper_bound] return [round(out, ndigits) for out in outliers]"},{"question":"def evaluate_rpn(tokens: list) -> int: Evaluates the given expression in Reverse Polish Notation and returns the result. >>> evaluate_rpn([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]) 9 >>> evaluate_rpn([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"]) 6 >>> evaluate_rpn([\\"10\\", \\"6\\", \\"9\\", \\"3\\", \\"+\\", \\"-11\\", \\"*\\", \\"/\\", \\"*\\", \\"17\\", \\"+\\", \\"5\\", \\"+\\"]) 22 >>> evaluate_rpn([\\"7\\", \\"3\\", \\"/\\"]) 2 >>> evaluate_rpn([\\"-7\\", \\"3\\", \\"/\\"]) -2","solution":"def evaluate_rpn(tokens): Evaluates the given expression in Reverse Polish Notation and returns the result. stack = [] for token in tokens: if token in \\"+-*/\\": b = stack.pop() a = stack.pop() if token == \\"+\\": stack.append(a + b) elif token == \\"-\\": stack.append(a - b) elif token == \\"*\\": stack.append(a * b) elif token == \\"/\\": # Truncate towards zero for integer division stack.append(int(a / b)) else: stack.append(int(token)) return stack[0]"},{"question":"class TrieNode: def __init__(self): Initialize a TrieNode with an empty dictionary of children and a boolean flag indicating if it is the end of a word. self.children = {} self.is_end_of_word = False class Trie: def __init__(self): Initialize the Trie with a root TrieNode. self.root = TrieNode() def insert(self, word: str): Insert a word into the Trie. Args: - word (str): The word to be inserted into the Trie. Returns: None pass def autocomplete(self, prefix: str) -> List[str]: Return a list of all words in the Trie that start with the given prefix. Args: - prefix (str): The prefix to be used for autocompletion. Returns: - List[str]: A list of words that start with the given prefix. >>> trie = Trie() >>> words = [\\"dog\\", \\"deer\\", \\"deal\\"] >>> for word in words: ... trie.insert(word) >>> sorted(trie.autocomplete(\\"de\\")) [\\"deal\\", \\"deer\\"] >>> sorted(trie.autocomplete(\\"cat\\")) [] pass # Test cases to validate the solution def test_insert_and_autocomplete_empty_trie(): trie = Trie() assert trie.autocomplete(\\"\\") == [] def test_autocomplete_no_matching_prefix(): trie = Trie() words = [\\"dog\\", \\"deer\\", \\"deal\\"] for word in words: trie.insert(word) assert trie.autocomplete(\\"cat\\") == [] def test_autocomplete_partial_prefix(): trie = Trie() words = [\\"dog\\", \\"deer\\", \\"deal\\"] for word in words: trie.insert(word) expected = sorted([\\"deer\\", \\"deal\\"]) result = sorted(trie.autocomplete(\\"de\\")) assert result == expected def test_insert_and_autocomplete_single_word(): trie = Trie() trie.insert(\\"dog\\") assert trie.autocomplete(\\"d\\") == [\\"dog\\"] def test_autocomplete_entire_word_as_prefix(): trie = Trie() words = [\\"car\\", \\"cart\\", \\"carbon\\"] for word in words: trie.insert(word) assert trie.autocomplete(\\"car\\") == [\\"car\\", \\"cart\\", \\"carbon\\"] def test_autocomplete_with_shared_prefix(): trie = Trie() words = [\\"apple\\", \\"app\\", \\"application\\", \\"apply\\"] for word in words: trie.insert(word) expected = sorted([\\"apple\\", \\"app\\", \\"application\\", \\"apply\\"]) result = sorted(trie.autocomplete(\\"app\\")) assert result == expected","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.is_end_of_word = True def _find_node(self, prefix): current = self.root for char in prefix: if char not in current.children: return None current = current.children[char] return current def _collect_all_words(self, node, prefix, words): if node.is_end_of_word: words.append(prefix) for char, next_node in node.children.items(): self._collect_all_words(next_node, prefix + char, words) def autocomplete(self, prefix): node = self._find_node(prefix) if not node: return [] words = [] self._collect_all_words(node, prefix, words) return words"},{"question":"def unique_paths(m: int, n: int) -> int: Calculates the number of unique paths from the top-left corner to the bottom-right corner of a m x n grid. :param m: Number of rows in the grid. :param n: Number of columns in the grid. :return: Number of unique paths to reach the bottom-right corner from the top-left corner. >>> unique_paths(3, 7) # 28 >>> unique_paths(3, 2) # 3 >>> unique_paths(7, 3) # 28","solution":"def unique_paths(m: int, n: int) -> int: Calculates the number of unique paths from the top-left corner to the bottom-right corner of a m x n grid. :param m: Number of rows in the grid. :param n: Number of columns in the grid. :return: Number of unique paths to reach the bottom-right corner from the top-left corner. # Create a 2D list initialized to 1 because there's only one way to reach any cell in the first row/column dp = [[1]*n for _ in range(m)] # Fill in the dp table row by row for i in range(1, m): for j in range(1, n): # The number of ways to reach dp[i][j] is the sum of the ways to reach the cell directly above it and the cell directly to the left of it dp[i][j] = dp[i-1][j] + dp[i][j-1] # The answer is in the bottom-right corner of the dp array return dp[m-1][n-1]"},{"question":"from typing import List, Union def quick_sort(arr: List[Union[int, str]]) -> None: Sorts a list of integers or strings in-place using the Quick Sort algorithm with median-of-three optimization. >>> numbers = [3, 6, 8, 10, 1, 2, 1] >>> quick_sort(numbers) >>> print(numbers) [1, 1, 2, 3, 6, 8, 10] >>> strings = [\\"apple\\", \\"orange\\", \\"banana\\", \\"kiwi\\"] >>> quick_sort(strings) >>> print(strings) [\\"apple\\", \\"banana\\", \\"kiwi\\", \\"orange\\"]","solution":"from typing import List, Union def quick_sort(arr: List[Union[int, str]]) -> None: def median_of_three(a, b, c): if (a <= b <= c) or (c <= b <= a): return b elif (b <= a <= c) or (c <= a <= b): return a else: return c def partition(low, high): mid = (low + high) // 2 pivot_val = median_of_three(arr[low], arr[mid], arr[high]) arr[low], arr[high] = arr[high], arr[low] pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quicksort_recursive(low, high): if low < high: pi = partition(low, high) quicksort_recursive(low, pi - 1) quicksort_recursive(pi + 1, high) if len(arr) > 1: quicksort_recursive(0, len(arr) - 1) # Example usage numbers = [3, 6, 8, 10, 1, 2, 1] quick_sort(numbers) print(numbers) # Expected sorted list [1, 1, 2, 3, 6, 8, 10] strings = [\\"apple\\", \\"orange\\", \\"banana\\", \\"kiwi\\"] quick_sort(strings) print(strings) # Expected sorted list [\\"apple\\", \\"banana\\", \\"kiwi\\", \\"orange\\"]"},{"question":"from typing import List, TypeVar T = TypeVar('T', int, str) class TopKFrequent: def __init__(self, k: int): Initializes the class with the value of k. pass def add(self, element: T): Adds an element to the stream. pass def top_k_frequent(self) -> List[T]: Returns a list of the k most frequent elements in descending order of their frequencies. pass # Unit Tests def test_single_element(): topk = TopKFrequent(1) topk.add('apple') assert topk.top_k_frequent() == ['apple'] def test_multiple_elements_same_frequency(): topk = TopKFrequent(2) topk.add('apple') topk.add('banana') assert sorted(topk.top_k_frequent()) == ['apple', 'banana'] def test_frequent_elements(): topk = TopKFrequent(2) topk.add('apple') topk.add('banana') topk.add('apple') topk.add('orange') topk.add('banana') topk.add('apple') assert topk.top_k_frequent() == ['apple', 'banana'] def test_updating_frequency(): topk = TopKFrequent(2) topk.add('apple') topk.add('banana') topk.add('apple') assert topk.top_k_frequent() == ['apple', 'banana'] topk.add('banana') topk.add('banana') topk.add('orange') assert topk.top_k_frequent() == ['banana', 'apple'] def test_edge_case_k_zero(): topk = TopKFrequent(0) topk.add('apple') assert topk.top_k_frequent() == [] def test_edge_case_no_elements(): topk = TopKFrequent(2) assert topk.top_k_frequent() == []","solution":"from typing import List, TypeVar from collections import defaultdict import heapq T = TypeVar('T', int, str) class TopKFrequent: def __init__(self, k: int): self.k = k self.freq_map = defaultdict(int) self.min_heap = [] def add(self, element: T): self.freq_map[element] += 1 def top_k_frequent(self) -> List[T]: if not self.freq_map: return [] for element, frequency in self.freq_map.items(): heapq.heappush(self.min_heap, (-frequency, element)) result = [] for _ in range(min(self.k, len(self.min_heap))): result.append(heapq.heappop(self.min_heap)[1]) return result"},{"question":"def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. >>> is_prime(7) == True >>> is_prime(4) == False def generate_primes(limit: int) -> list[int]: Returns a list of all prime numbers less than or equal to limit. >>> generate_primes(10) == [2, 3, 5, 7] >>> generate_primes(20) == [2, 3, 5, 7, 11, 13, 17, 19] def prime_factors(n: int) -> list[int]: Returns a list of prime factors of n. >>> prime_factors(28) == [2, 2, 7] >>> prime_factors(84) == [2, 2, 3, 7]","solution":"from math import isqrt def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. if n <= 1: raise ValueError(\\"Input must be greater than 1.\\") if n <= 3: return n > 1 if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def generate_primes(limit: int) -> list[int]: Returns a list of all prime numbers less than or equal to limit. if limit <= 1: raise ValueError(\\"Limit must be greater than 1.\\") primes = [] sieve = [True] * (limit + 1) for num in range(2, limit + 1): if sieve[num]: primes.append(num) for multiple in range(num * num, limit + 1, num): sieve[multiple] = False return primes def prime_factors(n: int) -> list[int]: Returns a list of prime factors of n. if n <= 1: raise ValueError(\\"Input must be greater than 1.\\") factors = [] while n % 2 == 0: factors.append(2) n //= 2 for i in range(3, isqrt(n) + 1, 2): while n % i == 0: factors.append(i) n //= i if n > 2: factors.append(n) return factors"},{"question":"class PrefixSumArray: def __init__(self, arr): Initialize the PrefixSumArray with the given array Args: arr (List[int]): List of integers to initialize the prefix sum array def update(self, index, value): Update the element at the specified index with the new value Args: index (int): The index of the element to update value (int): The new value to be set at the specified index def query_prefix_sum(self, index): Return the sum of elements from the start of the array up to the specified index Args: index (int): The index up to which the prefix sum is to be calculated Returns: int: The prefix sum from the start of the array to the given index def query_range_sum(self, left, right): Return the sum of elements in the specified range [left, right] Args: left (int): The starting index of the range right (int): The ending index of the range Returns: int: The sum of elements in the range [left, right] Unit Test: def test_initial_prefix_sum(): arr = [3, 2, -1, 6, 5, 4] ps = PrefixSumArray(arr) assert ps.query_prefix_sum(0) == 3 assert ps.query_prefix_sum(1) == 5 assert ps.query_prefix_sum(2) == 4 assert ps.query_prefix_sum(3) == 10 assert ps.query_prefix_sum(4) == 15 assert ps.query_prefix_sum(5) == 19 def test_update(): arr = [3, 2, -1, 6, 5, 4] ps = PrefixSumArray(arr) ps.update(2, 3) # arr now [3, 2, 3, 6, 5, 4] assert ps.query_prefix_sum(0) == 3 assert ps.query_prefix_sum(1) == 5 assert ps.query_prefix_sum(2) == 8 assert ps.query_prefix_sum(3) == 14 assert ps.query_prefix_sum(4) == 19 assert ps.query_prefix_sum(5) == 23 def test_query_range_sum(): arr = [3, 2, -1, 6, 5, 4] ps = PrefixSumArray(arr) assert ps.query_range_sum(1, 3) == 7 assert ps.query_range_sum(0, 5) == 19 assert ps.query_range_sum(2, 4) == 10 def test_invalid_index(): arr = [3, 2, -1, 6, 5, 4] ps = PrefixSumArray(arr) try: ps.query_prefix_sum(6) except IndexError as e: assert str(e) == \\"Index out of bounds\\" try: ps.update(6, 10) except IndexError as e: assert str(e) == \\"Index out of bounds\\" try: ps.query_range_sum(1, 6) except IndexError as e: assert str(e) == \\"Invalid range\\" try: ps.query_range_sum(3, 2) except IndexError as e: assert str(e) == \\"Invalid range\\"","solution":"class PrefixSumArray: def __init__(self, arr): self.arr = arr[:] self.prefix_sum = self._build_prefix_sum(arr) def _build_prefix_sum(self, arr): prefix_sum = [0] * len(arr) if arr: prefix_sum[0] = arr[0] for i in range(1, len(arr)): prefix_sum[i] = prefix_sum[i-1] + arr[i] return prefix_sum def update(self, index, value): if index < 0 or index >= len(self.arr): raise IndexError(\\"Index out of bounds\\") # Calculate the difference diff = value - self.arr[index] self.arr[index] = value # Update the prefix sums accordingly for i in range(index, len(self.prefix_sum)): self.prefix_sum[i] += diff def query_prefix_sum(self, index): if index < 0 or index >= len(self.arr): raise IndexError(\\"Index out of bounds\\") return self.prefix_sum[index] def query_range_sum(self, left, right): if left < 0 or right >= len(self.arr) or left > right: raise IndexError(\\"Invalid range\\") if left == 0: return self.prefix_sum[right] return self.prefix_sum[right] - self.prefix_sum[left-1]"},{"question":"def replace_words(text: str, replacements: dict[str, str]) -> str: Replaces words in the input text based on the replacements dictionary. Args: text (str): The input text where words need to be replaced. replacements (dict): A dictionary where keys are the words to be replaced, and values are their replacements. Returns: str: Modified text with all replacements applied. Examples: >>> replace_words(\\"the quick brown fox jumps over the lazy dog\\", {\\"jumps\\": \\"leaps\\", \\"lazy\\": \\"sleepy\\"}) 'the quick brown fox leaps over the sleepy dog' >>> replace_words(\\"hello world\\", {\\"hello\\": \\"hi\\", \\"world\\": \\"earth\\"}) 'hi earth' >>> replace_words(\\"a quick brown dog jumps over the quick fox\\", {\\"quick\\": \\"fast\\", \\"fox\\": \\"wolf\\"}) 'a fast brown dog jumps over the fast wolf'","solution":"def replace_words(text: str, replacements: dict[str, str]) -> str: Replaces words in the input text based on the replacements dictionary. Args: text (str): The input text where words need to be replaced. replacements (dict): A dictionary where keys are the words to be replaced, and values are their replacements. Returns: str: Modified text with all replacements applied. words = text.split() modified_words = [replacements.get(word, word) for word in words] return ' '.join(modified_words)"},{"question":"def binary_search(arr: list[int], target: int) -> int: Implements binary search to find the index of target in a sorted list of integers. >>> binary_search([1, 2, 3, 4, 5], 3) == 2 >>> binary_search([1, 2, 3, 4, 5], 1) == 0 >>> binary_search([1, 2, 3, 4, 5], 5) == 4 >>> binary_search([1, 2, 3, 4, 5], 6) == -1 >>> binary_search([], 1) == -1 >>> binary_search([1], 1) == 0 >>> binary_search([1], 2) == -1 >>> binary_search([1, 2, 3, 4, 5, 6], 4) == 3 >>> binary_search([10, 20, 30, 40, 50], 50) == 4 >>> binary_search([10, 20, 30, 40, 50], 35) == -1","solution":"def binary_search(arr: list[int], target: int) -> int: left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Movie Theater Seat Analysis Completion Task Complete the function \`can_reserve\` that will help determine if there is a block of \`M\` consecutive available seats in the movie theater row. def can_reserve(seats, M): Determines if there is a block of M consecutive available seats in a movie theater row. :param seats: List of integers where 1 indicates a reserved seat and 0 indicates an available seat. :param M: Integer representing the number of consecutive seats to reserve. :return: Boolean value, True if there is a block of M consecutive available seats, False otherwise. consecutive_free = 0 # Counter for consecutive available seats for seat in seats: if seat == 0: consecutive_free += 1 if consecutive_free == M: return True else: consecutive_free = 0 # Reset counter if a reserved seat is encountered return False # Return False if no block of M consecutive available seats is found","solution":"def can_reserve(seats, M): Determines if there is a block of M consecutive available seats in a movie theater row. :param seats: List of integers where 1 indicates a reserved seat and 0 indicates an available seat. :param M: Integer representing the number of consecutive seats to reserve. :return: Boolean value, True if there is a block of M consecutive available seats, False otherwise. consecutive_free = 0 # Counter for consecutive available seats for seat in seats: if seat == 0: consecutive_free += 1 if consecutive_free == M: return True else: consecutive_free = 0 # Reset counter if a reserved seat is encountered return False # Return False if no block of M consecutive available seats is found"},{"question":"import math from functools import reduce def find_lcm(arr: list) -> int: Find the smallest positive integer that is a multiple of all numbers in the given array. >>> find_lcm([1, 2, 3, 4, 5]) == 60 >>> find_lcm([2, 7, 3, 9, 4]) == 252 >>> find_lcm([5, 10, 20]) == 20","solution":"import math from functools import reduce def lcm(a, b): Helper function to find the Least Common Multiple (LCM) of two numbers. return abs(a * b) // math.gcd(a, b) def find_lcm(arr): Returns the Least Common Multiple (LCM) of all the numbers in the array. return reduce(lcm, arr)"},{"question":"from typing import List class StockData: def __init__(self, prices: List[float]): self.prices = prices def moving_average(self, period: int) -> List[float]: Calculates the moving average over the specified period. :param period: The number of days over which to calculate the moving average. :return: A list of floats representing the moving average. >>> stock_data = StockData([1.0, 2.0, 3.0, 4.0, 5.0]) >>> stock_data.moving_average(3) [2.0, 3.0, 4.0] >>> stock_data = StockData([1.0]) >>> stock_data.moving_average(1) [1.0] >>> stock_data = StockData([1.0, 2.0, 3.0, 10.0, 5.0, 8.0]) >>> stock_data.moving_average(5) [4.2, 5.6] >>> stock_data = StockData([1.0, 2.0, 3.0, 4.0, 5.0]) try: stock_data.moving_average(0) except ValueError as e: print(e) # \\"Invalid period\\" >>> stock_data = StockData([1.0, 2.0, 3.0, 4.0, 5.0]) try: stock_data.moving_average(6) except ValueError as e: print(e) # \\"Invalid period\\" >>> stock_data = StockData([i for i in range(1000)]) >>> result = stock_data.moving_average(100) >>> len(result) 901 >>> result[0] 49.5 >>> result[900] 949.5","solution":"from typing import List class StockData: def __init__(self, prices: List[float]): self.prices = prices def moving_average(self, period: int) -> List[float]: if period <= 0 or period > len(self.prices): raise ValueError(\\"Invalid period\\") averages = [] sum_period = sum(self.prices[:period]) averages.append(sum_period / period) for i in range(period, len(self.prices)): sum_period += self.prices[i] - self.prices[i - period] averages.append(sum_period / period) return averages"},{"question":"def find_second_largest(nums: list) -> int: Returns the second largest integer in the list. >>> find_second_largest([12, 35, 1, 10, 34, 1]) 34 >>> find_second_largest([10, 5, 10]) 5 >>> find_second_largest([1, 2]) 1 >>> find_second_largest([4, 99, 23, 56, 7]) 56","solution":"def find_second_largest(nums: list) -> int: Returns the second largest integer in the list. first = second = float('-inf') for num in nums: if num > first: second = first first = num elif first > num > second: second = num return second"},{"question":"def shortest_path(graph: dict[int, list[int]], start: int, end: int) -> int: Determines the shortest path between two specified users in a social network graph. Parameters: - graph (dict[int, list[int]]): A dictionary where keys are user IDs and values are lists of friends (user IDs). - start (int): The starting user ID. - end (int): The end user ID. Returns: - int: The number of edges in the shortest path from the start user to the end user. Returns -1 if no such path exists. Examples: >>> graph = { ... 1: [2, 3], ... 2: [1, 4], ... 3: [1], ... 4: [2, 5], ... 5: [4] ... } >>> shortest_path(graph, 1, 5) 3 >>> shortest_path(graph, 1, 6) -1","solution":"from collections import deque def shortest_path(graph, start, end): Returns the number of edges in the shortest path between start and end user in the given graph. If no such path exists, returns -1. if start == end: return 0 visited = set() queue = deque([(start, 0)]) # (current_node, current_distance) while queue: current_node, distance = queue.popleft() if current_node == end: return distance if current_node not in visited: visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor not in visited: queue.append((neighbor, distance + 1)) return -1"},{"question":"def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: Merges two sorted lists into a single sorted list. >>> merge_sorted_lists([1, 3, 5, 7], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sorted_lists([1, 3, 5], [2, 4, 6, 8, 10]) [1, 2, 3, 4, 5, 6, 8, 10] >>> merge_sorted_lists([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_lists([], [7, 8, 9]) [7, 8, 9] >>> merge_sorted_lists([], []) []","solution":"def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: Merges two sorted lists into a single sorted list. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Append remaining elements from list1, if any while i < len(list1): merged_list.append(list1[i]) i += 1 # Append remaining elements from list2, if any while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"from typing import List def matrix_chain_order(dims: List[int]) -> int: Calculate the minimum cost of multiplying a sequence of matrices. >>> matrix_chain_order([1, 2, 3, 4]) 18 >>> matrix_chain_order([10, 20, 30, 40, 30]) 30000 def test_matrix_chain_order_1(): assert matrix_chain_order([1, 2, 3, 4]) == 18 def test_matrix_chain_order_2(): assert matrix_chain_order([10, 20, 30, 40, 30]) == 30000 def test_matrix_chain_order_3(): assert matrix_chain_order([5, 10, 3, 12, 5, 50, 6]) == 2010 def test_matrix_chain_order_4(): assert matrix_chain_order([2, 3, 6, 4, 5]) == 124 def test_matrix_chain_order_5(): assert matrix_chain_order([30, 35, 15, 5, 10, 20, 25]) == 15125","solution":"from typing import List def matrix_chain_order(dims: List[int]) -> int: n = len(dims) - 1 # Initialize the matrix to hold our results dp = [[0 for _ in range(n)] for _ in range(n)] for length in range(2, n+1): # length is the length of the chain for i in range(n - length + 1): j = i + length - 1 dp[i][j] = float('inf') for k in range(i, j): # cost of splitting at k cost = dp[i][k] + dp[k+1][j] + dims[i] * dims[k+1] * dims[j+1] if cost < dp[i][j]: dp[i][j] = cost return dp[0][n-1]"},{"question":"def is_subset_sum(nums: list[int], target: int) -> bool: Determines if there is a subset of the given list with a sum equal to the target value. Uses a dynamic programming approach. >>> is_subset_sum([3, 34, 4, 12, 5, 2], 9) == True >>> is_subset_sum([1, 2, 3], 5) == True >>> is_subset_sum([1, 2, 3], 7) == False >>> is_subset_sum([5, 7, 1, 8, 2, 9], 15) == True >>> is_subset_sum([], 0) == True >>> is_subset_sum([], 1) == False >>> is_subset_sum([3, 34, 4], 0) == True >>> is_subset_sum([10], 10) == True >>> is_subset_sum([10], 5) == False >>> is_subset_sum([5], 10) == False >>> is_subset_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 55) == True >>> is_subset_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 56) == False >>> is_subset_sum([2, 2, 2, 2], 8) == True >>> is_subset_sum([2, 2, 2, 2, 2], 9) == False","solution":"def is_subset_sum(nums, target): Determines if there is a subset of the given list with a sum equal to the target value. Uses a dynamic programming approach. Args: nums : list[int] - A list of non-negative integers. target : int - The target sum we are trying to achieve with a subset of nums. Returns: bool - True if there is a subset with sum equals to target, False otherwise. n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"class MaxHeap: def __init__(self): Initialize an empty MaxHeap. self.heap = [] def insert(self, key): Insert a new element into the heap. >>> heap = MaxHeap() >>> heap.insert(10) >>> heap.insert(20) >>> heap.insert(15) self.heap.append(key) self._heapify_up(len(self.heap) - 1) def extract_max(self): Remove and return the maximum element from the heap. >>> heap = MaxHeap() >>> heap.insert(10) >>> heap.insert(20) >>> heap.extract_max() 20 >>> heap.extract_max() 10 >>> heap.extract_max() is None True if not self.heap: return None if len(self.heap) == 1: return self.heap.pop() root = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return root def _heapify_down(self, index): Private method to maintain heap properties while moving downwards from the root. largest = index left = 2 * index + 1 right = 2 * index + 2 if left < len(self.heap) and self.heap[left] > self.heap[largest]: largest = left if right < len(self.heap) and self.heap[right] > self.heap[largest]: largest = right if largest != index: self.heap[index], self.heap[largest] = self.heap[largest], self.heap[index] self._heapify_down(largest) def _heapify_up(self, index): Private method to maintain heap properties while moving upwards. parent = (index - 1) // 2 if index > 0 and self.heap[index] > self.heap[parent]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] self._heapify_up(parent) # Test Cases if __name__ == \\"__main__\\": heap = MaxHeap() heap.insert(10) heap.insert(20) heap.insert(15) print(heap.extract_max()) # Expected: 20 print(heap.extract_max()) # Expected: 15 print(heap.extract_max()) # Expected: 10 print(heap.extract_max()) # Expected: None","solution":"class MaxHeap: def __init__(self): self.heap = [] def insert(self, key): self.heap.append(key) self._heapify_up(len(self.heap) - 1) def extract_max(self): if not self.heap: return None if len(self.heap) == 1: return self.heap.pop() root = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return root def _heapify_down(self, index): largest = index left = 2 * index + 1 right = 2 * index + 2 if left < len(self.heap) and self.heap[left] > self.heap[largest]: largest = left if right < len(self.heap) and self.heap[right] > self.heap[largest]: largest = right if largest != index: self.heap[index], self.heap[largest] = self.heap[largest], self.heap[index] self._heapify_down(largest) def _heapify_up(self, index): parent = (index - 1) // 2 if index > 0 and self.heap[index] > self.heap[parent]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] self._heapify_up(parent)"},{"question":"from typing import List def longest_common_prefix(strs: List[str]) -> str: Find the longest common prefix among a list of strings. >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) \\"\\" pass def verify_common_prefix(strs: List[str], prefix: str) -> bool: Verify if the given prefix is the longest common prefix among the list of strings. >>> verify_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"], \\"fl\\") True >>> verify_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"], \\"\\") True pass","solution":"from typing import List def longest_common_prefix(strs: List[str]) -> str: if not strs: return \\"\\" # Start with the prefix as the first string prefix = strs[0] for s in strs[1:]: # Gradually reduce the prefix to the common part of each pair while not s.startswith(prefix): prefix = prefix[:-1] # remove the last character if not prefix: return \\"\\" return prefix def verify_common_prefix(strs: List[str], prefix: str) -> bool: for s in strs: if not s.startswith(prefix): return False return True"},{"question":"def traffic_light_simulation(cycles: int) -> list: Simulate a simple traffic light system over a given number of cycles. Each cycle consists of: - Green: 60 seconds - Yellow: 5 seconds - Red: 55 seconds Args: cycles (int): A positive integer representing the number of full cycles to simulate. Returns: list: A list of strings where each string represents the color of the traffic light ('Green', 'Yellow', or 'Red') for each second in the simulation. Raises: ValueError: If cycles is not a positive integer. Example: >>> traffic_light_simulation(1) ['Green', 'Green', ..., 'Green', 'Yellow', 'Yellow', ..., 'Yellow', 'Red', 'Red', ..., 'Red'] >>> traffic_light_simulation(2) ['Green', 'Green', ..., 'Green', 'Yellow', 'Yellow', ..., 'Yellow', 'Red', 'Red', ..., 'Red', 'Green', 'Green', ..., 'Green', 'Yellow', 'Yellow', ..., 'Yellow', 'Red', 'Red', ..., 'Red']","solution":"def traffic_light_simulation(cycles: int) -> list: if cycles <= 0: raise ValueError(\\"Cycles must be a positive integer.\\") # Define the durations for each color timings = { 'Green': 60, 'Yellow': 5, 'Red': 55 } # Generate the list of colors for one cycle one_cycle = ['Green'] * timings['Green'] + ['Yellow'] * timings['Yellow'] + ['Red'] * timings['Red'] # Repeat the cycle for the given number of cycles full_simulation = one_cycle * cycles return full_simulation"},{"question":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None self.tail = None self.size = 0 def add_last(self, value): new_node = Node(value) if not self.head: self.head = self.tail = new_node else: self.tail.next = new_node self.tail = new_node self.size += 1 def remove_first(self): if not self.head: return None value = self.head.value self.head = self.head.next self.size -= 1 if not self.head: self.tail = None return value def is_empty(self): return self.size == 0 def __len__(self): return self.size def to_list(self): current = self.head result = [] while current: result.append(current.value) current = current.next return result def remove_consecutive_duplicates(linked_list: LinkedList) -> None: Remove all consecutive duplicates from a linked list. Args: linked_list (LinkedList): The linked list from which to remove consecutive duplicates. Examples: >>> ll = LinkedList() >>> ll.add_last(1) >>> ll.add_last(1) >>> ll.add_last(2) >>> ll.add_last(3) >>> ll.add_last(3) >>> remove_consecutive_duplicates(ll) >>> ll.to_list() [1, 2, 3] >>> ll = LinkedList() >>> ll.add_last(4) >>> ll.add_last(4) >>> ll.add_last(4) >>> remove_consecutive_duplicates(ll) >>> ll.to_list() [4] >>> ll = LinkedList() >>> remove_consecutive_duplicates(ll) >>> ll.to_list() []","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None self.tail = None self.size = 0 def add_last(self, value): new_node = Node(value) if not self.head: self.head = self.tail = new_node else: self.tail.next = new_node self.tail = new_node self.size += 1 def remove_first(self): if not self.head: return None value = self.head.value self.head = self.head.next self.size -= 1 if not self.head: self.tail = None return value def is_empty(self): return self.size == 0 def __len__(self): return self.size def to_list(self): current = self.head result = [] while current: result.append(current.value) current = current.next return result def remove_consecutive_duplicates(linked_list: LinkedList) -> None: if linked_list.is_empty() or linked_list.head.next is None: return current = linked_list.head while current and current.next: if current.value == current.next.value: current.next = current.next.next linked_list.size -= 1 else: current = current.next if current and current.next is None: linked_list.tail = current"},{"question":"def fibonacci_sequence(count: int) -> list[int]: Generates the Fibonacci sequence up to a specified count of terms. Parameters: count (int): The count of Fibonacci terms to generate. Returns: list[int]: The list containing the Fibonacci sequence up to the specified count. Examples: >>> fibonacci_sequence(5) [0, 1, 1, 2, 3] >>> fibonacci_sequence(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> fibonacci_sequence(1) [0]","solution":"def fibonacci_sequence(count: int) -> list[int]: Generates the Fibonacci sequence up to a specified count of terms. Parameters: count (int): The count of Fibonacci terms to generate. Returns: list[int]: The list containing the Fibonacci sequence up to the specified count. if not isinstance(count, int) or count <= 0: raise ValueError(\\"The count must be a positive integer greater than zero.\\") if count == 1: return [0] sequence = [0, 1] for _ in range(2, count): next_term = sequence[-1] + sequence[-2] sequence.append(next_term) return sequence"},{"question":"def calculate_travel_time(speed: float, distance: float) -> float: Calculate the time taken to travel a certain distance given the speed. Parameters: speed (float): The speed of the car in units per hour. Must be a positive number. distance (float): The distance to be covered in units. Must be a positive number. Returns: float: The calculated travel time in hours. Raises: ValueError: If either speed or distance is not positive. >>> calculate_travel_time(60, 180) 3.0 >>> calculate_travel_time(50, 100) 2.0 >>> calculate_travel_time(-80, 160) Traceback (most recent call last): ... ValueError: Speed and distance must be positive","solution":"def calculate_travel_time(speed: float, distance: float) -> float: Calculate the time taken to travel a certain distance given the speed. Parameters: speed (float): The speed of the car in units per hour. Must be a positive number. distance (float): The distance to be covered in units. Must be a positive number. Returns: float: The calculated travel time in hours. Raises: ValueError: If either speed or distance is not positive. if speed <= 0 or distance <= 0: raise ValueError(\\"Speed and distance must be positive\\") return distance / speed"},{"question":"def nested_list_sum(nested_list: list) -> int: Compute the sum of all integers within a nested list structure. The function should handle arbitrarily deep nesting. >>> nested_list_sum([1, [2, 3, [4]], 5]) == 15 >>> nested_list_sum([1, [2, [3, [4, [5]]]]]) == 15 >>> nested_list_sum([-1, [-2, [-3, [-4, [-5]]]]]) == -15 >>> nested_list_sum([]) == 0 >>> nested_list_sum([1000000, [2000000, [3000000], -4000000]]) == 2000000","solution":"def nested_list_sum(nested_list: list) -> int: def helper(lst): total = 0 for element in lst: if isinstance(element, list): total += helper(element) else: total += element return total return helper(nested_list)"},{"question":"def series_parallel_resistance(resistance_1: float, resistance_2: float, resistance_3: float) -> float: Calculate the total resistance of a series-parallel circuit. :param resistance_1: A positive float representing the first resistance R1. :param resistance_2: A positive float representing the second resistance R2. :param resistance_3: A positive float representing the third resistance R3. :return: Total resistance Rt of the circuit. >>> series_parallel_resistance(4, 6, 8) 10.4 >>> series_parallel_resistance(10, 10, 10) 15.0 >>> series_parallel_resistance(4, 4, 4) 6.0 >>> series_parallel_resistance(1, 2, 3) 3.67","solution":"def series_parallel_resistance(resistance_1: float, resistance_2: float, resistance_3: float) -> float: Calculate the total resistance of a series-parallel circuit. :param resistance_1: A positive float representing the first resistance R1. :param resistance_2: A positive float representing the second resistance R2. :param resistance_3: A positive float representing the third resistance R3. :return: Total resistance Rt of the circuit. # Validate input resistances if resistance_1 <= 0 or resistance_2 <= 0 or resistance_3 <= 0: raise ValueError(\\"All resistance values must be positive\\") # Calculate the equivalent resistance of R1 and R2 in parallel r_parallel = (resistance_1 * resistance_2) / (resistance_1 + resistance_2) # Calculate the total resistance total_resistance = r_parallel + resistance_3 return total_resistance"},{"question":"def prime_factors(n: int) -> dict: Compute the prime factorization of a given positive integer \`n\`. Returns a dictionary where the keys are the prime factors and the values are their respective powers. >>> prime_factors(1) {} >>> prime_factors(12) {2: 2, 3: 1} >>> prime_factors(30) {2: 1, 3: 1, 5: 1} >>> prime_factors(60) {2: 2, 3: 1, 5: 1} >>> prime_factors(101) {101: 1}","solution":"def prime_factors(n: int) -> dict: Compute the prime factorization of a given positive integer \`n\`. Returns a dictionary where the keys are the prime factors and the values are their respective powers. if n <= 1: return {} factors = {} # Check for number of 2s in n while n % 2 == 0: factors[2] = factors.get(2, 0) + 1 n //= 2 # Check for odd numbers from 3 onwards factor = 3 while factor * factor <= n: while n % factor == 0: factors[factor] = factors.get(factor, 0) + 1 n //= factor factor += 2 # If n is still a prime number greater than 2 if n > 2: factors[n] = 1 return factors"},{"question":"from typing import List from collections import defaultdict class PredictiveText: def __init__(self) -> None: Initializes the word frequency dictionary. pass def learn(self, text: str) -> None: Processes the given text to learn word frequencies. pass def suggest(self, prefix: str, k: int) -> List[str]: Returns the top K frequent words starting with the given prefix. >>> pt = PredictiveText() >>> pt.learn(\\"hello world hello\\") >>> pt.suggest(\\"he\\", 1) [\\"hello\\"] >>> pt.suggest(\\"wo\\", 1) [\\"world\\"] >>> pt.suggest(\\"ho\\", 1) [] pass def test_initialization(): pt = PredictiveText() assert isinstance(pt.word_counts, defaultdict) def test_learn_single_word(): pt = PredictiveText() pt.learn(\\"hello\\") assert pt.word_counts[\\"hello\\"] == 1 def test_learn_multiple_words(): pt = PredictiveText() pt.learn(\\"hello world hello\\") assert pt.word_counts[\\"hello\\"] == 2 assert pt.word_counts[\\"world\\"] == 1 def test_suggest_basic(): pt = PredictiveText() pt.learn(\\"hello world hello\\") assert pt.suggest(\\"he\\", 1) == [\\"hello\\"] def test_suggest_limit(): pt = PredictiveText() pt.learn(\\"hello world hello hotel\\") assert pt.suggest(\\"ho\\", 2) == [\\"hotel\\"] def test_suggest_case_insensitivity(): pt = PredictiveText() pt.learn(\\"Hello hello\\") assert pt.suggest(\\"he\\", 1) == [\\"hello\\"] def test_suggest_prefix_not_found(): pt = PredictiveText() pt.learn(\\"hello world\\") assert pt.suggest(\\"xx\\", 1) == [] def test_suggest_tied_frequencies(): pt = PredictiveText() pt.learn(\\"apple apricot apple apricot avalanche\\") assert pt.suggest(\\"ap\\", 2) == [\\"apple\\", \\"apricot\\"] assert pt.suggest(\\"ap\\", 3) == [\\"apple\\", \\"apricot\\"] assert pt.suggest(\\"av\\", 1) == [\\"avalanche\\"]","solution":"from collections import defaultdict, Counter from typing import List class PredictiveText: def __init__(self) -> None: Initializes the word frequency dictionary. self.word_counts = defaultdict(int) def learn(self, text: str) -> None: Processes the given text to learn word frequencies. words = text.lower().split() for word in words: self.word_counts[word] += 1 def suggest(self, prefix: str, k: int) -> List[str]: Returns the top K frequent words starting with the given prefix. prefix = prefix.lower() matching_words = [word for word in self.word_counts if word.startswith(prefix)] sorted_words = sorted(matching_words, key=lambda word: (-self.word_counts[word], word)) return sorted_words[:k]"},{"question":"from typing import List def form_words(string: str, word_dict: List[str]) -> List[str]: Identifies all the words from the given dictionary that can be formed using the characters in the input string. >>> form_words(\\"abppplee\\", [\\"apple\\", \\"pear\\", \\"plea\\", \\"banana\\"]) ['apple', 'plea'] >>> form_words(\\"eerekc\\", [\\"tree\\", \\"treehouse\\", \\"reek\\", \\"seek\\"]) ['reek'] >>> form_words(\\"catsanddog\\", [\\"dog\\", \\"cats\\", \\"cat\\", \\"and\\", \\"bat\\"]) ['dog', 'cats', 'cat', 'and'] pass","solution":"from collections import Counter from typing import List def can_form_word(string_counter, word): word_counter = Counter(word) for char, count in word_counter.items(): if string_counter[char] < count: return False return True def form_words(string: str, word_dict: List[str]) -> List[str]: string_counter = Counter(string) result = [] for word in word_dict: if can_form_word(string_counter, word): result.append(word) return result"},{"question":"from typing import List def row_sums_descending(matrix: List[List[int]]) -> List[int]: Given an NxN matrix of integers, return a list of the sums of each row sorted in descending order. Args: matrix (List[List[int]]): An NxN matrix of integers. Returns: List[int]: A list of integers representing the sums of each row in descending order. Example: >>> row_sums_descending([ ... [3, 5, 1], ... [0, -2, 7], ... [-1, 4, 2] ... ]) [9, 5, 5] >>> row_sums_descending([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [24, 15, 6]","solution":"from typing import List def row_sums_descending(matrix: List[List[int]]) -> List[int]: Given an NxN matrix of integers, return a list of the sums of each row sorted in descending order. Args: matrix (List[List[int]]): An NxN matrix of integers. Returns: List[int]: A list of integers representing the sums of each row in descending order. row_sums = [sum(row) for row in matrix] row_sums.sort(reverse=True) return row_sums"},{"question":"from typing import List def rearrange_primes(numbers: List[int]) -> List[int]: Rearranges primes in a list in descending order while keeping non-primes in the same positions. Parameters: - numbers (List[int]): A list of integers containing both prime and non-prime numbers. Returns: - List[int]: A new list with prime numbers rearranged in descending order while non-prime numbers remain in their original positions. >>> rearrange_primes([10, 7, 2, 11, 4, 5, 8, 13]) [10, 13, 11, 7, 4, 5, 8, 2] >>> rearrange_primes([2, 3, 5, 7, 11]) [11, 7, 5, 3, 2] >>> rearrange_primes([1, 4, 6, 8, 10]) [1, 4, 6, 8, 10] >>> rearrange_primes([1, 2, 3]) [1, 3, 2] >>> rearrange_primes([]) []","solution":"from typing import List def is_prime(n: int) -> bool: Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True # 2 is the only even prime number if n % 2 == 0: return False # No other even number can be a prime for i in range(3, int(n**0.5) + 1, 2): # Odd numbers up to the square root of n if n % i == 0: return False return True def rearrange_primes(numbers: List[int]) -> List[int]: Rearranges primes in a list in descending order while keeping non-primes in the same positions. # Extract primes and their indices primes = [num for num in numbers if is_prime(num)] # Sort primes in descending order primes.sort(reverse=True) # Generate the result list result = [] prime_idx = 0 for num in numbers: if is_prime(num): result.append(primes[prime_idx]) prime_idx += 1 else: result.append(num) return result"},{"question":"def validate_and_notify(book_inventory: dict, min_stock: int, max_stock: int) -> str: Process and validate book inventories for a library management system. >>> validate_and_notify({\\"Book A\\": 5, \\"Book B\\": 0, \\"Book C\\": 15}, 1, 10) \\"Books out of stock range: [Book B, Book C]\\" >>> validate_and_notify({\\"Book A\\": 7, \\"Book B\\": 3, \\"Book C\\": 8}, 1, 10) \\"All books are within the acceptable stock levels.\\" >>> validate_and_notify({\\"Book A\\": 5, \\"Book B\\": 10}, -1, 10) \\"Error: Minimum stock should be a non-negative integer\\" >>> validate_and_notify({\\"Book A\\": 5, \\"Book B\\": 10}, 5, 3) \\"Error: Maximum stock should be greater than minimum stock\\"","solution":"def validate_and_notify(book_inventory: dict, min_stock: int, max_stock: int) -> str: # Check if min_stock is a non-negative integer if not isinstance(min_stock, int) or min_stock < 0: return \\"Error: Minimum stock should be a non-negative integer\\" # Check if max_stock is greater than min_stock if not isinstance(max_stock, int) or max_stock <= min_stock: return \\"Error: Maximum stock should be greater than minimum stock\\" # List to collect books out of stock range out_of_range_books = [] # Check every book's stock level for book, stock in book_inventory.items(): if not (min_stock <= stock <= max_stock): out_of_range_books.append(book) # Return appropriate message based on the collected books if out_of_range_books: books_list = \\", \\".join(out_of_range_books) return f\\"Books out of stock range: [{books_list}]\\" else: return \\"All books are within the acceptable stock levels.\\""},{"question":"import numpy as np def softmax(vector: np.ndarray) -> np.ndarray: Compute the softmax of a vector. Args: vector (np.ndarray): A 1-D numpy array representing the input scores. Returns: np.ndarray: A 1-D numpy array containing the softmax probabilities. Examples: >>> np.testing.assert_almost_equal(softmax(np.array([2.0, 1.0, 0.1])), np.array([0.65900114, 0.24243297, 0.09856589]), decimal=6) >>> np.testing.assert_almost_equal(softmax(np.array([-1.0, 0.0, 1.0])), np.array([0.09003057, 0.24472847, 0.66524096]), decimal=6)","solution":"import numpy as np def softmax(vector: np.ndarray) -> np.ndarray: Compute the softmax of a vector. Args: vector (np.ndarray): A 1-D numpy array representing the input scores. Returns: np.ndarray: A 1-D numpy array containing the softmax probabilities. # Subtract the max value from the vector elements for numerical stability c = np.max(vector) exp_shifted = np.exp(vector - c) sum_exp_shifted = np.sum(exp_shifted) return exp_shifted / sum_exp_shifted"},{"question":"from typing import List def moving_average(sequence: List[int], window_size: int) -> List[float]: Computes the moving average of the sequence with the given window size. Args: sequence (List[int]): The list of integers. window_size (int): The size of the moving window. Returns: List[float]: A list of floats representing the moving averages. Raises: ValueError: If window_size is less than 1 or greater than the length of the sequence.","solution":"from typing import List def moving_average(sequence: List[int], window_size: int) -> List[float]: Computes the moving average of the sequence with the given window size. Args: sequence (List[int]): The list of integers. window_size (int): The size of the moving window. Returns: List[float]: A list of floats representing the moving averages. Raises: ValueError: If window_size is less than 1 or greater than the length of the sequence. if window_size < 1 or window_size > len(sequence): raise ValueError(\\"Window size must be a positive integer and less than or equal to the length of the sequence.\\") moving_averages = [] for i in range(len(sequence) - window_size + 1): window = sequence[i:i + window_size] window_average = sum(window) / window_size moving_averages.append(window_average) return moving_averages"},{"question":"def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: Rotate a given N x N matrix 90 degrees clockwise. :param matrix: List of lists where each inner list represents a row of the matrix with integer values. :return: The input matrix rotated 90 degrees clockwise. Examples: >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]] >>> rotate_matrix([[5]]) [[5]] >>> rotate_matrix([ ... [ 1, 2, 3, 4, 5], ... [ 6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20], ... [21, 22, 23, 24, 25] ... ]) [[21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5]] pass","solution":"def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: Rotates a given NxN matrix 90 degrees clockwise. :param matrix: List of lists where each inner list is a row of the matrix. :return: The rotated matrix. N = len(matrix) # Perform the rotation layer by layer for layer in range(N // 2): first = layer last = N - layer - 1 for i in range(first, last): offset = i - first # Save the top element top = matrix[first][i] # Left -> Top matrix[first][i] = matrix[last - offset][first] # Bottom -> Left matrix[last - offset][first] = matrix[last][last - offset] # Right -> Bottom matrix[last][last - offset] = matrix[i][last] # Top -> Right matrix[i][last] = top return matrix"},{"question":"def calculate_total_price(price_per_book: float, quantity: int) -> float: Calculate the total price for an order of books after applying bulk purchase discounts. :param price_per_book: The price of a single book :param quantity: The number of books ordered :return: The total price after discounts >>> calculate_total_price(100, 5) 500.0 >>> calculate_total_price(100, 10) 900.0 >>> calculate_total_price(100, 20) 1600.0 >>> calculate_total_price(100, 0) 0.0 >>> calculate_total_price(-10, 5) Traceback (most recent call last): ... Exception: Price per book must be > 0 >>> calculate_total_price(100, -5) Traceback (most recent call last): ... Exception: Quantity must be a non-negative integer","solution":"def calculate_total_price(price_per_book: float, quantity: int) -> float: Calculate the total price for an order of books after applying bulk purchase discounts. :param price_per_book: The price of a single book :param quantity: The number of books ordered :return: The total price after discounts # Validate input if price_per_book <= 0: raise Exception(\\"Price per book must be > 0\\") if quantity < 0 or not isinstance(quantity, int): raise Exception(\\"Quantity must be a non-negative integer\\") # Calculate total price total_price = price_per_book * quantity # Apply discount based on quantity if quantity >= 20: total_price *= 0.8 # 20% discount elif quantity >= 10: total_price *= 0.9 # 10% discount return round(total_price, 2)"},{"question":"def binary_search_iterative(nums: list[int | float], target: int | float) -> int: Perform a binary search to find the target value in a sorted list using the iterative approach. Parameters: nums (list[int | float]): A sorted list of integers or floats. target (int | float): The search target, an integer or float. Returns: int: The index of the target element if found, otherwise -1. Examples: >>> binary_search_iterative([1, 2, 3, 4, 5, 6, 7, 8, 9], 5) 4 >>> binary_search_iterative([1, 2, 3, 4, 5, 6, 7, 8, 9], 10) -1 >>> binary_search_iterative([1.1, 2.2, 3.3, 4.4, 5.5], 3.3) 2 >>> binary_search_iterative([1.1, 2.2, 3.3, 4.4, 5.5], 6.6) -1 def binary_search_recursive(nums: list[int | float], target: int | float, left: int, right: int) -> int: Perform a binary search to find the target value in a sorted list using the recursive approach. Parameters: nums (list[int | float]): A sorted list of integers or floats. target (int | float): The search target, an integer or float. left (int): The left index of the current search bounds. right (int): The right index of the current search bounds. Returns: int: The index of the target element if found, otherwise -1. Examples: >>> binary_search_recursive([1, 2, 3, 4, 5, 6, 7, 8, 9], 5, 0, 8) 4 >>> binary_search_recursive([1, 2, 3, 4, 5, 6, 7, 8, 9], 10, 0, 8) -1 >>> binary_search_recursive([1.1, 2.2, 3.3, 4.4, 5.5], 3.3, 0, 4) 2 >>> binary_search_recursive([1.1, 2.2, 3.3, 4.4, 5.5], 6.6, 0, 4) -1","solution":"def binary_search_iterative(nums: list[int | float], target: int | float) -> int: left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return -1 def binary_search_recursive(nums: list[int | float], target: int | float, left: int, right: int) -> int: # Index validation if left < 0 or right >= len(nums): raise IndexError(\\"Left or right index out of range\\") if left > right: return -1 mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: return binary_search_recursive(nums, target, mid + 1, right) else: return binary_search_recursive(nums, target, left, mid - 1)"},{"question":"def evaluate_infix_expression(expression): Evaluate a mathematical expression provided in infix notation using two stacks. The expression can contain non-negative integers and the operators +, -, *, /, as well as parentheses (). The division operator / should perform floating point division. >>> evaluate_infix_expression(\\"3 + 2 * (1 + 2) / 3\\") # Output: 5.0 >>> evaluate_infix_expression(\\"(8 + 2) * 5 - 10 / 2\\") # Output: 45.0 >>> evaluate_infix_expression(\\"100 / (5 * (2 + 3))\\") # Output: 4.0 def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_op(a, b, op): if op == '+': return a + b if op == '-': return a - b if op == '*': return a * b if op == '/': return a / b def evaluate(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == ' ': i += 1 continue if tokens[i] == '(': ops.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while (i < len(tokens) and tokens[i].isdigit()): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == ')': while len(ops) != 0 and ops[-1] != '(': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(tokens[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while len(ops) != 0: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[-1] return evaluate(expression) def test_evaluate_simple_expression(): assert evaluate_infix_expression(\\"3 + 5\\") == 8 assert evaluate_infix_expression(\\"10 - 2\\") == 8 def test_evaluate_with_multiplication_division(): assert evaluate_infix_expression(\\"2 * 3\\") == 6 assert evaluate_infix_expression(\\"8 / 2\\") == 4.0 def test_evaluate_with_parentheses(): assert evaluate_infix_expression(\\"(8 + 2) * 5\\") == 50 assert evaluate_infix_expression(\\"10 / (2 + 3)\\") == 2.0 def test_evaluate_with_combined_operators(): assert evaluate_infix_expression(\\"3 + 2 * (1 + 2) / 3\\") == 5.0 assert evaluate_infix_expression(\\"(8 + 2) * 5 - 10 / 2\\") == 45.0 def test_evaluate_complex_expression(): assert evaluate_infix_expression(\\"100 / (5 * (2 + 3))\\") == 4.0 assert evaluate_infix_expression(\\"3 + 2 * ((7 + 5) / (2 * 3))\\") == 7.0","solution":"def evaluate_infix_expression(expression): def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_op(a, b, op): if op == '+': return a + b if op == '-': return a - b if op == '*': return a * b if op == '/': return a / b def evaluate(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == ' ': i += 1 continue if tokens[i] == '(': ops.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while (i < len(tokens) and tokens[i].isdigit()): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == ')': while len(ops) != 0 and ops[-1] != '(': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(tokens[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while len(ops) != 0: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[-1] return evaluate(expression)"},{"question":"from typing import List def largest_island(grid: List[List[str]]) -> int: Finds the size of the largest island in a 2D grid of '1's (land) and '0's (water). An island is a group of '1's connected horizontally or vertically. The function should return the size of the largest island. Parameters: grid (List[List[str]]): A 2D grid map of '1's (land) and '0's (water). Returns: int: The size of the largest island. Example: >>> grid = [ ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"] ... ] >>> largest_island(grid) 4 pass def test_largest_island(): grid1 = [ [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"] ] assert largest_island(grid1) == 4 grid2 = [ [\\"0\\", \\"1\\", \\"0\\"], [\\"1\\", \\"0\\", \\"0\\"], [\\"0\\", \\"1\\", \\"1\\"] ] assert largest_island(grid2) == 2 grid3 = [[\\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\"]] assert largest_island(grid3) == 0 grid4 = [[\\"1\\", \\"1\\", \\"1\\"], [\\"1\\", \\"1\\", \\"1\\"]] assert largest_island(grid4) == 6 grid5 = [[\\"1\\"]] assert largest_island(grid5) == 1 grid6 = [[\\"0\\"]] assert largest_island(grid6) == 0 grid7 = [ [\\"1\\", \\"0\\", \\"1\\", \\"0\\", \\"1\\"], [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"1\\", \\"1\\", \\"1\\"] ] assert largest_island(grid7) == 3","solution":"from typing import List def largest_island(grid: List[List[str]]) -> int: if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False] * cols for _ in range(rows)] def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == '0' or visited[r][c]: return 0 visited[r][c] = True size = 1 size += dfs(r+1, c) size += dfs(r-1, c) size += dfs(r, c+1) size += dfs(r, c-1) return size max_island_size = 0 for r in range(rows): for c in range(cols): if grid[r][c] == '1' and not visited[r][c]: max_island_size = max(max_island_size, dfs(r, c)) return max_island_size"},{"question":"def count_binary_substrings(s: str) -> int: Counts the number of contiguous substrings containing an equal number of 0s and 1s. >>> count_binary_substrings(\\"00110011\\") 6 >>> count_binary_substrings(\\"10101\\") 4 >>> count_binary_substrings(\\"000111\\") 3 >>> count_binary_substrings(\\"000\\") 0 >>> count_binary_substrings(\\"111\\") 0 >>> count_binary_substrings(\\"0\\") 0 >>> count_binary_substrings(\\"1\\") 0 >>> count_binary_substrings(\\"00110\\") 3 >>> count_binary_substrings(\\"00110\\") 3 >>> count_binary_substrings(\\"0011100\\") 4 >>> count_binary_substrings(\\"001100111\\") 6 >>> count_binary_substrings(\\"01100\\") 3","solution":"def count_binary_substrings(s: str) -> int: Counts the number of contiguous substrings containing an equal number of 0s and 1s. # This will store the lengths of consecutive groups of 0s or 1s groups = [] current_count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_count += 1 else: groups.append(current_count) current_count = 1 # Don't forget to append the last counted group groups.append(current_count) # Now count the number of valid substrings result = 0 for i in range(1, len(groups)): result += min(groups[i - 1], groups[i]) return result"},{"question":"def min_window(s: str, t: str) -> str: Find the smallest window in string \`s\` that contains all characters of string \`t\`. >>> min_window(\\"ADOBECODEBANC\\", \\"ABC\\") == \\"BANC\\" >>> min_window(\\"a\\", \\"a\\") == \\"a\\" >>> min_window(\\"a\\", \\"aa\\") == \\"\\" >>> min_window(\\"ab\\", \\"b\\") == \\"b\\"","solution":"from collections import Counter, defaultdict def min_window(s: str, t: str) -> str: if not t or not s: return \\"\\" dict_t = Counter(t) required = len(dict_t) l, r = 0, 0 formed = 0 window_counts = defaultdict(int) min_len = float('inf') min_window = (0, 0) while r < len(s): character = s[r] window_counts[character] += 1 if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 while l <= r and formed == required: character = s[l] if r - l + 1 < min_len: min_len = r - l + 1 min_window = (l, r) window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 l += 1 r += 1 l, r = min_window return s[l:r+1] if min_len != float('inf') else \\"\\""},{"question":"import heapq from collections import defaultdict class Graph: def __init__(self): self.adjacency_list = defaultdict(list) def add_edge(self, vertex_1: int, vertex_2: int, weight: float) -> None: Adds an edge between vertex_1 and vertex_2 with the given weight. pass def dijkstra(self, start_vertex: int) -> dict: Finds the shortest path from start_vertex to all other vertices using Dijkstra's algorithm. pass def depth_first_search(self, start_vertex: int) -> bool: Performs DFS from start_vertex and returns True if the graph is connected, otherwise False. pass def test_dijkstra(): g = Graph() edges = [ (0, 1, 4), (0, 7, 8), (1, 2, 8), (1, 7, 11), (2, 3, 7), (2, 8, 2), (2, 5, 4), (3, 4, 9), (3, 5, 14), (4, 5, 10), (5, 6, 2), (6, 7, 1), (6, 8, 6), (7, 8, 7), ] for v1, v2, weight in edges: g.add_edge(v1, v2, weight) shortest_paths = g.dijkstra(0) assert shortest_paths == {0: 0, 1: 4, 2: 12, 3: 19, 4: 21, 5: 11, 6: 9, 7: 8, 8: 14} def test_depth_first_search(): g = Graph() edges = [ (0, 1, 4), (0, 7, 8), (1, 2, 8), (1, 7, 11), (2, 3, 7), (2, 8, 2), (2, 5, 4), (3, 4, 9), (3, 5, 14), (4, 5, 10), (5, 6, 2), (6, 7, 1), (6, 8, 6), (7, 8, 7), ] for v1, v2, weight in edges: g.add_edge(v1, v2, weight) assert g.depth_first_search(0) == True g2 = Graph() edges2 = [ (0, 1, 4), (1, 2, 8), (2, 4, 2), (3, 5, 6) ] for v1, v2, weight in edges2: g2.add_edge(v1, v2, weight) assert g2.depth_first_search(0) == False","solution":"import heapq from collections import defaultdict class Graph: def __init__(self): self.adjacency_list = defaultdict(list) def add_edge(self, vertex_1, vertex_2, weight): self.adjacency_list[vertex_1].append((vertex_2, weight)) self.adjacency_list[vertex_2].append((vertex_1, weight)) # Assuming the graph is undirected def dijkstra(self, start_vertex): distances = {vertex: float('infinity') for vertex in self.adjacency_list} distances[start_vertex] = 0 priority_queue = [(0, start_vertex)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in self.adjacency_list[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def depth_first_search(self, start_vertex): visited = set() def dfs(vertex): visited.add(vertex) for neighbor, _ in self.adjacency_list[vertex]: if neighbor not in visited: dfs(neighbor) dfs(start_vertex) return len(visited) == len(self.adjacency_list)"},{"question":"class RangeSumFenwickTree: def __init__(self, size: int) -> None: Initializes the RangeSumFenwickTree with the specified size. pass # Remove this pass and implement the method def range_add(self, left: int, right: int, value: int) -> None: Adds the specified value to each element in the range [left, right). pass # Remove this pass and implement the method def range_sum(self, left: int, right: int) -> int: Returns the sum of the elements in the range [left, right). pass # Remove this pass and implement the method # Test cases def test_initial_state(): rsft = RangeSumFenwickTree(8) assert rsft.range_sum(0, 8) == 0 def test_single_range_add(): rsft = RangeSumFenwickTree(8) rsft.range_add(1, 4, 3) assert rsft.range_sum(1, 4) == 9 # 3 + 3 + 3 def test_multiple_range_adds(): rsft = RangeSumFenwickTree(8) rsft.range_add(1, 4, 3) rsft.range_add(3, 6, 5) assert rsft.range_sum(1, 5) == 19 # [3, 3, 8, 5] def test_non_overlapping_adds(): rsft = RangeSumFenwickTree(8) rsft.range_add(0, 2, 2) rsft.range_add(6, 8, 4) assert rsft.range_sum(0, 2) == 4 # 2 + 2 assert rsft.range_sum(6, 8) == 8 # 4 + 4 def test_large_range(): rsft = RangeSumFenwickTree(100000) rsft.range_add(0, 100000, 1) assert rsft.range_sum(0, 100000) == 100000 def test_partial_overlapping_adds(): rsft = RangeSumFenwickTree(8) rsft.range_add(0, 3, 2) rsft.range_add(2, 5, 3) assert rsft.range_sum(0, 2) == 4 # 2 + 2 assert rsft.range_sum(2, 5) == 11 # 2 + 3 + 3 + 3 assert rsft.range_sum(0, 5) == 15 # 2 + 2 + 3 + 3 + 3","solution":"class RangeSumFenwickTree: def __init__(self, size: int) -> None: self.size = size self.tree1 = [0] * (size + 1) self.tree2 = [0] * (size + 1) def __add(self, tree, index, value): while index <= self.size: tree[index] += value index += index & -index def __sum(self, tree, index): result = 0 while index > 0: result += tree[index] index -= index & -index return result def range_add(self, left: int, right: int, value: int) -> None: self.__add(self.tree1, left + 1, value) self.__add(self.tree1, right + 1, -value) self.__add(self.tree2, left + 1, value * left) self.__add(self.tree2, right + 1, -value * right) def __prefix_sum(self, index): return (self.__sum(self.tree1, index) * index - self.__sum(self.tree2, index)) def range_sum(self, left: int, right: int) -> int: return self.__prefix_sum(right) - self.__prefix_sum(left)"},{"question":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Create a function to transpose a given 2-dimensional list (matrix). >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) == [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([[1]]) == [[1]] >>> transpose_matrix([]) == [] >>> transpose_matrix([[1, 2, 3, 4]]) == [[1], [2], [3], [4]] >>> transpose_matrix([[1], [2], [3], [4]]) == [[1, 2, 3, 4]]","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) return [[matrix[j][i] for j in range(rows)] for i in range(cols)]"},{"question":"from typing import List def rotate_array(nums: List[int], k: int) -> List[int]: Rotates the elements of the list nums to the right by k steps. >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([0, 0, 0], 1) [0, 0, 0] >>> rotate_array([10, 20, 30, 40], 4) [10, 20, 30, 40] >>> rotate_array([1, 2, 3], 7) [3, 1, 2]","solution":"from typing import List def rotate_array(nums: List[int], k: int) -> List[int]: Rotates the elements of the list nums to the right by k steps. n = len(nums) k = k % n # Adjust k if it's greater than the length of nums return nums[-k:] + nums[:-k]"},{"question":"def compress_string(s: str) -> str: Compress string by replacing sequences of the same character with the character followed by the count of occurrences. If the compressed string is longer than the original, return the original string. >>> compress_string(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> compress_string(\\"abcdef\\") \\"abcdef\\" >>> compress_string(\\"aabbcc\\") \\"a2b2c2\\" >>> compress_string(\\"zzzzzzzz\\") \\"z8\\"","solution":"def compress_string(s: str) -> str: if not s: return s compressed = [] count = 1 prev_char = s[0] for i in range(1, len(s)): if s[i] == prev_char: count += 1 else: compressed.append(prev_char + str(count)) prev_char = s[i] count = 1 compressed.append(prev_char + str(count)) # Add the last set of characters compressed_string = ''.join(compressed) if len(compressed_string) <= len(s): return compressed_string else: return s"},{"question":"def generate_catalan_numbers(n: int) -> list[int]: Generate the first n Catalan numbers. Args: n (int): The number of Catalan numbers to generate. Returns: list[int]: A list of the first n Catalan numbers. Examples: >>> generate_catalan_numbers(10) [1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862] >>> generate_catalan_numbers(5) [1, 1, 2, 5, 14] >>> generate_catalan_numbers(1) [1] >>> generate_catalan_numbers(0) [] pass","solution":"def generate_catalan_numbers(n: int) -> list[int]: Generate the first n Catalan numbers. Args: n (int): The number of Catalan numbers to generate. Returns: list[int]: A list of the first n Catalan numbers. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return [] catalan_numbers = [1] # The very first Catalan number, C0 is 1 for i in range(1, n): next_catalan = (catalan_numbers[-1] * 2 * (2 * i - 1)) // (i + 1) catalan_numbers.append(next_catalan) return catalan_numbers"},{"question":"def next_permutation(nums: List[int]) -> List[int]: Modify nums into its next permutation as per the lexicographical order. If no next permutation is possible, return the smallest permutation. >>> next_permutation([1, 2, 3]) [1, 3, 2] >>> next_permutation([3, 2, 1]) [1, 2, 3] >>> next_permutation([1, 1, 5]) [1, 5, 1] >>> next_permutation([4, 3, 2, 1]) [1, 2, 3, 4]","solution":"from typing import List def next_permutation(nums: List[int]) -> List[int]: Modify nums into its next permutation as per the lexicographical order. If no next permutation is possible, return the smallest permutation. n = len(nums) if n <= 1: return nums # Step 1: Find the largest index i such that nums[i] < nums[i+1] i = n - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 if i >= 0: # Step 2: Find the largest index j > i such that nums[i] < nums[j] j = n - 1 while nums[j] <= nums[i]: j -= 1 # Step 3: Swap the value of nums[i] with nums[j] nums[i], nums[j] = nums[j], nums[i] # Step 4: Reverse the sequence from nums[i + 1] up to the last element nums[i + 1:] = reversed(nums[i + 1:]) return nums"},{"question":"def has_duplicate_sessions(sessions: list) -> bool: Check if there are duplicate session entries for any user at the same timestamp. Args: sessions (list of tuples): A list of tuples where each tuple contains (user_id: int, timestamp: int). Returns: bool: True if there are duplicate sessions for any user, False otherwise.","solution":"def has_duplicate_sessions(sessions): Check if there are duplicate session entries for any user at the same timestamp. Args: sessions (list of tuples): A list of tuples where each tuple contains (user_id: int, timestamp: int). Returns: bool: True if there are duplicate sessions for any user, False otherwise. session_set = set() for user_id, timestamp in sessions: if (user_id, timestamp) in session_set: return True session_set.add((user_id, timestamp)) return False"},{"question":"class SparseVector: Class to represent a sparse vector. >>> vec1 = SparseVector([1, 0, 0, 2, 3]) >>> vec2 = SparseVector([0, 3, 0, 4, 0]) >>> print(vec1) {0: 1, 3: 2, 4: 3} >>> print(vec2) {1: 3, 3: 4} >>> sum_vec = vec1.add(vec2) >>> print(sum_vec) {0: 1, 1: 3, 3: 6, 4: 3} >>> diff_vec = vec1.subtract(vec2) >>> print(diff_vec) {0: 1, 1: -3, 3: -2, 4: 3} >>> dot_prod = vec1.dot_product(vec2) >>> dot_prod 8","solution":"class SparseVector: def __init__(self, nums: list[int]): self.sparse_representation = {i: num for i, num in enumerate(nums) if num != 0} self.length = len(nums) def add(self, vec: 'SparseVector') -> 'SparseVector': if self.length != vec.length: raise ValueError(\\"Vectors must be of the same length\\") new_nums = [0] * self.length for key, value in self.sparse_representation.items(): new_nums[key] = value for key, value in vec.sparse_representation.items(): new_nums[key] += value return SparseVector(new_nums) def subtract(self, vec: 'SparseVector') -> 'SparseVector': if self.length != vec.length: raise ValueError(\\"Vectors must be of the same length\\") new_nums = [0] * self.length for key, value in self.sparse_representation.items(): new_nums[key] = value for key, value in vec.sparse_representation.items(): new_nums[key] -= value return SparseVector(new_nums) def dot_product(self, vec: 'SparseVector') -> int: if self.length != vec.length: raise ValueError(\\"Vectors must be of the same length\\") result = 0 for key, value in self.sparse_representation.items(): if key in vec.sparse_representation: result += value * vec.sparse_representation[key] return result def __repr__(self) -> str: return str(self.sparse_representation)"},{"question":"def is_balanced(s: str) -> bool: Returns True if the delimiters in the string 's' are balanced and correctly nested, otherwise False. >>> is_balanced(\\"()\\") True >>> is_balanced(\\"([{}])\\") True >>> is_balanced(\\"([)]\\") False >>> is_balanced(\\"(((()\\") False","solution":"def is_balanced(s: str) -> bool: Returns True if the delimiters in the string 's' are balanced and correctly nested, otherwise False. stack = [] matching_bracket = {')': '(', ']': '[', '}': '{'} for char in s: if char in '([{': stack.append(char) elif char in ')]}': if not stack or stack[-1] != matching_bracket[char]: return False stack.pop() return not stack"},{"question":"def smallest_window_substring(s: str, t: str) -> str: Find the smallest window in \`s\` which contains all the characters of \`t\`. Parameters: s (str): The main string. t (str): The string containing the set of characters to be included in the window. Returns: str: The smallest window in \`s\` that contains all characters of \`t\`. If no such window exists, return an empty string. >>> smallest_window_substring(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" >>> smallest_window_substring(\\"a\\", \\"aa\\") \\"\\" >>> smallest_window_substring(\\"a\\", \\"a\\") \\"a\\" pass","solution":"def smallest_window_substring(s: str, t: str) -> str: from collections import Counter, defaultdict if not t or not s: return \\"\\" dict_t = Counter(t) required = len(dict_t) l, r = 0, 0 formed = 0 window_counts = defaultdict(int) ans = float(\\"inf\\"), None, None while r < len(s): character = s[r] window_counts[character] += 1 if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 while l <= r and formed == required: character = s[l] if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s[ans[1]:ans[2] + 1]"},{"question":"def calculate_space_usage(directory: str, files: dict) -> int: Calculates the total space used by all files within the specified directory and its subdirectories. >>> files = { ... \\"/\\": [(\\"file1.txt\\", 100), (\\"file2.txt\\", 200)], ... \\"/subdir1\\": [(\\"file3.txt\\", 300)], ... \\"/subdir1/subsubdir1\\": [(\\"file4.txt\\", 400)], ... \\"/subdir2\\": [(\\"file5.txt\\", 500)] ... } >>> calculate_space_usage(\\"/\\", files) 1500 >>> calculate_space_usage(\\"/subdir1\\", files) 700 >>> calculate_space_usage(\\"/subdir2\\", files) 500 >>> calculate_space_usage(\\"/subdir1/subsubdir1\\", files) 400 >>> calculate_space_usage(\\"/emptydir\\", {}) 0 >>> files = { ... \\"/\\": [], ... \\"/dir1\\": [(\\"file1.txt\\", 100)], ... \\"/dir1/dir2\\": [(\\"file2.txt\\", 200)], ... \\"/dir1/dir2/dir3\\": [(\\"file3.txt\\", 300)] ... } >>> calculate_space_usage(\\"/\\", files) 600 >>> calculate_space_usage(\\"/dir1\\", files) 600 >>> calculate_space_usage(\\"/dir1/dir2\\", files) 500 >>> calculate_space_usage(\\"/dir1/dir2/dir3\\", files) 300","solution":"def calculate_space_usage(directory: str, files: dict) -> int: Calculates the total space used by all files within the specified directory and its subdirectories. :param directory: The path of the directory whose space usage needs to be calculated. :param files: A dictionary representing the file system. Keys are directory paths, and values are lists of tuples where each tuple represents a file (filename, size). :return: Total space used by all files in the given directory (including its subdirectories). total_size = 0 for dir_path, file_list in files.items(): if dir_path.startswith(directory): total_size += sum(size for _, size in file_list) return total_size"},{"question":"def first_missing_positive(nums: List[int]) -> int: Finds the smallest positive integer missing in an unsorted list of integers. >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 from solution import first_missing_positive def test_example_case_1(): assert first_missing_positive([1, 2, 0]) == 3 def test_example_case_2(): assert first_missing_positive([3, 4, -1, 1]) == 2 def test_example_case_3(): assert first_missing_positive([7, 8, 9, 11, 12]) == 1 def test_case_no_missing_positives(): assert first_missing_positive([1, 2, 3]) == 4 def test_case_with_duplicates(): assert first_missing_positive([1, 1, 2, 2]) == 3 def test_case_all_negative(): assert first_missing_positive([-1, -2, -3]) == 1 def test_case_mixed_elements(): assert first_missing_positive([0, 10, 2, -10, -20]) == 1 def test_empty_list(): assert first_missing_positive([]) == 1 def test_large_range(): assert first_missing_positive(list(range(1, 1001))) == 1001","solution":"def first_missing_positive(nums): n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"class FileSystem: In-memory file system simulation class. - mkdir(path: str) -> None: Creates a directory at the specified path. - addFile(path: str, content: str) -> None: Adds a file at the specified path with the given content. - getFile(path: str) -> str: Retrieves the content of the file at the specified path. - ls(path: str) -> list: Lists the contents of a directory or returns the file name if the path refers to a file. Example Usage: >>> fs = FileSystem() >>> fs.mkdir(\\"/a/b/c\\") >>> fs.mkdir(\\"/a/d\\") >>> fs.addFile(\\"/a/b/c/file.txt\\", \\"Hello, World!\\") >>> fs.addFile(\\"/a/d/anotherfile.txt\\", \\"Python Programming\\") >>> assert fs.getFile(\\"/a/b/c/file.txt\\") == \\"Hello, World!\\" >>> assert fs.getFile(\\"/a/d/anotherfile.txt\\") == \\"Python Programming\\" >>> assert fs.ls(\\"/a/b\\") == [\\"c\\"] >>> assert fs.ls(\\"/a\\") == [\\"b\\", \\"d\\"] >>> assert fs.ls(\\"/a/b/c/file.txt\\") == [\\"file.txt\\"] def mkdir(self, path: str) -> None: pass def addFile(self, path: str, content: str) -> None: pass def getFile(self, path: str) -> str: pass def ls(self, path: str) -> list: pass # Unit tests import pytest def test_mkdir(): fs = FileSystem() fs.mkdir(\\"/a/b/c\\") fs.mkdir(\\"/a/d\\") assert 'a' in fs.root assert 'b' in fs.root['a'] assert 'c' in fs.root['a']['b'] assert 'd' in fs.root['a'] def test_addFile_and_getFile(): fs = FileSystem() fs.mkdir(\\"/a/b/c\\") fs.addFile(\\"/a/b/c/file.txt\\", \\"Hello, World!\\") fs.addFile(\\"/a/d/anotherfile.txt\\", \\"Python Programming\\") assert fs.getFile(\\"/a/b/c/file.txt\\") == \\"Hello, World!\\" assert fs.getFile(\\"/a/d/anotherfile.txt\\") == \\"Python Programming\\" def test_ls(): fs = FileSystem() fs.mkdir(\\"/a/b/c\\") fs.addFile(\\"/a/b/c/file.txt\\", \\"Hello, World!\\") fs.addFile(\\"/a/d/anotherfile.txt\\", \\"Python Programming\\") assert fs.ls(\\"/a/b\\") == [\\"c\\"] assert fs.ls(\\"/a\\") == [\\"b\\", \\"d\\"] assert fs.ls(\\"/a/b/c/file.txt\\") == [\\"file.txt\\"] def test_getFile_non_existent(): fs = FileSystem() fs.mkdir(\\"/a/b/c\\") with pytest.raises(KeyError): fs.getFile(\\"/a/b/c/notafile.txt\\") def test_ls_non_existent(): fs = FileSystem() fs.mkdir(\\"/a/b/c\\") with pytest.raises(ValueError): fs.ls(\\"/a/b/c/nonexistent\\")","solution":"class FileSystem: def __init__(self): self.root = dict() def mkdir(self, path: str) -> None: parts = path.strip('/').split('/') current = self.root for part in parts: if part not in current: current[part] = dict() current = current[part] def addFile(self, path: str, content: str) -> None: parts = path.strip('/').split('/') *dirs, file_name = parts current = self.root for part in dirs: if part not in current: current[part] = dict() current = current[part] current[file_name] = content def getFile(self, path: str) -> str: parts = path.strip('/').split('/') current = self.root for part in parts: current = current[part] return current def ls(self, path: str) -> list: parts = path.strip('/').split('/') current = self.root for part in parts: if part in current: current = current[part] else: raise ValueError(\\"Path does not exist\\") if isinstance(current, dict): return sorted(list(current.keys())) else: return [parts[-1]]"},{"question":"def has_overlapping_intervals(intervals: list[tuple[int, int]]) -> bool: Determines if there are any overlapping intervals in the provided list. :param intervals: List of tuples, where each tuple contains two integers representing the start and end of an interval. :return: Boolean value indicating whether any pair of intervals overlap. >>> has_overlapping_intervals([(1, 5), (6, 10), (11, 15)]) False >>> has_overlapping_intervals([(1, 5), (5, 10), (11, 15)]) True >>> has_overlapping_intervals([(1, 5), (2, 4), (3, 7)]) True >>> has_overlapping_intervals([(1, 5)]) False >>> has_overlapping_intervals([]) False >>> has_overlapping_intervals([(1, 5), (2, 3)]) True >>> has_overlapping_intervals([(1, 3), (3, 5), (6, 8)]) True >>> has_overlapping_intervals([(-5, -1), (-10, -6)]) False","solution":"def has_overlapping_intervals(intervals): Determines if there are any overlapping intervals in the provided list. :param intervals: List of tuples, where each tuple contains two integers representing the start and end of an interval. :return: Boolean value indicating whether any pair of intervals overlap. # Sort intervals by their start time intervals.sort() # Iterate through the sorted intervals and check for overlaps for i in range(1, len(intervals)): prev_start, prev_end = intervals[i - 1] curr_start, curr_end = intervals[i] # Check if the current interval overlaps with the previous one if curr_start <= prev_end: return True return False"},{"question":"from typing import List def find_highest_frequency_element(arr: List[int]) -> int: Find the element with the highest frequency in the array. If multiple elements have the same highest frequency, return the smallest element. >>> find_highest_frequency_element([1, 3, 2, 3, 4, 1, 2, 3, 1]) 1 >>> find_highest_frequency_element([4, 4, 2, 2, 3, 3]) 2 >>> find_highest_frequency_element([10, 10, 20, 20, 30, 30, 30]) 30 >>> find_highest_frequency_element([5, 5, 6, 6, 7, 7, 7]) 7 >>> find_highest_frequency_element([1] * 1000000) 1 >>> find_highest_frequency_element([1, 2, 2, 1, 3, 3]) 1 >>> find_highest_frequency_element([2, 1, 2, 1, 2]) 2","solution":"from collections import defaultdict from typing import List def find_highest_frequency_element(arr: List[int]) -> int: Find the element with the highest frequency in the array. If multiple elements have the same highest frequency, return the smallest element. frequency = defaultdict(int) # Calculate the frequency of each element for num in arr: frequency[num] += 1 # Find the element with the highest frequency max_count = 0 max_elements = [] for num, count in frequency.items(): if count > max_count: max_count = count max_elements = [num] elif count == max_count: max_elements.append(num) # Return the smallest element among those with the highest frequency return min(max_elements)"},{"question":"def zigzag_convert(s: str, num_rows: int) -> str: Convert a given string s into a zigzag pattern on num_rows rows and then reads the pattern line by line. >>> zigzag_convert(\\"PAYPALISHIRING\\", 3) \\"PAHNAPLSIIGYIR\\" >>> zigzag_convert(\\"PAYPALISHIRING\\", 4) \\"PINALSIGYAHRPI\\" >>> zigzag_convert(\\"A\\", 1) \\"A\\" >>> zigzag_convert(\\"ABCDE\\", 1) \\"ABCDE\\" >>> zigzag_convert(\\"ABC\\", 5) \\"ABC\\" >>> zigzag_convert(\\"\\", 3) \\"\\" >>> zigzag_convert(\\"PAYPALISHIRING\\", -1) # raises ValueError >>> zigzag_convert(1234, 3) # raises ValueError >>> zigzag_convert(\\"PAYPALISHIRING\\", \\"three\\") # raises ValueError","solution":"def zigzag_convert(s: str, num_rows: int) -> str: if not isinstance(s, str) or not isinstance(num_rows, int) or num_rows <= 0: raise ValueError(\\"Invalid input parameters\\") if num_rows == 1 or len(s) <= num_rows: return s rows = ['' for _ in range(min(num_rows, len(s)))] current_row, step = 0, 1 for char in s: rows[current_row] += char if current_row == 0: step = 1 elif current_row == num_rows - 1: step = -1 current_row += step return ''.join(rows)"},{"question":"def double_square_sum(n: int) -> int: Computes the sum of the squares of all even numbers from 2 to n, inclusive. Parameters: n (int): The upper limit (inclusive) for the range of numbers to be considered. Returns: int: The sum of the squares of all even numbers from 2 to n. >>> double_square_sum(10) 220 >>> double_square_sum(6) 56 >>> double_square_sum(2) 4","solution":"def double_square_sum(n: int) -> int: Computes the sum of the squares of all even numbers from 2 to n, inclusive. Parameters: n (int): The upper limit (inclusive) for the range of numbers to be considered. Returns: int: The sum of the squares of all even numbers from 2 to n. return sum(i**2 for i in range(2, n + 1, 2))"},{"question":"def selection_sort(arr: list) -> list: Sorts a list of integers in ascending order using the Selection Sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: A list of integers sorted in ascending order. Raises: TypeError: If the input is not a list. ValueError: If any element in the list is not an integer. Example: >>> selection_sort([64, 25, 12, 22, 11]) [11, 12, 22, 25, 64] >>> selection_sort([3, -2, 5, 1, 6]) [-2, 1, 3, 5, 6] >>> selection_sort([]) [] >>> selection_sort('not a list') Traceback (most recent call last): ... TypeError: Input must be a list >>> selection_sort([4, 3, 'not an integer']) Traceback (most recent call last): ... ValueError: All elements must be integers","solution":"def selection_sort(arr): Sorts a list of integers in ascending order using the Selection Sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: A list of integers sorted in ascending order. Raises: TypeError: If the input is not a list. ValueError: If any element in the list is not an integer. if not isinstance(arr, list): raise TypeError(\\"Input must be a list\\") for element in arr: if not isinstance(element, int): raise ValueError(\\"All elements must be integers\\") n = len(arr) for i in range(n): # Find the minimum element in remaining unsorted array min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j # Swap the found minimum element with the first element arr[i], arr[min_idx] = arr[min_idx], arr[i] return arr"},{"question":"def remove_substring(main_string: str, substring: str) -> str: Removes all occurrences of substring from main_string. >>> remove_substring(\\"abcdefabcghi\\", \\"abc\\") \\"defghi\\" >>> remove_substring(\\"aaaaa\\", \\"a\\") \\"\\" >>> remove_substring(\\"hello world\\", \\" \\") \\"helloworld\\"","solution":"def remove_substring(main_string: str, substring: str) -> str: Removes all occurrences of substring from main_string. Parameters: main_string (str): The main string from which to remove the substring. substring (str): The substring to be removed from the main string. Returns: str: The result string with all occurrences of substring removed from main_string. if not substring: return main_string return main_string.replace(substring, \\"\\")"},{"question":"import numpy as np def euclidean_norm(vector: np.ndarray) -> float: Computes the Euclidean Norm (L2 Norm) of a given vector. Parameters: vector (np.ndarray): Input 1D numpy array of numeric values. Returns: float: Euclidean Norm of the vector. >>> vector = np.array([3, 4]) >>> euclidean_norm(vector) 5.0 >>> vector = np.array([1, 2, 2]) >>> euclidean_norm(vector) 3.0 >>> vector = np.array([0, 0, 0]) >>> euclidean_norm(vector) 0.0 >>> vector = np.array([-1, -1, -1, -1]) >>> euclidean_norm(vector) 2.0 >>> vector = np.ones(1000000) >>> np.isclose(euclidean_norm(vector), np.sqrt(1000000)) True","solution":"import numpy as np def euclidean_norm(vector: np.ndarray) -> float: Computes the Euclidean Norm (L2 Norm) of a given vector. Parameters: vector (np.ndarray): Input 1D numpy array of numeric values. Returns: float: Euclidean Norm of the vector. return np.sqrt(np.sum(vector ** 2))"},{"question":"import random import math import matplotlib.pyplot as plt from typing import List, Tuple class Route: def __init__(self, points: List[Tuple[int, int]]): self.points = points[:] def total_distance(self) -> float: Returns the total distance of the route. >>> Route([(0, 0), (3, 4), (3, 0)]).total_distance() 12.0 def mutate(self, mutation_rate: float): Performs mutation on the route based on the given mutation rate. >>> route = Route([(0, 0), (3, 4), (3, 0)]) >>> route.mutate(1.0) >>> set(route.points) == {(0, 0), (3, 4), (3, 0)} True def crossover(parent1: Route, parent2: Route) -> Route: Performs crossover between two parent routes and returns a new child route. def genetic_algorithm( initial_population: List[Route], generations: int = 1000, mutation_rate: float = 0.01, crossover_rate: float = 0.75, population_size: int = 100, visualize: bool = False ) -> Route: Uses a Genetic Algorithm to find the optimal route that minimizes the total distance traveled. >>> points = [ ... (0, 0), ... (1, 5), (2, 2), (3, 6), (5, 3), (6, 1) ... ] >>> initial_population = [Route(points) for _ in range(10)] >>> optimal_route = genetic_algorithm( ... initial_population=initial_population, ... generations=100, ... mutation_rate=0.05, ... crossover_rate=0.8, ... population_size=10, ... visualize=False ... ) >>> len(optimal_route.points) 6 >>> isinstance(optimal_route.total_distance(), float) True","solution":"import random import math import matplotlib.pyplot as plt from itertools import combinations class Route: def __init__(self, points: list): self.points = points random.shuffle(self.points) def total_distance(self) -> float: distance = 0.0 for i in range(len(self.points)): x1, y1 = self.points[i] x2, y2 = self.points[(i+1) % len(self.points)] distance += math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) return distance def mutate(self, mutation_rate: float): for i in range(len(self.points)): if random.random() < mutation_rate: j = random.randint(0, len(self.points) - 1) self.points[i], self.points[j] = self.points[j], self.points[i] def crossover(parent1: Route, parent2: Route) -> Route: start, end = sorted(random.sample(range(len(parent1.points)), 2)) child_points = [None] * len(parent1.points) child_points[start:end] = parent1.points[start:end] parent2_points = [point for point in parent2.points if point not in child_points] pointer = 0 for i in range(len(child_points)): if child_points[i] is None: child_points[i] = parent2_points[pointer] pointer += 1 return Route(child_points) def genetic_algorithm( initial_population: list, generations: int = 1000, mutation_rate: float = 0.01, crossover_rate: float = 0.75, population_size: int = 100, visualize: bool = False ) -> Route: def selection(population): return random.choices( population, weights=[1/route.total_distance() for route in population], k=2 ) population = initial_population if visualize: distances = [] for generation in range(generations): new_population = [] for _ in range(population_size): parent1, parent2 = selection(population) if random.random() < crossover_rate: child = crossover(parent1, parent2) else: child = Route(parent1.points[:]) child.mutate(mutation_rate) new_population.append(child) population = new_population if visualize: best_route = min(population, key=lambda route: route.total_distance()) distances.append(best_route.total_distance()) if visualize: plt.plot(range(generations), distances) plt.xlabel(\\"Generation\\") plt.ylabel(\\"Distance\\") plt.show() best_route = min(population, key=lambda route: route.total_distance()) return best_route"},{"question":"def longest_unique_subseq(s: str) -> int: Compute the length of the longest subsequence in a given string where all characters are unique. >>> longest_unique_subseq(\\"abcabcbb\\") 3 >>> longest_unique_subseq(\\"bbbbb\\") 1 >>> longest_unique_subseq(\\"pwwkew\\") 4 >>> longest_unique_subseq(\\"a\\") 1 >>> longest_unique_subseq(\\"abcdefghi\\") 9","solution":"def longest_unique_subseq(s: str) -> int: Function to compute the length of the longest subsequence with all unique characters. return len(set(s))"},{"question":"Implement a Naive Bayes Classifier Your task is to implement a Naive Bayes classifier for binary classification. Naive Bayes classifiers are based on applying Bayes' theorem with strong (naive) independence assumptions between the features. The classifier works by calculating the probability of each class given the input features and selecting the class with the highest probability. For binary classification, the probabilities for a data point (x = (x_1, x_2, ..., x_d)) to belong to class (y in {0, 1}) can be computed as: [ P(y mid x) = frac{ P(x mid y) cdot P(y) }{ P(x) } ] But since ( P(x) ) is the same for all classes, we can compare the numerator only: [ P(y mid x) propto P(y) cdot prod_{i=1}^{d} P(x_i mid y) ] Where: - ( P(y) ) is the prior probability of class y. - ( P(x_i mid y) ) is the likelihood of feature ( x_i ) given class y. You can assume that each feature is normally distributed. Given feature ( x_i ) for class y: [ P(x_i mid y) = frac{1}{sqrt{2 pi sigma_{y,i}^2}} exp left( - frac{ (x_i - mu_{y,i})^2 }{2 sigma_{y,i}^2} right) ] Where ( mu_{y,i} ) and ( sigma_{y,i}^2 ) are the mean and variance of feature ( x_i ) in class y. Requirements: 1. Implement the NaiveBayes class with \`fit\` and \`predict\` methods. 2. The \`fit\` method should calculate the mean and variance of each feature for both classes, as well as the prior probabilities. 3. The \`predict\` method should use the calculated parameters to predict the class of new observations. 4. Add appropriate validation checks for input data. Input: - Observations: A list of ndarrays representing the feature vectors of the training data. - Classes: An ndarray of integers {0, 1} representing the class labels of the training data. - A single test observation: An ndarray representing a new data point to classify. Output: - Predicted class: An integer value from {0, 1} corresponding to the predicted class of the observation. Constraints: - Inputs to the \`fit\` method can have up to 10,000 observations with up to 100 features each. - Inputs to the \`predict\` method must be the same dimensionality as the observations used in \`fit\`. # Example: import numpy as np class NaiveBayes: def __init__(self): self.priors = {} self.means = {} self.vars = {} def fit(self, observations, classes): n_features = observations[0].shape[0] for c in np.unique(classes): obs_c = [obs for (obs, label) in zip(observations, classes) if label == c] self.priors[c] = len(obs_c) / len(observations) self.means[c] = np.mean(obs_c, axis=0) self.vars[c] = np.var(obs_c, axis=0) def predict(self, observation): posteriors = [] for c in self.priors: prior = np.log(self.priors[c]) conditional = np.sum(-0.5 * np.log(2 * np.pi * self.vars[c]) - 0.5 * ((observation - self.means[c]) ** 2) / self.vars[c]) posteriors.append(prior + conditional) return np.argmax(posteriors) # Initialize the NaiveBayes classifier nb = NaiveBayes() # Fit the classifier with training data observations = [ np.asarray([1.0, 2.0]), np.asarray([1.0, 1.5]), np.asarray([2.0, 1.0]), np.asarray([2.5, 1.0]) ] classes = np.asarray([0, 0, 1, 1]) nb.fit(observations, classes) # Predict a new observation new_observation = np.asarray([1.5, 1.0]) print(nb.predict(new_observation)) # Expected output: 1 (example) Ensure your implementation meets these requirements and passes the provided example tests.","solution":"import numpy as np class NaiveBayes: def __init__(self): self.priors = {} self.means = {} self.vars = {} def fit(self, observations, classes): n_features = observations[0].shape[0] obs_by_class = {0: [], 1: []} for obs, cls in zip(observations, classes): if cls not in [0, 1]: raise ValueError(\\"Class labels must be 0 or 1.\\") obs_by_class[cls].append(obs) for c in [0, 1]: obs_c = np.array(obs_by_class[c]) self.priors[c] = len(obs_c) / len(observations) self.means[c] = np.mean(obs_c, axis=0) self.vars[c] = np.var(obs_c, axis=0) def predict(self, observation): if len(observation) != len(self.means[0]): raise ValueError(f\\"Expected observation length of {len(self.means[0])}, got {len(observation)}\\") posteriors = [] for c in self.priors: prior = np.log(self.priors[c]) conditional = np.sum(-0.5 * np.log(2 * np.pi * self.vars[c]) - 0.5 * ((observation - self.means[c]) ** 2) / self.vars[c]) posteriors.append(prior + conditional) return np.argmax(posteriors)"},{"question":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root: Optional[TreeNode]) -> int: Compute the maximum path sum of a binary tree. A path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node. >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> max_path_sum(root) 6 >>> root = TreeNode(-10, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))) >>> max_path_sum(root) 42 >>> root = TreeNode(2, TreeNode(-1), TreeNode(-2)) >>> max_path_sum(root) 2 >>> root = TreeNode(-3) >>> max_path_sum(root) -3 >>> max_path_sum(None) 0","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root: Optional[TreeNode]) -> int: if root is None: return 0 def helper(node: TreeNode) -> int: nonlocal max_sum if not node: return 0 left_gain = max(helper(node.left), 0) right_gain = max(helper(node.right), 0) current_path_sum = node.val + left_gain + right_gain max_sum = max(max_sum, current_path_sum) return node.val + max(left_gain, right_gain) max_sum = float('-inf') helper(root) return max_sum"},{"question":"from typing import List, Tuple def generate_valid_passwords(pairs: List[Tuple[str, str]], limit: int) -> List[str]: Generates valid passwords from character pairs such that the sum of the ASCII values of the characters in a password is divisible by 3. >>> pairs = [('a', 'b'), ('c', 'd'), ('e', 'f')] >>> limit = 5 >>> generate_valid_passwords(pairs, limit) ['aca', 'aeb', 'bfa', 'bec', 'dfc']","solution":"from typing import List, Tuple from itertools import permutations def generate_valid_passwords(pairs: List[Tuple[str, str]], limit: int) -> List[str]: Generates valid passwords from character pairs such that the sum of the ASCII values of the characters in a password is divisible by 3. all_chars = {char for pair in pairs for char in pair} valid_passwords = [] # Generate permutations of length 3 from the set of all unique characters for perm in permutations(all_chars, 3): if sum(ord(char) for char in perm) % 3 == 0: valid_passwords.append(''.join(perm)) if len(valid_passwords) == limit: break return valid_passwords"},{"question":"from typing import List class WordBreakSolver: A class that provides functionality to determine if a given string can be segmented into a space-separated sequence of one or more dictionary words. >>> solver = WordBreakSolver([\\"leetcode\\", \\"leet\\", \\"code\\"]) >>> solver.canBreak(\\"leetcode\\") True >>> solver.canBreak(\\"leetco\\") False >>> solver.setDictionary([\\"apple\\", \\"pen\\"]) >>> solver.canBreak(\\"applepenapple\\") True >>> solver.setDictionary([\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) >>> solver.canBreak(\\"catsandog\\") False def __init__(self, wordDict: List[str]) -> None: pass def setDictionary(self, wordDict: List[str]) -> None: pass def canBreak(self, s: str) -> bool: pass","solution":"from typing import List class WordBreakSolver: def __init__(self, wordDict: List[str]) -> None: self.wordDict = set(wordDict) # Using a set for O(1) look-ups def setDictionary(self, wordDict: List[str]) -> None: self.wordDict = set(wordDict) def canBreak(self, s: str) -> bool: n = len(s) dp = [False] * (n + 1) dp[0] = True for i in range(1, n + 1): for j in range(i): if dp[j] and s[j:i] in self.wordDict: dp[i] = True break return dp[n]"},{"question":"def remove_duplicates(data_log: list[int]) -> list[int]: Removes duplicate elements from the data_log while preserving the order of their first occurrence. Parameters: data_log (list of int): A list of integers representing a sequence of data entries Returns: list of int: A list with unique elements from the input list, in the order of their first appearance Examples: >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([7, 7, 6, 5, 5, 5, 4]) [7, 6, 5, 4] >>> remove_duplicates([3, 3, 3, 2, 1, 1]) [3, 2, 1] >>> remove_duplicates([1, 2, 3, 4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> remove_duplicates([5, 5, 5, 5, 5]) [5]","solution":"def remove_duplicates(data_log): Removes duplicate elements from the data_log while preserving the order of their first occurrence. Parameters: data_log (list of int): A list of integers representing a sequence of data entries Returns: list of int: A list with unique elements from the input list, in the order of their first appearance seen = set() unique_data_log = [] for item in data_log: if item not in seen: seen.add(item) unique_data_log.append(item) return unique_data_log"},{"question":"def find_fibonacci(n: int) -> int: Calculate the n-th number in the Fibonacci sequence. Args: n (int): A non-negative integer representing the position in the Fibonacci sequence. Returns: int: The n-th Fibonacci number. Examples: >>> find_fibonacci(0) 0 >>> find_fibonacci(1) 1 >>> find_fibonacci(7) 13 >>> find_fibonacci(10) 55 >>> find_fibonacci(30) 832040","solution":"def find_fibonacci(n: int) -> int: Returns the n-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 # Initialize base cases for _ in range(2, n+1): # Iterate to find the n-th Fibonacci number a, b = b, a + b return b"},{"question":"def rotate_image(matrix): Rotates the given n x n 2D matrix by 90 degrees clockwise in place. >>> matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] >>> rotate_image(matrix) >>> print(matrix) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ [ 5, 1, 9, 11], [ 2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] >>> rotate_image(matrix) >>> print(matrix) [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ]","solution":"def rotate_image(matrix): Rotates the given n x n 2D matrix by 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"class TreeNode: def __init__(self, value: int) -> None: Initialize a tree node with a given integer value. pass class BinarySearchTree: def __init__(self) -> None: Initialize an empty binary search tree. pass def insert(self, value: int) -> None: Insert a value into the binary search tree. pass def delete(self, value: int) -> None: Delete a value from the binary search tree. pass def search(self, value: int) -> bool: Search for a value in the binary search tree. Returns True if found, else False. pass def inorder_traversal(self) -> list[int]: Return a list of elements in in-order traversal (left-root-right). pass def preorder_traversal(self) -> list[int]: Return a list of elements in pre-order traversal (root-left-right). pass def postorder_traversal(self) -> list[int]: Return a list of elements in post-order traversal (left-right-root). pass def __repr__(self) -> str: Return a string representation of the binary search tree. pass # Example usage: # bst = BinarySearchTree() # bst.insert(5) # bst.insert(3) # bst.insert(7) # print(bst.search(4)) # Output: False # bst.delete(7) # print(bst.inorder_traversal()) # Output: [3, 5] # print(bst) # Output: BinarySearchTree(3, 5)","solution":"class TreeNode: def __init__(self, value: int) -> None: self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self) -> None: self.root = None def insert(self, value: int) -> None: if self.root is None: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node: TreeNode, value: int) -> None: if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert_recursive(node.right, value) def delete(self, value: int) -> None: self.root = self._delete_recursive(self.root, value) def _delete_recursive(self, node: TreeNode, value: int) -> TreeNode: if not node: return node if value < node.value: node.left = self._delete_recursive(node.left, value) elif value > node.value: node.right = self._delete_recursive(node.right, value) else: if not node.left: return node.right if not node.right: return node.left temp = self._find_min(node.right) node.value = temp.value node.right = self._delete_recursive(node.right, temp.value) return node def _find_min(self, node: TreeNode) -> TreeNode: while node.left: node = node.left return node def search(self, value: int) -> bool: return self._search_recursive(self.root, value) def _search_recursive(self, node: TreeNode, value: int) -> bool: if not node: return False if node.value == value: return True elif value < node.value: return self._search_recursive(node.left, value) else: return self._search_recursive(node.right, value) def inorder_traversal(self) -> list[int]: result = [] self._inorder_recursive(self.root, result) return result def _inorder_recursive(self, node: TreeNode, result: list[int]) -> None: if node: self._inorder_recursive(node.left, result) result.append(node.value) self._inorder_recursive(node.right, result) def preorder_traversal(self) -> list[int]: result = [] self._preorder_recursive(self.root, result) return result def _preorder_recursive(self, node: TreeNode, result: list[int]) -> None: if node: result.append(node.value) self._preorder_recursive(node.left, result) self._preorder_recursive(node.right, result) def postorder_traversal(self) -> list[int]: result = [] self._postorder_recursive(self.root, result) return result def _postorder_recursive(self, node: TreeNode, result: list[int]) -> None: if node: self._postorder_recursive(node.left, result) self._postorder_recursive(node.right, result) result.append(node.value) def __repr__(self) -> str: return f\\"BinarySearchTree({', '.join(map(str, self.inorder_traversal()))})\\""},{"question":"def is_transformation_possible(s: str, t: str) -> bool: Check if it is possible to transform string s into string t using the allowed operations. >>> is_transformation_possible(\\"ABC\\", \\"CBA\\") True >>> is_transformation_possible(\\"AABBCC\\", \\"ABABCC\\") True >>> is_transformation_possible(\\"AA\\", \\"BB\\") False >>> is_transformation_possible(\\"ABC\\", \\"AABCC\\") False >>> is_transformation_possible(\\"AB\\", \\"BA\\") True","solution":"def is_transformation_possible(s: str, t: str) -> bool: from collections import Counter return Counter(s) == Counter(t)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def linked_list_common_nodes(head1: ListNode, head2: ListNode) -> ListNode: Connect common nodes in two linked lists and return a new linked list of common nodes in ascending order. Given linked list 1: 1 -> 3 -> 4 -> 6 and linked list 2: 2 -> 3 -> 6 -> 7, the function should return a linked list: 3 -> 6. >>> head1 = list_to_linked_list([1, 3, 4, 6]) >>> head2 = list_to_linked_list([2, 3, 6, 7]) >>> common = linked_list_common_nodes(head1, head2) >>> linked_list_to_list(common) [3, 6] pass def list_to_linked_list(values): dummy = ListNode() current = dummy for val in values: current.next = ListNode(val) current = current.next return dummy.next def linked_list_to_list(head): result = [] while head: result.append(head.val) head = head.next return result def test_linked_list_common_nodes(): head1 = list_to_linked_list([1, 3, 4, 6]) head2 = list_to_linked_list([2, 3, 6, 7]) common = linked_list_common_nodes(head1, head2) assert linked_list_to_list(common) == [3, 6] def test_linked_list_common_nodes_with_duplicates(): head1 = list_to_linked_list([1, 2, 2, 4, 5]) head2 = list_to_linked_list([2, 2, 3, 5]) common = linked_list_common_nodes(head1, head2) assert linked_list_to_list(common) == [2, 5] def test_linked_list_common_nodes_no_common(): head1 = list_to_linked_list([0, 1, 2, 4]) head2 = list_to_linked_list([5, 6, 7]) common = linked_list_common_nodes(head1, head2) assert linked_list_to_list(common) == [] def test_linked_list_common_nodes_empty_first_list(): head1 = list_to_linked_list([]) head2 = list_to_linked_list([1, 2, 3]) common = linked_list_common_nodes(head1, head2) assert linked_list_to_list(common) == [] def test_linked_list_common_nodes_empty_second_list(): head1 = list_to_linked_list([1, 2, 3]) head2 = list_to_linked_list([]) common = linked_list_common_nodes(head1, head2) assert linked_list_to_list(common) == [] def test_linked_list_common_nodes_both_empty(): head1 = list_to_linked_list([]) head2 = list_to_linked_list([]) common = linked_list_common_nodes(head1, head2) assert linked_list_to_list(common) == []","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def linked_list_common_nodes(head1: ListNode, head2: ListNode) -> ListNode: # Function to generate a sorted list from the nodes' values def generate_sorted_list(node): values_set = set() while node: values_set.add(node.val) node = node.next return sorted(values_set) # Get sorted lists from both linked lists sorted_list1 = generate_sorted_list(head1) sorted_list2 = generate_sorted_list(head2) # Find common elements in the two sorted lists common_values = sorted(set(sorted_list1).intersection(set(sorted_list2))) # Creating the new linked list with common elements dummy = ListNode() # Dummy node to start the new linked list current = dummy for val in common_values: current.next = ListNode(val) current = current.next return dummy.next"},{"question":"def max_profit(prices: list[int]) -> int: Returns the maximum profit achievable by buying and selling the stock exactly once. :param prices: A list of integers representing stock prices. :return: An integer representing the maximum profit or 0 if no profit is possible. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1]) 0 >>> max_profit([]) 0 >>> max_profit([3, 3, 3, 3, 3]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([5, 4, 3, 2, 1]) 0 >>> max_profit([9, 1, 6, 3, 8]) 7 >>> max_profit([3, 2, 6, 1, 3, 4]) 4","solution":"def max_profit(prices): Returns the maximum profit achievable by buying and selling the stock exactly once. :param prices: A list of integers representing stock prices. :return: An integer representing the maximum profit or 0 if no profit is possible. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def longest_unique_substring(s: str) -> str: Implement a function that returns the longest substring without repeating characters. In case of multiple substrings of the same length, return the one which appears first. This function should raise: - TypeError if the input is not a string - ValueError if the input string is empty Examples: >>> longest_unique_substring('abcabcbb') == 'abc' >>> longest_unique_substring('bbbbb') == 'b' >>> longest_unique_substring('pwwkew') == 'wke' >>> longest_unique_substring('abcdefg') == 'abcdefg' >>> longest_unique_substring('') # should raise ValueError >>> longest_unique_substring(12345) # should raise TypeError","solution":"def longest_unique_substring(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") if len(s) == 0: raise ValueError(\\"Input string must not be empty\\") char_map = {} start = 0 max_length = 0 start_max = 0 for i, ch in enumerate(s): if ch in char_map and char_map[ch] >= start: start = char_map[ch] + 1 char_map[ch] = i if i - start + 1 > max_length: max_length = i - start + 1 start_max = start return s[start_max:start_max + max_length]"},{"question":"def generate_pascals_triangle(n: int) -> list: Generates Pascal's Triangle up to the nth row. :param n: An integer representing the number of rows to generate :return: A list of lists representing Pascal's Triangle >>> generate_pascals_triangle(5) [ [1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1] ] pass # To be implemented by the student","solution":"def generate_pascals_triangle(n): Generates Pascal's Triangle up to the nth row. :param n: An integer representing the number of rows to generate :return: A list of lists representing Pascal's Triangle if n < 0: return [] triangle = [] for i in range(n + 1): row = [1] * (i + 1) for j in range(1, i): row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j] triangle.append(row) return triangle"},{"question":"import time def dummy_function(): This is a dummy function with a known, short runtime. return def calculate_function_runtime(func): Records the start and end times of a function execution and returns the runtime. start_time = time.time() func() end_time = time.time() return end_time - start_time def test_calculate_function_runtime(monkeypatch): Test the calculate_function_runtime function by mocking the time.time method. # Simulated start and end times start_time = 1000.0 end_time = 1001.0 def mock_time(): Mocks the time.time method to produce controlled start and end times. return getattr(mock_time, \\"current\\", start_time) # Sequence of times to be returned by the mock mock_time.current = start_time times_sequence = [start_time, end_time] def side_effect(): return times_sequence.pop(0) monkeypatch.setattr(time, \\"time\\", side_effect) # Verify that the runtime calculated matches the expected runtime runtime = calculate_function_runtime(dummy_function) expected_runtime = end_time - start_time assert runtime == expected_runtime, f\\"Expected runtime: {expected_runtime}, but got: {runtime}\\"","solution":"import time def dummy_function(): This is a dummy function with a known, short runtime. return def calculate_function_runtime(func): Records the start and end times of a function execution and returns the runtime. start_time = time.time() func() end_time = time.time() return end_time - start_time"},{"question":"from typing import List, Tuple def optimized_merge_sort(collection: List[int]) -> Tuple[List[int], int, int]: Perform Merge Sort while collecting statistics on number of merge function calls and the number of comparisons made. :param collection: the list of integers to sort :return: (sorted list, number of merge calls, number of comparisons made) >>> sorted_list, merge_calls, comparisons = optimized_merge_sort([38, 27, 43, 3, 9, 82, 10]) >>> sorted_list [3, 9, 10, 27, 38, 43, 82] >>> merge_calls 10 >>> comparisons 13 >>> sorted_list, merge_calls, comparisons = optimized_merge_sort([1, 2, 3, 4, 5]) >>> sorted_list [1, 2, 3, 4, 5] >>> merge_calls 4 >>> comparisons 4","solution":"from typing import List, Tuple def optimized_merge_sort(collection: List[int]) -> Tuple[List[int], int, int]: Perform Merge Sort while collecting statistics on number of merge function calls and the number of comparisons made. :param collection: the list of integers to sort :return: (sorted list, number of merge calls, number of comparisons made) merge_calls = 0 comparisons = 0 def merge(left: List[int], right: List[int]) -> List[int]: nonlocal merge_calls, comparisons merge_calls += 1 sorted_list = [] i = j = 0 while i < len(left) and j < len(right): comparisons += 1 if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 while i < len(left): sorted_list.append(left[i]) i += 1 while j < len(right): sorted_list.append(right[j]) j += 1 return sorted_list def merge_sort(lst: List[int]) -> List[int]: if len(lst) <= 1: return lst mid = len(lst) // 2 left = merge_sort(lst[:mid]) right = merge_sort(lst[mid:]) return merge(left, right) sorted_collection = merge_sort(collection) return sorted_collection, merge_calls, comparisons"},{"question":"def find_kth_smallest(arr: list, k: int) -> int: Find the k-th smallest element in an unsorted array. The function should aim for an average-case time complexity of O(n). Args: arr (list): A list of integers. k (int): The 1-based index of the k-th smallest element to find. Returns: int: The k-th smallest element in the array. Raises: ValueError: If the input array is empty or if k is out of bounds. Examples: >>> find_kth_smallest([3, 2, 1, 5, 4], 3) 3 >>> find_kth_smallest([9, -1, 3, 5, 2], 2) 2 >>> find_kth_smallest([1], 1) 1 >>> find_kth_smallest([5, 5, 5, 5, 5], 3) 5 >>> find_kth_smallest([x for x in range(1, 1000001)], 1000000) 1000000","solution":"def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quickselect(arr, low, high, k): if low < high: pivot_index = partition(arr, low, high) if pivot_index == k: return arr[pivot_index] elif pivot_index > k: return quickselect(arr, low, pivot_index - 1, k) else: return quickselect(arr, pivot_index + 1, high, k) return arr[low] def find_kth_smallest(arr, k): if not arr: raise ValueError(\\"Array cannot be empty.\\") if k < 1 or k > len(arr): raise ValueError(\\"k is out of bounds.\\") return quickselect(arr[:], 0, len(arr) - 1, k - 1)"},{"question":"def generate_word_cloud(words_list: list[str]) -> dict[str, int]: Transforms a list of words into a dictionary suitable for creating a word cloud. Args: words_list (list of str): List of words and phrases. Returns: dict: A dictionary with words as keys and their respective frequencies as values. >>> words = [\\"hello\\", \\"world\\", \\"Hello\\", \\"WORLD\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\", \\"example\\", \\"example\\"] >>> generate_word_cloud(words) {'hello': 2, 'world': 2, 'test': 1, 'example': 2} >>> words = [] >>> generate_word_cloud(words) {} >>> words = [\\"the\\", \\"is\\", \\"at\\", \\"which\\", \\"on\\"] >>> generate_word_cloud(words) {} >>> words = [\\"Hello\\", \\"hello\\", \\"HELLO\\", \\"world\\", \\"WORLD\\", \\"world\\"] >>> generate_word_cloud(words) {'hello': 3, 'world': 3} >>> words = [\\"python\\", \\"Python\\", \\"PYTHON\\", \\"code\\", \\"Code\\"] >>> generate_word_cloud(words) {'python': 3, 'code': 2} >>> words = [\\"this\\", \\"is\\", \\"an\\", \\"example\\", \\"Example\\", \\"of\\", \\"a\\", \\"test\\", \\"Test\\"] >>> generate_word_cloud(words) {'example': 2, 'test': 2} >>> words = [\\"hello!\\", \\"HELLO!\\", \\"world?\\", \\"world!\\"] >>> generate_word_cloud(words) {'hello!': 2, 'world?': 1, 'world!': 1}","solution":"def generate_word_cloud(words_list): Transforms a list of words into a dictionary suitable for creating a word cloud. Args: words_list (list of str): List of words and phrases. Returns: dict: A dictionary with words as keys and their respective frequencies as values. import re from collections import Counter # List of common English stop words stop_words = set([ \\"a\\", \\"about\\", \\"above\\", \\"after\\", \\"again\\", \\"against\\", \\"all\\", \\"am\\", \\"an\\", \\"and\\", \\"any\\", \\"are\\", \\"aren't\\", \\"as\\", \\"at\\", \\"be\\", \\"because\\", \\"been\\", \\"before\\", \\"being\\", \\"below\\", \\"between\\", \\"both\\", \\"but\\", \\"by\\", \\"can't\\", \\"cannot\\", \\"could\\", \\"couldn't\\", \\"did\\", \\"didn't\\", \\"do\\", \\"does\\", \\"doesn't\\", \\"doing\\", \\"don't\\", \\"down\\", \\"during\\", \\"each\\", \\"few\\", \\"for\\", \\"from\\", \\"further\\", \\"had\\", \\"hadn't\\", \\"has\\", \\"hasn't\\", \\"have\\", \\"haven't\\", \\"having\\", \\"he\\", \\"he'd\\", \\"he'll\\", \\"he's\\", \\"her\\", \\"here\\", \\"here's\\", \\"hers\\", \\"herself\\", \\"him\\", \\"himself\\", \\"his\\", \\"how\\", \\"how's\\", \\"i\\", \\"i'd\\", \\"i'll\\", \\"i'm\\", \\"i've\\", \\"if\\", \\"in\\", \\"into\\", \\"is\\", \\"isn't\\", \\"it\\", \\"it's\\", \\"its\\", \\"itself\\", \\"let's\\", \\"me\\", \\"more\\", \\"most\\", \\"mustn't\\", \\"my\\", \\"myself\\", \\"no\\", \\"nor\\", \\"not\\", \\"of\\", \\"off\\", \\"on\\", \\"once\\", \\"only\\", \\"or\\", \\"other\\", \\"ought\\", \\"our\\", \\"ours\\", \\"ourselves\\", \\"out\\", \\"over\\", \\"own\\", \\"same\\", \\"shan't\\", \\"she\\", \\"she'd\\", \\"she'll\\", \\"she's\\", \\"should\\", \\"shouldn't\\", \\"so\\", \\"some\\", \\"such\\", \\"than\\", \\"that\\", \\"that's\\", \\"the\\", \\"their\\", \\"theirs\\", \\"them\\", \\"themselves\\", \\"then\\", \\"there\\", \\"there's\\", \\"these\\", \\"they\\", \\"they'd\\", \\"they'll\\", \\"they're\\", \\"they've\\", \\"this\\", \\"those\\", \\"through\\", \\"to\\", \\"too\\", \\"under\\", \\"until\\", \\"up\\", \\"very\\", \\"was\\", \\"wasn't\\", \\"we\\", \\"we'd\\", \\"we'll\\", \\"we're\\", \\"we've\\", \\"were\\", \\"weren't\\", \\"what\\", \\"what's\\", \\"when\\", \\"when's\\", \\"where\\", \\"where's\\", \\"which\\", \\"while\\", \\"who\\", \\"who's\\", \\"whom\\", \\"why\\", \\"why's\\", \\"with\\", \\"won't\\", \\"would\\", \\"wouldn't\\", \\"you\\", \\"you'd\\", \\"you'll\\", \\"you're\\", \\"you've\\", \\"your\\", \\"yours\\", \\"yourself\\", \\"yourselves\\" ]) # Convert all words to lowercase and filter out stop words filtered_words = [ word.lower() for word in words_list if word.lower() not in stop_words ] # Count the frequency of each word word_count = Counter(filtered_words) return dict(word_count) # Example usage words = [\\"hello\\", \\"world\\", \\"Hello\\", \\"WORLD\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\", \\"example\\", \\"example\\"] word_cloud = generate_word_cloud(words) print(word_cloud)"},{"question":"import asyncio import signal import random import logging # Setup logging logging.basicConfig(level=logging.INFO) async def fetch_stock_price(stock_symbol): Simulates fetching the stock price for a given symbol. Randomly raises ConnectionError to simulate network issues. pass async def monitor_stock_price(stock_symbol: str, update_interval: int = 5): Periodically fetches and displays the latest stock price for the given symbol. Retries up to 3 times on network error before logging an error. Parameters: stock_symbol (str): The symbol of the stock to monitor. update_interval (int): The interval (in seconds) at which to fetch and display the latest stock price. Defaults to 5. pass if __name__ == \\"__main__\\": stock_symbol = \\"AAPL\\" update_interval = 10 asyncio.run(monitor_stock_price(stock_symbol, update_interval))","solution":"import asyncio import signal import random import logging # Setup logging logging.basicConfig(level=logging.INFO) # Simulated stock price data provider async def fetch_stock_price(stock_symbol): Simulates fetching the stock price for a given symbol. Randomly raises ConnectionError to simulate network issues. if random.random() < 0.1: # Simulate a 10% chance of network error. raise ConnectionError(f\\"Failed to fetch price for {stock_symbol}\\") return round(random.uniform(100, 150), 2) async def monitor_stock_price(stock_symbol: str, update_interval: int = 5): Periodically fetches and displays the latest stock price for the given symbol. Retries up to 3 times on network error before logging an error. stop_event = asyncio.Event() def signal_handler(): stop_event.set() signal.signal(signal.SIGINT, lambda s, f: signal_handler()) while not stop_event.is_set(): for attempt in range(3): try: price = await fetch_stock_price(stock_symbol) logging.info(f\\"Latest price for {stock_symbol}: {price}\\") break except ConnectionError as e: if attempt < 2: logging.warning(f\\"Retrying ({attempt+1}/3): {e}\\") else: logging.error(f\\"Failed to fetch price after 3 attempts: {e}\\") try: await asyncio.wait_for(stop_event.wait(), timeout=update_interval) except asyncio.TimeoutError: continue if __name__ == \\"__main__\\": stock_symbol = \\"AAPL\\" update_interval = 10 asyncio.run(monitor_stock_price(stock_symbol, update_interval))"},{"question":"# Longest Consecutive Sequence in an Array Implement the function \`longest_consecutive_sequence\` that finds the length of the longest consecutive elements sequence in a given unsorted array of integers. def longest_consecutive_sequence(nums: list[int]) -> int: Given an unsorted array of integers, finds the length of the longest consecutive elements sequence. :param nums: List of integers representing the array. :return: Integer representing the length of the longest consecutive elements sequence. Constraints: - The length of the \`nums\` list will be at most 10^5. - All integers in the list will be distinct and in the range of [-10^9, 10^9]. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # Check if 'num' is the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak def test_longest_consecutive_sequence(): assert longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) == 4 # The sequence is [1, 2, 3, 4] def test_empty_array(): assert longest_consecutive_sequence([]) == 0 # No elements in the array def test_single_element(): assert longest_consecutive_sequence([1]) == 1 def test_array_with_no_consecutive_elements(): assert longest_consecutive_sequence([10, 5, 100]) == 1 def test_mixed_values(): assert longest_consecutive_sequence([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) == 9 # The sequence is [0, 1, 2, 3, 4, 5, 6, 7, 8] def test_duplicates_present(): assert longest_consecutive_sequence([1, 2, 2, 3]) == 3 # Sequence is [1, 2, 3] (duplicates removed) def test_large_negative_to_positive_sequence(): assert longest_consecutive_sequence([-2, -1, 0, 1, 2]) == 5 # The sequence is [-2, -1, 0, 1, 2]","solution":"def longest_consecutive_sequence(nums): Given an unsorted array of integers, finds the length of the longest consecutive elements sequence. :param nums: List of integers representing the array. :return: Integer representing the length of the longest consecutive elements sequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # Check if 'num' is the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def process_events(events: List[int]) -> int: Schedules the events and returns the total time taken to process all events. Parameters: events (list of int): List of event durations in seconds Returns: int: Total time taken to process all events >>> process_events([2, 3, 5, 7]) 17 >>> process_events([1, 1, 1, 1, 1]) 5 >>> process_events([]) 0 >>> process_events([10, 20, 30]) 60 >>> process_events([1000] * 1000) 1000000","solution":"def process_events(events): Schedules the events and returns the total time taken to process all events. Parameters: events (list of int): List of event durations in seconds Returns: int: Total time taken to process all events total_time = 0 for event_time in events: total_time += event_time return total_time"},{"question":"from typing import List def generate_combinations(characters: str) -> List[str]: Generates all possible unique combinations of characters from an input string. >>> generate_combinations(\\"abc\\") ['a', 'ab', 'abc', 'ac', 'b', 'bc', 'c'] >>> generate_combinations(\\"aabb\\") ['a', 'aa', 'aab', 'aabb', 'ab', 'abb', 'b', 'bb'] Params: characters (str): A string containing the set of characters to generate combinations from. Returns: list: A list of unique combinations sorted lexicographically. pass","solution":"from itertools import combinations def generate_combinations(characters: str) -> list: Generates all possible unique combinations of characters from an input string. Params: characters (str): A string containing the set of characters to generate combinations from. Returns: list: A list of unique combinations sorted lexicographically. unique_combinations = set() for r in range(1, len(characters) + 1): for combo in combinations(sorted(characters), r): unique_combinations.add(''.join(combo)) return sorted(unique_combinations)"},{"question":"from typing import Optional class ListNode: def __init__(self, val: int = 0, next: Optional['ListNode'] = None): self.val = val self.next = next def merge_two_sorted_lists(l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]: Merge two sorted linked lists into one sorted linked list. >>> list_to_linkedlist([1, 2, 4]) >>> list_to_linkedlist([1, 3, 4]) >>> linkedlist_to_list(merge_two_sorted_lists(l1, l2)) [1, 1, 2, 3, 4, 4] >>> l1 = None >>> l2 = list_to_linkedlist([0]) >>> linkedlist_to_list(merge_two_sorted_lists(l1, l2)) [0]","solution":"from typing import Optional class ListNode: def __init__(self, val: int = 0, next: Optional['ListNode'] = None): self.val = val self.next = next def merge_two_sorted_lists(l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]: dummy = ListNode() current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 else: current.next = l2 return dummy.next"},{"question":"def sort_by_salary(employees): Sorts the list of employee records in ascending order by the 'salary' key. Parameters: employees (list): A list of dictionaries with keys 'id', 'name', and 'salary'. Returns: None: The function modifies the list in-place. Example Usage: >>> employees = [ ... {'id': 1, 'name': 'Alice', 'salary': 70000}, ... {'id': 2, 'name': 'Bob', 'salary': 80000}, ... {'id': 3, 'name': 'Charlie', 'salary': 55000} ... ] >>> sort_by_salary(employees) >>> print(employees) [{'id': 3, 'name': 'Charlie', 'salary': 55000}, {'id': 1, 'name': 'Alice', 'salary': 70000}, {'id': 2, 'name': 'Bob', 'salary': 80000}] >>> employees = [{'id': 1, 'name': 'Danny', 'salary': 90000}] >>> sort_by_salary(employees) >>> print(employees) [{'id': 1, 'name': 'Danny', 'salary': 90000}] >>> employees = [] >>> sort_by_salary(employees) >>> print(employees) [] >>> employees = [ ... {'id': 1, 'name': 'Alice', 'salary': 50000}, ... {'id': 2, 'name': 'Bob', 'salary': 60000}, ... {'id': 3, 'name': 'Charlie', 'salary': 70000} ... ] >>> sort_by_salary(employees) >>> print(employees) [{'id': 1, 'name': 'Alice', 'salary': 50000}, {'id': 2, 'name': 'Bob', 'salary': 60000}, {'id': 3, 'name': 'Charlie', 'salary': 70000}] >>> employees = [ ... {'id': 1, 'name': 'Alice', 'salary': 70000}, ... {'id': 2, 'name': 'Bob', 'salary': 60000}, ... {'id': 3, 'name': 'Charlie', 'salary': 50000}, ... {'id': 4, 'name': 'Delta', 'salary': 60000} ... ] >>> sort_by_salary(employees) >>> print(employees) [{'id': 3, 'name': 'Charlie', 'salary': 50000}, {'id': 2, 'name': 'Bob', 'salary': 60000}, {'id': 4, 'name': 'Delta', 'salary': 60000}, {'id': 1, 'name': 'Alice', 'salary': 70000}]","solution":"def sort_by_salary(employees): Sorts the list of employee records in ascending order by the 'salary' key. Parameters: employees (list): A list of dictionaries with keys 'id', 'name', and 'salary'. Returns: None: The function modifies the list in-place. employees.sort(key=lambda x: x['salary'])"},{"question":"import re from typing import List, Dict def build_inverted_index(documents: List[str]) -> Dict[str, List[int]]: Constructs an inverted index from a given list of documents. Args: documents (list): List of strings, where each string represents a document. Returns: dict: A dictionary where each key is a word, and the value is a list of indices of the documents that contain that word. Example: >>> documents = [\\"The quick brown fox\\", \\"Jumped over the lazy dog\\", \\"The quick and lazy dog\\"] >>> build_inverted_index(documents) {'the': [0, 1, 2], 'quick': [0, 2], 'brown': [0], 'fox': [0], 'jumped': [1], 'over': [1], 'lazy': [1, 2], 'dog': [1, 2], 'and': [2]}","solution":"import re from collections import defaultdict def build_inverted_index(documents): Constructs an inverted index from a given list of documents. Args: documents (list): List of strings, where each string represents a document. Returns: dict: A dictionary where each key is a word, and the value is a list of indices of the documents that contain that word. inverted_index = defaultdict(list) for index, document in enumerate(documents): # Converting document to lowercase and removing non-alphanumeric characters words = re.findall(r'bw+b', document.lower()) for word in set(words): # Using set to avoid duplicate entries in the same document inverted_index[word].append(index) return dict(inverted_index)"},{"question":"from typing import List, Dict, Tuple def update_inventory_prices(inventory: List[Dict[str, any]], price_updates: List[Tuple[str, float]]) -> List[Dict[str, any]]: Update the prices of products in the inventory based on the provided price updates. >>> inventory = [{'id': 'p1', 'name': 'Product 1', 'price': 100.0}, {'id': 'p2', 'name': 'Product 2', 'price': 150.0}] >>> price_updates = [('p1', 110.0), ('p3', 170.0)] >>> update_inventory_prices(inventory, price_updates) [{'id': 'p1', 'name': 'Product 1', 'price': 110.0}, {'id': 'p2', 'name': 'Product 2', 'price': 150.0}] def test_update_inventory_prices_basic(): inventory = [{'id': 'p1', 'name': 'Product 1', 'price': 100.0}, {'id': 'p2', 'name': 'Product 2', 'price': 150.0}] price_updates = [('p1', 110.0), ('p3', 170.0)] expected = [{'id': 'p1', 'name': 'Product 1', 'price': 110.0}, {'id': 'p2', 'name': 'Product 2', 'price': 150.0}] assert update_inventory_prices(inventory, price_updates) == expected def test_update_inventory_prices_no_updates(): inventory = [{'id': 'p1', 'name': 'Product 1', 'price': 100.0}] price_updates = [] expected = [{'id': 'p1', 'name': 'Product 1', 'price': 100.0}] assert update_inventory_prices(inventory, price_updates) == expected def test_update_inventory_prices_no_inventory(): inventory = [] price_updates = [('p1', 110.0)] expected = [] assert update_inventory_prices(inventory, price_updates) == expected def test_update_inventory_prices_partial_updates(): inventory = [ {'id': 'p1', 'name': 'Product 1', 'price': 100.0}, {'id': 'p2', 'name': 'Product 2', 'price': 150.0}, {'id': 'p3', 'name': 'Product 3', 'price': 200.0}, ] price_updates = [('p2', 160.0)] expected = [ {'id': 'p1', 'name': 'Product 1', 'price': 100.0}, {'id': 'p2', 'name': 'Product 2', 'price': 160.0}, {'id': 'p3', 'name': 'Product 3', 'price': 200.0}, ] assert update_inventory_prices(inventory, price_updates) == expected def test_update_inventory_prices_edge_cases(): inventory = [ {'id': 'p1', 'name': 'Product 1', 'price': 100.0}, {'id': 'p2', 'name': 'Product 2', 'price': 150.0}, ] price_updates = [('p1', 110.0), ('p1', 120.0), ('p2', 160.0)] expected = [ {'id': 'p1', 'name': 'Product 1', 'price': 120.0}, {'id': 'p2', 'name': 'Product 2', 'price': 160.0}, ] assert update_inventory_prices(inventory, price_updates) == expected","solution":"from typing import List, Dict, Tuple def update_inventory_prices(inventory: List[Dict[str, any]], price_updates: List[Tuple[str, float]]) -> List[Dict[str, any]]: # Create a dictionary from the price updates for quick lookup updates_dict = {update[0]: update[1] for update in price_updates} # Iterate through the inventory and update the prices based on the update dictionary for item in inventory: if item['id'] in updates_dict: item['price'] = updates_dict[item['id']] return inventory"},{"question":"def convert_and_classify_temperature(celsius: float) -> Tuple[float, str]: Converts temperature from Celsius to Fahrenheit and classifies the temperature. Args: celsius (float): Temperature in degrees Celsius. Returns: Tuple[float, str]: Returns a tuple with: - fahrenheit (float): Temperature in degrees Fahrenheit. - classification (str): Classification of the temperature. Raises: ValueError: if the input temperature in Celsius is below absolute zero (-273.15). if celsius < -273.15: raise ValueError(\\"Temperature in Celsius cannot be below absolute zero (-273.15°C)\\") fahrenheit = celsius * 9/5 + 32 if celsius < 10: classification = \\"Cold\\" elif 10 <= celsius <= 25: classification = \\"Warm\\" else: classification = \\"Hot\\" return fahrenheit, classification","solution":"from typing import Tuple def convert_and_classify_temperature(celsius: float) -> Tuple[float, str]: Converts temperature from Celsius to Fahrenheit and classifies the temperature. Args: celsius (float): Temperature in degrees Celsius. Returns: Tuple[float, str]: Returns a tuple with: - fahrenheit (float): Temperature in degrees Fahrenheit. - classification (str): Classification of the temperature. Raises: ValueError: if the input temperature in Celsius is below absolute zero (-273.15). if celsius < -273.15: raise ValueError(\\"Temperature in Celsius cannot be below absolute zero (-273.15°C)\\") fahrenheit = celsius * 9/5 + 32 if celsius < 10: classification = \\"Cold\\" elif 10 <= celsius <= 25: classification = \\"Warm\\" else: classification = \\"Hot\\" return fahrenheit, classification"},{"question":"def is_anagram(str1: str, str2: str) -> bool: Determine if two strings are anagrams, ignoring spaces and capitalization. >>> is_anagram(\\"Listen\\", \\"Silent\\") True >>> is_anagram(\\"Hello World\\", \\"hello dlrow\\") True >>> is_anagram(\\"apple\\", \\"pale\\") False def is_scramble(str1: str, str2: str) -> bool: Determine if the second string is a scrambled version of the first string. >>> is_scramble(\\"abcde\\", \\"deabc\\") True >>> is_scramble(\\"abc\\", \\"bca\\") True >>> is_scramble(\\"apple\\", \\"pplea\\") True >>> is_scramble(\\"apple\\", \\"ppleaa\\") False","solution":"def is_anagram(str1, str2): Determines if two strings are anagrams, ignoring spaces and capitalization. # Remove spaces and convert to lower case cleaned_str1 = str1.replace(\\" \\", \\"\\").lower() cleaned_str2 = str2.replace(\\" \\", \\"\\").lower() # Sort and compare return sorted(cleaned_str1) == sorted(cleaned_str2) def is_scramble(str1, str2): Determines if the second string is a scrambled version of the first string, meaning it is a permutation of the first string that could be rotated. # Edge case: if lengths differ, they can't possibly be scrambles if len(str1) != len(str2): return False # Concatenate str1 with itself and check if str2 is a substring doubled_str1 = str1 + str1 return str2 in doubled_str1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_largest_element_in_bst(root: TreeNode, k: int) -> int: Computes the k-th largest element in the given BST. Parameters: root (TreeNode): The root of the binary search tree. k (int): The k-th largest element to find. Returns: int: The k-th largest element. >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(7) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(8) >>> kth_largest_element_in_bst(root, 1) 8 >>> kth_largest_element_in_bst(root, 2) 7 >>> kth_largest_element_in_bst(root, 3) 6 >>> kth_largest_element_in_bst(root, 4) 5 >>> kth_largest_element_in_bst(root, 5) 4 >>> kth_largest_element_in_bst(root, 6) 3 >>> kth_largest_element_in_bst(root, 7) 2 pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_largest_element_in_bst(root: TreeNode, k: int) -> int: Computes the k-th largest element in the given BST. Parameters: root (TreeNode): The root of the binary search tree. k (int): The k-th largest element to find. Returns: int: The k-th largest element. # We use reverse in-order traversal (right-root-left) to get elements in descending order def reverse_inorder_traversal(node): if node is None: return [] return reverse_inorder_traversal(node.right) + [node.val] + reverse_inorder_traversal(node.left) ordered_elements = reverse_inorder_traversal(root) return ordered_elements[k-1]"},{"question":"inventory = {} def add_item(item_name: str, quantity: int) -> None: Adds a new item to the inventory. If the item already exists, raises a ValueError. >>> add_item(\\"orange\\", 50) >>> add_item(\\"apple\\", 30) >>> add_item(\\"orange\\", 40) Traceback (most recent call last): ... ValueError: Item already exists def update_quantity(item_name: str, quantity: int) -> None: Updates the quantity of an existing item in the inventory. If the item does not exist, raises a ValueError. If the resulting quantity is negative, raises a ValueError. >>> add_item(\\"orange\\", 50) >>> update_quantity(\\"orange\\", 20) >>> update_quantity(\\"banana\\", 30) Traceback (most recent call last): ... ValueError: Item not found >>> update_quantity(\\"orange\\", -70) Traceback (most recent call last): ... ValueError: Insufficient quantity def get_inventory() -> dict: Returns the current state of the inventory. >>> add_item(\\"apple\\", 50) >>> add_item(\\"banana\\", 100) >>> get_inventory() {\\"apple\\": 50, \\"banana\\": 100}","solution":"# Global inventory dictionary inventory = {} def add_item(item_name: str, quantity: int) -> None: Adds a new item to the inventory. If the item already exists, raises a ValueError. if item_name in inventory: raise ValueError(\\"Item already exists\\") inventory[item_name] = quantity def update_quantity(item_name: str, quantity: int) -> None: Updates the quantity of an existing item in the inventory. If the item does not exist, raises a ValueError. If the resulting quantity is negative, raises a ValueError. if item_name not in inventory: raise ValueError(\\"Item not found\\") if inventory[item_name] + quantity < 0: raise ValueError(\\"Insufficient quantity\\") inventory[item_name] += quantity def get_inventory() -> dict: Returns the current state of the inventory. return inventory"},{"question":"def knapsack_dynamic(weights, values, capacity): Solves the Knapsack problem using dynamic programming for an optimal solution. Args: weights (list of int): A list of integers representing the weights of the items. values (list of int): A list of integers representing the values of the items. capacity (int): An integer representing the maximum capacity of the knapsack. Returns: int: The maximum value that can be obtained by selecting items without exceeding the knapsack's capacity. Examples: >>> knapsack_dynamic([1, 2, 3, 4, 5], [10, 20, 30, 40, 50], 10) 100 >>> knapsack_dynamic([1, 3, 4, 5], [1, 4, 5, 7], 7) 9 >>> knapsack_dynamic([2, 3, 4, 5], [3, 4, 5, 6], 5) 7 >>> knapsack_dynamic([5, 4, 6, 3], [10, 40, 30, 50], 10) 90 >>> knapsack_dynamic([], [], 5) 0 >>> knapsack_dynamic([1, 2, 3], [10, 20, 30], 0) 0","solution":"def knapsack_dynamic(weights, values, capacity): Solves the Knapsack problem using dynamic programming for optimal solution. Args: weights (list): A list of item weights. values (list): A list of item values. capacity (int): The maximum weight capacity of the knapsack. Returns: int: The maximum value achievable with the given constraints. n = len(weights) dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(capacity + 1): if weights[i-1] <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w - weights[i-1]] + values[i-1]) else: dp[i][w] = dp[i-1][w] return dp[n][capacity]"},{"question":"def shift_string(s: str, shift: int) -> str: Shifts each character in the input string by a specified number of positions in the alphabet. The alphabet wraps around such that shifting 'z' by one position results in 'a', and shifting 'Z' by one position results in 'A'. Non-alphabet characters remain unchanged. Args: s (str): The input string consisting of alphabetic and non-alphabetic characters. shift (int): The number of positions each character in the string \`s\` should be shifted. Returns: str: The resultant string after shifting each character in \`s\` by \`shift\` positions. Examples: >>> shift_string(\\"abc\\", 1) \\"bcd\\" >>> shift_string(\\"XYZ\\", 2) \\"ZAB\\" >>> shift_string(\\"Hello, World!\\", 5) \\"Mjqqt, Btwqi!\\" >>> shift_string(\\"shift123\\", 0) \\"shift123\\" pass # Unit tests def test_shift_string_basic(): assert shift_string(\\"abc\\", 1) == \\"bcd\\" assert shift_string(\\"XYZ\\", 2) == \\"ZAB\\" assert shift_string(\\"Hello, World!\\", 5) == \\"Mjqqt, Btwqi!\\" assert shift_string(\\"shift123\\", 0) == \\"shift123\\" def test_shift_string_wrapping(): assert shift_string(\\"xyz\\", 3) == \\"abc\\" assert shift_string(\\"ABC\\", 3) == \\"DEF\\" assert shift_string(\\"z\\", 1) == \\"a\\" assert shift_string(\\"Z\\", 1) == \\"A\\" assert shift_string(\\"a\\", -1) == \\"z\\" assert shift_string(\\"A\\", -1) == \\"Z\\" def test_shift_string_negative_shift(): assert shift_string(\\"bcd\\", -1) == \\"abc\\" assert shift_string(\\"ZAB\\", -2) == \\"XYZ\\" def test_shift_string_empty_string(): assert shift_string(\\"\\", 5) == \\"\\" def test_shift_string_non_alpha_characters(): assert shift_string(\\"Test! 123\\", 4) == \\"Xiwx! 123\\" assert shift_string(\\"Foo Bar!!\\", -3) == \\"Cll Yxo!!\\"","solution":"def shift_string(s: str, shift: int) -> str: def shift_char(c, shift): if 'a' <= c <= 'z': return chr((ord(c) - ord('a') + shift) % 26 + ord('a')) elif 'A' <= c <= 'Z': return chr((ord(c) - ord('A') + shift) % 26 + ord('A')) else: return c return ''.join(shift_char(c, shift) for c in s)"},{"question":"def compress_string(s: str) -> str: Compress the given string using the Run-Length Encoding algorithm. >>> compress_string(\\"AAAABBBCCDA\\") \\"A4B3C2D1A1\\" >>> compress_string(\\"AAABBAACC\\") \\"A3B2A2C2\\" def decompress_string(encoded: str) -> str: Decompress the given string encoded with the Run-Length Encoding algorithm. >>> decompress_string(\\"A4B3C2D1A1\\") \\"AAAABBBCCDA\\" >>> decompress_string(\\"A3B2A2C2\\") \\"AAABBAACC\\"","solution":"def compress_string(s: str) -> str: Compress the given string using the Run-Length Encoding algorithm. if not s: return \\"\\" compressed = [] count = 1 prev_char = s[0] for char in s[1:]: if char == prev_char: count += 1 else: compressed.append(f\\"{prev_char}{count}\\") prev_char = char count = 1 compressed.append(f\\"{prev_char}{count}\\") return ''.join(compressed) def decompress_string(encoded: str) -> str: Decompress the given string encoded with the Run-Length Encoding algorithm. decompressed = [] i = 0 n = len(encoded) while i < n: char = encoded[i] count = 0 i += 1 while i < n and encoded[i].isdigit(): count = count * 10 + int(encoded[i]) i += 1 decompressed.append(char * count) return ''.join(decompressed)"},{"question":"def is_happy_number(n: int) -> bool: Determines if a given number is a happy number. :param n: int - The number to be checked :return: bool - True if n is a happy number, False otherwise >>> is_happy_number(19) True >>> is_happy_number(7) True >>> is_happy_number(18) False >>> is_happy_number(1) True >>> is_happy_number(25) False","solution":"def is_happy_number(n: int) -> bool: Determines if a given number is a happy number. :param n: int - The number to be checked :return: bool - True if n is a happy number, False otherwise if n <= 0: return False def get_next(number): total_sum = 0 while number > 0: digit = number % 10 total_sum += digit ** 2 number //= 10 return total_sum seen_numbers = set() while n != 1 and n not in seen_numbers: seen_numbers.add(n) n = get_next(n) return n == 1"},{"question":"def boiling_point(altitude: float) -> float: Calculate the boiling point of water at a given altitude. >>> boiling_point(0) 100.0 >>> boiling_point(300) 99.0 >>> boiling_point(1500) 95.0 >>> boiling_point(3000) 90.0 >>> boiling_point(150.5) 99.5 >>> boiling_point(-50) Traceback (most recent call last): ... ValueError: Altitude must be non-negative","solution":"def boiling_point(altitude: float) -> float: Calculates the boiling point of water at a given altitude based on the formula: T = 100 - (altitude / 300). Parameters: altitude (float): The altitude above sea level in meters. Must be non-negative. Returns: float: The boiling point of water at the given altitude in degrees Celsius. Raises: ValueError: If altitude is negative. if altitude < 0: raise ValueError(\\"Altitude must be non-negative\\") boiling_temp = 100 - (altitude / 300) return round(boiling_temp, 2)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def balance_factor(root: TreeNode) -> int: Determine the balance factor of a binary tree. >>> balance_factor(TreeNode(1, TreeNode(2, TreeNode(3)))) 2 >>> balance_factor(TreeNode(1, None, TreeNode(2, None, TreeNode(3)))) -2 >>> balance_factor(None) 0 >>> balance_factor(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3))) 1","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def height(node): if node is None: return 0 return 1 + max(height(node.left), height(node.right)) def balance_factor(root: TreeNode) -> int: if root is None: return 0 left_height = height(root.left) right_height = height(root.right) return left_height - right_height"},{"question":"def count_set_bits_in_range(start: int, end: int) -> int: Counts the total number of set bits in the binary representations of all integers within the range [start, end] inclusive. >>> count_set_bits_in_range(5, 7) 9 >>> count_set_bits_in_range(0, 8) 13 >>> count_set_bits_in_range(10, 15) 17 >>> count_set_bits_in_range(0, 0) 0 >>> count_set_bits_in_range(2, 2) 1 >>> count_set_bits_in_range(7, 5) Traceback (most recent call last): ... ValueError: start should be less than or equal to end >>> count_set_bits_in_range(-1, 5) Traceback (most recent call last): ... ValueError: start and end must be non-negative integers >>> count_set_bits_in_range(0, 1.5) Traceback (most recent call last): ... TypeError: Both start and end must be integers >>> count_set_bits_in_range(\\"0\\", \\"5\\") Traceback (most recent call last): ... TypeError: Both start and end must be integers","solution":"def count_set_bits_in_range(start: int, end: int) -> int: Counts the total number of set bits in the binary representations of all integers within the range [start, end] inclusive. # Validate input types if not isinstance(start, int) or not isinstance(end, int): raise TypeError(\\"Both start and end must be integers\\") # Validate input values if start < 0 or end < 0: raise ValueError(\\"start and end must be non-negative integers\\") if start > end: raise ValueError(\\"start should be less than or equal to end\\") # Count set bits in the given range total_set_bits = 0 for number in range(start, end + 1): total_set_bits += bin(number).count('1') return total_set_bits"},{"question":"[Completion Task in Python] class Maze: def __init__(self, maze): Initialize the Maze class with the given 2D list 'maze' and initialize path and state variables. self.maze = maze self.n = len(maze) self.path_found = False self.path = [[0] * self.n for _ in range(self.n)] def is_safe(self, row: int, col: int) -> bool: Check if moving to a cell (row, col) is safe (i.e., within bounds, not a wall, and not already part of the path). :param row: The row index of the cell to check. :param col: The column index of the cell to check. :return: True if the cell is a valid move, otherwise False. return 0 <= row < self.n and 0 <= col < self.n and self.maze[row][col] == 0 and self.path[row][col] == 0 def solve_maze(self) -> bool: Solve the maze starting from the upper-left corner and ending at the bottom-right corner using backtracking. :return: True if a path from start to goal is found, otherwise False. if self._solve_maze_util(0, 0): self.path_found = True self._mark_path() return True else: return False def _solve_maze_util(self, row: int, col: int) -> bool: Utility function to solve the maze using backtracking. :param row: The current row index. :param col: The current column index. :return: True if a path to the goal is found from the current cell, otherwise False. if row == self.n - 1 and col == self.n - 1: self.path[row][col] = 1 return True if self.is_safe(row, col): self.path[row][col] = 1 if self._solve_maze_util(row + 1, col): return True if self._solve_maze_util(row, col + 1): return True if self._solve_maze_util(row - 1, col): return True if self._solve_maze_util(row, col - 1): return True self.path[row][col] = 0 return False def _mark_path(self): Mark the path found in the original maze grid with 'P'. for row in range(self.n): for col in range(self.n): if self.path[row][col] == 1: self.maze[row][col] = 'P' def print_maze_with_path(self): Print the maze grid with the path marked. for row in self.maze: print(' '.join(str(cell) for cell in row))","solution":"class Maze: def __init__(self, maze): self.maze = maze self.n = len(maze) self.path_found = False self.path = [[0] * self.n for _ in range(self.n)] def is_safe(self, row, col): Checks if a cell (row, col) is a valid move. return 0 <= row < self.n and 0 <= col < self.n and self.maze[row][col] == 0 and self.path[row][col] == 0 def solve_maze(self): Solves the maze using backtracking algorithm. if self._solve_maze_util(0, 0): self.path_found = True self._mark_path() return True else: return False def _solve_maze_util(self, row, col): Utility function to solve the maze using backtracking. # If (row, col) is the goal, mark it and return True if row == self.n - 1 and col == self.n - 1: self.path[row][col] = 1 return True # Check if maze[row][col] is a valid move if self.is_safe(row, col): # Mark the cell as part of the solution path self.path[row][col] = 1 # Move forward in each direction - down, right, up, left if self._solve_maze_util(row + 1, col): return True if self._solve_maze_util(row, col + 1): return True if self._solve_maze_util(row - 1, col): return True if self._solve_maze_util(row, col - 1): return True # If none of the above movements work, unmark the cell (backtrack) self.path[row][col] = 0 return False def _mark_path(self): Marks the path found in the original maze. for row in range(self.n): for col in range(self.n): if self.path[row][col] == 1: self.maze[row][col] = 'P' def print_maze_with_path(self): Prints the maze with the path marked. for row in self.maze: print(' '.join(str(cell) for cell in row))"},{"question":"def normalize_data(data: List[str]) -> List[str]: Normalize the data by replacing missing values with the mean of their respective columns. >>> data = [ ... \\"27.1,2.3,3.8\\", ... \\"23.4,,3.2\\", ... \\"21.9,18.2,\\" ... ] >>> normalize_data(data) ['27.1,2.3,3.8', '23.4,10.25,3.2', '21.9,18.2,3.5'] >>> normalize_data([]) [] >>> data = [ ... \\"27.1,,3.8\\", ... \\"23.4,,3.2\\", ... \\"21.9,,\\" ... ] >>> normalize_data(data) ['27.1,,3.8', '23.4,,3.2', '21.9,,3.5'] >>> data = [ ... \\"27.1,hello,3.8\\", ... \\"23.4,,3.2\\", ... \\"21.9,world,\\" ... ] >>> normalize_data(data) ['27.1,hello,3.8', '23.4,,3.2', '21.9,world,3.5'] >>> data = [ ... \\"1.0\\", ... \\"\\", ... \\"3.0\\" ... ] >>> normalize_data(data) ['1.0', '2.0', '3.0'] >>> data = [\\"1.0,2.0,3.0\\"] >>> normalize_data(data) ['1.0,2.0,3.0'] >>> data = [\\"a,b,c\\", \\"1.0,,2.0\\", \\"3.0,4.0,\\"] >>> normalize_data(data) ['a,b,c', '1.0,4.0,2.0', '3.0,4.0,2.0'] pass","solution":"from typing import List def normalize_data(data: List[str]) -> List[str]: if not data: return [] # Split each row into columns and parse floats; track indices of empty cells columns = [row.split(',') for row in data] num_cols = len(columns[0]) # Initialize sums and counts for calculating column means sums = [0.0] * num_cols counts = [0] * num_cols # Sum up values and count non-missing entries for each column for row in columns: for i in range(num_cols): if row[i] != '': try: value = float(row[i]) sums[i] += value counts[i] += 1 except ValueError: continue # Ignore non-numeric columns # Calculate the mean for each column means = [sums[i] / counts[i] if counts[i] > 0 else None for i in range(num_cols)] # Replace missing values with the computed column mean for row in columns: for i in range(num_cols): if row[i] == '' and means[i] is not None: row[i] = str(means[i]) # Join rows back together and return the normalized data return [','.join(row) for row in columns]"},{"question":"def longest_common_subsequence(seq1: str, seq2: str) -> str: Finds the longest common subsequence between two genome sequences. :param seq1: The first genome sequence as a string. :param seq2: The second genome sequence as a string. :return: The longest common subsequence as a string. >>> longest_common_subsequence(\\"ATCG\\", \\"ATCG\\") == \\"ATCG\\" >>> longest_common_subsequence(\\"ACGT\\", \\"TGCA\\") == \\"A\\" >>> longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") == \\"GTAB\\" >>> longest_common_subsequence(\\"\\", \\"AGGTAB\\") == \\"\\" >>> longest_common_subsequence(\\"AGGTAB\\", \\"\\") == \\"\\" >>> longest_common_subsequence(\\"ACCGGTCGAGTGCGCGGAAGCCGGCCGAA\\", \\"GTCGTTCGGAATGCCGTTGCTCTGTAAA\\") == \\"GTCGTCGGAAGCCGGCCGAA\\" pass","solution":"def longest_common_subsequence(seq1, seq2): m, n = len(seq1), len(seq2) # Create a DP table to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the table in bottom-up manner for i in range(m): for j in range(n): if seq1[i] == seq2[j]: dp[i + 1][j + 1] = dp[i][j] + 1 else: dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]) # LCS length is now dp[m][n], we build the LCS string from here i, j = m, n lcs = [] while i > 0 and j > 0: if dp[i][j] == dp[i - 1][j]: i -= 1 elif dp[i][j] == dp[i][j - 1]: j -= 1 else: lcs.append(seq1[i - 1]) i -= 1 j -= 1 return ''.join(reversed(lcs))"},{"question":"def manipulate_string(input_string: str, drop_vowels: bool, reverse_substrings: bool) -> str: Modifies a given string by removing vowels and reversing the order of characters selectively based on specified criteria. >>> manipulate_string(\\"example\\", drop_vowels=True, reverse_substrings=False) \\"xmpl\\" >>> manipulate_string(\\"example\\", drop_vowels=True, reverse_substrings=True) \\"lpmx\\" >>> manipulate_string(\\"example\\", drop_vowels=False, reverse_substrings=True) \\"elpmaxe\\" >>> manipulate_string(\\"example\\", drop_vowels=False, reverse_substrings=False) \\"example\\" >>> manipulate_string(\\"\\", drop_vowels=True, reverse_substrings=False) \\"\\" >>> manipulate_string(\\"aeiou\\", drop_vowels=True, reverse_substrings=False) \\"\\" >>> manipulate_string(\\"bcdfgh\\", drop_vowels=True, reverse_substrings=True) \\"hgfdcb\\"","solution":"def manipulate_string(input_string: str, drop_vowels: bool, reverse_substrings: bool) -> str: vowels = \\"aeiou\\" if drop_vowels: input_string = ''.join([ch for ch in input_string if ch not in vowels]) if reverse_substrings: return input_string[::-1] return input_string"},{"question":"def extract_errors(log_file_path: str) -> list: Extract and return error messages from a given log file. Args: log_file_path (str): The file path of the log file. Returns: list: A list of error messages. Examples: >>> extract_errors(\\"log_file.txt\\") ['Database connection failed', 'Timeout while processing request']","solution":"def extract_errors(log_file_path: str) -> list: error_messages = [] with open(log_file_path, 'r') as log_file: for line in log_file: if '[ERROR]' in line: # Extract the message part after the third closing bracket ']' error_message = line.split(']', 2)[2].strip() error_messages.append(error_message) return error_messages"},{"question":"import heapq class PriorityQueue: A basic priority queue class. - enqueue(item, priority): Adds an item to the queue with the given priority. - dequeue(): Removes and returns the item with the highest priority (the lowest numerical value of priority), or \`None\` if the queue is empty. Example Usage: >>> pq = PriorityQueue() >>> pq.enqueue('A', 2) >>> pq.enqueue('B', 1) >>> pq.enqueue('C', 3) >>> pq.dequeue() 'B' >>> pq.dequeue() 'A' >>> pq.dequeue() 'C' >>> pq.dequeue() None def __init__(self): self.heap = [] self.counter = 0 def enqueue(self, item: any, priority: int): pass def dequeue(self) -> any: pass def test_enqueue_dequeue_order(): pq = PriorityQueue() pq.enqueue('A', 2) pq.enqueue('B', 1) pq.enqueue('C', 3) assert pq.dequeue() == 'B' assert pq.dequeue() == 'A' assert pq.dequeue() == 'C' assert pq.dequeue() is None def test_dequeue_empty(): pq = PriorityQueue() assert pq.dequeue() is None def test_same_priority_order(): pq = PriorityQueue() pq.enqueue('A', 1) pq.enqueue('B', 1) pq.enqueue('C', 1) assert pq.dequeue() == 'A' assert pq.dequeue() == 'B' assert pq.dequeue() == 'C' def test_combined_priorities(): pq = PriorityQueue() pq.enqueue('A', 2) pq.enqueue('B', 3) pq.enqueue('C', 1) pq.enqueue('D', 2) assert pq.dequeue() == 'C' assert pq.dequeue() == 'A' assert pq.dequeue() == 'D' assert pq.dequeue() == 'B' def test_mixed_operations(): pq = PriorityQueue() pq.enqueue('A', 2) pq.enqueue('B', 3) assert pq.dequeue() == 'A' pq.enqueue('C', 1) assert pq.dequeue() == 'C' assert pq.dequeue() == 'B' assert pq.dequeue() is None","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] self.counter = 0 def enqueue(self, item: any, priority: int): # Increment the counter to maintain FIFO order for same-priority items self.counter += 1 heapq.heappush(self.heap, (priority, self.counter, item)) def dequeue(self) -> any: if not self.heap: return None return heapq.heappop(self.heap)[2]"},{"question":"class FiniteAutomaton: def __init__(self, pattern: str): Initialize the Finite Automaton with a given pattern. >>> fa = FiniteAutomaton(\\"abc\\") pass def build_finite_automaton(self): Build the finite automaton transitions for the input pattern. pass def search(self, text: str) -> list: Search for occurrences of the pattern within the given text using the finite automaton. >>> fa = FiniteAutomaton(\\"abc\\") >>> fa.build_finite_automaton() >>> fa.search(\\"abcabcabc\\") == [0, 3, 6] True >>> fa.search(\\"aabcabc\\") == [1, 4] True >>> fa.search(\\"bacbacabac\\") == [] True >>> fa.search(\\"abc\\") == [0] True >>> fa.search(\\"\\") == [] True >>> fa.search(\\"acbdabcacab\\") == [5] True >>> fa.search(\\"ababcabc\\") == [2, 5] True pass # Unit Tests from solution import FiniteAutomaton def test_search_no_occurrences(): fa = FiniteAutomaton(\\"abc\\") assert fa.search(\\"defghijkl\\") == [] def test_search_single_occurrence(): fa = FiniteAutomaton(\\"abc\\") assert fa.search(\\"defabcghi\\") == [3] def test_search_multiple_occurrences(): fa = FiniteAutomaton(\\"abc\\") assert fa.search(\\"abcabcabc\\") == [0, 3, 6] def test_search_with_overlapping_occurrences(): fa = FiniteAutomaton(\\"aa\\") assert fa.search(\\"aaaa\\") == [0, 1, 2] def test_search_occurrences_at_different_positions(): fa = FiniteAutomaton(\\"abc\\") assert fa.search(\\"aabcabc\\") == [1, 4] def test_search_pattern_at_end(): fa = FiniteAutomaton(\\"abc\\") assert fa.search(\\"xyzabc\\") == [3] def test_search_large_input(): fa = FiniteAutomaton(\\"aaa\\") text = \\"a\\" * 1000000 expected_result = list(range(1000000 - 2)) assert fa.search(text) == expected_result def test_search_boundary_case(): fa = FiniteAutomaton(\\"abc\\") assert fa.search(\\"\\") == [] assert fa.search(\\"abc\\") == [0] assert fa.search(\\"a\\") == [] assert fa.search(\\"ababcababc\\") == [2, 7]","solution":"class FiniteAutomaton: def __init__(self, pattern: str): self.pattern = pattern self.transition_table = [] self.build_finite_automaton() def build_finite_automaton(self): m = len(self.pattern) alphabet = set(self.pattern) self.transition_table = [{} for _ in range(m + 1)] for state in range(m + 1): for char in alphabet: next_state = self._next_state(state, char) self.transition_table[state][char] = next_state def _next_state(self, state, char): if state < len(self.pattern) and char == self.pattern[state]: return state + 1 for ns in range(state, 0, -1): if self.pattern[ns - 1] == char: if self.pattern[:ns - 1] == self.pattern[state - ns + 1:state]: return ns return 0 def search(self, text: str) -> list: n, m = len(text), len(self.pattern) state = 0 occurrences = [] for i in range(n): state = self.transition_table[state].get(text[i], 0) if state == m: occurrences.append(i - m + 1) return occurrences"},{"question":"def sort_students_by_gpa(students: List[Tuple[str, float]]) -> List[Tuple[str, float]]: Sorts a list of students by their GPA in descending order. If two students have the same GPA, they should be sorted by their names in ascending order. :param students: List of tuples, where each tuple contains a student's name (str) and their GPA (float). :return: List of tuples sorted by GPA in descending order. >>> sort_students_by_gpa([ ... (\\"Alice Johnson\\", 3.5), ... (\\"Bob Smith\\", 3.8), ... (\\"Charlie White\\", 3.5), ... (\\"David Brown\\", 3.9) ... ]) [('David Brown', 3.9), ('Bob Smith', 3.8), ('Alice Johnson', 3.5), ('Charlie White', 3.5)] >>> sort_students_by_gpa([]) [] >>> sort_students_by_gpa([(\\"Alice Johnson\\", 3.5)]) [(\\"Alice Johnson\\", 3.5)] from typing import List, Tuple def test_sort_students_by_gpa_empty_list(): assert sort_students_by_gpa([]) == [] def test_sort_students_by_gpa_single_student(): assert sort_students_by_gpa([(\\"Alice Johnson\\", 3.5)]) == [(\\"Alice Johnson\\", 3.5)] def test_sort_students_by_gpa_multiple_students(): students = [ (\\"Alice Johnson\\", 3.5), (\\"Bob Smith\\", 3.8), (\\"Charlie White\\", 3.5), (\\"David Brown\\", 3.9) ] expected = [ (\\"David Brown\\", 3.9), (\\"Bob Smith\\", 3.8), (\\"Alice Johnson\\", 3.5), (\\"Charlie White\\", 3.5) ] assert sort_students_by_gpa(students) == expected def test_sort_students_by_gpa_tie_breaking(): students = [ (\\"Charlie White\\", 3.5), (\\"Alice Johnson\\", 3.5), (\\"David Brown\\", 3.9), (\\"Bob Smith\\", 3.8) ] expected = [ (\\"David Brown\\", 3.9), (\\"Bob Smith\\", 3.8), (\\"Alice Johnson\\", 3.5), (\\"Charlie White\\", 3.5) ] assert sort_students_by_gpa(students) == expected def test_sort_students_by_gpa_all_same_gpa(): students = [ (\\"Alice Johnson\\", 3.5), (\\"Bob Smith\\", 3.5), (\\"Charlie White\\", 3.5), (\\"David Brown\\", 3.5) ] expected = [ (\\"Alice Johnson\\", 3.5), (\\"Bob Smith\\", 3.5), (\\"Charlie White\\", 3.5), (\\"David Brown\\", 3.5) ] assert sort_students_by_gpa(students) == expected def test_sort_students_by_gpa_mixed_cases(): students = [ (\\"alice johnson\\", 3.5), (\\"Bob smith\\", 3.5), (\\"bob Smith\\", 3.5), (\\"Alice Johnson\\", 3.5) ] expected = [ (\\"Alice Johnson\\", 3.5), (\\"Bob smith\\", 3.5), (\\"alice johnson\\", 3.5), (\\"bob Smith\\", 3.5) ] assert sort_students_by_gpa(students) == expected","solution":"def sort_students_by_gpa(students): Sorts a list of students by their GPA in descending order. If two students have the same GPA, they should be sorted by their names in ascending order. :param students: List of tuples, where each tuple contains a student's name (str) and their GPA (float). :return: List of tuples sorted by GPA in descending order. # First, sort by name in ascending order to ensure correct tie-breaking students_sorted = sorted(students, key=lambda student: student[0]) # Then, sort by GPA in descending order students_sorted = sorted(students_sorted, key=lambda student: student[1], reverse=True) return students_sorted"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def find_second_largest(root): Find the second largest element in the Binary Search Tree. Args: root (TreeNode): The root node of the BST. Returns: int or None: The second largest element in the BST, or None if it does not exist. Example: >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(25) >>> find_second_largest(root) 20 pass","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def find_second_largest(root): Find the second largest element in the Binary Search Tree. Args: root (TreeNode): The root node of the BST. Returns: int or None: The second largest element in the BST, or None if it does not exist. if not root or (not root.left and not root.right): return None def find_largest(node): while node.right: node = node.right return node # Start from the root and look for the second largest current = root while current: # Case 1: Current has a right child, and the right child has no children if current.right and not current.right.left and not current.right.right: return current.val # Case 2: Current has no right child, so the largest is in the left subtree if not current.right: return find_largest(current.left).val # Move to the right child current = current.right"},{"question":"class PriorityQueue: A priority queue implemented using a min-heap data structure. Methods: - insert(key: int) -> None: Inserts a new key into the priority queue. - get_min() -> int: Returns the smallest key without removing it. Raises an IndexError if the queue is empty. - extract_min() -> int: Removes and returns the smallest key. Raises an IndexError if the queue is empty. def __init__(self): def insert(self, key: int) -> None: def get_min(self) -> int: def extract_min(self) -> int: def test_priority_queue(): pq = PriorityQueue() # Test inserting and getting the min element pq.insert(10) pq.insert(4) pq.insert(15) pq.insert(20) assert pq.get_min() == 4 # Test extracting the min element assert pq.extract_min() == 4 assert pq.get_min() == 10 # Test inserting a new minimum element pq.insert(2) assert pq.get_min() == 2 assert pq.extract_min() == 2 # Test multiple extractions assert pq.extract_min() == 10 assert pq.extract_min() == 15 assert pq.extract_min() == 20 # Test exception for getting min from an empty queue try: pq.get_min() except IndexError as e: assert str(e) == \\"Priority queue is empty\\" # Test exception for extracting min from an empty queue try: pq.extract_min() except IndexError as e: assert str(e) == \\"Priority queue is empty\\" def test_edge_cases(): pq = PriorityQueue() # Test single insertion and extraction pq.insert(42) assert pq.get_min() == 42 assert pq.extract_min() == 42 # Insert elements in decreasing order pq.insert(5) pq.insert(4) pq.insert(3) pq.insert(2) pq.insert(1) for i in range(1, 6): assert pq.extract_min() == i # Insert elements in increasing order pq.insert(1) pq.insert(2) pq.insert(3) pq.insert(4) pq.insert(5) for i in range(1, 6): assert pq.extract_min() == i # Test mixed positive and negative numbers pq.insert(3) pq.insert(-1) pq.insert(4) pq.insert(-2) pq.insert(0) assert pq.extract_min() == -2 assert pq.extract_min() == -1 assert pq.extract_min() == 0 assert pq.extract_min() == 3 assert pq.extract_min() == 4","solution":"class PriorityQueue: def __init__(self): self.heap = [] def insert(self, key: int) -> None: self.heap.append(key) self._heapify_up(len(self.heap) - 1) def get_min(self) -> int: if not self.heap: raise IndexError(\\"Priority queue is empty\\") return self.heap[0] def extract_min(self) -> int: if not self.heap: raise IndexError(\\"Priority queue is empty\\") if len(self.heap) == 1: return self.heap.pop() min_element = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return min_element def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): smallest = index left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 if left_child_index < len(self.heap) and self.heap[left_child_index] < self.heap[smallest]: smallest = left_child_index if right_child_index < len(self.heap) and self.heap[right_child_index] < self.heap[smallest]: smallest = right_child_index if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest)"},{"question":"from datetime import datetime from typing import List, Tuple def calculate_overdue_books(current_date: datetime, borrowed_books: List[Tuple[str, datetime, datetime]]) -> Tuple[List[str], float]: Calculates the list of overdue books and the total penalty. Args: current_date (datetime): The current date. borrowed_books (List[Tuple[str, datetime, datetime]]): A list of tuples where each tuple contains (book_title, borrow_date, due_date). Returns: Tuple[List[str], float]: A tuple containing a list of overdue book titles and the total penalty for overdue books. Example: >>> from datetime import datetime >>> borrowed_books = [ >>> (\\"The Great Gatsby\\", datetime(2023, 1, 10), datetime(2023, 2, 10)), >>> (\\"1984\\", datetime(2023, 2, 15), datetime(2023, 3, 15)), >>> (\\"To Kill a Mockingbird\\", datetime(2023, 3, 1), datetime(2023, 4, 1)) >>> ] >>> current_date = datetime(2023, 4, 10) >>> overdue_books, total_penalty = calculate_overdue_books(current_date, borrowed_books) >>> print(overdue_books) # Expected: [\\"1984\\", \\"To Kill a Mockingbird\\"] >>> print(total_penalty) # Expected: 36.00","solution":"from datetime import datetime from typing import List, Tuple def calculate_overdue_books(current_date: datetime, borrowed_books: List[Tuple[str, datetime, datetime]]) -> Tuple[List[str], float]: overdue_books = [] total_penalty = 0.0 for book_title, borrow_date, due_date in borrowed_books: overdue_days = (current_date - due_date).days if overdue_days > 0: overdue_books.append(book_title) total_penalty += overdue_days return overdue_books, total_penalty"},{"question":"from typing import List, Tuple def calculate_productive_time(sessions: List[Tuple[int, int]]) -> int: Calculate the total productive time spent coding by each member, without overlapping times being counted multiple times. :param sessions: List of tuples, where each tuple represents a coding session with start and end times. :return: Total productive time spent coding. >>> calculate_productive_time([(1, 5), (3, 7), (9, 12)]) 8 >>> calculate_productive_time([(1, 2), (2, 3), (3, 4)]) 3 pass # Unit Test def test_calculate_productive_time_no_sessions(): assert calculate_productive_time([]) == 0 def test_calculate_productive_time_no_overlap(): assert calculate_productive_time([(1, 5), (6, 10), (11, 15)]) == 12 def test_calculate_productive_time_with_overlap(): assert calculate_productive_time([(1, 3), (2, 6), (4, 8)]) == 7 def test_calculate_productive_time_subset_overlap(): assert calculate_productive_time([(1, 10), (2, 3), (8, 12)]) == 11 def test_calculate_productive_time_consecutive_intervals(): assert calculate_productive_time([(1, 2), (2, 3), (3, 4)]) == 3 def test_calculate_productive_time_mixed(): assert calculate_productive_time([(1, 3), (5, 6), (2, 4), (7, 8)]) == 5 def test_calculate_productive_time_single_interval(): assert calculate_productive_time([(5, 10)]) == 5 # Call pytest main if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"from typing import List, Tuple def calculate_productive_time(sessions: List[Tuple[int, int]]) -> int: if not sessions: return 0 # Sort the sessions by their start time sessions.sort() total_time = 0 current_start, current_end = sessions[0] for start, end in sessions[1:]: if start <= current_end: # Extend the current interval current_end = max(current_end, end) else: # Add the current interval length to total time total_time += current_end - current_start # Move to the next interval current_start, current_end = start, end # Add the last interval length to total time total_time += current_end - current_start return total_time"},{"question":"class MinHeap: A min-heap implementation. Methods: insert(item: int): Adds an item to the heap. remove_min() -> int: Removes and returns the smallest item from the heap. get_min() -> int | None: Returns the smallest item without removing it. >>> heap = MinHeap() >>> heap.insert(10) >>> heap.insert(4) >>> heap.insert(9) >>> heap.insert(1) >>> heap.get_min() 1 >>> heap.remove_min() 1 >>> heap.get_min() 4 >>> heap.insert(2) >>> heap.get_min() 2 >>> heap.remove_min() 2 >>> heap.remove_min() 4 >>> heap.remove_min() 9 >>> heap.get_min() 10 def __init__(self): Initialize the heap with an empty list. self.heap = [] def insert(self, item: int): Adds \`item\` to the heap. pass def remove_min(self) -> int: Removes and returns the smallest item from the heap. Raises: IndexError: If the heap is empty. pass def get_min(self) -> int | None: Returns the smallest item without removing it. If the heap is empty, returns \`None\`. pass # Unit tests def test_insert_and_get_min(): heap = MinHeap() heap.insert(10) heap.insert(4) heap.insert(9) heap.insert(1) assert heap.get_min() == 1 def test_remove_min(): heap = MinHeap() heap.insert(10) heap.insert(4) heap.insert(9) heap.insert(1) assert heap.remove_min() == 1 assert heap.get_min() == 4 def test_get_min_on_empty_heap(): heap = MinHeap() assert heap.get_min() is None def test_remove_min_on_empty_heap(): heap = MinHeap() try: heap.remove_min() assert False, \\"Expected IndexError\\" except IndexError: assert True def test_heap_property_maintained(): heap = MinHeap() elements = [10, 4, 9, 1, 2, 7, 5] for elem in elements: heap.insert(elem) assert heap.remove_min() == 1 assert heap.get_min() == 2 assert heap.remove_min() == 2 assert heap.get_min() == 4 assert heap.remove_min() == 4 assert heap.get_min() == 5 heap.remove_min() heap.remove_min() heap.remove_min() heap.remove_min() assert heap.get_min() is None","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, item: int): self.heap.append(item) self._heapify_up(len(self.heap) - 1) def remove_min(self) -> int: if not self.heap: raise IndexError(\\"remove_min from empty heap\\") if len(self.heap) == 1: return self.heap.pop() min_item = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return min_item def get_min(self) -> int | None: if not self.heap: return None return self.heap[0] def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): smallest = index left_child = 2 * index + 1 right_child = 2 * index + 2 if left_child < len(self.heap) and self.heap[left_child] < self.heap[smallest]: smallest = left_child if right_child < len(self.heap) and self.heap[right_child] < self.heap[smallest]: smallest = right_child if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._heapify_down(smallest)"},{"question":"def max_difference(numbers: list[int]) -> int: Returns the maximum absolute difference between any two elements in the list. >>> max_difference([3, 6, 2, 7, 5]) == 5 >>> max_difference([]) == 0 >>> max_difference([10]) == 0 >>> max_difference([1, 9, 2, 5, 6]) == 8 import pytest def test_max_difference_standard_cases(): assert max_difference([3, 6, 2, 7, 5]) == 5 assert max_difference([1, 9, 2, 5, 6]) == 8 assert max_difference([1, 1, 1, 1, 1]) == 0 def test_max_difference_edge_cases(): assert max_difference([]) == 0 assert max_difference([10]) == 0 assert max_difference([-10, -5, 0, 5, 10]) == 20 assert max_difference([-5, -9, -3, -2, -8]) == 7 def test_max_difference_large_inputs(): large_numbers = [i for i in range(100000)] assert max_difference(large_numbers) == 99999","solution":"def max_difference(numbers: list[int]) -> int: Returns the maximum absolute difference between any two elements in the list. :param numbers: List of integers :return: Maximum absolute difference if len(numbers) < 2: return 0 min_val = float('inf') max_val = float('-inf') for num in numbers: if num < min_val: min_val = num if num > max_val: max_val = num return max_val - min_val"},{"question":"class SeatReservation: Design a seat reservation system for a small venue. >>> reservation_system = SeatReservation(3, 5) >>> reservation_system.check_availability(1, 2) True >>> reservation_system.reserve(1, 2) True >>> reservation_system.check_availability(1, 2) False >>> reservation_system.cancel(1, 2) True >>> reservation_system.check_availability(1, 2) True >>> reservation_system.reserve(1, 5) False def __init__(self, rows: int, seats_per_row: int): pass def reserve(self, row: int, seat: int) -> bool: pass def cancel(self, row: int, seat: int) -> bool: pass def check_availability(self, row: int, seat: int) -> bool: pass","solution":"class SeatReservation: def __init__(self, rows: int, seats_per_row: int): self.rows = rows self.seats_per_row = seats_per_row # Initialize a 2D list to keep track of seat reservations self.seats = [[False for _ in range(seats_per_row)] for _ in range(rows)] def reserve(self, row: int, seat: int) -> bool: if self._is_valid_seat(row, seat): if not self.seats[row][seat]: self.seats[row][seat] = True return True else: return False return False def cancel(self, row: int, seat: int) -> bool: if self._is_valid_seat(row, seat): if self.seats[row][seat]: self.seats[row][seat] = False return True else: return False return False def check_availability(self, row: int, seat: int) -> bool: if self._is_valid_seat(row, seat): return not self.seats[row][seat] return False def _is_valid_seat(self, row: int, seat: int) -> bool: return 0 <= row < self.rows and 0 <= seat < self.seats_per_row"},{"question":"from typing import List def find_missing_numbers(arr: List[int], lower: int, upper: int) -> List[int]: Returns a list of integers in the range [lower, upper] that are not present in arr. >>> find_missing_numbers([1, 3, 5, 7], 1, 10) [2, 4, 6, 8, 9, 10] >>> find_missing_numbers([-3, -2, 1, 4], -3, 5) [-1, 0, 2, 3, 5] >>> find_missing_numbers([2, 3, 4], 1, 4) [1] >>> find_missing_numbers([10, 12, 15], 10, 15) [11, 13, 14] >>> find_missing_numbers([], 2, 3) [2, 3]","solution":"from typing import List def find_missing_numbers(arr: List[int], lower: int, upper: int) -> List[int]: Returns a list of integers in the range [lower, upper] that are not present in arr. num_set = set(arr) return [num for num in range(lower, upper + 1) if num not in num_set]"},{"question":"def find_single_number(nums: list) -> int: Given an array of integers where every element appears twice except for one, this function finds and returns that single one using bitwise XOR operation. >>> find_single_number([4, 1, 2, 1, 2]) 4 >>> find_single_number([2]) 2 >>> find_single_number([3, 3, 7, 9, 9, 5, 5]) 7 >>> find_single_number([0, 0, 1]) 1 # Your implementation here def test_single_element(): assert find_single_number([2]) == 2 def test_all_pairs_except_one(): assert find_single_number([4, 1, 2, 1, 2]) == 4 assert find_single_number([3, 3, 7, 9, 9, 5, 5]) == 7 assert find_single_number([0, 0, 1]) == 1 def test_single_element_at_beginning(): assert find_single_number([5, 2, 2, 3, 3]) == 5 def test_single_element_at_end(): assert find_single_number([2, 4, 4, 2, 3]) == 3 def test_mixed_single_number(): assert find_single_number([10, 4, 1, 2, 1, 2, 4]) == 10 assert find_single_number([10, 4, 10, 4, 7]) == 7","solution":"def find_single_number(nums: list) -> int: Returns the element that appears only once in the list where every element appears twice except for one. single = 0 for num in nums: single ^= num return single"},{"question":"def longest_palindrome_length(s: str) -> int: Determine the length of the longest palindromic substring that can be formed by rearranging the characters of the given string. >>> longest_palindrome_length(\\"aabbcc\\") 6 >>> longest_palindrome_length(\\"abccccdd\\") 7 >>> longest_palindrome_length(\\"AaBb\\") 1","solution":"def longest_palindrome_length(s: str) -> int: from collections import Counter char_count = Counter(s) length = 0 odd_flag = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_flag = True if odd_flag: length += 1 return length"},{"question":"from typing import List, Tuple class SegmentTree: def __init__(self, data: List[int]): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data: List[int]): # Insert leaf nodes in the tree for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def range_sum(self, left: int, right: int) -> int: # Get sum of elements in the range [left, right] left += self.n right += self.n + 1 total = 0 while left < right: if left % 2 == 1: total += self.tree[left] left += 1 if right % 2 == 1: right -= 1 total += self.tree[right] left //= 2 right //= 2 return total def query_range_sum(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Computes the sum of elements within given range (l, r) in the array using Segment Tree. >>> query_range_sum([1, 3, 5, 7, 9, 11], [(1, 3), (0, 5), (2, 4)]) [15, 36, 21] >>> query_range_sum([1, 2, 3, 4, 5], [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]) [1, 2, 3, 4, 5] pass","solution":"from typing import List, Tuple class SegmentTree: def __init__(self, data: List[int]): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data: List[int]): # Insert leaf nodes in the tree for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def range_sum(self, left: int, right: int) -> int: # Get sum of elements in the range [left, right] left += self.n right += self.n + 1 total = 0 while left < right: if left % 2 == 1: total += self.tree[left] left += 1 if right % 2 == 1: right -= 1 total += self.tree[right] left //= 2 right //= 2 return total def query_range_sum(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: segment_tree = SegmentTree(arr) results = [] for l, r in queries: results.append(segment_tree.range_sum(l, r)) return results"},{"question":"def calculate_trapped_water(elevations: list[int]) -> int: Calculate the maximum volume of water that can be trapped between columns after rainfall. Args: - elevations (list[int]): A list of integers representing the elevations of the columns. Returns: - int: The maximum volume of water trapped between the columns. Examples: >>> calculate_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> calculate_trapped_water([0, 1, 2, 3, 4, 5]) 0 >>> calculate_trapped_water([3, 3, 3, 3, 3]) 0 >>> calculate_trapped_water([1, 0, 1]) 1 >>> calculate_trapped_water([4, 2, 0, 3, 2, 5]) 9 >>> calculate_trapped_water([]) 0 >>> calculate_trapped_water([2]) 0 >>> calculate_trapped_water([2, 0]) 0","solution":"def calculate_trapped_water(elevations: list[int]) -> int: Calculate the maximum volume of water that can be trapped. Args: - elevations (list[int]): A list of integers representing the elevations of the columns. Returns: - int: The maximum volume of water trapped between the columns. if not elevations: return 0 n = len(elevations) left_max = [0] * n right_max = [0] * n left_max[0] = elevations[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], elevations[i]) right_max[n - 1] = elevations[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], elevations[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - elevations[i] return trapped_water"},{"question":"def is_valid_float(input_str: str) -> bool: Checks whether the input string is a valid representation of a floating-point number. >>> is_valid_float(\\" 3.14 \\") True >>> is_valid_float(\\"+123.45\\") True >>> is_valid_float(\\" -.4e-2\\") True >>> is_valid_float(\\" \\") False >>> is_valid_float(\\"1,000.55\\") False >>> is_valid_float(\\"3..14\\") False","solution":"def is_valid_float(input_str: str) -> bool: Checks whether the input string is a valid representation of a floating-point number. input_str = input_str.strip() if not input_str: return False try: float(input_str) return True except ValueError: return False"},{"question":"from typing import List, Union def flatten_iterative(nested_list: List[Union[int, List]]) -> List[int]: Flattens a nested list of integers into a single list of integers iteratively. pass def flatten_recursive(nested_list: List[Union[int, List]]) -> List[int]: Flattens a nested list of integers into a single list of integers recursively. pass def test_flatten_simple_list(): nested_list = [1, 2, 3, 4] assert flatten_iterative(nested_list) == [1, 2, 3, 4] assert flatten_recursive(nested_list) == [1, 2, 3, 4] def test_flatten_nested_lists(): nested_list = [1, [2, 3], [4, 5], 6] assert flatten_iterative(nested_list) == [1, 2, 3, 4, 5, 6] assert flatten_recursive(nested_list) == [1, 2, 3, 4, 5, 6] def test_flatten_deeply_nested_lists(): nested_list = [1, [2, [3, 4]], [5, [6, [7]]]] assert flatten_iterative(nested_list) == [1, 2, 3, 4, 5, 6, 7] assert flatten_recursive(nested_list) == [1, 2, 3, 4, 5, 6, 7] def test_flatten_empty_list(): nested_list = [] assert flatten_iterative(nested_list) == [] assert flatten_recursive(nested_list) == [] def test_flatten_single_nested_element(): nested_list = [[[[1]]]] assert flatten_iterative(nested_list) == [1] assert flatten_recursive(nested_list) == [1] def test_flatten_mixed_types(): nested_list = [1, [[2, [3]], 4], 5, [6, [7, 8], 9]] assert flatten_iterative(nested_list) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert flatten_recursive(nested_list) == [1, 2, 3, 4, 5, 6, 7, 8, 9]","solution":"from typing import List, Union def flatten_iterative(nested_list: List[Union[int, List]]) -> List[int]: Flattens a nested list of integers into a single list of integers iteratively. flat_list = [] stack = [nested_list] while stack: current = stack.pop() if isinstance(current, list): stack.extend(reversed(current)) else: flat_list.append(current) return flat_list def flatten_recursive(nested_list: List[Union[int, List]]) -> List[int]: Flattens a nested list of integers into a single list of integers recursively. flat_list = [] for element in nested_list: if isinstance(element, list): flat_list.extend(flatten_recursive(element)) else: flat_list.append(element) return flat_list"},{"question":"class Deque: A double-ended queue (Deque) implementation that allows insertion and deletion of elements from both ends. Methods: __init__(self) Initialize the Deque with an empty list. add_front(self, item: Any) -> None Add an item to the front of the Deque. add_rear(self, item: Any) -> None Add an item to the rear of the Deque. remove_front(self) -> Any Remove and return the front item of the Deque. If the deque is empty, return \`None\`. remove_rear(self) -> Any Remove and return the rear item of the Deque. If the deque is empty, return \`None\`. size(self) -> int Return the number of items in the Deque. is_empty(self) -> bool Return \`True\` if the Deque is empty, otherwise \`False\`. def __init__(self): Initialize the Deque with an empty list. pass def add_front(self, item): Add an item to the front of the Deque. pass def add_rear(self, item): Add an item to the rear of the Deque. pass def remove_front(self): Remove and return the front item of the Deque. If the deque is empty, return \`None\`. pass def remove_rear(self): Remove and return the rear item of the Deque. If the deque is empty, return \`None\`. pass def size(self): Return the number of items in the Deque. pass def is_empty(self): Return True if the Deque is empty, otherwise False. pass","solution":"class Deque: def __init__(self): Initialize the Deque with an empty list. self.items = [] def add_front(self, item): Add an item to the front of the Deque. self.items.insert(0, item) def add_rear(self, item): Add an item to the rear of the Deque. self.items.append(item) def remove_front(self): Remove and return the front item of the Deque. If the deque is empty, return None. if self.items: return self.items.pop(0) else: return None def remove_rear(self): Remove and return the rear item of the Deque. If the deque is empty, return None. if self.items: return self.items.pop() else: return None def size(self): Return the number of items in the Deque. return len(self.items) def is_empty(self): Return True if the Deque is empty, otherwise False. return len(self.items) == 0"},{"question":"class Matrix: def __init__(self, data): Initialize the matrix with a 2D list of numbers. Parameters: data : list of list of numbers A 2D list where each sublist represents a row of the matrix. pass def add(self, other): Add two matrices if they have the same dimensions. Parameters: other : Matrix Another matrix to add to the current matrix. Returns: Matrix : A new matrix with the result of addition. Raises: ValueError : If the dimensions of the matrices do not match. pass def multiply(self, other): Multiply two matrices if the number of columns of the first matrix is equal to the number of rows of the second matrix. Parameters: other : Matrix Another matrix to multiply with the current matrix. Returns: Matrix : A new matrix with the result of multiplication. Raises: ValueError : If the matrices cannot be multiplied due to dimension mismatch. pass def transpose(self): Transpose the current matrix. Returns: Matrix : A new matrix which is the transpose of the current matrix. pass # Example 1: Matrix Addition m1 = Matrix([[1, 2], [3, 4]]) m2 = Matrix([[5, 6], [7, 8]]) result_add = m1.add(m2) assert result_add.data == [[6, 8], [10, 12]] # Example 2: Matrix Multiplication m3 = Matrix([[1, 2, 3], [4, 5, 6]]) m4 = Matrix([[7, 8], [9, 10], [11, 12]]) result_multiply = m3.multiply(m4) assert result_multiply.data == [[58, 64], [139, 154]] # Example 3: Matrix Transposition m5 = Matrix([[1, 2, 3], [4, 5, 6]]) result_transpose = m5.transpose() assert result_transpose.data == [[1, 4], [2, 5], [3, 6]]","solution":"class Matrix: def __init__(self, data): Initialize the matrix with a 2D list of numbers. Parameters: data : list of list of numbers A 2D list where each sublist represents a row of the matrix. self.data = data def add(self, other): Add two matrices if they have the same dimensions. Parameters: other : Matrix Another matrix to add to the current matrix. Returns: Matrix : A new matrix with the result of addition. Raises: ValueError : If the dimensions of the matrices do not match. if not (len(self.data) == len(other.data) and all(len(row) == len(other_row) for row, other_row in zip(self.data, other.data))): raise ValueError(\\"Matrices must have the same dimensions for addition\\") result = [[self.data[i][j] + other.data[i][j] for j in range(len(self.data[i]))] for i in range(len(self.data))] return Matrix(result) def multiply(self, other): Multiply two matrices if the number of columns of the first matrix is equal to the number of rows of the second matrix. Parameters: other : Matrix Another matrix to multiply with the current matrix. Returns: Matrix : A new matrix with the result of multiplication. Raises: ValueError : If the matrices cannot be multiplied due to dimension mismatch. if len(self.data[0]) != len(other.data): raise ValueError(\\"Number of columns in the first matrix must be equal to the number of rows in the second matrix for multiplication\\") result = [[sum(self.data[i][k] * other.data[k][j] for k in range(len(other.data))) for j in range(len(other.data[0]))] for i in range(len(self.data))] return Matrix(result) def transpose(self): Transpose the current matrix. Returns: Matrix : A new matrix which is the transpose of the current matrix. result = [[self.data[j][i] for j in range(len(self.data))] for i in range(len(self.data[0]))] return Matrix(result)"},{"question":"class Song: def __init__(self, id: int, title: str): self.id = id self.title = title class Playlist: def __init__(self): self.songs = [] self.song_map = {} def add_song(self, song: Song) -> None: Adds a new song to the playlist. pass def remove_song(self, song_id: int) -> bool: Removes the song with the given ID from the playlist. Returns \`True\` if the song was successfully removed, \`False\` if the song ID does not exist in the playlist. pass def play_next(self) -> Song: Returns the next song to be played and removes it from the playlist. If the playlist is empty, return \`None\`. pass if __name__ == \\"__main__\\": playlist = Playlist() playlist.add_song(Song(1, \\"Song A\\")) playlist.add_song(Song(2, \\"Song B\\")) print(playlist.play_next().title) # \\"Song A\\" assert playlist.remove_song(3) == False print(playlist.play_next().title) # \\"Song B\\"","solution":"class Song: def __init__(self, id: int, title: str): self.id = id self.title = title class Playlist: def __init__(self): self.songs = [] self.song_map = {} def add_song(self, song: Song) -> None: if song.id not in self.song_map: self.songs.append(song) self.song_map[song.id] = song def remove_song(self, song_id: int) -> bool: if song_id in self.song_map: for i, song in enumerate(self.songs): if song.id == song_id: del self.songs[i] break del self.song_map[song_id] return True return False def play_next(self) -> Song: if self.songs: next_song = self.songs.pop(0) del self.song_map[next_song.id] return next_song return None"},{"question":"def process_list(values: list, reverse: bool = False) -> list: Filters out negative values from the list, sorts the remaining values in ascending order or descending order based on the reverse flag, and returns the processed list. If the input is invalid, return an appropriate error message. >>> process_list([3, -1, 2, 0], False) [0, 2, 3] >>> process_list([3, -1, 2, 0], True) [3, 2, 0] >>> process_list([3, 'a', 2, 0]) 'Invalid input: all elements in the list must be integers' >>> process_list([]) 'Invalid input: the list should not be empty'","solution":"def process_list(values: list, reverse: bool = False) -> list: Filters out negative values from the list, sorts the remaining values in ascending order or descending order based on the reverse flag, and returns the processed list. If the input is invalid, return an appropriate error message. >>> process_list([3, -1, 2, 0], False) [0, 2, 3] >>> process_list([3, -1, 2, 0], True) [3, 2, 0] >>> process_list([3, 'a', 2, 0]) 'Invalid input: all elements in the list must be integers' >>> process_list([]) 'Invalid input: the list should not be empty' if not values: return 'Invalid input: the list should not be empty' if not all(isinstance(x, int) for x in values): return 'Invalid input: all elements in the list must be integers' filtered_values = [x for x in values if x >= 0] return sorted(filtered_values, reverse=reverse)"},{"question":"def second_highest_temp_change(temperatures: list[int]) -> int: Returns the second highest temperature change from the list of temperatures. Parameters: temperatures (list of ints): A list of integers representing daily temperature changes. Returns: int: The second highest temperature change. Raises: ValueError: If the list does not contain at least two unique temperature values. >>> second_highest_temp_change([10, 20, 30, 40, 50]) 40 >>> second_highest_temp_change([15, 15, -10, -20, 0]) 0 >>> second_highest_temp_change([100]) ValueError: List must contain at least two unique temperature changes def test_second_highest_temp_change_normal_case(): assert second_highest_temp_change([10, 20, 30, 40, 50]) == 40 def test_second_highest_temp_change_with_duplicates(): assert second_highest_temp_change([15, 15, -10, -20, 0]) == 0 def test_second_highest_temp_change_with_negatives(): assert second_highest_temp_change([-100, -50, -75, -25]) == -50 def test_second_highest_temp_change_error_case_single_value(): try: second_highest_temp_change([100]) except ValueError as e: assert str(e) == \\"List must contain at least two unique temperature changes\\" def test_second_highest_temp_change_error_case_all_duplicates(): try: second_highest_temp_change([5, 5, 5, 5]) except ValueError as e: assert str(e) == \\"List must contain at least two unique temperature changes\\"","solution":"def second_highest_temp_change(temperatures): Returns the second highest temperature change from the list of temperatures. Parameters: temperatures (list of ints): A list of integers representing daily temperature changes. Returns: int: The second highest temperature change. Raises: ValueError: If the list does not contain at least two unique temperature values. if len(temperatures) < 2: raise ValueError(\\"List must contain at least two unique temperature changes\\") unique_temps = list(set(temperatures)) if len(unique_temps) < 2: raise ValueError(\\"List must contain at least two unique temperature changes\\") unique_temps.sort(reverse=True) return unique_temps[1]"},{"question":"# Coding Assessment Question Context In many software applications, the task of finding the first unique character in a string is common. The challenge is to identify the character that appears only once in the string and has the earliest position. Task Write a Python function that takes a string as input and returns the index of the first non-repeating character. If there is no such character, return -1. Function Signature def first_unique_char(s: str) -> int: Find the index of the first non-repeating character in a string. >>> first_unique_char(\\"leetcode\\") 0 >>> first_unique_char(\\"loveleetcode\\") 2 >>> first_unique_char(\\"aabb\\") -1 pass Input * A string \`s\` of length \`n\` (1 ≤ n ≤ 10^5) consisting of lowercase English letters. Output * An integer representing the index of the first non-repeating character in the string. If no such character exists, return -1. Example print(first_unique_char(\\"leetcode\\")) # Output: 0 print(first_unique_char(\\"loveleetcode\\")) # Output: 2 print(first_unique_char(\\"aabb\\")) # Output: -1 Constraints * The function should be efficient in both time and space. * Assume the string \`s\` only contains lowercase English letters. * Handle edge cases such as strings with all repeating characters, single-character strings, and empty strings. Test Cases def test_first_unique_char_simple_cases(): assert first_unique_char(\\"leetcode\\") == 0 assert first_unique_char(\\"loveleetcode\\") == 2 assert first_unique_char(\\"aabb\\") == -1 def test_first_unique_char_single_char(): assert first_unique_char(\\"a\\") == 0 def test_first_unique_char_all_repeating_chars(): assert first_unique_char(\\"aabbcc\\") == -1 def test_first_unique_char_mixed(): assert first_unique_char(\\"abcabcde\\") == 6 def test_first_unique_char_with_non_repeating_last(): assert first_unique_char(\\"aabcdd\\") == 2 def test_first_unique_char_empty_string(): assert first_unique_char(\\"\\") == -1","solution":"def first_unique_char(s: str) -> int: This function finds the index of the first non-repeating character in a string. If there is no such character, it returns -1. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Find the first character with a frequency of 1 for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"def sort_by_length(words: list) -> list: Sorts the input list of words based on their length. Args: words (list): the list of words to be sorted. Returns: list: a new list with words sorted by length. # Using sorted function with key based on length to ensure stability return sorted(words, key=len) # Examples and Test Cases print(sort_by_length([\\"python\\", \\"is\\", \\"awesome\\", \\"and\\", \\"fun\\"])) # Expected: [\\"is\\", \\"and\\", \\"fun\\", \\"python\\", \\"awesome\\"] print(sort_by_length([\\"quick\\", \\"brown\\", \\"fox\\", \\"jumps\\", \\"over\\", \\"the\\", \\"lazy\\", \\"dog\\"])) # Expected: [\\"fox\\", \\"the\\", \\"dog\\", \\"over\\", \\"lazy\\", \\"quick\\", \\"brown\\", \\"jumps\\"] print(sort_by_length([\\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\"])) # Expected: [\\"one\\", \\"two\\", \\"four\\", \\"five\\", \\"three\\"] print(sort_by_length([\\"a\\", \\"list\\", \\"of\\", \\"varied\\", \\"length\\"])) # Expected: [\\"a\\", \\"of\\", \\"list\\", \\"length\\", \\"varied\\"] print(sort_by_length([])) # Expected: [] print(sort_by_length([\\"word\\"])) # Expected: [\\"word\\"] print(sort_by_length([\\"Apple\\", \\"a\\", \\"apple\\", \\"A\\"])) # Expected: [\\"a\\", \\"A\\", \\"Apple\\", \\"apple\\"] print(sort_by_length([\\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\"])) # Expected: [\\"one\\", \\"two\\", \\"four\\", \\"five\\", \\"three\\"] print(sort_by_length([\\"x\\", \\"xy\\", \\"xyz\\", \\"xyza\\", \\"xyzab\\"])) # Expected: [\\"x\\", \\"xy\\", \\"xyz\\", \\"xyza\\", \\"xyzab\\"]","solution":"def sort_by_length(words): Sorts the input list of words based on their length. Args: words (list): the list of words to be sorted. Returns: list: a new list with words sorted by length. # Using sorted function with key based on length to ensure stability return sorted(words, key=len)"},{"question":"def max_profit(prices: list) -> int: Returns the maximum possible profit from a single buy and sell transaction. Example: >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 def longest_increasing_subsequence(prices: list) -> int: Returns the length of the longest increasing subsequence of stock prices. Example: >>> longest_increasing_subsequence([7, 1, 5, 3, 6, 4]) 3 >>> longest_increasing_subsequence([7, 6, 4, 3, 1]) 1 def moving_average(prices: list, k: int) -> list: Returns the moving averages of the stock prices over a given window size. Example: >>> moving_average([7, 1, 5, 3, 6, 4], 3) [4.33, 3.0, 4.67, 4.33] >>> moving_average([1, 2, 3, 4, 5, 6], 2) [1.5, 2.5, 3.5, 4.5, 5.5]","solution":"def max_profit(prices): This function returns the maximum possible profit from a single buy and sell transaction. if not prices: return 0 min_price = float('inf') max_profit_val = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit_val: max_profit_val = price - min_price return max_profit_val def longest_increasing_subsequence(prices): This function returns the length of the longest increasing subsequence of stock prices. if not prices: return 0 n = len(prices) lis = [1] * n for i in range(1, n): for j in range(0, i): if prices[i] > prices[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis) def moving_average(prices, k): This function returns the moving averages of the stock prices over a given window size. if not prices or k <= 0 or k > len(prices): return [] result = [] window_sum = sum(prices[:k]) result.append(round(window_sum / k, 2)) for i in range(k, len(prices)): window_sum += prices[i] - prices[i - k] result.append(round(window_sum / k, 2)) return result"},{"question":"def reverse_within_bounds(array: list, start: int, end: int) -> list: Reverses elements of the given list 'array' from index 'start' to index 'end' (inclusive). Elements outside the specified bounds should remain unchanged. Examples: >>> reverse_within_bounds([1, 2, 3, 4, 5, 6], 1, 4) [1, 5, 4, 3, 2, 6] >>> reverse_within_bounds(['a', 'b', 'c', 'd', 'e'], 0, 2) ['c', 'b', 'a', 'd', 'e'] >>> reverse_within_bounds([10, 20, 30, 40, 50], 2, 4) [10, 20, 50, 40, 30] >>> reverse_within_bounds([1, 2, 3, 4], 0, 3) [4, 3, 2, 1]","solution":"def reverse_within_bounds(array: list, start: int, end: int) -> list: Reverses elements of the given list 'array' from index 'start' to index 'end' (inclusive). Elements outside the specified bounds should remain unchanged. Examples: >>> reverse_within_bounds([1, 2, 3, 4, 5, 6], 1, 4) [1, 5, 4, 3, 2, 6] >>> reverse_within_bounds(['a', 'b', 'c', 'd', 'e'], 0, 2) ['c', 'b', 'a', 'd', 'e'] >>> reverse_within_bounds([10, 20, 30, 40, 50], 2, 4) [10, 20, 50, 40, 30] >>> reverse_within_bounds([1, 2, 3, 4], 0, 3) [4, 3, 2, 1] # Slice the array for the reversal range reversed_segment = array[start:end+1][::-1] # Combine the segments to form the final array return array[:start] + reversed_segment + array[end+1:]"},{"question":"class ContainerStack: A class to manage a stack of containers with unique container IDs. Methods: - push(container_id: int) -> None: Adds a container with the given container_id to the top. - pop() -> int: Removes and returns the container_id from the top. If the stack is empty, returns -1. - size() -> int: Returns the current number of containers in the stack. Example: >>> stack = ContainerStack() >>> stack.push(1001) >>> stack.push(1002) >>> print(stack.size()) # Output: 2 >>> print(stack.pop()) # Output: 1002 >>> print(stack.size()) # Output: 1 >>> print(stack.pop()) # Output: 1001 >>> print(stack.pop()) # Output: -1 >>> print(stack.size()) # Output: 0 def __init__(self): pass def push(self, container_id: int) -> None: pass def pop(self) -> int: pass def size(self) -> int: pass # Unit Tests import pytest from solution import ContainerStack def test_push_and_size(): stack = ContainerStack() stack.push(1001) stack.push(1002) assert stack.size() == 2 def test_pop(): stack = ContainerStack() stack.push(1001) stack.push(1002) assert stack.pop() == 1002 assert stack.pop() == 1001 assert stack.pop() == -1 def test_size(): stack = ContainerStack() assert stack.size() == 0 stack.push(1001) assert stack.size() == 1 stack.push(1002) assert stack.size() == 2 stack.pop() assert stack.size() == 1 stack.pop() assert stack.size() == 0 @pytest.fixture def populated_stack(): stack = ContainerStack() for i in range(1, 101): # Push 100 containers into the stack stack.push(i) return stack def test_populated_stack_size(populated_stack): assert populated_stack.size() == 100 def test_pop_from_populated_stack(populated_stack): for i in range(100, 0, -1): assert populated_stack.pop() == i assert populated_stack.pop() == -1 if __name__ == \\"__main__\\": pytest.main()","solution":"class ContainerStack: def __init__(self): # Initialize the stack as an empty list self.stack = [] def push(self, container_id: int) -> None: # Append the container_id to the stack self.stack.append(container_id) def pop(self) -> int: # Pop the top container_id if stack is not empty, else return -1 return self.stack.pop() if self.stack else -1 def size(self) -> int: # Return the current size of the stack return len(self.stack)"},{"question":"from typing import List def calculate_mean(data: List[float]) -> float: Calculate the mean of a list of floating point numbers. Args: data (List[float]): A list of real numbers. Returns: float: The mean of the input list of numbers. >>> calculate_mean([1, 2, 3, 4, 5]) 3.0 >>> calculate_mean([7.5, 3.5, 4.0, 6.0]) 5.25 pass def calculate_median(data: List[float]) -> float: Calculate the median of a list of floating point numbers. Args: data (List[float]): A list of real numbers. Returns: float: The median of the input list of numbers. >>> calculate_median([1, 2, 3, 4, 5]) 3.0 >>> calculate_median([3, 1, 4, 2]) 2.5 pass","solution":"from typing import List def calculate_mean(data: List[float]) -> float: Calculate the mean of a list of floating point numbers. if not data: raise ValueError(\\"The input list is empty.\\") return sum(data) / len(data) def calculate_median(data: List[float]) -> float: Calculate the median of a list of floating point numbers. if not data: raise ValueError(\\"The input list is empty.\\") sorted_data = sorted(data) n = len(sorted_data) if n % 2 == 1: return float(sorted_data[n // 2]) else: mid1 = sorted_data[n // 2] mid2 = sorted_data[n // 2 - 1] return (mid1 + mid2) / 2"},{"question":"def find_zero_sum_triplets(arr: List[int]) -> List[List[int]]: Find all unique triplets in the list that sum up to zero. Parameters: arr (List[int]): A list of integers. Returns: List[List[int]]: A list of unique triplets [a, b, c] where a, b, and c are elements from arr, such that a + b + c = 0. Examples: >>> find_zero_sum_triplets([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> find_zero_sum_triplets([0, 0, 0, 0]) [[0, 0, 0]]","solution":"from typing import List def find_zero_sum_triplets(arr: List[int]) -> List[List[int]]: arr.sort() # Sort the array to make sure we can use the two pointer approach triplets = [] length = len(arr) for i in range(length - 2): if i > 0 and arr[i] == arr[i - 1]: continue # Skip duplicate values left, right = i + 1, length - 1 while left < right: total_sum = arr[i] + arr[left] + arr[right] if total_sum == 0: triplets.append([arr[i], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 # Skip duplicate values on the left while left < right and arr[right] == arr[right - 1]: right -= 1 # Skip duplicate values on the right left += 1 right -= 1 elif total_sum < 0: left += 1 # Move the left pointer to the right else: right -= 1 # Move the right pointer to the left return triplets"},{"question":"from typing import List, Union def sum_nested_list(nested_list: List[Union[int, List]]) -> int: Compute the sum of all integers in a nested list. >>> sum_nested_list([1, [2, 3], [4, [5, 6]], 7, [8, [9, 10]]]) 55 >>> sum_nested_list([1, 2, 3, 4]) 10 >>> sum_nested_list([]) 0","solution":"from typing import List, Union def sum_nested_list(nested_list: List[Union[int, List]]) -> int: Returns the sum of all integers in a nested list. total = 0 for element in nested_list: if isinstance(element, list): total += sum_nested_list(element) else: total += element return total"},{"question":"def is_isomorphic(s: str, t: str) -> bool: Checks if two strings are isomorphic. >>> is_isomorphic(\\"egg\\", \\"add\\") True >>> is_isomorphic(\\"foo\\", \\"bar\\") False >>> is_isomorphic(\\"paper\\", \\"title\\") True >>> is_isomorphic(\\"ab\\", \\"aa\\") False","solution":"def is_isomorphic(s: str, t: str) -> bool: Checks if two strings are isomorphic. if len(s) != len(t): return False s_to_t_mapping = {} t_to_s_mapping = {} for char_s, char_t in zip(s, t): if char_s in s_to_t_mapping: if s_to_t_mapping[char_s] != char_t: return False else: s_to_t_mapping[char_s] = char_t if char_t in t_to_s_mapping: if t_to_s_mapping[char_t] != char_s: return False else: t_to_s_mapping[char_t] = char_s return True"},{"question":"def count_rotations(rotated_array: list[int]) -> int: Given a rotated sorted array, return the number of rotations performed on the original sorted array. >>> count_rotations([4, 5, 6, 7, 0, 1, 2]) == 4 >>> count_rotations([7, 9, 11, 12, 15]) == 0 >>> count_rotations([15, 18, 2, 3, 6, 12]) == 2 >>> count_rotations([1, 2, 3, 4]) == 0 >>> count_rotations([2, 3, 4, 1]) == 3 >>> count_rotations([1]) == 0 >>> count_rotations([6, 7, 1, 2, 3, 4, 5]) == 2","solution":"def count_rotations(rotated_array: list[int]) -> int: Given a rotated sorted array, return the number of rotations performed on the original sorted array. low, high = 0, len(rotated_array) - 1 # If array is not rotated at all if rotated_array[low] < rotated_array[high]: return 0 while low <= high: mid = (low + high) // 2 # Check if mid+1 is the minimum element if mid < high and rotated_array[mid] > rotated_array[mid + 1]: return mid + 1 # Check if mid is the minimum element if mid > low and rotated_array[mid] < rotated_array[mid - 1]: return mid # Decide the sub-array to search if rotated_array[mid] >= rotated_array[low]: low = mid + 1 else: high = mid - 1 return 0"},{"question":"def format_number_with_commas(number: int) -> str: Formats the given integer with commas as thousand separators. >>> format_number_with_commas(1234567) '1,234,567' >>> format_number_with_commas(-987654) '-987,654' >>> format_number_with_commas(0) '0' >>> format_number_with_commas(1000) '1,000' >>> format_number_with_commas(-1000000) '-1,000,000' >>> format_number_with_commas(987654321) '987,654,321'","solution":"def format_number_with_commas(number: int) -> str: Formats the given integer with commas as thousand separators. Args: number (int): The integer to format. Returns: str: The formatted string with commas as thousand separators. return f\\"{number:,}\\""},{"question":"def merge_sort(arr: list[int]) -> list[int]: Sorts a list of integers using the Merge Sort algorithm. >>> merge_sort([12, 11, 13, 5, 6, 7]) [5, 6, 7, 11, 12, 13] >>> merge_sort([]) [] >>> merge_sort([1]) [1] >>> merge_sort([3, 2, 1]) [1, 2, 3] >>> merge_sort([10, -1, 2, 5, 0]) [-1, 0, 2, 5, 10]","solution":"def merge_sort(arr: list[int]) -> list[int]: Sorts a list of integers using the Merge Sort algorithm. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: list[int], right: list[int]) -> list[int]: Merges two sorted lists into one sorted list. sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list"},{"question":"def longest_unique_substring(s: str) -> str: Finds the longest substring without repeating characters. >>> longest_unique_substring(\\"abcabcbb\\") 'abc' >>> longest_unique_substring(\\"bbbbb\\") 'b' >>> longest_unique_substring(\\"pwwkew\\") 'wke' >>> longest_unique_substring(\\"abcdef\\") 'abcdef' >>> longest_unique_substring(\\"aab\\") 'ab' >>> longest_unique_substring(\\"dvdf\\") 'vdf' pass def substring_details(substring: str) -> str: Formats the details of the longest unique substring. >>> substring_details(\\"abc\\") 'Longest unique substring length: 3, Substring: \\"abc\\"' >>> substring_details(\\"b\\") 'Longest unique substring length: 1, Substring: \\"b\\"' >>> substring_details(\\"wke\\") 'Longest unique substring length: 3, Substring: \\"wke\\"' pass","solution":"def longest_unique_substring(s: str) -> str: Finds the longest substring without repeating characters. start = 0 max_length = 0 max_substring = '' used_chars = {} for i, char in enumerate(s): if char in used_chars and start <= used_chars[char]: start = used_chars[char] + 1 else: current_length = i - start + 1 if current_length > max_length: max_length = current_length max_substring = s[start:i+1] used_chars[char] = i return max_substring def substring_details(substring: str) -> str: Formats the details of the longest unique substring. return f'Longest unique substring length: {len(substring)}, Substring: \\"{substring}\\"'"},{"question":"from collections import defaultdict, deque from time import time class RateLimitExceededException(Exception): pass event_timestamps = defaultdict(deque) def rate_limiter(event_name: str, limit: int, time_window: float) -> bool: Determines if an event is allowed based on the given rate limit. :param event_name: The name of the event to be tracked. :param limit: The maximum number of times the event is allowed to occur within the time_window. :param time_window: The time window in seconds during which the limit applies. :return: Returns True if the event is allowed (i.e., it hasn't exceeded the limit in the given time window). :raises RateLimitExceededException: if the event has already occurred limit times within the time_window. :raises ValueError: if inputs are invalid. pass # Unit tests import pytest from time import sleep def test_rate_limiter_within_limit(): assert rate_limiter(\\"login_attempt\\", 5, 60) == True def test_rate_limiter_exact_limit(): event_name = \\"login_exact\\" for _ in range(5): assert rate_limiter(event_name, 5, 60) == True def test_rate_limiter_exceeds_limit(): event_name = \\"login_exceed\\" for _ in range(5): assert rate_limiter(event_name, 5, 60) == True with pytest.raises(RateLimitExceededException): rate_limiter(event_name, 5, 60) def test_rate_limiter_reset_after_time_window(): event_name = \\"login_reset\\" for _ in range(5): assert rate_limiter(event_name, 5, 1) == True sleep(1.1) # Wait for more than the time window assert rate_limiter(event_name, 5, 1) == True def test_rate_limiter_invalid_event_name(): with pytest.raises(ValueError): rate_limiter(\\"\\", 5, 60) def test_rate_limiter_invalid_limit(): with pytest.raises(ValueError): rate_limiter(\\"login_attempt\\", -1, 60) def test_rate_limiter_invalid_time_window(): with pytest.raises(ValueError): rate_limiter(\\"login_attempt\\", 5, -10) def test_rate_limiter_within_subsequent_calls(): event_name = \\"login_small_window\\" time_window = 0.5 # 500 ms limit = 2 assert rate_limiter(event_name, limit, time_window) == True assert rate_limiter(event_name, limit, time_window) == True with pytest.raises(RateLimitExceededException): rate_limiter(event_name, limit, time_window) sleep(time_window + 0.1) # Allow time window to reset assert rate_limiter(event_name, limit, time_window) == True","solution":"from collections import defaultdict, deque from time import time class RateLimitExceededException(Exception): pass event_timestamps = defaultdict(deque) def rate_limiter(event_name: str, limit: int, time_window: float) -> bool: Determines if an event is allowed based on the given rate limit. if not isinstance(event_name, str) or not event_name: raise ValueError(\\"Event name must be a non-empty string.\\") if not isinstance(limit, int) or limit <= 0: raise ValueError(\\"Limit must be a positive integer.\\") if not isinstance(time_window, (int, float)) or time_window <= 0: raise ValueError(\\"Time window must be a positive float.\\") current_time = time() timestamps = event_timestamps[event_name] # Remove timestamps that are outside the current time window while timestamps and timestamps[0] < current_time - time_window: timestamps.popleft() if len(timestamps) < limit: timestamps.append(current_time) return True else: raise RateLimitExceededException(f\\"The rate limit for event {event_name} has been exceeded.\\")"},{"question":"def min_valid_partition(s: str, valid_substrings: set) -> int: Given a string s and a set of valid substrings, find the minimum number of segments needed to partition the string such that every segment is a valid substring. If the partition is not possible, return -1. >>> min_valid_partition(\\"applepenapple\\", {\\"apple\\", \\"pen\\"}) 3 >>> min_valid_partition(\\"catsandog\\", {\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"}) -1 >>> min_valid_partition(\\"leetcode\\", {\\"leet\\", \\"code\\"}) 2 def test_min_valid_partition_single_letter(): assert min_valid_partition(\\"a\\", {\\"a\\"}) == 1 assert min_valid_partition(\\"b\\", {\\"a\\"}) == -1 def test_min_valid_partition_no_partition(): assert min_valid_partition(\\"abc\\", {\\"abc\\"}) == 1 assert min_valid_partition(\\"abc\\", {\\"a\\", \\"ab\\"}) == -1 def test_min_valid_partition_multiple_separators(): assert min_valid_partition(\\"applepenapple\\", {\\"apple\\", \\"pen\\"}) == 3 assert min_valid_partition(\\"catsandog\\", {\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"}) == -1 assert min_valid_partition(\\"leetcode\\", {\\"leet\\", \\"code\\"}) == 2 def test_min_valid_partition_complete_overlap(): assert min_valid_partition(\\"aaa\\", {\\"a\\", \\"aa\\"}) == 2 assert min_valid_partition(\\"aaa\\", {\\"aa\\", \\"a\\"}) == 2 def test_min_valid_partition_long_string(): assert min_valid_partition(\\"a\\" * 100, {\\"a\\" * i for i in range(1, 101)}) == 1 assert min_valid_partition(\\"a\\" * 1000, {\\"a\\"}) == 1000 def test_min_valid_partition_edge_cases(): assert min_valid_partition(\\"\\", {\\"a\\", \\"b\\"}) == 0 assert min_valid_partition(\\"x\\", {\\"a\\"}) == -1 assert min_valid_partition(\\"a\\" * 1000, set()) == -1 assert min_valid_partition(\\"abcde\\" * 200, {\\"abcde\\", \\"de\\", \\"bcd\\"}) == 200","solution":"def min_valid_partition(s: str, valid_substrings: set) -> int: n = len(s) dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, n + 1): for j in range(i): if s[j:i] in valid_substrings: dp[i] = min(dp[i], dp[j] + 1) return dp[n] if dp[n] != float('inf') else -1"},{"question":"def find_min_rotated(arr: list[int]) -> int: Finds the minimum value in a rotated sorted array. :param arr: List of integers that is non-empty and has been rotated. :return: The minimum value in the array. >>> find_min_rotated([4, 5, 6, 7, 0, 1, 2]) 0 >>> find_min_rotated([7, 8, 1, 2, 3, 4, 5, 6]) 1 >>> find_min_rotated([11, 13, 15, 17]) 11 pass def test_find_min_rotated(): assert find_min_rotated([4, 5, 6, 7, 0, 1, 2]) == 0 assert find_min_rotated([7, 8, 1, 2, 3, 4, 5, 6]) == 1 assert find_min_rotated([11, 13, 15, 17]) == 11 assert find_min_rotated([2, 3, 4, 5, 6, 7, 8, 1]) == 1 assert find_min_rotated([3, 4, 5, 1, 2]) == 1 assert find_min_rotated([2]) == 2 assert find_min_rotated([4, 5, 6, 1, 2, 3]) == 1 def test_large_array(): assert find_min_rotated(list(range(100000))[-1:] + list(range(100000))[:-1]) == 0 assert find_min_rotated(list(range(100000//2, 100000)) + list(range(100000//2))) == 0 def test_with_negative_numbers(): assert find_min_rotated([-4, -3, -2, -1, -10, -8, -7]) == -10 assert find_min_rotated([-13, -12, -11, -15, -14]) == -15 def test_with_mixed_numbers(): assert find_min_rotated([3, 4, 5, -1, 1, 2]) == -1 assert find_min_rotated([1, 2, 3, -4, -3, -2, -1, 0]) == -4","solution":"def find_min_rotated(arr: list[int]) -> int: Finds the minimum value in a rotated sorted array. :param arr: List of integers that is non-empty and has been rotated. :return: The minimum value in the array. left, right = 0, len(arr) - 1 if arr[left] < arr[right]: return arr[left] while left < right: mid = (left + right) // 2 if arr[mid] > arr[right]: left = mid + 1 else: right = mid return arr[left]"},{"question":"def check_permutation_in_string(pattern: str, text: str) -> bool: Verify whether any permutation of the pattern can be found in the text. Args: pattern (str): The pattern string to check for permutations. text (str): The text string to search within. Returns: bool: True if any permutation of the pattern is a substring in the text, False otherwise. >>> check_permutation_in_string(\\"ab\\", \\"eidbaooo\\") True >>> check_permutation_in_string(\\"ab\\", \\"eidboaoo\\") False","solution":"def check_permutation_in_string(pattern: str, text: str) -> bool: from collections import Counter len_pattern = len(pattern) len_text = len(text) if len_pattern > len_text: return False pattern_counter = Counter(pattern) window_counter = Counter(text[:len_pattern]) if pattern_counter == window_counter: return True for i in range(len_pattern, len_text): window_counter[text[i]] += 1 window_counter[text[i - len_pattern]] -= 1 if window_counter[text[i - len_pattern]] == 0: del window_counter[text[i - len_pattern]] if pattern_counter == window_counter: return True return False"},{"question":"from typing import List, Tuple def adjust_salaries(employees: List[Tuple[float, str]]) -> List[float]: Adjusts salaries based on performance ratings. Args: employees (List[Tuple[float, str]]): A list of tuples where each tuple contains a float (salary) and a string (performance rating). Returns: List[float]: A list of adjusted salaries. Raises: ValueError: If any performance rating is not 'A', 'B', 'C', or 'D'. >>> adjust_salaries([(50000, 'A'), (60000, 'C'), (70000, 'B'), (80000, 'D')]) [55000.0, 60000.0, 73500.0, 76000.0] >>> adjust_salaries([(100, 'E')]) Traceback (most recent call last): ... ValueError: Invalid performance rating: E","solution":"from typing import List, Tuple def adjust_salaries(employees: List[Tuple[float, str]]) -> List[float]: Adjusts salaries based on performance ratings. Args: employees (List[Tuple[float, str]]): A list of tuples where each tuple contains a float (salary) and a string (performance rating). Returns: List[float]: A list of adjusted salaries. Raises: ValueError: If any performance rating is not 'A', 'B', 'C', or 'D'. adjusted_salaries = [] for salary, rating in employees: if rating == 'A': adjusted_salary = salary * 1.10 elif rating == 'B': adjusted_salary = salary * 1.05 elif rating == 'C': adjusted_salary = salary elif rating == 'D': adjusted_salary = salary * 0.95 else: raise ValueError(f\\"Invalid performance rating: {rating}\\") adjusted_salaries.append(round(adjusted_salary, 2)) return adjusted_salaries"},{"question":"def longest_uniform_subarray(arr: list) -> int: Returns the length of the longest contiguous subarray where all of its elements have the same value. >>> longest_uniform_subarray([1, 1, 2, 2, 2, 3, 3, 3, 3]) 4 >>> longest_uniform_subarray([5, 5, 5, 5, 5]) 5 >>> longest_uniform_subarray([10, 9, 8, 7]) 1 >>> longest_uniform_subarray([]) 0 >>> longest_uniform_subarray([7]) 1","solution":"def longest_uniform_subarray(arr): Returns the length of the longest contiguous subarray where all of its elements have the same value. if not arr: return 0 max_len = 1 current_len = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1]: current_len += 1 else: if current_len > max_len: max_len = current_len current_len = 1 return max(current_len, max_len)"},{"question":"def final_position(commands: List[str]) -> Tuple[int, int]: Calculates the final position of the robot after executing a series of movement commands. Parameters: commands (list of str): A list of movement commands ('UP', 'DOWN', 'LEFT', 'RIGHT'). Returns: tuple: Final coordinates (x, y) on the 2D plane. Example Usage: >>> final_position([\\"UP\\", \\"UP\\", \\"LEFT\\"]) (-1, 2) >>> final_position([\\"DOWN\\", \\"DOWN\\", \\"RIGHT\\", \\"RIGHT\\", \\"UP\\"]) (1, -1) >>> final_position([]) (0, 0)","solution":"from typing import List, Tuple def final_position(commands: List[str]) -> Tuple[int, int]: Calculates the final position of the robot after executing a series of movement commands. Parameters: commands (list of str): A list of movement commands ('UP', 'DOWN', 'LEFT', 'RIGHT'). Returns: tuple: Final coordinates (x, y) on the 2D plane. x, y = 0, 0 # initial position # process each command for command in commands: if command == \\"UP\\": y += 1 elif command == \\"DOWN\\": y -= 1 elif command == \\"LEFT\\": x -= 1 elif command == \\"RIGHT\\": x += 1 return (x, y)"},{"question":"class Matrix: def __init__(self, data): self.data = data def transpose(self): Computes the transpose of the matrix. Returns: Matrix: A new Matrix instance that is the transpose of the original matrix. # Implement the function here # Example 1 matrix1 = Matrix([ [1, 2, 3], [4, 5, 6] ]) transposed_matrix1 = matrix1.transpose() print(transposed_matrix1.data) # Expected output: [[1, 4], [2, 5], [3, 6]] # Example 2 matrix2 = Matrix([ [1, 2], [3, 4], [5, 6] ]) transposed_matrix2 = matrix2.transpose() print(transposed_matrix2.data) # Expected output: [[1, 3, 5], [2, 4, 6]] # Example 3 matrix3 = Matrix([ [7] ]) transposed_matrix3 = matrix3.transpose() print(transposed_matrix3.data) # Expected output: [[7]]","solution":"class Matrix: def __init__(self, data): self.data = data def transpose(self): Computes the transpose of the matrix. Returns: Matrix: A new Matrix instance that is the transpose of the original matrix. transposed_data = [list(row) for row in zip(*self.data)] return Matrix(transposed_data)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head: ListNode) -> ListNode: Remove all duplicate elements from an unsorted singly linked list, retaining only the first occurrence of each element. >>> list_to_array(remove_duplicates(array_to_list([1, 3, 2, 3, 4, 4, 2]))) [1, 3, 2, 4] >>> list_to_array(remove_duplicates(array_to_list([5, 5, 5, 5]))) [5] >>> list_to_array(remove_duplicates(array_to_list([0, -1, -1, 2, 3]))) [0, -1, 2, 3] >>> list_to_array(remove_duplicates(array_to_list([]))) [] >>> list_to_array(remove_duplicates(array_to_list([1, 2, 3, 4]))) [1, 2, 3, 4] >>> list_to_array(remove_duplicates(array_to_list([2, 2, 2, 2]))) [2] pass def list_to_array(head): array = [] current = head while current is not None: array.append(current.val) current = current.next return array def array_to_list(array): if not array: return None head = ListNode(array[0]) current = head for value in array[1:]: new_node = ListNode(value) current.next = new_node current = new_node return head","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head: ListNode) -> ListNode: if not head: return head seen = set() current = head seen.add(current.val) while current and current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head"},{"question":"from typing import Sequence def censor_message(message: str, profane_words: Sequence[str]) -> str: Replaces each character of the profane words in the message with asterisks '*'. >>> censor_message(\\"This is a badword and another badword.\\", [\\"badword\\"]) 'This is a ******* and another *******.' >>> censor_message(\\"Beware of the ugly parts of the city.\\", [\\"ugly\\", \\"parts\\"]) 'Beware of the **** ***** of the city.' >>> censor_message(\\"Clean words only here!\\", [\\"dirty\\"]) 'Clean words only here!' >>> censor_message(\\"BadWord must be censored.\\", [\\"badword\\"]) '******* must be censored.' >>> censor_message(\\"\\", [\\"badword\\"]) '' >>> censor_message(\\"Avoid playgrounds with badwordss and badwords.\\", [\\"badword\\"]) 'Avoid playgrounds with badwordss and badwords.'","solution":"import re from typing import Sequence def censor_message(message: str, profane_words: Sequence[str]) -> str: Replaces each character of the profane words in the message with asterisks '*' def censor_word(match): return '*' * len(match.group()) # Create regex pattern for all profane words (case insensitive) pattern = re.compile(r'b(' + '|'.join(re.escape(word) for word in profane_words) + r')b', re.IGNORECASE) # Replace each match with asterisks censored_message = pattern.sub(censor_word, message) return censored_message"},{"question":"def evaluate_math_expression(expression: str) -> float: Evaluates a basic mathematical expression and returns the result as a float. Args: expression (str): The mathematical expression as a string. Returns: float: The evaluated result of the expression. Raises: ZeroDivisionError: If a division by zero occurs. Examples: >>> evaluate_math_expression(' 3 + 5 ') 8.0 >>> evaluate_math_expression('10 / 2') 5.0 >>> evaluate_math_expression('10 + 2 * 3') 16.0 >>> evaluate_math_expression('100 / 0') Traceback (most recent call last): ... ZeroDivisionError: Division by zero encountered in the expression >>> evaluate_math_expression('- 10 - 5 + 3') -12.0","solution":"def evaluate_math_expression(expression: str) -> float: Evaluates a basic mathematical expression and returns the result as a float. Args: expression (str): The mathematical expression as a string. Returns: float: The evaluated result of the expression. Raises: ZeroDivisionError: If a division by zero occurs. try: # Removing white spaces expression = expression.replace(\\" \\", \\"\\") # Evaluating the expression result = eval(expression) return float(result) except ZeroDivisionError: raise ZeroDivisionError('Division by zero encountered in the expression')"},{"question":"from typing import List def first_missing_positive(nums: List[int]) -> int: Find the smallest positive integer missing from an unsorted array. This function should return the smallest positive integer that does not appear in the input list. Args: nums (List[int]): A list of integers which can contain both positive and negative numbers, as well as zero. Returns: int: The smallest missing positive integer from the array. Raises: TypeError: If the input is not a list or contains non-integer elements. Example: >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 >>> first_missing_positive([]) 1 >>> first_missing_positive('123') Traceback (most recent call last): ... TypeError: first_missing_positive() only accepts a list of integers >>> first_missing_positive([1.2, 2, 3]) Traceback (most recent call last): ... TypeError: first_missing_positive() only accepts a list of integers","solution":"from typing import List def first_missing_positive(nums: List[int]) -> int: if not isinstance(nums, list) or any(not isinstance(x, int) for x in nums): raise TypeError(\\"first_missing_positive() only accepts a list of integers\\") n = len(nums) # Place each number in its right place (i.e., nums[i] should be i+1) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Now, the first place where its number is not right, return the place + 1 for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"class Event: def __init__(self, name: str, capacity: int): self.name = name self.capacity = capacity self.participants = [] class EventManager: def __init__(self): self.events = {} def create_event(self, event_name: str, capacity: int) -> None: Create a new event with the given name and capacity. If the event already exists, raise a ValueError. >>> em = EventManager() >>> em.create_event(\\"Concert A\\", 100) pass def assign_participant(self, event_name: str, participant_name: str) -> str: Assign a participant to the specified event if there is available capacity. If the event does not exist, raise a ValueError. If the event is full, raise a ValueError. >>> em = EventManager() >>> em.create_event(\\"Concert A\\", 2) >>> em.assign_participant(\\"Concert A\\", \\"Alice\\") 'Alice has been assigned to Concert A' >>> em.assign_participant(\\"Concert A\\", \\"Bob\\") 'Bob has been assigned to Concert A' >>> em.assign_participant(\\"Concert A\\", \\"Charlie\\") Traceback (most recent call last): ... ValueError: Event Concert A is full. >>> em.assign_participant(\\"Nonexistent Event\\", \\"David\\") Traceback (most recent call last): ... ValueError: Event Nonexistent Event does not exist. pass if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"class Event: def __init__(self, name: str, capacity: int): self.name = name self.capacity = capacity self.participants = [] class EventManager: def __init__(self): self.events = {} def create_event(self, event_name: str, capacity: int) -> None: if event_name in self.events: raise ValueError(f\\"Event {event_name} already exists.\\") self.events[event_name] = Event(event_name, capacity) def assign_participant(self, event_name: str, participant_name: str) -> str: if event_name not in self.events: raise ValueError(f\\"Event {event_name} does not exist.\\") event = self.events[event_name] if len(event.participants) >= event.capacity: raise ValueError(f\\"Event {event_name} is full.\\") event.participants.append(participant_name) return f\\"{participant_name} has been assigned to {event_name}\\""},{"question":"from typing import List def frequency_sort(arr: List[int]) -> List[int]: Sorts the array according to the frequency of elements in descending order. If two elements have the same frequency, the smaller element should precede the larger one. Parameters: arr (List[int]): A list of integers Returns: List[int]: A list of integers sorted by frequency and value >>> frequency_sort([4, 6, 2, 2, 6, 4, 4, 4]) == [4, 4, 4, 4, 2, 2, 6, 6] >>> frequency_sort([]) == [] >>> frequency_sort([1]) == [1] >>> frequency_sort([5, 3, 8, 9]) == [3, 5, 8, 9] >>> frequency_sort([4, 4, 5, 5, 2, 2]) == [2, 2, 4, 4, 5, 5] >>> frequency_sort([4, 4, 6, 6, 6, 3]) == [6, 6, 6, 4, 4, 3] >>> frequency_sort([-1, -2, -1, -2, -1, -3]) == [-1, -1, -1, -2, -2, -3]","solution":"from typing import List from collections import Counter def frequency_sort(arr: List[int]) -> List[int]: Sorts the array according to the frequency of elements in descending order. If two elements have the same frequency, the smaller element should precede the larger one. # Count the frequency of each number in the array freq = Counter(arr) # Sort the array based on frequency. In case of a tie, sort by the number itself. sorted_arr = sorted(arr, key=lambda x: (-freq[x], x)) return sorted_arr"},{"question":"import re from collections import defaultdict from typing import List, Dict def generate_word_cloud(text: str, stopwords: List[str]) -> Dict[str, int]: Generates a word cloud from the input text, ignoring specified stopwords. Parameters: text (str): The input text to process. stopwords (List[str]): A list of common English stopwords to be ignored. Returns: Dict[str, int]: A dictionary representing the word cloud, where keys are words and values are their corresponding frequencies. >>> text = \\"Python is great and python programming is fun. Learning python is essential in the current tech world.\\" >>> stopwords = [\\"is\\", \\"and\\", \\"the\\", \\"in\\"] >>> generate_word_cloud(text, stopwords) {'python': 3, 'great': 1, 'programming': 1, 'fun': 1, 'learning': 1, 'essential': 1, 'current': 1, 'tech': 1, 'world': 1} >>> text = \\"Python PYTHON python\\" >>> stopwords = [\\"is\\"] >>> generate_word_cloud(text, stopwords) {'python': 3} >>> text = \\"Hello, world! Hello, universe!\\" >>> stopwords = [\\"hello\\"] >>> generate_word_cloud(text, stopwords) {'world': 1, 'universe': 1} >>> text = \\"is the quick brown fox jumps over the lazy dog\\" >>> stopwords = [\\"is\\", \\"the\\", \\"over\\"] >>> generate_word_cloud(text, stopwords) {'quick': 1, 'brown': 1, 'fox': 1, 'jumps': 1, 'lazy': 1, 'dog': 1} >>> text = \\"\\" >>> stopwords = [\\"is\\", \\"the\\"] >>> generate_word_cloud(text, stopwords) {} >>> text = \\"This is a test. This test is only a test.\\" >>> stopwords = [] >>> generate_word_cloud(text, stopwords) {'this': 2, 'is': 2, 'a': 2, 'test': 3, 'only': 1}","solution":"import re from collections import defaultdict from typing import List, Dict def generate_word_cloud(text: str, stopwords: List[str]) -> Dict[str, int]: # Normalize to lowercase text = text.lower() # Remove punctuation text = re.sub(r'[^ws]', '', text) # Split the text into words words = text.split() # Use a set for fast lookup of stopwords stopwords_set = set(stopwords) # Calculate the frequency of each word, ignoring stopwords word_frequency = defaultdict(int) for word in words: if word not in stopwords_set: word_frequency[word] += 1 return dict(word_frequency)"},{"question":"from typing import List def closest_triplet_sum(arr: List[int], target: int) -> int: Returns the sum of the triplet in the given array which is closest to the given target. >>> closest_triplet_sum([-1, 2, 1, -4], 1) 2 >>> closest_triplet_sum([1, 1, -1, -1, 3], 3) 3 >>> closest_triplet_sum([4, -1, 2, 1], 0) 2","solution":"from typing import List def closest_triplet_sum(arr: List[int], target: int) -> int: arr.sort() # First, sort the array closest_sum = float('inf') # Initialize the closest sum with infinity for i in range(len(arr) - 2): # Iterate through the array left, right = i + 1, len(arr) - 1 while left < right: curr_sum = arr[i] + arr[left] + arr[right] if abs(target - curr_sum) < abs(target - closest_sum): closest_sum = curr_sum if curr_sum < target: left += 1 elif curr_sum > target: right -= 1 else: # when curr_sum == target return curr_sum return closest_sum"},{"question":"from typing import List def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. pass def sort_primes(arr: List[int]) -> List[int]: Sorts the prime numbers in an array in ascending order while keeping the non-prime numbers in their original positions. Parameters: arr (List[int]): The list of integers to be processed. Returns: List[int]: The list with primes sorted in ascending order and non-prime numbers in their original positions. >>> sort_primes([29, 15, -3, 4, 17, 5, 2]) [2, 15, -3, 4, 5, 17, 29] >>> sort_primes([7, 10, 23, 12, 19]) [7, 10, 19, 12, 23] >>> sort_primes([0, -1, -4, 2, 3, 5]) [0, -1, -4, 2, 3, 5] pass","solution":"from typing import List def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False max_divisor = int(n ** 0.5) + 1 for i in range(3, max_divisor, 2): if n % i == 0: return False return True def sort_primes(arr: List[int]) -> List[int]: Sorts the prime numbers in an array in ascending order while keeping the non-prime numbers in their original positions. # Extract primes and their indices primes = [num for num in arr if is_prime(num)] primes.sort() result = [] prime_index = 0 for num in arr: if is_prime(num): result.append(primes[prime_index]) prime_index += 1 else: result.append(num) return result"},{"question":"def calculate_sma(prices: List[float], window_size: int = 5) -> List[float]: Calculates the Simple Moving Average (SMA) for a given list of stock prices. Args: prices (List[float]): A list of historical stock prices. window_size (int): The period over which to compute the SMA. Returns: List[float]: A list of SMA values. For the initial window_size - 1 entries, return None. >>> prices = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0] >>> window_size = 3 >>> calculate_sma(prices, window_size) [None, None, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0] >>> prices = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0] >>> calculate_sma(prices) [None, None, None, None, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0] >>> prices = [100.0] >>> window_size = 1 >>> calculate_sma(prices, window_size) [100.0] >>> prices = [1.0, 2.0, 3.0, 4.0, 5.0] >>> window_size = 5 >>> calculate_sma(prices, window_size) [None, None, None, None, 3.0] # Your implementation goes here","solution":"def calculate_sma(prices, window_size=5): Calculates the Simple Moving Average (SMA) for a given list of stock prices. Args: prices (List[float]): A list of historical stock prices. window_size (int): The period over which to compute the SMA. Returns: List[float]: A list of SMA values. For the initial window_size - 1 entries, return None. if window_size <= 0 or window_size > len(prices): raise ValueError(\\"window_size must be a positive integer less than or equal to the length of prices\\") sma = [None] * (window_size - 1) for i in range(window_size - 1, len(prices)): window = prices[i - window_size + 1:i + 1] sma.append(sum(window) / window_size) return sma"},{"question":"def has_path(grid): Determines if there is a valid path from the top-left corner to the bottom-right corner of the grid using breadth-first search (BFS). Args: grid (list[list[int]]): 2D matrix representing the grid where 0 is an open cell and 1 is blocked. Returns: bool: True if there is a path from the top-left corner to the bottom-right corner, False otherwise. if not grid or not grid[0]: return False rows, cols = len(grid), len(grid[0]) # Early exit if the start or end points are blocked if grid[0][0] == 1 or grid[rows-1][cols-1] == 1: return False directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set() visited.add((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (rows-1, cols-1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny)) visited.add((nx, ny)) return False","solution":"from collections import deque def has_path(grid): Determines if there is a valid path from the top-left corner to the bottom-right corner of the grid using breadth-first search (BFS). Args: grid (list[list[int]]): 2D matrix representing the grid where 0 is an open cell and 1 is blocked. Returns: bool: True if there is a path from the top-left corner to the bottom-right corner, False otherwise. if not grid or not grid[0]: return False rows, cols = len(grid), len(grid[0]) # Early exit if the start or end points are blocked if grid[0][0] == 1 or grid[rows-1][cols-1] == 1: return False directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set() visited.add((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (rows-1, cols-1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"from typing import List, Tuple, Dict def build_graph(edges: List[Tuple[int, int, int]]) -> Dict[int, List[Tuple[int, int]]]: Builds the graph from a list of edges. Args: edges (List[Tuple[int, int, int]]): A list of tuples representing the edges in the graph. Returns: Dict[int, List[Tuple[int, int]]]: The adjacency list representation of the graph. pass def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]: Computes the shortest path from the start node to all other nodes using Dijkstra's algorithm. Args: graph (Dict[int, List[Tuple[int, int]]]): The adjacency list representation of the graph. start (int): The starting node. Returns: Dict[int, int]: A dictionary with the shortest distance to each node from the start node. pass # Example usage edges = [ (1, 2, 4), (1, 3, 2), (2, 3, 5), (3, 4, 1), (4, 5, 6) ] graph = build_graph(edges) start_node = 1 shortest_paths = dijkstra(graph, start_node) print(f\\"Shortest paths from node {start_node}: {shortest_paths}\\")","solution":"import heapq from typing import List, Tuple, Dict def build_graph(edges: List[Tuple[int, int, int]]) -> Dict[int, List[Tuple[int, int]]]: Builds the graph from a list of edges. Args: edges (List[Tuple[int, int, int]]): A list of tuples representing the edges in the graph. Returns: Dict[int, List[Tuple[int, int]]]: The adjacency list representation of the graph. graph = {} for u, v, w in edges: if u not in graph: graph[u] = [] graph[u].append((v, w)) # Assuming it's a directed graph; otherwise, uncomment the lines below # if v not in graph: # graph[v] = [] # graph[v].append((u, w)) return graph def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]: Computes the shortest path from the start node to all other nodes using Dijkstra's algorithm. Args: graph (Dict[int, List[Tuple[int, int]]]): The adjacency list representation of the graph. start (int): The starting node. Returns: Dict[int, int]: A dictionary with the shortest distance to each node from the start node. # Priority queue to keep track of the shortest path pq = [(0, start)] # Dictionary to store the shortest path distance to each node distances = {start: 0} # While there are nodes to process while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances.get(current_node, float('inf')): continue for neighbor, weight in graph.get(current_node, []): distance = current_distance + weight if distance < distances.get(neighbor, float('inf')): distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances"},{"question":"def is_clean_palindrome(text: str) -> bool: Determines if a given string is a palindrome after removing all non-alphabetic characters and ignoring case differences. >>> is_clean_palindrome('A man, a plan, a canal: Panama') True >>> is_clean_palindrome('No lemon, no melon!') True >>> is_clean_palindrome('Was it a car or a cat I saw?') True >>> is_clean_palindrome('Hello, World!') False >>> is_clean_palindrome('1234321') True >>> is_clean_palindrome('') True","solution":"def is_clean_palindrome(text: str) -> bool: Determines if the given text is a palindrome after removing all non-alphabetic characters and ignoring case differences. clean_text = ''.join(char.lower() for char in text if char.isalpha()) return clean_text == clean_text[::-1]"},{"question":"def count_unique_characters(text: str) -> int: Counts the number of unique alphanumeric characters in the given text. Args: text (str): A string containing the input text. Returns: int: The number of unique alphanumeric characters in the text. >>> count_unique_characters(\\"Hello, World! 123\\") == 10 >>> count_unique_characters(\\"aAaAaAaA\\") == 1 >>> count_unique_characters(\\"12345 54321\\") == 5 >>> count_unique_characters(\\"!@#%^&*()\\") == 0 >>> count_unique_characters(\\"AaBbCcDdEeFf\\") == 6 >>> count_unique_characters(\\"z\\") == 1 >>> count_unique_characters(\\"1a2b!3c 4d5e,\\") == 10 >>> count_unique_characters(\\"\\") == 0","solution":"def count_unique_characters(text: str) -> int: Counts the number of unique alphanumeric characters in the given text. Args: text (str): A string containing the input text. Returns: int: The number of unique alphanumeric characters in the text. # Convert the text to lowercase and filter out non-alphanumeric characters filtered_text = ''.join(char.lower() for char in text if char.isalnum()) # Use a set to keep track of unique characters unique_characters = set(filtered_text) # Return the number of unique characters return len(unique_characters)"},{"question":"def fibonacci(n: int) -> int: Returns the n-th Fibonacci number. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(5) 5 >>> fibonacci(10) 55 >>> fibonacci(-1) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer. def fibonacci_mod_m(n: int, m: int) -> int: Returns the n-th Fibonacci number modulo m. >>> fibonacci_mod_m(5, 3) 2 >>> fibonacci_mod_m(10, 7) 6 >>> fibonacci_mod_m(12, 10) 4 >>> fibonacci_mod_m(-1, 3) Traceback (most recent call last): ... ValueError: Both parameters must be positive integers. >>> fibonacci_mod_m(5, -2) Traceback (most recent call last): ... ValueError: Both parameters must be positive integers.","solution":"def fibonacci(n): Returns the n-th Fibonacci number. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b def fibonacci_mod_m(n, m): Returns the n-th Fibonacci number modulo m. if not isinstance(n, int) or not isinstance(m, int) or n < 0 or m <= 0: raise ValueError(\\"Both parameters must be positive integers.\\") fib_n = fibonacci(n) return fib_n % m"},{"question":"from typing import List, Dict from PIL import Image, ExifTags def extract_metadata(file_path: str, attributes: List[str]) -> Dict[str, str]: Extract specified metadata attributes from an image file. >>> extract_metadata('sample_image.jpg', ['Make', 'Model', 'DateTime']) == {'Make': 'Canon', 'Model': 'EOS 80D', 'DateTime': '2020:01:01 12:00:00'} >>> extract_metadata('non_existent_image.jpg', ['Make']) == {} @pytest.mark.parametrize(\\"file_path, attributes, expected\\", [ (\\"test_image.jpg\\", [\\"Make\\", \\"Model\\", \\"DateTime\\"], {}), (\\"non_existent_image.jpg\\", [\\"Make\\"], {}), (\\"no_metadata_image.jpg\\", [\\"Make\\", \\"Model\\", \\"DateTime\\"], {}), (\\"partial_metadata_image.jpg\\", [\\"Make\\", \\"Model\\", \\"DateTime\\"], {}) ]) def test_extract_metadata(file_path, attributes, expected): assert extract_metadata(file_path, attributes) == expected","solution":"from PIL import Image, ExifTags def extract_metadata(file_path, attributes): try: image = Image.open(file_path) exif_data = image._getexif() or {} metadata = {} for tag, value in exif_data.items(): tag_name = ExifTags.TAGS.get(tag) if tag_name in attributes: metadata[tag_name] = value return metadata except (FileNotFoundError, AttributeError, IOError): return {}"},{"question":"import re def find_and_replace(paragraph: str, target: str, replacement: str) -> str: Searches for all occurrences of the target word in the given paragraph and replaces them with the replacement word. Args: paragraph (str): The paragraph of text. target (str): The word in the paragraph that needs to be replaced. replacement (str): The word that will replace the target word. Returns: str: The modified paragraph with the target word replaced by the replacement word. >>> find_and_replace(\\"The quick brown fox jumps over the lazy dog.\\", \\"fox\\", \\"cat\\") 'The quick brown cat jumps over the lazy dog.' >>> find_and_replace(\\"Caterpillar and cat.\\", \\"cat\\", \\"dog\\") 'Caterpillar and dog.'","solution":"import re def find_and_replace(paragraph, target, replacement): Searches for all occurrences of the target word in the given paragraph and replaces them with the replacement word. Args: paragraph (str): The paragraph of text. target (str): The word in the paragraph that needs to be replaced. replacement (str): The word that will replace the target word. Returns: str: The modified paragraph with the target word replaced by the replacement word. if not paragraph: raise ValueError(\\"Paragraph should not be empty.\\") if not target: raise ValueError(\\"Target word should not be empty.\\") if not replacement: raise ValueError(\\"Replacement word should not be empty.\\") if target not in paragraph: raise ValueError(\\"Target word does not exist in the paragraph.\\") # Using regex word boundary b to ensure only whole words are replaced. pattern = r'b' + re.escape(target) + r'b' updated_paragraph = re.sub(pattern, replacement, paragraph) return updated_paragraph"},{"question":"class MinStack: Design and implement a class \`MinStack\` that supports the following operations: 1. \`push(val: int)\`: Pushes the integer \`val\` onto the stack. 2. \`pop()\`: Removes the top element from the stack. 3. \`top() -> int\`: Gets the top element of the stack. 4. \`get_min() -> int\`: Retrieves the minimum element in the stack. def __init__(self): Initialize the data structures. def push(self, val: int) -> None: Push the integer \`val\` onto the stack. Args: val (int): The value to be pushed onto the stack. def pop(self) -> None: Remove the top element from the stack. def top(self) -> int: Get the top element of the stack. Returns: int: The top element of the stack. def get_min(self) -> int: Retrieve the minimum element in the stack. Returns: int: The minimum element in the stack. from solution import MinStack def test_push_and_get_min(): min_stack = MinStack() min_stack.push(-2) min_stack.push(0) min_stack.push(-3) assert min_stack.get_min() == -3 def test_pop_and_top(): min_stack = MinStack() min_stack.push(-2) min_stack.push(0) min_stack.push(-3) min_stack.pop() assert min_stack.top() == 0 def test_get_min_after_pop(): min_stack = MinStack() min_stack.push(-2) min_stack.push(0) min_stack.push(-3) min_stack.pop() assert min_stack.get_min() == -2 def test_push_duplicate_min_elements(): min_stack = MinStack() min_stack.push(-2) min_stack.push(-2) min_stack.push(-2) assert min_stack.get_min() == -2 min_stack.pop() assert min_stack.get_min() == -2 min_stack.pop() assert min_stack.get_min() == -2 def test_operations_on_empty_stack(): min_stack = MinStack() assert min_stack.top() is None assert min_stack.get_min() is None min_stack.pop() # Should handle gracefully without error def test_edge_case_large_values(): min_stack = MinStack() min_stack.push(10**9) min_stack.push(-10**9) assert min_stack.get_min() == -10**9 min_stack.pop() assert min_stack.get_min() == 10**9","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() self.stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] def get_min(self) -> int: if self.min_stack: return self.min_stack[-1]"},{"question":"def update_inventory(current_inventory: dict, new_shipment: list) -> dict: Update the current inventory with the quantities from a new shipment. :param current_inventory: Dictionary with current stock levels. :param new_shipment: List of tuples with product name and quantity received. :return: Updated dictionary with new inventory levels. >>> update_inventory({'apple': 10, 'banana': 5}, [('apple', 3), ('orange', 7)]) {'apple': 13, 'banana': 5, 'orange': 7} >>> update_inventory({'apple': 0, 'banana': 2}, [('banana', 3), ('apple', 8)]) {'apple': 8, 'banana': 5}","solution":"def update_inventory(current_inventory: dict, new_shipment: list) -> dict: Update the current inventory with the quantities from a new shipment. :param current_inventory: Dictionary with current stock levels. :param new_shipment: List of tuples with product name and quantity received. :return: Updated dictionary with new inventory levels. # Validate inputs if not isinstance(current_inventory, dict): raise Exception(\\"Current inventory must be a dictionary\\") if not isinstance(new_shipment, list): raise Exception(\\"New shipment must be a list\\") for product, quantity in new_shipment: if not isinstance(quantity, int) or quantity < 0: raise Exception(\\"Shipment quantities must be >= 0\\") for product, stock in current_inventory.items(): if not isinstance(stock, int) or stock < 0: raise Exception(\\"Stock levels must be >= 0\\") # Update inventory for product, quantity in new_shipment: if product in current_inventory: current_inventory[product] += quantity else: current_inventory[product] = quantity return current_inventory"},{"question":"from typing import List, Dict def prioritize_tasks(task_graph: List[List[int]], tasks: Dict[int, str]) -> List[str]: Perform topological sort on the given task dependency graph and return the order of task names in which they should be completed. :param task_graph: Adjacency list representing the task dependency graph. :param tasks: Dictionary mapping task indices to their names. :return: List of task names in the order they should be completed. >>> tasks = { ... 0: \\"Collect Data\\", ... 1: \\"Research Topic\\", ... 2: \\"Write Report\\", ... 3: \\"Proofread Report\\", ... 4: \\"Submit Report\\", ... } >>> task_graph = [[2], [2], [3], [4], []] >>> prioritize_tasks(task_graph, tasks) ['Collect Data', 'Research Topic', 'Write Report', 'Proofread Report', 'Submit Report']","solution":"from typing import List, Dict def prioritize_tasks(task_graph: List[List[int]], tasks: Dict[int, str]) -> List[str]: Perform topological sort on the given task dependency graph and return the order of tasks names in which they should be completed. :param task_graph: Adjacency list representing the task dependency graph. :param tasks: Dictionary mapping task indices to their names. :return: List of task names in the order they should be completed. from collections import deque # Calculate in-degrees (number of incoming edges) for each node in_degree = [0] * len(task_graph) for node in range(len(task_graph)): for neighbor in task_graph[node]: in_degree[neighbor] += 1 # Initialize the queue with nodes having zero in-degree queue = deque([i for i in range(len(task_graph)) if in_degree[i] == 0]) topo_order = [] while queue: node = queue.popleft() topo_order.append(node) for neighbor in task_graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If there's a cycle in the graph, topo_order will not contain all the vertices if len(topo_order) != len(task_graph): raise ValueError(\\"The graph is not a DAG (cycle detected).\\") # Mapping indices to task names task_order = [tasks[i] for i in topo_order] return task_order"},{"question":"from typing import List def find_most_frequent_element(matrix: List[List[int]]) -> int: Returns the most frequent element in the given matrix. If multiple elements have the same highest frequency, returns the smallest element. >>> find_most_frequent_element([[1, 2, 3], [2, 3, 4], [3, 4, 5]]) 3 >>> find_most_frequent_element([[5]]) 5 >>> find_most_frequent_element([[2, 2, 2], [2, 2, 2], [2, 2, 2]]) 2 >>> find_most_frequent_element([[-1, -2, -3], [-2, -3, -4], [-3, -4, -5]]) -3","solution":"from typing import List from collections import Counter def find_most_frequent_element(matrix: List[List[int]]) -> int: Returns the most frequent element in the given matrix. If multiple elements have the same highest frequency, returns the smallest element. frequency = Counter() # Update frequencies for each row in the matrix for row in matrix: frequency.update(row) # Find the most common element, preferring smaller elements if tied most_common_element = min(frequency.items(), key=lambda x: (-x[1], x[0]))[0] return most_common_element"},{"question":"def gcd(a: int, b: int) -> int: Computes the Greatest Common Divisor (GCD) of two integers using the Euclidean Algorithm. Parameters: a (int): First non-zero integer. b (int): Second non-zero integer. Returns: int: The greatest common divisor of a and b. >>> gcd(48, 18) 6 >>> gcd(101, 10) 1 >>> gcd(-81, 27) 27","solution":"def gcd(a: int, b: int) -> int: Computes the Greatest Common Divisor (GCD) of two integers using the Euclidean Algorithm. Parameters: a (int): First non-zero integer. b (int): Second non-zero integer. Returns: int: The greatest common divisor of a and b. while b != 0: a, b = b, a % b return abs(a)"},{"question":"def rgb_to_hsl(r: float, g: float, b: float) -> tuple: Convert RGB color to HSL color. Args: r (float): Red component of the color, ranging from 0 to 255. g (float): Green component of the color, ranging from 0 to 255. b (float): Blue component of the color, ranging from 0 to 255. Returns: tuple: A tuple (h, s, l) representing the color in HSL format, where: - h (float): Hue component, ranging from 0 to 360. - s (float): Saturation component, ranging from 0 to 1. - l (float): Lightness component, ranging from 0 to 1. # Your implementation here pass # Test cases if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def rgb_to_hsl(r, g, b): Convert RGB color to HSL color. Args: r (float): Red component of the color, ranging from 0 to 255. g (float): Green component of the color, ranging from 0 to 255. b (float): Blue component of the color, ranging from 0 to 255. Returns: tuple: A tuple (h, s, l) representing the color in HSL format, where: - h (float): Hue component, ranging from 0 to 360. - s (float): Saturation component, ranging from 0 to 1. - l (float): Lightness component, ranging from 0 to 1. r /= 255.0 g /= 255.0 b /= 255.0 max_c = max(r, g, b) min_c = min(r, g, b) delta = max_c - min_c l = (max_c + min_c) / 2.0 if delta == 0: h = 0.0 s = 0.0 else: s = delta / (1.0 - abs(2.0 * l - 1.0)) if max_c == r: h = 60 * (((g - b) / delta) % 6) elif max_c == g: h = 60 * (((b - r) / delta) + 2) elif max_c == b: h = 60 * (((r - g) / delta) + 4) h = round(h, 2) s = round(s, 2) l = round(l, 2) return h, s, l"},{"question":"def longest_substring_distinct(s: str) -> str: Finds the longest substring of a given string s where all characters are distinct. >>> longest_substring_distinct(\\"abcabcbb\\") == \\"abc\\" >>> longest_substring_distinct(\\"bbbbb\\") == \\"b\\" >>> longest_substring_distinct(\\"pwwkew\\") == \\"wke\\" >>> longest_substring_distinct(\\"\\") == \\"\\"","solution":"def longest_substring_distinct(s: str) -> str: Finds the longest substring of a given string s where all characters are distinct. n = len(s) if n == 0: return \\"\\" char_index_map = {} longest_substr = \\"\\" left = 0 for right in range(n): if s[right] in char_index_map: left = max(left, char_index_map[s[right]] + 1) char_index_map[s[right]] = right if right - left + 1 > len(longest_substr): longest_substr = s[left:right+1] return longest_substr"},{"question":"def gcd(a: int, b: int) -> int: Computes the Greatest Common Divisor (GCD) of two non-negative integers using the Euclidean algorithm. Parameters: a (int): The first non-negative integer. b (int): The second non-negative integer. Returns: int: The GCD of a and b. Raises: ValueError: If either a or b is a negative integer. >>> gcd(48, 18) 6 >>> gcd(56, 98) 14 >>> gcd(101, 10) 1 >>> gcd(0, 25) 25 >>> gcd(37, 600) 1 import pytest from solution import gcd def test_gcd_positive_numbers(): assert gcd(48, 18) == 6 assert gcd(56, 98) == 14 assert gcd(101, 10) == 1 def test_gcd_with_zero(): assert gcd(0, 25) == 25 assert gcd(37, 0) == 37 def test_gcd_both_zeros(): assert gcd(0, 0) == 0 def test_gcd_negative_numbers(): with pytest.raises(ValueError): gcd(-1, 5) with pytest.raises(ValueError): gcd(5, -1) with pytest.raises(ValueError): gcd(-1, -5) def test_gcd_mixed_numbers(): assert gcd(27, 36) == 9 assert gcd(17, 17) == 17 pytest.main()","solution":"def gcd(a: int, b: int) -> int: Computes the Greatest Common Divisor (GCD) of two non-negative integers using the Euclidean algorithm. Parameters: a (int): The first non-negative integer. b (int): The second non-negative integer. Returns: int: The GCD of a and b. Raises: ValueError: If either a or b is a negative integer. if a < 0 or b < 0: raise ValueError(\\"Both numbers must be non-negative.\\") while b != 0: a, b = b, a % b return a"},{"question":"import math def calculate_cylinder_surface_area(radius: float, height: float) -> float: Calculate the total surface area of a cylindrical tank given its radius and height. Parameters: - radius (float): Radius of the cylindrical tank (meters) - height (float): Height of the cylindrical tank (meters) Returns: - float: The total surface area (square meters) >>> calculate_cylinder_surface_area(3, 5) 150.79644737231007 >>> calculate_cylinder_surface_area(1, 1) 12.566370614359172 >>> calculate_cylinder_surface_area(2, 3) 62.83185307179586 pass # Implement the function here def calculate_cylinder_volume(radius: float, height: float) -> float: Calculate the volume of a cylindrical tank given its radius and height. Parameters: - radius (float): Radius of the cylindrical tank (meters) - height (float): Height of the cylindrical tank (meters) Returns: - float: The volume (cubic meters) >>> calculate_cylinder_volume(3, 5) 141.3716694115407 >>> calculate_cylinder_volume(1, 1) 3.141592653589793 >>> calculate_cylinder_volume(2, 3) 37.69911184307752 pass # Implement the function here","solution":"import math def calculate_cylinder_surface_area(radius: float, height: float) -> float: Calculate the total surface area of a cylindrical tank given its radius and height. Parameters: - radius (float): Radius of the cylindrical tank (meters) - height (float): Height of the cylindrical tank (meters) Returns: - float: The total surface area (square meters) if radius <= 0 or height <= 0: raise ValueError(\\"Radius and height must be positive.\\") surface_area = 2 * math.pi * radius * (height + radius) return surface_area def calculate_cylinder_volume(radius: float, height: float) -> float: Calculate the volume of a cylindrical tank given its radius and height. Parameters: - radius (float): Radius of the cylindrical tank (meters) - height (float): Height of the cylindrical tank (meters) Returns: - float: The volume (cubic meters) if radius <= 0 or height <= 0: raise ValueError(\\"Radius and height must be positive.\\") volume = math.pi * radius ** 2 * height return volume"},{"question":"def find_single_number(nums): Find the single number that appears only once in a list of integers. Args: nums (list of int): A list of integers where each integer appears twice except for one. Returns: int: The integer that appears only once in the list. >>> find_single_number([2, 2, 1]) 1 >>> find_single_number([4, 1, 2, 1, 2]) 4 >>> find_single_number([1]) 1","solution":"def find_single_number(nums): Returns the single number that appears only once in the list. Args: nums (list of int): List of integers where each integer appears twice except for one. Returns: int: The integer that appears only once in the list. single_number = 0 for num in nums: single_number ^= num return single_number"},{"question":"def factorial(n: int) -> int: Calculates the factorial of a given non-negative integer n. >>> factorial(5) == 120 >>> factorial(0) == 1 >>> factorial(10) == 3628800 >>> factorial(20) == 2432902008176640000","solution":"def factorial(n: int) -> int: Calculates the factorial of a given non-negative integer n. if n == 0 or n == 1: return 1 result = 1 for i in range(2, n + 1): result *= i return result"},{"question":"def track_enrollments(enrollments: list[tuple[str, str]]) -> dict[str, int]: Tracks the enrollments and returns a summary of the total enrollments for each course. >>> track_enrollments([('user1', 'course1'), ('user2', 'course1'), ('user1', 'course2'), ('user1', 'course1'), ('user2', 'course2')]) {'course1': 3, 'course2': 2} >>> track_enrollments([('user1', 'course1')]) {'course1': 1} >>> track_enrollments([('user1', 'course1'), ('user2', 'course1')]) {'course1': 2} >>> track_enrollments([('user1', 'course1'), ('user2', 'course2')]) {'course1': 1, 'course2': 1} >>> track_enrollments([('user1', 'course1'), ('user1', 'course1'), ('user2', 'course1')]) {'course1': 3} >>> track_enrollments([]) {}","solution":"def track_enrollments(enrollments: list[tuple[str, str]]) -> dict[str, int]: Tracks the enrollments and returns a summary of the total enrollments for each course. Args: enrollments (list of tuples): A list of tuples where each tuple contains (\`user_id\`, \`course_id\`). Returns: dict: A dictionary where the keys are \`course_id\`, and the values are the total number of enrollments for that course. course_counts = {} for user_id, course_id in enrollments: if course_id in course_counts: course_counts[course_id] += 1 else: course_counts[course_id] = 1 return course_counts"},{"question":"from typing import List def find_word_in_grid(grid: List[List[str]], word: str) -> bool: Write a Python function that searches for a specific word in a grid of characters. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. You cannot use the same cell more than once in a single word construction. Args: grid (List[List[str]]): A 2D list of characters representing the grid. word (str): The word to search for in the grid. Returns: bool: Returns True if the word exists in the grid, otherwise False. Examples: >>> grid = [ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ] >>> word = \\"ABCCED\\" >>> find_word_in_grid(grid, word) True >>> word = \\"SEE\\" >>> find_word_in_grid(grid, word) True >>> word = \\"ABCB\\" >>> find_word_in_grid(grid, word) False","solution":"from typing import List def find_word_in_grid(grid: List[List[str]], word: str) -> bool: rows, cols = len(grid), len(grid[0]) def dfs(r, c, i): if i == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != word[i]: return False temp, grid[r][c] = grid[r][c], '#' # mark as visited found = ( dfs(r+1, c, i+1) or dfs(r-1, c, i+1) or dfs(r, c+1, i+1) or dfs(r, c-1, i+1) ) grid[r][c] = temp # unmark return found for r in range(rows): for c in range(cols): if dfs(r, c, 0): return True return False"},{"question":"def check_activity_eligibility(user_age: int, activity_age_ranges: dict) -> list: Determine the activities a user is eligible for based on their age. Args: user_age (int): The age of the user. activity_age_ranges (dict): A dictionary where keys are activity names and values are tuples representing minimum and maximum age limits. Returns: list: A list of strings representing the names of activities the user can participate in. Raises: ValueError: If user_age is a negative integer. Examples: >>> check_activity_eligibility(18, {\\"swimming\\": (10, 25), \\"marathon\\": (20, 30), \\"chess\\": (5, 50)}) ['swimming', 'chess'] >>> check_activity_eligibility(12, {\\"swimming\\": (10, 25), \\"marathon\\": (20, 30)}) ['swimming'] >>> check_activity_eligibility(40, {\\"archery\\": (15, 45), \\"basketball\\": (18, 35)}) ['archery'] >>> check_activity_eligibility(8, {\\"swimming\\": (10, 25), \\"basketball\\": (18, 35)}) [] def test_check_activity_eligibility(): assert check_activity_eligibility(18, {\\"swimming\\": (10, 25), \\"marathon\\": (20, 30), \\"chess\\": (5, 50)}) == ['swimming', 'chess'] assert check_activity_eligibility(12, {\\"swimming\\": (10, 25), \\"marathon\\": (20, 30)}) == ['swimming'] assert check_activity_eligibility(40, {\\"archery\\": (15, 45), \\"basketball\\": (18, 35)}) == ['archery'] assert check_activity_eligibility(8, {\\"swimming\\": (10, 25), \\"basketball\\": (18, 35)}) == [] assert check_activity_eligibility(25, {\\"running\\": (20, 30), \\"fishing\\": (15, 35), \\"reading\\": (1, 100)}) == ['running', 'fishing', 'reading'] def test_check_activity_eligibility_with_zero_age(): assert check_activity_eligibility(0, {\\"baby_swimming\\": (0, 2), \\"archery\\": (15, 45)}) == [\\"baby_swimming\\"] def test_check_activity_eligibility_with_large_range(): assert check_activity_eligibility(50, {\\"extreme_sports\\": (30, 60), \\"painting\\": (20, 80)}) == [\\"extreme_sports\\", \\"painting\\"] def test_check_activity_eligibility_no_activities(): assert check_activity_eligibility(25, {\\"child_sports\\": (5, 15), \\"senior_program\\": (60, 90)}) == [] def test_check_activity_eligibility_invalid_age(): try: check_activity_eligibility(-1, {\\"swimming\\": (10, 25)}) except ValueError as e: assert str(e) == \\"User age must be a non-negative integer.\\"","solution":"def check_activity_eligibility(user_age, activity_age_ranges): if user_age < 0: raise ValueError(\\"User age must be a non-negative integer.\\") eligible_activities = [] for activity, age_range in activity_age_ranges.items(): min_age, max_age = age_range if min_age <= user_age <= max_age: eligible_activities.append(activity) return eligible_activities"},{"question":"def process_coffee_orders(orders: List[Tuple[str, int]]) -> List[int]: Simulate the order processing in a coffee shop. The coffee shop sells three types of coffee: \\"Espresso\\", \\"Americano\\", and \\"Latte\\". Each type of coffee has a different preparation time: - \\"Espresso\\" takes 3 minutes to prepare. - \\"Americano\\" takes 5 minutes to prepare. - \\"Latte\\" takes 7 minutes to prepare. The shop can only process one coffee order at a time. Given a list of incoming orders and their timestamps in minutes since the shop opened, calculate the finish time for each order. Parameters: orders (List[Tuple[str, int]]): A list of tuples where each tuple contains the coffee type (string) and the timestamp (int). Returns: List[int]: Returns a list of integers representing the finish time for each order. >>> process_coffee_orders([(\\"Espresso\\", 1)]) [4] >>> process_coffee_orders([(\\"Espresso\\", 1), (\\"Americano\\", 10)]) [4, 15] >>> process_coffee_orders([(\\"Espresso\\", 1), (\\"Americano\\", 2), (\\"Latte\\", 3)]) [4, 9, 16] >>> process_coffee_orders([(\\"Espresso\\", 1), (\\"Espresso\\", 3), (\\"Espresso\\", 6)]) [4, 7, 10] >>> process_coffee_orders([]) [] >>> process_coffee_orders([(\\"Espresso\\", 1), (\\"Americano\\", 1), (\\"Latte\\", 1)]) [4, 9, 16] >>> process_coffee_orders([(\\"Espresso\\", 1), (\\"Americano\\", 2), (\\"Latte\\", 3), (\\"Espresso\\", 8)]) [4, 9, 16, 19]","solution":"from typing import List, Tuple def process_coffee_orders(orders: List[Tuple[str, int]]) -> List[int]: # Preparation times for different coffee types prep_times = { \\"Espresso\\": 3, \\"Americano\\": 5, \\"Latte\\": 7 } finish_times = [] current_time = 0 # Time when the last coffee order was processed for coffee_type, order_time in orders: prep_time = prep_times[coffee_type] # The coffee can start preparing either when it is ordered or when the previous coffee finishes, whichever is later start_time = max(current_time, order_time) finish_time = start_time + prep_time finish_times.append(finish_time) # Update the current time to the time when this coffee finishes current_time = finish_time return finish_times"},{"question":"def count_consecutive_sums(k: int) -> int: Return the number of ways to represent k as the sum of consecutive positive integers. >>> count_consecutive_sums(15) 4 >>> count_consecutive_sums(10) 2 >>> count_consecutive_sums(1) 1 >>> count_consecutive_sums(9) 3 >>> count_consecutive_sums(5) 2 >>> count_consecutive_sums(100) 3","solution":"def count_consecutive_sums(k: int) -> int: Return the number of ways to represent k as the sum of consecutive positive integers. count = 0 # We explore possible sequence lengths from 1 up to k for m in range(1, k + 1): # Check if there's a valid sequence of length m that sums to k # The sum of m consecutive numbers starting with n is: m*n + m*(m-1)/2 # Rearrange to solve for n: n = (k - m*(m-1)/2) / m sum_m_minus_1 = m * (m - 1) // 2 if sum_m_minus_1 >= k: break if (k - sum_m_minus_1) % m == 0: count += 1 return count"},{"question":"def find_missing_number(nums: List[int]) -> int: Finds the missing number in the list of integers from 1 to n. :param nums: List of integers containing unique elements from 1 to n except one missing number. :return: The missing number in the range from 1 to n. >>> find_missing_number([1, 2, 4, 6, 3, 7, 8]) 5 >>> find_missing_number([1, 2, 3, 5]) 4","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Finds the missing number in the list of integers from 1 to n. :param nums: List of integers containing unique elements from 1 to n except one missing number. :return: The missing number in the range from 1 to n. n = len(nums) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"from typing import List def calculate_percentage_changes(prices: List[float]) -> List[float]: Converts an array of daily prices for a particular stock into a list of percentage changes between consecutive days. >>> calculate_percentage_changes([100.0, 105.0, 102.0, 110.0]) [0, 5.0, -2.857142857142857, 7.8431372549019605] >>> calculate_percentage_changes([200.0]) [0] >>> calculate_percentage_changes([50.0, 50.0, 50.0]) [0, 0.0, 0.0] >>> calculate_percentage_changes([50.0, 100.0, 50.0]) [0, 100.0, -50.0] def test_single_price(): assert calculate_percentage_changes([200.0]) == [0] def test_constant_prices(): assert calculate_percentage_changes([50.0, 50.0, 50.0]) == [0, 0.0, 0.0] def test_varying_prices(): assert calculate_percentage_changes([100.0, 105.0, 102.0, 110.0]) == [0, 5.0, -2.857142857142857, 7.8431372549019605] def test_doubling_price(): assert calculate_percentage_changes([50.0, 100.0, 50.0]) == [0, 100.0, -50.0] def test_percentage_increase(): assert calculate_percentage_changes([100.0, 110.0, 121.0]) == [0, 10.0, 10.0] def test_percentage_decrease(): assert calculate_percentage_changes([100.0, 90.0, 81.0]) == [0, -10.0, -10.0]","solution":"from typing import List def calculate_percentage_changes(prices: List[float]) -> List[float]: if len(prices) == 1: return [0] percentage_changes = [0] # The first day change is always 0 for i in range(1, len(prices)): previous_price = prices[i - 1] current_price = prices[i] percentage_change = ((current_price - previous_price) / previous_price) * 100 percentage_changes.append(percentage_change) return percentage_changes"},{"question":"def custom_base64_decoder(encoded_string: str) -> str: Decodes a Base64-encoded string into its original format. Strips leading/trailing whitespaces and handles specific edge cases. >>> custom_base64_decoder(\\"SGVsbG8gV29ybGQ=\\") 'Hello World' >>> custom_base64_decoder(\\"V2VsY29tZQ==\\") 'Welcome' >>> custom_base64_decoder(\\"Tm90SGlkZGVuU3BhY2U=\\") 'NotHiddenSpace' >>> custom_base64_decoder(\\" U29tZSB0ZXh0IHdpdGggd2hpdGVzcGFjZSB0byB0ZXN0IC0gMTIzNDU= \\") 'Some text with whitespace to test - 12345' >>> custom_base64_decoder(\\"U29tZSBpbnZhbGlkIHN0cmluZyDpicmpQ==\\") Traceback (most recent call last): ... ValueError: Invalid Base64 string: contains non-base64 character >>> custom_base64_decoder(\\" \\") Traceback (most recent call last): ... ValueError: Empty string was passed to the function >>> custom_base64_decoder(\\" U29tZSBpbnRlcm5hbCB3aGl0ZXNwYWNl === \\") Traceback (most recent call last): ... ValueError: Invalid Base64 string: contains internal whitespace","solution":"import base64 def custom_base64_decoder(encoded_string: str) -> str: Decodes a Base64-encoded string into its original format. Strips leading/trailing whitespaces and handles specific edge cases. # Strip leading and trailing whitespace trimmed_string = encoded_string.strip() # Check if the string is empty after stripping if not trimmed_string: raise ValueError(\\"Empty string was passed to the function\\") # Check for internal whitespaces if ' ' in trimmed_string or 'n' in trimmed_string or 'r' in trimmed_string or 't' in trimmed_string: raise ValueError(\\"Invalid Base64 string: contains internal whitespace\\") try: # Decode the base64 encoded string decoded_bytes = base64.b64decode(trimmed_string, validate=True) decoded_string = decoded_bytes.decode('utf-8') except (base64.binascii.Error, UnicodeDecodeError): raise ValueError(\\"Invalid Base64 string: invalid encoding or padding\\") return decoded_string"},{"question":"import numpy as np def remove_column(mat: np.ndarray, col_idx: int) -> np.ndarray: Remove the column at index col_idx from the matrix mat. Parameters: mat (np.ndarray): A 2D numpy array of shape (k, n). col_idx (int): An integer representing the index of the column to be removed. Returns: np.ndarray: A 2D numpy array with the specified column removed. Raises: ValueError: If the col_idx is not a valid column index in mat. >>> mat = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) >>> remove_column(mat, 1) array([[1, 3], [4, 6], [7, 9]]) >>> mat = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) >>> remove_column(mat, 0) array([[2, 3], [5, 6], [8, 9]]) >>> mat = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) >>> remove_column(mat, 2) array([[1, 2], [4, 5], [7, 8]]) >>> mat = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) >>> remove_column(mat, 3) Traceback (most recent call last): ... ValueError: Invalid column index >>> mat = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) >>> remove_column(mat, -1) Traceback (most recent call last): ... ValueError: Invalid column index","solution":"import numpy as np def remove_column(mat: np.ndarray, col_idx: int) -> np.ndarray: Remove the column at index col_idx from the matrix mat. Parameters: mat (np.ndarray): A 2D numpy array of shape (k, n). col_idx (int): An integer representing the index of the column to be removed. Returns: np.ndarray: A 2D numpy array with the specified column removed. Raises: ValueError: If the col_idx is not a valid column index in mat. if col_idx < 0 or col_idx >= mat.shape[1]: raise ValueError(\\"Invalid column index\\") return np.delete(mat, col_idx, axis=1)"},{"question":"def filter_books(books: list[dict], preferred_genres: list[str], preferred_authors: list[str]) -> list[str]: Filters books based on preferred genres and authors. Args: books: list of dictionaries, where each dictionary has following keys: - title (str): The title of the book - genres (list of str): A list of genres the book belongs to - author (str): The author of the book preferred_genres: list of str, genres preferred by the user preferred_authors: list of str, authors preferred by the user Returns: list of str : titles of books that match the criteria Example: >>> books = [ ... {\\"title\\": \\"Book A\\", \\"genres\\": [\\"Fiction\\", \\"Fantasy\\"], \\"author\\": \\"Author 1\\"}, ... {\\"title\\": \\"Book B\\", \\"genres\\": [\\"Non-Fiction\\", \\"History\\"], \\"author\\": \\"Author 2\\"}, ... {\\"title\\": \\"Book C\\", \\"genres\\": [\\"Romance\\", \\"Fiction\\"], \\"author\\": \\"Author 1\\"}, ... {\\"title\\": \\"Book D\\", \\"genres\\": [\\"Sci-Fi\\", \\"Adventure\\"], \\"author\\": \\"Author 3\\"}, ... ] >>> preferred_genres = [\\"Fiction\\", \\"Sci-Fi\\"] >>> preferred_authors = [\\"Author 1\\", \\"Author 3\\"] >>> filter_books(books, preferred_genres, preferred_authors) [\\"Book A\\", \\"Book C\\", \\"Book D\\"] >>> preferred_genres = [\\"Non-Fiction\\"] >>> preferred_authors = [\\"Author 2\\"] >>> filter_books(books, preferred_genres, preferred_authors) [\\"Book B\\"]","solution":"def filter_books(books, preferred_genres, preferred_authors): Filters books based on preferred genres and authors. Args: books: list of dictionaries, where each dictionary has following keys: - title (str): The title of the book - genres (list of str): A list of genres the book belongs to - author (str): The author of the book preferred_genres: list of str, genres preferred by the user preferred_authors: list of str, authors preferred by the user Returns: list of str : titles of books that match the criteria filtered_books = [] for book in books: if book['author'] in preferred_authors and any(genre in preferred_genres for genre in book['genres']): filtered_books.append(book['title']) return filtered_books"},{"question":"def reverse_sentence(sentence: str) -> str: Reverse the words in a given sentence but leave the words themselves intact. >>> reverse_sentence(\\" Hello world! \\") ' world! Hello ' >>> reverse_sentence(\\"Coding assessments are important.\\") 'important. are assessments Coding' from solution import reverse_sentence def test_basic(): assert reverse_sentence(\\"Hello world\\") == \\"world Hello\\" def test_multiple_spaces(): assert reverse_sentence(\\" Hello world! \\") == \\" world! Hello \\" def test_single_word(): assert reverse_sentence(\\"single\\") == \\"single\\" def test_simple_case(): assert reverse_sentence(\\"Coding assessments are important.\\") == \\"important. are assessments Coding\\" def test_leading_and_trailing_spaces(): assert reverse_sentence(\\" Leading and trailing spaces \\") == \\" spaces trailing and Leading \\" def test_only_spaces(): assert reverse_sentence(\\" \\") == \\" \\" def test_empty_string(): assert reverse_sentence(\\"\\") == \\"\\" def test_various_characters(): assert reverse_sentence(\\"Hello, world! How's it going?\\") == \\"going? it How's world! Hello,\\"","solution":"def reverse_sentence(sentence: str) -> str: # Split the sentence by spaces words = sentence.split(' ') # Reverse the list of words reversed_words = words[::-1] # Join them back together with spaces return ' '.join(reversed_words)"},{"question":"from typing import List def rotate_matrix_90(matrix: List[List[int]]) -> List[List[int]]: Rotates the given NxN matrix counterclockwise by 90 degrees. >>> rotate_matrix_90([ ... [ 1, 2, 3 ], ... [ 4, 5, 6 ], ... [ 7, 8, 9 ] ... ]) [[3, 6, 9], [2, 5, 8], [1, 4, 7]] >>> rotate_matrix_90([[1]]) [[1]] >>> rotate_matrix_90([ ... [1, 2], ... [3, 4] ... ]) [[2, 4], [1, 3]]","solution":"def rotate_matrix_90(matrix): Rotates the given NxN matrix counterclockwise by 90 degrees. N = len(matrix) # Create a new matrix to store the result of rotation rotated_matrix = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): rotated_matrix[N - j - 1][i] = matrix[i][j] return rotated_matrix"},{"question":"def min_edit_distance(word1: str, word2: str) -> int: Determine the minimum edit distance between two strings. >>> min_edit_distance(\\"\\", \\"\\") == 0 >>> min_edit_distance(\\"\\", \\"abc\\") == 3 >>> min_edit_distance(\\"abc\\", \\"\\") == 3 >>> min_edit_distance(\\"abc\\", \\"abc\\") == 0 >>> min_edit_distance(\\"a\\", \\"b\\") == 1 >>> min_edit_distance(\\"abc\\", \\"abcd\\") == 1 >>> min_edit_distance(\\"abcd\\", \\"abc\\") == 1 >>> min_edit_distance(\\"intention\\", \\"execution\\") == 5 >>> min_edit_distance(\\"horse\\", \\"ros\\") == 3 from solution import min_edit_distance def test_empty_strings(): assert min_edit_distance(\\"\\", \\"\\") == 0 def test_empty_and_nonempty_string(): assert min_edit_distance(\\"\\", \\"abc\\") == 3 assert min_edit_distance(\\"abc\\", \\"\\") == 3 def test_same_strings(): assert min_edit_distance(\\"abc\\", \\"abc\\") == 0 def test_single_character_diff(): assert min_edit_distance(\\"a\\", \\"b\\") == 1 def test_insertion_only(): assert min_edit_distance(\\"abc\\", \\"abcd\\") == 1 def test_deletion_only(): assert min_edit_distance(\\"abcd\\", \\"abc\\") == 1 def test_substitution_only(): assert min_edit_distance(\\"intention\\", \\"execution\\") == 5 def test_complex_case(): assert min_edit_distance(\\"horse\\", \\"ros\\") == 3","solution":"def min_edit_distance(word1: str, word2: str) -> int: # Length of the two words m, n = len(word1), len(word2) # Initialize the DP table with dimensions (m+1) x (n+1) dp = [[0] * (n + 1) for _ in range(m + 1)] # Base cases: transforming from empty string to word2 and vice versa for i in range(1, m+1): dp[i][0] = i for j in range(1, n+1): dp[0][j] = j # Fill the DP table for i in range(1, m+1): for j in range(1, n+1): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] # No operation needed else: # Minimum of deleting from word1, inserting into word1, or replacing character dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 return dp[m][n]"},{"question":"def find_peaks(elevations: list[int]) -> list[int]: Identifies all peak elements in the elevation profile. Args: elevations (list[int]): List of integers representing the elevation levels. Returns: list[int]: List of peak elements. pass # Example usage elevations = [2, 4, 1, 7, 6, 8, 3] peak_elements = find_peaks(elevations) print(peak_elements) # Output should be: [4, 7, 8] def test_find_peaks_single_element(): assert find_peaks([5]) == [5] assert find_peaks([-1]) == [-1] def test_find_peaks_all_same(): assert find_peaks([3, 3, 3]) == [3, 3, 3] def test_find_peaks_example_case(): assert find_peaks([2, 4, 1, 7, 6, 8, 3]) == [4, 7, 8] def test_find_peaks_possible_duplicate_peaks(): assert find_peaks([1, 2, 2, 1]) == [2, 2] assert find_peaks([1, 3, 2, 3, 1]) == [3, 3] def test_find_peaks_decreasing_order(): assert find_peaks([6, 5, 4, 3]) == [6] def test_find_peaks_increasing_order(): assert find_peaks([1, 2, 3, 4]) == [4] def test_find_peaks_peak_at_end(): assert find_peaks([1, 2, 3]) == [3] assert find_peaks([1, 2, 3, 2]) == [3] def test_find_peaks_peak_at_start(): assert find_peaks([3, 2, 1]) == [3] def test_find_peaks_general_case(): assert find_peaks([0, 6, 7, 4, 8, 1, 8, 3, 6]) == [7, 8, 8, 6]","solution":"def find_peaks(elevations: list[int]) -> list[int]: Identifies all peak elements in the elevation profile. Args: elevations (list[int]): List of integers representing the elevation levels. Returns: list[int]: List of peak elements. n = len(elevations) if n == 1: return [elevations[0]] peaks = [] for i in range(n): if i == 0: if elevations[i] >= elevations[i + 1]: peaks.append(elevations[i]) elif i == n - 1: if elevations[i] >= elevations[i - 1]: peaks.append(elevations[i]) else: if elevations[i] >= elevations[i - 1] and elevations[i] >= elevations[i + 1]: peaks.append(elevations[i]) return peaks"},{"question":"from typing import List, Dict def event_schedule(graph: List[List[int]], sessions: Dict[int, str]) -> List[str]: Determine a valid schedule of sessions that respects the given constraints in a DAG. >>> graph = [[1, 3], [2], [3], [], [2, 5], []] >>> sessions = {0: \\"Keynote\\", 1: \\"Workshop 1\\", 2: \\"Workshop 2\\", 3: \\"Networking\\", 4: \\"Panel Discussion\\", 5: \\"Closing Remarks\\"} >>> event_schedule(graph, sessions) ['Keynote', 'Workshop 1', 'Workshop 2', 'Panel Discussion', 'Networking', 'Closing Remarks']","solution":"from typing import List, Dict def event_schedule(graph: List[List[int]], sessions: Dict[int, str]) -> List[str]: def dfs(node): nonlocal has_cycle, visited, stack if visited[node] == 1: has_cycle = True return if visited[node] == 2: return visited[node] = 1 # Mark as visiting for neighbor in graph[node]: if not has_cycle: dfs(neighbor) visited[node] = 2 # Mark as visited stack.append(node) n = len(graph) visited = [0] * n stack = [] has_cycle = False for i in range(n): if not has_cycle and visited[i] == 0: dfs(i) if has_cycle: return [] stack.reverse() # The topological order return [sessions[node] for node in stack]"},{"question":"def capitalize_words(text: str) -> str: Capitalizes the first letter of each word in the given text. Words are considered to be sequences of characters separated by spaces, tabs, or newline characters. >>> capitalize_words(\\"hello world\\") 'Hello World' >>> capitalize_words(\\" multiple spaces\\") ' Multiple Spaces' >>> capitalize_words(\\"tabstandnnewlines\\") 'TabstAndnNewlines' >>> capitalize_words(\\"\\") '' >>> capitalize_words(\\"a singleword\\") 'A Singleword' from solution import capitalize_words def test_capitalize_simple_sentence(): assert capitalize_words(\\"hello world\\") == \\"Hello World\\" def test_capitalize_multiple_spaces(): assert capitalize_words(\\" multiple spaces\\") == \\" Multiple Spaces\\" def test_capitalize_tabs_and_newlines(): assert capitalize_words(\\"tabstandnnewlines\\") == \\"TabstAndnNewlines\\" def test_capitalize_empty_string(): assert capitalize_words(\\"\\") == \\"\\" def test_capitalize_single_word(): assert capitalize_words(\\"a singleword\\") == \\"A Singleword\\" def test_capitalize_leading_and_trailing_spaces(): assert capitalize_words(\\" leading and trailing \\") == \\" Leading And Trailing \\" def test_capitalize_mixed_whitespace(): assert capitalize_words(\\" tabstand nnewlines \\") == \\" TabstAnd nNewlines \\"","solution":"def capitalize_words(text): Capitalizes the first letter of each word in the given text. Words are considered to be sequences of characters separated by spaces, tabs, or newline characters. Parameters: text (str): The input string. Returns: str: A new string with the first letter of each word capitalized. import re # Use a regular expression to find words and capitalize their first letters return re.sub(r'(S)(S*)', lambda m: m.group(1).upper() + m.group(2), text)"},{"question":"import string from collections import Counter def most_frequent_word(text: str, stopwords: list) -> str: Identifies the most frequent word in a given text excluding any given list of stop words. >>> most_frequent_word(\\"The quick brown fox jumps over the lazy dog. The dog was not amused.\\", [\\"the\\", \\"was\\", \\"not\\"]) \\"dog\\" >>> most_frequent_word(\\"Apple apple Apple orange banana apple Orange\\", []) \\"apple\\" >>> most_frequent_word(\\"Apple apple Apple orange banana apple Orange\\", [\\"apple\\", \\"orange\\", \\"banana\\"]) \\"\\" >>> most_frequent_word(\\"\\", [\\"the\\", \\"and\\"]) \\"\\" >>> most_frequent_word(\\"The quick brown fox jumps over the lazy dog. The dog was not amused.\\", []) \\"the\\" >>> most_frequent_word(\\"Hello! Hello, hello... world. World??\\", [\\"world\\"]) \\"hello\\"","solution":"import string from collections import Counter def most_frequent_word(text: str, stopwords: list) -> str: Identifies the most frequent word in the given text excluding the stop words. Arguments: text : str : The input text stopwords : list : List of stop words to be excluded Returns: str : the most frequent word not in the stopwords list # Convert the text to lowercase and remove punctuation text = text.lower() text = text.translate(str.maketrans(\\"\\", \\"\\", string.punctuation)) # Split the text into words words = text.split() # Filter words that are not in the stopwords list filtered_words = [word for word in words if word not in stopwords] # Count the occurrence of each word word_counts = Counter(filtered_words) # Return the word with the highest frequency if word_counts: return word_counts.most_common(1)[0][0] return \\"\\""},{"question":"class SegmentTree: def __init__(self, warehouses): Initialize the segment tree for the given warehouses. def build_tree(self, inventory, warehouse_id): Build the tree for a single warehouse's inventory. def update(self, warehouse_id, product_id, value): Update the inventory of a product in a warehouse. def query(self, warehouse_id, product_id): Query the inventory level of a specific product in a warehouse. def restock_query(self, warehouse_id, reorder_points): Calculate the restocking quantities for a warehouse based on reorder points. def build_tree(warehouses): Build and return the Segment Tree from the given warehouses. >>> warehouses = [ [20, 15, 30, 10], [50, 35, 20, 5], [60, 45, 25, 15] ] >>> tree = build_tree(warehouses) def inventory_query(tree, warehouse_id, product_id): Get the current inventory level of a specific product in a chosen warehouse. >>> warehouses = [ [20, 15, 30, 10], [50, 35, 20, 5], [60, 45, 25, 15] ] >>> tree = build_tree(warehouses) >>> inventory_query(tree, 1, 2) 20 >>> inventory_query(tree, 0, 0) 20 >>> inventory_query(tree, 2, 3) 15 def update_inventory(tree, warehouse_id, product_id, quantity): Update the inventory level of a product in a specific warehouse. >>> warehouses = [ [20, 15, 30, 10], [50, 35, 20, 5], [60, 45, 25, 15] ] >>> tree = build_tree(warehouses) >>> update_inventory(tree, 0, 1, -5) >>> inventory_query(tree, 0, 1) 10 >>> update_inventory(tree, 2, 3, 10) >>> inventory_query(tree, 2, 3) 25 def restock_query(tree, warehouse_id, reorder_points): For a specific warehouse, calculate the number of units that need to be reordered for each product based on predefined reorder points. >>> warehouses = [ [20, 15, 30, 10], [50, 35, 20, 5], [60, 45, 25, 15] ] >>> tree = build_tree(warehouses) >>> reorder_points = [25, 20, 30, 10] >>> restock_query(tree, 2, reorder_points) [0, 0, 5, 0] >>> restock_query(tree, 1, reorder_points) [0, 0, 10, 5] >>> reorder_points = [50, 50, 50, 50] >>> restock_query(tree, 0, reorder_points) [30, 35, 20, 40]","solution":"class SegmentTree: def __init__(self, warehouses): self.n = len(warehouses) # Number of warehouses self.m = len(warehouses[0]) # Number of products self.tree = [[0] * (2 * self.m) for _ in range(self.n)] for i in range(self.n): self.build_tree(warehouses[i], i) def build_tree(self, inventory, warehouse_id): for i in range(self.m): self.tree[warehouse_id][self.m + i] = inventory[i] for i in range(self.m - 1, 0, -1): self.tree[warehouse_id][i] = self.tree[warehouse_id][2 * i] + self.tree[warehouse_id][2 * i + 1] def update(self, warehouse_id, product_id, value): pos = product_id + self.m self.tree[warehouse_id][pos] += value while pos > 1: pos //= 2 self.tree[warehouse_id][pos] = self.tree[warehouse_id][2 * pos] + self.tree[warehouse_id][2 * pos + 1] def query(self, warehouse_id, product_id): pos = product_id + self.m return self.tree[warehouse_id][pos] def restock_query(self, warehouse_id, reorder_points): restock = [] for product_id in range(self.m): current_inventory = self.query(warehouse_id, product_id) restock_qty = reorder_points[product_id] - current_inventory if current_inventory < reorder_points[product_id] else 0 restock.append(restock_qty) return restock def build_tree(warehouses): return SegmentTree(warehouses) def inventory_query(tree, warehouse_id, product_id): return tree.query(warehouse_id, product_id) def update_inventory(tree, warehouse_id, product_id, quantity): tree.update(warehouse_id, product_id, quantity) def restock_query(tree, warehouse_id, reorder_points): return tree.restock_query(warehouse_id, reorder_points)"},{"question":"def reverse_words(sentence: str) -> str: Returns the given sentence with words in reversed order, preserving leading, trailing, and multiple spaces between words. Examples: >>> reverse_words(\\"Hello world\\") \\"world Hello\\" >>> reverse_words(\\"The quick brown fox\\") \\"fox brown quick The\\" >>> reverse_words(\\" This is a test \\") \\" test a is This \\" >>> reverse_words(\\"\\") \\"\\" >>> reverse_words(\\"Single\\") \\"Single\\" pass def test_reverse_words_regular_sentence(): assert reverse_words(\\"Hello world\\") == \\"world Hello\\" def test_reverse_words_multiple_spaces(): assert reverse_words(\\" This is a test \\") == \\" test a is This \\" def test_reverse_words_empty_string(): assert reverse_words(\\"\\") == \\"\\" def test_reverse_words_single_word(): assert reverse_words(\\"Single\\") == \\"Single\\" def test_reverse_words_spaces_only(): assert reverse_words(\\" \\") == \\" \\" def test_reverse_words_leading_trailing_spaces(): assert reverse_words(\\" Leading and trailing spaces \\") == \\" spaces trailing and Leading \\"","solution":"def reverse_words(sentence: str) -> str: Returns the given sentence with words in reversed order, preserving leading, trailing, and multiple spaces between words. # Split the sentence based on spaces without stripping leading/trailing spaces words = sentence.split(' ') # Reverse the list of words reversed_words = words[::-1] # Join the reversed list to form the new sentence reversed_sentence = ' '.join(reversed_words) return reversed_sentence"},{"question":"def twisted_fibonacci(a: int, b: int, n: int) -> list[int]: Returns the first \`n\` numbers of a Fibonacci-like sequence starting with integers \`a\` and \`b\`. >>> twisted_fibonacci(3, 5, 5) [3, 5, 8, 13, 21] >>> twisted_fibonacci(1, 2, 7) [1, 2, 3, 5, 8, 13, 21] >>> twisted_fibonacci(0, 1, 10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> twisted_fibonacci(5, 8, 6) [5, 8, 13, 21, 34, 55]","solution":"def twisted_fibonacci(a: int, b: int, n: int) -> list[int]: Returns the first \`n\` numbers of a Fibonacci-like sequence starting with integers \`a\` and \`b\`. if n == 1: return [a] elif n == 2: return [a, b] sequence = [a, b] for i in range(2, n): next_value = sequence[-1] + sequence[-2] sequence.append(next_value) return sequence"},{"question":"from typing import List class Trie: def __init__(self): Initialize your data structure here. pass def insert(self, word: str) -> None: Insert a word into the Trie. Args: word (str): Word to be inserted pass def search(self, prefix: str) -> List[str]: Search in the Trie for words that start with the given prefix. Args: prefix (str): Prefix to search for Returns: List[str]: List of words that start with the prefix pass def autocomplete(trie: Trie, prefix: str) -> List[str]: Takes a Trie object and a prefix, and returns a list of all words in the Trie that start with the given prefix. Args: trie (Trie): An instance of the Trie class prefix (str): The prefix to search for Returns: List[str]: List of words starting with the given prefix pass def test_trie_insert_and_search(): trie = Trie() trie.insert(\\"hello\\") trie.insert(\\"hell\\") trie.insert(\\"heaven\\") trie.insert(\\"heavy\\") assert sorted(trie.search(\\"he\\")) == [\\"heaven\\", \\"heavy\\", \\"hell\\", \\"hello\\"] assert sorted(trie.search(\\"hea\\")) == [\\"heaven\\", \\"heavy\\"] assert sorted(trie.search(\\"hell\\")) == [\\"hell\\", \\"hello\\"] assert trie.search(\\"hi\\") == [] def test_autocomplete(): trie = Trie() trie.insert(\\"dog\\") trie.insert(\\"deer\\") trie.insert(\\"deal\\") assert sorted(autocomplete(trie, \\"de\\")) == [\\"deal\\", \\"deer\\"] assert autocomplete(trie, \\"do\\") == [\\"dog\\"] assert autocomplete(trie, \\"da\\") == [] def test_empty_trie(): trie = Trie() assert trie.search(\\"a\\") == [] assert autocomplete(trie, \\"a\\") == [] def test_no_matching_prefix(): trie = Trie() trie.insert(\\"atom\\") trie.insert(\\"atmosphere\\") assert trie.search(\\"b\\") == [] assert autocomplete(trie, \\"atx\\") == [] def test_edge_cases(): trie = Trie() trie.insert(\\"a\\") trie.insert(\\"ab\\") trie.insert(\\"abc\\") assert sorted(trie.search(\\"a\\")) == [\\"a\\", \\"ab\\", \\"abc\\"] assert sorted(trie.search(\\"ab\\")) == [\\"ab\\", \\"abc\\"] assert trie.search(\\"abc\\") == [\\"abc\\"]","solution":"from typing import List, Dict, Optional class TrieNode: def __init__(self): self.children: Dict[str, TrieNode] = {} self.end_of_word: bool = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: current_node = self.root for char in word: if char not in current_node.children: current_node.children[char] = TrieNode() current_node = current_node.children[char] current_node.end_of_word = True def search(self, prefix: str) -> List[str]: words = [] current_node = self.root for char in prefix: if char not in current_node.children: return words current_node = current_node.children[char] self._find_words(current_node, prefix, words) return words def _find_words(self, node: TrieNode, path: str, words: List[str]) -> None: if node.end_of_word: words.append(path) for char, next_node in node.children.items(): self._find_words(next_node, path + char, words) def autocomplete(trie: Trie, prefix: str) -> List[str]: return trie.search(prefix)"},{"question":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def _search_node(self, prefix): node = self.root for char in prefix: if char not in node.children: return None node = node.children[char] return node class EnhancedTrie(Trie): def __init__(self): super().__init__() def autocomplete(self, prefix: str): Return a list of all words that start with the given prefix. # Implement auto-completion logic def count_words_starting_with(self, prefix: str): Return the number of words that start with the given prefix. # Implement counting logic # Unit Tests def test_autocomplete_no_match(): trie = EnhancedTrie() trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"apricot\\") trie.insert(\\"banana\\") assert trie.autocomplete(\\"z\\") == [] def test_autocomplete_multiple_matches(): trie = EnhancedTrie() trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"apricot\\") trie.insert(\\"banana\\") assert set(trie.autocomplete(\\"ap\\")) == {'app', 'apple', 'apricot'} def test_autocomplete_single_match(): trie = EnhancedTrie() trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"apricot\\") trie.insert(\\"banana\\") assert trie.autocomplete(\\"ban\\") == [\\"banana\\"] def test_count_words_with_no_match(): trie = EnhancedTrie() trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"apricot\\") trie.insert(\\"banana\\") assert trie.count_words_starting_with(\\"z\\") == 0 def test_count_words_with_multiple_matches(): trie = EnhancedTrie() trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"apricot\\") trie.insert(\\"banana\\") assert trie.count_words_starting_with(\\"ap\\") == 3 def test_count_words_with_single_match(): trie = EnhancedTrie() trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"apricot\\") trie.insert(\\"banana\\") assert trie.count_words_starting_with(\\"ban\\") == 1 def test_empty_trie(): trie = EnhancedTrie() assert trie.autocomplete('a') == [] assert trie.count_words_starting_with('a') == 0","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def _search_node(self, prefix): node = self.root for char in prefix: if char not in node.children: return None node = node.children[char] return node class EnhancedTrie(Trie): def __init__(self): super().__init__() def autocomplete(self, prefix: str): Return a list of all words that start with the given prefix. node = self._search_node(prefix) if not node: return [] words = [] self._dfs(node, prefix, words) return words def _dfs(self, node, prefix, words): Depth-first search from the given node to collect all words. if node.is_end_of_word: words.append(prefix) for char, child_node in node.children.items(): self._dfs(child_node, prefix + char, words) def count_words_starting_with(self, prefix: str): Return the number of words that start with the given prefix. node = self._search_node(prefix) if not node: return 0 return self._count_words(node) def _count_words(self, node): Count all words from the given node. count = 1 if node.is_end_of_word else 0 for child_node in node.children.values(): count += self._count_words(child_node) return count"},{"question":"def find_modes(numbers: list[int]) -> list[int]: Find the mode(s) of the list of integers. The mode is the number that appears most frequently in the list. If there are multiple numbers with the same highest frequency, return all of them in ascending order. >>> find_modes([1, 2, 3, 2, 4, 2, 3]) [2] >>> find_modes([4, 4, 1, 1, 2, 2]) [1, 2, 4] >>> find_modes([9]) [9] >>> find_modes([-1, -1, -2, -2]) [-2, -1] >>> find_modes([]) []","solution":"def find_modes(numbers: list[int]) -> list[int]: if not numbers: return [] from collections import Counter count = Counter(numbers) max_freq = max(count.values()) modes = [num for num, freq in count.items() if freq == max_freq] return sorted(modes)"},{"question":"class User: def __init__(self, username: str): self.username = username self.friends = set() def add_friend(self, friend: 'User') -> None: Adds a friend to the user's friend list. >>> alice = User(\\"alice\\") >>> bob = User(\\"bob\\") >>> alice.add_friend(bob) >>> alice.is_friend(bob) True pass def remove_friend(self, friend: 'User') -> None: Removes a friend from the user's friend list. >>> alice = User(\\"alice\\") >>> bob = User(\\"bob\\") >>> alice.add_friend(bob) >>> alice.remove_friend(bob) >>> alice.is_friend(bob) False pass def is_friend(self, friend: 'User') -> bool: Checks if a user has a specific friend. >>> alice = User(\\"alice\\") >>> bob = User(\\"bob\\") >>> alice.is_friend(bob) False pass def test_add_friend(): alice = User(\\"alice\\") bob = User(\\"bob\\") alice.add_friend(bob) assert alice.is_friend(bob) == True def test_remove_friend(): alice = User(\\"alice\\") bob = User(\\"bob\\") alice.add_friend(bob) alice.remove_friend(bob) assert alice.is_friend(bob) == False def test_is_not_friend(): alice = User(\\"alice\\") bob = User(\\"bob\\") assert alice.is_friend(bob) == False def test_add_self_as_friend(): alice = User(\\"alice\\") alice.add_friend(alice) assert alice.is_friend(alice) == False def test_add_same_friend_multiple_times(): alice = User(\\"alice\\") bob = User(\\"bob\\") alice.add_friend(bob) alice.add_friend(bob) assert len(alice.friends) == 1 def test_remove_non_existent_friend(): alice = User(\\"alice\\") bob = User(\\"bob\\") # Removing bob who is not a friend should not raise error try: alice.remove_friend(bob) assert True except: assert False","solution":"class User: def __init__(self, username: str): self.username = username self.friends = set() def add_friend(self, friend: 'User') -> None: if friend is not self and friend not in self.friends: self.friends.add(friend) def remove_friend(self, friend: 'User') -> None: self.friends.discard(friend) def is_friend(self, friend: 'User') -> bool: return friend in self.friends"},{"question":"def final_position(commands: List[str]) -> Tuple[int, int]: Computes the robot's final position after executing a sequence of movements. >>> final_position([\\"UP\\", \\"UP\\", \\"LEFT\\", \\"DOWN\\", \\"RIGHT\\", \\"RIGHT\\"]) (1, 1) >>> final_position([\\"UP\\", \\"UP\\", \\"DOWN\\", \\"DOWN\\", \\"LEFT\\", \\"LEFT\\"]) (-2, 0)","solution":"from typing import List, Tuple def final_position(commands: List[str]) -> Tuple[int, int]: x, y = 0, 0 for command in commands: if command == \\"UP\\": y += 1 elif command == \\"DOWN\\": y -= 1 elif command == \\"LEFT\\": x -= 1 elif command == \\"RIGHT\\": x += 1 return (x, y)"},{"question":"from typing import List, Tuple from collections import deque def minimum_moves(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Return the minimum number of moves required for the robot to reach the destination, or -1 if the destination is unreachable. # Your implementation here","solution":"from typing import List, Tuple from collections import deque def minimum_moves(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Return the minimum number of moves required for the robot to reach the destination, or -1 if the destination is unreachable. if start == end: return 0 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start[0], start[1], 0)]) # The queue will store (row, col, steps) visited = set() visited.add(start) while queue: row, col, steps = queue.popleft() for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited: if grid[new_row][new_col] == 0: if (new_row, new_col) == end: return steps + 1 queue.append((new_row, new_col, steps + 1)) visited.add((new_row, new_col)) return -1"},{"question":"def is_valid_permutation(s: str) -> bool: Determine if the given string s is a valid permutation of parentheses. >>> is_valid_permutation(\\"((()))\\") # True >>> is_valid_permutation(\\"(()())\\") # True >>> is_valid_permutation(\\"())(\\") # False","solution":"def is_valid_permutation(s: str) -> bool: Determine if the given string s is a valid permutation of parentheses. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"def are_permutations(s1: str, s2: str) -> bool: Determines if two strings are permutations of each other. Args: s1 (str): The first string to compare. s2 (str): The second string to compare. Returns: bool: True if the strings are permutations of each other, otherwise False. >>> are_permutations(\\"listen\\", \\"silent\\") True >>> are_permutations(\\"apple\\", \\"pale\\") False >>> are_permutations(\\"abc\\", \\"bac\\") True >>> are_permutations(\\"aabbcc\\", \\"abcabc\\") True","solution":"from collections import Counter def are_permutations(s1: str, s2: str) -> bool: Determines if two strings are permutations of each other. Args: s1 (str): The first string to compare. s2 (str): The second string to compare. Returns: bool: True if the strings are permutations of each other, otherwise False. # If lengths are not the same, they cannot be permutations if len(s1) != len(s2): return False # Count character frequencies for both strings counter_s1 = Counter(s1) counter_s2 = Counter(s2) # Compare the frequency counts return counter_s1 == counter_s2"},{"question":"import heapq def heuristic(a, b): return abs(a[0] - b[0]) + abs(a[1] - b[1]) def get_neighbors(point, maze): x, y = point neighbors = [] for nx, ny in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]: if 0 <= nx < len(maze) and 0 <= ny < len(maze[0]) and maze[nx][ny] == 0: neighbors.append((nx, ny)) return neighbors def a_star_pacman(maze: list[list[int]], start: tuple[int, int], end: tuple[int, int]) -> list[tuple[int, int]]: Implement the A* algorithm to solve the Pac-Man shortest path problem on a grid with passable and impassable cells. Pac-Man starts at a given start cell and needs to reach an end cell, navigating through passable cells while avoiding impassable cells. >>> maze = [ ... [0, 1, 0, 0], ... [0, 1, 0, 1], ... [0, 0, 0, 0], ... [1, 0, 1, 0] ... ] >>> start = (0, 0) >>> end = (3, 3) >>> a_star_pacman(maze, start, end) [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (2, 3), (3, 3)] >>> maze = [ ... [0] ... ] >>> start = (0, 0) >>> end = (0, 0) >>> a_star_pacman(maze, start, end) [(0, 0)] >>> maze = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> start = (0, 0) >>> end = (2, 2) >>> a_star_pacman(maze, start, end) [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]","solution":"import heapq def heuristic(a, b): return abs(a[0] - b[0]) + abs(a[1] - b[1]) def get_neighbors(point, maze): x, y = point neighbors = [] for nx, ny in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]: if 0 <= nx < len(maze) and 0 <= ny < len(maze[0]) and maze[nx][ny] == 0: neighbors.append((nx, ny)) return neighbors def a_star_pacman(maze, start, end): open_set = [] heapq.heappush(open_set, (0, start)) came_from = {} g_score = {start: 0} f_score = {start: heuristic(start, end)} while open_set: current = heapq.heappop(open_set)[1] if current == end: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) path.reverse() return path for neighbor in get_neighbors(current, maze): tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, end) heapq.heappush(open_set, (f_score[neighbor], neighbor)) return []"},{"question":"def are_permutations(str1: str, str2: str) -> bool: Returns True if str1 and str2 are permutations of each other, False otherwise. Raises TypeError if inputs are not strings. >>> are_permutations(\\"abc\\", \\"cba\\") True >>> are_permutations(\\"listen\\", \\"silent\\") True >>> are_permutations(\\"Hello\\", \\"oLleh\\") True >>> are_permutations(\\"apple\\", \\"pale\\") False >>> are_permutations(\\"test\\", \\"\\") False >>> are_permutations(123, \\"321\\") Traceback (most recent call last): ... TypeError: Inputs must be strings >>> are_permutations(\\"abc\\", 123) Traceback (most recent call last): ... TypeError: Inputs must be strings","solution":"def are_permutations(str1, str2): Returns True if str1 and str2 are permutations of each other, False otherwise. if not isinstance(str1, str) or not isinstance(str2, str): raise TypeError(\\"Inputs must be strings\\") # Normalize case str1 = str1.lower() str2 = str2.lower() # If lengths are not equal, they cannot be permutations if len(str1) != len(str2): return False # Count character occurrences char_count1 = {} char_count2 = {} for c in str1: if c in char_count1: char_count1[c] += 1 else: char_count1[c] = 1 for c in str2: if c in char_count2: char_count2[c] += 1 else: char_count2[c] = 1 # Compare character counts return char_count1 == char_count2"},{"question":"def count_unique_products(product_codes: list) -> int: Returns the number of unique product codes in the given list. >>> count_unique_products(['A123', 'B456', 'A123', 'C789', 'B456']) 3 >>> count_unique_products([]) 0 >>> count_unique_products(['A123']) 1 >>> count_unique_products(['A123', 'B456', 'C789', 'D012', 'E345']) 5 >>> count_unique_products(['A123', 'A123', 'A123']) 1 >>> count_unique_products(['a123', 'A123']) # Case-sensitive test 2 >>> count_unique_products(['1', '2', '3', '4', '5', '1', '2', '3']) 5 >>> count_unique_products(['x'*20, 'y'*20, 'z'*20, 'x'*20]) 3 pass","solution":"def count_unique_products(product_codes: list) -> int: Returns the number of unique product codes in the given list. # Use a set to store unique product codes since sets do not allow duplicates unique_codes = set(product_codes) # The number of unique product codes is the size of the set return len(unique_codes)"},{"question":"def fibonacci(n: int) -> int: Calculate the nth Fibonacci number. >>> fibonacci(0) 0 >>> fibonacci(7) 13 >>> fibonacci(10) 55","solution":"def fibonacci(n): Returns the nth Fibonacci number. if n <= 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"class Library: A basic library management system to add, lend, and return books. def __init__(self): Initialize the library with an empty collection of books and an empty record of lent books. self.books = {} self.lent_books = {} def add_book(self, title: str, author: str, quantity: int) -> None: Add books to the library or increase the quantity of existing books. >>> library = Library() >>> library.add_book(\\"1984\\", \\"George Orwell\\", 3) >>> library.books[\\"1984\\"][\\"quantity\\"] == 3 True >>> library.add_book(\\"1984\\", \\"George Orwell\\", 2) >>> library.books[\\"1984\\"][\\"quantity\\"] == 5 True pass def lend_book(self, title: str, user: str) -> str: Lend the specified book to the user. >>> library = Library() >>> library.add_book(\\"1984\\", \\"George Orwell\\", 3) >>> library.lend_book(\\"1984\\", \\"Alice\\") 'Book \\"1984\\" has been lent to Alice.' >>> library.lend_book(\\"1984\\", \\"Bob\\") 'Book \\"1984\\" has been lent to Bob.' >>> library.lend_book(\\"1984\\", \\"Charlie\\") 'Book \\"1984\\" has been lent to Charlie.' >>> library.lend_book(\\"1984\\", \\"Dave\\") 'Book \\"1984\\" is currently not available.' pass def return_book(self, title: str, user: str) -> str: Return the specified book from the user. >>> library = Library() >>> library.add_book(\\"1984\\", \\"George Orwell\\", 3) >>> library.lend_book(\\"1984\\", \\"Alice\\") >>> library.return_book(\\"1984\\", \\"Alice\\") 'Book \\"1984\\" has been returned by Alice.' >>> library.return_book(\\"1984\\", \\"Charlie\\") 'User Charlie has not borrowed book \\"1984\\".' pass # Example Usage if __name__ == \\"__main__\\": library = Library() library.add_book(\\"1984\\", \\"George Orwell\\", 3) library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 2) print(library.lend_book(\\"1984\\", \\"Alice\\")) print(library.lend_book(\\"1984\\", \\"Bob\\")) print(library.return_book(\\"1984\\", \\"Alice\\")) print(library.lend_book(\\"1984\\", \\"Alice\\")) print(library.lend_book(\\"1984\\", \\"Charlie\\")) print(library.return_book(\\"1984\\", \\"Charlie\\")) print(library.lend_book(\\"The Great Gatsby\\", \\"Alice\\"))","solution":"class Library: def __init__(self): self.books = {} self.lent_books = {} def add_book(self, title: str, author: str, quantity: int) -> None: if title in self.books: self.books[title]['quantity'] += quantity else: self.books[title] = { 'author': author, 'quantity': quantity } def lend_book(self, title: str, user: str) -> str: if title not in self.books: return f'Book \\"{title}\\" does not exist in the library.' if self.books[title]['quantity'] == 0: return f'Book \\"{title}\\" is currently not available.' if title in self.lent_books and user in self.lent_books[title]: return f'User {user} already borrowed book \\"{title}\\".' self.books[title]['quantity'] -= 1 if title not in self.lent_books: self.lent_books[title] = [] self.lent_books[title].append(user) return f'Book \\"{title}\\" has been lent to {user}.' def return_book(self, title: str, user: str) -> str: if title not in self.lent_books or user not in self.lent_books[title]: return f'User {user} has not borrowed book \\"{title}\\".' self.lent_books[title].remove(user) if len(self.lent_books[title]) == 0: del self.lent_books[title] self.books[title]['quantity'] += 1 return f'Book \\"{title}\\" has been returned by {user}.'"},{"question":"from typing import List def minRefuelStops(target: int, startFuel: int, stations: List[List[int]]) -> int: Calculate the minimum number of refueling stops required to reach the target distance. >>> minRefuelStops(100, 10, [[10, 60], [20, 30], [30, 30], [60, 40]]) == 2 >>> minRefuelStops(100, 50, [[25, 50], [50, 25]]) == 1 >>> minRefuelStops(1000, 100, [[100, 100], [200, 200], [300, 300], [400, 400], [500, 500], [600, 600], [700, 700], [800, 800], [900, 900]]) == 4 >>> minRefuelStops(200, 100, [[50, 100], [100, 100], [150, 100]]) == 1 >>> minRefuelStops(100, 1, [[10, 100]]) == -1","solution":"import heapq from typing import List def minRefuelStops(target: int, startFuel: int, stations: List[List[int]]) -> int: if startFuel >= target: return 0 max_heap = [] stations.append([target, 0]) fuel_at_last = startFuel refuel_stops = 0 prev = 0 for distance, fuel in stations: fuel_at_last -= distance - prev while max_heap and fuel_at_last < 0: fuel_at_last += -heapq.heappop(max_heap) refuel_stops += 1 if fuel_at_last < 0: return -1 heapq.heappush(max_heap, -fuel) prev = distance return refuel_stops"},{"question":"def are_anagrams(title1: str, title2: str) -> bool: Determine if two book titles can be made anagrams of each other by rearranging the characters. :param title1: First book title :param title2: Second book title :return: True if the titles can be made anagrams, False otherwise >>> are_anagrams(\\"deeR predator\\", \\"derEd partoer\\") True >>> are_anagrams(\\"Harry Potter\\", \\"Percy Jackson\\") False >>> are_anagrams(\\"Listen\\", \\"Silent\\") True >>> are_anagrams(\\"LiStEn\\", \\"SiLeNt\\") True >>> are_anagrams(\\"dormitory!\\", \\"dirty room!\\") True >>> are_anagrams(\\"conversation\\", \\"voices rant on\\") True >>> are_anagrams(\\"hello\\", \\"helloo\\") False >>> are_anagrams(\\"?!#@\\", \\"!?#@\\") True >>> are_anagrams(\\"12345\\", \\"54321\\") True >>> are_anagrams(\\"12345\\", \\"543210\\") False","solution":"from collections import Counter def are_anagrams(title1: str, title2: str) -> bool: Determine if two book titles can be made anagrams of each other. :param title1: First book title :param title2: Second book title :return: True if the titles can be made anagrams, False otherwise # Normalize both titles by converting to lowercase and removing spaces title1 = ''.join(title1.lower().split()) title2 = ''.join(title2.lower().split()) # Use Counter to count the frequency of each character return Counter(title1) == Counter(title2)"},{"question":"from typing import List def max_subsequence_sum(nums: List[int]) -> int: Write a function that takes in a list of integers and returns the maximum sum of any contiguous subsequence within the list. >>> max_subsequence_sum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> max_subsequence_sum([1]) 1 >>> max_subsequence_sum([5,4,-1,7,8]) 23 >>> max_subsequence_sum([-1,-2,-3,-4]) -1","solution":"def max_subsequence_sum(nums): Returns the maximum sum of any contiguous subsequence within the list. Uses Kadane's Algorithm to achieve the solution in O(N) time complexity. max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def is_prime(n: int) -> bool: Returns True if the integer n is a prime number, otherwise False. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(1) False >>> is_prime(0) False","solution":"def is_prime(n): Returns True if the integer n is a prime number, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while (i * i) <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"def optimized_binary_search(arr: list, target) -> int: Perform binary search on the sorted list \`arr\` to find the \`target\`. Parameters: arr (list): A sorted list of elements (integers, floating-point numbers, or strings). target : The element to search for within the list. Returns: int: The index of the target element if found; otherwise, -1. >>> optimized_binary_search([1, 3, 5, 7, 9], 7) 3 >>> optimized_binary_search([1.1, 2.2, 3.3, 4.4], 3.3) 2 >>> optimized_binary_search([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], \\"banana\\") 1 >>> optimized_binary_search([10, 20, 30], 25) -1 >>> optimized_binary_search([], 5) -1","solution":"def optimized_binary_search(arr, target): Perform binary search on the sorted list \`arr\` to find the \`target\`. Parameters: arr (list): A sorted list of elements (integers, floating-point numbers, or strings). target : The element to search for within the list. Returns: int: The index of the target element if found; otherwise, -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 mid_value = arr[mid] if mid_value == target: return mid elif mid_value < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def summarize_signals(signals: list[str]) -> dict[str, int]: Decode the sensor signals and compute the summary for each signal type. Parameters: signals (list[str]): A list of signal strings where each character alternates between a signal type (an uppercase letter) and a numeric value (0-9). Returns: dict[str, int]: A dictionary where keys are signal types and values are the total sums of their numeric values. Example: >>> signals = [\\"A2B3C4\\", \\"A1B2C3\\", \\"D5E2\\"] >>> summarize_signals(signals) {'A': 3, 'B': 5, 'C': 7, 'D': 5, 'E': 2}","solution":"def summarize_signals(signals: list[str]) -> dict[str, int]: summary = {} for signal in signals: for i in range(0, len(signal), 2): signal_type = signal[i] signal_value = int(signal[i+1]) if signal_type in summary: summary[signal_type] += signal_value else: summary[signal_type] = signal_value return summary"},{"question":"# Coding Assessment Question Context A software company needs your help to enhance their utility for calculating the nth Fibonacci number. The current algorithm is a naive recursive implementation which becomes extremely inefficient for large values of n. They aim to improve this by using a more efficient approach. Task Write a function \`efficient_fibonacci(n: int) -> int\` to compute the nth Fibonacci number efficiently. Use an iterative approach or matrix exponentiation to ensure the algorithm runs in optimal time for large n. Input/Output Format * **Input**: A non-negative integer \`n\` where \`n >= 0\`. * **Output**: An integer representing the nth Fibonacci number. Constraints 1. Ensure the function handles the input for both small and large values of \`n\` efficiently. 2. Raise a \`ValueError\` if \`n\` is negative. 3. Optimize the performance to handle very large values up to at least \`n = 10^5\`. Example >>> efficient_fibonacci(0) 0 >>> efficient_fibonacci(1) 1 >>> efficient_fibonacci(10) 55 >>> efficient_fibonacci(50) 12586269025 >>> efficient_fibonacci(-1) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer def efficient_fibonacci(n: int) -> int: Returns the nth Fibonacci number using an iterative approach. Raises a ValueError if n is negative. >>> efficient_fibonacci(0) 0 >>> efficient_fibonacci(1) 1 >>> efficient_fibonacci(10) 55 >>> efficient_fibonacci(50) 12586269025 >>> efficient_fibonacci(-1) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer pass def test_efficient_fibonacci_zero(): assert efficient_fibonacci(0) == 0 def test_efficient_fibonacci_one(): assert efficient_fibonacci(1) == 1 def test_efficient_fibonacci_small(): assert efficient_fibonacci(2) == 1 assert efficient_fibonacci(3) == 2 assert efficient_fibonacci(4) == 3 assert efficient_fibonacci(10) == 55 def test_efficient_fibonacci_large(): assert efficient_fibonacci(50) == 12586269025 assert efficient_fibonacci(100) == 354224848179261915075 def test_efficient_fibonacci_very_large(): # To test performance for large n assert efficient_fibonacci(100000) # We do not need the exact result for the performance test def test_negative_input(): try: efficient_fibonacci(-1) except ValueError as e: assert str(e) == \\"Input must be a non-negative integer\\"","solution":"def efficient_fibonacci(n: int) -> int: Returns the nth Fibonacci number using an iterative approach. Raises a ValueError if n is negative. if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") # Special cases if n == 0: return 0 if n == 1: return 1 # Start with the first two Fibonacci numbers a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"from typing import List def unique_substrings(s: str, length: int) -> List[str]: Find all unique substrings of a specified length within the given string. >>> unique_substrings(\\"hello\\", 2) [\\"he\\", \\"el\\", \\"ll\\", \\"lo\\"] >>> unique_substrings(\\"aaaa\\", 2) [\\"aa\\"] def main(): Main function to accept a string and a substring length from the user, then print the unique substrings. s = input(\\"Enter a string: \\") length = int(input(\\"Enter the substring length: \\")) result = unique_substrings(s, length) print(result)","solution":"from typing import List def unique_substrings(s: str, length: int) -> List[str]: Returns a list of all unique substrings of the given length from the input string. if length > len(s): return [] substrings = set() for i in range(len(s) - length + 1): substring = s[i:i + length] substrings.add(substring) return list(substrings) def main(): s = input(\\"Enter a string: \\") length = int(input(\\"Enter the substring length: \\")) result = unique_substrings(s, length) print(result)"},{"question":"def compute_catalan_number(n: int) -> int: Compute the nth Catalan number. Args: n (int): the index of the Catalan number to compute Returns: int: the nth Catalan number Raises: TypeError: if \`n\` is not an integer ValueError: if \`n\` is negative Examples: >>> compute_catalan_number(0) 1 >>> compute_catalan_number(1) 1 >>> compute_catalan_number(2) 2 >>> compute_catalan_number(3) 5 >>> compute_catalan_number(4) 14 >>> compute_catalan_number(10) 16796 >>> compute_catalan_number(10000) # correct value for this large index <large_number> >>> compute_catalan_number(-1) Traceback (most recent call last): ... ValueError: n must be a non-negative integer. >>> compute_catalan_number(2.5) Traceback (most recent call last): ... TypeError: n must be an integer.","solution":"def compute_catalan_number(n): Compute the nth Catalan number. Args: n (int): the index of the Catalan number to compute Returns: int: the nth Catalan number Raises: TypeError: if \`n\` is not an integer ValueError: if \`n\` is negative if not isinstance(n, int): raise TypeError(\\"n must be an integer.\\") if n < 0: raise ValueError(\\"n must be a non-negative integer.\\") if n == 0: return 1 # Initialize a list to store computed Catalan numbers catalan = [0] * (n + 1) catalan[0] = 1 for i in range(1, n + 1): for j in range(i): catalan[i] += catalan[j] * catalan[i - 1 - j] return catalan[n]"},{"question":"def longest_increasing_subsequence(sequence: List[int]) -> int: Identify the length of the longest strictly increasing subsequence from a given list of integers using dynamic programming. >>> longest_increasing_subsequence([10, 20, 10, 30, 40, 50]) 5 >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) 3 >>> longest_increasing_subsequence([3, 2, 1]) 1 >>> longest_increasing_subsequence([50, 3, 10, 7, 40, 80]) 4 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([5, 5, 5, 5]) 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1","solution":"def longest_increasing_subsequence(sequence): if not sequence: return 0 n = len(sequence) dp = [1] * n # dp[i] will be the length of LIS ending at index i for i in range(1, n): for j in range(i): if sequence[i] > sequence[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"class Graph: def __init__(self): self.adj_list = {} def add_vertex(self, vertex): Adds a vertex to the graph. >>> g = Graph() >>> g.add_vertex(1) >>> 1 in g.adj_list True pass def add_edge(self, vertex1, vertex2): Adds an edge to the graph. >>> g = Graph() >>> g.add_vertex(1) >>> g.add_vertex(2) >>> g.add_edge(1, 2) >>> g.adj_list[1] [2] >>> g.adj_list[2] [1] pass def are_connected(self, vertex1, vertex2): Checks if two vertices are connected. >>> g = Graph() >>> g.add_vertex(1) >>> g.add_vertex(2) >>> g.add_vertex(3) >>> g.add_edge(1, 2) >>> g.add_edge(2, 3) >>> g.are_connected(1, 3) True >>> g.are_connected(1, 4) False pass","solution":"class Graph: def __init__(self): self.adj_list = {} def add_vertex(self, vertex): if vertex not in self.adj_list: self.adj_list[vertex] = [] def add_edge(self, vertex1, vertex2): if vertex1 in self.adj_list and vertex2 in self.adj_list: self.adj_list[vertex1].append(vertex2) self.adj_list[vertex2].append(vertex1) def are_connected(self, vertex1, vertex2): if vertex1 not in self.adj_list or vertex2 not in self.adj_list: return False visited = set() stack = [vertex1] while stack: current = stack.pop() if current == vertex2: return True if current not in visited: visited.add(current) stack.extend([neighbor for neighbor in self.adj_list[current] if neighbor not in visited]) return False"},{"question":"def reverse_words(sentence: str) -> str: Returns a new string with the words in reversed order. >>> reverse_words(\\"hello world\\") \\"world hello\\" >>> reverse_words(\\"The quick brown fox\\") \\"fox brown quick The\\" >>> reverse_words(\\" space at ends \\") \\"ends at space\\" def is_palindrome(text: str) -> bool: Returns True if text is a palindrome, False otherwise. Ignores case, spaces, and punctuation. >>> is_palindrome(\\"A man a plan a canal Panama\\") True >>> is_palindrome(\\"Hello\\") False >>> is_palindrome(\\"No lemon, no melon\\") True","solution":"import re def reverse_words(sentence: str) -> str: Returns a new string with the words in reversed order. if not isinstance(sentence, str) or not sentence.strip(): raise ValueError(\\"Input must be a non-empty string\\") words = sentence.split() reversed_sentence = ' '.join(reversed(words)) return reversed_sentence def is_palindrome(text: str) -> bool: Returns True if text is a palindrome, False otherwise. Ignores case, spaces, and punctuation. if not isinstance(text, str) or not text.strip(): raise ValueError(\\"Input must be a non-empty string\\") # Remove non-alphanumeric characters, convert to lowercase clean_text = re.sub(r'[^A-Za-z0-9]', '', text).lower() reversed_text = clean_text[::-1] return clean_text == reversed_text"},{"question":"class ListOperations: @staticmethod def reverse_list(nums): Reverses the order of the list. >>> ListOperations.reverse_list([1, 2, 3, 4]) [4, 3, 2, 1] >>> ListOperations.reverse_list([1]) [1] @staticmethod def sum_of_elements(nums): Calculates the sum of all elements in the list. >>> ListOperations.sum_of_elements([1, 2, 3, 4]) 10 >>> ListOperations.sum_of_elements([0, 0, 0]) 0 @staticmethod def filter_odd(nums): Returns a list containing only the odd numbers from the original list. >>> ListOperations.filter_odd([1, 2, 3, 4, 5]) [1, 3, 5] >>> ListOperations.filter_odd([2, 4, 6]) [] @staticmethod def find_max(nums): Finds the maximum element in the list. >>> ListOperations.find_max([1, 2, 3, 4]) 4 >>> ListOperations.find_max([10]) 10 @staticmethod def unique_elements(nums): Returns a list of unique elements in the original list, preserving the order of their first appearance. >>> ListOperations.unique_elements([1, 2, 2, 3, 3, 4]) [1, 2, 3, 4] >>> ListOperations.unique_elements([1, 1, 1, 1]) [1]","solution":"class ListOperations: @staticmethod def reverse_list(nums): Reverses the order of the list. return nums[::-1] @staticmethod def sum_of_elements(nums): Calculates the sum of all elements in the list. return sum(nums) @staticmethod def filter_odd(nums): Returns a list containing only the odd numbers from the original list. return [num for num in nums if num % 2 != 0] @staticmethod def find_max(nums): Finds the maximum element in the list. return max(nums) @staticmethod def unique_elements(nums): Returns a list of unique elements in the original list, preserving the order of their first appearance. seen = set() unique = [] for num in nums: if num not in seen: unique.append(num) seen.add(num) return unique"},{"question":"import math class SimpleNeuralNetwork: def sigmoid(self, x): return 1 / (1 + math.exp(-x)) def feedforward(self, weights, biases, input_vector): Computes the output of the network for a given input by applying the weights and biases. Args: weights (List[List[float]]): 2D list representing the network's weights. biases (List[float]): List representing the network's biases. input_vector (List[float]): Input data vector. Returns: List[float]: Output probabilities for each digit. Example: >>> nn = SimpleNeuralNetwork() >>> nn.feedforward([[0.5, -0.2], [0.3, 0.8]], [0.1, -0.1], [1, 0]) # Output: [0.475, 0.549] pass def train(self, weights, biases, training_samples, epochs, learning_rate): Updates the weights and biases based on the difference between the predicted and actual labels. Args: weights (List[List[float]]): 2D list representing the network's weights. biases (List[float]): List representing the network's biases. training_samples (List[Tuple[List[float], List[float]]]): List of training samples. epochs (int): Number of training epochs. learning_rate (float): Learning rate. Returns: Tuple[List[List[float]], List[float]]: Updated weights and biases. Example: >>> nn = SimpleNeuralNetwork() >>> weights, biases = nn.train([[0.5, -0.2], [0.3, 0.8]], [0.1, -0.1], [( [1, 0], [1, 0] ), ( [0, 1], [0, 1] )], 3, 0.01) >>> print(weights, biases) pass def main(): Demonstrates the training and prediction process. pass","solution":"import math class SimpleNeuralNetwork: def sigmoid(self, x): return 1 / (1 + math.exp(-x)) def sigmoid_derivative(self, x): return x * (1 - x) def feedforward(self, weights, biases, input_vector): hidden_layer_input = [sum(i*w + b for i, w, b in zip(input_vector, layer, biases)) for layer in weights] hidden_layer_output = [self.sigmoid(x) for x in hidden_layer_input] return hidden_layer_output def train(self, weights, biases, training_samples, epochs, learning_rate): for epoch in range(epochs): for input_vector, true_output in training_samples: hidden_layer_output = self.feedforward(weights, biases, input_vector) output_error = [true - pred for true, pred in zip(true_output, hidden_layer_output)] output_delta = [error * self.sigmoid_derivative(out) for error, out in zip(output_error, hidden_layer_output)] for i in range(len(weights)): for j in range(len(weights[0])): weights[i][j] += learning_rate * output_delta[i] * input_vector[j] biases[i] += learning_rate * output_delta[i] return weights, biases def main(): training_samples = [([1, 0], [1, 0]), ([0, 1], [0, 1]), ([1, 1], [1, 1]), ([0, 0], [0, 0])] weights = [[0.5, -0.2], [0.3, 0.8]] biases = [0.1, -0.1] nn = SimpleNeuralNetwork() epochs = 3 learning_rate = 0.01 weights, biases = nn.train(weights, biases, training_samples, epochs, learning_rate) test_sample = [1, 0] output = nn.feedforward(weights, biases, test_sample) print(f\\"Output probabilities for the test sample: {output}\\") print(f\\"Weights that have been trained: {weights}\\") print(f\\"Biases that have been trained: {biases}\\") if __name__ == \\"__main__\\": main()"},{"question":"def calculate_edit_distance(str1: str, str2: str) -> int: Computes the Levenshtein distance (edit distance) between two strings. Parameters: - str1 (str): First string - str2 (str): Second string Returns: - int: The edit distance between the two strings Example: >>> calculate_edit_distance(\\"kitten\\", \\"sitting\\") 3 >>> calculate_edit_distance(\\"abc\\", \\"abc\\") 0","solution":"def calculate_edit_distance(str1, str2): Computes the Levenshtein distance (edit distance) between two strings. Parameters: - str1 (str): First string - str2 (str): Second string Returns: - int: The edit distance between the two strings len1, len2 = len(str1), len(str2) # Initialize a 2D array to store the distances dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] # Base cases: dp[i][0] and dp[0][j] for i in range(len1 + 1): dp[i][0] = i for j in range(len2 + 1): dp[0][j] = j # Fill dp array for i in range(1, len1 + 1): for j in range(1, len2 + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1] # Substitution ) return dp[len1][len2]"},{"question":"import numpy as np class MatrixOperations: @staticmethod def inverse(matrix): Returns the inverse of the given matrix if it is non-singular, otherwise returns None. :param matrix: A numpy array representing the matrix to be inverted. :return: Inverse of the matrix or None if the matrix is singular. # Your code here @staticmethod def determinant(matrix): Returns the determinant of the given matrix. :param matrix: A numpy array representing the matrix for which determinant is computed. :return: Determinant of the matrix. # Your code here","solution":"import numpy as np class MatrixOperations: @staticmethod def inverse(matrix): Returns the inverse of the given matrix if it is non-singular, otherwise returns None. :param matrix: A numpy array representing the matrix to be inverted. :return: Inverse of the matrix or None if the matrix is singular. try: inv_matrix = np.linalg.inv(matrix) return inv_matrix except np.linalg.LinAlgError: return None @staticmethod def determinant(matrix): Returns the determinant of the given matrix. :param matrix: A numpy array representing the matrix for which determinant is computed. :return: Determinant of the matrix. return np.linalg.det(matrix)"},{"question":"from typing import List class Grid: def __init__(self, grid: List[List[int]]): self.grid = grid self.rows = len(grid) self.cols = len(grid[0]) def min_cost_path(self) -> int: Compute and return the minimum cost path from the top-left corner to the bottom-right corner while avoiding obstacles. >>> grid = Grid([ ... [1, 2, 3], ... [4, -1, 6], ... [7, 8, 9] ... ]) >>> grid.min_cost_path() 21 >>> grid.add_obstacle(2, 1) >>> grid.min_cost_path() -1 >>> grid.clear_path(1, 1, 5) >>> grid.min_cost_path() 21 pass def add_obstacle(self, x: int, y: int) -> None: Mark a cell as an obstacle by setting its cost to -1. pass def clear_path(self, x: int, y: int, cost: int) -> None: Remove an obstacle from a cell by setting its cost to a valid integer value. pass","solution":"from heapq import heappop, heappush from typing import List class Grid: def __init__(self, grid: List[List[int]]): self.grid = grid self.rows = len(grid) self.cols = len(grid[0]) def min_cost_path(self) -> int: if not self.grid or self.grid[0][0] == -1 or self.grid[self.rows-1][self.cols-1] == -1: return -1 dirs = [(0, 1), (1, 0)] heap = [(self.grid[0][0], 0, 0)] costs = {(0, 0): self.grid[0][0]} while heap: current_cost, x, y = heappop(heap) if (x, y) == (self.rows - 1, self.cols - 1): return current_cost for dx, dy in dirs: nx, ny = x + dx, y + dy if 0 <= nx < self.rows and 0 <= ny < self.cols and self.grid[nx][ny] != -1: new_cost = current_cost + self.grid[nx][ny] if (nx, ny) not in costs or new_cost < costs[(nx, ny)]: costs[(nx, ny)] = new_cost heappush(heap, (new_cost, nx, ny)) return -1 def add_obstacle(self, x: int, y: int) -> None: if 0 <= x < self.rows and 0 <= y < self.cols: self.grid[x][y] = -1 def clear_path(self, x: int, y: int, cost: int) -> None: if 0 <= x < self.rows and 0 <= y < self.cols: self.grid[x][y] = cost"},{"question":"class ListNode: def __init__(self, key): self.key = key self.next = None def hasCycle(head: ListNode) -> bool: Detect if a singly linked list has a cycle. >>> head = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(3) >>> head.next = node2 >>> node2.next = node3 >>> node3.next = node2 # Creating cycle >>> hasCycle(head) True >>> node3.next = None >>> hasCycle(head) False pass def cycleLength(head: ListNode) -> int: Determine the length of the cycle if one exists in the linked list. >>> head = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(3) >>> head.next = node2 >>> node2.next = node3 >>> node3.next = node2 # Creating cycle >>> cycleLength(head) 2 >>> node3.next = None >>> cycleLength(head) 0 pass def removeCycle(head: ListNode) -> None: Remove the cycle from the linked list if it exists. >>> head = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(3) >>> head.next = node2 >>> node2.next = node3 >>> node3.next = node2 # Creating cycle >>> hasCycle(head) True >>> removeCycle(head) >>> hasCycle(head) False pass # Example usage: # Create nodes head = ListNode(3) node2 = ListNode(2) node3 = ListNode(0) node4 = ListNode(-4) # Link nodes to form a cycle: 3 -> 2 -> 0 -> -4 -> 2 head.next = node2 node2.next = node3 node3.next = node4 node4.next = node2 print(hasCycle(head)) # Should output: True print(cycleLength(head)) # Should output: 3 removeCycle(head) print(hasCycle(head)) # Should output: False","solution":"class ListNode: def __init__(self, key): self.key = key self.next = None def hasCycle(head: ListNode) -> bool: slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def cycleLength(head: ListNode) -> int: slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected, determine its length current = slow length = 1 while current.next != slow: current = current.next length += 1 return length return 0 def removeCycle(head: ListNode) -> None: slow, fast = head, head cycle_detected = False while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: cycle_detected = True break if not cycle_detected: return # No cycle # Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next # \`slow\` is now at the start of the cycle # Find the node just before the start of the cycle while fast.next != slow: fast = fast.next # Remove the cycle fast.next = None"},{"question":"def calculate_area(base: float, height: float) -> float: Calculates the area of a right-angled triangle given the lengths of its two perpendicular sides. Parameters: base (float): The length of one of the perpendicular sides of the triangle in meters. height (float): The length of the other perpendicular side of the triangle in meters. Returns: float: The area of the right-angled triangle in square meters. >>> calculate_area(10, 5) 25.0 >>> calculate_area(0, 5) 0.0 >>> calculate_area(3.3, 4.4) 7.26","solution":"def calculate_area(base: float, height: float) -> float: Calculates the area of a right-angled triangle given the lengths of its two perpendicular sides. Parameters: base (float): The length of one of the perpendicular sides of the triangle in meters. height (float): The length of the other perpendicular side of the triangle in meters. Returns: float: The area of the right-angled triangle in square meters. return 0.5 * base * height"},{"question":"def fibonacci_primes(n: int) -> list: Compute all Fibonacci prime numbers that do not exceed a given integer n. >>> fibonacci_primes(50) [2, 3, 5, 13] >>> fibonacci_primes(1000) [2, 3, 5, 13, 89, 233] >>> fibonacci_primes(10) [2, 3, 5] >>> fibonacci_primes(100) [2, 3, 5, 13, 89] >>> fibonacci_primes(1) []","solution":"def fibonacci_primes(n: int) -> list: def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True fib_primes = [] a, b = 0, 1 while a <= n: if is_prime(a): fib_primes.append(a) a, b = b, a + b return fib_primes"},{"question":"def basic_calculator(expression: str) -> int: Evaluates a simple arithmetic expression with +, -, *, and /. >>> basic_calculator(\\"3 + 5 * 2\\") 13 >>> basic_calculator(\\"10 + 2 * 6\\") 22 >>> basic_calculator(\\"100 * 2 + 12\\") 212 >>> basic_calculator(\\"100 * ( 2 + 12 )\\") 1400 >>> basic_calculator(\\"100 * ( 2 + 12 ) / 14\\") 100","solution":"def basic_calculator(expression: str) -> int: Evaluates a simple arithmetic expression. def operate(op, second, first): if op == '+': return first + second elif op == '-': return first - second elif op == '*': return first * second elif op == '/': return int(first / second) # python behaves like truncating towards zero for negative # Removing all whitespaces from the expression to handle the simpler string expression = expression.replace(\\" \\", \\"\\") stack = [] current_number = 0 current_operator = '+' i = 0 while i < len(expression): char = expression[i] if char.isdigit(): current_number = current_number * 10 + int(char) # if char is an operator or it's the last character in the expression if char in \\"+-*/\\" or i == len(expression) - 1: if current_operator == '+': stack.append(current_number) elif current_operator == '-': stack.append(-current_number) elif current_operator in \\"*/\\": last = stack.pop() stack.append(operate(current_operator, current_number, last)) current_operator = char current_number = 0 i += 1 return sum(stack)"},{"question":"def max_difference_linear(arr: list) -> int: Finds the maximum difference between any two elements in the list where the smaller element appears before the larger element using a linear-time algorithm. :param arr: A list of integers. :return: The maximum difference. :raises ValueError: If the list has fewer than 2 elements. >>> max_difference_linear([2, 3, 10, 2, 4, 8, 1]) 8 >>> max_difference_linear([7, 9, 5, 6, 3, 2]) 2 >>> max_difference_linear([1]) Traceback (most recent call last): ... ValueError: the list must have at least 2 elements pass def max_difference_naive(arr: list) -> int: Finds the maximum difference between any two elements in the list where the smaller element appears before the larger element using a naive quadratic-time algorithm. :param arr: A list of integers. :return: The maximum difference. :raises ValueError: If the list has fewer than 2 elements. >>> max_difference_naive([2, 3, 10, 2, 4, 8, 1]) 8 >>> max_difference_naive([7, 9, 5, 6, 3, 2]) 2 >>> max_difference_naive([1]) Traceback (most recent call last): ... ValueError: the list must have at least 2 elements pass","solution":"def max_difference_linear(arr: list) -> int: Finds the maximum difference between any two elements in the list where the smaller element appears before the larger element using a linear-time algorithm. :param arr: A list of integers. :return: The maximum difference. :raises ValueError: If the list has fewer than 2 elements. if len(arr) < 2: raise ValueError(\\"the list must have at least 2 elements\\") min_element = arr[0] max_diff = arr[1] - arr[0] for i in range(1, len(arr)): if arr[i] - min_element > max_diff: max_diff = arr[i] - min_element if arr[i] < min_element: min_element = arr[i] return max_diff def max_difference_naive(arr: list) -> int: Finds the maximum difference between any two elements in the list where the smaller element appears before the larger element using a naive quadratic-time algorithm. :param arr: A list of integers. :return: The maximum difference. :raises ValueError: If the list has fewer than 2 elements. if len(arr) < 2: raise ValueError(\\"the list must have at least 2 elements\\") max_diff = float('-inf') n = len(arr) for i in range(n): for j in range(i + 1, n): if arr[j] - arr[i] > max_diff: max_diff = arr[j] - arr[i] return max_diff"},{"question":"def normalize_sequence(nums: list) -> list: Normalize the numbers in the input list to be between 0 and 1. Args: - nums (list): A list of integers or floats. Returns: - list: A list of normalized numbers.","solution":"def normalize_sequence(nums: list) -> list: Normalize the numbers in the input list to be between 0 and 1. Args: - nums (list): A list of integers or floats. Returns: - list: A list of normalized numbers. min_value = min(nums) max_value = max(nums) if min_value == max_value: # If all elements are the same, return a list of zeros return [0.0] * len(nums) return [(x - min_value) / (max_value - min_value) for x in nums]"},{"question":"def check_palindromic_permutation(s: str) -> bool: Check if any permutation of the characters in the input string is a palindrome. >>> check_palindromic_permutation(\\"civic\\") True >>> check_palindromic_permutation(\\"ivicc\\") True >>> check_palindromic_permutation(\\"hello\\") False >>> check_palindromic_permutation(\\"aabbcc\\") True","solution":"def check_palindromic_permutation(s: str) -> bool: from collections import Counter count = Counter(s) odd_count = sum(1 for val in count.values() if val % 2 != 0) return odd_count <= 1"},{"question":"def is_balanced_sum(s: str, k: int) -> bool: Determines if the given numeric string \`s\` has a balanced sum for any valid length \`k\`. A numeric string \`s\` is said to have a balanced sum if the sum of its digits is the same for every possible substring of length \`k\`. Args: s (str): A string consisting of numeric characters (1-9). k (int): An integer representing the length of the substrings. Returns: bool: True if all possible substrings of length \`k\` have the same sum, False otherwise. >>> is_balanced_sum(\\"123123\\", 3) True >>> is_balanced_sum(\\"1234512345\\", 5) True >>> is_balanced_sum(\\"111222\\", 2) False","solution":"def is_balanced_sum(s: str, k: int) -> bool: Checks if every possible substring of length \`k\` in the given numeric string \`s\` has the same sum of digits. if k == 1: return True # Calculate the sum of the first substring of length \`k\` first_sum = sum(int(s[i]) for i in range(k)) # Traverse the string and compare sums of other substrings of length \`k\` for i in range(1, len(s) - k + 1): current_sum = sum(int(s[j]) for j in range(i, i + k)) if current_sum != first_sum: return False return True"},{"question":"def generate_greeting(name: str, current_time: str) -> str: Generates a personalized greeting based on the current time. Parameters: - name (str): The name of the user. - current_time (str): The current time in \\"HH:MM\\" 24-hour format. Returns: A string that is a personalized greeting based on the time of day, or \\"Invalid time format\\" for invalid input. >>> generate_greeting(\\"Alice\\", \\"06:30\\") 'Good Morning, Alice!' >>> generate_greeting(\\"Bob\\", \\"14:45\\") 'Good Afternoon, Bob!' >>> generate_greeting(\\"Charlie\\", \\"18:20\\") 'Good Evening, Charlie!' >>> generate_greeting(\\"Dana\\", \\"22:05\\") 'Good Night, Dana!' >>> generate_greeting(\\"Eve\\", \\"25:00\\") 'Invalid time format' >>> generate_greeting(\\"Frank\\", \\"03:15\\") 'Good Night, Frank!' >>> generate_greeting(\\"Gracie\\", \\"11:59\\") 'Good Morning, Gracie!'","solution":"def generate_greeting(name: str, current_time: str) -> str: Generates a personalized greeting based on the current time. Parameters: - name (str): The name of the user. - current_time (str): The current time in \\"HH:MM\\" 24-hour format. Returns: A string that is a personalized greeting based on the time of day, or \\"Invalid time format\\" for invalid input. try: hours, minutes = map(int, current_time.split(\\":\\")) if not (0 <= hours < 24 and 0 <= minutes < 60): return \\"Invalid time format\\" if 5 <= hours <= 11: greeting = \\"Good Morning\\" elif 12 <= hours <= 16: greeting = \\"Good Afternoon\\" elif 17 <= hours <= 20: greeting = \\"Good Evening\\" else: # This includes hours which fall between 21:00 and 04:59 greeting = \\"Good Night\\" return f\\"{greeting}, {name}!\\" except (ValueError, IndexError): return \\"Invalid time format\\""},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_k_nodes(head: 'ListNode', k: int) -> 'ListNode': Reverse the nodes of the given linked list k at a time and return its modified list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as is. You may not alter the values in the nodes, only the nodes themselves may be changed. Args: head: The head of the linked list. k: Number of nodes to be reversed at a time. Returns: The head of the modified list. pass # Helper function to convert linked list to python list def linked_list_to_list(head: ListNode) -> list: result = [] current = head while current: result.append(current.val) current = current.next return result # Helper function to convert list to linked list def list_to_linked_list(values: list) -> ListNode: if not values: return None head = ListNode(values[0]) current = head for val in values[1:]: current.next = ListNode(val) current = current.next return head # Unit tests def test_reverse_k_nodes(): # Test case 1: Reverse in groups of 2 head = list_to_linked_list([1, 2, 3, 4, 5]) k = 2 expected = [2, 1, 4, 3, 5] assert linked_list_to_list(reverse_k_nodes(head, k)) == expected # Test case 2: Reverse in groups of 3 head = list_to_linked_list([1, 2, 3, 4, 5, 6]) k = 3 expected = [3, 2, 1, 6, 5, 4] assert linked_list_to_list(reverse_k_nodes(head, k)) == expected # Test case 3: k = 1, list should remain unchanged head = list_to_linked_list([1, 2, 3, 4, 5]) k = 1 expected = [1, 2, 3, 4, 5] assert linked_list_to_list(reverse_k_nodes(head, k)) == expected # Test case 4: k greater than length of list head = list_to_linked_list([1, 2, 3]) k = 4 expected = [1, 2, 3] assert linked_list_to_list(reverse_k_nodes(head, k)) == expected # Test case 5: Empty list head = None k = 3 expected = [] assert linked_list_to_list(reverse_k_nodes(head, k)) == expected def test_reverse_k_nodes_edge_cases(): # Test case 6: Single node list head = list_to_linked_list([1]) k = 1 expected = [1] assert linked_list_to_list(reverse_k_nodes(head, k)) == expected # Test case 7: k is equal to list length head = list_to_linked_list([1, 2, 3]) k = 3 expected = [3, 2, 1] assert linked_list_to_list(reverse_k_nodes(head, k)) == expected","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_k_nodes(head: 'ListNode', k: int) -> 'ListNode': if not head or k == 1: return head # Helper function to reverse a portion of the list def reverse(start: 'ListNode', end: 'ListNode') -> 'ListNode': prev, curr = None, start while curr != end: next_node = curr.next curr.next = prev prev = curr curr = next_node return prev # Initialize pointers dummy = ListNode(0) dummy.next = head group_prev = dummy while True: kth = group_prev count = 0 # Find the kth node while count < k and kth.next: kth = kth.next count += 1 if count < k: break group_next = kth.next # Reverse the group group_start = group_prev.next group_end = kth.next reverse(group_start, group_end) group_prev.next = kth group_start.next = group_next group_prev = group_start return dummy.next"},{"question":"from typing import List def moving_average(data: List[float], window_size: int) -> List[float]: Smooth out sensor data measurements using a Moving Average filter. Args: data (List[float]): A list of floating-point numbers representing the sensor data. window_size (int): The number of data points to consider in each averaging window. Returns: List[float]: A list of floating-point numbers representing the smoothed data. Examples: >>> moving_average([1.0, 2.0, 3.0, 4.0, 5.0], 3) [2.0, 3.0, 4.0] >>> moving_average([10.0, 20.0, 30.0], 2) [15.0, 25.0] pass","solution":"from typing import List def moving_average(data: List[float], window_size: int) -> List[float]: if window_size > len(data): return [] result = [] window_sum = sum(data[:window_size]) result.append(window_sum / window_size) for i in range(window_size, len(data)): window_sum += data[i] - data[i - window_size] result.append(window_sum / window_size) return result"},{"question":"class MovieTheater: Class for managing movie theater seat reservations. >>> theater = MovieTheater(5, 8) >>> theater.display_seating() 'OOOOOOOOnOOOOOOOOnOOOOOOOOnOOOOOOOOnOOOOOOOO' >>> theater.reserve_seat(1, 3) True >>> theater.display_seating() 'OOXOOOOOnOOOOOOOOnOOOOOOOOnOOOOOOOOnOOOOOOOO' >>> theater.reserve_seat(1, 3) False >>> theater.cancel_reservation(1, 3) True >>> theater.display_seating() 'OOOOOOOOnOOOOOOOOnOOOOOOOOnOOOOOOOOnOOOOOOOO' >>> theater.cancel_reservation(1, 3) False def __init__(self, rows: int, seats_per_row: int): pass def reserve_seat(self, row: int, seat: int) -> bool: pass def cancel_reservation(self, row: int, seat: int) -> bool: pass def display_seating(self) -> str: pass","solution":"class MovieTheater: def __init__(self, rows: int, seats_per_row: int): self.rows = rows self.seats_per_row = seats_per_row self.seats = [[\\"O\\" for _ in range(seats_per_row)] for _ in range(rows)] def reserve_seat(self, row: int, seat: int) -> bool: if 1 <= row <= self.rows and 1 <= seat <= self.seats_per_row: if self.seats[row - 1][seat - 1] == \\"O\\": self.seats[row - 1][seat - 1] = \\"X\\" return True return False def cancel_reservation(self, row: int, seat: int) -> bool: if 1 <= row <= self.rows and 1 <= seat <= self.seats_per_row: if self.seats[row - 1][seat - 1] == \\"X\\": self.seats[row - 1][seat - 1] = \\"O\\" return True return False def display_seating(self) -> str: return \\"n\\".join(\\"\\".join(row) for row in self.seats)"},{"question":"def longest_palindromic_substring(s: str) -> str: Find the longest palindromic substring within a given string. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\" >>> longest_palindromic_substring(\\"a\\") \\"a\\" >>> longest_palindromic_substring(\\"abacdfgdcaba\\") \\"aba\\" >>> longest_palindromic_substring(\\"\\") \\"\\" >>> longest_palindromic_substring(\\"aaaa\\") \\"aaaa\\" pass def compress_string(s: str) -> str: Implement a basic string compression algorithm where consecutive duplicate characters are replaced with the character followed by the count of repetitions. >>> compress_string(\\"aabcccccaaa\\") \\"a2b1c5a3\\" >>> compress_string(\\"abcdef\\") \\"abcdef\\" >>> compress_string(\\"a\\") \\"a\\" >>> compress_string(\\"aa\\") \\"aa\\" >>> compress_string(\\"aaa\\") \\"a3\\" >>> compress_string(\\"\\") \\"\\" >>> compress_string(\\"aabbcc\\") \\"aabbcc\\" pass def is_anagram(s1: str, s2: str) -> bool: Determine whether two given strings are anagrams of each other. >>> is_anagram(\\"listen\\", \\"silent\\") True >>> is_anagram(\\"hello\\", \\"world\\") False >>> is_anagram(\\"a\\", \\"a\\") True >>> is_anagram(\\"a\\", \\"b\\") False >>> is_anagram(\\"anagram\\", \\"nagaram\\") True >>> is_anagram(\\"rat\\", \\"car\\") False >>> is_anagram(\\"\\", \\"\\") True pass","solution":"def longest_palindromic_substring(s: str) -> str: if len(s) == 0: return \\"\\" def expand_around_center(left: int, right: int) -> str: while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left+1:right] longest = \\"\\" for i in range(len(s)): # Odd length palindromes pal1 = expand_around_center(i, i) if len(pal1) > len(longest): longest = pal1 # Even length palindromes pal2 = expand_around_center(i, i + 1) if len(pal2) > len(longest): longest = pal2 return longest def compress_string(s: str) -> str: if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) compressed.append(str(count)) count = 1 compressed.append(s[-1]) compressed.append(str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s def is_anagram(s1: str, s2: str) -> bool: return sorted(s1) == sorted(s2)"},{"question":"def min_moves_to_balance(sequence: str) -> int: Returns the minimum number of moves required to balance the given sequence of parentheses. A move consists of either inserting or removing a single parenthesis. >>> min_moves_to_balance(\\"(()\\") 1 >>> min_moves_to_balance(\\")(\\") 2 >>> min_moves_to_balance(\\"()()\\") 0 >>> min_moves_to_balance(\\"())(()\\") 2","solution":"def min_moves_to_balance(sequence: str) -> int: Returns the minimum number of moves required to balance the given sequence of parentheses. A move consists of either inserting or removing a single parenthesis. >>> min_moves_to_balance(\\"(()\\") 1 >>> min_moves_to_balance(\\")(\\") 2 >>> min_moves_to_balance(\\"()()\\") 0 >>> min_moves_to_balance(\\"())(()\\") 2 # Track the number of unmatched opening and closing parentheses unmatched_open = 0 unmatched_close = 0 for char in sequence: if char == '(': unmatched_open += 1 elif char == ')': # If there is an unmatched opening parenthesis, match it with this closing one if unmatched_open > 0: unmatched_open -= 1 else: unmatched_close += 1 # The total number of moves to balance is the sum of unmatched opening and closing parentheses return unmatched_open + unmatched_close"},{"question":"def generate_all_strings(s: str) -> list[str]: Generate all possible strings by replacing each \`*\` in the original string with either '0' or '1', sorted in lexicographical order. >>> generate_all_strings(\\"a*c\\") ['a0c', 'a1c'] >>> generate_all_strings(\\"a*b*c\\") ['a0b0c', 'a0b1c', 'a1b0c', 'a1b1c'] from solution import generate_all_strings def test_single_asterisk(): assert generate_all_strings(\\"a*c\\") == ['a0c', 'a1c'] assert generate_all_strings(\\"*\\") == ['0', '1'] assert generate_all_strings(\\"ab*def\\") == ['ab0def', 'ab1def'] def test_multiple_asterisks(): assert generate_all_strings(\\"a*b*\\") == ['a0b0', 'a0b1', 'a1b0', 'a1b1'] assert generate_all_strings(\\"x*y*z\\") == ['x0y0z', 'x0y1z', 'x1y0z', 'x1y1z'] assert generate_all_strings(\\"*a*b\\") == ['0a0b', '0a1b', '1a0b', '1a1b'] def test_no_asterisks(): assert generate_all_strings(\\"abcdef\\") == [\\"abcdef\\"] assert generate_all_strings(\\"hello\\") == [\\"hello\\"] def test_empty_string(): assert generate_all_strings(\\"\\") == [\\"\\"] def test_unaltered_characters(): assert generate_all_strings(\\"abc\\") == [\\"abc\\"] assert generate_all_strings(\\"python\\") == [\\"python\\"]","solution":"def generate_all_strings(s: str) -> list[str]: Generate all possible strings by replacing each \`*\` in the original string \`s\` with either '0' or '1', sorted in lexicographical order. :param s: Input string containing characters \`a-z\` and \`*\`. :return: List of all possible strings with \`*\` replaced by '0' or '1'. # Base condition: if no '*' in the string, return the string as a single-item list if '*' not in s: return [s] # Recursive approach to replace '*' in the string result = [] # Generate strings for all '*' in the string replacing it with '0' and '1' for character in '01': new_string = s.replace('*', character, 1) result.extend(generate_all_strings(new_string)) # Ensure the result list is sorted return sorted(result)"},{"question":"from typing import List, Tuple def kruskal_mst(n: int, edges: List[Tuple[int, int, int]]) -> int: Returns the total weight of the minimum spanning tree using Kruskal's algorithm. :param n: An integer representing the number of vertices in the graph. :param edges: A list of tuples, where each tuple represents an edge in the format (u, v, weight). :return: An integer representing the total weight of the MST. Example: >>> kruskal_mst(4, [(1, 2, 1), (1, 3, 5), (2, 3, 2), (2, 4, 3), (3, 4, 4)]) 6 >>> kruskal_mst(5, [(1, 2, 3), (2, 3, 1), (3, 4, 6), (4, 5, 2), (1, 5, 10)]) 12 >>> kruskal_mst(3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)]) 3 >>> kruskal_mst(2, [(1, 2, 1)]) 1 >>> kruskal_mst(6, [(1, 2, 1), (3, 4, 4), (5, 6, 7), (1, 5, 8), (2, 3, 2), (4, 6, 3)]) 17","solution":"from typing import List, Tuple def kruskal_mst(n: int, edges: List[Tuple[int, int, int]]) -> int: Returns the total weight of the minimum spanning tree. :param n: An integer representing the number of vertices in the graph. :param edges: A list of tuples, where each tuple represents an edge in the format (u, v, weight). :return: An integer representing the total weight of the MST. # Helper function to find the root of a vertex u def find(parent, u): if parent[u] == u: return u parent[u] = find(parent, parent[u]) return parent[u] # Helper function to union two sets def union(parent, rank, u, v): root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: if rank[root_u] > rank[root_v]: parent[root_v] = root_u elif rank[root_u] < rank[root_v]: parent[root_u] = root_v else: parent[root_v] = root_u rank[root_u] += 1 # Sort the edges based on weight edges.sort(key=lambda x: x[2]) parent = [i for i in range(n + 1)] rank = [0] * (n + 1) mst_weight = 0 for u, v, weight in edges: if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_weight += weight return mst_weight"},{"question":"def process_students_data(students: list, threshold: float) -> list: Processes a list of students' data and filters based on their average grades. Parameters: - students (list): A list of dictionaries, each representing a student's data. - threshold (float): The minimum average grade to include a student in the final list. Returns: - list: A sorted and filtered list of students based on their average grades. >>> students_data = [ ... {\\"name\\": \\"Alice\\", \\"grades\\": [85, 90, 78], \\"id\\": 101}, ... {\\"name\\": \\"Bob\\", \\"grades\\": [70, 75, 80], \\"id\\": 102}, ... {\\"name\\": \\"Charlie\\", \\"grades\\": [95, 95, 92], \\"id\\": 103}, ... ] >>> process_students_data(students_data, 80.0) [ {\\"name\\": \\"Charlie\\", \\"grades\\": [95, 95, 92], \\"id\\": 103, \\"average\\": 94.0}, {\\"name\\": \\"Alice\\", \\"grades\\": [85, 90, 78], \\"id\\": 101, \\"average\\": 84.33} ]","solution":"def process_students_data(students, threshold): Processes a list of students' data and filters based on their average grades. Parameters: - students (list): A list of dictionaries, each representing a student's data. - threshold (float): The minimum average grade to include a student in the final list. Returns: - list: A sorted and filtered list of students based on their average grades. for student in students: grades = student['grades'] average_grade = sum(grades) / len(grades) student['average'] = round(average_grade, 2) students = [student for student in students if student['average'] >= threshold] students.sort(key=lambda x: x['average'], reverse=True) return students"},{"question":"def iterative_fibonacci(n: int) -> int: Returns the nth Fibonacci number using an iterative approach. Args: n (int): The position in the Fibonacci sequence. Returns: int: The nth Fibonacci number. Examples: >>> iterative_fibonacci(0) 0 >>> iterative_fibonacci(1) 1 >>> iterative_fibonacci(2) 1 >>> iterative_fibonacci(10) 55 >>> iterative_fibonacci(30) 832040 >>> iterative_fibonacci(50) 12586269025 pass","solution":"def iterative_fibonacci(n: int) -> int: Returns the nth Fibonacci number using an iterative approach. if n == 0: return 0 elif n == 1: return 1 else: a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def nearest_value(nums: list[int], target: int) -> int: Find the number in the list that is closest in value to the given target number. If there are two numbers equally close to the target, return the smaller number. Raise a ValueError if the nums list is empty. >>> nearest_value([4, 7, 10, 11, 12, 17], 9) 10 >>> nearest_value([4, 7, 10, 11, 12, 17], 8) 7 >>> nearest_value([4, 7, 10, 11, 12, 17], 5) 4 >>> nearest_value([4, 4, 4, 4], 3) 4 >>> nearest_value([-10, -5, 0, 5, 10], -7) -5 >>> nearest_value([1, 2, 3], 2) 2 >>> nearest_value([], 5) Traceback (most recent call last): ... ValueError: The list \`nums\` must not be empty.","solution":"def nearest_value(nums: list[int], target: int) -> int: if not nums: raise ValueError(\\"The list \`nums\` must not be empty.\\") closest_num = nums[0] min_diff = abs(nums[0] - target) for num in nums: diff = abs(num - target) if diff < min_diff or (diff == min_diff and num < closest_num): closest_num = num min_diff = diff return closest_num"},{"question":"from typing import List def matrix_product(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: Computes the product of two square matrices using the classical algorithm. The product C of two matrices A and B of size n x n is defined as: C[i][j] = sum(A[i][k] * B[k][j] for k = 0 to n-1) Parameters: matrix_a (List[List[int]]): A square matrix of integers n x n. matrix_b (List[List[int]]): Another square matrix of integers n x n. Returns: List[List[int]]: A new n x n matrix representing the product of matrix_a and matrix_b. >>> matrix_a = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> matrix_b = [ ... [9, 8, 7], ... [6, 5, 4], ... [3, 2, 1] ... ] >>> matrix_product(matrix_a, matrix_b) [[30, 24, 18], [84, 69, 54], [138, 114, 90]] >>> matrix_a = [ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ] >>> matrix_b = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> matrix_product(matrix_a, matrix_b) [[1, 2, 3], [4, 5, 6], [7, 8, 9]]","solution":"from typing import List def matrix_product(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: n = len(matrix_a) # Initialize the result matrix with zeros result = [[0] * n for _ in range(n)] # Perform matrix multiplication for i in range(n): for j in range(n): for k in range(n): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result"},{"question":"class LogAggregator: def __init__(self): Initialize the LogAggregator with an empty list of logs. self.logs = [] def add_log(self, timestamp: int, log_entry: str) -> None: Adds a log entry to the list of logs. Args: timestamp (int): The timestamp of the log entry. log_entry (str): The log entry message. def get_logs_in_range(self, start: int, end: int) -> list[str]: Retrieves all log entries within the specified time range [start, end]. Args: start (int): The start timestamp. end (int): The end timestamp. Returns: list[str]: A list of log entries within the time range.","solution":"class LogAggregator: def __init__(self): self.logs = [] def add_log(self, timestamp: int, log_entry: str) -> None: Adds a log entry to the list of logs. Args: timestamp (int): The timestamp of the log entry. log_entry (str): The log entry message. self.logs.append((timestamp, log_entry)) def get_logs_in_range(self, start: int, end: int) -> list[str]: Retrieves all log entries within the specified time range [start, end]. Args: start (int): The start timestamp. end (int): The end timestamp. Returns: list[str]: A list of log entries within the time range. return [log for (timestamp, log) in self.logs if start <= timestamp <= end]"},{"question":"def check_schedule_conflicts(schedules: list[list[tuple[int, int]]]) -> list[bool]: Determines if there are any conflicting classes in each student's schedule. :param schedules: List of student schedules. Each schedule is a list of tuples where each tuple contains start and end time of a class. :return: List of booleans indicating if there's a conflict (True if there is a conflict, False otherwise) for each schedule. >>> check_schedule_conflicts([[(9, 10), (10, 11), (15, 16)], [(8, 10), (9, 11)], [(14, 16), (16, 18), (18, 20)]]) [False, True, False] >>> check_schedule_conflicts([[(0, 1), (1, 2)], [(22, 23), (23, 24)], [(9, 10), (12, 13), (18, 19), (20, 21)]]) [False, False, False]","solution":"def check_schedule_conflicts(schedules: list[list[tuple[int, int]]]) -> list[bool]: Determines if there are any conflicting classes in each student's schedule. :param schedules: List of student schedules. Each schedule is a list of tuples where each tuple contains start and end time of a class. :return: List of booleans indicating if there's a conflict (True if there is a conflict, False otherwise) for each schedule. def has_conflict(schedule): # Sort the classes by start time sorted_schedule = sorted(schedule) for i in range(len(sorted_schedule) - 1): # Check if the end time of the current class is greater than the start time of the next class if sorted_schedule[i][1] > sorted_schedule[i+1][0]: return True return False return [has_conflict(schedule) for schedule in schedules]"},{"question":"class DynamicArray: def __init__(self, initial_capacity=2): Initialize the dynamic array with a specific capacity. self.capacity = initial_capacity self.size = 0 self.array = [None] * self.capacity self.sorted = False def add_element(self, value): Add an element to the dynamic array. if self.size == self.capacity: self._resize(2 * self.capacity) self.array[self.size] = value self.size += 1 self.sorted = False def remove_element(self, value): Remove the first occurrence of a value from the dynamic array. for i in range(self.size): if self.array[i] == value: for j in range(i, self.size - 1): self.array[j] = self.array[j + 1] self.size -= 1 self.array[self.size] = None if self.size <= self.capacity // 2 and self.capacity > 2: self._resize(max(self.capacity // 2, 2)) return def contains(self, value): Check if a value exists in the dynamic array. if self.sorted: return self._binary_search(value) return self._linear_search(value) def sort_array(self): Sort the dynamic array in ascending order. self.array = self.array[:self.size] self.array.sort() self.sorted = True def _resize(self, new_capacity): Resize the dynamic array to a new capacity. new_array = [None] * new_capacity for i in range(self.size): new_array[i] = self.array[i] self.array = new_array self.capacity = new_capacity def _linear_search(self, value): Perform a linear search for a value in the dynamic array. for i in range(self.size): if self.array[i] == value: return True return False def _binary_search(self, value): Perform a binary search for a value in the sorted dynamic array. left, right = 0, self.size - 1 while left <= right: mid = (left + right) // 2 if self.array[mid] == value: return True elif self.array[mid] < value: left = mid + 1 else: right = mid - 1 return False @property def is_sorted(self): Check if the dynamic array is sorted. return self.sorted def test_add_element(): da = DynamicArray() da.add_element(1) assert da.size == 1 assert da.array[0] == 1 def test_resize_on_add(): da = DynamicArray(2) da.add_element(1) da.add_element(2) da.add_element(3) # This should trigger a resize assert da.capacity == 4 assert da.size == 3 def test_remove_element(): da = DynamicArray() da.add_element(1) da.add_element(2) da.add_element(3) assert da.size == 3 da.remove_element(2) assert da.size == 2 assert da.contains(2) == False def test_resize_on_remove(): da = DynamicArray(4) da.add_element(1) da.add_element(2) da.remove_element(1) da.remove_element(2) # This should trigger a resize assert da.capacity == 2 assert da.size == 0 def test_contains_unsorted(): da = DynamicArray() da.add_element(1) da.add_element(2) assert da.contains(2) == True assert da.contains(3) == False def test_contains_sorted(): da = DynamicArray() da.add_element(1) da.add_element(2) da.add_element(3) da.sort_array() assert da.is_sorted == True assert da.contains(2) == True assert da.contains(4) == False def test_sort_array(): da = DynamicArray() da.add_element(3) da.add_element(1) da.add_element(2) da.sort_array() assert da.array[:da.size] == [1, 2, 3] assert da.is_sorted == True","solution":"class DynamicArray: def __init__(self, initial_capacity=2): self.capacity = initial_capacity self.size = 0 self.array = [None] * self.capacity self.sorted = False def add_element(self, value): if self.size == self.capacity: self._resize(2 * self.capacity) self.array[self.size] = value self.size += 1 self.sorted = False def remove_element(self, value): for i in range(self.size): if self.array[i] == value: for j in range(i, self.size - 1): self.array[j] = self.array[j + 1] self.size -= 1 self.array[self.size] = None if self.size <= self.capacity // 2 and self.capacity > 2: self._resize(max(self.capacity // 2, 2)) return def contains(self, value): if self.sorted: return self._binary_search(value) return self._linear_search(value) def sort_array(self): self.array = self.array[:self.size] self.array.sort() self.sorted = True def _resize(self, new_capacity): new_array = [None] * new_capacity for i in range(self.size): new_array[i] = self.array[i] self.array = new_array self.capacity = new_capacity def _linear_search(self, value): for i in range(self.size): if self.array[i] == value: return True return False def _binary_search(self, value): left, right = 0, self.size - 1 while left <= right: mid = (left + right) // 2 if self.array[mid] == value: return True elif self.array[mid] < value: left = mid + 1 else: right = mid - 1 return False @property def is_sorted(self): return self.sorted"}]`),C={name:"App",components:{PoemCard:R},data(){return{searchQuery:"",visibleCount:4,poemsData:E,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},F={class:"search-container"},z={class:"card-container"},I={key:0,class:"empty-state"},S=["disabled"],D={key:0},B={key:1};function P(i,e,l,f,n,a){const m=h("PoemCard");return r(),s("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",F,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>n.searchQuery=o),placeholder:"Search..."},null,512),[[b,n.searchQuery]]),n.searchQuery?(r(),s("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>n.searchQuery="")}," ✕ ")):d("",!0)]),t("div",z,[(r(!0),s(y,null,v(a.displayedPoems,(o,p)=>(r(),w(m,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(r(),s("div",I,' No results found for "'+u(n.searchQuery)+'". ',1)):d("",!0)]),a.hasMorePoems?(r(),s("button",{key:0,class:"load-more-button",disabled:n.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[n.isLoading?(r(),s("span",B,"Loading...")):(r(),s("span",D,"See more"))],8,S)):d("",!0)])}const j=c(C,[["render",P],["__scopeId","data-v-1d29f4ee"]]),O=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/27.md","filePath":"library/27.md"}'),M={name:"library/27.md"},U=Object.assign(M,{setup(i){return(e,l)=>(r(),s("div",null,[x(j)]))}});export{O as __pageData,U as default};
