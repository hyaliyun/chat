import{_,o as r,c as n,a as t,m,t as d,C as g,M as p,U as b,f as u,F as x,p as w,e as y,q as v}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function R(s,e,l,h,i,a){return r(),n("div",q,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),m(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),m(d(l.poem.solution),1)])])])}const j=_(k,[["render",R],["__scopeId","data-v-4e8b1fab"]]),F=JSON.parse(`[{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def add_trees_in_reverse_level_order(root1, root2): Returns the sum of two binary trees represented as numbers in reversed level-order format. pass def create_tree_from_list(vals): if not vals: return None root = TreeNode(vals[0]) queue = [root] i = 1 while i < len(vals): current = queue.pop(0) if i < len(vals) and vals[i] is not None: current.left = TreeNode(vals[i]) queue.append(current.left) i += 1 if i < len(vals) and vals[i] is not None: current.right = TreeNode(vals[i]) queue.append(current.right) i += 1 return root def tree_to_list(root): result = [] current = root while current: result.append(current.val) current = current.left return result def test_add_trees_in_reverse_level_order_simple(): root1 = create_tree_from_list([2, 4, 3]) root2 = create_tree_from_list([5, 6, 4]) result_tree = add_trees_in_reverse_level_order(root1, root2) assert tree_to_list(result_tree) == [7, 0, 8] def test_add_trees_in_reverse_level_order_with_carry(): root1 = create_tree_from_list([9, 9, 9]) root2 = create_tree_from_list([1, 1, 1]) result_tree = add_trees_in_reverse_level_order(root1, root2) assert tree_to_list(result_tree) == [0, 1, 1, 1] def test_add_trees_in_reverse_level_order_different_lengths(): root1 = create_tree_from_list([1, 0, 0, 0, 0]) root2 = create_tree_from_list([1]) result_tree = add_trees_in_reverse_level_order(root1, root2) assert tree_to_list(result_tree) == [2, 0, 0, 0, 0] def test_add_trees_in_reverse_level_order_with_no_carry(): root1 = create_tree_from_list([1, 2, 3]) root2 = create_tree_from_list([4, 5, 6]) result_tree = add_trees_in_reverse_level_order(root1, root2) assert tree_to_list(result_tree) == [5, 7, 9] def test_add_trees_in_reverse_level_order_with_zeros(): root1 = create_tree_from_list([0]) root2 = create_tree_from_list([0]) result_tree = add_trees_in_reverse_level_order(root1, root2) assert tree_to_list(result_tree) == [0]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def add_trees_in_reverse_level_order(root1, root2): Returns the sum of two binary trees represented as numbers in reversed level-order format. def add_lists_as_numbers(l1, l2): carry, head = 0, None current = None while l1 or l2 or carry: val1 = l1.pop(0) if l1 else 0 val2 = l2.pop(0) if l2 else 0 total = val1 + val2 + carry carry = total // 10 new_node = TreeNode(total % 10) if not head: head = new_node current = head else: current.left = new_node current = current.left return head def tree_to_list(tree): q, result = [tree], [] while q: node = q.pop(0) if node: result.append(node.val) q.append(node.left) q.append(node.right) return result list1 = tree_to_list(root1) list2 = tree_to_list(root2) return add_lists_as_numbers(list1, list2)"},{"question":"def find_subarray_with_target_sum(nums: List[int], target: int) -> List[int]: Find a contiguous subarray whose sum is exactly equal to the target. >>> find_subarray_with_target_sum([1, 2, 3, 4, 5], 9) == [2, 3, 4] >>> find_subarray_with_target_sum([1, -1, 5, -2, 3], 3) == [1, -1, 5, -2] >>> find_subarray_with_target_sum([1, 2, 3, 4, 5], 15) == [1, 2, 3, 4, 5] >>> find_subarray_with_target_sum([1, 2, 3, 4, 5], 8) == []","solution":"def find_subarray_with_target_sum(nums, target): Find a contiguous subarray whose sum is exactly equal to the target. # Dictionary to store cumulative sum and corresponding index cum_sum_map = {} current_sum = 0 for i, num in enumerate(nums): # Add the current number to the running sum current_sum += num # Check if the current running sum is equal to the target if current_sum == target: return nums[:i+1] # Check if any subarray sums up to the target by checking if # (current_sum - target) is present in the cumulative sum map if (current_sum - target) in cum_sum_map: return nums[cum_sum_map[current_sum - target] + 1:i + 1] # Store the current running sum with its index in the map cum_sum_map[current_sum] = i return []"},{"question":"from typing import List def numIslands(mat: List[List[int]]) -> int: Returns the number of islands in the given binary matrix. An island is a group of connected 1's surrounded by 0's. >>> numIslands([[1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1]]) 3 >>> numIslands([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> numIslands([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 1 >>> numIslands([]) 0 >>> numIslands([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]) 4 >>> numIslands([[1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1]]) 8","solution":"from typing import List def numIslands(mat: List[List[int]]) -> int: Returns the number of islands in the given binary matrix. An island is a group of connected 1's surrounded by 0's. if not mat: return 0 m, n = len(mat), len(mat[0]) visited = [[False] * n for _ in range(m)] def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or mat[i][j] == 0 or visited[i][j]: return visited[i][j] = True dfs(i+1, j) # down dfs(i-1, j) # up dfs(i, j+1) # right dfs(i, j-1) # left count = 0 for i in range(m): for j in range(n): if mat[i][j] == 1 and not visited[i][j]: dfs(i, j) count += 1 return count"},{"question":"def longest_valid_parentheses(s: str) -> int: Finds the length of the longest valid parentheses substring. Parameters: s (str): A string consisting of '(' and ')'. Returns: int: The length of the longest valid parentheses substring. >>> longest_valid_parentheses(\\"()()\\") 4 >>> longest_valid_parentheses(\\"((()))\\") 6 >>> longest_valid_parentheses(\\")()())\\") 4 >>> longest_valid_parentheses(\\"(\\") 0 >>> longest_valid_parentheses(\\"\\") 0","solution":"def longest_valid_parentheses(s): Finds the length of the longest valid parentheses substring. Parameters: s (str): A string consisting of '(' and ')'. Returns: int: The length of the longest valid parentheses substring. max_len = 0 stack = [] start = -1 for i, char in enumerate(s): if char == '(': stack.append(i) else: if stack: stack.pop() if stack: max_len = max(max_len, i - stack[-1]) else: max_len = max(max_len, i - start) else: start = i return max_len"},{"question":"def is_palindrome_substring(s: str, queries: List[Tuple[int, int]]) -> List[bool]: Determines if the substrings specified by each pair of start and end indices in queries are palindromes. Args: s (str): The input string. queries (list): A list of (start, end) index pairs representing the substring. Returns: list: A list of booleans corresponding to each query, where True means the substring is a palindrome and False means it is not. >>> is_palindrome_substring(\\"racecar\\", [(0, 6), (1, 5), (2, 4), (3, 3)]) [True, True, True, True] >>> is_palindrome_substring(\\"abcd\\", [(0, 1), (1, 3), (0, 3)]) [False, False, False] from solution import is_palindrome_substring def test_single_character_substrings(): s = \\"abc\\" queries = [(0, 0), (1, 1), (2, 2)] assert is_palindrome_substring(s, queries) == [True, True, True] def test_multiple_character_substrings(): s = \\"abba\\" queries = [(0, 3), (1, 2), (0, 1)] assert is_palindrome_substring(s, queries) == [True, True, False] def test_non_palindromic_substrings(): s = \\"abcd\\" queries = [(0, 1), (1, 3), (0, 3)] assert is) on जान 7 at at the given exchange rate (taking into account transaction fees).] let buy_date = खुशिलाल समय.wednesday() let price_per_currency = (AMER: 0.013, CHORL: 0.078) let time_of_day = (MON: 2, TUE: 3, WED: 13, THURS: 17, FRI: 6, SAT: 1, SUN: 4) let query_date = 'जान 7' func main() { // Define the exchange rate from AMER to CHORL currencies let exchange_rate: CurrencyExchangeRate = (buy: 1.2, sell: 1.3) // Define the exchange rate from CHORL to AMER currencies let exchange_rate_two: CurrencyExchangeRate = (buy: 1.3, sell: 1.2) // Create CurrencyExchangeRate object let rate = CurrencyExchange(current_rate: exchange_rate) let rate1 = CurrencyExchange(previous_rate: exchange_rate_two) // Calculate and print the transaction amount for 1000 AMER to CHORL on the given date let transaction_amount = getTransactionAmount(rate: rate, rate1: rate1, currency_type: ครุกษ 1000, other_currency_type: จีพาท람บิน 100) print(\\"The transaction amount is (transaction_amount)\\") } main()","solution":"def is_palindrome_substring(s, queries): Determines if the substrings specified by each pair of start and end indices in queries are palindromes. Args: s (str): The input string. queries (list): A list of (start, end) index pairs representing the substring. Returns: list: A list of booleans corresponding to each query, where True means the substring is a palindrome and False means it is not. result = [] for start, end in queries: substring = s[start:end+1] result.append(substring == substring[::-1]) return result"},{"question":"def count_blocked_buildings(heights: List[int]) -> int: Returns the count of buildings that have at least one building ahead of them that they cannot see due to the presence of a taller building blocking the view. >>> count_blocked_buildings([]) == 0 >>> count_blocked_buildings([5]) == 0 >>> count_blocked_buildings([1, 2, 3, 4, 5]) == 0 >>> count_blocked_buildings([5, 4, 3, 2, 1]) == 4 >>> count_blocked_buildings([3, 1, 4, 2, 5]) == 2 >>> count_blocked_buildings([1, 3, 2, 4, 3]) == 2 >>> count_blocked_buildings([1, 2, 2, 3, 1]) == 1","solution":"def count_blocked_buildings(heights): Returns the count of buildings that have at least one building ahead of them that they cannot see due to the presence of a taller building blocking the view. blocked_count = 0 max_height_so_far = 0 for height in heights: if height >= max_height_so_far: max_height_so_far = height else: blocked_count += 1 return blocked_count"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rearrange_even_odd(head: ListNode) -> ListNode: Rearranges the linked list such that all even numbers appear before all odd numbers. >>> linked_list_to_list(rearrange_even_odd(list_to_linked_list([1, 4, 3, 2, 5, 8]))) [4, 2, 8, 1, 3, 5] >>> linked_list_to_list(rearrange_even_odd(list_to_linked_list([2, 4, 6, 8]))) [2, 4, 6, 8] >>> linked_list_to_list(rearrange_even_odd(list_to_linked_list([1, 3, 5, 7]))) [1, 3, 5, 7] >>> linked_list_to_list(rearrange_even_odd(list_to_linked_list([1, 2, 3, 4, 5, 6]))) [2, 4, 6, 1, 3, 5] >>> linked_list_to_list(rearrange_even_odd(list_to_linked_list([]))) [] >>> linked_list_to_list(rearrange_even_odd(list_to_linked_list([1]))) [1] >>> linked_list_to_list(rearrange_even_odd(list_to_linked_list([2]))) [2]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rearrange_even_odd(head): Rearranges the linked list such that all even numbers appear before all odd numbers. if not head: return head even_dummy = ListNode(0) odd_dummy = ListNode(0) even_tail, odd_tail = even_dummy, odd_dummy current = head while current: if current.val % 2 == 0: even_tail.next = current even_tail = even_tail.next else: odd_tail.next = current odd_tail = odd_tail.next current = current.next even_tail.next = odd_dummy.next odd_tail.next = None return even_dummy.next"},{"question":"def trap(height: List[int]) -> int: Calculate the maximum amount of water that can be trapped after raining given a list of non-negative integers representing an elevation map. :param height: List[int] - List of non-negative integers representing the amounts of rainfall at regular intervals :return: int - The total amount of trapped water >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([3, 0, 3]) 3 >>> trap([4, 2, 0, 3, 2, 5]) 9 >>> trap([]) 0 >>> trap([1, 2, 3, 4, 5]) 0","solution":"def trap(height): Calculate the maximum amount of water that can be trapped after raining given a list of non-negative integers representing an elevation map. :param height: List[int] - List of non-negative integers representing the amounts of rainfall at regular intervals :return: int - The total amount of trapped water if not height or len(height) < 3: return 0 n = len(height) left, right = 0, n - 1 left_max, right_max = height[left], height[right] trapped_water = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) trapped_water += left_max - height[left] else: right -= 1 right_max = max(right_max, height[right]) trapped_water += right_max - height[right] return trapped_water"},{"question":"def oranges_rotting(grid: List[List[int]]) -> int: Computes the minimum time required for all fresh oranges to become rotten. If impossible, returns -1. >>> oranges_rotting([[2, 1, 1], [1, 1, 0], [0, 1, 1]]) == 4 >>> oranges_rotting([[2, 2, 2], [2, 2, 2], [2, 2, 2]]) == 0 >>> oranges_rotting([[2, 1, 0], [0, 1, 1], [1, 0, 1]]) == -1 >>> oranges_rotting([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == -1 >>> oranges_rotting([[0, 2]]) == 0 >>> oranges_rotting([[]]) == 0 >>> oranges_rotting([[1]]) == -1 >>> oranges_rotting([[2]]) == 0 pass","solution":"from collections import deque def oranges_rotting(grid): Computes the minimum time required for all fresh oranges to become rotten. If impossible, returns -1. rows, cols = len(grid), len(grid[0]) queue = deque() fresh_oranges = 0 # Populate initial state of the grid for r in range(rows): for c in range(cols): if grid[r][c] == 2: queue.append((r, c, 0)) # store the coordinate and the minute elif grid[r][c] == 1: fresh_oranges += 1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] time = 0 # Perform BFS to rot adjacent fresh oranges while queue: x, y, minute = queue.popleft() time = max(time, minute) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1: grid[nx][ny] = 2 fresh_oranges -= 1 queue.append((nx, ny, minute + 1)) return -1 if fresh_oranges > 0 else time"},{"question":"def last_index_of_smallest(nums): Finds the last occurrence of the smallest element in nums and returns its index. If the smallest element appears only once, returns its index directly. If the list is empty, returns -1. >>> last_index_of_smallest([3, 1, 4, 1, 5, 9, 1]) == 6 >>> last_index_of_smallest([42]) == 0 >>> last_index_of_smallest([1, 2, 3, 4, 5]) == 0 >>> last_index_of_smallest([3, 5, 1, 2, 1, 3, 1, 4]) == 6 >>> last_index_of_smallest([]) == -1 >>> last_index_of_smallest([2, 2, 2, 2, 2]) == 4 >>> last_index_of_smallest([4, 3, 2, 1, 0]) == 4 >>> last_index_of_smallest([4, 2, 3, 1, 5]) == 3","solution":"def last_index_of_smallest(nums): Finds the last occurrence of the smallest element in nums and returns its index. If the smallest element appears only once, returns its index directly. If the list is empty, returns -1. if not nums: return -1 min_value = min(nums) last_index = len(nums) - 1 - nums[::-1].index(min_value) return last_index"},{"question":"def min_max_partition(s: str, k: int) -> int: You are given a string \`s\` consisting of lowercase English letters and an integer \`k\`. You need to partition the string into as many parts as possible such that each letter appears in at most one part, and the length of the longest part is minimized. Return the minimum possible length of the longest part after partitioning. >>> min_max_partition(\\"a\\", 1) == 1 >>> min_max_partition(\\"abac\\", 4) == 3 # \\"aba\\", \\"c\\" -> length of longest part is 3 >>> min_max_partition(\\"aabbccdd\\", 8) == 2 # \\"aa\\", \\"bb\\", \\"cc\\", \\"dd\\" -> length of longest part is 2 >>> min_max_partition(\\"aabcdefa\\", 8) == 8 # \\"aabcdefa\\" -> length of longest part is 8 >>> min_max_partition(\\"abcdef\\", 6) == 1 # \\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\" -> length of longest part is 1 pass","solution":"def min_max_partition(s, k): Returns the minimum possible length of the longest part after partitioning the string \`s\`. last_occurrence = {} for i, char in enumerate(s): last_occurrence[char] = i partitions = [] start, end = 0, 0 for i, char in enumerate(s): end = max(end, last_occurrence[char]) if i == end: partitions.append(end - start + 1) start = i + 1 return max(partitions)"},{"question":"def minimum_removals(heights): Returns the minimum number of students that need to be removed so that the remaining students are standing in non-decreasing order of height. >>> minimum_removals([1, 3, 2, 1, 4, 5]) 2 >>> minimum_removals([1, 2, 3, 4, 5]) 0 >>> minimum_removals([5, 4, 3, 2, 1]) 4 >>> minimum_removals([2, 1, 2, 3, 2, 2, 3]) 2 >>> minimum_removals([1]) 0 >>> minimum_removals([]) 0 >>> minimum_removals([2, 2, 2, 2]) 0","solution":"def minimum_removals(heights): Returns the minimum number of students that need to be removed so that the remaining students are standing in non-decreasing order of height. def longest_increasing_subsequence(arr): if not arr: return 0 lis = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] >= arr[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis) n = len(heights) length_of_lis = longest_increasing_subsequence(heights) return n - length_of_lis"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Returns the number of unique paths in a grid that contains obstacles. Parameters: grid (List[List[int]]): 2D list representing the grid. 0 indicates empty cell, 1 indicates obstacle. Returns: int: Number of unique paths from the top-left to the bottom-right corner of the grid. >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 6 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[0, 0, 0], [1, 1, 0], [0, 0, 0]]) 1 >>> unique_paths_with_obstacles([[1, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 1]]) 0 >>> unique_paths_with_obstacles([[0, 0, 0], [1, 1, 1], [0, 0, 0]]) 0","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths in a grid that contains obstacles. Parameters: grid (List[List[int]]): 2D list representing the grid. 0 indicates empty cell, 1 indicates obstacle. Returns: int: Number of unique paths from the top-left to the bottom-right corner of the grid. if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) # Create a 2D array to store the number of unique paths to each cell dp = [[0] * n for _ in range(m)] # Initialize the starting point dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def is_balanced(s: str) -> bool: Determines whether a given sequence of brackets is balanced. Parameters: s (str): The input string containing only bracket characters. Returns: bool: True if the sequence is balanced, otherwise False. Examples: >>> is_balanced(\\"()[]{}\\") True >>> is_balanced(\\"([{}])\\") True >>> is_balanced(\\"[(])\\") False >>> is_balanced(\\"[({})](]\\") False","solution":"def is_balanced(s): Determines whether a given sequence of brackets is balanced. Parameters: s (str): The input string containing only bracket characters. Returns: bool: True if the sequence is balanced, otherwise False. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def letter_combinations(digits: str) -> List[str]: Returns all possible letter combinations that the number could represent using the mapping of digits to letters on a phone keypad. Example: >>> letter_combinations(\\"23\\") ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']","solution":"def letter_combinations(digits): Returns all possible letter combinations that the number could represent using the mapping of digits to letters on a phone keypad. if not digits: return [] digit_to_char = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_chars = digit_to_char[digits[index]] for char in possible_chars: path.append(char) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"def is_subsequence_of_permutation(nums1, nums2): Returns True if nums2 is a subsequence of any permutation of nums1, otherwise False. >>> is_subsequence_of_permutation([1, 2, 3, 4, 5], [2, 4, 3]) True >>> is_subsequence_of_permutation([1, 2, 3, 4, 5], [6, 4, 3]) False >>> is_subsequence_of_permutation([1, 2, 3, 4, 5], [2, 4, 3, 6]) False >>> is_subsequence_of_permutation([1, 2, 3, 4, 5], []) True >>> is_subsequence_of_permutation([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) True >>> is_subsequence_of_permutation([1, 2, 3], [2]) True >>> is_subsequence_of_permutation([1, 2, 3], [4]) False","solution":"def is_subsequence_of_permutation(nums1, nums2): Returns True if nums2 is a subsequence of any permutation of nums1, otherwise False. nums1_set = set(nums1) for num in nums2: if num not in nums1_set: return False return True"},{"question":"def largest_connected_component(isConnected): Determine the size of the largest connected component in an undirected graph given its adjacency matrix. :param isConnected: List[List[int]], 2D adjacency matrix of the graph :return: int, size of the largest connected component >>> largest_connected_component([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) == 1 >>> largest_connected_component([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 3 >>> largest_connected_component([ ... [1, 1, 0], ... [1, 1, 0], ... [0, 0, 1] ... ]) == 2 >>> largest_connected_component([ ... [1, 1, 0, 0], ... [1, 1, 1, 0], ... [0, 1, 1, 1], ... [0, 0, 1, 1] ... ]) == 4 >>> largest_connected_component([ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 1, 1], ... [0, 0, 1, 0, 0], ... [0, 1, 0, 1, 1], ... [0, 1, 0, 1, 1] ... ]) == 4","solution":"def largest_connected_component(isConnected): Determine the size of the largest connected component in an undirected graph given its adjacency matrix. :param isConnected: List[List[int]], 2D adjacency matrix of the graph :return: int, size of the largest connected component def dfs(node, visited): stack = [node] component_size = 0 while stack: current = stack.pop() if not visited[current]: visited[current] = True component_size += 1 for neighbor in range(len(isConnected)): if isConnected[current][neighbor] == 1 and not visited[neighbor]: stack.append(neighbor) return component_size n = len(isConnected) visited = [False] * n largest_size = 0 for i in range(n): if not visited[i]: size_of_component = dfs(i, visited) largest_size = max(largest_size, size_of_component) return largest_size"},{"question":"def sqrt(x: int) -> int: Returns the square root of x. If x is not a perfect square, returns the floor value of the square root. :param x: int :return: int >>> sqrt(4) == 2 >>> sqrt(9) == 3 >>> sqrt(16) == 4 >>> sqrt(25) == 5 >>> sqrt(8) == 2 >>> sqrt(20) == 4 >>> sqrt(15) == 3 >>> sqrt(0) == 0 >>> sqrt(1) == 1 >>> sqrt(123456789) == 11111 >>> sqrt(14) == 3 >>> sqrt(26) == 5 >>> sqrt(-1) # should raise ValueError(\\"Input should be a non-negative integer\\") pass","solution":"def sqrt(x): Returns the square root of x. If x is not a perfect square, returns the floor value of the square root. :param x: int :return: int if x < 0: raise ValueError(\\"Input should be a non-negative integer\\") if x == 0 or x == 1: return x low, high = 0, x result = 0 while low <= high: mid = (low + high) // 2 mid_squared = mid * mid if mid_squared == x: return mid elif mid_squared < x: low = mid + 1 result = mid else: high = mid - 1 return result"},{"question":"class StreamSorter: def __init__(self): Initializes an empty StreamSorter instance. pass def addNum(self, num: int): Adds the integer \`num\` to the stream. :param num: Integer to be added. pass def getSortedStream(self) -> List[int]: Returns a sorted list of all the integers added to the stream so far. :return: Sorted list of integers. pass # Unit Tests def test_add_and_get_sorted_empty(): sorter = StreamSorter() assert sorter.getSortedStream() == [] def test_add_and_get_sorted_single_element(): sorter = StreamSorter() sorter.addNum(5) assert sorter.getSortedStream() == [5] def test_add_and_get_sorted_multiple_elements(): sorter = StreamSorter() sorter.addNum(5) sorter.addNum(1) sorter.addNum(3) assert sorter.getSortedStream() == [1, 3, 5] def test_adding_multiple_times(): sorter = StreamSorter() sorter.addNum(10) sorter.addNum(-1) sorter.addNum(7) sorter.addNum(2) assert sorter.getSortedStream() == [-1, 2, 7, 10] def test_preserve_order_of_elements(): sorter = StreamSorter() sorter.addNum(3) sorter.addNum(5) sorter.addNum(2) assert sorter.getSortedStream() == [2, 3, 5] sorter.addNum(4) assert sorter.getSortedStream() == [2, 3, 4, 5] sorter.addNum(1) assert sorter.getSortedStream() == [1, 2, 3, 4, 5]","solution":"class StreamSorter: def __init__(self): self.nums = [] def addNum(self, num): Adds the integer \`num\` to the stream. self.nums.append(num) self.nums.sort() def getSortedStream(self): Returns a sorted list of all the integers added to the stream so far. return self.nums[:]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Determine whether the binary tree is balanced. >>> is_balanced(None) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> is_balanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> is_balanced(root) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Determine whether the binary tree is balanced. def check_balance(node): if not node: return 0, True left_depth, left_balanced = check_balance(node.left) right_depth, right_balanced = check_balance(node.right) current_balanced = left_balanced and right_balanced and abs(left_depth - right_depth <= 1) current_depth = max(left_depth, right_depth) + 1 return current_depth, current_balanced return check_balance(root)[1]"},{"question":"from typing import List def count_active_users(logs: List[List[int]]) -> int: Returns the number of unique active users based on the provided login logs. >>> count_active_users([[1, 1], [1, 7]]) 0 >>> count_active_users([[1, 1]]) 0 >>> count_active_users([[1, 1], [1, 5]]) 1 >>> count_active_users([[1, 1], [1, 6]]) 1 >>> count_active_users([[1, 1], [2, 10], [1, 12], [2, 20]]) 0 >>> count_active_users([[1, 1], [2, 1], [1, 3], [3, 5], [1, 20], [2, 6]]) 2 >>> count_active_users([[1, 1], [2, 1], [1, 6], [3, 12], [3, 16], [4, 20]]) 2 >>> count_active_users([]) 0 >>> count_active_users([[i, i * 10] for i in range(1, 1001)]) 0 >>> count_active_users([[1, 1], [1, 3], [2, 2], [2, 4], [3, 3], [3, 5]]) 3","solution":"def count_active_users(logs): Returns the number of unique active users based on the provided login logs. from collections import defaultdict # Dictionary to map user IDs to their respective login times user_logs = defaultdict(list) # Populate the dictionary with the logs for log in logs: user_logs[log[0]].append(log[1]) # Function to check if a user is active def is_active(times): times.sort() for i in range(len(times) - 1): if times[i+1] - times[i] <= 5: return True return False # Checking each user for activity active_users = set() for user, times in user_logs.items(): if is_active(times): active_users.add(user) return len(active_users)"},{"question":"class PathFinder: PathFinder class to determine if there exists a safe path in a grid. def __init__(self, grid: List[List[str]]): Initializes the PathFinder with a 2D grid. def applyOperations(self, operations: List[List[int]]): Applies a list of operations to update the grid. def hasSafePath(self) -> bool: Returns True if there is a path from top-left to bottom-right consisting only of 'S' cells. def __init__(self, grid): pass def applyOperations(self, operations): pass def hasSafePath(self): pass def test_initial_safe_path(): grid = [ ['S', 'S', 'T'], ['T', 'S', 'T'], ['T', 'S', 'S'] ] pathfinder = PathFinder(grid) assert pathfinder.hasSafePath() == True def test_initial_no_safe_path(): grid = [ ['S', 'T', 'T'], ['T', 'S', 'T'], ['T', 'S', 'S'] ] pathfinder = PathFinder(grid) assert pathfinder.hasSafePath() == False def test_operations_create_safe_path(): grid = [ ['S', 'T', 'T'], ['T', 'S', 'T'], ['T', 'T', 'S'] ] operations = [ [1, 2, 1], # Set grid[2][1] to 'S' [1, 1, 0] # Set grid[1][0] to 'S' ] pathfinder = PathFinder(grid) pathfinder.applyOperations(operations) assert pathfinder.hasSafePath() == True def test_operations_remove_safe_path(): grid = [ ['S', 'S', 'T'], ['S', 'S', 'S'], ['T', 'T', 'S'] ] operations = [ [2, 1, 1], # Set grid[1][1] to 'T' [2, 2, 2] # Set grid[2][2] to 'T' ] pathfinder = PathFinder(grid) pathfinder.applyOperations(operations) assert pathfinder.hasSafePath() == False def test_boundary_cells_trapped(): grid = [ ['T', 'S', 'S'], ['S', 'T', 'S'], ['S', 'S', 'T'] ] pathfinder = PathFinder(grid) assert pathfinder.hasSafePath() == False","solution":"class PathFinder: def __init__(self, grid): self.grid = grid self.n = len(grid) def applyOperations(self, operations): for operation in operations: op_type, x, y = operation if op_type == 1: self.grid[x][y] = 'S' elif op_type == 2: self.grid[x][y] = 'T' def hasSafePath(self): if self.grid[0][0] == 'T' or self.grid[self.n - 1][self.n - 1] == 'T': return False visited = [[False] * self.n for _ in range(self.n)] return self.dfs(0, 0, visited) def dfs(self, x, y, visited): if x < 0 or y < 0 or x >= self.n or y >= self.n or self.grid[x][y] == 'T' or visited[x][y]: return False if x == self.n - 1 and y == self.n - 1: return True visited[x][y] = True # Explore all four possible directions if (self.dfs(x + 1, y, visited) or self.dfs(x - 1, y, visited) or self.dfs(x, y + 1, visited) or self.dfs(x, y - 1, visited)): return True return False"},{"question":"def count_complete_components(n: int, roads: List[List[int]]) -> int: Determines the number of complete connected components in a road network. >>> count_complete_components(3, [[0, 1], [1, 2], [0, 2]]) 1 >>> count_complete_components(6, [[0, 1], [1, 2], [0, 2], [3, 4], [4, 5], [3, 5]]) 2 >>> count_complete_components(4, [[0, 1], [1, 2], [2, 3]]) 0 >>> count_complete_components(6, [[0, 1], [1, 2], [0, 2], [3, 4], [4, 5]]) 1 >>> count_complete_components(1, []) 1 >>> count_complete_components(2, [[0, 1]]) 1 >>> count_complete_components(2, []) 2","solution":"def count_complete_components(n, roads): from collections import defaultdict def is_complete_graph(component): num_nodes = len(component) num_edges = sum(len(adj[node]) for node in component) // 2 # because each edge is counted twice return num_edges == num_nodes * (num_nodes - 1) // 2 def dfs(node, visited, component): visited.add(node) component.add(node) for neighbor in adj[node]: if neighbor not in visited: dfs(neighbor, visited, component) # Create adjacency list for the graph adj = defaultdict(list) for u, v in roads: adj[u].append(v) adj[v].append(u) visited = set() complete_components_count = 0 # Traverse all nodes to find all connected components for node in range(n): if node not in visited: component = set() dfs(node, visited, component) if is_complete_graph(component): complete_components_count += 1 return complete_components_count"},{"question":"def longest_consecutive_subarray(arr: List[int]) -> int: Given an integer array \`arr\`, find the length of the longest contiguous subarray such that if you take all the elements of the subarray and rearrange them in any order, it forms a sequence of consecutive integers. A sequence of consecutive integers is an ordered list of integers where each number has exactly one less or one more than the number immediately before or after it. >>> longest_consecutive_subarray([1, 2, 3, 4, 5]) 5 >>> longest_consecutive_subarray([1, 3, 5, 7]) 1 >>> longest_consecutive_subarray([1, 2, 2, 3, 4]) 3 >>> longest_consecutive_subarray([-1, 0, 1, 2, -3, 4, 5]) 4 >>> longest_consecutive_subarray([1]) 1 >>> longest_consecutive_subarray([]) 0 >>> longest_consecutive_subarray([4, 3, 1, 0, 2, 5, 8, 6, 7]) 9 >>> longest_consecutive_subarray([5, 1, 3, 2, 4]) 5 >>> longest_consecutive_subarray([1, 2, 2, 3, 4, 5, 6]) 5 pass","solution":"def longest_consecutive_subarray(arr): Returns the length of the longest contiguous subarray that can be rearranged to form a sequence of consecutive integers. if not arr: return 0 max_len = 1 for i in range(len(arr)): min_val = max_val = arr[i] unique_elements = {arr[i]} for j in range(i + 1, len(arr)): if arr[j] in unique_elements: break unique_elements.add(arr[j]) min_val = min(min_val, arr[j]) max_val = max(max_val, arr[j]) if max_val - min_val == j - i: max_len = max(max_len, j - i + 1) return max_len"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def findGCA(root, p, q): Find the greatest common ancestor of two given nodes in the binary tree. >>> root = TreeNode(3) >>> root.left = TreeNode(5) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(6) >>> root.left.right = TreeNode(2) >>> root.right.left = TreeNode(0) >>> root.right.right = TreeNode(8) >>> p = root.left >>> q = root.left.right >>> findGCA(root, p, q) is root.left True >>> p = root.right.left >>> q = root.right.right >>> findGCA(root, p, q) is root.right True >>> p = root.left >>> q = root.right >>> findGCA(root, p, q) is root True >>> p = root.left.left >>> q = root.left.left >>> findGCA(root, p, q) is root.left.left True","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def findGCA(root, p, q): if not root or root == p or root == q: return root left = findGCA(root.left, p, q) right = findGCA(root.right, p, q) if left and right: return root return left if left else right"},{"question":"from typing import List class Solution: def findTwoSum(self, nums: List[int], target: int) -> List[int]: Returns the indices [i, j] such that nums[i] + nums[j] equals target, or an empty list if no such pair exists. Example: >>> s = Solution() >>> s.findTwoSum([2, 7, 11, 15], 9) [0, 1] >>> s.findTwoSum([3, 2, 4], 6) [1, 2] >>> s.findTwoSum([3, 3], 6) [0, 1] >>> s.findTwoSum([1, 2, 3], 7) [] >>> s.findTwoSum([5], 5) [] >>> s.findTwoSum([-1, -2, -3, -4, -5], -8) [2, 4] >>> s.findTwoSum([2, 3, 4, -2], 0) [0, 3]","solution":"from typing import List class Solution: def findTwoSum(self, nums: List[int], target: int) -> List[int]: Returns the indices [i, j] such that nums[i] + nums[j] equals target, or an empty list if no such pair exists. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return sorted([num_to_index[complement], i]) num_to_index[num] = i return []"},{"question":"def length_of_smallest_subsequence_with_all_distinct_chars(s: str) -> int: Given a string s, find the length of the smallest subsequence of s that contains all distinct characters of s. A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. >>> length_of_smallest_subsequence_with_all_distinct_chars(\\"abcabc\\") 3 >>> length_of_smallest_subsequence_with_all_distinct_chars(\\"abcdef\\") 6 >>> length_of_smallest_subsequence_with_all_distinct_chars(\\"aaaa\\") 1 >>> length_of_smallest_subsequence_with_all_distinct_chars(\\"aabbcc\\") 3 >>> length_of_smallest_subsequence_with_all_distinct_chars(\\"a\\") 1 >>> length_of_smallest_subsequence_with_all_distinct_chars(\\"\\") 0","solution":"def length_of_smallest_subsequence_with_all_distinct_chars(s): Returns the length of the smallest subsequence that contains all distinct characters of the string s. # Use a set to determine unique characters in the string unique_chars = set(s) # The length of the desired subsequence is just the number of unique characters return len(unique_chars)"},{"question":"def update_array(nums, operations): Apply a series of operations to the nums array. Each operation is a triplet (start, end, delta) that increments each element of the subarray nums[start...end] (both inclusive) by delta. Args: nums (list of int): The initial state of the array. operations (list of tuple): A list of operations where each operation is (start, end, delta). Returns: list of int: The updated array after all operations have been applied. Examples: >>> update_array([1, 2, 3, 4], [(1, 3, 2)]) [1, 4, 5, 6] >>> update_array([0, 0, 0, 0], [(0, 1, 1), (2, 3, 2), (1, 2, 3)]) [1, 4, 5, 2] >>> update_array([4, 4, 4, 4], [(0, 2, 2), (1, 3, 3)]) [6, 9, 9, 7] >>> update_array([1, 2, 3], []) [1, 2, 3] >>> update_array([0]*5, [(0, 4, 1000000000)]) [1000000000, 1000000000, 1000000000, 1000000000, 1000000000]","solution":"def update_array(nums, operations): Apply a series of operations to the nums array. Each operation is a triplet (start, end, delta) that increments each element of the subarray nums[start...end] (both inclusive) by delta. Args: nums (list of int): The initial state of the array. operations (list of tuple): A list of operations where each operation is (start, end, delta). Returns: list of int: The updated array after all operations have been applied. for (start, end, delta) in operations: for i in range(start, end + 1): nums[i] += delta return nums"},{"question":"def is_path_exists(grid: List[List[int]]) -> bool: Determines if there exists a path from the top-left corner to the bottom-right corner. Parameters: grid (List[List[int]]): The grid represented as a list of lists, where 1 represents a wall and 0 represents an open space. Returns: bool: True if a path exists, False otherwise. >>> is_path_exists([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == True >>> is_path_exists([ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) == False >>> is_path_exists([[0]]) == True >>> is_path_exists([[1]]) == False >>> is_path_exists([ ... [0, 0, 1, 0], ... [1, 0, 1, 0], ... [1, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0] ... ]) == True >>> is_path_exists([ ... [0, 0, 0, 0], ... [1, 1, 1, 0], ... [0, 0, 0, 1], ... [0, 1, 0, 0] ... ]) == False","solution":"def is_path_exists(grid): Determines if there exists a path from the top-left corner to the bottom-right corner. Parameters: grid (List[List[int]]): The grid represented as a list of lists, where 1 represents a wall and 0 represents an open space. Returns: bool: True if a path exists, False otherwise. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return False m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == 1 or visited[x][y]: return False if x == m - 1 and y == n - 1: return True visited[x][y] = True return dfs(x + 1, y) or dfs(x - 1, y) or dfs(x, y + 1) or dfs(x, y - 1) return dfs(0, 0)"},{"question":"import heapq def find_kth_largest(nums, k): Returns the k-th largest element in the array nums. Parameters: nums (list): List of integers k (int): The order of the largest element to find (1-based index) Returns: int: The k-th largest element pass def test_find_kth_largest(): assert find_kth_largest([3,2,1,5,6,4], 2) == 5, \\"Test case 1 failed\\" assert find_kth_largest([3,2,3,1,2,4,5,5,6], 4) == 4, \\"Test case 2 failed\\" assert find_kth_largest([1], 1) == 1, \\"Test case 3 failed\\" assert find_kth_largest([7,6,5,4,3,2,1], 5) == 3, \\"Test case 4 failed\\" assert find_kth_largest([1,2,3,4,5,6,7,8,9,10], 6) == 5, \\"Test case 5 failed\\" assert find_kth_largest([2, 1], 1) == 2, \\"Test case 6 failed\\" assert find_kth_largest([2, 1], 2) == 1, \\"Test case 7 failed\\"","solution":"import heapq def find_kth_largest(nums, k): Returns the k-th largest element in the array nums. Parameters: nums (list): List of integers k (int): The order of the largest element to find (1-based index) Returns: int: The k-th largest element min_heap = [] for num in nums: heapq.heappush(min_heap, num) if len(min_heap) > k: heapq.heappop(min_heap) return min_heap[0]"},{"question":"def reverse_words_and_string(s: str) -> str: Given a string s, reverse the order of the words in the string and reverse each word as well. Parameters: s (str): A string formatted as multiple words separated by single spaces with no leading or trailing spaces. Returns: str: The resultant string with reversed words and their order reversed. >>> reverse_words_and_string(\\"hello world\\") 'dlrow olleh' >>> reverse_words_and_string(\\"this is a test\\") 'tset a si siht' >>> reverse_words_and_string(\\"madam racecar level\\") 'level racecar madam' >>> reverse_words_and_string(\\"Abc DEf GHi\\") 'iHG fED cbA' >>> reverse_words_and_string(\\"123 456 7890\\") '0987 654 321'","solution":"def reverse_words_and_string(s): Given a string s, reverse the order of the words in the string and reverse each word as well. Parameters: s (str): A string formatted as multiple words separated by single spaces with no leading or trailing spaces. Returns: str: The resultant string with reversed words and their order reversed. words = s.split() reversed_words = [word[::-1] for word in words] reversed_sentence = ' '.join(reversed_words[::-1]) return reversed_sentence"},{"question":"def three_sum(arr: List[int], target: int) -> bool: Determine if there are three distinct integers in \`arr\` that add up to \`target\`. >>> three_sum([1, 2, 3, 4, 5, 6, 7], 12) == True >>> three_sum([0, -1, 2, -3, 1], 0) == True >>> three_sum([-1, 0, 1, 2, -1, -4], -5) == True >>> three_sum([1, 2, 3, 4, 5], 15) == False >>> three_sum([5, 3, 2, 1, 0], 20) == False >>> three_sum([-1, 9, 8, 6, 3], 30) == False >>> large_array = list(range(1000)) >>> three_sum(large_array, 3000) == False >>> three_sum(large_array, 1500) == True >>> three_sum([-5, -2, -3, -1, 0, 1, 2], -6) == True >>> three_sum([-8, -6, -4, -3, -2, 2], -10) == True >>> three_sum([1, 1, 1, 2, 2, 2], 6) == True >>> three_sum([5, 5, 5, 6, 6, 6], 18) == True >>> three_sum([1, 1, 1, 1, 1], 4) == False","solution":"def three_sum(arr, target): Returns true if there are three integers in the array \`arr\` that add up to \`target\`, otherwise returns false. arr.sort() n = len(arr) for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, n - 1 while left < right: curr_sum = arr[i] + arr[left] + arr[right] if curr_sum == target: return True elif curr_sum < target: left += 1 else: right -= 1 return False"},{"question":"def perform_actions(s: str, actions: List[List[Union[int, str]]]) -> List[int]: Ana is organizing a string-based puzzle competition and she wants to track participants' performance over time. She has a 0-indexed string \`s\` consisting of lowercase English letters and a 0-indexed 2D integer array \`actions\`. Each \`actions[i]\` can be of two types: - If \`type\` is \`1\`, find the number of unique characters in the substring \`s[left...right]\`. - If \`type\` is \`2\`, replace the character at index \`left\` in string \`s\` with character \`char\`. Return an array \`results\` where \`results[i]\` is the result of the \`i-th\` action if \`type\` is \`1\`. Example: >>> perform_actions(\\"abcdabc\\", [[1, 0, 3], [2, 2, 'z'], [1, 1, 4]]) [4, 4] >>> perform_actions(\\"abcdabc\\", [[2, 2, 'z'], [1, 1, 4]]) [4]","solution":"def perform_actions(s, actions): results = [] s = list(s) # Convert string to list for easy manipulation for action in actions: if action[0] == 1: left, right = action[1], action[2] substring = s[left:right + 1] unique_chars = len(set(substring)) results.append(unique_chars) elif action[0] == 2: index, char = action[1], action[2] s[index] = char return results"},{"question":"def find_anagrams(words): Given an array of strings 'words', find and return all strings that are anagrams of another string in the array. An anagram is a word formed by rearranging the letters of a different word, using all the original letters exactly once. Strings should be returned in the order they appear in the input array. If no strings are anagrams of another string, return an empty list. >>> find_anagrams([\\"listen\\", \\"enlist\\", \\"rat\\", \\"tar\\", \\"god\\", \\"dog\\"]) [\\"listen\\", \\"enlist\\", \\"rat\\", \\"tar\\", \\"god\\", \\"dog\\"] >>> find_anagrams([\\"hello\\", \\"world\\", \\"python\\"]) []","solution":"def find_anagrams(words): Returns a list of strings that are anagrams of another string in the array. Parameters: words (list): List of strings. Returns: list: List of anagram strings. from collections import defaultdict anagrams_dict = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagrams_dict[sorted_word].append(word) result = [] for word_list in anagrams_dict.values(): if len(word_list) > 1: result.extend(word_list) return result"},{"question":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Given a binary tree, where each node contains an integer value, return a 2D array where each element is a list of integers representing the node values at each depth level from top to bottom. The root node is at depth level 0, its children are at depth level 1, their children are at depth level 2, and so on. If the tree is empty, return an empty list. >>> level_order_traversal(None) [] >>> root = TreeNode(1) >>> level_order_traversal(root) [[1]] >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> level_order_traversal(root) [[1], [2, 3]] >>> root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3, TreeNode(5), TreeNode(6))) >>> level_order_traversal(root) [[1], [2, 3], [4, 5, 6]] >>> root = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4))), None) >>> level_order_traversal(root) [[1], [2], [3], [4]]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"def minimum_heater_radius(houses: List[int], k: int) -> int: Returns the minimum heater radius \`d\` such that all houses are covered by \`k\` heaters. >>> minimum_heater_radius([5, 5, 5, 5], 1) == 0 >>> minimum_heater_radius([1, 2, 3, 4, 5], 1) == 2 >>> minimum_heater_radius([1, 2, 3, 4, 5, 6, 7], 2) == 2 >>> minimum_heater_radius([10, 20, 30, 40, 50], 2) == 10 >>> minimum_heater_radius([1, 10, 20, 30, 40], 2) == 10 >>> minimum_heater_radius([2, 5, 9], 4) == 0","solution":"def can_cover_with_d(houses, k, d): Helper function to check if all houses can be covered by k heaters with a given radius d. heaters_count = 0 i = 0 while i < len(houses): heaters_count += 1 if heaters_count > k: return False # Place the heater to cover as many houses as possible cover_position = houses[i] + d # Move i to the next house which is not covered by this heater while i < len(houses) and houses[i] <= cover_position + d: i += 1 return True def minimum_heater_radius(houses, k): Returns the minimum heater radius \`d\` such that all houses are covered by \`k\` heaters. houses.sort() left = 0 right = houses[-1] - houses[0] while left < right: mid = (left + right) // 2 if can_cover_with_d(houses, k, mid): right = mid else: left = mid + 1 return left"},{"question":"def num_valid_parentheses(n: int) -> int: Returns the number of valid parentheses strings of length 2n. >>> num_valid_parentheses(0) == 1 >>> num_valid_parentheses(1) == 1 >>> num_valid_parentheses(2) == 2 >>> num_valid_parentheses(3) == 5 >>> num_valid_parentheses(4) == 14 >>> num_valid_parentheses(5) == 42 >>> num_valid_parentheses(10) == 16796 >>> num_valid_parentheses(20) == 6564120420","solution":"def catalan_number(n): Returns the nth Catalan number. if n == 0: return 1 catalan = [0] * (n + 1) catalan[0] = 1 for i in range(1, n + 1): for j in range(i): catalan[i] += catalan[j] * catalan[i - 1 - j] return catalan[n] def num_valid_parentheses(n): Returns the number of valid parentheses strings of length 2n. return catalan_number(n)"},{"question":"from typing import List def four_sum(arr: List[int], target: int) -> List[List[int]]: Find all unique quadruplets in the array which sum up to the target. >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([1, 2, 3, 4], 50) [] >>> four_sum([1, 1, 1, 1, 1, 1], 4) [[1, 1, 1, 1]] >>> four_sum([1, 2, 3, 4], 10) [[1, 2, 3, 4]] >>> four_sum([-1, -1, 1, 1, 0, 0], 0) [[-1, -1, 1, 1], [-1, 0, 0, 1]]","solution":"def four_sum(arr, target): Returns a list of all unique quadruplets [a, b, c, d] such that a + b + c + d = target. arr.sort() result = [] length = len(arr) for i in range(length - 3): if i > 0 and arr[i] == arr[i - 1]: continue for j in range(i + 1, length - 2): if j > i + 1 and arr[j] == arr[j - 1]: continue left, right = j + 1, length - 1 while left < right: total = arr[i] + arr[j] + arr[left] + arr[right] if total == target: result.append([arr[i], arr[j], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return result"},{"question":"def reverse_words(s: str) -> str: Given a string representing a sentence containing words separated by spaces, reverse the order of words in the sentence while preserving the spacing and punctuation. >>> reverse_words(\\"Hello\\") 'Hello' >>> reverse_words(\\"Hello world\\") 'world Hello' >>> reverse_words(\\" Hello world \\") 'world Hello' >>> reverse_words(\\"Hello, world!\\") 'world! Hello,' >>> reverse_words(\\"Hello, wonderful world!\\") 'world! wonderful Hello,' >>> reverse_words(\\"Hello World\\") 'World Hello' >>> reverse_words(\\"\\") '' >>> reverse_words(\\" \\") ''","solution":"def reverse_words(s): Function to reverse the order of words in a sentence while preserving the spacing and punctuation. Arguments: s -- string representing the input sentence Returns: A string with the words in reversed order. # Split the sentence by spaces to get the words words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words with a single space reversed_sentence = ' '.join(reversed_words) # Return the reversed sentence return reversed_sentence"},{"question":"def subtractOne(digits: List[int]) -> List[int]: Subtract one from the number represented by the digits array. >>> subtractOne([1, 2, 3]) == [1, 2, 2] >>> subtractOne([1, 0, 0]) == [9, 9] >>> subtractOne([1]) == [0] >>> subtractOne([2, 0, 0, 0]) == [1, 9, 9, 9] >>> subtractOne([1, 0]) == [9] >>> subtractOne([9]) == [8]","solution":"def subtractOne(digits): Subtracts one from the number represented by the digits array. n = len(digits) # Start from the end of the array for i in range(n-1, -1, -1): if digits[i] > 0: digits[i] -= 1 break else: digits[i] = 9 # If the first element is zero and the array length is greater than 1, remove it if digits[0] == 0 and len(digits) > 1: digits.pop(0) return digits"},{"question":"def min_books_difference(nums: List[int]) -> int: Redistribute books among the shelves to minimize the difference between the maximum number of books on any shelf and the minimum number of books on any shelf. Args: nums (List[int]): A list where nums[i] is the number of books on the i-th shelf. Returns: int: The minimum possible difference between the maximum and minimum number of books after redistribution. >>> min_books_difference([3, 3, 3]) 0 >>> min_books_difference([4, 1, 7, 6]) 0 >>> min_books_difference([5]) 0 >>> min_books_difference([]) None","solution":"def min_books_difference(nums): Returns the minimum difference between the maximum and minimum number of books on any shelf after redistributing. # The minimum possible difference is zero if all shelves can have the same number of books return 0 if nums else None"},{"question":"def max_weight_lift(nums, k): Finds the maximum sum of weights lifted in any consecutive k days. :param nums: List of integers representing the amount of weight lifted each day. :param k: Integer representing the number of consecutive days. :return: Maximum sum of weights lifted in any consecutive k days, or 0 if it is not possible. >>> max_weight_lift([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == 27 >>> max_weight_lift([1, 2], 3) == 0","solution":"def max_weight_lift(nums, k): Finds the maximum sum of weights lifted in any consecutive k days. :param nums: List of integers representing the amount of weight lifted each day. :param k: Integer representing the number of consecutive days. :return: Maximum sum of weights lifted in any consecutive k days, or 0 if it is not possible. if len(nums) < k: return 0 max_sum = current_sum = sum(nums[:k]) for i in range(k, len(nums)): current_sum += nums[i] - nums[i-k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def findMinPathSum(grid): Returns the minimum path sum from the top-left corner to the bottom-right corner of a 2D grid moving only right or down. >>> findMinPathSum([[5]]) == 5 >>> findMinPathSum([[1,2], [1,1]]) == 3 >>> findMinPathSum([[1, 2, 3]]) == 6 >>> findMinPathSum([[1], [2], [3]]) == 6 >>> findMinPathSum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> findMinPathSum([]) == 0 >>> findMinPathSum([[]]) == 0","solution":"def findMinPathSum(grid): Returns the minimum path sum from the top-left corner to the bottom-right corner of a 2D grid moving only right or down. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Create a dp grid to store the minimum path sum up to each cell dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] # Fill the values for the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the values for the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Compute minimum path sums for the rest of the cells for i in range(1, rows): for j in range(1, cols): dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) return dp[rows-1][cols-1]"},{"question":"def count_monotonic_subarrays(arr: List[int]) -> int: Returns the number of monotonic subarrays in the given array \`arr\`. A subarray is monotonic if it is either strictly increasing or strictly decreasing. >>> count_monotonic_subarrays([1]) 0 >>> count_monotonic_subarrays([1, 2]) 1 >>> count_monotonic_subarrays([3, 2]) 1 >>> count_monotonic_subarrays([1, 2, 3]) 3 >>> count_monotonic_subarrays([1, 3, 2]) 2 >>> count_monotonic_subarrays([1, 2, 3, 4]) 6 >>> count_monotonic_subarrays([4, 3, 2, 1]) 6 >>> count_monotonic_subarrays([1, 1, 1, 1]) 0 >>> count_monotonic_subarrays([1, 2, 1, 2, 3, 1]) 6","solution":"def count_monotonic_subarrays(arr): Returns the number of monotonic subarrays in the given array \`arr\`. A subarray is monotonic if it is either strictly increasing or strictly decreasing. def is_increasing(a, b): return a < b def is_decreasing(a, b): return a > b n = len(arr) count = 0 i = 0 while i < n: length = 1 # Check for increasing subarrays while i + 1 < n and is_increasing(arr[i], arr[i+1]): i += 1 length += 1 count += (length * (length - 1)) // 2 length = 1 start = i # Check for decreasing subarrays while i + 1 < n and is_decreasing(arr[i], arr[i+1]): i += 1 length += 1 count += (length * (length - 1)) // 2 if i == start: i += 1 return count"},{"question":"def min_subarray_len(arr: List[int], x: int) -> int: Returns the length of the smallest contiguous subarray where the sum is greater than or equal to x. If no such subarray exists, return -1. >>> min_subarray_len([1, 2, 3, 4, 5], 20) -1 >>> min_subarray_len([10], 10) 1 >>> min_subarray_len([1, 2, 3, 4, 5], 15) 5 >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 4, 4], 8) 2 >>> min_subarray_len([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15) 2 >>> min_subarray_len([1, 1, 1, 1, 1, 1, 1], 8) -1","solution":"def min_subarray_len(arr, x): Returns the length of the smallest contiguous subarray where the sum is greater than or equal to x. If no such subarray exists, return -1. n = len(arr) min_len = float('inf') left = 0 curr_sum = 0 for right in range(n): curr_sum += arr[right] while curr_sum >= x: min_len = min(min_len, right - left + 1) curr_sum -= arr[left] left += 1 return min_len if min_len != float('inf') else -1"},{"question":"def canPartitionKSubarrays(arr: List[int], k: int) -> bool: Determine whether the array can be partitioned into exactly k subarrays such that the sum of elements in each subarray is equal. >>> canPartitionKSubarrays([4, 3, 2, 3, 5, 2, 1], 4) == True >>> canPartitionKSubarrays([1, 2, 3, 4], 3) == False >>> canPartitionKSubarrays([2, 2, 2, 2, 2, 2], 3) == True >>> canPartitionKSubarrays([1, 1, 1, 1, 2, 2, 2, 2], 4) == True >>> canPartitionKSubarrays([2, 2, 2, 2, 3, 3], 2) == True >>> canPartitionKSubarrays([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 5) == True >>> canPartitionKSubarrays([10], 1) == True >>> canPartitionKSubarrays([1, 1, 1, 1], 1) == True >>> canPartitionKSubarrays([2, 4, 5], 2) == False pass","solution":"def canPartitionKSubarrays(arr, k): total_sum = sum(arr) # If total sum is not divisible by k, then we cannot partition it into k subarrays with equal sum if total_sum % k != 0: return False subarray_sum = total_sum // k used = [False] * len(arr) def can_partition(start_index, k_remaining, current_sum): # If only one subarray is remaining, it must be the valid subarray with the required sum if k_remaining == 1: return True if current_sum == subarray_sum: # A subarray with the required sum is found, try to find the next one return can_partition(0, k_remaining - 1, 0) for i in range(start_index, len(arr)): if not used[i] and current_sum + arr[i] <= subarray_sum: # Select this element and mark as used used[i] = True if can_partition(i + 1, k_remaining, current_sum + arr[i]): return True used[i] = False return False return can_partition(0, k, 0)"},{"question":"def min_refills(arr: List[int], k: int) -> int: Returns the minimum number of refills needed to water all the plants. Parameters: arr (list): A list of integers representing the consumption rate of water per hour for different plants. k (int): the capacity of the bucket. Returns: int: The minimum number of refills needed. >>> min_refills([2, 4, 3, 5], 6) 2 >>> min_refills([5], 10) 0 >>> min_refills([10], 10) 0 >>> min_refills([11], 10) 1 >>> min_refills([3, 3, 3, 3], 3) 3 >>> min_refills([1, 2, 1], 5) 0 >>> min_refills([2, 2, 2, 2, 2, 2], 4) 2 >>> min_refills([5, 6, 4, 10], 10) 2 >>> min_refills([], 10) 0 >>> min_refills([1, 1, 1, 1, 1], 5) 0","solution":"def min_refills(arr, k): Returns the minimum number of refills needed to water all the plants. Parameters: arr (list): A list of integers representing the consumption rate of water per hour for different plants. k (int): the capacity of the bucket. Returns: int: The minimum number of refills needed. refills = 0 current_capacity = k for consumption in arr: if current_capacity >= consumption: current_capacity -= consumption else: refills += 1 current_capacity = k - consumption return refills"},{"question":"def is_subsequence(s: str, word: str) -> bool: Helper function to check if word is a subsequence of s >>> is_subsequence(\\"abcde\\", \\"ace\\") True >>> is_subsequence(\\"abcde\\", \\"aec\\") False # Implement the function here def num_matching_subseq(s: str, words: List[str]) -> int: Determine the number of words in \`words\` that are subsequences of \`s\`. >>> num_matching_subseq(\\"abcde\\", [\\"a\\", \\"bb\\", \\"acd\\", \\"ace\\"]) == 3 >>> num_matching_subseq(\\"abcde\\", [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"]) == 5 >>> num_matching_subseq(\\"abcde\\", [\\"f\\", \\"g\\", \\"h\\"]) == 0 >>> num_matching_subseq(\\"abcdefg\\", [\\"abc\\", \\"bdg\\", \\"fg\\"]) == 3 >>> num_matching_subseq(\\"abcdefghijk\\", [\\"abc\\", \\"def\\", \\"ghij\\", \\"ijk\\", \\"mnop\\"]) == 4 # Implement the function here","solution":"def is_subsequence(s, word): Helper function to check if word is a subsequence of s it = iter(s) return all(char in it for char in word) def num_matching_subseq(s, words): Returns the number of words that are subsequences of s count = 0 for word in words: if is_subsequence(s, word): count += 1 return count"},{"question":"from typing import List def min_largest_element(nums: List[int]) -> int: Determines the minimum possible value of the largest element in the array after any number of operations. :param nums: List[int] - an array of integers :return: int - the minimum possible value of the largest element in the array >>> min_largest_element([10]) 10 >>> min_largest_element([5, 5, 5, 5]) 5 >>> min_largest_element([3, 7, 11]) 1 >>> min_largest_element([6, 12, 15]) 3 >>> min_largest_element([2, 4, 8]) 2 >>> min_largest_element([18, 24, 36]) 6 >>> min_largest_element([100, 200, 300, 400]) 100","solution":"from functools import reduce from math import gcd def min_largest_element(nums): Determines the minimum possible value of the largest element in the array after any number of operations. :param nums: List[int] - an array of integers :return: int - the minimum possible value of the largest element in the array # The number can be reduced to the gcd of all numbers in the array array_gcd = reduce(gcd, nums) return array_gcd"},{"question":"def gcd(a: int, b: int) -> int: Returns the greatest common divisor (GCD) of two positive integers a and b using the Euclidean algorithm. >>> gcd(10, 10) == 10 >>> gcd(25, 100) == 25 >>> gcd(7, 13) == 1 >>> gcd(48, 18) == 6 >>> gcd(270, 192) == 6 >>> gcd(17, 13) == 1 >>> gcd(19, 2) == 1 >>> gcd(123456, 789012) == 12","solution":"def gcd(a, b): Returns the greatest common divisor (GCD) of two positive integers a and b using the Euclidean algorithm. while b: a, b = b, a % b return a"},{"question":"from typing import List from collections import deque def shortest_path(grid: List[List[int]], k: int) -> int: Return the minimum number of steps required to walk from the top-left corner to the bottom-right corner with up to k eliminations of blocked cells. >>> grid = [ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0], ... [0, 1, 1], ... [0, 0, 0] ... ] >>> k = 1 >>> shortest_path(grid, k) 6 >>> grid = [ ... [0, 1, 1], ... [1, 1, 0], ... [1, 0, 0] ... ] >>> k = 1 >>> shortest_path(grid, k) -1 >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> k = 0 >>> shortest_path(grid, k) 4 >>> grid = [ ... [0, 1, 1], ... [1, 0, 0], ... [1, 1, 0] ... ] >>> k = 2 >>> shortest_path(grid, k) 4 >>> grid = [[0]] >>> k = 0 >>> shortest_path(grid, k) 0","solution":"from collections import deque def shortest_path(grid, k): rows, cols = len(grid), len(grid[0]) if rows == 1 and cols == 1: # Starting and ending on the same cell return 0 # Initialize the queue with the starting point, 0 steps, and \`k\` eliminations left queue = deque([(0, 0, 0, k)]) visited = set((0, 0, k)) while queue: x, y, steps, remaining_k = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # Up, Down, Left, Right movements nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols: # Check boundaries new_eliminations = remaining_k - grid[nx][ny] if new_eliminations >= 0: # If we can still eliminate cells if (nx, ny) == (rows - 1, cols - 1): # Reached the bottom-right corner return steps + 1 if (nx, ny, new_eliminations) not in visited: visited.add((nx, ny, new_eliminations)) queue.append((nx, ny, steps + 1, new_eliminations)) return -1"},{"question":"def longest_contiguous_ones(s: str) -> int: Returns the length of the longest contiguous substring of '1's one can achieve by changing at most one '0' to '1'. >>> longest_contiguous_ones(\\"110111\\") == 6 >>> longest_contiguous_ones(\\"101101\\") == 4 >>> longest_contiguous_ones(\\"0000\\") == 1","solution":"def longest_contiguous_ones(s): Returns the length of the longest contiguous substring of '1's one can achieve by changing at most one '0' to '1'. max_len = 0 zero_count = 0 left = 0 for right in range(len(s)): if s[right] == '0': zero_count += 1 while zero_count > 1: if s[left] == '0': zero_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def count_scores_within_range(scores: List[int], queries: List[List[int]]) -> List[int]: Returns a list of count of students who scored within given ranges for each query. Parameters: scores (list of int): List of student scores. queries (list of list of int): List of queries where each query is a list with two integers [low, high]. Returns: list of int: List of counts for each query. # Unit tests def test_count_scores_within_range_all_scores(): scores = [85, 78, 90, 95, 67, 88] queries = [[60, 100]] assert count_scores_within_range(scores, queries) == [6] def test_count_scores_within_range_individual_ranges(): scores = [85, 78, 90, 95, 67, 88] queries = [[70, 80], [85, 95], [60, 70]] assert count_scores_within_range(scores, queries) == [1, 4, 1] def test_count_scores_within_range_no_matches(): scores = [85, 78, 90, 95, 67, 88] queries = [[96, 100], [50, 66]] assert count_scores_within_range(scores, queries) == [0_minus', 'r_txn_bnocorr_cf', 'r_invest_deact3600_minus', 'r_invbstcf', 'r_dvpayf', 'r_eepo', 'r_dpc', 'r_eqpl_f', 'r_stborf', 'r_ti_opcf', 'r_mi_amort', 'r_tlcf', 'r_adj_dp', 'r_spin', 'r_invnp_cf', 'r_oilgas_f', 'r_acs', 'r_fx', 'r_miinvs', 'r_frnloassets', 'r_spen', ] # Only include scores between the given low and high for each query results = [] for low, high in queries: # count the scores within the range of the query count = sum(1 for score in scores if low <= score <= high) results.append(count) return results","solution":"def count_scores_within_range(scores, queries): Returns a list of count of students who scored within given ranges for each query. Parameters: scores (list of int): List of student scores. queries (list of list of int): List of queries where each query is a list with two integers [low, high]. Returns: list of int: List of counts for each query. results = [] for low, high in queries: count = sum(1 for score in scores if low <= score <= high) results.append(count) return results"},{"question":"def addOperators(num: str, target: int): Return all possibilities to add binary operators (\`+\`, \`-\`, or \`*\`) between the digits of \`s\` so that the resultant expression evaluates to the \`target\` value. >>> sorted(addOperators(\\"123\\", 6)) == sorted([\\"1+2+3\\", \\"1*2*3\\"]) >>> sorted(addOperators(\\"232\\", 8)) == sorted([\\"2*3+2\\", \\"2+3*2\\"]) >>> sorted(addOperators(\\"105\\", 5)) == sorted([\\"1*0+5\\", \\"10-5\\"]) >>> sorted(addOperators(\\"00\\", 0)) == sorted([\\"0+0\\", \\"0-0\\", \\"0*0\\"]) >>> addOperators(\\"3456237490\\", 9191) == [] >>> sorted(addOperators(\\"1\\", 1)) == [\\"1\\"] >>> addOperators(\\"1\\", 2) == []","solution":"def addOperators(num, target): def backtrack(index, prev_operand, current_operand, value, expression): if index == len(num): if value == target and current_operand == 0: results.append(\\"\\".join(expression[1:])) return current_operand = current_operand * 10 + int(num[index]) str_op = str(current_operand) if current_operand > 0: backtrack(index + 1, prev_operand, current_operand, value, expression) expression.append('+') expression.append(str_op) backtrack(index + 1, current_operand, 0, value + current_operand, expression) expression.pop() expression.pop() if expression: expression.append('-') expression.append(str_op) backtrack(index + 1, -current_operand, 0, value - current_operand, expression) expression.pop() expression.pop() expression.append('*') expression.append(str_op) backtrack(index + 1, prev_operand * current_operand, 0, value - prev_operand + (prev_operand * current_operand), expression) expression.pop() expression.pop() results = [] if num: backtrack(0, 0, 0, 0, []) return results"},{"question":"def evaluate(expression: str) -> int: Evaluate the arithmetic expression and return the result as an integer. The integer division should truncate toward zero and the result is guaranteed to be within the range of a 32-bit signed integer. The given \`expression\` is always valid. >>> evaluate(\\"3+2*2\\") == 7 >>> evaluate(\\" 3/2 \\") == 1 >>> evaluate(\\" 3+5 / 2 \\") == 5 >>> evaluate(\\"(1+(4+5+2)-3)+(6+8)\\") == 23 >>> evaluate(\\"2-1 + 2 \\") == 3 >>> evaluate(\\"2*(5+5*2)/3+(6/2+8)\\") == 21 >>> evaluate(\\"0-2147483648\\") == -2147483648 >>> evaluate(\\"14-3/2\\") == 13","solution":"def evaluate(expression: str) -> int: def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_op(a, b, op): if op == '+': return a + b if op == '-': return a - b if op == '*': return a * b if op == '/': return int(a / b) # use int() for truncating division towards zero def evaluate_tokens(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == ' ': i += 1 continue if tokens[i] == '(': ops.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while i < len(tokens) and tokens[i].isdigit(): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == ')': while len(ops) != 0 and ops[-1] != '(': op = ops.pop() val2 = values.pop() val1 = values.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(tokens[i])): op = ops.pop() val2 = values.pop() val1 = values.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while len(ops) != 0: op = ops.pop() val2 = values.pop() val1 = values.pop() values.append(apply_op(val1, val2, op)) return values[-1] tokens = list(expression) return evaluate_tokens(tokens)"},{"question":"def max_area(heights): Returns the maximum area of a rectangle formed by any two buildings. Arguments: heights -- a list of integers representing the heights of buildings. Returns: int -- the maximum area of the rectangle. from solution import max_area def test_max_area(): assert max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) == 49 assert max_area([1, 1]) == 1 assert max_area([4, 3, 2, 1, 4]) == 16 assert max_area([1, 2, 1]) == 2 assert max_area([1, 2, 4, 3]) == 4 def test_max_area_single_building(): assert max_area([4]) == 0 def test_max_area_increasing_heights(): assert max_area([1, 2, 3, 4, 5]) == 6 def test_max_area_decreasing_heights(): assert max_area([5, 4, 3, 2, 1]) == 6","solution":"def max_area(heights): Returns the maximum area of a rectangle formed by any two buildings. Arguments: heights -- a list of integers representing the heights of buildings. Returns: int -- the maximum area of the rectangle. max_area = 0 left, right = 0, len(heights) - 1 while left < right: height = min(heights[left], heights[right]) width = right - left max_area = max(max_area, height * width) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"from typing import List def min_cost_to_make_elements_equal(elements: List[int]) -> int: Computes the minimum total cost to make all elements of the array the same. >>> min_cost_to_make_elements_equal([]) == 0 >>> min_cost_to_make_elements_equal([5]) == 0 >>> min_cost_to_make_elements_equal([5, 5, 5, 5]) == 0 >>> min_cost_to_make_elements_equal([1, 2, 3]) == 2 >>> min_cost_to_make_elements_equal([1, 10, 2, 9]) == 16 >>> min_cost_to_make_elements_equal([-1, -3, -2, -4]) == 4 >>> min_cost_to_make_elements_equal([1, -1, 2, -2]) == 6 >>> min_cost_to_make_elements_equal([1000000, 1000001, 1000002]) == 2","solution":"def min_cost_to_make_elements_equal(elements): Computes the minimum cost to make all elements of the array the same. if not elements: return 0 elements.sort() median = elements[len(elements) // 2] total_cost = sum(abs(element - median) for element in elements) return total_cost"},{"question":"def closest_three_sum(arr, target): Finds the closest possible sum of any three distinct elements in \`arr\` that is closest to the \`target\`. >>> closest_three_sum([1, 2, 3, 4, 5], 10) # 10 >>> closest_three_sum([-1, 2, 1, -4], 1) # 2 >>> closest_three_sum([0, 2, 1, -3], 1) # 0 >>> closest_three_sum([1, 1, 1, 0], 100) # 3 >>> closest_three_sum([1, 2, -1, -4, 3, 5, -2], 3) # 3 >>> closest_three_sum([1, 1, -1, -1, 3], -1) # -1","solution":"def closest_three_sum(arr, target): Finds the closest possible sum of any three distinct elements in \`arr\` to the \`target\`. arr.sort() closest_sum = float('inf') for i in range(len(arr) - 2): left, right = i + 1, len(arr) - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return current_sum # If the exact sum is found, return it if abs(target - current_sum) < abs(target - closest_sum): closest_sum = current_sum elif abs(target - current_sum) == abs(target - closest_sum): closest_sum = min(closest_sum, current_sum) if current_sum < target: left += 1 else: right -= 1 return closest_sum"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of integers nums, return a list of integers where each element at index i of the output list is equal to the product of all the elements of nums except nums[i]. You must solve this problem without using division. >>> product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_except_self([1, 2, 0, 4]) == [0, 0, 8, 0] >>> product_except_self([-1, -2, -3, -4]) == [-24, -12, -8, -6] >>> product_except_self([1]) == [1] >>> product_except_self([3, 5]) == [5, 3] >>> product_except_self([]) == [] >>> product_except_self([-1, 2, -3, 4]) == [-24, 12, -8, 6]","solution":"def product_except_self(nums): Given a list of integers nums, return a list of integers where each element at index i of the output list is equal to the product of all the elements of nums except nums[i]. n = len(nums) if n == 0: return [] # Create two arrays for left and right products left_products = [1] * n right_products = [1] * n # Fill left_products list such that left_products[i] contains product of all elements to the left of nums[i] for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Fill right_products list such that right_products[i] contains product of all elements to the right of nums[i] for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Create the result array where each element is the product of the corresponding left and right products result = [1] * n for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def minMovesToSortArray(arr): Returns the minimum number of moves required to sort the array in non-decreasing order by reversing subarrays. >>> minMovesToSortArray([1, 2, 3, 4, 5]) == 0 >>> minMovesToSortArray([5, 4, 3, 2, 1]) == 1 >>> minMovesToSortArray([1, 3, 2, 4, 5]) == 1 >>> minMovesToSortArray([4, 3, 2, 1, 5]) == 1 >>> minMovesToSortArray([5, 1, 2, 4, 3]) == 2 >>> minMovesToSortArray([1, 3, 5, 4, 2, 6, 7, 8]) == 2 >>> minMovesToSortArray([1]) == 0 >>> minMovesToSortArray([2, 1]) == 1","solution":"def minMovesToSortArray(arr): Returns the minimum number of moves required to sort the array in non-decreasing order by reversing subarrays. n = len(arr) sorted_arr = sorted(arr) # Two pointers technique to find the minimum subarray that needs to be reversed left, right = 0, n - 1 while left < n and arr[left] == sorted_arr[left]: left += 1 while right >= 0 and arr[right] == sorted_arr[right]: right -= 1 # If array is already sorted if left >= right: return 0 # Check if reversing the subarray from left to right makes the array sorted subarray = arr[left:right + 1] if subarray == subarray[::-1] or arr[:left] + subarray[::-1] + arr[right + 1:] == sorted_arr: return 1 return 2 # If more than one move is needed, at most it will be 2 moves"},{"question":"from typing import List class RainfallTracker: A class used to track the daily amount of rainfall in a city over a period. Methods: - addRainfall(day: int, amount: int) -> None - totalRainfall() -> int - averageRainfall() -> float - maxRainfallDays() -> List[int] Example: >>> tracker = RainfallTracker() >>> tracker.addRainfall(1, 10) >>> tracker.totalRainfall() 10 >>> tracker.averageRainfall() 10.0 >>> tracker.addRainfall(2, 5) >>> tracker.addRainfall(2, 5) >>> tracker.totalRainfall() 20 >>> tracker.averageRainfall() 10.0 >>> tracker.maxRainfallDays() [2]","solution":"class RainfallTracker: def __init__(self): self.rainfall_data = {} def addRainfall(self, day, amount): if day in self.rainfall_data: self.rainfall_data[day] += amount else: self.rainfall_data[day] = amount def totalRainfall(self): return sum(self.rainfall_data.values()) def averageRainfall(self): total_days = len(self.rainfall_data) if total_days == 0: return 0.0 return self.totalRainfall() / total_days def maxRainfallDays(self): if not self.rainfall_data: return [] max_rainfall = max(self.rainfall_data.values()) return [day for day, amount in self.rainfall_data.items() if amount == max_rainfall]"},{"question":"from typing import List def min_workers(tasks: List[int], k: int) -> int: Returns the minimum number of workers needed to complete all the tasks. >>> min_workers([2, 3, 4], 5) == 2 >>> min_workers([1, 2, 1, 1, 1], 3) == 2 >>> min_workers([5, 5, 5, 5, 5], 5) == 5 >>> min_workers([2, 2, 2, 2, 2], 4) == 3 >>> min_workers([1, 1, 1, 1, 1], 2) == 3 >>> min_workers([], 5) == 0 >>> min_workers([7], 7) == 1 >>> min_workers([7, 8], 7) == 2 >>> min_workers([4, 4, 4, 4], 4) == 4 >>> min_workers([10, 10, 10], 10) == 3","solution":"def min_workers(tasks, k): Returns the minimum number of workers needed to complete all the tasks. workers_needed = 0 current_time = 0 for task in tasks: if current_time + task <= k: current_time += task else: workers_needed += 1 current_time = task if current_time > 0: workers_needed += 1 return workers_needed"},{"question":"def min_path_sum(mat): Returns the minimum path sum from the top-left corner to the bottom-right corner of the matrix. You can only move either down or right at any point in time. :param mat: A list of list of integers representing the matrix :return: Integer representing the minimum path sum >>> min_path_sum([[5]]) 5 >>> min_path_sum([[1, 2], [1, 1]]) 3 >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_sum([[1, 2, 3], [4, 5, 6]]) 12 >>> min_path_sum([]) 0 >>> min_path_sum([[]]) 0 >>> min_path_sum([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> min_path_sum([[1, 2, 3, 4]]) 10 >>> min_path_sum([[1], [2], [3], [4]]) 10","solution":"def min_path_sum(mat): Returns the minimum path sum from the top-left corner to the bottom-right corner of the matrix. You can only move either down or right at any point in time. :param mat: A list of list of integers representing the matrix :return: Integer representing the minimum path sum if not mat or not mat[0]: return 0 rows, cols = len(mat), len(mat[0]) # Create a DP table to store the minimum path sum for each cell dp = [[0] * cols for _ in range(rows)] # Initialize the DP table with the starting point dp[0][0] = mat[0][0] # Fill in the first row (only move right possible) for j in range(1, cols): dp[0][j] = dp[0][j-1] + mat[0][j] # Fill in the first column (only move down possible) for i in range(1, rows): dp[i][0] = dp[i-1][0] + mat[i][0] # Fill the rest of the DP table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + mat[i][j] return dp[rows-1][cols-1]"},{"question":"def can_transform(s: str, t: str) -> bool: Determine if string s can be transformed into string t by permuting the characters of s. >>> can_transform(\\"abc\\", \\"abc\\") == True >>> can_transform(\\"listen\\", \\"silent\\") == True >>> can_transform(\\"hello\\", \\"bello\\") == False >>> can_transform(\\"abcd\\", \\"abcde\\") == False >>> can_transform(\\"\\", \\"\\") == True >>> can_transform(\\"a\\", \\"a\\") == True >>> can_transform(\\"a\\", \\"b\\") == False >>> can_transform(\\"aabbcc\\", \\"ccbbaa\\") == True >>> can_transform(\\"aabbcc\\", \\"abbccc\\") == False","solution":"def can_transform(s, t): Determine if string s can be transformed into string t by permuting the characters of s. Parameters: s (str): The original string. t (str): The target string to be checked for permutability. Returns: bool: True if s can be permuted to form t, otherwise False. from collections import Counter return Counter(s) == Counter(t)"},{"question":"def two_sum(nums: List[int], target: int) -> bool: Given an array of integers \`nums\` and an integer \`target\`, determine if there are two distinct indices i and j in the array such that nums[i] + nums[j] == target. Args: nums (list of int): List of integers. target (int): Target integer. Returns: bool: True if such indices exist, False otherwise. >>> two_sum([2, 7, 11, 15], 9) True >>> two_sum([1, 2, 3, 4], 5) True >>> two_sum([2, 7, 11, 15], 10) False >>> two_sum([], 5) False >>> two_sum([5], 5) False >>> two_sum([1, 1, 3, 4], 2) True","solution":"def two_sum(nums, target): Given an array of integers \`nums\` and an integer \`target\`, determine if there are two distinct indices i and j in the array such that nums[i] + nums[j] == target. Args: nums (list of int): List of integers. target (int): Target integer. Returns: bool: True if such indices exist, False otherwise. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return True seen[num] = i return False"},{"question":"def find_words_that_can_be_typed(words: list) -> list: Returns a list of words that can be typed using letters of the alphabet on only one row of a QWERTY keyboard. Parameters: words (list): List of words to be checked Returns: list: List of words that can be typed using letters of the alphabet on only one row of a QWERTY keyboard >>> find_words_that_can_be_typed([\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"]) [\\"Alaska\\", \\"Dad\\"] >>> find_words_that_can_be_typed([\\"Hello\\", \\"alaska\\", \\"dAd\\", \\"peAce\\"]) [\\"alaska\\", \\"dAd\\"] >>> find_words_that_can_be_typed([\\"QWERTY\\", \\"YUIOP\\", \\"QY\\"]) [\\"QWERTY\\", \\"YUIOP\\", \\"QY\\"] >>> find_words_that_can_be_typed([\\"Hello\\", \\"World\\"]) [] >>> find_words_that_can_be_typed([]) [] >>> find_words_that_can_be_typed([\\"ASDF\\", \\"GHJKL\\"]) [\\"ASDF\\", \\"GHJKL\\"] >>> find_words_that_can_be_typed([\\"ZXCV\\", \\"BNM\\", \\"ZXC\\"]) [\\"ZXCV\\", \\"BNM\\", \\"ZXC\\"] >>> find_words_that_can_be_typed([\\"a\\", \\"Q\\", \\"z\\"]) [\\"a\\", \\"Q\\", \\"z\\"]","solution":"def find_words_that_can_be_typed(words): Returns a list of words that can be typed using letters of the alphabet on only one row of a QWERTY keyboard. Parameters: words (list): List of words to be checked Returns: list: List of words that can be typed using letters of the alphabet on only one row of a QWERTY keyboard first_row = set(\\"QWERTYUIOP\\") second_row = set(\\"ASDFGHJKL\\") third_row = set(\\"ZXCVBNM\\") def can_be_typed(word, row): for char in word.upper(): if char not in row: return False return True result = [] for word in words: if can_be_typed(word, first_row) or can_be_typed(word, second_row) or can_be_typed(word, third_row): result.append(word) return result"},{"question":"def combinationSum(nums: List[int], target: int) -> List[List[int]]: Returns all unique combinations of nums elements that sum up to target. Args: nums (list of int): The list of candidate numbers. target (int): The target sum. Returns: list of list of int: A list containing all unique combinations. Examples: >>> combinationSum([2,3,6,7], 7) [[2,2,3], [7]] >>> combinationSum([2,3,5], 8) [[2,2,2,2], [2,3,3], [3,5]]","solution":"def combinationSum(nums, target): Returns all unique combinations of nums elements that sum up to target. Args: nums (list of int): The list of candidate numbers. target (int): The target sum. Returns: list of list of int: A list containing all unique combinations. def backtrack(start, target, path, results): if target == 0: results.append(list(path)) return elif target < 0: return for i in range(start, len(nums)): path.append(nums[i]) backtrack(i, target - nums[i], path, results) path.pop() results = [] nums.sort() # Optional, to possibly speed up the process backtrack(0, target, [], results) return results"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Returns the original string by rearranging the characters of \`s\` to their original positions given by \`indices\`. >>> restore_string(\\"codeleet\\", [4,5,6,7,0,2,1,3]) == \\"leetcode\\" >>> restore_string(\\"abc\\", [0,1,2]) == \\"abc\\" >>> restore_string(\\"aiohn\\", [3,1,4,2,0]) == \\"nihao\\" >>> restore_string(\\"aaiougrt\\", [4,0,2,6,7,3,1,5]) == \\"arigatou\\" >>> restore_string(\\"art\\", [1,0,2]) == \\"rat\\"","solution":"def restore_string(s, indices): Returns the original string by rearranging the characters of s based on the indices provided in the array. restored = [''] * len(s) for char, index in zip(s, indices): restored[index] = char return ''.join(restored)"},{"question":"def divisible_pairs(nums: List[int]) -> List[List[int]]: Given an array of integers \`nums\`, create a 2D array \`result\` where each element \`result[i]\` is a list of integers consisting of elements from \`nums\` that are divisible by \`nums[i]\`. The list \`result[i]\` should be sorted in non-decreasing order. Return the \`result\` array in the same order as the input array \`nums\`. >>> divisible_pairs([]) [] >>> divisible_pairs([3]) [[3]] >>> divisible_pairs([1, 2, 4]) [[1, 2, 4], [2, 4], [4]] >>> divisible_pairs([2, 3, 8, 9, 12]) [[2, 8, 12], [3, 9, 12], [8], [9], [12]] >>> divisible_pairs([5, 13, 26]) [[5], [13, 26], [26]] >>> divisible_pairs([2, 3, 5]) [[2], [3], [5]]","solution":"def divisible_pairs(nums): result = [] for i in range(len(nums)): divisible_list = [num for num in nums if num % nums[i] == 0] result.append(sorted(divisible_list)) return result"},{"question":"def min_cost_transform(A: List[List[int]], B: List[List[int]], c: int) -> int: Calculates the minimum cost required to transform matrix A into matrix B. If not possible, returns -1. Parameters: A (list of list of int): The initial matrix. B (list of list of int): The target matrix. c (int): The cost to increment any element in A by one. Returns: int: The minimum total cost required or -1 if transformation is not possible. >>> A = [[1, 2], [3, 4]] >>> B = [[2, 3], [4, 5]] >>> min_cost_transform(A, B, 2) 8 >>> A = [[4, 5], [6, 7]] >>> B = [[2, 3], [4, 5]] >>> min_cost_transform(A, B, 1) -1","solution":"def min_cost_transform(A, B, c): Calculates the minimum cost required to transform matrix A into matrix B. If not possible, returns -1. Parameters: A (list of list of int): The initial matrix. B (list of list of int): The target matrix. c (int): The cost to increment any element in A by one. Returns: int: The minimum total cost required or -1 if transformation is not possible. m = len(A) n = len(A[0]) total_cost = 0 for i in range(m): for j in range(n): if A[i][j] > B[i][j]: return -1 else: total_cost += (B[i][j] - A[i][j]) * c return total_cost"},{"question":"from typing import List def numDistinctSubseqSum(nums: List[int], k: int) -> int: Returns the number of distinct subsequences of nums that sum up to k. >>> numDistinctSubseqSum([1, 2, 1], 3) 2 >>> numDistinctSubseqSum([1, 2, 3], 3) 2 >>> numDistinctSubseqSum([], 0) 1 >>> numDistinctSubseqSum([], 1) 0 >>> numDistinctSubseqSum([1, 1, 1], 2) 3 >>> numDistinctSubseqSum([1, 2, 3, 4, 5], 5) 3 >>> numDistinctSubseqSum([1, -1, 0], 0) 4 >>> numDistinctSubseqSum([2, -1, 3], 2) 2 >>> numDistinctSubseqSum([1, 2, 3], 0) 1 >>> numDistinctSubseqSum([1, 2, 3, 4, 5], 15) 1 >>> numDistinctSubseqSum([1, 2, 3], 7) 0","solution":"def numDistinctSubseqSum(nums, k): Returns the number of distinct subsequences of nums that sum up to k. from collections import defaultdict # Using dynamic programming with a dictionary to count subsequences sums dp = defaultdict(int) dp[0] = 1 for num in nums: # To prevent modifying dp in the middle of the iteration, use a temporary dict tmp = dp.copy() for sum_so_far in dp: new_sum = sum_so_far + num tmp[new_sum] += dp[sum_so_far] dp = tmp return dp[k]"},{"question":"def num_islands_after_conversions(grid: List[List[int]], positions: List[Tuple[int, int]]) -> int: Given an m x n binary matrix \`grid\` and a list of positions, convert each position to land and return the number of islands formed. >>> grid = [ ... [1, 1, 0, 0], ... [0, 1, 0, 0], ... [0, 0, 0, 1], ... [0, 0, 0, 0] ... ] >>> positions = [(2, 1), (3, 1)] >>> num_islands_after_conversions(grid, positions) 2 >>> grid = [ ... [1, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ] >>> positions = [(1, 1), (2, 2), (3, 3)] >>> num_islands_after_conversions(grid, positions) 4 >>> grid = [ ... [1, 1, 0, 0], ... [0, 1, 0, 1], ... [0, 0, 0, 1], ... [0, 0, 0, 1] ... ] >>> positions = [(1, 2), (2, 2), (3, 2)] >>> num_islands_after_conversions(grid, positions) 1 >>> grid = [ ... [1, 1, 1, 0], ... [1, 1, 1, 0], ... [1, 1, 1, 0], ... [0, 0, 0, 0], ... ] >>> positions = [(3, 0), (3, 1), (3, 2)] >>> num_islands_after_conversions(grid, positions) 1 pass","solution":"def num_islands_after_conversions(grid, positions): rows, cols = len(grid), len(grid[0]) # Function to perform DFS to mark visited islands def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] != 1: return grid[r][c] = '#' dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) # Convert given positions from 0 to 1 for x, y in positions: grid[x][y] = 1 num_islands = 0 # Count the number of islands for r in range(rows): for c in range(cols): if grid[r][c] == 1: dfs(r, c) num_islands += 1 return num_islands"},{"question":"def find_isolated_computers(n: int, edges: List[List[int]]) -> List[int]: Returns a list of isolated computers in ascending order. Parameters: n (int): Number of computers. edges (List[List[int]]): List of edges representing direct communication links. Returns: List[int]: A list of isolated computers in ascending order.","solution":"def find_isolated_computers(n, edges): Returns a list of isolated computers in ascending order. Parameters: n (int): Number of computers. edges (List[List[int]]): List of edges representing direct communication links. Returns: List[int]: A list of isolated computers in ascending order. # Create a set for all computers all_computers = set(range(n)) # Create a set for computers with edges connected_computers = set() for u, v in edges: connected_computers.add(u) connected_computers.add(v) # Isolated computers are those which are in all_computers but not in connected_computers isolated_computers = list(all_computers - connected_computers) isolated_computers.sort() return isolated_computers"},{"question":"from typing import List, Set class Node: def __init__(self, value: str, children: List['Node'] = None): self.value = value self.children = children if children is not None else [] def find_words_from_tree(root: Node, dictionary: Set[str]) -> List[str]: Find all root-to-leaf paths in the N-ary tree that form valid English words in the given dictionary. >>> root = Node('a', [Node('b'), Node('c', [Node('d'), Node('e')])]) >>> dictionary = {\\"ab\\", \\"acd\\", \\"ace\\"} >>> find_words_from_tree(root, dictionary) [\\"ab\\", \\"acd\\", \\"ace\\"] >>> root = Node('a', [Node('b'), Node('c')]) >>> dictionary = {\\"ab\\", \\"ac\\"} >>> find_words_from_tree(root, dictionary) [\\"ab\\", \\"ac\\"] >>> root = None >>> dictionary = {\\"a\\"} >>> find_words_from_tree(root, dictionary) []","solution":"from typing import List, Set class Node: def __init__(self, value: str, children: List['Node'] = None): self.value = value self.children = children if children is not None else [] def find_words_from_tree(root: Node, dictionary: Set[str]) -> List[str]: def dfs(node: Node, path: str, results: List[str]): new_path = path + node.value if not node.children: if new_path in dictionary: results.append(new_path) else: for child in node.children: dfs(child, new_path, results) results = [] if root: dfs(root, '', results) return sorted(results)"},{"question":"def common_free_time(schedules: List[List[List[int]]]) -> List[List[int]]: Returns a list of intervals representing the common free time slots among all schedules. Parameters: schedules (list of list of lists): a list of schedules, where each schedule is a list of busy time intervals [start, end]. Returns: list of lists: A list of intervals representing the common free time slots among all schedules. pass from solution import common_free_time def test_common_free_time_no_conflicts(): schedules = [[[1, 2]], [[6, 7]], [[10, 11]]] assert common_free_time(schedules) == [[0, 1], [2, 6], [7, 10], [11, 24]] def test_common_free_time_overlapping_intervals(): schedules = [[[1, 2], [5, 6]], [[2, 4], [8, 10]], [[3, 5], [7, 9]]] assert common_free_time(schedules) == [[0, 1], [6, 7], [10, 24]] def test_common_free_time_no_free_time(): schedules = [[[0, 1], [12, 13], [23, 24]], [[1, 12]], [[13, 23]]] assert common_free_time(schedules) == [] def test_common_free_time_entire_day_busy(): schedules = [[[0, 24]], [[0, 24]], [[0, 24]]] assert common_free_time(schedules) == [] def test_common_free_time_single_schedule(): schedules = [[[1, 3], [5, 6], [9, 10], [20, 22]]] assert common_free_time(schedules) == [[0, 1], [3, 5], [6, 9], [10, 20], [22, 24]]","solution":"def common_free_time(schedules): Returns a list of intervals representing the common free time slots among all schedules. Parameters: schedules (list of list of lists): a list of schedules, where each schedule is a list of busy time intervals [start, end]. Returns: list of lists: A list of intervals representing the common free time slots among all schedules. # Flatten and sort all busy intervals all_intervals = [interval for schedule in schedules for interval in schedule] all_intervals.sort() # Merge overlapping intervals merged_busy_intervals = [] for interval in all_intervals: if merged_busy_intervals and interval[0] <= merged_busy_intervals[-1][1]: merged_busy_intervals[-1][1] = max(merged_busy_intervals[-1][1], interval[1]) else: merged_busy_intervals.append(interval) # Find common free intervals free_intervals = [] end_of_last_busy = 0 for interval in merged_busy_intervals: if interval[0] > end_of_last_busy: # Check if the free interval is at least 1 hour long if interval[0] - end_of_last_busy >= 1: free_intervals.append([end_of_last_busy, interval[0]]) end_of_last_busy = interval[1] # Add the possible last free interval from the end of the last busy interval to 24 if valid. if end_of_last_busy < 24: free_intervals.append([end_of_last_busy, 24]) return free_intervals"},{"question":"def findUnique(nums: List[int]) -> int: Finds the element that appears only once in an array where all other elements appear exactly twice. Args: nums (List[int]): The list of integers where one integer appears only once and all others appear exactly twice. Returns: int: The integer that appears only once. >>> findUnique([2, 2, 1]) 1 >>> findUnique([4, 1, 2, 1, 2]) 4 >>> findUnique([1, 2, 1, 3, 2]) 3 >>> findUnique([1]) 1 >>> findUnique([0, 7, 7, 2, 2, 5, 5]) 0","solution":"def findUnique(nums): Finds the element that appears only once in an array where all other elements appear exactly twice. Args: nums (List[int]): The list of integers where one integer appears only once and all others appear exactly twice. Returns: int: The integer that appears only once. unique_element = 0 for num in nums: unique_element ^= num # XOR all elements. The result is the unique element. return unique_element"},{"question":"class CourseScheduler: def __init__(self, courses): Initializes the CourseScheduler object with a list of courses. Args: courses (List[List[Union[int, List[int]]]]): List of [course_i_duration, prerequisites], where course_i_duration is the duration to complete the course and prerequisites is a list of course indices that need to be completed before the course_i. pass def minimumCompletionTime(self): Returns the minimum time needed to complete all the courses. Returns: int: The minimum time to complete all courses. Examples: >>> courses = [[3, []], [2, [0]], [1, [1]]] >>> scheduler = CourseScheduler(courses) >>> scheduler.minimumCompletionTime() 6 >>> courses = [[4, []], [2, [0]], [6, [0, 1]], [8, [1, 2]]] >>> scheduler = CourseScheduler(courses) >>> scheduler.minimumCompletionTime() 20 pass # Unit Tests def test_basic_case(): courses = [[3, []], [2, [0]], [1, [1]]] scheduler = CourseScheduler(courses) assert scheduler.minimumCompletionTime() == 6 def test_multiple_prerequisites(): courses = [[4, []], [2, [0]], [6, [0, 1]], [8, [1, 2]]] scheduler = CourseScheduler(courses) assert scheduler.minimumCompletionTime() == 20 def test_no_prerequisites(): courses = [[3, []], [2, []], [4, []]] scheduler = CourseScheduler(courses) assert scheduler.minimumCompletionTime() == 4 def test_single_course(): courses = [[5, []]] scheduler = CourseScheduler(courses) assert scheduler.minimumCompletionTime() == 5 def test_long_chain_of_prerequisites(): courses = [[1, []], [2, [0]], [3, [1]], [4, [2]], [5, [3]]] scheduler = CourseScheduler(courses) assert scheduler.minimumCompletionTime() == 15 def test_disjoint_courses(): courses = [[2, []], [3, []], [1, [0]], [4, [1]]] scheduler = CourseScheduler(courses) assert scheduler.minimumCompletionTime() == 7","solution":"class CourseScheduler: def __init__(self, courses): self.courses = courses self.time_cache = {} def _calculate_completion_time(self, course_index): if course_index in self.time_cache: return self.time_cache[course_index] course_duration, prerequisites = self.courses[course_index] if not prerequisites: self.time_cache[course_index] = course_duration return course_duration max_prerequisite_time = max(self._calculate_completion_time(prereq) for prereq in prerequisites) total_time = course_duration + max_prerequisite_time self.time_cache[course_index] = total_time return total_time def minimumCompletionTime(self): total_time = 0 for course_index in range(len(self.courses)): total_time = max(total_time, self._calculate_completion_time(course_index)) return total_time"},{"question":"from typing import List from collections import defaultdict def group_anagrams(strs: List[str]) -> List[List[str]]: Groups the strings that are anagrams of each other. Args: strs: List of strings Returns: A list of lists, where each list contains strings that are anagrams of each other. >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] >>> group_anagrams([]) [] >>> group_anagrams([\\"abc\\"]) [['abc']] >>> group_anagrams([\\"abc\\", \\"def\\", \\"ghi\\"]) [['abc'], ['def'], ['ghi']] >>> group_anagrams([\\"a\\", \\"a\\", \\"a\\"]) [['a', 'a', 'a']]","solution":"from collections import defaultdict def group_anagrams(strs): Groups the strings that are anagrams of each other. Args: strs: List of strings Returns: A list of lists, where each list contains strings that are anagrams of each other. anagram_map = defaultdict(list) for s in strs: sorted_s = ''.join(sorted(s)) anagram_map[sorted_s].append(s) return list(anagram_map.values())"},{"question":"def find_longest_word(words: List[str], s: str) -> str: Returns the largest word in 'words' that can be formed by deleting some characters of 's' without reordering the characters of 's'. If there is more than one possible result, returns the word that appears first in 'words'. If no words in 'words' can be formed from 's', returns an empty string. >>> find_longest_word([\\"apple\\", \\"plea\\", \\"ale\\"], \\"abpcplea\\") == \\"apple\\" >>> find_longest_word([\\"a\\", \\"b\\", \\"c\\"], \\"abpcplea\\") == \\"a\\" >>> find_longest_word([], \\"abcd\\") == \\"\\" pass","solution":"def is_subsequence(word, s): Helper function to check if \`word\` is a subsequence of \`s\`. it = iter(s) return all(char in it for char in word) def find_longest_word(words, s): Returns the largest word in 'words' that can be formed by deleting some characters of 's' without reordering the characters of 's'. If there is more than one possible result, returns the word that appears first in 'words'. If no words in 'words' can be formed from 's', returns an empty string. longest_word = \\"\\" for word in words: if is_subsequence(word, s): if len(word) > len(longest_word) or (len(word) == len(longest_word) and word < longest_word): longest_word = word return longest_word"},{"question":"from typing import List def shortest_path(grid: List[List[int]], r1: int, c1: int, r2: int, c2: int) -> int: Given an n x n binary matrix grid where 0 represents an empty cell and 1 represents a wall, and two integers r1, c1 representing your starting position on the grid (r1, c1), and two integers r2, c2 representing your target position (r2, c2), return the length of the shortest path from your starting position to the target position, or -1 if there is no such path. Args: grid (List[List[int]]): n x n binary matrix grid. r1 (int): starting row index. c1 (int): starting column index. r2 (int): target row index. c2 (int): target column index. Returns: int: Length of the shortest path, or -1 if no such path exists. >>> shortest_path([ ... [0, 0, 1], ... [1, 0, 1], ... [0, 0, 0] ... ], 0, 0, 2, 2) 4 >>> shortest_path([ ... [0, 1, 1], ... [1, 1, 1], ... [1, 1, 0] ... ], 0, 0, 2, 2) -1","solution":"from collections import deque def shortest_path(grid, r1, c1, r2, c2): Returns the length of the shortest path from (r1, c1) to (r2, c2) in a binary matrix grid. Returns -1 if no such path exists. if grid[r1][c1] == 1 or grid[r2][c2] == 1: return -1 # Either start or end is blocked if (r1, c1) == (r2, c2): return 0 # Start and end are the same n = len(grid) directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] queue = deque([(r1, c1, 0)]) # (row, col, distance) visited = set() visited.add((r1, c1)) while queue: cr, cc, dist = queue.popleft() for dr, dc in directions: nr, nc = cr + dr, cc + dc if 0 <= nr < n and 0 <= nc < n and (nr, nc) not in visited: if grid[nr][nc] == 0: if (nr, nc) == (r2, c2): return dist + 1 queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) return -1"},{"question":"def max_jumps(arr: List[int], d: int) -> int: Determines the maximum number of indices you can visit starting from any index. You can jump to an index i if i + d <= arr[i] in either direction (left or right). You cannot land on a smaller value. pass # Test cases to validate the solution def test_max_jumps_basic(): arr = [6, 4, 14, 6, 8, 13, 9, 7, 10, 6, 12] d = 2 assert max_jumps(arr, d) == 4 def test_max_jumps_single_element(): arr = [5] d = 1 assert max_jumps(arr, d) == 1 def test_max_jumps_no_possible_jump(): arr = [1, 1, 1, 1, 1] d = 1 assert max_jumps(arr, d) == 1 def test_max_jumps_large_jump(): arr = [3, 6, 8, 12] d = 3 assert max_jumps(arr, d) == 4 def test_max_jumps_same_value(): arr = [7, 7, 7, 7, 7, 7] d = 2 assert max_jumps(arr, d) == 1","solution":"def max_jumps(arr, d): Determines the maximum number of indices you can visit starting from any index. You can jump to an index i if i + d <= arr[i] in either direction (left or right). You cannot land on a smaller value. def dfs(i, memo): if memo[i] != -1: return memo[i] max_reach = 1 # Jump to the right for j in range(i + 1, min(i + d + 1, len(arr))): if arr[j] < arr[i]: max_reach = max(max_reach, 1 + dfs(j, memo)) else: break # Jump to the left for j in range(i - 1, max(i - d - 1, -1), -1): if arr[j] < arr[i]: max_reach = max(max_reach, 1 + dfs(j, memo)) else: break memo[i] = max_reach return max_reach memo = [-1] * len(arr) return max(dfs(i, memo) for i in range(len(arr)))"},{"question":"def find_shadows(height): Given an array of heights representing the heights of buildings, returns an array of 0s and 1s where 1 indicates that the building is in shadow and 0 indicates that it is not in shadow. >>> find_shadows([]) == [] >>> find_shadows([5]) == [0] >>> find_shadows([3, 3, 3, 3]) == [1, 1, 1, 0] >>> find_shadows([1, 2, 3, 4]) == [1, 1, 1, 0] >>> find_shadows([4, 3, 2, 1]) == [0, 0, 0, 0] >>> find_shadows([3, 1, 4, 5, 2]) == [1, 1, 1, 0, 0] >>> find_shadows([2, 4, 6, 3, 5, 1]) == [1, 1, 0, 1, 0, 0]","solution":"def find_shadows(height): Given an array of heights representing the heights of buildings, returns an array of 0s and 1s where 1 indicates that the building is in shadow and 0 indicates that it is not in shadow. n = len(height) result = [0] * n max_height = 0 for i in range(n - 1, -1, -1): if height[i] > max_height: max_height = height[i] result[i] = 0 else: result[i] = 1 return result"},{"question":"def longest_subarray_with_two_distinct(nums: List[int]) -> int: Given a 0-indexed integer array \`nums\`, find the length of the longest subarray that contains at most two distinct integers. >>> longest_subarray_with_two_distinct([]) == 0 >>> longest_subarray_with_two_distinct([1]) == 1 >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 1]) == 5 >>> longest_subarray_with_two_distinct([1, 2, 1, 3, 4]) == 3 >>> longest_subarray_with_two_distinct([1, 2, 2, 3, 4]) == 3 >>> longest_subarray_with_two_distinct([1, 1, 1, 1]) == 4 >>> longest_subarray_with_two_distinct([1, 2, 1, 3, 1, 2, 1, 2, 1, 3, 2, 1]) == 5 >>> longest_subarray_with_two_distinct([1, 2, 3, 2, 2, 1]) == 4","solution":"def longest_subarray_with_two_distinct(nums): Returns the length of the longest subarray that contains at most two distinct integers. if not nums: return 0 left = 0 freq = {} max_len = 0 for right in range(len(nums)): if nums[right] in freq: freq[nums[right]] += 1 else: freq[nums[right]] = 1 while len(freq) > 2: freq[nums[left]] -= 1 if freq[nums[left]] == 0: del freq[nums[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def rob(nums: List[int]) -> int: Calculate the maximum amount of money that can be robbed without triggering the alarm. Args: nums (List[int]): List of non-negative integers representing the amount of money in each house. Returns: int: The maximum amount of money that can be robbed. >>> rob([]) == 0 >>> rob([5]) == 5 >>> rob([2, 3]) == 3 >>> rob([2, 7, 9]) == 11 >>> rob([1, 2, 3, 1]) == 4 >>> rob([2, 7, 9, 3, 1]) == 12 >>> rob([5, 5, 10, 100, 10, 5]) == 110 >>> rob([7, 10, 12, 7, 9, 14]) == 33","solution":"def rob(nums): Calculate the maximum amount of money that can be robbed without triggering the alarm. Args: nums (List[int]): List of non-negative integers representing the amount of money in each house. Returns: int: The maximum amount of money that can be robbed. if not nums: return 0 if len(nums) == 1: return nums[0] prev1, prev2 = 0, 0 for num in nums: temp = prev1 prev1 = max(prev2 + num, prev1) prev2 = temp return prev1"},{"question":"def max_pages(books: List[int], k: int) -> int: Given an array \`books\` where each element represents the number of pages in a particular book, and an integer \`k\` representing the number of friends, find the minimum possible value of the maximum number of pages read by any friend after optimally dividing the books such that each friend gets a contiguous segment of books. >>> max_pages([50], 1) == 50 >>> max_pages([10, 10, 10, 10], 2) == 20 >>> max_pages([10, 20, 30, 40, 50], 2) == 90 >>> max_pages([10, 20, 30, 40, 50], 3) == 60 >>> max_pages([10, 20, 30, 40, 50], 4) == 50 >>> max_pages([10, 20, 30, 40], 5) == -1 >>> max_pages([10, 20, 30], 3) == 30 >>> max_pages([1, 2, 3, 4, 5], 2) == 9","solution":"def is_valid(books, n, k, curr_min): current_sum = 0 required_students = 1 for i in range(n): if (books[i] > curr_min): return False if (current_sum + books[i] > curr_min): required_students += 1 current_sum = books[i] if required_students > k: return False else: current_sum += books[i] return True def max_pages(books, k): n = len(books) if k > n: return -1 start = max(books) end = sum(books) result = float('inf') while(start <= end): mid = (start + end) // 2 if (is_valid(books, n, k, mid)): result = min(result, mid) end = mid - 1 else: start = mid + 1 return result"},{"question":"from typing import List def largest_region(grid: List[List[int]]) -> int: Given an n x m 2D grid of integers, where each element in the grid represents a certain height above sea level, find the size of the largest region of connected cells with the same value. Cells are considered connected if they are adjacent horizontally, vertically, or diagonally. Return the size of the largest region of connected cells with the same value. >>> largest_region([]) 0 >>> largest_region([[]]) 0 >>> largest_region([[1]]) 1 >>> largest_region([[1, 2], [3, 4]]) 1 >>> largest_region([[1, 1], [2, 2]]) 2 >>> largest_region([[3, 3, 3], [3, 3, 3]]) 6 >>> largest_region([[1, 2, 2], [3, 2, 2], [1, 3, 1]]) 4","solution":"def largest_region(grid): Finds the size of the largest connected region of same values in a given 2D grid. :param grid: List of List of integers, representing the grid. :return: Integer, size of the largest connected region. if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) visited = [[False for _ in range(m)] for _ in range(n)] directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] def dfs(x, y, value): stack = [(x, y)] size = 0 while stack: cx, cy = stack.pop() if 0 <= cx < n and 0 <= cy < m and not visited[cx][cy] and grid[cx][cy] == value: visited[cx][cy] = True size += 1 for dx, dy in directions: stack.append((cx + dx, cy + dy)) return size largest_size = 0 for i in range(n): for j in range(m): if not visited[i][j]: region_size = dfs(i, j, grid[i][j]) largest_size = max(largest_size, region_size) return largest_size"},{"question":"def select_highest_avg_score_team(scores: list[int], team: list[list[int]]) -> int: Selects the team with the highest average score. In case of a tie, the team with the smallest id is selected. Args: scores (list): A list of integers representing the scores of participants. team (list): A list of lists with each inner list representing a team of participant ids. Returns: int: The id of the team with the highest average score. >>> select_highest_avg_score_team([10, 20, 30, 40, 50], [[0, 1, 2, 3, 4]]) 0 >>> select_highest_avg_score_team([10, 20, 30, 40, 50], [[0, 1], [2, 3, 4]]) 1 >>> select_highest_avg_score_team([10, 20, 30, 40, 50], [[0, 1], [1, 2], [3, 4]]) 2 >>> select_highest_avg_score_team([10, 20, 30, 40, 50], [[], [0, 1], [2, 3, 4]]) 2 >>> select_highest_avg_score_team([5, 15, 25, 35, 45], [[0], [1], [2], [3], [4]]) 4 >>> select_highest_avg_score_team([33, 44, 55, 22, 11, 99, 60], [[0, 1], [2, 3, 4], [5]]) 2","solution":"def select_highest_avg_score_team(scores, team): Selects the team with the highest average score. In case of a tie, the team with the smallest id is selected. Args: scores (list): A list of integers representing the scores of participants. team (list): A list of lists with each inner list representing a team of participant ids. Returns: int: The id of the team with the highest average score. highest_avg = -1 selected_team_id = -1 for i, members in enumerate(team): if not members: continue team_score = sum(scores[m] for m in members) team_size = len(members) team_avg = team_score / team_size if team_avg > highest_avg or (team_avg == highest_avg and i < selected_team_id): highest_avg = team_avg selected_team_id = i return selected_team_id"},{"question":"def shortest_string_length(s: str) -> int: Return the length of the shortest string that can be obtained by performing the operation described: pick any two distinct adjacent characters and delete them. >>> shortest_string_length(\\"aaa\\") == 3 >>> shortest_string_length(\\"ababab\\") == 0 >>> shortest_string_length(\\"abacb\\") == 1 >>> shortest_string_length(\\"a\\") == 1 >>> shortest_string_length(\\"\\") == 0","solution":"def shortest_string_length(s): Returns the length of the shortest string by performing operations described in the prompt: pick any two distinct adjacent characters and delete them. stack = [] for char in s: if stack and stack[-1] != char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"def count_even_numbers(low: int, high: int) -> int: Given two integers \`low\` and \`high\`, return the count of even numbers between \`low\` and \`high\` (both inclusive). If there are no even numbers between \`low\` and \`high\`, return \`0\`. >>> count_even_numbers(2, 10) # 2, 4, 6, 8, 10 5 >>> count_even_numbers(3, 9) # 4, 6, 8 3 >>> count_even_numbers(7, 7) # no even numbers 0 >>> count_even_numbers(4, 4) # 4 1 >>> count_even_numbers(10, 2) # invalid range 0 >>> count_even_numbers(2, 5) # 2, 4 2 >>> count_even_numbers(3, 6) # 4, 6 2 >>> count_even_numbers(1, 100) # 2, 4, 6, ..., 100 50 >>> count_even_numbers(8, 10) # 8, 10 2","solution":"def count_even_numbers(low, high): Returns the count of even numbers between low and high (both inclusive). If there are no even numbers between low and high, returns 0. if low > high: return 0 # Make sure low and high are the first even numbers >= low and <= high respectively if low % 2 != 0: low += 1 if high % 2 != 0: high -= 1 if low > high: return 0 return ((high - low) // 2) + 1"},{"question":"def can_complete_tasks(tasks: List[int], d: int, dayLimit: int) -> bool: Determines if it's possible to complete all tasks within d days with the given day limit on task durations. Args: tasks (List[int]): List of task durations. d (int): Maximum number of days available. dayLimit (int): Maximum duration of tasks that can be completed in a single day. Returns: bool: True if it's possible to complete all tasks within d days, False otherwise. >>> can_complete_tasks([1, 2, 3, 4], 2, 5) True >>> can_complete_tasks([4, 3, 3, 2, 1], 3, 5) True >>> can_complete_tasks([1, 10, 2, 2, 1, 1], 3, 12) True >>> can_complete_tasks([4, 4, 4, 4, 4], 2, 5) False >>> can_complete_tasks([8, 8, 8, 8, 8], 4, 9) False >>> can_complete_tasks([5, 5, 5, 5], 2, 7) False >>> can_complete_tasks([], 1, 3) True >>> can_complete_tasks([2], 1, 2) True >>> can_complete_tasks([1, 2], 1, 4) True >>> can_complete_tasks([1, 2, 3, 4, 5, 6], 3, 7) True >>> can_complete_tasks([3, 8, 7, 3, 6, 2, 4], 4, 10) True >>> can_complete_tasks([3, 8, 7, 3, 6, 2, 4], 3, 11) False","solution":"def can_complete_tasks(tasks, d, dayLimit): Determines if it's possible to complete all tasks within d days with the given day limit on task durations. Args: tasks (list of int): List of task durations. d (int): Maximum number of days available. dayLimit (int): Maximum duration of tasks that can be completed in a single day. Returns: bool: True if it's possible to complete all tasks within d days, False otherwise. # Sort tasks to try pairing the shortest tasks together tasks.sort() left, right = 0, len(tasks) - 1 days_needed = 0 while left <= right: if tasks[left] + tasks[right] <= dayLimit: left += 1 right -= 1 days_needed += 1 if days_needed > d: return False return days_needed <= d"},{"question":"def simplifyPath(paths: List[str]) -> List[str]: Simplifies each file path in the list by resolving special references and reducing redundant slashes. paths: list of strings, each representing a file path return: list of simplified file paths >>> simplifyPath([\\"/home/user/documents\\"]) [\\"/home/user/documents\\"] >>> simplifyPath([\\"/home/./user\\"]) [\\"/home/user\\"] >>> simplifyPath([\\"/home/user/../documents\\"]) [\\"/home/documents\\"] >>> simplifyPath([\\"/home/./user/../documents/./\\"]) [\\"/home/documents\\"] >>> simplifyPath([\\"/\\"]) [\\"/\\"]","solution":"def simplifyPath(paths): Simplifies each file path in the list by resolving special references and reducing redundant slashes. paths: list of strings, each representing a file path return: list of simplified file paths def simplify_single_path(path): parts = path.split('/') stack = [] for part in parts: if part == \\"..\\": if stack: stack.pop() elif part and part != \\".\\": stack.append(part) return \\"/\\" + \\"/\\".join(stack) return [simplify_single_path(path) for path in paths]"},{"question":"def has_unique_topological_ordering(n, edges): Determine if a directed acyclic graph has a unique topological ordering. :param n: Number of nodes in the graph. :param edges: List of pairs representing directed edges [u, v]. :return: True if there is a unique topological ordering, otherwise False.","solution":"from collections import deque def has_unique_topological_ordering(n, edges): Determine if a directed acyclic graph has a unique topological ordering. :param n: Number of nodes in the graph. :param edges: List of pairs representing directed edges [u, v]. :return: True if there is a unique topological ordering, otherwise False. # Initialize the graph graph = [[] for _ in range(n)] in_degree = [0] * n # Build the graph and compute in-degrees of each node for u, v in edges: graph[u].append(v) in_degree[v] += 1 # Queue for nodes with in-degree 0 zero_in_degree_queue = deque([i for i in range(n) if in_degree[i] == 0]) unique_topological_order = [] while zero_in_degree_queue: # If there is more than one choice at any point, the ordering is not unique if len(zero_in_degree_queue) > 1: return False # Get one of the nodes with in-degree 0 current_node = zero_in_degree_queue.popleft() unique_topological_order.append(current_node) # Decrease the in-degree of neighboring nodes for neighbor in graph[current_node]: in_degree[neighbor] -= 1 # If in-degree becomes 0, add it to the queue if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If the topological sort includes all nodes, it's unique return len(unique_topological_order) == n"},{"question":"def makesquare(nums: List[int]) -> bool: Given an array of integers nums representing different lengths of sticks, return True if you can form a square using all the sticks, and False otherwise. >>> makesquare([1, 1, 2, 2, 2]) == True >>> makesquare([4, 4, 4, 4, 4, 4, 4, 4]) == True >>> makesquare([5, 5, 5, 5, 5, 5, 5, 5, 10, 10, 10, 10, 15, 15, 15, 15]) == True >>> makesquare([1, 1, 1, 2, 2]) == False >>> makesquare([3, 3, 3, 3, 4]) == False >>> makesquare([5, 5, 5, 5, 5]) == False >>> makesquare([]) == False >>> makesquare([1]) == False >>> makesquare([4, 4, 4, 4]) == True >>> makesquare([1, 1, 1, 1]) == True >>> makesquare([10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10]) == False >>> makesquare([15, 15, 15, 15, 10, 10, 10, 10, 5, 5, 5, 5, 20, 20, 20, 20]) == True pass","solution":"def makesquare(nums): Returns True if you can form a square using all the sticks, else False. if not nums: return False total_length = sum(nums) if total_length % 4 != 0: return False side_length = total_length // 4 nums.sort(reverse=True) sides = [0] * 4 def dfs(index): if index == len(nums): return sides[0] == sides[1] == sides[2] == sides[3] == side_length for i in range(4): if sides[i] + nums[index] <= side_length: sides[i] += nums[index] if dfs(index + 1): return True sides[i] -= nums[index] return False return dfs(0)"},{"question":"import heapq def min_cost_to_connect_segments(segments): Returns the minimum total cost to connect all segments into one cable. Parameters: segments (list): A list of integers where each integer represents the length of a cable segment. Returns: int: The minimum total cost to connect all segments into one cable. Examples: >>> min_cost_to_connect_segments([4]) 0 >>> min_cost_to_connect_segments([1, 2]) 3 >>> min_cost_to_connect_segments([1, 2, 3, 4]) 19 >>> min_cost_to_connect_segments([1, 2, 5, 10, 35, 89]) 224 >>> min_cost_to_connect_segments([]) 0 >>> min_cost_to_connect_segments([4, 4, 4, 4]) 32 >>> min_cost_to_connect_segments([1000, 2000, 3000, 4000]) 19000","solution":"import heapq def min_cost_to_connect_segments(segments): Returns the minimum total cost to connect all segments into one cable. Parameters: segments (list): A list of integers where each integer represents the length of a cable segment. Returns: int: The minimum total cost to connect all segments into one cable. if not segments: return 0 min_heap = segments[:] heapq.heapify(min_heap) total_cost = 0 while len(min_heap) > 1: first = heapq.heappop(min_heap) second = heapq.heappop(min_heap) cost = first + second total_cost += cost heapq.heappush(min_heap, cost) return total_cost"},{"question":"def largest_island(grid: List[List[int]]) -> int: Find the size of the largest possible island in the grid after performing at most one transformation (turning one 0 into a 1). Args: grid: List[List[int]] - an n x n grid containing only integers 0 and 1 Returns: int - the size of the largest island possible with at most one transformation >>> largest_island([ ... [1, 0], ... [0, 1] ... ]) 3 >>> largest_island([ ... [1, 1], ... [1, 0] ... ]) 4 >>> largest_island([ ... [1, 1], ... [1, 1] ... ]) 4 >>> largest_island([ ... [0, 0], ... [0, 0] ... ]) 1 >>> largest_island([ ... [0, 1, 0], ... [1, 0, 1], ... [0, 1, 0] ... ]) 5","solution":"def largest_island(grid): def dfs(x, y, index): stack = [(x, y)] area = 0 while stack: cx, cy = stack.pop() if 0 <= cx < n and 0 <= cy < n and grid[cx][cy] == 1: grid[cx][cy] = index area += 1 for nx, ny in [(cx-1, cy), (cx+1, cy), (cx, cy-1), (cx, cy+1)]: stack.append((nx, ny)) return area n = len(grid) if not n: return 0 island_area = {} index = 2 # Start index from 2 because 0 and 1 are already in use # Step 1: Use DFS to paint each island and record their area for i in range(n): for j in range(n): if grid[i][j] == 1: island_area[index] = dfs(i, j, index) index += 1 if not island_area: return 1 # The grid only contains one cell as 0 max_area = max(island_area.values(), default=0) # Step 2: Check each 0 cell to see if it can connect two or more islands for i in range(n): for j in range(n): if grid[i][j] == 0: seen = set() new_area = 1 # Start with this cell being an island for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]: if 0 <= ni < n and 0 <= nj < n and grid[ni][nj] > 1: index = grid[ni][nj] if index not in seen: new_area += island_area[index] seen.add(index) max_area = max(max_area, new_area) return max_area"},{"question":"def max_rectangle_area(arr: List[int]) -> int: Returns the maximum rectangular area that can be formed between the buildings. Parameters: arr (list): A list of integers where each integer represents the height of a building. Returns: int: The maximum rectangular area possible. from solution import max_rectangle_area def test_single_building(): assert max_rectangle_area([5]) == 5 def test_two_buildings(): assert max_rectangle_area([5, 6]) == 10 def test_increasing_heights(): assert max_rectangle_area([1, 2, 3, 4, 5]) == 9 def test_decreasing_heights(): assert max_rectangle_area([5, 4, 3, 2, 1]) == 9 def test_valley_shape(): assert max_rectangle_area([6, 2, 5, 4, 5, 1, 6]) == 12 def test_plateau_shape(): assert max_rectangle_area([4, 4, 4, 4]) == 16 def test_random_heights(): assert max_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 def test_equal_heights(): assert max_rectangle_area([3, 3, 3]) == 9","solution":"def max_rectangle_area(arr): Returns the maximum rectangular area that can be formed between the buildings. Parameters: arr (list): A list of integers where each integer represents the height of a building. Returns: int: The maximum rectangular area possible. max_area = 0 n = len(arr) for left in range(n): min_height = arr[left] for right in range(left, n): min_height = min(min_height, arr[right]) width = right - left + 1 area = min_height * width max_area = max(max_area, area) return max_area"},{"question":"def max_sum_submatrix(mat, k): Returns the maximum sum of any sub-matrix of \`mat\` that does not exceed \`k\`. If no such sub-matrix exists, returns 0. >>> max_sum_submatrix([[1, 0, 1], [0, -2, 3]], 2) == 2 >>> max_sum_submatrix([[2, 2, -1]], 0) == -1 >>> max_sum_submatrix([[5, -4, -3, 4], [1, -4, -3, 4], [1, 2, 3, -4]], 8) == 8 >>> max_sum_submatrix([[2]], 3) == 2 >>> max_sum_submatrix([], 3) == 0 import bisect","solution":"def max_sum_submatrix(mat, k): import bisect def max_sum_subarray(arr, k): max_sum = float('-inf') curr_sum = 0 sums = [0] for num in arr: curr_sum += num idx = bisect.bisect_left(sums, curr_sum - k) if idx < len(sums): max_sum = max(max_sum, curr_sum - sums[idx]) bisect.insort(sums, curr_sum) return max_sum if not mat: return 0 m, n = len(mat), len(mat[0]) max_sum = float('-inf') for left in range(n): row_sum = [0] * m for right in range(left, n): for i in range(m): row_sum[i] += mat[i][right] max_sum = max(max_sum, max_sum_subarray(row_sum, k)) return max_sum if max_sum != float('-inf') else 0"},{"question":"from typing import List def judgeCircle(moves: str) -> bool: Determines if the robot returns to the origin after completing all of its moves. :param moves: A string containing characters 'L', 'R', 'U', and 'D' representing moves. :return: True if the robot returns to the origin, False otherwise. >>> judgeCircle(\\"L\\") False >>> judgeCircle(\\"LR\\") True >>> judgeCircle(\\"LLRR\\") True >>> judgeCircle(\\"LDRU\\") True # Your code here","solution":"def judgeCircle(moves: str) -> bool: Determines if the robot returns to the origin after completing all of its moves. :param moves: A string containing characters 'L', 'R', 'U', and 'D' representing moves. :return: True if the robot returns to the origin, False otherwise. x, y = 0, 0 for move in moves: if move == 'L': x -= 1 elif move == 'R': x += 1 elif move == 'U': y += 1 elif move == 'D': y -= 1 return x == 0 and y == 0"},{"question":"from typing import List def largest_number(n: int) -> int: Given a non-negative integer n, compute and return the largest number that can be formed by rearranging the digits of n. If the input is 0, return 0. >>> largest_number(0) == 0 True >>> largest_number(5) == 5 True >>> largest_number(111) == 111 True >>> largest_number(66666) == 66666 True >>> largest_number(123) == 321 True >>> largest_number(3021) == 3210 True >>> largest_number(9876543210) == 9876543210 True >>> largest_number(120300) == 321000 True >>> largest_number(98765432109876543210) == 99887766554433221100 True","solution":"def largest_number(n): Given a non-negative integer n, returns the largest number that can be formed by rearranging the digits of n. if n == 0: return 0 digits = list(str(n)) digits.sort(reverse=True) return int(''.join(digits))"},{"question":"def min_number_of_workers(intervals: List[List[int]]) -> int: Given a list of intervals, returns the minimum number of workers required to complete all the tasks without overlap. >>> min_number_of_workers([[1, 3], [2, 4], [3, 5]]) == 2 >>> min_number_of_workers([[1, 2], [2, 3], [3, 4], [4, 5]]) == 1 >>> min_number_of_workers([[1, 5], [2, 6], [3, 7], [4, 8]]) == 4 >>> min_number_of_workers([]) == 0 >>> min_number_of_workers([[1, 3], [1, 4], [1, 5]]) == 3 >>> min_number_of_workers([[1, 5], [2, 5], [3, 5]]) == 3 >>> min_number_of_workers([[1, 2]]) == 1","solution":"def min_number_of_workers(intervals): Given a list of intervals, returns the minimum number of workers required to complete all the tasks without overlap. if not intervals: return 0 # Separate start and end times starts = sorted(interval[0] for interval in intervals) ends = sorted(interval[1] for interval in intervals) workers = 0 end_idx = 0 for start in starts: if start < ends[end_idx]: workers += 1 else: end_idx += 1 return workers"},{"question":"from typing import List class CourseEnrollmentSystem: A class to manage university course enrollments. Methods: - enroll(studentId: int, courseId: int): Enrolls a student in a course. - drop(studentId: int, courseId: int): Drops a student from a course. - getEnrolledStudents(courseId: int) -> List[int]: Returns a sorted list of student IDs enrolled in a course. Example Usage: >>> ces = CourseEnrollmentSystem() >>> ces.enroll(1, 101) >>> ces.getEnrolledStudents(101) [1] >>> ces.enroll(2, 101) >>> ces.getEnrolledStudents(101) [1, 2] >>> ces.drop(1, 101) >>> ces.getEnrolledStudents(101) [2] def __init__(self): # Initializes the CourseEnrollmentSystem. def enroll(self, studentId: int, courseId: int): # Enrolls a student in the given course. def drop(self, studentId: int, courseId: int): # Drops a student from the given course. def getEnrolledStudents(self, courseId: int) -> List[int]: # Returns a list of students currently enrolled in the given course. --- def test_enroll_single_student(): ces = CourseEnrollmentSystem() ces.enroll(1, 101) assert ces.getEnrolledStudents(101) == [1] def test_enroll_multiple_students(): ces = CourseEnrollmentSystem() ces.enroll(1, 101) ces.enroll(2, 101) ces.enroll(3, 101) assert ces.getEnrolledStudents(101) == [1, 2, 3] def test_enroll_duplicate_students(): ces = CourseEnrollmentSystem() ces.enroll(1, 101) ces.enroll(1, 101) assert ces.getEnrolledStudents(101) == [1] def test_drop_student(): ces = CourseEnrollmentSystem() ces.enroll(1, 101) ces.enroll(2, 101) ces.drop(1, 101) assert ces.getEnrolledStudents(101) == [2] def test_drop_nonexistent_student(): ces = CourseEnrollmentSystem() ces.enroll(1, 101) ces.drop(2, 101) assert ces.getEnrolledStudents(101) == [1] def test_drop_all_students(): ces = CourseEnrollmentSystem() ces.enroll(1, 101) ces.enroll(2, 101) ces.drop(1, 101) ces.drop(2, 101) assert ces.getEnrolledStudents(101) == [] def test_enroll_in_multiple_courses(): ces = CourseEnrollmentSystem() ces.enroll(1, 101) ces.enroll(2, 102) assert ces.getEnrolledStudents(101) == [1] assert ces.getEnrolledStudents(102) == [2] def test_get_enrolled_students_empty_course(): ces = CourseEnrollmentSystem() assert ces.getEnrolledStudents(101) == []","solution":"class CourseEnrollmentSystem: def __init__(self): # Initializes the CourseEnrollmentSystem with a dictionary to hold course enrollments. self.enrollments = {} def enroll(self, studentId, courseId): # Enrolls the given student in the given course. if courseId not in self.enrollments: self.enrollments[courseId] = set() self.enrollments[courseId].add(studentId) def drop(self, studentId, courseId): # Drops the given student from the given course. if courseId in self.enrollments: self.enrollments[courseId].discard(studentId) def getEnrolledStudents(self, courseId): # Returns the list of students currently enrolled in the given course, sorted by studentId. if courseId in self.enrollments: return sorted(self.enrollments[courseId]) else: return []"},{"question":"def count_good_subarrays(nums: List[int], k: int) -> int: Returns the number of good subarrays in the array nums where the product of elements in the subarray is less than or equal to k. >>> count_good_subarrays([5], 10) == 1 >>> count_good_subarrays([10], 5) == 0 >>> count_good_subarrays([1, 2, 3], 6) == 6 >>> count_good_subarrays([1, 2, 1], 3) == 6 >>> count_good_subarrays([10, 20, 30], 5) == 0 >>> count_good_subarrays([1, 2, 3], 4) == 4 >>> count_good_subarrays([1, 2, 3], 10) == 6 >>> count_good_subarrays([2, 3, 4], 8) == 4 >>> count_good_subarrays([4, 5, 6], 24) == 4 >>> count_good_subarrays([10, 20, 30], 10000) == 6 >>> count_good_subarrays([2, 2, 2], 100) == 6 >>> count_good_subarrays([], 10) == 0 pass","solution":"def count_good_subarrays(nums, k): Returns the number of good subarrays in the array nums where the product of elements in the subarray is less than or equal to k. n = len(nums) count = 0 # Function to compute the product of subarray elements def product(subarray): result = 1 for num in subarray: result *= num return result for left in range(n): for right in range(left, n): if product(nums[left:right+1]) <= k: count += 1 return count"},{"question":"def to_hex(num: int) -> str: Converts a non-negative integer to its hexadecimal representation as a string. If the input is negative, returns an empty string. >>> to_hex(0) == \\"0\\" >>> to_hex(255) == \\"ff\\" >>> to_hex(16) == \\"10\\" >>> to_hex(1) == \\"1\\" >>> to_hex(3735928559) == \\"deadbeef\\" >>> to_hex(4294967295) == \\"ffffffff\\" >>> to_hex(-1) == \\"\\" >>> to_hex(-255) == \\"\\"","solution":"def to_hex(num): Converts a non-negative integer to its hexadecimal representation as a string. If the input is negative, returns an empty string. if num < 0: return \\"\\" if num == 0: return \\"0\\" hex_chars = \\"0123456789abcdef\\" hex_str = \\"\\" while num > 0: hex_str = hex_chars[num % 16] + hex_str num = num // 16 return hex_str"},{"question":"def max_balanced_strings(s: str) -> int: Returns the maximum number of balanced strings that can be obtained from the input string s. A balanced string has an equal number of 'x' and 'y' characters. >>> max_balanced_strings('') == 0 >>> max_balanced_strings('xxxxx') == 0 >>> max_balanced_strings('yyyyy') == 0 >>> max_balanced_strings('xyxy') == 2 >>> max_balanced_strings('xxy') == 0 >>> max_balanced_strings('xyxyxy') == 3 >>> max_balanced_strings('xxxyyyxyx') == 2 >>> max_balanced_strings('xyxxyxyyxxxyyyxxyy') == 4","solution":"def max_balanced_strings(s): Returns the maximum number of balanced strings that can be obtained from the input string s. A balanced string has an equal number of 'x' and 'y' characters. balance = 0 count = 0 for char in s: if char == 'x': balance += 1 elif char == 'y': balance -= 1 if balance == 0: count += 1 return count"},{"question":"def can_make_amount(denominations: List[int], amount: int) -> bool: Determines if it's possible to make up the given amount using the given denominations. :param denominations: List of integers representing coin denominations. :param amount: The target amount to make. :return: Boolean value, True if possible to make the amount, False otherwise. >>> can_make_amount([1, 2, 5], 11) True >>> can_make_amount([5], 10) True >>> can_make_amount([5], 3) False >>> can_make_amount([3, 7], 5) False >>> can_make_amount([2, 3], 6) True >>> can_make_amount([1, 2, 5], 100) True","solution":"def can_make_amount(denominations, amount): Determines if it's possible to make up the given amount using the given denominations. :param denominations: List of integers representing coin denominations. :param amount: The target amount to make. :return: Boolean value, True if possible to make the amount, False otherwise. dp = [False] * (amount + 1) dp[0] = True # Base case: zero amount can always be made with zero coins for coin in denominations: for x in range(coin, amount + 1): if dp[x - coin]: dp[x] = True return dp[amount]"},{"question":"class Node: def __init__(self, data): self.data = data self.next = None def largest_zero_sum_sublist(head): Returns the size of the largest contiguous sublist such that the sum of its elements is equal to zero in the given linked list. pass # Unit Tests def test_empty_list(): # Empty list test assert largest_zero_sum_sublist(None) == 0 def test_no_zero_sum_sublist(): # List with no zero sum sublist head = Node(1) head.next = Node(2) head.next.next = Node(3) assert largest_zero_sum_sublist(head) == 0 def test_single_element_zero(): # Single element that is zero head = Node(0) assert largest_zero_sum_sublist(head) == 1 def test_all_elements_zero(): # All elements are zero head = Node(0) head.next = Node(0) head.next.next = Node(0) head.next.next.next = Node(0) assert largest_zero_sum_sublist(head) == 4 def test_generic_list_with_zero_sum_sublist(): # List with zero sum sublist in it head = Node(1) head.next = Node(2) head.next.next = Node(-3) head.next.next.next = Node(3) head.next.next.next.next = Node(-1) head.next.next.next.next.next = Node(-1) assert largest_zero_sum_sublist(head) == 5","solution":"class Node: def __init__(self, data): self.data = data self.next = None def largest_zero_sum_sublist(head): Returns the size of the largest contiguous sublist such that the sum of its elements is equal to zero in the given linked list. prefix_sum = 0 max_len = 0 prefix_sum_map = {} current = head index = 0 while current is not None: prefix_sum += current.data if prefix_sum == 0: max_len = index + 1 if prefix_sum in prefix_sum_map: max_len = max(max_len, index - prefix_sum_map[prefix_sum]) else: prefix_sum_map[prefix_sum] = index current = current.next index += 1 return max_len"},{"question":"def max_non_decreasing_line(arr): Given an array of integers \`arr\`, where each integer represents the height of a person, return the maximum number of people that can form a single non-decreasing line from left to right. You are allowed to remove some people from the line to achieve this. :param arr: List[int] - A list of integers representing heights. :return: int - Maximum number of people that can form the non-decreasing line. >>> max_non_decreasing_line([]) == 0 >>> max_non_decreasing_line([5]) == 1 >>> max_non_decreasing_line([3, 3, 3]) == 3 >>> max_non_decreasing_line([1, 2, 3, 4, 5]) == 5 >>> max_non_decreasing_line([5, 4, 3, 2, 1]) == 1 >>> max_non_decreasing_line([2, 1, 3, 2, 4]) == 3 >>> max_non_decreasing_line([10, 20, 10, 30, 20, 50]) == 4 >>> max_non_decreasing_line([1, 3, 2, 1, 4, 7]) == 4","solution":"def max_non_decreasing_line(arr): Returns the maximum number of people that can form a single non-decreasing line from left to right by removing some people. :param arr: List[int] - A list of integers representing heights. :return: int - Maximum number of people that can form the non-decreasing line. if not arr: return 0 n = len(arr) dp = [1] * n # dp[i] will store the length of the longest non-decreasing subsequence ending with arr[i] for i in range(1, n): for j in range(i): if arr[i] >= arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def longest_word(words: list, letters: str) -> str: Returns the longest word that can be constructed from the given letters. >>> longest_word([\\"apple\\"], \\"aplinfre\\") == \\"apple\\" >>> longest_word([\\"apple\\", \\"bat\\", \\"cat\\", \\"car\\"], \\"aplinfre\\") == \\"apple\\" >>> longest_word([\\"apple\\", \\"bat\\", \\"cat\\"], \\"xyz\\") == \\"\\" >>> longest_word([\\"bat\\", \\"cat\\", \\"car\\"], \\"btarca\\") == \\"bat\\" >>> longest_word([], \\"btarca\\") == \\"\\" >>> longest_word([\\"bat\\", \\"cat\\", \\"car\\"], \\"\\") == \\"\\"","solution":"def can_construct(word, letters): Helper function to determine if a word can be constructed from given letters. # Create a set of available letters available_letters = set(letters) # Try to construct the word for letter in word: if letter not in available_letters: return False return True def longest_word(words, letters): Returns the longest word that can be constructed from the given letters. longest = \\"\\" for word in words: if can_construct(word, letters) and len(word) > len(longest): longest = word return longest"},{"question":"def count_similar_groups(words: List[str]) -> int: Groups words with identical character sets and returns the number of such groups. :param words: List of words to be grouped. :returns: Number of groups of identical character sets. >>> count_similar_groups([\\"listen\\", \\"silent\\", \\"enlist\\", \\"rat\\", \\"tar\\", \\"art\\", \\"evil\\", \\"vile\\", \\"live\\"]) 3 >>> count_similar_groups([\\"abc\\", \\"bac\\", \\"cab\\"]) 1 >>> count_similar_groups([\\"abc\\", \\"def\\", \\"ghi\\"]) 3 >>> count_similar_groups([\\"aaa\\", \\"aaa\\", \\"aaa\\"]) 1 >>> count_similar_groups([\\"abc\\", \\"bca\\", \\"cab\\", \\"xyz\\", \\"zyx\\"]) 2 >>> count_similar_groups([\\"ab\\", \\"abc\\", \\"bac\\", \\"cba\\", \\"a\\", \\"b\\", \\"ba\\"]) 4","solution":"def count_similar_groups(words): Groups words with identical character sets and returns the number of such groups. :param words: List of words to be grouped. :returns: Number of groups of identical character sets. unique_char_set_groups = set() for word in words: sorted_characters = \\"\\".join(sorted(set(word))) unique_char_set_groups.add(sorted_characters) return len(unique_char_set_groups)"},{"question":"def removeDuplicates(s: str) -> str: Function to remove duplicate characters and return the lexicographically smallest string following the rules. >>> removeDuplicates(\\"cbacdcbc\\") \\"acdb\\" >>> removeDuplicates(\\"bcabc\\") \\"abc\\" >>> removeDuplicates(\\"abc\\") \\"abc\\" >>> removeDuplicates(\\"aaaa\\") \\"a\\" >>> removeDuplicates(\\"abacb\\") \\"abc\\" >>> removeDuplicates(\\"ccbbccddeeff\\") \\"bcdef\\" >>> removeDuplicates(\\"zyxwv\\") \\"zyxwv\\" >>> removeDuplicates(\\"a\\") \\"a\\"","solution":"def removeDuplicates(s: str) -> str: Function to remove duplicate characters and return the lexicographically smallest string following the rules. last_occurrence = {c: i for i, c in enumerate(s)} stack = [] seen = set() for i, char in enumerate(s): if char in seen: continue while stack and char < stack[-1] and i < last_occurrence[stack[-1]]: seen.remove(stack.pop()) stack.append(char) seen.add(char) return ''.join(stack)"},{"question":"def is_valid_sequence(s: str) -> bool: Determines if a given string of brackets is valid. A string is considered valid if: - Every opening bracket has a corresponding closing bracket. - Brackets are closed in the correct order. Args: s (str): The input string containing brackets. Returns: bool: True if the string is valid, False otherwise. >>> is_valid_sequence(\\"()\\") True >>> is_valid_sequence(\\"()[]{}\\") True >>> is_valid_sequence(\\"{[]}\\") True >>> is_valid_sequence(\\"(]\\") False >>> is_valid_sequence(\\"([)]\\") False","solution":"def is_valid_sequence(s): Determines if a given string of brackets is valid. A string is considered valid if: - Every opening bracket has a corresponding closing bracket. - Brackets are closed in the correct order. Args: s (str): The input string containing brackets. Returns: bool: True if the string is valid, False otherwise. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isCompleteBinaryTree(root): Check whether a binary tree is a complete binary tree. Args: root (TreeNode): The root node of the binary tree. Returns: bool: True if the binary tree is complete, False otherwise. >>> tree = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) >>> isCompleteBinaryTree(tree) True >>> tree = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3)) >>> isCompleteBinaryTree(tree) True >>> tree = TreeNode(1, TreeNode(2, right=TreeNode(4)), TreeNode(3)) >>> isCompleteBinaryTree(tree) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isCompleteBinaryTree(root): if not root: return True queue = [root] foundNull = False while queue: current = queue.pop(0) if current: if foundNull: return False queue.append(current.left) queue.append(current.right) else: foundNull = True return True"},{"question":"def count_pairs(nums, target): Returns the number of pairs (i, j) where i < j and nums[i] + nums[j] equals target. >>> count_pairs([1, 2, 3, 4], 5) 2 >>> count_pairs([1, 1, 1, 1], 3) 0 >>> count_pairs([-1, -2, -3, 4, 3], 1) 2 >>> count_pairs([1, 1, 1, 1], 2) 6 >>> count_pairs([1, 2, 3, 4, 5], 10) 0","solution":"def count_pairs(nums, target): Returns the number of pairs (i, j) where i < j and nums[i] + nums[j] equals target. count = 0 n = len(nums) for i in range(n): for j in range(i + 1, n): if nums[i] + nums[j] == target: count += 1 return count"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the characters of the given string can be rearranged to form a palindrome. Args: s (str): The input string consisting of lowercase alphabets. Returns: bool: True if a palindrome can be formed, otherwise False. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False","solution":"def can_form_palindrome(s): Determines if the characters of the given string can be rearranged to form a palindrome. Args: s (str): The input string consisting of lowercase alphabets. Returns: bool: True if a palindrome can be formed, otherwise False. from collections import Counter # Count the occurrence of each character in the string count = Counter(s) # A palindrome can have at most one character with an odd occurrence odd_count = sum(1 for char, freq in count.items() if freq % 2 != 0) # For the string to be rearranged into a palindrome, at most one character should have an odd count return odd_count <= 1"},{"question":"from typing import List def min_students_to_rearrange(heights: List[int]) -> int: You are given an integer array \`heights\` representing the heights of students in a classroom in the order they appear. The teacher wants to rearrange the students in a non-decreasing order of their heights, but with the minimum number of students being moved to accomplish this. Return the minimum number of students that need to be moved to achieve the sorted order. Note: A move is defined as taking a student out of the current lineup and then inserting them back into any position of the lineup. >>> min_students_to_rearrange([1, 2, 3, 4]) 0 >>> min_students_to_rearrange([]) 0 >>> min_students_to_rearrange([1]) 0 >>> min_students_to_rearrange([4, 3, 2, 1]) 4 >>> min_students_to_rearrange([1, 3, 2, 4]) 2 >>> min_students_to_rearrange([3, 1, 2, 4]) 3 >>> min_students_to_rearrange([1, 2, 2, 1]) 2 >>> min_students_to_rearrange([2, 1, 2, 1]) 2 >>> min_students_to_rearrange([5, 3, 6, 1, 4, 2]) 6","solution":"def min_students_to_rearrange(heights): Returns the minimum number of students that need to be moved to achieve the sorted order. if not heights: return 0 sorted_heights = sorted(heights) count = 0 for i in range(len(heights)): if heights[i] != sorted_heights[i]: count += 1 return count"},{"question":"def longest_straight_subarray(arr: List[int], m: int) -> int: Returns the length of the longest straight subarray with consecutive increasing integers such that the subarray length does not exceed m. >>> longest_straight_subarray([1, 2, 3, 2, 3, 4, 5], 3) == 3 >>> longest_straight_subarray([1, 2, 3, 4], 5) == 4 >>> longest_straight_subarray([1, 3, 5, 7], 2) == 1 >>> longest_straight_subarray([1, 2, 3, 4, 5, 6, 7, 8], 4) == 4 >>> longest_straight_subarray([1], 1) == 1 >>> longest_straight_subarray([1, 1, 1, 1, 1], 3) == 1 >>> longest_straight_subarray([1, 2, 3, 1, 2, 3, 4], 3) == 3 >>> longest_straight_subarray([], 2) == 0 >>> longest_straight_subarray([1, 2, 3, 4, 5], 1) == 1 pass","solution":"def longest_straight_subarray(arr, m): Returns the length of the longest straight subarray with consecutive increasing integers such that the subarray length does not exceed m. n = len(arr) if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if arr[i] == arr[i - 1] + 1: current_length += 1 else: current_length = 1 if current_length > m: current_length = m max_length = max(max_length, current_length) return max_length"},{"question":"from typing import List, Tuple def invalid_transactions(transactions: List[Tuple[str, str, str, str]]) -> List[str]: You are given a list of \`n\` transactions where each transaction is represented as a tuple \`(name, time, amount, city)\`. The name is a string representing the person who did the transaction, time is an integer representing the time in minutes at which the transaction occurred, amount is an integer representing the transaction amount, and city is a string indicating the city in which the transaction occurred. A transaction is considered **invalid** if: * The amount exceeds 1000, or * There exists another transaction with the same name within a 60-minute interval (including both transactions) and in a different city. Your task is to return a list of strings representing all the invalid transactions. The transactions should be returned in the order they appear in the input list. >>> invalid_transactions([(\\"alice\\", \\"20\\", \\"800\\", \\"NY\\")]) [] >>> invalid_transactions([(\\"alice\\", \\"20\\", \\"1200\\", \\"NY\\")]) [\\"alice,20,1200,NY\\"] >>> invalid_transactions([(\\"alice\\", \\"20\\", \\"800\\", \\"NY\\"), (\\"alice\\", \\"50\\", \\"100\\", \\"LA\\")]) [\\"alice,20,800,NY\\", \\"alice,50,100,LA\\"] >>> invalid_transactions([(\\"alice\\", \\"20\\", \\"800\\", \\"NY\\"), (\\"alice\\", \\"70\\", \\"800\\", \\"NY\\")]) [] >>> invalid_transactions([(\\"bob\\", \\"50\\", \\"500\\", \\"SF\\"), (\\"alice\\", \\"20\\", \\"1200\\", \\"NY\\"), (\\"charlie\\", \\"55\\", \\"500\\", \\"SF\\"), (\\"alice\\", \\"25\\", \\"800\\", \\"LA\\")]) [\\"alice,20,1200,NY\\", \\"alice,25,800,LA\\"] >>> invalid_transactions([(\\"dave\\", \\"20\\", \\"800\\", \\"NY\\"), (\\"dave\\", \\"20\\", \\"500\\", \\"LA\\")]) [\\"dave,20,800,NY\\", \\"dave,20,500,LA\\"]","solution":"def invalid_transactions(transactions): invalid = set() for i in range(len(transactions)): name1, time1, amount1, city1 = transactions[i] if int(amount1) > 1000: invalid.add(i) for j in range(len(transactions)): if i != j: name2, time2, amount2, city2 = transactions[j] if name1 == name2 and abs(int(time1) - int(time2)) <= 60 and city1 != city2: invalid.add(i) invalid.add(j) return [\\",\\".join(transactions[i]) for i in invalid]"},{"question":"def min_swaps_to_sort(arr: List[int]) -> int: Returns the minimum number of swaps required to sort the array in non-decreasing order. >>> min_swaps_to_sort([4, 3, 2, 1]) 2 >>> min_swaps_to_sort([1, 2, 3, 4]) 0 >>> min_swaps_to_sort([4, 3, 2, 1, 5]) 2 >>> min_swaps_to_sort([1, 3, 5, 2, 4, 6]) 3 >>> min_swaps_to_sort([1]) 0 >>> min_swaps_to_sort([2, 1]) 1 >>> min_swaps_to_sort([19, 17, 15, 13, 11, 9, 7, 5, 3, 1]) 5","solution":"def min_swaps_to_sort(arr): Returns the minimum number of swaps required to sort the array in non-decreasing order. # Getting the array length n = len(arr) # Creating a list of tuples where each tuple is the element and its index arrpos = list(enumerate(arr)) # Sorting the array by its value arrpos.sort(key=lambda it: it[1]) # Visited array to keep track of already visited elements visited = [False] * n # Initialize result swaps = 0 # Loop through each element for i in range(n): # Skip already visited or already correctly placed elements if visited[i] or arrpos[i][0] == i: continue # initiate cycle variables cycle_size = 0 j = i # traverse the cycle while not visited[j]: # mark node as visited visited[j] = True # move to next node j = arrpos[j][0] cycle_size += 1 # Update swaps if there is more than one element in the cycle if cycle_size > 1: swaps += cycle_size - 1 return swaps"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates_unsorted_linked_list(head: ListNode) -> ListNode: Removes all nodes that have duplicate integers, leaving only distinct numbers from the original list. The list will be sorted in ascending order before returning. >>> head = convert_list_to_linked_list([1, 2, 3, 3, 4, 4, 5]) >>> new_head = remove_duplicates_unsorted_linked_list(head) >>> convert_linked_list_to_list(new_head) [1, 2, 5] >>> head = convert_list_to_linked_list([4, 4, 4, 4]) >>> new_head = remove_duplicates_unsorted_linked_list(head) >>> convert_linked_list_to_list(new_head) None pass def convert_list_to_linked_list(arr): if not arr: return None head = ListNode(arr[0]) current = head for value in arr[1:]: current.next = ListNode(value) current = current.next return head def convert_linked_list_to_list(head): arr = [] current = head while current: arr.append(current.val) current = current.next return arr def test_no_duplicates(): head = convert_list_to_linked_list([1, 2, 3]) new_head = remove_duplicates_unsorted_linked_list(head) assert convert_linked_list_to_list(new_head) == [1, 2, 3] def test_with_duplicates(): head = convert_list_to_linked_list([1, 2, 3, 3, 4, 4, 5]) new_head = remove_duplicates_unsorted_linked_list(head) assert convert_linked_list_to_list(new_head) == [1, 2, 5] def test_all_duplicate_elements(): head = convert_list_to_linked_list([4, 4, 4, 4]) new_head = remove_duplicates_unsorted_linked_list(head) assert new_head == None def test_single_element(): head = convert_list_to_linked_list([1]) new_head = remove_duplicates_unsorted_linked_list(head) assert convert_linked_list_to_list(new_head) == [1] def test_mixed_elements(): head = convert_list_to_linked_list([1, 1, 2, 3, 3, 4]) new_head = remove_duplicates_unsorted_linked_list(head) assert convert_linked_list_to_list(new_head) == [2, 4] def test_empty_list(): head = convert_list_to_linked_list([]) new_head = remove_duplicates_unsorted_linked_list(head) assert new_head == None","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates_unsorted_linked_list(head): Removes all nodes that have duplicate integers, leaving only distinct numbers from the original list. The list will be sorted in ascending order before returning. if not head: return None # count occurrences of each value count = {} current = head while current: count[current.val] = count.get(current.val, 0) + 1 current = current.next # collect distinct values distinct_values = [val for val, occ in count.items() if occ == 1] # if no distinct values found, return empty list if not distinct_values: return None # sort distinct values distinct_values.sort() # create new linked list new_head = ListNode(distinct_values[0]) current = new_head for val in distinct_values[1:]: current.next = ListNode(val) current = current.next return new_head"},{"question":"import heapq from collections import Counter def reorganizeString(s: str) -> str: Rearranges the string so that no two adjacent characters are the same. If it is not possible, returns an empty string. >>> reorganizeString(\\"aab\\") in [\\"aba\\"] True >>> reorganizeString(\\"aaabbc\\") in [\\"ababac\\", \\"abacab\\", \\"acabab\\", \\"acabab\\"] True >>> reorganizeString(\\"aaab\\") '' >>> reorganizeString(\\"a\\") 'a' >>> reorganizeString(\\"aa\\") '' >>> reorganizeString(\\"ab\\") in [\\"ab\\", \\"ba\\"] True >>> reorganizeString(\\"aabbcc\\") in [\\"abcabc\\", \\"acbacb\\", \\"bacbac\\", \\"bcabac\\", \\"cabacb\\", \\"cbacba\\"] True","solution":"import heapq from collections import Counter def reorganizeString(s: str) -> str: Rearranges the string so that no two adjacent characters are the same. If it is not possible, returns an empty string. count = Counter(s) max_heap = [(-freq, char) for char, freq in count.items()] heapq.heapify(max_heap) prev_char, prev_freq = None, 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char, prev_freq = char, freq + 1 result_str = \\"\\".join(result) if len(result_str) != len(s): return \\"\\" return result_str"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def hasPathSum(root: TreeNode, targetSum: int) -> bool: Determines if there exists a root-to-leaf path in the binary tree that sums to targetSum. Parameters: root (TreeNode): The root of the binary tree. targetSum (int): The sum to check for the valid path. Returns: bool: True if such a path exists, False otherwise. >>> hasPathSum(TreeNode(5, TreeNode(4), TreeNode(8)), 9) True >>> hasPathSum(TreeNode(5, TreeNode(4), TreeNode(8)), 14) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def hasPathSum(root, targetSum): Determines if there exists a root-to-leaf path in the binary tree that sums to targetSum. Parameters: root (TreeNode): The root of the binary tree. targetSum (int): The sum to check for the valid path. Returns: bool: True if such a path exists, False otherwise. if not root: return False # If we reach a leaf node, check if the remaining targetSum equals the node's value if not root.left and not root.right: return root.val == targetSum # Recursively check the left and right subtrees targetSum -= root.val return hasPathSum(root.left, targetSum) or hasPathSum(root.right, targetSum)"},{"question":"def count_buildings_with_sunrise_view(heights: List[int]) -> int: Returns the number of buildings that have an unobstructed view of the sunrise. A building has an unobstructed view of the sunrise if there is no building to the left with a greater or equal height. >>> count_buildings_with_sunrise_view([1, 2, 3, 4, 5]) 5 >>> count_buildings_with_sunrise_view([5, 4, 3, 2, 1]) 1 >>> count_buildings_with_sunrise_view([1, 3, 2, 4, 2]) 3 >>> count_buildings_with_sunrise_view([3, 3, 3, 3, 3]) 1 >>> count_buildings_with_sunrise_view([7]) 1 >>> count_buildings_with_sunrise_view([]) 0","solution":"def count_buildings_with_sunrise_view(heights): Returns the number of buildings that have an unobstructed view of the sunrise. if not heights: return 0 max_height = heights[0] count = 1 for i in range(1, len(heights)): if heights[i] > max_height: count += 1 max_height = heights[i] return count"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def detectCycle(head): Detects the node where the cycle begins in a singly linked list. If there is no cycle, returns null. :param head: ListNode, head of the singly linked list :return: ListNode, node where cycle begins or None if no cycle from solution import ListNode, detectCycle def test_no_cycle(): head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) assert detectCycle(head) == None def test_cycle_at_start(): head = ListNode(1) head.next = ListNode(2) head.next.next = head assert detectCycle(head) == head def test_cycle_at_middle(): head = ListNode(1) second_node = ListNode(2) tail = ListNode(3) head.next = second_node second_node.next = tail tail.next = second_node assert detectCycle(head) == second_node def test_large_cycle(): head = ListNode(1) second_node = ListNode(2) tail = ListNode(3) fourth_node = ListNode(4) head.next = second_node second_node.next = tail tail.next = fourth_node fourth_node.next = second_node assert detectCycle(head) == second_node def test_single_node_no_cycle(): head = ListNode(1) assert detectCycle(head) == None def test_single_node_with_cycle(): head = ListNode(1) head.next = head assert detectCycle(head) == head","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def detectCycle(head): Detects the node where the cycle begins in a singly linked list. If there is no cycle, returns null. :param head: ListNode, head of the singly linked list :return: ListNode, node where cycle begins or None if no cycle if not head or not head.next: return None slow = head fast = head has_cycle = False while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: has_cycle = True break if not has_cycle: return None slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"def longest_substring_without_repeating_characters(s: str) -> str: Given a string s, return the longest substring without repeating characters. If there are multiple longest substrings with the same length, return the one which appears first. >>> longest_substring_without_repeating_characters(\\"\\") == \\"\\" >>> longest_substring_without_repeating_characters(\\"a\\") == \\"a\\" >>> longest_substring_without_repeating_characters(\\"abcde\\") == \\"abcde\\" >>> longest_substring_without_repeating_characters(\\"abcabcbb\\") == \\"abc\\" >>> longest_substring_without_repeating_characters(\\"bbbbb\\") == \\"b\\" >>> longest_substring_without_repeating_characters(\\"abcabcdabcde\\") == \\"abcde\\" >>> longest_substring_without_repeating_characters(\\"pwwkew\\") == \\"wke\\" >>> longest_substring_without_repeating_characters(\\"dvdf\\") == \\"vdf\\"","solution":"def longest_substring_without_repeating_characters(s): Returns the longest substring without repeating characters. char_map = {} left = 0 longest = 0 start_index = 0 for right, char in enumerate(s): if char in char_map and char_map[char] >= left: left = char_map[char] + 1 char_map[char] = right if right - left + 1 > longest: longest = right - left + 1 start_index = left return s[start_index:start_index + longest]"},{"question":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the given list. :param nums: List of integers :return: Integer length of the longest increasing subsequence >>> length_of_lis([]) == 0 >>> length_of_lis([10]) == 1 >>> length_of_lis([1, 2, 3, 4, 5]) == 5 >>> length_of_lis([5, 4, 3, 2, 1]) == 1 >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> length_of_lis([2, 1, 3, 9, 1, 3, 5, 6, 4, 8, 9]) == 6","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the given list. :param nums: List of integers :return: Integer length of the longest increasing subsequence if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def sunsetView(buildings: List[int]) -> int: Returns the number of buildings with a direct view of the sunset. Parameters: buildings (List[int]): List of building heights. Returns: int: Number of buildings with a direct view of the sunset. >>> sunsetView([3, 3, 3, 3, 3]) 1 >>> sunsetView([1, 2, 3, 4, 5]) 1 >>> sunsetView([5, 4, 3, 2, 1]) 5 >>> sunsetView([4, 3, 2, 7, 3, 2, 5, 1]) 3 >>> sunsetView([10]) 1 >>> sunsetView([]) 0","solution":"def sunsetView(buildings): Returns the number of buildings with a direct view of the sunset. Parameters: buildings (List[int]): List of building heights. Returns: int: Number of buildings with a direct view of the sunset. count = 0 max_height = float('-inf') for height in reversed(buildings): if height > max_height: count += 1 max_height = height return count"},{"question":"def three_sum(nums): Given an array of integers, find all unique triplets in the array which gives the sum of zero. Notice that the solution set must not contain duplicate triplets. :param nums: List of integers :return: List of unique triplets that sum to zero >>> three_sum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([-3, -2, -1, -4]) [] >>> three_sum([1, 2, 3, 4, 5]) [] >>> three_sum([0, 0, 0, 0]) [[0, 0, 0]] >>> three_sum([-2, 0, 0, 2, 2]) [[-2, 0, 2]]","solution":"def three_sum(nums): Given an array of integers, find all unique triplets which sum to zero. :param nums: List of integers :return: List of unique triplets that sum to zero nums.sort() triplets = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue # skip duplicates left, right = i + 1, len(nums) - 1 while left < right: s = nums[i] + nums[left] + nums[right] if s < 0: left += 1 elif s > 0: right -= 1 else: triplets.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 # skip duplicates while left < right and nums[right] == nums[right - 1]: right -= 1 # skip duplicates left += 1 right -= 1 return triplets"},{"question":"def shuffle_string(s: str, indices: List[int]) -> str: Shuffle the string \`s\` according to the \`indices\` array and return the resultant shuffled string. Parameters: s : str : The input string to be shuffled. indices : List[int] : The array of indices representing the new positions of characters in the shuffled string. Returns: str : The shuffled string. >>> shuffle_string(\\"abc\\", [2, 0, 1]) \\"bca\\" >>> shuffle_string(\\"abcd\\", [0, 1, 2, 3]) \\"abcd\\" >>> shuffle_string(\\"abcd\\", [3, 2, 1, 0]) \\"dcba\\" >>> shuffle_string(\\"hello\\", [4, 3, 2, 1, 0]) \\"olleh\\" >>> shuffle_string(\\"aabb\\", [1, 0, 3, 2]) \\"aabb\\"","solution":"def shuffle_string(s, indices): Shuffles the string \`s\` according to the \`indices\` array. Parameters: s (str): The input string to be shuffled. indices (List[int]): The array of indices representing the new positions of characters in the shuffled string. Returns: str: The shuffled string. shuffled = [''] * len(s) for i, idx in enumerate(indices): shuffled[idx] = s[i] return ''.join(shuffled)"},{"question":"def max_interval(timestamps: List[str]) -> str: Returns the maximum interval between any two consecutive timestamps in the given list. Args: timestamps (list): List of timestamps in the format \\"HH:MM:SS\\". Returns: str: Maximum interval as a string in the format \\"HH:MM:SS\\". If the list contains fewer than two timestamps, return \\"00:00:00\\". >>> max_interval([\\"01:00:00\\", \\"01:30:00\\", \\"02:00:00\\"]) \\"00:30:00\\" >>> max_interval([\\"00:00:00\\", \\"12:00:00\\", \\"23:59:59\\"]) \\"12:00:00\\" >>> max_interval([\\"00:00:00\\", \\"00:00:01\\", \\"00:00:02\\"]) \\"00:00:01\\" >>> max_interval([\\"01:00:00\\", \\"02:00:00\\"]) \\"01:00:00\\" >>> max_interval([\\"01:00:00\\"]) \\"00:00:00\\" >>> max_interval([]) \\"00:00:00\\"","solution":"def max_interval(timestamps): Returns the maximum interval between any two consecutive timestamps in the given list. Args: timestamps (list): List of timestamps in the format \\"HH:MM:SS\\". Returns: str: Maximum interval as a string in the format \\"HH:MM:SS\\". if len(timestamps) < 2: return \\"00:00:00\\" max_diff = 0 def time_to_seconds(time_str): h, m, s = map(int, time_str.split(':')) return h * 3600 + m * 60 + s def seconds_to_time(seconds): h = seconds // 3600 m = (seconds % 3600) // 60 s = seconds % 60 return f\\"{h:02}:{m:02}:{s:02}\\" for i in range(1, len(timestamps)): t1 = time_to_seconds(timestamps[i-1]) t2 = time_to_seconds(timestamps[i]) diff = t2 - t1 if diff > max_diff: max_diff = diff return seconds_to_time(max_diff)"},{"question":"from typing import List def rob(nums: List[int]) -> int: Returns the maximum amount of money a thief can rob from the circle of houses. Given a list of non-negative integers representing the amount of money of each house, arranged in a circle, determine the maximum amount of money that can be robbed without alerting the police (i.e., not robbing two adjacent houses). >>> rob([100]) 100 >>> rob([2, 3]) 3 >>> rob([2, 3, 2]) 3 >>> rob([1, 2, 3, 1]) 4 >>> rob([200, 3, 140, 20, 10]) 340 >>> rob([2, 7, 9, 3, 1]) 11 >>> rob([5, 5, 10, 100, 10, 5]) 110 >>> rob([]) 0 >>> rob([0, 0, 0, 0, 0]) 0 >>> rob([5, 10, 0]) 10","solution":"def rob(nums): Returns the maximum amount of money a thief can rob from the circle of houses. def rob_linear(houses): rob1, rob2 = 0, 0 for n in houses: new_rob = max(rob1 + n, rob2) rob1 = rob2 rob2 = new_rob return rob2 if len(nums) == 1: return nums[0] # Exclude the first house or the last house because they can't be robbed together return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"def min_cost_to_reach_target(x: int, y: int, leftCost: int, rightCost: int, upCost: int, downCost: int) -> int: Calculate the minimum cost for the robot to reach the target position (x, y) from the origin (0, 0). Parameters: x (int): The X-coordinate of the target position. y (int): The Y-coordinate of the target position. leftCost (int): Cost of moving left. rightCost (int): Cost of moving right. upCost (int): Cost of moving up. downCost (int): Cost of moving down. Returns: int: The minimum cost to reach the target position. def test_min_cost_to_reach_target_right_up(): assert min_cost_to_reach_target(3, 4, 2, 3, 4, 5) == 3*3 + 4*4 def test_min_cost_to_reach_target_left_down(): assert min_cost_to_reach_target(-2, -3, 1, 2, 3, 4) == 2*1 + 3*4 def test_min_cost_to_reach_target_left_up(): assert min_cost_to_reach_target(-1, 2, 3, 2, 5, 4) == 1*3 + 2*5 def test_min_cost_to_reach_target_right_down(): assert min_cost_to_reach_target(2, -1, 4, 3, 2, 1) == 2*3 + 1*1 def test_min_cost_to_reach_target_zero(): assert min_cost_to_reach_target(0, 0, 1, 1, 1, 1) == 0","solution":"def min_cost_to_reach_target(x, y, leftCost, rightCost, upCost, downCost): Calculate the minimum cost for the robot to reach the target position (x, y) from the origin (0, 0). Parameters: x (int): The X-coordinate of the target position. y (int): The Y-coordinate of the target position. leftCost (int): Cost of moving left. rightCost (int): Cost of moving right. upCost (int): Cost of moving up. downCost (int): Cost of moving down. Returns: int: The minimum cost to reach the target position. total_cost = 0 # Move horizontally if x > 0: total_cost += x * rightCost else: total_cost += abs(x) * leftCost # Move vertically if y > 0: total_cost += y * upCost else: total_cost += abs(y) * downCost return total_cost"},{"question":"def minimize_total_lateness(tasks: List[Dict[str, int]]) -> List[int]: Returns the order of tasks that minimizes the total lateness. Parameters: tasks (list): List of dictionaries where each dictionary represents a task with 'duration' and 'deadline'. Returns: list: A 1-indexed list of task indices representing the order. >>> minimize_total_lateness([{'duration': 3, 'deadline': 9}, {'duration': 2, 'deadline': 7}, {'duration': 5, 'deadline': 5}]) [3, 2, 1] >>> minimize_total_lateness([{'duration': 1, 'deadline': 4}, {'duration': 2, 'deadline': 2}, {'duration': 1, 'deadline': 1}]) [3, 2, 1] >>> minimize_total_lateness([{'duration': 3, 'deadline': 9}, {'duration': 3, 'deadline': 10}, {'duration': 4, 'deadline': 1}]) [3, 1, 2] >>> minimize_total_lateness([{'duration': 1, 'deadline': 2}, {'duration': 4, 'deadline': 6}, {'duration': 2, 'deadline': 5}]) [1, 3, 2] >>> minimize_total_lateness([{'duration': 5, 'deadline': 5}, {'duration': 8, 'deadline': 10}, {'duration': 2, 'deadline': 8}]) [1, 3, 2]","solution":"def minimize_total_lateness(tasks): Returns the order of tasks that minimizes the total lateness. Parameters: tasks (list): List of dictionaries where each dictionary represents a task with 'duration' and 'deadline'. Returns: list: A 1-indexed list of task indices representing the order. # Sort tasks by deadlines sorted_tasks = sorted(enumerate(tasks), key=lambda x: x[1]['deadline']) # Extract the original indices (1-indexed) of the sorted tasks order = [task[0] + 1 for task in sorted_tasks] return order"},{"question":"def longest_bitonic_subsequence(arr: List[int]) -> int: Given an array of integers \`arr\`, return the length of the longest subsequence that is a bitonic sequence. A sequence is bitonic if it is first increasing and then decreasing. A strictly increasing or strictly decreasing sequence is also considered a bitonic sequence. >>> longest_bitonic_subsequence([1, 2, 3, 4, 3, 2, 1]) 7 >>> longest_bitonic_subsequence([1, 11, 2, 10, 4, 5, 2, 1]) 6 >>> longest_bitonic_subsequence([]) 0 >>> longest_bitonic_subsequence([10]) 1 >>> longest_bitonic_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_bitonic_subsequence([5, 4, 3, 2, 1]) 5 >>> longest_bitonic_subsequence([1, 3, 5, 4, 7, 6, 2, 0]) 7 >>> longest_bitonic_subsequence([10, 20, 30, 25, 15, 10, 5]) 7 >>> longest_bitonic_subsequence([10, 20, 30, 40, 50, 60, 55]) 7 >>> longest_bitonic_subsequence([80, 60, 30, 40, 20, 10]) 5 >>> longest_bitonic_subsequence([1, 3, 5, 10, 7, 6, 5, 3, 2, 1]) 10","solution":"def longest_bitonic_subsequence(arr): n = len(arr) if n == 0: return 0 # Initialize the increasing subsequence table inc = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: inc[i] = max(inc[i], inc[j] + 1) # Initialize the decreasing subsequence table dec = [1] * n for i in reversed(range(n-1)): for j in reversed(range(i, n)): if arr[i] > arr[j]: dec[i] = max(dec[i], dec[j] + 1) # Calculate the length of the longest bitonic subsequence max_length = 0 for i in range(n): max_length = max(max_length, inc[i] + dec[i] - 1) return max_length"},{"question":"def decompress_string(s: str) -> str: Decompress a compressed string where each character can be followed by a positive integer indicating the number of times it is repeated. :param s: Compressed input string :return: Decompressed output string >>> decompress_string(\\"a2b3\\") 'aabbb' >>> decompress_string(\\"abc\\") 'abc' >>> decompress_string(\\"a9\\") 'aaaaaaaaa' >>> decompress_string(\\"a1b2c3\\") 'abbccc' >>> decompress_string(\\"\\") '' >>> decompress_string(\\"a12b5\\") 'aaaaaaaaaaaabbbbb' >>> decompress_string(\\"a5b1c4d\\") 'aaaaabccccd'","solution":"def decompress_string(s): Decompress a compressed string where each character can be followed by a positive integer indicating the number of times it is repeated. :param s: Compressed input string :return: Decompressed output string decompressed = [] i = 0 while i < len(s): if s[i].isalpha(): char = s[i] count = 0 i += 1 while i < len(s) and s[i].isdigit(): count = count * 10 + int(s[i]) i += 1 if count == 0: decompressed.append(char) else: decompressed.append(char * count) else: i += 1 return ''.join(decompressed)"},{"question":"class WordDictionary: def __init__(self): Initializes the WordDictionary object. pass def addWord(self, word: str) -> None: Adds a word to the data structure. Args: word (str): The word to add pass def search(self, word: str) -> bool: Returns true if there is any string in the data structure that matches word or false otherwise. A word could contain the '.' character to represent any one letter. Args: word (str): The word to search Returns: bool: True if the word is found, False otherwise >>> wd = WordDictionary() >>> wd.addWord(\\"bad\\") >>> wd.addWord(\\"dad\\") >>> wd.addWord(\\"mad\\") >>> wd.search(\\"pad\\") False >>> wd.search(\\"bad\\") True >>> wd.search(\\".ad\\") True >>> wd.search(\\"b..\\") True pass","solution":"class WordDictionary: def __init__(self): self.words = [] def addWord(self, word: str) -> None: self.words.append(word) def search(self, word: str) -> bool: import re # Convert the word to a regex pattern pattern = '^' + word.replace('.', '[a-z]') + '' regex = re.compile(pattern) return any(regex.match(w) for w in self.words)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumNumbers(root: TreeNode) -> int: Returns the sum of all numbers formed by root-to-leaf paths in the binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> sumNumbers(root) 25 >>> root = TreeNode(4) >>> root.left = TreeNode(9) >>> root.right = TreeNode(0) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(1) >>> sumNumbers(root) 1026 >>> sumNumbers(None) 0 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> sumNumbers(root) 123 >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> sumNumbers(root) 123","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumNumbers(root): Returns the sum of all numbers formed by root-to-leaf paths in the binary tree. def dfs(node, current_number): if not node: return 0 current_number = current_number * 10 + node.val if not node.left and not node.right: # If leaf node return current_number return dfs(node.left, current_number) + dfs(node.right, current_number) return dfs(root, 0)"},{"question":"def min_coins(s: str, m: int) -> int: Determines the minimum number of coins needed to make amount m using the given denominations. :param s: A string of integers separated by commas representing coin denominations. :param m: The amount to form using the coins. :return: Minimum number of coins needed to make the amount m, or -1 if it's not possible. >>> min_coins(\\"1\\", 5) == 5 >>> min_coins(\\"5\\", 5) == 1 >>> min_coins(\\"3\\", 5) == -1 >>> min_coins(\\"1,2,5\\", 11) == 3 # 5 + 5 + 1 >>> min_coins(\\"2,5\\", 3) == -1 >>> min_coins(\\"1,3,4\\", 6) == 2 # 3 + 3 >>> min_coins(\\"1,2,5\\", 100) == 20 # 5 * 20 >>> min_coins(\\"10,25,50\\", 100) == 2 # 50 + 50 >>> min_coins(\\"3,7\\", 5) == -1 >>> min_coins(\\"2,4,6\\", 5) == -1 >>> min_coins(\\"1,5,10\\", 7) == 3 # 5 + 1 + 1 >>> min_coins(\\"1,2,5\\", 0) == 0","solution":"def min_coins(s, m): Determines the minimum number of coins needed to make amount m using the given denominations. :param s: A string of integers separated by commas representing coin denominations. :param m: The amount to form using the coins. :return: Minimum number of coins needed to make the amount m, or -1 if it's not possible. coins = list(map(int, s.split(','))) n = len(coins) # Create a table to store the minimum number of coins for values from 0 to m dp = [float('inf')] * (m + 1) dp[0] = 0 # base case: 0 coins are needed to make 0 amount # Update dp table for each coin available for coin in coins: for x in range(coin, m + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[m] if dp[m] != float('inf') else -1"},{"question":"def trap_rainwater(heights: List[int]) -> int: Given an array of integers heights representing the height of buildings, calculate the total amount of trapped water after it rains. >>> trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_rainwater([4, 2, 0, 3, 2, 5]) == 9 >>> trap_rainwater([]) == 0 >>> trap_rainwater([1, 2, 3, 4, 5]) == 0 >>> trap_rainwater([5]) == 0 >>> trap_rainwater([3, 1, 2]) == 1","solution":"def trap_rainwater(heights): Function to calculate the total amount of trapped water. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def max_apples(nums: List[int], k: int) -> int: Returns the maximum number of apples that can be collected by selecting up to k baskets. Args: nums (List[int]): An array where each element represents the number of apples present in a basket. k (int): The maximum number of baskets that can be selected. Returns: int: The maximum number of apples collected. >>> max_apples([5, 3, 2, 8, 6], 3) 19 >>> max_apples([7], 1) 7 >>> max_apples([1, 2, 3, 4, 5], 5) 15 >>> max_apples([4, 2, 6], 5) 12 >>> max_apples([4, 4, 4, 4], 2) 8 >>> max_apples([4, 4, 4, 4], 4) 16 >>> max_apples([3, 1, 4, 1, 5], 0) 0","solution":"def max_apples(nums, k): Returns the maximum number of apples that can be collected by selecting up to k baskets. # Sort the array in descending order to pick the baskets with the most apples nums.sort(reverse=True) # Select the top k baskets return sum(nums[:k])"},{"question":"def min_words_to_form_target(words, target): Function to find the minimum number of strings from 'words' required to form 'target'. Each string from 'words' can be used multiple times. If it is not possible to form 'target', return -1. pass def test_min_words_to_form_target(): from solution import min_words_to_form_target assert min_words_to_form_target([\\"ab\\", \\"cd\\", \\"ef\\"], \\"abcdef\\") == 3 assert min_words_to_form_target([\\"a\\", \\"ab\\", \\"bc\\"], \\"abac\\") == -1 assert min_words_to_form_target([\\"a\\", \\"abc\\", \\"b\\", \\"cd\\"], \\"abcd\\") == 3 assert min_words_to_form_target([\\"ab\\", \\"abc\\", \\"cd\\", \\"def\\"], \\"abcdef\\") == 2 assert min_words_to_form_target([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\"], \\"abcdef\\") == 6 assert min_words_to_form_target([\\"cat\\", \\"dog\\"], \\"catdog\\") == 2 assert min_words_to_form_target([\\"cat\\", \\"dog\\"], \\"dogcatcher\\") == -1 assert min_words_to_form_target([], \\"any\\") == -1","solution":"def min_words_to_form_target(words, target): Function to find the minimum number of strings from 'words' required to form 'target'. Each string from 'words' can be used multiple times. If it is not possible to form 'target', return -1. from collections import defaultdict, deque n = len(target) # Cache for minimum words needed for each substring of target ending at each character dp = [float('inf')] * (n + 1) dp[0] = 0 # Base case, 0 words needed to form the empty substring # Preprocessing: map every character in target to positions where it occurs char_positions = defaultdict(list) for i, char in enumerate(target): char_positions[char].append(i) # Use BFS to find the minimum number of words needed to form each prefix of the target queue = deque([(0, 0)]) # (current index in target, number of words used) while queue: current_index, num_words = queue.popleft() if current_index == n: return num_words for word in words: match_length = len(word) if target[current_index:current_index + match_length] == word: new_index = current_index + match_length if new_index <= n and dp[new_index] > num_words + 1: dp[new_index] = num_words + 1 queue.append((new_index, num_words + 1)) return dp[n] if dp[n] != float('inf') else -1"},{"question":"import heapq from typing import List def kth_smallest(matrix: List[List[int]], k: int) -> int: Finds the kth smallest element in the sorted order of all elements in a sorted m x n matrix. Each row and each column of the matrix is sorted in non-decreasing order. Args: matrix (List[List[int]]): 2D list of integers, with each row and column sorted in non-decreasing order. k (int): The kth smallest element to find. Returns: int: The kth smallest element in the sorted order of the matrix. Example: >>> matrix = [ ... [1, 5, 9], ... [10, 11, 13], ... [12, 13, 15] ... ] >>> k = 8 >>> kth_smallest(matrix, k) 13 >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> k = 3 >>> kth_smallest(matrix, k) 3 >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> k = 5 >>> kth_smallest(matrix, k) 5 def test_kth_smallest_1(): matrix = [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ] k = 8 assert kth_smallest(matrix, k) == 13 def test_kth_smallest_2(): matrix = [ [1, 2], [3, 4] ] k = 3 assert kth_smallest(matrix, k) == 3 def test_kth_smallest_3(): matrix = [ [1,2,3], [4,5,6], [7,8,9] ] k = 5 assert kth_smallest(matrix, k) == 5 def test_kth_smallest_4(): matrix = [ [1, 1, 3], [1, 3, 4] ] k = 2 assert kth_smallest(matrix, k) == 1 def test_kth_smallest_5(): matrix = [ [1, 1, 1, 2], [1, 1, 1, 3], [2, 2, 3, 3], [2, 2, 3, 4] ] k = 7 assert kth_smallest(matrix, k) == 2","solution":"import heapq def kth_smallest(matrix, k): Finds the kth smallest element in the sorted order of all elements in a sorted m x n matrix. Args: matrix (List[List[int]]): 2D list of integers, with each row and column sorted in non-decreasing order. k (int): The kth smallest element to find. Returns: int: The kth smallest element in the sorted order of the matrix. min_heap = [] n = len(matrix) # Build a list of the smallest element from each row along with their coordinates. for r in range(min(k, n)): # No need to consider more than k rows heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Remove the smallest element from the heap k times while k: element, r, c = heapq.heappop(min_heap) # If there's a next element in the row of the current smallest element, add it to the heap. if c < n - 1: heapq.heappush(min_heap, (matrix[r][c+1], r, c+1)) k -= 1 return element"},{"question":"def max_sum_of_k_subarray_max_elements(nums: List[int], k: int) -> int: You are given a 0-indexed integer array \`nums\` of length \`n\` and an integer \`k\`. Your goal is to partition the array into contiguous subarrays such that the sum of the largest elements in each subarray is maximized. The number of contiguous subarrays should be exactly \`k\`. Return an integer denoting the maximum possible sum of the largest elements in each subarray. If it's not possible to partition \`nums\` into exactly \`k\` subarrays, return -1. >>> max_sum_of_k_subarray_max_elements([1, 15, 7, 9, 2, 5, 10], 3) 34 >>> max_sum_of_k_subarray_max_elements([1, 2, 3, 4, 5], 2) 9 >>> max_sum_of_k_subarray_max_elements([1, 2, 3, 4, 5], 6) -1 >>> max_sum_of_k_subarray_max_elements([5], 1) 5 >>> max_sum_of_k_subarray_max_elements([5, 5, 5, 5], 2) 10 >>> max_sum_of_k_subarray_max_elements([1, 2, 3, 4], 5) -1","solution":"def max_sum_of_k_subarray_max_elements(nums, k): if k > len(nums): return -1 # Dynamic programming approach n = len(nums) dp = [[float('-inf')] * (k + 1) for _ in range(n + 1)] dp[0][0] = 0 for i in range(1, n + 1): for j in range(1, k + 1): current_max = float('-inf') for m in range(i, 0, -1): current_max = max(current_max, nums[m - 1]) if dp[m - 1][j - 1] != float('-inf'): dp[i][j] = max(dp[i][j], dp[m - 1][j - 1] + current_max) return dp[n][k] if dp[n][k] != float('-inf') else -1"},{"question":"def minimum_moving_cost(archers, cost): Determines the minimum total cost to distribute archers to ensure non-decreasing order of archer counts. :param archers: List[int] - number of archers in each town :param cost: List[int] - cost to move an archer between adjacent towns :return: int - minimum total cost for non-decreasing order of archer counts >>> minimum_moving_cost([5, 3, 6, 4, 8], [2, 3, 1, 4]) 3 >>> minimum_moving_cost([10], []) 0 >>> minimum_moving_cost([2, 3, 5, 6], [1, 2, 3]) 0 >>> minimum_moving_cost([5, 4, 3, 2, 1], [1, 2, 3, 4]) 10 >>> minimum_moving_cost([5, 2, 7, 3, 8], [1, 5, 6, 2]) 7 >>> minimum_moving_cost([4, 1, 5, 2], [0, 0, 0]) 0","solution":"def minimum_moving_cost(archers, cost): Determines the minimum total cost to distribute archers to ensure non-decreasing order of archer counts. :param archers: List[int] - number of archers in each town :param cost: List[int] - cost to move an archer between adjacent towns :return: int - minimum total cost for non-decreasing order of archer counts n = len(archers) if n == 0: return 0 # Minimum cost calculation is based on dynamic programming dp = [float('inf')] * n dp[0] = 0 # No cost to align archers in the first town for i in range(1, n): if archers[i] >= archers[i - 1]: dp[i] = dp[i - 1] if archers[i] < archers[i - 1]: dp[i] = min(dp[i], dp[i - 1] + cost[i - 1]) return dp[-1]"},{"question":"def min_deletions_to_make_valid(s: str) -> int: Given a string \`s\` consisting of the characters 'a', 'b', and 'c', return the minimum number of characters you need to delete to make the string a valid sequence. A valid sequence is defined as a string where no three consecutive characters are the same. >>> min_deletions_to_make_valid(\\"abc\\") == 0 >>> min_deletions_to_make_valid(\\"abca\\") == 0 >>> min_deletions_to_make_valid(\\"aaab\\") == 1 >>> min_deletions_to_make_valid(\\"abcaaa\\") == 1 >>> min_deletions_to_make_valid(\\"aaaaaa\\") == 4 >>> min_deletions_to_make_valid(\\"ababababccc\\") == 1 >>> min_deletions_to_make_valid(\\"\\") == 0 >>> min_deletions_to_make_valid(\\"a\\") == 0 >>> min_deletions_to_make_valid(\\"aa\\") == 0 >>> min_deletions_to_make_valid(\\"abacaba\\") == 0 >>> min_deletions_to_make_valid(\\"aabbcc\\") == 0 >>> min_deletions_to_make_valid(\\"aaaaaaaaaa\\") == 8","solution":"def min_deletions_to_make_valid(s): Returns the minimum number of characters that need to be deleted to make the string a valid sequence. A valid sequence is defined as a string where no three consecutive characters are the same. deletions = 0 n = len(s) # Iterate over the string and check for three consecutive characters. i = 0 while i < n - 2: if s[i] == s[i+1] == s[i+2]: deletions += 1 i += 1 # Skip one character else: i += 1 return deletions"},{"question":"def min_operations_to_equal_height(heights: List[int]) -> int: Returns the minimum number of operations required to make all the plants in the garden have the same height. :param heights: List[int] - heights of the plants :return: int - minimum number of operations >>> min_operations_to_equal_height([5, 5, 5]) == 0 >>> min_operations_to_equal_height([1, 2, 3]) == 3 >>> min_operations_to_equal_height([7]) == 0 >>> min_operations_to_equal_height([4, 4]) == 0 >>> min_operations_to_equal_height([4, 6]) == 2 >>> min_operations_to_equal_height(range(1, 1001)) == sum(range(1, 1000))","solution":"def min_operations_to_equal_height(heights): Returns the minimum number of operations required to make all the plants in the garden have the same height. :param heights: List[int] - heights of the plants :return: int - minimum number of operations max_height = max(heights) operations = 0 for height in heights: operations += max_height - height return operations"},{"question":"def substring_threshold(s: str, queries: List[List[int]]) -> List[bool]: Determine if each substring defined in queries has any character that appears at least 'threshold' times. Parameters: s (str): The input string queries (List[List[int]]): A list of queries, each with [start, end, threshold] Returns: List[bool]: A list of booleans corresponding to each query, indicating if the condition is met. >>> substring_threshold(\\"abcdef\\", [[0, 3, 2], [2, 5, 2]]) [False, False] >>> substring_threshold(\\"aabbcc\\", [[0, 3, 3], [2, 5, 2]]) [False, True] >>> substring_threshold(\\"aaabbbccc\\", [[0, 2, 2], [0, 5, 3], [3, 8, 3]]) [True, True, True] >>> substring_threshold(\\"aaaa\\", [[0, 0, 1], [0, 3, 4]]) [True, True] >>> substring_threshold(\\"aabbccddeeff\\", [[0, 11, 2], [1, 6, 3], [8, 11, 1]]) [True, False, True]","solution":"def substring_threshold(s, queries): Determine if each substring defined in queries has any character that appears at least 'threshold' times. Parameters: s (str): The input string queries (List[List[int]]): A list of queries, each with [start, end, threshold] Returns: List[bool]: A list of booleans corresponding to each query, indicating if the condition is met. result = [] for start, end, threshold in queries: substring = s[start:end+1] # Count the frequency of each character in the substring freq = {} for char in substring: if char in freq: freq[char] += 1 else: freq[char] = 1 # Check if any character exceeds or meets the threshold meets_threshold = any(count >= threshold for count in freq.values()) result.append(meets_threshold) return result"},{"question":"def minRemoveToMakeValid(s: str) -> str: Removes the minimum number of parentheses to make the input string valid. A valid string has balanced parentheses. >>> minRemoveToMakeValid(\\"(a)bc(d)\\") == \\"(a)bc(d)\\" >>> minRemoveToMakeValid(\\"a)b(c)d\\") == \\"ab(c)d\\" >>> minRemoveToMakeValid(\\"a)b((cd)\\") == \\"ab(cd)\\" >>> minRemoveToMakeValid(\\"((a)b(c)d\\") == \\"(a)b(c)d\\" >>> minRemoveToMakeValid(\\"abcdef\\") == \\"abcdef\\" >>> minRemoveToMakeValid(\\")(\\") == \\"\\" >>> minRemoveToMakeValid(\\"\\") == \\"\\"","solution":"def minRemoveToMakeValid(s): Removes the minimum number of parentheses to make the input string valid. A valid string has balanced parentheses. stack = [] valid_chars = list(s) # First pass to remove unmatched closing parentheses for i, char in enumerate(s): if char == '(': stack.append(i) elif char == ')': if stack: stack.pop() else: valid_chars[i] = '' # Second pass to remove any unmatched opening parentheses while stack: valid_chars[stack.pop()] = '' return ''.join(valid_chars)"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def rotateRight(head: ListNode, k: int) -> ListNode: Given a linked list, rotate the list to the right by k places, where k is a non-negative integer. Return the head of the rotated linked list. >>> head = ListNode(1) >>> head.next = ListNode(2) >>> head.next.next = ListNode(3) >>> head.next.next.next = ListNode(4) >>> head.next.next.next.next = ListNode(5) >>> new_head = rotateRight(head, 2) >>> result = [] >>> current = new_head >>> while current: >>> result.append(current.val) >>> current = current.next >>> result [4, 5, 1, 2, 3] >>> head = ListNode(0) >>> head.next = ListNode(1) >>> head.next.next = ListNode(2) >>> new_head = rotateRight(head, 4) >>> result = [] >>> current = new_head >>> while current: >>> result.append(current.val) >>> current = current.next >>> result [2, 0, 1]","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def get_list_length(head): length = 0 current = head while current: length += 1 current = current.next return length def rotateRight(head, k): if not head or k == 0: return head length = get_list_length(head) k %= length if k == 0: return head slow = fast = head for _ in range(k): fast = fast.next while fast.next: slow = slow.next fast = fast.next new_head = slow.next slow.next = None fast.next = head return new_head"},{"question":"def check_subarray_sum(nums: List[int], k: int) -> bool: Determines if there exists a continuous subarray of size at least 2 that sums up to a multiple of k. >>> check_subarray_sum([23, 2, 4, 6, 7], 6) True >>> check_subarray_sum([23, 2, 6, 4, 7], 6) True >>> check_subarray_sum([23, 2, 6, 4, 7], 13) False >>> check_subarray_sum([0, 0], 0) True >>> check_subarray_sum([1, 0], 0) False >>> check_subarray_sum([1, 2, 3], 10000) False >>> check_subarray_sum([1], 2) False >>> check_subarray_sum([0], 1) False","solution":"def check_subarray_sum(nums, k): Determines if there exists a continuous subarray of size at least 2 that sums up to a multiple of k. if k == 0: return any(nums[i] == 0 and nums[i + 1] == 0 for i in range(len(nums) - 1)) remainder_map = {0: -1} cumulative_sum = 0 for i, num in enumerate(nums): cumulative_sum += num remainder = cumulative_sum % k if remainder in remainder_map: if i - remainder_map[remainder] > 1: return True else: remainder_map[remainder] = i return False"},{"question":"def minimum_days_to_complete_tasks(tasks: List[int], d: int) -> int: Returns the minimum number of days needed to complete all tasks. :param tasks: List of integers where tasks[i] represents the hours needed for the i-th task. :param d: Integer representing the number of workers available. :return: Integer representing the minimum number of days needed. >>> minimum_days_to_complete_tasks([], 3) == 0 >>> minimum_days_to_complete_tasks([5], 1) == 1 >>> minimum_days_to_complete_tasks([5], 3) == 1 >>> minimum_days_to_complete_tasks([5, 4, 3], 3) == 1 >>> minimum_days_to_complete_tasks([5, 4, 3, 2, 1], 2) == 3 >>> minimum_days_to_complete_tasks([5, 4], 5) == 1 >>> minimum_days_to_complete_tasks([7, 10, 4, 9, 2, 5], 3) == 2","solution":"def minimum_days_to_complete_tasks(tasks, d): Returns the minimum number of days needed to complete all tasks. :param tasks: List of integers where tasks[i] represents the hours needed for the i-th task. :param d: Integer representing the number of workers available. :return: Integer representing the minimum number of days needed. if not tasks: return 0 # Sorting the tasks in descending order to distribute the heaviest tasks first. tasks.sort(reverse=True) days = 0 while tasks: days += 1 # Each worker takes up one task if available for _ in range(d): if tasks: tasks.pop(0) else: break return days"},{"question":"def max_books(prices, budget): Determines the maximum number of distinct books that can be bought without exceeding the budget. :param prices: List of integers representing the price of each book :param budget: Integer representing the available budget :return: Maximum number of distinct books that can be bought >>> max_books([5, 10, 3, 7], 25) 4 >>> max_books([5, 10, 3, 7], 15) 3 >>> max_books([5, 10, 3, 7], 10) 2 >>> max_books([5, 10, 3, 7], 0) 0 >>> max_books([10], 10) 1 >>> max_books([], 10) 0 >>> max_books([1, 2, 3, 4, 5], 100) 5","solution":"def max_books(prices, budget): Determines the maximum number of distinct books that can be bought without exceeding the budget. :param prices: List of integers representing the price of each book :param budget: Integer representing the available budget :return: Maximum number of distinct books that can be bought # Sort the book prices in ascending order to try to buy cheaper books first prices.sort() count = 0 total_spent = 0 for price in prices: if total_spent + price <= budget: total_spent += price count += 1 else: break return count"},{"question":"from typing import List def findKthLargest(arr: List[int], k: int) -> int: Given an integer array \`arr\` and an integer \`k\`, return the k-th largest element in the array. Note that it is the k-th largest element in the sorted order, not the k-th distinct element. >>> findKthLargest([3,2,1,5,6,4], 2) 5 >>> findKthLargest([3,2,3,1,2,4,5,5,6], 4) 4 >>> findKthLargest([1], 1) 1 >>> findKthLargest([1, 1, 1, 1, 1, 1, 1], 1) 1 >>> findKthLargest([1, 2, 2, 2, 3], 2) 2 >>> findKthLargest([7, 10, 4, 3, 20, 15], 6) 3","solution":"from typing import List def findKthLargest(arr: List[int], k: int) -> int: import heapq # Use a min-heap to keep track of the k largest elements min_heap = arr[:k] heapq.heapify(min_heap) for num in arr[k:]: if num > min_heap[0]: heapq.heappushpop(min_heap, num) return min_heap[0]"},{"question":"def can_rearrange_to_palindrome(s: str) -> bool: Determines if the string \`s\` can be rearranged to form a palindrome. Return true if it is possible to rearrange the characters of \`s\` to form a palindrome or false otherwise. >>> can_rearrange_to_palindrome(\\"aaaa\\") == True >>> can_rearrange_to_palindrome(\\"abccba\\") == True >>> can_rearrange_to_palindrome(\\"aabbcc\\") == True >>> can_rearrange_to_palindrome(\\"aabbc\\") == True >>> can_rearrange_to_palindrome(\\"\\") == True >>> can_rearrange_to_palindrome(\\"z\\") == True >>> can_rearrange_to_palindrome(\\"abcde\\") == False >>> can_rearrange_to_palindrome(\\"abcdcbae\\") == False","solution":"def can_rearrange_to_palindrome(s): Determines if the string \`s\` can be rearranged to form a palindrome from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 == 1) return odd_count <= 1"},{"question":"def wordBreak(s: str, wordDict: List[str]) -> bool: Given a string s and a dictionary of words wordDict, determine if s can be segmented into a sequence of one or more words in the dictionary. >>> wordBreak(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> wordBreak(\\"apple\\", [\\"apple\\"]) True >>> wordBreak(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> wordBreak(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False >>> wordBreak(\\"\\", [\\"cat\\", \\"dog\\"]) True >>> wordBreak(\\"anything\\", []) False >>> wordBreak(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\", \\"an\\", \\"ando\\"]) True","solution":"def wordBreak(s, wordDict): Returns True if s can be segmented into a sequence of one or more words in the wordDict. word_set = set(wordDict) dp = [False] * (len(s) + 1) dp[0] = True # base case: empty string can be segmented for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[len(s)]"},{"question":"def panoramic_view_indices(arr): Returns the list of indices of buildings that have a panoramic view. A building has a panoramic view if there are no taller buildings to its right. >>> panoramic_view_indices([1, 2, 3, 4]) [3] >>> panoramic_view_indices([4, 3, 2, 1]) [0, 1, 2, 3] >>> panoramic_view_indices([4, 2, 3, 1]) [0, 2, 3] >>> panoramic_view_indices([1, 3, 2, 4, 2]) [3, 4] >>> panoramic_view_indices([4]) [0] >>> panoramic_view_indices([4, 2]) [0, 1] >>> panoramic_view_indices([2, 4]) [1]","solution":"def panoramic_view_indices(arr): Returns the list of indices of buildings that have a panoramic view. A building has a panoramic view if there are no taller buildings to its right. n = len(arr) result = [] max_height = float('-inf') for i in range(n-1, -1, -1): if arr[i] > max_height: result.append(i) max_height = arr[i] return result[::-1]"},{"question":"def is_prime(n: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(11) True def reverse_number(n: int) -> int: Reverse the digits of a number. >>> reverse_number(123) 321 >>> reverse_number(400) 4 >>> reverse_number(1001) 1001 def largest_emirp(k: int) -> int: Find the largest emirp number less than or equal to k. >>> largest_emirp(50) 37 >>> largest_emirp(100) 97 >>> largest_emirp(10) -1 >>> largest_emirp(13) 13 >>> largest_emirp(2) -1","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def reverse_number(n): Reverse the digits of a number. return int(str(n)[::-1]) def largest_emirp(k): Find the largest emirp number less than or equal to k. for num in range(k, 1, -1): if is_prime(num) and is_prime(reverse_number(num)) and num != reverse_number(num): # Ensuring it's not a palindrome prime return num return -1"},{"question":"def longest_substring_with_two_distinct(s: str) -> int: Write a function that accepts a string \`s\` consisting of lowercase alphabetic characters and returns the length of the longest substring of \`s\` that contains at most two distinct characters. If the input string is empty, return 0. A substring is defined as a contiguous sequence of characters within the string. >>> longest_substring_with_two_distinct(\\"\\") == 0 >>> longest_substring_with_two_distinct(\\"a\\") == 1 >>> longest_substring_with_two_distinct(\\"aabb\\") == 4 >>> longest_substring_with_two_distinct(\\"ab\\") == 2 >>> longest_substring_with_two_distinct(\\"abcabcabc\\") == 2 >>> longest_substring_with_two_distinct(\\"abaccc\\") == 4 >>> longest_substring_with_two_distinct(\\"eceba\\") == 3 >>> longest_substring_with_two_distinct(\\"ccaabbb\\") == 5","solution":"def longest_substring_with_two_distinct(s): Returns the length of the longest substring with at most two distinct characters. n = len(s) if n == 0: return 0 max_len = 0 left = 0 char_map = {} for right in range(n): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def can_be_split(arr: list) -> bool: Determines if the array can be split into two contiguous subarrays such that the sum of the elements in both subarrays is equal. >>> can_be_split([1, 2, 3, 4, 5, 5]) True >>> can_be_split([1, 2, 3, 4, 6]) False >>> can_be_split([1, 1]) True >>> can_be_split([10, 10, 10, 30]) True >>> can_be_split([1, 1, 1, 1, 1]) False >>> can_be_split([2, 1, 1, 2]) True","solution":"def can_be_split(arr): Determines if the array can be split into two contiguous subarrays such that the sum of the elements in both subarrays is equal. Parameters: arr (list): The input array of integers. Returns: bool: True if the array can be split, False otherwise. total_sum = sum(arr) if total_sum % 2 != 0: return False target_sum = total_sum // 2 current_sum = 0 for i in range(len(arr) - 1): current_sum += arr[i] if current_sum == target_sum: return True return False"},{"question":"from typing import List def min_conversion_cost(s: str, t: str, cost: List[List[int]]) -> int: Calculate the minimum cost to convert string \`s\` into string \`t\` given a cost matrix for character transformations. If conversion is not possible, return -1. >>> min_conversion_cost(\\"abc\\", \\"abc\\", [[0 for _ in range(26)] for _ in range(26)]) == 0 >>> min_conversion_cost(\\"abc\\", \\"bcd\\", [[0 for _ in range(26)] for _ in range(26)]) == 3 >>> min_conversion_cost(\\"abc\\", \\"abcd\\", [[0 for _ in range(26)] for _ in range(26)]) == -1 >>> min_conversion_cost(\\"aaab\\", \\"bbba\\", [[2 if i != j else 0 for j in range(26)] for i in range(26)]) == 8 >>> min_conversion_cost(\\"xyz\\", \\"xyz\\", [[0 for _ in range(26)] for _ in range(26)]) == 0 >>> min_conversion_cost(\\"a\\", \\"z\\", [[100 for _ in range(26)] for _ in range(26)]) == 100","solution":"def min_conversion_cost(s, t, cost): if len(s) != len(t): return -1 total_cost = 0 for ch_s, ch_t in zip(s, t): if ch_s != ch_t: index_s = ord(ch_s) - ord('a') index_t = ord(ch_t) - ord('a') total_cost += cost[index_s][index_t] return total_cost"},{"question":"def find_peak(grid): Finds any peak in the 2D matrix grid. A peak is a cell that is greater than or equal to its 4 possible neighbors: left, right, top, bottom. :param grid: 2D list of integers :return: List of the coordinates [i, j] of any peak found pass # Unit Tests def test_single_peak(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] peak = find_peak(grid) assert peak == [2, 2] # (7 is the peak here) def test_multiple_peaks(): grid = [ [10, 8, 9], [5, 15, 6], [6, 7, 20] ] peak = find_peak(grid) assert peak in [[0, 0], [1, 1], [2, 2]] # Any of these is a valid peak def test_border_peak(): grid = [ [10, 2, 3], [4, 5, 6], [7, 8, 1] ] peak = find_peak(grid) assert peak in [[0, 0], [2, 1]] # (10 or 8 can be peaks) def test_all_equal(): grid = [ [5, 5, 5], [5, 5, 5], [5, 5, 5] ] peak = find_peak(grid) assert peak in [[i, j] for i in range(3) for j in range(3)] # Any cell is a peak def test_single_element(): grid = [ [42] ] peak = find_peak(grid) assert peak == [0, 0] def test_no_peak(): grid = [ [4, 3, 2], [3, 0, 1], [4, 2, 3] ] peak = find_peak(grid) assert peak in [[0, 0], [2, 0], [2, 2]] # Any cell meeting the criteria def test_negative_numbers(): grid = [ [-3, -2, -1], [-2, -5, -6], [-1, -2, -3] ] peak = find_peak(grid) assert peak == [0, 2] # -1 is the peak in this grid","solution":"def find_peak(grid): Finds any peak in the 2D matrix grid. A peak is a cell that is greater than or equal to its 4 possible neighbors: left, right, top, bottom. :param grid: 2D list of integers :return: List of the coordinates [i, j] of any peak found m, n = len(grid), len(grid[0]) def is_peak(i, j): val = grid[i][j] if i > 0 and val < grid[i - 1][j]: return False if i < m - 1 and val < grid[i + 1][j]: return False if j > 0 and val < grid[i][j - 1]: return False if j < n - 1 and val < grid[i][j + 1]: return False return True for i in range(m): for j in range(n): if is_peak(i, j): return [i, j] return None"},{"question":"def characterReplacement(s: str, k: int) -> int: Returns the length of the longest substring with all repeating characters after performing at most k replacements. >>> characterReplacement(\\"ABAB\\", 2) 4 >>> characterReplacement(\\"AABABBA\\", 1) 4 >>> characterReplacement(\\"AAAAA\\", 2) 5 >>> characterReplacement(\\"ABBBBA\\", 0) 4 >>> characterReplacement(\\"\\", 2) 0 >>> characterReplacement(\\"ABCDEFGH\\", 0) 1","solution":"def characterReplacement(s, k): Returns the length of the longest substring with all repeating characters after performing at most k replacements. max_len = 0 left = 0 max_count = 0 char_count = {} for right in range(len(s)): char_count[s[right]] = char_count.get(s[right], 0) + 1 max_count = max(max_count, char_count[s[right]]) if (right - left + 1) - max_count > k: char_count[s[left]] -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def numDistinctPatches(grid): Returns the number of distinct land patches in the grid. >>> numDistinctPatches([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) == 0 >>> numDistinctPatches([ [0, 1, 0], [0, 1, 0], [0, 0, 0] ]) == 1 >>> numDistinctPatches([ [1, 0, 0], [0, 1, 0], [0, 0, 1] ]) == 3 >>> numDistinctPatches([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) == 1 >>> numDistinctPatches([ [1, 0, 1], [0, 1, 0], [1, 0, 1] ]) == 5 >>> numDistinctPatches([]) == 0","solution":"def numDistinctPatches(grid): Returns the number of distinct land patches in the grid. if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False]*n for _ in range(m)] def dfs(i, j): if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] == 0 or visited[i][j]: return visited[i][j] = True dfs(i+1, j) dfs(i-1, j) dfs(i, j+1) dfs(i, j-1) land_patches = 0 for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: dfs(i, j) land_patches += 1 return land_patches"},{"question":"def shift_characters(s: str, k: int) -> str: Shifts each character in the string 's' to the right by 'k' positions. Characters wrap around within their respective groups (letters and digits). >>> shift_characters(\\"abc\\", 1) \\"bcd\\" >>> shift_characters(\\"xyz\\", 3) \\"abc\\" >>> shift_characters(\\"hello\\", 4) \\"lipps\\" >>> shift_characters(\\"abcd\\", 0) \\"abcd\\" >>> shift_characters(\\"123\\", 1) \\"234\\" >>> shift_characters(\\"789\\", 3) \\"012\\" >>> shift_characters(\\"987\\", 5) \\"432\\" >>> shift_characters(\\"012\\", 10) \\"012\\" >>> shift_characters(\\"a1b2c3\\", 1) \\"b2c3d4\\" >>> shift_characters(\\"x8y9z0\\", 3) \\"a1b2c3\\" >>> shift_characters(\\"x0y1z2\\", 2) \\"z2a3b4\\" >>> shift_characters(\\"m3n4o5\\", 13) \\"z6a7b8\\" >>> shift_characters(\\"aaaa\\", 0) \\"aaaa\\" >>> shift_characters(\\"9999\\", 10) \\"9999\\" >>> shift_characters(\\"hello123\\", 0) \\"hello123\\" pass","solution":"def shift_characters(s, k): Shifts each character in the string 's' to the right by 'k' positions. Characters wrap around within their respective groups (letters and digits). result = [] for char in s: if char.isalpha(): if char.islower(): result.append(chr((ord(char) - ord('a') + k) % 26 + ord('a'))) elif char.isdigit(): result.append(chr((ord(char) - ord('0') + k) % 10 + ord('0'))) return ''.join(result)"},{"question":"def longest_subarray_to_sort(arr: List[int]) -> int: Given an array of integers \`arr\`, find the length of the longest subarray which when sorting the subarray results in the entire array being sorted in non-decreasing order. Return the length of this subarray. >>> longest_subarray_to_sort([1, 3, 5, 4, 2, 6, 7]) == 4 >>> longest_subarray_to_sort([1, 2, 3, 4, 5, 6]) == 6 >>> longest_subarray_to_sort([4, 3, 2, 1, 5, 6, 7]) == 4 >>> longest_subarray_to_sort([1, 2, 3, 4, 6, 5, 0]) == 7 >>> longest_subarray_to_sort([3, 2, 1]) == 3 >>> longest_subarray_to_sort([1]) == 1 >>> longest_subarray_to_sort([1, 2]) == 2 >>> longest_subarray_to_sort([2, 1]) == 2 >>> longest_subarray_to_sort([2, 2, 2, 2, 2]) == 5 pass","solution":"def longest_subarray_to_sort(arr): n = len(arr) if n <= 1: return n start, end = -1, -1 for i in range(n - 1): if arr[i] > arr[i + 1]: start = i break if start == -1: return n for i in range(n - 1, 0, -1): if arr[i] < arr[i - 1]: end = i break subarray_min = float('inf') subarray_max = float('-inf') for i in range(start, end + 1): subarray_min = min(subarray_min, arr[i]) subarray_max = max(subarray_max, arr[i]) while start > 0 and arr[start - 1] > subarray_min: start -= 1 while end < n - 1 and arr[end + 1] < subarray_max: end += 1 return end - start + 1"},{"question":"def count_increasing_heights(heights): Returns the number of students standing in positions where the student's height is greater than all previous students' heights in the line. Parameters: heights (list): A list of unique integers representing the heights of students. Returns: int: The count of students taller than all previous students in the line. >>> count_increasing_heights([]) == 0 >>> count_increasing_heights([150]) == 1 >>> count_increasing_heights([140, 150, 160, 170]) == 4 >>> count_increasing_heights([170, 160, 150, 140]) == 1 >>> count_increasing_heights([150, 140, 160, 155, 165]) == 3 >>> count_increasing_heights([150, 160, 155, 170, 165, 180]) == 4 >>> count_increasing_heights([153, 151, 156, 158, 157, 160, 159, 161]) == 5","solution":"def count_increasing_heights(heights): Returns the number of students standing in positions where the student's height is greater than all previous students' heights in the line. Parameters: heights (list): A list of unique integers representing the heights of students. Returns: int: The count of students taller than all previous students in the line. count = 0 max_height_so_far = float('-inf') for height in heights: if height > max_height_so_far: count += 1 max_height_so_far = height return count"},{"question":"from typing import List def minimum_weight_path(grid: List[List[int]], k: int) -> int: Return the minimum possible weight of any path in the grid with a weight of at most \`k\`. If no such path exists, return -1. >>> minimum_weight_path([ [1, 2, 3], [4, 5, 1], [1, 2, 3] ], 5) 3 >>> minimum_weight_path([ [5, 4], [1, 2] ], 4) -1 >>> minimum_weight_path([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ], 1) 1 >>> minimum_weight_path([ [2, 2, 1], [2, 2, 1], [1, 1, 1] ], 2) 2 >>> minimum_weight_path([ [1] ], 1) 1 >>> minimum_weight_path([ [1, 2, 2, 2], [2, 1, 2, 2], [2, 2, 1, 2], [2, 2, 2, 1] ], 2) 2 pass","solution":"from heapq import heappop, heappush from typing import List def minimum_weight_path(grid: List[List[int]], k: int) -> int: n, m = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_within_bounds(x, y): return 0 <= x < n and 0 <= y < m def dijkstra(): heap = [(grid[0][0], 0, 0)] dist = [[float('inf')] * m for _ in range(n)] dist[0][0] = grid[0][0] while heap: weight, x, y = heappop(heap) if weight > k: continue if x == n - 1 and y == m - 1: return weight for dx, dy in directions: nx, ny = x + dx, y + dy if is_within_bounds(nx, ny): new_weight = max(weight, grid[nx][ny]) if new_weight < dist[nx][ny]: dist[nx][ny] = new_weight heappush(heap, (new_weight, nx, ny)) return -1 return dijkstra()"},{"question":"def count_repeated_substrings(s: str, k: int) -> int: Returns the number of distinct substrings of length k that occur more than once in s. >>> count_repeated_substrings(\\"abcdef\\", 2) 0 >>> count_repeated_substrings(\\"abcd\\", 1) 0 >>> count_repeated_substrings(\\"ababab\\", 2) 2 >>> count_repeated_substrings(\\"aaaa\\", 2) 1 >>> count_repeated_substrings(\\"abc\\", 4) 0 >>> count_repeated_substrings(\\"aaaa\\", 4) 0 >>> count_repeated_substrings(\\"ababa\\", 2) 2 >>> count_repeated_substrings(\\"aaa\\", 1) 1","solution":"def count_repeated_substrings(s, k): Returns the number of distinct substrings of length k that occur more than once in s. from collections import defaultdict if k > len(s): return 0 substring_count = defaultdict(int) # Traverse through the string to count all substrings of length k for i in range(len(s) - k + 1): substring = s[i:i + k] substring_count[substring] += 1 # Count substrings that appear more than once repeated_substrings_count = sum(1 for count in substring_count.values() if count > 1) return repeated_substrings_count"},{"question":"def longest_substring_with_one_replacement(s: str) -> int: Returns the length of the longest possible substring that can be achieved by replacing at most one character in \`s\`. >>> longest_substring_with_one_replacement(\\"a\\") == 1 >>> longest_substring_with_one_replacement(\\"aaaa\\") == 4 >>> longest_substring_with_one_replacement(\\"aabaa\\") == 5 >>> longest_substring_with_one_replacement(\\"ababa\\") == 3 >>> longest_substring_with_one_replacement(\\"abcabcabc\\") == 2","solution":"def longest_substring_with_one_replacement(s: str) -> int: Returns the length of the longest possible substring that can be achieved by replacing at most one character in \`s\`. n = len(s) max_len = 0 for char in set(s): left, count = 0, 0 for right in range(n): if s[right] != char: count += 1 while count > 1: if s[left] != char: count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def rotateImage(matrix: List[List[int]]) -> None: Rotates the image represented by the 2D matrix by 90 degrees clockwise in-place. >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> rotateImage(matrix) >>> print(matrix) [ [3, 1], [4, 2] ] >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotateImage(matrix) >>> print(matrix) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ ... [ 5, 1, 9, 11], ... [ 2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotateImage(matrix) >>> print(matrix) [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] >>> matrix = [ ... [1] ... ] >>> rotateImage(matrix) >>> print(matrix) [ [1] ]","solution":"def rotateImage(matrix): Rotates the image represented by the 2D matrix by 90 degrees clockwise in-place. n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def sort_words_by_length(sentence: str) -> List[str]: Given a string \`sentence\` that consists of words separated by spaces, return the words in \`sentence\` sorted in reverse order of their lengths. If two words have the same length, they should appear in the same order as they do in the original sentence. >>> sort_words_by_length(\\"The quick brown fox jumps over the lazy dog\\") [\\"quick\\", \\"brown\\", \\"jumps\\", \\"over\\", \\"lazy\\", \\"The\\", \\"fox\\", \\"the\\", \\"dog\\"] >>> sort_words_by_length(\\"\\") [] >>> sort_words_by_length(\\"word\\") [\\"word\\"] >>> sort_words_by_length(\\"cat dog bat\\") [\\"cat\\", \\"dog\\", \\"bat\\"] >>> sort_words_by_length(\\"sort these words correctly\\") [\\"correctly\\", \\"these\\", \\"words\\", \\"sort\\"]","solution":"def sort_words_by_length(sentence): Returns the words in the sentence sorted in reverse order of their lengths. Parameters: sentence (str): A string consisting of words separated by spaces. Returns: list: A list of words sorted in reverse order of their lengths. words = sentence.split() words.sort(key=len, reverse=True) return words"},{"question":"def can_form_palindrome(strings: List[str]) -> bool: Determines if you can form a palindrome by concatenating some (or all) of the given strings in any order. Args: strings (list of str): List of strings containing only lowercase alphabetic characters. Returns: bool: True if a palindrome can be formed, False otherwise. Examples: >>> can_form_palindrome([\\"a\\", \\"b\\", \\"c\\", \\"c\\", \\"b\\", \\"a\\"]) True >>> can_form_palindrome([\\"abc\\", \\"cba\\"]) True >>> can_form_palindrome([\\"a\\", \\"b\\", \\"c\\"]) False >>> can_form_palindrome([]) True >>> can_form_palindrome([\\"radar\\"]) True >>> can_form_palindrome([\\"hello\\"]) False >>> can_form_palindrome([\\"aaa\\", \\"aaa\\"]) True >>> can_form_palindrome([\\"aa\\", \\"bb\\", \\"cc\\", \\"dd\\"]) True >>> can_form_palindrome([\\"aa\\", \\"bb\\", \\"cc\\", \\"de\\"]) False","solution":"from collections import Counter def can_form_palindrome(strings): Determines if you can form a palindrome by concatenating some (or all) of the given strings in any order. Args: strings (list of str): List of strings containing only lowercase alphabetic characters. Returns: bool: True if a palindrome can be formed, False otherwise. # Counter to count all characters in all strings char_count = Counter() for s in strings: char_count.update(s) # Count how many characters have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # We can form a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: Finds the lowest common ancestor (LCA) of two given nodes in a binary search tree (BST). def test_lowestCommonAncestor(): # Create BST for testing root = TreeNode(6) root.left = TreeNode(2) root.right = TreeNode(8) root.left.left = TreeNode(0) root.left.right = TreeNode(4) root.left.right.left = TreeNode(3) root.left.right.right = TreeNode(5) root.right.left = TreeNode(7) root.right.right = TreeNode(9) p = root.left # Node with value 2 q = root.left.right # Node with value 4 # Test case 1: LCA of nodes with values 2 and 4 is 2 assert lowestCommonAncestor(root, p, q).val == 2 p = root.left # Node with value 2 q = root.right # Node with value 8 # Test case 2: LCA of nodes with values 2 and 8 is 6 assert lowestCommonAncestor(root, p, q).val == 6 p = root.left.left # Node with value 0 q = root.left.right.right # Node with value 5 # Test case 3: LCA of nodes with values 0 and 5 is 2 assert lowestCommonAncestor(root, p, q).val == 2 p = root.right.left # Node with value 7 q = root.right.right # Node with value 9 # Test case 4: LCA of nodes with values 7 and 9 is 8 assert lowestCommonAncestor(root, p, q).val == 8","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lowestCommonAncestor(root, p, q): Finds the LCA of two nodes p and q in a BST. current = root while current: # If both p and q are smaller than current, LCA lies in left if p.val < current.val and q.val < current.val: current = current.left # If both p and q are greater than current, LCA lies in right elif p.val > current.val and q.val > current.val: current = current.right else: # We have found the split point, i.e., the LCA node. return current"},{"question":"def findMinDifference(timePoints: List[str]) -> int: Returns the minimum difference in minutes between any two time points in the array. >>> findMinDifference([\\"23:59\\", \\"00:00\\"]) 1 >>> findMinDifference([\\"01:10\\", \\"03:25\\", \\"18:45\\", \\"02:50\\"]) 35 >>> findMinDifference([\\"12:01\\", \\"12:02\\", \\"12:03\\", \\"12:04\\"]) 1 >>> findMinDifference([\\"00:00\\", \\"12:00\\"]) 720 >>> findMinDifference([\\"00:00\\", \\"23:59\\", \\"00:00\\"]) 0 >>> findMinDifference([\\"23:59\\", \\"00:01\\", \\"23:58\\"]) 1","solution":"def findMinDifference(timePoints): Returns the minimum difference in minutes between any two time points in the array. Parameters: timePoints (List[str]): a list of time points in \\"HH:MM\\" format on a 24-hour clock. Returns: int: the minimum difference in minutes between any two time points. # Convert time points to minutes minutes = [] for time in timePoints: h, m = map(int, time.split(':')) total_minutes = h * 60 + m minutes.append(total_minutes) # Sort the list of minutes minutes.sort() # Initialize min_diff to a large value min_diff = float('inf') # Calculate the differences and keep track of the minimum difference for i in range(len(minutes) - 1): diff = minutes[i + 1] - minutes[i] min_diff = min(min_diff, diff) # Also consider the difference between the first and last time points across midnight min_diff = min(min_diff, (1440 - minutes[-1] + minutes[0])) return min_diff"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1: ListNode, l2: ListNode) -> ListNode: Merges two sorted linked lists \`l1\` and \`l2\` into one sorted linked list and returns the head of the new list. >>> l1 = list_to_linked([1, 2, 4]) >>> l2 = list_to_linked([1, 3, 4]) >>> linked_to_list(mergeTwoLists(l1, l2)) [1, 1, 2, 3, 4, 4] >>> l1 = list_to_linked([]) >>> l2 = list_to_linked([1, 3, 4]) >>> linked_to_list(mergeTwoLists(l1, l2)) [1, 3, 4] >>> l1 = list_to_linked([1, 2, 4]) >>> l2 = list_to_linked([]) >>> linked_to_list(mergeTwoLists(l1, l2)) [1, 2, 4] >>> l1 = list_to_linked([]) >>> l2 = list_to_linked([]) >>> linked_to_list(mergeTwoLists(l1, l2)) [] >>> l1 = list_to_linked([2, 4, 6, 8]) >>> l2 = list_to_linked([2, 4, 6, 8]) >>> linked_to_list(mergeTwoLists(l1, l2)) [2, 2, 4, 4, 6, 6, 8, 8] >>> l1 = list_to_linked([1, 3, 5]) >>> l2 = list_to_linked([2, 4, 6]) >>> linked_to_list(mergeTwoLists(l1, l2)) [1, 2, 3, 4, 5, 6]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1, l2): dummy = ListNode() current = dummy while l1 and l2: if l1.val <= l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next current.next = l1 if l1 else l2 return dummy.next"},{"question":"def min_operations_to_avoid_adjacent(s: str) -> int: Returns the minimum number of operations required so that no two adjacent characters in the string s are the same. Parameters: s (str): The input string containing only characters 'a', 'b', and 'c'. Returns: int: The minimum number of operations required. >>> min_operations_to_avoid_adjacent(\\"\\") == 0 >>> min_operations_to_avoid_adjacent(\\"a\\") == 0 >>> min_operations_to_avoid_adjacent(\\"aa\\") == 1 >>> min_operations_to_avoid_adjacent(\\"abc\\") == 0 >>> min_operations_to_avoid_adjacent(\\"aaaabbbbcccc\\") == 6","solution":"def min_operations_to_avoid_adjacent(s): Returns the minimum number of operations required so that no two adjacent characters in the string s are the same. Parameters: s (str): The input string containing only characters 'a', 'b', and 'c'. Returns: int: The minimum number of operations required. if len(s) < 2: return 0 operations = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: operations += 1 # Change the current character to one that is not the same as the previous or the next character (if possible) if s[i - 1] != 'a' and (i + 1 >= len(s) or s[i + 1] != 'a'): s = s[:i] + 'a' + s[i+1:] elif s[i - 1] != 'b' and (i + 1 >= len(s) or s[i + 1] != 'b'): s = s[:i] + 'b' + s[i+1:] else: s = s[:i] + 'c' + s[i+1:] return operations"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bstToGst(root): Given a BST, modify the BST such that each node's value is replaced with the sum of all values greater than or equal to the node's value in the original tree. # Your code here # Unit tests def tree_to_list(root): Helper function to convert the tree into a list using in-order traversal. if not root: return [] return tree_to_list(root.left) + [root.val] + tree_to_list(root.right) def test_bstToGst_single_node(): root = TreeNode(5) bstToGst(root) assert root.val == 5 def test_bstToGst_two_nodes(): root = TreeNode(2) root.right = TreeNode(5) bstToGst(root) assert root.val == 7 # 2 + 5 assert root.right.val == 5 def test_bstToGst_full_tree(): root = TreeNode(4) root.left = TreeNode(1) root.right = TreeNode(6) root.left.left = TreeNode(0) root.left.right = TreeNode(2, None, TreeNode(3)) root.right.left = TreeNode(5) root.right.right = TreeNode(7, None, TreeNode(8)) bstToGst(root) assert tree_to_list(root) == [36, 36, 35, 33, 30, 26, 21, 15, 8] def test_bstToGst_empty_tree(): root = None assert bstToGst(root) == None","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bstToGst(root): Given a BST, modify the BST such that each node's value is replaced with the sum of all values greater than or equal to the node's value in the original tree. def reverse_inorder_traversal(node, accumulated_sum): if node is None: return accumulated_sum # Traverse the right subtree first because it has greater values accumulated_sum = reverse_inorder_traversal(node.right, accumulated_sum) # Add the current node's value to accumulated_sum accumulated_sum += node.val # Update the current node's value node.val = accumulated_sum # Traverse the left subtree accumulated_sum = reverse_inorder_traversal(node.left, accumulated_sum) return accumulated_sum reverse_inorder_traversal(root, 0) return root"},{"question":"from typing import List def findPeakElement(nums: List[int]) -> int: Finds the index of a peak element in the array. A peak element is an element that is strictly greater than its neighbors. >>> findPeakElement([1, 2, 3, 1]) 2 >>> findPeakElement([1, 2, 1, 3, 5, 6, 4]) in [1, 5] True >>> findPeakElement([1, 2, 2, 1]) 1 >>> findPeakElement([1, 1, 1, 1]) in [0, 1, 2, 3] True >>> findPeakElement([4, 3, 2, 1]) 0 >>> findPeakElement([1, 2, 3, 4]) 3 >>> findPeakElement([1]) 0 >>> findPeakElement([1, 2]) 1 # Implementation here","solution":"def findPeakElement(nums): Finds the index of a peak element in the array. A peak element is an element that is strictly greater than its neighbors. :param nums: List[int] - the input array of integers :return: int - the index of any peak element left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] < nums[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"def rotate_string(s: str, n: int) -> str: Rotate the string 's' to the left by 'n' positions. Parameters: s (str): The string to rotate. n (int): The number of positions to rotate the string to the left. Returns: str: The rotated string. Examples: >>> rotate_string(\\"abcdefg\\", 2) 'cdefgab' >>> rotate_string(\\"abcdefg\\", 0) 'abcdefg' >>> rotate_string(\\"abcdefg\\", 7) 'abcdefg' >>> rotate_string(\\"abcdefg\\", 9) 'cdefgab' # 9 % 7 == 2 >>> rotate_string(\\"\\", 3) '' >>> rotate_string(\\"a\\", 5) 'a' >>> rotate_string(\\"hello\\", 5) 'hello' >>> rotate_string(\\"hello\\", 10) 'hello'","solution":"def rotate_string(s, n): Rotate the string 's' to the left by 'n' positions. Parameters: s (str): The string to rotate. n (int): The number of positions to rotate the string to the left. Returns: str: The rotated string. if not s: return s n = n % len(s) # In case n is larger than the length of s. return s[n:] + s[:n]"},{"question":"def lexicographically_smallest_string(s: str) -> str: Returns the lexicographically smallest string that can be formed from the string s by moving characters to the start. >>> lexicographically_smallest_string(\\"cbad\\") \\"abcd\\" >>> lexicographically_smallest_string(\\"dbca\\") \\"abcd\\" >>> lexicographically_smallest_string(\\"aedcb\\") \\"abcde\\" >>> lexicographically_smallest_string(\\"zxywv\\") \\"vwxyz\\" >>> lexicographically_smallest_string(\\"aaaaa\\") \\"aaaaa\\" >>> lexicographically_smallest_string(\\"gfe\\") \\"efg\\" >>> lexicographically_smallest_string(\\"a\\") \\"a\\" >>> lexicographically_smallest_string(\\"\\") \\"\\"","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be formed from the string s by moving characters to the start. return ''.join(sorted(s))"},{"question":"def max_trapped_water(arr: List[int]) -> int: Calculate the maximum volume of water that can be trapped between the buildings. Parameters: arr (list of int): List of heights of buildings. Returns: int: Maximum volume of water that can be trapped. >>> max_trapped_water([0,1,0]) == 0 >>> max_trapped_water([4, 2, 0, 3, 2, 5]) == 9 >>> max_trapped_water([1, 2, 3, 4, 5]) == 0 >>> max_trapped_water([5, 4, 3, 2, 1]) == 0 >>> max_trapped_water([2, 2, 2]) == 0 >>> max_trapped_water([1, 0, 2]) == 1 >>> max_trapped_water([2,0,2,0,2]) == 4 >>> max_trapped_water([]) == 0 >>> max_trapped_water([5]) == 0 >>> max_trapped_water([1, 1, 1, 1]) == 0","solution":"def max_trapped_water(arr): Calculate the maximum volume of water that can be trapped between the buildings. Parameters: arr (list of int): List of heights of buildings. Returns: int: Maximum volume of water that can be trapped. if not arr: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i-1], arr[i]) # Fill right_max array right_max[n-1] = arr[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], arr[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - arr[i] return trapped_water"},{"question":"def max_moves(nums: List[int]) -> int: Given a list of integers representing positions of stones on a number line, returns the maximum number of moves required to make all stone positions empty. Parameters: - nums (list of int): The positions of the stones. Returns: - int: The maximum number of moves to make all stone positions empty. Examples: >>> max_moves([1, 1, 1, 1, 1]) 2 >>> max_moves([1, 1, 2, 2, 2, 3, 3, 3, 3]) 4 >>> max_moves([1, 2, 3, 4, 5]) 0 >>> max_moves([1, 1, 2, 2, 3, 3, 4, 4, 5, 5]) 5 >>> max_moves([]) 0 >>> max_moves([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) 8 >>> max_moves([1, 2, 2, 3, 3, 3, 3]) 3","solution":"def max_moves(nums): Given a list of integers representing positions of stones on a number line, returns the maximum number of moves required to make all stone positions empty. Parameters: - nums (list of int): The positions of the stones. Returns: - int: The maximum number of moves to make all stone positions empty. from collections import Counter # Count the frequency of each position position_count = Counter(nums) # For each position, the maximum number of moves we can make is half the count # since each move removes two stones. max_moves = 0 for count in position_count.values(): max_moves += count // 2 return max_moves"},{"question":"def knapsack_max_weight(weights, m): Computes the maximum weight that can be achieved without exceeding the capacity of the knapsack. Parameters: weights (list): List of positive weights. m (int): Maximum capacity of the knapsack. Returns: int: Maximum weight that can be achieved without exceeding the capacity. Examples: >>> knapsack_max_weight([1, 3, 4, 5], 7) 7 >>> knapsack_max_weight([1, 3, 4, 5], 10) 10 >>> knapsack_max_weight([1, 3, 4, 5], 6) 6 >>> knapsack_max_weight([2, 2, 4, 6], 8) 8 >>> knapsack_max_weight([5, 7, 12, 3], 10) 10 >>> knapsack_max_weight([], 5) 0 >>> knapsack_max_weight([1, 2, 3], 0) 0 >>> knapsack_max_weight([1, 3, 6, 9], 2) 1","solution":"def knapsack_max_weight(weights, m): Computes the maximum weight that can be achieved without exceeding the capacity of the knapsack. Parameters: weights (list): List of positive weights. m (int): Maximum capacity of the knapsack. Returns: int: Maximum weight that can be achieved without exceeding the capacity. n = len(weights) dp = [0] * (m + 1) for weight in weights: for j in range(m, weight - 1, -1): dp[j] = max(dp[j], dp[j - weight] + weight) return dp[m]"},{"question":"def trap_rain_water(height: List[int]) -> int: Calculate the total units of water that can be trapped between poles. Parameters: height (list): List of integers representing the height of poles. Returns: int: Total units of trapped water. >>> trap_rain_water([]) 0 >>> trap_rain_water([1]) 0 >>> trap_rain_water([1, 2]) 0 >>> trap_rain_water([1, 1, 1, 1]) 0 >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rain_water([1, 2, 3, 4, 5]) 0 >>> trap_rain_water([5, 4, 3, 2, 1]) 0 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) 9","solution":"def trap_rain_water(height): Calculate the total units of water that can be trapped between poles. Parameters: height (list): List of integers representing the height of poles. Returns: int: Total units of trapped water. if not height or len(height) < 3: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate total water trapped water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def remove_to_length_k(s: str, k: int) -> str: Removes the lexicographically largest characters from the string \`s\` until its length is less than or equal to \`k\`. Parameters: s (str): The input string consisting of only lowercase English letters. k (int): The target length for the string \`s\`. Returns: str: The modified string with length less than or equal to \`k\`. >>> remove_to_length_k(\\"abcde\\", 3) 'abc' >>> remove_to_length_k(\\"bbbbaaaa\\", 3) 'aaa'","solution":"def remove_to_length_k(s, k): Removes the lexicographically largest characters from the string \`s\` until its length is less than or equal to \`k\`. Parameters: s (str): The input string consisting of only lowercase English letters. k (int): The target length for the string \`s\`. Returns: str: The modified string with length less than or equal to \`k\`. s = list(s) while len(s) > k: max_char = max(s) s.remove(max_char) return ''.join(s)"},{"question":"def final_lent_books(operations): Determine the final state of the library by returning a list of IDs of books that are currently lent out. >>> final_lent_books([1, 2, 3, -2, 4, -1]) [3, 4] >>> final_lent_books([1, -1, 2, 3, -2, -3]) [] >>> final_lent_books([1, 2, 2, 3, -3, 4, -1]) [2, 4] >>> final_lent_books([5, 6, 7, -8, 9]) [5, 6, 7, 9] >>> final_lent_books([]) [] >>> final_lent_books([-1, -2, -3]) []","solution":"def final_lent_books(operations): lent_books = {} result = [] for operation in operations: book_id = abs(operation) if operation > 0: if book_id not in lent_books: lent_books[book_id] = True result.append(book_id) elif operation < 0: if book_id in lent_books: lent_books.pop(book_id) result.remove(book_id) return result"},{"question":"def min_minutes_to_cut_trees(arr: List[int], k: int) -> int: Returns the minimum number of minutes required for the workers to cut down all the trees in the forest. :param arr: List[int], list of tree heights. :param k: int, number of workers assigned to cut the trees. :return: int, minimum number of minutes required. >>> min_minutes_to_cut_trees([], 5) 0 >>> min_minutes_to_cut_trees([10], 5) 1 >>> min_minutes_to_cut_trees([10], 1) 1 >>> min_minutes_to_cut_trees([10, 20, 30], 3) 1 >>> min_minutes_to_cut_trees([10, 20, 30, 40, 50], 3) 2 >>> min_minutes_to_cut_trees([10, 20], 5) 1 >>> min_minutes_to_cut_trees([10, 20, 30], 1) 3","solution":"def min_minutes_to_cut_trees(arr, k): Returns the minimum number of minutes required for the workers to cut down all the trees in the forest. :param arr: List[int], list of tree heights. :param k: int, number of workers assigned to cut the trees. :return: int, minimum number of minutes required. num_trees = len(arr) # If there are no trees, no time is required. if num_trees == 0: return 0 # The minimum number of minutes is the number of trees divided by the number of workers, # rounded up to account for any remaining trees. return (num_trees + k - 1) // k"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(root: TreeNode) -> bool: Returns whether the binary tree is symmetric. >>> is_symmetric(TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3)))) == True >>> is_symmetric(TreeNode(1, TreeNode(2, None, TreeNode(3)), TreeNode(2, None, TreeNode(3)))) == False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(root): Returns whether the binary tree is symmetric. if not root: return True def is_mirror(left, right): if not left and not right: return True if not left or not right: return False return (left.val == right.val) and is_mirror(left.right, right.left) and is_mirror(left.left, right.right) return is_mirror(root.left, root.right)"},{"question":"def can_be_non_decreasing(arr: List[int]) -> bool: Determine whether the array can be made non-decreasing with at most one replacement. Parameters: arr (List[int]): List of integers which may include positive, negative, or zero values. Returns: bool: True if the array can be made non-decreasing with at most one replacement, False otherwise.","solution":"def can_be_non_decreasing(arr): Determine whether the array can be made non-decreasing with at most one replacement. Parameters: arr (List[int]): List of integers which may include positive, negative, or zero values. Returns: bool: True if the array can be made non-decreasing with at most one replacement, False otherwise. n = len(arr) if n <= 1: return True count = 0 for i in range(1, n): if arr[i] < arr[i - 1]: count += 1 if count > 1: return False if i > 1 and arr[i] < arr[i - 2]: arr[i] = arr[i - 1] return True"},{"question":"from typing import List def findBuildingsWithOceanView(heights: List[int]) -> List[int]: Find out which buildings have an ocean view. A building has an ocean view if all buildings to its right are shorter. Parameters: heights (list of int): Heights of the buildings. Returns: list of int: Indices of buildings with ocean view in ascending order. >>> findBuildingsWithOceanView([5]) [0] >>> findBuildingsWithOceanView([1, 2, 3, 4]) [3] >>> findBuildingsWithOceanView([4, 3, 2, 1]) [0, 1, 2, 3] >>> findBuildingsWithOceanView([4, 2, 3, 1]) [0, 2, 3] >>> findBuildingsWithOceanView([2, 2, 2, 2]) [3] >>> findBuildingsWithOceanView([4, 1, 2, 3]) [0, 3]","solution":"def findBuildingsWithOceanView(heights): Find out which buildings have an ocean view. A building has an ocean view if all buildings to its right are shorter. Parameters: heights (list of int): Heights of the buildings. Returns: list of int: Indices of buildings with ocean view in ascending order. ocean_view_buildings = [] max_height = 0 for i in reversed(range(len(heights))): if heights[i] > max_height: ocean_view_buildings.append(i) max_height = heights[i] # Since we've collected indices from right to left, reverse to get ascending order ocean_view_buildings.reverse() return ocean_view_buildings"},{"question":"def pacific_atlantic_water_flow(heights: List[List[int]]) -> List[List[int]]: Returns a list of all cells that are reachable from any boundary cell of the grid. The result is a list of lists, where each element is a pair [i, j] denoting the row and column of a reachable cell. The list is sorted first by row and then by column. Args: heights: List[List[int]]: A grid of size m x n consisting of non-negative integers where each cell represents a point with a certain height. Returns: List[List[int]]: A list of all reachable cells from any boundary cell. Example: >>> pacific_atlantic_water_flow([[1, 2], [4, 3]]) [[0, 1], [1, 0], [1, 1]] >>> pacific_atlantic_water_flow([[1, 2, 3, 4]]) [[0,0],[0,1],[0,2],[0,3]] >>> pacific_atlantic_water_flow([[1], [2], [3], [4]]) [[0, 0], [1, 0], [2, 0], [3, 0]] >>> pacific_atlantic_water_flow([]) [] >>> pacific_atlantic_water_flow([[1, 1], [1, 1]]) [[0,0],[0,1],[1,0],[1,1]] pass","solution":"def pacific_atlantic_water_flow(heights): if not heights or not heights[0]: return [] m, n = len(heights), len(heights[0]) def bfs(starts): visited = set(starts) queue = starts[:] while queue: x, y = queue.pop(0) for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]: nx, ny = x + i, y + j if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and heights[nx][ny] >= heights[x][y]: visited.add((nx, ny)) queue.append((nx, ny)) return visited pacific_starts = [(i, 0) for i in range(m)] + [(0, j) for j in range(n)] atlantic_starts = [(i, n-1) for i in range(m)] + [(m-1, j) for j in range(n)] pacific_reachable = bfs(pacific_starts) atlantic_reachable = bfs(atlantic_starts) results = list(pacific_reachable & atlantic_reachable) results.sort() return [[x, y] for x, y in results]"},{"question":"def numEnclaves(grid: List[List[int]]) -> int: Return the total number of land cells that are #1-enclave connected islands in the grid. >>> numEnclaves([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 >>> numEnclaves([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 0 >>> numEnclaves([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 1 >>> numEnclaves([[0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]) == 4 >>> numEnclaves([[0, 0, 1, 0], [1, 1, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]) == 0","solution":"def numEnclaves(grid): def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == 0: return grid[x][y] = 0 dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) m, n = len(grid), len(grid[0]) # Eliminate border connected lands for i in range(m): for j in [0, n - 1]: if grid[i][j] == 1: dfs(i, j) for i in [0, m - 1]: for j in range(n): if grid[i][j] == 1: dfs(i, j) # Count enclave lands count = 0 for i in range(1, m - 1): for j in range(1, n - 1): if grid[i][j] == 1: count += 1 return count"},{"question":"def length_of_lis(nums: List[int]) -> int: Returns the length of the longest strictly increasing subsequence of the given list of stock prices. >>> length_of_lis([]) == 0 >>> length_of_lis([10]) == 1 >>> length_of_lis([1, 2, 3, 4, 5]) == 5 >>> length_of_lis([5, 4, 3, 2, 1]) == 1 >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> length_of_lis([3, 3, 3, 3, 3]) == 1","solution":"def length_of_lis(nums): Returns the length of the longest strictly increasing subsequence of the given list of stock prices. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def removeDuplicates(nums: List[int]) -> int: Removes duplicates from the list in-place and returns the new length of the list. :param nums: List[int] - The input list of integers. :return: int - The length of the list after duplicates have been removed. >>> nums = [1, 2, 2, 3, 4, 4, 5] >>> removeDuplicates(nums) 5 >>> nums[:5] [1, 2, 3, 4, 5] >>> nums = [1, 1, 1, 1, 1] >>> removeDuplicates(nums) 1 >>> nums[:1] [1] >>> nums = [] >>> removeDuplicates(nums) 0 >>> nums = [i % 10 for i in range(1000)] >>> removeDuplicates(nums) 10 >>> nums[:10] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]","solution":"def removeDuplicates(nums): Removes duplicates from the list in-place and returns the new length of the list. :param nums: List[int] - The input list of integers. :return: int - The length of the list after duplicates have been removed. if not nums: return 0 unique_position = 0 seen = set() for num in nums: if num not in seen: seen.add(num) nums[unique_position] = num unique_position += 1 return unique_position"},{"question":"from typing import List, Tuple def can_reach_hole(maze: List[List[int]], start: Tuple[int, int], destination: Tuple[int, int]) -> bool: Determines if the ball can reach the hole in the maze. Parameters: maze (List[List[int]]): The grid representing the maze. start (Tuple[int, int]): The starting position of the ball. destination (Tuple[int, int]): The hole's position. Returns: bool: True if the ball can reach the hole, otherwise False. import pytest def test_can_reach_hole(): maze = [ [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 1, 0], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0] ] start = (0, 4) destination = (4, 4) assert can_reach_hole(maze, start, destination) == True def test_cannot_reach_hole(): maze = [ [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [1, 1, 1, 1, 1], [0, 0, 0, 0, 0] ] start = (0, 4) destination = (4, 4) assert can_reach_hole(maze, start, destination) == False def test_start_is_hole(): maze = [ [0, 1], [0, 0] ] start = (1, 1) destination = (1, 1) assert can_reach_hole(maze, start, destination) == True def test_no_possible_move(): maze = [ [0, 1], [1, 0] ] start = (0, 0) destination = (1, 1) assert can_reach_hole(maze, start, destination) == False def test_single_cell_maze(): maze = [ [0] ] start = (0, 0) destination = (0, 0) assert can_reach_hole(maze, start, destination) == True if __name__ == '__main__': pytest.main()","solution":"from collections import deque def can_reach_hole(maze, start, destination): Determines if the ball can reach the hole in the maze. Parameters: maze (List[List[int]]): The grid representing the maze. start (Tuple[int, int]): The starting position of the ball. destination (Tuple[int, int]): The hole's position. Returns: bool: True if the ball can reach the hole, otherwise False. n = len(maze) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right visited = set() queue = deque([start]) while queue: x, y = queue.popleft() if (x, y) in visited: continue visited.add((x, y)) for d in directions: new_x, new_y = x, y # Roll the ball until it hits a wall while 0 <= new_x + d[0] < n and 0 <= new_y + d[1] < n and maze[new_x + d[0]][new_y + d[1]] == 0: new_x += d[0] new_y += d[1] if (new_x, new_y) == destination: return True if (new_x, new_y) not in visited: queue.append((new_x, new_y)) return False"},{"question":"def max_len_subarray_with_sum_k(arr: List[int], k: int) -> int: Given an array of integers \`arr\`, find the maximum length of a subarray where the sum of elements equals \`k\`. >>> max_len_subarray_with_sum_k([1, -1, 5, -2, 3], 3) == 4 >>> max_len_subarray_with_sum_k([1, 1, 1, 1, 1], 2) == 2 >>> max_len_subarray_with_sum_k([1, 2, 3, 4, 5], 15) == 5 >>> max_len_subarray_with_sum_k([-1, -1, 1, 1, -1], 0) == 4 >>> max_len_subarray_with_sum_k([1], 0) == 0 >>> max_len_subarray_with_sum_k([], 0) == 0 >>> max_len_subarray_with_sum_k([1, 2, 3, 4, 5], -3) == 0","solution":"def max_len_subarray_with_sum_k(arr, k): Returns the maximum length of a subarray with the sum equal to k. sum_indices = {} current_sum = 0 max_length = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum == k: max_length = i + 1 if (current_sum - k) in sum_indices: max_length = max(max_length, i - sum_indices[current_sum - k]) if current_sum not in sum_indices: sum_indices[current_sum] = i return max_length"},{"question":"def can_collect_candies(candies: List[int], queries: List[List[int]]) -> List[bool]: Determine if it is possible to collect exactly k candies in the subarray defined by queries. Args: candies: A list of integers representing the number of candies at each store. queries: A list of queries, where each query is represented by a list [start, end, k]. Returns: A list of boolean values, with each value indicating whether it is possible to collect exactly k candies for the corresponding query. Examples: >>> can_collect_candies([5], [[0, 0, 5]]) [True] >>> can_collect_candies([5], [[0, 0, 3]]) [False] >>> can_collect_candies([1, 2, 3, 4, 5], [[0, 2, 6], [1, 3, 9], [0, 4, 15]]) [True, True, True] >>> can_collect_candies([1, 2, 3, 4, 5], [[0, 2, 7], [1, 3, 10], [0, 4, 14]]) [False, False, False] >>> can_collect_candies([2, 4, 6, 8, 10], [[0, 2, 12], [2, 4, 24]]) [True, True] >>> can_collect_candies([7, 8, 9, 10, 11], [[0, 1, 15], [3, 4, 21]]) [True, True]","solution":"def can_collect_candies(candies, queries): prefix_sums = [0] * (len(candies) + 1) for i in range(len(candies)): prefix_sums[i + 1] = prefix_sums[i] + candies[i] result = [] for start, end, k in queries: total_candies = prefix_sums[end + 1] - prefix_sums[start] result.append(total_candies == k) return result"},{"question":"from typing import List def orangesRotting(grid: List[List[int]]) -> int: Given a 2D grid representing a field of oranges, where each cell in the grid can have one of three possible values: - 0 representing an empty cell, - 1 representing a fresh orange, - 2 representing a rotten orange. The function should return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1. A rotten orange can rot adjacent fresh oranges in the four possible cardinal directions (up, down, left, right) in one minute. >>> orangesRotting([ ... [2, 1, 1], ... [1, 1, 0], ... [0, 1, 1] ... ]) 4 >>> orangesRotting([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) -1","solution":"from collections import deque def orangesRotting(grid): rows, cols = len(grid), len(grid[0]) queue = deque() fresh_oranges = 0 # Add all rotten oranges to the queue and count fresh oranges for r in range(rows): for c in range(cols): if grid[r][c] == 2: queue.append((r, c)) elif grid[r][c] == 1: fresh_oranges += 1 # If there are no fresh oranges, return 0 if fresh_oranges == 0: return 0 minutes_elapsed = 0 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # Perform BFS starting from initially rotten oranges while queue and fresh_oranges > 0: minutes_elapsed += 1 for _ in range(len(queue)): x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1: grid[nx][ny] = 2 queue.append((nx, ny)) fresh_oranges -= 1 # If there are still fresh oranges left, return -1. Otherwise, return the time elapsed. return -1 if fresh_oranges > 0 else minutes_elapsed"},{"question":"def count_shaded_cells(forest: List[List[int]]) -> int: Determine the total number of cells that are shaded by at least one tree. A tree cell is considered to shade itself. :param forest: List[List[int]], a 2D list representing the forest :return: int, the count of shaded cells >>> count_shaded_cells([[1, 1],[1, 1]]) 4 >>> count_shaded_cells([[0, 0],[0, 0]]) 0 >>> count_shaded_cells([[1, 0],[0, 1]]) 4 >>> count_shaded_cells([[0, 0, 0],[0, 1, 0],[0, 0, 0]]) 5 >>> count_shaded_cells([[1, 0, 1],[0, 1, 0],[1, 0, 1]]) 9","solution":"def count_shaded_cells(forest): Returns the number of cells that are shaded by at least one tree. A tree cell is considered to shade itself. :param forest: List[List[int]], a 2D list representing the forest :return: int, the count of shaded cells if not forest: return 0 rows = len(forest) cols = len(forest[0]) shaded = set() for i in range(rows): for j in range(cols): if forest[i][j] == 1: shaded.add((i, j)) if i > 0: shaded.add((i - 1, j)) if i < rows - 1: shaded.add((i + 1, j)) if j > 0: shaded.add((i, j - 1)) if j < cols - 1: shaded.add((i, j + 1)) return len(shaded)"},{"question":"def max_ones(grid: List[List[int]]) -> int: You are given a two-dimensional grid of size \`n x m\`, where each cell of the grid contains either a \`0\` or a \`1\`. Each row and column of the grid can be flipped (changed all \`0\`s to \`1\`s, and all \`1\`s to \`0\`s) any number of times. Find the maximum number of \`1\`s that can be obtained in the grid after performing any number of flips. Return an integer \`answer\`, the maximum number of \`1\`s that can be obtained in the grid. >>> max_ones([[0, 1, 0, 1]]) # Flip the single row once 4 >>> max_ones([[0], [1], [0], [1]]) # Flip the single column once 4 >>> max_ones([[0, 0], [0, 0]]) # Flip each cell in every row or col 4 >>> max_ones([[1, 1], [1, 1]]) # No flipping required 4 >>> max_ones([[0, 1], [1, 0]]) # Flip either the rows or columns once 4 >>> max_ones([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) # Optimal arrangement can have all cells as 1 9","solution":"def max_ones(grid): This function accepts a 2D list 'grid' containing 0s and 1s and returns the maximum number of 1s that can be obtained by flipping any row or column any number of times. def count_ones(grid): return sum(sum(row) for row in grid) def flip_row(grid, row_idx): grid[row_idx] = [1 - cell for cell in grid[row_idx]] def flip_col(grid, col_idx): for row in grid: row[col_idx] = 1 - row[col_idx] n = len(grid) m = len(grid[0]) max_ones_count = 0 for row_mask in range(1 << n): # Flip specified rows: flipped_grid = [row[:] for row in grid] # Deep copy of the grid for row in range(n): if row_mask & (1 << row): flip_row(flipped_grid, row) for col_mask in range(1 << m): temp_grid = [row[:] for row in flipped_grid] # Copy the flipped grid for col in range(m): if col_mask & (1 << col): flip_col(temp_grid, col) max_ones_count = max(max_ones_count, count_ones(temp_grid)) return max_ones_count"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root: TreeNode) -> int: Determine the maximum depth of a binary tree. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. >>> root = TreeNode(1) >>> maxDepth(root) 1 >>> root = None >>> maxDepth(root) 0 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> maxDepth(root) 3 >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> maxDepth(root) 3 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.right.right = TreeNode(5) >>> maxDepth(root) 3 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> maxDepth(root) 3","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root: TreeNode) -> int: if root is None: return 0 left_depth = maxDepth(root.left) right_depth = maxDepth(root.right) return max(left_depth, right_depth) + 1"},{"question":"class ListNode: def __init__(self, val=0, prev=None, next=None): self.val = val self.prev = prev self.next = next def merge_k_lists(lists): Write a function to merge a group of \`k\` sorted doubly linked lists into a single sorted doubly linked list. :param lists: List of ListNode objects representing the head of each doubly linked list :return: ListNode object representing the head of the merged sorted doubly linked list >>> head1 = ListNode(1) >>> head1.next = ListNode(3, head1) >>> head1.next.next = ListNode(5, head1.next) >>> head2 = ListNode(2) >>> head2.next = ListNode(4, head2) >>> head2.next.next = ListNode(6, head2.next) >>> result = merge_k_lists([head1, head2]) >>> result_list = [] >>> while result: ... result_list.append(result.val) ... result = result.next >>> result_list [1, 2, 3, 4, 5, 6]","solution":"class ListNode: def __init__(self, val=0, prev=None, next=None): self.val = val self.prev = prev self.next = next def merge_two_lists(l1, l2): dummy = ListNode() curr = dummy while l1 and l2: if l1.val < l2.val: curr.next = l1 l1.prev = curr l1 = l1.next else: curr.next = l2 l2.prev = curr l2 = l2.next curr = curr.next if l1: curr.next = l1 l1.prev = curr if l2: curr.next = l2 l2.prev = curr merged_head = dummy.next if merged_head: merged_head.prev = None return merged_head def merge_k_lists(lists): if not lists: return None while len(lists) > 1: merged_lists = [] for i in range(0, len(lists), 2): l1 = lists[i] l2 = lists[i+1] if i+1 < len(lists) else None merged_lists.append(merge_two_lists(l1, l2)) lists = merged_lists return lists[0]"},{"question":"def findPoisonedDuration(timeSeries: List[int], duration: int) -> int: Calculate the total duration of an effect caused by event occurrences at specific times. Parameters: - timeSeries (list of int): List of times at which events occur. - duration (int): Duration of the effect caused by each event. Returns: int: The total duration of the effect. >>> findPoisonedDuration([1], 4) 4 >>> findPoisonedDuration([1, 7], 4) 8 >>> findPoisonedDuration([1, 2, 3, 4], 4) 7 >>> findPoisonedDuration([1, 2, 8, 9], 4) 10 >>> findPoisonedDuration([], 4) 0 >>> findPoisonedDuration([1, 1, 1, 1], 5) 5 >>> findPoisonedDuration([1, 10], 100) 109","solution":"def findPoisonedDuration(timeSeries, duration): This function calculates the total duration of an effect caused by event occurrences at specific times. Parameters: timeSeries (list of int): List of times at which events occur. duration (int): Duration of the effect caused by each event. Returns: int: The total duration of the effect. if not timeSeries: return 0 total_duration = 0 for i in range(len(timeSeries) - 1): total_duration += min(duration, timeSeries[i + 1] - timeSeries[i]) return total_duration + duration"},{"question":"def rotate(matrix: List[List[int]]) -> None: Rotates the given n x n 2D matrix representing an image 90 degrees clockwise in-place. Args: matrix (List[List[int]]): The n x n 2D matrix to be rotated. Returns: None: The function modifies the matrix in-place.","solution":"def rotate(matrix): Rotates the given n x n 2D matrix representing an image 90 degrees clockwise in-place. Args: matrix (List[List[int]]): The n x n 2D matrix to be rotated. Returns: None: The function modifies the matrix in-place. n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def lexical_order(n: int) -> List[int]: Returns a list of integers from 1 to n in lexicographical order. >>> lexical_order(13) [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9] >>> lexical_order(5) [1, 2, 3, 4, 5] >>> lexical_order(20) [1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 20, 3, 4, 5, 6, 7, 8, 9] >>> lexical_order(100) [1, 10, 100, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 3, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 4, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 5, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 6, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 7, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 8, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 9, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99] >>> lexical_order(21) [1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 20, 21, 3, 4, 5, 6, 7, 8, 9]","solution":"def lexical_order(n): Returns a list of integers from 1 to n in lexicographical order. result = [] def dfs(current): if current > n: return result.append(current) for i in range(10): next_num = current * 10 + i if next_num > n: return dfs(next_num) for i in range(1, 10): dfs(i) return result"},{"question":"def is_valid(s: str) -> bool: Determine if a given string \`s\` is valid based on proper nesting and matching of parentheses and braces. Args: - s (str): The input string to be checked Returns: - bool: True if valid, False otherwise >>> is_valid(\\"{[()()]}\\") True >>> is_valid(\\"[({)}]\\") False >>> is_valid(\\"(){}[]\\") True >>> is_valid(\\"{[]}\\") True # Additional test cases def test_valid_parentheses_and_braces(): assert is_valid(\\"{[()()]}\\") == True assert is_valid(\\"(){}[]\\") == True assert is_valid(\\"{[()]}\\") == True assert is_valid(\\"{[]}\\") == True def test_invalid_parentheses_and_braces(): assert is_valid(\\"{[(])}\\") == False assert is_valid(\\"({[})\\") == False assert is_valid(\\"[({)}]\\") == False assert is_valid(\\"{[}(]\\") == False def test_empty_string(): assert is_valid(\\"\\") == True def test_single_type_bracket(): assert is_valid(\\"(\\") == False assert is_valid(\\")\\") == False assert is_valid(\\"{\\") == False assert is_valid(\\"}\\") == False assert is_valid(\\"[\\") == False assert is_valid(\\"]\\") == False def test_unmatched_open_close(): assert is_valid(\\"}\\") == False assert is_valid(\\"{\\") == False assert is_valid(\\"[[[]\\") == False assert is_valid(\\"()(\\") == False def test_wrong_characters(): assert is_valid(\\"a+b(c)\\") == False assert is_valid(\\"123[{()}]\\") == False assert is_valid(\\"var = {[()]}\\") == False","solution":"def is_valid(s): Determine if a given string \`s\` is valid based on proper nesting and matching of parentheses and braces. Args: - s (str): The input string to be checked Returns: - bool: True if valid, False otherwise stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_bracket.values(): # If it's an opening bracket stack.append(char) elif char in matching_bracket.keys(): # If it's a closing bracket if stack == [] or stack.pop() != matching_bracket[char]: return False else: # If the character is not one of the expected parentheses or braces, it's invalid return False return stack == [] # Example usage: is_valid(\\"{[()()]}\\") should return True # Example usage: is_valid(\\"[({)}]\\") should return False"},{"question":"def min_path_sum(mat: List[List[int]]) -> int: Given a matrix 'mat' of size m x n, where every cell represents a cost to travel through, find a path from the top-left corner to the bottom-right corner which minimizes the sum of the costs of the cells on that path. You can only move right or down from a cell. Args: mat (list of list of int): The cost matrix. Returns: int: The minimum cost to travel from the top-left to the bottom-right. Examples: >>> min_path_sum([[1, 2, 5], [3, 2, 1]]) 6 >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7","solution":"def min_path_sum(mat): Given a matrix mat of size m x n, where every cell represents a cost to travel through, find a path from the top-left corner to the bottom-right corner which minimizes the sum of the costs of the cells on that path. You can only move right or down from a cell. Args: mat (list of list of int): The cost matrix. Returns: int: The minimum cost to travel from the top-left to the bottom-right. if not mat or not mat[0]: return 0 m, n = len(mat), len(mat[0]) # Create a 2D dp array to store the minimum cost up to each cell dp = [[0] * n for _ in range(m)] # Initialize the top-left cell with the cost of the starting point dp[0][0] = mat[0][0] # Fill in the cost for the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i-1][0] + mat[i][0] # Fill in the cost for the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + mat[0][j] # Fill in the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + mat[i][j] return dp[m-1][n-1]"},{"question":"def findRepeatedDnaSequences(s: str) -> List[str]: Returns all 10-letter-long sequences (substrings) that occur more than once in a DNA sequence. >>> sorted(findRepeatedDnaSequences(\\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\\")) [\\"AAAAACCCCC\\", \\"CCCCCAAAAA\\"] >>> sorted(findRepeatedDnaSequences(\\"AAAAAAAAAAA\\")) [\\"AAAAAAAAAA\\"] >>> findRepeatedDnaSequences(\\"ACGTACGTAC\\") [] >>> findRepeatedDnaSequences(\\"ACGT\\") [] >>> findRepeatedDnaSequences(\\"\\") [] >>> sorted(findRepeatedDnaSequences(\\"AAAAAAAAAACCCCCCCCCCAAAAAAAAAA\\")) [\\"AAAAAAAAAA\\"]","solution":"def findRepeatedDnaSequences(s): Returns all 10-letter-long sequences (substrings) that occur more than once in the given DNA sequence. sequence_counts = {} result = set() # Iterate over the string and use a sliding window approach to find all substrings of length 10 for i in range(len(s) - 9): substring = s[i:i + 10] if substring in sequence_counts: sequence_counts[substring] += 1 else: sequence_counts[substring] = 1 # If a substring is found more than once, add it to the result set if sequence_counts[substring] == 2: result.add(substring) return list(result)"},{"question":"def max_length_subarray(arr, x): Returns the maximum length of a subarray with at most x distinct integers. >>> max_length_subarray([1, 2, 3, 4], 0) 0 >>> max_length_subarray([1], 1) 1 >>> max_length_subarray([1], 0) 0 >>> max_length_subarray([1, 2, 1, 2, 3], 2) 4 >>> max_length_subarray([1, 2, 3, 4], 3) 3 >>> max_length_subarray([1, 2, 1, 3, 4], 4) 5 >>> max_length_subarray([1, 1, 1, 1], 1) 4 >>> max_length_subarray([1, 2, 3], 5) 3","solution":"def max_length_subarray(arr, x): Returns the maximum length of a subarray with at most x distinct integers. if x == 0: return 0 from collections import defaultdict max_len = 0 left = 0 counts = defaultdict(int) for right, value in enumerate(arr): counts[value] += 1 while len(counts) > x: counts[arr[left]] -= 1 if counts[arr[left]] == 0: del counts[arr[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def unique_paths(m: int, n: int) -> int: Given m and n, return the number of distinct paths the robot can take to reach the bottom-right corner (m-1, n-1) where it can move right, down, or diagonally right-down. >>> unique_paths(1, 1) == 1 >>> unique_paths(2, 2) == 3 >>> unique_paths(3, 3) == 13 >>> unique_paths(3, 2) == 5 >>> unique_paths(4, 4) == 63","solution":"def unique_paths(m, n): Given m and n, returns the number of distinct paths the robot can take from (0, 0) to (m-1, n-1) where it can move right, down, or diagonally right-down. # Create a 2D array to store the number of ways to reach each cell dp = [[0] * n for _ in range(m)] # There is exactly 1 way to reach the first cell (stay put) dp[0][0] = 1 for i in range(m): for j in range(n): if i - 1 >= 0: dp[i][j] += dp[i - 1][j] # from above if j - 1 >= 0: dp[i][j] += dp[i][j - 1] # from left if i - 1 >= 0 and j - 1 >= 0: dp[i][j] += dp[i - 1][j - 1] # from diagonal return dp[m - 1][n - 1]"},{"question":"def count_swaps_to_sort(heights: List[int]) -> int: Given an integer array \`heights\` representing the heights of a group of students standing in a line, return the minimum number of indices where the heights need to be swapped to make the entire array sorted in non-decreasing order. Note that each student must maintain their original position index after sorting. Args: heights (List[int]): List of integers representing the heights of students. Returns: int: The minimum number of indices that need to be swapped. >>> count_swaps_to_sort([1, 2, 3, 4, 5]) 0 >>> count_swaps_to_sort([2, 1, 3, 4, 5]) 2 >>> count_swaps_to_sort([5, 3, 1, 2, 4]) 5 >>> count_swaps_to_sort([]) 0 >>> count_swaps_to_sort([1]) 0 >>> count_swaps_to_sort([2, 2, 2, 2, 2]) 0 >>> count_swaps_to_sort([5, 4, 3, 2, 1]) 4","solution":"def count_swaps_to_sort(heights): Returns the minimum number of indices where the heights need to be swapped to make the entire array sorted in non-decreasing order. sorted_heights = sorted(heights) out_of_place_count = 0 for i in range(len(heights)): if heights[i] != sorted_heights[i]: out_of_place_count += 1 return out_of_place_count"},{"question":"def can_be_strictly_increasing(nums: List[int]) -> bool: Determines if the array can be made strictly increasing by modifying at most one element. >>> can_be_strictly_increasing([1]) True >>> can_be_strictly_increasing([1, 2, 3, 4, 5]) True >>> can_be_strictly_increasing([1, 3, 2, 4, 5]) True >>> can_be_strictly_increasing([10, 5, 7]) True >>> can_be_strictly_increasing([1, 2, 3, 2, 5, 4]) False >>> can_be_strictly_increasing([5, 3, 4, 4, 5]) False >>> can_be_strictly_increasing([9, 2, 3]) True >>> can_be_strictly_increasing([4, 2, 3]) True >>> can_be_strictly_increasing([1, 2, 5, 3, 4]) True >>> can_be_strictly_increasing([3, 4, 2, 3]) False >>> can_be_strictly_increasing([5, 4, 3]) False","solution":"def can_be_strictly_increasing(nums): Determines if the array can be made strictly increasing by modifying at most one element. n = len(nums) if n == 1: return True # Count the number of places where nums[i] is not less than nums[i + 1] count = 0 for i in range(n - 1): if nums[i] >= nums[i + 1]: count += 1 if count > 1: return False # If nums[i] >= nums[i+1], we can either change nums[i] or nums[i+1] if i > 0 and nums[i-1] >= nums[i+1] and i < n-2 and nums[i] >= nums[i+2]: return False return True"},{"question":"def sliding_operations(nums, k): Perform k sliding operations on the array \`nums\`, where each sliding operation consists of removing the smallest element from the array and appending it to the end of the array. Args: nums (List[int]): The array of integers. k (int): The number of sliding operations to perform. Returns: List[int]: The resulting array after performing k sliding operations. >>> sliding_operations([4, 1, 3, 2], 2) == [4, 3, 2, 1] >>> sliding_operations([1, 1, 1, 1], 3) == [1, 1, 1, 1] >>> sliding_operations([5], 3) == [5] >>> sliding_operations([2, 3, 1, 4], 0) == [2, 3, 1, 4] >>> sliding_operations([4, 3, 2, 1], 10) == [4, 3, 2, 1]","solution":"def sliding_operations(nums, k): Perform k sliding operations on the array \`nums\`, where each sliding operation consists of removing the smallest element from the array and appending it to the end of the array. Args: nums (List[int]): The array of integers. k (int): The number of sliding operations to perform. Returns: List[int]: The resulting array after performing k sliding operations. for _ in range(k): min_element = min(nums) nums.remove(min_element) nums.append(min_element) return nums"},{"question":"def calculate_event_durations(logs): Calculate the total duration of each event. Parameters: logs (list): List of strings in the format \\"id status timestamp\\" Returns: dict: Dictionary where key is the event 'id' and value is the total duration of the event.","solution":"def calculate_event_durations(logs): Calculate the total duration of each event. Parameters: logs (list): List of strings in the format \\"id status timestamp\\" Returns: dict: Dictionary where key is the event 'id' and value is the total duration of the event. events = {} # Dictionary to store the start time of each event. start_times = {} for log in logs: log_parts = log.split() event_id = log_parts[0] status = log_parts[1] timestamp = int(log_parts[2]) if status == \\"start\\": start_times[event_id] = timestamp elif status == \\"end\\": if event_id in start_times: duration = timestamp - start_times[event_id] events[event_id] = duration # For events that have a start time but no end time, set their duration to 0. for event_id in start_times: if event_id not in events: events[event_id] = 0 return events"},{"question":"def calculate(s: str) -> int: Given a string s representing a mathematical expression, implement a basic calculator to evaluate it. The expression s can contain '+', '-', '(', ')', non-negative integers, and white spaces. Return the result of the evaluation. >>> calculate(\\"3 + 2\\") == 5 >>> calculate(\\" 6 - 4 \\") == 2 >>> calculate(\\"(1 + 2)\\") == 3 >>> calculate(\\"(3+(4-1))\\") == 6 >>> calculate(\\"((3+(4-1))+(3+2))\\") == 11 >>> calculate(\\"(1+(2-(3+(4-5))))\\") == 1 >>> calculate(\\"2-(5-6)\\") == 3 >>> calculate(\\"1-(2+3-(4+(5-6)))\\") == -1 >>> calculate(\\" 3 + 5 - ( 2 - 1 ) \\") == 7 >>> calculate(\\"5- ( 3 + 7) + ( 13 - 10)\\") == -2","solution":"def calculate(s: str) -> int: def evaluate(tokens): stack = [] num = 0 sign = 1 while len(tokens) > 0: token = tokens.pop(0) if token.isdigit(): num = int(token) while len(tokens) > 0 and tokens[0].isdigit(): num = num * 10 + int(tokens.pop(0)) stack.append(sign * num) num = 0 elif token == '+': sign = 1 elif token == '-': sign = -1 elif token == '(': num = evaluate(tokens) stack.append(sign * num) num = 0 elif token == ')': break return sum(stack) # Remove the spaces and convert to list of tokens tokens = list(s.replace(' ', '')) return evaluate(tokens)"},{"question":"def max_path_sum(tree: List[Optional[int]]) -> int: Given a binary tree represented as a list, calculates the maximum sum from the root to any leaf node. >>> max_path_sum([1, 2, 3, 4, 5, 6, 7]) == 11 >>> max_path_sum([1, 2, 3, None, 5, None, 7]) == 11 >>> max_path_sum([1]) == 1 >>> max_path_sum([1, 2, None]) == 3 >>> max_path_sum([1, 2, 10]) == 11 >>> max_path_sum([]) == 0 >>> max_path_sum([None, None, None]) == 0","solution":"def max_path_sum(tree): Given a binary tree represented as a list, calculates the maximum sum from the root to any leaf node. if not tree or tree[0] is None: return 0 def helper(index): if index >= len(tree) or tree[index] is None: return 0 left_index = 2 * index + 1 right_index = 2 * index + 2 left_sum = helper(left_index) right_sum = helper(right_index) if left_sum == 0 and right_sum == 0 and (left_index < len(tree) or right_index < len(tree)): return tree[index] return tree[index] + max(left_sum, right_sum) return helper(0)"},{"question":"def canMeasureWater(jug1Capacity: int, jug2Capacity: int, targetCapacity: int) -> bool: Determine if it is possible to measure exactly targetCapacity using the two jugs. >>> canMeasureWater(3, 5, 4) == True >>> canMeasureWater(2, 6, 5) == False >>> canMeasureWater(5, 3, 5) == True >>> canMeasureWater(1, 2, 4) == False >>> canMeasureWater(3, 5, 0) == True >>> canMeasureWater(0, 5, 5) == True >>> canMeasureWater(0, 5, 3) == False >>> canMeasureWater(0, 5, 0) == True","solution":"def canMeasureWater(jug1Capacity, jug2Capacity, targetCapacity): Determine if it is possible to measure exactly targetCapacity using the two jugs. from math import gcd # If the target capacity is greater than the combined capacity of the two jugs, it's impossible if targetCapacity > jug1Capacity + jug2Capacity: return False # If the target capacity is zero, it's always possible if targetCapacity == 0: return True # Using the theory of Bezout's identity, check if the targetCapacity is a multiple of the GCD return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0"},{"question":"def min_moves_to_sort(cards: List[int]) -> int: Returns the minimum number of moves required to sort the deck. Args: cards (List[int]): A list of integers representing the initial order of cards. Returns: int: The minimum number of moves required to sort the deck. >>> min_moves_to_sort([1, 2, 3, 4, 5]) 0 >>> min_moves_to_sort([5, 4, 3, 2, 1]) 4 >>> min_moves_to_sort([3, 1, 2, 5, 4]) 2 >>> min_moves_to_sort([1]) 0 >>> min_moves_to_sort([2, 1]) 1 >>> min_moves_to_sort([4, 2, 3, 1, 5]) 2","solution":"def min_moves_to_sort(cards): Returns the minimum number of moves required to sort the deck. Args: cards (List[int]): A list of integers representing the initial order of cards. Returns: int: The minimum number of moves required to sort the deck. n = len(cards) # Create a list to store the length of the longest increasing subsequence ending at each index lis = [1] * n for i in range(1, n): for j in range(i): if cards[i] > cards[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # The result will be the total number of cards minus the length of the longest increasing subsequence return n - max(lis)"},{"question":"def longestZeroSumSubarray(arr: List[int]) -> int: Returns the length of the longest subarray with sum equal to 0. >>> longestZeroSumSubarray([1, 2, 3]) 0 >>> longestZeroSumSubarray([0, 0, 0, 0]) 4 >>> longestZeroSumSubarray([1, -1, 3, -3, 5]) 4 >>> longestZeroSumSubarray([4, -2, -2, 2, -2]) 5 >>> longestZeroSumSubarray([5, -5, 5, 1, -1, -5, 5]) 6 >>> longestZeroSumSubarray([1, 2, -3, 3, 1, -4, 2, -2]) 8","solution":"def longestZeroSumSubarray(arr): Returns the length of the longest subarray with sum equal to 0. hashmap = {} max_len = 0 current_sum = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum == 0: max_len = i + 1 if current_sum in hashmap: max_len = max(max_len, i - hashmap[current_sum]) else: hashmap[current_sum] = i return max_len"},{"question":"def reorder_odd_even(nums: List[int]) -> List[int]: Reorder the unsorted array such that all odd elements come before all even elements. Must solve it in O(n) time and with O(1) extra space. >>> reorder_odd_even([3, 1, 2, 4]) == [3, 1, 2, 4] or reorder_odd_even([3, 1, 2, 4]) == [1, 3, 2, 4] >>> reorder_odd_even([5, 7, 9, 11]) == [5, 7, 9, 11] >>> reorder_odd_even([2, 4, 6, 8]) == [2, 4, 6, 8] >>> reorder_odd_even([]) == [] >>> reorder_odd_even([1]) == [1] >>> reorder_odd_even([2]) == [2] >>> reorder_odd_even([1, 2, 3, 4, 5, 6]) == [1, 5, 3, 4, 2, 6] or reorder_odd_even([1, 2, 3, 4, 5, 6]) == [1, 3, 5, 4, 2, 6]","solution":"def reorder_odd_even(nums): Reorder the array such that all odd elements come before all even elements. Parameters: nums (list): The list of integers. Returns: list: The reordered list with all odd elements before even elements. left, right = 0, len(nums) - 1 while left < right: while left < right and nums[left] % 2 != 0: left += 1 while left < right and nums[right] % 2 == 0: right -= 1 if left < right: nums[left], nums[right] = nums[right], nums[left] return nums"},{"question":"def can_distribute_evenly(nums: List[int], k: int) -> bool: Determine if it's possible to distribute the candies from all the baskets into exactly k baskets without any candies left over. Parameters: nums (list): A list of integers representing the number of candies in each basket. k (int): Number of baskets to distribute the candies into. Returns: bool: True if candies can be evenly distributed, otherwise False. Examples: >>> can_distribute_evenly([2, 4, 6], 3) True >>> can_distribute_evenly([1, 2, 3, 4], 2) True >>> can_distribute_evenly([2, 3, 5], 4) False","solution":"def can_distribute_evenly(nums, k): Check if candies can be evenly distributed into exactly k baskets. Parameters: nums (list): A list of integers representing the number of candies in each basket. k (int): Number of baskets to distribute the candies into. Returns: bool: True if candies can be evenly distributed, otherwise False. total_candies = sum(nums) return total_candies % k == 0"},{"question":"from typing import List def minChargingStations(parkingLot: List[List[int]]) -> int: Return the minimum number of charging stations required to ensure that every parked car can access at least one charging station. >>> minChargingStations([[0, 0], [0, 0]]) == 0 >>> minChargingStations([[0, 1], [0, 0]]) == 1 >>> minChargingStations([[1, 1], [0, 0]]) == 1 >>> minChargingStations([[1, 0], [1, 0]]) == 1 >>> minChargingStations([[1, 0], [0, 1]]) == 1 >>> minChargingStations([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) == 1 pass","solution":"def minChargingStations(parkingLot): rows = len(parkingLot) cols = len(parkingLot[0]) def countCoverage(x, y): coverage_positions = set() for i in range(rows): if parkingLot[i][y] == 1: coverage_positions.add((i, y)) for j in range(cols): if parkingLot[x][j] == 1: coverage_positions.add((x, j)) for i in range(rows): for j in range(cols): if abs(x - i) == abs(y - j) and parkingLot[i][j] == 1: coverage_positions.add((i, j)) return coverage_positions car_positions = [(i, j) for i in range(rows) for j in range(cols) if parkingLot[i][j] == 1] charging_stations = 0 while car_positions: max_coverage = 0 best_position = None best_coverage_set = set() for i in range(rows): for j in range(cols): coverage_set = countCoverage(i, j) if len(coverage_set) > max_coverage: max_coverage = len(coverage_set) best_position = (i, j) best_coverage_set = coverage_set charging_stations += 1 car_positions = [car for car in car_positions if car not in best_coverage_set] for car in best_coverage_set: parkingLot[car[0]][car[1]] = 0 return charging_stations"},{"question":"def pacific_atlantic(heights): Return a list of grid coordinates where the oceanic waves can flow to both the Pacific and Atlantic oceans. Args: heights (List[List[int]]): m x n integer matrix representing the heights of each cell in a 2D grid. Returns: List[Tuple[int, int]]: List of coordinates where water can flow to both the Pacific and Atlantic oceans. >>> pacific_atlantic([ [1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4] ]) [(0, 4), (1, 3), (1, 4), (2, 2), (3, 0), (3, 1), (4, 0)] >>> pacific_atlantic([[1]]) [(0, 0)] >>> pacific_atlantic([ [2, 1], [1, 2] ]) [(0, 0), (0, 1), (1, 0), (1, 1)] >>> pacific_atlantic([]) [] >>> pacific_atlantic([[1, 2, 3]]) [(0, 0), (0, 1), (0, 2)] >>> pacific_atlantic([[1], [2], [3]]) [(0, 0), (1, 0), (2, 0)]","solution":"def pacific_atlantic(heights): if not heights: return [] m, n = len(heights), len(heights[0]) pacific_queue = [(i, 0) for i in range(m)] + [(0, j) for j in range(1, n)] atlantic_queue = [(i, n-1) for i in range(m)] + [(m-1, j) for j in range(n-1)] def bfs(queue): reachable = set(queue) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: x, y = queue.pop(0) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in reachable and heights[nx][ny] >= heights[x][y]: reachable.add((nx, ny)) queue.append((nx, ny)) return reachable pacific_reachable = bfs(pacific_queue) atlantic_reachable = bfs(atlantic_queue) return list(pacific_reachable & atlantic_reachable)"},{"question":"def count_balanced_subarrays(numbers: List[int], k: int) -> int: Returns the number of balanced subarrays in the given list 'numbers' that sum up to 'k'. >>> count_balanced_subarrays([1, 2, 3], 10) 0 >>> count_balanced_subarrays([], 0) 0 >>> count_balanced_subarrays([5], 5) 1 >>> count_balanced_subarrays([5], 1) 0 >>> count_balanced_subarrays([1, 1, 1], 2) 2 >>> count_balanced_subarrays([1, 2, 3, 4, 5], 5) 2 >>> count_balanced_subarrays([1, 2, 3], 6) 1 >>> count_balanced_subarrays([-1, 2, -1, 2], 2) 3","solution":"def count_balanced_subarrays(numbers, k): Returns the number of balanced subarrays in the given list 'numbers' that sum up to 'k'. count = 0 n = len(numbers) for i in range(n): curr_sum = 0 for j in range(i, n): curr_sum += numbers[j] if curr_sum == k: count += 1 return count"},{"question":"def unique_paths_with_obstacles(obstacle_grid: List[List[int]]) -> int: Returns the number of unique paths to reach from the top-left corner to the bottom-right corner, navigating through a grid with obstacles. >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ...]) == 6 >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ...]) == 2 >>> unique_paths_with_obstacles([ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ...]) == 0 >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ...]) == 0 >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [1, 1, 1], ... [0, 0, 0] ...]) == 0 >>> unique_paths_with_obstacles([ ... [0, 1, 0], ... [0, 1, 0], ... [0, 1, 0] ...]) == 0 >>> unique_paths_with_obstacles([ ... [0, 0, 0, 0], ... [0, 1, 0, 0], ... [0, 0, 0, 0], ... [1, 0, 1, 0] ...]) == 4","solution":"def unique_paths_with_obstacles(obstacle_grid): Returns the number of unique paths to reach from the top-left corner to the bottom-right corner, navigating through a grid with obstacles. :param obstacle_grid: List[List[int]] :return: int if not obstacle_grid or obstacle_grid[0][0] == 1: return 0 m, n = len(obstacle_grid), len(obstacle_grid[0]) dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = 1 # Starting point for i in range(m): for j in range(n): if obstacle_grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def rob(nums: List[int]) -> int: Given a list of non-negative integers representing the amount of money of each house located along a street, returns the maximum amount of money the robber can steal without alerting the police. >>> rob([1, 2, 3, 1]) 4 >>> rob([2, 7, 9, 3, 1]) 12 >>> rob([]) 0 >>> rob([5]) 5 >>> rob([2, 3, 2]) 4 >>> rob([2, 1, 1, 2]) 4 >>> rob([6, 7, 1, 30, 8, 2, 4]) 41 >>> rob([10, 10, 10, 10]) 20 >>> rob([2] * 1000) 1000","solution":"def rob(nums): Given a list of non-negative integers representing the amount of money of each house located along a street, returns the maximum amount of money the robber can steal without alerting the police. if not nums: return 0 n = len(nums) if n == 1: return nums[0] # dp[i] represents the maximum amount of money we can rob up to house i dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): # Decide whether to rob house i or not dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"def rotate(matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n matrix by 90 degrees clockwise in-place. Parameters: matrix (List[List[int]]): The n x n matrix to be rotated. Returns: List[List[int]]: The rotated matrix. >>> rotate([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ] >>> rotate([ ... [ 5, 1, 9, 11], ... [ 2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ]) == [ ... [15, 13, 2, 5], ... [14, 3, 4, 1], ... [12, 6, 8, 9], ... [16, 7, 10, 11] ... ] >>> rotate([ ... [1, 2], ... [3, 4] ... ]) == [ ... [3, 1], ... [4, 2] ... ] >>> rotate([ ... [1] ... ]) == [ ... [1] ... ]","solution":"def rotate(matrix): Rotates the given n x n matrix by 90 degrees clockwise in-place. Parameters: matrix (List[List[int]]): The n x n matrix to be rotated. Returns: List[List[int]]: The rotated matrix. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"def maximize_ratings(costs, ratings, budget): Function to maximize the total rating without exceeding the budget. Parameters: costs (list of int): Costs of the restaurants. ratings (list of int): Ratings of the restaurants. budget (int): Budget limit. Returns: int: Maximum total rating achievable within the budget. pass # Unit tests def test_maximize_ratings_exact_budget(): costs = [1, 3, 2, 4] ratings = [1, 6, 4, 7] budget = 5 assert maximize_ratings(costs, ratings, budget) == 10 def test_maximize_ratings_insufficient_budget(): costs = [4, 2, 3] ratings = [7, 2, 5] budget = 1 assert maximize_ratings(costs, ratings, budget) == 0 def test_maximize_ratings_unlimited_budget(): costs = [1, 2, 3, 4] ratings = [1, 4, 5, 7] budget = 10 assert maximize_ratings(costs, ratings, budget) == 17 def test_maximize_ratings_only_one_choice(): costs = [5] ratings = [10] budget = 5 assert maximize_ratings(costs, ratings, budget) == 10 def test_maximize_ratings_no_restaurants(): costs = [] ratings = [] budget = 5 assert maximize_ratings(costs, ratings, budget) == 0","solution":"def maximize_ratings(costs, ratings, budget): Function to maximize the total rating without exceeding the budget. Parameters: costs (list of int): Costs of the restaurants. ratings (list of int): Ratings of the restaurants. budget (int): Budget limit. Returns: int: Maximum total rating achievable within the budget. n = len(costs) dp = [[0 for _ in range(budget + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for b in range(budget + 1): if costs[i - 1] <= b: dp[i][b] = max(dp[i - 1][b], ratings[i - 1] + dp[i - 1][b - costs[i - 1]]) else: dp[i][b] = dp[i - 1][b] return dp[n][budget]"},{"question":"from typing import List, Tuple def max_meetings(meetings: List[Tuple[int, int]]) -> Tuple[int, List[int]]: Given a list of (start, end) times for a collection of meetings, return the maximum number of meetings that can be attended by a single person, along with the sorted list of indexes (0-indexed) of the meetings attended for this maximum count. >>> max_meetings([(1, 3), (2, 4), (3, 5)]) (2, [0, 2]) >>> max_meetings([]) (0, []) >>> max_meetings([(1, 2)]) (1, [0]) >>> max_meetings([(1, 4), (2, 3), (3, 5)]) (2, [1, 2]) >>> max_meetings([(1, 2), (2, 3), (3, 4)]) (3, [0, 1, 2]) >>> max_meetings([(1, 2), (1, 2), (1, 2)]) (1, [0]) >>> max_meetings([(1, 2), (3, 4), (0, 6), (5, 7), (8, 9), (5, 9)]) (4, [0, 1, 3, 4]) # or (4, [0, 1, 3, 5])","solution":"def max_meetings(meetings): Returns the maximum number of meetings that can be attended by a single person, and the list of indexes of the meetings attended. # Pair indices with meetings and sort by the end time. indexed_meetings = sorted(enumerate(meetings), key=lambda x: (x[1][1], x[1][0])) count = 0 end_time = -1 attended_indices = [] for index, (start, end) in indexed_meetings: if start >= end_time: count += 1 end_time = end attended_indices.append(index) return count, attended_indices"},{"question":"def longest_contiguous_sequence(nums: List[int]) -> int: Finds and returns the length of the longest contiguous subsequence such that every element in the subsequence is either strictly increasing or strictly decreasing. >>> longest_contiguous_sequence([]) 0 >>> longest_contiguous_sequence([1]) 1 >>> longest_contiguous_sequence([1, 2, 3, 4]) 4 >>> longest_contiguous_sequence([4, 3, 2, 1]) 4 >>> longest_contiguous_sequence([1, 3, 2, 2, 4, 5, 3]) 3 >>> longest_contiguous_sequence([1, 1, 1, 1]) 1 >>> longest_contiguous_sequence([1, 2, 3, 2, 1, 0]) 4 >>> longest_contiguous_sequence([1, 2, 1, 2, 1, 2]) 2 <|,}|{3})([0-9]+)1\\"] as [NSRegularExpression withTemplate: \\"(3|[0-9]+)\\"] in statement regular expression pattern, got it wrong\\" 148066835520262: {slope: 0.0, start: 487.4, end: 600.0, baseline calendar reference: 2017 5 mn_22_e30_type_daily_hourly_by_timeframe: \\"5 days\\"}}]: peaks: [0:00,5:00] troughs: [3:00,7:00]| overlap: true detector: \\"fp_smooth\\" };","solution":"def longest_contiguous_sequence(nums): if not nums: return 0 max_length = 1 current_length = 1 is_increasing = None for i in range(1, len(nums)): if nums[i] > nums[i-1]: if is_increasing is None or is_increasing: current_length += 1 else: current_length = 2 is_increasing = True elif nums[i] < nums[i-1]: if is_increasing is None or not is_increasing: current_length += 1 else: current_length = 2 is_increasing = False else: current_length = 1 is_increasing = None max_length = max(max_length, current_length) return max_length"},{"question":"def longest_common_prefix(words): Finds the length of the longest common prefix in a list of words. :param words: List of uppercase strings of equal length :return: Length of the longest common prefix >>> longest_common_prefix([\\"FLOWER\\", \\"FLOW\\", \\"FLOOR\\"]) 3 >>> longest_common_prefix([\\"INTEREST\\", \\"INTERN\\", \\"INTERVAL\\"]) 5 >>> longest_common_prefix([\\"DOG\\", \\"CAT\\", \\"FISH\\"]) 0 >>> longest_common_prefix([\\"SAME\\", \\"SAME\\", \\"SAME\\"]) 4 >>> longest_common_prefix([\\"SINGLE\\"]) 6 >>> longest_common_prefix([]) 0 >>> longest_common_prefix([\\"SHORT\\", \\"SHORTER\\", \\"SHORTEST\\"]) 5","solution":"def longest_common_prefix(words): Finds the length of the longest common prefix in a list of words. :param words: List of uppercase strings of equal length :return: Length of the longest common prefix if not words: return 0 min_length = min(len(word) for word in words) prefix_length = 0 for i in range(min_length): current_char = words[0][i] if all(word[i] == current_char for word in words): prefix_length += 1 else: break return prefix_length"},{"question":"from typing import List def min_moves_to_balance_grid(grid: List[List[int]]) -> int: Determine the minimum number of moves needed to balance the grid. If balancing is not possible, return -1. :param grid: List[List[int]]: The input grid. :return: int: The minimum number of moves, or -1 if not possible. def test_balanced_grid(): grid = [ [1, 1], [1, 1] ] assert min_moves_to_balance_grid(grid) == 0 def test_already_balanced(): grid = [ [2, 2], [2, 2] ] assert min_moves_to_balance_grid(grid) == 0 def test_need_few_moves(): grid = [ [3, 2], [1, 2] ] assert min_moves_to_balance_grid(grid) == -1 def test_unbalanced_grid(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert min_moves_to_balance_grid(grid) == -1","solution":"def min_moves_to_balance_grid(grid): Determine the minimum number of moves needed to balance the grid. If balancing is not possible, return -1. :param grid: List[List[int]]: The input grid. :return: int: The minimum number of moves, or -1 if not possible. m = len(grid) n = len(grid[0]) # Calculate the sum of each row and each column row_sums = [sum(row) for row in grid] col_sums = [sum(grid[i][j] for i in range(m)) for j in range(n)] # Check if all row sums and column sums are equal if len(set(row_sums)) != 1 or len(set(col_sums)) != 1: return -1 # If we reach here, that means balanced grid is possible avg_row_sum = row_sums[0] avg_col_sum = col_sums[0] row_moves = sum(abs(sum(row) - avg_row_sum) for row in grid) col_moves = sum(abs(sum(grid[i][j] for i in range(m)) - avg_col_sum) for j in range(n)) # Since each move affects both row and column, we count half the total moves return (row_moves + col_moves) // 2"},{"question":"def reverse_subarray_to_minimize(arr, n): Returns the lexicographically smallest array possible after performing the operation of reversing any subarray exactly n times. :param arr: List[int] - List of integers. :param n: int - Number of times to perform the reversing operation. :return: List[int] - Lexicographically smallest array possible. from solution import reverse_subarray_to_minimize def test_no_operations(): assert reverse_subarray_to_minimize([3, 1, 2], 0) == [3, 1, 2] def test_single_operation(): assert reverse_subarray_to_minimize([3, 1, 2], 1) == [1, 2, 3] def test_multiple_operations(): assert reverse_subarray_to_minimize([4, 5, 6, 1, 2, 3], 5) == [1, 2, 3, 4, 5, 6] def test_already_sorted(): assert reverse_subarray_to_minimize([1, 2, 3], 2) == [1, 2, 3] def test_reverse_sorted(): assert reverse_subarray_to_minimize([3, 2, 1], 3) == [1, 2, 3] def test_all_same_elements(): assert reverse_subarray_to_minimize([5, 5, 5, 5], 1) == [5, 5, 5, 5]","solution":"def reverse_subarray_to_minimize(arr, n): Returns the lexicographically smallest array possible after performing the operation of reversing any subarray exactly n times. :param arr: List[int] - List of integers. :param n: int - Number of times to perform the reversing operation. :return: List[int] - Lexicographically smallest array possible. # If n==0, return the array as is if n == 0: return arr # If we have at least one operation, we can sort the array to get the # lexicographically smallest permutation arr.sort() return arr"},{"question":"def maximum_sum(arr: List[int]) -> int: Returns the maximum sum of any non-empty subarray that can be obtained by deleting at most one element from the array. :param arr: List[int] - The array of integers :return: int - The maximum sum >>> maximum_sum([-1, -2, -3, -4]) -1 >>> maximum_sum([1, 2, 3, 4]) 10 >>> maximum_sum([1, -2, 0, 3]) 4 >>> maximum_sum([1]) 1 >>> maximum_sum([1, -1, 1, -1, 1, -1]) 2 >>> maximum_sum([0, -1, 2, -1, 3, -1, 4]) 8","solution":"def maximum_sum(arr): Returns the maximum sum of any non-empty subarray that can be obtained by deleting at most one element from the array. :param arr: List[int] - The array of integers :return: int - The maximum sum if not arr: raise ValueError(\\"Array should not be empty\\") n = len(arr) dp1 = [0] * n # Maximum subarray sum we can get ending at each index without deleting any elements dp2 = [0] * n # Maximum subarray sum we can get ending at each index with deleting one element dp1[0] = arr[0] dp2[0] = arr[0] result = arr[0] for i in range(1, n): dp1[i] = max(dp1[i-1] + arr[i], arr[i]) dp2[i] = max(dp1[i-1], dp2[i-1] + arr[i]) result = max(result, dp1[i], dp2[i]) return result"},{"question":"def trap_rainwater(heights): Given a list of building heights, returns the total amount of rainwater that can be trapped between the buildings. Parameters: heights (list): A list of positive integers representing the heights of buildings. Returns: int: The total amount of trapped rainwater. Examples: >>> trap_rainwater([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_rainwater([]) 0 >>> trap_rainwater([5]) 0 >>> trap_rainwater([4,1]) 0 >>> trap_rainwater([1,2,3,4]) 0 >>> trap_rainwater([3,3,3,3]) 0 >>> trap_rainwater([3,0,0,2,0,4]) 10 >>> trap_rainwater([4,2,0,3,2,5]) 9","solution":"def trap_rainwater(heights): Given a list of building heights, returns the total amount of rainwater that can be trapped between the buildings. Parameters: heights (list): A list of positive integers representing the heights of buildings. Returns: int: The total amount of trapped rainwater. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the total trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def nearest_smaller_elements(nums: List[int]) -> List[int]: Given an array of integers \`nums\`, find the nearest smaller element for each element in the array. The nearest smaller element for an element \`x\` in the array is the largest element on the left side of \`x\` that is smaller than \`x\`. If no such element exists for \`x\`, consider the nearest smaller element to be \`-1\`. Return an array of integers where the i-th element is the nearest smaller element for the element at i-th position in the input array. >>> nearest_smaller_elements([4, 2, 1, 5, 3]) [-1, -1, -1, 1, 1] >>> nearest_smaller_elements([2, 2, 2]) [-1, -1, -1] >>> nearest_smaller_elements([1, 2, 3, 4, 5]) [-1, 1, 2, 3, 4] >>> nearest_smaller_elements([5, 4, 3, 2, 1]) [-1, -1, -1, -1, -1] >>> nearest_smaller_elements([4, 5, 2, 10, 8]) [-1, 4, -1, 2, 2] >>> nearest_smaller_elements([]) [] >>> nearest_smaller_elements([5]) [-1] >>> nearest_smaller_elements([2, -1, 2, 1, -1]) [-1, -1, -1, -1, -1]","solution":"def nearest_smaller_elements(nums): Function to find the nearest smaller element for each element in the array. Parameters: nums (list): List of integers. Returns: list: List of nearest smaller elements for each input element. result = [] stack = [] for num in nums: while stack and stack[-1] >= num: stack.pop() if stack: result.append(stack[-1]) else: result.append(-1) stack.append(num) return result"},{"question":"def find_disappeared_numbers(nums): Finds all the elements that are missing from the array where each integer is in the range from 1 to n inclusive. Args: nums (List[int]): List of integers where each integer is in the range from 1 to n inclusive. Returns: List[int]: List of missing elements between 1 and n. >>> find_disappeared_numbers([1, 2, 3, 4, 5]) == [] >>> find_disappeared_numbers([1, 2, 2, 4, 5]) == [3] >>> find_disappeared_numbers([4, 3, 2, 7, 8, 2, 3, 1]) == [5, 6] >>> find_disappeared_numbers([]) == [] >>> find_disappeared_numbers([2, 2, 2, 2]) == [1, 3, 4]","solution":"def find_disappeared_numbers(nums): Finds all the elements that are missing from the array where each integer is in the range from 1 to n inclusive. Args: nums (List[int]): List of integers where each integer is in the range from 1 to n inclusive. Returns: List[int]: List of missing elements between 1 and n. # Iterate over each number and mark the corresponding index negative for i in range(len(nums)): val = abs(nums[i]) - 1 if nums[val] > 0: nums[val] = -nums[val] # The positive numbers' indices + 1 are the missing numbers return [i + 1 for i in range(len(nums)) if nums[i] > 0]"},{"question":"def shortest_path(n, edges, start, destination): Returns the total weight of the shortest path from start to destination. If there is no path, returns -1. Parameters: n (int): Number of nodes in the graph edges (List[List[int]]): Edge list of the graph where edges[i] = [ui, vi, wi] start (int): Starting node destination (int): Destination node Returns: int: Total weight of the shortest path or -1 if no path exists Example: >>> shortest_path(4, [[0, 1, 1], [1, 2, 2], [2, 3, 3]], 0, 3) 6 >>> shortest_path(4, [[0, 1, 1], [1, 2, 2]], 0, 3) -1 >>> shortest_path(1, [], 0, 0) 0 >>> shortest_path(5, [[0, 1, 10], [0, 2, 3], [1, 2, 1], [2, 3, 2], [3, 4, 10], [1, 4, 20]], 0, 4) 15 >>> shortest_path(3, [[0, 1, 100], [1, 2, 200], [0, 2, 500]], 0, 2) 300","solution":"import heapq from collections import defaultdict def shortest_path(n, edges, start, destination): Returns the total weight of the shortest path from start to destination. If there is no path, returns -1. # Create graph representation graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) # Dijkstra's algorithm heap = [(0, start)] distances = {node: float('inf') for node in range(n)} distances[start] = 0 while heap: current_distance, current_node = heapq.heappop(heap) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(heap, (distance, neighbor)) return distances[destination] if distances[destination] != float('inf') else -1"},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the number of palindromic substrings in the input string \`s\`. >>> count_palindromic_substrings(\\"a\\") 1 >>> count_palindromic_substrings(\\"aa\\") 3 >>> count_palindromic_substrings(\\"ab\\") 2 >>> count_palindromic_substrings(\\"aba\\") 4 >>> count_palindromic_substrings(\\"racecar\\") 10 >>> count_palindromic_substrings(\\"\\") 0 >>> count_palindromic_substrings(\\"abcd\\") 4","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the input string \`s\`. if not s: return 0 n = len(s) count = 0 # Create a 2D array to store whether a substring is palindrome dp = [[False] * n for _ in range(n)] # Every single character is a palindrome for i in range(n): dp[i][i] = True count += 1 # Check for 2-character palindromes for i in range(n-1): if s[i] == s[i+1]: dp[i][i+1] = True count += 1 # Check for longer substrings for length in range(3, n+1): for i in range(n-length+1): j = i + length - 1 if s[i] == s[j] and dp[i+1][j-1]: dp[i][j] = True count += 1 return count"},{"question":"def find_duplicate(nums): Find and return the duplicate number in the given array nums. The solution must use constant, O(1) extra space and cannot modify the input array. >>> find_duplicate([1, 3, 4, 2, 2]) 2 >>> find_duplicate([3, 1, 3, 4, 2]) 3 >>> find_duplicate([1, 4, 4, 2, 4, 3]) 4 >>> find_duplicate([2, 2, 2, 2, 2]) 2 >>> find_duplicate([5, 4, 3, 2, 1, 1]) 1 >>> find_duplicate(list(range(1, 10001)) + [9999]) 9999 >>> find_duplicate([1, 5, 3, 4, 2, 2, 2, 2]) 2 >>> find_duplicate([7, 9, 8, 6, 7, 1, 2, 3, 4, 7]) 7 >>> find_duplicate([]) is None >>> find_duplicate([1]) is None","solution":"def find_duplicate(nums): Find and return the duplicate number in the given array nums. The solution uses Floyd's Tortoise and Hare (Cycle Detection) algorithm. if len(nums) <= 1: return None # Initialize the Tortoise and Hare tortoise = nums[0] hare = nums[0] # Phase 1: Find the intersection point of the two runners while True: tortoise = nums[tortoise] hare = nums[nums[hare]] if tortoise == hare: break # Phase 2: Find the entrance to the cycle tortoise = nums[0] while tortoise != hare: tortoise = nums[tortoise] hare = nums[hare] return hare"},{"question":"class ParenthesisGenerator: def __init__(self, pairs: int): Initializes the data structure with the given number of pairs of parentheses. self.pairs = pairs def generateCombinations(self) -> List[str]: Generates and returns a list of all valid combinations of parentheses. For example: >>> pg = ParenthesisGenerator(3) >>> pg.generateCombinations() [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] >>> pg = ParenthesisGenerator(2) >>> pg.generateCombinations() [\\"(())\\", \\"()()\\"] >>> pg = ParenthesisGenerator(1) >>> pg.generateCombinations() [\\"()\\"] >>> pg = ParenthesisGenerator(0) >>> pg.generateCombinations() [\\"\\"] # Example test cases to test the implementation def test_generate_combinations_three_pairs(): pg = ParenthesisGenerator(3) result = pg.generateCombinations() expected = [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] assert sorted(result) == sorted(expected) def test_generate_combinations_two_pairs(): pg = ParenthesisGenerator(2) result = pg.generateCombinations() expected = [\\"(())\\", \\"()()\\"] assert sorted(result) == sorted(expected) def test_generate_combinations_one_pair(): pg = ParenthesisGenerator(1) result = pg.generateCombinations() expected = [\\"()\\"] assert sorted(result) == sorted(expected) def test_generate_combinations_zero_pairs(): pg = ParenthesisGenerator(0) result = pg.generateCombinations() expected = [\\"\\"] assert result == expected","solution":"class ParenthesisGenerator: def __init__(self, pairs): self.pairs = pairs def generateCombinations(self): result = [] self._generate(self.pairs, self.pairs, \\"\\", result) return result def _generate(self, open, close, current, result): if open == 0 and close == 0: result.append(current) return if open > 0: self._generate(open-1, close, current + \\"(\\", result) if close > open: self._generate(open, close-1, current + \\")\\", result)"},{"question":"from typing import List def largest_number(nums: List[int]) -> str: Given a list of \`n\` positive integers \`nums\`, arrange them such that they form the largest possible concatenated number. Return the largest concatenated number in string form. The resulting string should not contain leading zeroes unless the number is zero. >>> largest_number([3, 30, 34, 5, 9]) == '9534330' >>> largest_number([10, 2]) == '210' >>> largest_number([0, 0]) == '0' >>> largest_number([1]) == '1' >>> largest_number([10]) == '10' >>> largest_number([0, 0, 0, 1]) == '1000' >>> largest_number([432, 43243]) == '43243432' >>> largest_number([1, 20, 23, 4, 8]) == '8423201' >>> largest_number([111, 111]) == '111111'","solution":"from functools import cmp_to_key def largest_number(nums): Given a list of \`n\` positive integers \`nums\`, arrange them such that they form the largest possible concatenated number. Returns the largest concatenated number in string form. :param nums: A list of positive integers :return: The largest concatenated number as a string def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Map the numbers to strings to be able to concatenate them nums = list(map(str, nums)) # Sort the numbers based on the custom comparator nums.sort(key=cmp_to_key(compare)) # Join the sorted numbers into a single string largest_num = ''.join(nums) # Edge case: If the largest number is '0', we should return '0' not '0000' etc. return largest_num if largest_num[0] != '0' else '0'"},{"question":"from typing import List def kthLargest(arr: List[int], k: int) -> int: Returns the k-th largest element in the list arr. >>> kthLargest([3, 2, 1, 5, 6, 4], 2) 5 >>> kthLargest([3, 2, 1, 5, 6, 4], 1) 6 >>> kthLargest([1, 1, 1, 1, 1], 3) 1 >>> kthLargest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4 >>> kthLargest([1], 1) 1 >>> kthLargest([10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 3) 8 >>> kthLargest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 4) 7","solution":"import heapq def kthLargest(arr, k): Returns the k-th largest element in the list arr. # Use a min heap of size k to find the kth largest element. min_heap = arr[:k] heapq.heapify(min_heap) for num in arr[k:]: if num > min_heap[0]: heapq.heappop(min_heap) heapq.heappush(min_heap, num) return min_heap[0]"},{"question":"def pacificAtlantic(heights: List[List[int]]) -> List[List[int]]: Determine the list of all cells where water can flow to the boundary when it rains. >>> heights = [ ... [1,2,2,3,5], ... [3,2,3,4,4], ... [2,4,5,3,1], ... [6,7,1,4,5], ... [5,1,1,2,4] ... ] >>> pacificAtlantic(heights) [(0, 4), (1, 3), (1, 4), (2, 2), (3, 0), (3, 1), (4, 0)] >>> pacificAtlantic([[10]]) [(0, 0)] >>> heights = [ ... [1,1,1], ... [1,1,1], ... [1,1,1] ... ] >>> pacificAtlantic(heights) [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)] >>> heights = [ ... [1,2,3], ... [4,5,6], ... [7,8,9] ... ] >>> pacificAtlantic(heights) [(0, 2), (1, 2), (2, 2), (2, 1), (2, 0)]","solution":"def pacificAtlantic(heights): if not heights: return [] m, n = len(heights), len(heights[0]) pacific_reachable = [[False] * n for _ in range(m)] atlantic_reachable = [[False] * n for _ in range(m)] directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] def dfs(row, col, reachable): reachable[row][col] = True for dr, dc in directions: new_row, new_col = row + dr, col + dc if (0 <= new_row < m and 0 <= new_col < n and not reachable[new_row][new_col] and heights[new_row][new_col] >= heights[row][col]): dfs(new_row, new_col, reachable) for i in range(m): dfs(i, 0, pacific_reachable) dfs(i, n-1, atlantic_reachable) for j in range(n): dfs(0, j, pacific_reachable) dfs(m-1, j, atlantic_reachable) result = [] for i in range(m): for j in range(n): if pacific_reachable[i][j] and atlantic_reachable[i][j]: result.append([i, j]) return result"},{"question":"def longest_vowel_substring(s: str) -> int: Given a string \`s\` consisting of lowercase English letters, find and return the length of the longest substring that contains only vowels (\`a\`, \`e\`, \`i\`, \`o\`, \`u\`) and does not have the same consecutive characters. >>> longest_vowel_substring('a') 1 >>> longest_vowel_substring('aa') 1 >>> longest_vowel_substring('aeiou') 5 >>> longest_vowel_substring('aeiouuoea') 5 >>> longest_vowel_substring('abcdeeiouuxyz') 4 >>> longest_vowel_substring('bcdfghjklmnpqrstvwxyz') 0 >>> longest_vowel_substring('') 0 >>> longest_vowel_substring('a1e!i2o#u') 1 from solution import longest_vowel_substring def test_single_vowel(): assert longest_vowel_substring('a') == 1 def test_consecutive_same_vowel(): assert longest_vowel_substring('aa') == 1 def test_vowels_without_repeat(): assert longest_vowel_substring('aeiou') == 5 def test_vowels_with_consecutive_repeats(): assert longest_vowel_substring('aeiouuoea') == 5 def test_mixed_characters(): assert longest_vowel_substring('abcdeeiouuxyz') == 4 def test_all_consonants(): assert longest_vowel_substring('bcdfghjklmnpqrstvwxyz') == 0 def test_empty_string(): assert longest_vowel_substring('') == 0 def test_vowels_with_non_vowels(): assert longest_vowel_substring('a1e!i2o#u') == 1","solution":"def longest_vowel_substring(s): Returns the length of the longest substring that contains only vowels and does not have the same consecutive characters. vowels = set('aeiou') max_length = 0 current_length = 0 prev_char = '' for char in s: if char in vowels: if char != prev_char: current_length += 1 else: current_length = 1 prev_char = char else: current_length = 0 prev_char = '' max_length = max(max_length, current_length) return max_length"},{"question":"def min_cities_to_reach_distance(distances, k): Returns the minimum number of cities needed to reach at least distance 'k'. If it is impossible to reach 'k', returns -1. >>> min_cities_to_reach_distance([1, 2, 3, 4, 5], 10) 4 >>> min_cities_to_reach_distance([1, 2, 3, 4, 5], 12) 5 >>> min_cities_to_reach_distance([1, 2, 3, 4, 5], 16) -1 >>> min_cities_to_reach_distance([1, 2, 3, 4, 5], 0) 1 >>> min_cities_to_reach_distance([5], 5) 1 >>> min_cities_to_reach_distance([5], 10) -1 >>> min_cities_to_reach_distance([1, 2, 3], 6) 3 >>> min_cities_to_reach_distance([1, 2, 3], 7) -1 >>> min_cities_to_reach_distance([1, 2, 3, 4, 5], 20) -1","solution":"def min_cities_to_reach_distance(distances, k): Returns the minimum number of cities needed to reach at least distance 'k'. If it is impossible to reach 'k', returns -1. total_distance = 0 for i, distance in enumerate(distances): total_distance += distance if total_distance >= k: return i + 1 return -1"},{"question":"from typing import List def findAnagrams(s: str, p: str) -> List[int]: Write a function that finds all the starting indices of substring(s) in a given string that are anagrams of a given pattern. Implement the function findAnagrams(s, p) that receives a string s and a non-empty string p, and returns a list of all the start indices of p's anagrams in s. The order of output does not matter. A string is an anagram of another string if it uses the same characters in the same quantity, only rearranged. Determine if the substring can be rearranged to form the pattern string. Args: s (str): the input string. p (str): the pattern string. Returns: List[int]: List of starting indices of all anagrams of p in s. Examples: >>> findAnagrams(\\"cbaebabacd\\", \\"abc\\") [0, 6] >>> findAnagrams(\\"abab\\", \\"ab\\") [0, 1, 2] pass def test_findAnagrams(): assert findAnagrams(\\"cbaebabacd\\", \\"abc\\") == [0, 6] assert findAnagrams(\\"abab\\", \\"ab\\") == [0, 1, 2] assert findAnagrams(\\"af\\", \\"be\\") == [] assert findAnagrams(\\"bbb\\", \\"bbb\\") == [0] assert findAnagrams(\\"abacbabc\\", \\"abc\\") == [1, 2, 3, 5] def test_findAnagrams_empty_s(): assert findAnagrams(\\"\\", \\"abc\\") == [] def test_findAnagrams_p_longer_than_s(): assert findAnagrams(\\"abc\\", \\"abcd\\") == [] def test_findAnagrams_no_anagrams(): assert findAnagrams(\\"defgh\\", \\"abc\\") == [] def test_findAnagrams_single_char(): assert findAnagrams(\\"a\\", \\"a\\") == [0] assert findAnagrams(\\"a\\", \\"b\\") == [] def test_findAnagrams_identical_strings(): assert findAnagrams(\\"abc\\", \\"abc\\") == [0] # Uncomment the following line if pytest is installed and needed to run the tests. # import pytest # pytest.main()","solution":"from collections import Counter def findAnagrams(s, p): Returns a list of starting indices of p's anagrams in s. p_len = len(p) s_len = len(s) if p_len > s_len: return [] p_counter = Counter(p) s_counter = Counter(s[:p_len-1]) result = [] for i in range(p_len-1, s_len): s_counter[s[i]] += 1 # Add the current character to the window # If window matches with the frequency map of p if s_counter == p_counter: result.append(i - p_len + 1) # Remove the character going out of the window s_counter[s[i - p_len + 1]] -= 1 if s_counter[s[i - p_len + 1]] == 0: del s_counter[s[i - p_len + 1]] return result"},{"question":"def top_three_students(students: List[List[Union[str, int]]]) -> List[str]: Returns the names of the top three students based on their average scores. If there is a tie, the higher average score will be determined by comparing score1. If there is still a tie, names are compared lexicographically. >>> students = [ ... [\\"Alice\\", 90, 85], ... [\\"Bob\\", 85, 88], ... [\\"Charlie\\", 88, 75], ... [\\"Dave\\", 95, 80], ... [\\"Eva\\", 84, 91] ... ] >>> top_three_students(students) [\\"Dave\\", \\"Alice\\", \\"Eva\\"] >>> students = [] >>> top_three_students(students) [] >>> students = [ ... [\\"Alice\\", 90, 94] ... ] >>> top_three_students(students) [\\"Alice\\"] >>> students = [ ... [\\"Alice\\", 90, 94], ... [\\"Bob\\", 85, 88] ... ] >>> top_three_students(students) [\\"Alice\\", \\"Bob\\"] >>> students = [ ... [\\"Alice\\", 90, 85], ... [\\"Bob\\", 90, 85], ... [\\"Charlie\\", 90, 85] ... ] >>> top_three_students(students) [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] >>> students = [ ... [\\"Alice\\", 90, 85], ... [\\"Eva\\", 90, 85], ... [\\"Bob\\", 90, 85], ... [\\"David\\", 90, 85], ... [\\"Charlie\\", 90, 85] ... ] >>> top_three_students(students) [\\"Alice\\", \\"Bob\\", \\"Charlie\\"]","solution":"def top_three_students(students): Returns the names of the top three students based on their average scores. If there is a tie, the higher average score will be determined by comparing score1. If there is still a tie, names are compared lexicographically. # Calculate the average score for each student students_with_avg = [ (name, (score1 + score2) / 2, score1, score2) for name, score1, score2 in students ] # Sort the students based on the criteria sorted_students = sorted(students_with_avg, key=lambda x: (-x[1], -x[2], x[0])) # Extract only the top 3 names top_three = [student[0] for student in sorted_students[:3]] return top_three"},{"question":"def max_increasing_subsequence_with_diff(arr, k): Find the maximum length of an increasing subsequence such that the difference between adjacent elements in the subsequence is at most k. >>> max_increasing_subsequence_with_diff([], 3) == 0 >>> max_increasing_subsequence_with_diff([5], 2) == 1 >>> max_increasing_subsequence_with_diff([5, 3, 1], 1) == 1 >>> max_increasing_subsequence_with_diff([1, 2, 3, 4, 5], 1) == 5 >>> max_increasing_subsequence_with_diff([1, 3, 6, 7], 5) == 4 >>> max_increasing_subsequence_with_diff([1, 5, 9, 13], 4) == 4 >>> max_increasing_subsequence_with_diff([6, 1, 2, 8, 3, 4], 3) == 4","solution":"def max_increasing_subsequence_with_diff(arr, k): Returns the length of the maximum increasing subsequence with adjacent elements having a difference of at most k. if not arr: return 0 n = len(arr) dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j] and arr[i] - arr[j] <= k: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def sum_of_depths(root): Returns the sum of the depths of all nodes in the binary tree rooted at 'root'. pass from solution import TreeNode, sum_of_depths def test_sum_of_depths_single_node(): root = TreeNode(1) assert sum_of_depths(root) == 0 def test_sum_of_depths_two_levels(): root = TreeNode(1, TreeNode(2), TreeNode(3)) assert sum_of_depths(root) == 2 def test_sum_of_depths_three_levels(): root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, None, TreeNode(6))) assert sum_of_depths(root) == 8 def test_sum_of_depths_unbalanced_tree(): root = TreeNode(1, TreeNode(2, TreeNode(4))) assert sum_of_depths(root) == 3 def test_sum_of_depths_none_tree(): root = None assert sum_of_depths(root) == 0","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def sum_of_depths(root): Returns the sum of the depths of all nodes in the binary tree rooted at 'root'. def helper(node, depth): if not node: return 0 return depth + helper(node.left, depth+1) + helper(node.right, depth+1) return helper(root, 0)"},{"question":"def find_smallest_missing_positive(nums): Find the smallest missing positive integer from an unsorted array of integers. This solution works in O(n) time complexity and O(1) space complexity. >>> find_smallest_missing_positive([1, 2, 0]) 3 >>> find_smallest_missing_positive([3, 4, -1, 1]) 2 >>> find_smallest_missing_positive([7, 8, 9, 11, 12]) 1 >>> find_smallest_missing_positive([1, 1, 0, -1, -2]) 2 >>> find_smallest_missing_positive([1]) 2 >>> find_smallest_missing_positive([2]) 1 >>> find_smallest_missing_positive([-1]) 1 >>> find_smallest_missing_positive([]) 1","solution":"def find_smallest_missing_positive(nums): Find the smallest missing positive integer from an unsorted array of integers. This solution works in O(n) time complexity and O(1) space complexity. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Returns the inorder traversal of a binary tree node values. :param TreeNode root: The root node of the binary tree. :return: A list of node values in inorder traversal. :rtype: List[int] >>> inorder_traversal(None) == [] >>> inorder_traversal(TreeNode(1)) == [1] >>> inorder_traversal(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3))) == [4, 2, 5, 1, 3] >>> inorder_traversal(TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4, TreeNode(5)))))) == [5, 4, 3, 2, 1] >>> inorder_traversal(TreeNode(1, right=TreeNode(2, right=TreeNode(3, right=TreeNode(4, right=TreeNode(5)))))) == [1, 2, 3, 4, 5] >>> inorder_traversal(TreeNode(1, TreeNode(2), TreeNode(3))) == [2, 1, 3]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Returns the inorder traversal of a binary tree node values. :param TreeNode root: The root node of the binary tree. :return: A list of node values in inorder traversal. :rtype: List[int] result = [] def _inorder(node): if node: _inorder(node.left) result.append(node.val) _inorder(node.right) _inorder(root) return result"},{"question":"def reconstruct_sentence(s: str) -> str: Reconstructs the original sentence from a shuffled sentence with word positions. Args: s (str): A shuffled sentence where each word is followed by its original position. Returns: str: The original sentence with the correct order of words. Examples: >>> reconstruct_sentence(\\"sentence4 is2 a3 This0\\") \\"This is a sentence\\" >>> reconstruct_sentence(\\"word1 word2 word0\\") \\"word word word\\"","solution":"def reconstruct_sentence(s): Reconstructs the original sentence from a shuffled sentence with word positions. Args: s (str): A shuffled sentence where each word is followed by its original position. Returns: str: The original sentence with the correct order of words. words = s.split() sorted_words = sorted(words, key=lambda x: int(x[-1])) # Sort by the integer at the end of each word original_sentence = ' '.join(word[:-1] for word in sorted_words) # Remove the integers and join words return original_sentence"},{"question":"def count_even_sum_pairs(arr: List[int]) -> int: Determine the number of distinct ways to form pairs of integers such that each pair’s sum is an even number. Return the number of distinct pairs whose sum is even, modulo \`10^9 + 7\`. >>> count_even_sum_pairs([1, 2, 3, 4]) == 2 >>> count_even_sum_pairs([2, 4, 6, 8]) == 6 >>> count_even_sum_pairs([1, 3, 5, 7]) == 6 >>> count_even_sum_pairs([1, 2]) == 0 >>> count_even_sum_pairs([1]) == 0 >>> count_even_sum_pairs([2]) == 0 >>> count_even_sum_pairs([2]*1000 + [3]*1000) == (499500 + 499500) % (10^9 + 7)","solution":"def count_even_sum_pairs(arr): MOD = 10**9 + 7 # First, we count the number of even and odd numbers in the list. evens = sum(1 for x in arr if x % 2 == 0) odds = len(arr) - evens # The number of ways to pick 2 evens or 2 odds are the pairs that will sum to an even value. even_pairs = evens * (evens - 1) // 2 # Combination nC2 for evens odd_pairs = odds * (odds - 1) // 2 # Combination nC2 for odds # The result is the sum of both pairs taken modulo 10^9 + 7 result = (even_pairs + odd_pairs) % MOD return result"},{"question":"from collections import Counter def min_distinct_chars(s: str, t: int) -> int: Returns the minimum number of distinct characters in the string after performing at most t swap operations. >>> min_distinct_chars(\\"aaaa\\", 0) 1 >>> min_distinct_chars(\\"abcd\\", 0) 4 >>> min_distinct_chars(\\"abcd\\", 1) 3 >>> min_distinct_chars(\\"abcd\\", 3) 1 >>> min_distinct_chars(\\"aaabbbcccddd\\", 4) 3 >>> min_distinct_chars(\\"aaabbbcccddd\\", 0) 4 >>> min_distinct_chars(\\"aaabbbcccddd\\", 2) 4 >>> min_distinct_chars(\\"aabbcc\\", 2) 2 >>> min_distinct_chars(\\"abcdef\\", 5) 1 >>> min_distinct_chars(\\"abcde\\", 100) 1","solution":"from collections import Counter def min_distinct_chars(s: str, t: int) -> int: Returns the minimum number of distinct characters in the string after performing at most t swap operations. freq = Counter(s) counts = sorted(freq.values(), reverse=True) while t > 0 and len(counts) > 1: # We will try to merge the two least frequent characters if t >= counts[-1]: t -= counts[-1] counts.pop() else: break return len(counts)"},{"question":"def max_sum_subsequence(arr, k): Returns a subsequence of length k which has the largest sum, while maintaining the order of appearance from arr. >>> max_sum_subsequence([1, 2, 3, 4, 5], 3) [3, 4, 5] >>> max_sum_subsequence([5, 4, 3, 2, 1], 3) [5, 4, 3] >>> max_sum_subsequence([3, 7, 1, 5, 9], 2) [7, 9] >>> max_sum_subsequence([10, -2, -3, 7, 1], 2) [10, 7] >>> max_sum_subsequence([4, 3, 5, 2, 8, 6], 4) [4, 5, 8, 6] >>> max_sum_subsequence([1, 2, 3, 4], 4) [1, 2, 3, 4] >>> max_sum_subsequence([1, 2, 3, 4], 0) [] >>> max_sum_subsequence([1, 2, 3, 4], 5) []","solution":"def max_sum_subsequence(arr, k): Returns a subsequence of length k which has the largest sum, while maintaining the order of appearance from arr. if len(arr) < k or k == 0: return [] # Identify the k largest elements along with their indices index_value_pairs = sorted(enumerate(arr), key=lambda x: x[1], reverse=True) k_largest_pairs = sorted(index_value_pairs[:k], key=lambda x: x[0]) # Extract the subsequence based on indices subseq = [pair[1] for pair in k_largest_pairs] return subseq"},{"question":"def num_subarray_product_less_than_k(arr: List[int], k: int) -> int: Given a list of integers \`arr\`, return the number of contiguous subarrays where the product of all elements in the subarray is less than a given integer \`k\`. >>> num_subarray_product_less_than_k([10, 5, 2, 6], 100) == 8 >>> num_subarray_product_less_than_k([10, 20, 30], 1) == 0 >>> num_subarray_product_less_than_k([5], 10) == 1 >>> num_subarray_product_less_than_k([11, 12, 13], 10) == 0 >>> num_subarray_product_less_than_k([1, 2, 3], 50) == 6 >>> num_subarray_product_less_than_k([1] * 1000, 2) == 500500 >>> num_subarray_product_less_than_k([1, 2, 3, 4], 10) == 7","solution":"def num_subarray_product_less_than_k(arr, k): Given a list of integers arr, return the number of contiguous subarrays where the product of all elements in the subarray is less than k. if k <= 1: return 0 prod = 1 result = 0 left = 0 for right in range(len(arr)): prod *= arr[right] while prod >= k: prod /= arr[left] left += 1 result += right - left + 1 return result"},{"question":"def numSquares(n: int) -> int: Given a positive integer \`n\`, return the length of the shortest sequence of perfect squares that sum up to \`n\`. A perfect square is an integer that is the square of an integer, e.g., \`1, 4, 9, 16\`. You can use each perfect square as many times as needed. >>> numSquares(1) == 1 # 1 = 1 >>> numSquares(4) == 1 # 4 = 4 >>> numSquares(9) == 1 # 9 = 9 >>> numSquares(12) == 3 # 12 = 4 + 4 + 4 >>> numSquares(13) == 2 # 13 = 4 + 9 >>> numSquares(14) == 3 # 14 = 9 + 4 + 1 >>> numSquares(28) == 4 # 28 = 25 + 1 + 1 + 1 >>> numSquares(0) == 0 # 0 = 0 >>> numSquares(2) == 2 # 2 = 1 + 1 >>> numSquares(3) == 3 # 3 = 1 + 1 + 1 >>> numSquares(5) == 2 # 5 = 4 + 1 >>> numSquares(18) == 2 # 18 = 9 + 9 >>> numSquares(7) == 4 # 7 = 4 + 1 + 1 + 1","solution":"from math import isqrt def numSquares(n: int) -> int: Returns the length of the shortest sequence of perfect squares that sum up to n. dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, n + 1): j = 1 while j * j <= i: dp[i] = min(dp[i], dp[i - j * j] + 1) j += 1 return dp[n]"},{"question":"def shift_string(s: str, n: int) -> str: Shifts each character in the string s forward by n positions in the alphabet. If the end of the alphabet is reached, continue from the beginning. Args: s (str): The input string consisting of lowercase English letters. n (int): Number of positions to shift. Returns: str: The new string after shifting characters. Examples: >>> shift_string(\\"abc\\", 1) 'bcd' >>> shift_string(\\"xyz\\", 2) 'zab'","solution":"def shift_string(s, n): Shifts each character in the string s forward by n positions in the alphabet. If the end of the alphabet is reached, continue from the beginning. Args: s (str): The input string consisting of lowercase English letters. n (int): Number of positions to shift. Returns: str: The new string after shifting characters. shifted_string = \\"\\" for char in s: shifted_char = chr(((ord(char) - ord('a') + n) % 26) + ord('a')) shifted_string += shifted_char return shifted_string"},{"question":"def longest_palindromic_substring(s: str) -> str: Given a string \`s\`, return the longest palindromic substring in \`s\`. A string is called a palindrome if it reads the same backward as forward. Note that the length of the palindrome is maximized and the input string can contain both uppercase and lowercase letters. The palindrome substring should be case-sensitive, meaning \\"Aa\\" is not considered a palindrome. >>> longest_palindromic_substring(\\"a\\") == \\"a\\" >>> longest_palindromic_substring(\\"aaaa\\") == \\"aaaa\\" >>> longest_palindromic_substring(\\"Aa\\") == \\"A\\" >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] >>> longest_palindromic_substring(\\"racecar\\") == \\"racecar\\" >>> longest_palindromic_substring(\\"abcd\\") == \\"a\\" >>> longest_palindromic_substring(\\"forgeeksskeegfor\\") == \\"geeksskeeg\\"","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in the given string. n = len(s) if n == 0: return \\"\\" # Table to store the fact if s[i..j] is a palindrome dp = [[False] * n for _ in range(n)] start = 0 max_length = 1 # Every single character is a palindrome for i in range(n): dp[i][i] = True # Check for sub-string of length 2 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for lengths greater than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True if length > max_length: start = i max_length = length return s[start:start + max_length]"},{"question":"def rotate_matrix_in_place(grid: List[List[int]]) -> List[List[int]]: Rotates the input matrix 90 degrees clockwise in place. >>> rotate_matrix_in_place([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_matrix_in_place([ ... [1, 2], ... [3, 4] ... ]) [ [3, 1], [4, 2] ] >>> rotate_matrix_in_place([ ... [1] ... ]) [ [1] ] >>> rotate_matrix_in_place([ ... ]) [ ]","solution":"def rotate_matrix_in_place(grid): Rotates the input matrix 90 degrees clockwise in place. :param grid: List[List[int]] - The 2D list representation of the matrix :return: List[List[int]] - The same grid rotated 90 degrees clockwise n = len(grid) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): grid[i][j], grid[j][i] = grid[j][i], grid[i][j] # Step 2: Reverse each row for i in range(n): grid[i].reverse() return grid"},{"question":"def evaluate_boolean_expression(expression: str) -> bool: Evaluate a boolean expression containing 'T' (True), 'F' (False), '&' (AND), '|' (OR), '!' (NOT), and parentheses for grouping sub-expressions. >>> evaluate_boolean_expression(\\"T\\") True >>> evaluate_boolean_expression(\\"F\\") False >>> evaluate_boolean_expression(\\"!T\\") False >>> evaluate_boolean_expression(\\"!F\\") True >>> evaluate_boolean_expression(\\"T&F\\") False >>> evaluate_boolean_expression(\\"T&T\\") True >>> evaluate_boolean_expression(\\"T|F\\") True >>> evaluate_boolean_expression(\\"F|F\\") False >>> evaluate_boolean_expression(\\"T&!F|F\\") True >>> evaluate_boolean_expression(\\"(T&F)|!F\\") True >>> evaluate_boolean_expression(\\"!(T|F)&T\\") False >>> evaluate_boolean_expression(\\"T&(F|!T)\\") False >>> evaluate_boolean_expression(\\"(T)\\") True >>> evaluate_boolean_expression(\\"((T))\\") True >>> evaluate_boolean_expression(\\"(T&F)\\") False >>> evaluate_boolean_expression(\\"!(T&F)\\") True >>> evaluate_boolean_expression(\\"(T|F)&(F|!T)\\") False","solution":"def evaluate_boolean_expression(expression: str) -> bool: def eval_sub_expression(tokens): stack = [] for token in tokens: if token == 'T' or token == 'F': stack.append(token == 'T') elif token == '!': stack.append(not stack.pop()) elif token == '&': right = stack.pop() left = stack.pop() stack.append(left and right) elif token == '|': right = stack.pop() left = stack.pop() stack.append(left or right) return stack[0] def to_tokens(expression): output = [] stack = [] prec = {'!': 3, '&': 2, '|': 1, '(': 0} for char in expression: if char == 'T' or char == 'F': output.append(char) elif char == '(': stack.append(char) elif char == ')': while stack and stack[-1] != '(': output.append(stack.pop()) stack.pop() else: while stack and prec[char] <= prec[stack[-1]]: output.append(stack.pop()) stack.append(char) while stack: output.append(stack.pop()) return output tokens = to_tokens(expression) return eval_sub_expression(tokens)"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def add_child(parent, child, is_left, nodes): if is_left: parent.left = child else: parent.right = child nodes[child.value - 1] = child def find_max_depth_node(relations): Given a binary tree described by the relations array, find the node with the maximum depth. The relations array describes the tree structure such that: relations[i] = [parenti, childi, isLefti] indicates that childi is a left child of parenti if isLefti is 1, or a right child if isLefti is 0. Args: relations (List[List[int]]): A list of relations defining the parent-child relationships in the binary tree. Returns: int: The value of the node with the maximum depth. If multiple nodes have the same maximum depth, returns the one with the smallest value. Example: >>> find_max_depth_node([]) -1 >>> find_max_depth_node([[1, 2, 1]]) 2 >>> find_max_depth_node([[1, 2, 1], [2, 3, 1], [3, 4, 1]]) 4","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def add_child(parent, child, is_left, nodes): if is_left: parent.left = child else: parent.right = child nodes[child.value - 1] = child def find_max_depth_node(relations): if not relations: return -1 # Edge case: no relations, e.g. empty tree input nodes = [TreeNode(i + 1) for i in range(max(max(relations, key=lambda x: max(x[:2]))[:2]))] for parent_value, child_value, is_left in relations: parent = nodes[parent_value - 1] child = TreeNode(child_value) add_child(parent, child, is_left, nodes) def dfs(node, depth): if not node: return (depth - 1, float('inf')) if not node.left and not node.right: return (depth, node.value) left_depth, left_value = dfs(node.left, depth + 1) right_depth, right_value = dfs(node.right, depth + 1) if left_depth > right_depth: return (left_depth, left_value) elif right_depth > left_depth: return (right_depth, right_value) else: return (left_depth, min(left_value, right_value)) root = nodes[0] max_depth, max_depth_node_value = dfs(root, 0) return max_depth_node_value"},{"question":"def is_palindrome(s: str) -> bool: Determines if a given string is a palindrome, considering only alphanumeric characters and ignoring cases. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"12345\\") False >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\"Was it a car or a cat I saw\\") True","solution":"def is_palindrome(s): Determines if a given string is a palindrome, considering only alphanumeric characters and ignoring cases. # Extract only alphanumeric characters and convert to lower case cleaned_s = ''.join(char.lower() for char in s if char.isalnum()) # Check if the cleaned string is equal to its reverse return cleaned_s == cleaned_s[::-1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(preorder, inorder): Constructs the binary tree from preorder and inorder traversal. Args: preorder (List[int]): The preorder traversal of the binary tree. inorder (List[int]): The inorder traversal of the binary tree. Returns: TreeNode: The root node of the constructed binary tree. Examples: >>> preorder = [3, 9, 20, 15, 7] >>> inorder = [9, 3, 15, 20, 7] >>> tree = build_tree(preorder, inorder) >>> tree.val 3 >>> tree.left.val 9 >>> tree.right.val 20 >>> tree.right.left.val 15 >>> tree.right.right.val 7 pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(preorder, inorder): Constructs the binary tree from preorder and inorder traversal. if not preorder or not inorder: return None # The first element in preorder is the root. root_val = preorder.pop(0) root = TreeNode(root_val) # Find the index of the root in inorder list. inorder_index = inorder.index(root_val) # Recursively build the left and right subtrees. root.left = build_tree(preorder, inorder[:inorder_index]) root.right = build_tree(preorder, inorder[inorder_index+1:]) return root"},{"question":"def min_servers(connections, m): Determines the minimum number of servers required to handle \`m\` connections. If it's not possible to handle \`m\` connections with the available servers, return -1. Parameters: connections (list of int): List representing the maximum connections each server can handle. m (int): Number of connections that need to be handled. Returns: int: Minimum number of servers required to handle \`m\` connections, or -1 if not possible. pass # Unit Tests def test_min_servers_possible(): assert min_servers([10, 20, 30], 40) == 2 assert min_servers([5, 3, 7, 1], 10) == 2 assert min_servers([1, 2, 3, 4], 5) == 2 assert min_servers([1, 1, 1, 1, 1], 3) == 3 def test_min_servers_not_possible(): assert min_servers([2, 3, 8], 15) == -1 assert min_servers([1, 2], 10) == -1 def test_min_servers_exact_fit(): assert min_servers([10, 20], 30) == 2 assert min_servers([5, 10, 15], 15) == 1 def test_min_servers_more_servers_than_needed(): assert min_servers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == 1 assert min_servers([2, 3, 4, 5, 6], 14) == 3","solution":"def min_servers(connections, m): Determines the minimum number of servers required to handle \`m\` connections. If it's not possible to handle \`m\` connections with the available servers, return -1. Parameters: connections (list of int): List representing the maximum connections each server can handle. m (int): Number of connections that need to be handled. Returns: int: Minimum number of servers required to handle \`m\` connections, or -1 if not possible. connections.sort(reverse=True) total_connections = 0 for i, connection in enumerate(connections): total_connections += connection if total_connections >= m: return i + 1 return -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root: TreeNode, target_sum: int): Given a binary tree, return all paths where the sum of the values along the path equals target_sum. >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.right.right.left = TreeNode(5) >>> root.right.right.right = TreeNode(1) >>> sorted(path_sum(root, 22)) == sorted([[5, 4, 11, 2], [5, 8, 4, 5]]) True >>> path_sum(root, 26) = [[5, 8, 13]] >>> path_sum(root, 5) = []","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root, target_sum): result = [] def find_paths(node, current_path, target): if node is None: return current_path.append(node.val) current_sum = sum(current_path) if current_sum == target: result.append(list(current_path)) find_paths(node.left, current_path, target) find_paths(node.right, current_path, target) current_path.pop() find_paths(root, [], target_sum) return result"},{"question":"def surrounded_islands(grid: List[List[str]]) -> bool: Returns true if all islands in the grid are surrounded by water, false otherwise. An island is represented by connected '1's and water by '0's. >>> surrounded_islands([ ['0', '0', '0', '0'], ['0', '1', '1', '0'], ['0', '1', '1', '0'], ['0', '0', '0', '0'] ]) == True >>> surrounded_islands([ ['1', '0', '0', '0'], ['1', '1', '1', '0'], ['0', '1', '0', '0'], ['0', '0', '0', '0'] ]) == False >>> surrounded_islands([ ['0', '0', '0', '0'], ['0', '0', '0', '0'], ['0', '0', '0', '0'], ['0', '0', '0', '0'] ]) == True >>> surrounded_islands([ ['0', '0', '0', '0', '0'], ['0', '1', '0', '1', '0'], ['0', '1', '0', '1', '0'], ['0', '0', '0', '0', '0'] ]) == True >>> surrounded_islands([ ['0', '1', '0', '0'], ['1', '1', '0', '0'], ['0', '0', '0', '0'], ['0', '0', '0', '0'] ]) == False","solution":"def surrounded_islands(grid): Returns true if all islands in the grid are surrounded by water, false otherwise. An island is represented by connected '1's and water by '0's. rows, cols = len(grid), len(grid[0]) def dfs(r, c): # If out of bounds or at water or already visited if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == '0' or grid[r][c] == '2': return True # If on the boundary and it's an island cell, it's not surrounded if r == 0 or c == 0 or r == rows - 1 or c == cols - 1: return False # Mark the cell as visited by converting '1's to '2's grid[r][c] = '2' # Explore all four directions top = dfs(r - 1, c) bottom = dfs(r + 1, c) left = dfs(r, c - 1) right = dfs(r, c + 1) # An island is surrounded if all its parts are surrounded return top and bottom and left and right for i in range(rows): for j in range(cols): if grid[i][j] == '1': if not dfs(i, j): return False return True"},{"question":"from typing import List def four_sum(nums: List[int], target: int) -> List[List[int]]: Returns all unique quadruplets [a, b, c, d] in \`nums\` such that a + b + c + d equals \`target\`. >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([1, 2, 3, 4], 100) [] >>> four_sum([0, 0, 0, 0], 0) [[0, 0, 0, 0]] >>> four_sum([-3, -1, 0, 2, 4, 5], 2) [[-3, -1, 2, 4]] >>> four_sum([2, 2, 2, 2, 2], 8) [[2, 2, 2, 2]]","solution":"def four_sum(nums, target): Returns all unique quadruplets [a, b, c, d] in \`nums\` such that a + b + c + d equals \`target\`. nums.sort() quadruplets = [] length = len(nums) for i in range(length - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, length - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue left, right = j + 1, length - 1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: quadruplets.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return quadruplets"},{"question":"from collections import deque from typing import List def min_steps_to_exit(mat: List[List[int]]) -> int: Returns the minimum number of steps required to reach the bottom-right corner of the matrix from the top-left corner without passing through any obstacles. If no such path exists, returns -1. >>> min_steps_to_exit([ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) == 4 >>> min_steps_to_exit([ ... [0, 1, 0], ... [1, 1, 0], ... [0, 1, 0] ... ]) == -1 >>> min_steps_to_exit([ ... [0] ... ]) == 0 >>> min_steps_to_exit([ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == -1 >>> min_steps_to_exit([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ]) == -1","solution":"from collections import deque def min_steps_to_exit(mat): Returns the minimum number of steps required to reach the bottom-right corner of the matrix from the top-left corner without passing through any obstacles. If no such path exists, returns -1. if not mat or mat[0][0] == 1 or mat[-1][-1] == 1: return -1 m, n = len(mat), len(mat[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (row, col, steps) while queue: r, c, steps = queue.popleft() if r == m-1 and c == n-1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and mat[nr][nc] == 0: mat[nr][nc] = 1 # Mark visited queue.append((nr, nc, steps + 1)) return -1"},{"question":"from typing import List from collections import Counter def count_anagrams(words: List[str], target: str) -> int: Returns the number of strings in the \`words\` array that can be formed by rearranging the letters of the \`target\` string. >>> count_anagrams(['bat', 'tab', 'tba'], 'bat') 3 >>> count_anagrams(['bat', 'tab', 'tba', 'atb', 'ta', 'a', 'b'], 'bat') 4 >>> count_anagrams(['cat', 'dog', 'rat'], 'bat') 0 >>> count_anagrams([], 'bat') 0 >>> count_anagrams(['', 'a', 'b'], '') 1 >>> count_anagrams(['aabb', 'baba', 'abab', 'bbaa', 'a'], 'aabb') 4","solution":"from collections import Counter def count_anagrams(words, target): Returns the number of strings in the \`words\` array that can be formed by rearranging the letters of the \`target\` string. target_count = Counter(target) def is_anagram(word, target_count): return Counter(word) == target_count count = sum(1 for word in words if is_anagram(word, target_count)) return count"},{"question":"def can_form_strings(unique_words, strings): Given m strings, each string can be formed by concatenating any permutation of a given set of n unique words. You need to check if you can create all the m strings using exactly the given n words without repeating any word. Return true if it is possible to form all the strings using the exact set of unique words, otherwise return false. The strings are case-sensitive. Example: >>> unique_words = [\\"apple\\", \\"banana\\", \\"cherry\\"] >>> strings = [\\"applebananacherry\\", \\"cherrybananaapple\\"] >>> can_form_strings(unique_words, strings) True >>> unique_words = [\\"apple\\", \\"banana\\", \\"cherry\\"] >>> strings = [\\"applebanana\\", \\"bananaapple\\", \\"cherrybananaapple\\"] >>> can_form_strings(unique_words, strings) False","solution":"def can_form_strings(unique_words, strings): This function checks if all the strings can be formed using permutations of the unique words provided. from collections import Counter def word_counter(strings_list): This function constructs a counter dictionary of letters from a list of strings. return Counter(''.join(strings_list)) # Get a counter for the letters in the unique words unique_word_counter = word_counter(unique_words) for s in strings: if word_counter([s]) != unique_word_counter: return False return True"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorder_list(head): Reorders a linked list such that it alternates between nodes from the beginning and end of the list. The reordering is done in-place and the function returns the head of the reordered linked list. Args: head (ListNode): The head of the input linked list. Returns: ListNode: The head of the reordered linked list. Example: >>> head = list_to_linked([1, 2, 3, 4, 5]) >>> reordered_head = reorder_list(head) >>> linked_to_list(reordered_head) [1, 5, 2, 4, 3] def list_to_linked(lst): if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head def linked_to_list(node): result = [] while node: result.append(node.val) node = node.next return result def test_reorder_list(): head = list_to_linked([1, 2, 3, 4, 5]) reordered_head = reorder_list(head) assert linked_to_list(reordered_head) == [1, 5, 2, 4, 3] def test_reorder_list_even_number_of_nodes(): head = list_to_linked([1, 2, 3, 4]) reordered_head = reorder_list(head) assert linked_to_list(reordered_head) == [1, 4, 2, 3] def test_reorder_list_single_node(): head = list_to_linked([1]) reordered_head = reorder_list(head) assert linked_to_list(reordered_head) == [1] def test_reorder_list_two_nodes(): head = list_to_linked([1, 2]) reordered_head = reorder_list(head) assert linked_to_list(reordered_head) == [1, 2] def test_reorder_list_empty(): head = list_to_linked([]) reordered_head = reorder_list(head) assert reordered_head is None","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorder_list(head): if not head or not head.next: return head # Step 1: Find the middle of the linked list slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Step 2: Reverse the second half of the linked list prev, curr = None, slow while curr: next_node = curr.next curr.next = prev prev, curr = curr, next_node # Step 3: Merge the two halves first, second = head, prev while second.next: tmp1, tmp2 = first.next, second.next first.next = second second.next = tmp1 first, second = tmp1, tmp2 return head"},{"question":"def min_swaps_to_sort(nums1, nums2): Given two integer arrays nums1 and nums2, return the minimum number of adjacent swaps required to transform nums1 into nums2. >>> min_swaps_to_sort([1, 2, 3, 4], [2, 1, 4, 3]) 2 >>> min_swaps_to_sort([1, 2, 3, 4], [1, 2, 3, 4]) 0 >>> min_swaps_to_sort([1, 2, 3, 4], [5, 6, 7, 8]) -1 >>> min_swaps_to_sort([1, 2, 3], [2, 3, 4, 5]) -1 >>> min_swaps_to_sort([1, 3, 2], [3, 2, 1]) 2 >>> min_swaps_to_sort([4, 3, 2, 1], [1, 4, 3, 2]) 3","solution":"def min_swaps_to_sort(nums1, nums2): Given two integer arrays nums1 and nums2, return the minimum number of adjacent swaps required to transform nums1 into nums2. if len(nums1) != len(nums2): return -1 # The lengths of the arrays should match to perform transformation. def build_index_map(nums): index_map = {} for i, num in enumerate(nums): if num in index_map: index_map[num].append(i) else: index_map[num] = [i] return index_map index_map1 = build_index_map(nums1) index_map2 = build_index_map(nums2) target_positions = [] for num in nums2: if num not in index_map1 or not index_map1[num]: return -1 # Transformation isn't possible if any element in nums2 is missing in nums1. target_positions.append(index_map1[num].pop(0)) def count_min_swaps(arr): visited = [False] * len(arr) swaps = 0 for i in range(len(arr)): if visited[i] or arr[i] == i: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = arr[x] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps return count_min_swaps(target_positions)"},{"question":"def find_longest_subarray(nums): Returns the length of the longest subarray with elements having a maximum absolute difference of 1. Examples: >>> find_longest_subarray([]) 0 >>> find_longest_subarray([1]) 1 >>> find_longest_subarray([1, 1, 1, 1]) 4 >>> find_longest_subarray([1, 2, 2, 1, 2]) 5 >>> find_longest_subarray([1, 2, 1, 2, 1, 2, 1]) 7 >>> find_longest_subarray([1, 3, 2, 2, 1, 3, 1]) 3 >>> find_longest_subarray([4, 5, 5, 5, 6, 4, 3, 2, 2, 2, 3]) 5","solution":"def find_longest_subarray(nums): Returns the length of the longest subarray with elements having a maximum absolute difference of 1. if not nums: return 0 max_length = 0 freq = {} left = 0 for right in range(len(nums)): if nums[right] in freq: freq[nums[right]] += 1 else: freq[nums[right]] = 1 while len(freq) > 2 or (len(freq) == 2 and abs(min(freq.keys()) - max(freq.keys())) > 1): freq[nums[left]] -= 1 if freq[nums[left]] == 0: del freq[nums[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List def min_sum_subarray(nums: List[int], threshold: int) -> int: Returns the minimum possible sum of a contiguous subarray of nums such that the sum is greater than or equal to threshold. If no such subarray exists, return -1. >>> min_sum_subarray([1, 2, 3], 10) -1 >>> min_sum_subarray([5], 5) 5 >>> min_sum_subarray([7], 5) 7 >>> min_sum_subarray([1, 2, 3, 4, 5], 7) 7 >>> min_sum_subarray([2, 3, 1, 2, 4, 3], 7) 7 >>> min_sum_subarray([5, 1, 3, 4, 2], 9) 9 >>> min_sum_subarray([-1, 2, 3, -1, -2, 1, 4], 5) 5 >>> min_sum_subarray(list(range(1, 10001)), 5000) 5000","solution":"def min_sum_subarray(nums, threshold): Returns the minimum possible sum of a contiguous subarray of nums such that the sum is greater than or equal to threshold. If no such subarray exists, return -1. n = len(nums) min_sum = float('inf') for i in range(n): current_sum = 0 for j in range(i, n): current_sum += nums[j] if current_sum >= threshold: min_sum = min(min_sum, current_sum) break return min_sum if min_sum != float('inf') else -1"},{"question":"from typing import List def buildings_with_sunset_view(heights: List[int]) -> List[int]: You are given a 0-indexed integer array \`heights\` representing the heights of buildings within a city. The city has a rule that a building can see the sunset if there are no taller buildings to its right. Return the list of indices of the buildings that can see the sunset, in ascending order. >>> buildings_with_sunset_view([4, 2, 3, 1]) [0, 2, 3] >>> buildings_with_sunset_view([1, 2, 3, 4]) [3] >>> buildings_with_sunset_view([4, 3, 2, 1]) [0, 1, 2, 3] >>> buildings_with_sunset_view([5]) [0] >>> buildings_with_sunset_view([4, 4, 4, 4]) [3] >>> buildings_with_sunset_view([7, 3, 8, 3, 6, 1, 2]) [2, 4, 6]","solution":"def buildings_with_sunset_view(heights): Returns the list of indices of buildings that can see the sunset. A building can see the sunset if all the buildings to its right are shorter. result = [] current_max_height = 0 for i in range(len(heights) - 1, -1, -1): if heights[i] > current_max_height: result.append(i) current_max_height = heights[i] result.reverse() return result"},{"question":"def pacific_atlantic(matrix: List[List[int]]) -> List[Tuple[int, int]]: You are given a matrix consisting of integers, where each element represents the height of a certain position in a 2D landscape. Water can flow from one cell to any of its 4 adjacent cells (up, down, left, or right) if the height of the next cell is less than or equal to the current cell. Initially, water only starts from the cells on the border of the matrix. Find the cells where water can flow to the border either directly or indirectly. >>> pacific_atlantic([]) [] >>> pacific_atlantic([[]]) [] >>> pacific_atlantic([[1]]) [(0, 0)] >>> pacific_atlantic([[1, 2, 3]]) [(0, 0), (0, 1), (0, 2)] >>> pacific_atlantic([ ... [1, 2, 2, 3, 5], ... [3, 2, 3, 4, 4], ... [2, 4, 5, 3, 1], ... [6, 7, 1, 4, 5], ... [5, 1, 1, 2, 4] ... ]) [(0, 4), (1, 3), (1, 4), (2, 2), (3, 0), (3, 1), (4, 0)] >>> pacific_atlantic([ ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1] ... ]) [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (4, 0), (4, 1), (4, 2), (4, 3), (4, 4)]","solution":"def pacific_atlantic(matrix): if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) def dfs(r, c, visited, prev_height): if (r < 0 or r >= rows or c < 0 or c >= cols or (r, c) in visited or matrix[r][c] < prev_height): return visited.add((r, c)) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: dfs(r + dr, c + dc, visited, matrix[r][c]) pacific_reachable = set() atlantic_reachable = set() for i in range(rows): dfs(i, 0, pacific_reachable, float('-inf')) dfs(i, cols - 1, atlantic_reachable, float('-inf')) for j in range(cols): dfs(0, j, pacific_reachable, float('-inf')) dfs(rows - 1, j, atlantic_reachable, float('-inf')) result = list(pacific_reachable & atlantic_reachable) result.sort(key=lambda x: (x[0], x[1])) return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rangeSumBST(root, low, high): Given the root of a binary search tree, return the sum of values of all nodes with value between low and high (inclusive). >>> rangeSumBST(None, 1, 10) == 0 >>> rangeSumBST(TreeNode(5), 1, 10) == 5 >>> rangeSumBST(TreeNode(5), 6, 10) == 0 >>> rangeSumBST(TreeNode(10, TreeNode(5), TreeNode(15)), 1, 20) == 30 >>> rangeSumBST(TreeNode(10, TreeNode(5, TreeNode(3), TreeNode(7)), TreeNode(15, None, TreeNode(18))), 7, 15) == 32 >>> rangeSumBST(TreeNode(10, TreeNode(5, TreeNode(3), TreeNode(7)), TreeNode(15, None, TreeNode(18))), 6, 10) == 17","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rangeSumBST(root, low, high): Given the root of a binary search tree, return the sum of values of all nodes with value between low and high (inclusive). if not root: return 0 total_sum = 0 if low <= root.val <= high: total_sum += root.val if low < root.val: total_sum += rangeSumBST(root.left, low, high) if root.val < high: total_sum += rangeSumBST(root.right, low, high) return total_sum"},{"question":"from typing import List def count_beautiful_subarrays(nums: List[int], k: int) -> int: Counts the number of beautiful subarrays in the list \`nums\` that contain exactly \`k\` odd numbers. >>> count_beautiful_subarrays([1, 1, 2, 1, 1], 3) == 2 >>> count_beautiful_subarrays([2, 4, 6], 1) == 0 >>> count_beautiful_subarrays([1, 1, 1], 1) == 3 >>> count_beautiful_subarrays([], 1) == 0 >>> count_beautiful_subarrays([1], 1) == 1 >>> count_beautiful_subarrays([1, 2, 1, 2, 1], 5) == 0","solution":"def count_beautiful_subarrays(nums, k): Counts the number of beautiful subarrays in the list \`nums\` that contain exactly \`k\` odd numbers. from collections import defaultdict count = 0 prefix_counts = defaultdict(int) prefix_counts[0] = 1 odd_count = 0 for num in nums: if num % 2 != 0: odd_count += 1 if odd_count - k in prefix_counts: count += prefix_counts[odd_count - k] prefix_counts[odd_count] += 1 return count"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Codec: def serialize(self, root: TreeNode) -> str: Encodes a tree to a single string. :param root: TreeNode, the root of the binary tree :return: str, serialized string representation of the tree >>> codec = Codec() >>> codec.serialize(None) 'None,' >>> root = TreeNode(1) >>> codec.serialize(root) '1,None,None,' def deserialize(self, data: str) -> TreeNode: Decodes your encoded data to tree. :param data: str, serialized string representation of the tree :return: TreeNode, the root of the binary tree >>> codec = Codec() >>> codec.deserialize('None,') >>> codec.deserialize('1,None,None,').val == 1 True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Codec: def serialize(self, root): Encodes a tree to a single string. :type root: TreeNode :rtype: str def rserialize(node, string): if not node: string += \\"None,\\" else: string += str(node.val) + \\",\\" string = rserialize(node.left, string) string = rserialize(node.right, string) return string return rserialize(root, \\"\\") def deserialize(self, data): Decodes your encoded data to tree. :type data: str :rtype: TreeNode def rdeserialize(data_list): if data_list[0] == \\"None\\": data_list.pop(0) return None root = TreeNode(int(data_list[0])) data_list.pop(0) root.left = rdeserialize(data_list) root.right = rdeserialize(data_list) return root data_list = data.split(',') root = rdeserialize(data_list) return root"},{"question":"def maxSubArrayQueries(nums, queries): Given an integer array nums and an array of queries where each query is represented as an array [left, right], return an array of results where the ith result is defined by the maximum subarray sum from index left to index right inclusive. Note that the subarray sum can include negative numbers. For each query, you need to find the contiguous subarray within [left, right] which has the largest sum and return that sum. >>> maxSubArrayQueries([-2, 1, -3, 4, -1, 2, 1, -5, 4], [[0, 8]]) [6] >>> maxSubArrayQueries([-2, 1, -3, 4, -1, 2, 1, -5, 4], [[0, 8], [1, 7], [2, 5]]) [6, 6, 5] >>> maxSubArrayQueries([1, 2, 3, 4, 5], [[2, 2], [0, 0], [4, 4]]) [3, 1, 5] >>> maxSubArrayQueries([-1, -2, -3, -4, -5], [[0, 4], [1, 3], [2, 2]]) [-1, -2, -3] >>> maxSubArrayQueries([-2, -3, 4, -1, -2, 1, 5, -3], [[0, 6], [2, 7]]) [7, 7] >>> maxSubArrayQueries([], [[0, 0], [1, 1]]) IndexError def maxSubArray(nums): Helper function to find the maximum subarray sum using Kadane's algorithm.","solution":"def maxSubArray(nums): Helper function to find the maximum subarray sum using Kadane's algorithm. current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum def maxSubArrayQueries(nums, queries): Returns an array of results where each result is the maximum subarray sum for the range specified by each query in the queries array. results = [] for left, right in queries: subarray = nums[left:right+1] results.append(maxSubArray(subarray)) return results"},{"question":"def rearrange_string(s: str, k: int) -> str: Rearrange the string such that the same characters are at least k indices apart. Args: s (str): Input string containing only lowercase alphabetic characters. k (int): Minimum distance between same characters. Returns: str: Rearranged string if possible, otherwise an empty string. >>> rearrange_string(\\"aabbcc\\", 3) in [\\"abcabc\\", \\"acbacb\\"] >>> rearrange_string(\\"aaabc\\", 3) == \\"\\" >>> rearrange_string(\\"aabbcc\\", 0) == \\"aabbcc\\" >>> rearrange_string(\\"a\\", 2) == \\"a\\" >>> rearrange_string(\\"abcd\\", 5) == \\"abcd\\" >>> rearrange_string(\\"aaabbbccc\\", 3) in [\\"abcabcabc\\"] >>> rearrange_string(\\"aaabbc\\", 3) == \\"\\" # Your code here","solution":"import heapq from collections import Counter, deque def rearrange_string(s, k): if k == 0: return s # Step 1: Count the frequency of each character freq = Counter(s) # Step 2: Use a max heap to get the most frequent characters first max_heap = [(-value, key) for key, value in freq.items()] heapq.heapify(max_heap) # Step 3: Initialize the result and a queue to keep track of wait time for characters result = [] wait_queue = deque() while max_heap: current_freq, current_char = heapq.heappop(max_heap) result.append(current_char) wait_queue.append((current_char, current_freq + 1)) # Decrease frequency if len(wait_queue) < k: continue # Release the character from the wait queue if it has waited enough char_to_release, freq_to_release = wait_queue.popleft() if freq_to_release < 0: heapq.heappush(max_heap, (freq_to_release, char_to_release)) result_str = \\"\\".join(result) # Step 4: If the length of the result does not match input, it is not possible if len(result_str) != len(s): return \\"\\" return result_str"},{"question":"from typing import List def visibility(peaks: List[int]) -> List[List[int]]: You are given a 0-indexed array \`peaks\` where each element \`peaks[i]\` represents the height of a mountain peak at index \`i\`. A peak \`peaks[i]\` is considered 'visible' from the left if there is no higher peak to the left of \`i\`. Similarly, a peak \`peaks[i]\` is considered 'visible' from the right if there is no higher peak to the right of \`i\`. Return an array \`visibility\` of the same length as \`peaks\`, where \`visibility[i]\` is a 2-element list \`[left, right]\`. >>> visibility([5]) [[1, 1]] >>> visibility([3, 4]) [[1, 0], [1, 1]] >>> visibility([2, 1, 3, 4, 1]) [[1, 0], [0, 0], [1, 0], [1, 1], [0, 1]] pass def test_single_peak(): assert visibility([5]) == [[1, 1]] def test_two_peaks(): assert visibility([3, 4]) == [[1, 0], [1, 1]] assert visibility([5, 2]) == [[1, 1], [0, 1]] def test_multiple_peaks(): assert visibility([2, 1, 3, 4, 1]) == [[1, 0], [0, 0], [1, 0], [1, 1], [0, 1]] def test_all_equal_peaks(): assert visibility([4, 4, 4, 4]) == [[1, 0], [0, 0], [0, 0], [0, 1]] def test_decreasing_peaks(): assert visibility([5, 4, 3, 2, 1]) == [[1, 1], [0, 1], [0, 1], [0, 1], [0, 1]] def test_increasing_peaks(): assert visibility([1, 2, 3, 4, 5]) == [[1, 0], [1, 0], [1, 0], [1, 0], [1, 1]] def test_random_peaks(): assert visibility([1, 3, 2, 4, 3]) == [[1, 0], [1, 0], [0, 0], [1, 1], [0, 1]]","solution":"def visibility(peaks): n = len(peaks) visibility = [[0, 0] for _ in range(n)] # Check visibility from the left max_left = float('-inf') for i in range(n): if peaks[i] > max_left: visibility[i][0] = 1 max_left = peaks[i] # Check visibility from the right max_right = float('-inf') for i in range(n-1, -1, -1): if peaks[i] > max_right: visibility[i][1] = 1 max_right = peaks[i] return visibility"},{"question":"def max_projects(projects: List[int], budget: int) -> int: Returns the maximum number of unique projects that can be funded without exceeding the initial budget. >>> max_projects([1, 2, 3, 4], 10) == 4 >>> max_projects([4, 2, 1, 3], 6) == 3 >>> max_projects([10, 20, 30], 5) == 0 >>> max_projects([1, 1, 1, 1, 1, 1], 100) == 6 >>> max_projects([1, 2, 3], 0) == 0 >>> max_projects([2, 2, 2, 2], 5) == 2","solution":"def max_projects(projects, budget): Returns the maximum number of unique projects that can be funded without exceeding the initial budget. projects.sort() count = 0 total_cost = 0 for cost in projects: if total_cost + cost <= budget: total_cost += cost count += 1 else: break return count"},{"question":"def total_report_time(managers, employeeTimes, employeeID): Calculates the total time taken for task completion to be reported to the CEO starting from a given employeeID. Args: managers (List[int]): list where managers[i] denotes the manager ID of the i-th employee. employeeTimes (List[int]): list where employeeTimes[i] denotes the time taken by the i-th employee to complete a task. employeeID (int): the ID of the employee who starts the task. Returns: int: The total reporting time taken for the task completion to be reported to the CEO. return # Example test cases def test_reporting_time_from_employee_0(): managers = [-1, 0, 0, 1, 1, 2, 2] employeeTimes = [1, 2, 3, 4, 5, 6, 7] assert total_report_time(managers, employeeTimes, 0) == 1 # CEO def test_reporting_time_from_employee_4(): managers = [-1, 0, 0, 1, 1, 2, 2] employeeTimes = [1, 2, 3, 4, 5, 6, 7] assert total_report_time(managers, employeeTimes, 4) == 8 # 5 (Employee 4) + 2 (Employee 1) + 1 (CEO) = 8 def test_reporting_time_from_employee_6(): managers = [-1, 0, 0, 1, 1, 2, 2] employeeTimes = [1, 2, 3, 4, 5, 6, 7] assert total_report_time(managers, employeeTimes, 6) == 11 # 7 (Employee 6) + 3 (Employee 2) + 1 (CEO) = 11 def test_reporting_time_with_no_reporting_chain(): managers = [-1] employeeTimes = [1] assert total_report_time(managers, employeeTimes, 0) == 1 # Only CEO, no chain def test_reporting_time_from_middle_management(): managers = [3, 3, -1, 2] employeeTimes = [3, 2, 1, 4] assert total_report_time(managers, employeeTimes, 0) == 8 # 3 (Employee 0) + 4 (Employee 3) + 1 (CEO) = 8","solution":"def total_report_time(managers, employeeTimes, employeeID): Calculates the total time taken for task completion to be reported to the CEO starting from a given employeeID. Args: managers (List[int]): list where managers[i] denotes the manager ID of the i-th employee. employeeTimes (List[int]): list where employeeTimes[i] denotes the time taken by the i-th employee to complete a task. employeeID (int): the ID of the employee who starts the task. Returns: int: The total reporting time taken for the task completion to be reported to the CEO. total_time = 0 current_ID = employeeID while current_ID != -1: total_time += employeeTimes[current_ID] current_ID = managers[current_ID] return total_time"},{"question":"import collections def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring with at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") 5 >>> length_of_longest_substring_two_distinct(\\"\\") 0 >>> length_of_longest_substring_two_distinct(\\"a\\") 1 >>> length_of_longest_substring_two_distinct(\\"abaccc\\") 4 >>> length_of_longest_substring_two_distinct(\\"abcabcabc\\") 2","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring with at most two distinct characters. if len(s) < 3: return len(s) # Initialize sliding window and result variable left = 0 right = 0 char_map = {} max_length = 2 while right < len(s): char = s[right] if char in char_map: char_map[char] += 1 else: char_map[char] = 1 # If we have more than 2 distinct characters, shrink the window while len(char_map) > 2: left_char = s[left] char_map[left_char] -= 1 if char_map[left_char] == 0: del char_map[left_char] left += 1 # Update the result max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def minLexString(s: str, k: int) -> str: Returns the lexicographically smallest string possible by performing a series of operations on the string s. >>> minLexString(\\"cba\\", 1) \\"acb\\" >>> minLexString(\\"baaca\\", 1) \\"aacab\\" >>> minLexString(\\"cba\\", 2) \\"abc\\" >>> minLexString(\\"baaca\\", 2) \\"aaabc\\" >>> minLexString(\\"cba\\", 3) \\"abc\\" >>> minLexString(\\"baaca\\", 5) \\"aaabc\\" >>> minLexString(\\"a\\", 1) \\"a\\" >>> minLexString(\\"a\\", 2) \\"a\\" >>> minLexString(\\"ab\\", 1) \\"ab\\" >>> minLexString(\\"ab\\", 2) \\"ab\\"","solution":"def minLexString(s, k): Returns the lexicographically smallest string possible by performing a series of operations on the string s. if k == 1: # Generate all rotations and return the smallest one min_string = s for i in range(len(s)): rotated_string = s[i:] + s[:i] if rotated_string < min_string: min_string = rotated_string return min_string else: # If k >= 2, we can just return the sorted version of s return ''.join(sorted(s))"},{"question":"class LruCache: Simulate a Least Recently Used (LRU) cache. The cache should support the following operations: get(key) - returns the value associated with the key if it exists in the cache, otherwise returns -1. set(key, value) - inserts the value keyed by the key into the cache. If inserting the new item causes the cache to exceed its predetermined capacity, it evicts the least recently used item before inserting the new item. The cache should ensure both operations run in O(1) time complexity. Args: capacity (int): The maximum number of items the cache can hold. def __init__(self, capacity: int): Initialize the LRU cache with a given capacity. pass def get(self, key: int) -> int: Return the value if the key exists in the cache, otherwise return -1. pass def set(self, key: int, value: int) -> None: Insert or update the key-value pair in the cache. Evict the least recently used item if capacity is full. pass import pytest def test_cache_set_and_get(): cache = LruCache(2) cache.set(1, 1) cache.set(2, 2) assert cache.get(1) == 1 cache.set(3, 3) assert cache.get(2) == -1 cache.set(4, 4) assert cache.get(1) == -1 assert cache.get(3) == 3 assert cache.get(4) == 4 def test_cache_update(): cache = LruCache(2) cache.set(1, 1) assert cache.get(1) == 1 cache.set(1, 10) assert cache.get(1) == 10 def test_cache_eviction_order(): cache = LruCache(2) cache.set(1, 1) cache.set(2, 2) assert cache.get(1) == 1 cache.set(3, 3) assert cache.get(1) == 1 assert cache.get(2) == -1 def test_cache_most_recently_used(): cache = LruCache(2) cache.set(1, 1) cache.set(2, 2) assert cache.get(1) == 1 cache.set(3, 3) assert cache.get(1) == 1 assert cache.get(3) == 3 cache.set(4, 4) assert cache.get(1) == -1 assert cache.get(3) == 3 assert cache.get(4) == 4","solution":"class LruCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.order = [] def get(self, key: int) -> int: if key in self.cache: self.order.remove(key) self.order.insert(0, key) return self.cache[key] return -1 def set(self, key: int, value: int) -> None: if key in self.cache: self.order.remove(key) elif len(self.cache) >= self.capacity: oldest_key = self.order.pop() del self.cache[oldest_key] self.cache[key] = value self.order.insert(0, key)"},{"question":"def length_of_longest_substring_k_distinct(s: str, k: int) -> int: Returns the length of the longest substring that contains no more than k distinct characters. If k is greater than or equal to the number of unique characters in s, returns the length of s. >>> length_of_longest_substring_k_distinct(\\"eceba\\", 2) == 3 >>> length_of_longest_substring_k_distinct(\\"aa\\", 1) == 2 >>> length_of_longest_substring_k_distinct(\\"aaaa\\", 1) == 4 >>> length_of_longest_substring_k_distinct(\\"abcd\\", 0) == 0 >>> length_of_longest_substring_k_distinct(\\"\\", 2) == 0 >>> length_of_longest_substring_k_distinct(\\"abc\\", 4) == 3 >>> length_of_longest_substring_k_distinct(\\"abcdef\\", 3) == 3 >>> length_of_longest_substring_k_distinct(\\"aabacbebebe\\", 3) == 7 pass","solution":"def length_of_longest_substring_k_distinct(s, k): Returns the length of the longest substring that contains no more than k distinct characters. If k is greater than or equal to the number of unique characters in s, returns the length of s. :param s: str - the input string :param k: int - the maximum number of distinct characters :return: int - the length of the longest substring meeting the criteria if k == 0 or not s: return 0 n = len(s) if k >= len(set(s)): return n left = 0 right = 0 char_map = {} max_length = 0 while right < n: char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def evaluate_expression(s: str) -> int: Evaluates an arithmetical expression given as a string and returns the result as an integer. >>> evaluate_expression(\\"3 + 5\\") 8 >>> evaluate_expression(\\"10 + 2 * 6\\") 22 >>> evaluate_expression(\\"100 * 2 + 12\\") 212 >>> evaluate_expression(\\"100 * ( 2 + 12 )\\") 1400 >>> evaluate_expression(\\"100 - 6 / 3\\") 98","solution":"def evaluate_expression(s): Evaluates an arithmetical expression given as a string and returns the result as an integer. # Helper function to perform the basic arithmetic def operate(a, b, op): if op == '+': return a + b elif op == '-': return a - b elif op == '*': return a * b elif op == '/': return int(a / b) # Truncate towards zero # Tokenize the string by spaces tokens = s.split() values = [] operations = [] i = 0 while i < len(tokens): token = tokens[i] if token.isdigit(): values.append(int(token)) elif token in \\"+-\\": while (operations and operations[-1] in \\"+-*/\\"): values.append(operate(values.pop(-2), values.pop(), operations.pop())) operations.append(token) elif token in \\"*/\\": while (operations and operations[-1] in \\"*/\\"): values.append(operate(values.pop(-2), values.pop(), operations.pop())) operations.append(token) elif token == '(': operations.append(token) elif token == ')': while operations[-1] != '(': values.append(operate(values.pop(-2), values.pop(), operations.pop())) operations.pop() # Remove '(' from stack i += 1 while operations: values.append(operate(values.pop(-2), values.pop(), operations.pop())) return values[0]"},{"question":"from typing import List def minimum_maximum_delay(n: int, edges: List[List[int]]) -> int: You are working as a network administrator for a company. The company has a set of connected servers represented by a graph. Each server is labeled from \`0\` to \`n - 1\`. Some pairs of servers are directly connected by cables, and each cable has a certain delay time in milliseconds. Your task is to ensure that there is a data transfer path between any two servers with the minimum possible maximum delay time along that path. You are given an integer \`n\` representing the number of servers and a list \`edges\` where \`edges[i] = [u, v, time]\` represents a cable with a delay time between server \`u\` and server \`v\`. Return the minimum possible maximum delay time to ensure connectivity between every pair of servers. Note: If it's not possible to connect all servers, return \`-1\`. >>> minimum_maximum_delay(4, [[0, 1, 1], [1, 2, 1], [2, 3, 1], [3, 0, 1]]) 1 >>> minimum_maximum_delay(4, [[0, 1, 2], [1, 2, 2], [2, 3, 2]]) 2 >>> minimum_maximum_delay(4, [[0, 1, 1], [2, 3, 1]]) -1","solution":"def minimum_maximum_delay(n, edges): parent = list(range(n)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX # Sort edges based on the delay time edges.sort(key=lambda x: x[2]) max_delay = 0 for u, v, time in edges: if find(u) != find(v): union(u, v) max_delay = time # Check if all servers are connected root = find(0) if all(find(i) == root for i in range(n)): return max_delay else: return -1"},{"question":"def min_subarray_length_with_elements(arr: List[int], x: int, y: int) -> int: Given an integer array \`arr\` and two integers \`x\` and \`y\`, return the length of the smallest contiguous subarray of \`arr\` containing at least one occurrence of both elements \`x\` and \`y\`. If such a subarray does not exist, return \`-1\`. >>> min_subarray_length_with_elements([1, 2, 3, 4, 5], 6, 7) -1 >>> min_subarray_length_with_elements([1, 2, 3, 4, 5], 2, 5) 4 >>> min_subarray_length_with_elements([1, 2, 3, 2, 5, 2, 4, 5, 1], 2, 5) 2 >>> min_subarray_length_with_elements([1, 2, 5, 3, 4, 5, 2, 7], 5, 2) 2 >>> min_subarray_length_with_elements([1], 1, 1) 1 >>> min_subarray_length_with_elements([3, 1, 4, 3, 2, 3, 5, 3], 3, 3) 1","solution":"def min_subarray_length_with_elements(arr, x, y): Returns the length of the smallest contiguous subarray of \`arr\` containing at least one occurrence of both elements \`x\` and \`y\`. If such a subarray does not exist, returns -1. n = len(arr) min_length = float('inf') last_x, last_y = -1, -1 for i in range(n): if arr[i] == x: last_x = i if arr[i] == y: last_y = i if last_x != -1 and last_y != -1: current_length = abs(last_x - last_y) + 1 min_length = min(min_length, current_length) if min_length == float('inf'): return -1 return min_length"},{"question":"def max_nesting_depth(s: str) -> int: Returns the maximal nesting depth of the parentheses in the string \`s\`. >>> max_nesting_depth(\\"()\\") == 1 >>> max_nesting_depth(\\"(())\\") == 2 >>> max_nesting_depth(\\"((()))\\") == 3 >>> max_nesting_depth(\\"()(())\\") == 2 >>> max_nesting_depth(\\"((())())\\") == 3 >>> max_nesting_depth(\\"\\") == 0 >>> max_nesting_depth(\\"(()((())()))\\") == 4 >>> max_nesting_depth(\\"()()()\\") == 1 pass","solution":"def max_nesting_depth(s): Returns the maximal nesting depth of the parentheses in the string \`s\`. max_depth = 0 current_depth = 0 for char in s: if char == '(': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == ')': current_depth -= 1 return max_depth"},{"question":"def min_deletions(s: str) -> int: Calculates the minimum number of deletions required such that no two adjacent characters are the same. :param s: input string consisting of only lowercase English letters :return: minimum number of deletions required >>> min_deletions(\\"aab\\") == 1 >>> min_deletions(\\"aaaa\\") == 3 >>> min_deletions(\\"ababa\\") == 0 >>> min_deletions(\\"\\") == 0 >>> min_deletions(\\"abcde\\") == 0 >>> min_deletions(\\"aaaaaaa\\") == 6 >>> min_deletions(\\"abababab\\") == 0 >>> min_deletions(\\"aabbcc\\") == 3","solution":"def min_deletions(s): Calculates the minimum number of deletions required such that no two adjacent characters are the same :param s: input string consisting of only lowercase English letters :return: minimum number of deletions required if not s: return 0 deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestZigZag(root: TreeNode) -> int: Given a binary tree, find the length of the longest path which is a zig-zag path. A zig-zag path is defined as follows: - Each node in the path must have a child that alternates between left and right. - For instance, if a node has a left child, the next node in the path must have a right child, and vice versa. Return the length of the longest zig-zag path in the given binary tree. from solution import TreeNode, longestZigZag def test_empty_tree(): assert longestZigZag(None) == 0 def test_single_node(): assert longestZigZag(TreeNode(1)) == 0 def test_left_heavy_tree(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) assert longestZigZag(root) == 1 def test_right_heavy_tree(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) assert longestZigZag(root) == 1 def test_complete_zigzag(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(4) root.right.left = TreeNode(5) root.left.right.left = TreeNode(6) assert longestZigZag(root) == 3 def test_sparse_zigzag(): root = TreeNode(1) root.left = TreeNode(2) root.left.right = TreeNode(3) root.left.right.left = TreeNode(4) root.left.right.left.right = TreeNode(5) assert longestZigZag(root) == 4 def test_multiple_paths(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(4) root.right.left = TreeNode(5) root.left.right.left = TreeNode(6) root.left.right.left.right = TreeNode(7) root.right.left.left = TreeNode(8) assert longestZigZag(root) == 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestZigZag(root: TreeNode) -> int: def dfs(node, direction, length): if not node: return nonlocal max_length max_length = max(max_length, length) if direction == 'left': dfs(node.left, 'right', length + 1) dfs(node.right, 'left', 1) else: dfs(node.left, 'right', 1) dfs(node.right, 'left', length + 1) max_length = 0 if root: dfs(root.left, 'right', 1) dfs(root.right, 'left', 1) return max_length"},{"question":"from typing import List, Tuple, Dict def group_events_by_date(events: List[Tuple[str, str]]) -> Dict[str, List[str]]: Groups events by their dates and sorts descriptions by their timestamps. Parameters: events (list of tuple): A list where each tuple contains a timestamp and a description. Returns: dict: A dictionary with dates as keys and lists of sorted descriptions as values. >>> events = [( '2023-10-01 08:00:00', 'Event A'), ( '2023-10-01 09:00:00', 'Event B'), ( '2023-10-02 07:00:00', 'Event C')] >>> group_events_by_date(events) { '2023-10-01': ['Event A', 'Event B'], '2023-10-02': ['Event C'] }","solution":"from collections import defaultdict from datetime import datetime def group_events_by_date(events): Groups events by their dates and sorts descriptions by their timestamps. Parameters: events (list of tuple): A list where each tuple contains a timestamp and a description. Returns: dict: A dictionary with dates as keys and lists of sorted descriptions as values. grouped_events = defaultdict(list) for timestamp, description in events: date = timestamp.split()[0] grouped_events[date].append((timestamp, description)) for date in grouped_events: grouped_events[date].sort() grouped_events[date] = [desc for _, desc in grouped_events[date]] return dict(grouped_events)"},{"question":"def max_candies(nums): Returns the maximum number of candies that can be collected by picking a contiguous subarray from nums. Parameters: nums (List[int]): List of integers representing the number of candies in each box. Returns: int: The maximum number of candies from any contiguous subarray. pass # Unit tests def test_single_element_positive(): assert max_candies([10]) == 10 def test_single_element_negative(): assert max_candies([-5]) == -5 def test_all_positive_elements(): assert max_candies([1, 2, 3, 4]) == 10 def test_all_negative_elements(): assert max_candies([-1, -2, -3, -4]) == -1 def test_mixed_elements(): assert max_candies([1, -2, 3, 5, -1, 2]) == 9 def test_subarray_at_end(): assert max_candies([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 def test_entire_array(): assert max_candies([1, 2, 3, 4, 5]) == 15","solution":"def max_candies(nums): Returns the maximum number of candies that can be collected by picking a contiguous subarray from nums. Parameters: nums (List[int]): List of integers representing the number of candies in each box. Returns: int: The maximum number of candies from any contiguous subarray. max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def find_peak_element(nums: List[int]) -> int: Finds the index of a peak element in the array. A peak element is an element that is strictly greater than its neighbors. The function is optimized to run in O(log n) time complexity using binary search. :param nums: List[int] :return: int >>> find_peak_element([1]) 0 >>> find_peak_element([1, 2]) 1 >>> find_peak_element([2, 1]) 0 >>> find_peak_element([1, 3, 2]) 1 >>> find_peak_element([1, 2, 3]) 2 >>> find_peak_element([3, 2, 1]) 0 >>> find_peak_element([1, 3, 2, 4, 1]) # could be 1 or 3 1 >>> find_peak_element([]) -1","solution":"def find_peak_element(nums): Finds the index of a peak element in the array. A peak element is an element that is strictly greater than its neighbors. The function is optimized to run in O(log n) time complexity using binary search. :param nums: List[int] :return: int if not nums: return -1 left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"def num_islands(mat): Return the number of islands in the given matrix using DFS. :param mat: List[List[int]] - Matrix of size m x n with 1s (land) and 0s (water). :return: int - Number of islands. >>> num_islands([ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ]) 3 >>> num_islands([ [1, 1, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 0, 1] ]) 2 >>> num_islands([[0]]) 0 >>> num_islands([[1]]) 1 >>> num_islands([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 0","solution":"def num_islands(mat): Return the number of islands in the given matrix using DFS. :param mat: List[List[int]] - Matrix of size m x n with 1s (land) and 0s (water). :return: int - Number of islands. if not mat: return 0 def dfs(mat, i, j): Perform DFS to visit all parts of the island if i < 0 or i >= len(mat) or j < 0 or j >= len(mat[0]) or mat[i][j] == 0: return mat[i][j] = 0 # Mark the visited land as water dfs(mat, i+1, j) dfs(mat, i-1, j) dfs(mat, i, j+1) dfs(mat, i, j-1) count = 0 for i in range(len(mat)): for j in range(len(mat[0])): if mat[i][j] == 1: count += 1 dfs(mat, i, j) return count"},{"question":"def num_enclosed_lakes(grid: List[List[int]]) -> int: Returns the number of lakes that are completely surrounded by land in the given grid. >>> num_enclosed_lakes([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 0 >>> num_enclosed_lakes([ ... [1, 1, 1, 1], ... [1, 0, 0, 1], ... [1, 0, 0, 1], ... [1, 1, 1, 1] ... ]) == 1 >>> num_enclosed_lakes([ ... [1, 0, 1], ... [0, 0, 0], ... [1, 0, 1] ... ]) == 0 >>> num_enclosed_lakes([ ... [1, 1, 1, 1, 1], ... [1, 0, 1, 0, 1], ... [1, 0, 1, 0, 1], ... [1, 0, 0, 1, 1], ... [1, 1, 1, 1, 1] ... ]) == 2 >>> num_enclosed_lakes([ ... [1, 1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0, 1], ... [1, 0, 1, 1, 0, 1], ... [1, 1, 1, 0, 0, 1], ... [1, 0, 0, 0, 1, 1], ... [1, 1, 1, 1, 1, 1] ... ]) == 2 >>> num_enclosed_lakes([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0","solution":"def num_enclosed_lakes(grid): Returns the number of lakes that are completely surrounded by land in the given grid. if not grid or not grid[0]: return 0 n = len(grid) visited = [[False] * n for _ in range(n)] def is_on_border(x, y): return x == 0 or y == 0 or x == n - 1 or y == n - 1 def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= n or visited[x][y] or grid[x][y] == 1: return visited[x][y] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(x + dx, y + dy) # Mark all water cells that are connected to the border for i in range(n): for j in range(n): if (i == 0 or i == n - 1 or j == 0 or j == n - 1) and grid[i][j] == 0 and not visited[i][j]: dfs(i, j) # Now count all the lakes that are surrounded by land lake_count = 0 for i in range(1, n - 1): for j in range(1, n - 1): if grid[i][j] == 0 and not visited[i][j]: # Found a lake that is surrounded by land lake_count += 1 dfs(i, j) return lake_count"},{"question":"def is_special_subset(target: int, numbers: List[int]) -> bool: Determines if there exists a subset of \`numbers\` such that their sum is a divisor of \`target\`. Parameters: target (int): The target number. numbers (list of int): The list of positive integers. Returns: bool: True if such a subset exists, False otherwise. >>> is_special_subset(10, []) == False >>> is_special_subset(10, [5]) == True >>> is_special_subset(10, [3]) == False >>> is_special_subset(10, [1, 3, 5]) == True >>> is_special_subset(15, [2, 7]) == False >>> is_special_subset(12, [1, 2, 3, 4, 6, 12]) == True >>> is_special_subset(100, [10, 20, 30, 40]) == True >>> is_special_subset(101, [10, 20, 30, 40]) == False >>> is_special_subset(1, [2, 3, 4]) == False >>> is_special_subset(1, [1]) == True >>> is_special_subset(7, [1, 2, 3, 4, 5, 6, 7]) == True >>> is_special_subset(7, [2, 4, 6, 8]) == False","solution":"def is_special_subset(target, numbers): Determines if there exists a subset of \`numbers\` such that their sum is a divisor of \`target\`. Parameters: target (int): The target number. numbers (list of int): The list of positive integers. Returns: bool: True if such a subset exists, False otherwise. # Set of \\"special\\" numbers which are divisors of \`target\` special_numbers = {i for i in range(1, target+1) if target % i == 0} # Dynamic programming approach to find the possible sums we can achieve possible_sums = {0} for num in numbers: new_sums = {num + ps for ps in possible_sums} possible_sums.update(new_sums) # Check if any of the possible sums is a \\"special\\" number return not special_numbers.isdisjoint(possible_sums)"},{"question":"def shift_string(s: str, k: int) -> str: Shifts each character in the string s forward by k positions in the alphabetical order. If a character exceeds 'z', it wraps around to the beginning of the alphabet. Parameters: s (str): The input string to be shifted. k (int): The number of positions to shift each character. Returns: str: The transformed string after shifting. >>> shift_string(\\"abcd\\", 1) \\"bcde\\" >>> shift_string(\\"xyz\\", 2) \\"zab\\" >>> shift_string(\\"hello\\", 0) \\"hello\\" >>> shift_string(\\"abc\\", 27) \\"bcd\\" >>> shift_string(\\"abcdefghijklmnopqrstuvwxyz\\", 3) \\"defghijklmnopqrstuvwxyzabc\\"","solution":"def shift_string(s, k): Shifts each character in the string s forward by k positions in the alphabetical order. If a character exceeds 'z', it wraps around to the beginning of the alphabet. Parameters: s (str): The input string to be shifted. k (int): The number of positions to shift each character. Returns: str: The transformed string after shifting. # Define the alphabet length alphabet_length = 26 # Create the transformed string list shifted_string = [] for char in s: # Calculate the new position of the character new_position = (ord(char) - ord('a') + k) % alphabet_length # Append the new character to the transformed string list shifted_string.append(chr(ord('a') + new_position)) # Join the list to form the final transformed string return ''.join(shifted_string)"},{"question":"def max_water_trapped(heights): Calculate the maximum water trapped between the buildings after raining. Args: heights (list of int): The heights of adjacent buildings. Returns: int: The maximum amount of water that can be trapped. >>> max_water_trapped([]) == 0 >>> max_water_trapped([1, 1, 1, 1]) == 0 >>> max_water_trapped([2, 1, 2]) == 1 >>> max_water_trapped([0, 2, 0]) == 0 >>> max_water_trapped([2, 0, 2]) == 2 >>> max_water_trapped([3, 0, 2, 0, 4]) == 7 >>> max_water_trapped([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> max_water_trapped([4, 2, 0, 3, 2, 5]) == 9","solution":"def max_water_trapped(heights): Calculate the maximum water trapped between the buildings after raining. Args: heights (list of int): The heights of adjacent buildings. Returns: int: The maximum amount of water that can be trapped. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def minimum_effort_path(heights): Calculates the minimum effort to traverse from the top-left to the bottom-right corner of a given 2D grid. The effort is defined as the maximum absolute difference in heights between two consecutive cells of the path. :param heights: List of List of ints, representing the heights of the grid :return: The minimum effort required to traverse the grid from solution import minimum_effort_path def test_minimum_effort_path_small_grid(): grid = [ [1, 2, 2], [3, 8, 2], [5, 3, 5] ] assert minimum_effort_path(grid) == 2 def test_minimum_effort_path_flat_grid(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert minimum_effort_path(grid) == 0 def test_minimum_effort_path_single_cell(): grid = [ [1] ] assert minimum_effort_path(grid) == 0 def test_minimum_effort_path_large_diff(): grid = [ [1, 1000000], [1000000, 1] ] assert minimum_effort_path(grid) == 999999 def test_minimum_effort_path_complex_grid(): grid = [ [1, 2, 3], [3, 8, 4], [5, 3, 5] ] assert minimum_effort_path(grid) == 1","solution":"from heapq import heappop, heappush def minimum_effort_path(heights): Calculates the minimum effort to traverse from the top-left to the bottom-right corner of a given 2D grid. The effort is defined as the maximum absolute difference in heights between two consecutive cells of the path. :param heights: List of List of ints, representing the heights of the grid :return: The minimum effort required to traverse the grid # Possible moves (right, left, down, up) directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] rows, cols = len(heights), len(heights[0]) # Min-heap to store (effort, row, column) heap = [(0, 0, 0)] efforts = [[float('inf')] * cols for _ in range(rows)] efforts[0][0] = 0 while heap: current_effort, row, col = heappop(heap) if row == rows - 1 and col == cols - 1: return current_effort for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols: new_effort = max(current_effort, abs(heights[new_row][new_col] - heights[row][col])) if new_effort < efforts[new_row][new_col]: efforts[new_row][new_col] = new_effort heappush(heap, (new_effort, new_row, new_col))"},{"question":"from collections import deque def min_steps_to_reach_end(grid): Returns the minimum number of steps required to reach the bottom-right cell of the grid from the top-left cell. If there is no possible way, return -1. >>> min_steps_to_reach_end([ ... [0, 1], ... [1, 0] ... ]) == -1 >>> min_steps_to_reach_end([ ... [0, 0], ... [0, 0] ... ]) == 2 >>> min_steps_to_reach_end([ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) == 4 >>> min_steps_to_reach_end([ ... [0, 0, 1, 0, 0], ... [0, 1, 0, 0, 1], ... [0, 0, 0, 1, 0], ... [1, 1, 0, 0, 0], ... [0, 0, 0, 1, 0] ... ]) == 8 >>> min_steps_to_reach_end([ ... [1, 0], ... [0, 0] ... ]) == -1 >>> min_steps_to_reach_end([ ... [0, 0], ... [0, 1] ... ]) == -1","solution":"from collections import deque def min_steps_to_reach_end(grid): Returns the minimum number of steps required to reach the bottom-right cell of the grid from the top-left cell. If there is no possible way, return -1. n = len(grid) m = len(grid[0]) if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\"a\\") == 1 >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"abcdabcdeabcd\\") == 5 >>> length_of_longest_substring(\\"abcdeabc\\") == 5 >>> length_of_longest_substring(\\"abacabcdbb\\") == 4 >>> length_of_longest_substring(\\"abcabcbbabc\\") == 3 >>> length_of_longest_substring(\\"abcdefg\\") == 7 >>> length_of_longest_substring(\\"aaaaaa\\") == 1","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters. n = len(s) if n == 0: return 0 char_index_map = {} max_len = 0 start = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"import collections import sys from typing import List class Centrality: def __init__(self, graph: List[List[int]]): Initializes the Centrality object with the adjacency list graph. def bfs_shortest_path(self, start_node: int) -> List[int]: Performs BFS from the start_node to calculate shortest paths to all other nodes. Returns a list of shortest path distances. def calculateClosenessCentrality(self) -> List[float]: Returns a double array result where result[i] is the closeness centrality of the node \`i\`. Unit Test: import pytest from solution import Centrality def test_closeness_centrality_small_graph(): graph = [ [1, 2], # Node 0 connected to Node 1, Node 2 [0, 2], # Node 1 connected to Node 0, Node 2 [0, 1, 3], # Node 2 connected to Node 0, Node 1, Node 3 [2] # Node 3 connected to Node 2 ] centrality = Centrality(graph) result = centrality.calculateClosenessCentrality() assert result[0] != 0 assert result[1] != 0 assert result[2] != 0 assert result[3] != 0 def test_closeness_centrality_with_isolated_node(): graph = [ [1], # Node 0 connected to Node 1 [0], # Node 1 connected to Node 0 [], # Node 2 is isolated [4], # Node 3 connected to Node 4 [3] # Node 4 connected to Node 3 ] centrality = Centrality(graph) result = centrality.calculateClosenessCentrality() assert result[0] != 0 assert result[1] != 0 assert result[2] == 0 assert result[3] != 0 assert result[4] != 0 def test_closeness_centrality_star_graph(): graph = [ [1, 2, 3, 4], # Node 0 connected to all other nodes [0], # Node 1 connected to Node 0 [0], # Node 2 connected to Node 0 [0], # Node 3 connected to Node 0 [0] # Node 4 connected to Node 0 ] centrality = Centrality(graph) result = centrality.calculateClosenessCentrality() assert result[0] > result[1] assert result[0] > result[2] assert result[0] > result[3] assert result[0] > result[4]","solution":"import collections import sys class Centrality: def __init__(self, graph): Initializes the Centrality object with the adjacency list graph self.graph = graph self.n = len(graph) def bfs_shortest_path(self, start_node): Performs BFS from the start_node to calculate shortest paths to all other nodes Returns a list of shortest path distances distances = [sys.maxsize] * self.n distances[start_node] = 0 queue = collections.deque([start_node]) while queue: curr_node = queue.popleft() for neighbor in self.graph[curr_node]: if distances[neighbor] == sys.maxsize: distances[neighbor] = distances[curr_node] + 1 queue.append(neighbor) return distances def calculateClosenessCentrality(self): Returns a double array result where result[i] is the closeness centrality of the node \`i\` centrality = [0.0] * self.n for i in range(self.n): distances = self.bfs_shortest_path(i) sum_distances = sum(d for d in distances if d != sys.maxsize) reachable_nodes = sum(1 for d in distances if d != sys.maxsize) if reachable_nodes > 1: # if there's at least one reachable node other than itself centrality[i] = (reachable_nodes - 1) / sum_distances return centrality"},{"question":"def subset_sum(arr: List[int], target_value: int) -> bool: Determine if there exists a subset of the given array whose sum is equal to target_value. >>> subset_sum([1, 2, 3, 4], 6) True >>> subset_sum([1, 2, 7, 8], 10) True >>> subset_sum([], 0) True >>> subset_sum([0, 0, 0], 0) True >>> subset_sum([1, 2, 3], 7) False >>> subset_sum([2, 4, 6], 5) False >>> subset_sum([5], 10) False >>> subset_sum([], 5) False >>> subset_sum([1], 1) True >>> subset_sum([1], 0) True >>> subset_sum([1, 2, 3], 0) True >>> subset_sum([0, 0, 1], 1) True >>> subset_sum([0, 0, 1], 0) True >>> large_array = list(range(1, 21)) >>> subset_sum(large_array, 210) True >>> subset_sum(large_array, 230) False","solution":"def subset_sum(arr, target_value): Determines if there is a subset of arr that sums up to target_value. n = len(arr) dp = [[False for _ in range(target_value + 1)] for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, target_value + 1): if j < arr[i - 1]: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] return dp[n][target_value]"},{"question":"def find_and_replace_pattern(words: List[str], pattern: str) -> List[str]: Given a list of words and a pattern, return the list of words that match the pattern. A word matches the pattern if there exists a permutation of letters such that after substituting each letter in the pattern with a letter from the permutation, we obtain the word. Example: >>> find_and_replace_pattern([\\"abc\\",\\"deq\\",\\"mee\\",\\"aqq\\",\\"dkd\\",\\"ccc\\"], \\"abb\\") [\\"mee\\", \\"aqq\\"] >>> find_and_replace_pattern([], \\"abc\\") [] >>> find_and_replace_pattern([\\"xyz\\", \\"def\\", \\"ghi\\"], \\"aaa\\") [] >>> find_and_replace_pattern([\\"aaa\\", \\"bbb\\", \\"ccc\\"], \\"aaa\\") [\\"aaa\\", \\"bbb\\", \\"ccc\\"] >>> find_and_replace_pattern([\\"a\\", \\"b\\", \\"c\\"], \\"aa\\") [] >>> find_and_replace_pattern([\\"abcd\\", \\"efgh\\", \\"ijkl\\"], \\"abc\\") [] pass","solution":"def find_and_replace_pattern(words, pattern): def is_match(word, pattern): if len(word) != len(pattern): return False char_to_pattern = {} pattern_to_char = {} for w_char, p_char in zip(word, pattern): if w_char not in char_to_pattern: char_to_pattern[w_char] = p_char if p_char not in pattern_to_char: pattern_to_char[p_char] = w_char if (char_to_pattern[w_char], pattern_to_char[p_char]) != (p_char, w_char): return False return True return [word for word in words if is_match(word, pattern)]"},{"question":"from collections import Counter def frequency_sort(s: str) -> str: Sorts the characters in the string based on their frequency in non-increasing order. If frequencies of characters are the same, they are sorted alphabetically. :param s: input string :return: sorted string based on character frequencies pass def test_frequency_sort_example(): assert frequency_sort(\\"tree\\") == \\"eert\\" or frequency_sort(\\"tree\\") == \\"eetr\\" def test_frequency_sort_same_frequency(): assert frequency_sort(\\"cccaaa\\") == \\"aaaccc\\" or frequency_sort(\\"cccaaa\\") == \\"cccaaa\\" def test_frequency_sort_single_character(): assert frequency_sort(\\"a\\") == \\"a\\" def test_frequency_sort_empty_string(): assert frequency_sort(\\"\\") == \\"\\" def test_frequency_sort_all_unique(): assert frequency_sort(\\"abcd\\") == \\"abcd\\" def test_frequency_sort_mixed_characters(): assert frequency_sort(\\"aabbccdd\\") == \\"aabbccdd\\" or frequency_sort(\\"aabbccdd\\") == \\"bbaaddcc\\"","solution":"from collections import Counter def frequency_sort(s): Sorts the characters in the string based on their frequency in non-increasing order. If frequencies of characters are the same, they are sorted alphabetically. :param s: input string :return: sorted string based on character frequencies freq = Counter(s) sorted_chars = sorted(freq.items(), key=lambda x: (-x[1], x[0])) return ''.join([char * count for char, count in sorted_chars])"},{"question":"from typing import Dict def rearrange_string(s: str, dict: Dict[str, bool]) -> str: Rearranges the words in the string s such that all valid words appear before any invalid words while maintaining the original relative order of both valid and invalid words. Args: s (str): The input string containing words separated by spaces. dict (dict): Dictionary where keys are words and values are Booleans indicating if the word is valid. Returns: str: The rearranged string. >>> rearrange_string(\\"apple banana orange pear kiwi grape\\", {\\"apple\\": True, \\"banana\\": False, \\"orange\\": True, \\"pear\\": True, \\"kiwi\\": False, \\"grape\\": True}) \\"apple orange pear grape banana kiwi\\" >>> rearrange_string(\\"apple banana orange\\", {\\"apple\\": True, \\"banana\\": True, \\"orange\\": True}) \\"apple banana orange\\" >>> rearrange_string(\\"apple banana orange\\", {\\"apple\\": False, \\"banana\\": False, \\"orange\\": False}) \\"apple banana orange\\" >>> rearrange_string(\\"car bike train plane boat\\", {\\"car\\": True, \\"bike\\": False, \\"train\\": True, \\"plane\\": True, \\"boat\\": False}) \\"car train plane bike boat\\" >>> rearrange_string(\\"apple banana orange\\", {\\"apple\\": True, \\"banana\\": False}) \\"apple banana orange\\"","solution":"def rearrange_string(s, dict): Rearranges the words in the string s such that all valid words appear before any invalid words while maintaining the original relative order of both valid and invalid words. Args: s (str): The input string containing words separated by spaces. dict (dict): Dictionary where keys are words and values are Booleans indicating if the word is valid. Returns: str: The rearranged string. words = s.split() valid_words = [word for word in words if dict.get(word, False)] invalid_words = [word for word in words if not dict.get(word, False)] return ' '.join(valid_words + invalid_words)"},{"question":"from collections import deque from typing import List, Callable class ConditionalQueue: def __init__(self, limit: int): Initializes the queue with a size limit. def append(self, element: int): Adds an element to the queue. If the queue exceeds its size limit, the oldest element is removed. def dequeueIf(self, condition: Callable[[int], bool]) -> List[int]: Removes and returns all the elements from the queue that satisfy the given condition. # Unit tests def test_queue_append_and_limit(): q = ConditionalQueue(3) q.append(1) q.append(2) q.append(3) q.append(4) assert list(q.queue) == [2, 3, 4], \\"Oldest elements should be removed when limit is exceeded.\\" def test_dequeue_if_condition_met(): q = ConditionalQueue(5) q.append(1) q.append(2) q.append(3) q.append(4) q.append(5) removed = q.dequeueIf(lambda x: x % 2 == 0) # Remove even numbers assert removed == [2, 4], \\"Even numbers should be removed.\\" assert list(q.queue) == [1, 3, 5], \\"Queue should contain only odd numbers after removal.\\" def test_dequeue_if_no_condition_met(): q = ConditionalQueue(5) q.append(1) q.append(3) q.append(5) removed = q.dequeueIf(lambda x: x % 2 == 0) # Remove even numbers assert removed == [], \\"No numbers should be removed because all are odd.\\" assert list(q.queue) == [1, 3, 5], \\"Queue should remain unchanged when condition not met.\\" def test_mixed_operations(): q = ConditionalQueue(3) q.append(1) q.append(2) q.append(3) assert list(q.queue) == [1, 2, 3] q.append(4) assert list(q.queue) == [2, 3, 4], \\"Oldest element should be removed to maintain limit.\\" removed = q.dequeueIf(lambda x: x == 3) assert removed == [3], \\"Element equal to 3 should be removed.\\" assert list(q.queue) == [2, 4] q.append(5) assert list(q.queue) == [2, 4, 5], \\"Element 5 should be appended without exceeding the limit.\\" removed = q.dequeueIf(lambda x: x > 3) assert removed == [4, 5], \\"Elements greater than 3 should be removed.\\" assert list(q.queue) == [2], \\"Queue should contain element 2 after removals.\\" def test_empty_queue_dequeue(): q = ConditionalQueue(3) removed = q.dequeueIf(lambda x: x > 1) assert removed == [], \\"Removing from empty queue should return an empty list.\\" assert list(q.queue) == [], \\"Queue should remain empty.\\"","solution":"from collections import deque from typing import List, Callable class ConditionalQueue: def __init__(self, limit: int): self.limit = limit self.queue = deque() def append(self, element: int): if len(self.queue) >= self.limit: self.queue.popleft() # Remove the oldest element self.queue.append(element) def dequeueIf(self, condition: Callable[[int], bool]) -> List[int]: removed_elements = [] remaining_elements = deque() while self.queue: element = self.queue.popleft() if condition(element): removed_elements.append(element) else: remaining_elements.append(element) self.queue = remaining_elements return removed_elements"},{"question":"from typing import List def four_sum(nums: List[int]) -> List[List[int]]: Returns a list of unique quadruplets that sum up to zero. >>> four_sum([1, 0, -1, 0, -2, 2]) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([1, 2, 3, 4]) [] >>> four_sum([0, 0, 0, 0]) [[0, 0, 0, 0]] >>> four_sum([-3, -1, 0, 2, 4, 5]) [[-3, -1, 0, 4]] >>> four_sum([1, 0, -1, 0, -2, 2, 2, -2]) [[-2, -2, 2, 2], [-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] pass","solution":"def four_sum(nums): Returns a list of unique quadruplets that sum up to zero. nums.sort() results = [] length = len(nums) for i in range(length - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, length - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue left = j + 1 right = length - 1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == 0: results.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return results"},{"question":"def can_be_increasing(nums: List[int]) -> bool: Determine if it is possible to make the array strictly increasing by removing at most one element. >>> can_be_increasing([1, 2, 3, 4, 5]) == True >>> can_be_increasing([1, 2, 10, 3, 4]) == True >>> can_be_increasing([1, 2, 3, 4, 3]) == True >>> can_be_increasing([5, 1, 2, 3, 4]) == True >>> can_be_increasing([5, 4, 3, 2, 1]) == False >>> can_be_increasing([1, 2]) == True >>> can_be_increasing([2, 1]) == True >>> can_be_increasing([1]) == True >>> can_be_increasing([1, 2, 2, 3, 4]) == True","solution":"def can_be_increasing(nums): Returns True if it's possible to make the array strictly increasing by removing at most one element, otherwise returns False. n = len(nums) def is_strictly_increasing(arr): for i in range(len(arr) - 1): if arr[i] >= arr[i+1]: return False return True for i in range(n): if i == 0: if is_strictly_increasing(nums[1:]): return True elif i == n - 1: if is_strictly_increasing(nums[:-1]): return True else: if is_strictly_increasing(nums[:i] + nums[i+1:]): return True return False"},{"question":"def unobstructed_buildings(heights: List[int]) -> List[int]: Given an integer array representing the height of buildings along a street, returns an array containing the indices of the buildings that have an unobstructed view to the right. >>> unobstructed_buildings([4, 2, 3, 1]) == [0, 2, 3] >>> unobstructed_buildings([1, 3, 2, 4]) == [3] >>> unobstructed_buildings([4, 3, 2, 1]) == [0, 1, 2, 3] >>> unobstructed_buildings([1, 1, 1, 1]) == [3] >>> unobstructed_buildings([]) == [] >>> unobstructed_buildings([5]) == [0]","solution":"def unobstructed_buildings(heights): Returns an array of indices of buildings that have an unobstructed view to the right. n = len(heights) if n == 0: return [] result = [] max_height = float('-inf') for i in range(n - 1, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] return result[::-1]"},{"question":"def max_consecutive_ones(data: List[int], k: int) -> int: Returns the maximum number of consecutive 1s that can be achieved by flipping at most k 0s to 1s. >>> max_consecutive_ones([1, 1, 1, 1, 1], 2) 5 >>> max_consecutive_ones([1, 0, 1, 1, 0, 1], 1) 4 >>> max_consecutive_ones([0, 0, 0, 0, 0], 3) 3 >>> max_consecutive_ones([], 1) 0 >>> max_consecutive_ones([1, 0, 0, 1, 1, 0, 1, 1], 2) 6 >>> max_consecutive_ones([1, 0, 1, 0, 1, 0, 1], 4) 7 >>> max_consecutive_ones([0, 0, 1, 0, 0], 0) 1","solution":"def max_consecutive_ones(data, k): Returns the maximum number of consecutive 1s that can be achieved by flipping at most k 0s to 1s. left = 0 max_ones = 0 zeros_count = 0 for right in range(len(data)): # If we encounter a 0, increment the zero count if data[right] == 0: zeros_count += 1 # While we have more than k zeros in the current window, move the left pointer to the right while zeros_count > k: if data[left] == 0: zeros_count -= 1 left += 1 # Update the maximum length of the window with at most k zeros max_ones = max(max_ones, right - left + 1) return max_ones"},{"question":"def smallest_antipalindromic_string(n: int) -> str: Returns the lexicographically smallest anti-palindromic string of length n consisting only of lowercase English letters. >>> smallest_antipalindromic_string(1) 'a' >>> smallest_antipalindromic_string(2) 'ab' >>> smallest_antipalindromic_string(3) 'aba' >>> smallest_antipalindromic_string(4) 'abab' >>> smallest_antipalindromic_string(5) 'ababa' >>> smallest_antipalindromic_string(6) 'ababab' >>> smallest_antipalindromic_string(10) 'ababababab'","solution":"def smallest_antipalindromic_string(n): Returns the lexicographically smallest anti-palindromic string of length n consisting only of lowercase English letters. if n == 1: return 'a' res = [] letters = ['a', 'b'] for i in range(n): res.append(letters[i % 2]) return ''.join(res)"},{"question":"def processEditorActions(actions): Processes a sequence of editor actions and returns the final state of the string. Parameters: actions (list): A list of strings representing the actions to be performed. Returns: str: The final state of the string after all actions are performed. pass # implement the function here # Unit tests def test_process_editor_actions_insert_only(): assert processEditorActions([\\"INSERT a\\", \\"INSERT b\\", \\"INSERT c\\"]) == \\"abc\\" def test_process_editor_actions_backspace_only(): assert processEditorActions([\\"INSERT a\\", \\"INSERT b\\", \\"BACKSPACE\\", \\"BACKSPACE\\"]) == \\"\\" def test_process_editor_actions_backspace_and_insert(): assert processEditorActions([\\"INSERT a\\", \\"INSERT b\\", \\"BACKSPACE\\", \\"INSERT c\\"]) == \\"ac\\" def test_process_editor_actions_undo_insert(): assert processEditorActions([\\"INSERT a\\", \\"UNDO\\"]) == \\"\\" def test_process_editor_actions_undo_backspace(): assert processEditorActions([\\"INSERT a\\", \\"INSERT b\\", \\"BACKSPACE\\", \\"UNDO\\"]) == \\"ab\\" def test_process_editor_actions_multiple_undos(): assert processEditorActions([\\"INSERT a\\", \\"INSERT b\\", \\"BACKSPACE\\", \\"UNDO\\", \\"UNDO\\"]) == \\"a\\" def test_process_editor_actions_complex_sequence(): assert processEditorActions([\\"INSERT a\\", \\"INSERT b\\", \\"INSERT c\\", \\"BACKSPACE\\", \\"BACKSPACE\\", \\"BACKSPACE\\", \\"UNDO\\"]) == \\"a\\" def test_process_editor_actions_no_actions(): assert processEditorActions([]) == \\"\\" def test_process_editor_actions_only_undo(): assert processEditorActions([\\"UNDO\\", \\"UNDO\\", \\"UNDO\\"]) == \\"\\" if __name__ == \\"__main__\\": test_process_editor_actions_insert_only() test_process_editor_actions_backspace_only() test_process_editor_actions_backspace_and_insert() test_process_editor_actions_undo_insert() test_process_editor_actions_undo_backspace() test_process_editor_actions_multiple_undos() test_process_editor_actions_complex_sequence() test_process_editor_actions_no_actions() test_process_editor_actions_only_undo()","solution":"def processEditorActions(actions): Processes a sequence of editor actions and returns the final state of the string. Parameters: actions (list): A list of strings representing the actions to be performed. Returns: str: The final state of the string after all actions are performed. result = [] history = [] for action in actions: if action.startswith(\\"INSERT\\"): char = action.split()[1] result.append(char) history.append(action) elif action == \\"BACKSPACE\\": if result: # Only backspace if there are characters in the result removed_char = result.pop() history.append(f\\"REMOVE {removed_char}\\") elif action == \\"UNDO\\": if history: last_action = history.pop() if last_action.startswith(\\"INSERT\\"): result.pop() elif last_action.startswith(\\"REMOVE\\"): char = last_action.split()[1] result.append(char) return ''.join(result)"},{"question":"def min_path_cost(grid): Calculate the minimum cost required to move from the top-left corner to the bottom-right corner of the grid. Args: grid (List[List[int]]): A list of lists of integers representing the cost grid. Returns: int: The minimum path cost. Examples: >>> min_path_cost([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 21 >>> min_path_cost([[5]]) == 5 >>> min_path_cost([[1, 3], [1, 5]]) == 7 >>> min_path_cost([ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]) == 7 >>> min_path_cost([ [1, 2, 5], [3, 2, 1], [4, 2, 1] ]) == 7","solution":"def min_path_cost(grid): if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) for i in range(1, n): grid[i][0] += grid[i-1][0] for j in range(1, m): grid[0][j] += grid[0][j-1] for i in range(1, n): for j in range(1, m): grid[i][j] += min(grid[i-1][j], grid[i][j-1]) return grid[-1][-1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_univalue_path(root: TreeNode) -> int: Returns the length of the longest path where all nodes have the same value. pass # Example Test Cases: def test_longest_univalue_path_single_node(): root = TreeNode(1) assert longest_univalue_path(root) == 0 def test_longest_univalue_path_two_nodes_same_value(): root = TreeNode(1, TreeNode(1)) assert longest_univalue_path(root) == 1 def test_longest_univalue_path_two_nodes_different_value(): root = TreeNode(1, TreeNode(2)) assert longest_univalue_path(root) == 0 def test_longest_univalue_path_three_nodes_left_skewed(): root = TreeNode(1, TreeNode(1, TreeNode(1))) assert longest_univalue_path(root) == 2 def test_longest_univalue_path_three_nodes_right_skewed(): root = TreeNode(1, None, TreeNode(1, None, TreeNode(1))) assert longest_univalue_path(root) == 2 def test_longest_univalue_path_mixed(): root = TreeNode(1, TreeNode(1, TreeNode(1), TreeNode(1, None, TreeNode(1))), TreeNode(5)) assert longest_univalue_path(root) == 3 def test_longest_univalue_path_large_tree(): root = TreeNode(1, TreeNode(4, TreeNode(4), TreeNode(4)), TreeNode(5, None, TreeNode(5))) assert longest_univalue_path(root) == 2","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_univalue_path(root): Returns the length of the longest path where all nodes have the same value. def dfs(node): nonlocal longest_path if not node: return 0 left_len = dfs(node.left) right_len = dfs(node.right) left_path = right_path = 0 if node.left and node.left.val == node.val: left_path = left_len + 1 if node.right and node.right.val == node.val: right_path = right_len + 1 longest_path = max(longest_path, left_path + right_path) return max(left_path, right_path) longest_path = 0 dfs(root) return longest_path"},{"question":"def is_palindrome(s: str) -> bool: Helper function to check if a string is a palindrome. return s == s[::-1] def max_sum_of_palindromic_substrings(s: str) -> int: Find the maximum sum of substrings such that no two substrings overlap and each substring is a palindrome. >>> max_sum_of_palindromic_substrings(\\"5\\") 5 >>> max_sum_of_palindromic_substrings(\\"12345\\") 15 >>> max_sum_of_palindromic_substrings(\\"121\\") 121 >>> max_sum_of_palindromic_substrings(\\"12321\\") 12321 >>> max_sum_of_palindromic_substrings(\\"1221\\") 1221 >>> max_sum_of_palindromic_substrings(\\"123454321\\") 123454321 >>> max_sum_of_palindromic_substrings(\\"12332133\\") 123321 + 33 >>> max_sum_of_palindromic_substrings(\\"010\\") 10 >>> max_sum_of_palindromic_substrings(\\"9876789\\") 9876789","solution":"def is_palindrome(s): return s == s[::-1] def max_sum_of_palindromic_substrings(s): n = len(s) dp = [0] * (n + 1) for i in range(1, n + 1): for j in range(i): if is_palindrome(s[j:i]): dp[i] = max(dp[i], dp[j] + int(s[j:i])) return dp[n]"},{"question":"def isPathPossible(grid, threshold): Determines if it is possible to reach the bottom-right corner of the grid from the top-left corner under the constraint that the absolute difference between two consecutive cells in the path is at most \`threshold\`. Movement is allowed only right or down from the current cell. :param grid: List of List of integers representing the grid :param threshold: Integer indicating the maximum allowed absolute difference between two consecutive cells :return: Boolean value indicating if such a path exists","solution":"def isPathPossible(grid, threshold): Determines if it is possible to reach the bottom-right corner of the grid from the top-left corner under the constraint that the absolute difference between two consecutive cells in the path is at most \`threshold\`. Movement is allowed only right or down from the current cell. :param grid: List of List of integers representing the grid :param threshold: Integer indicating the maximum allowed absolute difference between two consecutive cells :return: Boolean value indicating if such a path exists if not grid or not grid[0]: return False rows, cols = len(grid), len(grid[0]) dp = [[False]*cols for _ in range(rows)] dp[0][0] = True for r in range(rows): for c in range(cols): if not dp[r][c]: continue if r+1 < rows and abs(grid[r][c] - grid[r+1][c]) <= threshold: dp[r+1][c] = True if c+1 < cols and abs(grid[r][c] - grid[r][c+1]) <= threshold: dp[r][c+1] = True return dp[rows-1][cols-1]"},{"question":"def min_sessions(tasks: List[int], sessionTime: int) -> int: Given an array of positive integers representing the durations of different tasks, and a positive integer \`sessionTime\`, partition the tasks into the minimum number of sessions such that the sum of task durations in each session is less than or equal to \`sessionTime\`. Each task must be assigned to exactly one session, and tasks cannot be split across sessions. Return the minimum number of sessions needed. >>> min_sessions([1, 2, 3], 3) 2 >>> min_sessions([3, 1, 3, 1, 1], 6) 2 >>> min_sessions([1, 2, 3, 4], 5) 2 >>> min_sessions([5, 5, 5, 5], 5) 4 >>> min_sessions([4], 4) 1 >>> min_sessions([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 3) 4","solution":"def min_sessions(tasks, sessionTime): Returns the minimum number of sessions needed to complete all tasks given that the sum of task durations in each session should not exceed sessionTime. n = len(tasks) dp = [float('inf')] * (1 << n) dp[0] = 1 # Calculate the sum of the tasks for each subset subset_sum = [0] * (1 << n) for mask in range(1 << n): total = 0 for i in range(n): if mask & (1 << i): total += tasks[i] subset_sum[mask] = total # Dynamic programming to find the minimum number of sessions for mask in range(1 << n): if subset_sum[mask] <= sessionTime: dp[mask] = 1 else: submask = mask while submask: if subset_sum[submask] <= sessionTime: dp[mask] = min(dp[mask], dp[mask ^ submask] + 1) submask = (submask - 1) & mask return dp[(1 << n) - 1]"},{"question":"def numIdenticalPairs(arr: List[int]) -> int: Returns the number of good pairs in the array where arr[i] == arr[j] and i < j. >>> numIdenticalPairs([1, 2, 3, 4]) 0 >>> numIdenticalPairs([1, 1, 1, 1]) 6 >>> numIdenticalPairs([1, 2, 3, 1, 1, 3]) 4 >>> numIdenticalPairs([]) 0 >>> numIdenticalPairs([1]) 0 >>> numIdenticalPairs([2, 2]) 1 >>> numIdenticalPairs([3, 3, 4, 2, 3, 4]) 4","solution":"def numIdenticalPairs(arr): Returns the number of good pairs in the array where arr[i] == arr[j] and i < j. count = 0 freq = {} for num in arr: if num in freq: count += freq[num] freq[num] += 1 else: freq[num] = 1 return count"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sum_of_wire_lengths(root): Given a binary tree, return the sum of the shortest wire lengths required to light up all the leaves. from solution import TreeNode, sum_of_wire_lengths def test_sum_of_wire_lengths(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.right.left = TreeNode(5) root.right.right = TreeNode(6) assert sum_of_wire_lengths(root) == 6 def test_single_node(): root = TreeNode(1) assert sum_of_wire_lengths(root) == 0 def test_left_heavy_tree(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) root.left.left.left = TreeNode(4) assert sum_of_wire_lengths(root) == 3 def test_right_heavy_tree(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) root.right.right.right = TreeNode(4) assert sum_of_wire_lengths(root) == 3 def test_balanced_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) assert sum_of_wire_lengths(root) == 2","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sum_of_wire_lengths(root): Given a binary tree, return the sum of the shortest wire lengths required to light up all the leaves. def dfs(node, depth): if not node: return 0 if not node.left and not node.right: return depth return dfs(node.left, depth + 1) + dfs(node.right, depth + 1) return dfs(root, 0)"},{"question":"def shortestBridge(grid: List[List[int]]) -> int: Given a 2D grid representing islands (1) and water (0), returns the length of the shortest bridge needed to connect any two islands by extending over water (0s). >>> shortestBridge([[0, 1], [1, 0]]) == 1 >>> shortestBridge([[0, 1, 0], [0, 0, 0], [0, 0, 1]]) == 2 >>> shortestBridge([[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]]) == 1 >>> shortestBridge([[0]]) == -1 >>> shortestBridge([[1, 1]]) == -1","solution":"from collections import deque def shortestBridge(grid): def in_bounds(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) def dfs(x, y, q): grid[x][y] = 2 q.append((x, y, 0)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if in_bounds(nx, ny) and grid[nx][ny] == 1: dfs(nx, ny, q) found = False q = deque() # Step 1: Find one island and mark it for i in range(len(grid)): if found: break for j in range(len(grid[0])): if grid[i][j] == 1: dfs(i, j, q) found = True break # Step 2: Use BFS to find the shortest path to the second island while q: x, y, dist = q.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if in_bounds(nx, ny): if grid[nx][ny] == 1: return dist if grid[nx][ny] == 0: grid[nx][ny] = 2 q.append((nx, ny, dist + 1)) return -1 # Example usage (debugging purposes) print(shortestBridge([[0,1],[1,0]])) print(shortestBridge([[0,1,0],[0,0,0],[0,0,1]])) print(shortestBridge([[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]))"},{"question":"def min_operations(nums: List[int], m: int) -> int: Returns the minimum number of operations required to make the array 'beautiful'. >>> min_operations([0, 0, 0, 0], 1) == 0 >>> min_operations([1, 3, 5], 4) == 0 >>> min_operations([1, 10], 5) == 4 >>> min_operations([10, 1], 5) == 4 >>> min_operations([-10, 0, 10], 5) == 10 >>> min_operations([1, 100, 1], 10) == 178","solution":"def min_operations(nums, m): Returns the minimum number of operations required to make the array 'beautiful'. n = len(nums) operations = 0 for i in range(1, n): if abs(nums[i] - nums[i - 1]) > m: operations += abs(nums[i] - nums[i - 1]) - m return operations"},{"question":"def is_scramble(s1: str, s2: str) -> bool: Determine if s2 is a scrambled string of s1. Args: s1 (str): First input string. s2 (str): Second input string. Returns: bool: True if s2 is a scrambled string of s1, otherwise False. Examples: >>> is_scramble(\\"abc\\", \\"abc\\") True >>> is_scramble(\\"great\\", \\"rgeat\\") True >>> is_scramble(\\"abc\\", \\"def\\") False >>> is_scramble(\\"\\", \\"\\") True >>> is_scramble(\\"a\\", \\"a\\") True >>> is_scramble(\\"a\\", \\"b\\") False >>> is_scramble(\\"abcdefghijklmnopq\\", \\"efghijklmndopabcq\\") True >>> is_scramble(\\"abc\\", \\"abcd\\") False >>> is_scramble(\\"abc\\", \\"xyz\\") False","solution":"def is_scramble(s1, s2): Returns true if s2 is a scrambled string of s1, otherwise returns false. # Base cases if len(s1) != len(s2): return False if s1 == s2: return True if sorted(s1) != sorted(s2): return False n = len(s1) for i in range(1, n): # Check if there is a valid split that makes s2 a scrambled string of s1 if (is_scramble(s1[:i], s2[:i]) and is_scramble(s1[i:], s2[i:])) or (is_scramble(s1[:i], s2[-i:]) and is_scramble(s1[i:], s2[:-i])): return True return False"},{"question":"class ElevatorSystem: Design an elevator system for a building with \`n\` floors. Each elevator can stop at any floor between 1 and \`n\`. Requests for elevator stops are represented as a list of tuples, where each tuple contains two integers - the current floor where the request is made and the target floor. Methods: - ElevatorSystem(int n, int m): Initializes the elevator system with \`n\` floors and \`m\` elevators. - void request(int currentFloor, int targetFloor): Registers a request to move from \`currentFloor\` to \`targetFloor\`. - List[List[int]] getElevatorStops(): Returns a list of lists, where each inner list contains the floors at which each elevator will stop, in the order they will be visited. def __init__(self, n, m): Initialize the elevator system with \`n\` floors and \`m\` elevators. :param n: Number of floors in the building. :param m: Number of elevators. def request(self, currentFloor, targetFloor): Register a request to move from \`currentFloor\` to \`targetFloor\`. :param currentFloor: The floor where the request is made. :param targetFloor: The target floor to which the user wants to go. def get_elevator_stops(self): Return a list of lists, where each inner list contains the floors at which each elevator will stop, in the order they will be visited. :return: List of lists of integers. # Here are some test cases to validate your solution def test_elevator_initialization(): system = ElevatorSystem(10, 3) assert system.n == 10 assert system.m == 3 assert system.elevator_stops == [[], [], []] def test_single_request(): system = ElevatorSystem(5, 1) system.request(1, 3) stops = system.get_elevator_stops() assert stops == [[1, 3]] def test_multiple_request_one_elevator(): system = ElevatorSystem(6, 1) system.request(1, 5) system.request(3, 4) stops = system.get_elevator_stops() assert stops == [[1, 5, 3, 4]] def test_multiple_request_multiple_elevators(): system = ElevatorSystem(6, 2) system.request(1, 5) system.request(3, 4) system.request(2, 6) system.request(5, 1) stops = system.get_elevator_stops() assert stops == [[1, 5, 2, 6], [3, 4, 5, 1]]","solution":"class ElevatorSystem: def __init__(self, n, m): Initializes the elevator system with \`n\` floors and \`m\` elevators. :param n: Number of floors in the building. :param m: Number of elevators. self.n = n self.m = m self.elevator_stops = [[] for _ in range(m)] self.requests = [] def request(self, currentFloor, targetFloor): Registers a request to move from \`currentFloor\` to \`targetFloor\`. :param currentFloor: The floor where the request is made. :param targetFloor: The target floor to which the user wants to go. self.requests.append((currentFloor, targetFloor)) def get_elevator_stops(self): Returns a list of lists, where each inner list contains the floors at which each elevator will stop, in the order they will be visited. :return: List of lists of integers. for i, request in enumerate(self.requests): currentFloor, targetFloor = request self.elevator_stops[i % self.m].append(currentFloor) self.elevator_stops[i % self.m].append(targetFloor) return self.elevator_stops"},{"question":"def find_duplicates(nums: List[int]) -> List[int]: Returns a list of all integers that appear more than once in nums, preserving their first occurrence order. >>> find_duplicates([1, 2, 2, 3, 4, 4, 5]) [2, 4] >>> find_duplicates([1, 2, 3, 4, 5]) [] >>> find_duplicates([1, 1, 1, 1, 1]) [1] >>> find_duplicates([1, 2, 3, 2, 4, 5, 5, 3]) [2, 3, 5] >>> find_duplicates([]) [] >>> find_duplicates([1]) [] >>> find_duplicates([1, 2]) [] >>> find_duplicates([1, 1]) [1]","solution":"def find_duplicates(nums): Returns a list of all integers that appear more than once in nums, preserving their first occurrence order. seen = set() duplicates = set() result = [] for num in nums: if num in seen: # It's a duplicate duplicates.add(num) else: seen.add(num) # We list duplicates in the order they first appeared in the input list for num in nums: if num in duplicates and num not in result: result.append(num) return result"},{"question":"def longestValidSubarray(eventOrder: List[int], k: int) -> int: You are given an array of integers \`eventOrder\` where \`eventOrder[i]\` represents the ID of the \`i\`th event a user has participated in, and an integer \`k\` which represents the maximum number of distinct event IDs allowed in a valid contiguous subarray. The objective is to find the length of the longest contiguous subarray that contains no more than \`k\` distinct event IDs. >>> longestValidSubarray([1, 2, 1, 2, 3], 2) 4 >>> longestValidSubarray([1, 2, 3, 4, 5], 3) 3 >>> longestValidSubarray([1, 1, 1, 1], 1) 4 >>> longestValidSubarray([1, 2, 3], 0) 0 >>> longestValidSubarray([], 1) 0 >>> longestValidSubarray([1, 1, 2, 2, 3, 3, 4, 4], 5) 8","solution":"def longestValidSubarray(eventOrder, k): from collections import defaultdict n = len(eventOrder) if n == 0 or k == 0: return 0 left = 0 max_length = 0 event_count = defaultdict(int) for right in range(n): event_count[eventOrder[right]] += 1 while len(event_count) > k: event_count[eventOrder[left]] -= 1 if event_count[eventOrder[left]] == 0: del event_count[eventOrder[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List, Optional def most_frequent_word(words: List[str], sentences: List[str]) -> Optional[str]: Given a list of \`words\` and an array \`sentences\` consisting of multiple sentences, return the word that appears the most frequently across all the sentences within the list. If there is a tie, return the word that comes first lexicographically (alphabetically). Note that the comparison should be case-insensitive and the result should be returned in lowercase. >>> most_frequent_word([\\"apple\\"], [\\"I have an apple\\", \\"He likes apple\\", \\"apple pie is delicious\\"]) 'apple' >>> most_frequent_word([\\"apple\\", \\"banana\\"], [\\"I like apple\\", \\"He likes apple and banana\\", \\"banana is good\\"]) 'apple' >>> most_frequent_word([\\"Apple\\", \\"Banana\\"], [\\"apple Apple\\", \\"BANANA apple\\", \\"banana BANANA\\"]) 'apple' >>> most_frequent_word([\\"pear\\"], [\\"An apple a day\\", \\"Keeps the doctor away\\"]) None >>> most_frequent_word([\\"apple\\", \\"banana\\", \\"cherry\\"], [\\"apple banana apple\\", \\"banana apple cherry\\", \\"cherry banana apple\\"]) 'apple' >>> most_frequent_word([\\"apple\\", \\"banana\\"], []) None","solution":"def most_frequent_word(words, sentences): from collections import Counter import re word_count = Counter() word_set = set(word.lower() for word in words) for sentence in sentences: sentence_words = re.findall(r'bw+b', sentence.lower()) for word in sentence_words: if word in word_set: word_count[word] += 1 if not word_count: return None most_common_word = min(word_count.items(), key=lambda x: (-x[1], x[0]))[0] return most_common_word"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longest_path_sum(root): Returns the sum of values of the longest path in the binary tree. If there are multiple longest paths, returns the maximum sum among them. import pytest def test_single_node(): root = TreeNode(10) assert longest_path_sum(root) == 10 def test_two_nodes(): root = TreeNode(2, TreeNode(3)) assert longest_path_sum(root) == 5 def test_balanced_tree(): root = TreeNode(1, TreeNode(2), TreeNode(3)) assert longest_path_sum(root) == 4 def test_unbalanced_tree(): root = TreeNode(1, TreeNode(2, TreeNode(3)), TreeNode(4)) assert longest_path_sum(root) == 6 def test_complex_tree(): root = TreeNode(5, TreeNode(4, TreeNode(11, TreeNode(7), TreeNode(2) ), right=None ), TreeNode(8, TreeNode(13), TreeNode(4, right=TreeNode(1) ) ) ) assert longest_path_sum(root) == 27","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longest_path_sum(root): Returns the sum of values of the longest path in the binary tree. If there are multiple longest paths, returns the maximum sum among them. def dfs(node): if not node: return (0, 0) # (max depth, max sum at max depth) left_depth, left_sum = dfs(node.left) right_depth, right_sum = dfs(node.right) if left_depth > right_depth: return (left_depth + 1, left_sum + node.value) elif right_depth > left_depth: return (right_depth + 1, right_sum + node.value) else: return (left_depth + 1, max(left_sum, right_sum) + node.value) _, max_path_sum = dfs(root) return max_path_sum"},{"question":"from typing import List def fairRatingScore(ratings: List[int], m: int) -> float: Calculates the fair rating score for a movie by removing the lowest \`m\` ratings and the highest \`m\` ratings and then averaging the remaining ratings. If there are fewer than \`2 * m\` ratings, returns -1. >>> fairRatingScore([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == 5.5 >>> fairRatingScore([1, 2, 3, 4], 2) == -1 >>> fairRatingScore([1, 2, 3, 4, 5, 6], 2) == 3.5 >>> fairRatingScore([5, 5, 5, 5, 5], 1) == 5.0 >>> fairRatingScore([-1, -2, -3, -4, -5, -6, -7, -8, -9, -10], 2) == -5.5","solution":"from typing import List def fairRatingScore(ratings: List[int], m: int) -> float: Calculates the fair rating score for a movie by removing the lowest \`m\` ratings and the highest \`m\` ratings and then averaging the remaining ratings. If there are fewer than \`2 * m\` ratings, returns -1. if len(ratings) < 2 * m: return -1 # Sort the ratings to easily remove the lowest and highest \`m\` ratings sorted_ratings = sorted(ratings) # Remove the lowest \`m\` and the highest \`m\` ratings trimmed_ratings = sorted_ratings[m:-m] # Calculate the average of the remaining ratings if len(trimmed_ratings) == 0: return -1 return sum(trimmed_ratings) / len(trimmed_ratings)"},{"question":"def birthday_candles(nums: List[int]) -> int: Finds out the number of tallest candles that can be blown out. Parameters: nums (list): A list of non-negative integers representing candle heights. Returns: int: Number of tallest candles. >>> birthday_candles([]) == 0 >>> birthday_candles([5]) == 1 >>> birthday_candles([3, 3, 3]) == 3 >>> birthday_candles([3, 2, 1, 3]) == 2 >>> birthday_candles([1, 2, 3, 4, 5]) == 1 >>> birthday_candles([2]*1000 + [3]*2000 + [4]*3000 + [5]*4000) == 4000","solution":"def birthday_candles(nums): Finds out the number of tallest candles that can be blown out. Parameters: nums (list): A list of non-negative integers representing candle heights. Returns: int: Number of tallest candles. if not nums: return 0 max_height = max(nums) return nums.count(max_height)"},{"question":"def min_jumps(heights: List[int]) -> int: You are given an integer array \`heights\` representing the height of stones arranged in a row. You can make a jump from one stone to another if the next stone is of the same height or any height less than or equal to the maximum height you've jumped before. Return the **minimum** number of jumps required to reach the last stone from the first stone in the array. If it is not possible to reach the last stone, return -1. >>> min_jumps([1, 2, 3, 4, 5]) # single step jumps 4 >>> min_jumps([3, 2, 1, 0, 4]) # no possible jump to the end -1 >>> min_jumps([2, 3, 1, 1, 4]) # minimum jumps are 2 (Index 0 to 1, Index 1 to # # #","solution":"def min_jumps(heights): n = len(heights) if n <= 1: return 0 max_reach = heights[0] jumps = 1 steps = heights[0] for i in range(1, n): if i == n-1: return jumps max_reach = max(max_reach, i + heights[i]) steps -= 1 if steps == 0: jumps += 1 if i >= max_reach: return -1 steps = max_reach - i return -1"},{"question":"def reverse_words(s: str) -> str: Given a string s consisting of multiple words separated by spaces, reverse the order of words in the string while preserving the original whitespace, reducing multiple spaces between words to a single space, and ensuring words are separated by a single space in the reversed output. Args: s (str): Input string. Returns: str: The resulting string after reversing the word order. >>> reverse_words(\\"hello\\") == \\"hello\\" >>> reverse_words(\\"hello world\\") == \\"world hello\\" >>> reverse_words(\\" hello world\\") == \\"world hello\\" >>> reverse_words(\\"hello world \\") == \\"world hello\\" >>> reverse_words(\\"hello world\\") == \\"world hello\\" >>> reverse_words(\\"the quick brown fox\\") == \\"fox brown quick the\\" >>> reverse_words(\\" hello world \\") == \\"world hello\\" >>> reverse_words(\\"\\") == \\"\\" >>> reverse_words(\\" \\") == \\"\\"","solution":"def reverse_words(s): Given a string s consisting of multiple words separated by spaces, reverses the order of words in the string while preserving the original whitespace, reducing multiple spaces between words to a single space, and ensuring words are separated by a single space in the reversed output. Args: s (str): Input string. Returns: str: The resulting string after reversing the word order. words = s.split() reversed_words = words[::-1] result = ' '.join(reversed_words) return result"},{"question":"from typing import List def count_cinephile_pairs(arr: List[int]) -> int: Returns the number of unique pairs of users who are cinephiles. >>> count_cinephile_pairs([1, 2, 3, 4, 5]) 0 >>> count_cinephile_pairs([1, 2, 2, 3, 4]) 1 >>> count_cinephile_pairs([1, 1, 2, 2, 2, 3, 4]) 4 >>> count_cinephile_pairs([2, 2, 2, 2]) 6 >>> count_cinephile_pairs([]) 0 >>> count_cinephile_pairs([3]) 0 >>> count_cinephile_pairs([3]*1000) 499500","solution":"from collections import defaultdict def count_cinephile_pairs(arr): Returns the number of unique pairs of users who are cinephiles. movie_count = defaultdict(int) # Count occurrences of each number of movies watched for count in arr: movie_count[count] += 1 total_pairs = 0 # Calculate the number of pairs for each movie count for count in movie_count.values(): if count > 1: total_pairs += count * (count - 1) // 2 return total_pairs"},{"question":"def combination_sum(arr: List[int], target: int) -> bool: Determine if there exists a combination of elements in the array that sums up to the target. Each element can be used multiple times. >>> combination_sum([2, 3, 5], 8) True # 3+5 or 2+2+2+2 >>> combination_sum([2, 3, 5], 7) True # 2+5 >>> combination_sum([3, 6, 7], 5) False # No combination can make 5 >>> combination_sum([2, 4], 7) False # No combination can make 7 >>> combination_sum([1], 5) True # 1+1+1+1+1 >>> combination_sum([5, 10, 20], 15) True # 5+10 >>> combination_sum([7], 14) True # 7+7","solution":"def combination_sum(arr, target): Determine if there exists a combination of elements in arr that sums up to the target. Each element can be used multiple times. if target == 0: return True if target < 0: return False for num in arr: if combination_sum(arr, target - num): return True return False"},{"question":"def find_buildings(heights): Returns the list of indices of the buildings that have a clear view. Parameters: heights (List[int]): A list of integers representing the heights of buildings. Returns: List[int]: A list of indices of the buildings that have a clear view, sorted in ascending order. Examples: >>> find_buildings([4, 2, 3, 1]) [0, 2, 3] >>> find_buildings([4, 3, 2, 1]) [0, 1, 2, 3] >>> find_buildings([1, 3, 2, 4]) [3] >>> find_buildings([2, 2, 2, 2]) [3] >>> find_buildings([3, 2, 4, 2]) [2, 3]","solution":"def find_buildings(heights): Returns the list of indices of the buildings that have a clear view. n = len(heights) result = [] max_height_seen_so_far = -1 for i in range(n - 1, -1, -1): if heights[i] > max_height_seen_so_far: result.append(i) max_height_seen_so_far = heights[i] return result[::-1]"},{"question":"def find_words_with_one_row(words: List[str]) -> List[str]: Given a non-empty list of words, return a list containing all the words that can be typed using letters of the alphabet on only one row of a standard QWERTY keyboard. >>> find_words_with_one_row([\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"]) ['Alaska', 'Dad'] >>> find_words_with_one_row([\\"QWERTY\\", \\"SAD\\", \\"ZXC\\"]) ['QWERTY', 'SAD', 'ZXC'] >>> find_words_with_one_row([\\"Hello\\", \\"AlAskA\\", \\"dAD\\", \\"peAce\\"]) ['AlAskA', 'dAD'] >>> find_words_with_one_row([\\"Chicken\\", \\"Broccoli\\"]) [] >>> find_words_with_one_row([\\"a\\", \\"Q\\", \\"m\\"]) ['a', 'Q', 'm']","solution":"def find_words_with_one_row(words): Given a non-empty list of words, return a list containing all the words that can be typed using letters of the alphabet on only one row of a standard QWERTY keyboard. row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") def can_be_typed_with_one_row(word): lower_word = word.lower() return (set(lower_word).issubset(row1) or set(lower_word).issubset(row2) or set(lower_word).issubset(row3)) return [word for word in words if can_be_typed_with_one_row(word)]"},{"question":"from typing import List def count_patterns(s: str, patterns: List[str]) -> List[int]: Returns the number of times each pattern in patterns appears as a substring in s. >>> count_patterns(\\"abcabcabc\\", [\\"abc\\", \\"bc\\", \\"a\\", \\"d\\"]) [3, 3, 3, 0] >>> count_patterns(\\"aaaaa\\", [\\"a\\", \\"aa\\", \\"aaa\\", \\"b\\"]) [5, 4, 3, 0]","solution":"def count_patterns(s, patterns): Returns the number of times each pattern in patterns appears as a substring in s. result = [] for pattern in patterns: count = 0 start = 0 while True: start = s.find(pattern, start) if start == -1: # No more occurrences found break count += 1 start += 1 # Move past the last found occurrence result.append(count) return result"},{"question":"def min_watering_operations(heights: List[int], range: int) -> int: Returns the minimum number of watering operations required to water all the plants. Parameters: heights (List[int]): List of integers representing the heights of plants. range (int): The fixed range of the watering can. Returns: int: Minimum number of watering operations required. >>> min_watering_operations([], 3) 0 >>> min_watering_operations([1], 3) 1 >>> min_watering_operations([1, 2, 3, 4, 5], 4) 1 >>> min_watering_operations([1, 3, 5, 7, 9], 2) 3 >>> min_watering_operations([1, 10, 20, 21, 22, 23, 30], 5) 4","solution":"def min_watering_operations(heights, range): Returns the minimum number of watering operations required to water all the plants. :param heights: List of integers representing the heights of plants. :param range: Integer, the fixed range of the watering can. :return: Integer, minimum number of watering operations required. if not heights: return 0 heights.sort() operations = 0 i = 0 n = len(heights) while i < n: # Start a new watering operation operations += 1 # Find the maximum height that can be watered in this operation coverage_end = heights[i] + range while i < n and heights[i] <= coverage_end: i += 1 return operations"},{"question":"def min_removals_to_unique_deck(nums: List[int], m: int) -> int: Returns the minimum number of cards that need to be removed from the deck so that the deck contains at most one card of each value from 1 to m. >>> min_removals_to_unique_deck([1, 2, 3, 4], 4) == 0 >>> min_removals_to_unique_deck([1, 2, 2, 4], 4) == 1 >>> min_removals_to_unique_deck([5, 6, 7, 8], 4) == 4 >>> min_removals_to_unique_deck([1, 2, 2, 3, 3, 5, 6], 4) == 4 >>> min_removals_to_unique_deck([], 4) == 0 >>> min_removals_to_unique_deck([1, 1, 1, 1], 4) == 3 >>> min_removals_to_unique_deck([10, 20, 30], 3) == 3","solution":"def min_removals_to_unique_deck(nums, m): Returns the minimum number of cards that need to be removed from the deck so that the deck contains at most one card of each value from 1 to m. # Create a frequency dictionary to count occurrences of each card value freq = {} for num in nums: if num not in freq: freq[num] = 0 freq[num] += 1 # Calculate the number of removals needed removals = 0 for key, count in freq.items(): if key <= m and count > 1: removals += count - 1 elif key > m: removals += count return removals"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head: ListNode) -> bool: Detect if a singly linked list has a cycle. :type head: ListNode :rtype: bool pass # implementation here # Unit Test Cases def test_no_cycle(): head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) assert hasCycle(head) == False def test_single_node_no_cycle(): head = ListNode(1) assert hasCycle(head) == False def test_cycle(): head = ListNode(1) second = ListNode(2) third = ListNode(3) head.next = second second.next = third third.next = head # Create a cycle assert hasCycle(head) == True def test_cycle_in_middle(): head = ListNode(1) second = ListNode(2) third = ListNode(3) fourth = ListNode(4) head.next = second second.next = third third.next = fourth fourth.next = second # Create a cycle here assert hasCycle(head) == True def test_empty_list(): head = None assert hasCycle(head) == False","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head): Detect if a singly linked list has a cycle. :type head: ListNode :rtype: bool slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"def min_swaps_to_palindrome(s: str) -> int: You are given a string \`s\` consisting of only lowercase letters. You can select any two non-overlapping substrings of \`s\` and swap them. The goal is to make the string a palindrome with the minimum number of such operations. If it is not possible to make \`s\` a palindrome, return \`-1\`. >>> min_swaps_to_palindrome(\\"mamad\\") 3 >>> min_swaps_to_palindrome(\\"aabb\\") 2 >>> min_swaps_to_palindrome(\\"aabbcca\\") 4 >>> min_swaps_to_palindrome(\\"racecar\\") 0 >>> min_swaps_to_palindrome(\\"abc\\") -1 >>> min_swaps_to_palindrome(\\"abcd\\") -1 >>> min_swaps_to_palindrome(\\"aa\\") 0 >>> min_swaps_to_palindrome(\\"aba\\") 0 >>> min_swaps_to_palindrome(\\"abba\\") 0 >>> min_swaps_to_palindrome(\\"\\") 0 >>> min_swaps_to_palindrome(\\"a\\") 0 pass","solution":"def min_swaps_to_palindrome(s): from collections import Counter # Function to return the minimum number of swaps needed to make a palindrome def count_min_swaps(data): n = len(data) if data == data[::-1]: return 0 data = list(data) min_swaps = 0 i, j = 0, n-1 while i < j: if data[i] != data[j]: k = j while k > i and data[k] != data[i]: k -= 1 if k == i: data[i], data[i+1] = data[i+1], data[i] min_swaps += 1 else: for l in range(k, j): data[l], data[l+1] = data[l+1], data[l] min_swaps += 1 i += 1 j -= 1 else: i += 1 j -= 1 return min_swaps # Count characters' frequencies freq = Counter(s) odd_count = sum(1 for count in freq.values() if count % 2 != 0) # If more than one character has an odd frequency, it is impossible if odd_count > 1: return -1 return count_min_swaps(s)"},{"question":"def min_lexicographical_order(s: str, k: int) -> str: Returns the lexicographically smallest string possible after performing at most k operations where each operation consists of moving any character in the string to the beginning. :param s: A string consisting of lowercase English letters :param k: An integer specifying the maximum number of operations allowed :return: The lexicographically smallest string achievable within the given constraints >>> min_lexicographical_order(\\"cba\\", 1) \\"acb\\" >>> min_lexicographical_order(\\"ba\\", 1) \\"ab\\" >>> min_lexicographical_order(\\"cba\\", 2) \\"abc\\" >>> min_lexicographical_order(\\"dcbaxyz\\", 3) \\"abcdxyz\\" >>> min_lexicographical_order(\\"abcdef\\", 0) \\"abcdef\\" from solution import min_lexicographical_order def test_min_lexicographical_order_k_1(): assert min_lexicographical_order(\\"cba\\", 1) == \\"acb\\" assert min_lexicographical_order(\\"ba\\", 1) == \\"ab\\" assert min_lexicographical_order(\\"dcab\\", 1) == \\"abdc\\" def test_min_lexicographical_order_k_greater_1(): assert min_lexicographical_order(\\"cba\\", 2) == \\"abc\\" assert min_lexicographical_order(\\"ba\\", 2) == \\"ab\\" assert min_lexicographical_order(\\"dcbaxyz\\", 3) == \\"abcdxyz\\" assert min_lexicographical_order(\\"geeks\\", 3) == \\"eegks\\" def test_min_lexicographical_order_k_0(): assert min_lexicographical_order(\\"abcdef\\", 0) == \\"abcdef\\" assert min_lexicographical_order(\\"zzzz\\", 0) == \\"zzzz\\"","solution":"def min_lexicographical_order(s, k): Returns the lexicographically smallest string possible after performing at most k operations where each operation consists of moving any character in the string to the beginning. :param s: A string consisting of lowercase English letters :param k: An integer specifying the maximum number of operations allowed :return: The lexicographically smallest string achievable within the given constraints if k == 1: # If k is 1, we can only rotate the string fully and find the minimum rotation n = len(s) return min(s[i:] + s[:i] for i in range(n)) else: # If k > 1, we can freely sort the string to get the lexicographically smallest result return ''.join(sorted(s))"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def subtreeWithAllDeepest(root: TreeNode) -> TreeNode: Given a binary tree, find the smallest subtree with all the deepest nodes. >>> root = TreeNode(3) >>> root.left = TreeNode(5) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(6) >>> root.left.right = TreeNode(2, TreeNode(7), TreeNode(4)) >>> root.right.left = TreeNode(0) >>> root.right.right = TreeNode(8) >>> subtreeWithAllDeepest(root).val 2 pass def test_subtree_with_all_deepest(): # Construct the example tree: # 3 # / # 5 1 # /| | # 6 2 0 8 # / # 7 4 node7 = TreeNode(7) node4 = TreeNode(4) node2 = TreeNode(2, node7, node4) node6 = TreeNode(6) node5 = TreeNode(5, node6, node2) node0 = TreeNode(0) node8 = TreeNode(8) node1 = TreeNode(1, node0, node8) root = TreeNode(3, node5, node1) # The subtree with all the deepest nodes is node with value 2 assert subtreeWithAllDeepest(root).val == 2 def test_single_node_tree(): root = TreeNode(1) assert subtreeWithAllDeepest(root).val == 1 def test_left_heavy_tree(): # Construct a left-heavy tree: # 1 # / # 2 # / # 3 node3 = TreeNode(3) node2 = TreeNode(2, node3) root = TreeNode(1, node2) # The deepest node is 3, so the subtree with all the deepest nodes is 3 itself assert subtreeWithAllDeepest(root).val == 3 def test_right_heavy_tree(): # Construct a right-heavy tree: # 1 # # 2 # # 3 node3 = TreeNode(3) node2 = TreeNode(2, None, node3) root = TreeNode(1, None, node2) # The deepest node is 3, so the subtree with all the deepest nodes is 3 itself assert subtreeWithAllDeepest(root).val == 3 def test_balanced_tree(): # Construct a balanced tree: # 1 # / # 2 3 # / # 4 5 node4 = TreeNode(4) node5 = TreeNode(5) node2 = TreeNode(2, node4, node5) node3 = TreeNode(3) root = TreeNode(1, node2, node3) # The deepest nodes are 4 and 5, so the subtree with all the deepest nodes is 2 assert subtreeWithAllDeepest(root).val == 2","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def subtreeWithAllDeepest(root: TreeNode) -> TreeNode: def dfs(node): if not node: return (None, 0) left_result = dfs(node.left) right_result = dfs(node.right) if left_result[1] > right_result[1]: return (left_result[0], left_result[1] + 1) elif left_result[1] < right_result[1]: return (right_result[0], right_result[1] + 1) else: return (node, left_result[1] + 1) result = dfs(root) return result[0]"},{"question":"def max_two_events(events: List[List[int]]) -> int: You are given an array \`events\` where \`events[i] = [startDayi, endDayi, valuei]\`, and you can attend at most two non-overlapping events. Select two non-overlapping events such that their combined value is maximized. Each event must be attended for the entire duration from its \`startDay\` to its \`endDay\` (inclusive). You may assume that \`events\` is sorted by \`endDay\`. Return the maximum combined value of the two non-overlapping events you can attend. >>> max_two_events([[1, 2, 4], [3, 4, 3], [2, 3, 1]]) 7 >>> max_two_events([[1, 3, 2], [4, 5, 2], [6, 7, 2]]) 4 >>> max_two_events([[1, 2, 5], [3, 4, 6], [4, 5, 1]]) 11 >>> max_two_events([[1, 3, 5], [6, 6, 8], [7, 8, 1]]) 13 >>> max_two_events([[1, 10, 11], [10, 20, 5], [30, 40, 15]]) 26","solution":"def maxTwoEvents(events): events.sort(key=lambda x: x[1]) # Sort events by endDay def upper_bound(event_list, day): Binary search to find the index of the first event in the event_list whose endDay is greater than the given day low, high = 0, len(event_list) while low < high: mid = (low + high) // 2 if event_list[mid][1] <= day: low = mid + 1 else: high = mid return low max_single_event = 0 max_combined_value = 0 single_event_values = [] # To store maximum value before each event # Traverse each event for i in range(len(events)): # Maximum single event value till the current event's startDay idx = upper_bound(events, events[i][0] - 1) max_single_event = single_event_values[idx - 1] if idx > 0 else 0 # Update the maximum combined value considering the current event max_combined_value = max(max_combined_value, max_single_event + events[i][2]) # Update the single event values list if i == 0: single_event_values.append(events[i][2]) else: single_event_values.append(max(single_event_values[-1], events[i][2])) return max_combined_value"},{"question":"def is_anagram(s1: str, s2: str) -> bool: Determines if s2 is an anagram of s1, ignoring spaces and capitalization. >>> is_anagram(\\"listen\\", \\"listen\\") == True >>> is_anagram(\\"listen\\", \\"silent\\") == True >>> is_anagram(\\"conversation\\", \\"voices rant on\\") == True >>> is_anagram(\\"Listen\\", \\"SiLenT\\") == True >>> is_anagram(\\"hello\\", \\"world\\") == False >>> is_anagram(\\"one\\", \\"two\\") == False >>> is_anagram(\\"aabbcc\\", \\"abcabc\\") == True >>> is_anagram(\\"aabbcc\\", \\"abcab\\") == False >>> is_anagram(\\"\\", \\"\\") == True >>> is_anagram(\\"a\\", \\"\\") == False >>> is_anagram(\\"\\", \\"a\\") == False","solution":"def is_anagram(s1, s2): Determines if s2 is an anagram of s1, ignoring spaces and capitalization. Args: s1 (str): First string. s2 (str): Second string. Returns: bool: True if s2 is an anagram of s1, False otherwise. # Remove spaces and convert to lowercase s1_cleaned = s1.replace(\\" \\", \\"\\").lower() s2_cleaned = s2.replace(\\" \\", \\"\\").lower() # Sort the characters and compare return sorted(s1_cleaned) == sorted(s2_cleaned)"},{"question":"def digit_root(n: int) -> int: Returns the sum of the digits of a positive integer n, repeated until a single-digit result is produced. >>> digit_root(5) 5 >>> digit_root(38) 2 # 3 + 8 = 11, 1 + 1 = 2 >>> digit_root(99) 9 # 9 + 9 = 18, 1 + 8 = 9 >>> digit_root(12345) 6 # 1 + 2 + 3 + 4 + 5 = 15, 1 + 5 = 6 >>> digit_root(0) 0 # Edge case: single digit 0 >>> digit_root(987654321) 9 # Sum of digits is a repeated process until single digit","solution":"def digit_root(n): Returns the sum of the digits of a positive integer n, repeated until a single-digit result is produced. while n >= 10: n = sum(int(digit) for digit in str(n)) return n"},{"question":"def nextPermutation(nums): Rearranges numbers into the lexicographically next greater permutation. If not possible, rearranges into sorted order in ascending order. >>> arr = [1, 2, 3] >>> nextPermutation(arr) >>> arr [1, 3, 2] >>> arr = [3, 2, 1] >>> nextPermutation(arr) >>> arr [1, 2, 3] >>> arr = [1, 1, 5] >>> nextPermutation(arr) >>> arr [1, 5, 1]","solution":"def nextPermutation(nums): Rearranges numbers into the lexicographically next greater permutation. If not possible, rearranges into sorted order in ascending order. # Step 1: Find the largest index k such that nums[k] < nums[k + 1] k = -1 for i in range(len(nums) - 1): if nums[i] < nums[i + 1]: k = i if k == -1: # No increasing pair found, nums are in descending order nums.reverse() # Completely reverse the nums to get the smallest permutation return # Step 2: Find the largest index l greater than k such that nums[k] < nums[l] l = -1 for i in range(k + 1, len(nums)): if nums[k] < nums[i]: l = i # Step 3: Swap the value of nums[k] with that of nums[l] nums[k], nums[l] = nums[l], nums[k] # Step 4: Reverse the sequence from nums[k + 1] to the end nums[k + 1:] = reversed(nums[k + 1:])"},{"question":"def has_cycle(n, edges): Determines if a directed graph has a cycle using depth-first search (DFS). Args: n: Number of nodes in the graph. edges: List of edges in the graph where each edge is represented by a list [u, v]. Returns: True if there is a cycle in the graph, False otherwise. >>> has_cycle(5, [[0, 1], [1, 2], [2, 3], [3, 4]]) False >>> has_cycle(3, [[0, 1], [1, 2], [2, 0]]) True >>> has_cycle(4, [[0, 1], [1, 2], [2, 0], [3, 4]]) True >>> has_cycle(4, [[0, 1], [2, 3]]) False >>> has_cycle(3, [[0, 0], [1, 2]]) True >>> has_cycle(4, [[0, 1], [1, 2], [2, 0], [2, 3], [3, 1]]) True >>> has_cycle(3, []) False >>> has_cycle(5, [[0, 1], [1, 2], [2, 3], [1, 4], [4, 3]]) False >>> has_cycle(1, []) False >>> has_cycle(4, [[0, 1], [2, 3]]) False","solution":"def has_cycle(n, edges): Determines if a directed graph has a cycle. Args: n: Number of nodes in the graph. edges: List of edges in the graph where each edge is represented by a list [u, v]. Returns: True if there is a cycle in the graph, False otherwise. from collections import defaultdict # Build adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) # States: 0 = unvisited, 1 = visiting, 2 = visited state = [0] * n def dfs(node): if state[node] == 1: # Found a cycle return True if state[node] == 2: # Already fully visited return False # Mark the node as visiting state[node] = 1 for neighbor in graph[node]: if dfs(neighbor): return True # Mark the node as fully visited state[node] = 2 return False for i in range(n): if state[i] == 0: # Only start DFS if the node is unvisited if dfs(i): return True return False"},{"question":"from typing import List def min_distance_with_segments(arr: List[int], k: int) -> int: Given an array of integers \`arr\` of length \`n\`, where each integer represents a position on a number line, and an integer \`k\`, return the minimum distance required to cover all positions by having at most \`k\` segments. Each segment is a continuous part of the number line, and you can place segments in such a way that all positions in \`arr\` are covered. Note that the ends of a segment can overlap with positions in \`arr\`. >>> min_distance_with_segments([1, 2, 3], 3) 0 >>> min_distance_with_segments([1, 2, 3, 10], 1) 9 >>> min_distance_with_segments([1, 2, 4, 7, 10], 2) 6 >>> min_distance_with_segments([1, 100, 200, 300], 2) 199 >>> min_distance_with_segments([10, 20, 30], 3) 0 >>> min_distance_with_segments([5], 1) 0 >>> min_distance_with_segments([10, 10, 10], 1) 0 >>> min_distance_with_segments([1, 2, 3, 6, 7, 8, 11, 12, 13], 3) 6","solution":"def min_distance_with_segments(arr, k): arr.sort() n = len(arr) if k >= n: return 0 gaps = [] for i in range(1, n): gaps.append(arr[i] - arr[i - 1]) gaps.sort(reverse=True) # Select the largest k-1 gaps to minimize the total distance of segments return arr[-1] - arr[0] - sum(gaps[:k-1])"},{"question":"from collections import deque def min_steps_to_reach_goal(m, n, sx, sy, gx, gy, obstacles): Find the minimum number of steps for the robot to reach from (sx, sy) to (gx, gy) in an m x n grid, avoiding obstacles. Parameters: - m (int): Number of rows in the grid. - n (int): Number of columns in the grid. - sx (int): Starting x-coordinate. - sy (int): Starting y-coordinate. - gx (int): Goal x-coordinate. - gy (int): Goal y-coordinate. - obstacles (list of tuples): List of obstacle coordinates (ox, oy). Returns: - int: Minimum number of steps to reach the goal or -1 if unreachable. >>> min_steps_to_reach_goal(5, 5, 0, 0, 4, 4, []) 8 >>> min_steps_to_reach_goal(3, 3, 0, 0, 2, 2, []) 4 >>> min_steps_to_reach_goal(5, 5, 0, 0, 4, 4, [(2, 2), (3, 3)]) 8 >>> min_steps_to_reach_goal(5, 5, 0, 0, 4, 4, [(0, 0)]) -1 >>> min_steps_to_reach_goal(5, 5, 0, 0, 4, 4, [(4, 4)]) -1 >>> min_steps_to_reach_goal(3, 3, 0, 0, 2, 2, [(0, 1), (1, 0), (1, 2), (2, 1)]) -1 >>> min_steps_to_reach_goal(100, 100, 0, 0, 99, 99, []) 198 >>> min_steps_to_reach_goal(5, 5, -1, 0, 4, 4, []) -1 >>> min_steps_to_reach_goal(5, 5, 0, 0, 5, 4, []) -1","solution":"from collections import deque def min_steps_to_reach_goal(m, n, sx, sy, gx, gy, obstacles): Find the minimum number of steps for the robot to reach from (sx, sy) to (gx, gy) in an m x n grid, avoiding obstacles. Parameters: - m (int): Number of rows in the grid. - n (int): Number of columns in the grid. - sx (int): Starting x-coordinate. - sy (int): Starting y-coordinate. - gx (int): Goal x-coordinate. - gy (int): Goal y-coordinate. - obstacles (list of tuples): List of obstacle coordinates (ox, oy). Returns: - int: Minimum number of steps to reach the goal or -1 if unreachable. # Directions for moving up, down, left, and right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # If start or goal is an obstacle or out of bounds, return -1 if (sx, sy) in obstacles or (gx, gy) in obstacles: return -1 if not (0 <= sx < m and 0 <= sy < n) or not (0 <= gx < m and 0 <= gy < n): return -1 # Set of obstacle positions for O(1) look-up obstacles = set(obstacles) # BFS queue initialized with the start position and step count of 0 queue = deque([(sx, sy, 0)]) visited = set((sx, sy)) while queue: x, y, steps = queue.popleft() # If the goal is reached, return the steps count if (x, y) == (gx, gy): return steps # Explore the neighboring cells for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and (nx, ny) not in obstacles: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) # If no path found to goal, return -1 return -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSum(root): Finds the maximum cost path from the root to any leaf node in the binary tree. :param root: TreeNode, the root of the binary tree :return: int, the maximum cost path from the root to any leaf node from solution import TreeNode, maxPathSum def test_single_node(): root = TreeNode(10) assert maxPathSum(root) == 10 def test_left_skewed_tree(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) root.left.left.left = TreeNode(4) assert maxPathSum(root) == 10 def test_right_skewed_tree(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) root.right.right.right = TreeNode(4) assert maxPathSum(root) == 10 def test_balanced_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) assert maxPathSum(root) == 11 # Path: 1 -> 3 -> 7 def test_mixed_tree(): root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(20) root.left.left = TreeNode(1) root.right.left = TreeNode(15) root.right.right = TreeNode(25) assert maxPathSum(root) == 55 # Path: 10 -> 20 -> 25","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSum(root): Finds the maximum cost path from the root to any leaf node in the binary tree. :param root: TreeNode, the root of the binary tree :return: int, the maximum cost path from the root to any leaf node if not root: return 0 def maxCost(node): if not node: return float('-inf') if not node.left and not node.right: return node.val left_cost = maxCost(node.left) right_cost = maxCost(node.right) return node.val + max(left_cost, right_cost) return maxCost(root)"},{"question":"def max_length_subarray(nums: List[int], target: int) -> int: Finds the length of the longest contiguous subarray such that the sum of its elements is at most target. >>> max_length_subarray([1, 2, 3, 4, 5], 9) 3 >>> max_length_subarray([1, 2, 3, 4, 5], 15) 5 >>> max_length_subarray([1, 2, 3, 4, 5], 5) 2 >>> max_length_subarray([1, 2, 3, 4, 5], 1) 1 >>> max_length_subarray([1, 2, 3, 4, 5], 0) 0 >>> max_length_subarray([5, 6, 7, 8], 1) 0 >>> max_length_subarray([], 10) 0 >>> max_length_subarray([2], 1) 0 >>> max_length_subarray([2], 2) 1 >>> max_length_subarray([2], 3) 1","solution":"def max_length_subarray(nums, target): Finds the length of the longest contiguous subarray such that the sum of its elements is at most target. max_len = 0 current_sum = 0 start = 0 for end in range(len(nums)): current_sum += nums[end] while current_sum > target and start <= end: current_sum -= nums[start] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"def longest_happy_days_subarray(hours): Returns the length of the longest contiguous subarray of happy days. A happy day is defined as a day where the worker works more than 8 hours. Parameters: hours (list): 1-indexed list of integers representing hours worked. Returns: int: Length of the longest contiguous subarray of happy days. >>> longest_happy_days_subarray([1, 2, 3, 4, 5, 6, 7, 8]) == 0 >>> longest_happy_days_subarray([9, 10, 11, 12, 13]) == 5 >>> longest_happy_days_subarray([9, 10, 8, 11, 12]) == 2 >>> longest_happy_days_subarray([7, 8, 9, 10, 7, 8, 11, 9]) == 2 >>> longest_happy_days_subarray([8, 7, 9, 6, 5]) == 1 >>> longest_happy_days_subarray([]) == 0 >>> longest_happy_days_subarray([9]) == 1 >>> longest_happy_days_subarray([8]) == 0","solution":"def longest_happy_days_subarray(hours): Returns the length of the longest contiguous subarray of happy days. A happy day is defined as a day where the worker works more than 8 hours. Parameters: hours (list): 1-indexed list of integers representing hours worked. Returns: int: Length of the longest contiguous subarray of happy days. max_length = 0 current_length = 0 for hour in hours: if hour > 8: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"class MarketplaceNotification: A notification system for an online marketplace where users can follow other users and get notifications when they list new items. def __init__(self): Initializes the notification system. pass def follow(self, followerId, followeeId): The user with the ID 'followerId' starts following the user with the ID 'followeeId'. pass def unfollow(self, followerId, followeeId): The user with the ID 'followerId' stops following the user with the ID 'followeeId'. pass def listItem(self, userId, itemName): The user with the ID 'userId' lists a new item with the name 'itemName'. This action triggers notifications to all followers of 'userId'. pass def getNotifications(self, userId): Returns a list of notifications for the user with the ID 'userId'. The format of each notification should be \\"User X listed new item: Y\\", where X is the ID of the user who listed the item, and Y is the item's name. Notifications should be listed in the order they were triggered. pass # Unit test example def test_follow(): mn = MarketplaceNotification() mn.follow(1, 2) assert mn.followers[2] == {1} def test_unfollow(): mn = MarketplaceNotification() mn.follow(1, 2) mn.unfollow(1, 2) assert mn.followers[2] == set() def test_list_item(): mn = MarketplaceNotification() mn.follow(1, 2) mn.listItem(2, \\"item1\\") assert mn.getNotifications(1) == [\\"User 2 listed new item: item1\\"] def test_get_notifications(): mn = MarketplaceNotification() mn.follow(1, 2) mn.listItem(2, \\"item1\\") mn.listItem(2, \\"item2\\") assert mn.getNotifications(1) == [\\"User 2 listed new item: item1\\", \\"User 2 listed new item: item2\\"] def test_no_notifications_for_non_follower(): mn = MarketplaceNotification() mn.follow(1, 2) mn.listItem(3, \\"item1\\") assert mn.getNotifications(1) == [] def test_unfollow_then_list_item(): mn = MarketplaceNotification() mn.follow(1, 2) mn.unfollow(1, 2) mn.listItem(2, \\"item1\\") assert mn.getNotifications(1) == [] def test_multiple_followees(): mn = MarketplaceNotification() mn.follow(1, 2) mn.follow(1, 3) mn.listItem(2, \\"item1\\") mn.listItem(3, \\"item2\\") assert mn.getNotifications(1) == [ \\"User 2 listed new item: item1\\", \\"User 3 listed new item: item2\\" ] def test_multiple_followers(): mn = MarketplaceNotification() mn.follow(1, 2) mn.follow(3, 2) mn.listItem(2, \\"item1\\") assert mn.getNotifications(1) == [\\"User 2 listed new item: item1\\"] assert mn.getNotifications(3) == [\\"User 2 listed new item: item1\\"]","solution":"class MarketplaceNotification: def __init__(self): self.followers = {} self.user_items = {} self.notifications = {} def follow(self, followerId, followeeId): if followeeId not in self.followers: self.followers[followeeId] = set() self.followers[followeeId].add(followerId) def unfollow(self, followerId, followeeId): if followeeId in self.followers: self.followers[followeeId].discard(followerId) def listItem(self, userId, itemName): if userId not in self.user_items: self.user_items[userId] = [] self.user_items[userId].append(itemName) notification = f\\"User {userId} listed new item: {itemName}\\" if userId in self.followers: for follower in self.followers[userId]: if follower not in self.notifications: self.notifications[follower] = [] self.notifications[follower].append(notification) def getNotifications(self, userId): if userId in self.notifications: return self.notifications[userId] return []"},{"question":"def numIslands(grid): Determine the total number of islands in a given grid. >>> grid = [ ... [\\"1\\", \\"1\\", \\"1\\", \\"0\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"1\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"] ... ] >>> numIslands(grid) 2 >>> grid = [ ... [\\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\"] ... ] >>> numIslands(grid) 0 >>> grid = [ ... [\\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\"] ... ] >>> numIslands(grid) 1 >>> grid = [ ... [\\"1\\", \\"0\\", \\"1\\"], ... [\\"0\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"0\\", \\"1\\"] ... ] >>> numIslands(grid) 5 >>> numIslands([]) 0","solution":"def numIslands(grid): Given a grid, count the number of islands. if not grid: return 0 def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != '1': return grid[x][y] = '! ' # Mark as visited dfs(x + 1, y) # Down dfs(x - 1, y) # Up dfs(x, y + 1) # Right dfs(x, y - 1) # Left count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': count += 1 dfs(i, j) return count"},{"question":"def substring_with_highest_distinct_characters(s: str, k: int) -> str: Finds the substring of length k with the highest number of distinct characters. If there are multiple substrings with the same highest number of distinct characters, returns the leftmost one. Parameters: s (str): The input string. k (int): The length of the substring to consider. Returns: str: The substring with the highest number of distinct characters, or an empty string if the length of s is less than k. Examples: >>> substring_with_highest_distinct_characters(\\"abcdabc\\", 3) 'abc' >>> substring_with_highest_distinct_characters(\\"abcdabc\\", 4) 'abcd' >>> substring_with_highest_distinct_characters(\\"abc\\", 4) '' >>> substring_with_highest_distinct_characters(\\"abcde\\", 5) 'abcde' >>> substring_with_highest_distinct_characters(\\"aabbaa\\", 2) 'ab' >>> substring_with_highest_distinct_characters(\\"abcabcbb\\", 3) 'abc' >>> substring_with_highest_distinct_characters(\\"abcabcabc\\", 3) 'abc'","solution":"def substring_with_highest_distinct_characters(s, k): Finds the substring of length k with the highest number of distinct characters. If there are multiple substrings with the same highest number of distinct characters, returns the leftmost one. Parameters: s (str): The input string. k (int): The length of the substring to consider. Returns: str: The substring with the highest number of distinct characters, or an empty string if the length of s is less than k. if len(s) < k: return '' max_distinct_count = 0 best_substring = '' for i in range(len(s) - k + 1): substring = s[i:i+k] distinct_count = len(set(substring)) if distinct_count > max_distinct_count: max_distinct_count = distinct_count best_substring = substring elif distinct_count == max_distinct_count and best_substring == '': best_substring = substring return best_substring"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_gcd_path_length(root): Find the length of the longest path in the binary tree such that the GCD of all the node values in that path is greater than 1. Return the length of the path. If there is no such path, return 0. >>> root = TreeNode(1) >>> root.left = TreeNode(1) >>> root.right = TreeNode(1) >>> max_gcd_path_length(root) 0 >>> root = TreeNode(2) >>> root.left = TreeNode(4) >>> root.right = TreeNode(6) >>> max_gcd_path_length(root) 1 >>> root = TreeNode(2) >>> root.left = TreeNode(4) >>> root.right = TreeNode(6) >>> root.left.left = TreeNode(8) >>> max_gcd_path_length(root) 2 >>> root = TreeNode(15) >>> root.left = TreeNode(10) >>> root.right = TreeNode(25) >>> root.left.left = TreeNode(5) >>> root.right.left = TreeNode(20) >>> root.right.right = TreeNode(30) >>> max_gcd_path_length(root) 2 >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(20) >>> root.left.right = TreeNode(2) >>> root.right.left = TreeNode(4) >>> root.right.right = TreeNode(5) >>> max_gcd_path_length(root) 1 >>> root = TreeNode(6) >>> root.left = TreeNode(9) >>> root.right = TreeNode(15) >>> max_gcd_path_length(root) 1","solution":"from math import gcd from collections import defaultdict from functools import lru_cache class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_gcd_path_length(root): if not root: return 0 @lru_cache(None) def helper(node): if not node: return 0, 0 # (max_path_length, gcd_so_far) left_len, left_gcd = helper(node.left) right_len, right_gcd = helper(node.right) current_best = 0 current_gcd = node.val if node.left and gcd(node.val, left_gcd) > 1: current_best = max(current_best, left_len + 1) current_gcd = gcd(current_gcd, left_gcd) if node.right and gcd(node.val, right_gcd) > 1: current_best = max(current_best, right_len + 1) current_gcd = gcd(current_gcd, right_gcd) return current_best, current_gcd max_path_len, best_gcd = helper(root) return max_path_len"},{"question":"def max_non_overlapping_tasks(tasks: List[List[int]]) -> int: Returns the maximum number of non-overlapping tasks that can be scheduled. :param tasks: List of tasks each represented as an interval [start, end] :type tasks: List[List[int]] >>> max_non_overlapping_tasks([[1, 2], [2, 3], [3, 4], [1, 3]]) 3 >>> max_non_overlapping_tasks([[1, 4], [2, 3], [3, 5], [6, 8]]) 3 >>> max_non_overlapping_tasks([[1, 2], [2, 3], [3, 4], [4, 5]]) 4 >>> max_non_overlapping_tasks([[1, 3], [2, 4], [3, 5], [1, 2]]) 2 >>> max_non_overlapping_tasks([[1, 4], [2, 4], [3, 4], [4, 5]]) 2","solution":"def max_non_overlapping_tasks(tasks): Returns the maximum number of non-overlapping tasks that can be scheduled. :param tasks: List of tasks each represented as an interval [start, end] :type tasks: List[List[int]] # Sort the tasks based on their end times tasks.sort(key=lambda x: x[1]) max_tasks = 0 end_time = float('-inf') for task in tasks: if task[0] >= end_time: end_time = task[1] max_tasks += 1 return max_tasks"},{"question":"def count_distinct_pairs_with_sum(arr, k): Returns the number of distinct pairs (i, j) in the array such that arr[i] + arr[j] equals k and i < j. >>> count_distinct_pairs_with_sum([1, 2, 3, 4], 5) 2 >>> count_distinct_pairs_with_sum([1, 2, 3, 4], 8) 0 >>> count_distinct_pairs_with_sum([1, 1, 1, 1], 2) 1 >>> count_distinct_pairs_with_sum([-1, -2, -3, -4, -5], -8) 1 >>> count_distinct_pairs_with_sum([1, -1, 2, -2, 3, -3, 4, -4], 0) 4 >>> count_distinct_pairs_with_sum([], 5) 0 >>> count_distinct_pairs_with_sum([5], 5) 0 pass","solution":"def count_distinct_pairs_with_sum(arr, k): Returns the number of distinct pairs (i, j) in the array such that arr[i] + arr[j] equals k and i < j. Parameters: arr (List[int]): the input array of integers k (int): the target sum Returns: int: the number of distinct pairs seen = set() pairs = set() for num in arr: complement = k - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return len(pairs)"},{"question":"class TreeNode: def __init__(self, val=0, children=[]): self.val = val self.children = children def sum_root_to_leaf_numbers(root: TreeNode) -> int: Compute the sum of all the number sequences formed by the root-to-leaf paths in the tree. >>> sum_root_to_leaf_numbers(TreeNode(1)) 1 >>> sum_root_to_leaf_numbers(TreeNode(1, children=[ TreeNode(2, children=[TreeNode(4), TreeNode(5)]), TreeNode(3, children=[TreeNode(6), TreeNode(7)]) ])) 522 >>> sum_root_to_leaf_numbers(TreeNode(0, children=[ TreeNode(4, children=[TreeNode(8), TreeNode(2)]), TreeNode(1, children=[TreeNode(3)]) ])) 103 >>> sum_root_to_leaf_numbers(TreeNode(0, children=[ TreeNode(1, children=[TreeNode(5)]), TreeNode(9) ])) 24 >>> sum_root_to_leaf_numbers(None) 0","solution":"class TreeNode: def __init__(self, val=0, children=[]): self.val = val self.children = children def sum_root_to_leaf_numbers(root): def dfs(node, current_number): if not node: return 0 current_number = current_number * 10 + node.val if not node.children: return current_number return sum(dfs(child, current_number) for child in node.children) return dfs(root, 0)"},{"question":"def longest_subsequence(nums: List[int], k: int) -> int: Returns the length of the longest subsequence whose sum is less than or equal to k. >>> longest_subsequence([1, 2, 3, 4, 5], 9) 3 >>> longest_subsequence([4], 4) 1 >>> longest_subsequence([4], 5) 1 >>> longest_subsequence([4], 3) 0","solution":"def longest_subsequence(nums, k): Returns the length of the longest subsequence whose sum is less than or equal to k. # Sort the list so we can try to accumulate smallest elements first nums.sort() current_sum = 0 max_length = 0 for num in nums: if current_sum + num <= k: current_sum += num max_length += 1 else: break return max_length"},{"question":"import heapq from typing import List def minimum_elevation_path(grid: List[List[int]]) -> int: Finds the path from the top-left corner to the bottom-right corner in the grid that minimizes the maximum elevation encountered along the path. >>> minimum_elevation_path([[0]]) 0 >>> minimum_elevation_path([[0, 1], [3, 2]]) 2 >>> minimum_elevation_path([[0, 2, 1], [1, 3, 2], [2, 4, 3]]) 3 >>> minimum_elevation_path([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 1 >>> minimum_elevation_path([[1, 1, 3], [3, 2, 3], [3, 4, 1]]) 3","solution":"import heapq def minimum_elevation_path(grid): Finds the path from the top-left corner to the bottom-right corner in the grid that minimizes the maximum elevation encountered along the path. m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] heap = [(grid[0][0], 0, 0)] visited = set((0, 0)) while heap: max_elevation, x, y = heapq.heappop(heap) if (x, y) == (m - 1, n - 1): return max_elevation for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited: new_elevation = max(max_elevation, grid[nx][ny]) visited.add((nx, ny)) heapq.heappush(heap, (new_elevation, nx, ny)) return -1 # No path found (should not happen in a valid grid)"},{"question":"def can_cross(stones, k): Determines whether you can reach the last stone given the maximum jump length k. Args: stones (List[int]): An array of positive integers representing the positions of the stones. k (int): The maximum jump length. Returns: bool: True if you can reach the last stone, otherwise False. Examples: >>> can_cross([0, 1, 3, 5, 6, 8], 3) True >>> can_cross([0, 2, 5, 10], 3) False >>> can_cross([0, 1, 2, 3, 4, 5, 6], 1) True >>> can_cross([0, 6, 12], 6) True >>> can_cross([0], 3) True >>> can_cross([0, 1, 4, 6, 8], 2) False","solution":"def can_cross(stones, k): Determines whether you can reach the last stone given the maximum jump length k. current_position = 0 for stone in stones: if stone - current_position <= k: current_position = stone else: return False return True"},{"question":"def successful_candidates(candidates, threshold): Returns the indices of candidates who scored above the threshold in non-increasing order of their scores. If multiple candidates have the same score, they are listed in ascending order of their indices. >>> successful_candidates([50, 60, 70], 80) [] >>> successful_candidates([90, 85, 80], 70) [0, 1, 2] >>> successful_candidates([60, 75, 85, 90, 50], 70) [3, 2, 1] >>> successful_candidates([75, 85, 85, 60, 50], 70) [1, 2, 0] >>> successful_candidates([], 70) [] >>> successful_candidates([1, 2, 3, 4, 5], 0) [4, 3, 2, 1, 0]","solution":"def successful_candidates(candidates, threshold): Returns the indices of candidates who scored above the threshold in non-increasing order of their scores. If multiple candidates have the same score, they are listed in ascending order of their indices. result = [(i, score) for i, score in enumerate(candidates) if score > threshold] result.sort(key=lambda x: (-x[1], x[0])) return [i for i, _ in result]"},{"question":"def largestIsland(grid: List[List[int]]) -> int: Returns the size of the largest island in the grid. >>> grid = [ ... [1, 0, 0, 1], ... [1, 1, 0, 0], ... [0, 0, 1, 1], ... [0, 1, 1, 1] ... ] >>> largestIsland(grid) 5 >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> largestIsland(grid) 0 >>> grid = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> largestIsland(grid) 9 >>> grid = [ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ] >>> largestIsland(grid) 1 >>> grid = [ ... [1], ... [1], ... [1] ... ] >>> largestIsland(grid) 3","solution":"def largestIsland(grid): Returns the size of the largest island in the grid. def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return 0 grid[i][j] = 0 # mark the land as visited size = 1 # count the current land cell for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]: size += dfs(grid, x, y) return size largest = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: size = dfs(grid, i, j) largest = max(largest, size) return largest"},{"question":"from typing import List, Tuple def has_cycle(graph_edges: List[Tuple[int, int]], n: int) -> bool: Determines if a directed graph contains a cycle. :param graph_edges: List of edges in the graph, where each edge is represented as a tuple (u, v) :param n: Number of nodes in the graph :return: True if a cycle exists, otherwise False >>> has_cycle([(0, 1), (1, 2), (2, 3)], 4) False >>> has_cycle([(0, 1), (1, 2), (2, 0)], 3) True >>> has_cycle([(0, 1), (1, 2), (2, 0), (2, 3), (3, 4), (4, 5), (5, 3)], 6) True >>> has_cycle([(0, 1), (1, 2), (2, 3), (3, 4), (1, 3), (4, 5)], 6) False >>> has_cycle([], 3) False >>> has_cycle([], 1) False >>> has_cycle([(0, 0)], 1) True","solution":"def has_cycle(graph_edges, n): Determines if a directed graph contains a cycle. :param graph_edges: List of edges in the graph, where each edge is represented as a tuple (u, v) :param n: Number of nodes in the graph :return: True if a cycle exists, otherwise False from collections import defaultdict, deque # Build the adjacency list graph = defaultdict(list) in_degree = {i: 0 for i in range(n)} for u, v in graph_edges: graph[u].append(v) in_degree[v] += 1 # Queue for nodes with no incoming edges zero_in_degree_queue = deque([node for node in in_degree if in_degree[node] == 0]) visited = 0 while zero_in_degree_queue: node = zero_in_degree_queue.popleft() visited += 1 for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) return visited != n"},{"question":"def can_see_count(heights: List[int]) -> List[int]: You are given an array of integers \`heights\` representing the heights of a group of people. In a queue, people can see forward if no one in front of them is taller. Write a function \`can_see_count(heights)\` that returns an array where each element represents the number of people that a person at each position can see, including themselves. >>> can_see_count([2, 2, 2, 2]) [4, 3, 2, 1] >>> can_see_count([4, 3, 2, 1]) [4, 3, 2, 1] >>> can_see_count([1, 2, 3, 4]) [1, 1, 1, 1] >>> can_see_count([2, 4, 3, 1]) [1, 3, 2, 1] >>> can_see_count([5]) [1] >>> can_see_count([5, 3]) [2, 1] >>> can_see_count([1, 1, 1, 1]) [4, 3, 2, 1]","solution":"def can_see_count(heights): n = len(heights) result = [1] * n for i in range(n): max_height = heights[i] count = 1 for j in range(i + 1, n): if heights[j] <= max_height: count += 1 max_height = heights[j] else: break result[i] = count return result"},{"question":"def heightChecker(heights: List[int]) -> int: Returns the number of students standing in the wrong positions. >>> heightChecker([1, 2, 3, 4]) == 0 >>> heightChecker([4, 3, 2, 1]) == 4 >>> heightChecker([1, 3, 2, 4, 5]) == 2 >>> heightChecker([1, 2, 2, 2, 1]) == 2 >>> heightChecker([]) == 0 >>> heightChecker([1]) == 0","solution":"def heightChecker(heights): Returns the number of students standing in the wrong positions. expected = sorted(heights) count = 0 for i in range(len(heights)): if heights[i] != expected[i]: count += 1 return count"},{"question":"def min_distinct_characters(s: str) -> int: Returns the minimum number of distinct characters that can remain in the string after performing the given operation any number of times. >>> min_distinct_characters(\\"a\\") 1 >>> min_distinct_characters(\\"abcd\\") 1 >>> min_distinct_characters(\\"aaabbbccc\\") 1 >>> min_distinct_characters(\\"\\") 0 >>> min_distinct_characters(\\"aabbccddeeffgg\\") 1","solution":"def min_distinct_characters(s): Returns the minimum number of distinct characters that can remain in the string. :param s: Input string consisting of only lowercase English letters :return: Minimum number of distinct characters that can remain in the string from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Sort the frequencies in descending order frequencies = sorted(char_count.values(), reverse=True) # If the string has no characters, return 0 if len(frequencies) == 0: return 0 # We need to keep at least 1 distinct character, so that's our answer return 1"},{"question":"def largestRectangleArea(heights: List[int]) -> int: Calculate the area of the largest rectangle in the histogram. >>> largestRectangleArea([2,1,5,6,2,3]) 10 >>> largestRectangleArea([2,2,2,2]) 8 >>> largestRectangleArea([1,2,3,4,5]) 9 >>> largestRectangleArea([5,4,3,2,1]) 9 >>> largestRectangleArea([]) 0 >>> largestRectangleArea([5]) 5 >>> largestRectangleArea([2,1,2]) 3","solution":"def largestRectangleArea(heights): Function to calculate the area of the largest rectangle in the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): # If the stack is empty or the current height is greater than the height of the histogram at the stack's top if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest (or minimum height) bar 'h' area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area, if needed max_area = max(max_area, area) # Now, pop the remaining bars from stack and calculate the area with every popped bar as the smallest bar while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def can_divide_into_k_subarrays(nums: List[int], k: int) -> bool: Determines if the array can be divided into k contiguous subarrays each having the same sum. Parameters: nums (list of int): The integer array. k (int): The number of subarrays required. Returns: bool: True if the array can be divided into k subarrays of equal sum, False otherwise. >>> can_divide_into_k_subarrays([1, 2, 1, 2, 1, 2], 3) True >>> can_divide_into_k_subarrays([1, 2, 1, 2, 1], 3) False >>> can_divide_into_k_subarrays([1], 1) True >>> can_divide_into_k_subarrays([1], 2) False >>> can_divide_into_k_subarrays([1, 1, 1, 1], 2) True >>> can_divide_into_k_subarrays([1, 2, 3, 4], 3) False >>> can_divide_into_k_subarrays([2, 4, 2, 4], 2) True >>> can_divide_into_k_subarrays([7, 7, 7, 7, 7, 7], 3) True >>> can_divide_into_k_subarrays([6, 1, 2, 3, 4, 5], 2) False","solution":"def can_divide_into_k_subarrays(nums, k): Determines if the array can be divided into k contiguous subarrays each having the same sum. Parameters: nums (list of int): The integer array. k (int): The number of subarrays required. Returns: bool: True if the array can be divided into k subarrays of equal sum, False otherwise. total_sum = sum(nums) n = len(nums) # The total sum must be divisible by k for it to be split into k subarrays of equal sum if total_sum % k != 0: return False target_sum = total_sum // k current_sum = 0 count_subarrays = 0 for num in nums: current_sum += num if current_sum == target_sum: count_subarrays += 1 current_sum = 0 return count_subarrays == k"},{"question":"def find_missing_positive(arr: List[int], x: int) -> int: Given an integer array \`arr\` sorted in non-decreasing order and an integer \`x\`, find the smallest positive integer missing from the array. Return the missing integer. If there are no missing integers, return the next integer after the last element of the array. >>> find_missing_positive([1, 2, 3, 4, 5], 0) 6 >>> find_missing_positive([1, 2, 4, 5], 0) 3 >>> find_missing_positive([2, 3, 4, 5], 0) 1 >>> find_missing_positive([1, 1, 2, 2, 3, 3, 5], 0) 4 >>> find_missing_positive([2], 0) 1 >>> find_missing_positive([], 0) 1 >>> find_missing_positive(list(range(1, 10001)), 0) 10001 >>> find_missing_positive([1, 2, 3, 5], 4) 4","solution":"def find_missing_positive(arr, x): Given an integer array \`arr\` sorted in non-decreasing order and an integer \`x\`, find the smallest positive integer missing from the array. Return the missing integer. If there are no missing integers, return the next integer after the last element of the array. arr_set = set(arr) i = 1 while i in arr_set: i += 1 return i"},{"question":"def max_area(nums: List[int]) -> int: Returns the maximum amount of water a container can store, formed by two lines from the list nums. :param nums: List of integers representing the height of lines. :return: Maximum amount of water a container can store. >>> max_area([1,8,6,2,5,4,8,3,7]) 49 >>> max_area([1,1,1,1,1,1,1,1,1]) 8 >>> max_area([1,2,3,4,5,6,7,8,9]) 20 >>> max_area([9,8,7,6,5,4,3,2,1]) 20 >>> max_area([1,3,2,5,25,24,5]) 24","solution":"def max_area(nums): Returns the maximum amount of water a container can store, formed by two lines from the list nums. :param nums: List of integers representing the height of lines. :return: Maximum amount of water a container can store. left = 0 right = len(nums) - 1 max_water = 0 while left < right: height = min(nums[left], nums[right]) width = right - left current_area = height * width max_water = max(max_water, current_area) if nums[left] < nums[right]: left += 1 else: right -= 1 return max_water"},{"question":"def max_profit(prices: List[int]) -> int: Returns the maximum profit from a single buy and sell action of stock. If no profit can be made, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0 >>> max_profit([1, 2, 3, 4, 5, 6]) == 5 >>> max_profit([6, 5, 4, 3, 2, 1]) == 0 >>> max_profit([5]) == 0 >>> max_profit([]) == 0 >>> max_profit([3, 1, 4, 8, 2, 5, 7]) == 7","solution":"def max_profit(prices): Returns the maximum profit from a single buy and sell action of stock. If no profit can be made, returns 0. :param prices: List of stock prices :return: Maximum profit if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"class MaxStack: Implement a class called MaxStack that supports the following operations: void push(int x) -- Pushes element x onto the stack. int pop() -- Removes the element on the top of the stack and returns it. int top() -- Gets the element on the top of the stack without removing it. int peekMax() -- Retrieves the maximum element in the stack without removing it. int popMax() -- Removes the maximum element in the stack and returns it. If there are multiple maximum elements, only the one closest to the top is removed. You must implement a solution with O(1) time complexity for both push and top, and O(n) time complexity for pop, peekMax, and popMax operations. from solution import MaxStack def test_push_pop(): stack = MaxStack() stack.push(3) stack.push(1) stack.push(5) assert stack.pop() == 5 assert stack.pop() == 1 assert stack.pop() == 3 def test_top(): stack = MaxStack() stack.push(3) stack.push(1) assert stack.top() == 1 stack.push(5) assert stack.top() == 5 def test_peekMax(): stack = MaxStack() stack.push(3) stack.push(1) assert stack.peekMax() == 3 stack.push(5) assert stack.peekMax() == 5 def test_popMax(): stack = MaxStack() stack.push(3) stack.push(1) stack.push(5) assert stack.popMax() == 5 assert stack.peekMax() == 3 stack.push(6) stack.push(2) assert stack.popMax() == 6 assert stack.popMax() == 3","solution":"class MaxStack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) def pop(self) -> int: popped = self.stack.pop() if popped == self.max_stack[-1]: self.max_stack.pop() return popped def top(self) -> int: return self.stack[-1] def peekMax(self) -> int: return self.max_stack[-1] def popMax(self) -> int: max_val = self.max_stack.pop() buffer = [] while self.stack[-1] != max_val: buffer.append(self.stack.pop()) self.stack.pop() for elem in reversed(buffer): self.push(elem) return max_val"},{"question":"def find_pairs(nums: List[int], k: int) -> int: Given a list of integers \`nums\` and an integer \`k\`, determine the number of unique pairs (a, b) such that a - b is equal to k. :param nums: List of integers :param k: Integer :return: Integer count of unique pairs (a, b) >>> find_pairs([], 1) 0 >>> find_pairs([1, 2, 3], -1) 0 >>> find_pairs([1, 2, 3], 5) 0 >>> find_pairs([1, 2, 3, 4], 1) 3 >>> find_pairs([1, 1, 1, 2, 2, 3], 1) 2 >>> find_pairs([1, 5, 3, 4, 2], 2) 3 >>> find_pairs([1, 2, 3, 1, 2, 3], 0) 3 >>> find_pairs([1, 3, 5, 7], 2) 3 pass","solution":"def find_pairs(nums, k): Returns the number of unique pairs (a, b) such that a - b = k. :param nums: List of integers :param k: Integer :return: Integer count of unique pairs (a, b) if not nums or k < 0: return 0 nums_set = set(nums) count = 0 # Check if each number minus k is in the set for unique pairs for num in nums_set: if num - k in nums_set: count += 1 return count"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1, l2): Given two linked lists where each node contains a single digit. The digits are stored in reverse order, such that the 1's digit is at the head of the list. Add the two numbers and return the sum as a linked list. >>> list_to_linked_list = lambda numbers: ListNode(0) >>> linked_list_to_list = lambda node: [node.val] >>> l1 = list_to_linked_list([2, 4, 3]) >>> l2 = list_to_linked_list([5, 6, 4]) >>> result = addTwoNumbers(l1, l2) >>> linked_list_to_list(result) == [7, 0, 8] True >>> l1 = list_to_linked_list([9, 9, 9]) >>> l2 = list_to_linked_list([1]) >>> result = addTwoNumbers(l1, l2) >>> linked_list_to_list(result) == [0, 0, 0, 1] True >>> l1 = list_to_linked_list([0]) >>> l2 = list_to_linked_list([0]) >>> result = addTwoNumbers(l1, l2) >>> linked_list_to_list(result) == [0] True >>> l1 = list_to_linked_list([2, 4, 3]) >>> l2 = list_to_linked_list([5, 6]) >>> result = addTwoNumbers(l1, l2) >>> linked_list_to_list(result) == [7, 0, 4] True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1, l2): dummy_head = ListNode(0) current = dummy_head carry = 0 while l1 is not None or l2 is not None: x = l1.val if l1 is not None else 0 y = l2.val if l2 is not None else 0 sum = carry + x + y carry = sum // 10 current.next = ListNode(sum % 10) current = current.next if l1 is not None: l1 = l1.next if l2 is not None: l2 = l2.next if carry > 0: current.next = ListNode(carry) return dummy_head.next"},{"question":"def kth_smallest_contiguous_subarrays(arr, k): Returns the k-th smallest element in the union of all possible contiguous subarrays of arr. If k-th smallest element is not possible, returns -1. >>> kth_smallest_contiguous_subarrays([3, 1, 2], 2) == 2 >>> kth_smallest_contiguous_subarrays([10], 1) == 10 >>> kth_smallest_contiguous_subarrays([10], 2) == -1 >>> kth_smallest_contiguous_subarrays([3, 1, 4, 2], 3) == 3 >>> kth_smallest_contiguous_subarrays([5, 2, 8, 3, 7], 10) == -1 >>> kth_smallest_contiguous_subarrays([6, 2, 8, 3], -1) == -1 >>> kth_smallest_contiguous_subarrays([], 1) == -1 >>> kth_smallest_contiguous_subarrays([], 0) == -1 >>> kth_smallest_contiguous_subarrays([7, 2, 5], 0) == -1","solution":"def kth_smallest_contiguous_subarrays(arr, k): Returns the k-th smallest element in the union of all possible contiguous subarrays of arr. If k-th smallest element is not possible, returns -1. if not arr or k < 1: return -1 all_elements = set() # Generate all contiguous subarrays and their elements for start in range(len(arr)): for end in range(start, len(arr)): all_elements.update(arr[start:end+1]) sorted_elements = sorted(all_elements) if k <= len(sorted_elements): return sorted_elements[k-1] else: return -1"},{"question":"def smallest_missing_positive(arr): Returns the smallest positive integer that is missing from the array. >>> smallest_missing_positive([3, 4, -1, 1]) 2 >>> smallest_missing_positive([-1, -2, -3]) 1 >>> smallest_missing_positive([1, 2, 3, 4, 5]) 6 >>> smallest_missing_positive([0, 2, 2, 1, 1]) 3 >>> smallest_missing_positive([]) 1 >>> smallest_missing_positive([1, 10, 20, 30]) 2 >>> smallest_missing_positive([1, 2, 2, 4, 1, 3]) 5","solution":"def smallest_missing_positive(arr): Returns the smallest positive integer that is missing from the array. # Remove negative numbers and zero, they are not needed arr = [num for num in arr if num > 0] num_set = set(arr) # Start checking from 1 upwards i = 1 while True: if i not in num_set: return i i += 1"},{"question":"def subarray_sum_equals_k(arr, k): Returns the number of continuous subarrays whose sum equals k. Parameters: arr (list): A list of integers. k (int): The target sum for the subarrays. Returns: int: The number of continuous subarrays whose sum equals k. >>> subarray_sum_equals_k([1, 1, 1], 2) 2 >>> subarray_sum_equals_k([2], 2) 1 >>> subarray_sum_equals_k([2], 1) 0 >>> subarray_sum_equals_k([0, 0, 0, 0], 0) 10 >>> subarray_sum_equals_k([1, -1, 1, -1], 0) 4 >>> subarray_sum_equals_k([1]*10000, 2) 9999 >>> subarray_sum_equals_k([1, 2, 3, 4, -1, -2, -3, 4], 3) 4 >>> subarray_sum_equals_k([1, 2, 3], 7) 0","solution":"def subarray_sum_equals_k(arr, k): Returns the number of continuous subarrays whose sum equals k. Parameters: arr (list): A list of integers. k (int): The target sum for the subarrays. Returns: int: The number of continuous subarrays whose sum equals k. count = 0 current_sum = 0 prefix_sums = {0: 1} for num in arr: current_sum += num if (current_sum - k) in prefix_sums: count += prefix_sums[current_sum - k] if current_sum in prefix_sums: prefix_sums[current_sum] += 1 else: prefix_sums[current_sum] = 1 return count"},{"question":"from typing import List def minimum_moves(grid: List[List[int]], k: int) -> int: Determine the minimum number of moves required to reach the goal. Parameters: grid (list of list of ints): Height of the terrain at each position. k (int): Maximum allowed height difference between consecutive cells. Returns: int: Minimum number of moves required to reach (m-1, n-1), or -1 if unreachable. >>> minimum_moves([[1, 0, 0], [1, 1, 0], [0, 1, 1]], 1) 4 >>> minimum_moves([[1, 3], [4, 2]], 1) -1 >>> minimum_moves([[1, 2, 3], [6, 5, 4]], 3) 3 >>> minimum_moves([[1, 2, 3, 4], [2, 3, 4, 5], [1, 1, 1, 1], [3, 2, 1, 0]], 2) 6 >>> minimum_moves([[1, 2, 3], [2, 10, 3], [1, 15, 1]], 10) 4","solution":"from collections import deque def minimum_moves(grid, k): Determine the minimum number of moves required to reach the goal. Parameters: grid (list of list of ints): Height of the terrain at each position. k (int): Maximum allowed height difference between consecutive cells. Returns: int: Minimum number of moves required to reach (m-1, n-1), or -1 if unreachable. rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, moves) visited = set((0, 0)) while queue: row, col, moves = queue.popleft() if (row, col) == (rows - 1, cols - 1): return moves for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited: if abs(grid[new_row][new_col] - grid[row][col]) <= k: queue.append((new_row, new_col, moves + 1)) visited.add((new_row, new_col)) return -1"},{"question":"def max_path_sum(grid: List[List[int]]) -> int: Given a grid of size \`m x n\` filled with non-negative integers, you can start at any cell in the first row and move to any cell in the last row. You can move directly downward to the cell immediately below, diagonally downward to the cell right below the current cell or the cell left below the current cell. Return the maximum path sum of all possible paths starting from any cell in the first row to any cell in the last row. >>> max_path_sum([[5]]) == 5 >>> max_path_sum([[1, 2, 3], [4, 5, 6]]) == 9 >>> max_path_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 18 >>> max_path_sum([ [10, 10, 2, 0, 20, 4], [1, 0, 0, 30, 2, 5], [0, 10, 4, 0, 2, 0], [1, 0, 2, 20, 0, 4] ]) == 74 >>> max_path_sum([]) == 0 >>> max_path_sum([[1, 2, 3, 4, 5]]) == 5","solution":"def max_path_sum(grid): if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) dp = [[0] * cols for _ in range(rows)] # Initialize the first row for j in range(cols): dp[0][j] = grid[0][j] # Fill the dp table for i in range(1, rows): for j in range(cols): max_up = dp[i-1][j] # coming straight down # coming down from the left diagonal if j > 0: max_up = max(max_up, dp[i-1][j-1]) # coming down from the right diagonal if j < cols - 1: max_up = max(max_up, dp[i-1][j+1]) dp[i][j] = grid[i][j] + max_up # The maximum sum path to reach any cell in the last row return max(dp[rows-1])"},{"question":"def minimize_largest_sum(arr, k): Partition the array into exactly 'k' non-empty continuous subarrays and minimize the largest sum among these subarrays. >>> minimize_largest_sum([7, 2, 5, 10, 8], 2) 18 >>> minimize_largest_sum([1, 2, 3, 4, 5], 1) 15 >>> minimize_largest_sum([1, 2, 3, 4, 5], 3) 6 >>> minimize_largest_sum([2, 3, 1, 2, 4, 3], 6) 4 >>> minimize_largest_sum([5, 5, 5, 5], 2) 10","solution":"def minimize_largest_sum(arr, k): def can_partition(max_sum): current_sum = 0 parts = 1 for num in arr: current_sum += num if current_sum > max_sum: parts += 1 current_sum = num if parts > k: return False return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_partition(mid): right = mid else: left = mid + 1 return left"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head): Returns the node where the cycle begins. If there is no cycle, return None. >>> head = ListNode(1) >>> head.next = ListNode(2) >>> head.next.next = ListNode(3) >>> detectCycle(head) is None True >>> head = ListNode(1) >>> second = ListNode(2) >>> head.next = second >>> second.next = head >>> detectCycle(head) == head True >>> head = ListNode(1) >>> second = ListNode(2) >>> third = ListNode(3) >>> fourth = ListNode(4) >>> head.next = second >>> second.next = third >>> third.next = fourth >>> fourth.next = second >>> detectCycle(head) == second True >>> head = ListNode(1) >>> second = ListNode(2) >>> head.next = second >>> second.next = head >>> detectCycle(head) == head True >>> nodes = [ListNode(i) for i in range(10)] >>> for i in range(9): ... nodes[i].next = nodes[i + 1] >>> nodes[-1].next = nodes[5] >>> detectCycle(nodes[0]) == nodes[5] True >>> head = ListNode(1) >>> detectCycle(head) is None True >>> head = ListNode(1) >>> head.next = head >>> detectCycle(head) == head True","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head): Returns the node where the cycle begins. If there is no cycle, return None. if not head or not head.next: return None slow = fast = head # First phase: determine if there is a cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected, find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow # No cycle detected return None"},{"question":"def partition_labels(s: str) -> List[int]: Splits the string s into as many parts as possible so that each letter appears in at most one part. Args: s (str): The input string consisting of lowercase English letters. Returns: List[int]: A list of integers representing the size of each part. >>> partition_labels(\\"ababcbacadefegdehijhklij\\") [9, 7, 8] >>> partition_labels(\\"abcdefg\\") [1, 1, 1, 1, 1, 1, 1] >>> partition_labels(\\"aaaaa\\") [5] >>> partition_labels(\\"abacbcabac\\") [10] >>> partition_labels(\\"abbcbcaa\\") [8] >>> partition_labels(\\"eccbbbbdec\\") [10]","solution":"def partition_labels(s): Splits the string s into as many parts as possible so that each letter appears in at most one part. Args: s (str): The input string consisting of lowercase English letters. Returns: List[int]: A list of integers representing the size of each part. # Record the last occurrence of each character in the string last_occurrence = {c: i for i, c in enumerate(s)} partitions = [] start, end = 0, 0 for i, c in enumerate(s): # Extend the end to the farthest last occurrence of the current character end = max(end, last_occurrence[c]) # When the end of the current partition is reached if i == end: # Append the size of the current partition partitions.append(i - start + 1) # Update the start for the next partition start = i + 1 return partitions"},{"question":"def min_max_pair_sum(weights): Returns the minimized maximum pair sum of given weights. If the number of weights is odd, returns -1. Examples: >>> min_max_pair_sum([1, 3, 2, 5]) 6 >>> min_max_pair_sum([1, 2, 3]) -1 >>> min_max_pair_sum([2, 8]) 10 >>> min_max_pair_sum([1000, 2000, 3000, 4000, 5000, 6000]) 7000 >>> min_max_pair_sum([4, 4, 4, 4]) 8","solution":"def min_max_pair_sum(weights): Returns the minimized maximum pair sum of given weights. If the number of weights is odd, returns -1. if len(weights) % 2 != 0: return -1 weights.sort() # Sort weights to minimize the pair sum max_pair_sum = 0 left, right = 0, len(weights) - 1 while left < right: pair_sum = weights[left] + weights[right] max_pair_sum = max(max_pair_sum, pair_sum) left += 1 right -= 1 return max_pair_sum"},{"question":"def sum_of_unique_elements(arr: List[int]) -> int: Returns the sum of all unique elements in the array. A unique element is an element that appears only once in the array. If there are no unique elements, return 0. Parameters: arr (list): A list of integers. Returns: int: Sum of unique elements. Examples: >>> sum_of_unique_elements([1, 2, 3, 2]) 4 >>> sum_of_unique_elements([4, 4, 4, 4]) 0 import unittest class TestSumOfUniqueElements(unittest.TestCase): def test_unique_elements_in_mixed_array(self): self.assertEqual(sum_of_unique_elements([1, 2, 3, 2]), 4) def test_no_unique_elements(self): self.assertEqual(sum_of_unique_elements([4, 4, 4, 4]), 0) def test_all_unique_elements(self): self.assertEqual(sum_of_unique_elements([1, 2, 3, 4]), 10) def test_empty_array(self): self.assertEqual(sum_of_unique_elements([]), 0) def test_single_element_array(self): self.assertEqual(sum_of_unique_elements([5]), 5) def test_unique_and_duplicate_elements(self): self.assertEqual(sum_of_unique_elements([10, 10, 20, 30, 30, 40]), 60) def test_negative_and_positive_numbers(self): self.assertEqual(sum_of_unique_elements([-1, -2, -1, 2, 3, 2, 4]), 5) def test_repeating_pattern(self): self.assertEqual(sum_of_unique_elements([1,1, 2, 2, 3, 3, 4]), 4) if __name__ == \\"__main__\\": unittest.main()","solution":"def sum_of_unique_elements(arr): Returns the sum of all unique elements in the array. Parameters: arr (list): A list of integers. Returns: int: Sum of unique elements. from collections import Counter element_count = Counter(arr) unique_sum = sum(key for key, value in element_count.items() if value == 1) return unique_sum"},{"question":"def minimize_array_sum(nums: List[int]) -> int: Minimize the element values in the array and return the sum after performing the described operation any number of times. >>> minimize_array_sum([8, 4, 6, 10]) 10 >>> minimize_array_sum([1, 3, 5, 7]) 16 >>> minimize_array_sum([8, 3, 6, 10, 5]) 17 >>> minimize_array_sum([24]) 3 >>> minimize_array_sum([13]) 13 >>> minimize_array_sum([]) 0","solution":"def minimize_array_sum(nums): Minimize the element values in the array and return the sum after performing the described operation any number of times. # Dividing all even numbers by 2 until they become odd minimized_nums = [] for num in nums: while num % 2 == 0: num //= 2 minimized_nums.append(num) return sum(minimized_nums) # Example usage: # nums = [8, 3, 6, 10, 5] # Result of minimize_array_sum(nums) would be 3 + 3 + 3 + 5 + 5 = 19"},{"question":"class Node: def __init__(self, val: int = 0, left = None, right = None, next = None): self.val = val self.left = left self.right = right self.next = next def connect(root: 'Node') -> 'Node': Populates each next pointer to point to its next right node in a perfect binary tree. >>> test_perfect_binary_tree() == None >>> test_single_node_tree() == None >>> test_empty_tree() == None >>> test_two_levels_tree() == None pass","solution":"class Node: def __init__(self, val: int = 0, left = None, right = None, next = None): self.val = val self.left = left self.right = right self.next = next def connect(root: 'Node') -> 'Node': Populates each next pointer to point to its next right node. if not root: return root # We start with the root node leftmost = root # Iterate over each level using the leftmost node while leftmost.left: # Traverse the current level head = leftmost while head: # Connect the children of the current head node head.left.next = head.right # Connect the right child to the next subtree's left child if head.next: head.right.next = head.next.left # Move to the next node in the current level head = head.next # Shift to the next level leftmost = leftmost.left return root"},{"question":"def minimize_max_sum(nums: List[int], x: int) -> int: Returns the minimum possible value of the maximum sum of x subarrays. Parameters: nums (List[int]): A zero-indexed integer array of length n. x (int): The number of subarrays to divide the array into. Returns: int: The minimum possible value of the maximum sum among the x subarrays. >>> minimize_max_sum([7, 2, 5, 10, 8], 2) 18 >>> minimize_max_sum([1, 2, 3, 4, 5], 2) 9 >>> minimize_max_sum([10], 1) 10 >>> minimize_max_sum([2, 3, 1, 2, 4, 3], 5) 4 >>> minimize_max_sum([1, 4, 4], 3) 4","solution":"def minimize_max_sum(nums, x): Returns the minimum possible value of the maximum sum of x subarrays. Parameters: nums (List[int]): A zero-indexed integer array of length n. x (int): The number of subarrays to divide the array into. Returns: int: The minimum possible value of the maximum sum among the x subarrays. def can_split(nums, x, max_sum): count = 1 current_sum = 0 for num in nums: current_sum += num if current_sum > max_sum: count += 1 current_sum = num if count > x: return False return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(nums, x, mid): right = mid else: left = mid + 1 return left"},{"question":"def max_product_subarray(arr, k): Find the maximum product of any subarray of \`arr\` with \`k\` elements, or return \`-1\` if it does not exist. >>> max_product_subarray([1, 2, 3, 4], 2) == 12 >>> max_product_subarray([1, 2, 3, 4], 3) == 24 >>> max_product_subarray([1, 2, 3, 4], 4) == 24 >>> max_product_subarray([1, 2, 3, -4], 2) == 6 >>> max_product_subarray([-1, -2, -3, -4], 2) == 12 >>> max_product_subarray([1, 2, 3], 4) == -1 >>> max_product_subarray([], 1) == -1 >>> max_product_subarray([0, -1, -2, -3, -4], 2) == 12 >>> max_product_subarray([1, 0, 3, 4, 5], 2) == 20 >>> max_product_subarray([5, 4, 2, 6], 1) == 6 >>> max_product_subarray([-10, 5, -4], 1) == 5 >>> max_product_subarray([-1, -2, -3], 1) == -1","solution":"def max_product_subarray(arr, k): n = len(arr) if k > n: return -1 max_product = float('-inf') for i in range(n - k + 1): product = 1 for j in range(k): product *= arr[i + j] max_product = max(max_product, product) return max_product"},{"question":"from typing import List def largest_rectangle_area(nums: List[int]) -> int: Finds the area of the largest rectangle in the histogram. Args: nums (List[int]): A list of non-negative integers representing the histogram's bar height. Returns: int: The area of the largest rectangle in the histogram. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([4]) 4 >>> largest_rectangle_area([2, 2, 2, 2]) 8 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([2, 1, 4, 5, 1, 3, 3]) 8 >>> largest_rectangle_area([0, 0, 0, 0, 0]) 0","solution":"def largest_rectangle_area(nums): Finds the area of the largest rectangle in the histogram. Args: nums (List[int]): A list of non-negative integers representing the histogram's bar height. Returns: int: The area of the largest rectangle in the histogram. stack = [] max_area = 0 index = 0 while index < len(nums): if not stack or nums[stack[-1]] <= nums[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (nums[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (nums[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def rob(nums: List[int]) -> int: Determine the maximum amount of money you can rob tonight without alerting the police. You cannot rob two adjacent houses. Args: nums (list): A list of non-negative integers representing the amount of money of each house. Returns: int: The maximum amount of money you can rob. >>> rob([]) 0 >>> rob([15]) 15 >>> rob([1, 2]) 2 >>> rob([1, 2, 3, 1]) 4 >>> rob([2, 7, 9, 3, 1]) 12 >>> rob([2, 1, 1, 2]) 4 >>> rob([5, 3, 4, 11, 2]) 16 >>> rob([100, 200, 300, 400, 500, 600, 700, 800, 900, 1000]) 3000 >>> rob([1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000]) 5000","solution":"def rob(nums): Returns the maximum amount of money you can rob tonight without alerting the police. Args: nums (list): A list of non-negative integers representing the amount of money of each house. Returns: int: The maximum amount of money you can rob. if not nums: return 0 elif len(nums) == 1: return nums[0] # Dynamic programming array to store the maximum amount robbed up to each house. dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"def product_except_self(nums): Given an array of n positive integers, construct a new array where each element is the product of all elements in the original array except the element at that position. Note: this should be done without using division. >>> product_except_self([1]) [1] >>> product_except_self([1, 2]) [2, 1] >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([100, 200, 300, 400]) [24000000, 12000000, 8000000, 6000000]","solution":"def product_except_self(nums): Returns an array where each element i is the product of all elements except nums[i]. n = len(nums) result = [1] * n # Calculate the products of elements before the current element left_product = 1 for i in range(n): result[i] = left_product left_product *= nums[i] # Calculate the products of elements after the current element right_product = 1 for i in range(n-1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the number of palindromic substrings in the given string \`s\`. >>> count_palindromic_substrings(\\"a\\") 1 >>> count_palindromic_substrings(\\"aa\\") 3 >>> count_palindromic_substrings(\\"ab\\") 2 >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aba\\") 4 >>> count_palindromic_substrings(\\"aaa\\") 6 >>> count_palindromic_substrings(\\"racecar\\") 10 >>> count_palindromic_substrings(\\"abba\\") 6 >>> count_palindromic_substrings(\\"\\") 0","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the given string \`s\`. n = len(s) count = 0 def expand_around_center(left, right): nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 for i in range(n): # Expand around one single center (odd-length palindromes) expand_around_center(i, i) # Expand around two adjacent centers (even-length palindromes) expand_around_center(i, i + 1) return count"},{"question":"def longest_word_length(s: str) -> int: Returns the length of the longest word in the sentence \`s\`. A word is defined as a maximal substring consisting of English letters only. >>> longest_word_length(\\"Hello, world! This is a test.\\") == 5 >>> longest_word_length(\\"Supercalifragilisticexpialidocious.\\") == 34 >>> longest_word_length(\\"\\") == 0 >>> longest_word_length(\\"Well, it's a beautiful day.\\") == 9 >>> longest_word_length(\\"1234!@#%^&*()_+ {}|:\\") == 0 >>> longest_word_length(\\"The quick Brown fox Jumps over the Lazy dog.\\") == 5","solution":"import re def longest_word_length(s): Returns the length of the longest word in the sentence \`s\`. A word is defined as a maximal substring consisting of English letters only. words = re.findall(r'b[A-Za-z]+b', s) if not words: return 0 return max(len(word) for word in words)"},{"question":"def coinChange(coins, amount): Determine the fewest number of coins needed to make up the given amount. If that amount cannot be made up by any combination of the coins, return -1. >>> coinChange([1, 2, 5], 11) 3 >>> coinChange([2], 3) -1 >>> coinChange([1, 2, 5], 0) 0 >>> coinChange([1], 1) 1 >>> coinChange([1], 2) 2 >>> coinChange([2, 5, 10, 1], 27) 4 >>> coinChange([186, 419, 83, 408], 6249) 20","solution":"def coinChange(coins, amount): Determine the fewest number of coins needed to make up the given amount. If that amount cannot be made up by any combination of the coins, return -1. # Initialize dp array where the value at each index represents the fewest # number of coins needed to make up that amount. dp = [float('inf')] * (amount + 1) dp[0] = 0 for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"from typing import List def can_jump(nums: List[int]) -> bool: Determine whether you can reach the last index starting from the first index. Parameters: nums (List[int]): An array of non-negative integers representing the maximum length of jump at each position. Returns: bool: True if you can reach the last index, False otherwise. Examples: >>> can_jump([2, 3, 1, 1, 4]) True >>> can_jump([3, 2, 1, 0, 4]) False from solution import can_jump def test_can_jump_example_1(): assert can_jump([2,3,1,1,4]) == True def test_can_jump_example_2(): assert can_jump([3,2,1,0,4]) == False def test_can_jump_single_element(): assert can_jump([0]) == True # Single element should always be reachable def test_can_jump_large_jump_at_start(): assert can_jump([10,1,1,1,1]) == True # Large jump at start def test_can_jump_only_one_jump_needed(): assert can_jump([2,0,0]) == True # Only one jump needed to reach the end def test_can_jump_no_jump_possible(): assert can_jump([0,1,2,3]) == False # 0 at start makes it impossible to jump def test_can_jump_multiple_zeros(): assert can_jump([2,0,0,1,4]) == False # Multiple zeros before reaching the end def test_can_jump_large_values(): assert can_jump([1]*100000) == True # Large array with values that ensure reachability def test_can_jump_edge_case_1(): assert can_jump([1,2,3]) == True # Simple reachability case def test_can_jump_edge_case_2(): assert can_jump([1,1,0,1]) == False # Last jump unable to reach the end","solution":"def can_jump(nums): Determine whether you can reach the last index starting from the first index. Parameters: nums (List[int]): An array of non-negative integers representing the maximum length of jump at each position. Returns: bool: True if you can reach the last index, False otherwise. max_reachable = 0 for i, jump in enumerate(nums): if i > max_reachable: return False max_reachable = max(max_reachable, i + jump) return max_reachable >= len(nums) - 1"},{"question":"def find_optimal_gas_station_location(nums: List[int]) -> float: Returns the optimal location for the gas station to minimize the maximum distance to any house. Parameters: nums (list): A list of non-overlapping, sorted integers representing house positions. Returns: float: The optimal location for the gas station. >>> find_optimal_gas_station_location([5]) 5.0 >>> find_optimal_gas_station_location([1, 5, 9]) 3.0 >>> find_optimal_gas_station_location([1, 2, 3, 10]) 6.5 >>> find_optimal_gas_station_location([-3, -1, 2, 6, 10]) 4.0 >>> find_optimal_gas_station_location([]) 0.0 >>> find_optimal_gas_station_location([4, 10]) 7.0 >>> find_optimal_gas_station_location([1, 100]) 50.5","solution":"def find_optimal_gas_station_location(nums): Returns the optimal location for the gas station to minimize the maximum distance to any house. Parameters: nums (list): A list of non-overlapping, sorted integers representing house positions. Returns: float: The optimal location for the gas station. if not nums: return 0.0 n = len(nums) # If there's only one house, the best place is at the house if n == 1: return float(nums[0]) max_distance = 0.0 optimal_location = 0.0 for i in range(n - 1): midpoint = (nums[i] + nums[i + 1]) / 2.0 distance = (nums[i + 1] - nums[i]) / 2.0 if distance > max_distance: max_distance = distance optimal_location = midpoint return optimal_location"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten(root): Flattens the binary tree into a \\"linked list\\" in the pre-order traversal order. >>> root = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5, None, TreeNode(6))) >>> flatten(root) >>> result = [] >>> while root: >>> result.append(root.val) >>> root = root.right >>> result [1, 2, 3, 4, 5, 6]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten(root): Flattens the binary tree into a \\"linked list\\" in the pre-order traversal order. if not root: return stack = [root] prev = None while stack: curr = stack.pop() if prev: prev.right = curr prev.left = None if curr.right: stack.append(curr.right) if curr.left: stack.append(curr.left) prev = curr"},{"question":"def min_possible_length(s: str) -> int: Returns the minimum possible length of the string after performing the operation repeatedly: Choose any two adjacent characters that are the same and delete them. >>> min_possible_length(\\"abc\\") 3 >>> min_possible_length(\\"aabb\\") 0 >>> min_possible_length(\\"abbac\\") 1 >>> min_possible_length(\\"abccba\\") 0 >>> min_possible_length(\\"abccbaa\\") 1 >>> min_possible_length(\\"a\\") 1","solution":"def min_possible_length(s): Returns the minimum possible length of the string after performing the operation repeatedly: Choose any two adjacent characters that are the same and delete them. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"import random class RandomizedSet: Implements a data structure that supports the following operations efficiently: insert, delete, search, and getRandom. The data structure should handle a dynamic set of unique integers. Methods: __init__: Initializes the data structure. insert(val): Inserts the item \`val\` into the set if not present. Returns \`true\` if the item was not present, \`false\` otherwise. remove(val): Removes the item \`val\` from the set if present. Returns \`true\` if the item was present, \`false\` otherwise. getRandom(): Returns a random element from the set. Each element must have the same probability of being returned. def __init__(self): Initializes the data structure. def insert(self, val: int) -> bool: Inserts the item \`val\` into the set if not present. Returns true if the item was not present, false otherwise. def remove(self, val: int) -> bool: Removes the item \`val\` from the set if present. Returns true if the item was present, false otherwise. def getRandom(self) -> int: Returns a random element from the set. Each element must have the same probability of being returned. def test_insert(): rs = RandomizedSet() assert rs.insert(1) == True assert rs.insert(1) == False assert rs.insert(2) == True def test_remove(): rs = RandomizedSet() rs.insert(1) rs.insert(2) assert rs.remove(1) == True assert rs.remove(1) == False assert rs.remove(3) == False assert rs.remove(2) == True def test_get_random(): rs = RandomizedSet() rs.insert(1) rs.insert(2) rs.insert(3) assert rs.getRandom() in {1, 2, 3} # Remove 2 and ensure it is not returned randomly rs.remove(2) random_vals = set() for _ in range(10): random_vals.add(rs.getRandom()) assert random_vals == {1, 3} def test_all_operations(): rs = RandomizedSet() assert rs.insert(1) == True assert rs.insert(2) == True assert rs.insert(3) == True assert rs.remove(1) == True assert rs.insert(1) == True random_vals = set() for _ in range(10): random_vals.add(rs.getRandom()) assert random_vals == {1, 2, 3}","solution":"import random class RandomizedSet: def __init__(self): Initializes the data structure. self.data = [] self.index_map = {} def insert(self, val: int) -> bool: Inserts the item \`val\` into the set if not present. Returns \`true\` if the item was not present, \`false\` otherwise. if val in self.index_map: return False # Store index of the inserted value self.index_map[val] = len(self.data) self.data.append(val) return True def remove(self, val: int) -> bool: Removes the item \`val\` from the set if present. Returns \`true\` if the item was present, \`false\` otherwise. if val not in self.index_map: return False # Swap the value with the last value in the list last_val = self.data[-1] val_index = self.index_map[val] self.data[val_index] = last_val self.index_map[last_val] = val_index # Remove the last value from the array self.data.pop() del self.index_map[val] return True def getRandom(self) -> int: Returns a random element from the set. Each element must have the same probability of being returned. return random.choice(self.data)"},{"question":"from typing import List def calculate_free_parking_time(parkings: List[str]) -> int: Calculate the total free parking time in minutes given a list of parking events. Args: parkings (list): List of strings, each in the format \\"HH:MM-HH:MM\\" representing parking events. Returns: int: Total free parking time in minutes. def test_no_parking_events(): assert calculate_free_parking_time([]) == 24 * 60 def test_non_overlapping_events(): assert calculate_free_parking_time([\\"08:00-10:00\\", \\"12:00-14:00\\"]) == (24*60 - 4*60) def test_full_day_parking(): assert calculate_free_parking_time([\\"00:00-24:00\\"]) == 0 def test_single_event(): assert calculate_free_parking_time([\\"09:00-17:00\\"]) == (24 * 60 - 8 * 60) def test_invalid_event(): assert calculate_free_parking_time([\\"17:00-09:00\\"]) == 24 * 60 def test_combined_events(): assert calculate_free_parking_time([\\"00:00-12:00\\", \\"12:00-13:00\\", \\"13:00-24:00\\"]) == 0","solution":"from datetime import datetime def calculate_free_parking_time(parkings): Calculate the total free parking time in minutes given a list of parking events. Args: parkings (list): List of strings, each in the format \\"HH:MM-HH:MM\\" representing parking events. Returns: int: Total free parking time in minutes. # Helper function to convert time string to minutes from start of day. def time_to_minutes(t): h, m = map(int, t.split(':')) return h * 60 + m all_day_minutes = 24 * 60 # Total minutes in a day total_occupied_minutes = 0 for event in parkings: start, end = event.split('-') start_minutes = time_to_minutes(start) end_minutes = time_to_minutes(end) # Validate the event if start_minutes < end_minutes: total_occupied_minutes += (end_minutes - start_minutes) total_free_parking_time = all_day_minutes - total_occupied_minutes return total_free_parking_time"},{"question":"def length_of_lis(nums: List[int]) -> int: Returns the length of the longest strictly increasing subsequence in nums. Parameters: nums (list): A list of integers. Returns: int: Length of the longest strictly increasing subsequence. >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([1, 2, 3, 4, 5, 6, 7, 8, 9]) 9 >>> length_of_lis([9, 8, 7, 6, 5, 4, 3, 2, 1]) 1 >>> length_of_lis([4, 10, 4, 3, 8, 9]) 3 >>> length_of_lis([10]) 1 >>> length_of_lis([]) 0 >>> length_of_lis([3, 3, 3, 3]) 1 >>> length_of_lis([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6","solution":"def length_of_lis(nums): Returns the length of the longest strictly increasing subsequence in nums. Parameters: nums (list): A list of integers. Returns: int: Length of the longest strictly increasing subsequence. if not nums: return 0 n = len(nums) dp = [1] * n for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def is_subsequence(small: str, large: str) -> bool: Check if a string is a subsequence of another string. Args: small (str): The string to check as a subsequence. large (str): The string to check against. Returns: bool: True if small is a subsequence of large, False otherwise. >>> is_subsequence(\\"abc\\", \\"aabbcc\\") True >>> is_subsequence(\\"abc\\", \\"acb\\") False >>> is_subsequence(\\"abc\\", \\"abacbc\\") True >>> is_subsequence(\\"\\", \\"anything\\") True >>> is_subsequence(\\"longsequence\\", \\"short\\") False def count_subsequences(patterns: List[str], s: str) -> int: Count how many strings in patterns are subsequences of string s. Args: patterns (List[str]): List of strings to check. s (str): The string to check against. Returns: int: The number of strings in patterns that are subsequences of s. >>> count_subsequences([\\"a\\", \\"bb\\", \\"acd\\", \\"ace\\"], \\"abcde\\") 3 >>> count_subsequences([\\"a\\", \\"b\\", \\"c\\", \\"d\\"], \\"abcd\\") 4 >>> count_subsequences([\\"xyz\\", \\"abc\\", \\"xy\\"], \\"axbyc\\") 2 >>> count_subsequences([\\"abc\\", \\"def\\"], \\"abcdef\\") 2 >>> count_subsequences([\\"abc\\", \\"def\\"], \\"\\") 0","solution":"def is_subsequence(small, large): it = iter(large) return all(char in it for char in small) def count_subsequences(patterns, s): count = 0 for pattern in patterns: if is_subsequence(pattern, s): count += 1 return count"},{"question":"def min_operations_to_unique(sequence: str) -> int: Given a string \`sequence\`, find the minimum number of operations required to make every character in the string unique. In one operation, you can choose any character from \`sequence\` and replace it with any uppercase English letter that is not already present in the \`sequence\`. Return an integer representing the minimum number of operations required. Args: - sequence (str): The input string where we need to make each character unique. Returns: - int: The minimum number of operations required. >>> min_operations_to_unique(\\"AAB\\") 1 >>> min_operations_to_unique(\\"AAA\\") 2 >>> min_operations_to_unique(\\"ABC\\") 0 >>> min_operations_to_unique(\\"ABCDABCD\\") 4 >>> min_operations_to_unique(\\"\\") 0 >>> min_operations_to_unique(\\"A\\" * 26) 25 >>> min_operations_to_unique(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") 0","solution":"def min_operations_to_unique(sequence): Given a string \`sequence\`, find the minimum number of operations required to make every character in the string unique. Args: - sequence (str): The input string where we need to make each character unique. Returns: - int: The minimum number of operations required. from collections import Counter # Count the frequency of each character in the input string frequency = Counter(sequence) # List of characters that we can use to replace duplicates available_chars = set(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") # Remove already present characters from the available characters list for char in sequence: if char in available_chars: available_chars.remove(char) operations = 0 for char, count in frequency.items(): # If there are duplicates while count > 1: operations += 1 count -= 1 # Replace one occurence of the character with an available character # Remove one character from the available set if available_chars: available_chars.pop() return operations"},{"question":"def can_split_array(nums: List[int]) -> bool: Determine if the given array can be split into two contiguous subarrays with equal sums. Parameters: nums (list of int): The input array of integers. Returns: bool: True if such a split is possible, False otherwise. >>> can_split_array([1, 2, 3, 1, 2, 3]) True >>> can_split_array([1, 2, 3, 4, 5, 6]) False >>> can_split_array([6, 3, 3]) True >>> can_split_array([1, 2, 3, 4]) False >>> can_split_array([]) False >>> can_split_array([5, 5]) True >>> can_split_array([5, 6]) False >>> can_split_array([0, 0, 0, 0]) True","solution":"def can_split_array(nums): Determine if the given array can be split into two contiguous subarrays with equal sums. Parameters: nums (list of int): The input array of integers. Returns: bool: True if such a split is possible, False otherwise. total_sum = sum(nums) if total_sum % 2 != 0: return False left_sum = 0 target = total_sum // 2 for num in nums: left_sum += num if left_sum == target: return True elif left_sum > target: return False return False"},{"question":"class Solution: def __init__(self): pass def splitArray(self, nums: List[int], k: int) -> int: Returns the minimized maximum sum of the subarrays. >>> sol = Solution() >>> sol.splitArray([7, 2, 5, 10, 8], 2) 18 >>> sol.splitArray([10], 1) 10 >>> sol.splitArray([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 2) 5 >>> sol.splitArray([1, 2, 3, 4, 5], 5) 5 >>> sol.splitArray([1, 3, 6, 1, 2, 8], 1) 21","solution":"class Solution: def splitArray(self, nums, k): Returns the minimized maximum sum of the subarrays. def can_split(nums, k, mid): current_sum = 0 required_subarrays = 1 for num in nums: if current_sum + num > mid: current_sum = num required_subarrays += 1 if required_subarrays > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(nums, k, mid): right = mid else: left = mid + 1 return left"},{"question":"def longest_valid_parentheses(s): This function returns the length of the longest valid parentheses substring. :param s: String comprising only '(' and ')' :return: Length of the longest valid parentheses substring","solution":"def longest_valid_parentheses(s): This function returns the length of the longest valid parentheses substring. :param s: String comprising only '(' and ')' :return: Length of the longest valid parentheses substring n = len(s) stack = [] max_length = 0 last_invalid_index = -1 for i in range(n): if s[i] == '(': stack.append(i) else: # s[i] == ')' if stack: stack.pop() if stack: max_length = max(max_length, i - stack[-1]) else: max_length = max(max_length, i - last_invalid_index) else: last_invalid_index = i return max_length"},{"question":"def minimum_time(tasks, k): Returns the minimum amount of time needed to complete all tasks using up to k workers. Tasks array holds times needed to complete each task. Each worker can handle exactly one task at a time. All tasks start simultaneously. >>> minimum_time([], 3) == 0 >>> minimum_time([4, 2, 8], 1) == 14 >>> minimum_time([4, 2, 8], 3) == 8 >>> minimum_time([5, 9, 6], 5) == 9 >>> minimum_time([2, 2, 3, 7, 1, 4], 3) == 7 >>> minimum_time([10, 20, 30, 40], 4) == 40 >>> minimum_time([1, 2, 3], 0) == ValueError(\\"Number of workers must be a positive integer.\\")","solution":"def minimum_time(tasks, k): Returns the minimum amount of time needed to complete all tasks using up to k workers. Tasks array holds times needed to complete each task. Each worker can handle exactly one task at a time. All tasks start simultaneously. if not tasks: return 0 if k <= 0: raise ValueError(\\"Number of workers must be a positive integer.\\") tasks.sort(reverse=True) workers = [0] * min(k, len(tasks)) for task in tasks: workers[0] += task workers.sort() return max(workers)"},{"question":"from collections import deque class MovingAverage: Design a data structure that supports adding historical price values and efficiently returning moving averages over a specified window size in real-time. Usage: >>> m = MovingAverage(3) >>> m.add(1) >>> m.add(10) >>> m.add(3) >>> m.add(5) >>> m.getAverage() 6.0 def __init__(self, size: int): Initializes the object with the size of the moving window. pass def add(self, value: int): Adds a new price value. pass def getAverage(self) -> float: Returns the current moving average of the added values within the window size. pass def test_moving_average_initial_state(): m = MovingAverage(3) assert m.getAverage() == 0.0 def test_moving_average_single_value(): m = MovingAverage(3) m.add(5) assert m.getAverage() == 5.0 def test_moving_average_less_than_window(): m = MovingAverage(3) m.add(5) m.add(10) assert m.getAverage() == 7.5 def test_moving_average_full_window(): m = MovingAverage(3) m.add(1) m.add(10) m.add(3) assert m.getAverage() == 14 / 3.0 def test_moving_average_exceed_window(): m = MovingAverage(3) m.add(1) m.add(10) m.add(3) m.add(5) assert m.getAverage() == 6.0 # (10 + 3 + 5) / 3 = 6.0 def test_moving_average_exact_window(): m = MovingAverage(3) m.add(1) m.add(2) m.add(3) assert m.getAverage() == 2.0 # (1 + 2 + 3) / 3 = 2.0 def test_moving_average_changing_values(): m = MovingAverage(3) m.add(3) m.add(-1) m.add(4) assert m.getAverage() == 2.0 # (3 - 1 + 4) / 3 = 2.0 m.add(10) assert m.getAverage() == 13 / 3.0 # (-1 + 4 + 10) / 3","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initializes the object with the size of the moving window. self.size = size self.window = deque() self.window_sum = 0 def add(self, value: int): Adds a new price value. if len(self.window) == self.size: self.window_sum -= self.window.popleft() self.window.append(value) self.window_sum += value def getAverage(self) -> float: Returns the current moving average of the added values within the window size. if not self.window: return 0 return self.window_sum / len(self.window)"},{"question":"class UniqueLinkedList: A class to represent a singly linked list where each node contains an integer value. Supports the following operations: - \`UniqueLinkedList()\` : Initializes the linked list object. - \`void add(int value)\` : Adds a new node with the given value to the end of the linked list. If the value already exists in the linked list, do not add it. - \`boolean remove(int value)\` : Removes the node with the given value from the linked list. Returns \`true\` if the node was successfully removed, otherwise returns \`false\`. - \`boolean contains(int value)\` : Checks whether the linked list contains a node with the given value. Returns \`true\` if such a node exists, otherwise returns \`false\`. - \`List<Integer> getAllElements()\` : Returns all the values in the linked list as a list. class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.head = None self.value_set = set() def add(self, value): Adds a new node with the given value to the end of the linked list. If the value already exists in the linked list, do not add it. def remove(self, value): Removes the node with the given value from the linked list. Returns \`true\` if the node was successfully removed, otherwise returns \`false\`. def contains(self, value): Checks whether the linked list contains a node with the given value. Returns \`true\` if such a node exists, otherwise returns \`false\`. def getAllElements(self): Returns all the values in the linked list as a list. def test_add(): ull = UniqueLinkedList() ull.add(1) ull.add(2) ull.add(1) # Duplicate, should not be added assert ull.getAllElements() == [1, 2] def test_remove(): ull = UniqueLinkedList() ull.add(1) ull.add(2) assert ull.remove(1) == True # Removed successfully assert ull.getAllElements() == [2] assert ull.remove(1) == False # Already removed, should return False def test_contains(): ull = UniqueLinkedList() ull.add(1) ull.add(2) assert ull.contains(1) == True assert ull.contains(2) == True assert ull.contains(3) == False def test_getAllElements(): ull = UniqueLinkedList() ull.add(3) ull.add(1) ull.add(2) assert ull.getAllElements() == [3, 1, 2] def test_all_operations_together(): ull = UniqueLinkedList() ull.add(1) ull.add(2) ull.add(3) assert ull.getAllElements() == [1, 2, 3] assert ull.contains(2) == True assert ull.remove(2) == True assert ull.contains(2) == False ull.add(2) assert ull.add(2) == None # Check that duplicates are not added assert ull.getAllElements() == [1, 3, 2]","solution":"class UniqueLinkedList: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.head = None self.value_set = set() def add(self, value): if value in self.value_set: return new_node = self.Node(value) self.value_set.add(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def remove(self, value): if value not in self.value_set: return False self.value_set.remove(value) current = self.head prev = None while current: if current.value == value: if prev: prev.next = current.next else: self.head = current.next return True prev = current current = current.next return False def contains(self, value): return value in self.value_set def getAllElements(self): elements = [] current = self.head while current: elements.append(current.value) current = current.next return elements"},{"question":"def longest_substring_with_k_distinct_chars(s: str, k: int) -> int: Returns the length of the longest substring of \`s\` that contains at most \`k\` distinct characters. >>> longest_substring_with_k_distinct_chars(\\"eceba\\", 2) 3 >>> longest_substring_with_k_distinct_chars(\\"aa\\", 1) 2 >>> longest_substring_with_k_distinct_chars(\\"a\\", 2) 1 >>> longest_substring_with_k_distinct_chars(\\"abc\\", 0) 0 >>> longest_substring_with_k_distinct_chars(\\"aaabbb\\", 2) 6 >>> longest_substring_with_k_distinct_chars(\\"abcadcacacaca\\", 3) 11 >>> longest_substring_with_k_distinct_chars(\\"\\", 2) 0","solution":"def longest_substring_with_k_distinct_chars(s, k): Returns the length of the longest substring that contains at most k distinct characters. if k == 0: return 0 n = len(s) left = 0 right = 0 max_len = 0 char_count = {} while right < n: char = s[right] if char in char_count: char_count[char] += 1 else: char_count[char] = 1 while len(char_count) > k: left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"def max_coins(grid: List[List[int]]) -> int: This function computes the maximum number of coins that can be collected by a robot moving from the top-left corner to the bottom-right corner of a grid. The robot can only move right or down. >>> max_coins([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 12 >>> max_coins([[2, 3], [4, 2]]) == 8","solution":"def max_coins(grid): This function computes the maximum number of coins that can be collected by a robot moving from the top-left corner to the bottom-right corner of a grid. The robot can only move right or down. Parameters: grid (List[List[int]]): A 2D list where each entry represents the coins in a cell. Returns: int: The maximum number of coins that can be collected. m, n = len(grid), len(grid[0]) # Create a 2D dp array dp = [[0]*n for _ in range(m)] # Initialize the dp array with the coins in the first cell dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right cell contains the maximum coins that can be collected return dp[m-1][n-1]"},{"question":"def longest_subsequence_lengths(arr): Given an integer array \`arr\`, return an array \`result\` where result[i] is the length of the longest subsequence ending at index \`i\` such that every element in the subsequence is larger than its predecessor. >>> longest_subsequence_lengths([4, 1, 2, 3, 5]) [1, 1, 2, 3, 4] >>> longest_subsequence_lengths([1, 1, 1, 1]) [1, 1, 1, 1] >>> longest_subsequence_lengths([1, 2, 3, 4]) [1, 2, 3, 4] >>> longest_subsequence_lengths([4, 3, 2, 1]) [1, 1, 1, 1] >>> longest_subsequence_lengths([10, 22, 9, 33, 21, 50]) [1, 2, 1, 3, 2, 4] result = [] # Your code here return result","solution":"def longest_subsequence_lengths(arr): Returns an array \`result\` where result[i] is the length of the longest subsequence ending at index \`i\`. n = len(arr) result = [1] * n # Minimum length of subsequence is 1 (the element itself) for i in range(1, n): for j in range(i): if arr[i] > arr[j]: result[i] = max(result[i], result[j] + 1) return result"},{"question":"def transform_array(nums): Transforms the array such that for each element at every even index, it is greater than its neighboring odd index elements. Parameters: nums (list): The input list of integers Returns: list: A transformed list meeting the criteria or an empty list if no such transformation is possible. >>> transform_array([1]) [1] >>> transform_array([1, 3, 2, 4]) [3, 1, 4, 2] or [4, 3, 2, 1] >>> transform_array([5, 1, 4, 2]) [5, 1, 4, 2] >>> transform_array([1, 2, 3, 4, 5, 6]) [2, 1, 4, 3, 6, 5] or [3, 2, 4, 1, 5, 6] or [2, 1, 3, 1, 5, 4] >>> transform_array([6, 1, 5, 2, 4, 3]) [6, 1, 5, 2, 4, 3] >>> transform_array([5, 5, 5, 5, 5]) [] >>> transform_array([]) []","solution":"def transform_array(nums): Transforms the array such that for each element at every even index, it is greater than its neighboring odd index elements. Parameters: nums (list): The input list of integers Returns: list: A transformed list meeting the criteria or an empty list if no such transformation is possible. if not nums: return [] m = len(nums) for i in range(0, m, 2): if i > 0 and nums[i] <= nums[i - 1]: nums[i], nums[i - 1] = nums[i - 1], nums[i] if i < m - 1 and nums[i] <= nums[i + 1]: nums[i], nums[i + 1] = nums[i + 1], nums[i] for i in range(0, m, 2): if (i > 0 and nums[i] <= nums[i - 1]) or (i < m - 1 and nums[i] <= nums[i + 1]): return [] return nums"},{"question":"def combinationSum(nums: List[int], target: int) -> List[List[int]]: Given an integer array nums and an integer target, return an array of all the unique combinations of numbers in nums where the numbers sum to target. You may return the combinations in any order. Each number in nums can be used an unlimited number of times. The solution set must not contain duplicate combinations. Examples: >>> combinationSum([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> combinationSum([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]] >>> combinationSum([2], 1) []","solution":"def combinationSum(nums, target): def backtrack(remain, path, start): if remain == 0: result.append(list(path)) return elif remain < 0: return for i in range(start, len(nums)): # include the number into the combination path.append(nums[i]) # give the current number another chance, since we can use them unlimited times backtrack(remain - nums[i], path, i) # backtrack, remove the number from the combination path.pop() nums.sort() result = [] backtrack(target, [], 0) return result"},{"question":"def form_chain(words): Forms a chain from words where the last character of each word matches the first character of the next word. Args: words (list of str): List of strings where each string is of the same length. Returns: list of str: A sequence of words forming the required chain. An empty list if no such sequence exists. Guaranteed to have at least one possible valid chain. >>> form_chain([\\"cat\\", \\"tap\\", \\"pat\\"]) ['cat', 'tap', 'pat'] >>> form_chain([\\"ab\\", \\"bc\\"]) ['ab', 'bc'] >>> form_chain([\\"ab\\", \\"cd\\"]) [] >>> form_chain([\\"ab\\", \\"bc\\", \\"cd\\", \\"da\\"]) ['ab', 'bc', 'cd', 'da'] >>> form_chain([\\"aa\\", \\"aa\\", \\"aa\\"]) ['aa', 'aa', 'aa']","solution":"def form_chain(words): Forms a chain from words where the last character of each word matches the first character of the next word. Args: words (list of str): List of strings where each string is of the same length. Returns: list of str: A sequence of words forming the required chain. An empty list if no such sequence exists. Guaranteed to have at least one possible valid chain. def backtrack(chain): if len(chain) == len(words): return chain last_char = chain[-1][-1] for i, word in enumerate(words): if not used[i] and word[0] == last_char: used[i] = True result = backtrack(chain + [word]) if result: return result used[i] = False return [] for start_word in words: used = [False] * len(words) used[words.index(start_word)] = True result = backtrack([start_word]) if result: return result return []"},{"question":"def evaluate_expression(s: str) -> int: Given a string s representing a mathematical expression that includes integers, the operators +, -, *, and /, and ( and ) for grouping, implement a function to evaluate and return the result of the expression. The integer division should truncate toward zero. The input string is guaranteed to be a valid mathematical expression. >>> evaluate_expression(\\"2+3\\") 5 >>> evaluate_expression(\\"2+3-1\\") 4 >>> evaluate_expression(\\"2*3/3\\") 2 >>> evaluate_expression(\\"(2+3)*4-5\\") 15 >>> evaluate_expression(\\"-7/3\\") -2 >>> evaluate_expression(\\"2+(3-1)*4/2\\") 6","solution":"def evaluate_expression(s): Evaluates a given mathematical expression string. :param s: A string representing a mathematical expression :return: The evaluated result as an integer def calc(it): num = 0 stack = [] sign = \\"+\\" while it < len(s): ch = s[it] if ch.isdigit(): num = num * 10 + int(ch) if ch == \\"(\\": num, j = calc(it + 1) it = j if ch in \\"+-*/)\\" or it == len(s) - 1: if sign == \\"+\\": stack.append(num) elif sign == \\"-\\": stack.append(-num) elif sign == \\"*\\": stack.append(stack.pop() * num) elif sign == \\"/\\": stack.append(int(stack.pop() / num)) sign = ch num = 0 if ch == \\")\\": return sum(stack), it it += 1 return sum(stack) return calc(0)"},{"question":"def rob(arr: List[int]) -> int: Given an integer array \`arr\` of length \`n\` representing the amount of money in each house, determine the maximum amount of money you can steal without stealing from two adjacent houses. You are not allowed to steal from the first and last house simultaneously as they are adjacent in the circular street layout. Return the maximum money you can steal. >>> rob([2, 3, 2]) 3 >>> rob([1, 2, 3, 1]) 4 >>> rob([5, 4, 3, 2, 1]) 8 >>> rob([6, 7, 1, 30, 8, 2, 4]) 41 >>> rob([]) 0 >>> rob([1]) 1 >>> rob([2, 1]) 2 >>> rob([1, 2, 1, 1]) 3","solution":"def rob(arr): Returns the maximum amount of money that can be stolen without stealing from two adjacent houses in a circular street layout. if not arr: return 0 n = len(arr) if n == 1: return arr[0] if n == 2: return max(arr) def rob_linear(houses): prev1, prev2 = 0, 0 for amount in houses: temp = prev1 prev1 = max(prev2 + amount, prev1) prev2 = temp return prev1 # Case 1: Rob excluding the first house max1 = rob_linear(arr[1:]) # Case 2: Rob excluding the last house max2 = rob_linear(arr[:-1]) return max(max1, max2)"},{"question":"def min_groups(heights: List[int], k: int) -> int: Returns the minimum number of groups needed such that the difference between the tallest and the shortest student in each group is at most k. >>> min_groups([], 3) 0 >>> min_groups([5], 3) 1 >>> min_groups([1, 2, 3], 2) 1 >>> min_groups([1, 2, 3], 3) 1 >>> min_groups([1, 5, 9, 13], 2) 4 >>> min_groups([1, 3, 6, 9, 12], 3) 3 >>> min_groups([1, 2, 7, 10, 15], 5) 3 >>> min_groups([5, 8, 12, 1, 20], 4) 3 >>> min_groups([1, 2, 3, 4, 5], 10) 1","solution":"def min_groups(heights, k): Returns the minimum number of groups needed such that the difference between the tallest and the shortest student in each group is at most k. if not heights: return 0 heights.sort() count = 1 start = heights[0] for height in heights: if height - start > k: count += 1 start = height return count"},{"question":"def search_range(nums, target): Finds the starting and ending position of a given target value in a sorted array. Args: nums - List of integers sorted in non-decreasing order. target - Integer value to find in the array. Returns: A list containing the starting and ending position of the target value, or [-1, -1] if the target is not found. >>> search_range([5, 7, 7, 8, 8, 10], 8) [3, 4] >>> search_range([5, 7, 7, 8, 8, 10], 6) [-1, -1] >>> search_range([2, 2, 2, 3, 4, 5], 2) [0, 2] >>> search_range([1, 2, 3, 4, 5, 5, 5], 5) [4, 6] >>> search_range([7], 7) [0, 0] >>> search_range([8], 0) [-1, -1] >>> search_range([], 4) [-1, -1] >>> search_range([1, 1, 2, 2, 2, 2, 3, 4], 2) [2, 5]","solution":"def search_range(nums, target): Finds the starting and ending position of a given target value in a sorted array. Args: nums - List of integers sorted in non-decreasing order. target - Integer value to find in the array. Returns: A list containing the starting and ending position of the target value, or [-1, -1] if the target is not found. def find_left_index(nums, target): left, right = 0, len(nums) - 1 left_index = -1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: left_index = mid right = mid - 1 elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left_index def find_right_index(nums, target): left, right = 0, len(nums) - 1 right_index = -1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: right_index = mid left = mid + 1 elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return right_index left_index = find_left_index(nums, target) right_index = find_right_index(nums, target) return [left_index, right_index] if left_index != -1 else [-1, -1]"},{"question":"def numDistinct(s: str, t: str) -> int: Returns the number of distinct subsequences of s which equals t. The answer can be very large, so return it modulo \`10^9 + 7\`. >>> numDistinct(\\"rabbbit\\", \\"rabbit\\") == 3 >>> numDistinct(\\"babgbag\\", \\"bag\\") == 5 >>> numDistinct(\\"abcde\\", \\"ace\\") == 1 >>> numDistinct(\\"abcdef\\", \\"\\") == 1 >>> numDistinct(\\"\\", \\"a\\") == 0 >>> numDistinct(\\"aaa\\", \\"aa\\") == 3","solution":"def numDistinct(s, t): Returns the number of distinct subsequences of s which equals t. mod = 10**9 + 7 m, n = len(s), len(t) if n == 0: return 1 if m == 0: return 0 dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): dp[i][0] = 1 # An empty t can always be formed. for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % mod else: dp[i][j] = dp[i - 1][j] return dp[m][n]"},{"question":"def findMissingNumbers(nums): Given an integer array nums of length n, where each element is between 1 and n inclusive, return a list of the numbers that are missing from the array. :param nums: List[int] - The input list of integers :return: List[int] - The list of missing numbers >>> findMissingNumbers([4, 3, 2, 7, 8, 2, 3, 1]) [5, 6] >>> findMissingNumbers([1, 2, 3, 4, 5, 6, 7, 8]) [] >>> findMissingNumbers([9, 9, 9, 9, 9, 9, 9, 9]) [1, 2, 3, 4, 5, 6, 7, 8] >>> findMissingNumbers([1]) [] >>> findMissingNumbers([2]) [1]","solution":"def findMissingNumbers(nums): Given an integer array nums of length n, where each element is between 1 and n inclusive, return a list of the numbers that are missing from the array. :param nums: List[int] - The input list of integers :return: List[int] - The list of missing numbers n = len(nums) all_numbers = set(range(1, n + 1)) present_numbers = set(nums) missing_numbers = list(all_numbers - present_numbers) return missing_numbers"},{"question":"def count_good_buildings(heights): Returns the total number of good buildings in the given sequence of heights. A building is considered good if all buildings to its left are smaller in height and all buildings to its right are larger in height. :param heights: List[int] :return: int >>> count_good_buildings([1]) 1 >>> count_good_buildings([3, 2, 1]) 0 >>> count_good_buildings([1, 2, 3, 4, 5]) 5 >>> count_good_buildings([1, 3, 2, 4, 5]) 3 >>> count_good_buildings([2, 1, 3, 5, 4]) 1 >>> count_good_buildings([]) 0 >>> count_good_buildings([-1, -2, 0, -3, 2]) 1 >>> count_good_buildings([1, 2, 2, 3, 4]) 3 >>> count_good_buildings([1, 2]) 2 >>> count_good_buildings([2, 1]) 0","solution":"def count_good_buildings(heights): Returns the total number of good buildings in the given sequence of heights. A building is considered good if all buildings to its left are smaller in height and all buildings to its right are larger in height. :param heights: List[int] :return: int n = len(heights) if n == 0: return 0 good_buildings_count = 0 for i in range(n): is_good = True for j in range(i): if heights[j] >= heights[i]: is_good = False break if is_good: for k in range(i + 1, n): if heights[k] <= heights[i]: is_good = False break if is_good: good_buildings_count += 1 return good_buildings_count"},{"question":"def rotate_string(s: str, n: int) -> str: Rotate the string s to the right by n characters and return the resulting string. >>> rotate_string(\\"hello\\", 0) \\"hello\\" >>> rotate_string(\\"hello\\", 2) \\"lohel\\" >>> rotate_string(\\"hello\\", 5) \\"hello\\" >>> rotate_string(\\"\\", 2) \\"\\" >>> rotate_string(\\"hello\\", 7) \\"lohel\\" >>> rotate_string(\\"hello\\", -2) \\"llohe\\"","solution":"def rotate_string(s, n): Rotate the string s to the right by n characters. if not s: return s n = n % len(s) return s[-n:] + s[:-n]"},{"question":"def is_range_covered(intervals: List[List[int]], a: int, b: int) -> bool: Check if the range [a, b] is fully covered by given intervals. >>> is_range_covered([[1, 2], [3, 4], [5, 6]], 2, 5) True >>> is_range_covered([[1, 10]], 1, 10) True >>> is_range_covered([[1, 3], [2, 5]], 1, 5) True >>> is_range_covered([[1, 2], [4, 5]], 3, 4) False >>> is_range_covered([[1, 2], [3, 5]], 2, 6) False >>> is_range_covered([[1, 2], [3, 4]], 2, 2) True >>> is_range_covered([[1, 2], [3, 4]], 5, 5) False >>> is_range_covered([], 1, 10) False","solution":"def is_range_covered(intervals, a, b): covered = [False] * (b - a + 1) for start, end in intervals: for i in range(max(start, a), min(end, b) + 1): covered[i - a] = True return all(covered)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameter_of_binary_tree(root: TreeNode) -> int: Finds the diameter of a binary tree, which is the length of the longest path between any two nodes in the tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> diameter_of_binary_tree(root) 2 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> diameter_of_binary_tree(root) 3 from solution import TreeNode, diameter_of_binary_tree def test_diameter_single_node(): root = TreeNode(1) assert diameter_of_binary_tree(root) == 0 def test_diameter_straight_line(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) assert diameter_of_binary_tree(root) == 2 def test_diameter_balanced_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) assert diameter_of_binary_tree(root) == 3 def test_diameter_unbalanced_tree(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) root.left.left.left = TreeNode(4) root.left.left.left.left = TreeNode(5) assert diameter_of_binary_tree(root) == 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameter_of_binary_tree(root): Finds the diameter of a binary tree, which is the length of the longest path between any two nodes in the tree. def depth(node): # Helper function to calculate the depth of the tree and update the diameter nonlocal diameter if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) # Path through this node is left_depth + right_depth diameter = max(diameter, left_depth + right_depth) # Return the depth of the tree rooted at this node return max(left_depth, right_depth) + 1 diameter = 0 depth(root) return diameter"},{"question":"def is_bipartite(graph: List[List[int]]) -> bool: Returns True if the graph is bipartite, otherwise returns False. >>> is_bipartite([[1,3], [0,2], [1,3], [0,2]]) True >>> is_bipartite([[1,2,3], [0,2], [0,1,3], [0,2]]) False >>> is_bipartite([]) True >>> is_bipartite([[]]) True >>> is_bipartite([[1], [0], [3], [2]]) True >>> is_bipartite([[1], [0], [3, 4], [2], [2]]) False","solution":"def is_bipartite(graph): Returns True if the graph is bipartite, otherwise returns False. color = {} def dfs(node, c): if node in color: return color[node] == c color[node] = c return all(dfs(nei, c ^ 1) for nei in graph[node]) return all(dfs(node, 0) for node in range(len(graph)) if node not in color)"},{"question":"def longest_common_subsequence(str1: str, str2: str) -> int: Returns the length of the longest common subsequence between str1 and str2. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence(\\"aabbcc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abcdef\\", \\"acf\\") 3 >>> longest_common_subsequence(\\"\\", \\"\\") 0 >>> longest_common_subsequence(\\"abc\\", \\"\\") 0 >>> longest_common_subsequence(\\"\\", \\"abc\\") 0 >>> longest_common_subsequence(\\"a\\", \\"a\\") 1 >>> longest_common_subsequence(\\"a\\", \\"b\\") 0","solution":"def longest_common_subsequence(str1, str2): Returns the length of the longest common subsequence between str1 and str2. m, n = len(str1), len(str2) # Create a 2D array to store the lengths of longest common subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"def maxProduct(nums: List[int]) -> int: Returns the maximum product of any three numbers in the array. >>> maxProduct([1, 2, 3, 4]) == 24 >>> maxProduct([1, 10, -5, 1, -100]) == 5000 >>> maxProduct([-10, -10, 5, 2]) == 500 >>> maxProduct([-1, -2, -3, -4]) == -6 >>> maxProduct([1000, 900, 800, 700, 600]) == 720000000 >>> maxProduct([1, 2, 3]) == 6","solution":"def maxProduct(nums): Returns the maximum product of any three numbers in the array. if len(nums) < 3: raise ValueError(\\"Input array must have at least three elements\\") # Initialize the three highest numbers and the two lowest numbers max1 = max2 = max3 = float('-inf') min1 = min2 = float('inf') # Traverse the array to find the three largest and two smallest numbers for num in nums: # Update the largest numbers if num > max1: max3 = max2 max2 = max1 max1 = num elif num > max2: max3 = max2 max2 = num elif num > max3: max3 = num # Update the smallest numbers if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num # The max product of three numbers would be the maximum of: # 1. The product of the three largest numbers # 2. The product of the two smallest numbers and the largest number return max(max1 * max2 * max3, min1 * min2 * max1)"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. Args: s (str): The input string consisting of lowercase letters. Returns: int: The length of the longest substring with at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") == 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") == 5 >>> length_of_longest_substring_two_distinct(\\"aaaa\\") == 4 >>> length_of_longest_substring_two_distinct(\\"a\\") == 1 >>> length_of_longest_substring_two_distinct(\\"ab\\") == 2 >>> length_of_longest_substring_two_distinct(\\"abcdef\\") == 2 >>> length_of_longest_substring_two_distinct(\\"\\") == 0","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring that contains at most two distinct characters. Args: s (str): The input string consisting of lowercase letters. Returns: int: The length of the longest substring with at most two distinct characters. if len(s) < 3: return len(s) left, right = 0, 0 max_len = 2 char_map = {} while right < len(s): if len(char_map) < 3: char_map[s[right]] = right right += 1 if len(char_map) == 3: min_index = min(char_map.values()) del char_map[s[min_index]] left = min_index + 1 max_len = max(max_len, right - left) return max_len"},{"question":"def longest_ones_with_flip(s: str) -> int: You are given a binary string \`s\` consisting of only the characters '0' and '1'. You can flip at most one '0' to '1'. Find the length of the longest contiguous subsequence of '1's that can be obtained by performing at most one flip to '0'. Return the length of this maximum contiguous subsequence of '1's. >>> longest_ones_with_flip(\\"11111\\") 5 >>> longest_ones_with_flip(\\"1101111\\") 7 >>> longest_ones_with_flip(\\"110110111\\") 6 >>> longest_ones_with_flip(\\"000\\") 1 >>> longest_ones_with_flip(\\"0111101\\") 6 >>> longest_ones_with_flip(\\"101\\") 3 >>> longest_ones_with_flip(\\"\\") 0","solution":"def longest_ones_with_flip(s): n = len(s) max_length = 0 left = 0 zero_count = 0 for right in range(n): if s[right] == '0': zero_count += 1 while zero_count > 1: if s[left] == '0': zero_count -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def rob(nums): Returns the maximum amount of money you can rob without setting off the alarms. >>> rob([]) == 0 >>> rob([5]) == 5 >>> rob([5, 3]) == 5 >>> rob([3, 5]) == 5 >>> rob([1, 2, 3, 1]) == 4 >>> rob([2, 7, 9, 3, 1]) == 12 >>> rob([100, 50, 200, 300, 100]) == 400 >>> rob([2, 1, 2, 1, 2, 1, 2]) == 8 >>> rob([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 30 >>> large_list = [10**6] * 1000 >>> rob(large_list) == 500000000 >>> large_list = [10**6, 10**6-1] * 500 >>> rob(large_list) == 500000000","solution":"def rob(nums): Returns the maximum amount of money you can rob without setting off the alarms. if not nums: return 0 if len(nums) == 1: return nums[0] rob1, rob2 = 0, 0 for n in nums: new_rob = max(rob1 + n, rob2) rob1 = rob2 rob2 = new_rob return rob2"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a string mathematical expression and returns its integer value. The expression may contain +, -, parentheses, non-negative integers, and spaces. >>> evaluate_expression(\\"1 + 1\\") 2 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") 23","solution":"def evaluate_expression(expression): Evaluates a string mathematical expression and returns its integer value. The expression may contain +, -, parentheses, non-negative integers, and spaces. def helper(s, i): stack = [] num = 0 sign = 1 while i < len(s): char = s[i] if char.isdigit(): num = num * 10 + int(char) elif char == '+': stack.append(sign * num) num = 0 sign = 1 elif char == '-': stack.append(sign * num) num = 0 sign = -1 elif char == '(': num, j = helper(s, i + 1) i = j - 1 elif char == ')': stack.append(sign * num) return sum(stack), i + 1 i += 1 stack.append(sign * num) return sum(stack), i expression = expression.replace(' ', '') result, _ = helper(expression, 0) return result"},{"question":"def is_rotated_subgrid_possible(grid: List[List[int]]) -> bool: Determine whether it is possible to make all rows in any rotated subgrid equal to each other. >>> is_rotated_subgrid_possible([[1]]) == False >>> is_rotated_subgrid_possible([[1, 1], [1, 1]]) == True >>> is_rotated_subgrid_possible([[1, 2], [3, 4]]) == False >>> is_rotated_subgrid_possible([[1, 1, 1], [1, 2, 2], [2, 2, 2]]) == True >>> is_rotated_subgrid_possible([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == False","solution":"def is_rotated_subgrid_possible(grid): m, n = len(grid), len(grid[0]) def check_square(i, j, k): square = [] for x in range(k): row = [grid[i + x][j + y] for y in range(k)] square.append(row) def rotate(square): return [list(row) for row in zip(*square[::-1])] for _ in range(4): square = rotate(square) if all(row == square[0] for row in square): return True return False for i in range(m): for j in range(n): max_size = min(m - i, n - j) for k in range(2, max_size + 1): if check_square(i, j, k): return True return False"},{"question":"def organize_messages(messages: List[Tuple[int, Optional[int]]]) -> List[List[int]]: Organize a list of messages into threads. Parameters: - messages: List of tuples (message_id, reply_to_id) Returns: A list of threads, where each thread is a list of message_ids sorted in chronological order. >>> organize_messages([(1, None)]) [[1]] >>> organize_messages([(1, None), (2, None), (3, None)]) [[1], [2], [3]] >>> organize_messages([(1, None), (2, 1), (3, 1), (4, 3)]) [[1, 2, 3, 4]] >>> organize_messages([(1, None), (2, 1), (3, None), (4, 3), (5, None)]) [[1, 2], [3, 4], [5]] >>> organize_messages([(1, 2), (2, None), (3, 4), (4, None)]) [[1], [2], [3], [4]] pass","solution":"def organize_messages(messages): Organizes a list of messages into threads. Parameters: - messages: List of tuples (message_id, reply_to_id) Returns: A list of threads, where each thread is a list of message_ids sorted in chronological order. # Create a dictionary to map each message_id to its index in the list message_index = {} for i, (mid, reply_to) in enumerate(messages): message_index[mid] = i # Initialize tracking structures threads = [] thread_mapping = {} in_reply_to_mapping = {} # Organize messages for mid, reply_to in messages: if reply_to is None or reply_to not in message_index: # New thread threads.append([mid]) thread_mapping[mid] = mid else: # Add to existing thread thread_id = thread_mapping.get(reply_to, None) if thread_id is not None: threads[in_reply_to_mapping[thread_id]].append(mid) thread_mapping[mid] = thread_id else: # Reply to a message that's not in the list, start a new thread threads.append([mid]) thread_mapping[mid] = mid in_reply_to_mapping[mid] = len(threads) - 1 return threads"},{"question":"def is_cyclic(graph: List[List[int]]) -> bool: Determines if an undirected graph contains a cycle. Parameters: graph (list of list of int): Adjacency list of the graph. Returns: bool: True if the graph contains a cycle, False otherwise. Examples: >>> graph = [ ... [1], ... [0, 2], ... [1, 3], ... [2] ... ] >>> is_cyclic(graph) False >>> graph = [ ... [1, 2], ... [0, 2], ... [0, 1] ... ] >>> is_cyclic(graph) True from solution import is_cyclic def test_no_cycle(): graph = [ [1], [0, 2], [1, 3], [2] ] assert not is_cyclic(graph) # No cycle in this graph def test_single_node_no_edges(): graph = [[]] assert not is_cyclic(graph) # Single node with no edges def test_small_cycle(): graph = [ [1, 2], [0, 2], [0, 1] ] assert is_cyclic(graph) # Small cycle (0-1-2-0) def test_disconnected_graph_with_cycle(): graph = [ [1], [0], [3, 4], [2, 4], [2, 3] ] assert is_cyclic(graph) # Cycle in the component (2-3-4-2) def test_disconnected_graph_without_cycle(): graph = [ [1], [0], [3], [2, 4], [3] ] assert not is_cyclic(graph) # No cycles in any component def test_complex_graph_with_cycle(): graph = [ [1, 2], [0, 3], [0, 3, 4], [1, 2], [2, 5], [4, 6], [5] ] assert is_cyclic(graph) # Cycle in the component (0-1-3-2-0)","solution":"def is_cyclic(graph): Determines if an undirected graph contains a cycle. Parameters: graph (list of list of int): Adjacency list of the graph. Returns: bool: True if the graph contains a cycle, False otherwise. def dfs(v, parent): visited.add(v) for neighbor in graph[v]: if neighbor not in visited: if dfs(neighbor, v): return True elif parent != neighbor: return True return False visited = set() for vertex in range(len(graph)): if vertex not in visited: if dfs(vertex, -1): return True return False"},{"question":"def max_value(events): Given a list of events where events[i] = [starti, endi, valuei], each event starts at starti, ends at endi, and has a value valuei, return the maximum value you can obtain by attending a subset of these events such that no two events overlap. >>> max_value([[1, 2, 4]]) 4 >>> max_value([[1, 2, 4], [3, 4, 3]]) 7 >>> max_value([[1, 4, 3], [2, 3, 5], [3, 4, 2]]) 5 >>> max_value([[1, 2, 4], [2, 3, 2], [3, 4, 3], [4, 5, 5]]) 9 >>> max_value([[1, 4, 3], [2, 5, 4], [3, 6, 5]]) 5","solution":"def max_value(events): # Sort events by their ending time events.sort(key=lambda x: x[1]) # DP array to store the maximum values dp = [0] * len(events) # Function to find the last event that doesn't conflict with event[i] def find_last_non_conflicting(i): low, high = 0, i-1 while low <= high: mid = (low + high) // 2 if events[mid][1] < events[i][0]: if events[mid + 1][1] < events[i][0]: low = mid + 1 else: return mid else: high = mid - 1 return -1 # Fill dp array dp[0] = events[0][2] for i in range(1, len(events)): include = events[i][2] l = find_last_non_conflicting(i) if l != -1: include += dp[l] dp[i] = max(include, dp[i-1]) return dp[-1]"},{"question":"from collections import OrderedDict, defaultdict class FirstUnique: Given a string \`stream\` that represents a continuous stream of characters appearing in chronological order, this class \`FirstUnique\` provides two operations: 1. \`FirstUnique(char stream[])\`: Initializes the object with the stream of characters. 2. \`char showFirstUnique()\`: Returns the first unique character in the stream. If there is no such character, return \`'#'\`. 3. \`void add(char c)\`: Adds the character \`c\` to the stream. >>> fu = FirstUnique(\\"aabbcd\\") >>> fu.showFirstUnique() 'c' >>> fu.add('a') >>> fu.showFirstUnique() 'c' >>> fu.add('c') >>> fu.showFirstUnique() '#' >>> fu.add('d') >>> fu.showFirstUnique() '#' def __init__(self, stream): Initializes the object with the stream of characters. pass def showFirstUnique(self): Returns the first unique character in the stream. If there is no such character, return '#'. pass def add(self, char): Adds the character \`c\` to the stream. pass def test_initial_stream(): fu = FirstUnique(\\"aabbcd\\") assert fu.showFirstUnique() == 'c' def test_add_existing_char_not_change(): fu = FirstUnique(\\"aabbcd\\") fu.add('a') assert fu.showFirstUnique() == 'c' def test_add_existing_char_to_unique_char(): fu = FirstUnique(\\"aabbcd\\") fu.add('d') assert fu.showFirstUnique() == 'c' def test_add_unique_char_to_make_no_unique(): fu = FirstUnique(\\"aabbcd\\") fu.add('c') fu.add('d') assert fu.showFirstUnique() == '#' def test_all_chars_non_unique(): fu = FirstUnique(\\"aabbcc\\") assert fu.showFirstUnique() == '#' def test_add_to_empty_stream(): fu = FirstUnique(\\"\\") assert fu.showFirstUnique() == '#' fu.add('a') assert fu.showFirstUnique() == 'a' fu.add('a') assert fu.showFirstUnique() == '#' def test_empty_initial_stream_add_unique_chars(): fu = FirstUnique(\\"\\") fu.add('x') assert fu.showFirstUnique() == 'x' fu.add('y') assert fu.showFirstUnique() == 'x' fu.add('x') assert fu.showFirstUnique() == 'y'","solution":"from collections import OrderedDict, defaultdict class FirstUnique: def __init__(self, stream): self.stream = OrderedDict() self.count = defaultdict(int) for char in stream: self.add(char) def showFirstUnique(self): for char in self.stream: if self.count[char] == 1: return char return '#' def add(self, char): if char in self.stream: self.count[char] += 1 else: self.stream[char] = None self.count[char] = 1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findBottomLeftValue(root: TreeNode) -> int: Given a binary tree, find the leftmost value in the last row of the tree. Args: root (TreeNode): The root of the binary tree. Returns: int: The leftmost value in the last row of the tree. Example: >>> root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3, None, TreeNode(5, TreeNode(6)))) >>> findBottomLeftValue(root) 6 # Your code here","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findBottomLeftValue(root): Returns the leftmost value in the last row of the tree. from collections import deque queue = deque([root]) while queue: node = queue.popleft() if node.right: queue.append(node.right) if node.left: queue.append(node.left) return node.val"},{"question":"from typing import List def is_possible_to_partition(arr: List[int], k: int) -> bool: Determine if it is possible to partition the array into k consecutive subsequences. :param arr: List[int] - The input array of integers. :param k: int - The desired number of consecutive subsequences. :return: bool - True if possible, otherwise False. >>> is_possible_to_partition([1,2,3,3,4,4,5,6], 4) True >>> is_possible_to_partition([1,2,3,4,5,6,7,8], 3) False >>> is_possible_to_partition([1,1,1,1,1], 5) False >>> is_possible_to_partition([3,3,3,3,3,3], 2) False >>> is_possible_to_partition([1,2,3,4,5,6,7,8], 2) True >>> is_possible_to_partition([], 1) True >>> is_possible_to_partition([1,2,4,5,6,7], 3) False","solution":"from collections import Counter import heapq def is_possible_to_partition(arr, k): Determine if it is possible to partition the array into k consecutive subsequences. :param arr: List[int] - The input array of integers :param k: int - The desired number of consecutive subsequences :return: bool - True if possible, otherwise False if len(arr) % k != 0: return False counter = Counter(arr) min_heap = list(counter.keys()) heapq.heapify(min_heap) while min_heap: first = min_heap[0] for i in range(first, first + k): if counter[i] == 0: return False counter[i] -= 1 if counter[i] == 0: if i != min_heap[0]: return False heapq.heappop(min_heap) return True"},{"question":"def max_equal_substrings(s: str) -> int: You are given a binary string \`s\` consisting only of the characters '0' and '1'. You need to find the maximum number of contiguous substrings such that each substring contains an equal number of '0's and '1's. If it is impossible to split the string in such a way, return \`-1\`. >>> max_equal_substrings(\\"0101\\") 2 >>> max_equal_substrings(\\"0011\\") 1 >>> max_equal_substrings(\\"0000\\") -1 >>> max_equal_substrings(\\"0000\\") -1 >>> max_equal_substrings(\\"\\") -1","solution":"def max_equal_substrings(s): Finds the maximum number of contiguous substrings such that each substring contains an equal number of '0's and '1's. If it is impossible to split the string in such a way, return -1. count_0 = 0 count_1 = 0 max_substrings = 0 for char in s: if char == '0': count_0 += 1 else: count_1 += 1 if count_0 == count_1: max_substrings += 1 if max_substrings == 0: return -1 return max_substrings"},{"question":"def num_subarray_product_less_than_k(nums: List[int], k: int) -> int: Returns the number of contiguous subarrays where the product of all the elements is less than k. Args: nums: List[int] - List of integers. k: int - The threshold product value. Returns: int - Number of subarrays with product less than k. Examples: >>> num_subarray_product_less_than_k([10, 5, 2, 6], 100) 8 >>> num_subarray_product_less_than_k([10, 5, 2, 6], 0) 0 >>> num_subarray_product_less_than_k([1, 2, 3], 4) 4 >>> num_subarray_product_less_than_k([1, 2, 3, 4], 10) 7 >>> num_subarray_product_less_than_k([10], 10) 0 >>> num_subarray_product_less_than_k([10], 20) 1 >>> num_subarray_product_less_than_k([1, 2, 3], 100) 6 >>> num_subarray_product_less_than_k([1, 1, 1, 1], 2) 10","solution":"def num_subarray_product_less_than_k(nums, k): Returns the number of contiguous subarrays where the product of all the elements is less than k. if k <= 1: return 0 count = 0 product = 1 left = 0 for right in range(len(nums)): product *= nums[right] while product >= k: product //= nums[left] left += 1 count += right - left + 1 return count"},{"question":"def count_distinct_strings(s: str) -> int: Returns the number of distinct strings that can be generated by replacing the wildcards in the string. Parameters: s (str): Input string containing lowercase English letters and wildcard '*' characters. Returns: int: Number of distinct strings that can be generated. >>> count_distinct_strings(\\"apple\\") == 1 >>> count_distinct_strings(\\"a*c\\") == 26 >>> count_distinct_strings(\\"*\\") == 26 >>> count_distinct_strings(\\"a**c\\") == 26 * 26 >>> count_distinct_strings(\\"****\\") == 26 ** 4 >>> count_distinct_strings(\\"a*p*le\\") == 26 * 26 >>> count_distinct_strings(\\"**a*b*c**\\") == 26 ** 6 >>> count_distinct_strings(\\"**********\\") == 26 ** 10","solution":"def count_distinct_strings(s): Returns the number of distinct strings that can be generated by replacing the wildcards in the string. Parameters: s (str): Input string containing lowercase English letters and wildcard '*' characters. Returns: int: Number of distinct strings that can be generated. wildcard_count = s.count('*') return 26 ** wildcard_count"},{"question":"def height_difference(heights, friends): Calculate the height difference between each person and their tallest friend. Parameters: heights (list[int]): List of heights of people. friends (list[list[int]]): List of pairs indicating friendships. Returns: list[int]: List of height differences for each person. pass # Test cases def test_no_friends(): heights = [160, 165, 170] friends = [] assert height_difference(heights, friends) == [0, 0, 0] def test_all_have_friends(): heights = [160, 165, 170] friends = [[0, 1], [1, 2]] assert height_difference(heights, friends) == [5, 5, -5] def test_some_have_friends(): heights = [160, 175, 150, 190] friends = [[0, 1], [2, 3]] assert height_difference(heights, friends) == [15, -15, 40, -40] def test_all_same_height(): heights = [175, 175, 175, 175] friends = [[0, 1], [1, 2], [2, 3], [3, 0]] assert height_difference(heights, friends) == [0, 0, 0, 0] def test_no_heights(): heights = [] friends = [] assert height_difference(heights, friends) == [] test_no_friends() test_all_have_friends() test_some_have_friends() test_all_same_height() test_no_heights()","solution":"def height_difference(heights, friends): Calculate the height difference between each person and their tallest friend. Parameters: heights (list[int]): List of heights of people. friends (list[list[int]]): List of pairs indicating friendships. Returns: list[int]: List of height differences for each person. n = len(heights) result = [0] * n # Initialize result with 0s, assuming no friends # Dictionary to store friends of each person friend_dict = {i: [] for i in range(n)} # Fill the friend_dict with friends for a, b in friends: friend_dict[a].append(b) friend_dict[b].append(a) for i in range(n): if friend_dict[i]: # Get the max height among friends max_friend_height = max(heights[j] for j in friend_dict[i]) result[i] = max_friend_height - heights[i] return result"},{"question":"def find_and_replace_pattern(words: List[str], pattern: str) -> List[str]: Find all strings in \`words\` that match the \`pattern\`. A string matches the pattern if the characters in the string can be replaced to get the pattern. >>> find_and_replace_pattern([\\"abc\\",\\"deq\\",\\"mee\\",\\"aqq\\",\\"dkd\\",\\"ccc\\"], \\"abb\\") [\\"mee\\", \\"aqq\\"] >>> find_and_replace_pattern([\\"abc\\",\\"deq\\",\\"xyz\\"], \\"abb\\") [] >>> find_and_replace_pattern([\\"aqq\\",\\"bcc\\",\\"dee\\"], \\"yxx\\") [\\"aqq\\",\\"bcc\\",\\"dee\\"] >>> find_and_replace_pattern([], \\"xyz\\") [] >>> find_and_replace_pattern([\\"abc\\",\\"def\\",\\"ghi\\"], \\"\\") [] >>> find_and_replace_pattern([\\"a\\",\\"b\\",\\"c\\"], \\"a\\") [\\"a\\",\\"b\\",\\"c\\"]","solution":"def find_and_replace_pattern(words, pattern): This function finds all the words in the list \`words\` that match the \`pattern\`. def matches(word): if len(word) != len(pattern): return False forward_map = {} backward_map = {} for w_char, p_char in zip(word, pattern): if w_char in forward_map and forward_map[w_char] != p_char: return False if p_char in backward_map and backward_map[p_char] != w_char: return False forward_map[w_char] = p_char backward_map[p_char] = w_char return True return [word for word in words if matches(word)]"},{"question":"from typing import List def min_subarray_len(target: int, nums: List[int]) -> int: Returns the minimum size of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead. >>> min_subarray_len(7, [2,3,1,2,4,3]) 2 >>> min_subarray_len(4, [1,4,4]) 1 >>> min_subarray_len(11, [1,1,1,1,1,1,1,1]) 0 >>> min_subarray_len(15, [1,2,3,4,5]) 5 >>> min_subarray_len(100, [1,2,3,4,5]) 0 >>> min_subarray_len(5, [5]) 1 >>> min_subarray_len(6, [5]) 0 >>> min_subarray_len(6, [10, 2, 3]) 1 >>> min_subarray_len(8, [1, 4, 4]) 2","solution":"def min_subarray_len(target, nums): Returns the minimum size of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead. n = len(nums) min_len = float('inf') left = 0 current_sum = 0 for right in range(n): current_sum += nums[right] while current_sum >= target: min_len = min(min_len, right - left + 1) current_sum -= nums[left] left += 1 return min_len if min_len != float('inf') else 0"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def reverse_level_order(root): Return the reversed level order traversal of the given binary tree's nodes' values as an array of arrays. >>> root = TreeNode(1) >>> test_reverse_level_order_single_node(root) [[1]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> test_reverse_level_order_multiple_levels(root) [[4, 5, 6, 7], [2, 3], [1]] >>> test_reverse_level_order_empty_tree(None) [] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> test_reverse_level_order_skewed_tree(root) [[3], [2], [1]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> test_reverse_level_order_tree_with_single_child_nodes(root) [[4], [3], [2], [1]] pass","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def reverse_level_order(root): if not root: return [] queue = deque([root]) result = deque() while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.appendleft(level_nodes) return list(result)"},{"question":"def contains_nearby_almost_duplicate(arr: List[int], x: int) -> bool: Determines if there exist two distinct indices i and j in the array such that |arr[i] - arr[j]| <= x and |i - j| <= x. >>> contains_nearby_almost_duplicate([1, 2, 3, 4, 5], 0) False >>> contains_nearby_almost_duplicate([1, 2, 3, 4, 5], 1) True >>> contains_nearby_almost_duplicate([10, 20, 30, 40, 50], 20) True >>> contains_nearby_almost_duplicate([10, 1, 30, 2, 50], 1) False >>> contains_nearby_almost_duplicate([1, 1, 1, 1, 1], 10) True >>> contains_nearby_almost_duplicate([], 2) False >>> contains_nearby_almost_duplicate([1], 1) False >>> contains_nearby_almost_duplicate([1, 2], 2) True","solution":"def contains_nearby_almost_duplicate(arr, x): Determines if there exist two distinct indices i and j in the array such that |arr[i] - arr[j]| <= x and |i - j| <= x. :param arr: List of integers :param x: Integer threshold for both value difference and index difference :return: Boolean indicating if such indices exist for i in range(len(arr)): for j in range(i + 1, len(arr)): if abs(arr[i] - arr[j]) <= x and abs(i - j) <= x: return True return False"},{"question":"def min_steps_to_end(steps: List[int]) -> int: Determines the minimum number of steps required to reach the last index of the array or returns -1 if it is not possible to reach the last index. :param steps: List[int] - List of steps where steps[i] denotes the maximum number of steps you can advance forward from the i-th position. :return: int - Minimum number of steps needed to reach the end or -1 if not possible. >>> min_steps_to_end([2, 3, 1, 1, 4]) == 2 >>> min_steps_to_end([3, 2, 1, 0, 4]) == -1 >>> min_steps_to_end([1]) == 0 >>> min_steps_to_end([0, 0, 0, 0]) == -1 >>> min_steps_to_end([1, 1, 1, 1]) == 3 >>> min_steps_to_end([5, 1, 1, 1, 1]) == 1 >>> min_steps_to_end([0]) == 0 >>> min_steps_to_end([1, 0]) == 1 >>> min_steps_to_end([0, 1, 2, 3]) == -1","solution":"def min_steps_to_end(steps): Determines the minimum number of steps required to reach the last index of the array or returns -1 if it is not possible to reach the last index. :param steps: List[int] - List of steps where steps[i] denotes the maximum number of steps you can advance forward from the i-th position. :return: int - Minimum number of steps needed to reach the end or -1 if not possible. n = len(steps) if n == 0: return -1 jumps = 0 curr_end = 0 curr_furthest = 0 for i in range(n-1): curr_furthest = max(curr_furthest, i + steps[i]) if i == curr_end: jumps += 1 curr_end = curr_furthest if curr_end >= n - 1: return jumps return -1 if curr_end < n - 1 else jumps"},{"question":"def max_overlap(ranges: List[Tuple[int, int]]) -> int: Find the maximum number of ranges that overlap at a single point on the number line. >>> max_overlap([(1, 2), (3, 4), (5, 6)]) 1 >>> max_overlap([(1, 3), (2, 4), (5, 6)]) 2 >>> max_overlap([(1, 5), (2, 6), (3, 7), (4, 8)]) 4 >>> max_overlap([(1, 10), (2, 9), (3, 8), (4, 7)]) 4 >>> max_overlap([(1, 5), (1, 5), (1, 5), (1, 5)]) 4 >>> max_overlap([(1, 2), (3, 4), (5, 6), (7, 8)]) 1 >>> max_overlap([(1, 1000000), (10, 500000), (100, 200000)]) 3","solution":"def max_overlap(ranges): events = [] for l, r in ranges: events.append((l, 1)) events.append((r + 1, -1)) events.sort() max_overlap = 0 current_overlap = 0 for _, event in events: current_overlap += event max_overlap = max(max_overlap, current_overlap) return max_overlap"},{"question":"from typing import List def maxCherries(grid: List[List[int]]) -> int: Returns the maximum number of cherries in the largest piece of cake after exactly one horizontal and one vertical cut. :param grid: List[List[int]], a 2D list representing the cake, where 1 represents a cherry and 0 represents an empty cell. :return: int, the maximum number of cherries in the largest piece.","solution":"def maxCherries(grid): Returns the maximum number of cherries in the largest piece of cake after exactly one horizontal and one vertical cut. :param grid: List[List[int]], a 2D list representing the cake, where 1 represents a cherry and 0 represents an empty cell. :return: int, the maximum number of cherries in the largest piece. rows = len(grid) cols = len(grid[0]) # Precompute the prefix sum 2D array prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)] for i in range(1, rows + 1): for j in range(1, cols + 1): prefix_sum[i][j] = (grid[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1]) def get_sum(top_left, bottom_right): (r1, c1), (r2, c2) = top_left, bottom_right return prefix_sum[r2+1][c2+1] - prefix_sum[r1][c2+1] - prefix_sum[r2+1][c1] + prefix_sum[r1][c1] max_cherries = 0 for i in range(1, rows): for j in range(1, cols): top_left = get_sum((0, 0), (i-1, j-1)) top_right = get_sum((0, j), (i-1, cols-1)) bottom_left = get_sum((i, 0), (rows-1, j-1)) bottom_right = get_sum((i, j), (rows-1, cols-1)) max_cherries = max(max_cherries, top_left, top_right, bottom_left, bottom_right) return max_cherries"},{"question":"def longest_increasing_sequence(speed: List[int]) -> int: Returns the length of the longest consecutive increasing speed sequence. >>> longest_increasing_sequence([3, 4, 5, 1, 2, 3, 4, 5, 6]) 6 >>> longest_increasing_sequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_sequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_sequence([1, 3, 5, 4, 7, 8, 9]) 4 >>> longest_increasing_sequence([]) 0 >>> longest_increasing_sequence([10, 9, 8, 7, 6, 5]) 1 >>> longest_increasing_sequence([1, 2, 2, 3, 4, 5]) 4 >>> longest_increasing_sequence([1]) 1 >>> longest_increasing_sequence([3, 2, 3, 4, 1, 2, 3, 4]) 4","solution":"def longest_increasing_sequence(speed): Returns the length of the longest consecutive increasing speed sequence. if not speed: return 0 longest = 1 current = 1 for i in range(1, len(speed)): if speed[i] > speed[i - 1]: current += 1 longest = max(longest, current) else: current = 1 return longest"},{"question":"def search(nums, target): Searches for the target in the rotated sorted array nums and returns its index if found, otherwise returns -1. The algorithm runs in O(log n) time complexity. >>> search([4,5,6,7,0,1,2], 0) == 4 >>> search([4,5,6,7,0,1,2], 3) == -1 >>> search([1], 0) == -1","solution":"def search(nums, target): Searches for the target in the rotated sorted array nums and returns its index if found, otherwise returns -1. The algorithm runs in O(log n) time complexity. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid if nums[left] <= nums[mid]: if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def largest_square(matrix: List[List[int]]) -> int: Find the largest square containing only 1s and return its area. >>> largest_square([]) 0 >>> largest_square([[]]) 0 >>> largest_square([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> largest_square([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 9 >>> largest_square([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) 4 >>> largest_square([[0]]) 0 >>> largest_square([[1]]) 1 >>> largest_square([ ... [1, 1, 1], ... [1, 1, 1] ... ]) 4 >>> largest_square([ ... [1, 1, 0, 0, 1, 1, 1], ... [1, 1, 1, 1, 0, 0, 0], ... [1, 1, 1, 1, 0, 1, 1], ... [1, 1, 0, 0, 1, 1, 1] ... ]) 4 pass","solution":"def largest_square(matrix): if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) max_side = 0 dp = [[0] * cols for _ in range(rows)] for i in range(rows): for j in range(cols): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"def max_length_of_substring_with_2_distinct_chars(s: str) -> int: Returns the maximum length of a substring that contains no more than 2 distinct characters. >>> max_length_of_substring_with_2_distinct_chars(\\"eceba\\") 3 >>> max_length_of_substring_with_2_distinct_chars(\\"aaaaa\\") 5 >>> max_length_of_substring_with_2_distinct_chars(\\"abcbbbbcccbdddadacb\\") 10 >>> max_length_of_substring_with_2_distinct_chars(\\"\\") 0 >>> max_length_of_substring_with_2_distinct_chars(\\"abac\\") 3 >>> max_length_of_substring_with_2_distinct_chars(\\"abcdef\\") 2 >>> max_length_of_substring_with_2_distinct_chars(\\"aaabbccdaaa\\") 5","solution":"def max_length_of_substring_with_2_distinct_chars(s): Returns the maximum length of a substring that contains no more than 2 distinct characters. if not s: return 0 left, right = 0, 0 max_len = 0 char_count = {} while right < len(s): if s[right] in char_count: char_count[s[right]] += 1 else: char_count[s[right]] = 1 while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"def find_disconnection_day(n: int, floors: List[List[List[int]]], actions: List[List[int]]) -> int: Returns the first day after which no employee can move from one occupied workstation to another on the same floor based on the given actions. :param n: Number of floors. :param floors: List of n 2D arrays where each element represents the workstations on each floor. :param actions: List of actions where each action is a tuple [f, r, c]. :return: The first day where no employee can move between any occupied workstation on any floor. >>> find_disconnection_day(1, [[[0, 0, 0], [0, 0, 0], [0, 0, 0]]], [[0, 1, 1], [0, 0, 0], [0, 2, 2]]) 2 >>> find_disconnection_day(2, [[[0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0]]], [[0, 0, 1], [0, 2, 1], [1, 0, 0], [1, 0, 2]]) 2 >>> find_disconnection_day(1, [[[0, 0, 0], [0, 0, 0], [0, 0, 0]]], [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 1, 1]]) 4 >>> find_disconnection_day(1, [[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]], [[0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 0, 3], [0, 1, 0]]) 5 # Implementation goes here","solution":"def find_disconnection_day(n, floors, actions): Returns the first day after which no employee can move from one occupied workstation to another on the same floor based on the given actions. :param n: Number of floors. :param floors: List of n 2D arrays where each element represents the workstations on each floor. :param actions: List of actions where each action is a tuple [f, r, c]. :return: The first day where no employee can move between any occupied workstation on any floor. def disjoint_set(rows, cols): parent = { (i, j): (i, j) for i in range(rows) for j in range(cols) } def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX return find, union, parent rows, cols = len(floors[0]), len(floors[0][0]) for day, (f, r, c) in enumerate(actions): floors[f][r][c] = 1 find, union, parent = disjoint_set(rows, cols) for i in range(rows): for j in range(cols): if floors[f][i][j] == 1: for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]: ni, nj = i + di, j + dj if 0 <= ni < rows and 0 <= nj < cols and floors[f][ni][nj] == 1: union((i, j), (ni, nj)) components = set(find((i, j)) for i in range(rows) for j in range(cols) if floors[f][i][j] == 1) if len(components) > 1: return day + 1 return len(actions)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSum(root): Given the root of a binary tree, return the maximum sum of values obtained by summing up all values from the nodes on a path from the root down to any leaf. A leaf is a node with no children. A path is any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path does not need to go through the root. >>> tree = TreeNode(10, TreeNode(5), TreeNode(12)) >>> maxPathSum(tree) 22 >>> tree = TreeNode(10) >>> maxPathSum(tree) 10 >>> tree = TreeNode(10, TreeNode(5, TreeNode(3))) >>> maxPathSum(tree) 18 >>> tree = TreeNode(10, None, TreeNode(15, None, TreeNode(20))) >>> maxPathSum(tree) 45 >>> tree = TreeNode(10, TreeNode(5, TreeNode(3), TreeNode(7)), TreeNode(12, None, TreeNode(14))) >>> maxPathSum(tree) 36","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxPathSum(root): Return the maximum sum of values obtained by summing up all values from the nodes on a path from the root down to any leaf. if root is None: return 0 left_sum = maxPathSum(root.left) right_sum = maxPathSum(root.right) return root.val + max(left_sum, right_sum)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root: TreeNode, target: int) -> List[List[int]]: Given a binary tree and an integer \`target\`, find all root-to-leaf paths where each path's sum equals the given \`target\`. >>> root = TreeNode(5) >>> path_sum(root, 5) [[5]] >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> path_sum(root, 5) [] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(4) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(6) >>> root.right.right = TreeNode(3) >>> sorted(path_sum(root, 8)) [[1, 2, 5], [1, 4, 3]] >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.right.right.left = TreeNode(5) >>> root.right.right.right = TreeNode(1) >>> sorted(path_sum(root, 22)) [[5, 4, 11, 2], [5, 8, 4, 5]] >>> root = None >>> path_sum(root, 0) []","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root, target): def dfs(node, current_path, current_sum): if not node: return current_path.append(node.val) current_sum += node.val if not node.left and not node.right and current_sum == target: paths.append(list(current_path)) dfs(node.left, current_path, current_sum) dfs(node.right, current_path, current_sum) current_path.pop() paths = [] dfs(root, [], 0) return paths"},{"question":"def single_number(nums: List[int]) -> int: Finds the single integer that appears only once in an array of integers where each integer appears exactly twice, except for one. >>> single_number([1]) == 1 >>> single_number([1, 1, 2]) == 2 >>> single_number([4, 1, 2, 1, 2]) == 4 >>> single_number([10] * 1000000 + [20]) == 20 >>> single_number([-1, -2, -1, -3, -2]) == -3 >>> single_number([-1, 2, -1, 3, 2]) == 3","solution":"def single_number(nums): Finds the single number in the list where every other number appears twice. :param nums: List of integers :return: The integer that appears only once unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"from typing import List def generate_combinations(n: int, k: int) -> List[List[int]]: Generates all possible combinations of k elements out of the set {1, 2, ..., n}. Parameters: n (int): The total number of distinct elements. k (int): The size of each combination. Returns: list: A list of lists containing all possible combinations. >>> generate_combinations(4, 2) [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]] >>> generate_combinations(3, 1) [[1], [2], [3]] >>> generate_combinations(4, 4) [[1, 2, 3, 4]] >>> generate_combinations(0, 0) [[]] >>> generate_combinations(3, 4) []","solution":"from itertools import combinations def generate_combinations(n, k): Generates all possible combinations of k elements out of the set {1, 2, ..., n}. Parameters: n (int): The total number of distinct elements. k (int): The size of each combination. Returns: list: A list of lists containing all possible combinations. return [list(comb) for comb in combinations(range(1, n + 1), k)]"},{"question":"def find_beautiful_permutation(arr: List[int]) -> List[int]: Given a sequence of integers \`arr\`, determine if there exists a 'beautiful' permutation of \`arr\`. A permutation is beautiful if each element is either greater than or less than its preceding element. If such a permutation exists, return any one. Otherwise, return an empty list. >>> find_beautiful_permutation([1]) [1] >>> find_beautiful_permutation([1, 2]) [1, 2] >>> find_beautiful_permutation([1, 2, 3]) [3, 1, 2] >>> find_beautiful_permutation([5, 3, 4, 2]) in ([[5, 2, 4, 3], [5, 2, 3, 4]]) >>> find_beautiful_permutation([1, 1, 1, 1]) [] >>> find_beautiful_permutation([10, 20, 30, 40, 50, 60]) [60, 10, 50, 20, 40, 30]","solution":"from typing import List def find_beautiful_permutation(arr: List[int]) -> List[int]: Function to find any beautiful permutation of arr if it exists. Returns the permutation if it exists, otherwise returns an empty list. if len(arr) <= 2: return list(sorted(arr)) if len(arr) <= 2 else [] arr.sort() n = len(arr) # Check if the maximum adjacent difference in the sorted array is not greater than 1 for i in range(1, n): if arr[i] - arr[i - 1] <= 0: return [] # If the above condition is passed then there exists a beautiful permutation result = [0] * n left, right = 0, n - 1 # Zigzag filling to ensure the alternating property for i in range(n): if i % 2 == 0: result[i] = arr[right] right -= 1 else: result[i] = arr[left] left += 1 return result"},{"question":"def maxSubArray(nums: List[int]) -> int: Finds the contiguous subarray within an array (containing at least one number) which has the largest sum and returns its sum. Uses Kadane's Algorithm to find the maximum sum subarray in O(n) time complexity. Examples: >>> maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6 >>> maxSubArray([-1, -2, -3, -4, -5]) == -1 >>> maxSubArray([1]) == 1 >>> maxSubArray([-1]) == -1 >>> maxSubArray([1, 2, 3, 4, 5]) == 15 >>> maxSubArray([1, -2, 3, 4, -1, 2, 1]) == 9 >>> maxSubArray([8, -19, 5, -4, 20]) == 21 pass","solution":"def maxSubArray(nums): Finds the contiguous subarray within an array (containing at least one number) which has the largest sum and returns its sum. Uses Kadane's Algorithm to find the maximum sum subarray in O(n) time complexity. max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def distribute_stars(arr): Distributes stars such that each student with a score greater than their adjacent students receives more stars than those adjacent students. Each student receives at least 1 star. >>> distribute_stars([3, 3, 3, 3, 3]) == 5 >>> distribute_stars([1, 2, 3, 4, 5]) == 15 >>> distribute_stars([5, 4, 3, 2, 1]) == 15 >>> distribute_stars([1, 2, 3, 2, 1]) == 9 >>> distribute_stars([3, 2, 1, 2, 3]) == 11 >>> distribute_stars([1, 0, 2, 1, 2, 1, 0]) == 12 >>> distribute_stars([5]) == 1 >>> distribute_stars([1, 2]) == 3 >>> distribute_stars([2, 1]) == 3","solution":"def distribute_stars(arr): Distributes stars such that each student with a score greater than their adjacent students receives more stars than those adjacent students. Each student receives at least 1 star. n = len(arr) if n == 0: return 0 # Initialize all students with one star stars = [1] * n # Traverse from left to right, and assign stars considering left neighbor for i in range(1, n): if arr[i] > arr[i - 1]: stars[i] = stars[i - 1] + 1 # Traverse from right to left, and assign stars considering right neighbor for i in range(n - 2, -1, -1): if arr[i] > arr[i + 1]: stars[i] = max(stars[i], stars[i + 1] + 1) # The total number of stars is the sum of stars array return sum(stars)"},{"question":"def min_adjacent_swaps(s1: str, s2: str) -> int: Returns the minimum number of adjacent swaps required to transform s1 into s2. If it is not possible, returns -1. >>> min_adjacent_swaps(\\"ab\\", \\"ba\\") == 1 >>> min_adjacent_swaps(\\"12345\\", \\"54321\\") == 10 >>> min_adjacent_swaps(\\"abcdef\\", \\"abcfed\\") == 3 >>> min_adjacent_swaps(\\"abc\\", \\"abc\\") == 0 >>> min_adjacent_swaps(\\"abc\\", \\"def\\") == -1 >>> min_adjacent_swaps(\\"abcd\\", \\"abdc\\") == 1 >>> min_adjacent_swaps(\\"ab\\", \\"cd\\") == -1","solution":"def min_adjacent_swaps(s1, s2): Returns the minimum number of adjacent swaps required to transform s1 into s2. If it is not possible, returns -1. if sorted(s1) != sorted(s2): return -1 swaps = 0 s1 = list(s1) for i in range(len(s2)): j = i while s1[j] != s2[i]: j += 1 while j > i: s1[j], s1[j-1] = s1[j-1], s1[j] swaps += 1 j -= 1 return swaps"},{"question":"def two_sum(nums, target): You are given an integer array \`nums\` and an integer \`target\`. Your task is to find two distinct integers \`nums[i]\` and \`nums[j]\` (where \`i != j\`) in the array that add up to \`target\`. Return an array containing the indices of the two numbers, \`i\` and \`j\`, in any order. If no such pair exists, return \`[-1, -1]\`. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([1, 2, 3, 4], 8) [-1, -1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([-1, -2, -3, -4, -5], -8) [2, 4] >>> two_sum([0, 1, 2, 0], 0) [0, 3] >>> two_sum([1000000, 2000000, 3000000, 1500000], 3500000) [1, 3] >>> two_sum([3, 3], 6) [0, 1]","solution":"def two_sum(nums, target): Given an array of integers nums and an integer target, returns the indices of the two numbers that add up to the target. Parameters: nums (List[int]): An array of integers. target (int): The target sum. Returns: List[int]: Indices of the two numbers such that they add up to target. If no such pair exists, returns [-1, -1]. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return [-1, -1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(root): Function to check if a binary tree is symmetric. >>> is_symmetric(None) == True >>> root = TreeNode(1) >>> is_symmetric(root) == True >>> root.left = TreeNode(2) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(4) >>> root.right.left = TreeNode(4) >>> root.right.right = TreeNode(3) >>> is_symmetric(root) == True >>> root.left.right = TreeNode(3) >>> root.right.right = TreeNode(3) >>> is_symmetric(root) == False >>> root.left.left.left = TreeNode(5) >>> root.right.right.right = TreeNode(5) >>> is_symmetric(root) == False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(root): Function to check if a binary tree is symmetric. if not root: return True def is_mirror(left, right): if not left and not right: return True if not left or not right: return False return (left.val == right.val) and is_mirror(left.right, right.left) and is_mirror(left.left, right.right) return is_mirror(root.left, root.right)"},{"question":"def largest_number_after_deletion(s: str, k: int) -> str: Given a string s containing digits from '0' to '9' and a number k, find the largest number that can be formed by deleting exactly k digits from s. >>> largest_number_after_deletion(\\"12345\\", 0) == \\"12345\\" >>> largest_number_after_deletion(\\"54321\\", 0) == \\"54321\\" >>> largest_number_after_deletion(\\"12345\\", 1) == \\"2345\\" >>> largest_number_after_deletion(\\"54321\\", 1) == \\"5432\\" >>> largest_number_after_deletion(\\"13245\\", 1) == \\"3245\\" >>> largest_number_after_deletion(\\"991211\\", 2) == \\"9921\\" >>> largest_number_after_deletion(\\"1092\\", 1) == \\"192\\" >>> largest_number_after_deletion(\\"123456\\", 2) == \\"3456\\" >>> largest_number_after_deletion(\\"7654321\\", 3) == \\"7654\\" >>> largest_number_after_deletion(\\"987654\\", 3) == \\"987\\" >>> largest_number_after_deletion(\\"10\\", 1) == \\"1\\" >>> largest_number_after_deletion(\\"100\\", 1) == \\"10\\" >>> largest_number_after_deletion(\\"10200\\", 1) == \\"1200\\"","solution":"def largest_number_after_deletion(s, k): Returns the largest number that can be formed by deleting exactly k digits from the string s containing digits. stack = [] for digit in s: while k > 0 and stack and stack[-1] < digit: stack.pop() k -= 1 stack.append(digit) return ''.join(stack[:len(stack) - k])"},{"question":"def two_sum(nums, target): Returns indices of the two numbers in the list such that they add up to the target. If no such numbers exist, returns [-1, -1]. >>> two_sum([2, 7, 11, 15], 9) == [0, 1] >>> two_sum([2, 7, 11, 15], 20) == [-1, -1] >>> two_sum([3, 2, 4], 6) == [1, 2] >>> two_sum([-1, -2, -3, -4, -5], -8) == [2, 4] >>> two_sum([0, 4, 3, 0], 0) == [0, 3] >>> two_sum([], 0) == [-1, -1] >>> two_sum([1], 2) == [-1, -1] >>> two_sum([1, 5], 10) == [-1, -1] >>> two_sum([3, 3], 6) == [0, 1]","solution":"def two_sum(nums, target): Returns indices of the two numbers in the list such that they add up to the target. If no such numbers exist, returns [-1, -1]. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return [-1, -1]"},{"question":"from typing import List def min_swaps_to_connect_ones(mat: List[List[int]]) -> int: Returns the minimum number of swaps needed to transform the matrix such that all 1s are adjacent to each other forming a single connected component. If it's impossible to form such a connected component, returns -1. >>> min_swaps_to_connect_ones([[0, 0], [0, 0]]) == -1 >>> min_swaps_to_connect_ones([[1, 1], [1, 1]]) == 0 >>> min_swaps_to_connect_ones([[1, 0], [1, 1]]) == 0 >>> min_swaps_to_connect_ones([[1, 0], [0, 1]]) == -1 >>> min_swaps_to_connect_ones([[1, 0, 0], [0, 1, 1], [0, 0, 1]]) == -1 >>> min_swaps_to_connect_ones([[1, 0, 1], [0, 0, 0], [1, 0, 1]]) == -1 pass","solution":"from collections import deque def min_swaps_to_connect_ones(mat): rows, cols = len(mat), len(mat[0]) def bfs_count_cells_and_is_connected(start_i, start_j): queue = deque([(start_i, start_j)]) visited = set([(start_i, start_j)]) component = [(start_i, start_j)] while queue: i, j = queue.popleft() for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_i, new_j = i + di, j + dj if 0 <= new_i < rows and 0 <= new_j < cols and (new_i, new_j) not in visited: if mat[new_i][new_j] == 1: queue.append((new_i, new_j)) visited.add((new_i, new_j)) component.append((new_i, new_j)) return len(component) == num_ones, component def manhattan_distance(pos1, pos2): return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1]) # Find all positions of 1s one_positions = [(i, j) for i in range(rows) for j in range(cols) if mat[i][j] == 1] num_ones = len(one_positions) if num_ones == 0: return -1 # No swaps needed as there are no 1s at all start_i, start_j = one_positions[0] is_connected, component = bfs_count_cells_and_is_connected(start_i, start_j) if is_connected: return 0 # To form one connected component, the minimum swaps needed can be large. # This problem is non-trivial and requires advanced techniques like Minimum Cost Max Flow or similar methods, # and might be out of the scope for direct implementation in this short format. return -1 # Placeholder for the minimal swaps calculation implementation."},{"question":"def kth_smallest(arr: List[int], k: int) -> int: Find the k-th smallest element in an unsorted array using the Quickselect method. >>> kth_smallest([3, 2, 1, 5, 4], 1) 1 >>> kth_smallest([9, 3, 7, 6, 2, 8, 1, 4, 5], 5) 5 >>> kth_smallest([10, 4, 5, 8, 6, 11, 26], 7) 26 >>> kth_smallest([20, 10, 30, 50, 40], 2) 20 >>> kth_smallest([6, 3, 1, 8, 4], 5) 8","solution":"def kth_smallest(arr, k): Returns the k-th smallest element in the unsorted array using Quickselect method. def partition(left, right, pivot_index): pivot_value = arr[pivot_index] # Move pivot to end arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left # Move all smaller elements to the left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 # Move pivot to its final place arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def quickselect(left, right, k_smallest): Returns the k-th smallest element of list within left..right. if left == right: return arr[left] pivot_index = left + (right - left) // 2 pivot_index = partition(left, right, pivot_index) # The pivot is in its final sorted position if k_smallest == pivot_index: return arr[k_smallest] elif k_smallest < pivot_index: return quickselect(left, pivot_index - 1, k_smallest) else: return quickselect(pivot_index + 1, right, k_smallest) return quickselect(0, len(arr) - 1, k - 1)"},{"question":"def coin_combinations(arr, target): Return the number of distinct combinations to sum up to the target using coins in the given array. :param arr: List[int] - List of available coin denominations :param target: int - Target sum :return: int - Number of distinct combinations to reach the target >>> coin_combinations([1, 2, 3], 4) 4 >>> coin_combinations([1, 2, 3], 0) 1 >>> coin_combinations([2], 3) 0 >>> coin_combinations([1, 2, 5], 5) 4 >>> coin_combinations([1, 2], 3) 2 >>> coin_combinations([], 10) 0 >>> coin_combinations([1, 2, 5], 11) 11 >>> coin_combinations([2, 3], 1) 0","solution":"def coin_combinations(arr, target): Return the number of distinct combinations to sum up to the target using coins in the given array. :param arr: List[int] - List of available coin denominations :param target: int - Target sum :return: int - Number of distinct combinations to reach the target # Initialize a list to store the number of ways to make each amount dp = [0] * (target + 1) dp[0] = 1 # There is one way to make 0, which is to use no coins # Iterate over each coin for coin in arr: # Update the combinations count for each possible sub-target for amount in range(coin, target + 1): dp[amount] += dp[amount - coin] return dp[target]"},{"question":"def largest_number_after_removal(s: str) -> str: Given a string \`s\` that consists of only digits, you can remove at most one digit from the string so that the resulting string is the largest possible number. Return the largest possible number you can obtain by removing one digit from \`s\`. >>> largest_number_after_removal(\\"123\\") == \\"23\\" >>> largest_number_after_removal(\\"231\\") == \\"31\\" >>> largest_number_after_removal(\\"312\\") == \\"32\\" >>> largest_number_after_removal(\\"0\\") == \\"\\" >>> largest_number_after_removal(\\"9\\") == \\"\\" >>> largest_number_after_removal(\\"10\\") == \\"1\\" >>> largest_number_after_removal(\\"20\\") == \\"2\\" >>> largest_number_after_removal(\\"210\\") == \\"21\\" >>> largest_number_after_removal(\\"101010\\") == \\"11010\\" >>> largest_number_after_removal(\\"1234567890\\") == \\"234567890\\" >>> largest_number_after_removal(\\"9876543210\\") == \\"987654321\\" >>> largest_number_after_removal(\\"222\\") == \\"22\\" >>> largest_number_after_removal(\\"10001\\") == \\"1001\\" >>> largest_number_after_removal(\\"76543210\\") == \\"7654321\\"","solution":"def largest_number_after_removal(s: str) -> str: This function takes a string s consisting of only digits and removes at most one digit to form the largest possible number. It returns the resulting largest possible number as a string. max_number = \\"\\" for i in range(len(s)): # Create a new number by skipping the digit at index i new_number = s[:i] + s[i+1:] # Compare to find the maximum number if new_number > max_number: max_number = new_number return max_number"},{"question":"def can_open_all_doors(keys: List[List[int]], doors: List[int]) -> bool: Determine if it's possible to open all doors using the given keys. :param keys: List[List[int]] - a list where each element is a list of doors that a specific key can open :param doors: List[int] - a list of doors that need to be opened :return: bool - True if all doors can be opened, False otherwise >>> can_open_all_doors([[1, 2], [2, 3], [5]], [1, 3, 5]) True >>> can_open_all_doors([[1, 2], [2, 3]], [1, 3, 5]) False >>> can_open_all_doors([[1, 2], [2, 3], [5]], []) True >>> can_open_all_doors([], [1, 3, 5]) False >>> can_open_all_doors([[1, 2, 3, 4, 5]], [1, 3, 5]) True >>> can_open_all_doors([[1, 2], [1, 2], [1, 2, 3, 5], [4, 5]], [1, 4, 5]) True","solution":"def can_open_all_doors(keys, doors): Determine if it's possible to open all doors using the given keys. :param keys: List[List[int]] - a list where each element is a list of doors that a specific key can open :param doors: List[int] - a list of doors that need to be opened :return: bool - True if all doors can be opened, False otherwise # Create a set to store all unique doors that can be opened by the given keys openable_doors = set() # Add each door from the key's list to the openable_doors set for key in keys: openable_doors.update(key) # Check if all doors that need to be opened are in the openable_doors set for door in doors: if door not in openable_doors: return False return True"},{"question":"def min_insertions_for_word_break(s: str, words_dict: List[str]) -> int: Given a string s and a set of valid words words_dict, find the minimum number of insertions needed to make s a valid sequence of words from words_dict. >>> min_insertions_for_word_break(\\"leetcode\\", [\\"leet\\", \\"code\\"]) 0 >>> min_insertions_for_word_break(\\"leetcod\\", [\\"leet\\", \\"code\\"]) 1 >>> min_insertions_for_word_break(\\"applepie\\", [\\"apple\\", \\"pie\\"]) 0 >>> min_insertions_for_word_break(\\"applpie\\", [\\"apple\\", \\"pie\\"]) 1 >>> min_insertions_for_word_break(\\"abcdefg\\", [\\"hij\\", \\"klm\\"]) inf >>> min_insertions_for_word_break(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) 0","solution":"def min_insertions_for_word_break(s, words_dict): Returns the minimum number of insertions required to make 's' a valid sequence of words from 'words_dict'. word_set = set(words_dict) n = len(s) # Create a dp array to store the minimum insertions for each prefix of s dp = [float('inf')] * (n + 1) dp[0] = 0 # No insertions needed for an empty prefix for i in range(1, n + 1): for j in range(i): segment = s[j:i] if segment in word_set: dp[i] = min(dp[i], dp[j]) else: for k in range(i - j + 1): for c in 'abcdefghijklmnopqrstuvwxyz': new_segment = segment[:k] + c + segment[k:] if new_segment in word_set: dp[i] = min(dp[i], dp[j] + 1) return dp[n]"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def deleteDuplicates(head: ListNode) -> ListNode: Removes duplicates from a sorted linked list and returns the head of the updated list. >>> list_to_linkedlist = lambda lst: ListNode(lst[0], list_to_linkedlist(lst[1:])) if lst else None >>> linkedlist_to_list = lambda head: [head.val] + linkedlist_to_list(head.next) if head else [] >>> linkedlist_to_list(deleteDuplicates(list_to_linkedlist([1, 2, 3]))) == [1, 2, 3] True >>> linkedlist_to_list(deleteDuplicates(list_to_linkedlist([1, 1, 1]))) == [1] True >>> linkedlist_to_list(deleteDuplicates(list_to_linkedlist([1, 1, 2, 3, 3]))) == [1, 2, 3] True >>> linkedlist_to_list(deleteDuplicates(list_to_linkedlist([]))) == [] True >>> linkedlist_to_list(deleteDuplicates(list_to_linkedlist([1]))) == [1] True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def deleteDuplicates(head): Removes duplicates from a sorted linked list and returns the head of the updated list. if not head: return head current = head while current and current.next: if current.val == current.next.val: current.next = current.next.next else: current = current.next return head"},{"question":"def reverse_pairs(nums: List[int]) -> int: Returns the number of reverse pairs in the given array. A reverse pair is a pair (i, j) where 0 <= i < j < nums.length and nums[i] > 2 * nums[j]. >>> reverse_pairs([1, 3, 2, 3, 1]) 2 >>> reverse_pairs([2, 4, 3, 5, 1]) 3 >>> reverse_pairs([1, 2, 3, 4, 5]) 0 >>> reverse_pairs([5, 4, 3, 2, 1]) 4 >>> reverse_pairs([1]) 0 >>> reverse_pairs([]) 0","solution":"def reverse_pairs(nums): Returns the number of reverse pairs in the given array. A reverse pair is a pair (i, j) where 0 <= i < j < nums.length and nums[i] > 2 * nums[j]. if not nums: return 0 def merge_sort_and_count(arr, left, right): if left >= right: return 0 mid = (left + right) // 2 count = merge_sort_and_count(arr, left, mid) + merge_sort_and_count(arr, mid + 1, right) # Count reverse pairs j = mid + 1 for i in range(left, mid + 1): while j <= right and arr[i] > 2 * arr[j]: j += 1 count += j - (mid + 1) # Merge the two halves temp = [] l, r = left, mid + 1 while l <= mid and r <= right: if arr[l] <= arr[r]: temp.append(arr[l]) l += 1 else: temp.append(arr[r]) r += 1 while l <= mid: temp.append(arr[l]) l += 1 while r <= right: temp.append(arr[r]) r += 1 for i in range(left, right + 1): arr[i] = temp[i - left] return count return merge_sort_and_count(nums, 0, len(nums) - 1)"},{"question":"from typing import List def has_subarray_with_target_sum(nums: List[int], targetSum: int) -> bool: Determines if there exists a continuous subarray within nums that sums up to targetSum. >>> has_subarray_with_target_sum([1, 2, 3, 7, 5], 12) True >>> has_subarray_with_target_sum([1, 2, 3, 4, 5], 20) False >>> has_subarray_with_target_sum([5], 5) True >>> has_subarray_with_target_sum([5], 10) False >>> has_subarray_with_target_sum([-1, -2, 3, 4], 1) True >>> has_subarray_with_target_sum([-1, 1, 0], 0) True >>> has_subarray_with_target_sum([], 0) False >>> has_subarray_with_target_sum([1, 2, 3, 4, 5], 15) True","solution":"def has_subarray_with_target_sum(nums, targetSum): Determines if there exists a continuous subarray within nums that sums up to targetSum. Args: nums: List of integers. targetSum: An integer representing the target subarray sum. Returns: bool: True if such a subarray exists, otherwise False. current_sum = 0 sum_indices_map = {} for i, num in enumerate(nums): current_sum += num if current_sum == targetSum: return True if (current_sum - targetSum) in sum_indices_map: return True sum_indices_map[current_sum] = i return False"},{"question":"def numDistinctIslands(grid): Determine the number of distinct islands in the grid. >>> numDistinctIslands([ [0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 >>> numDistinctIslands([ [0, 1, 0], [1, 1, 0], [0, 0, 0]]) == 1 >>> numDistinctIslands([ [1, 0, 0], [0, 1, 1], [0, 0, 1]]) == 2 >>> numDistinctIslands([ [1, 0, 1], [0, 1, 0], [1, 0, 1]]) == 1 >>> numDistinctIslands([ [1, 1, 0, 0], [1, 0, 0, 1], [0, 0, 1, 1], [1, 1, 0, 1]]) == 3","solution":"def numDistinctIslands(grid): Returns the number of distinct islands in the grid. if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = set() def dfs(r, c, direction): if ( r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0 or (r, c) in visited): return \\"\\" visited.add((r, c)) shape = direction shape += dfs(r + 1, c, \\"D\\") # Down shape += dfs(r - 1, c, \\"U\\") # Up shape += dfs(r, c + 1, \\"R\\") # Right shape += dfs(r, c - 1, \\"L\\") # Left shape += \\"B\\" # Backtrack return shape shapes = set() for r in range(rows): for c in range(cols): if grid[r][c] == 1 and (r, c) not in visited: shape = dfs(r, c, \\"O\\") # Origin shapes.add(shape) return len(shapes)"},{"question":"from typing import List def min_dishes(calories: List[int], T: int) -> int: Given an array of integers \`calories\` where each element represents the calorie count of a dish, return the minimum number of dishes needed to achieve exactly \`T\` calories. If it is not possible to achieve exactly \`T\` calories with any combination of dishes, return \`-1\`. >>> min_dishes([100, 200, 150], 350) == 2 >>> min_dishes([100, 200, 150], 300) == 2 >>> min_dishes([100, 200, 150], 400) == -1 >>> min_dishes([100, 200, 150], 200) == 1 >>> min_dishes([100, 50, 75, 200], 300) == 2 >>> min_dishes([50, 150, 250], 300) == 2 >>> min_dishes([100, 200, 150], 0) == 0 >>> min_dishes([100, 100, 100, 100], 200) == 2","solution":"def min_dishes(calories, T): Given an array of integers \`calories\` and a target calorie count \`T\`, return the minimum number of dishes needed to achieve exactly \`T\` calories. If it is not possible, return -1. dp = [float('inf')] * (T + 1) dp[0] = 0 for calorie in calories: for i in range(T, calorie - 1, -1): if dp[i - calorie] != float('inf'): dp[i] = min(dp[i], dp[i - calorie] + 1) return dp[T] if dp[T] != float('inf') else -1"},{"question":"def min_operations_to_make_all_elements_equal(arr: List[int], k: int) -> int: Returns the minimum number of operations required to make all elements of the array equal to k. If not possible, returns -1. >>> min_operations_to_make_all_elements_equal([2, 2, 2], 2) == 0 >>> min_operations_to_make_all_elements_equal([1, 2, 3], 2) == 2 >>> min_operations_to_make_all_elements_equal([-1, -2, -3], -2) == 2 >>> min_operations_to_make_all_elements_equal([1, 0, -1], 0) == 2 >>> min_operations_to_make_all_elements_equal([2, 'a', 3], 2) == -1 >>> min_operations_to_make_all_elements_equal([1000] * 1000, 1000) == 0 >>> min_operations_to_make_all_elements_equal([5], 5) == 0 >>> min_operations_to_make_all_elements_equal([5], 10) == 5","solution":"def min_operations_to_make_all_elements_equal(arr, k): Returns the minimum number of operations required to make all elements of the array equal to k. If not possible, returns -1. if not all(isinstance(i, int) for i in arr): return -1 operations = 0 for num in arr: operations += abs(num - k) return operations"},{"question":"def three_sum(arr: List[int], target: int) -> bool: Determines if there are three distinct elements in arr that add up to the target. Parameters: arr (list): List of positive integers. target (int): The target sum. Returns: bool: True if there exist three distinct elements that add up to the target, False otherwise. >>> three_sum([1, 2, 3, 4, 5], 9) True >>> three_sum([1, 2, 3, 4, 5], 50) False >>> three_sum([10, 20, 30, 40, 50], 100) True >>> three_sum([1, 2, 4, 8, 16], 32) False >>> three_sum([1, 1, 1, 2], 3) True >>> three_sum([1, 1, 1, 1, 2, 2, 2, 3], 6) True >>> three_sum([1, 4, 4, 4, 5, 6, 7], 15) True","solution":"def three_sum(arr, target): Determines if there are three distinct elements in arr that add up to the target. Parameters: arr (list): List of positive integers. target (int): The target sum. Returns: bool: True if there exist three distinct elements that add up to the target, False otherwise. arr.sort() n = len(arr) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"from typing import List def days_needed(times: List[int]) -> int: Determines the minimum number of school days required for all students to complete their projects, given that only one student can work on his or her project at any given time. School hours are from 9 AM to 3 PM, which equals 6 hours each day. >>> days_needed([]) == 0 >>> days_needed([2]) == 1 >>> days_needed([6]) == 1 >>> days_needed([14]) == 3 >>> days_needed([2, 3, 1]) == 1 >>> days_needed([4, 8, 2]) == 3 >>> days_needed([6, 6, 6]) == 3 >>> days_needed([5, 8, 7, 10, 2, 14, 20]) == 11","solution":"from typing import List def days_needed(times: List[int]) -> int: Returns the minimum number of school days required for all students to complete their projects. if not times: return 0 total_hours = sum(times) hours_per_day = 6 days = (total_hours + hours_per_day - 1) // hours_per_day # Calculate the ceiling of total hours divided by hours per day return days"},{"question":"def minutes_from_midnight(time: str) -> int: Given a string \`time\` representing a time in 24-hour HH:MM format, return the number of minutes that have elapsed from 00:00 (midnight). >>> minutes_from_midnight(\\"00:00\\") == 0 >>> minutes_from_midnight(\\"00:01\\") == 1 >>> minutes_from_midnight(\\"01:00\\") == 60 >>> minutes_from_midnight(\\"12:00\\") == 720 >>> minutes_from_midnight(\\"14:30\\") == 870 >>> minutes_from_midnight(\\"23:59\\") == 1439 >>> minutes_from_midnight(\\"06:45\\") == 405 >>> minutes_from_midnight(\\"18:25\\") == 1105","solution":"def minutes_from_midnight(time): Given a string \`time\` representing a time in 24-hour HH:MM format, returns the number of minutes that have elapsed from 00:00 (midnight). Parameters: time (str): A time in HH:MM format. Returns: int: The number of minutes elapsed from midnight. hours, minutes = map(int, time.split(':')) return hours * 60 + minutes"},{"question":"def rotate_array(nums, k): Rotates the array to the right by k steps. Parameters: nums (list): The list of integers to rotate. k (int): The number of steps to rotate the array to the right. Returns: list: The rotated list. >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_array([], 3) [] >>> rotate_array([1], 1) [1] >>> rotate_array([1], 2) [1] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] # Your code here","solution":"def rotate_array(nums, k): Rotates the array to the right by k steps. Parameters: nums (list): The list of integers to rotate. k (int): The number of steps to rotate the array to the right. Returns: list: The rotated list. n = len(nums) if n == 0: return [] k = k % n # Normalize k if it is greater than the length of the array return nums[-k:] + nums[:-k]"},{"question":"def longest_palindrome_length(s: str) -> int: Returns the length of the longest palindrome that can be obtained by removing at most one character from the string s. >>> longest_palindrome_length(\\"abba\\") 4 >>> longest_palindrome_length(\\"racecar\\") 7 >>> longest_palindrome_length(\\"abac\\") 3 >>> longest_palindrome_length(\\"bananas\\") 5 >>> longest_palindrome_length(\\"abc\\") 1 >>> longest_palindrome_length(\\"aaaaaaa\\") 7 >>> longest_palindrome_length(\\"abcdcbae\\") 7","solution":"def longest_palindrome_length(s): Returns the length of the longest palindrome that can be obtained by removing at most one character from the string s. def is_palindrome(sub): return sub == sub[::-1] if is_palindrome(s): # The original string is already a palindrome return len(s) n = len(s) for i in range(n): if is_palindrome(s[:i] + s[i+1:]): return n - 1 return n - 2 # In the worst case, removing one character doesn't help much # Example test case # s = \\"abac\\", removes 'b' or 'c' to get \\"aba\\" # longest_palindrome_length(\\"abac\\") should return 3"},{"question":"def two_sum_pairs(nums: List[int], target: int) -> List[List[int]]: Given a list of integers \`nums\` and an integer \`target\`, return all unique pairs of integers from the list that add up to the \`target\`. Each pair should be returned as a list with two elements. The solution set must not contain duplicate pairs, and the order of the pairs does not matter. If no such pairs exist, return an empty list. >>> sorted(two_sum_pairs([1, 2, 3, 4, 3], 6)) == sorted([[2, 4], [3, 3]]) True >>> two_sum_pairs([1, 2, 3], 7) == [] True >>> sorted(two_sum_pairs([-1, -2, -3, 3], 0)) == sorted([[-3, 3]]) True >>> sorted(two_sum_pairs([1, 1, 2, 2], 3)) == sorted([[1, 2]]) True >>> sorted(two_sum_pairs([0, 0, 1, -1], 0)) == sorted([[0, 0], [-1, 1]]) True","solution":"def two_sum_pairs(nums, target): Returns all unique pairs of integers that add up to the target. seen = set() output = set() for num in nums: complement = target - num if complement in seen: output.add(tuple(sorted((num, complement)))) seen.add(num) return [list(pair) for pair in output]"},{"question":"from collections import defaultdict import bisect class TimeMap: A class to store key-value pairs with a timestamp and retrieve values based on timestamps. Methods: - set(key: str, value: str, timestamp: int) -> None: Store the key with the value at the given timestamp. - get(key: str, timestamp: int) -> str: Returns the value associated with the key at the largest possible time <= timestamp. If no such value exists, returns an empty string. def __init__(self): self.store = defaultdict(list) def set(self, key, value, timestamp): Stores the key with the value at the given timestamp. pass def get(self, key, timestamp): Returns the value associated with the key at the largest possible time <= timestamp. If no such value exists, returns an empty string. pass # Unit Test def test_set_and_get(): tm = TimeMap() tm.set(\\"foo\\", \\"bar\\", 1) assert tm.get(\\"foo\\", 1) == \\"bar\\" assert tm.get(\\"foo\\", 2) == \\"bar\\" tm.set(\\"foo\\", \\"bar2\\", 2) assert tm.get(\\"foo\\", 1) == \\"bar\\" assert tm.get(\\"foo\\", 2) == \\"bar2\\" assert tm.get(\\"foo\\", 3) == \\"bar2\\" def test_get_non_existent_key(): tm = TimeMap() assert tm.get(\\"baz\\", 1) == \\"\\" def test_get_before_timestamp(): tm = TimeMap() tm.set(\\"key1\\", \\"value1\\", 5) assert tm.get(\\"key1\\", 4) == \\"\\" assert tm.get(\\"key1\\", 5) == \\"value1\\" assert tm.get(\\"key1\\", 10) == \\"value1\\" def test_overlapping_timestaps(): tm = TimeMap() tm.set(\\"foo\\", \\"bar1\\", 1) tm.set(\\"foo\\", \\"bar2\\", 1) assert tm.get(\\"foo\\", 1) == \\"bar2\\" def test_multikeys(): tm = TimeMap() tm.set(\\"foo\\", \\"bar1\\", 1) tm.set(\\"baz\\", \\"qux\\", 2) assert tm.get(\\"foo\\", 1) == \\"bar1\\" assert tm.get(\\"foo\\", 2) == \\"bar1\\" assert tm.get(\\"baz\\", 1) == \\"\\" assert tm.get(\\"baz\\", 2) == \\"qux\\"","solution":"from collections import defaultdict import bisect class TimeMap: def __init__(self): self.store = defaultdict(list) def set(self, key, value, timestamp): Stores the key with the value at the given timestamp. self.store[key].append((timestamp, value)) def get(self, key, timestamp): Returns the value associated with the key at the largest possible time <= timestamp. If no such value exists, returns an empty string. if key not in self.store: return \\"\\" values = self.store[key] idx = bisect.bisect_right(values, (timestamp, chr(255))) if idx == 0: return \\"\\" else: return values[idx-1][1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Returns the values of the nodes visible from the right side of the binary tree. # Unit tests def test_empty_tree(): assert right_side_view(None) == [] def test_single_node_tree(): tree = TreeNode(1) assert right_side_view(tree) == [1] def test_three_level_tree(): tree = TreeNode(1, TreeNode(2, None, TreeNode(5)), TreeNode(3, None, TreeNode(4))) assert right_side_view(tree) == [1, 3, 4] def test_unbalanced_tree(): tree = TreeNode(1, TreeNode(2, TreeNode(4, TreeNode(7), None), TreeNode(5)), TreeNode(3)) assert right_side_view(tree) == [1, 3, 5, 7] def test_full_tree(): tree = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) assert right_side_view(tree) == [1, 3, 7]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Returns the values of the nodes visible from the right side of the binary tree. if not root: return [] result = [] queue = [(root, 0)] rightmost_value_at_depth = dict() max_depth = -1 while queue: node, depth = queue.pop(0) if node: max_depth = max(max_depth, depth) rightmost_value_at_depth[depth] = node.val queue.append((node.left, depth + 1)) queue.append((node.right, depth + 1)) return [rightmost_value_at_depth[depth] for depth in range(max_depth + 1)]"},{"question":"def numDistinctIslands(grid: List[List[int]]) -> int: Given a 2D grid of integers representing a map where \`0\` represents water and \`1\` represents land, determine the total number of distinct islands. An island is defined as a group of connected \`1\`s (land) and it's connected horizontally or vertically. Consider two islands distinct if and only if one island is not a part of another. >>> numDistinctIslands([ [1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ]) 1 >>> numDistinctIslands([ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ]) 0 >>> numDistinctIslands([ [1, 1, 0, 1], [1, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0] ]) 3 >>> numDistinctIslands([ [1, 1, 0, 1, 1], [1, 0, 0, 1, 0], [0, 0, 0, 1, 1] ]) 2 >>> numDistinctIslands([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) 1","solution":"def numDistinctIslands(grid): Returns the number of distinct islands in a 2D grid. def dfs(r, c, di, island): if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c] == 1: island.add((r - di[0], c - di[1])) grid[r][c] = 0 # mark as visited dfs(r + 1, c, di, island) dfs(r - 1, c, di, island) dfs(r, c + 1, di, island) dfs(r, c - 1, di, island) distinct_islands = set() for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == 1: island = set() dfs(r, c, (r, c), island) if island: distinct_islands.add(frozenset(island)) return len(distinct_islands)"},{"question":"from typing import List def is_one_char_different(word1: str, word2: str) -> bool: Helper function to determine if two words differ by exactly one character. pass def minTransformations(wordList: List[str], targetWord: str) -> int: Returns the minimum number of transformations needed to convert targetWord into any word in wordList that is closest to the last word in the wordList. If no such transformation is possible, returns -1. pass import pytest def test_no_possible_transformation(): wordList = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] targetWord = \\"hit\\" assert minTransformations(wordList, targetWord) == -1 def test_single_transformation(): wordList = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] targetWord = \\"hot\\" assert minTransformations(wordList, targetWord) == 1 def test_multiple_transformations(): wordList = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] targetWord = \\"lot\\" assert minTransformations(wordList, targetWord) == 1 def test_direct_transformation(): wordList = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] targetWord = \\"dog\\" assert minTransformations(wordList, targetWord) == 1 def test_closest_to_last_word(): wordList = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"hotdog\\"] targetWord = \\"hit\\" assert minTransformations(wordList, targetWord) == -1 def test_large_list(): wordList = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] targetWord = \\"hit\\" assert minTransformations(wordList, targetWord) == -1","solution":"from collections import deque def is_one_char_different(word1, word2): Helper function to determine if two words differ by exactly one character. if len(word1) != len(word2): return False diff_count = sum(1 for a, b in zip(word1, word2) if a != b) return diff_count == 1 def minTransformations(wordList, targetWord): Returns the minimum number of transformations needed to convert targetWord into any word in wordList that is closest to the last word in the wordList. If no such transformation is possible, returns -1. wordList = set(wordList) # Convert to set for O(1) lookups if targetWord not in wordList: # If target word isn't in the list, no transformation is possible return -1 # Breadth-First Search (BFS) to find the minimum transformation steps queue = deque([(targetWord, 0)]) visited = set(targetWord) while queue: current_word, steps = queue.popleft() for word in wordList: if word not in visited and is_one_char_different(current_word, word): if word in wordList: return steps + 1 # Target word found visited.add(word) queue.append((word, steps + 1)) return -1 # Example usage: # wordList = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] # targetWord = \\"hit\\" # print(minTransformations(wordList, targetWord)) # Output should be 4 in the ideal case"},{"question":"from typing import List def longest_valid_segment(arr: List[int]) -> int: Returns the length of the longest valid segment in the permutation array \`arr\`. >>> longest_valid_segment([1]) == 1 >>> longest_valid_segment([1, 2, 3, 4]) == 4 >>> longest_valid_segment([3, 1, 4, 2]) == 1 >>> longest_valid_segment([1, 2, 3, 7, 8, 4, 5, 6]) == 3 >>> longest_valid_segment([1, 2, 3, 4, 7, 8, 9]) == 4 >>> longest_valid_segment([5, 6, 1, 2, 3]) == 3 >>> longest_valid_segment([10, 20, 30, 1, 2, 3, 4]) == 4 pass","solution":"def longest_valid_segment(arr): Returns the length of the longest valid segment in the permutation array \`arr\`. n = len(arr) max_len = 1 current_len = 1 for i in range(1, n): if arr[i] - arr[i - 1] == 1: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 max_len = max(max_len, current_len) return max_len"},{"question":"def count_blocking_view(heights: List[int]) -> List[int]: Return an array where each element is the count of people blocking the view of the corresponding person in the queue. >>> count_blocking_view([3, 2, 1]) [0, 1, 2] >>> count_blocking_view([5, 5, 5]) [0, 0, 0] >>> count_blocking_view([1, 2, 3]) [0, 0, 0] >>> count_blocking_view([4, 3, 2, 1]) [0, 1, 2, 3] >>> count_blocking_view([5, 1, 4, 2, 3]) [0, 1, 1, 2, 2] >>> count_blocking_view([1]) [0] >>> count_blocking_view([1, 2]) [0, 0] >>> count_blocking_view([2, 1]) [0, 1]","solution":"def count_blocking_view(heights): n = len(heights) view_count = [0] * n for i in range(1, n): count = 0 j = i - 1 while j >= 0: if heights[j] > heights[i]: count += 1 j -= 1 view_count[i] = count return view_count"},{"question":"import heapq from typing import List def kth_smallest(matrix: List[List[int]], k: int) -> int: Finds the kth smallest element in a sorted matrix. >>> kth_smallest([[1, 5, 9], [10, 11, 13], [12, 13, 15]], 1) 1 >>> kth_smallest([[1, 5, 9], [10, 11, 13], [12, 13, 15]], 9) 15 >>> kth_smallest([[2, 4], [6, 8]], 3) 6","solution":"import heapq def kth_smallest(matrix, k): Finds the kth smallest element in a sorted matrix. :param matrix: List[List[int]], a 2D list representing the matrix :param k: int, the position of the smallest element to find :return: int, the kth smallest element in the matrix n = len(matrix) min_heap = [] # Initialize min heap with the first element of each row. for r in range(min(k, n)): # Only need to consider at most k rows. heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract-min k-1 times to get to the kth smallest element. for i in range(k - 1): element, r, c = heapq.heappop(min_heap) if c + 1 < len(matrix[0]): heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return heapq.heappop(min_heap)[0]"},{"question":"def count_distinct_substrings(s: str) -> int: Given a string \`s\` consisting of lowercase English letters, return the total number of distinct substrings that can be formed from the string. >>> count_distinct_substrings(\\"a\\") 1 >>> count_distinct_substrings(\\"ab\\") 3 >>> count_distinct_substrings(\\"aa\\") 2 >>> count_distinct_substrings(\\"abc\\") 6 >>> count_distinct_substrings(\\"abab\\") 7 >>> count_distinct_substrings(\\"\\") 0","solution":"def count_distinct_substrings(s): Returns the number of distinct substrings of the given string s. substrings = set() for i in range(len(s)): for j in range(i+1, len(s)+1): substrings.add(s[i:j]) return len(substrings)"},{"question":"from collections import Counter def unique_character_sets(words: List[str]) -> List[Dict[str, int]]: Given an array of strings 'words', return an array of all the unique character sets that can be used to form all the words in the array in terms of dictionaries with character frequencies. >>> unique_character_sets([\\"apple\\"]) [{'a': 1, 'p': 2, 'l': 1, 'e': 1}] >>> unique_character_sets([\\"apple\\", \\"banana\\", \\"cherry\\"]) [{'a': 1, 'p': 2, 'l': 1, 'e': 1}, {'b': 1, 'a': 3, 'n': 2}, {'c': 1, 'h': 1, 'e': 1, 'r': 2, 'y': 1}] >>> unique_character_sets([]) [] >>> unique_character_sets([\\"a\\", \\"b\\", \\"c\\"]) [{'a': 1}, {'b': 1}, {'c': 1}] >>> unique_character_sets([\\"aa\\", \\"bb\\", \\"cc\\"]) [{'a': 2}, {'b': 2}, {'c': 2}]","solution":"from collections import Counter def unique_character_sets(words): Given an array of strings 'words', returns an array of all the unique character sets that can be used to form all the words in the array in terms of dictionaries with character frequencies. return [Counter(word) for word in words]"},{"question":"def can_robot_reach_goal(warehouse: List[List[int]]) -> bool: Determine if the robot can reach the bottom-right corner of the grid. :param warehouse: List[List[int]], a 2D grid representing the warehouse :return: bool, True if the robot can reach the goal, False otherwise >>> can_robot_reach_goal([[0]]) True >>> can_robot_reach_goal([[1]]) False >>> can_robot_reach_goal([ ... [0, 0, 1], ... [1, 0, 1], ... [1, 0, 0] ... ]) True >>> can_robot_reach_goal([ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) False >>> can_robot_reach_goal([ ... [0, 0, 0, 1], ... [1, 1, 0, 1], ... [1, 0, 0, 0], ... [1, 1, 1, 0] ... ]) True >>> can_robot_reach_goal([ ... [0, 0, 0, 1], ... [1, 1, 0, 1], ... [1, 0, 1, 1], ... [1, 1, 1, 0] ... ]) False >>> can_robot_reach_goal([ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) False >>> can_robot_reach_goal([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ]) False >>> can_robot_reach_goal([]) False >>> can_robot_reach_goal([[]]) False pass","solution":"def can_robot_reach_goal(warehouse): Determine if the robot can reach the bottom-right corner of the grid. :param warehouse: List[List[int]], a 2D grid representing the warehouse :return: bool, True if the robot can reach the goal, False otherwise if not warehouse or not warehouse[0]: return False m, n = len(warehouse), len(warehouse[0]) if warehouse[0][0] == 1 or warehouse[m-1][n-1] == 1: return False from collections import deque directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0)]) warehouse[0][0] = 1 # mark as visited while queue: x, y = queue.popleft() if x == m - 1 and y == n - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and warehouse[nx][ny] == 0: queue.append((nx, ny)) warehouse[nx][ny] = 1 # mark as visited return False"},{"question":"def count_squares(rectangles: List[List[int]]) -> int: Returns the number of unique side lengths that can form squares. Arguments: rectangles : List[List[int]] : list of rectangles dimensions [li, wi] Returns: int : number of unique square side lengths >>> count_squares([[3, 3]]) 3 >>> count_squares([[2, 3], [4, 5], [6, 6]]) 6 >>> count_squares([[2, 2], [2, 1], [3, 3]]) 3 >>> count_squares([[1, 2], [2, 3], [3, 4], [4, 5]]) 4 >>> count_squares([[1, 1]]) 1 >>> count_squares([]) 0","solution":"def count_squares(rectangles): Returns the number of unique side lengths that can form squares. Arguments: rectangles : List[List[int]] : list of rectangles dimensions [li, wi] Returns: int : number of unique square side lengths unique_squares = set() for l, w in rectangles: min_side = min(l, w) for length in range(1, min_side + 1): unique_squares.add(length) return len(unique_squares)"},{"question":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: Inserts the string \`word\` into the Trie. pass def search(self, word: str) -> bool: Returns \`true\` if the string \`word\` is in the Trie, and \`false\` otherwise. pass def startsWith(self, prefix: str) -> bool: Returns \`true\` if there is a previously inserted string in the Trie that has the prefix \`prefix\`, and \`false\` otherwise. pass def test_insert_and_search(): trie = Trie() trie.insert(\\"apple\\") assert trie.search(\\"apple\\") == True assert trie.search(\\"app\\") == False assert trie.startsWith(\\"app\\") == True trie.insert(\\"app\\") assert trie.search(\\"app\\") == True def test_starts_with(): trie = Trie() trie.insert(\\"banana\\") assert trie.startsWith(\\"ban\\") == True assert trie.startsWith(\\"bana\\") == True assert trie.startsWith(\\"band\\") == False def test_insert_and_search_multiple_words(): trie = Trie() words = [\\"cat\\", \\"car\\", \\"cart\\", \\"dog\\", \\"dove\\"] for word in words: trie.insert(word) for word in words: assert trie.search(word) == True assert trie.search(\\"cane\\") == False def test_prefix_not_in_trie(): trie = Trie() trie.insert(\\"house\\") assert trie.startsWith(\\"hou\\") == True assert trie.startsWith(\\"hom\\") == False assert trie.search(\\"home\\") == False","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def startsWith(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"from typing import List def largestIsland(grid: List[List[int]]) -> int: You are given an m x n grid \`grid\` of 0's (representing water) and 1's (representing land). An island is a maximal 4-directionally connected group of 1's. Determine the largest island's size. If no island exists, return 0. You may connect two 1's from different islands by flipping exactly one 0 to 1. The size of an island is the number of 1's it contains. >>> largestIsland([[1, 0], [0, 1]]) 3 >>> largestIsland([[1, 1], [0, 1]]) 4 >>> largestIsland([[1, 1], [1, 1]]) 4 >>> largestIsland([[0, 0], [0, 0]]) 1 >>> largestIsland([[1, 0, 1], [0, 0, 0], [1, 0, 1]]) 3 >>> largestIsland([ ... [1, 0, 0, 0, 1], ... [0, 1, 0, 1, 0], ... [1, 0, 1, 0, 1], ... [0, 1, 0, 1, 0], ... [1, 0, 0, 0, 1] ... ]) 5 # Your implementation here","solution":"from typing import List def largestIsland(grid: List[List[int]]) -> int: def dfs(x, y, index): stack = [(x, y)] seen.add((x, y)) area = 0 while stack: cx, cy = stack.pop() area += 1 island_ids[cx][cy] = index for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if 0 <= nx < row and 0 <= ny < col and (nx, ny) not in seen and grid[nx][ny] == 1: stack.append((nx, ny)) seen.add((nx, ny)) return area row, col = len(grid), len(grid[0]) island_ids = [[0] * col for _ in range(row)] island_areas = {} index = 2 seen = set() for i in range(row): for j in range(col): if grid[i][j] == 1 and (i, j) not in seen: area = dfs(i, j, index) island_areas[index] = area index += 1 max_area = max(island_areas.values(), default=0) for i in range(row): for j in range(col): if grid[i][j] == 0: possible_area = 1 seen_islands = set() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: ni, nj = i + dx, j + dy if 0 <= ni < row and 0 <= nj < col and grid[ni][nj] == 1: island_id = island_ids[ni][nj] if island_id not in seen_islands: possible_area += island_areas[island_id] seen_islands.add(island_id) max_area = max(max_area, possible_area) return max_area"},{"question":"def canAttendMeetings(intervals: list[tuple[int, int]]) -> bool: Determines if a person can attend all meetings without overlap. >>> canAttendMeetings([]) == True >>> canAttendMeetings([(10, 20)]) == True >>> canAttendMeetings([(1, 5), (6, 10), (11, 15)]) == True >>> canAttendMeetings([(1, 5), (4, 10), (11, 15)]) == False >>> canAttendMeetings([(10, 20), (15, 25)]) == False >>> canAttendMeetings([(1, 5), (5, 10), (10, 15)]) == True >>> canAttendMeetings([(1, 5), (2, 6), (4, 10)]) == False >>> canAttendMeetings([(1, 5), (5, 10), (11, 15), (14, 20)]) == False","solution":"def canAttendMeetings(intervals): Determines if a person can attend all meetings without overlap. Args: intervals (list of tuples): List of meeting time intervals represented as tuples (start, end). Returns: bool: True if a person can attend all meetings without overlap, False otherwise. intervals.sort(key=lambda x: x[0]) for i in range(1, len(intervals)): if intervals[i][0] < intervals[i-1][1]: return False return True"},{"question":"from typing import List def element_wise_max(nums1: List[int], nums2: List[int]) -> List[int]: Given two arrays of integers \`nums1\` and \`nums2\`, return the element-wise maximum of the two arrays. The element-wise maximum of two arrays is a new array such that each element at index \`i\` from the new array is the maximum of \`nums1[i]\` and \`nums2[i]\`. If the lengths of \`nums1\` and \`nums2\` are not the same, fill the shorter array with \`-Infinity\` until they are of equal length. >>> element_wise_max([1, 2, 3], [2, 3, 1]) [2, 3, 3] >>> element_wise_max([4, 5], [1, 6, 7]) [4, 6, 7] >>> element_wise_max([], [1, 2, 3]) [1, 2, 3] >>> element_wise_max([1, 2, 3], []) [1, 2, 3] >>> element_wise_max([3, 3, 3], [3, 3, 3]) [3, 3, 3] >>> element_wise_max([-float('inf'), 2], [-float('inf'), 3, 4]) [-float('inf'), 3, 4] >>> element_wise_max([-1, -2, -3], [-3, -2, -1]) [-1, -2, -1]","solution":"def element_wise_max(nums1, nums2): Returns the element-wise maximum of two arrays. If lengths of nums1 and nums2 are not the same, fill the shorter array with -Infinity until they are of equal length. len1, len2 = len(nums1), len(nums2) # Fill the shorter list with -Infinity up to the size of the longer list if len1 < len2: nums1 += [-float('inf')] * (len2 - len1) elif len2 < len1: nums2 += [-float('inf')] * (len1 - len2) # Calculate the element-wise maximum result = [max(a, b) for a, b in zip(nums1, nums2)] return result"},{"question":"def min_bulbs_on(n: int, flipOperations: List[int]) -> int: Returns the minimum number of bulbs that are still ON at the end of all flip operations. >>> min_bulbs_on(5, []) == 0 >>> min_bulbs_on(5, [1]) == 1 >>> min_bulbs_on(5, [5]) == 1 >>> min_bulbs_on(5, [1, 1]) == 0 >>> min_bulbs_on(5, [3, 3, 3]) == 1 >>> min_bulbs_on(5, [1, 2, 3, 4, 5]) == 5 >>> min_bulbs_on(5, [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]) == 0 >>> min_bulbs_on(1, [1]) == 1 >>> min_bulbs_on(1, [1, 1]) == 0","solution":"def min_bulbs_on(n, flipOperations): Returns the minimum number of bulbs that are still ON at the end of all flip operations. :param n: The number of bulbs. :param flipOperations: List of positions of the bulbs to be flipped. :return: The number of bulbs that are ON at the end. bulbs = [0] * n for pos in flipOperations: bulbs[pos - 1] ^= 1 return sum(bulbs)"},{"question":"def max_possible_sum(nums: List[int], k: int) -> int: Given an array of integers nums, you are allowed to perform at most k consecutive decrements to any element in the array. Return the maximum possible sum of the array after performing the decrements. >>> max_possible_sum([1, 2, 3, 4, 5], 0) 15 >>> max_possible_sum([1, 2, 3, 4, 5], 1) 14 >>> max_possible_sum([1, 2, 3, 4, 5], 3) 12 >>> max_possible_sum([1, 1, 1, 1], 4) 0 >>> max_possible_sum([1, 2, 3], 10) 0 >>> max_possible_sum([10], 5) 5 >>> max_possible_sum([5, 5, 5], 7) 8","solution":"def max_possible_sum(nums, k): Returns the maximum possible sum of the array after performing at most k consecutive decrements to any element. nums.sort(reverse=True) max_sum = sum(nums) for i in range(len(nums)): while k > 0 and nums[i] > 0: nums[i] -= 1 max_sum -= 1 k -= 1 return max_sum"},{"question":"def longest_alternating_subsequence(nums): Returns the length of the longest subsequence that is a strict alternation of increase and decrease. >>> longest_alternating_subsequence([1, 2, 3, 4, 5]) == 2 >>> longest_alternating_subsequence([5, 4, 3, 2, 1]) == 2 >>> longest_alternating_subsequence([1, 5, 3, 9, 7]) == 5 >>> longest_alternating_subsequence([10]) == 1 >>> longest_alternating_subsequence([]) == 0 >>> longest_alternating_subsequence([7, 7, 7, 7]) == 1 >>> longest_alternating_subsequence([1, 3, 2, 4, 3, 5, 4, 6]) == 8","solution":"def longest_alternating_subsequence(nums): Returns the length of the longest alternating subsequence of nums. if not nums: return 0 n = len(nums) up = [1] * n down = [1] * n for i in range(1, n): for j in range(i): if nums[i] > nums[j]: up[i] = max(up[i], down[j] + 1) elif nums[i] < nums[j]: down[i] = max(down[i], up[j] + 1) return max(max(up), max(down))"},{"question":"def shortestUniqueSubstring(s: str) -> int: Returns the length of the shortest substring that contains at least one of every different letter that appears in s. >>> shortestUniqueSubstring(\\"aaaa\\") == 1 >>> shortestUniqueSubstring(\\"abcde\\") == 5 >>> shortestUniqueSubstring(\\"aabcbcdbca\\") == 4 >>> shortestUniqueSubstring(\\"abacacdacbccb\\") == 4 >>> shortestUniqueSubstring(\\"a\\") == 1 >>> shortestUniqueSubstring(\\"abacbabc\\") == 3","solution":"def shortestUniqueSubstring(s): Returns the length of the shortest substring that contains at least one of every different letter that appears in s. unique_chars = set(s) required_char_count = len(unique_chars) left = 0 min_length = float('inf') char_frequency = {} num_unique_found = 0 for right in range(len(s)): if s[right] not in char_frequency: char_frequency[s[right]] = 0 char_frequency[s[right]] += 1 if char_frequency[s[right]] == 1: num_unique_found += 1 while num_unique_found == required_char_count: min_length = min(min_length, right - left + 1) char_frequency[s[left]] -= 1 if char_frequency[s[left]] == 0: num_unique_found -= 1 left += 1 return min_length"},{"question":"def numDistinct(s: str, t: str) -> int: Return the number of distinct subsequences of s which equals t. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. Since the answer may be very large, return the result modulo 10**9 + 7. >>> numDistinct(\\"rabbbit\\", \\"rabbit\\") 3 >>> numDistinct(\\"babgbag\\", \\"bag\\") 5 >>> numDistinct(\\"abcdef\\", \\"\\") 1 >>> numDistinct(\\"\\", \\"\\") 1 >>> numDistinct(\\"\\", \\"a\\") 0 >>> numDistinct(\\"\\", \\"abc\\") 0 >>> numDistinct(\\"aaaa\\", \\"aaaa\\") 1 >>> numDistinct(\\"a\\", \\"a\\") 1 >>> numDistinct(\\"abc\\", \\"d\\") 0 >>> numDistinct(\\"xyz\\", \\"yzx\\") 0 >>> numDistinct(\\"a\\"*1000, \\"a\\") 1000 >>> numDistinct(\\"a\\"*1000, \\"aa\\") 499500","solution":"def numDistinct(s, t): Returns the number of distinct subsequences of s which equals t. MOD = 10**9 + 7 m, n = len(s), len(t) if n == 0: return 1 # An empty t is a subsequence of any s including an empty s. if m == 0: return 0 # Non-empty t cannot be a subsequence of an empty s. dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): dp[i][0] = 1 # An empty t is a subsequence of any prefix of s. for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD else: dp[i][j] = dp[i - 1][j] return dp[m][n]"},{"question":"def max_profit_two_transactions(prices): Returns the maximum profit achievable with two non-overlapping transactions. >>> max_profit_two_transactions([]) 0 >>> max_profit_two_transactions([100]) 0 >>> max_profit_two_transactions([7, 6, 4, 3, 1]) 0 >>> max_profit_two_transactions([3, 3, 5, 0, 0, 3, 1, 4]) 6 >>> max_profit_two_transactions([1, 2, 3, 4, 5, 2, 1, 5]) 8 >>> max_profit_two_transactions([4, 1, 3, 2, 8, 4, 9, 2]) 12","solution":"def max_profit_two_transactions(prices): Returns the maximum profit achievable with two non-overlapping transactions. n = len(prices) if n < 2: return 0 left_profits = [0] * n right_profits = [0] * n # Calculate maximum profit for transactions from the left side min_price_left = prices[0] for i in range(1, n): min_price_left = min(min_price_left, prices[i]) left_profits[i] = max(left_profits[i-1], prices[i] - min_price_left) # Calculate maximum profit for transactions from the right side max_price_right = prices[-1] for i in range(n-2, -1, -1): max_price_right = max(max_price_right, prices[i]) right_profits[i] = max(right_profits[i+1], max_price_right - prices[i]) # Calculate the maximum profit by summing up the left and right profits max_profit = 0 for i in range(n): max_profit = max(max_profit, left_profits[i] + right_profits[i]) return max_profit"},{"question":"from typing import List def maxProfit(prices: List[int]) -> int: Calculate the maximum profit achievable with at most two transactions. Parameters: prices (List[int]): List of stock prices by day. Returns: int: The maximum profit possible with at most two transactions. from solution import maxProfit def test_no_prices(): assert maxProfit([]) == 0 def test_single_price(): assert maxProfit([5]) == 0 def test_no_transaction_needed(): assert maxProfit([5, 5, 5, 5]) == 0 def test_case1(): assert maxProfit([3,3,5,0,0,3,1,4]) == 6 # purchase at 0 sell at 3, purchase at 1 sell at 4 def test_case2(): assert maxProfit([1,2,3,4,5]) == 4 # purchase at 1 sell at 5 def test_case3(): assert maxProfit([7,6,4,3,1]) == 0 # no profit possible def test_case4(): assert maxProfit([1,2,4,2,5,7,2,4,9,0]) == 13 # purchase at 1, sell at 7, purchase at 2, sell at 9","solution":"def maxProfit(prices): Calculate the maximum profit achievable with at most two transactions. Parameters: prices (List[int]): List of stock prices by day. Returns: int: The maximum profit possible with at most two transactions. if not prices: return 0 n = len(prices) if n < 2: return 0 # Step 1: Create DP arrays to store max profit up to day i (before second transaction) profit1 = [0] * n min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) profit1[i] = max(profit1[i - 1], prices[i] - min_price) # Step 2: Create another DP array to store max profit after day i (after first transaction) profit2 = [0] * n max_price = prices[-1] for i in range(n - 2, -1, -1): max_price = max(max_price, prices[i]) profit2[i] = max(profit2[i + 1], max_price - prices[i]) # Step 3: Combine the two profits for the maximum profit with 2 transactions max_profit = 0 for i in range(n): max_profit = max(max_profit, profit1[i] + profit2[i]) return max_profit"},{"question":"import heapq from typing import List def trapRainWater(heightMap: List[List[int]]) -> int: Given an \`m x n\` grid filled with non-negative integers representing the height of each unit cell in a 2D elevation map, where the rain water can only move vertically or horizontally to adjacent cells of lower height, returns the amount of water it can trap after raining. >>> trapRainWater([ ... [1,4,3,1,3,2], ... [3,2,1,3,2,4], ... [2,3,3,2,3,1] ... ]) 4 >>> trapRainWater([]) 0 >>> trapRainWater([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 0 >>> trapRainWater([[1, 4, 3, 1, 3, 2]]) 0 >>> trapRainWater([ ... [1], ... [4], ... [3], ... [1], ... [3], ... [2] ... ]) 0 >>> trapRainWater([ ... [12, 13, 1, 12], ... [13, 4, 13, 12], ... [13, 8, 10, 12], ... [12, 13, 12, 12], ... [13, 13, 13, 13] ... ]) 14","solution":"import heapq def trapRainWater(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False] * n for _ in range(m)] heap = [] # Push all the boundary cells into the heap for i in range(m): for j in range(n): if i == 0 or j == 0 or i == m - 1 or j == n - 1: heapq.heappush(heap, (heightMap[i][j], i, j)) visited[i][j] = True dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)] water_trapped = 0 while heap: height, x, y = heapq.heappop(heap) for d in dirs: nx, ny = x + d[0], y + d[1] if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: water_trapped += max(0, height - heightMap[nx][ny]) heapq.heappush(heap, (max(height, heightMap[nx][ny]), nx, ny)) visited[nx][ny] = True return water_trapped"},{"question":"def is_arithmetic_sequence(arr: List[int]) -> bool: Checks if the given array of integers forms an arithmetic sequence. An arithmetic sequence is one in which the difference between any two consecutive elements is the same. Parameters: arr (list of int): An array of integers. Returns: bool: True if the array forms an arithmetic sequence, otherwise False. >>> is_arithmetic_sequence([1, 3, 5, 7]) True >>> is_arithmetic_sequence([5]) True >>> is_arithmetic_sequence([]) True >>> is_arithmetic_sequence([1, 4, 6, 9]) False >>> is_arithmetic_sequence([10, 5, 0, -5]) True >>> is_arithmetic_sequence([3, 3, 3, 3]) True >>> is_arithmetic_sequence([1000000, 999999, 999998, 999997]) True","solution":"def is_arithmetic_sequence(arr): Checks if the given array of integers forms an arithmetic sequence. An arithmetic sequence is one in which the difference between any two consecutive elements is the same. Parameters: arr (list of int): An array of integers. Returns: bool: True if the array forms an arithmetic sequence, otherwise False. if len(arr) <= 1: return True # A single element or empty list can be considered as an arithmetic sequence common_difference = arr[1] - arr[0] for i in range(2, len(arr)): if arr[i] - arr[i-1] != common_difference: return False return True"},{"question":"def can_form_prefix(words: List[str], pref: str) -> bool: Checks if it is possible to make at least one of the words start with the prefix \`pref\` after removing any number of characters from the words. >>> can_form_prefix([\\"apple\\", \\"banana\\", \\"cherry\\"], \\"ape\\") True >>> can_form_prefix([\\"apple\\", \\"banana\\", \\"cherry\\"], \\"xyz\\") False >>> can_form_prefix([\\"apple\\"], \\"apples\\") False >>> can_form_prefix([\\"prefix\\", \\"another\\"], \\"prefix\\") True >>> can_form_prefix([], \\"prefix\\") False >>> can_form_prefix([\\"apple\\", \\"banana\\"], \\"\\") True >>> can_form_prefix([\\"a\\", \\"b\\"], \\"a\\") True >>> can_form_prefix([\\"a\\", \\"b\\"], \\"c\\") False","solution":"def can_form_prefix(words, pref): Checks if it is possible to make at least one of the words start with the prefix \`pref\` after removing any number of characters from the words. # Sorting the prefix itself due to the operation: Letters are arbitrary in positions pref_sorted = sorted(pref) for word in words: # Try to form pref from sorted version of word word_sorted = sorted(word) if can_form_from(word_sorted, pref_sorted): return True return False def can_form_from(word_sorted, pref_sorted): Helper function to check if pref_sorted can be formed by removing any number of characters from word_sorted. # Initialize pointers for two arrays i, j = 0, 0 while i < len(word_sorted) and j < len(pref_sorted): if word_sorted[i] == pref_sorted[j]: j += 1 i += 1 # if we have traversed all characters in pref_sorted, return True return j == len(pref_sorted)"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Given an array of integers \`heights\` representing the height of blocks in a histogram, return the largest rectangular area that can be formed within the histogram. The width of each block is 1. >>> largest_rectangle_area([2]) == 2 >>> largest_rectangle_area([2, 1]) == 2 >>> largest_rectangle_area([5, 4, 3, 2, 1]) == 9 >>> largest_rectangle_area([1, 2, 3, 4, 5]) == 9 >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 >>> largest_rectangle_area([3, 3, 3, 3]) == 12 >>> largest_rectangle_area([]) == 0 >>> largest_rectangle_area([1, 3, 1, 3, 1]) == 5","solution":"def largest_rectangle_area(heights): Returns the largest rectangular area possible in a histogram. :param heights: List[int] a list of integers representing histogram heights. :return: int the area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def min_subarray_sum(nums: List[int], target: int) -> int: Determine the minimum number of elements you need to sum sequentially in the circular array to reach or exceed the target value. If no such subarray exists, return -1. Args: nums (List[int]): The input circular array of integers. target (int): The target sum to be reached or exceeded. Returns: int: The length of the shortest subarray that reaches or exceeds the target sum, or -1 if not possible. >>> min_subarray_sum([1, 2, 3, 4, 5], 11) 3 >>> min_subarray_sum([1, 2, 3, 4, 5], 16) -1 >>> min_subarray_sum([1, 10, 3, 2], 10) 1 >>> min_subarray_sum([1, 1, 1, 1], 4) 4 >>> min_subarray_sum([2, 1, 5, 2], 6) 2 >>> min_subarray_sum([1, 2, 3, 4, 5], 15) 5 >>> min_subarray_sum([4, 2, 1, 7, 3], 10) 2 >>> min_subarray_sum([100, 200, 300, 400], 700) 2 >>> min_subarray_sum([10], 10) 1 >>> min_subarray_sum([5], 10) -1","solution":"def min_subarray_sum(arr, target): n = len(arr) arr = arr + arr # Creating a duplicated circular array min_length = n + 1 for start in range(n): current_sum = 0 for end in range(start, start + n): current_sum += arr[end] if current_sum >= target: min_length = min(min_length, end - start + 1) break return min_length if min_length <= n else -1"},{"question":"import heapq from typing import List def trapRainWater(heightMap: List[List[int]]) -> int: Calculate the total amount of water trapped in the given 2D elevation map. >>> trapRainWater([]) 0 >>> trapRainWater([[]]) 0 >>> trapRainWater([[1]]) 0 >>> trapRainWater([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 0 >>> trapRainWater([[1, 4, 3], [3, 2, 5], [2, 4, 3]]) 1 >>> trapRainWater([[1, 4, 3, 1, 3, 2], [3, 2, 1, 3, 2, 4], [2, 3, 3, 2, 3, 1]]) 4 >>> trapRainWater([ ... [12, 13, 1, 12], ... [13, 4, 13, 12], ... [13, 8, 10, 12], ... [12, 13, 12, 12], ... [13, 13, 13, 13] ... ]) 14","solution":"import heapq def trapRainWater(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False] * n for _ in range(m)] heap = [] # Add all the border cells to the heap for i in range(m): for j in range(n): if i == 0 or i == m - 1 or j == 0 or j == n - 1: heapq.heappush(heap, (heightMap[i][j], i, j)) visited[i][j] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] water_trapped = 0 while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True water_trapped += max(0, height - heightMap[nx][ny]) new_height = max(height, heightMap[nx][ny]) heapq.heappush(heap, (new_height, nx, ny)) return water_trapped"},{"question":"def min_operations_to_alternate_string(s: str) -> int: Returns the minimum number of operations required to transform the string such that no two adjacent characters are the same. >>> min_operations_to_alternate_string('a') 0 >>> min_operations_to_alternate_string('ab') 0 >>> min_operations_to_alternate_string('aa') 1 >>> min_operations_to_alternate_string('abcd') 0 >>> min_operations_to_alternate_string('aabbcc') 3 >>> min_operations_to_alternate_string('abab') 0 >>> min_operations_to_alternate_string('aaaaa') 2 >>> min_operations_to_alternate_string('abacabadabacaba') 0 >>> min_operations_to_alternate_string('aabbccaabbcc') 6","solution":"def min_operations_to_alternate_string(s): Returns the minimum number of operations required to transform the string such that no two adjacent characters are the same. if len(s) <= 1: return 0 operations = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: operations += 1 # Choose a different character for the next position to avoid consecutive duplicates if i + 1 < len(s) and s[i + 1] == s[i]: s = s[:i] + 'z' + s[i + 1:] # Replace with 'z' or any other letter different from s[i] and s[i + 1] else: s = s[:i] + chr((ord(s[i]) - ord('a') + 1) % 26 + ord('a')) + s[i + 1:] return operations"},{"question":"from typing import List def smallest_common_number(mat: List[List[int]]) -> int: Find the smallest common number in all rows of the sorted 2D matrix. Parameters: mat (list of list of int): The input sorted 2D matrix Returns: int: The smallest common number or -1 if no common number exists >>> smallest_common_number([[1, 2, 3, 4, 5], [2, 4, 6, 8, 10], [2, 3, 5, 7, 9]]) 2 >>> smallest_common_number([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -1 >>> smallest_common_number([[1, 2, 3, 4, 5]]) 1 >>> smallest_common_number([]) -1 >>> smallest_common_number([[1, 5, 7], [2, 3, 5], [5, 6, 9]]) 5 >>> smallest_common_number([[2, 2, 2], [2, 3, 4], [2, 5, 7]]) 2 >>> smallest_common_number([[1, 2, 3, 4], [2, 4, 6, 8], [2, 3]]) 2","solution":"def smallest_common_number(mat): Find the smallest common number in all rows of the sorted 2D matrix. Parameters: mat (list of list of int): The input sorted 2D matrix Returns: int: The smallest common number or -1 if no common number exists num_rows = len(mat) num_columns = len(mat[0]) if mat else 0 if num_rows == 0 or num_columns == 0: return -1 column_indices = [0] * num_rows # To keep track of elements in each row while True: current_elements = [mat[i][column_indices[i]] for i in range(num_rows)] max_element = max(current_elements) if all(element == max_element for element in current_elements): return max_element for i in range(num_rows): while column_indices[i] < num_columns and mat[i][column_indices[i]] < max_element: column_indices[i] += 1 if column_indices[i] == num_columns: return -1"},{"question":"def min_cost_for_k_coins(numbers: List[int], k: int) -> int: Minimize the total cost of selecting k coins such that no two selected coins are adjacent in the original \`numbers\` list. >>> min_cost_for_k_coins([], 1) inf >>> min_cost_for_k_coins([10], 1) 10 >>> min_cost_for_k_coins([5, 1, 6, 2], 2) 3 >>> min_cost_for_k_coins([1, 100, 1, 100, 1], 3) 3 >>> min_cost_for_k_coins([5, 10], 1) 5 >>> min_cost_for_k_coins([5, 1000, 1, 1, 1, 1000, 5], 3) 7 >>> min_cost_for_k_coins([5, 5, 5], 0) 0 >>> min_cost_for_k_coins([1, 2, 3], 4) inf","solution":"def min_cost_for_k_coins(numbers, k): n = len(numbers) # A helper function to perform Depth First Search algorithm def dfs(index, coins_remaining, current_cost): if coins_remaining == 0: return current_cost if index >= n: return float('inf') # Option 1: Skip current index skip = dfs(index + 1, coins_remaining, current_cost) # Option 2: Choose current index and skip next one choose = dfs(index + 2, coins_remaining - 1, current_cost + numbers[index]) return min(skip, choose) return dfs(0, k, 0)"},{"question":"def min_operations_to_equal_elements(nums: List[int]) -> int: Returns the minimum number of operations required to make all elements in the array equal. >>> min_operations_to_equal_elements([1, 2, 3]) 2 >>> min_operations_to_equal_elements([1, 1, 1]) 0 >>> min_operations_to_equal_elements([1, 5, 9]) 8 >>> min_operations_to_equal_elements([7, 7, 7, 7]) 0 >>> min_operations_to_equal_elements([100, 200, 300]) 200","solution":"def min_operations_to_equal_elements(nums): Returns the minimum number of operations required to make all elements in the array equal. max_num = max(nums) min_num = min(nums) # Calculate the difference between max and min difference = max_num - min_num return difference"},{"question":"def max_non_overlapping_substrings(s: str, k: int) -> int: Return the maximum number of non-overlapping substrings of length \`k\` that contain exactly \`k\` distinct characters. :param s: A string consisting of lowercase alphabets :param k: An integer representing the length of the substring :return: An integer representing the maximum number of non-overlapping substrings >>> max_non_overlapping_substrings(\\"abcde\\", 6) 0 >>> max_non_overlapping_substrings(\\"aaaa\\", 2) 0 >>> max_non_overlapping_substrings(\\"abcabc\\", 3) 2 >>> max_non_overlapping_substrings(\\"abcdef\\", 3) 2 >>> max_non_overlapping_substrings(\\"abcdabc\\", 4) 1 >>> max_non_overlapping_substrings(\\"abcabcabc\\", 3) 3 >>> max_non_overlapping_substrings(\\"\\", 1) 0 >>> max_non_overlapping_substrings(\\"abcdef\\", 6) 1 >>> max_non_overlapping_substrings(\\"abacabc\\", 3) 2","solution":"def max_non_overlapping_substrings(s, k): Returns the maximum number of non-overlapping substrings of length \`k\` that contain exactly \`k\` distinct characters. :param s: A string consisting of lowercase alphabets :param k: An integer representing the length of the substring :return: An integer representing the maximum number of non-overlapping substrings if k > len(s): return 0 count = 0 i = 0 while i <= len(s) - k: substring = s[i:i+k] if len(set(substring)) == k: count += 1 i += k # Move i forward by k to ensure non-overlapping else: i += 1 # Move i forward by 1 to check next potential substring return count"},{"question":"def minimumDifference(weights): Returns the minimum absolute difference between the sums of the weights of the two groups. Args: weights (List[int]): A list of weights. Returns: int: The minimum absolute difference between the sums of the two groups. Examples: >>> minimumDifference([1]) 1 >>> minimumDifference([2, 2]) 0 >>> minimumDifference([1, 4]) 3 >>> minimumDifference([1, 2, 1, 4, 2]) 0 >>> minimumDifference([3, 1, 4, 2, 2]) 0 >>> minimumDifference([10, 20, 30]) 0 >>> minimumDifference([1, 5, 11, 5]) 0 >>> minimumDifference([3, 1, 4, 2, -5]) 1 >>> minimumDifference([5, 3, 8, 6, 4, 2]) 0","solution":"def minimumDifference(weights): Returns the minimum absolute difference between the sums of the weights of the two groups. total_sum = sum(weights) n = len(weights) subset_sums = {0} for weight in weights: new_sums = set() for s in subset_sums: new_sums.add(s + weight) subset_sums.update(new_sums) min_diff = float('inf') for s in subset_sums: diff = abs(total_sum - 2 * s) if diff < min_diff: min_diff = diff return min_diff"},{"question":"def maximum_perimeter_triangle(nums: List[int]) -> int: Returns the maximum perimeter of a triangle that can be formed with any three different elements from nums. If no valid triangle can be formed, returns 0. >>> maximum_perimeter_triangle([2, 1, 2, 4, 3, 5]) == 12 >>> maximum_perimeter_triangle([1, 1, 1]) == 3 >>> maximum_perimeter_triangle([2, 2, 2, 2]) == 6 >>> maximum_perimeter_triangle([1, 2, 3]) == 0 >>> maximum_perimeter_triangle([10, 15, 20, 25, 30]) == 75","solution":"def maximum_perimeter_triangle(nums): Returns the maximum perimeter of a triangle that can be formed with any three different elements from nums. If no valid triangle can be formed, returns 0. nums.sort(reverse=True) for i in range(len(nums) - 2): if nums[i] < nums[i+1] + nums[i+2]: return nums[i] + nums[i+1] + nums[i+2] return 0"},{"question":"def min_swaps_to_make_even(s: str) -> int: Given a string s representing a decimal number, return the minimum number of swaps needed to make the number even. If it is impossible to make the number even, return -1. Examples: >>> min_swaps_to_make_even(\\"2593\\") 1 >>> min_swaps_to_make_even(\\"1357\\") -1 >>> min_swaps_to_make_even(\\"2584\\") 0 Unit Test: from solution import min_swaps_to_make_even def test_number_already_even(): assert min_swaps_to_make_even(\\"2584\\") == 0 def test_single_swap_needed(): assert min_swaps_to_make_even(\\"2593\\") == 1 assert min_swaps_to_make_even(\\"123\\") == 1 def test_no_swap_needed(): assert min_swaps_to_make_even(\\"2\\") == 0 assert min_swaps_to_make_even(\\"10\\") == 0 def test_impossible_to_make_even(): assert min_swaps_to_make_even(\\"1357\\") == -1 assert min_swaps_to_make_even(\\"7531\\") == -1 def test_large_number_swaps(): assert min_swaps_to_make_even(\\"123456789\\") == 1 assert min_swaps_to_make_even(\\"987654321\\") == 1 def test_leading_zeros(): assert min_swaps_to_make_even(\\"1030\\") == 0","solution":"def min_swaps_to_make_even(s): Returns the minimum number of swaps needed to make the number represented by the string s even. If it is impossible to make the number even, return -1. n = len(s) last_digit = int(s[-1]) # If the last digit is already even, no swaps are needed if last_digit % 2 == 0: return 0 # Find the rightmost even digit for i in range(n - 1, -1, -1): if int(s[i]) % 2 == 0: if i == n - 1: return 0 else: # If we find an even digit, check the number of swaps needed to move it to the end return 1 # If no even digits are found, return -1 return -1"},{"question":"def rearrange_array(nums: List[int], k: int) -> Union[List[int], bool]: Rearranges the array such that the difference between consecutive elements is at most k. If no such rearrangement is possible, return false. If multiple rearrangements are possible, return any valid one. >>> rearrange_array([1, 3, 2, 5, 6], 3) != False >>> rearrange_array([1, 2, 3, 4, 5], 1) == [1, 2, 3, 4, 5] >>> rearrange_array([1, 10, 20], 5) == False >>> rearrange_array([1, 1, 1, 1], 0) != False and rearrange_array([1, 1, 1, 1], 0) == [1, 1, 1, 1] >>> rearrange_array([1], 1) == [1] >>> rearrange_array([10, 20, 30, 40], 100) == [10, 20, 30, 40]","solution":"def rearrange_array(nums, k): Rearranges the array such that the difference between consecutive elements is at most k. If no such rearrangement is possible, returns False. :param nums: List of integers :param k: Positive integer :return: Rearranged list of integers or False if not possible # Sort the array to make consecutive elements as close as possible nums.sort() # Check if we can rearrange to satisfy the condition for i in range(len(nums) - 1): if abs(nums[i] - nums[i + 1]) > k: return False return nums"},{"question":"def longest_increasing_subarray(arr: List[int]) -> int: Return the length of the longest possible increasing subarray that can be obtained after deleting at most one subarray from 'arr'. >>> longest_increasing_subarray([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subarray([1, 2, 5, 3, 4, 5, 6]) 6 >>> longest_increasing_subarray([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subarray([2, 2, 2, 2]) 1 >>> longest_increasing_subarray([]) 0 >>> longest_increasing_subarray([1]) 1 >>> longest_increasing_subarray([1, 2]) 2 >>> longest_increasing_subarray([2, 1]) 1","solution":"def longest_increasing_subarray(arr): n = len(arr) if n == 0: return 0 # Step 1: Find the lengths of increasing subarrays inc_left = [1] * n for i in range(1, n): if arr[i] > arr[i - 1]: inc_left[i] = inc_left[i - 1] + 1 inc_right = [1] * n for i in range(n - 2, -1, -1): if arr[i] < arr[i + 1]: inc_right[i] = inc_right[i + 1] + 1 # Step 2: Find the maximum length considering at most one deletion max_length = max(inc_left) # Length without any deletion for i in range(1, n - 1): if arr[i - 1] < arr[i + 1]: max_length = max(max_length, inc_left[i - 1] + inc_right[i + 1]) return max_length"},{"question":"from collections import deque from typing import List, Tuple def shortest_path_maze(grid: List[List[str]], start: Tuple[int, int], destination: Tuple[int, int]) -> int: Find the shortest path from start to destination in a 2D grid representing a maze. '#' represents a wall and '.' represents an open space. You can move up, down, left, or right. Return the length of the shortest path, or -1 if the destination is not reachable. Args: grid (List[List[str]]): 2D grid representing the maze start (Tuple[int, int]): Coordinates (sx, sy) of the start point destination (Tuple[int, int]): Coordinates (dx, dy) of the destination point Returns: int: Length of the shortest path, or -1 if the destination is not reachable. Examples: >>> grid = [ ['.', '.', '.'], ['#', '#', '.'], ['.', '.', '.'] ] >>> shortest_path_maze(grid, (0, 0), (2, 2)) 4 >>> grid = [ ['.', '#', '.'], ['#', '#', '.'], ['.', '.', '.'] ] >>> shortest_path_maze(grid, (0, 0), (2, 2)) -1","solution":"from collections import deque def shortest_path_maze(grid, start, destination): def is_valid_move(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == '.' sx, sy = start dx, dy = destination if grid[sx][sy] == '#' or grid[dx][dy] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(sx, sy, 0)]) visited = set((sx, sy)) while queue: x, y, dist = queue.popleft() if (x, y) == (dx, dy): return dist for direction in directions: nx, ny = x + direction[0], y + direction[1] if is_valid_move(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"from typing import List from collections import Counter def max_instances_of_balloon(s: str) -> int: Given a string s consisting of lowercase English letters, find and return the maximum number of instances of the substring \\"balloon\\" that can be formed using the characters in s. Each character in the string s may be used at most once in each substring. >>> max_instances_of_balloon('balloon') 1 >>> max_instances_of_balloon('bbaallloonnoo') 1 >>> max_instances_of_balloon('balloonballoon') 2 >>> max_instances_of_balloon('abcdefg') 0 >>> max_instances_of_balloon('baalloon') 1 >>> max_instances_of_balloon('balloonxballoon') 2 >>> max_instances_of_balloon('') 0 >>> max_instances_of_balloon('ballo') 0","solution":"from collections import Counter def max_instances_of_balloon(s): Returns the maximum number of instances of the substring \\"balloon\\" that can be formed using the characters in s. # Count the frequency of each character in the given string char_count = Counter(s) # \\"balloon\\" requires 1 'b', 1 'a', 2 'l', 2 'o', and 1 'n' # Calculate how many times we can form the word \\"balloon\\" count_b = char_count['b'] count_a = char_count['a'] count_l = char_count['l'] // 2 count_o = char_count['o'] // 2 count_n = char_count['n'] return min(count_b, count_a, count_l, count_o, count_n)"},{"question":"from typing import List def count_distinct_reorderings(n: int) -> int: Returns the number of distinct integers that can be formed by reordering the digits of n. Leading zeros are not allowed in the formed integers. Parameters: n (int): A positive integer Returns: int: Count of distinct integers >>> count_distinct_reorderings(123) 6 >>> count_distinct_reorderings(112) 3 >>> count_distinct_reorderings(102) 4 >>> count_distinct_reorderings(100) 1 >>> count_distinct_reorderings(123456) 720","solution":"from itertools import permutations def count_distinct_reorderings(n): Returns the number of distinct integers that can be formed by reordering the digits of n. Leading zeros are not allowed in the formed integers. Parameters: n (int): A positive integer Returns: int: Count of distinct integers # Convert the integer to string to get its digits digits = str(n) # Generate all unique permutations of the digits perm_set = set(int(''.join(p)) for p in permutations(digits)) # Filter out numbers with leading zeros, not counting the original number filtered_perm_set = {num for num in perm_set if len(str(num)) == len(digits)} # Return the count of unique valid integers return len(filtered_perm_set)"},{"question":"class TreeValueTracker: A data structure to track values in a tree and perform update and sum operations. TreeValueTracker(parent: List[int], values: List[int]) -> None: - Initializes the TreeValueTracker with the given parent-child relationships and node values. updateValue(node: int, value: int) -> None: - Updates the value of the specified node to the new given value. sumOfSubtree(node: int) -> int: - Returns the sum of the subtree rooted at the specified node. def __init__(self, parent: List[int], values: List[int]): pass def updateValue(self, node: int, value: int) -> None: pass def sumOfSubtree(self, node: int) -> int: pass # Unit tests def test_initial_sum(): parent = [-1, 0, 0, 1, 1, 2, 2] values = [1, 2, 3, 4, 5, 6, 7] tracker = TreeValueTracker(parent, values) assert tracker.sumOfSubtree(0) == 28 assert tracker.sumOfSubtree(1) == 11 assert tracker.sumOfSubtree(2) == 16 assert tracker.sumOfSubtree(3) == 4 def test_update_value(): parent = [-1, 0, 0, 1, 1, 2, 2] values = [1, 2, 3, 4, 5, 6, 7] tracker = TreeValueTracker(parent, values) tracker.updateValue(3, 10) assert tracker.sumOfSubtree(0) == 34 assert tracker.sumOfSubtree(1) == 17 assert tracker.sumOfSubtree(3) == 10 def test_multiple_updates(): parent = [-1, 0, 0, 1, 1, 2, 2] values = [1, 2, 3, 4, 5, 6, 7] tracker = TreeValueTracker(parent, values) tracker.updateValue(3, 10) tracker.updateValue(2, 9) assert tracker.sumOfSubtree(0) == 40 assert tracker.sumOfSubtree(1) == 17 assert tracker.sumOfSubtree(3) == 10 assert tracker.sumOfSubtree(2) == 22","solution":"class TreeValueTracker: def __init__(self, parent, values): self.parent = parent self.values = values self.n = len(values) # Build the adjacency list for the tree self.children = [[] for _ in range(self.n)] for i in range(1, self.n): self.children[parent[i]].append(i) # Calculate initial sums for all subtrees self.subtree_sums = [0] * self.n self.calculate_subtree_sums(0) def calculate_subtree_sums(self, node): self.subtree_sums[node] = self.values[node] for child in self.children[node]: self.subtree_sums[node] += self.calculate_subtree_sums(child) return self.subtree_sums[node] def updateValue(self, node, value): diff = value - self.values[node] self.values[node] = value self.update_subtree_sums(node, diff) def update_subtree_sums(self, node, diff): self.subtree_sums[node] += diff if self.parent[node] != -1: self.update_subtree_sums(self.parent[node], diff) def sumOfSubtree(self, node): return self.subtree_sums[node]"},{"question":"def remove_k_characters(s: str, k: int) -> str: Remove k characters from the string s to create the lexicographically smallest possible string. >>> remove_k_characters(\\"abcde\\", 2) == \\"abc\\" >>> remove_k_characters(\\"bcda\\", 1) == \\"bca\\" >>> remove_k_characters(\\"cba\\", 2) == \\"a\\" >>> remove_k_characters(\\"abcde\\", 1) == \\"abcd\\" >>> remove_k_characters(\\"abcd\\", 2) == \\"ab\\" >>> remove_k_characters(\\"aaaa\\", 2) == \\"aa\\" >>> remove_k_characters(\\"bbbb\\", 3) == \\"b\\" >>> remove_k_characters(\\"abc\\", 3) == \\"\\" >>> remove_k_characters(\\"xyz\\", 3) == \\"\\" >>> remove_k_characters(\\"\\", 0) == \\"\\" >>> remove_k_characters(\\"a\\", 1) == \\"\\"","solution":"def remove_k_characters(s, k): Returns the lexicographically smallest string after removing exactly k characters from s. stack = [] for char in s: while k > 0 and stack and stack[-1] > char: stack.pop() k -= 1 stack.append(char) # If there are still characters to remove, remove them from the end of the stack return ''.join(stack[:len(stack)-k])"},{"question":"def min_moves_to_make_unique(s: str) -> int: Returns the minimum number of moves required to make all characters in the string unique. If it's impossible to make all characters unique, return -1. >>> min_moves_to_make_unique(\\"abc\\") == 0 >>> min_moves_to_make_unique(\\"abac\\") == 1 >>> min_moves_to_make_unique(\\"aaabbbccc\\") == 6 >>> min_moves_to_make_unique(\\"abcdefghijklmnopqrstuvwxyzx\\") == -1 >>> min_moves_to_make_unique(\\"\\") == 0 >>> min_moves_to_make_unique(\\"aaaaa\\") == 4 pass","solution":"def min_moves_to_make_unique(s): Returns the minimum number of moves required to make all characters in the string unique. If it's impossible to make all characters unique, return -1. from collections import Counter if len(s) > 26: return -1 counter = Counter(s) duplicates = sum(count - 1 for count in counter.values() if count > 1) return duplicates"},{"question":"def maxPathSum(grid): Finds the maximum sum of values from the top-left to the bottom-right corner of a grid. You can only move right or down at each step. Parameters: grid (List[List[int]]): 2D list of non-negative integers. Returns: int: Maximum sum collected along the path. >>> maxPathSum([[1, 2, 3]]) # Single row 6 >>> maxPathSum([[1], [2], [3]]) # Single column 6 >>> maxPathSum([[5]]) # Single cell 5 >>> grid = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> maxPathSum(grid) # 3x3 grid 12 >>> grid = [ ... [1, 2], ... [1, 1] ... ] >>> maxPathSum(grid) # 2x2 grid 4","solution":"def maxPathSum(grid): Finds the maximum sum of values from the top-left to the bottom-right corner of a grid. You can only move right or down at each step. Parameters: grid (List[List[int]]): 2D list of non-negative integers. Returns: int: Maximum sum collected along the path. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"def find_deepest_path(paths: list[str]) -> str: Given a list of absolute paths, return the deepest path. Parameters: paths (list of str): The list of absolute paths in a file system Returns: str: The deepest path string >>> find_deepest_path([\\"/a/b/c/d/file.txt\\", \\"/a/b/file2.txt\\", \\"/a/b/c/e/directory\\"]) \\"/a/b/c/d/file.txt\\" >>> find_deepest_path([\\"/root/dir/file\\"]) \\"/root/dir/file\\" >>> find_deepest_path([]) \\"\\" >>> find_deepest_path([\\"/a/b/c/file1\\", \\"/d/e/f/file2\\"]) in [\\"/a/b/c/file1\\", \\"/d/e/f/file2\\"] >>> find_deepest_path([\\"/a\\", \\"/a/b\\", \\"/a/b/c\\"]) \\"/a/b/c\\" >>> find_deepest_path([\\"/\\"]) \\"/\\" # Implementation goes here","solution":"def find_deepest_path(paths): Given a list of absolute paths, return the deepest path. Parameters: paths (list of str): The list of absolute paths in a file system Returns: str: The deepest path string if not paths: return \\"\\" # Initialize the deepest path and its depth max_depth = 0 deepest_path = \\"\\" for path in paths: # Calculate the depth (number of slashes) for the current path depth = path.count('/') # Check if this path is deeper than the current deepest path if depth > max_depth: max_depth = depth deepest_path = path return deepest_path"},{"question":"def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. >>> is_prime(1) == False >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(5) == True >>> is_prime(9) == False >>> is_prime(11) == True >>> is_prime(25) == False >>> is_prime(29) == True def next_prime(n: int) -> int: Returns the smallest prime number greater than n. >>> next_prime(1) == 2 >>> next_prime(2) == 3 >>> next_prime(3) == 5 >>> next_prime(10) == 11 >>> next_prime(14) == 17 >>> next_prime(20) == 23 >>> next_prime(30) == 31 >>> next_prime(100) == 101 >>> next_prime(200) == 211","solution":"def is_prime(n): Returns True if n is a prime number, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def next_prime(n): Returns the smallest prime number greater than n. candidate = n + 1 while not is_prime(candidate): candidate += 1 return candidate"},{"question":"from typing import List def min_steps_to_destination(grid: List[List[int]]) -> int: Returns the minimum number of steps for the robot to reach destination (m-1, n-1) from the starting point (0, 0) in the given grid or -1 if no path exists. :param grid: List[List[int]] -- the grid representing the environment :return: int -- minimum number of steps to reach the destination or -1 if no path exists >>> min_steps_to_destination([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) # 4 >>> min_steps_to_destination([[0, 0, 0, 0], [1, 1, 0, 1], [0, 0, 0, 0], [0, 1, 1, 0]]) # 6 >>> min_steps_to_destination([[0, 1, 0], [1, 1, 0], [0, 0, 0]]) # -1 >>> min_steps_to_destination([[1, 0, 0], [0, 0, 0], [0, 0, 0]]) # -1 >>> min_steps_to_destination([[0, 0, 0], [0, 0, 0], [0, 0, 1]]) # -1 >>> min_steps_to_destination([[0]]) # 0 >>> min_steps_to_destination([[0, 1], [1, 0]]) # -1 pass","solution":"from collections import deque def min_steps_to_destination(grid): Returns the minimum number of steps for the robot to reach destination (m-1, n-1) from the starting point (0, 0) in the given grid or -1 if no path exists. :param grid: List[List[int]] -- the grid representing the environment :return: int -- minimum number of steps to reach the destination or -1 if no path exists if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, 0)]) # (x, y, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == m-1 and y == n-1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return -1"},{"question":"from typing import List def maxProduct(nums: List[int], k: int) -> int: Returns the maximum product of k consecutive elements in nums. >>> maxProduct([1, 5, 2, 6, 3, 4], 2) 18 >>> maxProduct([7], 1) 7 >>> maxProduct([1, 2, 3, 4], 4) 24 >>> maxProduct([0, 0, 0, 0], 2) 0 >>> maxProduct([1, -2, -3, 4, -5], 3) 60 >>> maxProduct([1, 2, 3], 5) 0 >>> maxProduct([1, 2, 3], 0) 0 >>> maxProduct([], 1) 0","solution":"from typing import List def maxProduct(nums: List[int], k: int) -> int: Returns the maximum product of k consecutive elements in nums. if len(nums) == 0 or k == 0 or k > len(nums): return 0 max_product = float('-inf') for i in range(len(nums) - k + 1): current_product = 1 for j in range(k): current_product *= nums[i + j] max_product = max(max_product, current_product) return max_product"},{"question":"def findAllConcatenatedWords(words): Identify and return all words that are concatenations of other words in the list. >>> findAllConcatenatedWords([\\"cat\\", \\"cats\\", \\"catsdog\\", \\"dog\\", \\"dogcatsdog\\"]) [\\"catsdog\\", \\"dogcatsdog\\"] >>> findAllConcatenatedWords([]) [] >>> findAllConcatenatedWords([\\"cat\\", \\"dog\\", \\"mouse\\"]) [] >>> findAllConcatenatedWords([\\"cat\\", \\"cats\\", \\"dog\\", \\"catdog\\", \\"dogcatscat\\"]) [\\"catdog\\", \\"dogcatscat\\"] >>> findAllConcatenatedWords([\\"cat\\", \\"cats\\", \\"dog\\", \\"catdog\\", \\"dogcatscat\\", \\"catdogcats\\", \\"house\\"]) [\\"catdog\\", \\"dogcatscat\\", \\"catdogcats\\"] >>> findAllConcatenatedWords([\\"cat\\", \\"cat\\", \\"cats\\", \\"catsdog\\", \\"dog\\"]) [\\"catsdog\\"] >>> findAllConcatenatedWords([\\"cat\\", \\"cats\\", \\"dog\\", \\"catsdog\\", \\"rat\\", \\"ratcatdog\\"]) [\\"catsdog\\", \\"ratcatdog\\"]","solution":"def findAllConcatenatedWords(words): Returns a list of all concatenated words in the input list of words. words_set = set(words) def canForm(word): if word in memo: return memo[word] for i in range(1, len(word)): prefix = word[:i] suffix = word[i:] if prefix in words_set and (suffix in words_set or canForm(suffix)): memo[word] = True return True memo[word] = False return False memo = {} concatenated_words = [] for word in words: if canForm(word): concatenated_words.append(word) return concatenated_words"},{"question":"def can_distribute_water(heights: List[int], k: int) -> bool: Determines if water can be distributed from the first building to the last or vice versa given the height difference limit k. >>> can_distribute_water([1, 2, 3, 4, 5], 1) True >>> can_distribute_water([1, 2, 10, 3, 4], 2) False >>> can_distribute_water([4, 4, 4, 4, 4], 0) True pass","solution":"def can_distribute_water(heights, k): Determines if water can be distributed from the first building to the last or vice versa given the height difference limit k. :param heights: List[int] - The heights of the buildings. :param k: int - the maximum allowable height difference for water distribution. :return: bool - True if water can be distributed as per the restrictions, else False. n = len(heights) reachable = [False] * n reachable[0] = True for i in range(n - 1): if reachable[i]: for j in range(i + 1, n): if abs(heights[j] - heights[i]) <= k: reachable[j] = True else: break return reachable[-1]"},{"question":"def shortest_palindrome(s: str) -> str: Returns the shortest palindrome that can be made by inserting characters at the beginning of the string s. >>> shortest_palindrome(\\"abcd\\") \\"dcbabcd\\" >>> shortest_palindrome(\\"aacecaaa\\") \\"aaacecaaa\\" >>> shortest_palindrome(\\"racecar\\") \\"racecar\\" >>> shortest_palindrome(\\"\\") \\"\\" >>> shortest_palindrome(\\"a\\") \\"a\\" >>> shortest_palindrome(\\"aa\\") \\"aa\\" >>> shortest_palindrome(\\"ab\\") \\"bab\\" >>> shortest_palindrome(\\"abc\\") \\"cbabc\\"","solution":"def shortest_palindrome(s): Returns the shortest palindrome that can be made by inserting characters at the beginning of s. # Helper function to check if a string is a palindrome def is_palindrome(x): return x == x[::-1] if is_palindrome(s): return s # Reverse the input string rev_s = s[::-1] # Add characters from the reversed string to the beginning until the full string is a palindrome for i in range(len(s)): if is_palindrome(rev_s[:i] + s): return rev_s[:i] + s # Example Usage # shortest_palindrome(\\"abcd\\") should return \\"dcbabcd\\""},{"question":"def number_of_buildings_each_can_check(heights: List[int]) -> List[int]: Determines the number of buildings each building can check. :param heights: List[int] heights of the buildings :return: List[int] number of buildings each building can check >>> number_of_buildings_each_can_check([5]) [0] >>> number_of_buildings_each_can_check([5, 6]) [1, 0] >>> number_of_buildings_each_can_check([6, 5]) [0, 0] >>> number_of_buildings_each_can_check([5, 5]) [1, 0] >>> number_of_buildings_each_can_check([5, 5, 5]) [2, 1, 0] >>> number_of_buildings_each_can_check([1, 2, 3, 4]) [3, 2, 1, 0] >>> number_of_buildings_each_can_check([4, 3, 2, 1]) [0, 0, 0, 0] >>> number_of_buildings_each_can_check([1, 3, 2, 4]) [3, 1, 1, 0] >>> number_of_buildings_each_can_check([]) []","solution":"def number_of_buildings_each_can_check(heights): Determines the number of buildings each building can check. :param heights: List[int] heights of the buildings :return: List[int] number of buildings each building can check n = len(heights) result = [0] * n for i in range(n): for j in range(i + 1, n): if heights[j] >= heights[i]: result[i] += 1 return result"},{"question":"def min_blocks_to_equalize(heights: List[int]) -> int: Returns the minimum number of blocks required to make all towers in the list of same height. :param heights: List of integers representing the heights of towers. :return: Integer representing the minimum number of blocks required. >>> min_blocks_to_equalize([5]) 0 >>> min_blocks_to_equalize([3, 3, 3]) 0 >>> min_blocks_to_equalize([1, 2, 3]) 3 >>> min_blocks_to_equalize([5, 4, 3, 2, 1]) 10 >>> min_blocks_to_equalize([1, 2, 3, 4, 5]) 10 >>> min_blocks_to_equalize([4, 1, 3, 2]) 6 >>> min_blocks_to_equalize([100000, 200000, 300000]) 300000","solution":"def min_blocks_to_equalize(heights): Returns the minimum number of blocks required to make all towers in the list of same height. :param heights: List of integers representing the heights of towers. :return: Integer representing the minimum number of blocks required. max_height = max(heights) total_blocks_required = sum(max_height - height for height in heights) return total_blocks_required"},{"question":"def minimum_swaps_to_sort(nums: List[int]) -> int: Returns the minimum number of swaps required to sort the array in non-decreasing order. >>> minimum_swaps_to_sort([2, 8, 5, 4]) 1 >>> minimum_swaps_to_sort([4, 3, 2]) 1 >>> minimum_swaps_to_sort([4, 3, 2, 1]) 2 >>> minimum_swaps_to_sort([1, 2, 3, 4]) 0 >>> minimum_swaps_to_sort([1]) 0 >>> minimum_swaps_to_sort([2, 1]) 1","solution":"def minimum_swaps_to_sort(nums): Returns the minimum number of swaps required to sort the array in non-decreasing order. n = len(nums) sorted_nums = sorted(nums) index_map = {value: idx for idx, value in enumerate(nums)} swaps = 0 for i in range(n): if nums[i] != sorted_nums[i]: swaps += 1 swap_idx = index_map[sorted_nums[i]] index_map[nums[i]] = swap_idx nums[i], nums[swap_idx] = nums[swap_idx], nums[i] return swaps"},{"question":"def has_subarray_with_sum(nums, target): Returns True if there exists a contiguous subarray whose sum equals target, else False. >>> has_subarray_with_sum([1, 2, 3, 4, 5], 9) True >>> has_subarray_with_sum([1, 2, 3], 6) True >>> has_subarray_with_sum([], 0) False >>> has_subarray_with_sum([5], 5) True >>> has_subarray_with_sum([5], 10) False >>> has_subarray_with_sum([1, -1, 2, -2, 3], 0) True >>> has_subarray_with_sum([-1, -2, -3], -6) True >>> has_subarray_with_sum([0, 0, 0, 0], 0) True >>> has_subarray_with_sum([0, 0, 0, 0], 1) False","solution":"def has_subarray_with_sum(nums, target): Returns True if there exists a contiguous subarray whose sum equals target, else False. current_sum = 0 sum_dict = {0: -1} # Maps sum to the index where this sum occurs for i, num in enumerate(nums): current_sum += num if current_sum - target in sum_dict: return True # Record the current sum with its corresponding index if current_sum not in sum_dict: sum_dict[current_sum] = i return False"},{"question":"class CustomDeque: A custom deque implementation that supports the following operations efficiently: - pushFront(int x): Adds the element x to the front of the deque. - pushBack(int x): Adds the element x to the back of the deque. - popFront(): Removes and returns the element from the front of the deque. If the deque is empty, return -1. - popBack(): Removes and returns the element from the back of the deque. If the deque is empty, return -1. - peekFront(): Returns the element at the front of the deque without removing it. If the deque is empty, return -1. - peekBack(): Returns the element at the back of the deque without removing it. If the deque is empty, return -1. def __init__(self): # Initialize the deque def pushFront(self, x): # Method to add element to the front of the deque def pushBack(self, x): # Method to add element to the back of the deque def popFront(self): # Method to remove and return the element from the front of the deque. Return -1 if empty. def popBack(self): # Method to remove and return the element from the back of the deque. Return -1 if empty. def peekFront(self): # Method to return the element at the front of the deque without removing it. Return -1 if empty. def peekBack(self): # Method to return the element at the back of the deque without removing it. Return -1 if empty. # Unit Tests def test_pushFront_peekFront(): deque = CustomDeque() deque.pushFront(1) assert deque.peekFront() == 1 deque.pushFront(2) assert deque.peekFront() == 2 def test_pushBack_peekBack(): deque = CustomDeque() deque.pushBack(1) assert deque.peekBack() == 1 deque.pushBack(2) assert deque.peekBack() == 2 def test_popFront(): deque = CustomDeque() deque.pushFront(1) deque.pushFront(2) assert deque.popFront() == 2 assert deque.popFront() == 1 assert deque.popFront() == -1 def test_popBack(): deque = CustomDeque() deque.pushBack(1) deque.pushBack(2) assert deque.popBack() == 2 assert deque.popBack() == 1 assert deque.popBack() == -1 def test_peekFront_empty(): deque = CustomDeque() assert deque.peekFront() == -1 def test_peekBack_empty(): deque = CustomDeque() assert deque.peekBack() == -1","solution":"class CustomDeque: def __init__(self): self.deque = [] def pushFront(self, x): self.deque.insert(0, x) def pushBack(self, x): self.deque.append(x) def popFront(self): if self.deque: return self.deque.pop(0) return -1 def popBack(self): if self.deque: return self.deque.pop() return -1 def peekFront(self): if self.deque: return self.deque[0] return -1 def peekBack(self): if self.deque: return self.deque[-1] return -1"},{"question":"from typing import List def maxSlidingWindow(arr: List[int], k: int) -> List[int]: Returns an array containing the maximum of each sliding window of size k. >>> maxSlidingWindow([1,3,-1,-3,5,3,6,7], 3) [3,3,5,5,6,7] >>> maxSlidingWindow([1,2,3,4,5], 1) [1,2,3,4,5]","solution":"from collections import deque from typing import List def maxSlidingWindow(arr: List[int], k: int) -> List[int]: Returns an array containing the maximum of each sliding window of size k. if not arr or k == 0: return [] n = len(arr) if k == 1: return arr def clean_deque(i): if deq and deq[0] == i - k: deq.popleft() while deq and arr[i] > arr[deq[-1]]: deq.pop() deq = deque() max_indices = [] max_numbers = [] for i in range(n): clean_deque(i) deq.append(i) if i >= k - 1: max_numbers.append(arr[deq[0]]) return max_numbers"},{"question":"def min_insertions_to_balance(s: str) -> int: Returns the minimum number of insertions needed to make the string balanced. >>> min_insertions_to_balance(\\"()\\") == 0 >>> min_insertions_to_balance(\\"(())\\") == 0 >>> min_insertions_to_balance(\\"()()\\") == 0 >>> min_insertions_to_balance(\\"(\\") == 1 >>> min_insertions_to_balance(\\"(((\\") == 3 >>> min_insertions_to_balance(\\"((())\\") == 1 >>> min_insertions_to_balance(\\")\\") == 1 >>> min_insertions_to_balance(\\")))\\") == 3 >>> min_insertions_to_balance(\\"())\\") == 1 >>> min_insertions_to_balance(\\"())(\\") == 2 >>> min_insertions_to_balance(\\"(()))(\\") == 2 >>> min_insertions_to_balance(\\")()(\\") == 2","solution":"def min_insertions_to_balance(s): Returns the minimum number of insertions needed to make the string balanced. left_count = 0 right_needed = 0 for char in s: if char == '(': left_count += 1 elif char == ')': if left_count > 0: left_count -= 1 else: right_needed += 1 return left_count + right_needed"},{"question":"def sum_of_most_frequent_character_frequencies(s: str) -> int: Returns the sum of the frequencies of the most frequent character of every possible substring of s. >>> sum_of_most_frequent_character_frequencies(\\"a\\") == 1 >>> sum_of_most_frequent_character_frequencies(\\"ab\\") == 3 >>> sum_of_most_frequent_character_frequencies(\\"aaa\\") == 10 >>> sum_of_most_frequent_character_frequencies(\\"abb\\") == 8 >>> sum_of_most_frequent_character_frequencies(\\"abcd\\") == 10 >>> sum_of_most_frequent_character_frequencies(\\"bbbb\\") == 20 # Your code here","solution":"def sum_of_most_frequent_character_frequencies(s): Returns the sum of the frequencies of the most frequent character of every possible substring of s. total_sum = 0 n = len(s) # Iterate through all possible starting points of substrings for i in range(n): freq = [0] * 26 # There are 26 lowercase letters max_freq = 0 # Iterate through all possible ending points starting from i for j in range(i, n): char_index = ord(s[j]) - ord('a') freq[char_index] += 1 max_freq = max(max_freq, freq[char_index]) total_sum += max_freq return total_sum"},{"question":"def can_attend_all_meetings(meetings): Determine if a single person can attend all meetings without overlaps. Parameters: - meetings (list of tuple): List of tuples where each tuple represents a meeting with (startTime, endTime). Returns: - bool: True if a person can attend all meetings without any overlaps, False otherwise. >>> can_attend_all_meetings([]) True >>> can_attend_all_meetings([(0, 30)]) True >>> can_attend_all_meetings([(0, 30), (35, 50), (55, 70)]) True >>> can_attend_all_meetings([(0, 30), (25, 50), (55, 70)]) False >>> can_attend_all_meetings([(0, 30), (30, 50), (50, 70)]) True >>> can_attend_all_meetings([(0, 30), (25, 40), (35, 50)]) False >>> can_attend_all_meetings([(0, 20), (10, 30), (20, 40)]) False >>> can_attend_all_meetings([(30, 50), (0, 30)]) True >>> can_attend_all_meetings([(0, 10), (10, 20), (20, 30)]) True >>> can_attend_all_meetings([(0, 20), (0, 30)]) False","solution":"def can_attend_all_meetings(meetings): Determine if a single person can attend all meetings without overlaps. Parameters: - meetings (list of tuple): List of tuples where each tuple represents a meeting with (startTime, endTime). Returns: - bool: True if a person can attend all meetings without any overlaps, False otherwise. if not meetings: return True # Sort the meetings by start time meetings.sort(key=lambda x: x[0]) # Check for overlaps for i in range(1, len(meetings)): if meetings[i][0] < meetings[i-1][1]: return False return True"},{"question":"def largest_square_submatrix(mat: List[List[int]]) -> int: Find the side length of the largest square submatrix containing only 1s. >>> largest_square_submatrix([]) == 0 >>> largest_square_submatrix([[]]) == 0 >>> largest_square_submatrix([[0, 0], [0, 0]]) == 0 >>> largest_square_submatrix([[1, 1], [1, 1]]) == 2 >>> largest_square_submatrix([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 3 >>> largest_square_submatrix([[1, 0], [1, 1]]) == 1 >>> largest_square_submatrix([[0, 1], [1, 1]]) == 1 >>> largest_square_submatrix([ ... [1, 1, 0, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [0, 1, 1, 1] ... ]) == 3 >>> largest_square_submatrix([ ... [0, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 2 >>> largest_square_submatrix([[1, 1, 1]]) == 1 >>> largest_square_submatrix([[1], [1], [1]]) == 1","solution":"def largest_square_submatrix(mat): if not mat or not mat[0]: return 0 n = len(mat) m = len(mat[0]) # Initialize a DP array to store the size of the largest square submatrix ending at (i, j) dp = [[0] * m for _ in range(n)] max_side = 0 # Iterate through the matrix to fill the DP array for i in range(n): for j in range(m): if mat[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"[Completion Task in Python] def subarray_sum(nums: List[int], target: int) -> int: Given an array of integers nums and an integer target, return the number of non-empty subarrays whose sum is equal to target. A subarray is a contiguous part of the array. >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([1, 2, 3], 3) 2 >>> subarray_sum([1, -1, 0], 0) 3 >>> subarray_sum([1, 2, 3], 7) 0 >>> subarray_sum([2, 2, 2], 2) 3 >>> subarray_sum([100, 200, 300], 500) 1","solution":"def subarray_sum(nums, target): Returns the number of non-empty subarrays whose sum is equal to target. count = 0 current_sum = 0 sum_count = {0: 1} for num in nums: current_sum += num if (current_sum - target) in sum_count: count += sum_count[current_sum - target] if current_sum in sum_count: sum_count[current_sum] += 1 else: sum_count[current_sum] = 1 return count"},{"question":"from collections import deque, defaultdict from typing import List, Dict def topological_sort(graph: Dict[int, List[int]]) -> List[int]: Returns a valid topological sort order of tasks represented by the given DAG. The graph is represented as an adjacency list. >>> graph = {5: [2, 0], 4: [0, 1], 2: [3], 3: [1], 0: [], 1: []} >>> result = topological_sort(graph) >>> assert result.index(5) < result.index(2) >>> assert result.index(5) < result.index(0) >>> assert result.index(4) < result.index(0) >>> assert result.index(4) < result.index(1) >>> assert result.index(2) < result.index(3) >>> assert result.index(3) < result.index(1) >>> graph = {1: [2], 2: [3], 3: [4], 4: [2]} >>> result = topological_sort(graph) >>> assert result == [] # No valid topological sort due to the cycle >>> graph = {1: [], 2: [], 3: []} >>> result = topological_sort(graph) >>> assert len(result) == 3 >>> assert set(result) == {1, 2, 3} >>> graph = {1: []} >>> result = topological_sort(graph) >>> assert result == [1] >>> graph = {1: [2], 2: [], 3: [4], 4: []} >>> result = topological_sort(graph) >>> assert result.index(1) < result.index(2) >>> assert result.index(3) < result.index(4) >>> assert len(result) == 4","solution":"from collections import deque, defaultdict def topological_sort(graph): Returns a valid topological sort order of tasks represented by the given DAG. The graph is represented as an adjacency list. indegree = defaultdict(int) # To store the indegree of each node for nodes in graph.values(): for node in nodes: indegree[node] += 1 zero_indegree = deque() for node in graph.keys(): if indegree[node] == 0: zero_indegree.append(node) topo_order = [] while zero_indegree: current = zero_indegree.popleft() topo_order.append(current) for neighbor in graph[current]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: zero_indegree.append(neighbor) if len(topo_order) == len(graph): return topo_order else: return [] # If there’s a cycle, return an empty list indicating no valid order exists"},{"question":"from typing import List from heapq import heappush, heappop from collections import Counter def reorganizeString(s: str) -> str: Reorganize the string so that no two adjacent characters are the same. >>> reorganizeString(\\"aab\\") \\"aba\\" >>> reorganizeString(\\"aaab\\") \\"\\" >>> reorganizeString(\\"aabb\\") in [\\"abab\\", \\"baba\\"] >>> reorganizeString(\\"abc\\") in [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] >>> reorganizeString(\\"aaabbb\\") in [\\"ababab\\", \\"bababa\\"] >>> reorganizeString(\\"a\\") \\"a\\" >>> reorganizeString(\\"\\") \\"\\"","solution":"from heapq import heappush, heappop from collections import Counter def reorganizeString(s): Reorganize the string so that no two adjacent characters are the same. # Count the frequency of each character char_count = Counter(s) # Add all characters and their counts to a max heap max_heap = [] for char, count in char_count.items(): heappush(max_heap, (-count, char)) prev_char = None prev_count = 0 result = [] while max_heap: count, char = heappop(max_heap) result.append(char) # If the previous character's count is greater than 0, push it back to heap if prev_char and prev_count < 0: heappush(max_heap, (prev_count, prev_char)) prev_char = char prev_count = count + 1 # Decrement the count # Check if the result is valid if len(result) == len(s): return ''.join(result) else: return \\"\\""},{"question":"def split_string(s: str, delimiters: str) -> List[str]: Splits the string \`s\` using the characters in \`delimiters\` as delimiters and returns a list of non-empty substrings. >>> split_string(\\"hello,world;this|is:a=test\\", \\",;|:=\\") [\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\"] >>> split_string(\\"helloworld\\", \\",;|:=\\") [\\"helloworld\\"] >>> split_string(\\",;|:=\\", \\",;|:=\\") [] >>> split_string(\\"a,b;c:d|e\\", \\",;|:=\\") [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"] >>> split_string(\\"\\", \\",;|:=\\") [] >>> split_string(\\"a,,b;;c::d||e\\", \\",;|:=\\") [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"]","solution":"def split_string(s, delimiters): Splits the string \`s\` using the characters in \`delimiters\` as delimiters and returns a list of non-empty substrings. :param s: The string to be split :param delimiters: A string containing unique delimiter characters :return: A list of non-empty substrings import re # Create a regex pattern from the delimiters pattern = '[' + re.escape(delimiters) + ']' # Split the string using the regex pattern substrings = re.split(pattern, s) # Return list of non-empty substrings return [substring for substring in substrings if substring]"},{"question":"def can_rotate_to_goal(s: str, goal: str) -> bool: Determines if you can obtain \`goal\` by rotating \`s\` any number of times. >>> can_rotate_to_goal(\\"abcde\\", \\"cdeab\\") True >>> can_rotate_to_goal(\\"abcde\\", \\"abced\\") False >>> can_rotate_to_goal(\\"abcde\\", \\"abcdef\\") False >>> can_rotate_to_goal(\\"a\\", \\"a\\") True >>> can_rotate_to_goal(\\"\\", \\"\\") True","solution":"def can_rotate_to_goal(s, goal): Determines if you can obtain \`goal\` by rotating \`s\` any number of times. :param s: Original string :param goal: Target string after rotation :return: True if goal can be obtained by rotating s, False otherwise if len(s) != len(goal): return False return goal in (s + s)"},{"question":"def find_winners(arr): Returns a list of winners in the array. An element is considered a winner if it is greater than the previous and next elements. :param arr: List[int] - An array of distinct integers :return: List[int] - A list of winners","solution":"def find_winners(arr): Returns a list of winners in the array. An element is considered a winner if it is greater than the previous and next elements. :param arr: List[int] - An array of distinct integers :return: List[int] - A list of winners winners = [] n = len(arr) for i in range(1, n-1): if arr[i] > arr[i-1] and arr[i] > arr[i+1]: winners.append(arr[i]) return winners"},{"question":"def longest_substring_with_one_change(s: str) -> int: Given a binary string s, you are allowed to change at most one '0' to '1'. Returns the length of the longest contiguous substring of '1's in the resulting string. If the string already consists entirely of '1's, you may not make any change and should return the length of the string. >>> longest_substring_with_one_change(\\"11111\\") 5 >>> longest_substring_with_one_change(\\"11101\\") 5 >>> longest_substring_with_one_change(\\"101010\\") 3 >>> longest_substring_with_one_change(\\"01111\\") 5 >>> longest_substring_with_one_change(\\"11110\\") 5 >>> longest_substring_with_one_change(\\"0000\\") 1 >>> longest_substring_with_one_change(\\"\\") 0 >>> longest_substring_with_one_change(\\"0\\") 1 >>> longest_substring_with_one_change(\\"1\\") 1","solution":"def longest_substring_with_one_change(s): Given a binary string s, you are allowed to change at most one '0' to '1'. Returns the length of the longest contiguous substring of '1's in the resulting string. If the string already consists entirely of '1's, you may not make any change and should return the length of the string. n = len(s) if n == 0: return 0 # Check if the string already consists entirely of '1's if '0' not in s: return n max_len = 0 zero_count = 0 left = 0 for right in range(n): if s[right] == '0': zero_count += 1 while zero_count > 1: if s[left] == '0': zero_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def is_subsequence(small: str, large: str) -> bool: Check if 'small' is a subsequence of 'large'. >>> is_subsequence(\\"abc\\", \\"abcd\\") True >>> is_subsequence(\\"de\\", \\"efghi\\") True >>> is_subsequence(\\"gh\\", \\"efghi\\") False def count_subsequences(words1: list[str], words2: list[str]) -> int: Counts the number of strings in words1 which are subsequences of any strings in words2. >>> count_subsequences([\\"abc\\", \\"de\\", \\"f\\", \\"gh\\"], [\\"abcd\\", \\"efghi\\"]) 3 >>> count_subsequences([\\"a\\", \\"bc\\", \\"def\\"], [\\"abcdef\\"]) 3 def test_example_case(): words1 = [\\"abc\\", \\"de\\", \\"f\\", \\"gh\\"] words2 = [\\"abcd\\", \\"efghi\\"] assert count_subsequences(words1, words2) == 3 def test_empty_words1(): words1 = [] words2 = [\\"abcd\\", \\"efghi\\"] assert count_subsequences(words1, words2) == 0 def test_empty_words2(): words1 = [\\"abc\\", \\"de\\", \\"f\\", \\"gh\\"] words2 = [] assert count_subsequences(words1, words2) == 0 def test_no_subsequences(): words1 = [\\"abc\\", \\"de\\", \\"f\\", \\"gh\\"] words2 = [\\"xyz\\", \\"mnop\\"] assert count_subsequences(words1, words2) == 0 def test_all_subsequences(): words1 = [\\"a\\", \\"bc\\", \\"def\\"] words2 = [\\"abcdef\\"] assert count_subsequences(words1, words2) == 3 def test_partial_subsequences(): words1 = [\\"a\\", \\"bc\\", \\"def\\"] words2 = [\\"abc\\", \\"ef\\"] assert count_subsequences(words1, words2) == 2","solution":"def is_subsequence(small, large): Helper function to determine if 'small' is a subsequence of 'large'. it = iter(large) return all(char in it for char in small) def count_subsequences(words1, words2): Counts the number of strings in words1 which are subsequences of any strings in words2. count = 0 for word1 in words1: if any(is_subsequence(word1, word2) for word2 in words2): count += 1 return count"},{"question":"def farthest_building(heights: List[int], d: int) -> int: Determines the farthest building index that can be reached without moving more than \`d\` units horizontally and while adhering to the height difference constraint. Args: heights: List of building heights. d: Maximum allowable horizontal movement distance. Returns: The index of the farthest building that can be reached under the given constraints. >>> farthest_building([1, 2, 3, 4, 5], 10) 4 >>> farthest_building([5, 4, 3, 2, 1], 10) 4 >>> farthest_building([1, 2, 4, 5], 3) 1 >>> farthest_building([1, 2, 1, 2, 3, 2], 2) 2 >>> farthest_building([2, 1, 1, 1, 2, 1, 1], 3) 3 >>> farthest_building([1, 2, 3, 3, 5, 6], 10) 3 >>> farthest_building([1, 3, 5, 7, 9], 10) 0 >>> farthest_building([3], 5) 0 >>> farthest_building([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 0) 0 >>> farthest_building([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 5) 5","solution":"def farthest_building(heights, d): Determines the farthest building index that can be reached without moving more than \`d\` units horizontally and while adhering to the height difference constraint. Args: heights: List of building heights. d: Maximum allowable horizontal movement distance. Returns: The index of the farthest building that can be reached under the given constraints. max_index = 0 for i in range(len(heights)): if i > d: break if i > 0 and abs(heights[i] - heights[i - 1]) > 1: break max_index = i return max_index"},{"question":"def remove_duplicates(nums): Removes duplicates in place for a sorted array and returns the new length. :param nums: List[int] - A list of integers sorted in non-decreasing order. :return: int - The new length of the array after duplicates are removed. >>> remove_duplicates([1, 2, 3, 4]) 4 >>> remove_duplicates([1, 1, 2, 2, 3, 4, 4]) 4 >>> remove_duplicates([1, 1, 1, 1]) 1 >>> remove_duplicates([]) 0 >>> remove_duplicates([1]) 1","solution":"def remove_duplicates(nums): Removes duplicates in place for a sorted array and returns the new length. :param nums: List[int] - A list of integers sorted in non-decreasing order. :return: int - The new length of the array after duplicates are removed. if not nums: return 0 write_index = 1 # Index to write the next unique element for read_index in range(1, len(nums)): if nums[read_index] != nums[read_index - 1]: nums[write_index] = nums[read_index] write_index += 1 return write_index"},{"question":"from typing import List def is_possible_rearrangement(s: str, n: int, m: int) -> bool: Determine if it's possible to rearrange the characters of \`s\` such that every substring with length \`n\` has at least \`m\` distinct characters. Parameters: - s: the input string - n: the length of the substring - m: the minimum number of distinct characters in every substring of length \`n\` Returns: - True if the rearrangement is possible, False otherwise. import collections def test_is_possible_rearrangement_basic(): assert is_possible_rearrangement(\\"abcd\\", 3, 3) == True assert is_possible_rearrangement(\\"aabbcc\\", 3, 2) == True def test_is_possible_rearrangement_complex(): assert is_possible_rearrangement(\\"aabbcc\\", 4, 3) == True assert is_possible_rearrangement(\\"aabbcc\\", 4, 4) == False def test_is_possible_rearrangement_edge_cases(): assert is_possible_rearrangement(\\"aaa\\", 2, 2) == False assert is_possible_rearrangement(\\"abcd\\", 1, 1) == True assert is_possible_rearrangement(\\"aabbccddee\\", 3, 2) == True def test_is_possible_rearrangement_same_character(): assert is_possible_rearrangement(\\"aaaaa\\", 2, 2) == False assert is_possible_rearrangement(\\"aaaaa\\", 1, 1) == True","solution":"from collections import Counter def is_possible_rearrangement(s, n, m): Determine if it's possible to rearrange the characters of \`s\` such that every substring with length \`n\` has at least \`m\` distinct characters. Parameters: - s: the input string - n: the length of the substring - m: the minimum number of distinct characters in every substring of length \`n\` Returns: - True if the rearrangement is possible, False otherwise. if n < m: return False # It's not possible because there cannot be more distinct characters than the length of the substring. counter = Counter(s) # If the total number of characters in string \`s\` is less than \`n\`, it's not possible if len(s) < n: return False # Count the number of different characters in \`s\` distinct_char_count = len(counter) if distinct_char_count < m: return False # Not enough distinct characters to meet the requirement return True"},{"question":"def find_course_order(num_courses: int, prerequisites: List[List[int]]) -> List[int]: Determines the order of courses one should take to finish all courses. Args: num_courses (int): The total number of courses. prerequisites (list of list of int): Each inner list has two elements [a, b] meaning course b must be taken before course a. Returns: list of int: The order of courses to complete, or an empty list if it's not possible to complete all courses. >>> find_course_order(3, []) [0, 1, 2] >>> find_course_order(2, [[1, 0]]) [0, 1] >>> find_course_order(4, [[1, 0], [2, 0], [3, 1], [3, 2]]) in [[0, 1, 2, 3], [0, 2, 1, 3]] True >>> find_course_order(2, [[1, 0], [0, 1]]) [] >>> find_course_order(3, [[0, 1], [1, 2], [2, 0]]) []","solution":"from collections import defaultdict, deque def find_course_order(num_courses, prerequisites): Determines the order of courses one should take to finish all courses. Args: num_courses (int): The total number of courses. prerequisites (list of list of int): Each inner list has two elements [a, b] meaning course b must be taken before course a. Returns: list of int: The order of courses to complete, or an empty list if it's not possible to complete all courses. # Graph adjacency list representation graph = defaultdict(list) # In-degree of each course in_degree = {i: 0 for i in range(num_courses)} # Build graph and populate in-degree for dest, src in prerequisites: graph[src].append(dest) in_degree[dest] += 1 # Queue for courses with no prerequisites zero_in_degree_queue = deque([k for k in in_degree if in_degree[k] == 0]) order = [] while zero_in_degree_queue: node = zero_in_degree_queue.popleft() order.append(node) # Decrease the in-degree of neighboring courses for neighbor in graph[node]: in_degree[neighbor] -= 1 # If in-degree becomes zero, add to queue if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If the order contains all courses, return it if len(order) == num_courses: return order else: return []"},{"question":"def are_all_servers_connected(n: int, edges: List[List[int]]) -> bool: Determines if all servers are connected. :param n: Number of servers :param edges: List of edges where each edge is represented as [ui, vi] :return: True if all servers are connected, False otherwise >>> are_all_servers_connected(4, [[0, 1], [1, 2], [2, 3]]) True >>> are_all_servers_connected(4, [[0, 1], [1, 2], [2, 0], [1, 3]]) True >>> are_all_servers_connected(1, []) True >>> are_all_servers_connected(4, [[0, 1], [1, 2]]) False >>> are_all_servers_connected(5, [[0, 1], [1, 2], [2, 3]]) False >>> are_all_servers_connected(2, []) False >>> are_all_servers_connected(0, []) True >>> are_all_servers_connected(2, [[0, 1]]) True >>> are_all_servers_connected(3, [[1, 2]]) False","solution":"def are_all_servers_connected(n, edges): Determines if all servers are connected. :param n: Number of servers :param edges: List of edges where each edge is represented as [ui, vi] :return: True if all servers are connected, False otherwise if n <= 1: return True from collections import defaultdict, deque # Build adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # BFS to check connectivity visited = set() queue = deque([0]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return len(visited) == n"},{"question":"def reorder_string(s: str) -> str: Reorders the string such that all the lowercase letters come before any digits, while preserving the relative order among letters and digits. >>> reorder_string(\\"a1b2c3\\") \\"abc123\\" >>> reorder_string(\\"z1y2x3w4\\") \\"zyxw1234\\"","solution":"def reorder_string(s): Reorders the string such that all the lowercase letters come before any digits, while preserving the relative order among letters and digits. letters = [char for char in s if char.isalpha()] digits = [char for char in s if char.isdigit()] return ''.join(letters + digits)"},{"question":"def find_triplet_with_sum(arr, k): Determines if there exists a triplet in the sorted array \`arr\` that sums up to \`k\`. :param arr: List[int] - A sorted list of integers :param k: int - Target sum for the triplets :return: bool - True if such a triplet exists, otherwise False >>> find_triplet_with_sum([1, 2, 3, 4, 5], 9) True >>> find_triplet_with_sum([1, 2, 3, 4, 5], 20) False >>> find_triplet_with_sum([1], 1) False >>> find_triplet_with_sum([1, 2], 3) False >>> find_triplet_with_sum([-4, -1, 0, 2, 3, 5], 1) True >>> find_triplet_with_sum([-5, -4, -3, -2, -1], -9) True >>> find_triplet_with_sum([-1, 0, 1, 2], 0) True >>> find_triplet_with_sum([1, 1, 1, 2, 2, 3], 6) True >>> find_triplet_with_sum([1, 1, 1, 2, 2, 3], 10) False","solution":"def find_triplet_with_sum(arr, k): Determines if there exists a triplet in the sorted array \`arr\` that sums up to \`k\`. :param arr: List[int] - A sorted list of integers :param k: int - Target sum for the triplets :return: bool - True if such a triplet exists, otherwise False n = len(arr) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == k: return True elif current_sum < k: left += 1 else: right -= 1 return False"},{"question":"def can_finish_courses(num_courses: int, prerequisites: List[List[int]]) -> bool: Determine if it's possible to finish all courses given the prerequisites. :param num_courses: Number of courses :param prerequisites: List of prerequisite pairs [a_i, b_i] :return: True if it's possible to finish all courses, False otherwise >>> can_finish_courses(4, []) True >>> can_finish_courses(2, [[1, 0]]) True >>> can_finish_courses(2, [[1, 0], [0, 1]]) False >>> can_finish_courses(4, [[1, 0], [2, 1], [3, 2]]) True >>> can_finish_courses(4, [[1, 0], [2, 1], [3, 1], [1, 3]]) False >>> can_finish_courses(5, [[1, 4], [2, 4], [3, 1], [3, 2]]) True >>> can_finish_courses(6, [[1, 0], [2, 1], [4, 3], [5, 3]]) True >>> can_finish_courses(3, [[1, 0], [2, 0], [1, 0]]) True","solution":"def can_finish_courses(num_courses, prerequisites): Determine if it's possible to finish all courses given the prerequisites. :param num_courses: Number of courses :param prerequisites: List of prerequisite pairs [a_i, b_i] :return: True if it's possible to finish all courses, False otherwise from collections import deque, defaultdict # Create a list of incoming edges and an adjacency list indegree = [0] * num_courses adjacency_list = defaultdict(list) # Populate indegree and adjacency list for a, b in prerequisites: indegree[a] += 1 adjacency_list[b].append(a) # Use a queue to perform a topological sort queue = deque() # Add courses with no prerequisites to the queue for course in range(num_courses): if indegree[course] == 0: queue.append(course) taken_courses = 0 while queue: current_course = queue.popleft() taken_courses += 1 for neighbor in adjacency_list[current_course]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) return taken_courses == num_courses"},{"question":"def maxRectangleArea(heights: List[int]) -> int: Given an array of integers 'heights' representing the heights of buildings arranged in a line, calculate the area of the largest rectangle that can be formed by any contiguous subarray of these buildings. The area of the rectangle is determined by the shortest building in the subarray multiplied by the number of buildings in that subarray. >>> maxRectangleArea([2, 1, 5, 6, 2, 3]) == 10 >>> maxRectangleArea([5, 4, 3, 2, 1]) == 9 >>> maxRectangleArea([1, 2, 3, 4, 5]) == 9 >>> maxRectangleArea([2, 2, 2, 2, 2]) == 10 >>> maxRectangleArea([5]) == 5 >>> maxRectangleArea([2, 4, 2, 1]) == 6","solution":"def maxRectangleArea(heights): Given an array of integers 'heights' representing the heights of buildings arranged in a line, calculate the area of the largest rectangle that can be formed by any contiguous subarray of these buildings. The area of the rectangle is determined by the shortest building in the subarray multiplied by the number of buildings in that subarray. stack = [] max_area = 0 index = 0 while index < len(heights): # If the current building is taller than the building at stack top, push it to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest (or minimum height) building area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area, if needed max_area = max(max_area, area) # Now pop the remaining buildings from stack and calculate area with every popped building while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bst_to_gst(root: TreeNode) -> TreeNode: Convert a BST to a Greater Sum Tree where each node's value is replaced by the sum of all values greater than or equal to the node's value in the BST. :param TreeNode root: The root of the binary search tree. :return TreeNode: The root of the greater sum tree. def tree_to_list(root): Helper function to convert BST to a list via level-order traversal for easier testing. if not root: return [] result, queue = [], [root] while queue: node = queue.pop(0) if node: result.append(node.val) queue.append(node.left) queue.append(node.right) else: result.append(None) # Remove trailing Nones which are not necessary while result and result[-1] is None: result.pop() return result def test_bst_to_gst(): # Creating the BST used in the example root = TreeNode(4) root.left = TreeNode(1) root.right = TreeNode(6) root.left.left = TreeNode(0) root.left.right = TreeNode(2) root.left.right.right = TreeNode(3) root.right.left = TreeNode(5) root.right.right = TreeNode(7) root.right.right.right = TreeNode(8) # Converting the BST to the greater sum tree new_root = bst_to_gst(root) # Checking the expected structure and values of the greater sum tree expected_output = [30, 36, 21, 36, 35, 26, 15, None, None, None, 33, None, None, None, 8] assert tree_to_list(new_root) == expected_output def test_single_node(): root = TreeNode(10) new_root = bst_to_gst(root) assert tree_to_list(new_root) == [10] def test_empty_tree(): root = None new_root = bst_to_gst(root) assert tree_to_list(new_root) == [] def test_left_skewed_bst(): root = TreeNode(3) root.left = TreeNode(2) root.left.left = TreeNode(1) new_root = bst_to_gst(root) expected_output = [3, 5, None, 6] assert tree_to_list(new_root) == expected_output def test_right_skewed_bst(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) new_root = bst_to_gst(root) expected_output = [6, None, 5, None, 3] assert tree_to_list(new_root) == expected_output","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bst_to_gst(root): Convert a BST to a Greater Sum Tree where each node's value is replaced by the sum of all values greater than or equal to the node's value in the BST. :param TreeNode root: The root of the binary search tree. :return TreeNode: The root of the greater sum tree. def reverse_inorder_traversal(node, acc_sum): if node is None: return acc_sum # Traverse the right subtree acc_sum = reverse_inorder_traversal(node.right, acc_sum) # Update the node's value acc_sum += node.val node.val = acc_sum # Traverse the left subtree acc_sum = reverse_inorder_traversal(node.left, acc_sum) return acc_sum reverse_inorder_traversal(root, 0) return root"},{"question":"def max_visible_height(grid: List[List[int]]) -> int: Given a rows x cols matrix of integers representing building heights in a city, returns the maximum building height that can be visible from any of the four sides. >>> max_visible_height([[3, 5, 4], [2, 1, 6], [3, 8, 7]]) 8 >>> max_visible_height([[42]]) 42 >>> max_visible_height([[1, 2, 3, 4, 5]]) 5 >>> max_visible_height([[1], [2], [3], [4], [5]]) 5 >>> max_visible_height([[7, 1, 4], [6, 3, 5], [2, 8, 9]]) 9 >>> max_visible_height([[1, 2, 3], [8, 4, 6], [7, 5, 9]]) 9 >>> max_visible_height([]) 0 >>> max_visible_height([[]]) 0","solution":"def max_visible_height(grid): Given a rows x cols matrix of integers representing building heights in a city, returns the maximum building height that can be visible from any of the four sides. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) max_height = -1 # Check from north to south and south to north for c in range(cols): north_max = -1 south_max = -1 for r in range(rows): north_max = max(north_max, grid[r][c]) south_max = max(south_max, grid[rows-1-r][c]) max_height = max(max_height, north_max, south_max) # Check from west to east and east to west for r in range(rows): west_max = -1 east_max = -1 for c in range(cols): west_max = max(west_max, grid[r][c]) east_max = max(east_max, grid[r][cols-1-c]) max_height = max(max_height, west_max, east_max) return max_height"},{"question":"def find_indices_with_diff(nums, target): Find two distinct integers in 'nums' such that their difference equals 'target'. Parameters: nums (list): A list of integers. target (int): The target difference. Returns: list: A list containing the indices of the two numbers such that nums[i] - nums[j] = target. If no such pair exists, return an empty list. # Unit Tests from solution import find_indices_with_diff def test_found_pair(): assert find_indices_with_diff([1, 5, 3, 8], 2) in [[1, 2], [0, 2]] def test_no_pair(): assert find_indices_with_diff([1, 2, 3], 10) == [] def test_multiple_pairs(): result = find_indices_with_diff([1, 4, 6, 8], 2) assert result in [[0, 1], [1, 2], [2, 3]] def test_negative_numbers(): assert find_indices_with_diff([-5, -2, 3, 7], -3) == [0, 1] def test_single_element_target_zero(): assert find_indices_with_diff([1], 0) == [] def test_empty_array(): assert find_indices_with_diff([], 5) == [] def test_large_numbers(): assert find_indices_with_diff([1000000, 500000, 2000000], 1500000) == [1, 2] def test_pair_with_zero(): assert find_indices_with_diff([0, 2, -2], 2) == [0, 1] or [1, 2] def test_pair_with_target_zero(): assert find_indices_with_diff([2, 3, 4, 4], 0) == [2, 3]","solution":"def find_indices_with_diff(nums, target): Find two distinct integers in 'nums' such that their difference equals 'target'. Parameters: nums (list): A list of integers. target (int): The target difference. Returns: list: A list containing the indices of the two numbers such that nums[i] - nums[j] = target. If no such pair exists, return an empty list. num_indices = {} for i, num in enumerate(nums): if num - target in num_indices: return [num_indices[num - target], i] if num + target in num_indices: return [num_indices[num + target], i] num_indices[num] = i return []"},{"question":"import math from typing import List, Tuple def euclidean_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float: Calculate the Euclidean distance between two points p1 and p2. return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) def kth_closest_pair(friends: List[Tuple[int, int]], k: int) -> List[int]: Find the k-th closest pair of friends based on the Euclidean distance between each pair of friends. Parameters: friends(List[Tuple[int, int]]): A list of tuples representing the position of each friend on a 2D grid. k (int): The k-th closest pair to find. Returns: List[int]: A list containing the indices of the friends in the k-th closest pair. >>> kth_closest_pair([(0, 0), (1, 1), (2, 2)], 1) [0, 1] >>> kth_closest_pair([(0, 0), (1, 1), (2, 2)], 2) [1, 2] >>> kth_closest_pair([(0, 0), (1, 0), (1, 1)], 1) [0, 1] >>> kth_closest_pair([(0, 0), (4, 3), (3, 4), (0, 5)], 2) [2, 3] >>> kth_closest_pair([(0, 0), (1, 2), (1, 3), (4, 0)], 1) [1, 2] # Unit tests can be written as follows def test_kth_closest_pair(): assert kth_closest_pair([(0, 0), (1, 1), (2, 2)], 1) == [0, 1] assert kth_closest_pair([(0, 0), (1, 1), (2, 2)], 2) == [1, 2] assert kth_closest_pair([(0, 0), (1, 0), (1, 1)], 1) == [0, 1] assert kth_closest_pair([(0, 0), (4, 3), (3, 4), (0, 5)], 2) == [2, 3] assert kth_closest_pair([(0, 0), (1, 2), (1, 3), (4, 0)], 1) == [1, 2]","solution":"import math from itertools import combinations def euclidean_distance(p1, p2): Calculate the Euclidean distance between two points p1 and p2. return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) def kth_closest_pair(friends, k): Find the k-th closest pair of friends based on the Euclidean distance. distances = [] # Generate all pairs of friends for i, j in combinations(range(len(friends)), 2): dist = euclidean_distance(friends[i], friends[j]) distances.append((dist, i, j)) # Sort based on the distance, and then on the indices if there is a tie distances.sort(key=lambda x: (x[0], x[1], x[2])) # Get the k-th (1-indexed) closest pair closest_pair = distances[k-1] return [closest_pair[1], closest_pair[2]]"},{"question":"def longest_threshold_subsequence(arr: List[int], threshold: int) -> int: Returns the length of the longest threshold subsequence of arr such that the sum of its elements does not exceed threshold. >>> longest_threshold_subsequence([1, 2, 3, 4, 5], 10) 4 >>> longest_threshold_subsequence([10, 20, 30], 5) 0 >>> longest_threshold_subsequence([5], 10) 1 >>> longest_threshold_subsequence([15], 10) 0 >>> longest_threshold_subsequence([1, 2, 3, 9, 10], 6) 3 >>> longest_threshold_subsequence([], 10) 0 >>> longest_threshold_subsequence([4, 4, 4, 4], 4) 1 >>> longest_threshold_subsequence([1, 2, 3], 0) 0","solution":"def longest_threshold_subsequence(arr, threshold): Returns the length of the longest threshold subsequence of arr such that the sum of its elements does not exceed threshold. arr.sort() subseq_sum = 0 length = 0 for num in arr: if subseq_sum + num <= threshold: subseq_sum += num length += 1 else: break return length"},{"question":"def minimize_lexicographical_string(s: str, k: int) -> str: Constructs a new string by concatenating exactly \`k\` substrings from \`s\` such that the lexicographical order of the new string is minimized. Parameters: s (str): input string consisting of lowercase English letters k (int): number of substrings to concatenate Returns: str: the minimized lexicographical string >>> minimize_lexicographical_string(\\"azb\\", 2) 'az' >>> minimize_lexicographical_string(\\"abcddcba\\", 3) 'abc' >>> minimize_lexicographical_string(\\"xyz\\", 3) 'xyz' >>> minimize_lexicographical_string(\\"zabcde\\", 2) 'ab' >>> minimize_lexicographical_string(\\"zebra\\", 3) 'bra' >>> minimize_lexicographical_string(\\"aaaaaaa\\", 3) 'aaa' >>> minimize_lexicographical_string(\\"bbbbb\\", 2) 'bb' >>> minimize_lexicographical_string(\\"a\\", 1) 'a' >>> minimize_lexicographical_string(\\"z\\", 1) 'z' >>> minimize_lexicographical_string(\\"abacabadabacaba\\", 4) 'abac' >>> minimize_lexicographical_string(\\"abcdefghijklmnopqrstuvwxyz\\", 5) 'abcde'","solution":"def minimize_lexicographical_string(s, k): Constructs a new string by concatenating exactly \`k\` substrings from \`s\` such that the lexicographical order of the new string is minimized. Parameters: s (str): input string consisting of lowercase English letters k (int): number of substrings to concatenate Returns: str: the minimized lexicographical string n = len(s) minimized_substr = [] for i in range(n - k + 1): minimized_substr.append(s[i: i + k]) return min(minimized_substr)"},{"question":"def max_profit(nums: List[int]) -> int: Returns the maximum profit the company can achieve without working two consecutive days. >>> max_profit([1, 2, 3, 1]) 4 >>> max_profit([2, 7, 9, 3, 1]) 12 >>> max_profit([3]) 3 >>> max_profit([-1]) 0 >>> max_profit([]) 0 >>> max_profit([-1, -2, -3, -4]) 0 >>> max_profit([-1, 1, -3, -4, 5]) 6 >>> max_profit([3, 2, 5, 10, 7]) 15 >>> max_profit([1, 15, 7, 10, 8]) 25","solution":"def max_profit(nums): Returns the maximum profit the company can achieve without working two consecutive days. if not nums: return 0 n = len(nums) if n == 1: return max(0, nums[0]) dp = [0] * n dp[0] = max(0, nums[0]) dp[1] = max(dp[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]) return dp[-1]"},{"question":"def has_cycle(graph: list[list[int]]) -> bool: Determines if there is a cycle in an undirected graph. Parameters: graph (list[list[int]]): The adjacency list of the graph. Returns: bool: True if there is at least one cycle in the graph, False otherwise. Example: >>> has_cycle([[1, 2], [0, 3], [0, 3], [1, 2]]) True >>> has_cycle([[1], [0, 2], [1]]) False # Your code here def test_cycle_present(): graph = [ [1, 2], [0, 3], [0, 3], [1, 2] ] assert has_cycle(graph) == True def test_no_cycle(): graph = [ [1], [0, 2], [1] ] assert has_cycle(graph) == False def test_single_node_no_cycle(): graph = [ [] ] assert has_cycle(graph) == False def test_disconnected_graph_with_cycle(): graph = [ [1], [0, 2, 3], [1], [1, 4], [3] ] assert has_cycle(graph) == False def test_disconnected_graph_no_cycle_with_multiple_components(): graph = [ [1, 2], [0], [0], [4], [3, 5], [4] ] assert has_cycle(graph) == False def test_cycle_in_one_component(): graph = [ [1, 2], [0, 3], [0, 3], [1, 2], [5], [4] ] assert has_cycle(graph) == True def test_large_graph_with_cycle(): graph = [ [1, 2], # 0 [0, 3, 4], # 1 [0, 4], # 2 [1, 5], # 3 [1, 2, 5], # 4 [3, 4, 6], # 5 [5] # 6 ] assert has_cycle(graph) == True def test_large_graph_no_cycle(): graph = [ [1, 2], # 0 [0, 3], # 1 [0, 4], # 2 [1, 5], # 3 [2, 6], # 4 [3], # 5 [4] # 6 ] assert has_cycle(graph) == False","solution":"def has_cycle(graph: list[list[int]]) -> bool: Determines if there is a cycle in an undirected graph. Parameters: graph (list[list[int]]): The adjacency list of the graph. Returns: bool: True if there is at least one cycle in the graph, False otherwise. visited = [False] * len(graph) def dfs(v, parent): visited[v] = True for neighbour in graph[v]: if not visited[neighbour]: if dfs(neighbour, v): return True elif neighbour != parent: return True return False for node in range(len(graph)): if not visited[node]: # If the node hasn't been visited yet. if dfs(node, -1): # We use -1 as the parent of the root node. return True return False"},{"question":"from typing import List, Tuple def has_cycle_with_exact_weight(edges: List[Tuple[int, int, int]], N: int, k: int) -> bool: Determine if there is a cycle in the network that includes node 1 and has the total weight of edges exactly equal to k. >>> has_cycle_with_exact_weight([], 2, 3) False >>> has_cycle_with_exact_weight([(1, 2, 3)], 2, 3) False >>> has_cycle_with_exact_weight([(1, 2, 3), (2, 3, 1), (3, 1, 2)], 3, 6) True >>> has_cycle_with_exact_weight([(2, 3, 2), (3, 4, 3), (4, 2, 1)], 4, 6) False >>> has_cycle_with_exact_weight([(1, 2, 1), (2, 3, 1), (3, 1, 1)], 3, 4) False >>> has_cycle_with_exact_weight([(1, 2, 3), (2, 3, 1), (3, 4, 2), (4, 1, 2)], 4, 8) True","solution":"def has_cycle_with_exact_weight(edges, N, k): from collections import defaultdict graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) def dfs(node, parent, current_sum, target, visited): if visited[node]: return current_sum == target visited[node] = True for neighbor, weight in graph[node]: if neighbor != parent: if dfs(neighbor, node, current_sum + weight, target, visited): return True visited[node] = False return False visited = [False] * (N + 1) return dfs(1, -1, 0, k, visited)"},{"question":"from typing import List def remove_hash(s: str, words: List[str]) -> List[str]: Removes all hash(#) characters from the string s and returns the array of words in the same order they were concatenated. >>> remove_hash(\\"#hello#world#this#is#a#test#\\", [\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\"]) [\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\"] >>> remove_hash(\\"helloworldthisisatest\\", [\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\"]) [\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\"] >>> remove_hash(\\"#hello#\\", [\\"hello\\"]) [\\"hello\\"] >>> remove_hash(\\"\\", [\\"\\"]) [\\"\\"] >>> remove_hash(\\"h#e#l#l#o#w#o#r#l#d\\", [\\"hello\\", \\"world\\"]) [\\"hello\\", \\"world\\"] >>> remove_hash(\\"12#34#56#78#9\\", [\\"12\\", \\"34\\", \\"56\\", \\"78\\", \\"9\\"]) [\\"12\\", \\"34\\", \\"56\\", \\"78\\", \\"9\\"]","solution":"from typing import List def remove_hash(s: str, words: List[str]) -> List[str]: Removes all hash(#) characters from the string s and returns the array of words in the same order they were concatenated. cleaned_string = s.replace(\\"#\\", \\"\\") result = [] start = 0 for word in words: length = len(word) result.append(cleaned_string[start:start+length]) start += length return result"},{"question":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def preorderTraversal(root: TreeNode) -> List[int]: Given the root of a binary tree, return the preorder traversal of its nodes' values. >>> preorderTraversal(None) == [] >>> preorderTraversal(TreeNode(1)) == [1] >>> preorderTraversal(TreeNode(1, TreeNode(2), TreeNode(3))) == [1, 2, 3]","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def preorderTraversal(root: TreeNode) -> List[int]: def traverse(node): if node: result.append(node.val) traverse(node.left) traverse(node.right) result = [] traverse(root) return result"},{"question":"def longest_subarray_after_flip(arr): Returns the length of the longest contiguous subarray of 1s after flipping exactly one 0 to 1 or one 1 to 0. >>> longest_subarray_after_flip([1, 1, 1, 1]) 4 >>> longest_subarray_after_flip([0, 0, 0, 0]) 1 >>> longest_subarray_after_flip([1, 0, 1, 1, 0, 1]) 4 >>> longest_subarray_after_flip([0]) 1 >>> longest_subarray_after_flip([1]) 1 >>> longest_subarray_after_flip([1, 0, 1, 0, 1, 0, 1]) 3 >>> longest_subarray_after_flip([0, 1, 0, 0, 1, 0, 0, 0]) 2 >>> longest_subarray_after_flip([0, 1, 1, 1, 1, 0]) 5","solution":"def longest_subarray_after_flip(arr): Returns the length of the longest contiguous subarray of 1s after flipping exactly one 0 to 1 or one 1 to 0. max_len = 0 zero_count = 0 left = 0 for right in range(len(arr)): if arr[right] == 0: zero_count += 1 while zero_count > 1: if arr[left] == 0: zero_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"from typing import List def count_permutations(s: str) -> int: Returns the number of distinct permutations of string s. def test_all_unique(): assert count_permutations(\\"abc\\") == 6 def test_all_same(): assert count_permutations(\\"aaa\\") == 1 def test_two_same_one_different(): assert count_permutations(\\"aab\\") == 3 def test_mix_characters(): assert count_permutations(\\"aabb\\") == 6 def test_multiple_same_characters(): assert count_permutations(\\"aaabb\\") == 10 def test_empty_string(): assert count_permutations(\\"\\") == 1 def test_single_character(): assert count_permutations(\\"x\\") == 1","solution":"from math import factorial from collections import Counter def count_permutations(s): Returns the number of distinct permutations of string s. # Count the frequency of each character in the string freq = Counter(s) # Calculate the factorial of the length of the string n = len(s) total_permutations = factorial(n) # Divide by the factorial of each frequency to avoid overcounting permutations with identical characters for count in freq.values(): total_permutations //= factorial(count) return total_permutations"},{"question":"from typing import List from collections import deque def shortest_path_in_maze(grid: List[List[int]]) -> int: Returns the length of the shortest path from the top-left corner to the bottom-right corner in a maze grid. If no such path exists, returns -1. >>> shortest_path_in_maze([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 5 >>> shortest_path_in_maze([ ... [0, -1, 0], ... [0, -1, 0], ... [0, 0, 0] ... ]) == 5 >>> shortest_path_in_maze([ ... [-1, 0], ... [0, 0] ... ]) == -1 >>> shortest_path_in_maze([ ... [0, 0], ... [0, -1] ... ]) == -1 >>> shortest_path_in_maze([ ... [0, -1], ... [-1, 0] ... ]) == -1 >>> shortest_path_in_maze([ ... [0] ... ]) == 1 >>> shortest_path_in_maze([ ... [-1] ... ]) == -1","solution":"from collections import deque def shortest_path_in_maze(grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner in a maze grid. If no such path exists, returns -1. n = len(grid) if grid[0][0] == -1 or grid[n-1][n-1] == -1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if row == n-1 and col == n-1: return dist for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < n and grid[new_row][new_col] == 0 and (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col, dist + 1)) return -1"},{"question":"from typing import List def min_new_bridges(intervals: List[List[int]]) -> int: Given an array of intervals representing highway bridges, return the minimum number of new bridges required to make the entire highway passable without any gap. >>> min_new_bridges([[1, 3], [6, 9], [11, 13]]) 2 >>> min_new_bridges([[1, 5], [5, 10], [10, 15]]) 0 >>> min_new_bridges([]) 0 >>> min_new_bridges([[1, 5]]) 0 >>> min_new_bridges([[1, 5], [4, 10], [15, 20]]) 1","solution":"from typing import List def min_new_bridges(intervals: List[List[int]]) -> int: if not intervals: return 0 # Sort intervals by their start time intervals.sort() # Initialize gap count gaps = 0 # Iterate through sorted intervals and check for gaps for i in range(1, len(intervals)): # If there's a gap between the end of the previous bridge and the start of the current one if intervals[i][0] > intervals[i-1][1]: gaps += 1 return gaps"},{"question":"from typing import List, Tuple from collections import defaultdict, deque def minimum_time_required(n: int, time: List[int], dependencies: List[Tuple[int, int]]) -> int: Determine the minimum total time required to solve all problems given dependencies. Each problem has an individual time limit and dependencies which need to be resolved before solving the problem. Args: n (int): The number of problems. time (List[int]): An array where time[i] is the time limit to solve problem i. dependencies (List[Tuple[int, int]]): A list of pairs [a, b] indicating that problem 'a' must be solved before problem 'b'. Returns: int: The minimum total time required to solve all problems or -1 if it is impossible due to cyclical dependencies. Examples: >>> minimum_time_required(3, [3, 2, 5], []) 5 >>> minimum_time_required(3, [3, 2, 5], [[0, 1], [1, 2]]) 10 >>> minimum_time_required(3, [3, 2, 5], [[0, 1], [1, 2], [2, 0]]) -1 >>> minimum_time_required(4, [1, 2, 3, 4], [[0, 2], [1, 2], [2, 3]]) 9","solution":"from collections import defaultdict, deque def minimum_time_required(n, time, dependencies): # Create an adjacency list for the problems adj_list = defaultdict(list) in_degree = [0] * n # Build the graph and in-degree count for a, b in dependencies: adj_list[a].append(b) in_degree[b] += 1 # Initialize a queue and add all nodes with zero in-degree queue = deque() for i in range(n): if in_degree[i] == 0: queue.append(i) # Track the total time required total_time = [0] * n while queue: node = queue.popleft() for neighbor in adj_list[node]: in_degree[neighbor] -= 1 total_time[neighbor] = max(total_time[neighbor], total_time[node] + time[node]) if in_degree[neighbor] == 0: queue.append(neighbor) # Check if there's any cyclic dependency if any(in_degree): return -1 # The answer is the maximum total time taken to solve any problem return max(total_time[i] + time[i] for i in range(n))"},{"question":"def word_weights(words: List[str]) -> List[int]: Given a list of words, return a list of integers representing the weight of each word. Weight of a word is defined as the total number of distinct characters it contains. >>> word_weights([\\"apple\\"]) == [4] >>> word_weights([\\"apple\\", \\"banana\\", \\"cherry\\"]) == [4, 3, 5] >>> word_weights([\\"\\"]) == [0] >>> word_weights([\\"test\\", \\"test\\", \\"test\\"]) == [3, 3, 3] >>> word_weights([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"]) == [1, 2, 3, 4] >>> word_weights([\\"a\\", \\"b\\", \\"c\\"]) == [1, 1, 1] >>> word_weights([\\"aaa\\", \\"bbb\\", \\"ccc\\"]) == [1, 1, 1] >>> word_weights([\\"aA\\", \\"Bb\\", \\"Cc\\"]) == [2, 2, 2]","solution":"def word_weights(words): Given a list of words, return a list of integers representing the weight of each word. Weight of a word is defined as the total number of distinct characters it contains. return [len(set(word)) for word in words]"},{"question":"def min_operations(initialState: str, finalState: str) -> int: Calculates the minimum number of operations required to transform initialState into finalState by moving any character to the front. >>> min_operations(\\"abc\\", \\"bca\\") 2 >>> min_operations(\\"abcdef\\", \\"fedcba\\") 5 >>> min_operations(\\"abc\\", \\"def\\") -1","solution":"def min_operations(initialState, finalState): if sorted(initialState) != sorted(finalState): return -1 n = len(initialState) ops = 0 j = n - 1 for i in range(n - 1, -1, -1): if initialState[i] == finalState[j]: j -= 1 else: ops += 1 return ops"},{"question":"def find_missing_number(nums: List[int]) -> int: Returns the missing number in the list of integers from 1 to n. >>> find_missing_number([1, 2, 4, 5, 6]) 3 >>> find_missing_number([2, 3, 4, 5, 6, 7, 8, 9]) 1 >>> find_missing_number([1, 2, 3, 4, 5, 6, 7, 8]) 9 >>> find_missing_number([1]) 2 >>> find_missing_number([2]) 1 >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) 6","solution":"def find_missing_number(nums): Returns the missing number in the list of integers from 1 to n. n = len(nums) + 1 total_sum = n * (n + 1) // 2 actual_sum = sum(nums) return total_sum - actual_sum"},{"question":"def trapRainwater(heights: List[int]) -> int: Calculate the total amount of rainwater that can be trapped after it rains. Parameters: heights (list): A list of integers representing the heights of buildings. Returns: int: Total amount of trapped rainwater. >>> trapRainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trapRainwater([4, 2, 0, 3, 2, 5]) 9 >>> trapRainwater([4, 2, 3]) 1 >>> trapRainwater([]) 0 >>> trapRainwater([1, 1, 1, 1]) 0 >>> trapRainwater([5, 4, 1, 2]) 1 >>> trapRainwater([0]) 0 >>> trapRainwater([2, 0, 2]) 2","solution":"def trapRainwater(heights): Calculates the total amount of rainwater trapped between the buildings. Parameters: heights (list): A list of integers representing the heights of buildings. Returns: int: Total amount of trapped rainwater. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"from typing import List def min_steps(grid: List[List[int]], k: int) -> int: Given a 2D grid 'grid' of size n x m and a height difference threshold 'k', return the minimum number of steps required to reach the bottom-right corner of the grid from the top-left corner. If it is not possible, return -1. >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> min_steps(grid, 3) 4 >>> grid = [ ... [1, 2, 3], ... [10, 5, 6], ... [7, 8, 9] ... ] >>> min_steps(grid, 2) -1 >>> grid = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> min_steps(grid, 0) 4 >>> grid = [ ... [1, 5, 2], ... [2, 3, 6], ... [1, 7, 9] ... ] >>> min_steps(grid, 10) 4 >>> grid = [[1]] >>> min_steps(grid, 0) 0","solution":"from collections import deque def min_steps(grid, k): Given a 2D grid 'grid' of size n x m and a height difference threshold 'k', return the minimum number of steps required to reach the bottom-right corner of the grid from the top-left corner. If it is not possible, return -1. def is_within_bounds(x, y, n, m): return 0 <= x < n and 0 <= y < m n = len(grid) m = len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == n - 1 and y == m - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_within_bounds(nx, ny, n, m) and (nx, ny) not in visited: if abs(grid[nx][ny] - grid[x][y]) <= k: queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return -1"},{"question":"def shortest_path_with_one_wall_break(grid: List[List[str]]) -> int: Find the shortest path from top-left to bottom-right in a labyrinth where you can break up to one wall. Parameters: grid (List[List[str]]): 2D list representing the labyrinth. Returns: int: Length of the shortest path or -1 if no such path exists. >>> grid1 = [[\\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\"]] >>> shortest_path_with_one_wall_break(grid1) 5 >>> grid2 = [[\\"0\\", \\"1\\", \\"0\\"], [\\"0\\", \\"1\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\"]] >>> shortest_path_with_one_wall_break(grid2) 5 >>> grid3 = [[\\"0\\", \\"1\\", \\"0\\"], [\\"1\\", \\"1\\", \\"1\\"], [\\"0\\", \\"1\\", \\"0\\"]] >>> shortest_path_with_one_wall_break(grid3) -1 >>> grid4 = [[\\"0\\", \\"1\\", \\"1\\", \\"0\\"], [\\"0\\", \\"0\\", \\"1\\", \\"0\\"], [\\"1\\", \\"1\\", \\"1\\", \\"1\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\"]] >>> shortest_path_with_one_wall_break(grid4) 7 >>> grid5 = [[\\"1\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\"]] >>> shortest_path_with_one_wall_break(grid5) -1 >>> grid6 = [[\\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"1\\"]] >>> shortest_path_with_one_wall_break(grid6) -1","solution":"from collections import deque def shortest_path_with_one_wall_break(grid): Function to find the shortest path from top-left to bottom-right in a labyrinth where you can break up to one wall. Parameters: grid (List[List[str]]): 2D list representing the labyrinth. Returns: int: Length of the shortest path or -1 if no such path exists. m, n = len(grid), len(grid[0]) if not grid or grid[0][0] == '1' or grid[m-1][n-1] == '1': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1, 0)]) # (x, y, distance, wall_broken) visited = set((0, 0, 0)) while queue: x, y, distance, wall_broken = queue.popleft() if (x, y) == (m - 1, n - 1): return distance for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: if grid[nx][ny] == '0' and (nx, ny, wall_broken) not in visited: visited.add((nx, ny, wall_broken)) queue.append((nx, ny, distance + 1, wall_broken)) elif grid[nx][ny] == '1' and wall_broken == 0 and (nx, ny, 1) not in visited: visited.add((nx, ny, 1)) queue.append((nx, ny, distance + 1, 1)) return -1"},{"question":"def max_non_overlapping_sessions(sessions): Returns the maximum number of non-overlapping sessions that can be attended. Parameters: sessions (List[List[int]]): A list of [start, end] time pairs for each session. Returns: int: The maximum number of non-overlapping sessions. >>> max_non_overlapping_sessions([[1,3],[2,4],[3,5]]) 2 >>> max_non_overlapping_sessions([[1,2],[2,3],[3,4],[4,5]]) 4 >>> max_non_overlapping_sessions([]) 0 >>> max_non_overlapping_sessions([[1, 4], [2, 5], [3, 6]]) 1 >>> max_non_overlapping_sessions([[1, 2], [2, 3], [1, 3], [3, 4]]) 3 >>> max_non_overlapping_sessions([[1, 2], [1, 2], [1, 2]]) 1 >>> max_non_overlapping_sessions([[1, 1], [2, 2], [3, 3]]) 3","solution":"def max_non_overlapping_sessions(sessions): Returns the maximum number of non-overlapping sessions that can be attended. Parameters: sessions (List[List[int]]): A list of [start, end] time pairs for each session. Returns: int: The maximum number of non-overlapping sessions. # Sort the sessions based on their end times sessions.sort(key=lambda x: x[1]) # Initialize the end time of the last attended session to a very small value last_end_time = float('-inf') max_sessions = 0 for start, end in sessions: if start >= last_end_time: # Attend this session last_end_time = end max_sessions += 1 return max_sessions"},{"question":"def min_operations_to_reach_sum(arr: List[int], k: int, x: int) -> int: Returns the minimum number of operations needed to make the sum of any 'k' consecutive elements in the array greater than or equal to 'x'. Returns -1 if it's not possible to achieve the goal. >>> min_operations_to_reach_sum([1, 2, 3, 4, 5], 3, 9) == 0 >>> min_operations_to_reach_sum([5, 1, 3, 2, 4], 3, 8) == 0 >>> min_operations_to_reach_sum([4, 5, 1, 1, 1, 1, 1], 4, 10) == 0 >>> min_operations_to_reach_sum([1, 2, 3, 4], 3, 15) == -1 >>> min_operations_to_reach_sum([1, 1, 1, 1], 2, 4) == -1 >>> min_operations_to_reach_sum([1, 1, 1, 1, 1, 1], 1, 2) == -1 >>> min_operations_to_reach_sum([10], 1, 10) == 0 >>> min_operations_to_reach_sum([], 1, 1) == -1 >>> min_operations_to_reach_sum([10, 20, 30], 2, 40) == 0 >>> min_operations_to_reach_sum([5, 5, 5, 5, 5], 5, 25) == 0 >>> min_operations_to_reach_sum([5, 5, 5, 5, 5, 5], 1, 6) == -1","solution":"def min_operations_to_reach_sum(arr, k, x): Returns the minimum number of operations needed to make the sum of any k consecutive elements in the array greater than or equal to x. Return -1 if it's not possible to achieve the goal. n = len(arr) if k > n: return -1 # Compute initial sum of first k elements current_sum = sum(arr[:k]) if current_sum >= x: return 0 # Find the max sum of k consecutive elements by shifting window max_sum = current_sum for i in range(1, n - k + 1): current_sum = current_sum - arr[i - 1] + arr[i + k - 1] max_sum = max(max_sum, current_sum) if max_sum >= x: return 0 else: return -1"},{"question":"def maxEvents(events: List[List[int]]) -> int: Returns the maximum number of events that can be attended. >>> maxEvents([[1, 2], [3, 4], [5, 6]]) == 3 >>> maxEvents([[1, 2], [2, 3], [3, 4]]) == 3 >>> maxEvents([[1, 4], [2, 5], [3, 6]]) == 3 >>> maxEvents([[1, 1], [2, 2], [3, 3]]) == 3 >>> maxEvents([[1, 1], [1, 1], [1, 1]]) == 1 >>> maxEvents([[1, 2], [2, 3], [3, 3]]) == 3 >>> maxEvents([]) == 0 >>> maxEvents([[1, 100000]]) == 1 >>> maxEvents([[1, 100], [101, 200], [201, 300]]) == 3","solution":"def maxEvents(events): Returns the maximum number of events that can be attended. events.sort(key=lambda x: x[1]) # Sort events by their end days. attended_days = set() for event in events: for day in range(event[0], event[1] + 1): if day not in attended_days: attended_days.add(day) break return len(attended_days)"},{"question":"class BinaryTree: Binary tree class implementing methods to add nodes, get leaf nodes, and check if the tree is balanced. def add(self, value: int): Adds a node with the given value to the binary tree. pass def getLeaves(self) -> List[int]: Returns a list of all leaf nodes' values of the binary tree. pass def isBalanced(self) -> bool: Returns True if the binary tree is balanced, and False otherwise. pass from solution import BinaryTree def test_add_and_get_leaves(): bt = BinaryTree() bt.add(10) bt.add(5) bt.add(15) bt.add(3) bt.add(7) bt.add(12) bt.add(17) assert set(bt.getLeaves()) == {3, 7, 12, 17} def test_is_balanced_empty_tree(): bt = BinaryTree() assert bt.isBalanced() == True def test_is_balanced_single_node(): bt = BinaryTree() bt.add(10) assert bt.isBalanced() == True def test_is_balanced_balanced_tree(): bt = BinaryTree() bt.add(10) bt.add(5) bt.add(15) bt.add(3) bt.add(7) bt.add(12) bt.add(17) assert bt.isBalanced() == True def test_is_balanced_unbalanced_tree(): bt = BinaryTree() bt.add(10) bt.add(5) bt.add(4) bt.add(3) assert bt.isBalanced() == False","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def add(self, value): Adds a node with the given value to the binary tree. if not self.root: self.root = TreeNode(value) else: self._add_recursive(self.root, value) def _add_recursive(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._add_recursive(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._add_recursive(node.right, value) def getLeaves(self): Returns a list of all leaf nodes' values of the binary tree. leaves = [] self._collect_leaves(self.root, leaves) return leaves def _collect_leaves(self, node, leaves): if node is not None: if node.left is None and node.right is None: leaves.append(node.value) if node.left: self._collect_leaves(node.left, leaves) if node.right: self._collect_leaves(node.right, leaves) def isBalanced(self): Returns True if the binary tree is balanced, and False otherwise. def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) balanced = abs(left_height - right_height) <= 1 return max(left_height, right_height) + 1, balanced and left_balanced and right_balanced _, is_balanced = check_balance(self.root) return is_balanced"},{"question":"def minimum_difference_partition(transactions: List[int]) -> int: Segments a list of customer transactions into 2 groups such that the difference between the sum of transactions in each group is minimized and returns the minimal difference. >>> minimum_difference_partition([5]) == 5 >>> minimum_difference_partition([1, 2]) == 1 >>> minimum_difference_partition([1, 1, 1, 1, 1, 1, 1, 1]) == 0 >>> minimum_difference_partition([10, 20, 30, 40, 50]) == 10 >>> minimum_difference_partition([3, 1, 4, 2, 2]) == 0 >>> minimum_difference_partition([1, 3, 1000]) == 996 pass","solution":"def minimum_difference_partition(transactions): Segments a list of customer transactions into 2 groups such that the difference between the sum of transactions in each group is minimized and returns the minimal difference. total_sum = sum(transactions) n = len(transactions) target = total_sum // 2 # Initializing DP table where dp[i] means if we can form sum i with any subset of transactions dp = [False] * (target + 1) dp[0] = True for transaction in transactions: # We iterate backwards to avoid using the same element multiple times for j in range(target, transaction - 1, -1): dp[j] = dp[j] or dp[j - transaction] # Finding the highest value we can reach <= target which indicates the closest sum to half the total sum for i in range(target, -1, -1): if dp[i]: sum1 = i break sum2 = total_sum - sum1 return abs(sum2 - sum1)"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_minimum_distance(root: TreeNode, x: int, y: int) -> int: Given the root of a binary tree and two integers x and y, find the minimum distance between the nodes with these values. If either of the values x or y does not exist in the tree, return -1. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(6) >>> find_minimum_distance(root, 4, 5) 2 >>> find_minimum_distance(root, 4, 6) 4 >>> find_minimum_distance(root, 3, 4) 3 >>> find_minimum_distance(root, 2, 4) 1 >>> find_minimum_distance(root, 6, 6) 0 >>> find_minimum_distance(root, 4, 7) -1 >>> find_minimum_distance(root, 7, 8) -1 >>> root = None >>> find_minimum_distance(root, 1, 2) -1 >>> root = TreeNode(1) >>> find_minimum_distance(root, 1, 1) 0 >>> find_minimum_distance(root, 1, 2) -1","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_lca(root, x, y): if not root: return None if root.value == x or root.value == y: return root left_lca = find_lca(root.left, x, y) right_lca = find_lca(root.right, x, y) if left_lca and right_lca: return root return left_lca if left_lca is not None else right_lca def find_distance_from_lca(lca, value, distance=0): if not lca: return -1 if lca.value == value: return distance left_dist = find_distance_from_lca(lca.left, value, distance + 1) right_dist = find_distance_from_lca(lca.right, value, distance + 1) return left_dist if left_dist != -1 else right_dist def find_minimum_distance(root, x, y): if not root: return -1 lca = find_lca(root, x, y) if not lca: return -1 dist_x = find_distance_from_lca(lca, x) dist_y = find_distance_from_lca(lca, y) if dist_x == -1 or dist_y == -1: return -1 return dist_x + dist_y"},{"question":"def find_max_in_bitonic(arr: List[int]) -> int: Finds the maximum element in a bitonic sequence. Bitonic sequence: A sequence that first increases then decreases. :param arr: List of integers in bitonic order. :return: The maximum element in the bitonic sequence. >>> find_max_in_bitonic([1, 3, 8, 12, 4, 2]) 12 >>> find_max_in_bitonic([1, 2, 3, 4, 5, 3, 1]) 5","solution":"def find_max_in_bitonic(arr): Finds the maximum element in a bitonic sequence. Bitonic sequence: A sequence that first increases then decreases. :param arr: List of integers in bitonic order. :return: The maximum element in the bitonic sequence. left, right = 0, len(arr) - 1 while left < right: mid = left + (right - left) // 2 if arr[mid] > arr[mid + 1]: right = mid else: left = mid + 1 return arr[left]"},{"question":"def process_operations(operations: List[str]) -> List[int]: Process a list of stack operations and return the final state of the stack. The operations can be of three types: - \\"PUSH x\\": Push integer x onto the stack. - \\"POP\\": Remove the top element of the stack. - \\"INCREMENT k val\\": Increment the bottom k elements of the stack by the integer val. >>> process_operations([\\"PUSH 1\\", \\"PUSH 2\\", \\"PUSH 3\\"]) [1, 2, 3] >>> process_operations([\\"PUSH 1\\", \\"PUSH 2\\", \\"POP\\", \\"PUSH 3\\"]) [1, 3] >>> process_operations([\\"PUSH 1\\", \\"PUSH 2\\", \\"PUSH 3\\", \\"INCREMENT 2 10\\"]) [11, 12, 3] >>> process_operations([\\"PUSH 1\\", \\"PUSH 2\\", \\"INCREMENT 5 10\\"]) [11, 12] >>> process_operations([\\"PUSH 1\\", \\"PUSH 2\\", \\"INCREMENT 2 5\\", \\"POP\\", \\"PUSH 3\\", \\"INCREMENT 1 100\\"]) [106, 3] >>> process_operations([\\"POP\\", \\"PUSH 1\\", \\"POP\\", \\"POP\\"]) [] >>> process_operations([]) []","solution":"def process_operations(operations): stack = [] for op in operations: parts = op.split() if parts[0] == \\"PUSH\\": stack.append(int(parts[1])) elif parts[0] == \\"POP\\": if stack: stack.pop() elif parts[0] == \\"INCREMENT\\": k = int(parts[1]) val = int(parts[2]) for i in range(min(k, len(stack))): stack[i] += val return stack"},{"question":"class Solution: def findBuildingsWithOceanView(self, heights: List[int]) -> List[int]: Returns a list of indices of buildings that have an unobstructed ocean view. >>> sol = Solution() >>> sol.findBuildingsWithOceanView([4, 2, 3, 1]) == [0, 2, 3] >>> sol.findBuildingsWithOceanView([4, 3, 2, 1]) == [0, 1, 2, 3] >>> sol.findBuildingsWithOceanView([1, 3, 2, 4]) == [3]","solution":"class Solution: def findBuildingsWithOceanView(self, heights): Returns a list of indices of buildings that have an unobstructed ocean view. if not heights: return [] n = len(heights) result = [n - 1] for i in range(n - 2, -1, -1): if heights[i] > heights[result[-1]]: result.append(i) return result[::-1]"},{"question":"from typing import List, Tuple def sort_leaderboard(results: List[Tuple[str, int]]) -> List[str]: Returns the list of participant names sorted by their scores in descending order. If scores are equal, names are sorted lexicographically. >>> sort_leaderboard([(\\"Alice\\", 70), (\\"Bob\\", 50), (\\"Charlie\\", 60)]) ['Alice', 'Charlie', 'Bob'] >>> sort_leaderboard([(\\"Alice\\", 50), (\\"Bob\\", 50), (\\"Charlie\\", 60)]) ['Charlie', 'Alice', 'Bob'] >>> sort_leaderboard([(\\"Alice\\", 50), (\\"Alice\\", 70), (\\"Bob\\", 60)]) ['Alice', 'Bob', 'Alice']","solution":"from typing import List, Tuple def sort_leaderboard(results: List[Tuple[str, int]]) -> List[str]: Returns the list of participant names sorted by their scores in descending order. If scores are equal, names are sorted lexicographically. # Sort the results first by score (descending) and then by name (ascending) sorted_results = sorted(results, key=lambda x: (-x[1], x[0])) # Extract the names from the sorted results return [name for name, score in sorted_results]"},{"question":"def lexicographically_smallest_string(s: str, k: int) -> str: Determine the lexicographically smallest string that can be obtained by performing at most k operations on the string s. :param s: the input string consisting of only uppercase English letters. :param k: the maximum number of operations allowed. :return: the lexicographically smallest string that can be obtained. >>> lexicographically_smallest_string(\\"CBA\\", 1) \\"BCA\\" >>> lexicographically_smallest_string(\\"CBA\\", 2) \\"BAC\\" >>> lexicographically_smallest_string(\\"CBA\\", 3) \\"ABC\\" >>> lexicographically_smallest_string(\\"ABC\\", 0) \\"ABC\\" >>> lexicographically_smallest_string(\\"ACBD\\", 10) \\"ABCD\\" >>> lexicographically_smallest_string(\\"ACBD\\", 2) \\"ABCD\\" >>> lexicographically_smallest_string(\\"A\\", 1) \\"A\\" >>> lexicographically_smallest_string(\\"Z\\", 0) \\"Z\\" # Implement the function here","solution":"def lexicographically_smallest_string(s, k): Returns the lexicographically smallest string that can be obtained by performing at most k operations on the string s. if k >= len(s): # If k is greater or equal to the length of string, we can sort the string. return ''.join(sorted(s)) else: # We can only swap adjacent characters or change any character to any other one. # Use bubble sort like approach considering k swaps to get closer to the lexicographically smallest string. s = list(s) for i in range(len(s)): for j in range(min(k, len(s) - i - 1)): if s[j] > s[j + 1]: s[j], s[j + 1] = s[j + 1], s[j] k -= 1 if k == 0: return ''.join(s) return ''.join(s)"},{"question":"def convert(s: str, numRows: int) -> str: Convert the input string into a zigzag pattern on the given number of rows, and then read the converted string line by line. >>> convert(\\"PAYPALISHIRING\\", 3) \\"PAHNAPLSIIGYIR\\" >>> convert(\\"PAYPALISHIRING\\", 1) \\"PAYPALISHIRING\\" >>> convert(\\"PAYPALISHIRING\\", 2) \\"PYAIHRNAPLSIIG\\" >>> convert(\\"PAY\\", 5) \\"PAY\\" >>> convert(\\"ABCDE\\", 4) \\"ABCED\\" >>> convert(\\"\\", 3) \\"\\" >>> convert(\\"A\\", 1) \\"A\\"","solution":"def convert(s, numRows): if numRows == 1 or numRows >= len(s): return s # Create an array to hold the zigzag pattern rows = ['' for _ in range(numRows)] # Initialize variables to track the direction and current position current_row = 0 going_down = False # Traverse the input string and place each character in the appropriate row for char in s: rows[current_row] += char if current_row == 0 or current_row == numRows - 1: going_down = not going_down current_row += 1 if going_down else -1 # Join all rows to form the final zigzag string return ''.join(rows)"},{"question":"def longestGoodSubstring(s: str) -> int: Returns the length of the longest good substring. A good substring is a substring that contains no repeating characters. :param s: A string consisting of lowercase English letters. :type s: str :return: Length of the longest good substring. :rtype: int >>> longestGoodSubstring(\\"abcabcbb\\") == 3 >>> longestGoodSubstring(\\"bbbbb\\") == 1 >>> longestGoodSubstring(\\"pwwkew\\") == 3 >>> longestGoodSubstring(\\"\\") == 0 >>> longestGoodSubstring(\\"abcd\\") == 4 >>> longestGoodSubstring(\\"aabbcc\\") == 2 >>> longestGoodSubstring(\\"au\\") == 2 >>> longestGoodSubstring(\\"a\\") == 1 >>> longestGoodSubstring(\\"dvdf\\") == 3","solution":"def longestGoodSubstring(s): Returns the length of the longest good substring. A good substring is a substring that contains no repeating characters. :param s: A string consisting of lowercase English letters. :type s: str :return: Length of the longest good substring. :rtype: int if not s: return 0 n = len(s) max_len = 0 char_index = {} start = 0 for end in range(n): if s[end] in char_index and char_index[s[end]] >= start: start = char_index[s[end]] + 1 char_index[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"def longest_uniform_substring_length(s: str) -> int: Given a string \`s\`, return the length of the longest substring of \`s\` such that all the characters in this substring are the same. If the string \`s\` is empty, return 0. >>> longest_uniform_substring_length(\\"\\") == 0 >>> longest_uniform_substring_length(\\"a\\") == 1 >>> longest_uniform_substring_length(\\"aaaa\\") == 4 >>> longest_uniform_substring_length(\\"abcde\\") == 1 >>> longest_uniform_substring_length(\\"aabbbcccc\\") == 4 >>> longest_uniform_substring_length(\\"aaabbbcccbbb\\") == 3 >>> longest_uniform_substring_length(\\"aabbcccaaa\\") == 3 >>> longest_uniform_substring_length(\\"abbcccdddde\\") == 4","solution":"def longest_uniform_substring_length(s): Returns the length of the longest substring of \`s\` such that all the characters in this substring are the same. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def can_form_consecutive(nums: List[int], k: int) -> bool: Determines if there exists any subarray of length k that can be rearranged to form a consecutive sequence of numbers. :param nums: List[int] :param k: int :return: bool >>> can_form_consecutive([1, 2, 3, 4], 3) == True >>> can_form_consecutive([4, 3, 2, 1], 2) == True >>> can_form_consecutive([1, 3, 2, 4, 6, 5], 3) == True >>> can_form_consecutive([1, 5, 3, 2, 4], 5) == True >>> can_form_consecutive([7, 6, 5, 8, 9], 3) == True >>> can_form_consecutive([1, 2, 4, 5], 3) == False >>> can_form_consecutive([4, 1, 2, 3], 5) == False >>> can_form_consecutive([1, 9, 3, 5, 7], 2) == False >>> can_form_consecutive([8, 10, 12, 14], 3) == False >>> can_form_consecutive([2, 4, 6, 8], 3) == False >>> can_form_consecutive([1], 1) == True >>> can_form_consecutive([1], 2) == False >>> can_form_consecutive([], 1) == False >>> can_form_consecutive([2, 1], 2) == True >>> can_form_consecutive([1, 1, 2, 2], 2) == True","solution":"def can_form_consecutive(nums, k): Determines if there exists any subarray of length k that can be rearranged to form a consecutive sequence of numbers. :param nums: List[int] :param k: int :return: bool if k > len(nums): return False for i in range(len(nums) - k + 1): subarray = sorted(nums[i:i + k]) consecutive = True for j in range(1, k): if subarray[j] != subarray[j - 1] + 1: consecutive = False break if consecutive: return True return False"},{"question":"def max_consecutive_sum(arr: List[int], m: int) -> int: Returns the maximum sum of m consecutive elements in the array. If the array has fewer than m elements, returns the sum of all elements in the array. >>> max_consecutive_sum([1, 2, 3, 4, 5], 2) == 9 >>> max_consecutive_sum([1, 2], 3) == 3 >>> max_consecutive_sum([-1, -2, -3, -4, -5], 2) == -3 >>> max_consecutive_sum([1, 2, 3, 4, 5], 5) == 15 >>> max_consecutive_sum([1, 2, 3, 4, 5], 1) == 5 >>> max_consecutive_sum([1, 2, 3, -2, 5, -6, 7, 8, 9], 3) == 24 >>> max_consecutive_sum([], 3) == 0","solution":"from typing import List def max_consecutive_sum(arr: List[int], m: int) -> int: Returns the maximum sum of m consecutive elements in the array. If the array has fewer than m elements, returns the sum of all elements in the array. if len(arr) < m: return sum(arr) max_sum = current_sum = sum(arr[:m]) for i in range(m, len(arr)): current_sum += arr[i] - arr[i - m] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List def longest_increasing_path(grid: List[List[int]]) -> int: Given an \`m x n\` integer matrix \`grid\`, return the length of the longest increasing path in \`grid\`. An increasing path is a path where each subsequent cell is strictly greater than the previous cell. You may move in any of the four cardinal directions (up, down, left, right) from a cell. >>> grid = [ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ] >>> longest_increasing_path(grid) 4 >>> grid = [] >>> longest_increasing_path(grid) 0 >>> grid = [[]] >>> longest_increasing_path(grid) 0 >>> grid = [[1]] >>> longest_increasing_path(grid) 1 >>> grid = [ ... [7, 7], ... [7, 7] ... ] >>> longest_increasing_path(grid) 1 >>> grid = [ ... [1, 2, 3, 4] ... ] >>> longest_increasing_path(grid) 4 >>> grid = [ ... [1], ... [2], ... [3], ... [4] ... ] >>> longest_increasing_path(grid) 4 >>> grid = [ ... [3, 4, 5], ... [3, 2, 6], ... [2, 2, 1] ... ] >>> longest_increasing_path(grid) 4","solution":"from typing import List def longestIncreasingPath(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[-1] * cols for _ in range(rows)] def dfs(r, c): if dp[r][c] != -1: return dp[r][c] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] max_path = 1 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] > grid[r][c]: max_path = max(max_path, 1 + dfs(nr, nc)) dp[r][c] = max_path return dp[r][c] return max(dfs(r, c) for r in range(rows) for c in range(cols))"},{"question":"def minDistance(word1: str, word2: str) -> int: Returns the minimum number of operations required to convert word1 to word2. >>> minDistance(\\"test\\", \\"test\\") == 0 >>> minDistance(\\"\\", \\"abc\\") == 3 >>> minDistance(\\"horse\\", \\"ros\\") == 3 >>> minDistance(\\"intention\\", \\"execution\\") == 5 >>> minDistance(\\"abc\\", \\"yabd\\") == 2","solution":"def minDistance(word1, word2): Returns the minimum number of operations required to convert word1 to word2. m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # delete dp[i][j - 1], # insert dp[i - 1][j - 1]) # replace return dp[m][n]"},{"question":"def min_insertions_to_palindrome(s: str) -> int: Returns the minimum number of insertions required to make the string \`s\` a palindrome. >>> min_insertions_to_palindrome('a') == 0 >>> min_insertions_to_palindrome('aa') == 0 >>> min_insertions_to_palindrome('ab') == 1 >>> min_insertions_to_palindrome('racecar') == 0 >>> min_insertions_to_palindrome('abc') == 2 >>> min_insertions_to_palindrome('geeks') == 3 >>> min_insertions_to_palindrome('') == 0 >>> min_insertions_to_palindrome('aebcbda') == 2","solution":"def min_insertions_to_palindrome(s): Returns the minimum number of insertions required to make the string \`s\` a palindrome. def lcs(a, b): dp = [[0] * (len(b) + 1) for _ in range(len(a) + 1)] for i in range(1, len(a) + 1): for j in range(1, len(b) + 1): if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[len(a)][len(b)] reverse_s = s[::-1] lcs_length = lcs(s, reverse_s) return len(s) - lcs_length"},{"question":"def count_unique_k_substrings(s: str, k: int) -> int: Returns the number of unique k-substrings in string s. A k-substring is defined as a substring of s with length exactly k that contains unique digits. >>> count_unique_k_substrings(\\"123\\", 3) 1 >>> count_unique_k_substrings(\\"123456\\", 3) 4 >>> count_unique_k_substrings(\\"12\\", 3) 0 >>> count_unique_k_substrings(\\"111\\", 2) 0 >>> count_unique_k_substrings(\\"\\", 1) 0 >>> count_unique_k_substrings(\\"1234123\\", 1) 7","solution":"def count_unique_k_substrings(s, k): Returns the number of unique k-substrings in string s. A k-substring is defined as a substring of s with length exactly k that contains unique digits. if k > len(s): return 0 count = 0 for i in range(len(s) - k + 1): substring = s[i:i + k] if len(set(substring)) == k: count += 1 return count"},{"question":"def look_and_say(n: int) -> str: Returns the \`n\`th term of the look-and-say sequence. >>> look_and_say(1) \\"1\\" >>> look_and_say(2) \\"11\\" >>> look_and_say(3) \\"21\\" >>> look_and_say(4) \\"1211\\" >>> look_and_say(5) \\"111221\\" >>> look_and_say(6) \\"312211\\"","solution":"def look_and_say(n): Returns the \`n\`th term of the look-and-say sequence. if n == 1: return \\"1\\" prev_term = look_and_say(n - 1) result, i = \\"\\", 0 while i < len(prev_term): count = 1 while i + 1 < len(prev_term) and prev_term[i] == prev_term[i + 1]: i += 1 count += 1 result += str(count) + prev_term[i] i += 1 return result"},{"question":"def min_steps(grid, start, end): Returns the minimum number of steps required to reach the end cell from the start cell in a given grid. If the path is not possible, returns -1. :param grid: List[List[int]] :param start: Tuple[int, int] :param end: Tuple[int, int] :return: int >>> grid = [ ... [0, 0, 1], ... [1, 0, 1], ... [0, 0, 0] ... ] >>> min_steps(grid, (0, 0), (2, 2)) 4 >>> grid = [ ... [0, 1, 0], ... [1, 1, 1], ... [0, 0, 0] ... ] >>> min_steps(grid, (0, 0), (2, 2)) -1 >>> grid = [ ... [1, 0, 0], ... [1, 0, 1], ... [0, 0, 0] ... ] >>> min_steps(grid, (0, 0), (2, 2)) -1 >>> grid = [ ... [0, 0, 0], ... [1, 0, 1], ... [0, 0, 1] ... ] >>> min_steps(grid, (0, 0), (2, 2)) -1 >>> grid = [ ... [0, 0, 0], ... [1, 0, 1], ... [0, 0, 0] ... ] >>> min_steps(grid, (0, 0), (0, 0)) 0","solution":"from collections import deque def min_steps(grid, start, end): Returns the minimum number of steps required to reach the end cell from the start cell in a given grid. If the path is not possible, returns -1. :param grid: List[List[int]] :param start: Tuple[int, int] :param end: Tuple[int, int] :return: int rows, cols = len(grid), len(grid[0]) x1, y1 = start x2, y2 = end if grid[x1][y1] == 1 or grid[x2][y2] == 1: return -1 queue = deque([(x1, y1, 0)]) # (x, y, steps) visited = set() visited.add((x1, y1)) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: x, y, steps = queue.popleft() if (x, y) == (x2, y2): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def canTransform(original: List[int], target: List[int]) -> bool: Determines if original can be transformed into target by removing pairs of equal elements. :param original: List[int] :param target: List[int] :return: bool >>> canTransform([1, 2, 2, 3, 4, 4], [2, 3]) == True >>> canTransform([5, 5, 6, 7, 7], [5, 7]) == True >>> canTransform([1, 2, 2, 3], [1, 1]) == False >>> canTransform([3, 3, 3], [3, 3, 3, 3]) == False >>> canTransform([1, 1, 2, 2], [1, 2]) == True >>> canTransform([4, 4, 4, 4], [4, 4]) == True >>> canTransform([1, 2, 3], []) == True >>> canTransform([], []) == True >>> canTransform([], [1]) == False >>> canTransform([], [1, 2]) == False","solution":"def canTransform(original, target): Determines if original can be transformed into target by removing pairs of equal elements. :param original: List[int] :param target: List[int] :return: bool from collections import Counter # Count the frequency of each element in original and target original_count = Counter(original) target_count = Counter(target) # For transformation to be possible, for each element in target, original must have at least that many for key, count in target_count.items(): if original_count[key] < count: return False return True"},{"question":"def min_deletions(s: str) -> int: Return the minimum number of deletions needed so that no two consecutive characters are the same. >>> min_deletions(\\"abc\\") == 0 >>> min_deletions(\\"acbacb\\") == 0 >>> min_deletions(\\"aaa\\") == 2 >>> min_deletions(\\"bbb\\") == 2 >>> min_deletions(\\"aab\\") == 1 >>> min_deletions(\\"abbcc\\") == 2 >>> min_deletions(\\"\\") == 0 >>> min_deletions(\\"a\\") == 0 >>> min_deletions(\\"b\\") == 0 >>> min_deletions(\\"c\\") == 0 >>> min_deletions(\\"aa\\") == 1 >>> min_deletions(\\"ab\\") == 0","solution":"def min_deletions(s: str) -> int: deletions = 0 for i in range(1, len(s)): if s[i] == s[i-1]: deletions += 1 return deletions"},{"question":"def manhattan_distance(point1, point2): Returns the Manhattan distance between two points. >>> manhattan_distance([1, 2], [4, 6]) 7 >>> manhattan_distance([1, 1], [1, 1]) 0 ... def closest_pair(points): Returns the Manhattan distance of the closest pair of points. >>> closest_pair([[1, 2], [4, 6], [1, 3]]) 1 >>> closest_pair([[0, 0], [0, 2], [0, 4], [2, 0]]) 2 >>> closest_pair([[1, 1], [1, 1]]) 0 >>> closest_pair([[-1, -1], [-2, -2], [-3, -3], [0, 0]]) 2 >>> closest_pair([[0, 0]]) float('inf') ...","solution":"def manhattan_distance(point1, point2): Returns the Manhattan distance between two points. return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1]) def closest_pair(points): Returns the Manhattan distance of the closest pair of points. min_distance = float('inf') n = len(points) for i in range(n): for j in range(i + 1, n): distance = manhattan_distance(points[i], points[j]) if distance < min_distance: min_distance = distance return min_distance"},{"question":"def has_pair_with_sum(nums: List[int], k: int) -> bool: Determines if there exists a pair of distinct integers in the array whose sum is equal to k. :param nums: List of integers :param k: The target sum :return: Boolean whether such a pair exists >>> has_pair_with_sum([1, 2, 3, 4], 5) True >>> has_pair_with_sum([1, 2, 3, 4], 8) False >>> has_pair_with_sum([-1, -2, -3, -4], -5) True >>> has_pair_with_sum([0, 1, 2, 3], 3) True >>> has_pair_with_sum([0, 0, 1, 1], 2) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False >>> has_pair_with_sum([5, 7, 1, 2, 8], 12) True >>> has_pair_with_sum([], 1) False >>> has_pair_with_sum([1], 1) False","solution":"def has_pair_with_sum(nums, k): Determines if there exists a pair of distinct integers in the array whose sum is equal to k. :param nums: List of integers :param k: The target sum :return: Boolean whether such a pair exists seen = set() for num in nums: if k - num in seen: return True seen.add(num) return False"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Determine the largest rectangular area that can be formed within the bounds of a given histogram represented by a list of non-negative integers. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 4]) 4 >>> largest_rectangle_area([2, 3, 4, 5, 6]) 12 >>> largest_rectangle_area([6, 5, 4, 3, 2]) 12 >>> largest_rectangle_area([1, 1, 1, 1]) 4 >>> largest_rectangle_area([]) 0 >>> largest_rectangle_area([1]) 1","solution":"def largest_rectangle_area(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def find_duplicates(nums: List[int]) -> List[int]: Given a list of n integers where each integer is in the range [1, n] inclusive. Some elements appear twice and others appear once. Find all the elements that appear twice in this list without using any extra space and in O(n) runtime complexity. Return a list of these elements. >>> find_duplicates([4, 3, 2, 7, 8, 2, 3, 1]) [2, 3] >>> find_duplicates([1, 1, 2, 2, 3, 3, 4, 4, 5, 5]) [1, 2, 3, 4, 5] >>> find_duplicates([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [] >>> find_duplicates([]) [] >>> find_duplicates([1]) [] >>> find_duplicates([1, 3, 4, 2, 2, 3, 1, 4, 5]) [2, 3, 1, 4]","solution":"def find_duplicates(nums): Find all the elements that appear twice in this list without using any extra space and in O(n) runtime complexity. Parameters: nums (list): List of integers. Returns: list: List of duplicated integers. # Result list to store duplicates duplicates = [] # Iterate over the nums list for i in range(len(nums)): # Index derived from the absolute value of the current element index = abs(nums[i]) - 1 # If the number at index is negative, it means the number at current index is a duplicate if nums[index] < 0: duplicates.append(index + 1) else: # Mark the number at the derived index as visited by making it negative nums[index] = -nums[index] return duplicates"},{"question":"from typing import List def find_kth_largest(nums: List[int], k: int) -> int: Given a list of integers \`nums\` and an integer \`k\`, where \`k\` is guaranteed to be smaller than the length of the list, find the \`k\`-th largest element in the list in \`O(n)\` average time complexity. >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([1], 1) 1 >>> find_kth_largest([1, 2, 3, 4, 5], 4) 2 >>> find_kth_largest([5, 4, 3, 2, 1], 3) 3 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4 >>> find_kth_largest([7, 10, 4, 3, 20, 15], 3) 10 >>> find_kth_largest([-1, -2, -3, -4, -5], 2) -2","solution":"import random def partition(nums, left, right): pivot_index = random.randint(left, right) pivot_value = nums[pivot_index] nums[pivot_index], nums[right] = nums[right], nums[pivot_index] store_index = left for i in range(left, right): if nums[i] < pivot_value: nums[i], nums[store_index] = nums[store_index], nums[i] store_index += 1 nums[store_index], nums[right] = nums[right], nums[store_index] return store_index def quick_select(nums, left, right, k): if left == right: return nums[left] pivot_index = partition(nums, left, right) if k == pivot_index: return nums[k] elif k < pivot_index: return quick_select(nums, left, pivot_index - 1, k) else: return quick_select(nums, pivot_index + 1, right, k) def find_kth_largest(nums, k): size = len(nums) target = size - k return quick_select(nums, 0, size - 1, target)"},{"question":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root: Optional[TreeNode], val: int) -> Optional[TreeNode]: Inserts a new value into the BST and returns the root of the BST. >>> result = insert_into_bst(None, 5) >>> tree_to_list(result) [5] >>> root = TreeNode(10) >>> result = insert_into_bst(root, 5) >>> tree_to_list(result) [5, 10] >>> root = TreeNode(10) >>> result = insert_into_bst(root, 15) >>> tree_to_list(result) [10, 15] >>> root = TreeNode(10) >>> insert_into_bst(root, 5) >>> insert_into_bst(root, 15) >>> insert_into_bst(root, 3) >>> insert_into_bst(root, 8) >>> insert_into_bst(root, 13) >>> insert_into_bst(root, 18) >>> tree_to_list(root) [3, 5, 8, 10, 13, 15, 18] >>> root = TreeNode(10) >>> insert_into_bst(root, 10) >>> tree_to_list(root) [10, 10]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root: TreeNode, val: int) -> TreeNode: Inserts a new value into the BST and returns the root of the BST. if root is None: return TreeNode(val) if val < root.val: if root.left is None: root.left = TreeNode(val) else: insert_into_bst(root.left, val) else: if root.right is None: root.right = TreeNode(val) else: insert_into_bst(root.right, val) return root"},{"question":"def min_operations_to_target(start: int, target: List[int]) -> int: Returns the minimum number of operations required to make \`start\` equal to any integer in \`target\`. If it is not possible, returns -1. :param start: The starting integer :param target: A list of integers :return: Minimum number of operations or -1 if not possible >>> min_operations_to_target(5, [5]) == 0 >>> min_operations_to_target(0, [1]) == 1 >>> min_operations_to_target(10, [5, 15, 20]) == 5 >>> min_operations_to_target(7, [2, 9, 12]) == 2 >>> min_operations_to_target(8, [1, 4, 10]) == 2 >>> min_operations_to_target(3, [7, 8, 9]) == 4 >>> min_operations_to_target(20, [5, 10, 30]) == 10 >>> min_operations_to_target(100, [50, 60, 75]) == 25 >>> min_operations_to_target(1000000, [999999, 1000001]) == 1 >>> min_operations_to_target(5, []) == -1","solution":"def min_operations_to_target(start, target): Returns the minimum number of operations required to make \`start\` equal to any integer in \`target\`. If it is not possible, returns -1. :param start: The starting integer :param target: A list of integers :return: Minimum number of operations or -1 if not possible if not target: return -1 min_operations = float('inf') for t in target: min_operations = min(min_operations, abs(start - t)) return min_operations if min_operations != float('inf') else -1"},{"question":"def sum_of_substrings(s: str) -> int: Returns the sum of all possible substrings of the given string as integers. Parameters: s (str): A string containing only digits. Returns: int: The sum of all possible substrings converted to integers. >>> sum_of_substrings(\\"123\\") == 164 >>> sum_of_substrings(\\"1\\") == 1 >>> sum_of_substrings(\\"112\\") == 137 >>> sum_of_substrings(\\"1234\\") == 1670 pass","solution":"def sum_of_substrings(s): Returns the sum of all possible substrings of the given string as integers. Parameters: s (str): A string containing only digits. Returns: int: The sum of all possible substrings converted to integers. total_sum = 0 n = len(s) for i in range(n): for j in range(i + 1, n + 1): total_sum += int(s[i:j]) return total_sum"},{"question":"def climb_stairs(n: int) -> int: Return the number of unique ways to climb to the top of a staircase with n steps if you can either take 1 or 2 steps at a time. >>> climb_stairs(0) 1 >>> climb_stairs(1) 1 >>> climb_stairs(2) 2 >>> climb_stairs(3) 3 >>> climb_stairs(5) 8 >>> climb_stairs(10) 89","solution":"def climb_stairs(n): Returns the number of unique ways to climb to the top of a staircase with n steps where you can either take 1 or 2 steps at a time. if n <= 1: return 1 dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 for i in range(2, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n]"},{"question":"def maximize_median(ar1, ar2): Remove any element from ar1 and insert it into ar2 such that the median of the modified ar2 is maximized. Return the modified array ar2. def test_case_1(): ar1 = [1, 3, 5] ar2 = [2, 4, 6] expected_result = [2, 3, 4, 6] # can also be [2, 4, 5, 6] in this case result = maximize_median(ar1, ar2) assert result in [[2, 3, 4, 6], [2, 4, 5, 6]] def test_case_2(): ar1 = [1, 10, 20] ar2 = [3, 5, 7, 9] expected_result = [3, 5, 7, 9, 10] result = maximize_median(ar1, ar2) assert result == expected_result def test_case_3(): ar1 = [1, 1, 1] ar2 = [2, 2, 2] expected_result = [1, 2, 2, 2] result = maximize_median(ar1, ar2) assert result == expected_result def test_case_4(): ar1 = [-5, -10, -20] ar2 = [-1, 0, 1] expected_result = [-5, -1, 0, 1] result is intended maximize_median(ar1, ar2) assert result == expected_result def test_case_5(): ar1 = [0] ar2 = [0] expected_result = [0, 0] result = maximize_median(ar1, ar2) assert result == expected_result","solution":"def maximize_median(ar1, ar2): Remove any element from ar1 and insert it into ar2 such that the median of the modified ar2 is maximized. Return the modified array ar2. ar2_sorted = sorted(ar2) max_median = -float('inf') resulting_ar2 = [] for elem in ar1: temp_ar2 = ar2 + [elem] temp_ar2.sort() n = len(temp_ar2) if n % 2 == 1: median = temp_ar2[n//2] else: median = (temp_ar2[n//2 - 1] + temp_ar2[n//2]) / 2.0 if median > max_median: max_median = median resulting_ar2 = temp_ar2 return resulting_ar2"},{"question":"def decode_message(encoded_message: str, shift: int) -> str: Decodes the encoded message by shifting each letter by the specified number of places down the alphabet. Non-alphabet characters remain the same. >>> decode_message('bcdef', 1) 'abcde' >>> decode_message('XYZ', 3) 'UVW' >>> decode_message('Hello, World!', 1) 'Gdkkn, Vnqkc!' >>> decode_message('123 ABC abc!', 2) '123 YZA yza!' >>> decode_message('Python', 0) 'Python'","solution":"def decode_message(encoded_message, shift): Decodes the encoded message by shifting each letter by the specified number of places down the alphabet. Non-alphabet characters remain the same. Parameters: encoded_message (str): The string to decode. shift (int): The number of places to shift each alphabet letter. Returns: str: The decoded message. decoded_chars = [] for char in encoded_message: if char.isalpha(): if char.islower(): decoded_chars.append(chr((ord(char) - ord('a') - shift) % 26 + ord('a'))) elif char.isupper(): decoded_chars.append(chr((ord(char) - ord('A') - shift) % 26 + ord('A'))) else: decoded_chars.append(char) return ''.join(decoded_chars)"},{"question":"from typing import List def walls_and_gates(rooms: List[List[int]]) -> None: Fills each empty room in the grid with the distance to its nearest gate. If it's impossible to reach a gate, it should remain 2147483647. Parameters: rooms (List[List[int]]): 2D grid representing rooms, gates, and walls. Returns: None: Modifies input grid in-place. pass # Unit Tests def test_walls_and_gates_all_infinite(): grid = [[2147483647]] walls_and_gates(grid) assert grid == [[2147483647]] def test_walls_and_gates_single_gate(): grid = [[0]] walls_and_gates(grid) assert grid == [[0]] def test_walls_and_gates_gate_and_rooms(): grid = [[2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647]] expected_output = [[3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4]] walls_and_gates(grid) assert grid == expected_output def test_walls_and_gates_empty_rooms_around_gate(): grid = [[2147483647, 2147483647, 2147483647, 0]] expected_output = [[3, 2, 1, 0]] walls_and_gates(grid) assert grid == expected_output def test_walls_and_gates_walls_everywhere(): grid = [[-1, -1, -1], [-1, 0, -1], [-1, -1, -1]] expected_output = [[-1, -1, -1], [-1, 0, -1], [-1, -1, -1]] walls_and_gates(grid) assert grid == expected_output","solution":"from collections import deque def walls_and_gates(rooms): Fills each empty room in the grid with the distance to its nearest gate. If it's impossible to reach a gate, it should remain 2147483647. Parameters: rooms (List[List[int]]): 2D grid representing rooms, gates, and walls. Returns: None: Modifies input grid in-place. if not rooms: return m, n = len(rooms), len(rooms[0]) queue = deque() # Enqueue all gates for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) # Directions for top, bottom, left, right directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # BFS from all gates while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == 2147483647: rooms[nx][ny] = rooms[x][y] + 1 queue.append((nx, ny))"},{"question":"from typing import List def find_task_order(n: int, dependencies: List[List[int]]) -> List[int]: Given the number of tasks \`n\` and a list of dependencies \`dependencies\`, returns a list representing a possible order of task completion or an empty list if all tasks cannot be completed. pass def test_no_dependencies(): # Test when there are no dependencies assert find_task_order(3, []) == [1, 2, 3] def test_single_dependency(): # Test with a single dependency assert find_task_order(2, [[1, 2]]) == [1, 2] def test_multiple_dependencies(): # Test with multiple dependencies result = find_task_order(4, [[1, 2], [2, 3], [3, 4]]) assert result == [1, 2, 3, 4] or result == [1, 3, 2, 4] def test_circular_dependency(): # Test with a circular dependency assert find_task_order(3, [[1, 2], [2, 3], [3, 1]]) == [] def test_complex_dependencies(): # Test with a more complex dependency graph result = find_task_order(6, [[1, 4], [2, 4], [3, 5], [4, 5], [5, 6]]) assert result == [1, 2, 3, 4, 5, 6] or result == [2, 1, 3, 4, 5, 6] or result == [2, 3, 1, 4, 5, 6] def test_single_task(): # Test with only one task assert find_task_order(1, []) == [1]","solution":"from collections import defaultdict, deque def find_task_order(n, dependencies): Given the number of tasks \`n\` and a list of dependencies \`dependencies\`, returns a list representing a possible order of task completion or an empty list if all tasks cannot be completed. # Create an adjacency list for the graph adj_list = defaultdict(list) in_degree = {i: 0 for i in range(1, n + 1)} # Build the graph and in-degree count for a, b in dependencies: adj_list[a].append(b) in_degree[b] += 1 # Initialize the queue with tasks that have no dependencies (in-degree 0) zero_in_degree_queue = deque([k for k in in_degree if in_degree[k] == 0]) order = [] while zero_in_degree_queue: task = zero_in_degree_queue.popleft() order.append(task) # Decrease the in-degree of neighboring tasks for neighbor in adj_list[task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If the resulting order contains all tasks, return the order if len(order) == n: return order else: return []"},{"question":"def smallest_abs_difference(arr1: List[int], arr2: List[int]) -> int: Returns the smallest absolute difference between any element of arr1 and any element of arr2. >>> smallest_abs_difference([1, 3, 15, 11, 2], [23, 127, 235, 19, 8]) == 3 >>> smallest_abs_difference([1, 2, 3], [10, 20, 30]) == 7 >>> smallest_abs_difference([-1, -2, -3], [-10, -20, -30]) == 7 >>> smallest_abs_difference([1, 2, 3], [1, 2, 3]) == 0 >>> smallest_abs_difference([1], [10, 20, 30]) == 9 >>> smallest_abs_difference([], [1, 2, 3]) == float('inf') >>> smallest_abs_difference([1, 2, 3], []) == float('inf')","solution":"def smallest_abs_difference(arr1, arr2): Returns the smallest absolute difference between any element of arr1 and any element of arr2. arr1.sort() arr2.sort() i = 0 j = 0 min_diff = float('inf') while i < len(arr1) and j < len(arr2): min_diff = min(min_diff, abs(arr1[i] - arr2[j])) if arr1[i] < arr2[j]: i += 1 else: j += 1 return min_diff"},{"question":"def is_mountain_element(nums: List[int], target: int) -> bool: Determine if target is a mountain element in the sorted array nums. An element nums[i] is considered a mountain element if it is larger than its immediate neighbors, i.e., nums[i-1] < nums[i] > nums[i+1]. Return True if target is a mountain element in nums, otherwise return False. If target does not exist in nums, also return False. Args: nums : List[int] -- sorted array of integers in non-decreasing order target : int -- target integer to check Returns: bool -- True if target is a mountain element, False otherwise Examples: >>> is_mountain_element([1, 3, 2], 3) True >>> is_mountain_element([1, 2, 3, 4, 3, 2], 3) False","solution":"def is_mountain_element(nums, target): Determine if the target is a mountain element in the nums array. Arguments: nums : List[int] -- sorted array of integers in non-decreasing order target : int -- target integer to check Returns: bool -- True if target is a mountain element, False otherwise for i in range(1, len(nums)-1): if nums[i] == target and nums[i-1] < nums[i] > nums[i+1]: return True return False"},{"question":"class IslandCounter: IslandCounter is a class that can be used to count the number of islands in a 2D grid. An island is made up of connected '1's (lands) and is surrounded by '0's (water). Functions: - __init__(grid: List[List[str]]) : Initializes the IslandCounter object with a grid. - addLand(row: int, col: int) : Sets the value at grid[row][col] to '1', marking it as land. - countIslands() : Returns the number of distinct islands in the grid. >>> grid = [ ... ['1', '1', '0', '0', '0'], ... ['1', '1', '0', '0', '0'], ... ['0', '0', '1', '0', '0'], ... ['0', '0', '0', '1', '1']] >>> ic = IslandCounter(grid) >>> ic.countIslands() 3 >>> grid = [ ... ['0', '0', '0', '0', '0'], ... ['0', '0', '0', '0', '0'], ... ['0', '0', '0', '0', '0'], ... ['0', '0', '0', '0', '0']] >>> ic = IslandCounter(grid) >>> ic.countIslands() 0","solution":"class IslandCounter: def __init__(self, grid): self.grid = grid self.m = len(grid) self.n = len(grid[0]) self.visited = [[False] * self.n for _ in range(self.m)] def addLand(self, row, col): self.grid[row][col] = '1' def countIslands(self): def dfs(r, c): if r < 0 or c < 0 or r >= self.m or c >= self.n or self.grid[r][c] == '0' or self.visited[r][c]: return self.visited[r][c] = True dfs(r+1, c) dfs(r-1, c) dfs(r, c+1) dfs(r, c-1) self.visited = [[False] * self.n for _ in range(self.m)] island_count = 0 for i in range(self.m): for j in range(self.n): if self.grid[i][j] == '1' and not self.visited[i][j]: island_count += 1 dfs(i, j) return island_count"},{"question":"from typing import List, Tuple def query_match(words: List[str], queries: List[Tuple[str, str]]) -> List[bool]: Returns a list of booleans where each element indicates whether the corresponding query can be matched to the given pattern. :param words: List of words :param queries: List of tuples (query_word, pattern) :return: List of booleans >>> words = [\\"apple\\", \\"banana\\", \\"caramel\\"] >>> queries = [(\\"appetizing\\", \\"eat\\"), (\\"carnival\\", \\"arc\\"), (\\"chocolate\\", \\"late\\")] >>> query_match(words, queries) [False, True, True] pass def test_query_match_basic(): words = [\\"apple\\", \\"banana\\", \\"caramel\\"] queries = [(\\"appetizing\\", \\"eat\\"), (\\"carnival\\", \\"arc\\"), (\\"chocolate\\", \\"late\\")] expected = [False, True, True] assert query_match(words, queries) == expected def test_query_match_single_char(): words = [\\"a\\", \\"b\\", \\"c\\"] queries = [(\\"a\\", \\"a\\"), (\\"b\\", \\"a\\"), (\\"c\\", \\"a\\")] expected = [True, False, False] assert query_match(words, queries) == expected def test_query_match_empty_pattern(): words = [\\"apple\\", \\"banana\\", \\"caramel\\"] queries = [(\\"apple\\", \\"\\"), (\\"banana\\", \\"\\"), (\\"caramel\\", \\"\\")] expected = [True, True, True] assert query_match(words, queries) == expected def test_query_match_empty_query(): words = [\\"apple\\", \\"banana\\", \\"caramel\\"] queries = [(\\"\\", \\"a\\"), (\\"\\", \\"b\\"), (\\"\\", \\"caramel\\")] expected = [False, False, False] assert query_match(words, queries) == expected def test_query_match_no_match(): words = [\\"apple\\", \\"banana\\", \\"caramel\\"] queries = [(\\"pineapple\\", \\"z\\"), (\\"strawberry\\", \\"qwe\\"), (\\"kiwi\\", \\"u\\")] expected = [False, False, False] assert query_match(words, queries) == expected","solution":"def query_match(words, queries): Returns a list of booleans where each element indicates whether the corresponding query can be matched to the given pattern. :param words: List of words :param queries: List of tuples (query_word, pattern) :return: List of booleans def can_match(query_word, pattern): from collections import Counter pattern_count = Counter(pattern) query_length = len(pattern) for i in range(len(query_word) - query_length + 1): substring = query_word[i:i+query_length] if Counter(substring) == pattern_count: return True return False results = [] for query_word, pattern in queries: results.append(can_match(query_word, pattern)) return results"},{"question":"def max_diff_increasing_subarray(nums: List[int]) -> int: Given an integer array \`nums\`, return the maximum difference between the increasing adjacent elements in a subarray where the elements are in strictly increasing order. If the array is already in strictly increasing order, return the maximum difference between its adjacent elements. If no such subarray exists, return 0. >>> max_diff_increasing_subarray([5, 4, 3, 2, 1]) == 0 >>> max_diff_increasing_subarray([10]) == 0 >>> max_diff_increasing_subarray([1, 2]) == 1 >>> max_diff_increasing_subarray([2, 1]) == 0 >>> max_diff_increasing_subarray([1, 3, 2, 4, 6, 5]) == 2 >>> max_diff_increasing_subarray([1, 2, 3, 4, 5, 6]) == 1 >>> max_diff_increasing_subarray([1, 5, 3, 8, 4, 9]) == 5","solution":"def max_diff_increasing_subarray(nums): Returns the maximum difference between increasing adjacent elements in a subarray. If no such subarray exists or array is too short, return 0. if len(nums) < 2: return 0 max_diff = 0 current_diff = 0 for i in range(1, len(nums)): if nums[i] > nums[i-1]: diff = nums[i] - nums[i-1] current_diff = max(current_diff, diff) max_diff = max(max_diff, current_diff) else: current_diff = 0 return max_diff"},{"question":"def bitwise_xor_bin_str(a: str, b: str) -> str: Takes two binary strings \`a\` and \`b\` of the same length and returns a binary string \`c\` where each bit \`c[i]\` is '1' if \`a[i]\` and \`b[i]\` are different, and '0' if they are the same. >>> bitwise_xor_bin_str(\\"1111\\", \\"1111\\") '0000' >>> bitwise_xor_bin_str(\\"0000\\", \\"0000\\") '0000' >>> bitwise_xor_bin_str(\\"1111\\", \\"0000\\") '1111' >>> bitwise_xor_bin_str(\\"1101\\", \\"1011\\") '0110' >>> bitwise_xor_bin_str(\\"1\\", \\"0\\") '1'","solution":"def bitwise_xor_bin_str(a, b): Takes two binary strings \`a\` and \`b\` of the same length and returns a binary string \`c\` where each bit \`c[i]\` is '1' if \`a[i]\` and \`b[i]\` are different, and '0' if they are the same. # Lengths of both strings should be the same assert len(a) == len(b) # Using list comprehension to generate the result c = ''.join('1' if a[i] != b[i] else '0' for i in range(len(a))) return c"},{"question":"import json class TreeNode: def __init__(self, val=0, left=None, right=None, random=None): self.val = val self.left = left self.right = right self.random = random def serialize(root): Encodes a binary tree to a single string. pass def deserialize(data): Decodes your encoded data to tree. pass import pytest def test_serialize_deserialize_empty(): root = None data = serialize(root) assert data == \\"null\\" assert deserialize(data) is None def test_serialize_deserialize_single_node(): root = TreeNode(1) data = serialize(root) new_root = deserialize(data) assert new_root.val == 1 assert new_root.left is None assert new_root.right is None assert new_root.random is None def test_serialize_deserialize_simple_tree(): # Construct the tree: # 1 # / # 2 3 # Random pointers: 1->3, 2->1, 3->2 root = TreeNode(1) node2 = TreeNode(2) node3 = TreeNode(3) root.left = node2 root.right = node3 root.random = node3 node2.random = root node3.random = node2 data = serialize(root) new_root = deserialize(data) # Validate structure and values assert new_root.val == 1 assert new_root.left.val == 2 assert new_root.right.val == 3 assert new_root.random.val == 3 assert new_root.left.random.val == 1 assert new_root.right.random.val == 2 def test_serialize_deserialize_complex_tree(): # Construct a more complex tree: # 4 # / # 2 6 # / / # 1 3 5 7 # Random pointers: 4->7, 2->6, 6->2, 1->3, 3->5, 5->1, 7->4 root = TreeNode(4) node2 = TreeNode(2) node6 = TreeNode(6) node1 = TreeNode(1) node3 = TreeNode(3) node5 = TreeNode(5) node7 = TreeNode(7) root.left = node2 root.right = node6 node2.left = node1 node2.right = node3 node6.left = node5 node6.right = node7 root.random = node7 node2.random = node6 node6.random = node2 node1.random = node3 node3.random = node5 node5.random = node1 node7.random = root data = serialize(root) new_root = deserialize(data) # Validate structure and values assert new_root.val == 4 assert new_root.left.val == 2 assert new_root.right.val == 6 assert new_root.left.left.val == 1 assert new_root.left.right.val == 3 assert new_root.right.left.val == 5 assert new_root.right.right.val == 7 # Validate random pointers assert new_root.random.val == 7 assert new_root.left.random.val == 6 assert new_root.right.random.val == 2 assert new_root.left.left.random.val == 3 assert new_root.left.right.random.val == 5 assert new_root.right.left.random.val == 1 assert new_root.right.right.random.val == 4","solution":"import json class TreeNode: def __init__(self, val=0, left=None, right=None, random=None): self.val = val self.left = left self.right = right self.random = random def serialize(root): Encodes a binary tree to a single string. if not root: return \\"null\\" def build_dict(node): if not node: return None node_dict = { \\"val\\": node.val, \\"left\\": build_dict(node.left), \\"right\\": build_dict(node.right), \\"random\\": node.random.val if node.random else None } return node_dict result = json.dumps(build_dict(root)) return result def deserialize(data): Decodes your encoded data to tree. if data == \\"null\\": return None node_dict = json.loads(data) def build_tree(node_dict): if not node_dict: return None node = TreeNode(node_dict[\\"val\\"]) node.left = build_tree(node_dict[\\"left\\"]) node.right = build_tree(node_dict[\\"right\\"]) return node root = build_tree(node_dict) def assign_random(node, node_dict): if not node or not node_dict: return if node_dict[\\"random\\"] is not None: node.random = get_node_by_val(root, node_dict[\\"random\\"]) assign_random(node.left, node_dict[\\"left\\"]) assign_random(node.right, node_dict[\\"right\\"]) def get_node_by_val(node, val): if not node: return None if node.val == val: return node left_result = get_node_by_val(node.left, val) return left_result if left_result else get_node_by_val(node.right, val) assign_random(root, node_dict) return root"},{"question":"from typing import List def count_good_strings(words: List[str], chars: str) -> int: Return the sum of the lengths of all good strings in words that can be formed by characters in chars. >>> count_good_strings([\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"], \\"atach\\") 6 >>> count_good_strings([\\"hello\\", \\"world\\"], \\"a\\") 0 >>> count_good_strings([\\"a\\", \\"b\\"], \\"ab\\") 2 >>> count_good_strings([\\"hello\\", \\"world\\", \\"hi\\", \\"there\\"], \\"helloworld\\") 10 >>> count_good_strings([\\"aaa\\", \\"ab\\", \\"bbc\\"], \\"aabbcc\\") 5 >>> count_good_strings([], \\"abc\\") 0 >>> count_good_strings([\\"word\\"], \\"\\") 0 >>> count_good_strings([], \\"\\") 0","solution":"def count_good_strings(words, chars): Return the sum of the lengths of all good strings in words that can be formed by characters in chars. from collections import Counter chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) for char, count in word_count.items(): if chars_count[char] < count: break else: total_length += len(word) return total_length"},{"question":"def min_swaps_to_group_ones(bits): Returns the minimum number of swaps needed to group all \\"1\\"s together in a contiguous block. >>> min_swaps_to_group_ones([\\"0\\", \\"0\\", \\"0\\"]) == -1 >>> min_swaps_to_group_ones([\\"1\\", \\"1\\", \\"1\\", \\"0\\", \\"0\\"]) == 0 >>> min_swaps_to_group_ones([\\"1\\", \\"0\\", \\"1\\", \\"0\\", \\"1\\", \\"0\\"]) == 1 >>> min_swaps_to_group_ones([\\"0\\", \\"1\\", \\"0\\", \\"1\\", \\"0\\", \\"1\\", \\"0\\", \\"1\\", \\"0\\", \\"1\\"]) == 2 >>> min_swaps_to_group_ones([\\"1\\", \\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"1\\", \\"1\\", \\"0\\"]) == 1 >>> min_swaps_to_group_ones([\\"1\\", \\"1\\", \\"1\\", \\"1\\"]) == 0 >>> min_swaps_to_group_ones([\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"]) == 0 >>> min_swaps_to_group_ones([]) == -1 >>> min_swaps_to_group_ones([\\"0\\"]) == -1 >>> min_swaps_to_group_ones([\\"1\\"]) == 0","solution":"def min_swaps_to_group_ones(bits): Returns the minimum number of swaps needed to group all \\"1\\"s together in a contiguous block. num_ones = bits.count(\\"1\\") if num_ones == 0: return -1 num_bits = len(bits) min_swaps = float('inf') ones_count_in_window = 0 left = 0 for right in range(num_bits): if bits[right] == \\"1\\": ones_count_in_window += 1 if right - left + 1 == num_ones: min_swaps = min(min_swaps, num_ones - ones_count_in_window) if bits[left] == \\"1\\": ones_count_in_window -= 1 left += 1 return min_swaps"},{"question":"def max_points(nums: List[int]) -> int: Returns the maximum points you can achieve with the constraint that once you score points from a particular round, you cannot score points from the previous or the following round. >>> max_points([]) == 0 >>> max_points([5]) == 5 >>> max_points([5, 10]) == 10 >>> max_points([10, 5]) == 10 >>> max_points([5, 5, 10, 100, 10, 5]) == 110 >>> max_points([3, 2, 5, 10, 7]) == 15 >>> max_points([3, 2, 7, 10]) == 13 >>> max_points([20, 10, 30, 40, 50, 60]) == 120 >>> max_points([50, 50, 50, 50, 50, 50]) == 150 # Your implementation here","solution":"def max_points(nums): Returns the maximum points achievable with the given constraints. :param nums: List of non-negative integers representing points in each round. :return: Maximum points achievable. if not nums: return 0 if len(nums) == 1: return nums[0] n = len(nums) # dp[i] will store the maximum points we can achieve considering up to round i dp = [0] * n # Base cases dp[0] = nums[0] if n > 1: dp[1] = max(nums[0], nums[1]) # Fill dp array for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"def surrounded_regions(grid: List[List[int]]) -> List[List[int]]: You are given an m x n grid where each cell can either be: - 0 representing water - 1 representing land A region is a group of 1's (land) connected 4-directionally (horizontal or vertical). You need to find and mark all land cells that are surrounded by water cells. A land cell is considered surrounded by water if all horizontal and vertical neighbors are either water or are also part of the surroundings that do not eventually connect to the boundary of the grid. Note: The edges of the grid are assumed to be surrounded by water. Return the modified grid where all surrounded land cells are marked with 2 (a new value to indicate they are surrounded by water). If no cells are surrounded by water, return the grid as it is. >>> grid = [ ... [1, 1, 1, 1, 1, 1, 1], ... [1, 0, 0, 0, 0, 0, 1], ... [1, 0, 1, 1, 1, 0, 1], ... [1, 0, 1, 0, 1, 0, 1], ... [1, 0, 1, 1, 1, 0, 1], ... [1, 0, 0, 0, 0, 0, 1], ... [1, 1, 1, 1, 1, 1, 1] ... ] >>> surrounded_regions(grid) [ [1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 2, 2, 2, 0, 1], [1, 0, 2, 0, 2, 0, 1], [1, 0, 2, 2, 2, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1] ] >>> grid = [ ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0] ... ] >>> surrounded_regions(grid) [ [0, 0, 0, 0], [0, 2, 2, 0], [0, 2, 2, 0], [0, 0, 0, 0] ] # Insert solution implementation here","solution":"def surrounded_regions(grid): rows, cols = len(grid), len(grid[0]) def dfs(r, c): # If we're out of bounds or at a cell that isn't land, return if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] != 1: return # Mark the current cell as visited by changing it to -1 grid[r][c] = -1 # Perform DFS in all 4-directionally connected cells (up, down, left, right) dfs(r - 1, c) dfs(r + 1, c) dfs(r, c - 1) dfs(r, c + 1) # First, mark all lands connected to the boundaries as not surrounded using DFS for i in range(rows): for j in range(cols): if (i in [0, rows - 1] or j in [0, cols - 1]) and grid[i][j] == 1: dfs(i, j) # Now, mark all surrounded land cells with 2 for i in range(rows): for j in range(cols): if grid[i][j] == 1: grid[i][j] = 2 elif grid[i][j] == -1: grid[i][j] = 1 return grid"},{"question":"from typing import List def find_kth_missing(arr: List[int], k: int) -> int: Finds the k-th missing positive integer in a sorted array of unique integers. Parameters: arr (List[int]): A sorted list of unique integers. k (int): The k-th missing positive integer to find. Returns: int: The k-th missing positive integer, or -1 if there are fewer than k missing positive integers. Examples: >>> find_kth_missing([2, 3, 4, 7, 11], 5) 9 >>> find_kth_missing([1, 2, 3, 4], 2) 6 >>> find_kth_missing([1, 2, 3, 4], 1) 5 >>> find_kth_missing([2, 3, 4, 7, 11], 10) 15 >>> find_kth_missing([], 1) 1 >>> find_kth_missing([1, 2, 3], 100) 103 >>> find_kth_missing([10, 20, 30], 5) 5","solution":"def find_kth_missing(arr, k): Finds the k-th missing positive integer in a sorted array of unique integers. Parameters: arr (List[int]): A sorted list of unique integers. k (int): The k-th missing positive integer to find. Returns: int: The k-th missing positive integer, or -1 if there are fewer than k missing positive integers. missing_count = 0 current = 1 index = 0 while missing_count < k: if index < len(arr) and arr[index] == current: index += 1 else: missing_count += 1 if missing_count == k: return current current += 1 return -1"},{"question":"def can_make_equal(x: int, y: int, arr: List[int]) -> bool: Determines if it is possible to make all elements of the array equal after performing any number of the allowed operations (increment one element by x or decrement one element by y) Args: x (int): the increment value y (int): the decrement value arr (array of int): the input array of integers Returns: bool: True if it is possible to make all elements equal, otherwise False >>> can_make_equal(2, 3, [5, 5, 5, 5]) == True >>> can_make_equal(2, 2, [10, 12, 14, 16]) == True >>> can_make_equal(3, 6, [9, 15, 21]) == True >>> can_make_equal(4, 5, [1, 2, 3]) == False >>> can_make_equal(3, 4, [5]) == True","solution":"def can_make_equal(x, y, arr): Determines if it is possible to make all elements of the array equal after performing any number of the allowed operations (increment one element by x or decrement one element by y) Args: x (int): the increment value y (int): the decrement value arr (array of int): the input array of integers Returns: bool: True if it is possible to make all elements equal, otherwise False min_val = min(arr) gcd = y for num in arr: if (num - min_val) % gcd != 0: return False return True"},{"question":"from typing import List def distribute(nums: List[int], k: int) -> int: Distribute the elements of nums into k subarrays such that the largest sum of any subarray is minimized. :param nums: List of integers to be partitioned. :param k: Number of partitions. :returns: The minimized largest sum among the partitions. Example: >>> distribute([7, 2, 5, 10, 8], 2) 18 >>> distribute([10], 1) 10 >>> distribute([1, 1, 1, 1, 1], 2) 3 >>> distribute([7, 2, 5, 10, 8], 5) 10 >>> distribute([2, 3, 5, 7, 11, 13], 1) 41 >>> distribute([7, 2, 5, 10, 8], 5) 10","solution":"def distribute(nums, k): def can_partition(nums, k, max_sum): current_sum = 0 required_subarrays = 1 for num in nums: if current_sum + num > max_sum: required_subarrays += 1 current_sum = num if required_subarrays > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_partition(nums, k, mid): right = mid else: left = mid + 1 return left"},{"question":"class ReflectMatrix: Class to reflect a matrix along its main diagonal. def __init__(self, matrix): Initializes the ReflectMatrix object with the given matrix. :param matrix: List of List of int - n x n matrix. def reflect(self): Reflects the matrix along its main diagonal. def getMatrix(self): Returns the matrix after it has been reflected. :return: List of List of int if __name__ == \\"__main__\\": matrix_1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rm_1 = ReflectMatrix(matrix_1) rm_1.reflect() assert rm_1.getMatrix() == [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] matrix_2 = [ [1, 2], [3, 4] ] rm_2 = ReflectMatrix(matrix_2) rm_2.reflect() assert rm_2.getMatrix() == [ [1, 3], [2, 4] ] matrix_3 = [ [5] ] rm_3 = ReflectMatrix(matrix_3) rm_3.reflect() assert rm_3.getMatrix() == [ [5] ] matrix_4 = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] rm_4 = ReflectMatrix(matrix_4) rm_4.reflect() assert rm_4.getMatrix() == [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ]","solution":"class ReflectMatrix: def __init__(self, matrix): Initialize the ReflectMatrix object with the given matrix. self.matrix = matrix def reflect(self): Reflects the matrix along its main diagonal. n = len(self.matrix) for i in range(n): for j in range(i + 1, n): # Swap element at (i, j) with element at (j, i) self.matrix[i][j], self.matrix[j][i] = self.matrix[j][i], self.matrix[i][j] def getMatrix(self): Returns the matrix after it has been reflected. return self.matrix"},{"question":"from typing import List def findMaxForm(strs: List[str], m: int, n: int) -> int: Find the maximum number of binary strings you can form with given m zeros and n ones. Each binary string can represent a sum of the count of '0's and '1's, corresponding to m zeros and n ones. You cannot reuse any string. Args: strs (List[str]): List of binary strings. m (int): Number of zeros you can use. n (int): Number of ones you can use. Returns: int: Maximum number of binary strings you can form. >>> findMaxForm([\\"10\\", \\"0001\\", \\"111001\\", \\"1\\", \\"0\\"], 5, 3) 4 >>> findMaxForm([\\"10\\", \\"0\\", \\"1\\"], 1, 1) 2","solution":"from typing import List def findMaxForm(strs: List[str], m: int, n: int) -> int: # dp[i][j] means the maximum number of strings we can form with i 0s and j 1s dp = [[0] * (n + 1) for _ in range(m + 1)] for s in strs: zeros = s.count('0') ones = s.count('1') # Update the dp array from bottom right to top left for i in range(m, zeros - 1, -1): for j in range(n, ones - 1, -1): dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1) return dp[m][n]"},{"question":"class TrieNode: def __init__(self): self.children = {} self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: Inserts a word into the Trie. >>> trie = Trie() >>> trie.insert(\\"apple\\") def search(self, word: str) -> bool: Returns True if the word is in the Trie, otherwise returns False. >>> trie = Trie() >>> trie.insert(\\"apple\\") >>> trie.search(\\"apple\\") == True >>> trie.search(\\"app\\") == False def startsWith(self, prefix: str) -> bool: Returns True if there is any word in the Trie that starts with the given prefix, otherwise returns False. >>> trie = Trie() >>> trie.insert(\\"apple\\") >>> trie.startsWith(\\"app\\") == True >>> trie.startsWith(\\"appl\\") == True >>> trie.startsWith(\\"apple\\") == True >>> trie.startsWith(\\"apples\\") == False","solution":"class TrieNode: def __init__(self): self.children = {} self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_word def startsWith(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"def find_max_average(arr: List[int], k: int) -> float: Find the maximum average value of any contiguous subarray of length k. >>> find_max_average([1, 12, -5, -6, 50, 3], 4) 12.75 >>> find_max_average([4, 2, 1, 3, 5], 1) 5.0 >>> find_max_average([7, 3, 6, 0, 8], 5) 4.8 >>> find_max_average([-4, -2, -1, -3, -5], 2) -1.5 >>> find_max_average([1, 2], 3) \\"The length of the array must be greater than or equal to k.\\"","solution":"def find_max_average(arr, k): if len(arr) < k: raise ValueError(\\"The length of the array must be greater than or equal to k.\\") # Initial window sum max_sum = sum(arr[:k]) window_sum = max_sum # Sliding window to find the maximum sum for i in range(k, len(arr)): window_sum = window_sum - arr[i - k] + arr[i] if window_sum > max_sum: max_sum = window_sum # Calculate the maximum average max_average = max_sum / k return round(max_average, 5)"},{"question":"def canPartition(arr: List[int]) -> bool: Determines whether the array can be partitioned into two subsets with equal sum. >>> canPartition([1, 5, 11, 5]) True >>> canPartition([1, 2, 3, 5]) False","solution":"def canPartition(arr): Determines whether the array can be partitioned into two subsets with equal sum. total_sum = sum(arr) if total_sum % 2 != 0: return False target = total_sum // 2 n = len(arr) dp = [[False] * (target + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): dp[i][0] = True for j in range(1, target + 1): dp[i][j] = dp[i - 1][j] if arr[i - 1] <= j: dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]] return dp[n][target]"},{"question":"def findSubstring(s: str, words: List[str]) -> int: Return the length of the longest substring in s that is a concatenation of each word in words exactly once and without any intervening characters. >>> findSubstring(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) == 6 >>> findSubstring(\\"wordgoodgoodgoodbestword\\", [\\"word\\", \\"good\\", \\"best\\", \\"word\\"]) == 0 >>> findSubstring(\\"barfoofoobarthefoobarman\\", [\\"bar\\", \\"foo\\", \\"the\\"]) == 9 >>> findSubstring(\\"abcabcabc\\", [\\"ab\\", \\"bc\\", \\"ca\\"]) == 6 >>> findSubstring(\\"\\", [\\"word\\"]) == 0 >>> findSubstring(\\"foobar\\", [\\"foo\\", \\"bar\\"]) == 6 >>> findSubstring(\\"foobar\\", [\\"foo\\", \\"baz\\"]) == 0 >>> findSubstring(\\"aaaaaaaa\\", [\\"aa\\", \\"aa\\", \\"aa\\"]) == 6 def test_findSubstring(): assert findSubstring(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) == 6 assert findSubstring(\\"wordgoodgoodgoodbestword\\", [\\"word\\", \\"good\\", \\"best\\", \\"word\\"]) == 0 assert findSubstring(\\"barfoofoobarthefoobarman\\", [\\"bar\\", \\"foo\\", \\"the\\"]) == 9 assert findSubstring(\\"abcabcabc\\", [\\"ab\\", \\"bc\\", \\"ca\\"]) == 6 assert findSubstring(\\"\\", [\\"word\\"]) == 0 assert findSubstring(\\"foobar\\", [\\"foo\\", \\"bar\\"]) == 6 assert findSubstring(\\"foobar\\", [\\"foo\\", \\"baz\\"]) == 0 assert findSubstring(\\"aaaaaaaa\\", [\\"aa\\", \\"aa\\", \\"aa\\"]) == 6 def test_findSubstring_different_word_lengths(): assert findSubstring(\\"abfoobar\\", [\\"ab\\", \\"fo\\", \\"obar\\"]) == 0","solution":"def findSubstring(s, words): Return the length of the longest substring in s that is a concatenation of each word in words exactly once and without any intervening characters. from collections import Counter if not s or not words or not words[0]: return 0 word_length = len(words[0]) word_count = len(words) total_length = word_length * word_count word_dict = Counter(words) def is_concatenation(start): seen_words = Counter() for i in range(start, start + total_length, word_length): current_word = s[i:i+word_length] if current_word not in word_dict: return False seen_words[current_word] += 1 if seen_words[current_word] > word_dict[current_word]: return False return True for i in range(len(s) - total_length + 1): if is_concatenation(i): return total_length return 0"},{"question":"from typing import List def minimize_max_traffic(n: int, roads: List[List[int]], traffic: List[int]) -> int: Given a city with n intersections and n roads, this function reroutes traffic by swapping the traffic values of two intersections to minimize the maximum traffic congestion at any intersection. :param n: int, the number of intersections :param roads: List[List[int]], the roads connecting the intersections :param traffic: List[int], the traffic congestion at each intersection :return: int, the minimum maximum traffic congestion possible after swapping Example: >>> minimize_max_traffic(3, [[0, 1], [1, 2], [2, 0]], [10, 20, 30]) 20 >>> minimize_max_traffic(4, [[0, 1], [1, 2], [2, 3], [3, 0]], [5, 15, 25, 35]) 25 >>> minimize_max_traffic(5, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 0]], [8, 12, 20, 28, 35]) 28 >>> minimize_max_traffic(3, [[0, 1], [1, 2], [2, 0]], [10, 10, 10]) 10 >>> minimize_max_traffic(3, [[0, 1], [1, 2], [2, 0]], [1, 50, 100]) 50","solution":"def minimize_max_traffic(n, roads, traffic): Given a city with n intersections and n roads, this function reroutes traffic by swapping the traffic values of two intersections to minimize the maximum traffic congestion at any intersection. :param n: int, the number of intersections :param roads: List[List[int]], the roads connecting the intersections :param traffic: List[int], the traffic congestion at each intersection :return: int, the minimum maximum traffic congestion possible after swapping # Sort the traffic values traffic_sorted = sorted(traffic) # The minimum maximum traffic congestion after swapping will always be between # the initially sorted penultimate and second values as we can swap # the lowest traffic value with the highest and similar considerations. possible_scenarios = [] if n > 1: possible_scenarios.append(max(traffic_sorted[1], traffic_sorted[-1])) possible_scenarios.append(max(traffic_sorted[0], traffic_sorted[-2])) return min(possible_scenarios)"},{"question":"def is_palindrome(s: str) -> bool: Return True if the input string s is a palindrome, ignoring spaces, punctuation, and capitalization. Otherwise, return False. >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"madam\\") == True >>> is_palindrome(\\"Madam\\") == True >>> is_palindrome(\\"A man a plan a canal Panama\\") == True >>> is_palindrome(\\"Able , was I ere I saw eLba\\") == True >>> is_palindrome(\\"hello\\") == False >>> is_palindrome(\\"12321\\") == True >>> is_palindrome(\\"12345\\") == False >>> is_palindrome(\\"No 'x' in Nixon!\\") == True # Your code here","solution":"def is_palindrome(s): Returns True if the input string s is a palindrome, ignoring spaces, punctuation, and capitalization. Otherwise, returns False. # Filter only alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered list of characters reads the same forwards and backwards return filtered_chars == filtered_chars[::-1]"},{"question":"def reverse_subarray(arr, i, j): Reverses the order of the elements in arr between the indices i and j (inclusive). Parameters: arr (list): The input array. i (int): The starting index of the subarray to reverse. j (int): The ending index of the subarray to reverse. Returns: list: The modified array with the subarray reversed. # Unit Tests def test_reverse_subarray_middle(): assert reverse_subarray([1, 2, 3, 4, 5], 1, 3) == [1, 4, 3, 2, 5] def test_reverse_subarray_edge(): assert reverse_subarray([1, 2, 3, 4, 5], 0, 4) == [5, 4, 3, 2, 1] def test_reverse_subarray_single_element(): assert reverse_subarray([1, 2, 3, 4, 5], 2, 2) == [1, 2, 3, 4, 5] def test_reverse_subarray_start_end_same(): assert reverse_subarray([1, 2, 3, 4, 5], 1, 1) == [1, 2, 3, 4, 5] def test_reverse_subarray_empty(): assert reverse_subarray([], 0, 0) == []","solution":"def reverse_subarray(arr, i, j): Reverses the order of the elements in arr between the indices i and j (inclusive). Parameters: arr (list): The input array. i (int): The starting index of the subarray to reverse. j (int): The ending index of the subarray to reverse. Returns: list: The modified array with the subarray reversed. while i < j: arr[i], arr[j] = arr[j], arr[i] i += 1 j -= 1 return arr"},{"question":"def rob(houses: List[int]) -> int: Determine the maximum amount of money a thief can rob without triggering the security system. :param houses: List[int] - a list of integers representing the profit of \`n\` houses :return: int - the maximum money that can be robbed >>> rob([]) 0 >>> rob([50]) 50 >>> rob([20, 30]) 30 >>> rob([30, 20]) 30 >>> rob([1, 2, 3, 1]) 4 >>> rob([2, 7, 9, 3, 1]) 12 >>> rob([2, 1, 1, 2]) 4 >>> rob([5, 5, 5, 5, 5, 5]) 15","solution":"def rob(houses): Determine the maximum amount of money a thief can rob without triggering the security system. :param houses: List[int] - a list of integers representing the profit of n houses :return: int - the maximum money that can be robbed if not houses: return 0 if len(houses) == 1: return houses[0] # Dynamic programming array to store the maximum profit up to each house dp = [0] * len(houses) dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, len(houses)): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1]"},{"question":"def find_dominant_character(s: str) -> str: Returns the dominant character if one exists, otherwise an empty string. A character is dominant if the number of times it appears in the string is strictly greater than the occurrences of all other characters combined. >>> find_dominant_character(\\"aabbc\\") '' >>> find_dominant_character(\\"aaaab\\") 'a' >>> find_dominant_character(\\"\\") '' >>> find_dominant_character(\\"a\\") 'a' >>> find_dominant_character(\\"aaaa\\") 'a' >>> find_dominant_character(\\"aabbccddeeffgghhiijja\\") '' >>> find_dominant_character(\\"aaabc\\") 'a'","solution":"def find_dominant_character(s): Returns the dominant character if one exists, otherwise an empty string. A character is dominant if the number of times it appears in the string is strictly greater than the occurrences of all other characters combined. if not s: return \\"\\" char_count = {} # Count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 total_length = len(s) for char, count in char_count.items(): if count > (total_length - count): return char return \\"\\""},{"question":"from typing import List def can_traverse(grid: List[List[int]], t: int) -> bool: Determine whether there is a path from the top-left cell to the bottom-right cell in the matrix such that the absolute height differences between adjacent cells in the path do not exceed t. Args: grid : List[List[int]] - m x n grid containing integers representing cell heights t : int - threshold for the absolute height difference between adjacent cells Returns: bool - True if such a path exists, False otherwise Example: >>> can_traverse([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 0) True >>> can_traverse([[1, 3, 5], [2, 8, 7], [10, 13, 15]], 1) False","solution":"def can_traverse(grid, t): from collections import deque m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y, visited): return 0 <= x < m and 0 <= y < n and not visited[x][y] visited = [[False for _ in range(n)] for _ in range(m)] # Start BFS from the top-left cell (0, 0) queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() if x == m - 1 and y == n - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny, visited) and abs(grid[nx][ny] - grid[x][y]) <= t: visited[nx][ny] = True queue.append((nx, ny)) return False"},{"question":"def unique_substrings_count(s: str, n: int) -> int: Returns the number of substrings of \`s\` whose length is exactly \`n\` and whose characters are unique. Parameters: s (str): Input string consisting of lowercase English letters. n (int): Length of the substrings to consider. Returns: int: Number of substrings of length \`n\` with unique characters. >>> unique_substrings_count(\\"abcabc\\", 3) 4 >>> unique_substrings_count(\\"aaaaa\\", 2) 0 >>> unique_substrings_count(\\"a\\", 1) 1 >>> unique_substrings_count(\\"ab\\", 2) 1 >>> unique_substrings_count(\\"ab\\", 3) 0 >>> unique_substrings_count(\\"\\", 1) 0 >>> unique_substrings_count(\\"\\", 0) 0 >>> unique_substrings_count(\\"abcdef\\", 6) 1 >>> unique_substrings_count(\\"abcdef\\", 5) 2 >>> unique_substrings_count(\\"abcdabc\\", 4) 4 >>> unique_substrings_count(\\"abcdefg\\", 7) 1","solution":"def unique_substrings_count(s, n): Returns the number of substrings of \`s\` whose length is exactly \`n\` and whose characters are unique. Parameters: s (str): Input string consisting of lowercase English letters. n (int): Length of the substrings to consider. Returns: int: Number of substrings of length \`n\` with unique characters. if n > len(s) or n < 1: return 0 unique_count = 0 for i in range(len(s) - n + 1): substring = s[i:i+n] if len(set(substring)) == n: unique_count += 1 return unique_count"},{"question":"def friend_groups(n: int, requests: List[List[int]]) -> int: In an online multiplayer game, you are tasked with managing friend requests among \`n\` players. You are given a 0-indexed 2D integer array \`requests\`, where each \`requests[i]\` is an array of two integers \`[a, b]\` representing a friend request from player \`a\` to player \`b\`. Friendships are bidirectional, meaning if player \`a\` and player \`b\` become friends then both players will consider each other as friends. Your task is to process each friend request in the order they appear and compute the total number of friend groups (clusters of connected players) after all requests have been processed. Return the number of such friend groups. Note that each player can belong to only one friend group. >>> friend_groups(5, []) 5 >>> friend_groups(4, [[0, 1], [1, 2], [2, 3], [0, 3]]) 1 >>> friend_groups(6, [[0, 1], [2, 3], [4, 5]]) 3 >>> friend_groups(4, [[0, 1]]) 3 >>> friend_groups(5, [[0, 1], [1, 2], [3, 4]]) 2 >>> friend_groups(7, [[0, 1], [2, 3], [4, 5], [1, 2], [3, 6], [5, 6]]) 1","solution":"class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size self.count = size def find(self, p): if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) # path compression return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 self.count -= 1 def get_count(self): return self.count def friend_groups(n, requests): uf = UnionFind(n) for a, b in requests: uf.union(a, b) return uf.get_count()"},{"question":"def four_sum(arr: List[int], target: int) -> bool: Determines if there are four elements in the list \`arr\` that add up to \`target\`. Args: arr (list of int): List of integers to analyze. target (int): The target sum. Returns: bool: True if there are four elements that add up to the target, False otherwise. >>> four_sum([1, 2, 3, 4, 5], 10) True >>> four_sum([1, 2, 3, 4, 5], 50) False >>> four_sum([1, 0, -1, 0, -2, 2], 0) True >>> four_sum([1, -2, 3, 0, -6, 1, 6], 0) True >>> four_sum([2, 2, 2, 2, 2], 8) True >>> four_sum([], 0) False >>> four_sum([1, 2, 3], 6) False","solution":"def four_sum(arr, target): Determines if there are four elements in the list \`arr\` that add up to \`target\`. Args: arr (list of int): List of integers to analyze. target (int): The target sum. Returns: bool: True if there are four elements that add up to the target, False otherwise. arr.sort() n = len(arr) for i in range(n - 3): if i > 0 and arr[i] == arr[i - 1]: continue for j in range(i + 1, n - 2): if j > i + 1 and arr[j] == arr[j - 1]: continue left = j + 1 right = n - 1 while left < right: total = arr[i] + arr[j] + arr[left] + arr[right] if total == target: return True elif total < target: left += 1 else: right -= 1 return False"},{"question":"def has_quadruplet(nums: List[int], target: int) -> bool: Determines if there exist four distinct indices i, j, k, and l such that the sum of elements at those indices equals the target. :param nums: List[int] - a list of integers :param target: int - the target sum for the quadruplet :return: bool - True if such quadruplet exists, otherwise False >>> has_quadruplet([1, 2, 3, 4, 5], 10) True >>> has_quadruplet([1, 2, 3, 4, 5], 50) False >>> has_quadruplet([], 10) False >>> has_quadruplet([1, 2, 3], 6) False >>> has_quadruplet([-1, -2, -3, -4, 0], -10) True >>> has_quadruplet([1, 2, -3, 4, -1, 0], 2) True >>> has_quadruplet([2, 2, 2, 2, 2], 8) True","solution":"def has_quadruplet(nums, target): Determines if there exist four distinct indices i, j, k, and l such that the sum of elements at those indices equals the target. :param nums: List[int] - a list of integers :param target: int - the target sum for the quadruplet :return: bool - True if such quadruplet exists, otherwise False nums_len = len(nums) if nums_len < 4: return False nums.sort() for i in range(nums_len - 3): for j in range(i + 1, nums_len - 2): for k in range(j + 1, nums_len - 1): for l in range(k + 1, nums_len): if nums[i] + nums[j] + nums[k] + nums[l] == target: return True return False"},{"question":"def isAnagram(s: str, t: str) -> bool: Checks if string t is an anagram of string s. Parameters: s (str): The original string. t (str): The string to check if it is an anagram of s. Returns: bool: True if t is an anagram of s, False otherwise. >>> isAnagram(\\"listen\\", \\"silent\\") True >>> isAnagram(\\"hello\\", \\"billion\\") False","solution":"def isAnagram(s, t): Checks if string t is an anagram of string s. Parameters: s (str): The original string. t (str): The string to check if it is an anagram of s. Returns: bool: True if t is an anagram of s, False otherwise. if len(s) != len(t): return False return sorted(s) == sorted(t)"},{"question":"def maximalSquare(mat: List[List[int]]) -> int: Given an \`m x n\` matrix \`mat\` filled with non-negative integers, find the largest square containing only \`1\`s and return its area. >>> maximalSquare([]) 0 >>> maximalSquare([[0]]) 0 >>> maximalSquare([[1]]) 1 >>> maximalSquare([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> maximalSquare([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 9 >>> maximalSquare([[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]) 4 >>> maximalSquare([[1, 1, 0, 1], [1, 1, 0, 1], [1, 1, 1, 1]]) 4","solution":"def maximalSquare(mat): if not mat: return 0 m, n = len(mat), len(mat[0]) dp = [[0] * n for _ in range(m)] max_side = 0 for i in range(m): for j in range(n): if mat[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"def min_moves_to_arrange(heights: List[int]) -> int: You are given an integer array 'heights' representing the heights of students in a classroom, where 'heights[i]' is the height of the 'ith' student. The students are currently standing in a random order. Your task is to find the minimum number of students that must be moved to new positions such that the entire class is arranged in non-decreasing order of their heights. Return the minimum number of moves required. >>> min_moves_to_arrange([1, 2, 3, 4, 5]) 0 >>> min_moves_to_arrange([5, 4, 3, 2, 1]) 4 >>> min_moves_to_arrange([3, 1, 4, 2, 5]) 2 >>> min_moves_to_arrange([1]) 0 >>> min_moves_to_arrange([]) 0 >>> min_moves_to_arrange([2, 2, 2, 2]) 0 >>> min_moves_to_arrange([1, 3, 2, 4, 5]) 1","solution":"def min_moves_to_arrange(heights): # find the length of LIS using dynamic programming n = len(heights) if n == 0: return 0 dp = [1] * n for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: dp[i] = max(dp[i], dp[j] + 1) lis_length = max(dp) return n - lis_length"},{"question":"def max_length_of_special_substring(s: str) -> int: Finds the maximum length of a special substring containing equal numbers of 'a' and 'b' in the string s. If no such substring exists, returns 0. >>> max_length_of_special_substring(\\"abab\\") 4 >>> max_length_of_special_substring(\\"aabb\\") 4 >>> max_length_of_special_substring(\\"aaaa\\") 0 >>> max_length_of_special_substring(\\"abbaba\\") 6 >>> max_length_of_special_substring(\\"babababa\\") 8 >>> max_length_of_special_substring(\\"\\") 0 >>> max_length_of_special_substring(\\"a\\") 0 >>> max_length_of_special_substring(\\"b\\") 0","solution":"def max_length_of_special_substring(s): Finds the maximum length of a special substring containing equal numbers of 'a' and 'b' in the string s. If no such substring exists, returns 0. max_length = 0 for i in range(len(s)): count_a = 0 count_b = 0 for j in range(i, len(s)): if s[j] == 'a': count_a += 1 elif s[j] == 'b': count_b += 1 if count_a == count_b: max_length = max(max_length, j - i + 1) return max_length"},{"question":"from typing import List def max_non_overlapping_tasks(tasks: List[List[int]]) -> int: Returns the maximum number of non-overlapping tasks that can be scheduled. >>> max_non_overlapping_tasks([[1, 3], [2, 5], [4, 6]]) == 2 >>> max_non_overlapping_tasks([[1, 2], [2, 3], [3, 4]]) == 3 >>> max_non_overlapping_tasks([[1, 4], [2, 5], [3, 6]]) == 1 pass","solution":"def max_non_overlapping_tasks(tasks): Returns the maximum number of non-overlapping tasks that can be scheduled. if not tasks: return 0 # Sort tasks based on their end time tasks.sort(key=lambda x: x[1]) count = 0 end_time = 0 for task in tasks: if task[0] >= end_time: count += 1 end_time = task[1] return count"},{"question":"def min_servers(load, maxLoad): Given a list of loads and the maximum load a single server can handle, returns the minimum number of servers required to handle all loads without exceeding the max load for any server. >>> min_servers([1, 2, 3], 10) 1 >>> min_servers([10, 10, 10], 10) 3 >>> min_servers([3, 8, 2, 7, 5, 4], 10) 3 >>> min_servers([1]*15, 5) 3 >>> min_servers([], 10) 0 >>> min_servers([50], 50) 1 >>> min_servers([1, 2, 3], 0) Traceback (most recent call last): ... ValueError: maxLoad must be a positive integer. >>> min_servers([5, 6, 3, 7, 8], 10) 4 >>> min_servers([1, 2, 2, 3], 8) 1","solution":"def min_servers(load, maxLoad): Given a list of loads and the maximum load a single server can handle, returns the minimum number of servers required to handle all loads without exceeding the max load for any server. if maxLoad <= 0: raise ValueError(\\"maxLoad must be a positive integer.\\") load.sort(reverse=True) servers = [] for l in load: placed = False for i in range(len(servers)): if servers[i] + l <= maxLoad: servers[i] += l placed = True break if not placed: servers.append(l) return len(servers)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def postorder_traversal(root): Returns the postorder traversal of the binary tree as a list of integers. pass # Unit Tests def test_postorder_traversal_single_node(): root = TreeNode(1) assert postorder_traversal(root) == [1] def test_postorder_traversal_empty_tree(): assert postorder_traversal(None) == [] def test_postorder_traversal_balanced_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) assert postorder_traversal(root) == [4, 5, 2, 3, 1] def test_postorder_traversal_left_skewed_tree(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) root.left.left.left = TreeNode(4) assert postorder_traversal(root) == [4, 3, 2, 1] def test_postorder_traversal_right_skewed_tree(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) root.right.right.right = TreeNode(4) assert postorder_traversal(root) == [4, 3, 2, 1] def test_postorder_traversal_complex_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) assert postorder_traversal(root) == [4, 5, 2, 6, 7, 3, 1]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def postorder_traversal(root): Returns the postorder traversal of the binary tree as a list of integers. result = [] def traverse(node): if node is not None: traverse(node.left) traverse(node.right) result.append(node.val) traverse(root) return result"},{"question":"def unique_paths(grid: List[List[int]]) -> int: Determine the number of distinct paths the robot can take to reach the bottom-right corner of the grid without triggering any mines. Parameters: grid (list of list of int): 2D grid representation of the minefield where 0 is an empty cell and 1 is a mine. Returns: int: The number of unique paths from the top-left corner to the bottom-right corner. >>> unique_paths([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 6 >>> unique_paths([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> unique_paths([[0, 1], [1, 0]]) 0 >>> unique_paths([[0]]) 1 >>> unique_paths([ ... [1, 0], ... [0, 0] ... ]) 0 >>> unique_paths([ ... [0, 0], ... [0, 1] ... ]) 0","solution":"def unique_paths(grid): Function to calculate the number of unique paths in a minefield grid. Parameters: grid (list of list of int): 2D grid representation of the minefield where 0 is an empty cell and 1 is a mine. Returns: int: The number of unique paths from the top-left corner to the bottom-right corner. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] return dp[m - 1][n - 1]"},{"question":"def min_and_sum_arrays(arr1, arr2): Given two integer arrays \`arr1\` and \`arr2\` of the same length, return a tuple containing a new array \`result\` where each element \`result[i]\` is the minimum of \`arr1[i]\` and \`arr2[i]\` and the sum of all elements in the \`result\` array. >>> min_and_sum_arrays([1, 2, 3], [1, 2, 3]) ([1, 2, 3], 6) >>> min_and_sum_arrays([4, 2, 6], [1, 5, 3]) ([1, 2, 3], 6) >>> min_and_sum_arrays([10, 20, 30], [5, 25, 15]) ([5, 20, 15], 40) >>> min_and_sum_arrays([-1, -2, -3], [-1, -3, -2]) ([-1, -3, -3], -7) >>> min_and_sum_arrays([0, 0, 0], [0, 0, 0]) ([0, 0, 0], 0)","solution":"def min_and_sum_arrays(arr1, arr2): Given two integer arrays \`arr1\` and \`arr2\` of the same length, return a tuple containing a new array \`result\` where each element \`result[i]\` is the minimum of \`arr1[i]\` and \`arr2[i]\` and the sum of all elements in the \`result\` array. result = [min(a, b) for a, b in zip(arr1, arr2)] total_sum = sum(result) return result, total_sum"},{"question":"def count_distinct_characters(s: str, queries: List[Tuple[int, int]]) -> List[int]: Returns an array of distinct character counts for each query's substring. Parameters: s (str): The input string. queries (list of tuple of int): Array of queries where each query is a tuple (l, r) representing the bounds of the substring. Returns: list: Array of distinct character counts for each substring defined by queries. >>> count_distinct_characters(\\"abcba\\", [(0, 1), (1, 4), (2, 2), (0, 4)]) [2, 3, 1, 3] >>> count_distinct_characters(\\"abcba\\", [(2, 1)]) [0] >>> count_distinct_characters(\\"abcba\\", [(0, 0), (2, 2), (4, 4)]) [1, 1, 1] >>> count_distinct_characters(\\"abcba\\", [(0, 4)]) [3] >>> count_distinct_characters(\\"aaaa\\", [(0, 0), (0, 3), (1, 2)]) [1, 1, 1] >>> count_distinct_characters(\\"abcdefgh\\", [(0, 3), (4, 7)]) [4, 4] >>> count_distinct_characters(\\"abcdefgh\\", [(0, 3), (2, 5)]) [4, 4]","solution":"def count_distinct_characters(s, queries): Returns an array of distinct character counts for each query's substring. Parameters: s (str): The input string. queries (list of tuple): Array of queries where each query is a tuple (l, r) representing the bounds of the substring. Returns: list: Array of distinct character counts for each substring defined by queries. results = [] for l, r in queries: if l > r: results.append(0) else: substring = s[l:r+1] distinct_characters = set(substring) results.append(len(distinct_characters)) return results"},{"question":"from typing import List, Tuple def min_operations_to_transform(initial: str, target: str, transformations: List[Tuple[str, str, int]]) -> int: Determine the minimum number of operations required to transform \`initial\` to \`target\` using the given transformations. If it's not possible to transform \`initial\` to \`target\`, return \`-1\`. >>> min_operations_to_transform(\\"a\\", \\"b\\", [(\\"a\\", \\"b\\", 1), (\\"b\\", \\"c\\", 1)]) == 1 >>> min_operations_to_transform(\\"a\\", \\"c\\", [(\\"a\\", \\"b\\", 1), (\\"b\\", \\"c\\", 1)]) == 2 >>> min_operations_to_transform(\\"a\\", \\"d\\", [(\\"a\\", \\"b\\", 1), (\\"c\\", \\"d\\", 1)]) == -1 >>> min_operations_to_transform(\\"a\\", \\"a\\", [(\\"a\\", \\"b\\", 1)]) == 0 >>> min_operations_to_transform(\\"a\\", \\"d\\", [(\\"a\\", \\"b\\", 1), (\\"a\\", \\"c\\", 2), (\\"b\\", \\"d\\", 1), (\\"c\\", \\"d\\", 1)]) == 2 >>> min_operations_to_transform(\\"a\\", \\"e\\", [(\\"a\\", \\"b\\", 1), (\\"b\\", \\"c\\", 2), (\\"c\\", \\"d\\", 3), (\\"d\\", \\"e\\", 4)]) == 10","solution":"from collections import deque, defaultdict def min_operations_to_transform(initial, target, transformations): adj_list = defaultdict(list) for start, end, steps in transformations: adj_list[start].append((end, steps)) queue = deque([(initial, 0)]) visited = set() visited.add(initial) while queue: current, current_steps = queue.popleft() if current == target: return current_steps for neighbor, steps in adj_list[current]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, current_steps + steps)) return -1"},{"question":"def find_single_element(arr): Returns the element that appears only once in the array. The array is guaranteed to have all elements appearing exactly twice except for one element. Time Complexity: O(n) Space Complexity: O(1) >>> find_single_element([2, 1, 4, 5, 2, 4, 1]) == 5 >>> find_single_element([3, 3, 7, 9, 9]) == 7 >>> find_single_element([10, 20, 10, 30, 30]) == 20 >>> find_single_element([1]) == 1 >>> find_single_element([0, 0, -1, -2, -2]) == -1","solution":"def find_single_element(arr): Returns the element that appears only once in the array. The array is guaranteed to have all elements appearing exactly twice except for one element. Time Complexity: O(n) Space Complexity: O(1) unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"def max_sum_subsequence(nums, k): Returns the maximum sum of a non-empty subsequence of nums that contains at most k distinct numbers. Args: nums: List[int] - a list of integers k: int - the maximum number of distinct numbers allowed in the subsequence Returns: int - the maximum sum of the subsequence Examples: >>> max_sum_subsequence([4, 3, 3, 2, 1], 2) 10 >>> max_sum_subsequence([-5, -1, -2, -3, -4, -6], 3) -6 >>> max_sum_subsequence([7], 1) 7 >>> max_sum_subsequence([0, 0, 0, -1, -2], 1) 0 >>> max_sum_subsequence([5, 5, 5, 5], 1) 20 >>> max_sum_subsequence([1, 2, 3], 0) 0 >>> max_sum_subsequence([], 5) 0 >>> max_sum_subsequence([1, 2, 2, 3, 4], 10) 12","solution":"from collections import Counter def max_sum_subsequence(nums, k): Returns the maximum sum of a non-empty subsequence of nums that contains at most k distinct numbers. if k == 0: return 0 freq = Counter(nums) freq_sorted = sorted(freq.items(), key=lambda x: x[0], reverse=True) max_sum = 0 distinct_count = 0 for num, count in freq_sorted: if distinct_count < k: max_sum += num * count distinct_count += 1 else: break return max_sum"},{"question":"def max_apples_after_swap(nums: List[int]) -> int: Returns the maximum number of apples in any one basket after performing at most one swap operation. >>> max_apples_after_swap([5]) == 5 >>> max_apples_after_swap([]) == 0 >>> max_apples_after_swap([3, 7]) == 7 >>> max_apples_after_swap([10, 1]) == 10 >>> max_apples_after_swap([1, 2, 3]) == 3 >>> max_apples_after_swap([1, 5, 3]) == 5 >>> max_apples_after_swap([4, 4, 4]) == 4 >>> max_apples_after_swap([1, 2, 3, 4, 5]) == 5 >>> max_apples_after_swap([10, 20, 30, 40, 50]) == 50 >>> max_apples_after_swap([10, 3, 15, 7, 9]) == 15","solution":"def max_apples_after_swap(nums): Returns the maximum number of apples in any one basket after performing at most one swap operation. Parameters: - nums: List[int], a list of integers representing the number of apples in different baskets. Returns: - int: The maximum number of apples in a single basket after the swap. if not nums or len(nums) == 1: return nums[0] if nums else 0 max_apples = max(nums) for i in range(len(nums)): for j in range(i + 1, len(nums)): # Swap baskets i and j nums[i], nums[j] = nums[j], nums[i] max_after_swap = max(nums) max_apples = max(max_apples, max_after_swap) # Swap back nums[i], nums[j] = nums[j], nums[i] return max_apples"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1, l2): Add two numbers represented by linked lists and return the sum as a linked list. The digits are stored in reverse order, with each node containing a single digit. >>> l1 = list_to_linkedlist([2, 4, 3]) >>> l2 = list_to_linkedlist([5, 6, 4]) >>> result = addTwoNumbers(l1, l2) >>> linkedlist_to_list(result) [7, 0, 8] >>> l1 = list_to_linkedlist([9, 9]) >>> l2 = list_to_linkedlist([5, 6, 4]) >>> result = addTwoNumbers(l1, for example, you're working on a peer-to-peer file sharing application, and the monitoring of file transfer speeds isn't efficient, you might consider if SSL connections or efficient algorithms might address other issues. - **Test the Solution**: Implement test cases incrementally and assess the viable solutions. Consult your peers, confide in mentors, or seek external opinions occasionally to get fresh perspectives and identify overlooked issues. **Final Version** .class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1, l2): Add two numbers represented by linked lists and return the sum as a linked list. The digits are stored in reverse order such that the 1's digit comes first, and each of their nodes contains a single digit. Add the two numbers and return the result in the same reverse order format. Example: Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Explanation: 342 + 465 = 807 (stored in reverse order as 7 -> 0 -> 8) >>> list_to_linkedlist([2, 4, 3]) l2 = list_to_linkedlist([5, 6, 4]) result = addTwoNumbers(l1, l2) assert linkedlist_to_list(result) == [7, 0, 8] >>> l1 = list_to_linkedlist([9, 9]) l2 = list_to_linkedlist([5, 6, 4]) result = addTwoNumbers(l1, l2) assert linkedlist_to_list(result) == [4, 6, 5] >>> l1 = list_to_linkedlist([9,9,9]) l2 = list_to_linkedlist([1]) result = addTwoNumbers(l1, l2) assert linkedlist_to_list(result) == [0,0,0,1] >>> l1 = list_to_linkedlist([0]) l2 = list_to_linkedlist([0]) result = addTwoNumbers(l1, l2) assert linkedlist_to_list(result) == [0] pass def list_to_linkedlist(lst): dummy_head = ListNode() current = dummy_head for number in lst: current.next = ListNode(number) current = current.next return dummy_head.next def linkedlist_to_list(node): lst = [] current = node while current is not None: lst.append(current.val) current = current.next return lst","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1, l2): dummy_head = ListNode() current = dummy_head carry = 0 while l1 is not None or l2 is not None or carry: val1 = l1.val if l1 is not None else 0 val2 = l2.val if l2 is not None else 0 total = val1 + val2 + carry carry = total // 10 current.next = ListNode(total % 10) current = current.next if l1 is not None: l1 = l1.next if l2 is not None: l2 = l2.next return dummy_head.next"},{"question":"def buildings_with_nice_view(heights): Returns indices of buildings that have a nice view. A building has a nice view if there are no buildings to the right that are equal to or taller than the current building. >>> buildings_with_nice_view([1, 1, 1, 1]) [3] >>> buildings_with_nice_view([1, 2, 3, 4]) [3] >>> buildings_with_nice_view([4, 3, 2, 1]) [0, 1, 2, 3] >>> buildings_with_nice_view([4, 2, 3, 1]) [0, 2, 3] >>> buildings_with_nice_view([5]) [0]","solution":"def buildings_with_nice_view(heights): Returns indices of buildings that have a nice view. A building has a nice view if there are no buildings to the right that are equal to or taller than the current building. n = len(heights) result = [] max_height = -1 # Initialize with a height lower than the minimum possible height for i in range(n-1, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] return result[::-1]"},{"question":"from typing import List def min_job_duration(nums: List[int], d: int) -> int: Given an array of integers \`nums\`, where \`nums[i]\` represents a different job's duration, and an integer \`d\` which represents the maximum number of days you have to complete all the jobs, return the minimum possible maximum job duration that can be achieved by optimally distributing the jobs over the given days. >>> min_job_duration([7, 2, 5, 10, 8], 1) == 32 >>> min_job_duration([7, 2, 5, 10, 8], 2) == 18 >>> min_job_duration([7, 2, 5, 10, 8], 3) == 14 >>> min_job_duration([1, 2, 3, 4, 5], 2) == 9 >>> min_job_duration([1, 2, 3, 4, 5], 3) == 6 >>> min_job_duration([7], 5) == 7 >>> min_job_duration([1, 1, 1, 1], 4) == 1 >>> min_job_duration([100, 200, 300, 400, 500], 5) == 500 >>> min_job_duration([10]*1000, 10) == 1000","solution":"from typing import List def is_valid(nums: List[int], days: int, max_job_duration: int) -> bool: day_count = 1 current_duration = 0 for num in nums: if current_duration + num > max_job_duration: day_count += 1 current_duration = 0 current_duration += num if day_count > days: return False return True def min_job_duration(nums: List[int], days: int) -> int: left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if is_valid(nums, days, mid): right = mid else: left = mid + 1 return left"},{"question":"def max_tasks(workers, tasks): Returns the maximum number of tasks that can be completed given workers' capacities and tasks' efforts. >>> max_tasks([3, 5, 7], [2, 4, 6]) 3 >>> max_tasks([2, 5], [3, 4, 6]) 1 >>> max_tasks([1, 1], [2, 3]) 0 >>> max_tasks([5], [5]) 1 >>> max_tasks([1, 2, 3, 4], [2, 3]) 2 >>> max_tasks([1, 2], [1, 2, 3, 4]) 2 >>> max_tasks([1, 2, 3], []) 0 >>> max_tasks([], [1, 2, 3]) 0","solution":"def max_tasks(workers, tasks): Returns the maximum number of tasks that can be completed given workers' capacities and tasks' efforts. workers.sort() tasks.sort() max_completed_tasks = 0 task_index = 0 for worker in workers: if task_index < len(tasks) and worker >= tasks[task_index]: max_completed_tasks += 1 task_index += 1 return max_completed_tasks"},{"question":"def find_substring(s: str, words: List[str]) -> List[int]: Return the starting indices of substrings in \`s\` that are concatenations of all words in \`words\`. >>> find_substring(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) == [0, 9] >>> find_substring(\\"barfoothefoobarman\\", [\\"foo\\", \\"baz\\"]) == [] >>> find_substring(\\"wordgoodgoodgoodbestword\\", [\\"word\\", \\"good\\", \\"best\\", \\"word\\"]) == [] >>> find_substring(\\"wordgoodgoodgoodbestword\\", [\\"word\\", \\"good\\", \\"best\\", \\"good\\"]) == [8] >>> find_substring(\\"\\", [\\"foo\\", \\"bar\\"]) == [] >>> find_substring(\\"barfoothefoobarman\\", []) == [] >>> find_substring(\\"foodayfoobarfoo\\", [\\"foo\\", \\"bar\\", \\"day\\"]) == [3]","solution":"def find_substring(s, words): from collections import Counter if not s or not words: return [] word_len = len(words[0]) total_words = len(words) substring_len = word_len * total_words word_count = Counter(words) result_indices = [] for i in range(word_len): left = i right = i current_count = Counter() while right + word_len <= len(s): word = s[right:right + word_len] right += word_len if word in word_count: current_count[word] += 1 while current_count[word] > word_count[word]: current_count[s[left:left + word_len]] -= 1 left += word_len if right - left == substring_len: result_indices.append(left) else: current_count.clear() left = right return sorted(result_indices)"},{"question":"from typing import List def minOperationsToEqualElements(arr: List[int]) -> int: Returns the minimum number of operations needed to make all elements in the array equal. >>> minOperationsToEqualElements([1]) 0 >>> minOperationsToEqualElements([1, 1, 1, 1]) 0 >>> minOperationsToEqualElements([1, 2]) 1 >>> minOperationsToEqualElements([1, 2, 3]) 2 >>> minOperationsToEqualElements([1000, 2000, 3000]) 2000 >>> minOperationsToEqualElements([]) 0 >>> minOperationsToEqualElements([-1, 0, 1]) 2 >>> minOperationsToEqualElements([-10, 0, 10]) 20 >>> minOperationsToEqualElements([-100, 0, 100]) 200","solution":"from typing import List def minOperationsToEqualElements(arr: List[int]) -> int: Returns the minimum number of operations needed to make all the elements in the array equal. if not arr: # If the array is empty return 0 arr.sort() median = arr[len(arr) // 2] return sum(abs(x - median) for x in arr)"},{"question":"def maximize_consecutive_ones(s: str) -> int: Returns the maximum length of consecutive '1's possible after flipping at most one '0' to '1'. >>> maximize_consecutive_ones(\\"11111\\") 5 >>> maximize_consecutive_ones(\\"1110111\\") 7 >>> maximize_consecutive_ones(\\"11011101111\\") 8 >>> maximize_consecutive_ones(\\"00000\\") 1 >>> maximize_consecutive_ones(\\"\\") 0 >>> maximize_consecutive_ones(\\"101010101010\\") 3","solution":"def maximize_consecutive_ones(s): Returns the maximum length of consecutive '1's possible after flipping at most one '0' to '1'. max_len = 0 left = 0 zero_count = 0 for right in range(len(s)): if s[right] == '0': zero_count += 1 while zero_count > 1: if s[left] == '0': zero_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"from typing import List def longest_constrained_subsequence(arr: List[int]) -> int: Given a list of n positive integers, find the longest subsequence such that the absolute difference between any two elements in the subsequence is equal to the difference between their respective indices in the original list. Return the length of this subsequence. >>> longest_constrained_subsequence([1, 5, 7, 8, 5, 3, 4, 2, 1]) 4 >>> longest_constrained_subsequence([1, 2, 3]) 3 >>> longest_constrained_subsequence([3, 3, 3, 3]) 1 >>> longest_constrained_subsequence([5, 1, 2, 1, 5]) 3 >>> longest_constrained_subsequence([]) 0 >>> longest_constrained_subsequence([1]) 1 >>> longest_constrained_subsequence([1, 2]) 2 >>> longest_constrained_subsequence([1, 3]) 1 >>> longest_constrained_subsequence([1, 100, 3, 101]) 2 >>> longest_constrained_subsequence([1, 2, 100, 300]) 2","solution":"def longest_constrained_subsequence(arr): Function to find the longest subsequence such that the absolute difference between any two elements is equal to the difference between their respective indices. n = len(arr) if n == 0: return 0 dp = [1] * n # dp[i] will store the length of the longest valid subsequence ending at index i for i in range(n): for j in range(i): if abs(arr[i] - arr[j]) == i - j: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head: ListNode) -> ListNode: Detects the node where the cycle begins in a linked list. If no cycle, returns None. :param head: The head node of the linked list. :return: The node where the cycle begins, or None if no cycle exists. pass from solution import ListNode, detectCycle def test_no_cycle(): # List: 1 -> 2 -> 3 -> None head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) assert detectCycle(head) is None def test_cycle_at_beginning(): # List: 1 -> 2 -> 3 -> 1 (cycle) head = ListNode(1) second = ListNode(2) third = ListNode(3) head.next = second second.next = third third.next = head assert detectCycle(head) == head def test_cycle_in_middle(): # List: 1 -> 2 -> 3 -> 4 -> 2 (cycle starting from 2) head = ListNode(1) second = ListNode(2) third = ListNode(3) fourth = ListNode(4) head.next = second second.next = third third.next = fourth fourth.next = second assert detectCycle(head) == second def test_longer_cycle(): # List: 1 -> 2 -> 3 -> 4 -> 5 -> 2 (cycle starting from 2) head = ListNode(1) second = ListNode(2) third = ListNode(3) fourth = ListNode(4) fifth = ListNode(5) head.next = second second.next = third third.next = fourth fourth.next = fifth fifth.next = second assert detectCycle(head) == second def test_single_node_no_cycle(): # List: 1 -> None head = ListNode(1) assert detectCycle(head) is None def test_single_node_with_cycle(): # List: 1 -> 1 (cycle to itself) head = ListNode(1) head.next = head assert detectCycle(head) == head","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head): Detects the node where the cycle begins in a linked list. If no cycle, returns None. :param head: The head node of the linked list. :return: The node where the cycle begins, or None if no cycle exists. if not head or not head.next: return None slow = head fast = head # Step 1: Determine whether a cycle exists using Floyd's Tortoise and Hare algorithm while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: # If we're here, it means no cycle was detected return None # Step 2: Find the start node of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"def solveSudoku(board): Solves the Sudoku puzzle in-place. pass # Helper to create deep copies of boards for testing purposes import copy def test_sudoku_solver(): board = [ ['5', '3', '.', '.', '7', '.', '.', '.', '.'], ['6', '.', '.', '1', '9', '5', '.', '.', '.'], ['.', '9', '8', '.', '.', '.', '.', '6', '.'], ['8', '.', '.', '.', '6', '.', '.', '.', '3'], ['4', '.', '.', '8', '.', '3', '.', '.', '1'], ['7', '.', '.', '.', '2', '.', '.', '.', '6'], ['.', '6', '.', '.', '.', '.', '2', '8', '.'], ['.', '.', '.', '4', '1', '9', '.', '.', '5'], ['.', '.', '.', '.', '8', '.', '.', '7', '9'] ] solved_board = [ ['5', '3', '4', '6', '7', '8', '9', '1', '2'], ['6', '7', '2', '1', '9', '5', '3', '4', '8'], ['1', '9', '8', '3', '4', '2', '5', '6', '7'], ['8', '5', '9', '7', '6', '1', '4', '2', '3'], ['4', '2', '6', '8', '5', '3', '7', '9', '1'], ['7', '1', '3', '9', '2', '4', '8', '5', '6'], ['9', '6', '1', '5', '3', '7', '2', '8', '4'], ['2', '8', '7', '4', '1', '9', '6', '3', '5'], ['3', '4', '5', '2', '8', '6', '1', '7', '9'] ] test_board = copy.deepcopy(board) solveSudoku(test_board) assert test_board == solved_board","solution":"def solveSudoku(board): Solves the Sudoku puzzle in-place. def isValid(board, row, col, num): for x in range(9): if board[row][x] == num: return False if board[x][col] == num: return False if board[3 * (row // 3) + x // 3][3 * (col // 3) + x % 3] == num: return False return True def solve(board): for i in range(9): for j in range(9): if board[i][j] == '.': for num in '123456789': if isValid(board, i, j, num): board[i][j] = num if solve(board): return True board[i][j] = '.' return False return True solve(board) # Helper to create deep copies of boards for testing purposes import copy"},{"question":"from typing import List def min_jumps(nums: List[int]) -> int: Returns the minimum number of jumps required to reach the top of the ladder. If reaching the top is not possible, returns -1. >>> min_jumps([2, 3, 1, 1, 4]) 2 >>> min_jumps([1, 2, 1, 1, 1]) 3 >>> min_jumps([10, 1, 1, 1, 1, 1]) 1 >>> min_jumps([1, 0, 0]) -1 >>> min_jumps([3, 2, 1, 0, 4]) -1 >>> min_jumps([0]) 0 >>> min_jumps([2, 3, 0, 1, 4]) 2 >>> min_jumps([1]) 0 >>> min_jumps([]) 0","solution":"def min_jumps(nums): Returns the minimum number of jumps required to reach the top of the ladder. If reaching the top is not possible, returns -1. if not nums or len(nums) == 1: return 0 jumps = 0 curr_end = 0 curr_farthest = 0 for i in range(len(nums) - 1): curr_farthest = max(curr_farthest, i + nums[i]) if i == curr_end: jumps += 1 curr_end = curr_farthest if curr_end >= len(nums) - 1: return jumps return -1"},{"question":"def min_energy_to_reach_top(x: int, k: int) -> int: Returns the minimum energy required to reach exactly x units. Parameters: x (int): Total number of units to reach the top floor k (int): Energy units required to use the elevator Returns: int: Minimum energy required >>> min_energy_to_reach_top(5, 10) 5 >>> min_energy_to_reach_top(10, 5) 5 >>> min_energy_to_reach_top(7, 7) 7 >>> min_energy_to_reach_top(15, 10) 10 >>> min_energy_to_reach_top(1, 5) 1","solution":"def min_energy_to_reach_top(x, k): Returns the minimum energy required to reach exactly x units. Parameters: x (int): Total number of units to reach the top floor k (int): Energy units required to use the elevator Returns: int: Minimum energy required # If taking stairs all the way is cheaper or x is less than k if x <= k: return x else: return min(x, k)"},{"question":"def maxProfit(stockPrices: List[int]) -> int: Returns the maximum profit that can be achieved from a single buy and sell transaction. >>> maxProfit([7, 1, 5, 3, 6, 4]) 5 >>> maxProfit([7, 6, 4, 3, 1]) 0 >>> maxProfit([1, 2, 3, 4, 5]) 4 >>> maxProfit([5, 4, 3, 2, 1]) 0 >>> maxProfit([5]) 0 >>> maxProfit([]) 0 >>> maxProfit([3, 3, 3, 3, 3]) 0 >>> maxProfit([3, 3, 5, 0, 0, 3, 1, 4]) 4","solution":"def maxProfit(stockPrices): Returns the maximum profit that can be achieved from a single buy and sell transaction if not stockPrices or len(stockPrices) < 2: return 0 min_price = stockPrices[0] max_profit = 0 for price in stockPrices[1:]: current_profit = price - min_price if current_profit > max_profit: max_profit = current_profit if price < min_price: min_price = price return max_profit"},{"question":"def longest_subsequence_with_difference(arr: List[int], difference: int) -> int: Given an array of integers \`arr\` and an integer \`difference\`, return the length of the longest subsequence in the array that forms an arithmetic sequence with the given difference. >>> longest_subsequence_with_difference([1, 2, 3, 4], 1) 4 >>> longest_subsequence_with_difference([1, 3, 5, 7], 1) 1 >>> longest_subsequence_with_difference([4, 3, 2, 1], -1) 4 >>> longest_subsequence_with_difference([1, 5, 7, 8, 5, 3, 4, 2, 1], -2) 4 >>> longest_subsequence_with_difference([1, 6, 11, 16, 21], 5) 5 >>> longest_subsequence_with_difference([], 1) 0","solution":"def longest_subsequence_with_difference(arr, difference): Returns the length of the longest subsequence in the array that forms an arithmetic sequence with the given difference. dp = {} max_length = 0 for num in arr: if num - difference in dp: dp[num] = dp[num - difference] + 1 else: dp[num] = 1 max_length = max(max_length, dp[num]) return max_length"},{"question":"def max_subarray_sum(nums): Finds the contiguous subarray within an array which has the largest sum and returns the sum. Parameters: nums (list of int): List of integers Returns: int: The sum of the maximum subarray Examples: >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([0, 0, 0, 0]) 0 >>> max_subarray_sum([]) 0 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, 3, 4, -1, 2, 1, -5, 4]) 9 >>> max_subarray_sum([1, -1, 1, -1, 1, -1, 1]) 1","solution":"def max_subarray_sum(nums): Finds the contiguous subarray within an array which has the largest sum and returns the sum. Parameters: nums (list of int): List of integers Returns: int: The sum of the maximum subarray if not nums: return 0 max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def execute_requests(warehouse: List[List[int]], requests: List[List[int]]) -> List[List[int]]: Modifies the warehouse based on the requests to move boxes. Args: warehouse (list of list of int): The initial state of the warehouse. requests (list of list of int): The list of requests to move boxes. Returns: list of list of int: The final state of the warehouse. >>> execute_requests( ... [ ... [1, 2], ... [3, 4] ... ], ... [[0, 0, 1, 1]] ... ) [ [0, 2], [3, 5] ] >>> execute_requests( ... [ ... [1, 2], ... [3, 4] ... ], ... [] ... ) [ [1, 2], [3, 4] ] >>> execute_requests( ... [ ... [0, 2], ... [3, 0] ... ], ... [[1, 0, 0, 1]] ... ) [ [0, 5], [0, 0] ] pass","solution":"def execute_requests(warehouse, requests): Modifies the warehouse based on the requests to move boxes. Args: warehouse (list of list of int): The initial state of the warehouse. requests (list of list of int): The list of requests to move boxes. Returns: list of list of int: The final state of the warehouse. for request in requests: x1, y1, x2, y2 = request box_count = warehouse[x1][y1] warehouse[x2][y2] += box_count warehouse[x1][y1] = 0 return warehouse"},{"question":"def longest_substring_after_one_swap(s: str) -> int: Return the length of the longest substring consisting of only 'a's or only 'b's that can be achieved after performing exactly one swap. >>> longest_substring_after_one_swap(\\"baab\\") 2 >>> longest_substring_after_one_swap(\\"aaaa\\") 4 >>> longest_substring_after_one_swap(\\"bbbb\\") 4 >>> longest_substring_after_one_swap(\\"abab\\") 2 >>> longest_substring_after_one_swap(\\"a\\") 1 >>> longest_substring_after_one_swap(\\"b\\") 1 >>> longest_substring_after_one_swap(\\"aaaab\\") 4 >>> longest_substring_after_one_swap(\\"baaaa\\") 4 >>> longest_substring_after_one_swap(\\"aababb\\") 3 >>> longest_substring_after_one_swap(\\"abba\\") 2","solution":"def longest_substring_after_one_swap(s): def max_substring_length(s, c): n = len(s) cnt = s.count(c) max_len, curr_len = 0, 0 for i in range(n): if s[i] == c: curr_len += 1 else: max_len = max(max_len, curr_len + 1) curr_len = 0 return min(max(max_len, curr_len + 1), cnt) return max(max_substring_length(s, 'a'), max_substring_length(s, 'b'))"},{"question":"def exist(grid: List[str], word: str) -> bool: Determine if the word exists in the 2D grid following the rules of adjacency. >>> exist([\\"ABCE\\", \\"SFCS\\", \\"ADEE\\"], \\"ABCCED\\") True >>> exist([\\"ABCE\\", \\"SFCS\\", \\"ADEE\\"], \\"ABCB\\") False >>> exist([], \\"A\\") False >>> exist([\\"A\\"], \\"A\\") True >>> exist([\\"A\\"], \\"B\\") False >>> exist([\\"ABCE\\", \\"SFES\\", \\"ADEE\\"], \\"SEE\\") True >>> exist([\\"AAA\\", \\"AAB\\", \\"AAA\\"], \\"AAAA\\") True","solution":"def exist(grid, word): def dfs(x, y, word_index): if word_index == len(word): return True if (x < 0 or x >= rows or y < 0 or y >= cols or grid[x][y] != word[word_index] or visited[x][y]): return False visited[x][y] = True # Explore neighbors in DFS manner has_path = (dfs(x + 1, y, word_index + 1) or dfs(x - 1, y, word_index + 1) or dfs(x, y + 1, word_index + 1) or dfs(x, y - 1, word_index + 1)) visited[x][y] = False return has_path if not grid: return False rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] for i in range(rows): for j in range(cols): if grid[i][j] == word[0] and dfs(i, j, 0): return True return False"},{"question":"from typing import List def findNumberOfLIS(nums: List[int]) -> int: Returns the number of longest increasing subsequences in the array. >>> findNumberOfLIS([]) 0 >>> findNumberOfLIS([1]) 1 >>> findNumberOfLIS([2, 2, 2, 2, 2]) 5 >>> findNumberOfLIS([1, 3, 5, 7]) 1 >>> findNumberOfLIS([7, 5, 3, 1]) 4 >>> findNumberOfLIS([1, 3, 5, 4, 7]) 2 >>> findNumberOfLIS([2, 2, 2, 2, 2, 2]) 6 >>> findNumberOfLIS([1, 2, 4, 3, 5, 4, 7, 2]) 3 >>> findNumberOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) 4 pass import pytest def test_empty_array(): assert findNumberOfLIS([]) == 0 def test_single_element(): assert findNumberOfLIS([1]) == 1 def test_all_same_elements(): assert findNumberOfLIS([2, 2, 2, 2, 2]) == 5 def test_increasing_elements(): assert findNumberOfLIS([1, 3, 5, 7]) == 1 def test_decreasing_elements(): assert findNumberOfLIS([7, 5, 3, 1]) == 4 def test_mixed_elements(): assert findNumberOfLIS([1, 3, 5, 4, 7]) == 2 assert findNumberOfLIS([2, 2, 2, 2, 2, 2]) == 6 assert findNumberOfLIS([1, 2, 4, 3, 5, 4, 7, 2]) == 3 def test_complicated_case(): assert findNumberOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4 pytest.main()","solution":"def findNumberOfLIS(nums): if not nums: return 0 n = len(nums) lengths = [0] * n counts = [0] * n for i in range(n): lengths[i] = 1 counts[i] = 1 for j in range(i): if nums[j] < nums[i]: if lengths[j] + 1 > lengths[i]: lengths[i] = lengths[j] + 1 counts[i] = counts[j] elif lengths[j] + 1 == lengths[i]: counts[i] += counts[j] longest = max(lengths) return sum(c for i, c in enumerate(counts) if lengths[i] == longest)"},{"question":"from typing import List def numMatchingSubseq(s: str, words: List[str]) -> int: Given a string s containing only lowercase English letters and a list of words words, determine the number of words in the list that are subsequences of the string s. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Args: s (str): the string to be checked against. words (List[str]): the list of words to check within the string s. Returns: int: the number of words in the list that are subsequences of s. >>> numMatchingSubseq(\\"abcde\\", [\\"a\\", \\"bb\\", \\"acd\\", \\"ace\\"]) 3 >>> numMatchingSubseq(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) 0 >>> numMatchingSubseq(\\"abc\\", []) 0 >>> numMatchingSubseq(\\"abcde\\", [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"]) 5 >>> numMatchingSubseq(\\"abcde\\", [\\"xyz\\", \\"pqr\\"]) 0 >>> numMatchingSubseq(\\"abcdefghijklmn\\", [\\"abc\\", \\"ghi\\", \\"lmn\\", \\"mn\\", \\"def\\"]) 5","solution":"def numMatchingSubseq(s, words): def is_subsequence(x, y): it = iter(y) return all(char in it for char in x) return sum(is_subsequence(word, s) for word in words)"},{"question":"def singleNumber(nums: List[int]) -> int: Finds the element that appears exactly once in an array where every other element appears three times. >>> singleNumber([2, 2, 3, 2]) == 3 >>> singleNumber([0, 1, 0, 1, 0, 1, 99]) == 99 >>> singleNumber([-2, -2, -3, -2]) == -3 >>> singleNumber([-1, -1, -1, -99]) == -99 >>> singleNumber([30000, 500, 100, 30000, 100, 30000, 100]) == 500 >>> singleNumber([-1000, -1000, -1000, -999]) == -999 >>> singleNumber([1]*999999 + [2, 2, 2] + [-1]*999999 + [999999999]) == 999999999","solution":"def singleNumber(nums): Finds the element that appears exactly once in an array where every other element appears three times. Args: nums (List[int]): The list of integers. Returns: int: The single integer that appears once. one, two = 0, 0 for num in nums: one = (one ^ num) & ~two two = (two ^ num) & ~one return one"},{"question":"from typing import List from collections import Counter def top_k_frequent_words(strs: List[str], k: int) -> List[str]: Returns the k most frequent words from the list of strings. Args: strs (list): List of strings. k (int): Number of top frequent words to return. Returns: list: List of k most frequent words sorted by frequency and lexicographical order. >>> top_k_frequent_words([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"], 2) ['apple', 'banana'] >>> top_k_frequent_words([\\"apple\\", \\"apple\\", \\"apple\\"], 1) ['apple'] >>> top_k_frequent_words([\\"apple\\", \\"banana\\", \\"cherry\\", \\"apple\\", \\"banana\\", \\"cherry\\"], 2) ['apple', 'banana'] >>> top_k_frequent_words([\\"apple\\", \\"banana\\", \\"cherry\\", \\"apple\\", \\"banana\\", \\"durian\\", \\"banana\\"], 2) ['banana', 'apple'] >>> top_k_frequent_words([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"], 3) ['a', 'b', 'c']","solution":"from collections import Counter def top_k_frequent_words(strs, k): Returns the k most frequent words from the list of strings. Args: strs (list): List of strings. k (int): Number of top frequent words to return. Returns: list: List of k most frequent words sorted by frequency and lexicographical order. count = Counter(strs) sorted_words = sorted(count.items(), key=lambda x: (-x[1], x[0])) return [word for word, freq in sorted_words[:k]]"},{"question":"def find_min_radius(houses: List[int], heaters: List[int]) -> int: Returns the minimum radius \`r\` such that all houses can be covered by at least one heater. >>> find_min_radius([1, 2, 3], [2]) 1 >>> find_min_radius([1, 2, 3, 4], [1, 4]) 1 >>> find_min_radius([1, 5, 9], [2, 8]) 3 >>> find_min_radius([1, 2, 3], [1, 3]) 1 >>> find_min_radius([], []) 0 >>> find_min_radius([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [5]) 5","solution":"def find_closest_heater(house, heaters): Returns the minimum distance from the house to the nearest heater using binary search. left, right = 0, len(heaters) - 1 while left < right: mid = (left + right) // 2 if heaters[mid] < house: left = mid + 1 else: right = mid return left def find_min_radius(houses, heaters): Returns the minimum radius \`r\` such that all houses can be covered by at least one heater. # Sort houses and heaters (they are assumed sorted but we ensure it) houses.sort() heaters.sort() min_radius = 0 for house in houses: # Find the nearest heater index = find_closest_heater(house, heaters) # Calculate distances to the possible nearest heaters dist1 = abs(house - heaters[index]) dist2 = float('inf') if index > 0: dist2 = abs(house - heaters[index - 1]) # Choose the minimum distance nearest_heater_dist = min(dist1, dist2) # Update the minimum radius required min_radius = max(min_radius, nearest_heater_dist) return min_radius"},{"question":"from typing import List def has_valid_permutation(nums: List[int]) -> bool: You are given an integer array \`nums\` of length \`n\`. You are allowed to permute \`nums\` into a new sequence \`arr\`. A permutation of \`nums\` is considered **valid** if for every \`i\` (1 <= \`i\` <= n/2), the sum of \`arr[i]\` and \`arr[n-i+1]\` is the same. Return \`true\` if there exists at least one valid permutation of \`nums\`, otherwise, return \`false\`. >>> has_valid_permutation([1, 2, 3, 4]) True >>> has_valid_permutation([1, 2, 3, 5]) False >>> has_valid_permutation([1]) True >>> has_valid_permutation([1, 2]) True >>> has_valid_permutation([1, 1, 2, 2]) True >>> has_valid_permutation([2, 2, 2, 2]) True >>> has_valid_permutation([1, 3, 5, 2]) False >>> has_valid_permutation([3, 9, 7, 2, 1, 6, 8, 4]) True >>> has_valid_permutation([4, 2, 1, 3]) True >>> has_valid_permutation([1, -1, -1, 1]) True","solution":"from itertools import permutations def has_valid_permutation(nums): Returns if there exists a valid permutation of nums where for every i (1 <= i <= n/2), the sum of arr[i] and arr[n-i+1] is the same. n = len(nums) # Check all permutations of nums for perm in permutations(nums): # Check if the permutation is valid valid = True sum_val = perm[0] + perm[-1] for i in range(1, n//2 + 1): if perm[i-1] + perm[-i] != sum_val: valid = False break if valid: return True return False"},{"question":"def remove_min_chars(s: str) -> str: Removes the minimum number of characters from the string so that no two consecutive characters are the same. If there are multiple valid results, returns the one which comes first lexicographically. >>> remove_min_chars(\\"abc\\") == \\"abc\\" >>> remove_min_chars(\\"aaa\\") == \\"a\\" >>> remove_min_chars(\\"ababab\\") == \\"ababab\\" >>> remove_min_chars(\\"aabbcc\\") == \\"abc\\" >>> remove_min_chars(\\"aabacbccb\\") == \\"abacbcb\\" >>> remove_min_chars(\\"\\") == \\"\\"","solution":"def remove_min_chars(s): Removes the minimum number of characters from the string so that no two consecutive characters are the same. If there are multiple valid results, returns the one which comes first lexicographically. if not s: return \\"\\" result = [] previous_char = None for char in s: if char != previous_char: result.append(char) previous_char = char return ''.join(result)"},{"question":"from typing import List def is_path_possible(grid: List[List[int]], k: int, startRow: int, startCol: int, endRow: int, endCol: int) -> bool: Determine if there is a path from (startRow, startCol) to (endRow, endCol) navigating through at most \`k\` obstacles in the given grid. :param grid: List[List[int]] :param k: int :param startRow: int :param startCol: int :param endRow: int :param endCol: int :return: bool >>> grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> is_path_possible(grid, 0, 0, 0, 2, 2) True >>> grid = [[0, 1, 0], [0, 1, 0], [0, 0, 0]] >>> is_path_possible(grid, 1, 0, 0, 2, 2) True >>> grid = [[0, 1, 0], [1, 1, 0], [0, 0, 0]] >>> is_path_possible(grid, 1, 0, 0, 2, 2) False >>> grid = [[0, 1, 0], [0, 1, 0], [0, 1, 0]] >>> is_path_possible(grid, 3, 0, 0, 2, 2) True >>> grid = [[0, 1, 0], [0, 1, 0], [0, 0, 0]] >>> is_path_possible(grid, 1, 0, 0, 0, 0) True","solution":"from collections import deque def is_path_possible(grid, k, startRow, startCol, endRow, endCol): Determine if there is a path from (startRow, startCol) to (endRow, endCol) navigating through at most \`k\` obstacles in the given grid. :param grid: List[List[int]] :param k: int :param startRow: int :param startCol: int :param endRow: int :param endCol: int :return: bool m, n = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(startRow, startCol, 0)]) # (row, col, obstacles) visited = set([(startRow, startCol, 0)]) while queue: row, col, obstacles = queue.popleft() # Check if we reached the goal if row == endRow and col == endCol: return True # Try all 4 possible directions for dr, dc in directions: newRow, newCol = row + dr, col + dc newObstacles = obstacles + grid[newRow][newCol] if 0 <= newRow < m and 0 <= newCol < n else obstacles if 0 <= newRow < m and 0 <= newCol < n and newObstacles <= k and (newRow, newCol, newObstacles) not in visited: visited.add((newRow, newCol, newObstacles)) queue.append((newRow, newCol, newObstacles)) return False"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def subtreeSums(root): For each node in a binary tree, determine the sum of the values of all nodes in its subtree. Return an array where the ith element represents the sum of the subtree values for the node with value i. >>> root = TreeNode(1) >>> assert subtreeSums(root) == [1] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> assert subtreeSums(root) == [3, 2] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> assert subtreeSums(root) == [6, 2, 3] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> assert subtreeSums(root) == [28, 11, 16, 4, 5, 6, 7] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.left.left = TreeNode(5) >>> assert subtreeSums(root) == [15, 11, 3, 9, 5] >>> assert subtreeSums(None) == []","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def subtreeSums(root): def dfs(node): if not node: return 0 total_sum = node.val + dfs(node.left) + dfs(node.right) result[node.val - 1] = total_sum return total_sum if root is None: return [] # Determine number of nodes by finding max value in the tree def find_max_value(node): if not node: return float('-inf') return max(node.val, find_max_value(node.left), find_max_value(node.right)) n = find_max_value(root) result = [0] * n dfs(root) return result"},{"question":"def rob_houses(arr, m): Given a list of non-negative integers representing the amount of money of each house and an integer m representing the number of houses you can rob at once, returns the maximum amount of money you can rob without robbing two consecutive houses. >>> rob_houses([100], 1) == 100 >>> rob_houses([100, 200], 1) == 200 >>> rob_houses([100, 200, 300], 1) == 400 >>> rob_houses([100, 200, 300, 400], 1) == 600 >>> rob_houses([], 1) == 0 >>> rob_houses([100, 100, 100, 100, 100], 1) == 300 >>> rob_houses([100, 1, 100, 1, 100], 1) == 300","solution":"def rob_houses(arr, m): Given a list of non-negative integers representing the amount of money of each house and an integer m representing the number of houses you can rob at once, returns the maximum amount of money you can rob without robbing two consecutive houses. n = len(arr) if n == 0: return 0 if n == 1: return arr[0] # Initialize dp array dp = [0] * (n + 1) dp[1] = arr[0] for i in range(2, n + 1): dp[i] = max(dp[i-1], dp[i-2] + arr[i-1]) return dp[n]"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Returns the largest sum of any contiguous subarray in nums. >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([5, 4, -1, 7, 8]) == 23 >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([-1, -2, -3, -4]) == -1 >>> max_subarray_sum([3, -2, 5, -1]) == 6 >>> max_subarray_sum([2, -1, 2, 3, 4, -5]) == 10","solution":"def max_subarray_sum(nums): Returns the largest sum of any contiguous subarray in nums. max_sum = float('-inf') current_sum = 0 for num in nums: current_sum += num if current_sum > max_sum: max_sum = current_sum if current_sum < 0: current_sum = 0 return max_sum"},{"question":"def max_swaps_to_balance(nums: List[int]) -> int: You are given a 0-indexed integer array \`nums\` consisting of \`n\` elements, where \`n\` is even. The array is called well-balanced if the sum of the even-indexed elements equals the sum of the odd-indexed elements. You are allowed to perform at most one swap between an even-indexed element and an odd-indexed element. Return the maximum possible number of such swaps that can be performed on \`nums\` so that the array becomes well-balanced. If the array is already well-balanced, return 0. >>> max_swaps_to_balance([1, 1, 1, 1]) 0 >>> max_swaps_to_balance([1, 2, 3, 4]) 1 >>> max_swaps_to_balance([1, 1, 1, 2]) 0 >>> max_swaps_to_balance([1, 3, 2, 4, 2, 4]) 1","solution":"def max_swaps_to_balance(nums): Returns the maximum possible number of swaps to make the array well-balanced. If already well-balanced, returns 0. # Calculate initial sums of even-indexed and odd-indexed elements sum_even = sum(nums[i] for i in range(0, len(nums), 2)) sum_odd = sum(nums[i] for i in range(1, len(nums), 2)) # If already well-balanced, return 0 if sum_even == sum_odd: return 0 # Calculate the difference diff = abs(sum_even - sum_odd) # Initialize the maximum number of swaps max_swaps = 0 # Iterate through possible swaps for i in range(0, len(nums), 2): for j in range(1, len(nums), 2): # Calculate new sums after a swap between nums[i] and nums[j] new_sum_even = sum_even - nums[i] + nums[j] new_sum_odd = sum_odd - nums[j] + nums[i] if new_sum_even == new_sum_odd: max_swaps = 1 break if max_swaps == 1: break return max_swaps"},{"question":"def minDistance(s1: str, s2: str) -> int: Return the minimum number of operations required to transform s2 into s1. >>> minDistance(\\"abc\\", \\"abc\\") == 0 >>> minDistance(\\"abc\\", \\"abcd\\") == 1 >>> minDistance(\\"abcd\\", \\"abc\\") == 1 >>> minDistance(\\"abc\\", \\"def\\") == 3 >>> minDistance(\\"\\", \\"abc\\") == 3 >>> minDistance(\\"abc\\", \\"\\") == 3 >>> minDistance(\\"horse\\", \\"ros\\") == 3 >>> minDistance(\\"intention\\", \\"execution\\") == 5","solution":"def minDistance(s1, s2): Return the minimum number of operations required to transform s2 into s1. len1, len2 = len(s1), len(s2) # Create a 2D array where dp[i][j] represents the edit distance between # s1 up to length i and s2 up to length j. dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] # Initialize the base cases for i in range(len1 + 1): dp[i][0] = i for j in range(len2 + 1): dp[0][j] = j # Fill the dp array for i in range(1, len1 + 1): for j in range(1, len2 + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no new operation required else: dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1) # Replacement return dp[len1][len2]"},{"question":"def splitArray(nums: List[int], k: int) -> int: Returns the minimum possible maximum reading time to split the array into k subarrays. >>> splitArray([7, 2, 5, 10, 8], 2) == 18 >>> splitArray([1, 1, 1, 1], 2) == 2 >>> splitArray([1, 2, 3, 4, 5], 1) == 15 >>> splitArray([1, 2, 3, 4, 5], 5) == 5 >>> splitArray([10], 1) == 10","solution":"def can_split(nums, k, max_time): current_sum = 0 required_splits = 1 for num in nums: if current_sum + num > max_time: required_splits += 1 current_sum = num if required_splits > k: return False else: current_sum += num return True def splitArray(nums, k): Returns the minimum possible maximum reading time to split the array into k subarrays. left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(nums, k, mid): right = mid else: left = mid + 1 return left"},{"question":"def group_identical_characters(s: str) -> str: Group all the identical characters of the string together while maintaining their original relative order. >>> group_identical_characters(\\"abacbc\\") == \\"aabbcc\\" >>> group_identical_characters(\\"\\") == \\"\\" >>> group_identical_characters(\\"aaaa\\") == \\"aaaa\\" >>> group_identical_characters(\\"abcdef\\") == \\"abcdef\\" >>> group_identical_characters(\\"aabbccaa\\") == \\"aaaabbcc\\" >>> s = \\"a\\" * 1000 + \\"b\\" * 1000 + \\"c\\" * 1000 >>> group_identical_characters(s) == \\"a\\" * 1000 + \\"b\\" * 1000 + \\"c\\" * 1000","solution":"def group_identical_characters(s): from collections import defaultdict # Create a dictionary to store characters and their occurrences char_dict = defaultdict(list) # Iterate over the string and group characters for char in s: char_dict[char].append(char) # Combine the grouped characters maintaining their original order result = ''.join(''.join(char_dict[char]) for char in sorted(char_dict.keys(), key=lambda x: s.index(x))) return result"},{"question":"from typing import List def top_k_frequent(words: List[str], k: int) -> List[str]: Returns the k most frequent words in the list sorted by frequency and lexicographical order. Args: words: List[str] - a list of words k: int - the number of most frequent words to return Returns: List[str] - the k most frequent words >>> top_k_frequent([\\"i\\", \\"love\\", \\"leetcode\\", \\"i\\", \\"love\\", \\"coding\\"], 2) ['i', 'love'] >>> top_k_frequent([\\"the\\", \\"day\\", \\"is\\", \\"sunny\\", \\"the\\", \\"the\\", \\"the\\", \\"sunny\\", \\"is\\", \\"is\\"], 4) ['the', 'is', 'sunny', 'day'] >>> top_k_frequent([\\"word\\"], 1) ['word'] >>> top_k_frequent([\\"aaa\\", \\"aa\\", \\"a\\", \\"aaa\\", \\"aa\\", \\"aaa\\"], 2) ['aaa', 'aa'] >>> top_k_frequent([\\"a\\", \\"b\\", \\"c\\", \\"a\\", \\"b\\", \\"c\\", \\"a\\"], 5) ['a', 'b', 'c'] >>> top_k_frequent([\\"a\\", \\"b\\", \\"c\\"], 2) ['a', 'b']","solution":"from collections import Counter def top_k_frequent(words, k): Returns the k most frequent words in the list sorted by frequency and lexicographical order. Args: words: List[str] - a list of words k: int - the number of most frequent words to return Returns: List[str] - the k most frequent words count = Counter(words) candidates = sorted(count.items(), key=lambda item: (-item[1], item[0])) return [word for word, freq in candidates[:k]]"},{"question":"from typing import List def min_partitions(nums: List[int]) -> int: Given an array of integers \`nums\`, partition it into subarrays such that each subarray is sorted in non-decreasing order. Find the minimum number of subarrays needed in any such partition. A subarray is a contiguous portion of the original array. Return the minimum number of subarrays needed. >>> min_partitions([1, 2, 3, 4, 5]) == 1 >>> min_partitions([5, 4, 3, 2, 1]) == 5 >>> min_partitions([1, 3, 2, 4, 3]) == 3 >>> min_partitions([1]) == 1 >>> min_partitions([2, 2, 2, 2]) == 1 >>> min_partitions([1, 2]) == 1 >>> min_partitions([2, 1]) == 2 >>> min_partitions([]) == 0","solution":"def min_partitions(nums): Returns the minimum number of subarrays needed such that each subarray is sorted in non-decreasing order. if not nums: return 0 count = 1 for i in range(1, len(nums)): if nums[i] < nums[i - 1]: count += 1 return count"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def array_to_tree(arr): Convert an array representation of a tree to a TreeNode if not arr: return None nodes = [None if val is None else TreeNode(val) for val in arr] kid = nodes[::-1] root = kid.pop() for node in nodes: if node: if kid: node.left = kid.pop() if kid: node.right = kid.pop() return root def longest_univalue_path(arr) -> int: Given an array representing a binary tree, find the longest path where each node in the path has the same value. >>> longest_univalue_path([5, 5, 5, 5, 5, None, 5]) 4 >>> longest_univalue_path([1, 2, 3, 4, 5]) 0 >>> longest_univalue_path([1]) 0 >>> longest_univalue_path([]) 0 >>> longest_univalue_path([1, 4, 5, 4, 4, 5]) 2 >>> longest_univalue_path([5, 4, 5, 1, 1, 5]) 2","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def array_to_tree(arr): if not arr: return None nodes = [None if val is None else TreeNode(val) for val in arr] kid = nodes[::-1] root = kid.pop() for node in nodes: if node: if kid: node.left = kid.pop() if kid: node.right = kid.pop() return root def longest_univalue_path(arr): if not arr: return 0 root = array_to_tree(arr) global_max = [0] def helper(node): if not node: return 0 left_length = helper(node.left) right_length = helper(node.right) left_path = right_path = 0 if node.left and node.left.val == node.val: left_path = left_length + 1 if node.right and node.right.val == node.val: right_path = right_length + 1 global_max[0] = max(global_max[0], left_path + right_path) return max(left_path, right_path) helper(root) return global_max[0]"},{"question":"def remove_k_characters(s: str, k: int) -> str: Remove k characters from the string s to get the highest possible lexicographical value. Parameters: - s (str): string of lowercase letters. - k (int): number of characters to remove. Returns: - str: resulting string after removing k characters.","solution":"def remove_k_characters(s, k): Remove k characters from the string s to get the highest possible lexicographical value. Parameters: - s (str): string of lowercase letters. - k (int): number of characters to remove. Returns: - str: resulting string after removing k characters. stack = [] for char in s: while stack and k > 0 and stack[-1] < char: stack.pop() k -= 1 stack.append(char) # If k is still greater than 0 after the loop if k > 0: stack = stack[:-k] return ''.join(stack)"},{"question":"def has_cycle(graph): Function to detect a cycle in a directed graph represented as an adjacency list. :param graph: A dictionary where the keys are nodes and the values are lists of neighboring nodes. :return: True if there is a cycle, False otherwise. pass def test_no_cycle(): graph = { 0: [1], 1: [2], 2: [3], 3: [] } assert not has_cycle(graph) def test_self_loop(): graph = { 0: [1], 1: [2], 2: [0] } assert has_cycle(graph) def test_simple_cycle(): graph = { 0: [1], 1: [2], 2: [0] } assert has_cycle(graph) def test_disjoint_cycle(): graph = { 0: [1], 1: [2], 2: [0], 3: [4], 4: [5], 5: [3] } assert has_cycle(graph) def test_no_cycle_large(): graph = { 0: [1, 2, 3], 1: [4], 2: [4], 3: [4], 4: [] } assert not has_cycle(graph) def test_multiple_entry_points(): graph = { 0: [1], 1: [], 2: [3], 3: [] } assert not has_cycle(graph)","solution":"def has_cycle(graph): Function to detect a cycle in a directed graph represented as an adjacency list. :param graph: A dictionary where the keys are nodes and the values are lists of neighboring nodes. :return: True if there is a cycle, False otherwise. def dfs(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True visiting.remove(node) visited.add(node) return False visited = set() visiting = set() for node in graph: if dfs(node): return True return False"},{"question":"def largest_land_mass(grid: List[List[int]]) -> int: Computes the largest connected land mass in terms of number of '1's in the grid. >>> largest_land_mass([ ... [1, 1, 0, 0], ... [1, 1, 0, 0], ... [0, 0, 1, 0], ... [0, 0, 0, 1] ... ]) 4 >>> largest_land_mass([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> largest_land_mass([ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ]) 1","solution":"def largest_land_mass(grid): Computes the largest connected land mass in terms of number of '1's in the grid. :param grid: List[List[int]]: 2D grid of integers representing the boolean matrix :return: int: size of the largest connected land mass if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(x, y): if x < 0 or y < 0 or x >= rows or y >= cols or grid[x][y] == 0 or visited[x][y]: return 0 visited[x][y] = True area = 1 area += dfs(x+1, y) area += dfs(x-1, y) area += dfs(x, y+1) area += dfs(x, y-1) return area largest_area = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 1 and not visited[i][j]: largest_area = max(largest_area, dfs(i, j)) return largest_area"},{"question":"MOD = 10**9 + 7 class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def count_even_product_paths(root: TreeNode) -> int: Return the number of unique paths in the tree such that the product of the values in the path is even. The answer should be returned modulo 10^9 + 7. >>> root = TreeNode(2) >>> root.left = TreeNode(3) >>> root.right = TreeNode(4) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(5) >>> count_even_product_paths(root) 5 >>> root = TreeNode(2) >>> root.left = TreeNode(4) >>> root.right = TreeNode(6) >>> count_even_product_paths(root) 3 >>> root = TreeNode(1) >>> root.left = TreeNode(3) >>> root.right = TreeNode(5) >>> count_even_product_paths(root) 0 >>> root = TreeNode(2) >>> count_even_product_paths(root) 1 >>> root = TreeNode(1) >>> count_even_product_paths(root) 0 # Implementation here","solution":"MOD = 10**9 + 7 class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def count_even_product_paths(root: TreeNode) -> int: def dfs(node, current_product): if not node: return 0 # Update the current product current_product *= node.val # Check if the current product is even is_even = current_product % 2 == 0 # Start counting from 0 count = 1 if is_even else 0 # Explore left and right subtrees if node.left: count += dfs(node.left, current_product) if node.right: count += dfs(node.right, current_product) # Return count modulo MOD at each point return count % MOD return dfs(root, 1)"},{"question":"from collections import Counter def min_anagram_deletions(word1: str, word2: str) -> int: Returns the minimum number of deletions required to make word1 and word2 anagrams of each other. >>> min_anagram_deletions(\\"aabbcc\\", \\"aabbcc\\") 0 >>> min_anagram_deletions(\\"abc\\", \\"def\\") 6 >>> min_anagram_deletions(\\"abc\\", \\"bcd\\") 2 >>> min_anagram_deletions(\\"aabbcc\\", \\"abcc\\") Title <bytecode>","solution":"from collections import Counter def min_anagram_deletions(word1, word2): Returns the minimum number of deletions required to make word1 and word2 anagrams of each other. counter1 = Counter(word1) counter2 = Counter(word2) deletions = 0 # Calculate deletions for characters in word1 that are not in word2 or have different frequencies for char in counter1: if char in counter2: deletions += abs(counter1[char] - counter2[char]) else: deletions += counter1[char] # Calculate deletions for characters in word2 that are not in word1 for char in counter2: if char not in counter1: deletions += counter2[char] return deletions"},{"question":"def count_distinct_substrings(s: str, n: int) -> int: Returns the number of distinct substrings of length \`n\` in the given string \`s\`. >>> count_distinct_substrings(\\"ababc\\", 2) 3 # \\"ab\\", \\"ba\\", \\"bc\\" >>> count_distinct_substrings(\\"aaaa\\", 1) 1 # \\"a\\" >>> count_distinct_substrings(\\"abcd\\", 3) 2 # \\"abc\\", \\"bcd\\" >>> count_distinct_substrings(\\"abcd\\", 4) 1 # \\"abcd\\" >>> count_distinct_substrings(\\"abcd\\", 5) 0 # n greater than length of s >>> count_distinct_substrings(\\"\\", 2) 0 # empty string case >>> count_distinct_substrings(\\"a\\", 1) 1 # single character string case >>> count_distinct_substrings(\\"abcabcabcabc\\", 3) 3 # \\"abc\\", \\"bca\\", \\"cab\\"","solution":"def count_distinct_substrings(s, n): Returns the number of distinct substrings of length \`n\` in the given string \`s\`. if n > len(s): return 0 substrings = set() # Using a set to keep track of unique substrings for i in range(len(s) - n + 1): substrings.add(s[i:i+n]) return len(substrings)"},{"question":"class MeetingRooms: A company wants to interactively and efficiently manage their meeting rooms usage throughout the day. Methods: MeetingRooms(n: int): Initializes the meeting rooms system with n available meeting rooms. bool book(int startTime, int endTime): Checks if there is an available meeting room for the given time interval [startTime, endTime), and if so, books a room and returns true; otherwise returns false. bool cancel(int startTime, int endTime): Cancels a previously booked meeting for the given time interval [startTime, endTime), freeing up the room and returning true; if there was no such booking, returns false. def __init__(self, n: int): Initializes the meeting rooms system with n available meeting rooms. pass def book(self, startTime: int, endTime: int) -> bool: Checks if there is an available meeting room for the given time interval [startTime, endTime), and if so, books a room and returns true; otherwise returns false. >>> mr = MeetingRooms(2) >>> mr.book(10, 12) True >>> mr.book(10, 12) True >>> mr.book(10, 12) False pass def cancel(self, startTime: int, endTime: int) -> bool: Cancels a previously booked meeting for the given time interval [startTime, endTime), freeing up the room and returning true; if there was no such booking, returns false. >>> mr = MeetingRooms(2) >>> mr.book(10, 12) True >>> mr.cancel(10, 12) True >>> mr.cancel(10, 12) False pass","solution":"class MeetingRooms: def __init__(self, n: int): Initializes the meeting rooms system with n available meeting rooms. self.n = n self.bookings = [] def book(self, startTime: int, endTime: int) -> bool: Checks if there is an available meeting room for the given time interval [startTime, endTime), and if so, books a room and returns true; otherwise returns false. count = 0 for book in self.bookings: if max(book[0], startTime) < min(book[1], endTime): count += 1 if count < self.n: self.bookings.append((startTime, endTime)) return True return False def cancel(self, startTime: int, endTime: int) -> bool: Cancels a previously booked meeting for the given time interval [startTime, endTime), freeing up the room and returning true; if there was no such booking, returns false. if (startTime, endTime) in self.bookings: self.bookings.remove((startTime, endTime)) return True return False"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(arr): Build a binary tree in a level-order manner from the given array. if not arr: return None nodes = [TreeNode(val) if val is not None else None for val in arr] root = nodes[0] child_index = 1 for node in nodes: if node: if child_index < len(arr): node.left = nodes[child_index] child_index += 1 if child_index < len(arr): node.right = nodes[child_index] child_index += 1 return root def longest_unique_path(root): Find the length of the longest unique path in the binary tree. def helper(node, seen): if not node or node.val in seen: return 0 seen.add(node.val) left = helper(node.left, seen) right = helper(node.right, seen) seen.remove(node.val) return 1 + max(left, right) if not root: return 0 return helper(root, set()) def longest_unique_path_from_array(arr): Given an array of integers, find and return the length of the longest unique path in a binary tree structured from the \`arr\` elements such that each node in this path has a unique value. >>> longest_unique_path_from_array([]) == 0 >>> longest_unique_path_from_array([1]) == 1 >>> longest_unique_path_from_array([1, 2, 3, 4, 5, 6, 7]) == 3 >>> longest_unique_path_from_array([1, 2, 2, 3, 4]) == 3 >>> longest_unique_path_from_array([1, 1, 1, 1]) == 1 >>> longest_unique_path_from_array([1, 2, None, 3, None]) == 3 root = build_tree(arr) return longest_unique_path(root)","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(arr): if not arr: return None nodes = [TreeNode(val) if val is not None else None for val in arr] root = nodes[0] child_index = 1 for node in nodes: if node: if child_index < len(arr): node.left = nodes[child_index] child_index += 1 if child_index < len(arr): node.right = nodes[child_index] child_index += 1 return root def longest_unique_path(root): def helper(node, seen): if not node or node.val in seen: return 0 seen.add(node.val) left = helper(node.left, seen) right = helper(node.right, seen) seen.remove(node.val) return 1 + max(left, right) if not root: return 0 return helper(root, set()) def longest_unique_path_from_array(arr): root = build_tree(arr) return longest_unique_path(root)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sort_linked_list(head: ListNode) -> ListNode: Sort the linked list in ascending order using the merge sort algorithm. >>> head = list_to_linked_list([4, 2, 1, 3]) >>> sorted_head = merge_sort_linked_list(head) >>> linked_list_to_list(sorted_head) [1, 2, 3, 4] def list_to_linked_list(lst: List[int]) -> ListNode: Convert a list to a linked list. def linked_list_to_list(head: ListNode) -> List[int]: Convert a linked list to a list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sort_linked_list(head): if not head or not head.next: return head def split(head): slow = head fast = head.next while fast and fast.next: slow = slow.next fast = fast.next.next middle = slow.next slow.next = None return head, middle def merge(l1, l2): dummy = ListNode() current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next current.next = l1 if l1 else l2 return dummy.next def merge_sort(head): if not head or not head.next: return head left, right = split(head) left = merge_sort(left) right = merge_sort(right) return merge(left, right) return merge_sort(head)"},{"question":"def next_greater_element(nums1, nums2): Finds the next greater element for each element in nums2 within nums1. Args: nums1: A list of integers where nums2 is a subset of nums1. nums2: A list of integers that is a subset of nums1. Returns: A list of integers where each element in nums2 is replaced by its next greater element in nums1. If there is no greater element, -1 is returned for that element. Examples: >>> next_greater_element([4, 1, 2], [1, 2]) [2, -1] >>> next_greater_element([4, 1, 2], [2]) [-1] >>> next_greater_element([2, 4], [2]) [4] >>> next_greater_element([2, 4], [4]) [-1] >>> next_greater_element([1, 3, 4, 2], [1, 3, 4, 2]) [3, 4, -1, -1] >>> next_greater_element([1, 5, 3, 6, 4, 2], [5, 3, 2]) [6, 6, -1] >>> next_greater_element([1, 3, 1, 3, 5], [3, 1]) [5, 3]","solution":"def next_greater_element(nums1, nums2): Finds the next greater element for each element in nums2 within nums1. result = [] num_dict = {val: idx for idx, val in enumerate(nums1)} for num in nums2: found = False for i in range(num_dict[num] + 1, len(nums1)): if nums1[i] > num: result.append(nums1[i]) found = True break if not found: result.append(-1) return result"},{"question":"def longest_monotonic_path(points: List[List[int]]) -> int: Given a list of \`points\` where \`points[i] = [xi, yi]\` represents a point in a 2D plane, return the length of the longest monotonic path that can be formed using the given points. A sequence of points is called a monotonic path if either the x-coordinates or the y-coordinates of the points in the sequence are strictly increasing or strictly decreasing. Example Usage: >>> longest_monotonic_path([[1, 1]]) 1 >>> longest_monotonic_path([[1, 1], [2, 2]]) 2 >>> longest_monotonic_path([[1, 1], [1, 2]]) 2 >>> longest_monotonic_path([[1, 1], [2, 2], [3, 1], [4, 2], [5, 1]]) 5 >>> longest_monotonic_path([[1, 1], [2, 2], [1, 2], [2, 1]]) 2 >>> longest_monotonic_path([[4, 4], [3, 3], [2, 2], [1, 1]]) 4","solution":"def longest_monotonic_path(points): Given a list of points in a 2D plane, return the length of the longest monotonic path. if not points: return 0 points.sort() def lis(sequence): Helper function to calculate the longest increasing subsequence. if not sequence: return 0 dp = [1] * len(sequence) for i in range(1, len(sequence)): for j in range(i): if sequence[i] > sequence[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def lds(sequence): Helper function to calculate the longest decreasing subsequence. if not sequence: return 0 dp = [1] * len(sequence) for i in range(1, len(sequence)): for j in range(i): if sequence[i] < sequence[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) x_coords = [x for x, y in points] y_coords = [y for x, y in points] longest_increasing_x = lis(x_coords) longest_decreasing_x = lds(x_coords) longest_increasing_y = lis(y_coords) longest_decreasing_y = lds(y_coords) return max(longest_increasing_x, longest_decreasing_x, longest_increasing_y, longest_decreasing_y)"},{"question":"def uniquePathsWithObstacles(obstacleGrid): Returns the number of unique paths from top-left to bottom-right in a grid with obstacles. Parameters: obstacleGrid (List[List[int]]): 2D grid with 0s for empty cells and 1s for obstacles. Returns: int: Number of unique paths. # Your code here from solution import uniquePathsWithObstacles def test_no_obstacles(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert uniquePathsWithObstacles(grid) == 6 def test_with_obstacles(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert uniquePathsWithObstacles(grid) == 2 def test_starting_point_is_obstacle(): grid = [ [1, 0, 0], [0, 0, 0], [0, 0, 0] ] assert uniquePathsWithObstacles(grid) == 0 def test_ending_point_is_obstacle(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 1] ] assert uniquePathsWithObstacles(grid) == 0 def test_single_cell_no_obstacle(): grid = [[0]] assert uniquePathsWithObstacles(grid) == 1 def test_single_cell_with_obstacle(): grid = [[1]] assert uniquePathsWithObstacles(grid) == 0 def test_no_path_due_to_horizontal_obstacle(): grid = [ [0, 1], [1, 0] ] assert uniquePathsWithObstacles(grid) == 0 def test_no_path_due_to_vertical_obstacle(): grid = [ [0, 1], [0, 1] ] assert uniquePathsWithObstacles(grid) == 0","solution":"def uniquePathsWithObstacles(obstacleGrid): Returns the number of unique paths from top-left to bottom-right in a grid with obstacles. Parameters: obstacleGrid (List[List[int]]): 2D grid with 0s for empty cells and 1s for obstacles. Returns: int: Number of unique paths. m = len(obstacleGrid) n = len(obstacleGrid[0]) # If starting or ending point is an obstacle, return 0 if obstacleGrid[0][0] == 1 or obstacleGrid[m-1][n-1] == 1: return 0 # Initialize the DP table with zeros dp = [[0] * n for _ in range(m)] # Starting point dp[0][0] = 1 # Fill the DP table for i in range(m): for j in range(n): if obstacleGrid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def min_path_sum(grid): Return the minimum total contagiousness value for any path from the top-left to the bottom-right in a given n x n matrix grid. >>> min_path_sum([[1,3,1], [1,5,1], [4,2,1]]) 7 >>> min_path_sum([[1, 2, 3]]) 6 >>> min_path_sum([[1], [2], [3]]) 6 >>> min_path_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21 >>> min_path_sum([]) 0 >>> min_path_sum([[5]]) 5","solution":"def min_path_sum(grid): Returns the minimum total contagiousness value for any path from the top-left to the bottom-right. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Initialize a dp array with the same dimensions as grid dp = [[0] * cols for _ in range(rows)] # Start at the top-left corner dp[0][0] = grid[0][0] # Fill the first row cumulative sum for col in range(1, cols): dp[0][col] = dp[0][col - 1] + grid[0][col] # Fill the first column cumulative sum for row in range(1, rows): dp[row][0] = dp[row - 1][0] + grid[row][0] # Fill the rest of the dp array for row in range(1, rows): for col in range(1, cols): dp[row][col] = grid[row][col] + min(dp[row - 1][col], dp[row][col - 1]) return dp[rows - 1][cols - 1]"},{"question":"from typing import List from math import gcd def smallest_multiple(n: int) -> int: Returns the smallest positive integer that is a multiple of both \`a\` and \`b\`, where \`a\` and \`b\` are integers that satisfy the conditions \`1 <= a, b <= n\` and \`a != b\`. If there are no valid integers \`a\` and \`b\` such that \`a != b\`, returns -1. >>> smallest_multiple(1) -1 >>> smallest_multiple(2) 2 >>> smallest_multiple(3) 2 >>> smallest_multiple(4) 2 >>> smallest_multiple(5) 2 >>> smallest_multiple(6) 2 >>> smallest_multiple(10) 2 >>> smallest_multiple(15) 2 >>> smallest_multiple(20) 2","solution":"from math import gcd def smallest_multiple(n): Returns the smallest positive integer that is a multiple of both \`a\` and \`b\`, where \`a\` and \`b\` are integers that satisfy the conditions \`1 <= a, b <= n\` and \`a != b\`. If there are no valid integers \`a\` and \`b\` such that \`a != b\`, returns -1. def lcm(x, y): return x * y // gcd(x, y) smallest = float('inf') found = False for a in range(1, n + 1): for b in range(a + 1, n + 1): # No need to check b <= a found = True multiple = lcm(a, b) if multiple < smallest: smallest = multiple if found: return smallest else: return -1"},{"question":"from typing import List def count_building_pairs(nums: List[int], k: int) -> int: Count the number of distinct pairs of buildings \`(i, j)\` such that: * \`0 <= i < j < len(nums)\` * The difference in height between \`i-th\` and \`j-th\` buildings is exactly \`k\` Args: nums (List[int]): List of building heights k (int): Target difference in heights Returns: int: The number of valid pairs \`(i, j)\` >>> count_building_pairs([1, 5, 3, 4, 2], 2) 3 >>> count_building_pairs([1, 2, 3, 4, 5], 10) 0 >>> count_building_pairs([1, 3, 5, 7, 9], 2) 4 >>> count_building_pairs([4, 4, 4, 4], 0) 6 >>> count_building_pairs([-1, -3, 1, 3], 4) 2 >>> count_building_pairs([], 2) 0","solution":"def count_building_pairs(nums, k): Count the number of distinct pairs of buildings (i, j) such that: * 0 <= i < j < len(nums) * The difference in height between i-th and j-th buildings is exactly k Args: nums (List[int]): List of building heights k (int): Target difference in heights Returns: int: The number of valid pairs (i, j) # Initialize count of pairs count = 0 # Iterate over the array with two nested loops to find pairs for i in range(len(nums)): for j in range(i + 1, len(nums)): if abs(nums[i] - nums[j]) == k: count += 1 return count"},{"question":"def max_length_substring_with_distinct_chars(s: str, x: int) -> int: Finds the maximum length of a substring that contains at most x distinct characters. >>> max_length_substring_with_distinct_chars(\\"\\", 3) == 0 >>> max_length_substring_with_distinct_chars(\\"abcde\\", 0) == 0 >>> max_length_substring_with_distinct_chars(\\"a\\", 1) == 1 >>> max_length_substring_with_distinct_chars(\\"a\\", 2) == 1 >>> max_length_substring_with_distinct_chars(\\"abcba\\", 2) == 3 >>> max_length_substring_with_distinct_chars(\\"abcdef\\", 6) == 6 >>> max_length_substring_with_distinct_chars(\\"abcdef\\", 2) == 2 >>> max_length_substring_with_distinct_chars(\\"aaabbcc\\", 1) == 3 >>> max_length_substring_with_distinct_chars(\\"aaabbcc\\", 10) == 7","solution":"def max_length_substring_with_distinct_chars(s, x): Finds the maximum length of a substring that contains at most x distinct characters. Args: s (str): The input string. x (int): The maximum number of distinct characters allowed in the substring. Returns: int: The length of the longest substring with at most x distinct characters. n = len(s) if n == 0 or x == 0: return 0 char_count = {} left = 0 max_length = 0 for right in range(n): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > x: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List def min_subarray_len(arr: List[int], target: int) -> int: Finds the smallest contiguous subarray length such that the sum is at least target. If no such subarray exists, return 0. >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 1, 1, 1, 1], 10) 0 >>> min_subarray_len([1, 2, 3, 4, 5], 15) 5 >>> min_subarray_len([10], 10) 1 >>> min_subarray_len([1, 4, 4], 7) 2 >>> min_subarray_len([10**6] * 10000, 10**6) 1","solution":"def min_subarray_len(arr, target): Finds the smallest contiguous subarray length such that the sum is at least target. If no such subarray exists, returns 0. :param arr: List of integers. :param target: Integer target sum. :return: Minimum length of a qualifying subarray or 0 if no such subarray exists. n = len(arr) min_length = float('inf') start = 0 curr_sum = 0 for end in range(n): curr_sum += arr[end] while curr_sum >= target: min_length = min(min_length, end - start + 1) curr_sum -= arr[start] start += 1 return min_length if min_length != float('inf') else 0"},{"question":"def longest_unique_char_substring(s: str) -> int: Returns the length of the longest substring containing only one unique character. >>> longest_unique_char_substring(\\"aaabbbaac\\") 3 >>> longest_unique_char_substring(\\"aabbaa\\") 2 >>> longest_unique_char_substring(\\"aaaaa\\") 5 >>> longest_unique_char_substring(\\"bbbbb\\") 5 >>> longest_unique_char_substring(\\"abababab\\") 1 >>> longest_unique_char_substring(\\"aabbaabb\\") 2 >>> longest_unique_char_substring(\\"\\") 0 >>> longest_unique_char_substring(\\"a\\") 1 >>> longest_unique_char_substring(\\"b\\") 1 >>> longest_unique_char_substring(\\"aaabbaaabbaaa\\") 3 >>> longest_unique_char_substring(\\"bbbaaabbbaaa\\") 3","solution":"def longest_unique_char_substring(s): Returns the length of the longest substring containing only one unique character. Parameters: s (str): The input string consisting only of the characters 'a' and 'b'. Returns: int: The length of the longest substring with one unique character. if not s: return 0 max_len = 1 current_len = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 return max(max_len, current_len)"},{"question":"def can_jump(arr: List[int]) -> bool: Determines if it's possible to reach the last index of the array starting from the first index. Parameters: arr (list[int]): The input array of non-negative integers where each element represents the maximum jump length. Returns: bool: True if able to reach the last index, otherwise False. >>> can_jump([2, 3, 1, 1, 4]) True >>> can_jump([3, 2, 1, 0, 4]) False >>> can_jump([0]) True >>> can_jump([2, 0, 0, 0]) False >>> can_jump([5, 0, 0, 0, 1]) True >>> can_jump([1, 2, 3, 4, 5]) True >>> can_jump([1] * 10000 + [0]) True >>> can_jump([1] * 9999 + [0, 0]) False >>> can_jump([0] * 10) False","solution":"def can_jump(arr): Determines if it's possible to reach the last index of the array starting from the first index. Parameters: arr (list[int]): The input array of non-negative integers where each element represents the maximum jump length. Returns: bool: True if able to reach the last index, otherwise False. max_reachable = 0 n = len(arr) for i in range(n): if i > max_reachable: return False max_reachable = max(max_reachable, i + arr[i]) return max_reachable >= (n - 1)"},{"question":"def can_split_equal_sum(arr: list) -> bool: Determines if it is possible to split the array into two non-empty parts with equal sum. >>> can_split_equal_sum([1, 1, 1, 1, 1, 1]) == True >>> can_split_equal_sum([1, 2, 3, 4]) == False >>> can_split_equal_sum([5]) == False >>> can_split_equal_sum([-1, 1, 0]) == True >>> can_split_equal_sum([0, 0, 0, 0]) == True >>> can_split_equal_sum([1000000, 1000000, 1000000, 1000000]) == True","solution":"def can_split_equal_sum(arr): Determines if it is possible to split the array into two non-empty parts with equal sum. Parameters: arr (list): List of integers. Returns: bool: True if such a partition is possible, otherwise False. total_sum = sum(arr) if total_sum % 2 != 0: return False target_sum = total_sum // 2 current_sum = 0 for num in arr: current_sum += num if current_sum == target_sum: return True return False"},{"question":"def smaller_numbers_than_current(nums): Given an array of integers \`nums\`, where each integer is unique, return an array of the same length where each element at index \`i\` represents the count of elements in \`nums\` that are smaller than \`nums[i]\`. >>> smaller_numbers_than_current([8, 1, 2, 2, 3]) == [4, 0, 1, 1, 3] >>> smaller_numbers_than_current([1, 2, 3, 4, 5]) == [0, 1, 2, 3, 4] >>> smaller_numbers_than_current([5, 4, 3, 2, 1]) == [4, 3, 2, 1, 0] >>> smaller_numbers_than_current([10]) == [0] >>> smaller_numbers_than_current([1000, 2000, 3000, 4000]) == [0, 1, 2, 3]","solution":"def smaller_numbers_than_current(nums): Given an array of integers nums, where each integer is unique, returns an array of the same length where each element at index i represents the count of elements in nums that are smaller than nums[i]. sorted_nums = sorted(nums) return [sorted_nums.index(num) for num in nums]"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_second_smallest(root: TreeNode) -> int: Find the second smallest value in a binary tree where each node contains a unique integer value. If there is no such second smallest value, return \`-1\`. >>> find_second_smallest(None) -1 >>> find_second_smallest(TreeNode(1)) -1 >>> >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> find_second_smallest(root) 2 >>> >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(7) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(8) >>> find_second_smallest(root) 3","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_second_smallest(root): def inorder_traversal(node): if node: inorder_traversal(node.left) result.append(node.value) inorder_traversal(node.right) if not root: return -1 result = [] inorder_traversal(root) sorted_unique_values = list(sorted(set(result))) if len(sorted_unique_values) < 2: return -1 else: return sorted_unique_values[1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_valid_path(root: TreeNode) -> int: Given a binary tree, return the length of the longest \\"valid path\\". A \\"valid path\\" is a sequence of steps from the root to any node such that no two consecutive nodes along the sequence are both 'left' children or both 'right' children. The length of a path is the number of nodes in the path, including the start and end nodes. If the tree is empty, return 0. >>> test_empty_tree() True >>> test_single_node() True >>> test_two_nodes_alternating() True >>> test_two_nodes_same_direction() True >>> test_three_nodes_alternating() True >>> test_three_nodes_same_direction() True >>> test_complex_tree() True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_valid_path(root): def dfs(node, comes_from_left, length): if not node: return length left_length = dfs(node.left, True, length+1 if not comes_from_left else 1) right_length = dfs(node.right, False, length+1 if comes_from_left else 1) return max(left_length, right_length) return dfs(root, False, 0)"},{"question":"def count_distinct_subarrays(arr): Returns the total number of distinct subarrays in arr. pass # Unit tests def test_single_element_array(): assert count_distinct_subarrays([1]) == 1 def test_all_distinct_elements(): assert count_distinct_subarrays([1, 2, 3]) == 6 def test_some_duplicates(): assert count_distinct_subarrays([1, 2, 1]) == 5 def test_all_same_elements(): assert count_distinct_subarrays([1, 1, 1]) == 3 def test_large_input(): arr = list(range(1, 101)) assert count_distinct_subarrays(arr) == sum(range(1, 101)) def test_empty_array(): assert count_distinct_subarrays([]) == 0","solution":"def count_distinct_subarrays(arr): Returns the total number of distinct subarrays in arr. n = len(arr) subarrays_count = 0 for start in range(n): seen = set() for end in range(start, n): if arr[end] in seen: break seen.add(arr[end]) subarrays_count += 1 return subarrays_count"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def insert_into_sorted_linked_list(head: ListNode, k: int) -> ListNode: Inserts a new node with value \`k\` into the sorted linked list and returns the head of the updated list. >>> def list_to_array(head): ... array = [] ... current = head ... while current: ... array.append(current.val) ... current = current.next ... return array >>> def array_to_list(array): ... if not array: ... return None ... head = ListNode(array[0]) ... current = head ... for value in array[1:]: ... current.next = ListNode(value) ... current = current.next ... return head >>> head = array_to_list([2, 3, 4]) >>> new_head = insert_into_sorted_linked_list(head, 1) >>> list_to_array(new_head) [1, 2, 3, 4] >>> head = array_to_list([1, 3, 4]) >>> new_head = insert_into_sorted_linked_list(head, 2) >>> list_to_array(new_head) [1, 2, 3, 4] >>> head = array_to_list([1, 2, 3]) >>> new_head = insert_into_sorted_linked_list(head, 4) >>> list_to_array(new_head) [1, 2, 3, 4] >>> head = None >>> new_head = insert_into_sorted_linked_list(head, 1) >>> list_to_array(new_head) [1] >>> head = array_to_list([1, 2, 2, 4]) >>> new_head = insert_into_sorted_linked_list(head, 2) >>> list_to_array(new_head) [1, 2, 2, 2, 4] pass","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def insert_into_sorted_linked_list(head, k): Inserts a new node with value \`k\` into the sorted linked list and returns the head of the updated list. new_node = ListNode(k) # Special case: If the list is empty or the new node should be placed at the beginning if not head or head.val >= k: new_node.next = head return new_node # Traverse the list to find the correct position current = head while current.next and current.next.val < k: current = current.next # Insert the new node at the correct position new_node.next = current.next current.next = new_node return head"},{"question":"def min_segments(nums: List[int], k: int) -> int: Returns the minimum number of segments required to partition the array \`nums\` such that every segment has a sum less than or equal to \`k\`. >>> min_segments([1, 2, 3, 4, 5], 1) == 5 >>> min_segments([1, 2, 3, 4, 5], 15) == 1 >>> min_segments([1, 4, 3, 2, 5], 5) == 3 >>> min_segments([1, 2, 3, 4, 5], 6) == 3 >>> min_segments([1, 2, 2, 1, 1], 3) == 3 >>> min_segments([7, 2, 5, 10, 8], 15) == 3","solution":"def min_segments(nums, k): Returns the minimum number of segments required to partition the array \`nums\` such that every segment has a sum less than or equal to \`k\`. segments = 0 current_sum = 0 for num in nums: if current_sum + num <= k: current_sum += num else: segments += 1 current_sum = num if current_sum > 0: segments += 1 return segments"},{"question":"from typing import List, Tuple def pacific_atlantic(grid: List[List[int]]) -> List[Tuple[int, int]]: Determine all the cells from which water can flow to the border in any direction. >>> grid = [ ... [1, 2, 2, 3, 5], ... [3, 2, 3, 4, 4], ... [2, 4, 5, 3, 1], ... [6, 7, 1, 4, 5], ... [5, 1, 1, 2, 4] ... ] >>> pacific_atlantic(grid) [(0, 4), (1, 3), (1, 4), (2, 2), (3, 0), (3, 1), (4, 0)] >>> pacific_atlantic([]) [] >>> grid = [[1]] >>> pacific_atlantic(grid) [(0, 0)] >>> grid = [ ... [1, 1], ... [1, 1] ... ] >>> pacific_atlantic(grid) [(0, 0), (0, 1), (1, 0), (1, 1)] >>> grid = [ ... [1, 2], ... [2, 3] ... ] >>> pacific_atlantic(grid) [(0, 1), (1, 0), (1, 1)]","solution":"def pacific_atlantic(grid): if not grid: return [] rows, cols = len(grid), len(grid[0]) pacific_reachable = set() atlantic_reachable = set() def dfs(r, c, reachable, prev_height): if ((r, c) in reachable or r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] < prev_height): return reachable.add((r, c)) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dr, dc in directions: dfs(r + dr, c + dc, reachable, grid[r][c]) for r in range(rows): dfs(r, 0, pacific_reachable, grid[r][0]) dfs(r, cols - 1, atlantic_reachable, grid[r][cols - 1]) for c in range(cols): dfs(0, c, pacific_reachable, grid[0][c]) dfs(rows - 1, c, atlantic_reachable, grid[rows - 1][c]) return list(pacific_reachable & atlantic_reachable)"},{"question":"def min_moves_to_equal_elements(arr: List[int]) -> int: Returns the minimum number of moves to make all elements in the array equal. >>> min_moves_to_equal_elements([5]) == 0 >>> min_moves_to_equal_elements([4, 4, 4, 4]) == 0 >>> min_moves_to_equal_elements([1, 2, 3]) == 3 >>> min_moves_to_equal_elements([10, 14, 17]) == 11 >>> min_moves_to_equal_elements([1, 1, 4, 4]) == 6","solution":"def min_moves_to_equal_elements(arr): Returns the minimum number of moves to make all elements in the array equal. # The optimal way is to increment all elements except the maximum element until they become equal. # This is equivalent to making all elements equal to the minimum element by a number of decrements. min_element = min(arr) moves = sum(element - min_element for element in arr) return moves"},{"question":"from collections import Counter def can_partition_palindromes(s: str) -> bool: Determines if it is possible to partition the string \`s\` into substrings such that each substring is a palindrome. :param s: A string consisting of lower-case English letters. :return: True if such a partition is possible, False otherwise. >>> can_partition_palindromes(\\"a\\") True >>> can_partition_palindromes(\\"aa\\") True >>> can_partition_palindromes(\\"ab\\") False >>> can_partition_palindromes(\\"abc\\") False def test_can_partition_palindromes_all_unique(): assert can_partition_palindromes(\\"a\\") == True assert can_partition_palindromes(\\"aa\\") == True assert can_partition_palindromes(\\"ab\\") == False assert can_partition_palindromes(\\"abc\\") == False def test_can_partition_palindromes_even_freq(): assert can_partition_palindromes(\\"aaabbb\\") == False assert can_partition_palindromes(\\"aabb\\") == True assert can_partition_palindromes(\\"aabbcc\\") == True def test_can_partition_palindromes_odd_freq(): assert can_partition_palindromes(\\"aab\\") == True assert can_partition_palindromes(\\"aabbc\\") == True assert can_partition_palindromes(\\"aabbcccd\\") == False def test_can_partition_palindromes_mixed_characters(): assert can_partition_palindromes(\\"racecar\\") == True assert can_partition_palindromes(\\"mamad\\") == True assert can_partition_palindromes(\\"madam\\") == True assert can_partition_palindromes(\\"asbbsa\\") == True assert can_partition_palindromes(\\"abcdefg\\") == False","solution":"def can_partition_palindromes(s): Determines if it is possible to partition the string s into substrings such that each substring is a palindrome. :param s: A string consisting of lower-case English letters. :return: True if such a partition is possible, False otherwise. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Check the number of characters that have odd frequencies odd_count = sum(1 for count in freq.values() if count % 2 != 0) # If more than one character has an odd frequency, # then it's not possible to partition the string into palindromic substrings return odd_count <= 1"},{"question":"from typing import List def length_of_longest_subarray(nums: List[int]) -> int: Returns the length of the longest contiguous subarray without duplicate elements. >>> length_of_longest_subarray([1, 2, 3, 1, 2, 3]) == 3 >>> length_of_longest_subarray([2, 2, 2, 2]) == 1 >>> length_of_longest_subarray([]) == 0 >>> length_of_longest_subarray([1, 2, 3, 4, 5]) == 5 >>> length_of_longest_subarray([1]) == 1 >>> length_of_longest_subarray([1, 2, 3, 4, 1, 5]) == 5 >>> length_of_longest_subarray([1, 1, 1, 2, 2, 2]) == 2 >>> length_of_longest_subarray([5, 6, 7, 8, 9, 1, 2, 3]) == 8 >>> length_of_longest_subarray([1, 2, 1, 3, 2, 1, 3, 4]) == 4","solution":"def length_of_longest_subarray(nums): Returns the length of the longest contiguous subarray without duplicate elements. Parameters: nums (List[int]): List of integers. Returns: int: Length of the longest contiguous subarray without duplicates. n = len(nums) if n == 0: return 0 max_len = 0 start = 0 seen = {} for end in range(n): if nums[end] in seen and seen[nums[end]] >= start: start = seen[nums[end]] + 1 seen[nums[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"from typing import List def rearrange_string(s: str, k: int) -> str: Rearranges the string such that the same characters are at least \`k\` distance apart. If it's not possible to rearrange the string in such a way, returns an empty string. The input string will contain only lowercase English letters. >>> rearrange_string(\\"aabbcc\\", 3) in [\\"abcabc\\", \\"acbacb\\"] True >>> rearrange_string(\\"aaabc\\", 3) '' >>> rearrange_string(\\"a\\", 2) 'a' >>> rearrange_string(\\"aabbcc\\", 0) 'aabbcc' >>> rearrange_string(\\"aaabb\\", 2) in [\\"ababa\\", \\"abbaa\\", \\"baaba\\"] True >>> rearrange_string(\\"aaabc\\", 1) 'aaabc'","solution":"from heapq import heappush, heappop from collections import Counter, deque def rearrange_string(s, k): if k <= 1: return s freq_map = Counter(s) max_heap = [] for char, count in freq_map.items(): heappush(max_heap, (-count, char)) result = [] wait_queue = deque() while max_heap: count, char = heappop(max_heap) result.append(char) wait_queue.append((char, count + 1)) if len(wait_queue) < k: continue wait_char, wait_count = wait_queue.popleft() if wait_count < 0: heappush(max_heap, (wait_count, wait_char)) return ''.join(result) if len(result) == len(s) else \\"\\""},{"question":"from typing import List def max_points(points: List[List[int]]) -> int: Given a list of \`points\` on a 2D plane where each \`point = [x, y]\`, determine the maximum number of points that lie on the same straight line. You should implement a function that returns the maximum number of points that lie on a single straight line. >>> max_points([]) == 0 >>> max_points([[0, 0]]) == 1 >>> max_points([[0, 0], [1, 1]]) == 2 >>> max_points([[0, 0], [0, 1], [0, 2], [0, 3]]) == 4 >>> max_points([[0, 0], [1, 1], [2, 2], [3, 3]]) == 4 >>> max_points([[1, 1], [2, 2], [3, 3], [4, 4], [5, 1], [7, 2]]) == 4 >>> max_points([[1, 1], [1, 1], [1, 1], [2, 2], [3, 3]]) == 5 >>> max_points([ [1, 1], [2, 2], [3, 3], [4, 4], [4, 5], [4, 6], [5, 5], [5, 6], [6, 6], [6, 7], [7, 7], [8, 8] ]) == 8","solution":"from collections import defaultdict from math import gcd def max_points(points): def get_slope(p1, p2): dx = p2[0] - p1[0] dy = p2[1] - p1[1] if dx == 0: return (0, p1[0]) if dy == 0: return (p1[1], 0) d = gcd(dx, dy) return (dy // d, dx // d) n = len(points) if n < 3: return n max_points_on_line = 0 for i in range(n): slopes = defaultdict(int) duplicates = 1 for j in range(i + 1, n): if points[i] == points[j]: duplicates += 1 else: slope = get_slope(points[i], points[j]) slopes[slope] += 1 current_max = duplicates for count in slopes.values(): current_max = max(current_max, count + duplicates) max_points_on_line = max(max_points_on_line, current_max) return max_points_on_line"},{"question":"def search_matrix(mat: List[List[int]], target: int) -> bool: Returns true if the target is found in the sorted matrix mat; otherwise, returns false. Utilizes an efficient search algorithm that leverages the sorted properties of the matrix. >>> search_matrix([[1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]], 5) == True >>> search_matrix([[1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]], 20) == False >>> search_matrix([], 1) == False >>> search_matrix([[1, 2, 3, 4, 5]], 3) == True >>> search_matrix([[1, 2, 3, 4, 5]], 6) == False >>> search_matrix([[1], [2], [3], [4], [5]], 3) == True >>> search_matrix([[1], [2], [3], [4], [5]], 6) == False >>> search_matrix([[1]], 1) == True >>> search_matrix([[1]], 2) == False","solution":"def search_matrix(mat, target): Returns true if the target is found in the sorted matrix mat; otherwise, returns false. Utilizes an efficient search algorithm that leverages the sorted properties of the matrix. if not mat or not mat[0]: return False rows = len(mat) cols = len(mat[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if mat[row][col] == target: return True elif mat[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def isEvenOddTree(root: TreeNode) -> bool: Determine if the binary tree is an Even Odd Tree. >>> root = TreeNode(1) >>> root.left = TreeNode(10) >>> root.right = TreeNode(4) >>> root.left.left = TreeNode(3) >>> root.right.left = TreeNode(7) >>> root.right.right = TreeNode(9) >>> isEvenOddTree(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(10) >>> root.right = TreeNode(4) >>> root.left.left = TreeNode(2) >>> root.right.left = TreeNode(7) >>> root.right.right = TreeNode(9) >>> isEvenOddTree(root) False","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def isEvenOddTree(root): if not root: return True level = 0 queue = deque([root]) while queue: size = len(queue) prev_val = None for i in range(size): node = queue.popleft() if (level % 2 == 0 and (node.val % 2 == 0 or (prev_val is not None and node.val <= prev_val))) or (level % 2 == 1 and (node.val % 2 == 1 or (prev_val is not None and node.val >= prev_val))): return False prev_val = node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) level += 1 return True"},{"question":"def max_growth_rates_sum(growthRates: List[int], days: int) -> int: Returns the maximum sum of growth rates of any contiguous subarray of length \`days\` from the array \`growthRates\`. Parameters: growthRates (list): List of integers representing growth rates of plants. days (int): The length of the contiguous subarray to consider. Returns: int: The maximum sum of the contiguous subarray of length \`days\`, or -1 if the length of \`growthRates\` is less than \`days\`. >>> max_growth_rates_sum([1, 2, 3, 4, 5], 2) 9 >>> max_growth_rates_sum([1, 2, 3, 4, 5], 3) 12 >>> max_growth_rates_sum([1, 2, 3, 4, 5], 5) 15 >>> max_growth_rates_sum([1, 2, 3, 4, 5], 1) 5 >>> max_growth_rates_sum([1, 2, 3], 4) -1 >>> max_growth_rates_sum([1, -2, 3, -4, 5, -6], 2) 1 >>> max_growth_rates_sum([1, -2, 3, -4, 5, -6], 3) 4 >>> max_growth_rates_sum([5, 5, 5, 5, 5], 2) 10 >>> max_growth_rates_sum([5, 5, 5, 5, 5], 3) 15","solution":"def max_growth_rates_sum(growthRates, days): Returns the maximum sum of growth rates of any contiguous subarray of length \`days\` from the array \`growthRates\`. Parameters: growthRates (list): List of integers representing growth rates of plants. days (int): The length of the contiguous subarray to consider. Returns: int: The maximum sum of the contiguous subarray of length \`days\`, or -1 if the length of \`growthRates\` is less than \`days\`. n = len(growthRates) if n < days: return -1 max_sum = sum(growthRates[:days]) current_sum = max_sum for i in range(days, n): current_sum += growthRates[i] - growthRates[i - days] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"import heapq from collections import Counter def rearrangeString(inputStr: str) -> str: Rearranges the characters in the input string such that no two adjacent characters are the same. If it is not possible, returns an empty string. >>> rearrangeString(\\"AAB\\") \\"ABA\\" >>> rearrangeString(\\"AAAB\\") \\"\\" >>> rearrangeString(\\"AAABB\\") in [\\"ABABA\\", \\"BABAB\\"] >>> rearrangeString(\\"\\") \\"\\" >>> rearrangeString(\\"A\\") \\"A\\"","solution":"import heapq from collections import Counter def rearrangeString(inputStr): Rearranges the characters in the input string such that no two adjacent characters are the same. If it is not possible, returns an empty string. char_count = Counter(inputStr) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) prev_char = None prev_count = 0 result = [] while max_heap or prev_count < 0: if max_heap: count, char = heapq.heappop(max_heap) result.append(char) count += 1 if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_char, prev_count = char, count rearranged_str = ''.join(result) return rearranged_str if len(rearranged_str) == len(inputStr) else ''"},{"question":"def maxIndexDifference(arr: List[int]) -> int: Find and return the maximum value of \`j - i\` for all valid pairs of indices \`(i, j)\` such that \`arr[i] <= arr[j]\`. If no such pair exists, return \`0\`. >>> maxIndexDifference([1]) 0 >>> maxIndexDifference([5, 4, 3, 2, 1]) 0 >>> maxIndexDifference([1, 1, 1, 1, 1]) 4 >>> maxIndexDifference([1, 2, 3, 4, 5]) 4 >>> maxIndexDifference([5, 4, 3, 2, 1]) 0 >>> maxIndexDifference([1, 3, 2, 4, 1, 5, 7]) 6 >>> maxIndexDifference([10, 5, 6, 1, 12, 7]) 4 >>> maxIndexDifference([]) 0 from typing import List","solution":"def maxIndexDifference(arr): n = len(arr) if n == 0: return 0 left_min = [0] * n right_max = [0] * n left_min[0] = arr[0] for i in range(1, n): left_min[i] = min(arr[i], left_min[i - 1]) right_max[n - 1] = arr[n - 1] for j in range(n - 2, -1, -1): right_max[j] = max(arr[j], right_max[j + 1]) i, j = 0, 0 max_diff = 0 while i < n and j < n: if left_min[i] <= right_max[j]: max_diff = max(max_diff, j - i) j = j + 1 else: i = i + 1 return max_diff"},{"question":"def calculate_bonus_points(grades): Returns the total number of bonus points given out to the students. A bonus point is given to every student who has a better grade than the student right before them. :param grades: List of integers representing the grades of students. :return: Integer representing the total number of bonus points.","solution":"def calculate_bonus_points(grades): Returns the total number of bonus points given out to the students. A bonus point is given to every student who has a better grade than the student right before them. :param grades: List of integers representing the grades of students. :return: Integer representing the total number of bonus points. if not grades or len(grades) == 1: return 0 bonus_points = 0 for i in range(1, len(grades)): if grades[i] > grades[i - 1]: bonus_points += 1 return bonus_points"},{"question":"def sort_by_exclamation_marks(s: str) -> str: Sorts the words in the sentence in descending order based on the number of exclamation marks. Parameters: s (str): A sentence where words might have exclamation marks. Returns: str: The input sentence with words sorted by the number of exclamation marks in descending order. Examples: >>> sort_by_exclamation_marks(\\"hello! world!! programming!!! is fun!!\\") \\"programming!!! world!! fun!! hello! is\\" >>> sort_by_exclamation_marks(\\"a! b!! c!!! d!!\\") \\"c!!! b!! d!! a!\\" >>> sort_by_exclamation_marks(\\"apple banana!! cherry! date\\") \\"banana!! cherry! apple date\\" >>> sort_by_exclamation_marks(\\"hi!! there!\\") \\"hi!! there!\\" >>> sort_by_exclamation_marks(\\"no exclamation marks here\\") \\"no exclamation marks here\\" >>> sort_by_exclamation_marks(\\"\\") \\"\\" >>> sort_by_exclamation_marks(\\"single!\\") \\"single!\\" >>> sort_by_exclamation_marks(\\"single\\") \\"single\\" >>> sort_by_exclamation_marks(\\"first! second third!!! fourth!\\") \\"third!!! first! fourth! second\\"","solution":"def sort_by_exclamation_marks(s): Sorts the words in the sentence in descending order based on the number of exclamation marks. Parameters: s (str): A sentence where words might have exclamation marks. Returns: str: The input sentence with words sorted by the number of exclamation marks in descending order. def exclamation_count(word): return word.count('!') words = s.split() words_sorted = sorted(words, key=exclamation_count, reverse=True) return ' '.join(words_sorted)"},{"question":"def find_k_closest_integers(arr: List[int], k: int, x: int) -> List[int]: Given an array of integers \`arr\`, an integer \`k\`, and an integer \`x\`, find the \`k\` closest integers to \`x\` in the array. The result should also be sorted in ascending order. An integer \`a\` is closer to \`x\` than an integer \`b\` if: - |a - x| < |b - x|, or - |a - x| == |b - x| and a < b Return the sorted list of the \`k\` closest integers. Example: >>> find_k_closest_integers([1, 2, 3, 4, 5], 4, 3) [1, 2, 3, 4] >>> find_k_closest_integers([1,2,3,4,5], 4, -1) [1, 2, 3, 4]","solution":"def find_k_closest_integers(arr, k, x): Returns the k closest integers to x in the array arr, sorted in ascending order. Parameters: arr (list): List of integers. k (int): Number of closest integers to find. x (int): Target integer. Returns: list: k closest integers sorted in ascending order. # Sort the array with custom key: absolute difference from x and then by the values themselves sorted_by_closeness = sorted(arr, key=lambda num: (abs(num - x), num)) # Slice to get the k closest numbers and sort them in ascending order k_closest_sorted = sorted(sorted_by_closeness[:k]) return k_closest_sorted"},{"question":"def is_anagram(s1: str, s2: str) -> bool: Checks if s2 contains a substring that is an anagram of s1. >>> is_anagram(\\"ab\\", \\"eidbaooo\\") True >>> is_anagram(\\"abc\\", \\"cbaebabacd\\") True >>> is_anagram(\\"ab\\", \\"eidboaoo\\") False >>> is_anagram(\\"xyz\\", \\"abcdef\\") False >>> is_anagram(\\"\\", \\"abcdef\\") True >>> is_anagram(\\"a\\", \\"\\") False >>> is_anagram(\\"\\", \\"\\") True >>> is_anagram(\\"abc\\", \\"cba\\") True >>> is_anagram(\\"a\\", \\"a\\") True >>> is_anagram(\\"a\\", \\"b\\") False >>> is_anagram(\\"aa\\", \\"baa\\") True >>> is_anagram(\\"aa\\", \\"aab\\") True >>> is_anagram(\\"aaa\\", \\"aaaaa\\") True >>> is_anagram(\\"aa\\", \\"abcdefgh\\") False","solution":"def is_anagram(s1, s2): Checks if s2 contains a substring that is an anagram of s1. from collections import Counter len_s1 = len(s1) s1_count = Counter(s1) for i in range(len(s2) - len_s1 + 1): if Counter(s2[i:i+len_s1]) == s1_count: return True return False"},{"question":"def find_max_subtree_weight(parent: List[int], values: List[int]) -> Tuple[int, int]: Returns the index of the node with the maximum subtree weight and the weight of the subtree. >>> find_max_subtree_weight([-1, 0, 0, 1, 1, 2, 2], [1, 2, 3, 4, 5, 6, 7]) (0, 28) >>> find_max_subtree_weight([-1, 0, 0, 0, 1, 1], [1, 2, 3, 4, 5, 6]) (0, 21) >>> find_max_subtree_weight([-1, 0, 1, 1, 2], [1, 2, 3, 4, 5]) (0, 15) >>> find_max_subtree_weight([-1, 0, 0, 1, 1], [2, 3, 1, 5, 2]) (0, 13) >>> find_max_subtree_weight([-1], [10]) (0, 10)","solution":"def find_max_subtree_weight(parent, values): Returns the index of the node with the maximum subtree weight and the weight of the subtree. n = len(parent) from collections import defaultdict tree = defaultdict(list) for i in range(n): if parent[i] != -1: tree[parent[i]].append(i) def calculate_weights(node): Calculate the subtotal weight of the subtree rooted at \`node\`. Return both the weight and update the weights array. total_weight = values[node] for child in tree[node]: total_weight += calculate_weights(child) weights[node] = total_weight return total_weight weights = [0] * n calculate_weights(parent.index(-1)) max_weight = max(weights) max_weight_node = min(i for i in range(n) if weights[i] == max_weight) return max_weight_node, max_weight"},{"question":"from typing import List def exist(board: List[List[str]], word: str) -> bool: Return True if word exists in the grid following the described rules else False. >>> exist([['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], \\"ABCCED\\") True >>> exist([['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], \\"SEE\\") True >>> exist([['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], \\"ABCB\\") False >>> exist([['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], \\"\\") True >>> exist([['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], \\"ABCCEDFCSAD\\") False","solution":"def exist(board, word): Returns True if the word exists in the board following the described rules, else False. def backtrack(i, j, k): if k == len(word): return True if (i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]): return False temp, board[i][j] = board[i][j], \\"#\\" found = (backtrack(i + 1, j, k + 1) or backtrack(i - 1, j, k + 1) or backtrack(i, j + 1, k + 1) or backtrack(i, j - 1, k + 1)) board[i][j] = temp return found for row in range(len(board)): for col in range(len(board[0])): if backtrack(row, col, 0): return True return False"},{"question":"def min_modifications_to_make_valid(s: str) -> int: Returns the minimum number of parentheses that need to be added or removed to make the string valid. >>> min_modifications_to_make_valid(\\"()\\") == 0 >>> min_modifications_to_make_valid(\\"()()()\\") == 0 >>> min_modifications_to_make_valid(\\"(()\\") == 1 >>> min_modifications_to_make_valid(\\")(\\") == 2 >>> min_modifications_to_make_valid(\\"(((\\") == 3 >>> min_modifications_to_make_valid(\\")))\\") == 3 >>> min_modifications_to_make_valid(\\")()(\\") == 2 >>> min_modifications_to_make_valid(\\"(())\\") == 0 >>> min_modifications_to_make_valid(\\"(()())\\") == 0 >>> min_modifications_to_make_valid(\\"()())\\") == 1 >>> min_modifications_to_make_valid(\\"(()))(\\") == 2 >>> min_modifications_to_make_valid(\\"())(()\\") == 2","solution":"def min_modifications_to_make_valid(s: str) -> int: Returns the minimum number of parentheses that need to be added or removed to make the string valid. open_count = 0 # Keeps track of the number of unmatched '(' close_needed = 0 # Keeps track of how many ')' are needed to balance '(' for char in s: if char == '(': open_count += 1 elif char == ')': if open_count > 0: open_count -= 1 else: close_needed += 1 # Total modifications needed is the sum of unmatched '(' and ')' needed return open_count + close_needed"},{"question":"def shortest_unique_string_length(s: str) -> int: Find the length of the shortest possible string that can be achieved by replacing characters in the string \`s\` while maintaining the relative order of characters. Args: s (str): The input string consisting of only lowercase English letters. Returns: int: The length of the shortest possible string. >>> shortest_unique_string_length('aaaaa') 1 >>> shortest_unique_string_length('ababab') 2 >>> shortest_unique_string_length('abcdefg') 7 >>> shortest_unique_string_length('abcabcabc') 3 >>> shortest_unique_string_length('') 0","solution":"def shortest_unique_string_length(s): Finds the length of the shortest possible string that can be obtained by replacing characters in the string \`s\` while maintaining the relative order of characters. Args: s (str): The input string consisting of only lowercase English letters. Returns: int: The length of the shortest possible string. return len(set(s))"},{"question":"def group_characters(s: str) -> str: Group all characters in the string so that each group's characters are the same and the number of groups is minimized. >>> group_characters(\\"abc\\") \\"abc\\" >>> group_characters(\\"aaaa\\") \\"aaaa\\" >>> group_characters(\\"aaabbbccc\\") in [\\"aaabbbccc\\", \\"bbbaaaccc\\", \\"cccbbbbaa\\"] >>> group_characters(\\"a\\") \\"a\\" >>> group_characters(\\"aabbccddeeff\\") in [\\"aabbccddeeff\\", \\"bbaaccddeeff\\", \\"ccaabbddffee\\", \\"ddaabbccffee\\", \\"eeaabbccddff\\", \\"ffaabbccddeeff\\"]","solution":"def group_characters(s): Groups all characters in the string so that each group's characters are the same and the number of groups is minimized. :param s: input string consisting only of lowercase English letters :return: resulting string with grouped characters from collections import Counter # Count the occurrences of each character char_count = Counter(s) # Initialize the result as an empty list result = [] # Append characters sorted by their order for char, count in char_count.items(): result.append(char * count) # Join the list into a string and return return ''.join(result)"},{"question":"def min_moves_to_equal_candies(nums: List[int]) -> int: Returns the minimum number of moves required to ensure that all the children have the same number of candies. Args: nums (List[int]): List of integers representing the number of candies each child has. Returns: int: The minimum number of moves required. Examples: >>> min_moves_to_equal_candies([1, 0, 0, 8, 6]) 14 >>> min_moves_to_equal_candies([3, 3, 3, 3]) 0","solution":"def min_moves_to_equal_candies(nums): Returns the minimum number of moves required to ensure that all the children have the same number of candies. # Sort list to find the median easily nums.sort() # Find the median median = nums[len(nums) // 2] # Calculate the number of moves to make all elements equal to the median moves = sum(abs(num - median) for num in nums) return moves"},{"question":"from typing import List def smallestRange(nums: List[List[int]]) -> List[int]: You are given an integer array \`nums\` where each integer represents a position on a number line. Write a function to find the smallest range that includes at least one number from each of the \`k\` lists. If there are multiple answers, return the range that starts at the smallest number. Return the start and end of the range as a list of two integers. def test_smallestRange(): nums = [ [4, 10, 15, 24, 26], [0, 9, 12, 20], [5, 18, 22, 30] ] assert smallestRange(nums) == [20, 24] def test_single_list(): nums = [[1, 2, 3, 4, 5]] assert smallestRange(nums) == [1, 1] def test_no_overlap(): nums = [ [1, 2, 3], [7, 8, 9], [14, 15, 16] ] assert smallestRange(nums) == [3, 14] def test_all_lists_same(): nums = [ [1, 2, 3], [1, 2, 3], [1, 2, 3] ] assert smallestRange(nums) == [1, 1] def test_lists_with_single_numbers(): nums = [ [1], [2], [3] ] assert smallestRange(nums) == [1, 3]","solution":"from typing import List import heapq def smallestRange(nums: List[List[int]]) -> List[int]: min_heap = [] max_value = float('-inf') for i in range(len(nums)): heapq.heappush(min_heap, (nums[i][0], i, 0)) max_value = max(max_value, nums[i][0]) start, end = float('-inf'), float('inf') while min_heap: min_value, row, idx = heapq.heappop(min_heap) if max_value - min_value < end - start: start, end = min_value, max_value if idx + 1 == len(nums[row]): break next_value = nums[row][idx + 1] heapq.heappush(min_heap, (next_value, row, idx + 1)) max_value = max(max_value, next_value) return [start, end]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def leafSimilar(root1, root2): Determine if the two binary trees are leaf-similar. >>> root1 = TreeNode(3) >>> root1.left = TreeNode(5) >>> root1.right = TreeNode(1) >>> root1.left.left = TreeNode(6) >>> root1.left.right = TreeNode(2) >>> root1.left.right.left = TreeNode(7) >>> root1.left.right.right = TreeNode(4) >>> root1.right.left = TreeNode(9) >>> root1.right.right = TreeNode(8) >>> root2 = TreeNode(3) >>> root2.left = TreeNode(5) >>> root2.right = TreeNode(1) >>> root2.left.left = TreeNode(6) >>> root2.left.right = TreeNode(7) >>> root2.right.left = TreeNode(4) >>> root2.right.right = TreeNode(2) >>> root2.right.right.left = TreeNode(9) >>> root2.right.right.right = TreeNode(8) >>> leafSimilar(root1, root2) True >>> root2.right.right.right = TreeNode(10) >>> leafSimilar(root1, root2) False >>> root3 = TreeNode(1) >>> root4 = TreeNode(1) >>> leafSimilar(root3, root4) True >>> root4.val = 2 >>> leafSimilar(root3, root4) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def leafSimilar(root1, root2): Determine if the two binary trees are leaf-similar. def getLeafValues(root): leaves = [] def traverse(node): if node: if not node.left and not node.right: # It's a leaf node leaves.append(node.val) traverse(node.left) traverse(node.right) traverse(root) return leaves return getLeafValues(root1) == getLeafValues(root2)"},{"question":"from typing import List def search_range(nums: List[int], target: int) -> List[int]: Given an array of integers sorted in non-decreasing order and a target integer, find the starting and ending position of the given target value. The algorithm should run in O(log n) time. If the target is not found in the array, it returns [-1, -1]. >>> search_range([1, 2, 3, 4, 5], 6) == [-1, -1] >>> search_range([2, 4, 6, 8, 10], 5) == [-1, -1] >>> search_range([1, 1, 1, 1, 1], 1) == [0, 4] >>> search_range([1, 1, 1, 1, 1], 2) == [-1, -1] >>> search_range([1, 2, 3, 3, 3, 4, 5], 3) == [2, 4] >>> search_range([1, 2, 2, 2, 2, 3, 4], 2) == [1, 4] >>> search_range([], 1) == [-1, -1] >>> search_range([1], 1) == [0, 0] >>> search_range([1, 2, 3, 4, 5], 1) == [0, 0] >>> search_range([1, 2, 3, 4, 5], 5) == [4, 4] >>> nums = [1] * 1000 + [2] * 1000 + [3] * 1000 >>> search_range(nums, 2) == [1000, 1999] >>> search_range(nums, 3) == [2000, 2999] >>> search_range(nums, 4) == [-1, -1]","solution":"def search_range(nums, target): def find_leftmost(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 else: right = mid - 1 return left def find_rightmost(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right leftmost = find_leftmost(nums, target) rightmost = find_rightmost(nums, target) if leftmost <= rightmost: return [leftmost, rightmost] else: return [-1, -1]"},{"question":"def is_double_palindrome(s: str) -> bool: Determines if the string \`s\` is a double-palindrome. A double-palindrome reads the same forwards and backwards, and its first half and second half are also palindromes. Args: s (str): the input string consisting of lowercase English letters. Returns: bool: True if the string is a double-palindrome, otherwise False. >>> is_double_palindrome(\\"abcddcba\\") False >>> is_double_palindrome(\\"aabbccaa\\") False >>> is_double_palindrome(\\"aabbdddd\\") False >>> is_double_palindrome(\\"abccbaabccba\\") True >>> is_double_palindrome(\\"aaaaaaaa\\") True >>> is_double_palindrome(\\"abababab\\") False","solution":"def is_double_palindrome(s): Determines if the string \`s\` is a double-palindrome. n = len(s) # Helper function to check if a given substring is a palindrome def is_palindrome(sub): return sub == sub[::-1] # The entire string should be a palindrome if not is_palindrome(s): return False # The first half should be a palindrome first_half = s[:n//2] if not is_palindrome(first_half): return False # The second half should be a palindrome second_half = s[n//2:] if not is_palindrome(second_half): return False return True"},{"question":"from typing import List def combination_sum(arr: List[int], target: int) -> List[List[int]]: Return a list of all unique combinations of numbers from the given list that add up to the target. Each number from the list can only be used once in a combination. The combinations should be returned in ascending order and each combination itself should be in non-descending order as well. >>> combination_sum([2, 3, 6, 7], 9) == [[2, 7], [3, 6]] >>> combination_sum([2, 3, 5], 8) == [[3, 5]] >>> combination_sum([1, 2, 3], 7) == [] >>> combination_sum([1, 2, 3, 4, 5], 15) == [[1, 2, 3, 4, 5]] >>> combination_sum([5, 10, 12, 13], 10) == [[10]] >>> combination_sum([], 5) == [] >>> combination_sum([1, 2, 2, 3], 4) == [[1, 3], [2, 2]]","solution":"from typing import List def combination_sum(arr: List[int], target: int) -> List[List[int]]: arr.sort() result = [] def backtrack(start, path, target): if target == 0: result.append(path) return elif target < 0: return for i in range(start, len(arr)): if i > start and arr[i] == arr[i - 1]: continue backtrack(i + 1, path + [arr[i]], target - arr[i]) backtrack(0, [], target) return result"},{"question":"def count_flower_borders(grid: List[List[str]]) -> int: Returns the number of distinct flower borders in a 2D grid. >>> count_flower_borders([]) 0 >>> count_flower_borders([[]]) 0 >>> count_flower_borders([ ... ['0', '0', '0'], ... ['0', '0', '0'], ... ['0', '0', '0'] ... ]) 0 >>> count_flower_borders([ ... ['0', '0', '0'], ... ['0', '1', '0'], ... ['0', '0', '0'] ... ]) 1 >>> count_flower_borders([ ... ['1', '0', '1'], ... ['0', '0', '0'], ... ['1', '0', '1'] ... ]) 4 >>> count_flower_borders([ ... ['1', '1', '0'], ... ['1', '0', '0'], ... ['0', '0', '1'] ... ]) 2 >>> count_flower_borders([ ... ['1', '1', '1'], ... ['1', '1', '1'], ... ['1', '1', '1'] ... ]) 1","solution":"def count_flower_borders(grid): Returns the number of distinct flower borders in a 2D grid. if not grid: return 0 def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0': return grid[i][j] = '0' # Mark as visited # Explore all 8 directions directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] for d in directions: dfs(grid, i + d[0], j + d[1]) num_borders = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': num_borders += 1 dfs(grid, i, j) return num_borders"},{"question":"class LibraryTracker: A class to track the number of visitors to a library each day. Methods: - visit(day: int) -> None: Records a visitor for the given day. - count(day: int) -> int: Returns the number of visitors recorded for the given day. - total(start_day: int, end_day: int) -> int: Returns the total number of visitors between the start_day and end_day (inclusive). def __init__(self): pass def visit(self, day: int) -> None: pass def count(self, day: int) -> int: pass def total(self, start_day: int, end_day: int) -> int: pass # Example unit tests using pytest import pytest def test_visit_and_count(): tracker = LibraryTracker() tracker.visit(1) tracker.visit(1) tracker.visit(2) assert tracker.count(1) == 2 assert tracker.count(2) == 1 assert tracker.count(3) == 0 def test_total(): tracker = LibraryTracker() tracker.visit(1) tracker.visit(3) tracker.visit(3) tracker.visit(4) assert tracker.total(1, 4) == 4 assert tracker.total(1, 2) == 1 assert tracker.total(3, 4) == 3 assert tracker.total(5, 6) == 0 def test_total_with_no_visits(): tracker = LibraryTracker() assert tracker.total(1, 10) == 0","solution":"class LibraryTracker: def __init__(self): self.visitors = {} def visit(self, day: int) -> None: if day in self.visitors: self.visitors[day] += 1 else: self.visitors[day] = 1 def count(self, day: int) -> int: return self.visitors.get(day, 0) def total(self, start_day: int, end_day: int) -> int: return sum(self.visitors.get(day, 0) for day in range(start_day, end_day + 1))"},{"question":"from typing import List def canFinishProjects(n: int, dependencies: List[List[int]]) -> bool: Determines if it's possible to complete all projects given their dependencies. Parameters: n (int): Total number of projects. dependencies (List[List[int]]): List of dependencies where each dependency is a pair [a, b]. Returns: bool: True if all projects can be completed, False otherwise. >>> canFinishProjects(3, []) True >>> canFinishProjects(3, [[0, 1], [1, 2]]) True >>> canFinishProjects(3, [[0, 1], [1, 2], [2, 0]]) False >>> canFinishProjects(4, [[0, 1], [2, 3]]) True >>> canFinishProjects(4, [[0, 1], [1, 2], [2, 3], [3, 1]]) False >>> canFinishProjects(1, []) True >>> canFinishProjects(2, [[1, 0], [0, 1]]) False >>> canFinishProjects(2, [[0, 1]]) True","solution":"from collections import deque, defaultdict def canFinishProjects(n, dependencies): Determines if it's possible to finish all projects given their dependencies. Parameters: n (int): Total number of projects. dependencies (List[List[int]]): List of dependencies where each dependency is a pair [a, b]. Returns: bool: True if all projects can be completed, False otherwise. graph = defaultdict(list) in_degree = [0] * n for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 queue = deque([i for i in range(n) if in_degree[i] == 0]) count = 0 while queue: node = queue.popleft() count += 1 for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return count == n"},{"question":"def min_relocation_cost(houses, m): Find the minimum total relocation cost to service all houses with new mailbox locations. Args: houses (List[int]): A list of coordinates of houses. m (int): The number of mailboxes. Returns: int: The minimum total relocation cost for optimal mailbox placements. >>> min_relocation_cost([1], 1) 0 >>> min_relocation_cost([1, 4], 1) 3 >>> min_relocation_cost([1, 4, 8, 10], 2) 5 >>> min_relocation_cost([1, 2, 3, 4, 5], 2) 3 >>> min_relocation_cost([1, 2], 3) 0 >>> min_relocation_cost([1, 2, 3, 4, 5], 5) 0","solution":"def min_relocation_cost(houses, m): houses.sort() # Sort the coordinates of houses n = len(houses) if m >= n: return 0 dp = [[0] * n for _ in range(m + 1)] cost = [[0] * n for _ in range(n)] for i in range(n): for j in range(i, n): mid = (i + j) // 2 for k in range(i, j + 1): cost[i][j] += abs(houses[k] - houses[mid]) for i in range(n): dp[1][i] = cost[0][i] for i in range(2, m + 1): for j in range(i - 1, n): dp[i][j] = float('inf') for k in range(i - 2, j): dp[i][j] = min(dp[i][j], dp[i - 1][k] + cost[k + 1][j]) return dp[m][n - 1]"},{"question":"def can_distribute_all_packets(arr, k): Checks if it is possible to distribute all packets such that each child gets exactly k candies. Parameters: arr (list of int): List representing sizes of packets of candies. k (int): Number of candies each child should receive. Returns: bool: True if it is possible to distribute all packets to meet the requirement, False otherwise. >>> can_distribute_all_packets([6, 12, 18], 6) True >>> can_distribute_all_packets([6, 12, 7], 6) False >>> can_distribute_all_packets([0, 0, 0], 0) True >>> can_distribute_all_packets([0, 1, 0], 0) False >>> can_distribute_all_packets([5, 10, 15, 20], 5) True >>> can_distribute_all_packets([5, 10, 15, 25], 7) False >>> can_distribute_all_packets([], 5) True","solution":"def can_distribute_all_packets(arr, k): Checks if it is possible to distribute all packets such that each child gets exactly k candies. Parameters: arr (list of int): List representing sizes of packets of candies. k (int): Number of candies each child should receive. Returns: bool: True if it is possible to distribute all packets to meet the requirement, False otherwise. if k == 0: return all(candy == 0 for candy in arr) for size in arr: if size % k != 0: return False return True"},{"question":"def can_transform(s: str, t: str) -> bool: Determines if t can be transformed into s by inserting or deleting at most one character. >>> can_transform(\\"abc\\", \\"abc\\") True >>> can_transform(\\"abc\\", \\"abdc\\") True >>> can_transform(\\"abcd\\", \\"abc\\") True >>> can_transform(\\"abc\\", \\"abde\\") False >>> can_transform(\\"abc\\", \\"abcde\\") False >>> can_transform(\\"abc\\", \\"dabc\\") True >>> can_transform(\\"abc\\", \\"bc\\") True >>> can_transform(\\"abc\\", \\"xyz\\") False >>> can_transform(\\"\\", \\"a\\") True >>> can_transform(\\"a\\", \\"\\") True >>> can_transform(\\"\\", \\"\\") True","solution":"def can_transform(s, t): Determines if t can be transformed into s by inserting or deleting at most one character. len_s = len(s) len_t = len(t) if abs(len_s - len_t) > 1: return False i = j = 0 diff_count = 0 while i < len_s and j < len_t: if s[i] != t[j]: if diff_count == 1: return False diff_count += 1 if len_s > len_t: i += 1 elif len_s < len_t: j += 1 else: i += 1 j += 1 else: i += 1 j += 1 return True"},{"question":"def min_roads_to_remove(n: int, edges: List[List[int]]) -> int: Returns the smallest number of roads to remove to make the graph a tree of n nodes. If impossible, returns -1. >>> min_roads_to_remove(4, [[0, 1], [1, 2], [2, 3]]) 0 >>> min_roads_to_remove(4, [[0, 1], [0, 2], [0, 3], [1, 2]]) 1 >>> min_roads_to_remove(6, [[0, 1], [0, 2], [3, 4]]) -1 >>> min_roads_to_remove(5, [[0, 1], [0, 2], [0, 3], [1, 3], [2, 4], [3, 4]]) 2 >>> min_roads_to_remove(3, []) -1","solution":"def min_roads_to_remove(n, edges): Returns the smallest number of roads to remove to make the graph a tree of n nodes. If impossible, returns -1. from collections import defaultdict, deque # Check if it's even possible if len(edges) < n - 1: return -1 parent = list(range(n)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX # Connect all nodes and count redundancies for u, v in edges: union(u, v) unique_roots = len(set(find(i) for i in range(n))) # the graph needs to have exactly 1 connected component to be a tree return len(edges) - (n - 1) if unique_roots == 1 else -1"},{"question":"from typing import List, Tuple def sort_applicants(applicants: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts the list of applicants by their scores in non-decreasing order. If two applicants have the same score, they are sorted alphabetically by their names. Parameters: applicants (List[Tuple[str, int]]): A list of tuples where each tuple contains a name (str) and a score (int). Returns: List[Tuple[str, int]]: The sorted list of applicants. pass # Example test cases def test_sort_applicants_empty(): assert sort_applicants([]) == [] def test_sort_applicants_single(): assert sort_applicants([(\\"Alice\\", 50)]) == [(\\"Alice\\", 50)] def test_sort_applicants_sorted_by_score(): applicants = [(\\"Alice\\", 50), (\\"Bob\\", 75), (\\"Charlie\\", 60)] expected = [(\\"Alice\\", 50), (\\"Charlie\\", 60), (\\"Bob\\", 75)] assert sort_applicants(applicants) == expected def test_sort_applicants_sorted_by_name_with_same_score(): applicants = [(\\"Alice\\", 50), (\\"Bob\\", 50), (\\"Carol\\", 50)] expected = [(\\"Alice\\", 50), (\\"Bob\\", 50), (\\"Carol\\", 50)] assert sort_applicants(applicants) == expected def test_sort_applicants_mixed(): applicants = [(\\"Bob\\", 75), (\\"Charlie\\", 60), (\\"Alice\\", 50), (\\"Dave\\", 50)] expected = [(\\"Alice\\", 50), (\\"Dave\\", 50), (\\"Charlie\\", 60), (\\"Bob\\", 75)] assert sort_applicants(applicants) == expected def test_sort_applicants_reverse_order(): applicants = [(\\"Charlie\\", 90), (\\"Bob\\", 80), (\\"Alice\\", 70)] expected = [(\\"Alice\\", 70), (\\"Bob\\", 80), (\\"Charlie\\", 90)] assert sort_applicants(applicants) == expected","solution":"from typing import List, Tuple def sort_applicants(applicants: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts the list of applicants by their scores in non-decreasing order. If two applicants have the same score, they are sorted alphabetically by their names. Parameters: applicants (List[Tuple[str, int]]): A list of tuples where each tuple contains a name (str) and a score (int). Returns: List[Tuple[str, int]]: The sorted list of applicants. return sorted(applicants, key=lambda x: (x[1], x[0]))"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def insert(self, value): Insert a value into the binary tree. >>> tree = BinaryTree() >>> tree.insert(10) >>> tree.insert(5) >>> tree.insert(15) >>> tree.exists(10) True >>> tree.exists(20) False pass def delete(self, value): Delete a value from the binary tree. >>> tree = BinaryTree() >>> tree.insert(10) >>> tree.insert(5) >>> tree.delete(5) >>> tree.exists(5) False pass def exists(self, value): Check if a value exists in the binary tree. >>> tree = BinaryTree() >>> tree.insert(10) >>> tree.insert(5) >>> tree.exists(10) True >>> tree.exists(20) False pass def find_min(self): Find the minimum value in the binary tree. >>> tree = BinaryTree() >>> tree.insert(10) >>> tree.insert(5) >>> tree.insert(15) >>> tree.find_min() 5 pass def find_max(self): Find the maximum value in the binary tree. >>> tree = BinaryTree() >>> tree.insert(10) >>> tree.insert(5) >>> tree.insert(15) >>> tree.find_max() 15 pass","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert(node.left, value) elif value > node.value: if node.right is None: node.right = TreeNode(value) else: self._insert(node.right, value) # if value == node.value, do nothing to avoid duplicates def delete(self, value): self.root = self._delete(self.root, value) def _delete(self, node, value): if node is None: return node if value < node.value: node.left = self._delete(node.left, value) elif value > node.value: node.right = self._delete(node.right, value) else: if node.left is None: return node.right elif node.right is None: return node.left min_larger_node = self._find_min(node.right) node.value = min_larger_node.value node.right = self._delete(node.right, min_larger_node.value) return node def exists(self, value): return self._exists(self.root, value) def _exists(self, node, value): if node is None: return False if value == node.value: return True elif value < node.value: return self._exists(node.left, value) else: return self._exists(node.right, value) def find_min(self): if self.root is None: return None return self._find_min(self.root).value def _find_min(self, node): current = node while current.left is not None: current = current.left return current def find_max(self): if self.root is None: return None return self._find_max(self.root).value def _find_max(self, node): current = node while current.right is not None: current = current.right return current"},{"question":"def longest_row_of_ones(mat: List[List[int]]) -> int: Identify and return the length of the longest row of 1's in a 2D binary matrix. >>> longest_row_of_ones([ [0, 1, 1, 0], [1, 1, 1, 1], [0, 0, 1, 1] ]) 4 >>> longest_row_of_ones([ [0, 0, 0, 0], [0, 0, 0, 1], [0, 0, 0, 0] ]) 1 >>> longest_row_of_ones([ [1, 0, 0, 1], [1, 1, 0, 0], [0, 1, 1, 1] ]) 3 >>> longest_row_of_ones([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 0 >>> longest_row_of_ones([ [1, 1, 1], [1, 1, 1] ]) 3","solution":"def longest_row_of_ones(mat): Returns the length of the longest row of 1s in the matrix mat. If there are multiple rows with the same maximum length, return any one of them. max_length = 0 for row in mat: current_length = 0 for val in row: if val == 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def longest_increasing_subarray_length(arr: List[int]) -> int: Returns the length of the longest subarray that forms an increasing sequence. >>> longest_increasing_subarray_length([]) == 0 >>> longest_increasing_subarray_length([5]) == 1 >>> longest_increasing_subarray_length([2, 2, 2, 2]) == 1 >>> longest_increasing_subarray_length([1, 2, 3, 4, 5]) == 5 >>> longest_increasing_subarray_length([5, 4, 3, 2, 1]) == 1 >>> longest_increasing_subarray_length([1, 3, 5, 4, 2, 2, 2, 6, 7, 8]) == 4 >>> longest_increasing_subarray_length([1, 2, 3, 2, 3, 4, 1, 2, 3, 4, 5]) == 5 >>> longest_increasing_subarray_length([1, 2, 3, 1, 2, 2, 1, 2, 3, 4, 3]) == 4","solution":"def longest_increasing_subarray_length(arr): Returns the length of the longest subarray that forms an increasing sequence. if not arr: return 0 if len(arr) == 1: return 1 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def exist(board: List[List[str]], word: str) -> bool: Determine if there exists a sequence in the grid that spells out the given target word by moving sequentially adjacent cells. Adjacent cells are horizontally or vertically neighboring, and the same letter cell may not be used more than once. Args: board (List[List[str]]): Two-dimensional grid containing letters. word (str): Target word to search for in the grid. Returns: bool: A boolean indicating whether such a path exists in the grid for the target word. >>> board = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']] >>> exist(board, 'ABCCED') True >>> exist(board, 'ABCB') False >>> exist([['A']], 'A') True >>> exist([['A']], 'B') False >>> exist([], 'A') False","solution":"def exist(board, word): def dfs(board, word, i, j, word_index): if word_index == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[word_index]: return False temp = board[i][j] board[i][j] = \\"#\\" found = (dfs(board, word, i + 1, j, word_index + 1) or dfs(board, word, i - 1, j, word_index + 1) or dfs(board, word, i, j + 1, word_index + 1) or dfs(board, word, i, j - 1, word_index + 1)) board[i][j] = temp return found for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): return True return False"},{"question":"def min_adjacent_swaps_to_sort(arr: List[int]) -> int: Returns the minimum number of adjacent swaps required to sort the array in ascending order. >>> min_adjacent_swaps_to_sort([1, 2, 3, 4, 5]) 0 >>> min_adjacent_swaps_to_sort([5, 4, 3, 2, 1]) 10 >>> min_adjacent_swaps_to_sort([2, 4, 1, 3, 5]) 3 >>> min_adjacent_swaps_to_sort([1]) 0 >>> min_adjacent_swaps_to_sort([1, 3, 5, 2, 6, 4]) 4","solution":"def min_adjacent_swaps_to_sort(arr): Returns the minimum number of adjacent swaps required to sort the array in ascending order. def merge_count_split_inv(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort(arr, temp_arr, left, mid) inv_count += merge_sort(arr, temp_arr, mid + 1, right) inv_count += merge_count_split_inv(arr, temp_arr, left, mid, right) return inv_count n = len(arr) temp_arr = [0]*n return merge_sort(arr, temp_arr, 0, n-1)"},{"question":"def maxCoins(nums: List[int]) -> int: Given a list of integers representing the number of balloons in sections of a hallway, returns the maximum score achieved by popping all balloons optimally. Args: nums (List[int]): A list of integers representing the number of balloons in sections of a hallway. Returns: int: The maximum score achieved by popping all the balloons optimally. Example: >>> maxCoins([3]) 3 >>> maxCoins([3,1]) 6 >>> maxCoins([3,1,5]) 35 >>> maxCoins([3,1,5,8]) 167 >>> maxCoins([1,1,1]) 3 >>> maxCoins([9,76,64,21]) 116718 from typing import List def test_single_balloon(): assert maxCoins([3]) == 3 def test_two_balloons(): assert maxCoins([3,1]) == 6 def test_three_balloons(): assert maxCoins([3,1,5]) == 35 def test_multiple_balloons(): assert maxCoins([3,1,5,8]) == 167 def test_empty_list(): assert maxCoins([]) == 0 def test_same_value_balloons(): assert maxCoins([1, 1, 1]) == 3 def test_large_values(): assert maxCoins([9,76,64,21]) == 116718","solution":"def maxCoins(nums): Given a list of integers representing the number of balloons in sections of a hallway, returns the maximum score achieved by popping all balloons optimally. # Pad nums with 1 at the start and end to handle edge cases nums = [1] + nums + [1] n = len(nums) # Create a memoization table to store the results of subproblems dp = [[0] * n for _ in range(n)] # Build the table dp[][] in bottom-up manner for length in range(2, n): # length is the range we consider for left in range(n - length): # left is the starting index right = left + length # right is the ending index set after the length # Initialize the score for (left, right) range dp[left][right] = 0 # Iterating in the range (left+1, right) for i in range(left + 1, right): # coins gained by popping the current balloon is nums[left] * nums[i] * nums[right] # adding the coins from previously solved subproblems dp[left][right] = max(dp[left][right], nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right]) return dp[0][n - 1]"},{"question":"def longestValidParentheses(s: str) -> int: Returns the length of the longest valid (well-formed) parentheses substring. Args: s (str): The input string containing just the characters '(' and ')'. Returns: int: The length of the longest valid parentheses substring. >>> longestValidParentheses(\\"\\") == 0 >>> longestValidParentheses(\\"((((\\") == 0 >>> longestValidParentheses(\\"))))\\") == 0 >>> longestValidParentheses(\\"()\\") == 2 >>> longestValidParentheses(\\"(()\\") == 2 >>> longestValidParentheses(\\"()(())\\") == 6 >>> longestValidParentheses(\\")()())\\") == 4 >>> longestValidParentheses(\\")()()(()\\") == 4 >>> longestValidParentheses(\\"(()))())(\\") == 4 >>> longestValidParentheses(\\"()(()))())(\\") == 6","solution":"def longestValidParentheses(s): Returns the length of the longest valid (well-formed) parentheses substring. Args: s (str): The input string containing just the characters '(' and ')'. Returns: int: The length of the longest valid parentheses substring. max_len = 0 stack = [-1] # Initialize stack with -1 to handle base case where a valid substring starts at index 0 for i, char in enumerate(s): if char == '(': stack.append(i) else: # char == ')' stack.pop() if not stack: stack.append(i) else: max_len = max(max_len, i - stack[-1]) return max_len"},{"question":"def min_operations_to_zero(arr, target): Returns the minimum number of operations required to reduce target to 0 by subtracting elements of the array. If it's not possible to reduce target to 0, return -1. >>> min_operations_to_zero([1, 2, 3], 7) 3 >>> min_operations_to_zero([5, 3, 4], 7) 2 >>> min_operations_to_zero([2], 3) -1 >>> min_operations_to_zero([1, 5], 100) 20 >>> min_operations_to_zero([1], 0) 0 >>> min_operations_to_zero([3, 7, 10], 14) 2","solution":"def min_operations_to_zero(arr, target): Returns the minimum number of operations required to reduce target to 0 by subtracting elements of the array. If it's not possible to reduce target to 0, return -1. dp = [float('inf')] * (target + 1) dp[0] = 0 # Zero operations to reduce target 0 to 0 for t in range(1, target + 1): for num in arr: if t - num >= 0: dp[t] = min(dp[t], dp[t - num] + 1) return dp[target] if dp[target] != float('inf') else -1"},{"question":"class TextEditor: A simple text editor that tracks word count in a document. Operations: - insert(word: str) -> None: Inserts the specified word into the document. - delete(word: str) -> None: Deletes the first occurrence of the specified word from the document. - count(word: str) -> int: Returns the count of the specified word in the document. The text editor handles case-insensitivity when performing operations on the document. Example: >>> editor = TextEditor() >>> editor.insert('Hello') >>> editor.insert('HELLO') >>> editor.count('hello') 2 >>> editor.delete('HELLO') >>> editor.count('hello') 1 def __init__(self): Initialize the TextEditor with an empty document. pass def insert(self, word: str) -> None: Inserts the specified word into the document. Args: word (str): The word to add to the document. Should only include letters a-z or A-Z. pass def delete(self, word: str) -> None: Deletes the first occurrence of the specified word from the document. Args: word (str): The word to delete from the document. pass def count(self, word: str) -> int: Returns the count of the specified word in the document. Args: word (str): The word to count in the document. Returns: int: The number of occurrences of the word in the document. pass from solution import TextEditor def test_insert_and_count(): editor = TextEditor() editor.insert('Hello') editor.insert('World') assert editor.count('Hello') == 1 assert editor.count('World') == 1 assert editor.count('hello') == 1 assert editor.count('world') == 1 def test_delete(): editor = TextEditor() editor.insert('Hello') editor.insert('Hello') editor.delete('Hello') assert editor.count('Hello') == 1 editor.delete('Hello') assert editor.count('Hello') == 0 editor.delete('Hello') assert editor.count('Hello') == 0 def test_case_insensitivity(): editor = TextEditor() editor.insert('Hello') editor.insert('HELLO') assert editor.count('hello') == 2 editor.delete('HELLO') assert editor.count('hello') == 1 def test_non_alpha_word(): editor = TextEditor() editor.insert('Hello123') assert editor.count('Hello123') == 0 assert editor.count('hello') == 0","solution":"class TextEditor: def __init__(self): self.document = [] def insert(self, word: str) -> None: if word.isalpha(): self.document.append(word.lower()) def delete(self, word: str) -> None: word_lower = word.lower() if word_lower in self.document: self.document.remove(word_lower) def count(self, word: str) -> int: return self.document.count(word.lower())"},{"question":"def gameOfLife(grid: List[List[int]]) -> None: Update the 'grid' in-place to the next state of the Game of Life. The rules are as follows: 1. Any live cell with fewer than two live neighbors dies as if caused by under-population. 2. Any live cell with two or three live neighbors lives on to the next generation. 3. Any live cell with more than three live neighbors dies, as if by over-population. 4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. Args: grid (List[List[int]]): A 2D grid representing the state of each cell in the game. Returns: None: The grid is updated in place. from typing import List def test_gameOfLife_still_life(): grid = [ [1, 1], [1, 1] ] expected = [ [1, 1], [1, 1] ] gameOfLife(grid) assert grid == expected def test_gameOfLife_oscillator(): grid = [ [0, 1, 0], [0, 1, 0], [0, 1, 0] ] expected = [ [0, 0, 0], [1, 1, 1], [0, 0, 0] ] gameOfLife(grid) assert grid == expected def test_gameOfLife_becomes_dead(): grid = [ [1, 1, 1], [1, 0, 1], [1, 1, 1] ] expected = [ [1, 0, 1], [0, 0, 0], [1, 0, 1] ] gameOfLife(grid) assert grid == expected def test_gameOfLife_reproduction(): grid = [ [0, 1, 0], [0, 0, 1], [1, 1, 1] ] expected = [ [0, 0, 0], [1, 0, 1], [0, 1, 1] ] gameOfLife(grid) assert grid == expected","solution":"from typing import List def gameOfLife(grid: List[List[int]]) -> None: Update the 'grid' in-place to the next state of the Game of Life. m, n = len(grid), len(grid[0]) # Helper function to calculate live neighbors of a cell def live_neighbors(r, c): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] live_count = 0 for dr, dc in directions: if 0 <= r + dr < m and 0 <= c + dc < n: live_count += grid[r + dr][c + dc] & 1 return live_count # Iterate through every cell to determine its next state for r in range(m): for c in range(n): live_count = live_neighbors(r, c) if grid[r][c] == 1 and (live_count < 2 or live_count > 3): # Live cells with fewer than two or more than three live neighbors die grid[r][c] = 1 # Setting the second bit to 0 (already 0 if &= 1) elif grid[r][c] == 1 and (live_count == 2 or live_count == 3): # Live cells with two or three live neighbors continue to live grid[r][c] = 3 # Mark it as live in next state (bit 1 kept as it is, bit 2 set to 1) elif grid[r][c] == 0 and live_count == 3: # Dead cells with exactly three live neighbors become alive grid[r][c] = 2 # Mark it as live in next state (bit 2 set to 1) # Update the grid to the next state by shifting bits for r in range(m): for c in range(n): grid[r][c] >>= 1"},{"question":"def min_bricks_to_end(heights: List[int], bricks: int) -> int: Calculates the minimum number of bricks required to jump from the first building to the last one. If it is not possible within the given bricks, returns -1. :param heights: List[int] - List of building heights :param bricks: int - Total number of bricks available :return: int - Minimum bricks required or -1 if not possible from solution import min_bricks_to_end def test_not_enough_bricks(): assert min_bricks_to_end([1, 2, 3, 4, 5], 3) == -1 def test_exact_bricks_needed(): assert min_bricks_to_end([1, 2, 1, 2, 1], 2) == 2 def test_no_bricks_needed(): assert min_bricks_to_end([3, 3, 3, 3], 0) == 0 def test_more_bricks_than_needed(): assert min_bricks_to_end([1, 2, 3, 4], 10) == 3 def test_single_building(): assert min_bricks_to_end([1], 0) == 0 def test_high_height_differences(): assert min_bricks_to_end([1, 10, 1, 10], 18) == 18 def test_negative_bricks(): assert min_bricks_to_end([1, 2, 3], -1) == -1 def test_empty_height(): assert min_bricks_to_end([], 0) == 0 def test_no_need_for_bricks(): assert min_bricks_to_end([5, 4, 3, 2, 1], 0) == 0","solution":"def min_bricks_to_end(heights, bricks): Calculates the minimum number of bricks required to jump from the first building to the last one. If it is not possible within the given bricks, returns -1. :param heights: List[int] - List of building heights :param bricks: int - Total number of bricks available :return: int - Minimum bricks required or -1 if not possible total_bricks_needed = 0 for i in range(len(heights) - 1): if heights[i + 1] > heights[i]: diff = heights[i + 1] - heights[i] total_bricks_needed += diff if total_bricks_needed > bricks: return -1 return total_bricks_needed"},{"question":"def can_partition_equal_sum_subarrays(arr: List[int], k: int) -> bool: Determine if the array can be partitioned into contiguous subarrays with equal sums. >>> can_partition_equal_sum_subarrays([2, 2, 2, 2], 1) True >>> can_partition_equal_sum_subarrays([5], 1) True >>> can_partition_equal_sum_subarrays([2, 3, 5, 1], 2) False >>> can_partition_equal_sum_subarrays([4, 4, 4, 4, 4, 4], 1) True >>> can_partition_equal_sum_subarrays([1, 2, 3, 4, 6, 6], 3) False","solution":"def can_partition_equal_sum_subarrays(arr, k): Determine if the array can be partitioned into contiguous subarrays with equal sums. total_sum = sum(arr) n = len(arr) # If the total sum is not divisible by the length of array, we cannot partition it into equal sum subarrays if total_sum % n != 0: return False subarray_sum = total_sum // n current_sum = 0 partitions = 0 for num in arr: current_sum += num if current_sum == subarray_sum: partitions += 1 current_sum = 0 # If the number of partitions found is equal to the length of the array, return True return partitions == n"},{"question":"def can_jump(arr): Determines if you can reach the last index from the first index. Parameters: arr (list): A list of integers where each element represents the maximum jump length at that position. Returns: bool: True if you can reach the last index, False otherwise. >>> can_jump([2, 3, 1, 1, 4]) True >>> can_jump([3, 2, 1, 0, 4]) False >>> can_jump([0]) True >>> can_jump([1, 1, 1, 1, 1]) True >>> can_jump([5, 0, 0, 0, 0, 0]) True >>> can_jump([100, 0, 0, 0, 0]) True >>> can_jump([]) False >>> can_jump([0, 1]) False","solution":"def can_jump(arr): Determines if you can reach the last index from the first index. Parameters: arr (list): A list of integers where each element represents the maximum jump length at that position. Returns: bool: True if you can reach the last index, False otherwise. max_reach = 0 for i, jump in enumerate(arr): if i > max_reach: return False max_reach = max(max_reach, i + jump) if max_reach >= len(arr) - 1: return True return False"},{"question":"def longest_even_char_substring(s: str) -> int: Returns the length of the longest substring with each unique character appearing an even number of times. >>> longest_even_char_substring(\\"aabbac\\") 4 >>> longest_even_char_substring(\\"dogracecarcar\\") 0 >>> longest_even_char_substring(\\"abba\\") 4 >>> longest_even_char_substring(\\"abcd\\") 0 >>> longest_even_char_substring(\\"abacaba\\") 7 from solution import longest_even_char_substring def test_longest_even_char_substring(): assert longest_even_char_substring(\\"aabbac\\") == 4 assert longest_even_char_substring(\\"dogracecarcar\\") == 0 assert longest_even_char_substring(\\"abba\\") == 4 assert longest_even_char_substring(\\"abcd\\") == 0 assert longest_even_char_substring(\\"abacaba\\") == 7","solution":"def longest_even_char_substring(s): Returns the length of the longest substring with each unique character appearing an even number of times. n = len(s) max_len = 0 prefix_xor = [0] * (n+1) first_occur = {0: -1} for i in range(n): # Update prefix xor for each character prefix_xor[i+1] = prefix_xor[i] ^ (1 << (ord(s[i]) - ord('a'))) if prefix_xor[i+1] in first_occur: max_len = max(max_len, i - first_occur[prefix_xor[i+1]]) else: first_occur[prefix_xor[i+1]] = i return max_len"},{"question":"def evaluate_expression(s: str) -> int: Evaluate the given string mathematical expression \`s\` containing non-negative integers and operators +, -, *, /. Handle the division in integer format, truncating towards zero. :param s: str :return: int >>> evaluate_expression(\\"3+5\\") 8 >>> evaluate_expression(\\"10-2\\") 8 >>> evaluate_expression(\\"2*3\\") 6 >>> evaluate_expression(\\"8/3\\") 2 >>> evaluate_expression(\\" 3 + 5 \\") 8 >>> evaluate_expression(\\"10-3*2\\") 4 >>> evaluate_expression(\\"14-3/2\\") 13 >>> evaluate_expression(\\"10/3\\") 3 >>> evaluate_expression(\\"14 + 2 * 3 / 7\\") 14 >>> evaluate_expression(\\"0\\") 0 >>> evaluate_expression(\\"42\\") 42","solution":"def evaluate_expression(s): Evaluate the given string mathematical expression \`s\` containing non-negative integers and operators +, -, *, /. Handle the division in integer format, truncating towards zero. :param s: str :return: int def operate(a, b, op): if op == '+': return a + b if op == '-': return a - b if op == '*': return a * b if op == '/': return int(a / b) # to truncate towards zero num_stack = [] op_stack = [] i = 0 n = len(s) while i < n: if s[i].isdigit(): num = 0 while i < n and s[i].isdigit(): num = num * 10 + int(s[i]) i += 1 num_stack.append(num) # Debug: print current num_stack print(f\\"num_stack: {num_stack}\\") else: if s[i] in \\"+-*/\\": while (op_stack and (op_stack[-1] in \\"*/\\" or (op_stack[-1] in \\"+-\\" and s[i] in \\"+-\\"))): num2 = num_stack.pop() num1 = num_stack.pop() op = op_stack.pop() result = operate(num1, num2, op) num_stack.append(result) # Debug: print after operation print(f\\"Operate: {num1} {op} {num2} = {result}, num_stack: {num_stack}\\") op_stack.append(s[i]) # Debug: print op_stack print(f\\"op_stack: {op_stack}\\") i += 1 while op_stack: num2 = num_stack.pop() num1 = num_stack.pop() op = op_stack.pop() result = operate(num1, num2, op) num_stack.append(result) # Debug: print after operation print(f\\"Final Operate: {num1} {op} {num2} = {result}, num_stack: {num_stack}\\") return num_stack[0]"},{"question":"from typing import List def min_cost_partition(nums: List[int]) -> int: You are given a 0-indexed integer array nums consisting of n positive integers. You can choose an integer k where 1 <= k <= n and partition the array into exactly k non-empty contiguous subarrays. The cost of a partition is the sum of the largest elements of each subarray. Return the minimum possible cost to partition nums. >>> min_cost_partition([5]) 5 >>> min_cost_partition([5, 3]) 5 >>> min_cost_partition([2, 3, 1, 4]) 4 >>> min_cost_partition([1, 3, 2, 1, 4, 1, 5, 6]) 6 >>> min_cost_partition([1, 2, 1, 4, 3, 5, 6, 1]) 6","solution":"from functools import lru_cache def min_cost_partition(nums): @lru_cache(None) def dp(i, k): if k == 1: return max(nums[:i]) min_cost = float('inf') for j in range(1, i): min_cost = min(min_cost, max(nums[j:i]) + dp(j, k-1)) return min_cost return min(dp(len(nums), k) for k in range(1, len(nums)+1))"},{"question":"from typing import List def isValidSquare(points: List[List[int]]) -> bool: Determines if a set of four of these points can form a square. >>> isValidSquare([[0, 0], [1, 0], [1, 1], [0, 1]]) True >>> isValidSquare([[0, 0], [2, 0], [3, 1], [1, 1]]) False >>> isValidSquare([[0, 0], [1, 1], [1, 2], [0, 2], [2, 0]]) False pass","solution":"from typing import List from itertools import combinations def distance_squared(p1, p2): return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 def is_square(p1, p2, p3, p4): distances = [ distance_squared(p1, p2), distance_squared(p1, p3), distance_squared(p1, p4), distance_squared(p2, p3), distance_squared(p2, p4), distance_squared(p3, p4) ] distances.sort() return distances[0] > 0 and distances[0] == distances[1] == distances[2] == distances[3] and distances[4] == distances[5] def isValidSquare(points: List[List[int]]) -> bool: if len(points) < 4: return False for quad in combinations(points, 4): if is_square(*quad): return True return False"},{"question":"def max_nesting_depth(s: str) -> int: Determine the maximum nesting depth of the parentheses in a given string. :param s: str - a string containing only valid parentheses :return: int - the maximum depth of nested parentheses >>> max_nesting_depth(\\"()\\") 1 >>> max_nesting_depth(\\"(())\\") 2 >>> max_nesting_depth(\\"((()))\\") 3 >>> max_nesting_depth(\\"()(()())\\") 2 >>> max_nesting_depth(\\"()()()()()\\") 1 >>> max_nesting_depth(\\"((())()(()))\\") 3 >>> max_nesting_depth(\\"\\") 0","solution":"def max_nesting_depth(s): Returns the maximum nesting depth of the parentheses in string s. :param s: str - a string containing only valid parentheses :return: int - the maximum depth of nested parentheses max_depth = 0 current_depth = 0 for char in s: if char == '(': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == ')': current_depth -= 1 return max_depth"},{"question":"def is_bipartite(graph: List[List[int]]) -> bool: Determines if the given graph is bipartite. A bipartite graph is one that can be colored using two colors such that no two adjacent vertices share the same color. :param graph: List[List[int]] - adjacency list representing the graph. :return: bool - True if the graph is bipartite, otherwise False. >>> is_bipartite([[1, 3], [0, 2], [1, 3], [0, 2]]) True >>> is_bipartite([[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]]) False >>> is_bipartite([[]]) True >>> is_bipartite([]) True >>> is_bipartite([[1], [0], [3], [2]]) True >>> is_bipartite([[0]]) False","solution":"def is_bipartite(graph): Determines if the given graph is bipartite. :param graph: List[List[int]] - adjacency list representing the graph. :return: bool - True if the graph is bipartite, otherwise False. color = {} def dfs(node, c): if node in color: return color[node] == c color[node] = c return all(dfs(nei, c ^ 1) for nei in graph[node]) return all(dfs(node, 0) for node in range(len(graph)) if node not in color)"},{"question":"def min_operations_to_create_valid_pair(nums1: List[int], nums2: List[int]) -> int: Returns the minimum number of operations needed to make at least one valid pair (a, b) exist, where a and b satisfy the problem condition. If it is not possible, returns -1. >>> min_operations_to_create_valid_pair([1, 2, 3, 4], [2, 3]) == 0 >>> min_operations_to_create_valid_pair([4, 1, 2, 3], [2, 3]) == 1 >>> min_operations_to_create_valid_pair([1, 2, 3, 4], [5, 6]) == -1 >>> min_operations_to_create_valid_pair([1, 1, 1, 1], [2, 2]) == -1 >>> min_operations_to_create_valid_pair([1, 2], [1]) == -1 >>> min_operations_to_create_valid_pair([], []) == -1 >>> min_operations_to_create_valid_pair([1, 2, 3], [4, 5, 6]) == -1 >>> min_operations_to_create_valid_pair_and_count(nums1: List[int], nums2: List[int]): Returns a tuple of the minimum number of operations needed to make at least one valid pair (a, b) exist, where a and b satisfy the problem condition, and such pair (a, b). If it is not possible, returns -1 and None. >>> find_valid_pair_and_count([1, 2, 3, 4], [2, 3]) (0, (2, 3)) >>> find_valid_pair_and_count([4, 1, 2, 3], [2, 3]) (1, (2, 3)) >>> find_valid_pair_and_count([1, 2, 3, 4], [5, 6]) (-1, None) >>> find_valid_pair_and_count([1, 1, 1, 1], [2, 2]) (-1, None) >>> find_valid_pair_and_count([1, 2], [1]) (-1, None) >>> find_valid_pair_and_count([], []) (-1, None) >>> find_valid_pair_and_count([1, 2, 3], [4, 5, 6]) (-1, None) >>> find_valid_pair_and_count([1, 2, 3, 4, 5, 6], [4, 5]) (2, (4, 5)) >>> find_valid_pair_and_count([1, 2, 3, 4, 5, 6, 7], [5, 6]) (3, (5, 6))","solution":"def min_operations_to_create_valid_pair(nums1, nums2): Returns the minimum number of operations needed to make at least one valid pair (a, b) exist, where a and b satisfy the problem condition. If it is not possible, returns -1. n1, n2 = len(nums1), len(nums2) # It's impossible if nums1 length is less than or equal to nums2, because we can't find a valid \\"i\\" if n1 <= n2: return -1 # Check cyclic shifts on nums1 for k in range(n1): for i in range(min(n1 - k - 1, n2)): if nums1[k + i + 1] == nums2[i]: return k return -1"},{"question":"def maxProfit(prices: List[int], fee: int) -> int: Calculate the maximum profit achievable with a stock prices array and transaction fee. >>> maxProfit([1, 3, 2, 8, 4, 9], 2) 8 >>> maxProfit([5, 4, 3, 2, 1], 1) 0 pass import pytest from solution import maxProfit def test_no_prices(): assert maxProfit([], 2) == 0 def test_single_price(): assert maxProfit([5], 2) == 0 def test_multiple_prices_with_fee(): assert maxProfit([1, 3, 2, 8, 4, 9], 2) == 8 def test_multiple_prices_with_higher_fee(): assert maxProfit([1, 3, 7, 5, 10, 3], 3) == 6 def test_all_increasing_prices(): assert maxProfit([1, 2, 3, 4, 5], 1) == 3 def test_all_decreasing_prices(): assert maxProfit([5, 4, 3, 2, 1], 1) == 0 def test_no_transaction_due_to_fee(): assert maxProfit([1, 3, 2, 8, 4, 9], 10) == 0 def test_fluctuating_prices(): assert maxProfit([3, 2, 6, 5, 0, 3], 2) == 3","solution":"def maxProfit(prices, fee): n = len(prices) if not prices or n < 2: return 0 cash, hold = 0, -prices[0] for price in prices: # Store the previous cash value prev_cash = cash # Update cash to either keep it as is, # or sell the stock we're holding (paying the fee) cash = max(cash, hold + price - fee) # Update hold to either keep it as is, # or buy the stock with the current price (spending cash) hold = max(hold, prev_cash - price) return cash"},{"question":"def max_operations_to_limit_heights(heights: List[int], maxHeight: int) -> int: Returns the maximum number of operations required to make all building heights not exceed maxHeight. Parameters: heights (list of int): A list of integers representing heights of buildings. maxHeight (int): The maximum height a building is allowed to be. Returns: int: The maximum number of operations required. >>> max_operations_to_limit_heights([5, 8, 6, 4], 5) 4 >>> max_operations_to_limit_heights([1, 2, 3, 4], 5) 0 >>> max_operations_to_limit_heights([10, 15, 12], 5) 22 >>> max_operations_to_limit_heights([], 5) 0 >>> max_operations_to_limit_heights([2, 5, 5, 1], 5) 0 >>> max_operations_to_limit_heights([0, -1, 5, 8], 5) 3","solution":"def max_operations_to_limit_heights(heights, maxHeight): Returns the maximum number of operations required to make all building heights not exceed maxHeight. Parameters: heights (list of int): A list of integers representing heights of buildings. maxHeight (int): The maximum height a building is allowed to be. Returns: int: The maximum number of operations required. operations = 0 for height in heights: if height > maxHeight: operations += (height - maxHeight) return operations"},{"question":"class TwoSum: Initialize your data structure here. def __init__(self): pass def add(self, number: int) -> None: Add the number to an internal data structure. def find(self, value: int) -> bool: Find if there exists any pair of integers which sum is equal to the value. # Unit Tests def test_add_and_find_true(): two_sum = TwoSum() two_sum.add(1) two_sum.add(3) two_sum.add(5) assert two_sum.find(4) == True # 1 + 3 assert two_sum.find(8) == True # 3 + 5 def test_add_and_find_false(): two_sum = TwoSum() two_sum.add(1) two_sum.add(3) two_sum.add(5) assert two_sum.find(7) == False # No pairs sum to 7 def test_add_duplicates_and_find_true(): two_sum = TwoSum() two_sum.add(1) two_sum.add(1) assert two_sum.find(2) == True # 1 + 1 def test_add_duplicates_and_find_false(): two_sum = TwoSum() two_sum.add(1) two_sum.add(1) assert two_sum.find(3) == False # Even though there are duplicates, they're not the correct sum def test_find_on_empty(): two_sum = TwoSum() assert two_sum.find(1) == False # Can't find any pairs in an empty data structure def test_find_with_large_numbers(): two_sum = TwoSum() two_sum.add(1000000) two_sum.add(500000) assert two_sum.find(1500000) == True # 1000000 + 500000 assert two_sum.find(2000000) == False # No pairs sum to 2000000","solution":"class TwoSum: def __init__(self): Initialize your data structure here. The data structure will use a dictionary to keep track of the numbers and their frequencies. self.num_counts = {} def add(self, number): Add the number to the data structure. if number in self.num_counts: self.num_counts[number] += 1 else: self.num_counts[number] = 1 def find(self, value): Find if there exists any pair of integers which sum is equal to the value. for num in self.num_counts: complement = value - num if complement in self.num_counts: if complement != num or self.num_counts[num] > 1: return True return False"},{"question":"def maxProfitWithinKDays(numbers: List[int], k: int) -> int: Returns the maximum profit that can be achieved from at most one transaction within k days. If no profit can be achieved, returns 0. >>> maxProfitWithinKDays([7, 1, 5, 3, 6, 4], 6) 5 >>> maxProfitWithinKDays([7, 6, 4, 3, 1], 5) 0 >>> maxProfitWithinKDays([1, 2, 3, 4, 5], 5) 4 >>> maxProfitWithinKDays([1, 10, 7, 5, 11, 3], 6) 10 >>> maxProfitWithinKDays([], 0) 0 >>> maxProfitWithinKDays([3], 1) 0 >>> maxProfitWithinKDays([1, 2], 2) 1 >>> maxProfitWithinKDays([10, 9, 8, 1], 4) 0 >>> maxProfitWithinKDays([5, 5, 5, 5], 4) 0 >>> maxProfitWithinKDays([2, 4, 1], 10) 2 >>> maxProfitWithinKDays([3, 3, 5, 0, 0, 3, 1, 4], 8) 4 >>> maxProfitWithinKDays([7, 1, 5, 3, 6, 4, 8], 7) 7","solution":"def maxProfitWithinKDays(numbers, k): Returns the maximum profit that can be achieved from at most one transaction within k days. If no profit can be achieved, returns 0. if not numbers or len(numbers) < 2: return 0 min_price = float('inf') max_profit = 0 for price in numbers: min_price = min(min_price, price) max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"def correct_id_numbers(id_numbers): Returns a list of corrected ID numbers. Each ID number is increased by the sum of its digits. Parameters: id_numbers (list of int): A list of original ID numbers. Returns: list of int: A list of corrected ID numbers. pass def test_correct_id_numbers(): assert correct_id_numbers([456]) == [471] assert correct_id_numbers([123]) == [129] assert correct_id_numbers([0]) == [0] assert correct_id_numbers([1, 25, 678]) == [2, 32, 699] assert correct_id_numbers([111, 222, 333]) == [114, 228, 342] assert correct_id_numbers([9999, 54321, 12345]) == [10035, 54336, 12360] def test_correct_id_numbers_single_digit(): assert correct_id_numbers([5]) == [10] assert correct_id_numbers([9]) == [18] def test_correct_id_numbers_empty_list(): assert correct_id_numbers([]) == [] def test_correct_id_numbers_no_change(): assert correct_id_numbers([0, 1, 2]) == [0, 2, 4]","solution":"def correct_id_numbers(id_numbers): Returns a list of corrected ID numbers. Each ID number is increased by the sum of its digits. Parameters: id_numbers (list of int): A list of original ID numbers. Returns: list of int: A list of corrected ID numbers. def sum_of_digits(n): return sum(int(digit) for digit in str(n)) corrected_numbers = [ id_number + sum_of_digits(id_number) for id_number in id_numbers ] return corrected_numbers"},{"question":"from typing import List def largestOfRowMin(mat: List[List[int]]) -> int: Returns the largest value among the smallest values in each row of the matrix. :param mat: List[List[int]] - Input matrix of non-negative integers :return: int - Largest value among the smallest values of each row pass # Test cases def test_largestOfRowMin_normal_case(): mat = [[3, 7, 8], [9, 2, 5], [1, 4, 6]] assert largestOfRowMin(mat) == 3 def test_largestOfRowMin_single_element_rows(): mat = [[10], [6], [8], [7]] assert largestOfRowMin(mat) == 10 def test_largestOfRowMin_identical_elements(): mat = [[5, 5, 5], [5, 5, 5], [5, 5, 5]] assert largestOfRowMin(mat) == 5 def test_largestOfRowMin_single_row(): mat = [[3, 7, 1, 2]] assert largestOfRowMin(mat) == 1 def test_largestOfRowMin_single_column(): mat = [[10], [2], [3], [8], [4]] assert largestOfRowMin(mat) == 10 def test_largestOfRowMin_matrix_with_zero(): mat = [[0, 1, 2], [3, 0, 4], [6, 5, 0]] assert largestOfRowMin(mat) == 0 def test_largestOfRowMin_empty_matrix(): mat = [] assert largestOfRowMin(mat) == float('-inf') def test_largestOfRowMin_empty_rows(): mat = [[], [], []] assert largestOfRowMin(mat) == float('-inf')","solution":"from typing import List def largestOfRowMin(mat: List[List[int]]) -> int: Returns the largest value among the smallest values in each row of the matrix. :param mat: List[List[int]] - Input matrix of non-negative integers :return: int - Largest value among the smallest values of each row if not mat or not mat[0]: return float('-inf') # Define behavior for empty matrix as returning negative infinity row_mins = [min(row) for row in mat] return max(row_mins)"},{"question":"def min_total_travel_distance(grid: List[List[int]]) -> int: Returns the minimum total travel distance from the plaza to all buildings or -1 if no empty plot is available. >>> min_total_travel_distance([ ... [1, 0, 1], ... [0, 0, 0], ... [1, 0, 1] ... ]) == 8 >>> min_total_travel_distance([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == -1 >>> min_total_travel_distance([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == -1 >>> min_total_travel_distance([ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> min_total_travel_distance([ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ]) == 8 pass","solution":"def min_total_travel_distance(grid): Returns the minimum total travel distance from the plaza to all buildings or -1 if no empty plot is available. if not grid: return -1 rows = [] cols = [] for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: rows.append(i) cols.append(j) if not rows: return -1 # No buildings to determine travel distance from if len(rows) == len(grid) * len(grid[0]): return -1 # No empty plot to build plaza rows.sort() cols.sort() median_row = rows[len(rows) // 2] median_col = cols[len(cols) // 2] min_distance = sum(abs(row - median_row) for row in rows) + sum(abs(col - median_col) for col in cols) return min_distance"},{"question":"def max_non_overlapping_events(events: list[list[int]]) -> int: Returns the maximum number of non-overlapping events. Parameters: events (list[list[int]]): A list of events where each event is represented by [startTime, endTime] Returns: int: The maximum number of non-overlapping events. Examples: >>> max_non_overlapping_events([]) 0 >>> max_non_overlapping_events([[0, 10]]) 1 >>> max_non_overlapping_events([[0, 10], [15, 25], [30, 40]]) 3 >>> max_non_overlapping_events([[0, 10], [5, 15], [10, 20]]) 2","solution":"def max_non_overlapping_events(events): Returns the maximum number of non-overlapping events. Parameters: events (list[list[int]]): A list of events where each event is represented by [startTime, endTime] Returns: int: The maximum number of non-overlapping events. # Sort events based on their end times events.sort(key=lambda x: x[1]) # Initialize counters max_events = 0 last_end_time = 0 # Loop through sorted events and select non-overlapping events for event in events: if event[0] >= last_end_time: max_events += 1 last_end_time = event[1] return max_events"},{"question":"def can_schedule(bookings, newBooking): Determines if a new booking can be scheduled without conflicting with existing bookings. Parameters: bookings (list of tuples): A list of tuples where each tuple contains two integers representing the start and end time of existing bookings. newBooking (tuple): A tuple containing two integers representing the start and end time of the new booking. Returns: bool: True if the new booking can be scheduled without conflicting, False otherwise. def test_can_schedule_no_conflict(): bookings = [(8, 10), (12, 14), (15, 18)] newBooking = (10, 12) assert can_schedule(bookings, newBooking) == True def test_can_schedule_conflict_start(): bookings = [(8, 10), (12, 14), (15, 18)] newBooking = (9, 11) assert can_schedule(bookings, newBooking) == False def test_can_schedule_conflict_end(): bookings = [(8, 10), (12, 14), (15, 18)] newBooking = (14, 16) assert can_schedule(bookings, newBooking) == False def test_can_schedule_conflict_full_overlap(): bookings = [(8, 10), (12, 14), (15, 18)] newBooking = (9, 16) assert can_schedule(bookings, newBooking) == False def test_can_schedule_exact_same_time(): bookings = [(8, 10), (12, 14), (15, 18)] newBooking = (12, 14) assert can_schedule(bookings, newBooking) == False def test_can_schedule_with_no_existing_bookings(): bookings = [] newBooking = (10, 12) assert can_schedule(bookings, newBooking) == True","solution":"def can_schedule(bookings, newBooking): Determines if a new booking can be scheduled without conflicting with existing bookings. Parameters: bookings (list of tuples): A list of tuples where each tuple contains two integers representing the start and end time of existing bookings. newBooking (tuple): A tuple containing two integers representing the start and end time of the new booking. Returns: bool: True if the new booking can be scheduled without conflicting, False otherwise. new_start, new_end = newBooking for start, end in bookings: if new_start < end and start < new_end: return False return True"},{"question":"def find_missing_number(nums: list[int]) -> int: Finds and returns the missing number in an array containing unique integers from 1 to n with one missing number. >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) == 6 >>> find_missing_number([2, 3, 4, 5, 6]) == 1 >>> find_missing_number([1, 2, 3, 4, 5, 6, 7]) == 8 >>> find_missing_number([2]) == 1 >>> find_missing_number(list(range(1, 10001))[:4999] + list(range(1, 10001))[5000:]) == 5000 >>> find_missing_number([1, 2, 3, 4, 5]) != 0","solution":"def find_missing_number(nums): Finds and returns the missing number in an array containing unique integers from 1 to n with one missing number. Parameters: nums: list of int Returns: int: the missing number n = len(nums) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) missing_number = expected_sum - actual_sum return missing_number"},{"question":"def final_prices(prices): Returns the final prices of the product after applying the discount policy. >>> final_prices([8, 4, 6, 2, 3]) [4, 2, 4, 2, 3] >>> final_prices([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> final_prices([5, 5, 5, 5, 5]) [5, 5, 5, 5, 5] >>> final_prices([5, 4, 3, 2, 1]) [1, 1, 1, 1, 1] >>> final_prices([10, 1, 10, 1, 10]) [9, 1, 9, 1, 10] >>> final_prices([5]) [5] >>> final_prices([8, 2]) [6, 2] >>> final_prices([2, 8]) [2, 8]","solution":"def final_prices(prices): This function returns the final prices after applying the discount policy. n = len(prices) final_prices = prices[:] for i in range(n): for j in range(i + 1, n): if prices[j] < prices[i]: final_prices[i] -= prices[j] break return final_prices"},{"question":"def max_viewing_platform(heights): Returns the maximum size of any viewing platform that can be formed from the given building heights. Args: heights (List[int]): A list of integers representing the heights of the buildings. Returns: int: The maximum size of any viewing platform. Examples: >>> max_viewing_platform([5]) 1 >>> max_viewing_platform([5, 10]) 2 >>> max_viewing_platform([10, 5]) 1 >>> max_viewing_platform([10, 9, 8, 7]) 1 >>> max_viewing_platform([1, 2, 3, 4]) 4 >>> max_viewing_platform([5, 10, 7, 6, 11, 12]) 3 >>> max_viewing_platform([10, 1, 3, 7, 6, 5]) 3 >>> max_viewing_platform([1, 3, 2, 5, 4, 6]) 2 >>> max_viewing_platform([5, 5, 5, 5, 5]) 5","solution":"def max_viewing_platform(heights): Returns the maximum size of any viewing platform that can be formed. n = len(heights) if n == 0: return 0 max_platform_size = 1 for start in range(n): current_min = heights[start] current_platform_size = 1 for end in range(start + 1, n): if heights[end] >= current_min: current_platform_size += 1 max_platform_size = max(max_platform_size, current_platform_size) current_min = heights[end] else: break return max_platform_size"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumOfTree(root): Returns the sum of all values in the binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> sumOfTree(root) 15","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumOfTree(root): Returns the sum of all values in the binary tree. if not root: return 0 return root.val + sumOfTree(root.left) + sumOfTree(root.right)"},{"question":"def find_substring_indices(s: str, sub: str) -> List[int]: Returns a list of starting indices in the string \`s\` where the string \`sub\` is a contiguous substring. Parameters: s (str): The main string in which to search for the substring. sub (str): The substring to search for in the main string. Returns: list: A list of starting indices where the substring \`sub\` occurs in the string \`s\`. Examples: >>> find_substring_indices(\\"ababcabc\\", \\"abc\\") [2, 5] >>> find_substring_indices(\\"aaaaa\\", \\"aa\\") [0, 1, 2, 3] >>> find_substring_indices(\\"abcd\\", \\"e\\") [] >>> find_substring_indices(\\"hello\\", \\"ll\\") [2] >>> find_substring_indices(\\"mississippi\\", \\"issi\\") [1, 4] >>> find_substring_indices(\\"banana\\", \\"ana\\") [1, 3] >>> find_substring_indices(\\"abcdef\\", \\"abcdef\\") [0] >>> find_substring_indices(\\"abcdef\\", \\"gh\\") []","solution":"def find_substring_indices(s, sub): Returns a list of starting indices in the string \`s\` where the string \`sub\` is a contiguous substring. Parameters: s (str): the main string in which to search for the substring sub (str): the substring to search for in the main string Returns: list: a list of starting indices where the substring \`sub\` occurs in the string \`s\` # The length of the main string and the substring n, m = len(s), len(sub) result = [] # Use the sliding window technique and direct comparison for i in range(n - m + 1): if s[i:i + m] == sub: result.append(i) return result"},{"question":"def most_engaged_users(sessions): Analyzes the reading habits of users and identify the most engaged user for each book. Args: sessions (List[List[int]]): A 2D integer array where sessions[i] = [userID, bookID, duration]. Returns: List[List[int]]: A 2D integer array where each entry is in the form [bookID, userID, totalDuration]. >>> most_engaged_users([[1, 101, 30]]) [[101, 1, 30]] >>> most_engaged_users([[1, 101, 30], [2, 101, 45], [1, 101, 15]]) [[101, 1, 45]] >>> most_engaged_users([[1, 101, 30], [2, 101, 45], [1, 101, 15], [3, 102, 60], [2, 102, 60], [3, 101, 30]]) [[101, 1, 45], [102, 2, 60]] >>> most_engaged_users([[1, 101, 30], [2, 101, 30]]) [[101, 1, 30]] >>> most_engaged_users([[3, 200, 10], [1, 100, 20], [2, 100, 20], [1, 200, 50]]) [[100, 1, 20], [200, 1, 50]]","solution":"def most_engaged_users(sessions): from collections import defaultdict # Dictionary to store total duration per user per book book_user_duration = defaultdict(lambda: defaultdict(int)) for session in sessions: userID, bookID, duration = session book_user_duration[bookID][userID] += duration result = [] for bookID in sorted(book_user_duration.keys()): most_engaged_user = min(book_user_duration[bookID].items(), key=lambda x: (-x[1], x[0])) result.append([bookID, most_engaged_user[0], most_engaged_user[1]]) return result"},{"question":"class WordDictionary: You are given a list of strings \`words\` representing a dictionary, where each string consists of lowercase English letters. Implement a data structure that supports the following two operations: void addWord(String word) - Adds a word to the dictionary. boolean search(String word) - Returns \`true\` if the word is in the dictionary, \`false\` if it is not. A word may contain \`'.'\` which can be matched with any letter. Example: wordDictionary = WordDictionary() wordDictionary.addWord(\\"bad\\") wordDictionary.addWord(\\"dad\\") wordDictionary.addWord(\\"mad\\") wordDictionary.search(\\"pad\\") # return False wordDictionary.search(\\"bad\\") # return True wordDictionary.search(\\".ad\\") # return True wordDictionary.search(\\"b..\\") # return True def __init__(self): Initialize the object. def addWord(self, word: str) -> None: Adds a word to the dictionary. def search(self, word: str) -> bool: Returns \`true\` if the word is in the dictionary, \`false\` if it is not. A word may contain \`'.'\` which represents any one letter. # Unit tests def test_add_and_search_word(): wd = WordDictionary() wd.addWord(\\"bad\\") wd.addWord(\\"dad\\") wd.addWord(\\"mad\\") assert wd.search(\\"pad\\") == False assert wd.search(\\"bad\\") == True assert wd.search(\\".ad\\") == True assert wd.search(\\"b..\\") == True def test_search_without_adding(): wd = WordDictionary() assert wd.search(\\"bad\\") == False assert wd.search(\\"..d\\") == False def test_search_with_only_dots(): wd = WordDictionary() wd.addWord(\\"hello\\") wd.addWord(\\"world\\") assert wd.search(\\".....\\") == True assert wd.search(\\"....\\") == False assert wd.search(\\".....s\\") == False def test_search_with_mixed_words(): wd = WordDictionary() wd.addWord(\\"cat\\") wd.addWord(\\"car\\") wd.addWord(\\"cart\\") assert wd.search(\\"ca.\\") == True assert wd.search(\\"na.\\") == False assert wd.search(\\"c.t\\") == True assert wd.search(\\"ca..\\") == True","solution":"class WordDictionary: def __init__(self): Initialize the WordDictionary object. self.words = [] def addWord(self, word): Adds a word into the data structure. :param word: str self.words.append(word) def search(self, word): Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. :param word: str :return: bool def is_match(word, pattern): if len(word) != len(pattern): return False for w, p in zip(word, pattern): if p != '.' and w != p: return False return True for w in self.words: if is_match(w, word): return True return False"},{"question":"from typing import List def is_path_exists(grid: List[List[int]], startX: int, startY: int, endX: int, endY: int) -> bool: Determine if there is a valid path for the pawn to move from (startX, startY) to (endX, endY) in the grid. The pawn can only move up, down, left, or right into open cells (cells with 1). Args: grid (List[List[int]]): The grid representing the game board. startX (int): The starting x-coordinate. startY (int): The starting y-coordinate. endX (int): The ending x-coordinate. endY (int): The ending y-coordinate. Returns: bool: True if there is a path, False otherwise. Example: >>> is_path_exists([[1, 0, 0, 0], [1, 1, 1, 1], [0, 1, 0, 0], [1, 1, 1, 1]], 0, 0, 3, 3) True >>> is_path_exists([[1, 0, 0, 0], [1, 1, 0, 1], [0, 1, 0, 0], [1, 1, 0, 1]], 0, 1, 3, 3) False","solution":"def is_path_exists(grid, startX, startY, endX, endY): Function to determine if a path exists in the grid from (startX, startY) to (endX, endY). if grid[startX][startY] == 0 or grid[endX][endY] == 0: return False rows = len(grid) cols = len(grid[0]) def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and grid[x][y] == 1 def dfs(x, y): if x == endX and y == endY: return True grid[x][y] = 2 # mark as visited for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if is_valid(nx, ny): if dfs(nx, ny): return True return False return dfs(startX, startY)"},{"question":"from typing import List def evaluateSentiment(review: str, positiveWords: List[str], negativeWords: List[str]) -> str: Evaluates the sentiment of a customer review based on the frequency of positive and negative words. >>> evaluateSentiment(\\"The product is good and amazing\\", [\\"good\\", \\"great\\", \\"fantastic\\", \\"amazing\\"], [\\"bad\\", \\"terrible\\", \\"awful\\", \\"horrible\\"]) \\"positive\\" >>> evaluateSentiment(\\"The experience was terrible and awful\\", [\\"good\\", \\"great\\", \\"fantastic\\", \\"amazing\\"], [\\"bad\\", \\"terrible\\", \\"awful\\", \\"horrible\\"]) \\"negative\\" >>> evaluateSentiment(\\"The movie was good but the ending was terrible\\", [\\"good\\", \\"great\\", \\"fantastic\\", \\"amazing\\"], [\\"bad\\", \\"terrible\\", \\"awful\\", \\"horrible\\"]) \\"neutral\\" >>> evaluateSentiment(\\"The service was okay and acceptable\\", [\\"good\\", \\"great\\", \\"fantastic\\", \\"amazing\\"], [\\"bad\\", \\"terrible\\", \\"awful\\", \\"horrible\\"]) \\"neutral\\" >>> evaluateSentiment(\\"The meal was good but service was terrible\\", [\\"Good\\", \\"Great\\", \\"Fantastic\\", \\"Amazing\\"], [\\"Bad\\", \\"Terrible\\", \\"Awful\\", \\"Horrible\\"]) \\"neutral\\"","solution":"from typing import List def evaluateSentiment(review: str, positiveWords: List[str], negativeWords: List[str]) -> str: Evaluates the sentiment of a customer review based on the frequency of positive and negative words. Args: review (str): The customer review as a string. positiveWords (List[str]): List of words indicating positive sentiment. negativeWords (List[str]): List of words indicating negative sentiment. Returns: str: \\"positive\\" if positive words outnumber negative words, \\"negative\\" if negative words outnumber positive words, \\"neutral\\" if counts are equal. # Tokenize the review by splitting it into words words = review.split() # Count occurrences of positive and negative words pos_count = sum(1 for word in words if word in positiveWords) neg_count = sum(1 for word in words if word in negativeWords) # Determine the sentiment based on counts if pos_count > neg_count: return \\"positive\\" elif neg_count > pos_count: return \\"negative\\" else: return \\"neutral\\""},{"question":"def min_operations_to_unify_string(s: str) -> int: Returns the minimum number of operations needed to convert s into a string where all characters are the same. >>> min_operations_to_unify_string(\\"aaaa\\") == 0 >>> min_operations_to_unify_string(\\"aab\\") == 1 >>> min_operations_to_unify_string(\\"aabac\\") == 2 >>> min_operations_to_unify_string(\\"a\\") == 0 >>> min_operations_to_unify_string(\\"a\\" * 1000 + \\"b\\" * 500 + \\"c\\" * 500) == 1000","solution":"def min_operations_to_unify_string(s): Returns the minimum number of operations needed to convert s into a string where all characters are the same. from collections import Counter # Calculate the frequency of each character in the string char_frequency = Counter(s) # Find the character with the maximum frequency max_freq = max(char_frequency.values()) # Minimum operations is equal to the total length of the string # minus the frequency of the most frequent character return len(s) - max_freq"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: An iterator over a binary search tree (BST) that returns the nodes' values in ascending order. def __init__(self, root: TreeNode): Initializes an object of the BSTIterator class. The root of the BST is provided. Parameters: root (TreeNode): The root node of the balanced binary search tree. # Initialize the stack and push the leftmost path starting from the root for the first call self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): Helper function to traverse the leftmost path starting from the root and push all nodes onto the stack. Parameters: root (TreeNode): The current node in the traversal. while root: self.stack.append(root) root = root.left def next(self) -> int: Returns the next smallest number in the BST. Returns: int: The next smallest value in the BST. def hasNext(self) -> bool: Returns True if there exists a next smallest number in the BST; otherwise False. Returns: bool: True if there are more nodes to return in ascending order, False otherwise. # Unit Test def test_BSTIterator(): # Construct the BST: # 7 # / # 3 15 # / # 9 20 root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) # Initialize the iterator iterator = BSTIterator(root) # Test sequence of next() and hasNext() assert iterator.hasNext() == True assert iterator.next() == 3 assert iterator.hasNext() == True assert iterator.next() == 7 assert iterator.hasNext() == True assert iterator.next() == 9 assert iterator.hasNext() == True assert iterator.next() == 15 assert iterator.hasNext() == True assert iterator.next() == 20 assert iterator.hasNext() == False def test_empty_BSTIterator(): # Construct an empty BST root = None # Initialize the iterator iterator = BSTIterator(root) # Test hasNext() and next() assert iterator.hasNext() == False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): Initializes an object of the BSTIterator class. The root of the BST is provided. self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): Helper function to traverse the leftmost path starting from the root. while root: self.stack.append(root) root = root.left def next(self) -> int: Returns the next smallest number in the BST. topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val def hasNext(self) -> bool: Returns True if there exists a next smallest number in the BST; otherwise False. return len(self.stack) > 0"},{"question":"def print_directory_structure(directory, level=0): Prints the directory structure in a tree format with appropriate indentation. :param directory: The directory structure as a nested dictionary. :param level: The current level of recursion (used for indentation). Default is 0. Example usage: >>> directory = { >>> \\"root\\": { >>> \\"folder1\\": { >>> \\"subfolder1\\": None, >>> \\"subfolder2\\": { >>> \\"subsubfolder1\\": None >>> } >>> }, >>> \\"folder2\\": { >>> \\"subfolder3\\": None >>> }, >>> \\"folder3\\": None >>> } >>> } >>> print_directory_structure(directory) root folder1 subfolder1 subfolder2 subsubfolder1 folder2 subfolder3 folder3 import pytest from io import StringIO from contextlib import redirect_stdout def test_print_directory_empty(): directory = {} with StringIO() as buf, redirect_stdout(buf): print_directory_structure(directory) output = buf.getvalue() assert output == \\"\\" def test_print_directory_single_folder(): directory = {\\"root\\": None} with StringIO() as buf, redirect_stdout(buf): print_directory_structure(directory) output = buf.getvalue() assert output == \\"rootn\\" def test_print_directory_nested_folders(): directory = { \\"root\\": { \\"folder1\\": { \\"subfolder1\\": None, \\"subfolder2\\": { \\"subsubfolder1\\": None } }, \\"folder2\\": { \\"subfolder3\\": None }, \\"folder3\\": None } } expected_output = \\"rootn folder1n subfolder1n subfolder2n subsubfolder1n folder2n subfolder3n folder3n\\" with StringIO() as buf, redirect_stdout(buf): print_directory_structure(directory) output = buf.getvalue() assert output == expected_output def test_print_directory_multiple_roots(): directory = { \\"root1\\": { \\"folder1\\": None }, \\"root2\\": { \\"folder2\\": { \\"subfolder1\\": None } } } expected_output = \\"root1n folder1nroot2n folder2n subfolder1n\\" with StringIO() as buf, redirect_stdout(buf): print_directory_structure(directory) output = buf.getvalue() assert output == expected_output","solution":"def print_directory_structure(directory, level=0): Prints the directory structure in a tree format with appropriate indentation. :param directory: The directory structure as a nested dictionary. :param level: The current level of recursion (used for indentation). Default is 0. if directory is None: return for folder in directory: print(' ' * level + folder) print_directory_structure(directory[folder], level + 1) # Example usage: # directory = { # \\"root\\": { # \\"folder1\\": { # \\"subfolder1\\": None, # \\"subfolder2\\": { # \\"subsubfolder1\\": None # } # }, # \\"folder2\\": { # \\"subfolder3\\": None # }, # \\"folder3\\": None # } # } # print_directory_structure(directory)"},{"question":"def evaluate_expression(expression: str) -> int: Parses and evaluates a given mathematical expression string. Args: expression (str): A string containing a mathematical expression. Returns: int: The result of evaluating the expression. Examples: >>> evaluate_expression(\\"2 + 3\\") 5 >>> evaluate_expression(\\"2 - 3 * 4\\") -10 >>> evaluate_expression(\\"(2 + 3) * 4\\") 20 >>> evaluate_expression(\\"20 / 3\\") 6 >>> evaluate_expression(\\"3 + 5 / 2\\") 5 >>> evaluate_expression(\\"10 + (2 + 3) * (2 - (1 + 1))\\") 10 >>> evaluate_expression(\\" 7 - 4 + 2* ( 3 - 1 ) \\") 7 >>> evaluate_expression(\\"8\\") 8","solution":"def evaluate_expression(expression): Parses and evaluates a given mathematical expression string. Args: expression (str): A string containing a mathematical expression. Returns: int: The result of evaluating the expression. def operate(op, second, first): if op == '+': return first + second elif op == '-': return first - second elif op == '*': return first * second elif op == '/': return int(first / second) # integer division truncating towards zero def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def apply_operations(operators, values): while operators and operators[-1] in ('+', '-', '*', '/'): values.append(operate(operators.pop(), values.pop(), values.pop())) operators = [] values = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue if expression[i] == '(': operators.append(expression[i]) elif expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 values.append(num) i -= 1 elif expression[i] == ')': while operators and operators[-1] != '(': apply_operations(operators, values) operators.pop() else: # operator while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operations(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operations(operators, values) return values[0]"},{"question":"def sort_names(names): Sorts a list of full names lexicographically by last name. If last names are the same, then by first name, and if first names are the same, then by middle name. >>> sort_names([\\"John Doe\\"]) ['John Doe'] >>> sort_names([\\"Jane Austen\\", \\"John Doe\\", \\"Emily Bronte\\"]) ['Jane Austen', 'Emily Bronte', 'John Doe'] >>> sort_names([\\"John Smith\\", \\"Jane Smith\\", \\"Emily Smith\\"]) ['Emily Smith', 'Jane Smith', 'John Smith'] >>> sort_names([\\"John Smith John\\", \\"John Smith Alan\\", \\"John Smith Brian\\"]) ['John Smith Alan', 'John Smith Brian', 'John Smith John'] >>> sort_names([\\"John A Smith\\", \\"John B Smith\\", \\"John C Smith\\"]) ['John A Smith', 'John B Smith', 'John C Smith'] >>> sort_names([\\"Jane Austen\\", \\"Emily Bronte\\", \\"John Doe\\", \\"John Smith\\", \\"Jane Smith\\", \\"Emily Smith\\"]) ['Jane Austen', 'Emily Bronte', 'John Doe', 'Emily Smith', 'Jane Smith', 'John Smith']","solution":"def sort_names(names): Sorts a list of full names lexicographically by last name. If last names are the same, then by first name, and if first names are the same, then by middle name. return sorted(names, key=lambda name: (name.split()[-1], name.split()[0], ' '.join(name.split()[1:-1])))"},{"question":"def apply_queries_to_grid(a: int, b: int, queries: List[List[int]]) -> List[List[int]]: Apply a list of queries to a grid of dimension a by b. Each query in queries is a list of the form [xi, yi, vi], indicating that you should increase each element of the sub-grid whose top-left corner is at (0, 0) and bottom-right corner is at (xi, yi) by vi. Parameters: a (int): Number of rows of the grid. b (int): Number of columns of the grid. queries (list of list of ints): List of queries. Returns: list of list of ints: The final grid after applying all queries. >>> apply_queries_to_grid(3, 3, [[1, 1, 2], [2, 2, 3]]) [[5, 5, 3], [5, 5, 3], [3, 3, 3]] >>> apply_queries_to_grid(4, 4, [[1, 1, 2], [0, 0, 1], [3, 3, 5]]) [[8, 7, 5, 5], [7, 7, 5, 5], [5, 5, 5, 5], [5, 5, 5, 5]]","solution":"def apply_queries_to_grid(a, b, queries): Apply a list of queries to a grid of dimension a by b. Parameters: a (int): Number of rows of the grid. b (int): Number of columns of the grid. queries (list of list of ints): List of queries where each query is [xi, yi, vi]. Returns: list of list of ints: The final grid after applying all queries. grid = [[0 for _ in range(b)] for _ in range(a)] for xi, yi, vi in queries: for row in range(xi + 1): for col in range(yi + 1): grid[row][col] += vi return grid"},{"question":"class InventoryManager: A class to manage an inventory of items with functionalities to add items, update item prices, and calculate total value of inventory. def __init__(self): Initializes the InventoryManager object. def addItem(self, name: str, price: float): Adds an item with the specified name and price to the inventory. If the item already exists, its price is updated to the new price. :param name: Name of the item :param price: Price of the item def getTotalValue(self) -> float: Returns the total value of all items in the inventory. :return: Total value of all items # Unit tests def test_add_item(): manager = InventoryManager() manager.addItem('item1', 10.0) assert manager.inventory['item1'] == 10.0 def test_update_item_price(): manager = InventoryManager() manager.addItem('item1', 10.0) manager.addItem('item1', 15.0) assert manager.inventory['item1'] == 15.0 def test_get_total_value(): manager = InventoryManager() manager.addItem('item1', 10.0) manager.addItem('item2', 20.0) assert manager.getTotalValue() == 30.0 def test_get_total_value_with_update(): manager = InventoryManager() manager.addItem('item1', 10.0) manager.addItem('item2', 20.0) manager.addItem('item1', 15.0) # Update price of item1 assert manager.getTotalValue() == 35.0","solution":"class InventoryManager: def __init__(self): Initializes the InventoryManager object. self.inventory = {} def addItem(self, name, price): Adds an item with the specified name and price to the inventory. If the item already exists, its price is updated to the new price. :param name: Name of the item :param price: Price of the item self.inventory[name] = price def getTotalValue(self): Returns the total value of all items in the inventory. :return: Total value of all items return sum(self.inventory.values())"},{"question":"def partition_into_contiguous_subarrays(nums: List[int]) -> List[Tuple[int, int]]: Partition the given list into the fewest number of contiguous subarrays such that each subarray contains every number from 1 to the length of that subarray exactly once. Returns a list of tuples containing the starting and ending indices of each subarray in \`nums\`. >>> partition_into_contiguous_subarrays([4, 3, 2, 1, 2, 1, 3, 4]) == [(0, 3), (4, 7)] >>> partition_into_contiguous_subarrays([1]) == [(0, 0)] >>> partition_into_contiguous_subarrays([1, 2, 3, 1, 2, 3, 1, 2, 3]) == [(0, 2), (3, 5), (6, 8)] >>> partition_into_contiguous_subarrays([3, 2, 1, 3, 2, 1, 3, 2, 1]) == [(0, 2), (3, 5), (6, 8)] >>> partition_into_contiguous_subarrays([1, 2, 3, 4, 5, 6, 7, 8, 9]) == [(0, 8)]","solution":"def partition_into_contiguous_subarrays(nums): Partition the given list into the fewest number of contiguous subarrays such that each subarray contains every number from 1 to the length of that subarray exactly once. Returns a list of tuples containing the starting and ending indices of each subarray in \`nums\`. n = len(nums) partitions = [] i = 0 while i < n: # Use a set to keep track of the numbers in the current partition num_set = set() # Mark the start of the current partition start = i while i < n and nums[i] not in num_set: num_set.add(nums[i]) i += 1 # Mark the end of the current partition end = i - 1 partitions.append((start, end)) return partitions"},{"question":"def numDecodings(s: str) -> int: Determine the total number of ways to decode the message. >>> numDecodings(\\"1\\") == 1 >>> numDecodings(\\"2\\") == 1 >>> numDecodings(\\"9\\") == 1 >>> numDecodings(\\"12\\") == 2 >>> numDecodings(\\"26\\") == 2 >>> numDecodings(\\"0\\") == 0 >>> numDecodings(\\"01\\") == 0 >>> numDecodings(\\"126\\") == 3 >>> numDecodings(\\"226\\") == 3 >>> numDecodings(\\"1234\\") == 3 >>> numDecodings(\\"1111111111\\") == 89 >>> numDecodings(\\"10\\") == 1 >>> numDecodings(\\"101\\") == 1 >>> numDecodings(\\"110\\") == 1","solution":"def numDecodings(s): Determine the total number of ways to decode the message. if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 if s[0] != '0' else 0 for i in range(2, n + 1): one_digit = int(s[i-1:i]) two_digits = int(s[i-2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i-1] if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"def max_depth(values): Returns the maximum depth of the binary tree represented by \`values\`. :param values: List[int] :return: int >>> max_depth([]) == 0 >>> max_depth([1]) == 1 >>> max_depth([1, 2, 3]) == 2 >>> values = [1, 2, 3, 4, 5, None, None] >>> max_depth(values) == 3 >>> values = [1, 2, 3, 4, None, None, None, 5] >>> max_depth(values) == 4 >>> values = [1, None, 2, None, None, None, 3] >>> max_depth(values) == 3","solution":"def max_depth(values): Returns the maximum depth of the binary tree represented by \`values\`. :param values: List[int] :return: int if not values: return 0 def depth_helper(index): if index >= len(values) or values[index] is None: return 0 left_depth = depth_helper(2 * index + 1) right_depth = depth_helper(2 * index + 2) return 1 + max(left_depth, right_depth) return depth_helper(0)"},{"question":"def longest_valid_lineup(heights): Returns the length of the longest contiguous subarray that forms a valid lineup. A valid lineup means the subarray is either non-increasing or non-decreasing. >>> longest_valid_lineup([2, 2, 2, 2]) 4 >>> longest_valid_lineup([1, 2, 3, 4, 5]) 5 >>> longest_valid_lineup([5, 4, 3, 2, 1]) 5 >>> longest_valid_lineup([1, 3, 2, 4, 2]) 2 >>> longest_valid_lineup([1, 3, 2, 2, 4, 6, 5, 7]) 4 >>> longest_valid_lineup([]) 0 >>> longest_valid_lineup([10]) 1 >>> longest_valid_lineup([1, 3, 1, 3, 1, 3]) 2","solution":"def longest_valid_lineup(heights): Returns the length of the longest contiguous subarray that forms a valid lineup. A valid lineup means the subarray is either non-increasing or non-decreasing. if not heights: return 0 max_length = 1 current_length_inc = 1 current_length_dec = 1 for i in range(1, len(heights)): if heights[i] >= heights[i - 1]: current_length_inc += 1 else: current_length_inc = 1 if heights[i] <= heights[i - 1]: current_length_dec += 1 else: current_length_dec = 1 max_length = max(max_length, current_length_inc, current_length_dec) return max_length"},{"question":"def rotate_image_90_degrees(matrix): Rotates the given n x n matrix 90 degrees clockwise in-place. :param matrix: List[List[int]], a 2D list representing the image. :return: The same matrix after being rotated 90 degrees clockwise. pass # Test Cases def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_image_90_degrees(matrix) == expected def test_rotate_4x4_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotate_image_90_degrees(matrix) == expected def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] expected = [ [3, 1], [4, 2] ] assert rotate_image_90_degrees(matrix) == expected def test_rotate_1x1_matrix(): matrix = [ [1] ] expected = [ [1] ] assert rotate_image_90_degrees(matrix) == expected def test_rotate_5x5_matrix(): matrix = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] expected = [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ] assert rotate_image_90_degrees(matrix) == expected","solution":"def rotate_image_90_degrees(matrix): Rotates the given n x n matrix 90 degrees clockwise in-place. :param matrix: List[List[int]], a 2D list representing the image. :return: The same matrix after being rotated 90 degrees clockwise. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"def min_subarray_len(nums: List[int], x: int) -> int: Returns the minimum length of a contiguous subarray of which the sum is greater than or equal to x. If no such subarray exists, returns 0. >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 1, 1, 1, 1], 10) 0 >>> min_subarray_len([1, 2, 3, 4], 15) 0 >>> min_subarray_len([1, 2, 3, 4, 10], 10) 1 >>> min_subarray_len([10, 2, 3, 1, 1], 10) 1 >>> min_subarray_len([1, 1, 99], 100) 2 >>> min_subarray_len([1, 2, 3, 4, 5], 15) 5","solution":"def min_subarray_len(nums, x): Returns the minimum length of a contiguous subarray of which the sum is greater than or equal to x. If no such subarray exists, returns 0. n = len(nums) min_length = float('inf') start = 0 current_sum = 0 for end in range(n): current_sum += nums[end] while current_sum >= x: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return 0 if min_length == float('inf') else min_length"},{"question":"def num_islands(board): Returns the number of islands in the given 2D binary matrix. >>> num_islands([ [1, 1, 1, 1, 0], [1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0] ]) == 1 >>> num_islands([ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ]) == 3 >>> num_islands([ [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0] ]) == 0 >>> num_islands([ [1, 1], [1, 1] ]) == 1 >>> num_islands([ [1, 0, 0, 1, 0], [0, 1, 0, 0, 1], [0, 0, 1, 0, 0], [1, 0, 0, 1, 0] ]) == 7 >>> num_islands([]) == 0 >>> num_islands([[0]]) == 0 >>> num_islands([[1]]) == 1","solution":"def num_islands(board): Returns the number of islands in the given 2D binary matrix. if not board: return 0 rows = len(board) cols = len(board[0]) islands_count = 0 def dfs(i, j): if i < 0 or j < 0 or i >= rows or j >= cols or board[i][j] == 0: return board[i][j] = 0 # Mark the land as visited dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) for i in range(rows): for j in range(cols): if board[i][j] == 1: islands_count += 1 dfs(i, j) return islands_count"},{"question":"def lexicographically_smallest_string(s: str) -> str: Returns the lexicographically smallest string that can be obtained by removing any number of characters from the given string \`s\`. >>> lexicographically_smallest_string(\\"\\") \\"\\" >>> lexicographically_smallest_string(\\"abc\\") \\"abc\\" >>> lexicographically_smallest_string(\\"cba\\") \\"abc\\" >>> lexicographically_smallest_string(\\"bbcaac\\") \\"aabbcc\\" >>> lexicographically_smallest_string(\\"a\\") \\"a\\" >>> lexicographically_smallest_string(\\"aaaaa\\") \\"aaaaa\\" >>> lexicographically_smallest_string(\\"thequickbrownfox\\") \\"bcefhiknooqrtuwx\\"","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be obtained by removing any number of characters from the given string \`s\`. if not s: return \\"\\" return \\"\\".join(sorted(s))"},{"question":"from typing import List def split_string(s: str, k: int) -> List[str]: Splits the string \`s\` into \`k\` contiguous substrings such that the difference between the lengths of the longest and the shortest substrings is minimized. Parameters: s (str): The input string. k (int): The number of substrings to split into. Returns: List[str]: The list containing \`k\` substrings or an empty list if not possible. >>> split_string(\\"abcdefghij\\", 3) ['abcd', 'efg', 'hij'] >>> split_string(\\"abcdefghij\\", 4) ['abc', 'def', 'gh', 'ij'] >>> split_string(\\"abcdefgh\\", 4) ['ab', 'cd', 'ef', 'gh'] >>> split_string(\\"abc\\", 5) [] >>> split_string(\\"abcdef\\", 1) ['abcdef'] >>> split_string(\\"abcdef\\", 6) ['a', 'b', 'c', 'd', 'e', 'f'] >>> split_string(\\"a\\"*1000, 10) ['aaaaaaaaaa', 'aaaaaaaaaa', 'aaaaaaaaaa', 'aaaaaaaaaa', 'aaaaaaaaaa', 'aaaaaaaaaa', 'aaaaaaaaaa', 'aaaaaaaaaa', 'aaaaaaaaaa', 'aaaaaaaaaa']","solution":"def split_string(s, k): Splits the string \`s\` into \`k\` contiguous substrings such that the difference between the lengths of the longest and the shortest substrings is minimized. Parameters: s (str): The input string. k (int): The number of substrings to split into. Returns: List[str]: The list containing \`k\` substrings or an empty list if not possible. n = len(s) if k > n: return [] # Calculate the base size and the remainder base_size = n // k remainder = n % k substrings = [] start = 0 for i in range(k): current_size = base_size + (1 if i < remainder else 0) substrings.append(s[start:start + current_size]) start += current_size return substrings"},{"question":"class MyCircularQueue: Implement a circular queue using a fixed-size array. A circular queue follows the First-In-First-Out (FIFO) principle but wraps around when the end of the array is reached. Implement the \`MyCircularQueue\` class: - \`MyCircularQueue(int k)\`: Initializes the circular queue with a maximum size of \`k\`. - \`bool enQueue(int value)\`: Inserts an element into the circular queue. Returns \`true\` if the operation is successful, otherwise returns \`false\`. - \`bool deQueue()\`: Removes an element from the circular queue. Returns \`true\` if the operation is successful, otherwise returns \`false\`. - \`int Front()\`: Gets the front item from the queue. If the queue is empty, return \`-1\`. - \`int Rear()\`: Gets the last item from the queue. If the queue is empty, return \`-1\`. - \`bool isEmpty()\`: Checks whether the circular queue is empty. - \`bool isFull()\`: Checks whether the circular queue is full. >>> circularQueue = MyCircularQueue(3) >>> circularQueue.enQueue(1) True >>> circularQueue.enQueue(2) True >>> circularQueue.enQueue(3) True >>> circularQueue.enQueue(4) False >>> circularQueue.Front() 1 >>> circularQueue.Rear() 3 >>> circularQueue.isFull() True >>> circularQueue.deQueue() True >>> circularQueue.deQueue() True >>> circularQueue.Front() 3 >>> circularQueue.Rear() 3 >>> circularQueue.deQueue() True >>> circularQueue.deQueue() False >>> circularQueue.Front() -1 >>> circularQueue.Rear() -1 >>> circularQueue.isEmpty() True >>> circularQueue.enQueue(5) True >>> circularQueue.enQueue(6) True >>> circularQueue.Front() 5 >>> circularQueue.Rear() 6 def __init__(self, k: int): pass def enQueue(self, value: int) -> bool: pass def deQueue(self) -> bool: pass def Front(self) -> int: pass def Rear(self) -> int: pass def isEmpty(self) -> bool: pass def isFull(self) -> bool: pass","solution":"class MyCircularQueue: def __init__(self, k: int): self.queue = [0] * k self.head = -1 self.tail = -1 self.max_size = k def enQueue(self, value: int) -> bool: if self.isFull(): return False if self.isEmpty(): self.head = 0 self.tail = (self.tail + 1) % self.max_size self.queue[self.tail] = value return True def deQueue(self) -> bool: if self.isEmpty(): return False if self.head == self.tail: self.head = -1 self.tail = -1 else: self.head = (self.head + 1) % self.max_size return True def Front(self) -> int: if self.isEmpty(): return -1 return self.queue[self.head] def Rear(self) -> int: if self.isEmpty(): return -1 return self.queue[self.tail] def isEmpty(self) -> bool: return self.head == -1 def isFull(self) -> bool: return (self.tail + 1) % self.max_size == self.head"},{"question":"from typing import List def rotateImage(grid: List[List[int]]) -> List[List[int]]: Rotates the given n x n 2D matrix 90 degrees clockwise. Args: grid (List[List[int]]): A n x n 2D matrix representing the image. Returns: List[List[int]]: The rotated 2D matrix. pass def test_rotate_image_example(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotateImage(grid) == expected def test_rotate_image_single_element(): grid = [ [1] ] expected = [ [1] ] assert rotateImage(grid) == expected def test_rotate_image_2x2(): grid = [ [1, 2], [3, 4] ] expected = [ [3, 1], [4, 2] ] assert rotateImage(grid) == expected def test_rotate_image_4x4(): grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotateImage(grid) == expected def test_rotate_image_non_square(): grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] try: rotateImage(grid) assert False, \\"Expected failure on non-square matrix\\" except AssertionError: assert True","solution":"from typing import List def rotateImage(grid: List[List[int]]) -> List[List[int]]: Rotates the given n x n 2D matrix 90 degrees clockwise. Args: grid (List[List[int]]): A n x n 2D matrix representing the image. Returns: List[List[int]]: The rotated 2D matrix. # Get the size of the matrix n = len(grid) # Create an empty matrix to hold the rotated values rotated = [[0]*n for _ in range(n)] # Perform the rotation for i in range(n): for j in range(n): rotated[j][n-1-i] = grid[i][j] return rotated"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(l1: ListNode, l2: ListNode) -> ListNode: Given two linked lists representing two non-negative integers where digits are stored in reverse order, return the sum as a linked list. Each node contains a single digit. The digits are stored in reverse order, and each of their non-empty linked lists does not contain any leading zero, except the number 0 itself. Args: l1 (ListNode): The head of the first linked list. l2 (ListNode): The head of the second linked list. Returns: ListNode: The head of the resulting linked list representing the sum. >>> ll1 = ListNode(2, ListNode(4, ListNode(3))) >>> ll2 = ListNode(5, ListNode(6, ListNode(4))) >>> result = add_two_numbers(ll1, ll2) >>> while result: ... print(result.val, end=' ') ... result = result.next 7 0 8","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(l1, l2): dummy = ListNode() current = dummy carry = 0 while l1 or l2 or carry: val1 = l1.val if l1 else 0 val2 = l2.val if l2 else 0 total = val1 + val2 + carry carry = total // 10 current.next = ListNode(total % 10) current = current.next if l1: l1 = l1.next if l2: l2 = l2.next return dummy.next"},{"question":"def min_abs_diff_sum(nums: List[int], k: int) -> int: Finds the minimum absolute difference between the sum of a non-empty subarray and k. Args: nums (list<int>): List of integers. k (int): Target integer. Returns: int: The minimum absolute difference. >>> min_abs_diff_sum([1, -2, 3, 4, -1], 3) == 0 >>> min_abs_diff_sum([1], 2) == 1 >>> min_abs_diff_sum([-1], -2) == 1 >>> min_abs_diff_sum([1, -2, 3, 4, -1], -3) == 1 >>> min_abs_diff_sum([], 3) == float('inf') >>> min_abs_diff_sum([-1, -2, -3, -4], -3) == 0 >>> min_abs_diff_sum([0, 0, 0, 1, 2], 4) == 1","solution":"def min_abs_diff_sum(nums, k): Finds the minimum absolute difference between the sum of a non-empty subarray and k. Args: nums (list<int>): List of integers. k (int): Target integer. Returns: int: The minimum absolute difference. n = len(nums) min_abs_diff = float('inf') closest_sum = float('inf') for i in range(n): curr_sum = 0 for j in range(i, n): curr_sum += nums[j] abs_diff = abs(curr_sum - k) if abs_diff < min_abs_diff: min_abs_diff = abs_diff closest_sum = curr_sum elif abs_diff == min_abs_diff: closest_sum = min(closest_sum, curr_sum) return min_abs_diff"},{"question":"import re class Dictionary: Implements a Dictionary that supports adding words and searching words with support for wildcard characters. Methods: - addWord(word): Adds the given word to the dictionary. - searchWord(word): Returns True if the given word is in the dictionary, supporting \\".\\" as a wildcard character. Examples: >>> dictionary = Dictionary() >>> dictionary.addWord(\\"bad\\") >>> dictionary.addWord(\\"dad\\") >>> dictionary.searchWord(\\"pad\\") False >>> dictionary.searchWord(\\"bad\\") True >>> dictionary.searchWord(\\".ad\\") True >>> dictionary.searchWord(\\"b..\\") True def __init__(self): self.words = [] def addWord(self, word): pass def searchWord(self, word): pass def test_add_word(): dictionary = Dictionary() dictionary.addWord(\\"bad\\") assert \\"bad\\" in dictionary.words def test_search_word_exact(): dictionary = Dictionary() dictionary.addWord(\\"bad\\") dictionary.addWord(\\"dad\\") dictionary.addWord(\\"mad\\") assert dictionary.searchWord(\\"pad\\") == False assert dictionary.searchWord(\\"bad\\") == True def test_search_word_with_wildcard(): dictionary = Dictionary() dictionary.addWord(\\"bad\\") dictionary.addWord(\\"dad\\") dictionary.addWord(\\"mad\\") assert dictionary.searchWord(\\".ad\\") == True assert dictionary.searchWord(\\"b..\\") == True assert dictionary.searchWord(\\"..d\\") == True assert dictionary.searchWord(\\"...\\") == True assert dictionary.searchWord(\\"ba.\\") == True def test_search_word_with_multiple_wildcards(): dictionary = Dictionary() dictionary.addWord(\\"bad\\") dictionary.addWord(\\"dad\\") dictionary.addWord(\\"mad\\") assert dictionary.searchWord(\\"...\\") == True assert dictionary.searchWord(\\"b..\\") == True assert dictionary.searchWord(\\".a.\\") == True assert dictionary.searchWord(\\"..d\\") == True","solution":"import re class Dictionary: def __init__(self): self.words = [] def addWord(self, word): Adds the given word to the dictionary. self.words.append(word) def searchWord(self, word): Returns True if the given word is in the dictionary, supporting \\".\\" as a wildcard character where \\".\\" can represent any single letter. pattern = re.compile(f\\"^{word}\\") for w in self.words: if pattern.match(w): return True return False"},{"question":"def remove_adjacent_duplicates(s: str) -> str: Removes all adjacent duplicates in the string s. >>> remove_adjacent_duplicates(\\"abc\\") == \\"abc\\" >>> remove_adjacent_duplicates(\\"aabbcc\\") == \\"\\" >>> remove_adjacent_duplicates(\\"abbac\\") == \\"c\\" >>> remove_adjacent_duplicates(\\"abccba\\") == \\"\\" >>> remove_adjacent_duplicates(\\"a\\"*5000 + \\"b\\"*5000 + \\"c\\"*5000) == \\"\\" >>> remove_adjacent_duplicates(\\"abcabc\\") == \\"abcabc\\"","solution":"def remove_adjacent_duplicates(s: str) -> str: Removes all adjacent duplicates in the string s. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return ''.join(stack)"},{"question":"from typing import Dict def evaluate_expression(expression: str, values: Dict[str, int]) -> int: Evaluates the given expression by summing up the values of variables in the dictionary. Parameters: - expression (str): A string representing the sum of variables (e.g., \\"a+b+c\\"). - values (dict): A dictionary containing the values for each variable. Returns: - int: The result of the expression. >>> evaluate_expression(\\"a\\", {'a': 10}) == 10 >>> evaluate_expression(\\"a+b\\", {'a': 10, 'b': 5}) == 15 >>> evaluate_expression(\\"a+b+c\\", {'a': 1, 'b': 2, 'c': 3}) == 6 >>> evaluate_expression(\\"a+b+c\\", {'a': 0, 'b': 2, 'c': 3}) == 5 >>> evaluate_expression(\\"a+b\\", {'a': 1000000, 'b': 2000000}) == 3000000 >>> evaluate_expression(\\"x+y+z\\", {'z': 3, 'y': 2, 'x': 1}) == 6 >>> try: >>> evaluate_expression(\\"a+b\\", {'a': 1}) >>> except KeyError as e: >>> assert str(e) == \\"'b'\\"","solution":"def evaluate_expression(expression: str, values: dict) -> int: Evaluates the given expression by summing up the values of variables in the dictionary. Parameters: - expression (str): A string representing the sum of variables (e.g., \\"a+b+c\\"). - values (dict): A dictionary containing the values for each variable. Returns: - int: The result of the expression. # Split the expression by '+' to get the list of variables variables = expression.split('+') # Sum up the values of the variables using the provided dictionary result = sum(values[var] for var in variables) return result"},{"question":"def min_length_subarray(arr, threshold): Returns the minimum length of a subarray with a sum greater than or equal to threshold. If no such subarray exists, return -1. >>> min_length_subarray([1, 2, 3, 4, 5], 11) 3 >>> min_length_subarray([1, 2, 3, 4, 5], 16) -1 >>> min_length_subarray([5, 1, 2, 3], 5) 1 >>> min_length_subarray([1, 2, 3, 4, 5], 15) 5 >>> min_length_subarray([2, 3, 1, 2, 4, 3], 7) 2 >>> min_length_subarray([1, 2, 3], 10) -1 >>> min_length_subarray([1, 2, 3, 4, 5], 100) -1 >>> min_length_subarray([1, -1, 5, 2], 3) 1","solution":"def min_length_subarray(arr, threshold): Returns the minimum length of a subarray with a sum greater than or equal to threshold. If no such subarray exists, return -1. n = len(arr) min_len = float('inf') current_sum = 0 left = 0 for right in range(n): current_sum += arr[right] while current_sum >= threshold: min_len = min(min_len, right - left + 1) current_sum -= arr[left] left += 1 return min_len if min_len != float('inf') else -1"},{"question":"from typing import List def min_keys_to_visit_all_rooms(rooms: List[int]) -> int: Returns the minimum number of keys needed to visit all rooms at least once. Parameters: rooms (List[int]): A list where rooms[i] represents the number of keys in the i-th room. Returns: int: The minimum number of keys required to visit all rooms at least once. pass def test_basic_case(): assert min_keys_to_visit_all_rooms([1, 1, 1]) == 3 def test_no_rooms(): assert min_keys_to_visit_all_rooms([]) == 0 def test_one_room(): assert min_keys_to_visit_all_rooms([5]) == 5 def test_more_complex_case(): assert min_keys_to_visit_all_rooms([1, 2, 3]) == 6 def test_large_numbers(): assert min_keys_to_visit_all_rooms([1000, 2000, 3000]) == 6000 def test_varying_keys(): assert min_keys_to_visit_all_rooms([1, 0, 3, 1, 2]) == 7","solution":"from typing import List def min_keys_to_visit_all_rooms(rooms: List[int]) -> int: Returns the minimum number of keys needed to visit all rooms at least once. Parameters: rooms (List[int]): A list where rooms[i] represents the number of keys in the i-th room. Returns: int: The minimum number of keys required to visit all rooms at least once. if not rooms: return 0 # BFS to find the minimum number of keys to visit all rooms n = len(rooms) visited = [False] * n queue = [0] visited[0] = True keys_collected = 0 while queue: current_room = queue.pop(0) keys_in_current_room = rooms[current_room] keys_collected += keys_in_current_room for next_room in range(n): if not visited[next_room]: visited[next_room] = True queue.append(next_room) return keys_collected"},{"question":"from typing import List def longest_palindrome(s: str) -> int: Write a function that takes a string \`s\` as input and returns the length of the longest palindrome that can be formed with the letters of \`s\`. The string may consist of both uppercase and lowercase letters. The palindrome does not need to be limited to dictionary words. Note that in the result, the characters are case-sensitive, meaning that \\"Aa\\" is not considered a palindrome. Examples: >>> longest_palindrome(\\"aaaa\\") 4 >>> longest_palindrome(\\"abccccdd\\") 7 >>> longest_palindrome(\\"AaBbCcDd\\") 1 >>> longest_palindrome(\\"AaBbCcDd#\\") 1 >>> longest_palindrome(\\"A\\") 1 >>> longest_palindrome(\\"\\") 0 pass","solution":"from collections import Counter def longest_palindrome(s): Returns the length of the longest palindrome that can be formed with the letters of the input string \`s\`. char_count = Counter(s) length = 0 odd_found = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"def deepest_level_sum(tree: List[int]) -> int: Returns the sum of values of all nodes at the deepest level in the given binary tree. The binary tree is represented as a list where \`-1\` signifies a null node. >>> deepest_level_sum([5]) == 5 >>> deepest_level_sum([1, 2, 3, 4, 5, 6, 7]) == 22 >>> deepest_level_sum([1, 2, 3, -1, -1, 6, 7]) == 13 >>> deepest_level_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == sum(range(8, 16)) >>> deepest_level_sum([1, -1, -1, -1, -1, -1, -1, -1, -1]) == 1 >>> deepest_level_sum([]) == 0 >>> deepest_level_sum([-1, -1, -1, -1, -1, -1, -1, -1]) == 0","solution":"def deepest_level_sum(tree): Returns the sum of values of all nodes at the deepest level in the given binary tree. The binary tree is represented as a list where \`-1\` signifies a null node. if not tree or tree[0] == -1: return 0 current_level = [0] next_level = [] # BFS to find the deepest level while current_level: next_level = [] for index in current_level: left_index = 2 * index + 1 right_index = 2 * index + 2 if left_index < len(tree) and tree[left_index] != -1: next_level.append(left_index) if right_index < len(tree) and tree[right_index] != -1: next_level.append(right_index) if not next_level: break current_level = next_level # Calculate the sum of values at the deepest level return sum(tree[idx] for idx in current_level)"},{"question":"class WorkerAvailability: Class to determine the maximum number of consecutive hours during which at least one worker is available. Args: - arr1: List[int] : Availability of the first worker for each hour. - arr2: List[int] : Availability of the second worker for each hour. Methods: - __init__(self, arr1, arr2): Initializes the object with the two arrays of worker availability. - max_consecutive_hours(self): Returns the maximum number of consecutive hours during which at least one worker is available. >>> wa = WorkerAvailability([0, 0, 0, 0], [0, 0, 0, 0]) >>> wa.max_consecutive_hours() 0 >>> wa = WorkerAvailability([1, 1, 1, 1], [1, 1, 1, 1]) >>> wa.max_consecutive_hours() 4 >>> wa = WorkerAvailability([1, 0, 1, 1], [0, 1, 0, 1]) >>> wa.max_consecutive_hours() 4 >>> wa = WorkerAvailability([0, 1, 0, 0, 1, 1, 0], [1, 0, 1, 0, 0, 1, 1]) >>> wa.max_consecutive_hours() 3 >>> wa = WorkerAvailability([1, 1, 0, 1, 1, 1], [0, 0, 0, 1, 0, 0]) >>> wa.max_consecutive_hours() 3 def __init__(self, arr1, arr2): pass def max_consecutive_hours(self): pass import pytest def test_max_consecutive_hours_all_unavailable(): arr1 = [0, 0, 0, 0] arr2 = [0, 0, 0, 0] wa = WorkerAvailability(arr1, arr2) assert wa.max_consecutive_hours() == 0 def test_max_consecutive_hours_all_available(): arr1 = [1, 1, 1, 1] arr2 = [1, 1, 1, 1] wa = WorkerAvailability(arr1, arr2) assert wa.max_consecutive_hours() == 4 def test_max_consecutive_hours_partial_availability(): arr1 = [1, 0, 1, 1] arr2 = [0, 1, 0, 1] wa = WorkerAvailability(arr1, arr2) assert wa.max_consecutive_hours() == 4 def test_max_consecutive_hours_mixed_availability(): arr1 = [0, 1, 0, 0, 1, 1, 0] arr2 = [1, 0, 1, 0, 0, 1, 1] wa = WorkerAvailability(arr1, arr2) assert wa.max_consecutive_hours() == 3 def test_max_consecutive_hours_interrupted(): arr1 = [1, 1, 0, 1, 1, 1] arr2 = [0, 0, 0, 1, 0, 0] wa = WorkerAvailability(arr1, arr2) assert wa.max_consecutive_hours() == 3","solution":"class WorkerAvailability: def __init__(self, arr1, arr2): self.arr1 = arr1 self.arr2 = arr2 def max_consecutive_hours(self): max_hours = 0 current_hours = 0 for hour1, hour2 in zip(self.arr1, self.arr2): if hour1 == 1 or hour2 == 1: current_hours += 1 max_hours = max(max_hours, current_hours) else: current_hours = 0 return max_hours"},{"question":"def find_duplicates(nums): Given a list of integers where each integer appears at most twice, return an array of all the integers that appear exactly twice. This function must run in O(n) time and use only constant extra space. >>> find_duplicates([1, 2, 3, 1, 2, 3]) [1, 2, 3] >>> find_duplicates([4, 3, 2, 7, 8, 2, 3, 1]) [2, 3] >>> find_duplicates([1, 2, 3, 4, 5]) [] >>> find_duplicates([1]) [] >>> find_duplicates([]) []","solution":"def find_duplicates(nums): Returns a list of integers that appear exactly twice in the input list. This function modifies the input list nums in-place to mark visited elements by flipping their sign. It then collects elements that were visited more than once. result = [] for i in range(len(nums)): index = abs(nums[i]) - 1 if nums[index] < 0: result.append(abs(nums[i])) else: nums[index] = -nums[index] return result"},{"question":"def remove_duplicates(s: str) -> str: Removes all duplicate letters in the string such that each letter appears only once and maintains the original order of appearance. >>> remove_duplicates(\\"abacabad\\") 'abcd' >>> remove_duplicates(\\"abcdef\\") 'abcdef' >>> remove_duplicates(\\"aaaaaa\\") 'a' >>> remove_duplicates(\\"\\") '' >>> remove_duplicates(\\"abc\\") 'abc' >>> remove_duplicates(\\"thequickbrownfoxjumpsoverthelazydog\\") 'thequickbrownfxjmpsvlazydg'","solution":"def remove_duplicates(s): Removes all duplicate letters in the string such that each letter appears only once and maintains the original order of appearance. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"import math from typing import List def is_prime(n: int) -> bool: Helper function to determine if a number \`n\` is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def count_elements_with_three_divisors(arr: List[int]) -> int: Count the number of elements in the array \`arr\` that have exactly three divisors. :param arr: List of integers :return: Count of elements with exactly three divisors >>> count_elements_with_three_divisors([4]) 1 >>> count_elements_with_three_divisors([4, 9, 25]) 3 >>> count_elements_with_three_divisors([1, 2, 3, 5, 6]) 0 >>> count_elements_with_three_divisors([1, 4, 8, 9, 16, 25]) 3 >>> count_elements_with_three_divisors([4, 9, 25, 49, 121]) 5 >>> count_elements_with_three_divisors([6, 10, 12, 15, 18]) 0 >>> count_elements_with_three_divisors([]) 0","solution":"import math def is_prime(n): Helper function to determine if a number \`n\` is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def count_elements_with_three_divisors(arr): Counts the number of elements in the array \`arr\` that have exactly three divisors. count = 0 for num in arr: if num < 4: continue sqrt_num = int(math.sqrt(num)) if sqrt_num * sqrt_num == num and is_prime(sqrt_num): count += 1 return count"},{"question":"def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merges all overlapping intervals and returns the merged intervals in sorted order. >>> merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18]]) [[1, 6], [8, 10], [15, 18]] >>> merge_intervals([[1, 4], [4, 5]]) [[1, 5]] >>> merge_intervals([[1, 4], [0, 4]]) [[0, 4]] >>> merge_intervals([[1, 4], [2, 3]]) [[1, 4]] >>> merge_intervals([[1, 4], [0, 1]]) [[0, 4]] >>> merge_intervals([]) [] >>> merge_intervals([[2, 3], [4, 5], [6, 7], [8, 9], [1, 10]]) [[1, 10]]","solution":"def merge_intervals(intervals): Merges all overlapping intervals and returns the merged intervals in sorted order. :param intervals: List[List[int]] - A list of intervals where each interval is a list of two integers [starti, endi] :return: List[List[int]] - A list of merged and sorted intervals if not intervals: return [] # Sort intervals by the start time intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] # If the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: last_merged[1] = max(last_merged[1], current[1]) else: # Otherwise, add the current interval to the list merged_intervals.append(current) return merged_intervals"},{"question":"from typing import List def minimize_difference(nums: List[int], k: int) -> int: Split the array \`nums\` into \`k\` consecutive subarrays such that the difference between the maximum sum of any subarray and the minimum sum of any subarray is minimized. Return the minimum difference between the maximum and minimum subarray sums achieved by any way of splitting the array. >>> minimize_difference([7, 2, 5, 10, 8], 2) 18 >>> minimize_difference([10], 1) 10 >>> minimize_difference([5, 5, 5, 5, 5], 3) 10 >>> minimize_difference([1, 2, 3, 4, 5], 5) 5 >>> minimize_difference([1, 1, 1, 1, 1, 1, 1, 1], 4) 2","solution":"def can_partition(nums, k, max_sum): current_sum = 0 required_subarrays = 1 for num in nums: if current_sum + num > max_sum: required_subarrays += 1 current_sum = num if required_subarrays > k: return False else: current_sum += num return True def minimize_difference(nums, k): left, right = max(nums), sum(nums) result = right while left <= right: mid = (left + right) // 2 if can_partition(nums, k, mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"def canBeNonDecreasing(nums: List[int], k: int) -> bool: Determines if it is possible to make the array non-decreasing using exactly k increments. Parameters: nums (list of int): The input array of integers. k (int): The number of increments allowed. Returns: bool: True if nums can be made non-decreasing using exactly k increments, false otherwise. from solution import canBeNonDecreasing def test_canBeNonDecreasing_case_1(): assert canBeNonDecreasing([1, 2, 3], 0) == True def test_canBeNonDecreasing_case_2(): assert canBeNonDecreasing([3, 2, 1], 3) == True def test_canBeNonDecreasing_case_3(): assert canBeNonDecreasing([3, 2, 1], 2) == False def test_canBeNonDecreasing_case_4(): assert canBeNonDecreasing([1, 3, 2], 1) == True def test_canBeNonDecreasing_case_5(): assert canBeNonDecreasing([1, 3, 2, 4], 1) == True def test_canBeNonDecreasing_case_6(): assert canBeNonDecreasing([5, 4, 3, 2, 1], 10) == True def test_canBeNonDecreasing_case_7(): assert canBeNonDecreasing([5, 4, 3, 2, 1], 9) == False","solution":"def canBeNonDecreasing(nums, k): Determines if it is possible to make the array non-decreasing using exactly k increments. Parameters: nums (list of int): The input array of integers. k (int): The number of increments allowed. Returns: bool: True if nums can be made non-decreasing using exactly k increments, false otherwise. n = len(nums) for i in range(1, n): if nums[i] < nums[i - 1]: diff = nums[i - 1] - nums[i] if k >= diff: k -= diff nums[i] += diff else: return False return k == 0"},{"question":"def min_distance(s1: str, s2: str) -> int: Returns the minimum number of operations required to convert s1 into s2. Operations permitted: - Insert a character. - Delete a character. - Replace a character. >>> min_distance(\\"horse\\", \\"ros\\") 3 >>> min_distance(\\"intention\\", \\"execution\\") 5 >>> min_distance(\\"abcdef\\", \\"abcdef\\") 0 >>> min_distance(\\"abc\\", \\"yabd\\") 2 >>> min_distance(\\"\\", \\"\\") 0 >>> min_distance(\\"\\", \\"a\\") 1 >>> min_distance(\\"a\\", \\"\\") 1 >>> min_distance(\\"a\\", \\"b\\") 1 >>> min_distance(\\"a\\", \\"a\\") 0 >>> min_distance(\\"abc\\", \\"abcd\\") 1 >>> min_distance(\\"abcd\\", \\"abc\\") 1 >>> min_distance(\\"abc\\", \\"ab\\") 1","solution":"def min_distance(s1, s2): Returns the minimum number of operations required to convert s1 into s2. Operations permitted: - Insert a character. - Delete a character. - Replace a character. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # s1 is empty, insert all characters of s2 elif j == 0: dp[i][j] = i # s2 is empty, delete all characters of s1 elif s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] # Characters match, move to next else: dp[i][j] = 1 + min(dp[i-1][j], # Remove from s1 dp[i][j-1], # Insert into s1 dp[i-1][j-1]) # Replace character return dp[m][n]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root: TreeNode) -> int: Determine the depth of the deepest leaf node in a binary tree. >>> maxDepth(None) == 0 >>> root = TreeNode(1) >>> maxDepth(root) == 1 >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20, TreeNode(15), TreeNode(7)) >>> maxDepth(root) == 3 >>> root = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4)))) >>> maxDepth(root) == 4 >>> root = TreeNode(1, right=TreeNode(2, right=TreeNode(3, right=TreeNode(4)))) >>> maxDepth(root) == 4 >>> root = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5)) >>> maxDepth(root) == 3","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root): Returns the maximum depth of the binary tree. :param root: TreeNode, the root of the binary tree :return: int, the maximum depth of the tree if not root: return 0 left_depth = maxDepth(root.left) right_depth = maxDepth(root.right) return 1 + max(left_depth, right_depth)"},{"question":"def is_valid_parenthesis_string(s: str) -> bool: Determine whether the input string \`s\` is a valid parenthesis string. A valid parenthesis string is defined based on the following rules: - An empty string \`\\"\\"\` is valid. - If \`A\` is a valid string, then \`A + A\` is valid. - If \`A\` is a valid string, then \`(A)\` is valid. >>> is_valid_parenthesis_string(\\"\\") == True >>> is_valid_parenthesis_string(\\"()\\") == True >>> is_valid_parenthesis_string(\\"(())\\") == True >>> is_valid_parenthesis_string(\\"()()\\") == True >>> is_valid_parenthesis_string(\\")\\") == False >>> is_valid_parenthesis_string(\\"(\\") == False >>> is_valid_parenthesis_string(\\"(()\\") == False >>> is_valid_parenthesis_string(\\"(()(()))\\") == True >>> is_valid_parenthesis_string(\\"(()())(\\") == False # Implement the function to determine if the parenthesis string is valid","solution":"def is_valid_parenthesis_string(s): stack = [] for char in s: if char == \\"(\\": stack.append(char) elif char == \\")\\": if len(stack) == 0: return False stack.pop() return len(stack) == 0"},{"question":"def largest_rectangle_area(heights): Given a list of non-negative integers representing the heights of blocks in a histogram, finds the area of the largest rectangle in the histogram. Args: heights (List[int]): A list of non-negative integers representing the heights of the blocks. Returns: int: The area of the largest rectangle. Examples: >>> largest_rectangle_area([]) == 0 >>> largest_rectangle_area([5]) == 5 >>> largest_rectangle_area([1, 2, 3, 4, 5]) == 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) == 9 >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 >>> largest_rectangle_area([3, 3, 3, 3, 3]) == 15 >>> largest_rectangle_area([2, 1, 2, 1, 2]) == 5 >>> largest_rectangle_area([1, 3, 1, 3, 1, 3]) == 6 >>> largest_rectangle_area([2, 0, 2, 2, 2]) == 6","solution":"def largest_rectangle_area(heights): Given a list of non-negative integers representing the heights of blocks in a histogram, finds the area of the largest rectangle in the histogram. Args: heights (List[int]): A list of non-negative integers representing the heights of the blocks. Returns: int: The area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def has_pair_with_sum(arr: List[int], target: int) -> bool: Determines if there exist two integers in the array such that their sum is equal to the target. :param arr: List of integers. :param target: Target sum. :return: Boolean indicating if there exists a pair with the sum equals to target. >>> has_pair_with_sum([2, 7, 11, 15], 9) True >>> has_pair_with_sum([2, 7, 11, 15], 10) False >>> has_pair_with_sum([], 0) False >>> has_pair_with_sum([1], 2) False >>> has_pair_with_sum([1, 1, 3, 5], 2) True >>> has_pair_with_sum([-1, -2, -3, -4, -5], -8) True >>> has_pair_with_sum([-1, 2, 3, -4, 5], 1) True >>> has_pair_with_sum([1000000000, 2000000000, 3000000000, 4000000000], 7000000000) True >>> has_pair_with_sum([-2, 0, 2], 0) True","solution":"def has_pair_with_sum(arr, target): Determines if there exist two integers in the array such that their sum is equal to the target. :param arr: List of integers. :param target: Target sum. :return: Boolean indicating if there exists a pair with the sum equals to target. complement_set = set() for num in arr: if target - num in complement_set: return True complement_set.add(num) return False"},{"question":"from typing import List def rob(nums: List[int]) -> int: Given a list of non-negative integers representing the amount of money of each house, returns the maximum amount of money you can rob tonight without alerting the smart lock system. >>> rob([]) == 0 >>> rob([5]) == 5 >>> rob([3, 10]) == 10 >>> rob([2, 7, 9, 3, 1]) == 12 >>> rob([1, 2, 3, 1]) == 4 >>> rob([2, 1, 1, 2]) == 4 >>> rob([100, 1, 1, 100]) == 200","solution":"from typing import List def rob(nums: List[int]) -> int: Given a list of non-negative integers representing the amount of money of each house, returns the maximum amount of money you can rob tonight without alerting the smart lock system. if not nums: return 0 if len(nums) == 1: return nums[0] if len(nums) == 2: return max(nums[0], nums[1]) dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"def is_robot_return_to_origin(route: str) -> bool: Determines if the robot returns to the origin position (0, 0) after completing the entire route. :param route: A string representing the movements of a robot. :return: True if the robot returns to the origin, False otherwise. >>> is_robot_return_to_origin(\\"UD\\") True >>> is_robot_return_to_origin(\\"LLRR\\") True >>> is_robot_return_to_origin(\\"LRLR\\") True >>> is_robot_return_to_origin(\\"UDLR\\") True >>> is_robot_return_to_origin(\\"\\") True >>> is_robot_return_to_origin(\\"UUDD\\") True >>> is_robot_return_to_origin(\\"LL\\") False >>> is_robot_return_to_origin(\\"URDL\\") True >>> is_robot_return_to_origin(\\"UUDDLRR\\") False >>> is_robot_return_to_origin(\\"UDDR\\") False","solution":"def is_robot_return_to_origin(route): Determines if the robot returns to the origin position (0, 0) after completing the entire route. :param route: A string representing the movements of a robot. :return: True if the robot returns to the origin, False otherwise. x, y = 0, 0 for move in route: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return x == 0 and y == 0"},{"question":"def max_unique_substrings(s: str) -> int: Returns the maximum number of unique substrings that can be formed by deleting some or none of the characters in the string s. >>> max_unique_substrings(\\"1\\") == 1 >>> max_unique_substrings(\\"12\\") == 2 >>> max_unique_substrings(\\"111\\") == 3 >>> max_unique_substrings(\\"123456\\") == 6 >>> max_unique_substrings(\\"112233\\") == 6 >>> max_unique_substrings(\\"\\") == 0","solution":"def max_unique_substrings(s): Returns the maximum number of unique substrings that can be formed by deleting some or none of the characters in the string s. return len(s)"},{"question":"def findAndReplacePattern(words: List[str], pattern: str) -> List[str]: Return a list of strings found in \`words\` that match the \`pattern\`. >>> findAndReplacePattern([\\"abc\\",\\"deq\\",\\"mee\\",\\"aqq\\",\\"dkd\\",\\"ccc\\"], \\"abb\\") [\\"mee\\",\\"aqq\\"] >>> findAndReplacePattern([\\"xyz\\", \\"xzz\\", \\"fxx\\", \\"abc\\"], \\"foo\\") [\\"xzz\\", \\"fxx\\"] >>> findAndReplacePattern([\\"abc\\", \\"deq\\", \\"xyz\\"], \\"aaa\\") [] >>> findAndReplacePattern([\\"aba\\", \\"cdc\\", \\"ded\\"], \\"aba\\") [\\"aba\\", \\"cdc\\", \\"ded\\"] >>> findAndReplacePattern([], \\"abc\\") [] >>> findAndReplacePattern([\\"abc\\", \\"deq\\"], \\"\\") []","solution":"def findAndReplacePattern(words, pattern): def get_pattern(s): mapping = {} result = [] next_char = 'a' for char in s: if char not in mapping: mapping[char] = next_char next_char = chr(ord(next_char) + 1) result.append(mapping[char]) return ''.join(result) pattern_transformed = get_pattern(pattern) result = [] for word in words: if get_pattern(word) == pattern_transformed: result.append(word) return result"},{"question":"from typing import List class MatrixBlocks: A class to represent a matrix and find the largest block of connected 1s. Attributes: matrix (List[List[int]]): The matrix containing 0s and 1s. Methods: getLargestBlockSize() -> int: Returns the size of the largest block of connected 1s. >>> mb = MatrixBlocks([ ... [1, 0, 0], ... [0, 1, 1], ... [1, 1, 0] ... ]) >>> mb.getLargestBlockSize() 4 >>> mb = MatrixBlocks([ ... [1, 1, 0, 0], ... [1, 0, 0, 1], ... [0, 0, 1, 1], ... [0, 1, 0, 0] ... ]) >>> mb.getLargestBlockSize() 3 def __init__(self, matrix: List[List[int]]): self.matrix = matrix self.rows = len(matrix) self.cols = len(matrix[0]) if self.rows > 0 else 0 def getLargestBlockSize(self) -> int: pass","solution":"class MatrixBlocks: def __init__(self, matrix): self.matrix = matrix self.rows = len(matrix) self.cols = len(matrix[0]) if self.rows > 0 else 0 def getLargestBlockSize(self): def dfs(i, j): if i < 0 or i >= self.rows or j < 0 or j >= self.cols or self.matrix[i][j] != 1: return 0 self.matrix[i][j] = -1 # mark as visited size = 1 size += dfs(i + 1, j) size += dfs(i - 1, j) size += dfs(i, j + 1) size += dfs(i, j - 1) return size max_block_size = 0 for i in range(self.rows): for j in range(self.cols): if self.matrix[i][j] == 1: max_block_size = max(max_block_size, dfs(i, j)) return max_block_size"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Returns the length of the shortest path in terms of number of steps to reach the bottom-right corner from the top-left corner in a grid where 1 represents obstacle and 0 represents free space. Moves can be made to any of the 8 adjacent cells. >>> shortest_path([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 3 >>> shortest_path([ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 4 >>> shortest_path([ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) -1 >>> shortest_path([ ... [0] ... ]) 1 >>> shortest_path([ ... [1, 0], ... [0, 0] ... ]) -1 >>> shortest_path([ ... [0, 0], ... [0, 1] ... ]) -1","solution":"from collections import deque def shortest_path(grid): Returns the length of the shortest path in terms of number of steps to reach the bottom-right corner from the top-left corner in a grid where 1 represents obstacle and 0 represents free space. Moves can be made to any of the 8 adjacent cells. if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 n, m = len(grid), len(grid[0]) directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] queue = deque([(0, 0, 1)]) grid[0][0] = 1 # Mark the start node as visited while queue: x, y, steps = queue.popleft() if x == n - 1 and y == m - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0: queue.append((nx, ny, steps + 1)) grid[nx][ny] = 1 # Mark the node as visited return -1"},{"question":"from typing import List def findUnique(nums: List[int]) -> int: This function finds the single integer that appears only once in the list where every other integer appears exactly twice. :param nums: List of integers where every integer appears twice except for one :return: The single integer that appears only once >>> findUnique([1, 1, 2, 2, 3]) 3 >>> findUnique([4, 1, 2, 1, 2]) 4 >>> findUnique([1, 2, 3, 4, 5, 5, 4, 3, 2]) 1 >>> findUnique([-1, -2, -3, -1, -2, -3, -4]) -4 >>> findUnique([-1, -2, -2, -1, -3]) -3 >>> findUnique([99]) 99","solution":"from typing import List def findUnique(nums: List[int]) -> int: This function finds the single integer that appears only once in the list where every other integer appears exactly twice. The solution uses bitwise XOR to achieve O(n) runtime complexity and O(1) space complexity. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"from typing import List from math import gcd from functools import reduce def min_possible_sum(nums: List[int]) -> int: Returns the minimum possible sum of the array after performing the operation any number of times. The operation involves selecting any two adjacent elements and replacing both of them with their GCD. >>> min_possible_sum([10]) 10 >>> min_possible_sum([10, 15]) 10 >>> min_possible_sum([5, 5, 5, 5]) 20 >>> min_possible_sum([12, 15, 18]) 9 >>> min_possible_sum([3, 7, 11]) 3 >>> min_possible_sum([]) 0","solution":"from math import gcd from functools import reduce def min_possible_sum(nums): Returns the minimum possible sum of the array after performing the operation any number of times. The operation involves selecting any two adjacent elements and replacing both of them with their GCD. if not nums: return 0 return reduce(gcd, nums) * len(nums)"},{"question":"def longest_good_subsequence(s: str) -> int: Returns the length of the longest good subsequence of s. A good subsequence must contain all vowels ('a', 'e', 'i', 'o', 'u') at least once. >>> longest_good_subsequence('bcdfg') == -1 >>> longest_good_subsequence('abcdefg') == -1 >>> longest_good_subsequence('aeiou') == 5 >>> longest_good_subsequence('abecidofugu') == 11 >>> longest_good_subsequence('aaaaaa') == -1 >>> longest_good_subsequence('aeioub') == 6 >>> longest_good_subsequence('a'*100 + 'e'*100 + 'i'*100 + 'o'*100 + 'u'*100) == 500","solution":"def longest_good_subsequence(s): Returns the length of the longest good subsequence of s. A good subsequence must contain all vowels ('a', 'e', 'i', 'o', 'u') at least once. vowels = {'a', 'e', 'i', 'o', 'u'} found_vowels = set() for char in s: if char in vowels: found_vowels.add(char) # If we found all the vowels if len(found_vowels) == 5: break if len(found_vowels) == 5: return len(s) else: return -1"},{"question":"def trap(height): Computes the total amount of rainwater trapped after it rains. :param height: List of non-negative integers representing the height of the bars. :type height: List[int] :return: Total amount of trapped rainwater. :rtype: int >>> trap([]) 0 >>> trap([4]) 0 >>> trap([1,2,3,4,5]) 0 >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9 >>> trap([0,2,4,6,8,6,4,2,0]) 0 >>> trap([0,7,1,4,6]) 7 >>> trap([2,2,2,2,2]) 0 >>> trap([3, 0, 2, 0, 4]) 7","solution":"def trap(height): Computes the total amount of rainwater trapped after it rains. :param height: List of non-negative integers representing the height of the bars. :type height: List[int] :return: Total amount of trapped rainwater. :rtype: int n = len(height) if n == 0: return 0 left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the total water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def move_value_to_end(nums, val): Given an array nums and a value val, move all instances of val to the end of the array while maintaining the relative order of the other elements. :param nums: List[int] - The list of integers :param val: int - The value to be moved to the end of the array :return: List[int] - The modified array Examples: >>> move_value_to_end([1, 2, 3, 4, 2, 2, 5], 2) [1, 3, 4, 5, 2, 2, 2] >>> move_value_to_end([1, 2, 3, 4, 5], 6) [1, 2, 3, 4, 5] >>> move_value_to_end([2, 2, 2, 2, 2], 2) [2, 2, 2, 2, 2] >>> move_value_to_end([1], 1) [1] >>> move_value_to_end([1], 2) [1] >>> move_value_to_end([], 1) [] >>> move_value_to_end([4, 5, 4, 4, 6, 4, 7], 4) [5, 6, 7, 4, 4, 4, 4] >>> move_value_to_end([10, 3, 10, 1, 5, 10], 10) [3, 1, 5, 10, 10, 10]","solution":"def move_value_to_end(nums, val): Given an array nums and a value val, move all instances of val to the end of the array while maintaining the relative order of the other elements. :param nums: List[int] - The list of integers :param val: int - The value to be moved to the end of the array :return: List[int] - The modified array last_non_val_index = 0 # Traverse through the array for i in range(len(nums)): if nums[i] != val: nums[last_non_val_index] = nums[i] last_non_val_index += 1 # Fill the remaining positions with val for i in range(last_non_val_index, len(nums)): nums[i] = val return nums"},{"question":"def longest_subarray_with_sum_at_most_m(arr: List[int], m: int) -> int: Returns the length of the longest subarray where the sum of its elements is at most m. >>> longest_subarray_with_sum_at_most_m([1, 2, 3, 4, 5], 7) 3 >>> longest_subarray_with_sum_at_most_m([10], 10) 1 >>> longest_subarray_with_sum_at_most_m([7, 7, 7], 7) 1 >>> longest_subarray_with_sum_at_most_m([10, 20, 30], 5) 0 >>> longest_subarray_with_sum_at_most_m([1, 2, 3, 1, 1], 8) 5 >>> longest_subarray_with_sum_at_most_m([1, 2, 1, 0, 1, 1, 1], 4) 5 pass","solution":"def longest_subarray_with_sum_at_most_m(arr, m): Returns the length of the longest subarray where the sum of its elements is at most m. max_length = 0 current_sum = 0 start = 0 for end in range(len(arr)): current_sum += arr[end] while current_sum > m and start <= end: current_sum -= arr[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def count_unique_substrings_with_odd(arr: List[int], k: int) -> int: Returns the number of unique substrings of length k in arr where each substring contains at least one odd number. >>> count_unique_substrings_with_odd([1, 2, 3], 4) == 0 >>> count_unique_substrings_with_odd([2, 4, 6, 8], 2) == 0 >>> count_unique_substrings_with_odd([1, 3, 5, 7], 2) == 3 >>> count_unique_substrings_with_odd([1, 2, 3, 4, 5], 2) == 4","solution":"def count_unique_substrings_with_odd(arr, k): Returns the number of unique substrings of length k in arr where each substring contains at least one odd number. unique_substrings = set() for i in range(len(arr) - k + 1): substring = tuple(arr[i:i+k]) if any(x % 2 != 0 for x in substring): unique_substrings.add(substring) return len(unique_substrings)"},{"question":"def maxProfit(prices: List[int]) -> int: Returns the maximum profit from buying and selling the stock once. :param prices: List[int] - List representing daily stock prices. :return: int - Maximum profit possible, or 0 if no profit can be achieved. >>> maxProfit([7, 1, 5, 3, 6, 4]) 5 >>> maxProfit([7, 6, 4, 3, 1]) 0 >>> maxProfit([7]) 0 >>> maxProfit([]) 0 >>> maxProfit([3, 8, 2, 10, 4, 8, 1, 6]) 8 >>> maxProfit([5, 5, 5, 5, 5]) 0 >>> maxProfit([2, 4, 1, 7, 6, 5]) 6","solution":"def maxProfit(prices): Returns the maximum profit from buying and selling the stock once. :param prices: List[int] - List representing daily stock prices. :return: int - Maximum profit possible, or 0 if no profit can be achieved. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: # Update the minimum price observed so far if price < min_price: min_price = price # Calculate potential profit at current price and update max profit potential_profit = price - min_price if potential_profit > max_profit: max_profit = potential_profit return max_profit"},{"question":"from typing import List class KClosestPoints: def __init__(self, points: List[List[int]], k: int): Initializes the KClosestPoints object with array of points and integer k. self.points = points self.k = k def getKClosest(self) -> List[List[int]]: Returns the list of k closest points to the origin sorted by their distance to the origin. If two points have the same distance, the point with the smaller x-coordinate should appear first. If the x-coordinates are identical, the point with the smaller y-coordinate should come first. >>> kcp = KClosestPoints([[1, 3], [-2, 2]], 1) >>> kcp.getKClosest() [[-2, 2]] >>> kcp = KClosestPoints([[3, 3], [5, -1], [-2, 4]], 2) >>> kcp.getKClosest() [[3, 3], [-2, 4]] >>> kcp = KClosestPoints([[1, 2], [2, 1], [1, -2]], 2) >>> kcp.getKClosest() [[1, -2], [1, 2]] >>> kcp = KClosestPoints([[1, 1], [2, 2], [3, 3], [-1, -1], [-2, -2], [-3, -3]], 3) >>> kcp.getKClosest() [[-1, -1], [1, 1], [-2, -2]] >>> kcp = KClosestPoints([], 0) >>> kcp.getKClosest() []","solution":"from typing import List import heapq class KClosestPoints: def __init__(self, points: List[List[int]], k: int): self.points = points self.k = k def getKClosest(self) -> List[List[int]]: Returns the list of k closest points to the origin sorted by their distance to the origin. # Define a lambda to compute the Euclidean distance squared from the origin for a point def distance_squared(point): return point[0]**2 + point[1]**2 # Use a heap to get the k smallest distances heap = [] for point in self.points: # Add tuples of (distance squared, x coordinate, y coordinate) to the heap heapq.heappush(heap, (distance_squared(point), point)) # Extract the k closest points and sort by distance, and then lexicographically by (x, y) if distances are the same closest_points = [heapq.heappop(heap)[1] for _ in range(self.k)] closest_points.sort(key=lambda point: (distance_squared(point), point[0], point[1])) return closest_points"},{"question":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the array nums. Examples: >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([]) 0 >>> length_of_lis([10]) 1 >>> length_of_lis([1, 2, 3, 4, 5]) 5 >>> length_of_lis([5, 4, 3, 2, 1]) 1 >>> length_of_lis([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]) 6 >>> length_of_lis([2, 2, 2, 2, 2]) 1","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the array nums. if not nums: return 0 # Initialize DP array where dp[i] represents the length of the longest # increasing subsequence that ends with nums[i] dp = [1] * len(nums) # Build the dp array for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence is the maximum value in dp array return max(dp)"},{"question":"from typing import List def min_possible_largest(nums: List[int]) -> int: Given a list of non-negative integers nums, this function returns the minimum possible value of the largest element in the list after performing the specified operation any number of times: Pick the largest element and reduce it by any value that is a power of 2 (the value must be less than or equal to the largest element). >>> min_possible_largest([8]) == 0 >>> min_possible_largest([0, 0, 0]) == 0 >>> min_possible_largest([4, 3, 8]) == 0 >>> min_possible_largest([256, 128, 512]) == 0 >>> min_possible_largest([1, 1, 1]) == 0","solution":"def min_possible_largest(nums): while any(num > 0 for num in nums): max_num = max(nums) if max_num == 0: break max_index = nums.index(max_num) power_of_2 = 1 while power_of_2 * 2 <= max_num: power_of_2 *= 2 nums[max_index] -= power_of_2 return max(nums)"},{"question":"def count_distinct_subarrays_with_sum_k(nums: List[int], k: int) -> int: Returns the number of distinct subarrays in nums that have an exact sum of k. >>> count_distinct_subarrays_with_sum_k([1, 2, 3, 4], 3) 2 >>> count_distinct_subarrays_with_sum_k([1, 1, 1, 1], 2) 1 >>> count_distinct_subarrays_with_sum_k([1, 2, 4], 10) 0 >>> count_distinct_subarrays_with_sum_k([2, 2, 2], 2) 1 >>> count_distinct_subarrays_with_sum_k([1, 2, 1, 3, 2], 3) 3 >>> count_distinct_subarrays_with_sum_k([3, 3, 3], 3) 1","solution":"def count_distinct_subarrays_with_sum_k(nums, k): Returns the number of distinct subarrays in nums that have an exact sum of k. n = len(nums) distinct_subarrays = set() for start in range(n): current_sum = 0 subarray = [] for end in range(start, n): current_sum += nums[end] subarray.append(nums[end]) if current_sum == k: distinct_subarrays.add(tuple(subarray)) elif current_sum > k: break return len(distinct_subarrays)"},{"question":"from collections import defaultdict class CharacterReplacement: def __init__(self): pass def longestSubstringWithSameLetter(self, s: str, k: int) -> int: Returns the length of the longest substring containing the same letter after making at most k changes. >>> cr = CharacterReplacement() >>> cr.longestSubstringWithSameLetter(\\"aaaa\\", 2) 4 >>> cr.longestSubstringWithSameLetter(\\"aaab\\", 1) 4 >>> cr.longestSubstringWithSameLetter(\\"aabbcc\\", 2) 4 >>> cr.longestSubstringWithSameLetter(\\"abcdef\\", 0) 1 >>> cr.longestSubstringWithSameLetter(\\"abcdef\\", 5) 6 >>> cr.longestSubstringWithSameLetter(\\"aabccbb\\", 2) 5 >>> cr.longestSubstringWithSameLetter(\\"aaaabb\\", 2) 6","solution":"from collections import defaultdict class CharacterReplacement: def __init__(self): pass def longestSubstringWithSameLetter(self, s: str, k: int) -> int: left = 0 max_length = 0 max_count = 0 count = defaultdict(int) for right in range(len(s)): count[s[right]] += 1 max_count = max(max_count, count[s[right]]) if (right - left + 1) - max_count > k: count[s[left]] -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"class Node: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root): Given a binary tree, populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to 'null'. This function modifies the tree in place. The binary tree can be assumed to be a perfect binary tree, where every node has two children and all leaves are at the same level. >>> root = Node(1, Node(2, Node(4), Node(5)), Node(3, Node(6), Node(7))) >>> connect(root) >>> root.left.next.val == 3 True >>> root.left.left.next.val == 5 True pass def test_connect_empty_tree(): assert connect(None) is None def test_connect_single_node(): root = Node(1) connect(root) assert root.next is None def test_connect_three_level_tree(): root = Node(1, Node(2, Node(4), Node(5)), Node(3, Node(6), Node(7))) connect(root) # Level 2 assert root.left.next == root.right assert root.right.next is None # Level 3 assert root.left.left.next == root.left.right assert root.left.right.next == root.right.left assert root.right.left.next == root.right.right assert root.right.right.next is None","solution":"class Node: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root): if not root: return None leftmost = root while leftmost.left: head = leftmost while head: head.left.next = head.right if head.next: head.right.next = head.next.left head = head.next leftmost = leftmost.left return root"},{"question":"def lexicographically_smallest_string(s: str) -> str: Returns the lexicographically smallest string that can be obtained by moving characters to the end of the string. >>> lexicographically_smallest_string(\\"cba\\") \\"abc\\" >>> lexicographically_smallest_string(\\"abc\\") \\"abc\\" >>> lexicographically_smallest_string(\\"bbac\\") \\"abbc\\" >>> lexicographically_smallest_string(\\"aaaa\\") \\"aaaa\\" >>> lexicographically_smallest_string(\\"\\") \\"\\" >>> lexicographically_smallest_string(\\"a\\") \\"a\\" >>> lexicographically_smallest_string(\\"z\\") \\"z\\"","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be obtained by moving characters to the end of the string. return ''.join(sorted(s))"},{"question":"def length_of_longest_substring_k_distinct(s: str, k: int) -> int: Find the length of the longest substring of \`s\` that contains at most \`k\` distinct characters. If \`k\` is zero or if the string is empty, return 0. Your solution should have a time complexity of O(n). >>> length_of_longest_substring_k_distinct(\\"\\", 0) 0 >>> length_of_longest_substring_k_distinct(\\"\\", 1) 0 >>> length_of_longest_substring_k_distinct(\\"abc\\", 0) 0 >>> length_of_longest_substring_k_distinct(\\"aaaaa\\", 1) 5 >>> length_of_longest_substring_k_distinct(\\"aaaaa\\", 2) 5 >>> length_of_longest_substring_k_distinct(\\"abcba\\", 3) 5 >>> length_of_longest_substring_k_distinct(\\"eceba\\", 2) 3 >>> length_of_longest_substring_k_distinct(\\"aa\\", 1) 2 >>> length_of_longest_substring_k_distinct(\\"aabbcc\\", 2) 4 >>> length_of_longest_substring_k_distinct(\\"aabbcc\\", 1) 2 >>> length_of_longest_substring_k_distinct(\\"aabbcc\\", 10) 6","solution":"def length_of_longest_substring_k_distinct(s, k): if k == 0 or not s: return 0 char_frequency = {} left = 0 max_length = 0 for right in range(len(s)): right_char = s[right] if right_char not in char_frequency: char_frequency[right_char] = 0 char_frequency[right_char] += 1 while len(char_frequency) > k: left_char = s[left] char_frequency[left_char] -= 1 if char_frequency[left_char] == 0: del char_frequency[left_char] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def subarray_sum(nums: List[int], target: int) -> int: Returns the number of contiguous subarrays that have a sum equal to a given integer target. >>> subarray_sum([1, 2, 3], 7) == 0 >>> subarray_sum([5], 5) == 1 >>> subarray_sum([1, -1, 2, -2], 0) == 3 >>> subarray_sum([1, 1, 1], 2) == 2 >>> subarray_sum([-1, -1, 1], 0) == 1 >>> subarray_sum([0, 0, 0, 0], 0) == 10 >>> subarray_sum([1, 2, 3, 4, 5], 15) == 1 >>> subarray_sum([1]*1000, 5) == 996","solution":"def subarray_sum(nums, target): Returns the number of contiguous subarrays that have a sum equal to the given target. :param nums: List[int] - The input array of integers :param target: int - The sum that each contiguous subarray should equal to :return: int - The number of contiguous subarrays that sum up to the target count = 0 sum_so_far = 0 hashmap = {0: 1} for num in nums: sum_so_far += num if sum_so_far - target in hashmap: count += hashmap[sum_so_far - target] if sum_so_far in hashmap: hashmap[sum_so_far] += 1 else: hashmap[sum_so_far] = 1 return count"},{"question":"from typing import List def find_longest_word(s: str, dict: List[str]) -> str: Find the longest string in \`dict\` that can be formed by deleting some characters of the given string \`s\` without reordering. If there are multiple results, return the longest word with the smallest lexicographical order. If there is no possible result, return an empty string. >>> find_longest_word(\\"abpcplea\\", [\\"ale\\", \\"apple\\", \\"monkey\\", \\"plea\\"]) == \\"apple\\" >>> find_longest_word(\\"abpcplea\\", [\\"a\\", \\"b\\", \\"c\\"]) == \\"a\\" >>> find_longest_word(\\"abpcplea\\", [\\"x\\", \\"y\\", \\"z\\"]) == \\"\\" >>> find_longest_word(\\"abpcplea\\", [\\"abc\\", \\"abe\\", \\"abf\\"]) == \\"abc\\" >>> find_longest_word(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) == \\"\\" >>> find_longest_word(\\"abpcplea\\", []) == \\"\\" >>> find_longest_word(\\"\\", []) == \\"\\"","solution":"def find_longest_word(s, dict): def can_form_by_deleting(word): it = iter(s) return all(char in it for char in word) # Sort by length (desc) and then lexicographical order (asc) dict.sort(key=lambda x: (-len(x), x)) for word in dict: if can_form_by_deleting(word): return word return \\"\\""},{"question":"def min_changes_to_make_divisible(s: str, d: int) -> int: Determine the minimum number of changes required to make the string of digits \`s\` divisible by \`d\`. Parameters: - s: str, input string consisting of digits. - d: int, a non-negative integer. Returns: - int, minimum number of changes required. >>> min_changes_to_make_divisible(\\"123\\", 3) 0 >>> min_changes_to_make_divisible(\\"124\\", 3) 1 >>> min_changes_to_make_divisible(\\"528\\", 5) 1 >>> min_changes_to_make_divisible(\\"100\\", 4) 0 >>> min_changes_to_make_divisible(\\"99\\", 7) 1","solution":"def min_changes_to_make_divisible(s, d): Determine the minimum number of changes required to make the string of digits \`s\` divisible by \`d\`. Parameters: - s: str, input string consisting of digits. - d: int, a non-negative integer. Returns: - int, minimum number of changes required. num = int(s) if num % d == 0: return 0 min_changes = len(s) for i in range(len(s)): original_digit = s[i] for new_digit in '0123456789': if new_digit != original_digit: new_s = s[:i] + new_digit + s[i+1:] if int(new_s) % d == 0: min_changes = min(min_changes, 1) return min_changes"},{"question":"def min_difference(tasks: List[int]) -> int: Returns the minimum difference possible after distributing all the tasks between the two servers. >>> min_difference([1, 2, 3, 4, 5]) 1 >>> min_difference([1, 2, 3, 7]) 1 >>> min_difference([10]) 10 >>> min_difference([5, 5]) 0 >>> min_difference([10, 20, 10, 5, 5]) 0","solution":"def min_difference(tasks): Returns the minimum difference possible after distributing all the tasks between the two servers. total_sum = sum(tasks) n = len(tasks) half_sum = total_sum // 2 dp = [[False] * (half_sum + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(half_sum + 1): dp[i][j] = dp[i-1][j] if j >= tasks[i-1]: dp[i][j] = dp[i][j] or dp[i-1][j-tasks[i-1]] for j in range(half_sum, -1, -1): if dp[n][j]: return total_sum - 2 * j"},{"question":"def is_palindrome_permutation(s: str) -> bool: Determines if the given string is a permutation of a palindrome. >>> is_palindrome_permutation('') == True >>> is_palindrome_permutation('a') == True >>> is_palindrome_permutation('taco cat') == True >>> is_palindrome_permutation('atco cta') == True >>> is_palindrome_permutation('Able was I ere I saw Elba') == True >>> is_palindrome_permutation('random') == False >>> is_palindrome_permutation('Tact Coa') == True >>> is_palindrome_permutation('!!??!!') == True >>> is_palindrome_permutation('racecar') == True >>> is_palindrome_permutation('abbaaccd') == False pass","solution":"def is_palindrome_permutation(s): Determines if the given string is a permutation of a palindrome. Parameters: s (str): The input string. Returns: bool: True if the string is a permutation of a palindrome, False otherwise. from collections import Counter # Remove non-alphanumeric characters and convert to lowercase. cleaned_str = ''.join(filter(str.isalnum, s)).lower() # Count frequency of each character. char_count = Counter(cleaned_str) # Check the number of characters with odd counts. odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # At most one character with an odd count is allowed for a permutation of a palindrome. return odd_count <= 1"},{"question":"def minCostClimbingStairs(nums: List[int]) -> int: Returns the minimum cost to reach the top of the floor. Args: nums: A list of integers representing the cost of climbing stairs. Returns: An integer representing the minimum cost to reach the top. >>> minCostClimbingStairs([10, 15, 20]) == 15 >>> minCostClimbingStairs([]) == 0 >>> minCostClimbingStairs([10]) == 10 >>> minCostClimbingStairs([10, 15]) == 10 >>> minCostClimbingStairs([10, 10, 10, 10]) == 20 >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1]) == 6","solution":"def minCostClimbingStairs(nums): Returns the minimum cost to reach the top of the floor. Args: nums: A list of integers representing the cost of climbing stairs. Returns: An integer representing the minimum cost to reach the top. n = len(nums) if n == 0: return 0 if n == 1: return nums[0] dp = [0] * n dp[0] = nums[0] dp[1] = nums[1] for i in range(2, n): dp[i] = min(dp[i-1], dp[i-2]) + nums[i] return min(dp[-1], dp[-2])"},{"question":"def single_number(nums: List[int]) -> int: Function to find the single integer in the array where every other integer appears exactly three times. Parameters: nums (list of int): The array of integers. Returns: int: The single integer that appears only once. >>> single_number([2, 2, 3, 2]) 3 >>> single_number([0, 1, 0, 1, 0, 1, 99]) 99 >>> single_number([1, 2, 2, 2]) 1 >>> single_number([-2, -2, 1, 1, -2, 1, -3]) -3 >>> single_number([30000, 500, 100, 30000, 100, 30000, 100]) 500 >>> single_number([3, 3, 3, -9]) -9 pass","solution":"def single_number(nums): Function to find the single integer in the array where every other integer appears exactly three times. Parameters: nums (list of int): The array of integers. Returns: int: The single integer that appears only once. ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bstFromPreorderInorderTraversal(preorder): Given an integer \`n\` representing the number of nodes in a binary search tree (BST) and an array \`preorder\` of length \`n\` containing the preorder traversal of the BST, construct the BST and return the inorder traversal of its nodes' values. >>> bstFromPreorderInorderTraversal([]) == [] >>> bstFromPreorderInorderTraversal([5]) == [5] >>> bstFromPreorderInorderTraversal([5, 3]) == [3, 5] >>> bstFromPreorderInorderTraversal([5, 3, 7]) == [3, 5, 7] >>> bstFromPreorderInorderTraversal([8, 5, 1, 7, 10, 12]) == [1, 5, 7, 8, 10, 12] >>> bstFromPreorderInorderTraversal([8, 3, 1, 6, 4, 7, 10, 14, 13]) == [1, 3, 4, 6, 7, 8, 10, 13, 14]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bstFromPreorder(preorder): if not preorder: return None def buildBST(preorder, lower, upper): if not preorder or preorder[0] < lower or preorder[0] > upper: return None value = preorder.pop(0) root = TreeNode(value) root.left = buildBST(preorder, lower, value) root.right = buildBST(preorder, value, upper) return root return buildBST(preorder, float('-inf'), float('inf')) def inorderTraversal(root): if not root: return [] return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right) def bstFromPreorderInorderTraversal(preorder): root = bstFromPreorder(preorder[:]) return inorderTraversal(root)"},{"question":"def replace_words(s: str, dictionary: [str]) -> str: Replace words in string s that match any word in dictionary with the word surrounded by asterisks (*). The case is ignored during matching. Parameters: s (str): The input string. dictionary ([str]): List of words to be replaced. Returns: str: The resulting string after replacements. Examples: >>> replace_words(\\"Hello world\\", [\\"world\\"]) \\"Hello *world*\\" >>> replace_words(\\"Hello World\\", [\\"world\\"]) \\"Hello *World*\\" >>> replace_words(\\"The quick brown fox jumps over the lazy dog\\", [\\"the\\", \\"quick\\", \\"dog\\"]) \\"*The* *quick* brown fox jumps over *the* lazy *dog*\\" >>> replace_words(\\"Hello everyone\\", [\\"world\\"]) \\"Hello everyone\\" >>> replace_words(\\"Hello world\\", [\\"hello\\", \\"world\\"]) \\"*Hello* *world*\\" >>> replace_words(\\"\\", [\\"world\\"]) \\"\\" >>> replace_words(\\"Hello world\\", []) \\"Hello world\\" >>> replace_words(\\"Hello, world!\\", [\\"hello\\", \\"world\\"]) \\"Hello, world!\\"","solution":"def replace_words(s, dictionary): Replace words in string s that match any word in dictionary with the word surrounded by asterisks (*). The case is ignored during matching. Parameters: s (str): The input string. dictionary ([str]): List of words to be replaced. Returns: str: The resulting string after replacements. words = s.split() lower_dictionary = {word.lower() for word in dictionary} for i in range(len(words)): if words[i].lower() in lower_dictionary: words[i] = '*' + words[i] + '*' return ' '.join(words)"},{"question":"from typing import List def min_total_distance(nums: List[int], k: int) -> int: Given a list of integers \`nums\` representing the position of houses along a street and an integer \`k\` representing the number of mailboxes to be placed, return the minimum total distance between the houses and the mailboxes. The distance between the house at position \`i\` and the mailbox at position \`j\` is \`|i - j|\`. The houses can share the same mailbox. >>> min_total_distance([1, 2, 3], 1) 2 >>> min_total_distance([1, 5, 9], 1) 8 >>> min_total_distance([1, 2, 3], 2) 1 >>> min_total_distance([1, 5, 9], 2) 4 >>> min_total_distance([1, 2, 3], 3) 0 >>> min_total_distance([1, 5, 9], 3) 0 >>> min_total_distance([1, 2, 3], 4) 0 >>> min_total_distance([1, 5, 9], 5) 0","solution":"def min_total_distance(nums, k): This function returns the minimum total distance between the houses and the mailboxes. Parameters: nums (list): A list of integers representing the position of houses along a street. k (int): An integer representing the number of mailboxes to be placed. Returns: int: The minimum total distance between the houses and the mailboxes. nums.sort() n = len(nums) # Edge case: if number of mailboxes is more or equal to the number of houses if k >= n: return 0 # DP array to store result for subproblems dp = [[float('inf')] * (k+1) for _ in range(n+1)] dp[0][0] = 0 # Cost is the distance for all houses within each mailbox range def compute_cost(l, r): mid = (l + r) // 2 cost = 0 for i in range(l, r+1): cost += abs(nums[i] - nums[mid]) return cost for i in range(1, n+1): for j in range(1, k+1): for p in range(i): dp[i][j] = min(dp[i][j], dp[p][j-1] + compute_cost(p, i-1)) return dp[n][k]"},{"question":"def highest_avg_salary_department() -> str: SQL query to find the DepartmentId with the highest average salary. Returns the DepartmentId with the highest average salary. >>> query = highest_avg_salary_department() >>> expected_query = ''' SELECT DepartmentId FROM Employees GROUP BY DepartmentId HAVING AVG(Salary) = ( SELECT MAX(avg_salary) FROM ( SELECT AVG(Salary) as avg_salary FROM Employees GROUP BY DepartmentId ) AS avg_salaries ) ''' >>> assert query.strip() == expected_query.strip() pass","solution":"def highest_avg_salary_department(): SQL query to find the DepartmentId with the highest average salary. Returns the DepartmentId with the highest average salary. query = SELECT DepartmentId FROM Employees GROUP BY DepartmentId HAVING AVG(Salary) = ( SELECT MAX(avg_salary) FROM ( SELECT AVG(Salary) as avg_salary FROM Employees GROUP BY DepartmentId ) AS avg_salaries ) return query"},{"question":"def longest_path(nums: List[int]) -> int: Returns the length of the longest path where the absolute difference between consecutive elements is at most one. :param nums: List[int] - Array of unique integers :return: int - Length of the longest valid path >>> longest_path([]) == 0 >>> longest_path([1]) == 1 >>> longest_path([1, 2]) == 2 >>> longest_path([1, 3]) == 1 >>> longest_path([1, 2, 3, 4, 5]) == 5 >>> longest_path([1, 2, 3, 5, 6, 7]) == 3 >>> longest_path([5, 1, 2, 3]) == 3 >>> longest_path([10, 20, 30, 40, 50]) == 1 >>> longest_path([1, 4, 2, 3, 5]) == 5 pass","solution":"def longest_path(nums): Returns the length of the longest path where the absolute difference between consecutive elements is at most one. :param nums: List[int] - Array of unique integers :return: int - Length of the longest valid path if not nums: return 0 nums.sort() max_length = 1 current_length = 1 for i in range(1, len(nums)): if abs(nums[i] - nums[i-1]) <= 1: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def min_operations_to_divisible(arr: List[int], k: int) -> int: Returns the minimum number of operations required to make all elements of the array divisible by k. >>> min_operations_to_divisible([6, 12, 18], 6) 0 >>> min_operations_to_divisible([1, 2, 3], 3) 2 >>> min_operations_to_divisible([2, 5, 8], 3) 3 >>> min_operations_to_divisible([100, 200, 300], 100) 0 >>> min_operations_to_divisible([1, 2, 3], 1) 0","solution":"def min_operations_to_divisible(arr, k): Returns the minimum number of operations required to make all elements of the array divisible by k. total_operations = 0 # For each element in the array, calculate the remainder when divided by k. for num in arr: remainder = num % k # Calculate the minimum of the remainder and k - remainder. # This gives the minimum number of increments or decrements needed for divisibility. total_operations += min(remainder, k - remainder) return total_operations"},{"question":"def findMissingNumber(nums): Finds the missing number in a continuous sequence of unique integers. Args: nums (list of int): List of integers with one missing number. Returns: int: The missing number in the sequence. def test_find_missing_number(): # Test case where the missing number is 5. nums = [1, 2, 3, 4, 6, 7, 8, 9, 10] assert findMissingNumber(nums) == 5 # Test case where the missing number is 1. nums = [2, 3, 4, 5] assert findMissingNumber(nums) == 1 # Test case where the missing number is 10. nums = [1, 2, 3, 4, 5, 6, 7, 8, 9] assert findMissingNumber(nums) == 10 # Test case where the missing number is 7. nums = [1, 2, 3, 4, 5, 6, 8, 9, 10] assert findMissingNumber(nums) == 7 # Test case where the missing number is 4. nums = [1, 2, 3, 5, 6, 7, 8, 9, 10] assert findMissingNumber(nums) == 4 # Test case where the missing number is 3. nums = [1, 2, 4, 5, 6] assert findMissingNumber(nums) == 3","solution":"def findMissingNumber(nums): Finds the missing number in a continuous sequence of unique integers. Args: nums (list of int): List of integers with one missing number. Returns: int: The missing number in the sequence. n = len(nums) + 1 total_sum = n * (n + 1) // 2 actual_sum = sum(nums) return total_sum - actual_sum"},{"question":"def smallest_substring_max_distinct(s: str) -> int: Given a string \`s\`, find the length of the smallest substring that contains the maximum number of distinct characters. >>> smallest_substring_max_distinct(\\"\\") == 0 >>> smallest_substring_max_distinct(\\"a\\") == 1 >>> smallest_substring_max_distinct(\\"ab\\") == 2 >>> smallest_substring_max_distinct(\\"aaaa\\") == 1 >>> smallest_substring_max_distinct(\\"abcabcbb\\") == 3 >>> smallest_substring_max_distinct(\\"aabcbcdbca\\") == 4 >>> smallest_substring_max_distinct(\\"abcdef\\") == 6 >>> smallest_substring_max_distinct(\\"aaaabcdefaaa\\") == 6","solution":"def smallest_substring_max_distinct(s): Returns the length of the smallest substring that contains the maximum number of distinct characters. if not s: return 0 max_distinct_chars = len(set(s)) n = len(s) min_len = n + 1 for i in range(n): seen_chars = set() for j in range(i, n): seen_chars.add(s[j]) if len(seen_chars) == max_distinct_chars: min_len = min(min_len, j - i + 1) break return min_len"},{"question":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: Given a grid of size \`m x n\`, where each cell contains a positive integer representing its height, return the minimum sum of heights you can accumulate along a path from the top-left to the bottom-right cell. You can only move either down or right at any point in time. >>> min_path_sum([[1, 2], [1, 1]]) 3 >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_sum([[5]]) 5 >>> min_path_sum([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 5 >>> min_path_sum([]) -1 >>> min_path_sum([[]]) -1","solution":"def min_path_sum(grid): if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) # Create a 2D dp array to store the minimum path sum to reach each cell dp = [[float('inf')] * n for _ in range(m)] dp[0][0] = grid[0][0] # Fill the dp array for i in range(m): for j in range(n): if i > 0: dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j]) if j > 0: dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j]) min_sum = dp[-1][-1] return min_sum if min_sum < float('inf') else -1"},{"question":"def max_reachable_nodes(n, edges, restricted): Returns the maximum number of nodes that can be reached from node 0 without visiting any restricted nodes. pass # Unit Test Cases def test_max_reachable_nodes_no_restriction(): n = 5 edges = [[0, 1], [0, 2], [1, 3], [2, 4]] restricted = [] assert max_reachable_nodes(n, edges, restricted) == 5 def test_max_reachable_nodes_with_restriction(): n = 5 edges = [[0, 1], [0, 2], [1, 3], [2, 4]] restricted = [3] assert max_reachable_nodes(n, edges, restricted) == 4 def test_max_reachable_nodes_with_multiple_restrictions(): n = 7 edges = [[0, 1], [0, 2], [1, 3], [2, 4], [3, 5], [4, 6]] restricted = [3, 4] assert max_reachable_nodes(n, edges, restricted) == 3 def test_max_reachable_nodes_disconnected_graph(): n = 6 edges = [[0, 1], [0, 2], [3, 4], [4, 5]] restricted = [3] assert max_reachable_nodes(n, edges, restricted) == 3 def test_max_reachable_nodes_start_is_restricted(): n = 3 edges = [[0, 1], [1, 2]] restricted = [0] assert max_reachable_nodes(n, edges, restricted) == 0","solution":"from collections import defaultdict, deque def max_reachable_nodes(n, edges, restricted): Returns the maximum number of nodes that can be reached from node 0 without visiting any restricted nodes. graph = defaultdict(list) restricted_set = set(restricted) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() to_visit = deque([0]) reachable_count = 0 while to_visit: node = to_visit.popleft() if node in visited or node in restricted_set: continue visited.add(node) reachable_count += 1 for neighbor in graph[node]: if neighbor not in visited and neighbor not in restricted_set: to_visit.append(neighbor) return reachable_count"},{"question":"def evaluate_expression(s: str) -> int: Evaluates the arithmetic expression contained in the string s and returns the result. The expression can include integers and the operators '+', '-', '*', '/'. Integer division should truncate toward zero. >>> evaluate_expression(\\"2+3\\") == 5 >>> evaluate_expression(\\"5-2\\") == 3 >>> evaluate_expression(\\"3*4\\") == 12 >>> evaluate_expression(\\"10/2\\") == 5 >>> evaluate_expression(\\"2+3*4\\") == 14 >>> evaluate_expression(\\"10+5-3*2\\") == 9 >>> evaluate_expression(\\"10/3\\") == 3 >>> evaluate_expression(\\"2+3*4-6/3\\") == 12 >>> evaluate_expression(\\"10/3*3\\") == 9","solution":"def evaluate_expression(s): Evaluates the arithmetic expression contained in the string s and returns the result. The expression can include integers and the operators '+', '-', '*', '/'. Integer division should truncate toward zero. def apply_operator(operators, values): right = values.pop() left = values.pop() operator = operators.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(int(left / right)) # truncate toward zero import re tokens = re.findall(r'd+|[+/*-]', s) values = [] operators = [] precedence = {'+': 1, '-': 1, '*': 2, '/': 2} for token in tokens: if token.isdigit(): values.append(int(token)) else: while (operators and precedence[operators[-1]] >= precedence[token]): apply_operator(operators, values) operators.append(token) while operators: apply_operator(operators, values) return values[0]"},{"question":"def is_scrambled_version(query: str, words: List[str]) -> bool: Determine if the string \`query\` is a scrambled version of any of the strings in \`words\`. A scrambled version of a string can be formed by rearranging its letters. Returns \`true\` if \`query\` is a scrambled version of any word in \`words\`, otherwise returns \`false\`. >>> is_scrambled_version('god', ['dog', 'cat', 'bat']) == True >>> is_scrambled_version('god', ['cat', 'bat', 'rat']) == False >>> is_scrambled_version('', ['']) == True >>> is_scrambled_version('test', []) == False >>> is_scrambled_version('test', ['abcd', 'efgh', 'ijkl']) == False >>> is_scrambled_version('a', ['a', 'b', 'c']) == True >>> is_scrambled_version('aabb', ['aabb', 'bbaa', 'abab']) == True >>> is_scrambled_version('aabbcc', ['abcabc', 'aabbcc']) == True","solution":"def is_scrambled_version(query, words): Determines if 'query' is a scrambled version of any word in 'words'. Args: query (str): The string to check. words (list of str): The list of words to compare against. Returns: bool: True if 'query' is a scrambled version of any word in 'words', False otherwise. sorted_query = ''.join(sorted(query)) for word in words: if ''.join(sorted(word)) == sorted_query: return True return False"},{"question":"def truncate_array(arr, k): Truncate the array such that each element appears at most \`k\` times while maintaining the order of first occurrences. Parameters: arr (list of int): The input array of integers. k (int): The maximum number of occurrences for each element. Returns: list of int: The truncated array. pass # Write your implementation here # Test cases def test_truncate_array_no_repetition(): assert truncate_array([1, 2, 3, 4], 1) == [1, 2, 3, 4] def test_truncate_array_with_repetition(): assert truncate_array([1, 1, 2, 3, 3, 3, 4], 2) == [1, 1, 2, 3, 3, 4] def test_truncate_array_with_high_k(): assert truncate_array([1, 2, 2, 3, 3, 3, 4], 10) == [1, 2, 2, 3, 3, 3, 4] def test_truncate_array_with_zero_k(): assert truncate_array([1, 2, 3, 4], 0) == [] def test_truncate_array_mixed_duplicates(): assert truncate_array([1, 2, 2, 1, 1, 3, 3, 4], 2) == [1, 2, 2, 1, 3, 3, 4] def test_truncate_array_with_one_occurrence_limit(): assert truncate_array([1, 2, 2, 3, 3, 3, 4], 1) == [1, 2, 3, 4]","solution":"def truncate_array(arr, k): Truncate the array such that each element appears at most \`k\` times while maintaining the order of first occurrences. Parameters: arr (list of int): The input array of integers. k (int): The maximum number of occurrences for each element. Returns: list of int: The truncated array. from collections import defaultdict element_count = defaultdict(int) result = [] for num in arr: if element_count[num] < k: result.append(num) element_count[num] += 1 return result"},{"question":"from typing import List def remove_duplicates(arr: List[int]) -> None: Removes duplicates from the array in-place such that each unique element appears only once. The order of the elements is preserved, and remaining spaces are filled with zeros. Parameters: arr (List[int]): The input array with possible duplicates. Returns: None: The input array is modified in-place. def test_basic_case(): arr = [4, 3, 2, 4, 1, 3, 2] remove_duplicates(arr) assert arr == [4, 3, 2, 1, 0, 0, 0] def test_all_unique(): arr = [1, 2, 3, 4, 5] remove_duplicates(arr) assert arr == [1, 2, 3, 4, 5] def test_all_duplicates(): arr = [2, 2, 2, 2, 2] remove_duplicates(arr) assert arr == [2, 0, 0, 0, 0] def test_mixed(): arr = [1, 1, 2, 3, 3, 3, 4, 5, 5] remove_duplicates(arr) assert arr == [1, 2, 3, 4, 5, 0, 0, 0, 0] def test_empty_array(): arr = [] remove_duplicates(arr) assert arr == [] def test_single_element(): arr = [7] remove_duplicates(arr) assert arr == [7] def test_single_duplicate(): arr = [8, 8] remove_duplicates(arr) assert arr == [8, 0]","solution":"def remove_duplicates(arr): Removes duplicates from the array in-place such that each unique element appears only once. The order of the elements is preserved, and remaining spaces are filled with zeros. Parameters: arr (List[int]): The input array with possible duplicates. Returns: None: The input array is modified in-place. if not arr: return seen = set() write_index = 0 for num in arr: if num not in seen: seen.add(num) arr[write_index] = num write_index += 1 # Fill the rest of the array with zeros for i in range(write_index, len(arr)): arr[i] = 0"},{"question":"def max_tasks_on_time(tasks: List[int], deadlines: List[int]) -> int: Returns the maximum number of tasks that can be completed on or before their respective deadlines. Parameters: tasks (list of int): The durations of the tasks. deadlines (list of int): The respective deadlines of the tasks. Returns: int: The maximum number of tasks that can be completed on or before their respective deadlines. >>> max_tasks_on_time([1, 2, 3], [2, 4, 6]) 3 >>> max_tasks_on_time([4, 2, 1], [3, 4, 5]) 2 >>> max_tasks_on_time([3, 2, 1], [1, 1, 1]) 1 >>> max_tasks_on_time([5, 10, 15], [7, 12, 18]) 1 >>> max_tasks_on_time([2, 3, 4], [2, 5, 9]) 3 >>> max_tasks_on_time([4, 5, 2], [4, 4, 3]) 1","solution":"def max_tasks_on_time(tasks, deadlines): Returns the maximum number of tasks that can be completed on or before their respective deadlines. Parameters: tasks (list of int): The durations of the tasks. deadlines (list of int): The respective deadlines of the tasks. Returns: int: The maximum number of tasks that can be completed on or before their respective deadlines. # Combine tasks and deadlines into one list of tuples (duration, deadline) combined = list(zip(tasks, deadlines)) # Sort the combined list by deadlines, and by durations if deadlines are the same combined.sort(key=lambda x: (x[1], x[0])) current_time = 0 count = 0 for duration, deadline in combined: if current_time + duration <= deadline: current_time += duration count += 1 return count"},{"question":"def closest_pair(arr: List[int], target: int) -> List[int]: Write an algorithm that takes an integer array \`arr\` and an integer \`target\`, and returns an unique pair of integers from \`arr\` whose sum is closest to \`target\`. If there are multiple pairs with the same closest sum, return the pair with the smallest sum. If there are still multiple pairs, return the first occurring pair in the array. The result should be in the form of an integer array containing the pair of integers. >>> closest_pair([1, 3, 4, 2, -1, 5], 6) [1, 5] >>> closest_pair([10, 22, 28, 29, 30, 40], 54) [22, 30] >>> closest_pair([-1, 1, 4, 5, 3], 2) [-1, 3] >>> closest_pair([1], 2) [] >>> closest_pair([100, 200, 300, 400, 500], 600) [100, 500] >>> closest_pair([1, 60, -10, 70, -80, 85], 0) [-80, 85]","solution":"def closest_pair(arr, target): Returns a pair of integers from arr whose sum is closest to the target. if len(arr) < 2: return [] arr = list(set(arr)) # Unique values only arr.sort() closest_sum = float('inf') # Initialize with an infinitely large number result_pair = [] left, right = 0, len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if abs(target - current_sum) < abs(target - closest_sum): closest_sum = current_sum result_pair = [arr[left], arr[right]] elif abs(target - current_sum) == abs(target - closest_sum): if current_sum < closest_sum: closest_sum = current_sum result_pair = [arr[left], arr[right]] if current_sum < target: left += 1 else: right -= 1 return result_pair"},{"question":"def count_signal_pairs(heights: List[int]) -> int: Count the total number of pairs (i, j) such that a signal can be sent from building i to building j where |i - j| >= 2. Args: heights (list): List of integers representing building heights. Returns: int: Total count of valid signal pairs. >>> count_signal_pairs([4]) 0 >>> count_signal_pairs([3, 1]) 0 >>> count_signal_pairs([1, 2, 3]) 1 >>> count_signal_pairs([1, 2, 3, 4]) 3 >>> count_signal_pairs([1, 1, 1, 1, 1]) 6 >>> count_signal_pairs([5, 3, 2, 8, 7, 6]) 10 >>> count_signal_pairs([10, 11, 13, 15, 14, 12, 10, 9]) 21","solution":"def count_signal_pairs(heights): Count the total number of pairs (i, j) such that a signal can be sent from building i to building j where |i - j| >= 2. Args: heights (list): List of integers representing building heights. Returns: int: Total count of valid signal pairs. n = len(heights) if n < 3: return 0 # No pair (i, j) can exist if less than 3 buildings # For each i, the count of valid pairs (i, j) where j >= i + 2 total_pairs = 0 for i in range(n - 2): valid_pairs_for_i = n - (i + 2) total_pairs += valid_pairs_for_i return total_pairs"},{"question":"from typing import List def reorder_string(s: str, indices: List[int]) -> str: Reorder the string 's' according to the given 'indices' array. Parameters: s (str): The input string. indices (List[int]): The indices indicating the new positions of characters in 's'. Returns: str: The reordered string. pass def test_reorder_string_example(): assert reorder_string(\\"abc\\", [2, 1, 0]) == \\"cba\\" def test_reorder_string_same_position(): assert reorder_string(\\"abc\\", [0, 1, 2]) == \\"abc\\" def test_reorder_string_shuffled(): assert reorder_string(\\"aiohn\\", [3, 1, 4, 2, 0]) == \\"nihao\\" def test_reorder_string_partial(): assert reorder_string(\\"art\\", [1, 0, 2]) == \\"rat\\" def test_reorder_string_single_char(): assert reorder_string(\\"a\\", [0]) == \\"a\\" def test_reorder_string_long_string(): assert reorder_string(\\"codeleet\\", [4, 5, 6, 7, 0, 2, 1, 3]) == \\"leetcode\\"","solution":"def reorder_string(s, indices): Reorder the string 's' according to the given 'indices' array. Parameters: s (str): The input string. indices (List[int]): The indices indicating the new positions of characters in 's'. Returns: str: The reordered string. n = len(s) reordered = [''] * n for i in range(n): reordered[indices[i]] = s[i] return ''.join(reordered)"},{"question":"def substrings_with_functional_keys(text: str, functionalKeys: List[str]) -> List[str]: Returns an array of substrings that can be formed using only the functional keys. Args: text (str): The input text to be analyzed. functionalKeys (list of str): The list of functional characters. Returns: list of str: An array of substrings that can be formed using the functional keys. >>> substrings_with_functional_keys(\\"abc\\", [\\"a\\", \\"b\\", \\"c\\"]) ['abc'] >>> substrings_with_functional_keys(\\"abc\\", [\\"x\\", \\"y\\", \\"z\\"]) [] >>> substrings_with_functional_keys(\\"abcde\\", [\\"a\\", \\"b\\", \\"e\\"]) ['ab', 'e'] >>> substrings_with_functional_keys(\\"aaabbbccc\\", [\\"a\\", \\"c\\"]) ['aaa', 'ccc']","solution":"def substrings_with_functional_keys(text, functionalKeys): Returns an array of substrings that can be formed using only the functional keys. Args: text (str): The input text to be analyzed. functionalKeys (list of str): The list of functional characters. Returns: list of str: An array of substrings that can be formed using the functional keys. functional_set = set(functionalKeys) result = [] current_substring = \\"\\" for char in text: if char in functional_set: current_substring += char else: if current_substring: result.append(current_substring) current_substring = \\"\\" if current_substring: result.append(current_substring) return result"},{"question":"def merge_alternately(word1: str, word2: str) -> str: Merges two strings by alternating their characters. If one string runs out of characters, appends the remaining characters of the other string. >>> merge_alternately(\\"abc\\", \\"def\\") 'adbecf' >>> merge_alternately(\\"ab\\", \\"zxcv\\") 'azbxcv' >>> merge_alternately(\\"abcd\\", \\"xy\\") 'axbycd' >>> merge_alternately(\\"\\", \\"xyz\\") 'xyz' >>> merge_alternately(\\"abc\\", \\"\\") 'abc' >>> merge_alternately(\\"\\", \\"\\") ''","solution":"def merge_alternately(word1, word2): Merges two strings by alternating their characters. If one string runs out of characters, appends the remaining characters of the other string. merged = [] len1, len2 = len(word1), len(word2) for i in range(max(len1, len2)): if i < len1: merged.append(word1[i]) if i < len2: merged.append(word2[i]) return ''.join(merged)"},{"question":"def find_substring_indices(text: str, words: List[str]) -> List[int]: Write a function that takes two arguments: a string \`text\` and an array of words \`words\`. The function should return a list of starting indices of all substrings in \`text\` that are a concatenation of each word in \`words\` exactly once and without any intervening characters. Words in \`words\` may be repeated. The order in which the words are concatenated should be the same as in \`words\`. You may assume that \`words\` have the same length. >>> find_substring_indices(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) [0, 9] >>> find_substring_indices(\\"wordgoodgoodgoodbestword\\", [\\"word\\", \\"good\\", \\"best\\", \\"word\\"]) [] >>> find_substring_indices(\\"barfoofoobarthefoobarman\\", [\\"bar\\", \\"foo\\", \\"the\\"]) [6, 9, 12] >>> find_substring_indices(\\"lingmindraboofooowingdingbarrwingmonkeypoundcake\\", [\\"fooo\\", \\"barr\\", \\"wing\\", \\"ding\\", \\"wing\\"]) [13] >>> find_substring_indices(\\"\\", [\\"foo\\", \\"bar\\"]) [] >>> find_substring_indices(\\"foobar\\", []) [] >>> find_substring_indices(\\"foobarfoobar\\", [\\"foo\\", \\"bar\\", \\"foobar\\"]) []","solution":"def find_substring_indices(text, words): Returns a list of starting indices of all substrings in text that are a concatenation of each word in words. Args: text (str): The input string in which to search. words (List[str]): The list of words to concatenate. Returns: List[int]: The starting indices of all concatenated substrings. if not text or not words or len(words[0]) == 0: return [] word_len = len(words[0]) total_len = word_len * len(words) word_count = len(words) # Count frequency of each word in words list from collections import Counter word_freq = Counter(words) result = [] # Slide a window of size equal to the total length of all words concatenated for i in range(len(text) - total_len + 1): seen = {} j = 0 while j < word_count: # Get the current substring from the text word_start = i + j * word_len word = text[word_start:word_start + word_len] # If the word is in our list if word in word_freq: seen[word] = seen.get(word, 0) + 1 # If the word frequency exceeds expected frequency, break if seen[word] > word_freq[word]: break else: break j += 1 if seen == word_freq: result.append(i) return result"},{"question":"def max_difference_after_change(nums): Given an integer array \`nums\`, return the maximum difference you can get by changing exactly one element in the array. The difference is calculated as the maximum value of the array minus the minimum value of the array after the change. If the array has less than two elements, return \`0\`. >>> max_difference_after_change([8, 1, 2, 6, 4]) 8 >>> max_difference_after_change([1, 1, 1, 1, 1]) 0 >>> max_difference_after_change([5]) 0 >>> max_difference_after_change([1, 9]) 9 >>> max_difference_after_change([0, 0, 0, 0]) 0 >>> max_difference_after_change([4, 5, 0, 6, 7]) 9","solution":"def max_difference_after_change(nums): if len(nums) < 2: return 0 min_value = min(nums) max_value = max(nums) if min_value == max_value: return 0 potential_max_diff = max(max_value - min_value, (9 if max_value != 9 else max_value) - min_value, max_value - (0 if min_value != 0 else min_value)) return potential_max_diff"},{"question":"import collections class FrequencyStack: Design a class \`FrequencyStack\` that simulates the operations of a stack-like data structure that supports frequency-based operations. >>> fs = FrequencyStack() >>> fs.push(5) >>> fs.push(7) >>> fs.push(5) >>> fs.push(7) >>> fs.push(4) >>> fs.push(5) >>> fs.pop() 5 >>> fs.pop() 7 >>> fs.pop() 5 >>> fs.pop() 4 >>> fs_single = FrequencyStack() >>> fs_single.push(10) >>> fs_single.pop() 10 >>> fs_alternate = FrequencyStack() >>> fs_alternate.push(3) >>> fs_alternate.push(3) >>> fs_alternate.push(3) >>> fs_alternate.push(4) >>> fs_alternate.push(4) >>> fs_alternate.push(4) >>> fs_alternate.push(5) >>> fs_alternate.push(5) >>> fs_alternate.pop() 4 >>> fs_alternate.pop() 3 >>> fs_alternate.pop() 5 >>> fs_alternate.pop() 4 >>> fs_alternate.pop() 3 >>> fs_alternate.pop() 5 >>> fs_alternate.pop() 4 >>> fs_alternate.pop() 3 def __init__(self): Initializes the \`FrequencyStack\` object. pass def push(self, val: int): Pushes an integer \`val\` onto the stack. pass def pop(self) -> int: Removes and returns the most frequent element in the stack. If there is a tie for the most frequent element, the element closest to the top of the stack is removed and returned. pass","solution":"import collections class FrequencyStack: def __init__(self): self.freq = collections.Counter() self.stacks = collections.defaultdict(list) self.max_freq = 0 def push(self, val: int): self.freq[val] += 1 current_freq = self.freq[val] if current_freq > self.max_freq: self.max_freq = current_freq self.stacks[current_freq].append(val) def pop(self) -> int: val = self.stacks[self.max_freq].pop() if not self.stacks[self.max_freq]: self.max_freq -= 1 self.freq[val] -= 1 return val"},{"question":"def find_highest_peak(grid): Finds the coordinates of the highest peak in a 2D grid. Parameters: grid (List[List[int]]): 2D list representing the grid elevations. Returns: List[int]: Coordinates of the highest peak in the form [row, col]. >>> find_highest_peak([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [2, 2] >>> find_highest_peak([ ... [1, 2, 3], ... [4, 5, 5], ... [7, 5, 9] ... ]) [2, 2] >>> find_highest_peak([ ... [1, 2, 9], ... [4, 5, 9], ... [7, 8, 9] ... ]) [0, 2] >>> find_highest_peak([ ... [5] ... ]) [0, 0] >>> find_highest_peak([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) [0, 0] >>> find_highest_peak([]) [] >>> find_highest_peak([[]]) []","solution":"def find_highest_peak(grid): Finds the coordinates of the highest peak in a 2D grid. Parameters: grid (List[List[int]]): 2D list representing the grid elevations. Returns: List[int]: Coordinates of the highest peak in the form [row, col]. if not grid or not grid[0]: return [] m, n = len(grid), len(grid[0]) highest_peak = float('-inf') highest_coords = [] for r in range(m): for c in range(n): if grid[r][c] > highest_peak: highest_peak = grid[r][c] highest_coords = [r, c] elif grid[r][c] == highest_peak: continue return highest_coords"},{"question":"def minSessions(tasks, sessionTime): Calculate the minimum number of work sessions required to complete all the tasks. >>> minSessions([1, 2, 3], 3) 2 >>> minSessions([3, 1, 3, 1, 1], 8) 2 >>> minSessions([1, 2, 3, 4, 5], 15) 1 >>> minSessions([1, 1, 1, 1, 1, 1, 1, 1], 3) 3 >>> minSessions([10, 10, 10], 10) 3 >>> minSessions([2, 3, 1, 5, 2], 5) 3 >>> minSessions([4, 4, 4], 3) 3 >>> minSessions([], 5) 0 >>> minSessions([5], 5) 1 >>> minSessions([2, 2, 2, 2, 2], 4) 3","solution":"def minSessions(tasks, sessionTime): def dfs(index, sessions): if index == len(tasks): return len(sessions) min_sessions = float('inf') for i in range(len(sessions)): if sessions[i] + tasks[index] <= sessionTime: sessions[i] += tasks[index] min_sessions = min(min_sessions, dfs(index + 1, sessions)) sessions[i] -= tasks[index] sessions.append(tasks[index]) min_sessions = min(min_sessions, dfs(index + 1, sessions)) sessions.pop() return min_sessions tasks.sort(reverse=True) return dfs(0, [])"},{"question":"def common_elements(matrix): Finds all elements present in every row of the matrix in increasing order. :param matrix: List of lists where each list represents a row in the matrix. :return: List of common elements sorted in ascending order. >>> common_elements([[1, 2, 3, 4, 5], [2, 4, 5, 8, 10], [3, 5, 7, 9, 11], [1, 3, 5, 7, 9]]) [5] >>> common_elements([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [] >>> common_elements([[1], [1], [1]]) [1] >>> common_elements([[1, 2, 3], [2, 3, 4], [2, 3, 5]]) [2, 3] >>> common_elements([]) [] >>> common_elements([[1, 2, 3, 4, 5]]) [1, 2, 3, 4, 5] >>> common_elements([[1, 2, 3], [1, 2, 3], [1, 2, 3]]) [1, 2, 3]","solution":"def common_elements(matrix): Finds all elements present in every row of the matrix in increasing order. :param matrix: List of lists where each list represents a row in the matrix. :return: List of common elements sorted in ascending order. if not matrix: return [] common_set = set(matrix[0]) for row in matrix[1:]: common_set &= set(row) return sorted(common_set)"},{"question":"def length_of_last_word(s: str) -> int: Write a function that takes a string \`s\` as input, where \`s\` consists of words separated by spaces. The function should return the length of the last word in the string. If the last word does not exist, return 0. A word is defined as a contiguous sequence of non-space characters. Example: >>> length_of_last_word(\\"Hello\\") 5 >>> length_of_last_word(\\"Hello World\\") 5 >>> length_of_last_word(\\"Hello World \\") 5 >>> length_of_last_word(\\"Hello World\\") 5 >>> length_of_last_word(\\"\\") 0 >>> length_of_last_word(\\" \\") 0 >>> length_of_last_word(\\"a\\") 1 >>> length_of_last_word(\\"hello! world!\\") 6 >>> length_of_last_word(\\" \\") 0","solution":"def length_of_last_word(s): Returns the length of the last word in the string s. If the last word does not exist, returns 0. words = s.strip().split() if not words: return 0 return len(words[-1])"},{"question":"def minEatingSpeed(nums: List[int], h: int) -> int: Determines the minimum integer k such that all bananas from piles in nums can be eaten in h hours. >>> minEatingSpeed([3, 6, 7, 11], 8) 4 >>> minEatingSpeed([30, 11, 23, 4, 20], 5) 30 >>> minEatingSpeed([1, 1, 1, 1], 4) 1 >>> minEatingSpeed([100], 10) 10 >>> minEatingSpeed([1, 2, 3, 4], 4) 4","solution":"def minEatingSpeed(nums, h): Determines the minimum integer k such that all bananas from piles in nums can be eaten in h hours. def canFinish(k): hours_needed = 0 for pile in nums: hours_needed += -(-pile // k) # This is the same as math.ceil(pile / k) return hours_needed <= h left, right = 1, max(nums) while left < right: mid = (left + right) // 2 if canFinish(mid): right = mid else: left = mid + 1 return left"},{"question":"def is_magic_square(matrix: List[List[int]]) -> bool: Determine whether an \`n x n\` matrix is a magic square. A magic square is defined as a square matrix in which the sums of the numbers in each row, each column, and both main diagonals are all the same. Args: matrix (List[List[int]]): A two-dimensional list of integers. Returns: bool: True if the matrix is a magic square, False otherwise. >>> is_magic_square([ ... [2, 7, 6], ... [9, 5, 1], ... [4, 3, 8] ... ]) True >>> is_magic_square([ ... [2, 7, 5], ... [9, 5, 1], ... [4, 3, 8] ... ]) False >>> is_magic_square([[]]) False >>> is_magic_square([[1]]) True >>> is_magic_square([ ... [16, 23, 17, 8], ... [5, 10, 11, 26], ... [19, 12, 13, 6], ... [4, 1, 20, 25] ... ]) False","solution":"def is_magic_square(matrix): n = len(matrix) if n == 0: return False # Calculate the sum of the first row target_sum = sum(matrix[0]) # Check the sums of all rows for row in matrix: if sum(row) != target_sum: return False # Check the sums of all columns for col in range(n): if sum(matrix[row][col] for row in range(n)) != target_sum: return False # Check the sum of the main diagonal if sum(matrix[i][i] for i in range(n)) != target_sum: return False # Check the sum of the anti-diagonal if sum(matrix[i][n - 1 - i] for i in range(n)) != target_sum: return False return True"},{"question":"class ArrayPermutation: ArrayPermutation class to handle permutation array operations. Methods: - __init__(self, nums): Initializes the permutation array. - swap(self, i, j): Swaps elements at indices i and j. - find(self, target): Finds the index of the target element. - isSorted(self): Checks if the array is sorted. Example: >>> arr_perm = ArrayPermutation([3, 1, 2, 0]) >>> arr_perm.swap(0, 3) >>> arr_perm.nums [0, 1, 2, 3] >>> arr_perm.find(2) 2 >>> arr_perm.find(4) -1 >>> arr_perm.isSorted() False >>> arr_perm = ArrayPermutation([0, 1, 2, 3]) >>> arr_perm.isSorted() True def __init__(self, nums): self.nums = nums def swap(self, i, j): pass # Swap elements at indices i and j def find(self, target): pass # Find and return the index of target def isSorted(self): pass # Check if the array is sorted def test_initialization(): nums = [3, 1, 2, 0] arr_perm = ArrayPermutation(nums) assert arr_perm.nums == nums def test_swap(): nums = [3, 1, 2, 0] arr_perm = ArrayPermutation(nums) arr_perm.swap(0, 3) assert arr_perm.nums == [0, 1, 2, 3] def test_find_existing_element(): nums = [3, 1, 2, 0] arr_perm = ArrayPermutation(nums) assert arr_perm.find(2) == 2 assert arr_perm.find(0) == 3 def test_find_non_existing_element(): nums = [3, 1, 2, 0] arr_perm = ArrayPermutation(nums) assert arr_perm.find(4) == -1 def test_isSorted_true(): nums = [0, 1, 2, 3] arr_perm = ArrayPermutation(nums) assert arr_perm.isSorted() == True def test_isSorted_false(): nums = [3, 1, 2, 0] arr_perm = ArrayPermutation(nums) assert arr_perm.isSorted() == False","solution":"class ArrayPermutation: def __init__(self, nums): self.nums = nums def swap(self, i, j): self.nums[i], self.nums[j] = self.nums[j], self.nums[i] def find(self, target): for index, num in enumerate(self.nums): if num == target: return index return -1 def isSorted(self): for i in range(len(self.nums)): if self.nums[i] != i: return False return True"},{"question":"from typing import List, Union def count_files(folders: List[Union[int, List]]) -> int: Returns the total number of files across all folders, including nested ones. >>> count_files([2, 1, 3, 4]) == 10 >>> count_files([2, [0, [3, 4], 1], 1]) == 11 >>> count_files([]) == 0 >>> count_files([[], [[]], [[], []]]) == 0 >>> count_files([0, [0, [0, [1]], 0], 0]) == 1 >>> count_files([1, [2, [3]], 4]) == 10","solution":"def count_files(folders): Returns the total number of files across all folders, including nested ones. total_files = 0 def helper(sub_folders): nonlocal total_files for item in sub_folders: if isinstance(item, list): helper(item) else: total_files += item helper(folders) return total_files"},{"question":"def longest_substring_with_two_distinct_chars(sentence: str) -> int: Returns the length of the longest substring with at most two distinct characters. Arguments: sentence: A string consisting of lowercase English letters and spaces. Returns: The length of the longest substring that contains at most two distinct characters. Examples: >>> longest_substring_with_two_distinct_chars(\\"eceba\\") 3 >>> longest_substring_with_two_distinct_chars(\\"aaaa\\") 4 >>> longest_substring_with_two_distinct_chars(\\"\\") 0 pass def test_example_case(): assert longest_substring_with_two_distinct_chars(\\"eceba\\") == 3 def test_single_character_string(): assert longest_substring_with_two_distinct_chars(\\"aaaa\\") == 4 def test_two_character_string(): assert longest_substring_with_two_distinct_chars(\\"ababab\\") == 6 def test_empty_string(): assert longest_substring_with_two_distinct_chars(\\"\\") == 0 def test_no_double_characters(): assert longest_substring_with_two_distinct_chars(\\"abcde\\") == 2 def test_multiple_long_substrings(): assert longest_substring_with_two_distinct_chars(\\"abcabcabc\\") == 2 def test_different_distinct_substrings(): assert longest_substring_with_two_distinct_chars(\\"abaccc\\") == 4","solution":"def longest_substring_with_two_distinct_chars(sentence): Returns the length of the longest substring with at most two distinct characters. if len(sentence) == 0: return 0 start = 0 max_length = 0 char_map = {} for end in range(len(sentence)): if sentence[end] not in char_map: char_map[sentence[end]] = 0 char_map[sentence[end]] += 1 while len(char_map) > 2: char_map[sentence[start]] -= 1 if char_map[sentence[start]] == 0: del char_map[sentence[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def first_missing_positive(nums): Returns the smallest positive integer that does not appear in the array. :param nums: List of integers :return: Smallest positive integer missing from the array >>> first_missing_positive([1, 2, 3]) 4 >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 1, 2, 2]) 3 >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 >>> first_missing_positive([-1, -2, -3]) 1 >>> first_missing_positive([1, 3, 4, 5, 6]) 2","solution":"def first_missing_positive(nums): Returns the smallest positive integer that does not appear in the array. :param nums: List of integers :return: Smallest positive integer missing from the array n = len(nums) # Place each number in its right place, e.g. 3 should be at index 2 (nums[2]) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: correct_index = nums[i] - 1 nums[i], nums[correct_index] = nums[correct_index], nums[i] # Find the smallest positive missing integer for i in range(n): if nums[i] != i + 1: return i + 1 # If all numbers are in place, the smallest missing positive integer is n + 1 return n + 1"},{"question":"def is_achievable(times: List[int], k: int, t: float) -> bool: Determine if there is a contiguous subarray of length k whose average processing time is less than or equal to t. :param times: List[int] - Array of request processing times. :param k: int - The length of the subarray to consider. :param t: float - The threshold for the average processing time. :return: bool - True if such a subarray exists, False otherwise. pass def test_is_achievable_subarray_less_than_threshold(): assert is_achievable([1, 2, 3, 4, 5], 3, 3) == True def test_is_achievable_no_subarray_meets_threshold(): assert is_achievable([5, 6, 7, 8, 9], 4, 5.5) == False def test_is_achievable_subarray_equal_to_threshold(): assert is_achievable([1, 2, 3, 4, 5], 2, 3.5) == True def test_is_achievable_single_element_subarray(): assert is_achievable([2, 4, 6, 8], 1, 5) == True def test_is_achievable_k_greater_than_array_length(): assert is_achievable([2, 4, 6], 4, 5) == False def test_is_achievable_subarray_with_exact_match(): assert is_achievable([1, 2, 1, 2, 1], 3, 2) == True def test_is_achievable_all_elements_same(): assert is_achievable([4, 4, 4, 4, 4], 3, 4) == True","solution":"def is_achievable(times, k, t): Determine if there is a contiguous subarray of length k whose average processing time is less than or equal to t. :param times: List[int] - Array of request processing times. :param k: int - The length of the subarray to consider. :param t: float - The threshold for the average processing time. :return: bool - True if such a subarray exists, False otherwise. n = len(times) if k > n: return False current_sum = sum(times[:k]) if current_sum / k <= t: return True for i in range(k, n): current_sum += times[i] - times[i - k] if current_sum / k <= t: return True return False"},{"question":"def max_combined_score(scores: List[int]) -> int: Returns the highest possible combined score by choosing exactly one even and one odd score. If it's not possible to select such a pair, returns -1. >>> max_combined_score([]) == -1 >>> max_combined_score([1, 3, 5]) == -1 >>> max_combined_score([2, 4, 6]) == -1 >>> max_combined_score([2, 3]) == 5 >>> max_combined_score([2, 3, 5, 8]) == 13 >>> max_combined_score([10, 30, 15, 5]) == 45 >>> max_combined_score([4, 4, 1, 1]) == 5 >>> max_combined_score([4, 4, 4, 1]) == 5 >>> max_combined_score([0, 0, 1, 1]) == 1","solution":"def max_combined_score(scores): Returns the highest possible combined score by choosing exactly one even and one odd score. If it's not possible to select such a pair, returns -1. max_even = -1 max_odd = -1 for score in scores: if score % 2 == 0: if score > max_even: max_even = score else: if score > max_odd: max_odd = score if max_even == -1 or max_odd == -1: return -1 else: return max_even + max_odd"},{"question":"def simulate_snake_game(m: int, n: int, commands: str) -> list: Simulates a simple snake game on an m x n grid following the movement commands. Args: m (int): number of rows in the grid. n (int): number of columns in the grid. commands (str): sequence of movement commands ('U', 'D', 'L', 'R'). Returns: list of tuples: positions of the snake's segments at the end of the game or [(0, 0)] if the game ends prematurely. >>> simulate_snake_game(3, 3, \\"RRDLL\\") [(0, 0), (0, 1), (0, 2), (1, 2), (1, 1), (1, 0)] >>> simulate_snake_game(3, 3, \\"RRR\\") [(0, 0)] >>> simulate_snake_game(3, 3, \\"RRDULU\\") [(0, 0)] >>> simulate_snake_game(3, 3, \\"\\") [(0, 0)] >>> simulate_snake_game(3, 3, \\"D\\") [(0, 0), (1, 0)] >>> simulate_snake_game(3, 3, \\"DULL\\") [(0, 0)] >>> simulate_snake_game(3, 3, \\"\\") [(0, 0)] pass # Write your solution here","solution":"def simulate_snake_game(m, n, commands): Simulates a simple snake game on an m x n grid following the movement commands. Args: m (int): number of rows in the grid. n (int): number of columns in the grid. commands (str): sequence of movement commands ('U', 'D', 'L', 'R'). Returns: list of tuples: positions of the snake's segments at the end of the game or [(0, 0)] if the game ends prematurely. directions = { 'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1) } snake_body = [(0, 0)] # Initial position head = (0, 0) for command in commands: if command in directions: new_head = (head[0] + directions[command][0], head[1] + directions[command][1]) # Check boundaries if new_head[0] < 0 or new_head[0] >= m or new_head[1] < 0 or new_head[1] >= n: return [(0, 0)] # Check self-collision if new_head in snake_body: return [(0, 0)] # Move the snake snake_body.append(new_head) head = new_head return snake_body"},{"question":"def partitionAndMaximizeSquareSum(n: int, k: int) -> List[int]: Partitions the number n into k non-negative integers such that the sum of their squares is maximized. >>> partitionAndMaximizeSquareSum(10, 3) in [[4, 3, 3], [3, 4, 3], [3, 3, 4]] True >>> partitionAndMaximizeSquareSum(10, 1) == [10] True >>> partitionAndMaximizeSquareSum(0, 1) == [0] True >>> partitionAndMaximizeSquareSum(0, 0) == [] True >>> partitionAndMaximizeSquareSum(4, 5) == [1, 1, 1, 1, 0] True >>> partitionAndMaximizeSquareSum(12, 3) in [[4, 4, 4]] True >>> partitionAndMaximizeSquareSum(0, 3) == [0, 0, 0] True >>> partitionAndMaximizeSquareSum(1, 1) == [1] True >>> partitionAndMaximizeSquareSum(1, 2) == [1, 0] True >>> partitionAndMaximizeSquareSum(100, 10) == [10] * 10 True","solution":"def partitionAndMaximizeSquareSum(n, k): Partitions the number n into k non-negative integers such that the sum of their squares is maximized. if k == 0: return [] # Initially distribute n as evenly as possible quotient, remainder = divmod(n, k) # Create an initial partition with the quotient distributed partition = [quotient] * k # Distribute the remainder to maximize the square sum for i in range(remainder): partition[i] += 1 return partition"},{"question":"def compile_text(s: str) -> str: Compile the final text after processing the keystrokes. :param s: string representing series of keystrokes. :return: final compiled text. pass def test_compile_text_no_backspaces(): assert compile_text(\\"abc\\") == \\"abc\\" def test_compile_text_with_backspaces(): assert compile_text(\\"ab#c\\") == \\"ac\\" def test_compile_text_with_multiple_backspaces(): assert compile_text(\\"ac\\") == \\"c\\" assert compile_text(\\"a#b#c#\\") == \\"\\" def test_compile_text_all_backspaces(): assert compile_text(\\"#\\") == \\"\\" def test_compile_text_with_consecutive_keystrokes(): assert compile_text(\\"a#b#c#d\\") == \\"d\\" assert compile_text(\\"abcdefg#\\") == \\"ad\\" assert compile_text(\\"abc#de#\\") == \\"d\\" def test_compile_text_empty_string(): assert compile_text(\\"\\") == \\"\\" def test_compile_text_no_backspaces_mixed_characters(): assert compile_text(\\"abdce\\") == \\"abdce\\"","solution":"def compile_text(s): Compiles the final text after processing keystrokes. :param s: string representing series of keystrokes. :return: final compiled text. result = [] for char in s: if char == '#': if result: result.pop() else: result.append(char) return ''.join(result)"},{"question":"def max_items_that_can_be_bought(items: List[int], budget: int) -> int: Determine the maximum number of items that can be bought without exceeding the given budget. :param items: List of integers representing the cost of items. :param budget: Integer representing the total amount of budget available. :return: Integer representing the maximum number of items that can be bought without exceeding the budget. >>> max_items_that_can_be_bought([1, 3, 2, 5, 4], 10) 4 >>> max_items_that_can_be_bought([10, 20, 30], 5) 0 >>> max_items_that_can_be_bought([2], 5) 1 >>> max_items_that_can_be_bought([10], 5) 0 >>> max_items_that_can_be_bought([3, 3, 3], 9) 3 >>> max_items_that_can_be_bought([], 10) 0 >>> max_items_that_can_be_bought([5, 7, 3], 100) 3","solution":"def max_items_that_can_be_bought(items, budget): Returns the maximum number of items that can be bought without exceeding the given budget. :param items: List of integers representing the cost of items. :param budget: Integer representing the total amount of budget available. :return: Integer representing the maximum number of items that can be bought without exceeding the budget. items.sort() total_cost = 0 count = 0 for item in items: if total_cost + item <= budget: total_cost += item count += 1 else: break return count"},{"question":"def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n matrix 90 degrees clockwise in-place. >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) == [ ... [3, 1], ... [4, 2] ... ] pass","solution":"def rotate_matrix(matrix): Rotates the given n x n matrix 90 degrees clockwise in-place. n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"def minimumEffortPath(grid: List[List[int]]) -> int: Calculate the minimum effort path from top-left to bottom-right in a grid. Args: grid (List[List[int]]): A 2D list where each element represents the elevation at that point. Returns: int: The minimum possible value of the maximum difference in elevation between consecutive cells on the path. >>> minimumEffortPath([[1, 2, 2], [3, 8, 2], [5, 3, 5]]) 2 >>> minimumEffortPath([[1]]) 0 >>> minimumEffortPath([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 0 >>> minimumEffortPath([[1, 3, 5], [2, 4, 6], [4, 6, 8]]) 2 >>> minimumEffortPath([[1, 100], [100, 1]]) 99","solution":"import heapq def minimumEffortPath(heights): Calculate the minimum effort path from top-left to bottom-right in a grid with heights. This function uses Dijkstra's algorithm with a priority queue to find the minimum effort required. m, n = len(heights), len(heights[0]) efforts = [[float('inf')] * n for _ in range(m)] efforts[0][0] = 0 heap = [(0, 0, 0)] # (effort, x, y) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while heap: effort, x, y = heapq.heappop(heap) if (x, y) == (m-1, n-1): return effort for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: new_effort = max(effort, abs(heights[nx][ny] - heights[x][y])) if new_effort < efforts[nx][ny]: efforts[nx][ny] = new_effort heapq.heappush(heap, (new_effort, nx, ny))"},{"question":"def rearrange_string(s: str) -> str: Rearranges the string such that all digits appear at the end, maintaining the relative order of both non-digit characters and digits. :param s: The input string consisting of lowercase alphabets and digits. :return: A rearranged string with all digits at the end. >>> rearrange_string(\\"a1b2c3\\") 'abc123' >>> rearrange_string(\\"abc123\\") 'abc123' >>> rearrange_string(\\"abcdef\\") 'abcdef' >>> rearrange_string(\\"1234\\") '1234' >>> rearrange_string(\\"\\") '' >>> rearrange_string(\\"a1b2c3d4e5\\") 'abcde12345' >>> rearrange_string(\\"aaa111\\") 'aaa111' >>> rearrange_string(\\"a1a1a1\\") 'aaa111'","solution":"def rearrange_string(s): Rearranges the string such that all digits appear at the end, maintaining the relative order of both non-digit characters and digits. :param s: The input string consisting of lowercase alphabets and digits. :return: A rearranged string with all digits at the end. non_digits = [] digits = [] for char in s: if char.isdigit(): digits.append(char) else: non_digits.append(char) return ''.join(non_digits) + ''.join(digits)"},{"question":"def splitArray(arr: list[int], k: int) -> int: Split the list \`arr\` into \`k\` contiguous subarrays such that the largest sum of any subarray is minimized. Args: arr (list of int): list of integers k (int): number of subarrays Returns: int: the minimum possible largest sum >>> splitArray([7, 2, 5, 10, 8], 2) == 18 >>> splitArray([1, 2, 3, 4, 5], 2) == 9 >>> splitArray([1, 4, 4], 3) == 4 >>> splitArray([1, 4, 4, 1], 4) == 4 >>> splitArray([1, 4, 4, 1], 1) == 10 >>> splitArray([1, 2, 3, 4, 5], 5) == 5","solution":"def splitArray(arr, k): Function to split the array into k contiguous subarrays such that the largest sum of any subarray is minimized. def can_split(mid): current_sum = 0 count = 1 for num in arr: if current_sum + num > mid: count += 1 current_sum = num if count > k: return False else: current_sum += num return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"def count_target_occurrences(nums: List[int], target: int) -> int: Returns the number of distinct indices such that nums[i] is equal to target. Parameters: nums (list of int): The list of integers. target (int): The target integer. Returns: int: The count of target occurrences in the list. >>> count_target_occurrences([1, 2, 3, 4], 2) 1 >>> count_target_occurrences([1, 2, 3, 4, 2, 2, 3], 2) 3 >>> count_target_occurrences([1, 3, 4, 5], 2) 0 >>> count_target_occurrences([2, 2, 2, 2], 2) 4 >>> count_target_occurrences([], 2) 0","solution":"def count_target_occurrences(nums, target): Returns the number of distinct indices such that nums[i] is equal to target. Parameters: nums (list of int): The list of integers. target (int): The target integer. Returns: int: The count of target occurrences in the list. count = 0 for num in nums: if num == target: count += 1 return count"},{"question":"def min_operations_to_equal_elements(arr) -> int: Returns the minimum number of operations needed to make all elements in the array equal. An operation is defined as choosing indices \`i\` and \`j\` such that \`arr[i] != arr[j]\` and setting either \`arr[i]\` to \`arr[j]\` or \`arr[j]\` to \`arr[i]\`. >>> min_operations_to_equal_elements([1, 1, 1]) 0 >>> min_operations_to_equal_elements([1, 2]) 1 >>> min_operations_to_equal_elements([5, 5, 5, 5, 5]) 0 >>> min_operations_to_equal_elements([4, 3, 4, 3, 4]) 2 >>> min_operations_to_equal_elements([3, 3, 3, 3, 1, 1]) 2 >>> min_operations_to_equal_elements([7]) 0 >>> min_operations_to_equal_elements([1, 2, 3, 4, 5, 6, 7, 8, 8]) 7","solution":"def min_operations_to_equal_elements(arr): Returns the minimum number of operations needed to make all elements in the array equal. An operation is defined as choosing indices \`i\` and \`j\` such that \`arr[i] != arr[j]\` and setting either \`arr[i]\` to \`arr[j]\` or \`arr[j]\` to \`arr[i]\`. from collections import Counter frequency = Counter(arr) max_frequency = max(frequency.values()) return len(arr) - max_frequency"},{"question":"def find_pair_with_sum(nums, target): Returns True if there are two numbers in \`nums\` that add up to \`target\`, otherwise returns False. :param nums: List of unique integers :param target: The target sum :return: Boolean indicating if there is a pair that sums to target >>> find_pair_with_sum([2, 7, 11, 15], 9) == True >>> find_pair_with_sum([1, 2, 3, 4], 8) == False >>> find_pair_with_sum([5], 10) == False >>> find_pair_with_sum([-1, 3, 4, 2], 1) == True >>> find_pair_with_sum([5, 75, 25], 100) == True >>> find_pair_with_sum([10**6, 10**6 + 1], 2000001) == True","solution":"def find_pair_with_sum(nums, target): Returns True if there are two numbers in \`nums\` that add up to \`target\`, otherwise returns False. :param nums: List of unique integers :param target: The target sum :return: Boolean indicating if there is a pair that sums to target seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"def min_keep_operations(s: str) -> int: Returns the minimum number of \\"keep\\" operations needed to remove the entire string. >>> min_keep_operations('') 0 >>> min_keep_operations('a') 1 >>> min_keep_operations('aaaa') 1 >>> min_keep_operations('abcd') 4 >>> min_keep_operations('aabbcc') 3 >>> min_keep_operations('ababab') 6 >>> min_keep_operations('abcabcabc') 9 >>> min_keep_operations('aaabbbccc') 3","solution":"def min_keep_operations(s): Returns the minimum number of \\"keep\\" operations needed to remove the entire string. if not s: return 0 operations = 1 for i in range(1, len(s)): if s[i] != s[i - 1]: operations += 1 return operations"},{"question":"def rob_houses(arr: List[int]) -> int: Given an array of integers where each element represents the amount of money in a house, return the maximum amount of money the thieves can rob without robbing two adjacent houses. >>> rob_houses([]) == 0 >>> rob_houses([5]) == 5 >>> rob_houses([5, 3]) == 5 >>> rob_houses([2, 7, 9]) == 11 >>> rob_houses([2, 7, 9, 3, 1]) == 12 >>> rob_houses([1, 2, 3, 1]) == 4 >>> rob_houses([2, 1, 1, 2]) == 4","solution":"def rob_houses(arr): Given an array of integers where each element represents the amount of money in a house, return the maximum amount of money the thieves can rob without robbing two adjacent houses. if not arr: return 0 if len(arr) == 1: return arr[0] max_money = [0] * len(arr) max_money[0] = arr[0] max_money[1] = max(arr[0], arr[1]) for i in range(2, len(arr)): max_money[i] = max(max_money[i-1], arr[i] + max_money[i-2]) return max_money[-1]"},{"question":"def find_subarray_with_given_sum(arr, target): Returns the first continuous subarray of \`arr\` that sums up to \`target\`. If no such subarray is found, returns an empty array. >>> find_subarray_with_given_sum([1, 2, 3], 10) == [] >>> find_subarray_with_given_sum([1, 2, 3], 2) == [2] >>> find_subarray_with_given_sum([1, 2, 3, 4, 5], 15) == [1, 2, 3, 4, 5] >>> find_subarray_with_given_sum([1, 2, 3, 7, 5], 12) == [2, 3, 7] >>> find_subarray_with_given_sum([1, 2, 3, 4, 5, 4], 9) == [2, 3, 4] >>> find_subarray_with_given_sum([1, 2, 3, 4], 3) == [1, 2] >>> find_subarray_with_given_sum([1, 2, 3, 4], 7) == [3, 4]","solution":"def find_subarray_with_given_sum(arr, target): Returns the first continuous subarray of \`arr\` that sums up to \`target\`. If no such subarray is found, returns an empty array. current_sum = 0 start_index = 0 subarray_dict = {} for end_index in range(len(arr)): current_sum += arr[end_index] # Check if the current sum is the target if current_sum == target: return arr[start_index:end_index + 1] # If the current sum minus target exists in the dictionary, we have found a subarray if (current_sum - target) in subarray_dict: start_index = subarray_dict[current_sum - target] + 1 return arr[start_index:end_index + 1] # Store the current sum with its corresponding index subarray_dict[current_sum] = end_index return []"},{"question":"class SubstringCalculator: def __init__(self, s: str): Initializes the object with the string s. self.s = s def longestSubstringWithTwoDistinctChars(self) -> int: Returns the length of the longest substring that contains at most two distinct characters. >>> calculator = SubstringCalculator(\\"eceba\\") >>> calculator.longestSubstringWithTwoDistinctChars() 3 >>> calculator = SubstringCalculator(\\"ccaabbb\\") >>> calculator.longestSubstringWithTwoDistinctChars() 5","solution":"class SubstringCalculator: def __init__(self, s): self.s = s def longestSubstringWithTwoDistinctChars(self): Returns the length of the longest substring that contains at most two distinct characters. n = len(self.s) if n < 3: return n left = 0 right = 0 max_len = 2 hashmap = {} while right < n: if len(hashmap) < 3: hashmap[self.s[right]] = right right += 1 if len(hashmap) == 3: del_idx = min(hashmap.values()) del hashmap[self.s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"from typing import List def min_operations_to_equalize_mountains(peaks: List[int]) -> int: Returns the minimum number of operations needed to make all the mountains the same height. Args: peaks (list of int): A list of integers representing the heights of the mountains. Returns: int: The minimum number of operations required. >>> min_operations_to_equalize_mountains([5, 3, 1]) 6 >>> min_operations_to_equalize_mountains([4, 4, 4, 4]) 0 pass def test_all_same_height(): assert min_operations_to_equalize_mountains([5, 5, 5]) == 0 def test_single_mountain(): assert min_operations_to_equalize_mountains([7]) == 0 def test_two_mountains(): assert min_operations_to_equalize_mountains([5, 3]) == 2 assert min_operations_to_equalize_mountains([3, 5]) == 2 def test_multiple_mountains(): assert min_operations_to_equalize_mountains([5, 3, 1]) == 6 assert min_operations_to_equalize_mountains([4, 4, 4, 4]) == 0 assert min_operations_to_equalize_mountains([10, 1, 10, 1]) == 18 def test_empty_list(): assert min_operations_to_equalize_mountains([]) == 0","solution":"def min_operations_to_equalize_mountains(peaks): Returns the minimum number of operations needed to make all the mountains the same height. Args: peaks (list of int): A list of integers representing the heights of the mountains. Returns: int: The minimum number of operations required. if not peaks: return 0 max_height = max(peaks) total_operations = sum(max_height - height for height in peaks) return total_operations"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeDuplicates(head: ListNode) -> ListNode: Removes duplicates from a linked list. Args: head (ListNode): The head of the linked list. Returns: ListNode: The head of the modified linked list with duplicates removed. def linked_list_to_list(head: ListNode) -> List[int]: Helper function to convert linked list to list. result = [] current = head while current: result.append(current.val) current = current.next return result # Unit tests def create_linked_list(values): Create linked list from a list of values. if not values: return None head = ListNode(values[0]) current = head for val in values[1:]: current.next = ListNode(val) current = current.next return head def test_removeDuplicates_no_duplicates(): head = create_linked_list([1, 2, 3, 4, 5]) modified_head = removeDuplicates(head) assert linked_list_to_list(modified_head) == [1, 2, 3, 4, 5] def test_removeDuplicates_with_duplicates(): head = create_linked_list([1, 2, 2, 3, 4, 4, 5]) modified_head = removeDuplicates(head) assert linked_list_to_list(modified_head) == [1, 2, 3, 4, 5] def test_removeDuplicates_all_duplicates(): head = create_linked_list([1, 1, 1, 1, 1]) modified_head = removeDuplicates(head) assert linked_list_to_list(modified_head) == [1] def test_removeDuplicates_empty_list(): head = create_linked_list([]) modified_head = removeDuplicates(head) assert linked_list_to_list(modified_head) == [] def test_removeDuplicates_single_element(): head = create_linked_list([7]) modified_head = removeDuplicates(head) assert linked_list_to_list(modified_head) == [7]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeDuplicates(head): Removes duplicates from a linked list. Args: head (ListNode): The head of the linked list. Returns: ListNode: The head of the modified linked list with duplicates removed. if not head: return head current = head seen = set([current.val]) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head def linked_list_to_list(head): Helper function to convert linked list to list. result = [] current = head while current: result.append(current.val) current = current.next return result"},{"question":"def max_noodle_pairs(lengths: List[int], m: int) -> int: Determine the maximum number of pairs of noodles that can be combined to form a balanced noodle of at least a given length. >>> max_noodle_pairs([1, 2, 3, 4, 5, 6], 5) 3 >>> max_noodle_pairs([1, 2, 2, 2, 3], 5) 1 >>> max_noodle_pairs([4, 5, 7, 8], 10) 2 >>> max_noodle_pairs([1, 2, 2, 2, 3], 10) 0 >>> max_noodle_pairs([5, 5, 10, 1], 10) 2 >>> max_noodle_pairs([], 5) 0 >>> max_noodle_pairs([10], 5) 0","solution":"def max_noodle_pairs(lengths, m): lengths = sorted(lengths) i, j = 0, len(lengths) - 1 count = 0 while i < j: if lengths[i] + lengths[j] >= m: count += 1 i += 1 j -= 1 else: i += 1 return count"},{"question":"def min_deletions(s: str) -> int: Returns the minimum number of deletions required such that no two adjacent characters are the same. >>> min_deletions(\\"abc\\") == 0 >>> min_deletions(\\"aaaa\\") == 3 >>> min_deletions(\\"aab\\") == 1 >>> min_deletions(\\"aabb\\") == 2 >>> min_deletions(\\"abab\\") == 0 >>> min_deletions(\\"\\") == 0 >>> min_deletions(\\"a\\") == 0 >>> min_deletions(\\"aabba\\") == 2 >>> min_deletions(\\"aabbcc\\") == 3","solution":"def min_deletions(s: str) -> int: Returns the minimum number of deletions required such that no two adjacent characters are the same. if not s: return 0 deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"def can_player1_win(nums: List[int]) -> bool: Determines if Player 1 can be guaranteed to win or end the game in a tie, assuming both players play optimally. Args: nums (list of int): The input array of integers. Returns: bool: True if Player 1 can be guaranteed to win or tie, False otherwise. >>> can_player1_win([5]) True >>> can_player1_win([1, 5]) True >>> can_player1_win([1, 5, 2]) False >>> can_player1_win([1, 2, 3, 4]) True >>> can_player1_win([1, 5, 233, 7]) True >>> can_player1_win([8, 15, 3, 7]) True","solution":"def can_player1_win(nums): Determines if Player 1 can be guaranteed to win or end the game in a tie, assuming both players play optimally. Args: nums (list of int): The input array of integers. Returns: bool: True if Player 1 can be guaranteed to win or tie, False otherwise. n = len(nums) # dp[i][j] will be the maximum score player 1 can achieve more than player 2 with subarray nums[i:j+1] dp = [[0] * n for _ in range(n)] # Initialize the dp array where the subarray have only one element for i in range(n): dp[i][i] = nums[i] # Fill the dp array for subarrays longer than one element for length in range(2, n + 1): # length ranges from 2 to n for i in range(n - length + 1): j = i + length - 1 dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]) return dp[0][n - 1] >= 0"},{"question":"def min_sum_subarray(arr: List[int], k: int) -> int: Returns the minimum sum of any subarray of length k. >>> min_sum_subarray([1, 2, 3, 4, 5], 2) 3 >>> min_sum_subarray([5, 1, 2, 3, 4], 2) 3 >>> min_sum_subarray([3, 1, 4, 1, 5], 1) 1 >>> min_sum_subarray([1, 2, 3, 4], 4) 10 >>> min_sum_subarray([-1, -2, -3, -4], 2) -7 >>> min_sum_subarray([1, -2, 3, -4, 5], 2) -1 >>> min_sum_subarray([], 1) Traceback (most recent call last): ... ValueError: Invalid input >>> min_sum_subarray([1, 2, 3], 0) Traceback (most recent call last): ... ValueError: Invalid input >>> min_sum_subarray([1, 2, 3], 4) Traceback (most recent call last): ... ValueError: Invalid input","solution":"def min_sum_subarray(arr, k): Returns the minimum sum of any subarray of length k. if not arr or k <= 0 or k > len(arr): raise ValueError(\\"Invalid input\\") current_sum = sum(arr[:k]) min_sum = current_sum for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] min_sum = min(min_sum, current_sum) return min_sum"},{"question":"def word_pattern(pattern: str, s: str) -> bool: Determine if s follows the same pattern as pattern. :param pattern: A string pattern where each character represents a distinct element. :param s: A string consisting of words separated by spaces. :return: A boolean indicating whether s follows pattern. >>> word_pattern(\\"abba\\", \\"dog cat cat dog\\") True >>> word_pattern(\\"abba\\", \\"dog cat cat fish\\") False >>> word_pattern(\\"abc\\", \\"dog cat fish\\") True >>> word_pattern(\\"aabb\\", \\"dog dog dog dog\\") False >>> word_pattern(\\"xyz\\", \\"apple banana orange\\") True >>> word_pattern(\\"\\", \\"\\") True >>> word_pattern(\\"a\\", \\"apple\\") True >>> word_pattern(\\"a\\", \\"apple banana\\") False >>> word_pattern(\\"abc\\", \\"apple apple orange\\") False >>> word_pattern(\\"abcd\\", \\"dog cat\\") False >>> word_pattern(\\"a\\", \\"dog cat cat dog\\") False","solution":"def word_pattern(pattern: str, s: str) -> bool: Determine if s follows the same pattern as pattern. :param pattern: A string pattern where each character represents a distinct element. :param s: A string consisting of words separated by spaces. :return: A boolean indicating whether s follows pattern. words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for ch, word in zip(pattern, words): if ch not in char_to_word: if word in word_to_char: return False char_to_word[ch] = word word_to_char[word] = ch else: if char_to_word[ch] != word: return False return True"},{"question":"def max_hamming_distance(data: List[int], k: int) -> int: Returns the maximum hamming distance between two non-overlapping segments of length k. If it is impossible to find such segments, returns -1. >>> max_hamming_distance([0, 1, 0, 1, 0, 1], 2) 2 >>> max_hamming_distance([1, 1, 1, 0, 0, 0], 3) 3 >>> max_hamming_distance([1, 0, 0, 1], 2) 2 >>> max_hamming_distance([1, 0, 1], 2) -1 >>> max_hamming_distance([0, 0, 0, 0, 0, 0], 2) 0 >>> max_hamming_distance([1, 1, 1, 1, 1, 1], 2) 0 >>> max_hamming_distance([0, 1, 0, 1, 1, 0, 1, 0], 2) 2 >>> max_hamming_distance([0, 1]*10, 5) 5","solution":"def max_hamming_distance(data, k): Returns the maximum hamming distance between two non-overlapping segments of length k. If it is impossible to find such segments, returns -1. n = len(data) # To have two non-overlapping segments of length k, data must be at least 2 * k long if n < 2 * k: return -1 max_dist = 0 for i in range(n - 2 * k + 1): for j in range(i + k, n - k + 1): dist = sum(1 for x, y in zip(data[i:i+k], data[j:j+k]) if x != y) if dist > max_dist: max_dist = dist return max_dist"},{"question":"def max_subarray_sum(arr): Returns the maximum sum of any contiguous subarray of arr. >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([1, -2, 3, 4, -1, 2, 1, -5, 4]) 9 >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([]) 0 >>> max_subarray_sum([0, 0, 0, 0, 0]) 0 >>> max_subarray_sum([0, -1, -2, -3, 0]) 0","solution":"def max_subarray_sum(arr): Returns the maximum sum of any contiguous subarray of arr. if not arr: return 0 # Handle case for empty array current_max = arr[0] global_max = arr[0] for num in arr[1:]: current_max = max(num, current_max + num) global_max = max(global_max, current_max) return global_max"},{"question":"from typing import List def trap(height: List[int]) -> int: Calculate the maximum amount of rainwater that can be trapped between the buildings after it rains. :param height: List[int] - a list of non-negative integers representing the heights of buildings. :return: int - the maximum volume of water that can be trapped. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([]) 0 >>> trap([1,2,3,4,5]) 0 >>> trap([4]) 0 >>> trap([3, 3, 3, 3, 3]) 0 >>> trap([2, 0, 2]) 2 >>> trap([2, 0, 2, 0, 2]) 4 >>> trap([4, 2, 0, 3, 2, 5]) 9","solution":"def trap(height): Calculate the maximum amount of rainwater that can be trapped between the buildings after it rains. :param height: List[int] - a list of non-negative integers representing the heights of buildings. :return: int - the maximum volume of water that can be trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the trapped water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def first_missing_positive(nums: List[int]) -> int: Returns the smallest missing positive integer from an unsorted list of integers. The solution should have O(n) time complexity. >>> first_missing_positive([3, 4, -1, 1]) == 2 >>> first_missing_positive([1, 2, 0]) == 3 >>> first_missing_positive([1, 2, 3, 4, 5]) == 6 >>> first_missing_positive([-1]) == 1 >>> first_missing_positive([1]) == 2 >>> first_missing_positive([2]) == 1 >>> first_missing_positive([7, 8, 9, 11, 12]) == 1 >>> first_missing_positive(range(1, 100001)) == 100001","solution":"def first_missing_positive(nums): Returns the smallest missing positive integer from an unsorted list of integers. The solution should have O(n) time complexity. n = len(nums) # Put each number in its right place for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Find the first position which does not have the correct number for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def remove_k_most_frequent(s: str, k: int) -> str: Remove the k most frequent characters from the string. If there are multiple characters with the same frequency, remove the characters in alphabetical order. Return the transformed string after performing the removals. >>> remove_k_most_frequent('ababac', 1) 'bbc' >>> remove_k_most_frequent('abcd', 1) 'bcd' >>> remove_k_most_frequent('abcabc', 3) '' >>> remove_k_most_frequent('aabbbcccc', 2) 'aa' >>> remove_k_most_frequent('xyzxyzxyz', 2) 'zzz' >>> remove_k_most_frequent('a', 1) '' >>> remove_k_most_frequent('a', 2) ''","solution":"def remove_k_most_frequent(s, k): from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Sort characters by frequency (highest first), and alphabetically if frequencies are equal sorted_chars = sorted(freq.items(), key=lambda x: (-x[1], x[0])) # Find the k most frequent characters to remove chars_to_remove = {char for char, _ in sorted_chars[:k]} # Build the result string by excluding the characters to remove result = ''.join(char for char in s if char not in chars_to_remove) return result"},{"question":"def max_target_height(grid: List[List[int]], t: int) -> int: Returns the maximum height achievable in the grid without exceeding the target height t by removing the maximum amount of bars. >>> max_target_height([[1]], 1) 1 >>> max_target_height([[2]], 1) 0 >>> max_target_height([[1, 2], [3, 4]], 3) 3 >>> max_target_height([[1, 3, 2], [4, 2, 2]], 2) 2 >>> max_target_height([[1, 4, 6], [3, 5, 7]], 4) 4 >>> max_target_height([[1, 4, 6], [2, 5, 3]], 3) 3 >>> max_target_height([[1, 2, 3], [4, 5, 6]], 0) 0 >>> max_target_height([[0, 0, 0], [0, 0, 0]], 999999) 0 >>> max_target_height([[1, 2, 5], [5, 3, 8]], 10) 8 >>> max_target_height([], 5) 0 >>> max_target_height([[]], 5) 0","solution":"def max_target_height(grid, t): Returns the maximum height achievable in the grid without exceeding the target height t by removing the maximum amount of bars. m = len(grid) n = len(grid[0]) if m > 0 else 0 max_height = 0 for i in range(m): for j in range(n): if grid[i][j] <= t: max_height = max(max_height, grid[i][j]) return max_height"},{"question":"def largest_island(matrix: List[List[int]]) -> int: Given an n x n matrix containing 0s and 1s, where 0 represents water and 1 represents land, determine the size of the largest island. An island is a group of 1s connected vertically or horizontally. You may assume that all four edges of the matrix are surrounded by water. >>> largest_island([]) 0 >>> largest_island([ [1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 1] ]) 4","solution":"def largest_island(matrix): Returns the size of the largest island (group of connected 1s) in the matrix. param matrix: List of lists representing the n x n matrix return: Integer representing the size of the largest island if not matrix or not matrix[0]: return 0 n = len(matrix) visited = [[False] * n for _ in range(n)] def dfs(x, y): Depth-first search to explore the island and calculate its size. param x, y: Coordinates of the current cell return: The size of the island if x < 0 or x >= n or y < 0 or y >= n or matrix[x][y] == 0 or visited[x][y]: return 0 visited[x][y] = True size = 1 # Current cell # Explore the four directions size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size max_size = 0 for i in range(n): for j in range(n): if matrix[i][j] == 1 and not visited[i][j]: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"def is_possible_to_make_equal(nums: List[int]) -> bool: Determines if it's possible to make all bank account amounts equal by transferring amounts that are powers of 2. :param nums: List[int] - List of integers representing the amounts in each bank account :return: bool - True if it's possible to make all accounts equal, otherwise False >>> is_possible_to_make_equal([4, 4, 4]) True >>> is_possible_to_make_equal([1, 2, 3]) False >>> is_possible_to_make_equal([8]) True >>> is_possible_to_make_equal([2, 4, 8]) True >>> is_possible_to_make_equal([]) True >>> is_possible_to_make_equal([1048576, 2097152, 4194304]) True >>> is_possible_to_make_equal([1, 3, 9]) False","solution":"def is_possible_to_make_equal(nums): Determines if it's possible to make all bank account amounts equal by transferring amounts that are powers of 2. :param nums: List[int] - List of integers representing the amounts in each bank account :return: bool - True if it's possible to make all accounts equal, otherwise False def gcd(x, y): while y: x, y = y, x % y return x if len(nums) == 0: return True # Calculate the GCD of all the numbers current_gcd = nums[0] for num in nums[1:]: current_gcd = gcd(current_gcd, num) # Check each number after dividing by the GCD if it's a power of 2 for num in nums: divided_value = num // current_gcd # it should be exactly one 1 bit in binary representation for power of 2 if divided_value & (divided_value - 1) != 0: return False return True"},{"question":"def min_days_to_complete_tasks(tasks, days): Returns the minimum number of days needed to complete all tasks. If it's not possible to complete all tasks, return -1. :param tasks: List of integers where tasks[i] is the number of times task i needs to be completed. :param days: List of integers where days[i] is the number of consecutive days required to complete task i. :return: Minimum number of days to complete all tasks or -1 if not possible. >>> min_days_to_complete_tasks([3, 2, 2], [2, 2, 1]) == 5 >>> min_days_to_complete_tasks([3, 2, 2], [4, 2, 1]) == -1 >>> min_days_to_complete_tasks([1, 1, 1], [1, 1, 1]) == 3 >>> min_days_to_complete_tasks([3, 2, 1], [3, 2, 1]) == 6 >>> min_days_to_complete_tasks([0, 0, 0], [0, 0, 0]) == 0 >>> min_days_to_complete_tasks([], []) == 0","solution":"def min_days_to_complete_tasks(tasks, days): Returns the minimum number of days needed to complete all tasks. If it's not possible to complete all tasks, return -1. :param tasks: List of integers where tasks[i] is the number of times task i needs to be completed. :param days: List of integers where days[i] is the number of consecutive days required to complete task i. :return: Minimum number of days to complete all tasks or -1 if not possible. if len(tasks) != len(days): return -1 total_days = 0 for task, day in zip(tasks, days): if day > task: return -1 total_days += day return total_days"},{"question":"def max_depth_after_insertion(s: str) -> int: Given a balanced parentheses string s, returns the maximum depth of balanced parentheses in the resulting string after inserting exactly one pair of parentheses. >>> max_depth_after_insertion(\\"()\\") 2 >>> max_depth_after_insertion(\\"(())\\") 3 >>> max_depth_after_insertion(\\"((()))\\") 4 >>> max_depth_after_insertion(\\"()()\\") 2 >>> max_depth_after_insertion(\\"(()())\\") 3 >>> max_depth_after_insertion(\\"(())()()\\") 3","solution":"def max_depth_after_insertion(s: str) -> int: Given a balanced parentheses string s, returns the maximum depth of balanced parentheses in the resulting string after inserting exactly one pair of parentheses. current_depth = 0 max_depth = 0 for char in s: if char == '(': current_depth += 1 max_depth = max(max_depth, current_depth) elif char == ')': current_depth -= 1 return max_depth + 1"},{"question":"from collections import deque class RecentCounter: RecentCounter class to count recent requests in the last 3000 milliseconds. Methods: def __init__(self): Initializes the RecentCounter with an empty request log. def ping(self, t: int) -> int: Adds a new request at time \`t\` (in milliseconds) and returns the number of requests in the last 3000 milliseconds. >>> rc = RecentCounter() >>> rc.ping(1) 1 >>> rc.ping(100) 2 >>> rc.ping(3001) 3 >>> rc.ping(3002) 3 >>> rc.ping(7000) 1 >>> rc.ping(7001) 2","solution":"from collections import deque class RecentCounter: def __init__(self): self.requests = deque() def ping(self, t: int) -> int: self.requests.append(t) while self.requests[0] < t - 3000: self.requests.popleft() return len(self.requests)"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Finds the shortest path from the top-left corner to the bottom-right corner in a grid. Parameters: grid (List[List[int]]): A 2D list representing the grid where 0 is an empty spot, 1 is a wall and 2 is the person starting position. Returns: int: The length of the shortest path if it exists, otherwise -1. >>> shortest_path([[0, 0, 0], [1, 1, 0], [0, 0, 0]]) 4 >>> shortest_path([[0, 1], [1, 0]]) -1 >>> shortest_path([[1, 1], [1, 1]]) -1 >>> shortest_path([[0, 0], [0, 0]]) 2 >>> shortest_path([[0, 0, 1, 0, 0], [1, 0, 1, 0, 1], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 1, 0]]) 8","solution":"from collections import deque def shortest_path(grid): Finds the shortest path from the top-left corner to the bottom-right corner in a grid. Parameters: grid (List[List[int]]): A 2D list representing the grid where 0 is an empty spot, 1 is a wall and 2 is the person starting position. Returns: int: The length of the shortest path if it exists, otherwise -1. if not grid: return -1 m, n = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] start = (0, 0) end = (m-1, n-1) # Check if start or end are blocked if grid[start[0]][start[1]] == 1 or grid[end[0]][end[1]] == 1: return -1 queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add(start) while queue: r, c, dist = queue.popleft() # Check if we have reached the end if (r, c) == end: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"def find_min_heaters(nums: List[int]) -> int: Returns the minimum number of heaters required to cover all the houses. Args: nums (list): list of integers representing the position of houses along a street. Returns: int: minimum number of heaters needed. >>> find_min_heaters([]) == 0 >>> find_min_heaters([0]) == 1 >>> find_min_heaters([5]) == 1 >>> find_min_heaters([1, 1, 1]) == 1 >>> find_min_heaters([1, 2]) == 1 >>> find_min_heaters([1, 10]) == 2 >>> find_min_heaters([1, 2, 3, 5, 6, 7, 9, 10, 11, 14]) == 4 >>> find_min_heaters([1, 2, 2, 2, 3, 4, 5]) == 2","solution":"def find_min_heaters(nums): Returns the minimum number of heaters required to cover all the houses. Args: nums (list): list of integers representing the position of houses along a street. Returns: int: minimum number of heaters needed. if not nums: return 0 nums.sort() heaters_count = 0 i = 0 n = len(nums) while i < n: heaters_count += 1 location = nums[i] # Place heater at the current house i += 1 # Move i to the farthest house that can be covered by this heater while i < n and nums[i] <= location + 1: i += 1 # Location of the heater has been determined # Move i to the first house not covered by this heater location = nums[i - 1] + 1 while i < n and nums[i] <= location: i += 1 return heaters_count"},{"question":"def min_difference_after_merges(nums: List[int]) -> int: Given a list of integers \`nums\`, perform a series of merge operations to minimize the possible difference between the maximum and minimum elements in the list. Return the minimal possible difference between the maximum and minimum elements of the list after any sequence of merge operations is completed. >>> min_difference_after_merges([10]) == 0 >>> min_difference_after_merges([1, 2]) == 0 >>> min_difference_after_merges([1, 3, 5, 7]) == 0 >>> min_difference_after_merges([-1, -4, 2, 3]) == 0 >>> min_difference_after_merges([]) == 0 >>> min_difference_after_merges([0, 0, 0, 0]) == 0","solution":"def min_difference_after_merges(nums): Returns the minimal possible difference between the maximum and minimum elements of the list after any sequence of merge operations is completed. # If the list is empty, the difference is 0 if not nums: return 0 # After enough merge operations, you are left with only one element: the sum of all elements. total_sum = sum(nums) # Since we are considering sums, and the list collapses to a single element # the minimax difference is always zero, because the maximum and minimum will be equal. return 0"},{"question":"from typing import List def findSubstring(s: str, words: List[str]) -> List[int]: Returns all the start indices of substrings that are concatenations of each word in words exactly once. >>> findSubstring(\\"barfoothefoobarman\\", [\\"foo\\",\\"bar\\"]) [0, 9] >>> findSubstring(\\"barfoothefoobarman\\", [\\"foo\\",\\"baz\\"]) [] >>> findSubstring(\\"wordgoodgoodgoodbestword\\", [\\"word\\",\\"good\\",\\"best\\",\\"word\\"]) [] >>> findSubstring(\\"barfoofoobarthefoobar\\", [\\"bar\\",\\"foo\\",\\"the\\"]) [6, 9, 12] >>> findSubstring(\\"\\", [\\"foo\\",\\"bar\\"]) [] >>> findSubstring(\\"barfoothefoobarman\\", []) []","solution":"def findSubstring(s, words): Returns all the start indices of substring(s) that are concatenations of each word in words exactly once. if not s or not words: return [] word_length = len(words[0]) word_count = len(words) substring_length = word_length * word_count # Build a word frequency dictionary word_frequency = {} for word in words: if word in word_frequency: word_frequency[word] += 1 else: word_frequency[word] = 1 result_indices = [] for i in range(word_length): left = i right = i curr_frequency = {} word_used = 0 while right + word_length <= len(s): # Extract word from right pointer word = s[right:right+word_length] right += word_length if word in word_frequency: if word in curr_frequency: curr_frequency[word] += 1 else: curr_frequency[word] = 1 word_used += 1 # If there are more than needed of any word, shift the left pointer to the right to balance while curr_frequency[word] > word_frequency[word]: left_word = s[left:left+word_length] left += word_length curr_frequency[left_word] -= 1 word_used -= 1 # If all words are used the correct number of times, record the start index if word_used == word_count: result_indices.append(left) else: # Reset the count and move on curr_frequency.clear() word_used = 0 left = right return result_indices"},{"question":"def shortest_subarray_with_k_distinct(arr: List[int], k: int) -> int: Returns the length of the shortest contiguous subarray that contains at least k distinct integers. If no such subarray exists, return -1. >>> shortest_subarray_with_k_distinct([1, 2, 1, 2, 3], 2) == 2 >>> shortest_subarray_with_k_distinct([1, 2, 1, 3, 4], 3) == 3 >>> shortest_subarray_with_k_distinct([1, 1, 1, 1], 2) == -1","solution":"def shortest_subarray_with_k_distinct(arr, k): Returns the length of the shortest contiguous subarray that contains at least k distinct integers. If no such subarray exists, return -1. from collections import defaultdict n = len(arr) if k > n: return -1 # Impossible to have k distinct elements if k > n l, r = 0, 0 min_length = float('inf') count = defaultdict(int) distinct_count = 0 while r < n: count[arr[r]] += 1 if count[arr[r]] == 1: distinct_count += 1 while distinct_count >= k: min_length = min(min_length, r - l + 1) count[arr[l]] -= 1 if count[arr[l]] == 0: distinct_count -= 1 l += 1 r += 1 return min_length if min_length != float('inf') else -1"},{"question":"def has_pair_with_sum(nums, target): Determines if there are two integers in the array whose sum equals the target. >>> has_pair_with_sum([2, 7, 11, 15], 9) True >>> has_pair_with_sum([1, 2, 3, 4], 8) False >>> has_pair_with_sum([1, 4, 45, 6, 10, -8], 16) True >>> has_pair_with_sum([1, 2, 3, -3], 0) True >>> has_pair_with_sum([-1, -2, -3, -4], -7) True >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([5], 5) False","solution":"def has_pair_with_sum(nums, target): Determines if there are two integers in the array whose sum equals the target. :param nums: List[int] - List of integers :param target: int - Target sum :return: bool - True if such a pair exists, otherwise False seen = set() for num in nums: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"def max_sum_subarray_length_k(arr, k): Returns the maximum sum of a continuous subarray of length k. Args: arr (list of int): The input array of integers. k (int): The length of the subarray. Returns: int: The maximum sum of a subarray of length k. Examples: >>> max_sum_subarray_length_k([1, 2, 3, 4], 2) 7 >>> max_sum_subarray_length_k([2], 1) 2 >>> max_sum_subarray_length_k([-1, -2, -3, -4], 2) -3 >>> max_sum_subarray_length_k([1, -2, 3, 4, -1, 2, 1, -5, 4], 4) 8 >>> max_sum_subarray_length_k([1, 2, 3, 4, -1, 2], 6) 11 >>> max_sum_subarray_length_k([1, 3, 2, 1], 4) 7 >>> max_sum_subarray_length_k(list(range(1, 101)), 5) 490 >>> max_sum_subarray_length_k([1, 2, 3], 4) Traceback (most recent call last): ... ValueError: Array length must be at least k.","solution":"def max_sum_subarray_length_k(arr, k): Returns the maximum sum of a continuous subarray of length k. Args: arr (list of int): The input array of integers. k (int): The length of the subarray. Returns: int: The maximum sum of a subarray of length k. if len(arr) < k: raise ValueError(\\"Array length must be at least k.\\") # Calculate the sum of the first subarray of length k max_sum = sum(arr[:k]) current_sum = max_sum # Slide the window of size k and update the sums for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def num_islands(grid: List[List[str]]) -> int: You are given a 2D character grid of size \`m x n\` representing a map. Each cell in the grid contains either a '1' (representing land) or a '0' (representing water). An island is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. Return the number of distinct islands in the grid. >>> num_islands([['1', '1', '1', '1', '0'], ['1', '1', '0', '1', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '0', '0', '0']]) 1 >>> num_islands([['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '1', '0', '0'], ['0', '0', '0', '1', '1']]) 3 >>> num_islands([['0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0'], ['0', '0', '0', '0', '0']]) 0 >>> num_islands([['1', '0', '1', '0', '1']]) 3 >>> num_islands([['1'], ['0'], ['1'], ['0'], ['1']]) 3 pass","solution":"def num_islands(grid): Returns the number of distinct islands in the given grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == '0' or visited[x][y]: return visited[x][y] = True dfs(x+1, y) dfs(x-1, y) dfs(x, y+1) dfs(x, y-1) island_count = 0 for i in range(m): for j in range(n): if grid[i][j] == '1' and not visited[i][j]: dfs(i, j) island_count += 1 return island_count"},{"question":"from typing import List def min_steps_to_gather(grid: List[List[int]]) -> int: Determine the minimum number of steps required for all enemy units to gather at any single point on the grid. If it's impossible for all units to meet, return \`-1\`. >>> min_steps_to_gather([[0, 0], [0, 0]]) == 0 >>> min_steps_to_gather([[0, 1], [0, 0]]) == 0 >>> min_steps_to_gather([[1, 0], [1, 1]]) == -1 >>> min_steps_to_gather([[1, 0, 0], [0, 0, 0], [0, 0, 1]]) == 4 >>> min_steps_to_gather([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 0","solution":"from collections import deque def min_steps_to_gather(grid): if not grid: return -1 n = len(grid) enemies = [(i, j) for i in range(n) for j in range(n) if grid[i][j] == 1] if not enemies: return 0 def bfs_from(position): dist = [[-1] * n for _ in range(n)] queue = deque([position]) dist[position[0]][position[1]] = 0 while queue: x, y = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] != 1 and dist[nx][ny] == -1: dist[nx][ny] = dist[x][y] + 1 queue.append((nx, ny)) return dist total_dists = [[0] * n for _ in range(n)] for enemy in enemies: dist = bfs_from(enemy) for i in range(n): for j in range(n): if grid[i][j] != 1 and dist[i][j] != -1: total_dists[i][j] += dist[i][j] elif dist[i][j] == -1: total_dists[i][j] = float('inf') min_steps = min(min(row) for row in total_dists) return min_steps if min_steps != float('inf') else -1"},{"question":"def searchMatrix(matrix: List[List[int]], target: int) -> bool: Searches for a target value in a matrix where each row is sorted in ascending order from left to right, and each column is sorted in ascending order from top to bottom. :param matrix: List[List[int]], the matrix of integers :param target: int, the target value to search for :return: bool, True if the target exists in the matrix, otherwise False >>> matrix = [ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ] >>> searchMatrix(matrix, 5) True >>> searchMatrix(matrix, 20) False","solution":"def searchMatrix(matrix, target): Searches for a target value in a matrix where each row is sorted in ascending order from left to right, and each column is sorted in ascending order from top to bottom. :param matrix: List[List[int]], the matrix of integers :param target: int, the target value to search for :return: bool, True if the target exists in the matrix, otherwise False if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head): Detects the node where the cycle begins in a linked list. :param head: ListNode, the head of the linked list :return: ListNode, the node where the cycle begins, or None if there is no cycle >>> head = ListNode(1) >>> head.next = ListNode(2) >>> head.next.next = ListNode(3) >>> detectCycle(head) == None True >>> head = ListNode(1) >>> cycle_node = ListNode(2) >>> head.next = cycle_node >>> head.next.next = ListNode(3) >>> head.next.next.next = ListNode(4) >>> head.next.next.next.next = cycle_node # cycle starts here at node with value 2 >>> detectCycle(head) == cycle_node True >>> head = ListNode(1) >>> detectCycle(head) == None True >>> head = ListNode(1) >>> head.next = head # cycle >>> detectCycle(head) == head True >>> head = ListNode(1) >>> head.next = ListNode(2) >>> head.next.next = head # cycle starts here at node with value 1 >>> detectCycle(head) == head True","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head): Detects the node where the cycle begins in a linked list. :param head: ListNode, the head of the linked list :return: ListNode, the node where the cycle begins, or None if there is no cycle if not head or not head.next: return None slow = head fast = head # Detect whether there's a cycle using two pointers while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # If no cycle detected if not fast or not fast.next: return None # Find the entry to the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"def count_dominations(list1, list2): Returns the number of dominations where elements in list1 dominate elements in list2. Parameters: list1 (List[int]): The first list of positive integers. list2 (List[int]): The second list of positive integers. Returns: int: The total count of dominations. >>> count_dominations([5, 6, 7], [1, 2, 3]) 9 >>> count_dominations([4, 5, 6], [5, 5, 5]) 3 >>> count_dominations([1, 2, 3], [4, 5, 6]) 0 >>> count_dominations([4, 5, 6], [3, 5, 7]) 4 >>> count_dominations([2, 2, 2], [2, 2, 2]) 0 >>> count_dominations([1000] * 100, [1] * 100) 10000","solution":"def count_dominations(list1, list2): Returns the number of dominations where elements in list1 dominate elements in list2. Parameters: list1 (List[int]): The first list of positive integers. list2 (List[int]): The second list of positive integers. Returns: int: The total count of dominations. count = 0 for x in list1: for y in list2: if x > y: count += 1 return count"},{"question":"def break_palindrome(s: str) -> str: This function takes a palindromic string and replaces exactly one character to make it non-palindromic while ensuring it remains lexicographically smallest. Returns the resultant string after the replacement, or an empty string if it's impossible. >>> break_palindrome(\\"abccba\\") \\"aaccba\\" >>> break_palindrome(\\"a\\") \\"\\" >>> break_palindrome(\\"aa\\") \\"ab\\" >>> break_palindrome(\\"aaa\\") \\"aab\\" >>> break_palindrome(\\"aba\\") \\"abb\\" >>> break_palindrome(\\"cdc\\") \\"adc\\" pass def test_break_palindrome(): assert break_palindrome(\\"abccba\\") == \\"aaccba\\" assert break_palindrome(\\"a\\") == \\"\\" assert break_palindrome(\\"aa\\") == \\"ab\\" assert break_palindrome(\\"aaa\\") == \\"aab\\" assert break_palindrome(\\"aba\\") == \\"abb\\" assert break_palindrome(\\"cdc\\") == \\"adc\\" def test_break_palindrome_edge_cases(): assert break_palindrome(\\"a\\") == \\"\\" assert break_palindrome(\\"z\\") == \\"\\" assert break_palindrome(\\"aaaaaa\\") == \\"aaaaab\\" assert break_palindrome(\\"racecar\\") == \\"aacecar\\"","solution":"def break_palindrome(s: str) -> str: This function takes a palindromic string and replaces exactly one character to make it non-palindromic while ensuring it remains lexicographically smallest. n = len(s) # If the length of s is 1, it is impossible to make it non-palindromic if n == 1: return \\"\\" # Convert the string to a list to allow mutation chars = list(s) # Try to change the first non-'a' character in the first half of the string to 'a' for i in range(n // 2): if chars[i] != 'a': chars[i] = 'a' return \\"\\".join(chars) # If the string is entirely 'a's, we change the last character to 'b' chars[-1] = 'b' return \\"\\".join(chars)"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderTraversalFromList(lst: List[Optional[int]]) -> List[int]: Given a binary tree serialized as a list of integer values, return the level order traversal of its nodes' values. >>> levelOrderTraversalFromList([3, 9, 20, None, None, 15, 7]) == [3, 9, 20, 15, 7] >>> levelOrderTraversalFromList([]) == [] >>> levelOrderTraversalFromList([1]) == [1] >>> levelOrderTraversalFromList([1, 2, None, 3, None, 4]) == [1, 2, 3, 4] >>> levelOrderTraversalFromList([1, None, 2, None, 3, None, 4]) == [1, 2, 3, 4] >>> levelOrderTraversalFromList([1, 2, 3, 4, 5, 6, 7]) == [1, 2, 3, 4, 5, 6, 7] >>> levelOrderTraversalFromList([1, 2, 3, None, 4, None, 5]) == [1, 2, 3, 4, 5]","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree_from_list(lst: List[Optional[int]]) -> Optional[TreeNode]: if not lst: return None root = TreeNode(lst[0]) queue = [root] i = 1 while queue and i < len(lst): current = queue.pop(0) if lst[i] is not None: current.left = TreeNode(lst[i]) queue.append(current.left) i += 1 if i < len(lst) and lst[i] is not None: current.right = TreeNode(lst[i]) queue.append(current.right) i += 1 return root def levelOrderTraversal(root: Optional[TreeNode]) -> List[int]: if not root: return [] result = [] queue = [root] while queue: current = queue.pop(0) result.append(current.val) if current.left: queue.append(current.left) if current.right: queue.append(current.right) return result def levelOrderTraversalFromList(lst: List[Optional[int]]) -> List[int]: root = build_tree_from_list(lst) return levelOrderTraversal(root)"},{"question":"def count_waterproof_buildings(heights): Returns the number of waterproof buildings in the list. A building is considered waterproof if there exists a sequence of contiguous buildings that includes this building, and the height of every building in this sequence is greater than or equal to the height of the building on either end of the sequence. >>> count_waterproof_buildings([]) == 0 >>> count_waterproof_buildings([5]) == 1 >>> count_waterproof_buildings([3, 3, 3]) == 3 >>> count_waterproof_buildings([1, 2, 3, 4, 5]) == 5 >>> count_waterproof_buildings([5, 4, 3, 2, 1]) == 5 >>> count_waterproof_buildings([3, 1, 4, 1, 5, 9, 2]) == 7 >>> count_waterproof_buildings([1, 2, 1, 4, 5, 3, 6]) == 7 >>> count_waterproof_buildings([2, 2, 3, 2, 2]) == 5","solution":"def count_waterproof_buildings(heights): Returns the number of waterproof buildings in the list. if not heights: return 0 n = len(heights) count = 0 for i in range(n): left_max = max(heights[:i+1]) # Max height from the left including current building right_max = max(heights[i:]) # Max height from the right including current building # Check if there's at least one possible sequence that satisfies the condition if left_max >= heights[i] and right_max >= heights[i]: count += 1 return count"},{"question":"def trap(height: List[int]) -> int: Calculate the total amount of trapped water given the heights of the buildings. Parameters: height (List[int]): List of integers representing the height of buildings. Returns: int: The total amount of water trapped between the buildings. Example: >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9 >>> trap([1,0,1]) 1 >>> trap([]) 0 >>> trap([3, 0, 2, 0, 4]) 7 >>> trap([0,0,0,0]) 0 >>> trap([5,4,1,2]) 1","solution":"def trap(height): Calculate the total amount of trapped water given the heights of the buildings. Parameters: height (List[int]): List of integers representing the height of buildings. Returns: int: The total amount of water trapped between the buildings. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) # Fill right_max array right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"from typing import List def find_buildings_with_sunset_view(arr: List[int]) -> List[int]: Given an array of integers representing the heights of buildings in a row, determine the number of buildings that have an unobstructed view of the sunset. Unobstructed view of the sunset is defined as no taller building to the right. Parameters: arr (List[int]): List of integers representing building heights Returns: List[int]: Indices of buildings with unobstructed view >>> find_buildings_with_sunset_view([]) [] >>> find_buildings_with_sunset_view([1]) [0] >>> find_buildings_with_sunset_view([1, 2, 3, 4, 5]) [4] >>> find_buildings_with_sunset_view([5, 4, 3, 2, 1]) [0, 1, 2, 3, 4] >>> find_buildings_with_sunset_view([2, 3, 4, 1]) [2, 3] >>> find_buildings_with_sunset_view([1, 1, 1, 1]) [3] >>> find_buildings_with_sunset_view([3, 5, 4, 9, 7]) [3, 4] >>> find_buildings_with_sunset_view([2, 3, 5, 9]) [3]","solution":"def find_buildings_with_sunset_view(arr): Returns the indices of buildings that have an unobstructed view of the sunset. n = len(arr) if n == 0: return [] max_height = arr[-1] result = [n-1] for i in range(n-2, -1, -1): if arr[i] > max_height: result.append(i) max_height = arr[i] return result[::-1]"},{"question":"def min_path_sum(matrix: List[List[int]]) -> int: Returns the minimum sum of all numbers along the path from the top-left corner to the bottom-right corner. :param matrix: List[List[int]] - 2D list representing the grid of non-negative integers :return: int - Minimum path sum from top-left to bottom-right corner >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> min_path_sum([[1, 2, 3]]) == 6 >>> min_path_sum([[1], [2], [3]]) == 6 >>> min_path_sum([]) == 0 >>> min_path_sum([[5]]) == 5 >>> min_path_sum([ ... [1, 2], ... [1, 1] ... ]) == 3","solution":"def min_path_sum(matrix): Returns the minimum sum of all numbers along the path from the top-left corner to the bottom-right corner. :param matrix: List[List[int]] - 2D list representing the grid of non-negative integers :return: int - Minimum path sum from top-left to bottom-right corner if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) # Initialize the dp table with the top-left element of matrix dp = [[0] * n for _ in range(m)] dp[0][0] = matrix[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + matrix[0][j] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + matrix[i][0] # Populate the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[m-1][n-1]"},{"question":"import math from typing import List, Tuple def euclidean_distance(p1: Tuple[float, float], p2: Tuple[float, float]) -> float: Calculates the Euclidean distance between two 2D points p1 and p2 return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def minPath(points: List[Tuple[float, float]]) -> float: Given a list of n points (x, y) on a 2D plane, find the shortest path that visits all points. The path starts and ends at the first point in the list. >>> minPath([(0, 0)]) 0 >>> minPath([(0, 0), (1, 1)]) 2.8284271247461903 >>> minPath([(0, 0), (1, 0), (0, 1)]) 3.414213562373095 >>> minPath([(0, 0), (1, 0), (1, 1), (0, 1)]) 4.0","solution":"import itertools import math def euclidean_distance(p1, p2): Calculates the Euclidean distance between two 2D points p1 and p2. return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def minPath(points): Calculates the length of the shortest path that visits all points starting and ending at the first point. if not points or len(points) == 1: return 0 start_point = points[0] other_points = points[1:] min_path_length = float('inf') # Generate all permutations of the other points to find the shortest path for perm in itertools.permutations(other_points): path_length = euclidean_distance(start_point, perm[0]) # Calculate the path length for this permutation for i in range(len(perm) - 1): path_length += euclidean_distance(perm[i], perm[i + 1]) path_length += euclidean_distance(perm[-1], start_point) # Update the minimum path length found if path_length < min_path_length: min_path_length = path_length return min_path_length"},{"question":"def smallest_lexicographical_swap(s: str) -> str: Returns the lexicographically smallest string that can be obtained after exactly one swap between two different indices. >>> smallest_lexicographical_swap(\\"a\\") == \\"a\\" >>> smallest_lexicographical_swap(\\"ab\\") == \\"ab\\" >>> smallest_lexicographical_swap(\\"ba\\") == \\"ab\\" >>> smallest_lexicographical_swap(\\"baa\\") == \\"aab\\" >>> smallest_lexicographical_swap(\\"aaa\\") == \\"aaa\\" >>> smallest_lexicographical_swap(\\"bbb\\") == \\"bbb\\" >>> smallest_lexicographical_swap(\\"bab\\") == \\"abb\\" >>> smallest_lexicographical_swap(\\"bba\\") == \\"abb\\"","solution":"def smallest_lexicographical_swap(s): Returns the lexicographically smallest string that can be obtained after exactly one swap between two different indices. # If the string length is less than 2, return the same string. if len(s) < 2: return s s = list(s) # Convert string to list to perform swaps smallest_string = s[:] # Initialize the smallest string as the original list n = len(s) # Iterate over all pairs of indices for i in range(n): for j in range(i + 1, n): # Swap characters at indices i and j s[i], s[j] = s[j], s[i] # Check if we have a new smallest string if s < smallest_string: smallest_string = s[:] # Swap back the characters to restore original order s[i], s[j] = s[j], s[i] return ''.join(smallest_string)"},{"question":"from collections import deque def min_flips_to_connect_island_to_border(grid): Find the smallest number of \`0\`s you must flip to \`1\`s in order to connect the island to any border of the grid. >>> min_flips_to_connect_island_to_border([ ... [0, 1, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> min_flips_to_connect_island_to_border([ ... [0, 0, 0, 0, 0], ... [0, 1, 1, 0, 0], ... [0, 1, 0, 0, 0], ... [0, 0, 0, 0, 0] ... ]) == 1 >>> min_flips_to_connect_island_to_border([ ... [0, 0, 0, 0, 0], ... [0, 1, 0, 0, 0], ... [0, 1, 1, 0, 0], ... [0, 0, 1, 0, 0], ... [0, 0, 0, 0, 0] ... ]) == 1 >>> min_flips_to_connect_island_to_border([ ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 1, 0, 0], ... [0, 0, 1, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0] ... ]) == 2","solution":"from collections import deque def min_flips_to_connect_island_to_border(grid): def bfs(queue, visited): while queue: x, y, dist = queue.popleft() if x == 0 or y == 0 or x == len(grid)-1 or y == len(grid[0])-1: return dist for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (nx, ny) not in visited: visited.add((nx, ny)) if grid[nx][ny] == 0: queue.append((nx, ny, dist+1)) else: # grid[nx][ny] == 1 queue.appendleft((nx, ny, dist)) return -1 # Find any land cell (1) to start BFS start = None for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: start = (i, j) break if start: break # BFS to find the minimum number of flips to connect to border queue = deque([(start[0], start[1], 0)]) visited = set([start]) return bfs(queue, visited)"},{"question":"def min_cost_to_reach_last_stage(arr: List[int]) -> int: Determine the minimum possible total cost to reach the last stage of the game, starting from the first stage. :param arr: List[int] - List of costs to enter each stage. :return: int - The minimum total cost to reach the last stage. >>> min_cost_to_reach_last_stage([5]) 5 >>> min_cost_to_reach_last_stage([1, 100]) 101 >>> min_cost_to_reach_last_stage([10, 15, 20]) 30 >>> min_cost_to_reach_last_stage([1, 2, 3, 4, 5]) 9 >>> min_cost_to_reach_last_stage([1, 100, 1, 1, 100, 1]) 4 >>> min_cost_to_reach_last_stage([0, 0, 0, 0, 0, 0]) 0","solution":"def min_cost_to_reach_last_stage(arr): Return the minimum possible total cost to reach the last stage of the game. :param arr: List[int] - List of costs to enter each stage. :return: int - The minimum total cost to reach the last stage. n = len(arr) if n == 0: return 0 if n == 1: return arr[0] dp = [0] * n dp[0] = arr[0] dp[1] = arr[0] + arr[1] for i in range(2, n): dp[i] = arr[i] + min(dp[i-1], dp[i-2]) return dp[-1]"},{"question":"def can_transform(s: str, t: str) -> bool: Determines if string s can be transformed into string t by changing any character in s to any other character. Since we can change any character in s to any character, we can transform s to t as long as their lengths are the same, which is specified in the problem statement. >>> can_transform(\\"abc\\", \\"abc\\") == True >>> can_transform(\\"abc\\", \\"def\\") == True >>> can_transform(\\"a\\", \\"b\\") == True >>> can_transform(\\"\\", \\"\\") == True >>> can_transform(\\"abcdx\\", \\"wxyzj\\") == True","solution":"def can_transform(s, t): Determines if string s can be transformed into string t by changing any character in s to any other character. Since we can change any character in s to any character, we can transform s to t as long as their lengths are the same, which is specified in the problem statement. return len(s) == len(t)"},{"question":"def minPathCost(grid): Returns the minimum cost path from the top-left to the bottom-right of the grid. >>> minPathCost([[1]]) == 1 >>> minPathCost([[1, 2], [1, 1]]) == 3 >>> minPathCost([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7 >>> minPathCost([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 21 >>> minPathCost([ ... [1, 2, 5], ... [3, 2, 1], ... [4, 3, 1] ... ]) == 7","solution":"def minPathCost(grid): Returns the minimum cost path from the top-left to the bottom-right of the grid. m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] # Initialize the dp array with the moveCost of the initial positions dp[0][0] = grid[0][0] # Fill the first row (since we can only move right) for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (since we can only move down) for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the remaining cells for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[m - 1][n - 1]"},{"question":"def lexicographically_smallest_string(s: str) -> str: Returns a string formed by removing each lexicographically smallest character from \`s\` and appending it to the result until \`s\` is empty. >>> lexicographically_smallest_string(\\"aabbcc\\") \\"abc\\" >>> lexicographically_smallest_string(\\"abcabc\\") \\"abc\\" >>> lexicographically_smallest_string(\\"bacdacb\\") \\"abcd\\" >>> lexicographically_smallest_string(\\"zzyyxx\\") \\"xyz\\" >>> lexicographically_smallest_string(\\"zzbbxxccaa\\") \\"abcxz\\" >>> lexicographically_smallest_string(\\"abcdef\\") \\"abcdef\\" >>> lexicographically_smallest_string(\\"aaabbbcccddd\\") \\"abcd\\" >>> lexicographically_smallest_string(\\"\\") \\"\\" >>> lexicographically_smallest_string(\\"a\\") \\"a\\" >>> lexicographically_smallest_string(\\"aaaa\\") \\"a\\"","solution":"def lexicographically_smallest_string(s): Returns a string formed by removing each lexicographically smallest character from \`s\` and appending it to the result until \`s\` is empty. result = [] # Convert s to list for easy removal of characters s = list(s) while s: # Find the lexicographically smallest character smallest_char = min(s) # Remove all occurrences of this smallest character s = [char for char in s if char != smallest_char] # Append the smallest character to the result result.append(smallest_char) return ''.join(result)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_increasing_path(root): Determine the longest path in the binary tree where the values along the path form a strictly increasing sequence. Return the length of the longest strictly increasing path. >>> root = TreeNode(1) >>> root.left = TreeNode(3) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> longest_increasing_path(root) 3 >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(15) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(6) >>> root.right.right = TreeNode(20) >>> longest_increasing_path(root) 3 >>> longest_increasing_path(None) 0 >>> root = TreeNode(1) >>> longest_increasing_path(root) 1","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_increasing_path(root): def dfs(node, prev_val, length): if not node: return length if node.val > prev_val: length += 1 else: length = 1 left_length = dfs(node.left, node.val, length) right_length = dfs(node.right, node.val, length) return max(length, left_length, right_length) if root is None: return 0 return dfs(root, float('-inf'), 0)"},{"question":"def min_deletions_to_make_good(s: str) -> int: Returns the minimum number of deletions required to make the string 's' good. A string is considered \\"good\\" if there are no two consecutive 'a's and no two consecutive 'b's. >>> min_deletions_to_make_good(\\"abab\\") == 0 >>> min_deletions_to_make_good(\\"a\\") == 0 >>> min_deletions_to_make_good(\\"b\\") == 0 >>> min_deletions_to_make_good(\\"aaa\\") == 2 >>> min_deletions_to_make_good(\\"bbb\\") == 2 >>> min_deletions_to_make_good(\\"aabba\\") == 2 >>> min_deletions_to_make_good(\\"ababab\\") == 0 >>> min_deletions_to_make_good(\\"abba\\") == 1 >>> min_deletions_to_make_good(\\"a\\") == 0 >>> min_deletions_to_make_good(\\"b\\") == 0 >>> min_deletions_to_make_good(\\"aa\\") == 1 >>> min_deletions_to_make_good(\\"bb\\") == 1","solution":"def min_deletions_to_make_good(s): Returns the minimum number of deletions required to make the string 's' good. A string is considered \\"good\\" if there are no two consecutive 'a's and no two consecutive 'b's. deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"def rearrange_students(s: str) -> str: Rearranges the input string such that all '+' characters come before all '-' characters. Parameters: s (str): The input string containing '+' and '-' characters. Returns: str: The rearranged string with all '+' characters before all '-' characters. Examples: >>> rearrange_students('+++') == '+++' >>> rearrange_students('---') == '---' >>> rearrange_students('+--++-') == '+++---' >>> rearrange_students('-+-+') == '++--' >>> rearrange_students('-+') == '+-' >>> rearrange_students('+--') == '+--' >>> rearrange_students('') == '' >>> rearrange_students('+') == '+' >>> rearrange_students('-') == '-'","solution":"def rearrange_students(s): Rearranges the input string such that all '+' characters come before all '-' characters. Parameters: s (str): The input string containing '+' and '-' characters. Returns: str: The rearranged string with all '+' characters before all '-' characters. plus_count = s.count('+') minus_count = s.count('-') return '+' * plus_count + '-' * minus_count"},{"question":"def single_number(arr: List[int]) -> int: Returns the single number that appears only once in the array where every other number appears three times. This solution assumes constant space and linear time complexity. >>> single_number([2, 2, 3, 2]) == 3 >>> single_number([-2, -2, -2, -1]) == -1 >>> single_number([1]) == 1 >>> single_number([0, 0, 0, 1]) == 1 >>> single_number([1, 1, 1, 9, 2, 2, 2, 8, 8, 3, 3, 3, 9, 9, 6, 8, 6, 6, 4, 4, 4, 10]) == 10 >>> single_number([5, 6, 5, 3, 3, 5, 6, 6, 7, 3]) == 7 >>> single_number([7, 7, -3, 7, -3, -3, -5, 11, 11, 11]) == -5","solution":"def single_number(arr): Returns the single number that appears only once in the array where every other number appears three times. This solution assumes constant space and linear time complexity. ones, twos = 0, 0 for num in arr: # \`ones & num\` gives the bits that are there in both \`ones\` and the new number # we add these bits to \`twos\` using bitwise OR twos |= ones & num # XOR the new number with \`ones\`. The \`Num\` bits that are in \`ones\` will be zeroed out and vice versa # The bits that appear first time get stored in \`ones\`. ones ^= num # \`common_bit_mask\` contains all the common bit positions which have appeared three times common_bit_mask = ~(ones & twos) # Remove the common bits from \`ones\` and \`twos\` ones &= common_bit_mask twos &= common_bit_mask return ones"},{"question":"from typing import List def hasPath(maze: List[List[str]], start: List[int], destination: List[int]) -> bool: You are given an \`m x n\` grid \`maze\` consisting of walls ('#') and empty spaces ('.'). A ball is placed at the starting point \`start\` and you need to find if there is a path for the ball to reach the destination point \`destination\`. The ball can travel up, down, left, or right, but it can only stop when it hits a wall. You need to return \`true\` if there is such a path from \`start\` to \`destination\` in the maze, otherwise return \`false\`. >>> maze = [ ... ['.', '.', '.', '#', '.', '.'], ... ['.', '#', '.', '#', '.', '#'], ... ['.', '#', '.', '.', '#', '.'], ... ['.', '.', '#', '.', '.', '.'] ... ] >>> hasPath(maze, [0, 0], [3, 5]) True >>> maze = [ ... ['.', '.', '.', '#', '.', '.'], ... ['.', '#', '.', '#', '.', '#'], ... ['.', '#', '.', '.', '#', '.'], ... ['.', '.', '#', '.', '#', '.'] ... ] >>> hasPath(maze, [0, 0], [3, 5]) False","solution":"from typing import List from collections import deque def hasPath(maze: List[List[str]], start: List[int], destination: List[int]) -> bool: def is_valid(x, y): return 0 <= x < len(maze) and 0 <= y < len(maze[0]) and maze[x][y] == '.' def bfs(start): queue = deque([start]) visited = set() visited.add((start[0], start[1])) while queue: x, y = queue.popleft() if [x, y] == destination: return True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_x, new_y = x, y while is_valid(new_x + dx, new_y + dy): new_x += dx new_y += dy if (new_x, new_y) not in visited: visited.add((new_x, new_y)) queue.append((new_x, new_y)) return False return bfs(start)"},{"question":"from typing import List def max_elements_with_repetitions(arr: List[int]) -> int: Given an array of non-negative integers, maximize the number of the elements with at least one repetition in the array. >>> max_elements_with_repetitions([]) == 0 >>> max_elements_with_repetitions([1, 2, 3, 4, 5]) == 0 >>> max_elements_with_repetitions([1, 1, 1, 1, 1]) == 1 >>> max_elements_with_repetitions([1, 2, 2, 3, 3, 3, 4, 4]) == 3 >>> max_elements_with_repetitions([1]) == 0 >>> max_elements_with_repetitions([1, 2, 2, 3, 4, 4, 4, 5, 5, 6, 7, 7]) == 4","solution":"def max_elements_with_repetitions(arr): Returns the maximum number of elements with at least one repetition in the array. from collections import Counter # Count the frequency of each element count = Counter(arr) # Calculate the number of elements with at least one repetition elements_with_repetition = sum(1 for v in count.values() if v > 1) return elements_with_repetition"},{"question":"def calculate_final_inventory(inventoryChanges: List[int], currentInventory: int) -> int: Calculate the final inventory after applying the monthly changes. :param inventoryChanges: List of 12 integers representing inventory changes for each month. :param currentInventory: Integer representing the inventory at the start of January. :return: Integer representing the final inventory at the end of the year. from solution import calculate_final_inventory def test_standard_case(): inventory_changes = [10, -5, 3, -8, 7, -2, 1, 4, -3, 2, -6, 5] current_inventory = 50 assert calculate_final_inventory(inventory_changes, current_inventory) == 58 def test_all_positive_changes(): inventory_changes = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] current_inventory = 10 assert calculate_final_inventory(inventory_changes, current_inventory) == 22 def test_all_negative_changes(): inventory_changes = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1] current_inventory = 10 assert calculate_final_inventory(inventory_changes, current_inventory) == -2 def test_zero_changes(): inventory_changes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] current_inventory = 10 assert calculate_final_inventory(inventory_changes, current_inventory) == 10 def test_large_changes(): inventory_changes = [1000, -500, 300, -800, 700, -200, 100, 400, -300, 200, -600, 500] current_inventory = 1000 assert calculate_final_inventory(inventory_changes, current_inventory) == 1800","solution":"def calculate_final_inventory(inventoryChanges, currentInventory): Calculate the final inventory after applying the monthly changes. :param inventoryChanges: List of 12 integers representing inventory changes for each month. :param currentInventory: Integer representing the inventory at the start of January. :return: Integer representing the final inventory at the end of the year. for change in inventoryChanges: currentInventory += change return currentInventory"},{"question":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedListProcessor: def __init__(self, head): Initializes the linked list with the provided head node. self.head = head def reverseList(self): Reverses the linked list and returns the new head. pass def splitList(self, head): Splits the given list into two halves and returns a pair of nodes representing the heads of the two lists. If the list has an odd number of elements, the extra element should go in the first half. pass def mergeLists(self, list1, list2): Merges two lists by alternating nodes from each list and returns the head of the merged list. pass def process(self): Processes the linked list by reversing it, splitting it into two halves, and merging the halves by alternating nodes from each half. Returns the head of the processed linked list. pass import pytest def test_reverseList(): # Create the linked list 1->2->3->None head = Node(1, Node(2, Node(3))) processor = LinkedListProcessor(head) new_head = processor.reverseList() # Check if linked list is reversed to 3->2->1->None assert new_head.value == 3 assert new_head.next.value == 2 assert new_head.next.next.value == 1 assert new_head.next.next.next is None def test_splitList(): # Create the linked list 1->2->3->4->None head = Node(1, Node(2, Node(3, Node(4)))) processor = LinkedListProcessor(head) first_half, second_half = processor.splitList(head) # Check first half 1->2->None assert first_half.value == 1 assert first_half.next.value == 2 assert first_half.next.next is None # Check second half 3->4->None assert second_half.value == 3 assert second_half.next.value == 4 assert second_half.next.next is None def test_mergeLists(): # Create two lists 1->2->None and 3->4->None list1 = Node(1, Node(2)) list2 = Node(3, Node(4)) processor = LinkedListProcessor(None) merged_head = processor.mergeLists(list1, list2) # Check merged list: 1->3->2->4->None assert merged_head.value == 1 assert merged_head.next.value == 3 assert merged_head.next.next.value == 2 assert merged_head.next.next.next.value == 4 assert merged_head.next.next.next.next is None def test_process(): # Create the linked list 1->2->3->4->5->None head = Node(1, Node(2, Node(3, Node(4, Node(5))))) processor = LinkedListProcessor(head) processed_head = processor.process() # Check processed list: 5->3->4->2->1->None assert processed_head.value == 5 assert processed_head.next.value == 3 assert processed_head.next.next.value == 4 assert processed_head.next.next.next.value == 2 assert processed_head.next.next.next.next.value == 1 assert processed_head.next.next.next.next.next is None","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedListProcessor: def __init__(self, head): self.head = head def reverseList(self): prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev return self.head def splitList(self, head): if not head: return None, None slow = head fast = head while fast and fast.next: prev_slow = slow slow = slow.next fast = fast.next.next middle = slow prev_slow.next = None return head, middle def mergeLists(self, list1, list2): if not list1: return list2 if not list2: return list1 head = list1 list1 = list1.next current = head toggle = True while list1 and list2: if toggle: current.next = list2 list2 = list2.next else: current.next = list1 list1 = list1.next toggle = not toggle current = current.next if list1: current.next = list1 if list2: current.next = list2 return head def process(self): # Step 1: Reverse the linked list reversed_head = self.reverseList() # Step 2: Split the reversed list into two halves first_half, second_half = self.splitList(reversed_head) # Step 3: Merge the two halves by alternating the nodes from each half merged_head = self.mergeLists(first_half, second_half) return merged_head"},{"question":"from typing import List, Tuple def max_events_in_interval(events: List[Tuple[int, str, int]], interval: int) -> List[Tuple[str, int]]: Return the maximum number of events within any interval minutes for each category. Parameters: events (list of tuple): A list where each element is a tuple (event_id, category, time) interval (int): The interval in minutes Returns: list of tuple: A list of tuples (category, max_count) for each category >>> events = [(1, 'A', 10), (2, 'A', 15), (3, 'B', 30), (4, 'A', 25), (5, 'B', 35)] >>> max_events_in_interval(events, 10) [('A', 2), ('B', 2)]","solution":"from collections import defaultdict from bisect import bisect_right def max_events_in_interval(events, interval): Returns the maximum number of events within any interval minutes for each category. Parameters: events (list of tuple): A list where each element is a tuple (event_id, category, time) interval (int): The interval in minutes Returns: list of tuple: A list of tuples (category, max_count) for each category events_by_category = defaultdict(list) # Group events by category and sort by time for event_id, category, time in events: events_by_category[category].append(time) result = [] for category, times in events_by_category.items(): times.sort() max_count = 0 for i in range(len(times)): # Find the position where a time exceeds the current time + interval j = bisect_right(times, times[i] + interval) max_count = max(max_count, j - i) result.append((category, max_count)) return result"},{"question":"class OperationArray: You are given an integer array \`arr\` consisting of \`n\` elements. Implement the class \`OperationArray\` to efficiently perform operations. OperationArray(arr): Initializes the object with the given integer array \`arr\`. update(index, value): Updates the element at index \`index\` to \`value\`. query(left, right): Returns the sum of the elements in the array within the inclusive range \`[left, right]\`. Ensure that the class can handle multiple update and query operations efficiently. Examples: >>> op_array = OperationArray([1, 2, 3, 4, 5]) >>> op_array.query(0, 4) 15 >>> op_array.update(2, 10) >>> op_array.query(1, 3) 16 def __init__(self, arr): Initializes the object with the given integer array arr. def update(self, index, value): Updates the element at index to value. def query(self, left, right): Returns the sum of the elements in the array within the inclusive range [left, right]. from solution import OperationArray def test_initial_sum(): arr = [1, 2, 3, 4, 5] op_array = OperationArray(arr) assert op_array.query(0, 4) == 15 # Sum of [1, 2, 3, 4, 5] assert op_array.query(1, 3) == 9 # Sum of [2, 3, 4] def test_update_and_sum(): arr = [1, 2, 3, 4, 5] op_array = OperationArray(arr) op_array.update(2, 10) # Update index 2 to 10 -> arr becomes [1, 2, 10, 4, 5] assert op_array.query(0, 4) == 22 # Sum of [1, 2, 10, 4, 5] assert op_array.query(2, 4) == 19 # Sum of [10, 4, 5] def test_update_and_query(): arr = [5, 8, 6, 3, 2, 7, 2, 6] op_array = OperationArray(arr) assert op_array.query(0, 7) == 39 # Sum of entire array op_array.update(3, 11) # Update index 3 to 11 -> arr becomes [5, 8, 6, 11, 2, 7, 2, 6] assert op_array.query(0, 7) == 47 # Sum of updated array assert op_array.query(2, 5) == 26 # Sum of [6, 11, 2, 7]","solution":"class OperationArray: def __init__(self, arr): Initializes the object with the given integer array arr. self.n = len(arr) self.arr = arr[:] self.BIT = [0] * (self.n + 1) for i in range(self.n): self._update_BIT(i + 1, arr[i]) def _update_BIT(self, index, value): Updates the BIT with the provided value at the given index. while index <= self.n: self.BIT[index] += value index += index & -index def _prefix_sum(self, index): Returns the prefix sum from the start to the given index using BIT. result = 0 while index > 0: result += self.BIT[index] index -= index & -index return result def update(self, index, value): Updates the element at index to value. delta = value - self.arr[index] self.arr[index] = value self._update_BIT(index + 1, delta) def query(self, left, right): Returns the sum of the elements in the array within the inclusive range [left, right]. return self._prefix_sum(right + 1) - self._prefix_sum(left)"},{"question":"class RideSharingSystem: def __init__(self, drivers): Initializes the RideSharingSystem object with the distances of \`n\` drivers. def assign(self): Returns the ID of the nearest available driver to a passenger or \`-1\` if no drivers are available. >>> system = RideSharingSystem([10, 5, 20]) >>> system.assign() 1 >>> system.assign() 0 >>> system.assign() 2 >>> system.assign() -1 def free(self, driverId): Releases the driver with the given ID back to the pool of available drivers. >>> system = RideSharingSystem([10, 5, 20]) >>> system.assign() 1 >>> system.assign() 0 >>> system.free(1) >>> system.assign() 1 def evaluate(self): Returns the average distance of all currently assigned drivers from their passenger locations as a double. >>> system = RideSharingSystem([10, 20]) >>> system.assign() 0 >>> system.evaluate() 10.0 >>> system.assign() 1 >>> system.evaluate() 15.0","solution":"class RideSharingSystem: def __init__(self, drivers): self.drivers = drivers self.available_drivers = set(range(len(drivers))) self.assigned_drivers = {} def assign(self): if not self.available_drivers: return -1 nearest_driver_id = min(self.available_drivers, key=lambda x: (self.drivers[x], x)) self.available_drivers.remove(nearest_driver_id) self.assigned_drivers[nearest_driver_id] = self.drivers[nearest_driver_id] return nearest_driver_id def free(self, driverId): if driverId in self.assigned_drivers: del self.assigned_drivers[driverId] self.available_drivers.add(driverId) def evaluate(self): if not self.assigned_drivers: return 0.0 total_distance = sum(self.assigned_drivers.values()) return total_distance / len(self.assigned_drivers)"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string s, find the length of the longest substring without repeating characters. Parameters: s (str): The input string Returns: int: The length of the longest substring without repeating characters Examples: >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"abcbabcd\\") 4","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for index, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = index longest = max(longest, index - start + 1) return longest"},{"question":"from typing import List def count_subsequence_occurrences(words: List[str], subsequence: str) -> int: Given a list of strings \`words\`, and a single string \`subsequence\`, return the count of strings within \`words\` that contain \`subsequence\` as a subsequence. >>> count_subsequence_occurrences([\\"abc\\", \\"aebdc\\", \\"ac\\", \\"akd\\"], \\"abc\\") 2 >>> count_subsequence_occurrences([\\"xyz\\", \\"qwerty\\", \\"mnop\\"], \\"abc\\") 0 >>> count_subsequence_occurrences([], \\"abc\\") 0 >>> count_subsequence_occurrences([\\"abc\\", \\"aebdc\\", \\"ac\\", \\"akd\\"], \\"\\") 4 >>> count_subsequence_occurrences([\\"abc\\", \\"abc\\", \\"abc\\", \\"abc\\"], \\"abc\\") 4 >>> count_subsequence_occurrences([\\"a\\", \\"b\\", \\"c\\", \\"d\\"], \\"a\\") 1","solution":"def count_subsequence_occurrences(words, subsequence): def is_subsequence(s, subseq): subseq_index = 0 for char in s: if subseq_index < len(subseq) and char == subseq[subseq_index]: subseq_index += 1 if subseq_index == len(subseq): return True return subseq_index == len(subseq) count = 0 for word in words: if is_subsequence(word, subsequence): count += 1 return count"},{"question":"def smallest_rectangle_area(words: List[str]) -> int: Returns the area of the smallest rectangle that can be formed using the words such that each word is a row in the rectangle and all columns are unique. If such a rectangle does not exist, return -1. >>> smallest_rectangle_area([\\"ab\\",\\"cd\\",\\"ef\\"]) 6 >>> smallest_rectangle_area([\\"aa\\", \\"bb\\", \\"cc\\"]) -1 >>> smallest_rectangle_area([\\"a\\", \\"a\\", \\"a\\", \\"a\\"]) 4 >>> smallest_rectangle_area([\\"abcd\\",\\"efgh\\",\\"ijkl\\",\\"mnop\\"]) 16 >>> smallest_rectangle_area([\\"abcdef\\", \\"ghijkl\\"]) 12","solution":"def smallest_rectangle_area(words): Returns the area of the smallest rectangle that can be formed using the words such that each word is a row in the rectangle and all columns are unique. If such a rectangle does not exist, return -1. from itertools import permutations def has_unique_columns(words_rect): cols = [''.join(row[i] for row in words_rect) for i in range(len(words_rect[0]))] return len(cols) == len(set(cols)) min_area = float('inf') word_length = len(words[0]) for perm in permutations(words): if has_unique_columns(perm): min_area = min(min_area, len(words) * word_length) break return min_area if min_area != float('inf') else -1"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. Parameters: s (str): The input string. Returns: int: The length of the longest substring without repeating characters. >>> length_of_longest_substring('') == 0 >>> length_of_longest_substring('a') == 1 >>> length_of_longest_substring('abcdef') == 6 >>> length_of_longest_substring('abcabcbb') == 3 >>> length_of_longest_substring('bbbbb') == 1 >>> length_of_longest_substring('pwwkew') == 3 >>> length_of_longest_substring('abrkaabcdefghijjxxx') == 10 >>> length_of_longest_substring('!@#%^&') == 7 >>> length_of_longest_substring('1234567890abcdefgh') == 18","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. Parameters: s (str): The input string. Returns: int: The length of the longest substring without repeating characters. char_index = {} longest_length = 0 start = 0 for end in range(len(s)): if s[end] in char_index: start = max(start, char_index[s[end]] + 1) char_index[s[end]] = end longest_length = max(longest_length, end - start + 1) return longest_length"},{"question":"from typing import List def max_length_no_valley(arr: List[int]) -> int: Calculate the maximum length of the array where no element is smaller than both its previous and next elements. >>> max_length_no_valley([1, 2, 3]) 3 >>> max_length_no_valley([3, 2, 1]) 3 >>> max_length_no_valley([2, 1, 2]) 2 >>> max_length_no_valley([2, 1, 3, 1, 4]) 3 >>> max_length_no_valley([1, 3, 5, 7]) 4 >>> max_length_no_valley([5, 1, 2, 3, 4, 0, 6, 1, 7]) 6 >>> max_length_no_valley([]) 0 >>> max_length_no_valley([1]) 1 >>> max_length_no_valley([1, 2]) 2","solution":"def max_length_no_valley(arr): Calculate the maximum length of the array where no element is smaller than both its previous and next elements. if len(arr) < 3: return len(arr) to_remove = set() for i in range(1, len(arr)-1): if arr[i] < arr[i-1] and arr[i] < arr[i+1]: to_remove.add(i) # Removing indices in to_remove set new_arr = [arr[i] for i in range(len(arr)) if i not in to_remove] return len(new_arr)"},{"question":"from typing import List def three_sum(arr: List[int], target: int) -> bool: Determines if there exist three integers in \`arr\` such that their sum is \`target\`. :param arr: List of integers :param target: Integer target sum :return: Boolean indicating if there is a combination of three integers that sum to \`target\` >>> three_sum([1, 2, 3, 4, 5], 12) True >>> three_sum([10, 20, -10, -20, 30, -30], 0) True >>> three_sum([0, -1, 2, -3, 1], 0) True >>> three_sum([1, 2, 3, 4, 5], 50) False >>> three_sum([1, -1, 1, -1], 3) False >>> three_sum([1, 1, -2], 5) False >>> three_sum([], 0) False >>> three_sum([1], 1) False >>> three_sum([1, 2], 3) False >>> three_sum([1, 2, 3], 7) False >>> three_sum([1, 1, 1, 2, 2, 2], 6) True >>> three_sum([0, 0, 0, 0, 0, 0], 0) True >>> three_sum([1, 1, 1, 1], 4) False","solution":"def three_sum(arr, target): Determines if there exist three integers in \`arr\` such that their sum is \`target\`. :param arr: List of integers :param target: Integer target sum :return: Boolean indicating if there is a combination of three integers that sum to \`target\` arr.sort() n = len(arr) for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, n - 1 while left < right: total = arr[i] + arr[left] + arr[right] if total == target: return True elif total < target: left += 1 else: right -= 1 return False"},{"question":"def maxBalloons(nums: List[int]) -> int: Given an array of integers \`nums\` representing the number of balloons in each room, you need to deflate balloons in such a way that no two adjacent rooms have non-zero balloons at the same time. Return the maximum total number of balloons you can leave inflated after deflating some rooms under the given condition. >>> maxBalloons([]) == 0 >>> maxBalloons([5]) == 5 >>> maxBalloons([5, 10]) == 10 >>> maxBalloons([2, 3, 2]) == 4 >>> maxBalloons([1, 2, 3, 1]) == 4 >>> maxBalloons([5, 5, 10, 100, 10, 5]) == 110 >>> maxBalloons([10, 20, 30, 40, 50, 60]) == 120 >>> maxBalloons([50, 1, 1, 50]) == 100 >>> maxBalloons([10, 50, 10, 50, 10]) == 100","solution":"def maxBalloons(nums): n = len(nums) if n == 0: return 0 elif n == 1: return nums[0] dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"def is_palindrome(s, l, r): Checks if the substring s[l:r+1] is a palindrome. substring = s[l:r+1] return substring == substring[::-1] def check_palindromes(s, queries): Given a string s and a list of queries (l, r) pairs, returns a list of boolean values indicating whether the substring s[l:r+1] is a palindrome. >>> check_palindromes(\\"racecar\\", [(0, 6), (1, 5), (2, 4)]) [True, True, True] >>> check_palindromes(\\"hello\\", [(0, 1), (0, 2), (3, 4)]) [False, False, False]","solution":"def is_palindrome(s, l, r): Checks if the substring s[l:r+1] is a palindrome. substring = s[l:r+1] return substring == substring[::-1] def check_palindromes(s, queries): Given a string s and a list of queries (l, r) pairs, returns a list of boolean values indicating whether the substring s[l:r+1] is a palindrome. results = [] for l, r in queries: results.append(is_palindrome(s, l, r)) return results"},{"question":"def min_x_length_subsequence_sum(nums, x): Returns the minimum sum of any x-length subsequence in the nums array. A subsequence consists of x consecutive elements in the array. >>> min_x_length_subsequence_sum([4, 3, 2, 1, 6], 2) 3 >>> min_x_length_subsequence_sum([1, 2, 3, 4, 5], 3) 6 >>> min_x_length_subsequence_sum([5, 3, 1, 2, 6], 1) 1 >>> min_x_length_subsequence_sum([3, 2, -1, 4, 1], 2) 1 >>> min_x_length_subsequence_sum([10, 20, 30, 40, 50], 4) 100 >>> min_x_length_subsequence_sum([], 3) 0 >>> min_x_length_subsequence_sum([2, 3, 1], 0) 0 >>> min_x_length_subsequence_sum([4, 5, 2, 1], 5) 0","solution":"def min_x_length_subsequence_sum(nums, x): Returns the minimum sum of any x-length subsequence in the nums array. A subsequence consists of x consecutive elements in the array. if not nums or x <= 0 or x > len(nums): return 0 # Initialize the minimum sum with a large value min_sum = float('inf') # Slide a window of size x across the array current_sum = sum(nums[:x]) min_sum = min(min_sum, current_sum) for i in range(x, len(nums)): current_sum += nums[i] - nums[i - x] min_sum = min(min_sum, current_sum) return min_sum"},{"question":"def largest_group(employees_projects: dict) -> int: Determine the maximum number of employees who have participated in at least one project together, directly or indirectly. >>> employees_projects = { 'project1': [1, 2, 3], 'project2': [3, 4, 5], 'project3': [5, 6, 7], 'project4': [8], 'project5': [9, 10], } >>> largest_group(employees_projects) 7 >>> employees_projects = { 'project1': [1, 2, 3, 4, 5] } >>> largest_group(employees_projects) 5 >>> employees_projects = { 'project1': [1, 2], 'project2': [3, 4], 'project3': [5, 6] } >>> largest_group(employees_projects) 2 >>> employees_projects = { 'project1': [1], 'project2': [2], 'project3': [3], 'project4': [4] } >>> largest_group(employees_projects) 1 >>> employees_projects = { 'project1': [1, 2, 3], 'project2': [3, 4], 'project3': [4, 5, 6] } >>> largest_group(employees_projects) 6 # Implementation goes here","solution":"def largest_group(employees_projects): from collections import defaultdict # Create a dictionary to map employee to projects employee_projects = defaultdict(set) for project, employees in employees_projects.items(): for employee in employees: employee_projects[employee].add(project) # Create a graph where nodes are employees and edges exist if they share a project graph = defaultdict(list) for project, employees in employees_projects.items(): for i in range(len(employees)): for j in range(i + 1, len(employees)): graph[employees[i]].append(employees[j]) graph[employees[j]].append(employees[i]) # To find the largest connected component, we perform DFS/BFS on the graph def dfs(employee, visited): stack = [employee] size = 0 while stack: emp = stack.pop() if emp not in visited: visited.add(emp) size += 1 for neighbor in graph[emp]: if neighbor not in visited: stack.append(neighbor) return size visited = set() max_group_size = 0 for employee in employee_projects.keys(): if employee not in visited: max_group_size = max(max_group_size, dfs(employee, visited)) return max_group_size"},{"question":"class Solution: Given a string \`s\`, return the longest palindromic substring in \`s\`. >>> sol = Solution(\\"babad\\") >>> sol.longestPalindrome() in {\\"bab\\", \\"aba\\"} True >>> sol = Solution(\\"a\\") >>> sol.longestPalindrome() \\"a\\" >>> sol = Solution(\\"ac\\") >>> sol.longestPalindrome() in {\\"a\\", \\"c\\"} True >>> sol = Solution(\\"cbbd\\") >>> sol.longestPalindrome() \\"bb\\" >>> sol = Solution(\\"racecar\\") >>> sol.longestPalindrome() \\"racecar\\" >>> sol = Solution(\\"\\") >>> sol.longestPalindrome() \\"\\" def __init__(self, s: str): self.s = s def longestPalindrome(self) -> str: pass","solution":"class Solution: def __init__(self, s): self.s = s def longestPalindrome(self): s = self.s n = len(s) if n == 0: return \\"\\" longest_palindrome = \\"\\" def expand_around_center(left, right): while left >= 0 and right < n and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] for i in range(n): odd_palindrome = expand_around_center(i, i) even_palindrome = expand_around_center(i, i + 1) current_longest = max(odd_palindrome, even_palindrome, longest_palindrome, key=len) if len(current_longest) > len(longest_palindrome): longest_palindrome = current_longest return longest_palindrome"},{"question":"def min_operations(s1: str, s2: str) -> int: Returns the minimum number of operations required to transform s1 into s2. >>> min_operations(\\"intention\\", \\"execution\\") 5 >>> min_operations(\\"\\", \\"test\\") 4 >>> min_operations(\\"test\\", \\"\\") 4 >>> min_operations(\\"abcdef\\", \\"abcdef\\") 0 >>> min_operations(\\"a\\", \\"b\\") 1 >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"flaw\\", \\"lawn\\") 2 >>> min_operations(\\"gumbo\\", a: 4 }, { s: \\"enter\\", a: 5 }]) \\"enter\\"","solution":"def min_operations(s1, s2): Returns the minimum number of operations required to transform s1 into s2. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If s1 is empty, insert all characters of s2 elif j == 0: dp[i][j] = i # If s2 is empty, delete all characters of s1 elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no operation needed else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Delete dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"def uniquePathsWithObstacles(grid): Returns the number of unique paths from top-left to bottom-right corner of the grid, avoiding obstacles represented by 1. >>> uniquePathsWithObstacles([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 6 >>> uniquePathsWithObstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 2 >>> uniquePathsWithObstacles([[1, 0], [0, 0]]) == 0 >>> uniquePathsWithObstacles([[0, 0], [0, 1]]) == 0 >>> uniquePathsWithObstacles([[0, 0, 0, 1, 0]]) == 0 >>> uniquePathsWithObstacles([[0], [0], [1], [0]]) == 0 >>> uniquePathsWithObstacles([[0]]) == 1 >>> uniquePathsWithObstacles([[1]]) == 0","solution":"def uniquePathsWithObstacles(grid): Returns the number of unique paths from top-left to bottom-right corner of the grid, avoiding obstacles represented by 1. if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] # Start point dp[0][0] = 1 # Fill the dp table for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def smallest_substring_with_distinct_chars(s: str, p: int) -> int: Returns the length of the smallest substring such that the number of distinct characters in the substring is greater than or equal to p. If no such substring exists, returns -1. >>> smallest_substring_with_distinct_chars(\\"aabcabcab\\", 3) == 3 >>> smallest_substring_with_distinct_chars(\\"aaaa\\", 2) == -1 >>> smallest_substring_with_distinct_chars(\\"abcdef\\", 6) == 6 >>> smallest_substring_with_distinct_chars(\\"abcabcabc\\", 4) == -1 >>> smallest_substring_with_distinct_chars(\\"aabbcc\\", 2) == 2 >>> smallest_substring_with_distinct_chars(\\"aabbcc\\", 3) == 4 >>> smallest_substring_with_distinct_chars(\\"xyzabcklmn\\", 5) == 5 >>> smallest_substring_with_distinct_chars(\\"a\\", 1) == 1 >>> smallest_substring_with_distinct_chars(\\"a\\", 2) == -1 >>> smallest_substring_with_distinct_chars(\\"\\", 1) == -1 >>> smallest_substring_with_distinct_chars(\\"\\", 0) == 0 >>> smallest_substring_with_distinct_chars(\\"a\\"*1000, 1) == 1 >>> smallest_substring_with_distinct_chars(\\"a\\"*1000, 2) == -1","solution":"def smallest_substring_with_distinct_chars(s, p): Returns the length of the smallest substring such that the number of distinct characters in the substring is greater than or equal to p. If no such substring exists, returns -1. from collections import defaultdict if p == 0: return 0 n = len(s) if p > n: return -1 left, right = 0, 0 char_count = defaultdict(int) distinct_count = 0 min_length = float('inf') while right < n: char_count[s[right]] += 1 if char_count[s[right]] == 1: distinct_count += 1 while distinct_count >= p: min_length = min(min_length, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: distinct_count -= 1 left += 1 right += 1 return min_length if min_length != float('inf') else -1"},{"question":"def checkDistances(s: str, distance: List[int]) -> bool: Determine if the distance values are correctly mapped for string \`s\`. :param s: A string consisting of lowercase English letters. :param distance: An integer array of length 26 representing the distances for each letter. :return: True if the distances are correctly mapped, otherwise False. >>> checkDistances('abac', [1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]) True >>> checkDistances('abca', [1, 3, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]) False >>> checkDistances('a', [0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]) True >>> checkDistances('abcdef', [0, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]) True","solution":"def checkDistances(s, distance): first_occurrence = [-1] * 26 for i, char in enumerate(s): idx = ord(char) - ord('a') if first_occurrence[idx] == -1: first_occurrence[idx] = i else: if i - first_occurrence[idx] - 1 != distance[idx]: return False return True"},{"question":"def subarray_sum(arr, k): Given an array of integers \`arr\`, find the number of contiguous subarrays that have a sum equal to a given integer \`k\`. Parameters: arr (list): List of integers k (int): The target sum Returns: int: The count of subarrays that sum to k >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([1], 1) 1 >>> subarray_sum([1, 2, 3], 6) 1 >>> subarray_sum([1, -1, 2, 3, -1, 1], 3) 3 >>> subarray_sum([-1, -1, 1, 0, 1, 1], 0) 4 >>> subarray_sum([], 0) 0","solution":"def subarray_sum(arr, k): Returns the number of contiguous subarrays that have a sum equal to k. Parameters: arr (list): List of integers k (int): The target sum Returns: int: The count of subarrays that sum to k count = 0 current_sum = 0 sum_dict = {0: 1} # To handle the case when subarray starts from index 0 for num in arr: current_sum += num if current_sum - k in sum_dict: count += sum_dict[current_sum - k] if current_sum in sum_dict: sum_dict[current_sum] += 1 else: sum_dict[current_sum] = 1 return count"},{"question":"def reverse_words(s: str) -> str: Given a string \`s\` representing a sentence, return the same sentence with the words reversed. >>> reverse_words(\\"hello world\\") 'world hello' >>> reverse_words(\\" leading spaces\\") 'spaces leading'","solution":"def reverse_words(s): Reverses the words in the input sentence while retaining their original order. Parameters: s (str): A sentence where words are separated by spaces. Returns: str: The sentence with the words' order reversed. # Split the sentence into words words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list into a new sentence reversed_sentence = ' '.join(reversed_words) return reversed_sentence"},{"question":"def max_rectangle_area(buildings: List[int]) -> int: Calculates the maximum area of a rectangle that can be formed by any two buildings. Args: buildings (List[int]): List of building heights. Returns: int: The maximum area. Examples: >>> max_rectangle_area([1, 5, 4, 3]) == 9 >>> max_rectangle_area([3, 3, 3, 3]) == 12 >>> max_rectangle_area([1, 2, 3, 4, 5]) == 9 >>> max_rectangle_area([5, 4, 3, 2, 1]) == 9 >>> max_rectangle_area([5]) == 0 >>> max_rectangle_area([]) == 0 >>> max_rectangle_area([2, 2]) == 4","solution":"def max_rectangle_area(buildings): Calculates the maximum area of a rectangle that can be formed by any two buildings. Args: buildings (List[int]): List of building heights. Returns: int: The maximum area. max_area = 0 n = len(buildings) for i in range(n): for j in range(i+1, n): height = min(buildings[i], buildings[j]) width = j - i + 1 area = height * width max_area = max(max_area, area) return max_area"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_subtree_sum(root): Returns the largest subtree sum in the given binary tree. Parameters: root (TreeNode): The root node of the binary tree. Returns: int: The largest subtree sum. pass # Example usage: # root = TreeNode(1) # root.left = TreeNode(2) # root.right = TreeNode(3) # subtree_sum = largest_subtree_sum(root) # print(subtree_sum) # Expected output is 6 (subtree with root node 1)","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_subtree_sum(root): Returns the largest subtree sum in the given binary tree. Parameters: root (TreeNode): The root node of the binary tree. Returns: int: The largest subtree sum. def subtree_sum(node): if node is None: return 0 left_sum = subtree_sum(node.left) right_sum = subtree_sum(node.right) current_sum = node.val + left_sum + right_sum # Track the maximum subtree sum encountered so far nonlocal max_sum if current_sum > max_sum: max_sum = current_sum return current_sum max_sum = float('-inf') subtree_sum(root) return max_sum # Example usage: # root = TreeNode(1) # root.left = TreeNode(2) # root.right = TreeNode(3) # subtree_sum = largest_subtree_sum(root) # print(subtree_sum) # Expected output is 6 (subtree with root node 1)"},{"question":"def min_length_after_operations(s: str) -> int: Returns the minimum possible length of string s after performing the given operations. >>> min_length_after_operations(\\"a\\") 1 >>> min_length_after_operations(\\"aaaa\\") 1 >>> min_length_after_operations(\\"ababab\\") 2 >>> min_length_after_operations(\\"aabbcc\\") 3 >>> min_length_after_operations(\\"abc\\") 3 >>> min_length_after_operations(\\"aabbccddeeff\\") 6","solution":"def min_length_after_operations(s): Returns the minimum possible length of string s after performing the given operations. from collections import Counter # Count the occurrences of each character in the string. char_count = Counter(s) # The minimum possible length is the number of unique characters in the string. return len(char_count)"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def rearrange_odd_even(head: ListNode) -> ListNode: Rearrange the linked list such that all odd-indexed nodes are grouped together followed by the even-indexed nodes. The node values should retain their relative order among the odd-indexed and even-indexed nodes. >>> list_to_linked([1,2,3,4,5]) [1,3,5,2,4] >>> list_to_linked([1]) [1] >>> list_to_linked([1,2]) [1, 2] >>> list_to_linked([2,4,6,8,10]) [2, 6, 10, 4, 8] >>> list_to_linked([1,2,3,4,5,6,7,8]) [1,3,5,7,2,4,6,8] >>> list_to_linked(None) [] pass def list_to_linked(lst): if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head def linked_to_list(node): lst = [] while node: lst.append(node.value) node = node.next return lst","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def rearrange_odd_even(head): if not head or not head.next: return head odd = head even = head.next even_head = even while even and even.next: odd.next = odd.next.next even.next = even.next.next odd = odd.next even = even.next odd.next = even_head return head"},{"question":"def max_robbed_money(arr, k): Calculate the maximum amount of money you can rob without alerting the police. You cannot rob two consecutive houses, and you must skip at least 'k' houses between each robbing. >>> max_robbed_money([], 2) == 0 >>> max_robbed_money([5], 1) == 5 >>> max_robbed_money([5, 10], 2) == 10 >>> max_robbed_money([3, 2, 5, 10, 7], 1) == 15 >>> max_robbed_money([3, 2, 5, 10, 7], 2) == 13 >>> max_robbed_money([1, 2, 3, 4, 5], 4) == 5 >>> max_robbed_money([6, 7, 1, 30, 8, 2, 4], 1) == 41 >>> max_robbed_money([5, 3, 4], 5) == 5 >>> max_robbed_money([7, 4, 5, 6], 6) == 7","solution":"def max_robbed_money(arr, k): n = len(arr) if not arr: return 0 if k >= n: return max(arr) dp = [0] * n dp[0] = arr[0] for i in range(1, n): if i <= k: dp[i] = max(dp[i-1], arr[i]) # up to first k houses, we can only rob individually up to the max else: dp[i] = max(dp[i-1], arr[i] + dp[i-k-1]) return dp[-1]"},{"question":"def isAncestor(n: int, edges: List[List[int]], queries: List[List[int]]) -> List[bool]: You are given a binary tree with \`n\` nodes, where each node has a unique value from \`1\` to \`n\`. Determine if one node is an ancestor of another node for each query. Parameters: n (int): The number of nodes in the tree. edges (List[List[int]]): The edges of the tree where edges[i] = [a, b] indicates an edge from \`a\` to \`b\`. queries (List[List[int]]): A list of queries where queries[i] = [u, v] determines if \`u\` is an ancestor of \`v\`. Returns: List[bool]: An array of boolean values for each query, indicating if \`u\` is an ancestor of \`v\`. >>> isAncestor(5, [[1, 2], [1, 3], [2, 4], [2, 5]], [[1, 4], [2, 5], [3, 5], [1, 1], [4, 4]]) [True, True, False, True, True] >>> isAncestor(1, [], [[1, 1]]) [True] >>> isAncestor(5, [[1, 2], [2, 3], [3, 4], [4, 5]], [[1, 5], [2, 4], [3, 5], [1, 3], [4, 1]]) [True, True, True, True, False] >>> isAncestor(4, [[1, 2], [1, 3], [1, 4]], [[1, 2], [1, 3], [1, 4], [2, 3], [3, 4]]) [True, True, True, False, False] >>> isAncestor(6, [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6]], [[1, 4], [1, 5], [1, 6], [2, 5], [3, 2], [3, 6]]) [True, True, True, True, False, True]","solution":"def isAncestor(n, edges, queries): from collections import defaultdict, deque # Build adjacency list adj_list = defaultdict(list) for a, b in edges: adj_list[a].append(b) # Define parents for each node and initialize with None parent = {i: None for i in range(1, n+1)} parent[1] = 0 # As root has no parent, we can use 0 as a mark # BFS to set all parent nodes def bfs(root): queue = deque([root]) while queue: node = queue.popleft() for child in adj_list[node]: if parent[child] is None: parent[child] = node queue.append(child) # Call bfs starting from root node bfs(1) # Helper function to find if u is ancestor of v def is_ancestor(u, v): while v and v != u: v = parent[v] return v == u # Result for each query return [is_ancestor(u, v) for u, v in queries]"},{"question":"def max_bridges(heights, k): Returns the maximum number of bridges that can be placed given the heights of the buildings and the maximum allowable height difference for a bridge, k. >>> max_bridges([10, 30, 50], 5) == 0 >>> max_bridges([1, 2, 3, 4, 5], 1) == 2 >>> max_bridges([10, 13, 15, 17, 19], 3) == 2 >>> max_bridges([1, 3, 5, 7, 9], 2) == 2 >>> max_bridges([10, 10, 10, 10], 0) == 2 >>> max_bridges([10], 5) == 0 >>> max_bridges([7, 7, 7, 7], 0) == 2","solution":"def max_bridges(heights, k): Returns the maximum number of bridges that can be placed given the heights of the buildings and the maximum allowable height difference for a bridge, k. # Sort the array of heights heights.sort() max_count = 0 i = 0 while i < len(heights) - 1: if abs(heights[i] - heights[i + 1]) <= k: max_count += 1 i += 2 # skip the next element as it is already paired else: i += 1 return max_count"},{"question":"def maximal_square(matrix: List[List[str]]) -> int: Given a 2D binary matrix, return the maximum square area of 1's that can be formed within the matrix. >>> maximal_square([ ... [\\"1\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"0\\",\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"0\\",\\"0\\",\\"1\\",\\"0\\"] ... ]) 4 >>> maximal_square([ ... [\\"0\\",\\"1\\"], ... [\\"1\\",\\"0\\"] ... ]) 1 >>> maximal_square([ ... [\\"0\\"] ... ]) 0 >>> maximal_square([ ... [\\"1\\",\\"1\\"], ... [\\"1\\",\\"1\\"] ... ]) 4 >>> maximal_square([]) 0","solution":"def maximal_square(matrix): if not matrix: return 0 n = len(matrix) m = len(matrix[0]) dp = [[0] * (m + 1) for _ in range(n + 1)] max_side = 0 for i in range(1, n + 1): for j in range(1, m + 1): if matrix[i - 1][j - 1] == '1': dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"def max_k_constrained_product(nums, k): Returns the maximum product of all k-constrained subarrays. Parameters: nums (list): A list of integers. k (int): The constraint length of the subarray. Returns: int: The maximum product of all k-constrained subarrays. >>> max_k_constrained_product([1, 2, 3, 4], 2) 12 >>> max_k_constrained_product([1, 2], 3) 2 >>> max_k_constrained_product([3], 1) 3 >>> max_k_constrained_product([-1, -2, -3, -4], 2) 12 >>> max_k_constrained_product([-1, 2, -3, 4], 3) 6 >>> max_k_constrained_product([0, 0, 0, 0], 2) 0","solution":"def max_k_constrained_product(nums, k): Returns the maximum product of all k-constrained subarrays. Parameters: nums (list): A list of integers. k (int): The constraint length of the subarray. Returns: int: The maximum product of all k-constrained subarrays. if not nums: return 0 max_product = float('-inf') for i in range(len(nums)): product = 1 for j in range(k): if i + j < len(nums): product *= nums[i + j] else: break max_product = max(max_product, product) return max_product"},{"question":"from typing import List class Solution: def __init__(self, nums: List[int], k: int): Initializes the object with the array \`nums\` and the integer \`k\`. >>> Solution([1, 2, 3, 4, 5], 2) # Initializes the array and k self.nums = nums self.k = k def maxSumSubarray(self) -> int: Returns the maximum possible sum of a subarray with length \`k\`. >>> s = Solution([1, 2, 3, 4, 5], 2) >>> s.maxSumSubarray() 9 # subarray [4, 5] pass def minSumSubarray(self) -> int: Returns the minimum possible sum of a subarray with length \`k\`. >>> s = Solution([1, 2, 3, 4, 5], 2) >>> s.minSumSubarray() 3 # subarray [1, 2] pass","solution":"class Solution: def __init__(self, nums, k): self.nums = nums self.k = k def maxSumSubarray(self): if not self.nums or self.k <= 0 or self.k > len(self.nums): return 0 max_sum = sum(self.nums[:self.k]) window_sum = max_sum for i in range(self.k, len(self.nums)): window_sum += self.nums[i] - self.nums[i - self.k] max_sum = max(max_sum, window_sum) return max_sum def minSumSubarray(self): if not self.nums or self.k <= 0 or self.k > len(self.nums): return 0 min_sum = sum(self.nums[:self.k]) window_sum = min_sum for i in range(self.k, len(self.nums)): window_sum += self.nums[i] - self.nums[i - self.k] min_sum = min(min_sum, window_sum) return min_sum"},{"question":"def minimum_length_subarray_with_product(arr, k): Determine the minimum length of a contiguous subarray of arr such that the product of its elements is equal to k. If no such subarray exists, return -1. >>> minimum_length_subarray_with_product([2, 3, 1, 2, 4, 3], 8) == 2 >>> minimum_length_subarray_with_product([1, 2, 3, 4], 6) == 2 >>> minimum_length_subarray_with_product([10, 2, 2, 5, 4], 20) == 2 >>> minimum_length_subarray_with_product([1, 2, 3], 100) == -1 >>> minimum_length_subarray_with_product([5, 1, 3, 2], 3) == 1 >>> minimum_length_subarray_with_product([2, 5, 2], 20) == 3","solution":"def minimum_length_subarray_with_product(arr, k): Determine the minimum length of a contiguous subarray of arr such that the product of its elements is equal to k. If no such subarray exists, return -1. n = len(arr) left = 0 product = 1 min_length = float('inf') for right in range(n): product *= arr[right] while product >= k and left <= right: if product == k: min_length = min(min_length, right - left + 1) product //= arr[left] left += 1 return min_length if min_length != float('inf') else -1"},{"question":"class ParkingSystem: A class to simulate the parking system of a multi-storey car park. ParkingSystem(int[] levelsAndSlots): Initializes the car park with the given configuration where levelsAndSlots[i] represents the number of slots available on the i-th level. parkCar(int level) -> bool: Attempts to park a car on the given level. If there is an available slot for the car on the given level, the car is parked and the method returns True. Otherwise, the method returns False. leaveCar(int level) -> bool: Removes a car from the given level. If there is such a car on the level, it is removed and the method returns True. Otherwise, the method returns False. def __init__(self, levelsAndSlots): # Add necessary initializations def parkCar(self, level: int) -> bool: Attempts to park a car on the specified level. # Implementation def leaveCar(self, level: int) -> bool: Attempts to remove a car from the specified level. # Implementation # Example usage if __name__ == \\"__main__\\": ps = ParkingSystem([2, 3, 4]) print(ps.parkCar(0)) # True print(ps.parkCar(0)) # True print(ps.parkCar(0)) # False print(ps.parkCar(1)) # True print(ps.parkCar(2)) # True print(ps.leaveCar(1)) # True print(ps.leaveCar(1)) # False print(ps.leaveCar(2)) # True print(ps.leaveCar(2)) # True print(ps.leaveCar(0)) # True","solution":"class ParkingSystem: def __init__(self, levelsAndSlots): self.levels = [] for slots in levelsAndSlots: self.levels.append({ 'total_slots': slots, 'occupied_slots': 0 }) def parkCar(self, level): if level < len(self.levels) and self.levels[level]['occupied_slots'] < self.levels[level]['total_slots']: self.levels[level]['occupied_slots'] += 1 return True return False def leaveCar(self, level): if level < len(self.levels) and self.levels[level]['occupied_slots'] > 0: self.levels[level]['occupied_slots'] -= 1 return True return False"},{"question":"def islandPerimeter(grid: List[List[int]]) -> int: Given a binary matrix \`grid\`, where each cell is either \`0\` (representing water) or \`1\` (representing land), return the length of the perimeter of the island in \`grid\`. The island is always surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. >>> islandPerimeter([[0, 1], [1, 1]]) 8 >>> islandPerimeter([[1, 1], [1, 1]]) 8 >>> islandPerimeter([[1]]) 4 >>> islandPerimeter([[0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0]]) 16 >>> islandPerimeter([[0, 0, 0], [0, 0, 0]]) 0 >>> islandPerimeter([[0]]) 0","solution":"def islandPerimeter(grid): Returns the perimeter of the island in the binary matrix grid. :param grid: List[List[int]] - A list of lists where each element is either 0 or 1. :return: int - The perimeter of the island. rows = len(grid) cols = len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: perimeter += 4 if r > 0 and grid[r-1][c] == 1: # Check above perimeter -= 2 if c > 0 and grid[r][c-1] == 1: # Check left perimeter -= 2 return perimeter"},{"question":"def find_target_sum_ways(nums: List[int], target: int) -> int: Returns the number of different expressions that can be constructed out of nums which evaluates to target. >>> find_target_sum_ways([1, 1, 1, 1, 1], 3) == 5 >>> find_target_sum_ways([1], 1) == 1 >>> find_target_sum_ways([1, 2, 1, 2], 0) == 4 >>> find_target_sum_ways([1, 2, 3], 7) == 0 >>> find_target_sum_ways([1, 2, 3], -6) == 1 >>> find_target_sum_ways([0, 0, 0], 0) == 8","solution":"def find_target_sum_ways(nums, target): Returns the number of different expressions that can be constructed out of nums which evaluates to target. from collections import defaultdict dp = defaultdict(int) dp[0] = 1 for num in nums: next_dp = defaultdict(int) for sum_ in dp: next_dp[sum_ + num] += dp[sum_] next_dp[sum_ - num] += dp[sum_] dp = next_dp return dp[target]"},{"question":"from typing import List def longest_subarray_with_k_distinct(nums: List[int], k: int) -> int: Given an array \`nums\` of integers and an integer \`k\`, return the length of the longest continuous subarray that contains at most \`k\` distinct integers. >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3], 2) == 4 >>> longest_subarray_with_k_distinct([1], 1) == 1 >>> longest_subarray_with_k_distinct([1, 2, 3, 4, 5], 5) == 5 >>> longest_subarray_with_k_distinct([2, 2, 2, 2], 1) == 4 >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3], 3) == 5 >>> longest_subarray_with_k_distinct([1, 2, 3, 4, 5], 0) == 0 >>> longest_subarray_with_k_distinct([], 1) == 0","solution":"def longest_subarray_with_k_distinct(nums, k): Returns the length of the longest continuous subarray that contains at most k distinct integers. Parameters: nums (list of int): A list of integers. k (int): Number of distinct integers allowed in the subarray. Returns: int: Length of the longest subarray with at most k distinct integers. from collections import defaultdict n = len(nums) if n == 0 or k == 0: return 0 left = 0 right = 0 max_length = 0 count = defaultdict(int) while right < n: count[nums[right]] += 1 while len(count) > k: count[nums[left]] -= 1 if count[nums[left]] == 0: del count[nums[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def reorder_to_standard_lexicographical(order: str, words: List[str]) -> List[str]: Reorder the array of strings \`words\` according to the standard lexicographical order. >>> reorder_to_standard_lexicographical(\\"abcdefghijklmnopqrstuvwxyz\\", [\\"word\\", \\"apple\\", \\"hero\\"]) [\\"apple\\", \\"hero\\", \\"word\\"] >>> reorder_to_standard_lexicographical(\\"zyxwvutsrqponmlkjihgfedcba\\", [\\"cherry\\", \\"banana\\", \\"apple\\"]) [\\"apple\\", \\"banana\\", \\"cherry\\"]","solution":"def reorder_to_standard_lexicographical(order, words): Reorder the array of strings \`words\` according to the standard lexicographical order. Parameters: order (str): A permutation of the lowercase English letters. words (list): An array of strings sorted according to the order defined by \`order\`. Returns: list: The reordered array of strings according to standard lexicographical order. return sorted(words)"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Given a string \`s\` and an integer array \`indices\` of the same length, return a new string where each character is relocated to the position specified in \`indices\`. >>> restore_string(\\"codeleet\\", [4,5,6,7,0,2,1,3]) == \\"leetcode\\" >>> restore_string(\\"a\\", [0]) == \\"a\\" >>> restore_string(\\"\\", []) == \\"\\" >>> restore_string(\\"abcd\\", [3, 2, 1, 0]) == \\"dcba\\" >>> restore_string(\\"test\\", [0, 1, 2, 3]) == \\"test\\"","solution":"def restore_string(s, indices): Restores the string such that the character at the i-th position moves to indices[i]. Parameters: s (str): The original string. indices (list of int): The new positions for each character. Returns: str: The restored string. # Create a list with the same length as s, initialized with empty characters restored = [''] * len(s) # Iterate over each character in the string along with its index for i, char in enumerate(s): # Place the character at its new position as specified in indices restored[indices[i]] = char # Join the list into a string and return it return ''.join(restored)"},{"question":"def decode_string(encoded_str: str) -> str: Decodes the given encoded string where each character group is followed by an integer representing the number of times the characters should be repeated. >>> decode_string(\\"a2\\") \\"aa\\" >>> decode_string(\\"b3\\") \\"bbb\\" >>> decode_string(\\"a2b3\\") \\"aabbb\\" >>> decode_string(\\"x1y5z2\\") \\"xyyyyyzz\\" >>> decode_string(\\"a10b1\\") \\"aaaaaaaaaab\\" >>> decode_string(\\"c2d4\\") \\"ccdddd\\" >>> decode_string(\\"a100\\") \\"a\\" * 100 >>> decode_string(\\"b50c30\\") \\"b\\" * 50 + \\"c\\" * 30 >>> decode_string(\\"a3B2c1\\") \\"aaaBBc\\" >>> decode_string(\\"A1F3G2H4\\") \\"AFFFGGHHHH\\"","solution":"def decode_string(encoded_str): Decodes the given encoded string where each character group is followed by an integer representing the number of times the characters should be repeated. decoded_str = \\"\\" i = 0 while i < len(encoded_str): char = encoded_str[i] repeat_count = \\"\\" # Look ahead to collect the digit(s) j = i + 1 while j < len(encoded_str) and encoded_str[j].isdigit(): repeat_count += encoded_str[j] j += 1 decoded_str += char * int(repeat_count) i = j # Move to the next character group return decoded_str"},{"question":"def checkDistances(s: str, distance: List[int]) -> bool: Returns True if the given distance array is correct for the string s, otherwise returns False. >>> checkDistances(\\"abac\\", [1, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]) True >>> checkDistances(\\"abba\\", [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) False >>> checkDistances(\\"aabb\\", [0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]) True >>> checkDistances(\\"abcdabcd\\", [3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) True >>> checkDistances(\\"aa\\", [0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]) True","solution":"def checkDistances(s, distance): Returns True if the given distance array is correct for the string s, otherwise returns False. first_occurrence = {} for i, char in enumerate(s): if char in first_occurrence: actual_distance = i - first_occurrence[char] - 1 expected_distance = distance[ord(char) - ord('a')] if actual_distance != expected_distance: return False else: first_occurrence[char] = i return True"},{"question":"from typing import List def longest_cycle(edges: List[int]) -> int: Finds the length of the longest cycle in the directed graph represented by edges. If no cycle exists, returns -1. Parameters: edges (List[int]): List of integers representing the end node of a directed edge starting from node \`i\`, or \`-1\` if there is no outgoing edge. Returns: int: The length of the longest cycle, or -1 if no cycle exists. Example: >>> longest_cycle([-1, -1, -1, -1]) -1 >>> longest_cycle([1, 2, 3, 0]) 4 >>> longest_cycle([1, 2, 0, 4, 5, 3]) 3 >>> longest_cycle([0]) 1 >>> longest_cycle([1, 2, 3, 0, -1]) 4 >>> longest_cycle([]) -1 >>> longest_cycle([1, 2, -1, 4, 5, 3, 6, -1, 8, 6]) 3 pass","solution":"def longest_cycle(edges): Finds the length of the longest cycle in the directed graph represented by edges. If no cycle exists, returns -1. Parameters: edges (List[int]): List of integers representing the end node of a directed edge starting from node \`i\`, or \`-1\` if there is no outgoing edge. Returns: int: The length of the longest cycle, or -1 if no cycle exists. n = len(edges) visited = [False] * n rec_stack = [False] * n longest_cycle_length = -1 def dfs(node, path_length, path_index): nonlocal longest_cycle_length if visited[node]: if rec_stack[node]: # A cycle is detected cycle_length = path_length - path_index[node] longest_cycle_length = max(longest_cycle_length, cycle_length) return visited[node] = True rec_stack[node] = True path_index[node] = path_length if edges[node] != -1: dfs(edges[node], path_length + 1, path_index) rec_stack[node] = False for i in range(n): if not visited[i]: dfs(i, 0, [-1] * n) return longest_cycle_length"},{"question":"import heapq from collections import defaultdict class ModeHeap: Data structure that supports adding integers onto a heap and fetching the mode of the heap. >>> mh = ModeHeap() >>> mh.add(5) >>> mh.getMode() == 5 >>> mh = ModeHeap() >>> mh.add(3) >>> mh.add(3) >>> mh.add(1) >>> mh.getMode() == 3 >>> mh = ModeHeap() >>> mh.add(4) >>> mh.add(4) >>> mh.add(6) >>> mh.add(6) >>> mh.add(6) >>> mh.getMode() == 6 >>> mh = ModeHeap() >>> mh.add(2) >>> mh.add(3) >>> mh.add(2) >>> mh.add(3) >>> mh.getMode() in [2, 3] >>> mh = ModeHeap() >>> mh.getMode() == None def __init__(self): Initializes the ModeHeap data structure. pass def add(self, num): Adds an integer num to the heap and updates the mode. pass def getMode(self): Returns the mode of the integers currently in the heap. pass","solution":"import heapq from collections import defaultdict class ModeHeap: def __init__(self): Initializes the ModeHeap data structure. self.heap = [] self.num_count = defaultdict(int) self.mode = None self.mode_count = 0 def add(self, num): Adds an integer num to the heap and updates the mode. heapq.heappush(self.heap, num) self.num_count[num] += 1 # Update mode if necessary if self.num_count[num] > self.mode_count: self.mode = num self.mode_count = self.num_count[num] def getMode(self): Returns the mode of the integers currently in the heap. return self.mode"},{"question":"def sum_of_minimums(arr: List[int]) -> int: Returns the overall sum of the minimum value of every contiguous subarray of \`arr\`. >>> sum_of_minimums([3, 1, 2, 4]) 17 >>> sum_of_minimums([5]) 5 >>> sum_of_minimums([3, 1]) 5 >>> sum_of_minimums([2, 2, 2, 2]) 20 >>> sum_of_minimums([1, 2, 3, 4]) 20 >>> sum_of_minimums([4, 3, 2, 1]) 20","solution":"def sum_of_minimums(arr): Returns the overall sum of the minimum value of every contiguous subarray of \`arr\`. n = len(arr) overall_sum = 0 for i in range(n): current_min = arr[i] for j in range(i, n): current_min = min(current_min, arr[j]) overall_sum += current_min return overall_sum"},{"question":"from typing import List def min_steps_maze(maze: List[List[str]]) -> int: Returns the minimum number of steps required to move from the start (0, 0) to the destination (m-1, n-1) in the given maze. If there is no valid path, returns -1. >>> min_steps_maze([['E', 'E', 'E'], ['E', 'W', 'E'], ['E', 'E', 'E']]) 4 >>> min_steps_maze([['E', 'W', 'E'], ['W', 'W', 'W'], ['E', 'E', 'E']]) -1","solution":"from collections import deque def min_steps_maze(maze): Returns the minimum number of steps required to move from the start (0, 0) to the destination (m-1, n-1) in the given maze. If there is no valid path, returns -1. m, n = len(maze), len(maze[0]) if maze[0][0] == 'W' or maze[m-1][n-1] == 'W': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == m - 1 and y == n - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and maze[nx][ny] == 'E' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def daily_temperatures(arr: List[int]) -> List[int]: Given an integer \`n\` and a list of integers \`arr\` representing back-to-back daily temperatures, return another list such that, for each day in the input list, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put \`0\` instead. :param arr: List of integers representing daily temperatures :return: List of integers representing waiting days for a warmer temperature >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([60, 62, 64, 66, 68, 70]) [1, 1, 1, 1, 1, 0] >>> daily_temperatures([70, 68, 66, 64, 62, 60]) [0, 0, 0, 0, 0, 0] >>> daily_temperatures([75]) [0] >>> daily_temperatures([65, 65, 65, 65, 65]) [0, 0, 0, 0, 0] >>> daily_temperatures([30, 40, 50, 60, 50, 40, 30, 20]) [1, 1, 1, 0, 0, 0, 0, 0]","solution":"def dailyTemperatures(arr): Given a list of daily temperatures, return a list such that each element represents the number of days you would have to wait until a warmer temperature. :param arr: List of integers representing daily temperatures :return: List of integers representing waiting days for a warmer temperature n = len(arr) answer = [0] * n stack = [] for i in range(n): while stack and arr[i] > arr[stack[-1]]: j = stack.pop() answer[j] = i - j stack.append(i) return answer"},{"question":"class UserScoreTracker: A class to track user scores based on actions. Methods: - addUser(userId: str) -> None: Adds a new user with the given userId. - recordAction(userId: str, actionType: str) -> None: Records an action for the user, updating their score. - getUserScore(userId: str) -> int: Returns the current score of the user. - getTopKUsers(k: int) -> List[str]: Returns a list of the top k users based on their scores. def __init__(self): Initializes the tracker with an empty user database and action score values. pass def addUser(self, userId: str) -> None: Adds a new user with the given userId. pass def recordAction(self, userId: str, actionType: str) -> None: Records an action of type actionType for the user, updating their score. pass def getUserScore(self, userId: str) -> int: Returns the current score of the user. pass def getTopKUsers(self, k: int) -> List[str]: Returns a list of the top k users in descending order of their scores. pass def test_add_user(): tracker = UserScoreTracker() tracker.addUser(\\"user1\\") assert tracker.getUserScore(\\"user1\\") == 0 def test_record_action(): tracker = UserScoreTracker() tracker.addUser(\\"user1\\") tracker.recordAction(\\"user1\\", \\"post\\") assert tracker.getUserScore(\\"user1\\") == 10 tracker.recordAction(\\"user1\\", \\"comment\\") assert tracker.getUserScore(\\"user1\\") == 15 tracker.recordAction(\\"user1\\", \\"like\\") assert tracker.getUserScore(\\"user1\\") == 16 def test_non_existent_user(): tracker = UserScoreTracker() tracker.recordAction(\\"user1\\", \\"post\\") assert tracker.getUserScore(\\"user1\\") == 0 def test_get_top_k_users(): tracker = UserScoreTracker() tracker.addUser(\\"user1\\") tracker.addUser(\\"user2\\") tracker.addUser(\\"user3\\") tracker.recordAction(\\"user1\\", \\"post\\") tracker.recordAction(\\"user2\\", \\"post\\") tracker.recordAction(\\"user2\\", \\"comment\\") tracker.recordAction(\\"user3\\", \\"like\\") assert tracker.getTopKUsers(1) == [\\"user2\\"] assert tracker.getTopKUsers(2) == [\\"user2\\", \\"user1\\"] assert tracker.getTopKUsers(3) == [\\"user2\\", \\"user1\\", \\"user3\\"] def test_get_top_k_users_with_tie(): tracker = UserScoreTracker() tracker.addUser(\\"userA\\") tracker.addUser(\\"userB\\") tracker.addUser(\\"userC\\") tracker.recordAction(\\"userA\\", \\"post\\") tracker.recordAction(\\"userB\\", \\"post\\") tracker.recordAction(\\"userC\\", \\"comment\\") tracker.recordAction(\\"userC\\", \\"like\\") assert tracker.getTopKUsers(2) == [\\"userA\\", \\"userB\\"] assert tracker.getTopKUsers(3) == [\\"userA\\", \\"userB\\", \\"userC\\"]","solution":"class UserScoreTracker: def __init__(self): self.users = {} self.actions = {\\"post\\": 10, \\"comment\\": 5, \\"like\\": 1} def addUser(self, userId): if userId not in self.users: self.users[userId] = 0 def recordAction(self, userId, actionType): if userId in self.users and actionType in self.actions: self.users[userId] += self.actions[actionType] def getUserScore(self, userId): return self.users.get(userId, 0) def getTopKUsers(self, k): sorted_users = sorted(self.users.items(), key=lambda x: (-x[1], x[0])) return [user for user, score in sorted_users[:k]]"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def get_intersection_node(headA: ListNode, headB: ListNode) -> ListNode: Finds the node at which the intersection of two singly linked lists begins. If no intersection, returns None. >>> common = ListNode(8, ListNode(10)) >>> headA = ListNode(3, ListNode(7, common)) >>> headB = ListNode(99, ListNode(1, common)) >>> get_intersection_node(headA, headB) == common True >>> headA = ListNode(1, ListNode(2, ListNode(3))) >>> headB = ListNode(4, ListNode(5, ListNode(6))) >>> get_intersection_node(headA, headB) == None True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def get_intersection_node(headA, headB): Finds the node at which the intersection of two singly linked lists begins. If no intersection, returns None. if not headA or not headB: return None pointer_a = headA pointer_b = headB while pointer_a is not pointer_b: pointer_a = pointer_a.next if pointer_a else headB pointer_b = pointer_b.next if pointer_b else headA return pointer_a"},{"question":"def max_items(prices: List[int], budget: int) -> int: Returns the maximum number of items that can be bought with the given budget. Args: prices (list of int): The prices of the items. budget (int): The available budget. Returns: int: The maximum number of items that can be bought without exceeding the budget. # Unit Test Cases def test_max_items_exact_budget(): assert max_items([1, 2, 3, 4, 5], 15) == 5 def test_max_items_small_budget(): assert max_items([5, 3, 8, 2, 4], 7) == 2 def test_max_items_zero_budget(): assert max_items([1, 2, 3], 0) == 0 def test_max_items_insufficient_budget(): assert max_items([10, 20, 30], 5) == 0 def test_max_items_unsorted_prices(): assert max_items([3, 2, 1, 5, 4], 10) == 4 def test_max_items_large_budget(): assert max_items([1, 2, 3, 4, 5], 20) == 5","solution":"def max_items(prices, budget): Returns the maximum number of items that can be bought with the given budget. Args: prices (list of int): The prices of the items. budget (int): The available budget. Returns: int: The maximum number of items that can be bought without exceeding the budget. prices.sort() total_cost = 0 num_items = 0 for price in prices: if total_cost + price <= budget: total_cost += price num_items += 1 else: break return num_items"},{"question":"def remove_duplicates(nums: List[int]) -> List[int]: Removes duplicates from a sorted array and returns a new array with unique elements. :param nums: List of integers sorted in non-decreasing order :return: New list containing only unique elements, in the same order as original >>> remove_duplicates([]) [] >>> remove_duplicates([2]) [2] >>> remove_duplicates([1, 2, 3]) [1, 2, 3] >>> remove_duplicates([1, 1, 2, 3, 3, 4]) [1, 2, 3, 4] >>> remove_duplicates([0, 0, 0, 0]) [0] >>> remove_duplicates([5, 6, 6, 7, 8, 8, 9, 9, 10]) [5, 6, 7, 8, 9, 10] >>> remove_duplicates(list(range(10000)) + [9999]*50) list(range(10000))","solution":"def remove_duplicates(nums): Removes duplicates from a sorted array and returns a new array with unique elements. :param nums: List of integers sorted in non-decreasing order :return: New list containing only unique elements, in the same order as original if not nums: return [] unique_nums = [nums[0]] for i in range(1, len(nums)): if nums[i] != nums[i - 1]: unique_nums.append(nums[i]) return unique_nums"},{"question":"def min_time_to_alternate(s: str) -> int: Calculate the minimum time to make string s alternating. >>> min_time_to_alternate(\\"aab\\") 1 >>> min_time_to_alternate(\\"aba\\") 0 >>> min_time_to_alternate(\\"aaaa\\") 2 >>> min_time_to_alternate(\\"bbbb\\") 2 >>> min_time_to_alternate(\\"ababab\\") 0 >>> min_time_to_alternate(\\"\\") 0 >>> min_time_to_alternate(\\"a\\") 0 >>> min_time_to_alternate(\\"b\\") 0 >>> min_time_to_alternate(\\"a\\" * 1000) 500 >>> min_time_to_alternate(\\"b\\" * 1000) 500 >>> min_time_to_alternate(\\"ab\\" * 500) 0 >>> min_time_to_alternate(\\"ba\\" * 500) 0","solution":"def min_time_to_alternate(s): Calculate the minimum time to make string s alternating. n = len(s) # Two patterns to compare: # pattern1: \\"ababab...\\" # pattern2: \\"babababa...\\" time1 = 0 # to make it like \\"ababab...\\" time2 = 0 # to make it like \\"bababab...\\" for i in range(n): if (i % 2 == 0 and s[i] != 'a') or (i % 2 == 1 and s[i] != 'b'): time1 += 1 if (i % 2 == 0 and s[i] != 'b') or (i % 2 == 1 and s[i] != 'a'): time2 += 1 return min(time1, time2)"},{"question":"def min_subset_sum_difference(nums: List[int]) -> int: Given an array of integers \`nums\`, distribute these integers into two subsets \`S1\` and \`S2\` such that the absolute difference between the sum of the elements in \`S1\` and \`S2\` is minimized. Return the minimum possible value of the absolute difference between the sums. >>> min_subset_sum_difference([1, 2, 3, 9]) 3 >>> min_subset_sum_difference([1, 2, 7, 1, 5]) 0 >>> min_subset_sum_difference([1, 3, 100, 4]) 92 >>> min_subset_sum_difference([0, 0, 0]) 0 >>> min_subset_sum_difference([1]) 1 >>> min_subset_sum_difference([5, 5, 5, 5]) 0","solution":"def min_subset_sum_difference(nums): total_sum = sum(nums) n = len(nums) # The target is to check half of the total_sum target = total_sum // 2 # Initialize a dp array dp = [False] * (target + 1) dp[0] = True # Update the dp array for num in nums: for j in range(target, num - 1, -1): if dp[j - num]: dp[j] = True # Find the maximum j for which dp[j] is true for j in range(target, -1, -1): if dp[j]: return total_sum - 2 * j"}]`),A={name:"App",components:{PoemCard:j},data(){return{searchQuery:"",visibleCount:4,poemsData:F,isLoading:!1}},computed:{filteredPoems(){const s=this.searchQuery.trim().toLowerCase();return s?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(s)||e.solution&&e.solution.toLowerCase().includes(s)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(s=>setTimeout(s,1e3)),this.visibleCount+=4,this.isLoading=!1}}},S={class:"search-container"},C={class:"card-container"},I={key:0,class:"empty-state"},z=["disabled"],D={key:0},P={key:1};function E(s,e,l,h,i,a){const c=g("PoemCard");return r(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",S,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),p(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(r(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")}," ✕ ")):u("",!0)]),t("div",C,[(r(!0),n(x,null,w(a.displayedPoems,(o,f)=>(r(),y(c,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(r(),n("div",I,' No results found for "'+d(i.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(r(),n("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(r(),n("span",P,"Loading...")):(r(),n("span",D,"See more"))],8,z)):u("",!0)])}const M=_(A,[["render",E],["__scopeId","data-v-5d732c5c"]]),O=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/60.md","filePath":"drive/60.md"}'),B={name:"drive/60.md"},W=Object.assign(B,{setup(s){return(e,l)=>(r(),n("div",null,[v(M)]))}});export{O as __pageData,W as default};
