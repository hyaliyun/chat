import{_ as p,o as n,c as i,a as t,m as h,t as d,C as g,M as y,U as _,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},N={class:"review-content"};function E(r,e,l,c,a,s){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const A=p(k,[["render",E],["__scopeId","data-v-d2b2d85d"]]),z=JSON.parse('[{"question":"# Binary Tree to Doubly Linked List Conversion You are given a binary tree with the following node structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Write a function `convert_bin_tree_to_dll` that converts the given binary tree into a doubly linked list, using an in-order traversal. The left pointer in the tree node should be used as the previous pointer in the doubly linked list, and the right pointer should be used as the next pointer. Your function should return the head of the doubly linked list. # Function Signature ```python def convert_bin_tree_to_dll(root: TreeNode) -> TreeNode: ``` # Input * `root`: The root of a binary tree (`TreeNode`). # Output * The head of the doubly linked list (`TreeNode`). # Constraints * The number of nodes in the tree is in the range `[0, 1000]`. * `-10^5 <= Node.val <= 10^5` # Requirements * The solution should perform the transformation efficiently with respect to time and space. * The resulting linked list should represent an in-order traversal of the tree. # Example Example 1: ``` Input: 4 / 2 5 / 1 3 Output: 1 <-> 2 <-> 3 <-> 4 <-> 5 ``` Example 2: ``` Input: 1 / 2 3 Output: 2 <-> 1 <-> 3 ``` # Edge Cases * Empty tree: `root` is None. * Single node tree. * Left-skewed or right-skewed trees. # Notes * Use recursion or an iterative approach to achieve the in-order traversal and transformation. * Make sure to handle edge cases and null nodes appropriately to avoid any unintended errors.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def convert_bin_tree_to_dll(root: TreeNode) -> TreeNode: Function to convert a binary tree to a doubly linked list using in-order traversal. Uses the left pointer as the previous and the right as the next pointer. Returns the head of the doubly linked list. if not root: return None # Helper function to convert the tree def helper(node): nonlocal last, head if node: # Recursively visit left subtree helper(node.left) # Processing the current node if last: # Link the previous node (last) with the current one (node) last.right = node node.left = last else: # If this is the leftmost node, it will be the head of the list head = node last = node # Update last to the current node # Recursively visit right subtree helper(node.right) last = None # This will keep track of the last processed node in the DLL head = None # This will be the head of our DLL helper(root) return head"},{"question":"# Context A Segment Tree is a powerful data structure that supports fast range queries and point updates. Given an array, you are to implement a Segment Tree class which uses a commutative function provided during initialization to process range queries and point updates efficiently in logarithmic time. # Task Implement a class `SegmentTree` that supports the following functionalities: 1. **Initialization**: Initialize the Segment Tree with an array and a commutative function. 2. **Point Update**: Update the value at a specific index. 3. **Range Query**: Query the result of the commutative function applied over a range of indices. # Details * **Function Signature**: ```python class SegmentTree: def __init__(self, arr: List[Any], function: Callable[[Any, Any], Any]): # Initialize your segment tree pass def update(self, index: int, value: Any): # Update the element at index with the new value pass def query(self, left: int, right: int) -> Any: # Return the result of the function applied from index left to right pass ``` * **Input/Output**: * `__init__(arr: List[Any], function: Callable[[Any, Any], Any])`: * `arr`: An array of any data type. * `function`: A commutative function taking two inputs of the array\'s data type. * `update(index: int, value: Any)`: No output. Updates the value at `index` in the array. * `query(left: int, right: int) -> Any`: Returns the result of the function applied over the range `[left,right]` inclusive. * **Constraints**: * 1 ≤ len(arr) ≤ 10⁵ * 0 ≤ index, left, right < len(arr) * The commutative function is guaranteed to return results within a reasonable bound. # Example Usage ```python # Example with maximum function arr = [2, 4, 5, 3, 4] mytree = SegmentTree(arr, max) print(mytree.query(2, 4)) # Output: 5 mytree.update(3, 6) print(mytree.query(0, 3)) # Output: 6 # Example with summation function using lambda arr = [4, 5, 2, 3, 4, 43, 3] mytree = SegmentTree(arr, lambda a, b: a + b) print(mytree.query(0, 6)) # Output: 64 mytree.update(2, -10) print(mytree.query(0, 6)) # Output: 52 ```","solution":"from typing import List, Callable, Any class SegmentTree: def __init__(self, arr: List[Any], function: Callable[[Any, Any], Any]): self.n = len(arr) self.function = function self.tree = [None] * (2 * self.n) # Tree array to store segment tree # Build tree by inserting leaf elements in tree array for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, index: int, value: Any): # Set value at position p pos = index + self.n self.tree[pos] = value # Then move upward and update nodes i = pos while i > 1: i //= 2 self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def query(self, left: int, right: int) -> Any: # Get the sum of elements between indices l and r inclusive res = None l = left + self.n r = right + self.n + 1 while l < r: if l % 2 == 1: if res is None: res = self.tree[l] else: res = self.function(res, self.tree[l]) l += 1 if r % 2 == 1: r -= 1 if res is None: res = self.tree[r] else: res = self.function(res, self.tree[r]) l //= 2 r //= 2 return res"},{"question":"# Context Anagram detection is a common problem in text processing and cryptography. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Given two strings consisting of lowercase English letters, your task is to determine if the two strings are anagrams of each other. # Task Write a function `are_anagrams` that takes two strings as input and returns `True` if they are anagrams of each other and `False` otherwise. # Input/Output Format Input * Two strings, `s1` and `s2`. (1<= len(s1), len(s2) <= 10^5) Output * Boolean value - `True` if the strings are anagrams, `False` otherwise. # Constraints * The input strings will consist of lowercase English letters only. * You cannot use any sorting mechanisms. # Performance Requirements * The function should operate in O(n) time complexity where n is the length of the strings. * Space complexity should be O(1) since the frequency array is constant and does not depend on the input size. # Implementation ```python def are_anagrams(s1, s2): # Your implementation goes here pass # Example usage: print(are_anagrams(\\"apple\\", \\"pleap\\")) # True print(are_anagrams(\\"apple\\", \\"cherry\\")) # False ``` # Explanation 1. Initialize two arrays of size 26 (to count character frequencies for `s1` and `s2`). 2. Traverse both strings and update the corresponding frequency arrays. 3. Compare the frequency arrays; if they are identical, return True, else return False. # Edge Cases to Consider * The lengths of the input strings are not the same. * Both input strings are empty.","solution":"def are_anagrams(s1, s2): if len(s1) != len(s2): return False char_count = [0] * 26 for char in s1: char_count[ord(char) - ord(\'a\')] += 1 for char in s2: char_count[ord(char) - ord(\'a\')] -= 1 if char_count[ord(char) - ord(\'a\')] < 0: return False return True"},{"question":"# Matrix Multiplication Challenge **Context**: You are developing a component for a scientific computing application that requires frequently performing matrix multiplications. Your task is to implement the matrix multiplication operation in a way that validates input dimensions and correctly computes the product of the matrices. **Task**: Write a function `matrix_multiply` that takes two 2D lists (matrices), `multiplicand` and `multiplier`, and returns their matrix product. If the matrices are not compatible for multiplication (i.e., the number of columns in `multiplicand` does not match the number of rows in `multiplier`), the function should raise an appropriate exception. **Function Signature**: ```python def matrix_multiply(multiplicand: list, multiplier: list) -> list: pass ``` **Input**: - `multiplicand` (List[List[int]]): A list of lists representing the first matrix with dimensions m x n. - `multiplier` (List[List[int]]): A list of lists representing the second matrix with dimensions n x p. **Output**: - A list of lists representing the resultant matrix with dimensions m x p. **Constraints**: - Each matrix can have up to 100 rows and columns. - Each element in the matrices is an integer between -1000 and 1000. - Assume that the input matrices are non-empty and contain valid integers. **Example**: ```python multiplicand = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] multiplier = [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] result = matrix_multiply(multiplicand, multiplier) # Expected output: # [ # [30, 24, 18], # [84, 69, 54], # [138, 114, 90] # ] ``` **Performance Requirements**: - The function should work efficiently within the provided constraints. - Consider ways to minimize the number of operations in the innermost loop.","solution":"def matrix_multiply(multiplicand: list, multiplier: list) -> list: Multiplies two matrices (2D lists) and returns the resultant matrix. Raises ValueError if the matrices cannot be multiplied (i.e., inner dimensions do not match). # Get the dimensions of the matrices m = len(multiplicand) n = len(multiplicand[0]) p = len(multiplier[0]) if n != len(multiplier): raise ValueError(\\"Cannot multiply matrices: Inner dimensions do not match.\\") # Initialize the result matrix with zeros result = [[0] * p for _ in range(m)] # Perform multiplication for i in range(m): for j in range(p): result[i][j] = sum(multiplicand[i][k] * multiplier[k][j] for k in range(n)) return result"},{"question":"You are tasked with implementing a function that determines if a given string matches a pattern. The pattern can include: * `\'.\'` which matches any single character. * `\'*\'` which matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Your task is to implement the function `is_match`, and it should return `True` if the input string matches the pattern, otherwise `False`. # Function Signature ```python def is_match(s: str, p: str) -> bool: pass ``` # Input * `s` (1 <= |s| <= 1000): a string consisting of lowercase alphabets. * `p` (1 <= |p| <= 1000): a pattern where `\'.\'` and `\'*\'` have special meanings as explained. # Output * Return `True` if `s` matches the pattern `p`, else `False`. # Examples ```python is_match(\\"aa\\", \\"a\\") # False is_match(\\"aa\\", \\"aa\\") # True is_match(\\"aaa\\", \\"aa\\") # False is_match(\\"aa\\", \\"a*\\") # True is_match(\\"aa\\", \\".*\\") # True is_match(\\"ab\\", \\".*\\") # True is_match(\\"aab\\", \\"c*a*b\\") # True ``` # Constraints * Your implementation should efficiently handle cases where `s` and `p` are at their maximum length. # Notes * Watch out for edge cases like empty strings and patterns. * Consider the performance implications of your solution, especially regarding time and space complexity.","solution":"def is_match(s: str, p: str) -> bool: # Let\'s use dynamic programming to solve the problem dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True # Both s and p are empty # Handle patterns with \'*\' for j in range(1, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # This accounts for zero occurrences of the character before \'*\' for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == s[i - 1] or p[j - 1] == \'.\': # Characters match or there\'s \'.\', which can match any char dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': # \'*\' can represent zero of the preceding element dp[i][j] = dp[i][j - 2] if p[j - 2] == s[i - 1] or p[j - 2] == \'.\': # \'*\' can represent one or more of the preceding element dp[i][j] |= dp[i - 1][j] return dp[len(s)][len(p)]"},{"question":"Context You are working on modifying a large set of numbers that are represented as arrays of their digits. Each digit is contained in the array in big-endian order (most significant digit first). Your task is to implement a function that increments one to the number represented by the array, considering potential carries. Objective Write a Python function `plus_one(digits)` that takes a list `digits` where each element is a non-negative digit (0-9), and returns a new list that represents the number incremented by one. Function Signature ```python def plus_one(digits: List[int]) -> List[int]: ``` Input - `digits`: List[int] - a non-empty list where each element represents a digit of a number in base 10. Output - Return a list of integers which represents the input number incremented by one. Constraints - The input list will not be empty and will contain only non-negative digits. - You may not use Python\'s built-in integer increment operators directly on the overall numeric value represented by the list. Example ```python # Example 1 digits = [1, 2, 9] print(plus_one(digits)) # Output: [1, 3, 0] # Example 2 digits = [9, 9, 9] print(plus_one(digits)) # Output: [1, 0, 0, 0] # Example 3 digits = [0] print(plus_one(digits)) # Output: [1] # Example 4 digits = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] print(plus_one(digits)) # Output: [9, 8, 7, 6, 5, 4, 3, 2, 1, 1] ``` Constraints - The length of the `digits` list is `[1, 1000000]`. - Each element in `digits` is `[0, 9]`. Performance Requirements - The solution must run in O(n) time complexity and use O(1) additional space.","solution":"from typing import List def plus_one(digits: List[int]) -> List[int]: Given a list of digits representing a number, increment the number by one and return the resulting list of digits. n = len(digits) # Start from the last digit and work our way backwards for i in reversed(range(n)): if digits[i] < 9: # If the digit is less than 9, we can simply increment this digit by one digits[i] += 1 return digits else: # If the digit is 9, it becomes 0 digits[i] = 0 # If we exhausted all digits and all were 9s, we need an extra place for the carry return [1] + digits"},{"question":"In a text-editing software, the auto-correct feature relies heavily on measuring the similarity between two words to suggest corrections. This similarity is calculated using the Edit Distance algorithm. Given two words A and B, implement a function that computes the minimum number of operations required to transform word A into word B. **Function Signature**: ```python def edit_distance(word_a: str, word_b: str) -> int: ``` # Input * `word_a` (1 <= len(word_a) <= 1000): A string consisting of lowercase English letters. * `word_b` (1 <= len(word_b) <= 1000): A string consisting of lowercase English letters. # Output * Returns an integer representing the minimum number of operations (insertions, deletions, substitutions) required to transform `word_a` into `word_b`. # Constraints * The solution must run within a time complexity of O(length_a * length_b). * The solution must use a dynamic programming approach to ensure optimal performance. # Examples ```python assert edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert edit_distance(\\"flaw\\", \\"lawn\\") == 2 assert edit_distance(\\"\\", \\"abc\\") == 3 assert edit_distance(\\"intention\\", \\"execution\\") == 5 ``` # Notes 1. Consider edge cases such as an empty string. 2. Ensure your implementation handles large string sizes efficiently. 3. Optimize for both time and space complexity to meet the constraints.","solution":"def edit_distance(word_a: str, word_b: str) -> int: len_a, len_b = len(word_a), len(word_b) # Create a 2D array to store the edit distances dp = [[0] * (len_b + 1) for _ in range(len_a + 1)] # Initialize the dp array for i in range(len_a + 1): dp[i][0] = i for j in range(len_b + 1): dp[0][j] = j # Fill the dp array using bottom-up dynamic programming approach for i in range(1, len_a + 1): for j in range(1, len_b + 1): if word_a[i - 1] == word_b[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j], # delete dp[i][j - 1], # insert dp[i - 1][j - 1] # replace ) + 1 return dp[len_a][len_b]"},{"question":"# Anagram Checker Write a function to determine if two given strings are anagrams of each other. An anagram is a word formed by rearranging the letters of a different word, using all the original letters exactly once. Your function should be case-sensitive and assume that the input strings only contain lowercase English letters. Function Signature ```python def is_anagram(s: str, t: str) -> bool: pass ``` Input * `s` (string): The first input string. * `t` (string): The second input string. Output * `bool`: Returns `True` if `t` is an anagram of `s`, otherwise returns `False`. Constraints * The length of the strings will not exceed 10^5. Examples 1. **Example 1:** * Input: `s = \\"anagram\\"`, `t = \\"nagaram\\"` * Output: `True` 2. **Example 2:** * Input: `s = \\"rat\\"`, `t = \\"car\\"` * Output: `False` # Scenario Imagine you are implementing an auto-correct feature for a text editor that identifies if a user intended to type a different word by checking if the typed word is an anagram of any known dictionary words. Your implementation should efficiently determine the anagram status of two words, considering the constraints and performance requirements.","solution":"def is_anagram(s: str, t: str) -> bool: Returns True if t is an anagram of s, otherwise returns False. if len(s) != len(t): return False return sorted(s) == sorted(t)"},{"question":"Objective Demonstrate understanding and implementation of binary tree traversal techniques, including handling different traversal strategies (DFS and BFS) to solve a specific problem of finding a path with a given sum. Scenario: Given a binary tree, you need to determine if there exists a path from the root to any leaf node such that the sum of node values along this path equals a given target sum. Function Implementation Implement the function `has_path_sum(root, target_sum)` which checks if such a path exists. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root, target_sum): :type root: TreeNode :type target_sum: int :rtype: bool # Write your solution here pass ``` Input and Output * **Input**: - `root` (TreeNode): The root node of the binary tree. - `target_sum` (integer): The target sum to check for the root-to-leaf path. * **Output**: - (boolean): Return `True` if such a path exists, otherwise `False`. Constraints * The number of nodes in the tree is in the range [0, 5000]. * -1000 <= Node.val <= 1000 * -1000 <= target_sum <= 1000 Examples Example 1: ``` Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], target_sum = 22 Output: True Explanation: The root-to-leaf path with the sum 22 is 5 -> 4 -> 11 -> 2. ``` Example 2: ``` Input: root = [1,2,3], target_sum = 5 Output: False Explanation: There is no root-to-leaf path with the sum 5. ``` Example 3: ``` Input: root = [], target_sum = 0 Output: False Explanation: The tree is empty, hence there is no path. ``` Notes * Pay attention to edge cases such as an empty tree or single-node trees. * Aim for an efficient solution considering both time and space complexities. * Consider iterative and recursive approaches for an optimal solution.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root, target_sum): :type root: TreeNode :type target_sum: int :rtype: bool if not root: return False # Check if we are at a leaf node and the path sum equals the target sum if not root.left and not root.right and root.val == target_sum: return True # Recur on the left and right subtrees with the reduced target sum return has_path_sum(root.left, target_sum - root.val) or has_path_sum(root.right, target_sum - root.val)"},{"question":"You are given an array of integers. Your task is to write a Python function that sorts the array using the Quick Sort algorithm. The function should be capable of simulating the sorting process by printing the array at each iteration. Function Signature: ```python def quick_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts an array using the Quick Sort algorithm. Parameters: arr (List[int]): The list of integers to sort. simulation (bool): If True, print the array at each iteration step. Returns: List[int]: Sorted array. ``` Detailed Requirements: 1. **Input**: - An array of integers, `arr`, which needs to be sorted. - A boolean flag `simulation`. If `simulation` is set to `True`, your function should print the array at each iteration step. 2. **Output**: - Return the sorted array. 3. **Constraints**: - The size of the array will not exceed `10^4` elements. - Each integer in the array will be between `-10^6` and `10^6`. Example: ```python arr = [3, 6, 8, 10, 1, 2, 1] quick_sort(arr, simulation=True) ``` **Expected Output:** ``` iteration 0: 3 6 8 10 1 2 1 iteration 1: 1 2 1 3 6 8 10 iteration 2: 1 1 2 3 6 8 10 ``` 4. **Assumptions**: - The pivot selection can be the last element in the partitioned range. - An empty array or an array with one element is already sorted. 5. **Edge Cases**: - Test your function with an empty array. - Test with arrays containing multiple repeated values. - Test with already sorted or reverse sorted arrays to handle worst-case performance. Implement the required function by considering the points mentioned above.","solution":"from typing import List def quick_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts an array using the Quick Sort algorithm. Parameters: arr (List[int]): The list of integers to sort. simulation (bool): If True, print the array at each iteration step. Returns: List[int]: Sorted array. if not arr: return [] def _quick_sort_helper(arr, low, high, iteration): if low < high: pivot_index = _partition(arr, low, high) if simulation: print(f\'iteration {iteration}:\', \' \'.join(map(str, arr))) iteration += 1 _quick_sort_helper(arr, low, pivot_index - 1, iteration) _quick_sort_helper(arr, pivot_index + 1, high, iteration) return arr def _partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 return _quick_sort_helper(arr, 0, len(arr) - 1, 0)"},{"question":"# Search in a Row and Column-wise Sorted Matrix Context: You are given a matrix of size `m x n` such that each row and each column of the matrix is sorted in non-decreasing order. Your task is to write a function that efficiently searches for a given key in this matrix and returns its position. The matrix is particularly structured such that: * Each row\'s elements are sorted from left to right. * Each column\'s elements are sorted from top to bottom. Requirements: - Implement a function `search_matrix(matrix, key)` that searches for the key in the matrix. - If the key is found, return a tuple representing the (row, column) where the key is located (1-based index). - If the key is not found, return `None`. Input: - `matrix`: A list of lists representing the `m x n` matrix, where each inner list represents a row. - `key`: An integer representing the value to search for in the matrix. Output: - A tuple `(row, column)` representing the 1-based index position of the key if found, otherwise `None`. Constraints: - The matrix is guaranteed to have at least one row and one column. - `0 < m, n <= 1000` Performance: - Your solution should have a time complexity of O(m + n). Example: ```python def search_matrix(matrix, key): # Your implementation here # Example test case matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 print(search_matrix(matrix, key)) # Output should be (2, 3) # Additional test conditions assert search_matrix(matrix, 100) == None # Key not in matrix assert search_matrix(matrix, 2) == (1, 1) # Edge element assert search_matrix(matrix, 20) == (4, 3) # Another edge element ```","solution":"def search_matrix(matrix, key): Search for the given key in the matrix. Arguments: matrix -- List of lists representing the matrix. key -- Integer key to search for. Returns: Tuple representing the (row, column) index (1-based) if the key is found. None if the key is not found. if not matrix: return None m = len(matrix) n = len(matrix[0]) # Start from top-right corner row = 0 col = n - 1 while row < m and col >= 0: if matrix[row][col] == key: return (row + 1, col + 1) elif matrix[row][col] > key: col -= 1 else: row += 1 return None"},{"question":"# Question: Histogram Calculation Given an unordered list of integers, write a function `get_histogram(input_list: list) -> dict` that returns a histogram of the input list as a dictionary where the keys are the unique elements from the list, and the values are the counts of these elements. Function Signature ```python def get_histogram(input_list: list) -> dict: ``` Input - `input_list` (list): A list of integers, which can be empty. The integers can be negative, zero, or positive. Output - `histogram` (dict): A dictionary where the keys are the unique integers from the input list, and the values are their respective counts. Constraints - Elements in `input_list` are integers and fit within the integer range of the programming language. - The list can be empty. Performance Requirements - The function should have a time complexity of O(n), where n is the length of the input list. - The function should have a space complexity of O(k), where k is the number of unique elements in the input list. Examples 1. Example 1: - Input: `[3, 3, 2, 1]` - Output: `{1: 1, 2: 1, 3: 2}` 2. Example 2: - Input: `[2, 3, 5, 5, 5, 6, 4, 3, 7]` - Output: `{2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1}` 3. Example 3: - Input: `[]` - Output: `{}` Notes: - Edge cases such as an empty list should return an empty dictionary. - Consider input lists with varying lengths and distributions of integers.","solution":"def get_histogram(input_list): Returns a histogram of the input list as a dictionary. Parameters: input_list (list): A list of integers. Returns: dict: A dictionary where keys are the unique elements from the list and values are the counts of these elements. histogram = {} for item in input_list: if item in histogram: histogram[item] += 1 else: histogram[item] = 1 return histogram"},{"question":"# Problem Description You are working on a system requiring low-level data encoding and manipulation. Specifically, you need to implement functionality that allows inserting single or multiple bits into specific positions of an integer. Your task is to write two functions that perform these bit manipulations. # Functions 1. `insert_one_bit(num: int, bit: int, i: int) -> int`: * **Input**: - `num`: An integer representing the binary number where the bit will be inserted. - `bit`: A single binary bit (0 or 1) to be inserted. - `i`: The zero-based position where the bit should be inserted. * **Output**: Returns a new integer representing the modified binary number after the bit has been inserted. 2. `insert_mult_bits(num: int, bits: int, length: int, i: int) -> int`: * **Input**: - `num`: An integer representing the binary number where bits will be inserted. - `bits`: An integer representing the binary bits to be inserted. - `length`: The number of bits in `bits`. - `i`: The zero-based position where the bits should be inserted. * **Output**: Returns a new integer representing the modified binary number after multiple bits have been inserted. # Example: ```python # Example 1 num = 21 # Binary: 10101 bit = 1 i = 2 assert insert_one_bit(num, bit, i) == 45 # Binary: 101101 # Example 2 num = 5 # Binary: 101 bits = 7 # Binary: 111 length = 3 i = 1 assert insert_mult_bits(num, bits, length, i) == 47 # Binary: 101111 ``` # Constraints: - Ensure to handle edge cases like insertion at the start and end. - Assume all numbers are non-negative. - Ensure the bit position does not exceed typical integer boundaries. Implement these functions efficiently considering the above constraints.","solution":"def insert_one_bit(num: int, bit: int, i: int) -> int: Inserts a single bit into a specific position of an integer. # Create a mask to the left of the insert position mask = (1 << i) - 1 left_part = (num & ~mask) << 1 right_part = (num & mask) result = left_part | (bit << i) | right_part return result def insert_mult_bits(num: int, bits: int, length: int, i: int) -> int: Inserts multiple bits into a specific position of an integer. # Create a mask to the left of the insert position mask = (1 << i) - 1 left_part = (num & ~mask) << length right_part = (num & mask) result = left_part | (bits << i) | right_part return result"},{"question":"Objective You are required to implement a function that finds all possible subsets of a given list of distinct integers. Your solution must include both a backtracking method and an iterative method. # Problem Statement **Function Signature**: ```python def find_subsets(nums: List[int]) -> List[List[int]]: pass ``` **Input**: * A list of distinct integers, `nums`, with length (n) where (0 leq n leq 10). **Output**: * A list containing all possible subsets of `nums`. Each subset should be represented as a list of integers. The solution set must not contain duplicate subsets, and the subsets can be in any order. # Constraints * The values in `nums` are distinct integers. # Performance Requirements * The implementation should aim for a time complexity of (O(2^n)) and similar space complexity. The solution should handle large sequences efficiently within these constraints. # Example ```python # Example 1 nums = [1, 2, 3] find_subsets(nums) # Expected Output: # [ # [], [1], [2], [3], # [1, 2], [1, 3], [2, 3], # [1, 2, 3] # ] # Example 2 nums = [] find_subsets(nums) # Expected Output: # [ # [] # ] ``` # Requirements * The function should utilize both backtracking and iterative methods. * Make sure your code can handle edge cases and is optimized for performance within the given constraints.","solution":"from typing import List def find_subsets(nums: List[int]) -> List[List[int]]: def backtrack(): def backtrack_helper(index: int, path: List[int]): subsets.append(list(path)) for i in range(index, len(nums)): path.append(nums[i]) backtrack_helper(i + 1, path) path.pop() subsets = [] backtrack_helper(0, []) return subsets def iterative(): subsets = [[]] for num in nums: subsets += [current + [num] for current in subsets] return subsets # Combining both methods\' results to meet the requirement backtracking_result = backtrack() iterative_result = iterative() return backtracking_result, iterative_result"},{"question":"# Roman Numeral Interpreter **Context and Objective:** You are tasked to implement a function that converts a Roman numeral into an integer. This function will be a part of a larger historical data processing system that interprets ancient numerical data. **Function Signature:** ```python def roman_to_int(s: str) -> int: ``` **Input:** * A single string `s` representing a valid Roman numeral, where 1 <= len(s) <= 15. The string is guaranteed to be within the range from 1 to 3999. **Output:** * An integer representing the conversion of the Roman numeral to an integer. **Example:** ```python roman_to_int(\\"III\\") => 3 roman_to_int(\\"IV\\") => 4 roman_to_int(\\"IX\\") => 9 roman_to_int(\\"LVIII\\") => 58 roman_to_int(\\"MCMXCIV\\") => 1994 ``` **Constraints and Requirements:** * You must use a solution with O(n) time complexity. * Consider common Roman numeral rules, including subtractive combinations (like IV for 4). * You do not need to validate the input string, as it’s guaranteed to be a standard Roman numeral. **Scenario:** Imagine that you are building a module for a museum exhibit interactive display. The display will show visitors the conversion of Roman numerals they input on a touch screen, reflecting the corresponding integer values.","solution":"def roman_to_int(s: str) -> int: Converts a valid Roman numeral into an integer. Parameters: s (str): A valid Roman numeral string (1 <= len(s) <= 15). Returns: int: The integer representation of the Roman numeral. roman_to_int_map = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(s): curr_value = roman_to_int_map[char] if curr_value < prev_value: total -= curr_value else: total += curr_value prev_value = curr_value return total"},{"question":"# Alternating Bits Context: You’re developing a feature for a communication system that requires verification of data patterns. One of the features is to check if a given number has alternating binary bits— where adjacent bits must differ. Objective: Implement a function that determines whether a given positive integer has alternating bits. If every two adjacent bits in the binary representation are different, the function should return `True`. Otherwise, it should return `False`. Function Signature: ```python def has_alternating_bits(n: int) -> bool: ``` Input: - `n` (int): A positive integer. Output: - `bool`: Return `True` if `n` has alternating bits, `False` otherwise. Constraints: - 1 ≤ n ≤ (2^{31} - 1) Example: ```python assert has_alternating_bits(5) == True # binary: 101 assert has_alternating_bits(7) == False # binary: 111 assert has_alternating_bits(11) == False # binary: 1011 assert has_alternating_bits(10) == True # binary: 1010 ``` Notes: - Your solution should efficiently handle large integers within the given constraints. - Ensure edge cases such as minimum values are managed correctly. - Both time and space efficiency should be considered.","solution":"def has_alternating_bits(n: int) -> bool: Checks if the given positive integer has alternating bits in its binary representation. Args: n (int): A positive integer. Returns: bool: True if the integer has alternating bits, False otherwise. current_bit = n & 1 # Get the last bit n >>= 1 # Right shift to check the next bit while n > 0: next_bit = n & 1 # Get the next bit if current_bit == next_bit: return False current_bit = next_bit n >>= 1 return True"},{"question":"**Scenario**: You are tasked with helping an expedition team optimize the usage of their knapsack to carry the most valuable items within a weight limit. The team has a list of items, each described by its weight and value. **Problem Statement**: Implement a function `maximize_knapsack_value(items, capacity)` that returns the maximum summarized value of the items that can fit into the given knapsack capacity. Each item can either be included or excluded completely. **Function Signature**: ```python class Item: def __init__(self, value, weight): self.value = value self.weight = weight def maximize_knapsack_value(items: List[Item], capacity: int) -> int: ``` **Input**: - `items`: A list of `Item` objects with `value` and `weight` attributes. - `capacity`: An integer representing the capacity of the knapsack. **Output**: - An integer representing the maximum achievable value with the given capacity. **Constraints**: - The number of items, `n`, is such that 1 <= n <= 1000. - The capacity of the knapsack, `m`, is such that 1 <= m <= 1000. - Each item value and weight are positive integers. **Example**: ```python capacity = 5 items = [Item(60, 5), Item(50, 3), Item(70, 4), Item(30, 2)] assert maximize_knapsack_value(items, capacity) == 80 # The maximum value is obtained by items valued 50 (weight 3) and 30 (weight 2). ``` **Notes**: - Ensure to handle edge cases, such as zero or negative weights for items, appropriately. - Optimize the function for better efficiency considering the input constraints.","solution":"from typing import List class Item: def __init__(self, value, weight): self.value = value self.weight = weight def maximize_knapsack_value(items: List[Item], capacity: int) -> int: Returns the maximum summarized value of the items that can fit into the given knapsack capacity. n = len(items) dp = [[0] * (capacity + 1) for _ in range(n + 1)] for i in range(1, n + 1): for w in range(capacity + 1): if items[i-1].weight <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w - items[i-1].weight] + items[i-1].value) else: dp[i][w] = dp[i-1][w] return dp[n][capacity]"},{"question":"You are given an unsorted array of integers and a target integer. Implement a function that finds the index of the target integer. If the target integer does not exist in the array, the function should return -1. The solution needs to be implemented using the linear search algorithm. Function Signature: ```python def find_target_index(array: List[int], target: int) -> int: ``` Input: * `array` (List[int]): An array of integers, where 0 ≤ len(array) ≤ 10^6. * `target` (int): The integer value to search for. Output: * (int): The index of the target integer within the array, or -1 if it does not exist. Example: ```python # Example 1: input_array = [1, 2, 3, 4, 5] target = 3 print(find_target_index(input_array, target)) # Output: 2 # Example 2: input_array = [10, 20, 30, 40, 50] target = 5 print(find_target_index(input_array, target)) # Output: -1 # Example 3: input_array = [] target = 1 print(find_target_index(input_array, target)) # Output: -1 ``` Constraints: * Perform a linear search algorithm to solve the problem (use a loop). * The function should handle edge cases properly. * Maintain the time complexity of O(n) and space complexity of O(1).","solution":"from typing import List def find_target_index(array: List[int], target: int) -> int: Linear search for the target index in the array. :param array: List of integers to search within. :param target: Integer value to search for. :return: Index of the target if found, otherwise -1. for index, value in enumerate(array): if value == target: return index return -1"},{"question":"Height of a Binary Tree You are given a binary tree and your task is to implement a function that returns the height of the tree. The height is defined as the number of levels in the tree. The empty tree has a height of 0, a single node tree has a height of 1, and so on. # Function Signature ```python def height(root: Optional[Node]) -> int: pass ``` # Input - The input to the function is the root of a binary tree. # Output - The function should return an integer representing the height of the tree. # Constraints - The number of nodes in the tree will not exceed (10^4). - The value of each node will be unique. # Example ```python # Definition for a binary tree node (already provided in imported \'bst\' module). class Node: def __init__(self, key: int): self.left = None self.right = None self.val = key # Example usage: root = Node(9) root.left = Node(6) root.right = Node(12) root.left.left = Node(3) root.left.right = Node(8) root.right.left = Node(10) root.right.right = Node(15) root.left.right.left = Node(7) root.right.right.right = Node(18) assert height(root) == 4 ``` # Explanation - The provided example tree has a height of 4, which is the length of the longest path from the root node (9) to the deepest leaf node (18). # Notes - You can assume that the binary tree nodes are created using the Node class provided in the bst module. - The testing class and tree creation are already implemented for you to check your solution. # Additional Example ```python # Submitting assumed tree is implemented in Node class provided in bst module. root = None assert height(root) == 0 # Empty tree should return height 0 root = Node(10) assert height(root) == 1 # Tree with single node should return height 1 ``` # Testing To ensure your solution works correctly, you can use the `unittest` framework provided in the code snippet to validate your implementation.","solution":"from typing import Optional # Definition for a binary tree node. class Node: def __init__(self, key: int): self.left = None self.right = None self.val = key def height(root: Optional[Node]) -> int: Returns the height of the binary tree rooted at the given node. if root is None: return 0 else: left_height = height(root.left) right_height = height(root.right) return 1 + max(left_height, right_height)"},{"question":"# Hailstone Sequence Analysis and Extension Given the hailstone sequence defined by the following rules: * If the number is 1, the sequence ends. * If the number is even, the next number is `n / 2`. * If the number is odd, the next number is `3n + 1`. Implement a function `hailstone(n: int) -> List[int]` that generates the sequence from the given starting number `n`. In addition to this, you will also implement a function `analyze_hailstone(n: int) -> Dict[str, Any]` that: 1. Computes the hailstone sequence. 2. Calculates and returns: * The length of the sequence, excluding the starting number. * The maximum value encountered in the sequence. * The sequence itself. # Function Specifications ```python def hailstone(n: int) -> List[int]: Generates and returns the hailstone sequence starting from the given number `n`. :param n: Starting integer (n > 0) :return: List of integers representing the hailstone sequence. pass def analyze_hailstone(n: int) -> Dict[str, Any]: Analyzes the hailstone sequence starting from the given number `n`. :param n: Starting integer (n > 0) :return: Dictionary containing the sequence length, maximum value in the sequence, and the sequence itself. pass ``` # Input/Output Examples Example 1: ```python hailstone(5) # Output: [5, 16, 8, 4, 2, 1] analyze_hailstone(5) # Output: { # \'length\': 5, # \'max_value\': 16, # \'sequence\': [5, 16, 8, 4, 2, 1] # } ``` # Constraints * `1 <= n <= 10^6` * Ensure your code can handle large sequences efficiently. # Edge Cases * Handle cases where `n` is a small number (e.g., 1). * Consider both very small and very large values of `n` to ensure performance. Test your implementation thoroughly to verify correctness and efficiency.","solution":"from typing import List, Dict, Any def hailstone(n: int) -> List[int]: Generates and returns the hailstone sequence starting from the given number `n`. :param n: Starting integer (n > 0) :return: List of integers representing the hailstone sequence. sequence = [] while n != 1: sequence.append(n) if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 sequence.append(1) # End the sequence with 1 return sequence def analyze_hailstone(n: int) -> Dict[str, Any]: Analyzes the hailstone sequence starting from the given number `n`. :param n: Starting integer (n > 0) :return: Dictionary containing the sequence length, maximum value in the sequence, and the sequence itself. sequence = hailstone(n) length = len(sequence) - 1 max_value = max(sequence) return { \'length\': length, \'max_value\': max_value, \'sequence\': sequence }"},{"question":"# Context: In cryptography and certain numeric challenges, some numbers hold unique properties based on digit manipulation. One interesting property is where the sum of a number’s digits, each raised to the power of their respective positions (starting from 1), equals the number itself. # Task: Write a function `find_special_numbers(low, high)` that returns a list of all numbers within a specified range `[low, high]` meeting the following property: For a number `n`, let `d_1, d_2, ..., d_k` be its digits from left to right. The number `n` satisfies the property if: [ n = d_1^1 + d_2^2 + ... + d_k^k ] # Input: - `low` (int): The lower limit of the range (inclusive). - `high` (int): The upper limit of the range (inclusive). # Output: - A list of integers within the range where each number satisfies the described property. # Constraints: - ( 1 leq text{low} leq text{high} leq 10^6 ) # Example: ```python def find_special_numbers(low, high): # Your code here # Example test cases assert find_special_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert find_special_numbers(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert find_special_numbers(10, 150) == [89, 135] ``` # Additional Note: Efficiency is key. Consider the constraints when designing your solution to optimize performance.","solution":"def find_special_numbers(low, high): def is_special(n): str_n = str(n) return n == sum(int(digit) ** (i + 1) for i, digit in enumerate(str_n)) return [n for n in range(low, high + 1) if is_special(n)]"},{"question":"You are tasked with implementing two functions that convert integers between different numeral bases. Function Definitions: 1. **int_to_base** * **Input**: * `num` (int): A non-negative integer that needs to be converted to a different base. * `base` (int): The base to convert the number to (2 <= base <= 36). * **Output**: * Return the string representation of the number `num` in the specified base. 2. **base_to_int** * **Input**: * `str_to_convert` (str): A string representing a number in the specified base. * `base` (int): The base of the input number represented by `str_to_convert` (2 <= base <= 36). * **Output**: * Return the integer value of the `str_to_convert` in decimal. Example: ```python int_to_base(255, 16) # should return \'FF\' base_to_int(\'101\', 2) # should return 5 ``` Constraints: * The `num` and `base` for `int_to_base` function will be valid integers within appropriate range. * The `str_to_convert` and `base` for `base_to_int` function will be valid, containing appropriate characters for their respective bases. **Note**: - Do not use Python\'s built-in functions like `int()` for `base_to_int`.","solution":"def int_to_base(num, base): Converts a non-negative integer to a string representation in the specified base (2 <= base <= 36). if num == 0: return \'0\' digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" result = [] while num: result.append(digits[num % base]) num //= base return \'\'.join(result[::-1]) def base_to_int(str_to_convert, base): Converts a string representing a number in the specified base to its integer value. digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" base_map = {char: index for index, char in enumerate(digits[:base])} num = 0 for char in str_to_convert: num = num * base + base_map[char] return num"},{"question":"# Question Statement Implement a function that computes the length of the missing side of a right-angled triangle using the Pythagorean Theorem. The function should handle provided inputs gracefully and ensure that the inputs form a valid right-angled triangle with non-negative side lengths. # Scenario You are developing an educational tool to teach geometry. One of the features allows students to find the length of the missing side of a right-angled triangle given the other two sides. # Requirements * Implement a function `find_missing_side(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> str` where: * One of `opposite`, `adjacent`, or `hypotenuse` will be `?` (a string). * The other two parameters will be floating-point numbers representing the lengths of the sides. * The function should return a string in the format \\"Opposite = x\\", \\"Adjacent = y\\", or \\"Hypotenuse = z\\", where x, y, or z is the calculated length, rounded to two decimal places. # Constraints 1. The input will always include exactly one \\"?\\" and two floating-point numbers. 2. The function should raise a `ValueError` for: * Invalid inputs (non-numeric and non-\\"?\\" strings). * Non-valid triangle side lengths. 3. The computed side must form a valid right-angled triangle with the existing side lengths. # Example ```python assert find_missing_side(3.0, 4.0, \\"?\\") == \\"Hypotenuse = 5.00\\" assert find_missing_side(3.0, \\"?\\", 5.0) == \\"Adjacent = 4.00\\" assert find_missing_side(\\"?\\", 4.0, 5.0) == \\"Opposite = 3.00\\" try: find_missing_side(3.0, -4.0, \\"?\\") except ValueError as e: assert str(e) == \\"Invalid side lengths provided.\\" ``` # Function Signature ```python from typing import Union def find_missing_side(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> str: pass ```","solution":"from typing import Union import math def find_missing_side(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> str: Computes the length of the missing side of a right-angled triangle using the Pythagorean Theorem. if opposite == \\"?\\": if not (isinstance(adjacent, float) and isinstance(hypotenuse, float)): raise ValueError(\\"Invalid side inputs.\\") if adjacent >= hypotenuse: raise ValueError(\\"Invalid side lengths provided.\\") opposite_length = math.sqrt(hypotenuse ** 2 - adjacent ** 2) return f\\"Opposite = {opposite_length:.2f}\\" elif adjacent == \\"?\\": if not (isinstance(opposite, float) and isinstance(hypotenuse, float)): raise ValueError(\\"Invalid side inputs.\\") if opposite >= hypotenuse: raise ValueError(\\"Invalid side lengths provided.\\") adjacent_length = math.sqrt(hypotenuse ** 2 - opposite ** 2) return f\\"Adjacent = {adjacent_length:.2f}\\" elif hypotenuse == \\"?\\": if not (isinstance(opposite, float) and isinstance(adjacent, float)): raise ValueError(\\"Invalid side inputs.\\") hypotenuse_length = math.sqrt(opposite ** 2 + adjacent ** 2) return f\\"Hypotenuse = {hypotenuse_length:.2f}\\" else: raise ValueError(\\"One side length must be \'?\'\\")"},{"question":"# Context A company needs a tool to process lists of URLs and extract just the core domain names for analytics purposes. A simplified solution is to be implemented that avoids using regular expressions or complex parsing libraries, focusing instead on basic string operations. # Task Given a URL as a string, write a function `extract_domain_name(url: str) -> str` that parses out and returns just the domain name. # Requirements - **Function Signature**: `def extract_domain_name(url: str) -> str:` - **Input**: A single string representing a URL, e.g., \\"http://github.com/SaadBenn\\" - **Output**: A string representing the core domain, e.g., \\"github\\". - **Constraints**: - URLs may or may not include \\"http://\\", \\"https://\\", \\"www.\\". - Assume input strings are well-formed URLs. # Examples 1. `extract_domain_name(\\"http://github.com/SaadBenn\\")` should return `\\"github\\"`. 2. `extract_domain_name(\\"http://www.zombie-bites.com\\")` should return `\\"zombie-bites\\"`. 3. `extract_domain_name(\\"https://www.cnet.com\\")` should return `\\"cnet\\"`. 4. `extract_domain_name(\\"https://bbc.co.uk/news\\")` should return `\\"bbc\\"`. # Hint Remember to handle URLs both with and without \\"www.\\" and \\"http://\\", \\"https://\\". # Evaluation Criteria - Correctness: The function must pass all test cases. - Robustness: Correctly handles different URL formats. - Efficiency: Reasonable time and space complexity.","solution":"def extract_domain_name(url: str) -> str: Extracts and returns the core domain name from a URL. # Remove protocol (http:// or https://) if \\"://\\" in url: url = url.split(\\"://\\")[1] # Remove \\"www.\\" if present if url.startswith(\\"www.\\"): url = url[4:] # Get domain part before any \\"/\\" domain_parts = url.split(\'/\') domain = domain_parts[0] # Get the first part of the domain (e.g., \\"github\\" from \\"github.com\\") core_domain = domain.split(\'.\')[0] return core_domain"},{"question":"# Level Order Traversal of a Binary Tree Given a binary tree, implement a function `level_order` to return the level order traversal of its nodes\' values. Each level should be captured as a list, and the function should return a list of these level lists. Input - The function `level_order` receives a single argument: - `root`: The root node of the binary tree. Output - The function should return a list of lists. Each inner list represents the values of nodes at each level from top to bottom. Constraints - You may assume that the number of nodes in the binary tree is at most 10,000. - Node values are integers. Example - Given binary tree: ``` 3 / 9 20 / 15 7 ``` - The function should return: ``` [ [3], [9,20], [15,7] ] ``` Notes - Consider edge cases such as an empty tree (your function should return an empty list). - Reflect on performance in relation to time and space complexity when implementing your solution.","solution":"from collections import deque class TreeNode: Definition for a binary tree node. def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order(root): Return the level order traversal of a binary tree as a list of lists. Each inner list represents node values at each level from top to bottom. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"You are given a positive integer `n`. Write a function `int_divide(n)` that computes the number of ways in which the integer `n` can be decomposed into sums of non-negative integers, including the integer itself. # Function Signature ```python def int_divide(n: int) -> int: ``` # Input - A single integer `n` (1 <= n <= 500), which represents the number to be decomposed. # Output - An integer representing the number of ways to decompose the input integer `n`. # Example ```python Input: 4 Output: 5 Explanation: 4 can be partitioned as follows: - 4 = 4 - 4 = 3 + 1 - 4 = 2 + 2 - 4 = 2 + 1 + 1 - 4 = 1 + 1 + 1 + 1 Input: 7 Output: 15 Explanation: 7 can be partitioned as follows: - 7 = 7 - 7 = 6 + 1 - 7 = 5 + 2 - 7 = 5 + 1 + 1 - 7 = 4 + 3 - 7 = 4 + 2 + 1 - 7 = 4 + 1 + 1 + 1 - 7 = 3 + 3 + 1 - 7 = 3 + 2 + 2 - 7 = 3 + 2 + 1 + 1 - 7 = 3 + 1 + 1 + 1 + 1 - 7 = 2 + 2 + 2 + 1 - 7 = 2 + 2 + 1 + 1 + 1 - 7 = 2 + 1 + 1 + 1 + 1 + 1 - 7 = 1 + 1 + 1 + 1 + 1 + 1 + 1 ``` # Constraints - The function should handle integers up to the value of 500. - Ensure your solution is efficient with respect to both time and space. # Notes - Focus on dynamic programming principles to build the solution incrementally. - Handle edge cases such as very small values (1) effectively.","solution":"def int_divide(n: int) -> int: Returns the number of ways to decompose the integer n into sums of non-negative integers. # dp[i] will store the number of ways to partition the integer i. dp = [0] * (n + 1) dp[0] = 1 # There\'s one way to partition 0. # We iterate through each number from 1 to n to build up the dp array. for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"Context In geometry, the Pythagorean theorem relates the lengths of the sides of a right-angled triangle. The theorem states that [a^2 + b^2 = c^2], where (c) is the hypotenuse (the side opposite the right angle), and (a) and (b) are the lengths of the other two sides. Your task is to write a function that calculates the length of the unknown side of a right-angled triangle given the other two sides. Function Specification **Function Name**: `calculate_third_side` **Parameters**: - `opposite` (float or str): The length of the side opposite the right angle. Provide \\"?\\" if this is the unknown side. - `adjacent` (float or str): The length of the side adjacent to the right angle. Provide \\"?\\" if this is the unknown side. - `hypotenuse` (float or str): The length of the hypotenuse. Provide \\"?\\" if this is the unknown side. **Returns**: - (str): A statement indicating the length of the \\"unknown side = x\\", where `x` is the calculated length. **Constraints**: - At most one of the parameters will be \\"?\\". - All numerical inputs will be positive. - The provided sides will always form a valid right-angled triangle when the two numeric sides are known. **Examples**: 1. `calculate_third_side(3, 4, \\"?\\")` should return `\\"Hypotenuse = 5.0\\"` 2. `calculate_third_side(3, \\"?\\", 5)` should return `\\"Adjacent = 4.0\\"` 3. `calculate_third_side(\\"?\\", 4, 5)` should return `\\"Opposite = 3.0\\"`","solution":"import math def calculate_third_side(opposite, adjacent, hypotenuse): Calculates the length of the unknown side of a right-angled triangle given the other two sides. Parameters: opposite (float or str): The length of the side opposite the right angle. Provide \\"?\\" if this is the unknown side. adjacent (float or str): The length of the side adjacent to the right angle. Provide \\"?\\" if this is the unknown side. hypotenuse (float or str): The length of the hypotenuse. Provide \\"?\\" if this is the unknown side. Returns: str: A statement indicating the length of the unknown side. if hypotenuse == \\"?\\": opposite = float(opposite) adjacent = float(adjacent) hypotenuse_value = math.sqrt(opposite**2 + adjacent**2) return f\\"Hypotenuse = {hypotenuse_value:.1f}\\" if opposite == \\"?\\": adjacent = float(adjacent) hypotenuse = float(hypotenuse) opposite_value = math.sqrt(hypotenuse**2 - adjacent**2) return f\\"Opposite = {opposite_value:.1f}\\" if adjacent == \\"?\\": opposite = float(opposite) hypotenuse = float(hypotenuse) adjacent_value = math.sqrt(hypotenuse**2 - opposite**2) return f\\"Adjacent = {adjacent_value:.1f}\\""},{"question":"# Pigeonhole Sort Implementation Context You are provided with a dataset containing numerical values representing housing prices in a small neighborhood where the prices fall within a relatively fixed range. To effectively sort these prices using a specific sorting algorithm that suits the data characteristics, you have decided to implement the Pigeonhole Sort algorithm. Problem Statement Implement the `pigeonhole_sort` function that takes a list of integers representing the housing prices and sorts them in ascending order using Pigeonhole Sort. Function Signature ```python def pigeonhole_sort(arr: list[int]) -> list[int]: pass ``` Input * A list `arr` of integers of length (n) (1 ≤ (n) ≤ 10^5) * Each element in `arr` is within the range -10^4 to 10^4. Output * A new list of integers sorted in ascending order. Constraints * The length of the list and the range of values are approximately the same. Example ```python pigeonhole_sort([8, 3, 2, 7, 4, 6, 8]) ``` Output: ```python [2, 3, 4, 6, 7, 8, 8] ``` Notes * Ensure that your implementation is efficient in terms of time and space given the problem constraints. * Tests include arrays with duplicate values and arrays where all elements are the same.","solution":"def pigeonhole_sort(arr: list[int]) -> list[int]: if not arr: return [] # An empty list is already sorted # Find the minimum and maximum values to determine the range min_value = min(arr) max_value = max(arr) range_size = max_value - min_value + 1 # Calculate the range size # Create empty pigeonholes holes = [0] * range_size # Populate the pigeonholes for num in arr: holes[num - min_value] += 1 # Gather the sorted elements from the pigeonholes sorted_arr = [] for i in range(range_size): while holes[i] > 0: sorted_arr.append(i + min_value) holes[i] -= 1 return sorted_arr"},{"question":"# Assessing Understanding of Linked List Operations Context: You are a software engineer hired by a tech company to ensure data integrity in their record-keeping system. Daily records are stored in linked lists, and before processing, you need to verify that these lists are sorted in increasing order. Task: Write a Python function to determine whether a given linked list is sorted in increasing order. The function should return `True` if the list is sorted, and `False` otherwise. An empty list is considered sorted. Function Signature: ```python def is_sorted(head: ListNode) -> bool: pass ``` Input: * `head` (ListNode): A reference to the head of the linked list. Output: * `True` if the list is sorted in increasing order. * `False` otherwise. Constraints: 1. The linked list can be empty. 2. The linked list consists of nodes with integer values. Example: ```python # List: None print(is_sorted(None)) # Output: True # List: 1 -> 2 -> 3 -> 4 head = ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) print(is_sorted(head)) # Output: True # List: 1 -> 2 -> -1 -> 3 head = ListNode(1, ListNode(2, ListNode(-1, ListNode(3)))) print(is_sorted(head)) # Output: False ``` Additional Information: * You may assume the definition of the `ListNode` class is as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Write a solution that properly handles all the provided constraints and considerations.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head: ListNode) -> bool: if not head or not head.next: return True current = head while current.next: if current.val > current.next.val: return False current = current.next return True"},{"question":"# Unique Character Identification in Modified Strings You are given two strings, `s` and `t`, consisting of only lowercase letters. String `t` is generated by random shuffling string `s` and then adding one additional letter at a random position. Your task is to find the letter that was added to `t`. Function Description: Implement the function `find_difference(s: str, t: str) -> str` that takes in two parameters: - `s` (a string representing the original string): - `t` (a string representing the modified string): Both strings are non-empty, and string `t` is always one character longer than string `s`. Input: - `s` (1 ≤ len(s) ≤ 10^5), where `s` is a string containing only lowercase letters. - `t` (len(t) = len(s) + 1), where `t` is a string containing only lowercase letters. Output: - Return the character that was added to create `t`. Examples: Example 1: ``` Input: s = \\"abcd\\", t = \\"abcde\\" Output: \'e\' Explanation: \'e\' is the additional character in t. ``` Example 2: ``` Input: s = \\"a\\", t = \\"aa\\" Output: \'a\' Explanation: The additional character is \'a\'. ``` Constraints: - You may assume that `t` is generated by shuffling `s` and adding one additional letter. Performance Requirements: - Your solution must execute in linear time, O(n), and use constant space. Write the function `find_difference(s: str, t: str) -> str` to solve the above task.","solution":"def find_difference(s: str, t: str) -> str: Finds the additional character added to t. extra_char = 0 for char in s: extra_char ^= ord(char) for char in t: extra_char ^= ord(char) return chr(extra_char)"},{"question":"You are provided with a list of numbers. Your task is to write a function `top_1` that finds the most frequent value(s) in the list and returns them in a list. If there are multiple values with the same highest frequency, include all of them in the result list. # Example ```python assert top_1([1, 1, 2, 2, 3, 4]) == [1, 2] assert top_1([1]) == [1] assert top_1([1, 2, 2, 3, 3, 3, 4]) == [3] assert top_1([]) == [] assert top_1([1, 1, 1, 2, 2, 2, 3, 3, 3]) == [1, 2, 3] ``` # Function Signature ```python def top_1(arr: list[int]) -> list[int]: ``` # Input - `arr`: A list of integers (n, where 0 <= n <= 10^6). # Output - A list containing the most frequent value(s) from the input list. # Constraints - Elements will be integers. - The input list can contain up to 10^6 integers. - The output list should be sorted in ascending order if there are multiple modes. # Notes 1. Consider edge cases such as an empty list or a list where all elements are unique. 2. Optimize your solution to handle large inputs efficiently.","solution":"from collections import Counter def top_1(arr: list[int]) -> list[int]: Finds the most frequent value(s) in the list and returns them in a list. If there are multiple values with the same highest frequency, return all of them in ascending order. if not arr: return [] counter = Counter(arr) max_frequency = max(counter.values()) most_frequent = [num for num, freq in counter.items() if freq == max_frequency] return sorted(most_frequent)"},{"question":"# Move Zeros to End of Array Problem Statement You are given an array containing various elements, including zeros. Your task is to write a function that moves all the zeros in the array to the end while preserving the order of the other elements. Implement the function `move_zeros(array: list) -> list` which will achieve this. Input - `array`: A list of elements containing integers, floating point numbers, strings, and booleans. Output - A list with all zeros moved to the end while maintaining the relative order of other elements. Constraints - The elements in the array may include `False`, `0`, `0.0`, `True`, and other data types. - Only elements that are exactly zero (not `False` used as zero) should be moved. Function Signature ```python def move_zeros(array: list) -> list: # Your code here ``` Example ```python assert move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"]) == [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] assert move_zeros([0, 0, 0, \\"apple\\", False, 3.14, 0]) == [\\"apple\\", False, 3.14, 0, 0, 0, 0] assert move_zeros([1, 2, 3]) == [1, 2, 3] assert move_zeros([0, 0, 0]) == [0, 0, 0] assert move_zeros([]) == [] ``` # Guidelines 1. **Be cautious about type-checking**: The value `False` should not be considered as `0`. 2. **Edge cases**: Ensure to handle cases like an array with all zeros, no zeros, or an empty array. 3. **Efficiency required**: Aim for a solution with O(n) time complexity and be mindful of the space complexity.","solution":"def move_zeros(array: list) -> list: Move all zeros in the array to the end while preserving the order of the other elements. non_zero_elements = [x for x in array if x != 0 or type(x) is bool] zero_count = len(array) - len(non_zero_elements) return non_zero_elements + [0] * zero_count"},{"question":"# Factor Combination Algorithm Objective: Write a function that takes an integer `n` and returns all possible unique combinations of its factors, excluding 1 and `n`. Requirements: 1. **Function Signature**: ```python def get_factors(n: int) -> List[List[int]]: ``` 2. **Input/Output Formats**: * **Inputs**: * `n` (integer): An integer, always positive. * **Outputs**: * List of Lists containing integer factor combinations, or an empty list if no such combination exists. 3. **Constraints**: * Factors must be greater than 1 and less than `n`. * Each combination should sort factors in non-decreasing order. Example: 1. **Input**: * `n = 12` 2. **Output**: * `[[2, 6], [2, 2, 3], [3, 4]]` 3. **Input**: * `n = 32` 4. **Output**: * `[[2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8]]` 5. **Input**: * `n = 1` 6. **Output**: * `[]` 7. **Input**: * `n = 37` 8. **Output**: * `[]` Constraints: * Time Complexity: O(nlogn) * Space Complexity: O(logn) Notes: A factor\'s set should not contain 1 or `n` itself, and should display all unique combinations of splitting `n` into parts that multiply back to `n`. Implementation Guidelines: You can use one of the following: * **Iterative DFS**: - Use a stack to simulate the recursive calls, ensuring that each possible factor combination is considered. * **Recursive DFS**: - Utilize helper recursion to break down `n` and accumulate factors until all factors are found. - Ensure no repeated combinations by careful selection of combinable factors.","solution":"from typing import List def get_factors(n: int) -> List[List[int]]: def backtrack(remain, start, path): if path: result.append(path + [remain]) for i in range(start, int(remain ** 0.5) + 1): if remain % i == 0: backtrack(remain // i, i, path + [i]) result = [] if n <= 1: return result backtrack(n, 2, []) return result"},{"question":"# Objective Your task is to implement the Pigeonhole Sort algorithm in Python. # Problem Statement Write a function `pigeonhole_sort(arr)` that takes a list of integers `arr` as its input and returns a sorted list. Use the Pigeonhole Sort technique to achieve this. # Input - `arr` (list of int): A list of integers to sort. # Output - (list of int): A sorted list of integers. # Constraints - The length of `arr` will be in the range [0, 1000]. - The integers in `arr` will be in the range [-500, 500]. # Performance Requirements - The algorithm should have a time complexity of O(n + Range) and space complexity of O(Range), where `Range` is the difference between the maximum and minimum values in `arr`. # Example ```python # Example 1: arr = [8, 3, 2, 7, 4] print(pigeonhole_sort(arr)) # Output: [2, 3, 4, 7, 8] # Example 2: arr = [-1, -10, 5, 2, 0] print(pigeonhole_sort(arr)) # Output: [-10, -1, 0, 2, 5] # Example 3: arr = [500, -500] print(pigeonhole_sort(arr)) # Output: [-500, 500] # Example 4: arr = [] print(pigeonhole_sort(arr)) # Output: [] # Example 5: arr = [7, 7, 7] print(pigeonhole_sort(arr)) # Output: [7, 7, 7] ``` # Note The Pigeonhole Sort is particularly efficient for lists where the number of elements `n` is close to the range of possible values `Range`. Thus, ensure your solution runs efficiently within the provided constraints.","solution":"def pigeonhole_sort(arr): if not arr: return arr min_val = min(arr) max_val = max(arr) size = max_val - min_val + 1 pigeonholes = [0] * size for num in arr: pigeonholes[num - min_val] += 1 sorted_arr = [] for i in range(size): while pigeonholes[i] > 0: sorted_arr.append(i + min_val) pigeonholes[i] -= 1 return sorted_arr"},{"question":"Problem Statement You are given an abstract `AbstractQueue` class and two concrete queue implementations: `ArrayQueue` and `LinkedListQueue`. Your task is to extend this queue functionality by implementing a `CircularQueue` class using an array with a fixed size that efficiently handles the wrap-around scenario. # Core Requirements: 1. **Enqueue**: Add a new item to the rear of the queue. If the queue is full, raise a `OverflowError` exception. 2. **Dequeue**: Remove and return the front item of the queue. If the queue is empty, raise an `IndexError` exception. 3. **Peek**: Return the front element without removing it. If the queue is empty, raise an `IndexError` exception. 4. **Queue Properties**: Check if the queue is empty or full and return the queue size. # Constraints: * The queue should operate in O(1) time for enqueue, dequeue, and peek operations. * Use a fixed size array to implement the queue. * Handle wrap-around scenarios properly. # Function Definitions: You need to define the following methods: * `def __init__(self, capacity: int):` - Initialize the queue with the fixed capacity. * `def enqueue(self, value):` - Add an item to the rear of the queue. * `def dequeue(self):` - Remove and return the front item. * `def peek(self):` - Return the front item without removal. * `def is_full(self) -> bool:` - Check if the queue is full. * `def is_empty(self) -> bool:` - Check if the queue is empty. * `def __len__(self) -> int:` - Return the number of elements in the queue. # Example: ```python q = CircularQueue(3) q.enqueue(1) q.enqueue(2) q.enqueue(3) print(q.is_full()) # Output: True print(q.dequeue()) # Output: 1 print(q.peek()) # Output: 2 q.enqueue(4) print(len(q)) # Output: 3 ``` # Note: * Provide efficient handling for the circular nature of the queue. * Ensure your implementation handles all edge cases and constraints provided.","solution":"class CircularQueue: def __init__(self, capacity: int): self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = 0 self.size = 0 def enqueue(self, value): if self.is_full(): raise OverflowError(\\"Queue is full\\") self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def is_full(self) -> bool: return self.size == self.capacity def is_empty(self) -> bool: return self.size == 0 def __len__(self) -> int: return self.size"},{"question":"**Problem Statement:** You are given the root of a binary tree. Implement a function to perform a postorder traversal on the binary tree. # Function Signature: ```python def postorder_traversal(root: Optional[Node]) -> List[int]: pass ``` # Input: - `root`: a Node object representing the root of the binary tree, or `None` if the tree is empty. # Output: - A list of integers representing the postorder traversal of the binary tree. # Constraints: - The number of nodes in the binary tree can range from `0` to `10^4`. - The values of the nodes are integers and can be positive, negative, or zero. # Performance Requirements: - The implementation should have a time complexity of O(n) where n is the number of nodes in the binary tree. - Strive for efficient space usage. # Example: ```python # Example Binary Tree # 1 # / # 2 3 # / # 4 5 # Input: The binary tree rooted at the node \'root\' with the given structure. root = Node(1, Node(2, Node(4), Node(5)), Node(3)) # Expected Output: [4, 5, 2, 3, 1] print(postorder_traversal(root)) ``` # Notes: - Implement both a recursive and an iterative approach in the same function, and select the one which you believe is more optimal in practice. Explain the reasons for choosing that approach in comments within the code. - Consider edge cases and ensure your solution handles them gracefully.","solution":"from typing import Optional, List class Node: def __init__(self, value: int, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.value = value self.left = left self.right = right def postorder_traversal(root: Optional[Node]) -> List[int]: Perform a postorder traversal on the binary tree. :param root: Node - the root of the binary tree or None :return: List[int] - list of integers in postorder traversal order if root is None: return [] result = [] # Iterative approach using a stack stack = [] visited = set() while stack or root: while root: stack.append(root) root = root.left node = stack[-1] if node.right and node.right not in visited: root = node.right else: node = stack.pop() result.append(node.value) visited.add(node) root = None return result"},{"question":"# Path Simplification Coding Challenge Objective Write a function `simplify_path` to simplify given Unix-style paths, resolving \'.\' (current directory) and \'..\' (parent directory). Your solution should handle edge cases like multiple slashes and paths attempting to navigate above the root directory. Function Signature ```python def simplify_path(path: str) -> str: pass ``` Input Format * A single string `path` representing an absolute path (Unix-style). Output Format * A single string representing the simplified canonical path. Constraints * The length of `path` will be between 1 and 3000. * `path` will start with \'/\' (indicating an absolute path). Examples 1. **Input**: `\\"/home/\\"` **Output**: `\\"/home\\"` 2. **Input**: `\\"/a/./b/../../c/\\"` **Output**: `\\"/c\\"` 3. **Input**: `\\"/../\\"` **Output**: `/` 4. **Input**: `\\"/home//foo/\\"` **Output**: `\\"/home/foo\\"` Requirements * Your implementation should process the path in linear time. * Avoid using additional constructs outside standard libraries. Explanation To solve this challenge, manage the path components using a stack: 1. Split the input path by \'/\'. 2. Traverse each component (token) and update the stack based on token types: - \'..\' means popping the topmost element from the stack. - \'.\' or empty tokens are ignored. - Valid directory names are pushed onto the stack. 3. Join the stack components with \'/\' to form the canonical path, ensuring it starts with \'/\'. Good luck and happy coding!","solution":"def simplify_path(path: str) -> str: Simplifies a given Unix-style absolute path. Args: - path (str): A string representing an absolute path. Returns: - str: The simplified canonical path. tokens = path.split(\'/\') stack = [] for token in tokens: if token == \'\' or token == \'.\': continue elif token == \'..\': if stack: stack.pop() else: stack.append(token) return \'/\' + \'/\'.join(stack)"},{"question":"# Scenario You are assisting a company specializing in educational software development. They are creating an app that helps students learn about geometric properties, specifically right-angled triangles. You have been tasked to implement a function that calculates the length of one missing side of a right-angled triangle using the Pythagorean theorem, given the other two sides. # Function Specification Implement a function named `compute_third_side` as described below: ```python def compute_third_side(opposite, adjacent, hypotenuse): Computes the length of the missing side of a right-angled triangle. Args: - opposite (float or str): the length of the opposite side or \\"?\\" if unknown. - adjacent (float or str): the length of the adjacent side or \\"?\\" if unknown. - hypotenuse (float or str): the length of the hypotenuse side or \\"?\\" if unknown. Returns: - float: The length of the missing side. Raises: - ValueError: If the input is invalid or it’s impossible to form a right-angled triangle with the given sides. ``` # Input - `opposite`: A float representing the length of the opposite side or \\"?\\" indicating it is unknown. - `adjacent`: A float representing the length of the adjacent side or \\"?\\" indicating it is unknown. - `hypotenuse`: A float representing the length of the hypotenuse side or \\"?\\" indicating it is unknown. # Output - A float representing the length of the missing side. # Constraints - Only one of `opposite`, `adjacent`, or `hypotenuse` will be \\"?\\". - The provided lengths will be positive numbers. - Must handle inputs where provided lengths cannot form a valid right-angled triangle and raise a `ValueError`. # Implementation Notes - Validate inputs to ensure they are consistent with the properties of right-angled triangles. - Provide clear error messages in case of invalid inputs. # Examples 1. `compute_third_side(\\"?\\", 3, 5)` should return `4.0` (opposite side). 2. `compute_third_side(5, \\"?\\", 13)` should return `12.0` (adjacent side). 3. `compute_third_side(6, 8, \\"?\\")` should return `10.0` (hypotenuse). # Unit Tests Ensure you provide a set of unit tests to validate your function against regular and edge cases.","solution":"import math def compute_third_side(opposite, adjacent, hypotenuse): Computes the length of the missing side of a right-angled triangle. Args: - opposite (float or str): the length of the opposite side or \\"?\\" if unknown. - adjacent (float or str): the length of the adjacent side or \\"?\\" if unknown. - hypotenuse (float or str): the length of the hypotenuse side or \\"?\\" if unknown. Returns: - float: The length of the missing side. Raises: - ValueError: If the input is invalid or it’s impossible to form a right-angled triangle with the given sides. # Validate inputs if not isinstance(opposite, (int, float, str)) or not isinstance(adjacent, (int, float, str)) or not isinstance(hypotenuse, (int, float, str)): raise ValueError(\\"Inputs should be float or \'?\'.\\") if (opposite != \\"?\\" and opposite <= 0) or (adjacent != \\"?\\" and adjacent <= 0) or (hypotenuse != \\"?\\" and hypotenuse <= 0): raise ValueError(\\"Side lengths must be positive numbers.\\") # Calculate the missing side using Pythagorean theorem if opposite == \\"?\\": if hypotenuse <= adjacent: raise ValueError(\\"Hypotenuse must be the longest side.\\") return math.sqrt(hypotenuse ** 2 - adjacent ** 2) elif adjacent == \\"?\\": if hypotenuse <= opposite: raise ValueError(\\"Hypotenuse must be the longest side.\\") return math.sqrt(hypotenuse ** 2 - opposite ** 2) elif hypotenuse == \\"?\\": return math.sqrt(opposite ** 2 + adjacent ** 2) else: raise ValueError(\\"Exactly one side length must be \'?\'.\\")"},{"question":"# Single Number in Thrice-Repeating Array Context In some problem scenarios, you might encounter an array where every integer appears exactly three times except for one integer, which appears only once. Your task is to identify that single integer. Such a scenario could represent data streams where a majority of elements are redundant/duplicated, but certain identifiers need extraction with accurate low resource utilization. Problem Statement Write a function to find the integer that appears exactly once in an array where every other integer appears exactly three times. Your solution must run in linear time and use constant space. Function Signature ```python def find_single_number(nums: List[int]) -> int: pass ``` Input * `nums`: A list of integers of size `n` (1 <= n <= 3 * 10^4), where every integer appears three times except for one which appears exactly once. The list can contain both positive and negative integers. Output * Returns the single integer that appears exactly once. Constraints: - You must achieve a time complexity of O(n). - You must not use any extra memory (O(1) space complexity). Example ```python assert find_single_number([2, 2, 3, 2]) == 3 assert find_single_number([0, 1, 0, 1, 0, 1, 99]) == 99 ``` Additional Notes * Consider edge cases with the minimum and maximum input constraints. * Ensure that your code handles negative numbers correctly.","solution":"from typing import List def find_single_number(nums: List[int]) -> int: Finds the element that appears exactly once in an array where every other element appears exactly three times. one, two = 0, 0 for num in nums: one = (one ^ num) & ~two two = (two ^ num) & ~one return one"},{"question":"# Question: Reverse String Implementation Objective Implement a function to reverse a string using any of the methods discussed above (recursive, iterative, pythonic, ultra-pythonic). Requirements You need to implement a function `reverse_string(s)` that: * Takes a single string `s` as input. * Returns the reversed version of the string. Input Format * A string `s`, where (0 leq text{len}(s) leq 10^5). Output Format * A single string which is the reverse of the input string. Constraints * The solution should handle strings efficiently within the given constraints. * Ensure that any edge cases such as empty string or single character strings are handled properly. Function Signature ```python def reverse_string(s: str) -> str: pass ``` Example # Input ```python s = \\"hello\\" ``` # Output ```python \\"olleh\\" ``` Notes * Your solution should be efficient and handle large strings optimally. * You can choose any of the discussed methods or a combination of them if it suits your approach.","solution":"def reverse_string(s: str) -> str: Returns the reversed version of the string `s`. return s[::-1]"},{"question":"# Problem: Optimize Network Cost You\'re hired to optimize the layout of a new telecommunications network. Your task is to lay out the cables in such a way that all cities are connected with the minimum total cable length. The network is represented as an undirected, weighted graph where each node is a city and each edge between two nodes represents a cable of certain length. # Input Format - The first line contains two integers, ( n ) (number of cities) and ( m ) (number of cables). - The next ( m ) lines contain three integers each: ( u ), ( v ), and ( w ), representing a cable between cities ( u ) and ( v ) with length ( w ). # Output Format - A single integer: the minimal total length of cables required to ensure all cities are connected. - If the cities cannot be fully connected with the given cables, output -1. Example **Input:** ``` 5 6 1 2 3 1 3 8 2 4 5 3 4 2 3 5 4 4 5 6 ``` **Output:** ``` 14 ``` **Explanation:** A minimum spanning tree can be formed with cables of length 3, 5, 2, and 4, resulting in a total length of 14. # Constraints - ( 1 leq n leq 1000 ) - ( 1 leq m leq 100000 ) - ( 1 leq w leq 1000000 ) # Requirements: - Your function should be efficient in both time and space complexity. - Utilize Kruskal\'s Algorithm with Disjoint-Set data structure to find the MST. ```python def optimize_network_cost(n, m, edges): Find the minimum cost to connect all cities (nodes) in an undirected graph using Kruskal\'s algorithm with a Disjoint-Set data structure (Union-Find). Args: n (int): Number of cities (vertices in the graph). m (int): Number of cables (edges in the graph). edges (list of tuples): Each tuple has three integers (u, v, w) representing an edge between cities u and v with a weight w. Returns: int: Minimum total length of cables required to connect all cities, or -1 if not all cities can be connected. pass # Implement your solution here # Example usage: # n = 5 # m = 6 # edges = [(1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6)] # print(optimize_network_cost(n, m, edges)) # Output: 14 ```","solution":"def optimize_network_cost(n, m, edges): Find the minimum cost to connect all cities (nodes) in an undirected graph using Kruskal\'s algorithm with a Disjoint-Set data structure (Union-Find). Args: n (int): Number of cities (vertices in the graph). m (int): Number of cables (edges in the graph). edges (list of tuples): Each tuple has three integers (u, v, w) representing an edge between cities u and v with a weight w. Returns: int: Minimum total length of cables required to connect all cities, or -1 if not all cities can be connected. # Helper function to find the representative of a set def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] # Helper function to union two sets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 # Kruskal\'s algorithm edges.sort(key=lambda x: x[2]) # Sort edges by weight parent = [i for i in range(n+1)] rank = [0] * (n+1) min_cost = 0 edges_in_mst = 0 for u, v, w in edges: if find(parent, u) != find(parent, v): union(parent, rank, u, v) min_cost += w edges_in_mst += 1 # Check if we included exactly n-1 edges if edges_in_mst == n - 1: return min_cost else: return -1"},{"question":"# Ternary Search Implementation Problem Statement You are given a sorted array `arr` of length `n` and an integer `key`. Implement a function `ternary_search` that returns the index of `key` in the array using the ternary search algorithm. If `key` is not present, return `-1`. Function Signature ```python def ternary_search(arr: list[int], key: int) -> int: ``` Input - `arr`: A list of integers sorted in ascending order. `1 <= len(arr) <= 10^6` - `key`: An integer value to search for in the array. `-10^6 <= key <= 10^6` Output - Return the index of `key` in the array if it exists. Otherwise, return `-1`. Constraints - You can assume that all array elements are distinct. - Aim for a time complexity of O(log<sub>3</sub>(N)). Example ```python # Example 1: arr = [1, 2, 4, 5, 9, 12, 15] key = 5 print(ternary_search(arr, key)) # Output: 3 # Example 2: arr = [1, 2, 4, 5, 9, 12, 15] key = 10 print(ternary_search(arr, key)) # Output: -1 ``` Requirements 1. Ensure the function handles edge cases such as empty arrays, and arrays with one element. 2. The solution should operate within the specified time complexity. 3. Avoid using built-in search functions or libraries to ensure students practice algorithm implementation.","solution":"def ternary_search(arr, key): Performs a ternary search on the sorted array \'arr\' to find the index of \'key\'. Returns -1 if the key is not found. def search(left, right): if left > right: return -1 third = (right - left) // 3 mid1 = left + third mid2 = right - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: return search(left, mid1 - 1) elif key > arr[mid2]: return search(mid2 + 1, right) else: return search(mid1 + 1, mid2 - 1) return search(0, len(arr) - 1)"},{"question":"# Bellman-Ford Path Reconstruction As a transportation planner, you are required to determine the most efficient routes in a city road network with varying path costs. The network, represented as a directed graph with possible negative weights, requires the use of the Bellman-Ford algorithm. Besides finding the shortest path, you are required to also reconstruct the path itself if a solution exists. Task Implement a function `bellman_ford_with_paths(graph, source)` that: 1. Uses the Bellman-Ford algorithm to determine the shortest path from a source node to all other nodes. 2. Detects if there is any negative-weight cycle accessible from the source. 3. Returns a tuple `(shortest_paths, paths)` where: - `shortest_paths` is a dictionary with nodes as keys and their shortest distance from the source as values. If a node is unreachable, its distance should be `float(\'inf\')`. - `paths` is a dictionary with nodes as keys and lists representing the sequence of nodes forming the shortest path from the source to that node. If a node is unreachable, its path should be an empty list. Input - `graph`: A dictionary representing the weighted directed graph. Keys are node identifiers and values are dictionaries with adjacent nodes as keys and edge weights as values (e.g., `{\'a\': {\'b\': 6, \'e\': 7}, ...}`). - `source`: The starting node for the shortest path calculation. Constraints - The graph can have up to 1000 nodes. - Edge weights can range from -1000 to 1000. Output - A tuple `(shortest_paths, paths)` as described above. Example ```python graph = { \'a\': {\'b\': 6, \'e\': 7}, \'b\': {\'c\': 5, \'d\': -4, \'e\': 8}, \'c\': {\'b\': -2}, \'d\': {\'a\': 2, \'c\': 7}, \'e\': {\'b\': -3} } source = \'a\' shortest_paths, paths = bellman_ford_with_paths(graph, source) print(shortest_paths) # {\'a\': 0, \'b\': 4, \'c\': 9, \'d\': 0, \'e\': 7} print(paths) # {\'a\': [\'a\'], \'b\': [\'a\', \'e\', \'b\'], \'c\': [\'a\', \'e\', \'b\', \'c\'], \'d\': [\'a\', \'e\', \'b\', \'d\'], \'e\': [\'a\', \'e\']} ``` **Note**: Ensure that your solution handles edge cases and checks for negative-weight cycles.","solution":"def bellman_ford_with_paths(graph, source): # Step 1: Initialization shortest_paths = {node: float(\'inf\') for node in graph} shortest_paths[source] = 0 predecessor = {node: None for node in graph} paths = {node: [] for node in graph} # Step 2: Relax edges repeatedly for _ in range(len(graph) - 1): for node in graph: for neighbor, weight in graph[node].items(): if shortest_paths[node] + weight < shortest_paths[neighbor]: shortest_paths[neighbor] = shortest_paths[node] + weight predecessor[neighbor] = node # Step 3: Check for negative-weight cycles for node in graph: for neighbor, weight in graph[node].items(): if shortest_paths[node] + weight < shortest_paths[neighbor]: raise ValueError(\\"Graph contains a negative-weight cycle\\") # Step 4: Reconstruct paths for node in graph: if shortest_paths[node] < float(\'inf\'): current = node while current is not None: paths[node].insert(0, current) current = predecessor[current] if paths[node][0] != source: paths[node] = [] return shortest_paths, paths"},{"question":"# Context You are managing an archive system that organizes data hierarchically and allows quick retrieval and updates. One frequent operation is to find the next item in the sorted order. # Task Write a function that, given the root of a binary search tree (BST) and a node, returns the in-order successor of the given node if it exists. If the in-order successor does not exist, return None. # Function Signature ```python def find_inorder_successor(root: \'TreeNode\', node: \'TreeNode\') -> \'TreeNode\': pass ``` # Input - `root`: Root node of the binary search tree (TreeNode). It could be `None`. - `node`: Node in the tree for which the in-order successor needs to be found. This node will always be a valid TreeNode reference within the BST. # Output - Return the in-order successor node (TreeNode) if it exists, otherwise return `None`. # Constraints - All `TreeNode` values are unique. - The number of nodes, n, in the BST is in the range [0, 10^4]. # Example Input ```python root = [20, 9, 25, 5, 12, None, None, None, None, 11, 14] node = TreeNode(val=12) ``` Output ```python TreeNode(val=14) ``` # Notes 1. Ensure to handle edge cases such as the BST being empty or the node having no successor correctly. 2. Optimize your solution for time complexity O(h), where h is the height of the BST.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_inorder_successor(root: \'TreeNode\', node: \'TreeNode\') -> \'TreeNode\': if not root or not node: return None # Helper function to find the leftmost node def find_min(node): while node.left is not None: node = node.left return node # If the node has a right child, then the successor is the leftmost node in the right subtree if node.right: return find_min(node.right) # Otherwise, the successor is one of the ancestors successor = None current = root while current: if node.val < current.val: successor = current current = current.left elif node.val > current.val: current = current.right else: break return successor"},{"question":"**Question: Implement Binary Exponentiation with Matrix Representation** # Context: Binary exponentiation is a powerful technique to compute large powers efficiently. This approach can be extended to other mathematical structures like matrices. For example, computing the nth power of a matrix can be beneficial in certain applications such as finding nth terms of linear recurrences. # Task: Write a function to compute the nth power of a given 2x2 matrix using Binary Exponentiation. Implement both iterative and recursive versions of this function. # Input: - A 2x2 matrix represented as a list of lists (e.g., `[[a11, a12], [a21, a22]]`). - An integer `n` (0 <= n <= 10^9). - An optional integer `mod` for modular arithmetic. # Output: - The resulting 2x2 matrix after exponentiation. # Constraints: - The matrix elements and `n` are guaranteed to be integers. - If `mod` is specified, all operations (addition, multiplication) should be done modulo `mod`. # Example: ```python matrix = [[2, 1], [1, 0]] n = 5 mod = 1000 exponentiate_matrix(matrix, n, mod) -> [[21, 13], [13, 8]] ``` # Guidelines: 1. Define a helper function `matrix_multiply` to multiply two 2x2 matrices. 2. Define both `matrix_power_iter` (iterative) and `matrix_power_recur` (recursive) functions to compute the power of a matrix using Binary Exponentiation, utilizing the helper function. 3. Ensure to handle edge cases like `n = 0` and `n = 1`. 4. Optimize for efficiency, keeping in mind the space and time complexity.","solution":"def matrix_multiply(matrix1, matrix2, mod=None): Multiplies two 2x2 matrices and returns the resulting matrix. a11 = matrix1[0][0] * matrix2[0][0] + matrix1[0][1] * matrix2[1][0] a12 = matrix1[0][0] * matrix2[0][1] + matrix1[0][1] * matrix2[1][1] a21 = matrix1[1][0] * matrix2[0][0] + matrix1[1][1] * matrix2[1][0] a22 = matrix1[1][0] * matrix2[0][1] + matrix1[1][1] * matrix2[1][1] if mod: a11 %= mod a12 %= mod a21 %= mod a22 %= mod return [[a11, a12], [a21, a22]] def matrix_power_iter(matrix, n, mod=None): Computes the nth power of a 2x2 matrix iteratively using Binary Exponentiation. result = [[1, 0], [0, 1]] # Identity matrix base = matrix while n > 0: if n % 2 == 1: result = matrix_multiply(result, base, mod) base = matrix_multiply(base, base, mod) n //= 2 return result def matrix_power_recur(matrix, n, mod=None): Computes the nth power of a 2x2 matrix recursively using Binary Exponentiation. if n == 0: return [[1, 0], [0, 1]] # Identity matrix if n == 1: return matrix half_power = matrix_power_recur(matrix, n // 2, mod) half_power_squared = matrix_multiply(half_power, half_power, mod) if n % 2 == 0: return half_power_squared else: return matrix_multiply(half_power_squared, matrix, mod)"},{"question":"**Scenario**: You are given an array representing the daily stock price changes of a certain stock. Your task is to determine the maximum profit that can be made by buying on one day and selling on another day after considering the price changes given. You\'ll need to implement Kadane\'s Algorithm to find the maximum sum of any contiguous subarray which will provide the highest profit margin. **Function Signature**: ```python def max_profit_from_stock_changes(price_changes: List[int]) -> int: ``` **Input**: - `price_changes`: A list of integers where each integer represents the daily change in stock price. The array is non-empty and contains at least one element. **Output**: - Return an integer representing the maximum profit possible from the stock price changes. If all changes are negative, return the maximum single day change. **Constraints**: 1. The length of `price_changes` will be in the range [1, 10^5]. 2. Each value in `price_changes` will be in the range [-10^4, 10^4]. **Examples**: 1. `price_changes = [-2, 3, 8, -1, 4]` **Output**: `14` (Subarray `[3, 8, -1, 4]` gives the maximum profit) 2. `price_changes = [-1, 1, 0]` **Output**: `1` (Subarray `[1]` gives the maximum profit) 3. `price_changes = [-1, -3, -4]` **Output**: `-1` (Subarray `[-1]` gives the maximum profit) 4. `price_changes = [-2, 3, 8, -12, 8, 4]` **Output**: `12` (Subarray `[8, 4]` gives the maximum profit) **Note**: - The function should handle edge cases such as all negative values efficiently. - Students need to carefully ensure the starting and ending points of subsequences are correctly managed to maximize profit.","solution":"from typing import List def max_profit_from_stock_changes(price_changes: List[int]) -> int: Returns the maximum profit that can be made from the given daily stock price changes using the Kadane\'s Algorithm for finding the maximum sum of any contiguous subarray. # Initialize with the first element max_current = max_global = price_changes[0] for price in price_changes[1:]: # Compare the current element and the current element + max_current max_current = max(price, max_current + price) # Update the global max if the current max is greater max_global = max(max_global, max_current) return max_global"},{"question":"Scenario In a software project, you need to efficiently merge two sorted data sequences. Each sequence is represented as a linked list. The task is to create a new sorted linked list that integrates the nodes from the input lists. This new list must maintain the sorted order of elements. Task Write a function `merge_two_sorted_linked_lists(l1, l2)` that merges two sorted linked lists and returns the head of the merged linked list. Input * `l1` and `l2`: Heads of two singly linked lists. Each list node has the structure `Node(val, next)`, where `val` is the value stored in the node and `next` is the pointer to the next node in the list. Output * Return the head node of the merged singly linked list. Constraints * All input and output lists must be sorted in non-decreasing order. * If both input lists are empty, return None. * You are not allowed to use any additional data structures. * You must handle edge cases efficiently. Performance Requirements * The solution should have a time complexity of O(n + m). * For large lists, prefer an iterative approach to avoid recursion limit issues. Example ```python class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_linked_lists(l1, l2): # Your implementation here # Example usage: # Linked list 1: 1 -> 2 -> 4 # Linked list 2: 1 -> 3 -> 4 # Function Returns: 1 -> 1 -> 2 -> 3 -> 4 -> 4 # To create nodes and use the function: # l1 = Node(1, Node(2, Node(4))) # l2 = Node(1, Node(3, Node(4))) # merged = merge_two_sorted_linked_lists(l1, l2) # Traverse merged to print values: 1 -> 1 -> 2 -> 3 -> 4 -> 4 ``` Ensure your solution is efficient and handles edge cases as discussed. Your implementation will be assessed based on correctness, efficiency, and adherence to the constraints.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_linked_lists(l1, l2): # Create a dummy node to act as the starting point of the merged list dummy = Node() current = dummy # Traverse both lists and append the smaller value to the merged list while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # Append the remaining elements of l1 or l2, if any if l1: current.next = l1 if l2: current.next = l2 # Return the merged list, which starts at the next node of dummy return dummy.next"},{"question":"# Krishnamurthy Number Checker with Optimization Objective Write a function that checks whether a given number is a Krishnamurthy Number or not. In your implementation, optimize the factorial calculations using memoization. Requirements - Implement a function `is_krishnamurthy_number(num)` that takes a single integer `num` as input. - The function should return a boolean value: `True` if the number is a Krishnamurthy Number, and `False` otherwise. Constraints - The input number will be a non-negative integer (`0 <= num <= 10^6`). Input Example ```python print(is_krishnamurthy_number(145)) print(is_krishnamurthy_number(40585)) print(is_krishnamurthy_number(357)) ``` Output Example ```python True True False ``` Explanation 1. `145` is a Krishnamurthy Number because 1! + 4! + 5! = 145. 2. `40585` is a Krishnamurthy Number because 4! + 0! + 5! + 8! + 5! = 40585. 3. `357` is not a Krishnamurthy Number as 3! + 5! + 7! != 357.","solution":"def is_krishnamurthy_number(num): Checks whether a given number is a Krishnamurthy Number. A Krishnamurthy Number is a number where the sum of the factorials of its digits equals the number itself. Parameters: num (int): The input number to check. Returns: bool: True if the number is a Krishnamurthy Number, False otherwise. def factorial(n): Returns the factorial of a given number using recursion with memoization. if n in memo: return memo[n] if n == 0 or n == 1: return 1 result = n * factorial(n - 1) memo[n] = result return result # Memoization dictionary for factorial calculations memo = {} # Sum the factorial of each digit in the number digit_sum = sum(factorial(int(digit)) for digit in str(num)) return digit_sum == num"},{"question":"# Question You are given a straightforward implementation of the Interpolation Search algorithm. Now, your task is to adapt and enhance the provided algorithm to handle more complex data scenarios. **Problem Statement**: You need to write a function that improves the presented Interpolation Search algorithm by fixing potential pitfalls, handling edge cases, and optimizing performance. Specifically, you must accommodate non-uniformly distributed datasets and avoid division by zero errors. **Function Signature**: ```python def enhanced_interpolation_search(array: List[int], search_key: int) -> int: :param array: The array to be searched. :param search_key: The key to be searched in the array. :returns: Index of search_key in array if found, else -1. ``` **Input and Output**: * The function takes in: - `array`: A list of integers which is sorted in non-decreasing order. - `search_key`: An integer key to search for within the array. * The function should return an integer: - The index of the `search_key` within the array if found. - `-1` if the `search_key` is not present in the array. **Constraints**: - The array length will be between 1 and (10^5). - All integers are between (-10^9) and (10^9). **Performance Requirements**: - The function should be optimized in terms of time complexity and handle arrays with both uniform and non-uniform distributions efficiently. **Example**: ```python assert enhanced_interpolation_search([5, 10, 12, 14, 18, 20], 14) == 3 assert enhanced_interpolation_search([5, 10, 12, 14, 18, 20], 100) == -1 assert enhanced_interpolation_search([], 50) == -1 assert enhanced_interpolation_search([10, 10, 10, 10], 10) == 0 ``` **Explanation**: In these examples, the function finds the position of the search_key within the provided sorted array or returns `-1` if the search_key is not present, handling empty and uniform arrays efficiently.","solution":"from typing import List def enhanced_interpolation_search(array: List[int], search_key: int) -> int: Returns the index of search_key in array if found, else -1. if not array: return -1 low = 0 high = len(array) - 1 while low <= high and array[low] <= search_key <= array[high]: # Avoid division by zero if array[high] == array[low] if array[high] == array[low]: if array[low] == search_key: return low else: return -1 # Calculate the probe position pos = low + ((search_key - array[low]) * (high - low) // (array[high] - array[low])) if pos < low or pos > high: return -1 if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"You are implementing a library to serialize and deserialize a binary tree. Given a binary tree, you need to write functions to convert the tree to a string and then reconstruct the tree from the string. Your task is to implement the following two functions in Python: - `serialize(root)`: This function takes the root of the binary tree and returns a serialized string representation of the tree. - `deserialize(data)`: This function takes the serialized string and reconstructs the binary tree, returning the root of the tree. # Function Signature ```python class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root): # Your code here def deserialize(data): # Your code here ``` # Input and Output Formats - **serialize** - **Input**: `root` - The root node of a binary tree of type `TreeNode`. - **Output**: Returns a string representation of the binary tree. - **deserialize** - **Input**: `data` - A string representation of the binary tree. - **Output**: Returns the root node of the reconstructed binary tree of type `TreeNode`. # Constraints - The number of nodes in the tree is in the range `[0, 10^4]`. - The value of nodes is an integer in the range `[-10^5, 10^5]`. # Example ```python # Example Usage root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) data = serialize(root) print(data) # Outputs a pre-order serialized string such as: \\"1 2 # # 3 4 # # 5 # #\\" restored_root = deserialize(data) print(serialize(restored_root)) # Should output the same string as above. ``` # Performance Requirements - Both `serialize` and `deserialize` functions should run efficiently within the given constraints. Please implement the functions, ensuring correctness and taking care of edge cases such as empty trees, or very large trees that require deep recursion.","solution":"class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root): Encodes a tree to a single string. def helper(node): if node is None: return \\"#\\" return \\"{} {} {}\\".format(node.val, helper(node.left), helper(node.right)) return helper(root) def deserialize(data): Decodes your encoded data to tree. def helper(data_iter): val = next(data_iter) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = helper(data_iter) node.right = helper(data_iter) return node data_iter = iter(data.split()) return helper(data_iter)"},{"question":"# Task You are required to write a function that finds the most frequent value(s) in a given list of integers. If there are multiple values that are the most frequent, the function should return all of them in no particular order. # Function Signature ```python def find_modes(arr: List[int]) -> List[int]: ``` # Input - `arr`: A list of integers. (0 ≤ len(arr) ≤ 10^6, -10^9 ≤ arr[i] ≤ 10^9) # Output - A list of integers which are the mode(s) of the input list. If the input list is empty, return an empty list. # Examples ```python assert find_modes([1, 1, 2, 2, 3, 4]) == [1, 2] assert find_modes([4, 4, 1, 1, 2, 2]) == [4, 1, 2] assert find_modes([]) == [] assert find_modes([7, 7, 7, 8, 8, 8, 9, 9, 6]) == [7, 8] ``` # Constraints - Implement the function with a time complexity of O(n). # Additional Information - Handle edge cases such as an empty list, list with one element, and all elements being unique. - The order of elements in the output list does not matter. - The function should be efficient with respect to both time and space complexity.","solution":"from typing import List from collections import Counter def find_modes(arr: List[int]) -> List[int]: if not arr: return [] counter = Counter(arr) max_count = max(counter.values()) return [key for key, count in counter.items() if count == max_count]"},{"question":"# Scenario: You are tasked with working on a text-processing feature for a new software that compares user input against a reference string. One of the requirements is to verify if the user\'s input string is one edit distance away from the reference string. This check is fundamental for implementing functionalities like autocorrect or spell suggestions. # Problem: Given two strings `S` and `T`, write a function `is_one_edit` to determine if they are exactly one edit distance apart. An edit can be: 1. Inserting a character 2. Deleting a character 3. Modifying a character You need to implement a function: ```python def is_one_edit(s: str, t: str) -> bool: pass ``` # Input: - `s` and `t`: two strings with lengths between 0 and 10^3. # Output: - Return `True` if the strings are exactly one edit distance apart, otherwise `False`. # Constraints: - The function should run in linear time relative to the length of the shorter string. # Examples: 1. `is_one_edit(\\"abc\\", \\"ab\\")` should return `True` (delete \'c\'). 2. `is_one_edit(\\"abc\\", \\"adc\\")` should return `True` (modify \'b\' to \'d\'). 3. `is_one_edit(\\"abc\\", \\"abcd\\")` should return `True` (insert \'d\'). 4. `is_one_edit(\\"abc\\", \\"abc\\")` should return `False` (no edit). 5. `is_one_edit(\\"abc\\", \\"ac\\")` should return `True` (delete \'b\'). Consider necessary edge cases, including empty strings and strings differing in length by more than one character.","solution":"def is_one_edit(s: str, t: str) -> bool: Determines if the strings s and t are exactly one edit distance apart. An edit can be: 1. Inserting a character 2. Deleting a character 3. Modifying a character m, n = len(s), len(t) # If the length difference is more than 1, it\'s not one edit distance if abs(m - n) > 1: return False # Identify the shorter and longer string if m > n: s, t = t, s m, n = n, m # To accommodate the scenario of modification in one pass edit_found = False i, j = 0, 0 # Pointers for both strings while i < m and j < n: if s[i] != t[j]: # If we have already encountered an edit, return False if edit_found: return False edit_found = True # If lengths are the same, move both pointers (for replace case) if m == n: i += 1 # If lengths are different, move pointer of the longer string else: i += 1 j += 1 # If the strings are of different lengths, consider the last character of the longer string return edit_found or m < n"},{"question":"# RSA Encryption Algorithm Implementation You are required to implement a function to securely generate RSA keys and to encrypt/decrypt messages using these keys. The RSA key generation involves selecting two large prime numbers, computing the modulus, and finding modular inverses. You will then use the generated keys to encrypt and decrypt messages. Function: `generate_key(k)` * **Input**: * `k` (int): The number of bits in the modulus ( n ). * **Output**: * A tuple `(n, e, d)` where: - `n` (int): The modulus. - `e` (int): The public exponent. - `d` (int): The private exponent. You also need to implement the functions: Function: `encrypt(data, e, n)` * **Input**: * `data` (int): The message to be encrypted. * `e` (int): The public exponent. * `n` (int): The modulus. * **Output**: * `encrypted_data` (int): The encrypted message. Function: `decrypt(data, d, n)` * **Input**: * `data` (int): The encrypted message. * `d` (int): The private exponent. * `n` (int): The modulus. * **Output**: * `decrypted_data` (int): The decrypted message. Constraints 1. ( k ) will be a positive integer and will not exceed 128 bits. 2. The message to be encrypted ( data ) will be a non-negative integer less than ( n ). Example Usage ```python n, e, d = generate_key(16) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data ``` Notes: * Do not use any external libraries for prime generation and modular arithmetic. * Focus on correctness and handle typical edge cases for key generation and encryption/decryption processes.","solution":"import random def gcd(a, b): while b != 0: a, b = b, a % b return a def modinv(a, m): m0, x0, x1 = m, 0, 1 if m == 1: return 0 while a > 1: q = a // m m, a = a % m, m x0, x1 = x1 - q * x0, x0 if x1 < 0: x1 += m0 return x1 def is_prime(num): if num < 2: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def get_random_prime(bit_length): while True: num = random.getrandbits(bit_length) if is_prime(num): return num def generate_key(k): p = get_random_prime(k // 2) q = get_random_prime(k // 2) n = p * q phi = (p - 1) * (q - 1) e = 65537 # Commonly used public exponent while gcd(e, phi) != 1: e += 2 d = modinv(e, phi) return (n, e, d) def encrypt(data, e, n): return pow(data, e, n) def decrypt(data, d, n): return pow(data, d, n)"},{"question":"A cityscape is represented as an `m x n` matrix of non-negative integers where each value represents the height of a building. The \\"Pacific Ocean\\" is adjacent to the left and top edges of the city, while the \\"Atlantic Ocean\\" is adjacent to the right and bottom edges. Water can flow from a building to an adjacent building if the neighboring building is of equal or lesser height. You need to find all coordinates where water can flow to both the Pacific and Atlantic oceans. # Input - A matrix of non-negative integers with dimensions `m x n`. # Output - A list of coordinates where water can flow to both oceans. # Constraints - The matrix dimensions `m` and `n` are less than 150. - Order of the coordinates in the output does not matter. # Example Given the following 5x5 matrix: ``` Pacific ~ ~ ~ ~ ~ ~ 1 2 2 3 (5) * ~ 3 2 3 (4) (4) * ~ 2 4 (5) 3 1 * ~ (6) (7) 1 4 5 * ~ (5) 1 1 2 4 * * * * * * Atlantic ``` Return: ``` [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] ``` # Function Signature ```python def pacific_atlantic(matrix): :type matrix: List[List[int]] :rtype: List[List[int]] ``` # Requirements - Ensure that you handle edge cases where the matrix is empty. - Optimize the function to run efficiently within the given constraints. - Consider the recursive depth and potential stack overflow issues. Test your function with the above example and additional test cases to ensure correctness and performance.","solution":"def pacific_atlantic(matrix): if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) pacific_reachable = [[False for _ in range(n)] for _ in range(m)] atlantic_reachable = [[False for _ in range(n)] for _ in range(m)] def dfs(matrix, reachable, i, j): reachable[i][j] = True for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]: if 0 <= x < m and 0 <= y < n and not reachable[x][y] and matrix[x][y] >= matrix[i][j]: dfs(matrix, reachable, x, y) for i in range(m): dfs(matrix, pacific_reachable, i, 0) dfs(matrix, atlantic_reachable, i, n-1) for j in range(n): dfs(matrix, pacific_reachable, 0, j) dfs(matrix, atlantic_reachable, m-1, j) result = [] for i in range(m): for j in range(n): if pacific_reachable[i][j] and atlantic_reachable[i][j]: result.append([i, j]) return result"},{"question":"You are tasked with determining the minimum number of moves required to find the critical floor F in the worst-case scenario, using a given number of eggs and floors. Implement a function `minimum_moves` that uses dynamic programming to achieve this. # Function Signature: ```python def minimum_moves(eggs: int, floors: int) -> int: pass ``` # Input: - `eggs` (int): The number of eggs available (1 <= eggs <= 100). - `floors` (int): The number of floors (0 <= floors <= 100). # Output: - (int): The minimum number of moves required to find the critical floor F in the worst-case scenario. # Example: ```python print(minimum_moves(1, 2)) # Output: 2 print(minimum_moves(2, 10)) # Output: 4 print(minimum_moves(3, 14)) # Output: 4 ``` # Constraints: - You need to use a dynamic programming approach. - Consider edge cases where one or both parameters are at their minimum or maximum values. # Context: You are working in a company that develops building safety systems. Determining the critical floor precisely with the minimal number of trials ensures that your company can optimize the testing process and improve safety measures efficiently.","solution":"def minimum_moves(eggs: int, floors: int) -> int: Returns the minimum number of moves required to find the critical floor F in the worst-case scenario. if floors == 0: return 0 if eggs == 1: return floors dp = [[0] * (floors + 1) for _ in range(eggs + 1)] for f in range(floors + 1): dp[1][f] = f for e in range(2, eggs + 1): for f in range(1, floors + 1): dp[e][f] = float(\'inf\') for x in range(1, f + 1): res = 1 + max(dp[e - 1][x - 1], dp[e][f - x]) if res < dp[e][f]: dp[e][f] = res return dp[eggs][floors]"},{"question":"You are given a list `lst` and an integer `N`. Implement a function `control_occurrences` that returns a new list containing each number from the list at most `N` times while maintaining the original order. # Function Signature: ```python def control_occurrences(lst: List[int], N: int) -> List[int]: ``` # Input: - `lst`: A list of integers. - `N`: An integer indicating the maximum number of times any element can appear in the returned list. # Output: - A list of integers containing each element from original list `lst` at most `N` times in the order of its first appearance. # Constraints: - All integers in the list are non-negative. - `0 <= len(lst) <= 10^5` - `1 <= N <= 10^9` # Performance Requirements: - Your solution should have a time complexity of O(n). # Example: ```python assert control_occurrences([1,2,3,1,2,1,2,3], 2) == [1,2,3,1,2,3] assert control_occurrences([20,37,20,21,20,37,21], 1) == [20,37,21] assert control_occurrences([], 3) == [] ``` # Considerations: - Make sure to handle major edge cases such as empty lists. - Think about performance implications for very large values of N, which should not affect the solution.","solution":"def control_occurrences(lst, N): Returns a new list containing each number from the original list at most `N` times while maintaining the original order. from collections import defaultdict count = defaultdict(int) result = [] for num in lst: if count[num] < N: result.append(num) count[num] += 1 return result"},{"question":"**Union-Find Data Structure Implementation and Application** You are provided with a Union-Find data structure. Your task is to implement a function to count the number of distinct groups (islands) in a grid after a sequence of land additions. # Function Signature: ```python def num_islands(positions: List[List[int]]) -> List[int]: ``` # Input: - `positions`: A list of lists, where each inner list represents the coordinates [x, y] of land that is added sequentially to a grid. Each coordinate is a non-negative integer. # Output: - A list of integers, where each integer represents the number of islands after each addition of land. An island is a group of connected lands horizontally or vertically. # Constraints: 1. The grid is initially all water (0\'s), and you are adding land (1\'s) at the given positions. 2. Coordinate values are non-negative integers. Assume the coordinates fit within the typical integer range used in Python. 3. Each land addition happens one after another, modifying the grid state consecutively. 4. Consider each addition independently, updating the number of islands after each action. # Example: Given a 3x3 grid, `positions = [[0, 0], [0, 1], [1, 2], [2, 1]]`: ``` Initial grid (all water): 0 0 0 0 0 0 0 0 0 Operation #1: addLand(0, 0) Grid becomes: 1 0 0 0 0 0 --> Number of islands = 1 0 0 0 Operation #2: addLand(0, 1) Grid becomes: 1 1 0 0 0 0 --> Number of islands = 1 0 0 0 Operation #3: addLand(1, 2) Grid becomes: 1 1 0 0 0 1 --> Number of islands = 2 0 0 0 Operation #4: addLand(2, 1) Grid becomes: 1 1 0 0 0 1 --> Number of islands = 3 0 1 0 Expected output: [1, 1, 2, 3] ``` Implement the function `num_islands` to count the islands after each land addition. **Note**: Your solution should maintain efficient operations for union and find.","solution":"from typing import List class UnionFind: def __init__(self, width, height): self.parent = {} self.rank = {} self.size = width * height for i in range(width * height): self.parent[i] = -1 self.rank[i] = 0 self.count = 0 def find(self, i): if self.parent[i] != i: self.parent[i] = self.find(self.parent[i]) return self.parent[i] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def setParent(self, x): if self.parent[x] == -1: self.parent[x] = x self.count += 1 def num_islands(positions: List[List[int]]) -> List[int]: if not positions: return [] max_x = max(pos[0] for pos in positions) max_y = max(pos[1] for pos in positions) uf = UnionFind(max_x + 1, max_y + 1) res = [] added_land = set() for pos in positions: x, y = pos index = x * (max_y + 1) + y if index in added_land: res.append(uf.count) continue added_land.add(index) uf.setParent(index) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy n_index = nx * (max_y + 1) + ny if 0 <= nx <= max_x and 0 <= ny <= max_y and n_index in added_land: uf.union(index, n_index) res.append(uf.count) return res"},{"question":"**Problem Statement:** You are provided with a partially implemented Doubly Linked List. Your task is to complete the implementation and add functionalities to insert nodes at specific positions, delete nodes from specific positions, and reverse the list. You must handle edge cases such as inserting into and deleting from an empty list and adjusting pointers correctly. # Instructions: - Implement the following functions: 1. `insert_at_position(self, value, position)`: - **Input**: An integer `value` and an integer `position`. - **Output**: None. - **Operation**: Inserts a node with the given `value` at the specified `position` (0-based index). 2. `delete_at_position(self, position)`: - **Input**: An integer `position`. - **Output**: None. - **Operation**: Deletes the node at the specified `position`. 3. `reverse(self)`: - **Input**: None. - **Output**: None. - **Operation**: Reverses the entire linked list. # Constraints: - You must maintain the doubly linked list properties. - Minimize the time complexity for each operation. # Example: ```plaintext # Initialize the doubly linked list dll = DoublyLinkedList() # Insert elements dll.insert_at_position(10, 0) # List: 10 dll.insert_at_position(20, 1) # List: 10 <-> 20 dll.insert_at_position(30, 2) # List: 10 <-> 20 <-> 30 dll.insert_at_position(40, 1) # List: 10 <-> 40 <-> 20 <-> 30 # Delete elements dll.delete_at_position(1) # List: 10 <-> 20 <-> 30 dll.delete_at_position(2) # List: 10 <-> 20 # Reverse list dll.reverse() # List: 20 <-> 10 ``` # Class Definitions: ```python class DoublyLinkedListNode(object): def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList(object): def __init__(self): self.head = None self.tail = None def insert_at_position(self, value, position): # Implement this method pass def delete_at_position(self, position): # Implement this method pass def reverse(self): # Implement this method pass ``` **Write your implementation below.**","solution":"class DoublyLinkedListNode(object): def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList(object): def __init__(self): self.head = None self.tail = None def insert_at_position(self, value, position): new_node = DoublyLinkedListNode(value) if position == 0: if not self.head: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node return current = self.head for _ in range(position - 1): if not current: raise IndexError(\'Position out of bounds\') current = current.next if not current: raise IndexError(\'Position out of bounds\') new_node.next = current.next new_node.prev = current if current.next: current.next.prev = new_node else: self.tail = new_node current.next = new_node def delete_at_position(self, position): if not self.head: raise IndexError(\'Position out of bounds\') if position == 0: if self.head == self.tail: self.head = self.tail = None else: self.head = self.head.next self.head.prev = None return current = self.head for _ in range(position - 1): if not current: raise IndexError(\'Position out of bounds\') current = current.next if not current or not current.next: raise IndexError(\'Position out of bounds\') to_delete = current.next current.next = to_delete.next if to_delete.next: to_delete.next.prev = current else: self.tail = current def reverse(self): current = self.head self.tail = self.head prev = None while current: next_node = current.next current.next = prev current.prev = next_node prev = current current = next_node self.head = prev def to_list(self): elements = [] current = self.head while current: elements.append(current.value) current = current.next return elements"},{"question":"You are given an array containing various elements. Your task is to write a function `optimized_move_zeros` that moves all the zeros present in the array to the end, while preserving the order of the other elements. The function should perform the operation in-place to optimize space complexity. # Input * An array `arr` of any elements (integers, booleans, strings, etc.) # Output * The same array `arr` with all zeros moved to the end. # Constraints * The elements of the array can be of mixed data types. * Boolean `False` should **not** be considered as zero. * The function should perform the operation in-place with O(1) extra space complexity. # Examples ``` optimized_move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"]) # Returns => [False, 1, 1, 2, 1, 3, \'a\', 0, 0] optimized_move_zeros([0, \\"zero\\", 3, 2, 0, 1, True]) # Returns => [\\"zero\\", 3, 2, 1, True, 0, 0] optimized_move_zeros([0, 0, 0, 0]) # Returns => [0, 0, 0, 0] ``` # Function Signature: ```python def optimized_move_zeros(arr): pass ``` # Requirements: - Function implementation should be done in-place to achieve O(1) space complexity. - Time complexity should remain O(n).","solution":"def optimized_move_zeros(arr): Moves all zeros in the array to the end in-place. Parameters: arr (list): The input list which may contain mixed data types including integers, booleans, strings, etc. Returns: list: The modified list with all zeros moved to the end. zero_count = 0 write_index = 0 for element in arr: if element != 0 or element is False: arr[write_index] = element write_index += 1 else: zero_count += 1 for i in range(zero_count): arr[write_index + i] = 0 return arr"},{"question":"# Graph Pathfinding Challenge You are given the task of determining if there is a path between two nodes in a directed graph using Depth-First Search (DFS). Implement the function `is_reachable` that returns a boolean indicating if there is a path from the source node to the target node. The graph is represented using an adjacency list. # Function Signature ```python def is_reachable(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: pass ``` # Input 1. `vertex_count` (int): The number of vertices in the graph. 2. `edges` (List[Tuple[int, int]]): A list of directed edges in the graph where each edge is represented by a tuple `(source, target)`. 3. `source` (int): The starting node for the path search. 4. `target` (int): The target node for the path search. # Output - Return `True` if there is a path from `source` to `target`, otherwise return `False`. # Constraints - `1 <= vertex_count <= 10^5` - `0 <= source, target < vertex_count` - The graph may contain cycles. - Multiple edges between the same nodes are allowed. # Example ```python # Example 1 print(is_reachable(4, [(0, 1), (0, 2), (1, 2), (2, 0), (2, 3), (3, 3)], 1, 3)) # Output: True # Example 2 print(is_reachable(4, [(0, 1), (0, 2), (1, 2), (2, 0), (2, 3), (3, 3)], 3, 1)) # Output: False ``` **Explanation**: - In Example 1, there is a path from node 1 to node 3 (e.g., 1 -> 2 -> 3). - In Example 2, there is no path from node 3 to node 1. **Notes**: - Ensure your solution efficiently handles large graphs with up to 10^5 vertices and edges.","solution":"from typing import List, Tuple def is_reachable(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: # Create adjacency list adj_list = {i: [] for i in range(vertex_count)} for u, v in edges: adj_list[u].append(v) def dfs(current, destination, visited): if current == destination: return True visited.add(current) for neighbor in adj_list[current]: if neighbor not in visited: if dfs(neighbor, destination, visited): return True return False return dfs(source, target, set())"},{"question":"Coding Assessment Question **Context**: Matrix operations are fundamental in various fields such as computer graphics, machine learning, and scientific computation. Your task is to implement a function that multiplies two matrices. # Task Write a function named `matrix_multiply` which takes two parameters `matrix1` and `matrix2`. Both parameters are lists of lists of integers representing two-dimensional matrices. Your function should return a new matrix which is the product of `matrix1` and `matrix2`. # Function Signature ```python def matrix_multiply(matrix1: list, matrix2: list) -> list: ``` # Input * `matrix1`: A list of lists of integers representing the multiplicand matrix. The number of columns can vary but each internal list (i.e., row) must have the same number of elements. * `matrix2`: A list of lists of integers representing the multiplier matrix. The number of rows can vary but each internal list (i.e., column) must have the same number of elements. # Output * Return a list of lists of integers representing the resultant matrix product. # Constraints * The number of columns in `matrix1` must be equal to the number of rows in `matrix2`. * The integer values in the matrices will range from -10^9 to 10^9. * Both `matrix1` and `matrix2` will have at least one row and one column. # Performance Requirements Ensure the function runs efficiently for matrix dimensions of size up to 50x50. # Example ```python matrix1 = [ [1, 2], [3, 4] ] matrix2 = [ [2, 0], [1, 2] ] result = matrix_multiply(matrix1, matrix2) print(result) # Output: [[4, 4], [10, 8]] ``` # Notes * Carefully handle edge cases where matrix dimensions do not align correctly and raise an appropriate exception. * Validate input matrices to ensure they conform to the expected format. * Think about the data structure and iteration approach to achieve optimal performance.","solution":"def matrix_multiply(matrix1: list, matrix2: list) -> list: Multiplies two matrices matrix1 and matrix2 and returns the resulting matrix. Assumes the number of columns in matrix1 equals the number of rows in matrix2. # Check the dimensions if len(matrix1[0]) != len(matrix2): raise ValueError(\\"Number of columns in matrix1 must be equal to number of rows in matrix2\\") # Dimensions of the resulting matrix rows_matrix1 = len(matrix1) cols_matrix2 = len(matrix2[0]) common_dim = len(matrix2) # Initialize the resulting matrix with zeros result = [[0 for _ in range(cols_matrix2)] for _ in range(rows_matrix1)] # Perform the multiplication for i in range(rows_matrix1): for j in range(cols_matrix2): for k in range(common_dim): result[i][j] += matrix1[i][k] * matrix2[k][j] return result"},{"question":"# Question: Number of Connected Components in Dynamic Graph Given that you are provided with a dynamic graph where edges are added over time, write a function to determine the number of connected components after each edge addition. Input: - An integer `n` representing the number of nodes, labeled from `0` to `n-1`. - A list of edges, where each edge is represented by a tuple `(u, v)` indicating an edge between nodes `u` and `v`. Output: - A list of integers representing the number of connected components after each edge addition. Constraints: - `1 <= n <= 1000` - `1 <= number of edges <= 2000` - Each edge addition is valid, i.e., no duplicate edge additions between the same nodes. Performance Requirements: - The algorithm should be efficient enough to handle the upper constraints in a reasonable time. Example: Input: ```python n = 5 edges = [(0, 1), (1, 2), (3, 4), (2, 3)] ``` Output: ```python [4, 3, 2, 1] ``` Explanation: - Initially, there are `5` nodes and `5` connected components. - After adding the edge `(0, 1)`, node `0` is connected to node `1`, resulting in `4` connected components. - After adding the edge `(1, 2)`, nodes `0`, `1`, `2` form a single connected component, thus reducing the number of connected components to `3`. - After adding the edge `(3, 4)`, nodes `3` and `4` form another connected component, reducing the number of connected components to `2`. - After adding the edge `(2, 3)`, all nodes are now connected, thus resulting in `1` connected component. Write the function `num_connected_components(n: int, edges: List[Tuple[int, int]]) -> List[int]` to solve the problem.","solution":"from typing import List, Tuple class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n self.components = n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) # Path compression return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 self.components -= 1 def num_connected_components(n: int, edges: List[Tuple[int, int]]) -> List[int]: uf = UnionFind(n) result = [] for u, v in edges: uf.union(u, v) result.append(uf.components) return result"},{"question":"# Context You have been given a singly linked list with potential duplicate elements. Your task is to implement two functions: one which removes duplicates using additional space to keep track of seen elements, and another which removes duplicates without using additional space. # Task Implement two functions: 1. `remove_dups(head: Node) -> None`: This function removes duplicates using additional memory for storage, ensuring O(N) time complexity. 2. `remove_dups_without_set(head: Node) -> None`: This function removes duplicates without using additional memory, ensuring O(1) space complexity. # Input - The head of a singly linked list. # Output - The head of the modified linked list with duplicates removed. # Constraints - You may assume that the linked list contains only strings as node values. - The linked list has at most 10^5 nodes. # Performance Requirements - The `remove_dups` function should run in O(N) time complexity. - The `remove_dups_without_set` function should run in O(N^2) time complexity. # Example The linked list is represented with arrows indicating the `next` reference: ``` A -> A -> B -> C -> D -> C -> F -> G ``` After calling `remove_dups`: ``` A -> B -> C -> D -> F -> G ``` The same output should be achieved by calling `remove_dups_without_set` on an identical initial list. # Note - You do not need to create the linked list or handle input/output. Focus on implementing the functions as specified.","solution":"class Node: def __init__(self, val=None, next=None): self.val = val self.next = next def remove_dups(head: Node) -> None: current = head seen = set() prev = None while current: if current.val in seen: prev.next = current.next else: seen.add(current.val) prev = current current = current.next def remove_dups_without_set(head: Node) -> None: current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# Scenario You are an event organizer responsible for scheduling a series of workshops. Each workshop is characterized by a start and an end time. Your priority is to ensure that none of the workshops overlap, as this would prevent attendees from participating in all sessions. # Problem Statement Write a function `can_attend_all_workshops` that determines if it is possible for a person to attend all the workshops given a list of start and end times. # Function Signature ```python def can_attend_all_workshops(workshops: List[List[int]]) -> bool: :param workshops: a list of [start, end] pairs for each workshop (0 <= start < end <= 10^6). :rtype: bool :returns: True if a person can attend all workshops without any overlaps, otherwise False. ``` # Input * `workshops`: List of lists, where each inner list contains two integers `[start, end]` representing start and end time of a workshop. - Example: `[[0, 30], [5, 10], [15, 20]]` # Output * Returns `True` if a person can attend all workshops without any overlaps. * Returns `False` if there is at least one overlapping workshop. # Constraints * The length of `workshops` does not exceed ( 10^4 ). * The integer values in `workshops` are in the range [0, 10^6]. # Performance Requirements * The solution is expected to work efficiently for up to ( 10^4 ) workshops. # Example Example 1 ```python Input: [[0, 30], [5, 10], [15, 20]] Output: False Explanation: The intervals [0, 30] and [5, 10] overlap. ``` Example 2 ```python Input: [[7, 10], [2, 4]] Output: True Explanation: No intervals overlap. ``` # Additional Scenarios 1. If there are no workshops (`workshops` is an empty list), return `True`. 2. Handle edge cases where some workshops finish exactly when the next one starts, ensuring that they are not considered as overlapping.","solution":"from typing import List def can_attend_all_workshops(workshops: List[List[int]]) -> bool: Determines if it\'s possible to attend all workshops without any overlaps. :param workshops: a list of [start, end] pairs for each workshop (0 <= start < end <= 10^6). :rtype: bool :returns: True if a person can attend all workshops without any overlaps, otherwise False. if not workshops: return True # Sort workshops by their start time workshops.sort(key=lambda x: x[0]) # Traverse the sorted workshops to check for overlaps for i in range(1, len(workshops)): # Compare end time of previous workshop with start time of current workshop if workshops[i-1][1] > workshops[i][0]: return False return True"},{"question":"# Decode String You are given an encoded string containing several nested and repeated patterns in the format `k[encoded_string]`, where the encoding rule is that the `encoded_string` inside the square brackets is repeated exactly `k` times. Write a function `decode_string` to decode the string and return its decoded form. Function Signature: ```python def decode_string(s: str) -> str: pass ``` Input: * A single string `s` containing the encoded pattern. It is guaranteed that the input string is always valid and well-formed with no extra white spaces. Output: * A single string containing the decoded version of the input string. Constraints: * `1 <= len(s) <= 30,000` * `1 <= k <= 1000` * The string does not contain any digits except for the repeat numbers `k`. Examples: 1. **Input**: \\"3[a]2[bc]\\" **Output**: \\"aaabcbc\\" 2. **Input**: \\"3[a2[c]]\\" **Output**: \\"accaccacc\\" 3. **Input**: \\"2[abc]3[cd]ef\\" **Output**: \\"abcabccdcdcdef\\" Explanation: * In the first example, \\"3[a]\\" means \\"aaa\\" and \\"2[bc]\\" means \\"bcbc\\", hence resulting in \\"aaabcbc\\". * In the second example, \\"a2[c]\\" means \\"acc\\", and repeating this 3 times gives \\"accaccacc\\". * In the third example, \\"2[abc]\\" is \\"abcabc\\" and \\"3[cd]\\" is \\"cdcdcd\\", resulting in \\"abcabccdcdcdef\\". Write an efficient and clear implementation that correctly decodes the given string based on the described rules.","solution":"def decode_string(s: str) -> str: stack = [] current_num = 0 current_string = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \\"\\" current_num = 0 elif char == \']\': last_string, num = stack.pop() current_string = last_string + num * current_string else: current_string += char return current_string"},{"question":"# Trimmed Mean Calculation Problem Statement Given a list of numerical values and a percentage `p`, implement the function `trimmean(arr, p)` that computes the trimmed mean of the list. The trimmed mean is the mean of the remaining list after removing the top `p/2`% largest and `p/2`% smallest values. Function Signature ```python def trimmean(arr: list[float], p: float) -> float: pass ``` Input - `arr`: A list of floating-point numbers, size `n` (0 ≤ n ≤ 10^5). - `p`: A floating-point value representing the total percentage of elements to trim, where 0 ≤ `p` < 100. Output - Returns a floating-point number representing the trimmed mean of the list. Constraints 1. The list `arr` may contain duplicate values. 2. The list may be empty, for which the function should return `0.0`. 3. Handle floating-point arithmetic appropriately to avoid floating-point precision issues. Examples ```python assert trimmean([6, 2, 3, 8, 7, 5, 1, 9], 20) == 5.5 assert trimmean([1, 2, 3, 4, 5, 6, 7, 8], 25) == 4.5 assert trimmean([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 10) == 55.0 assert trimmean([], 20) == 0.0 assert trimmean([1], 0) == 1.0 ``` Additional Notes - Avoid manual sorting if possible and explore efficient sorting techniques or utilize built-in sorting functions to ensure optimal performance. - Consider edge cases such as when the input list is already very small or when `p` is 0 or close to 100.","solution":"def trimmean(arr, p): Computes the trimmed mean of the list after removing the top p/2% largest and p/2% smallest values. Parameters: arr (list of floats): The list of numerical values. p (float): Percentage of elements to trim. Returns: float: The trimmed mean of the list. if not arr: return 0.0 n = len(arr) trim_count = int(n * p / 100 / 2) sorted_arr = sorted(arr) trimmed_arr = sorted_arr[trim_count: n - trim_count] if not trimmed_arr: return 0.0 return sum(trimmed_arr) / len(trimmed_arr)"},{"question":"**Edit Distance Calculation** Given two words `A` and `B`, write a function to find the minimum number of operations required to transform word `A` into word `B`. The allowed operations are: 1. Insertion of a character. 2. Deletion of a character. 3. Substitution of one character for another. # Function Signature ```python def edit_distance(word_a: str, word_b: str) -> int: ``` # Input * `word_a` (string): The first string (1 ≤ len(word_a) ≤ 500). * `word_b` (string): The second string (1 ≤ len(word_b) ≤ 500). # Output * Return an integer representing the minimum number of operations. # Example ```python edit_distance(\\"food\\", \\"money\\") # returns 4 edit_distance(\\"intention\\", \\"execution\\") # returns 5 ``` # Constraints: * You must use dynamic programming to solve the problem. * Aim for an efficient solution in terms of time and space. # Explanation For example, to transform the word “intention” to “execution”, the following steps could be taken: 1. Replace \'i\' with \'e\': in**t**ention → ex**t**ention (cost = 1) 2. Replace \'n\' with \'x\': ext**e**ntion → exc**e**ntion (cost = 2) 3. Replace \'t\' with \'c\': exce**n**tion → exec**n**tion (cost = 3) 4. Replace \'i\' with \'u\': execu**tion** → exec**tio**n (cost = 4) 5. Insert \'n\': execuuu**** → execut**ion** (cost = 5) # Additional Requirements - You should handle edge cases where either of the strings is empty. - Optimize space complexity where possible. - Ensure that your implementation has clear, readable code with comments that explain your logic.","solution":"def edit_distance(word_a: str, word_b: str) -> int: Computes the minimum number of operations required to transform word_a into word_b. Operations allowed: insertion, deletion, substitution. Args: word_a (str): The first string. word_b (str): The second string. Returns: int: The minimum number of operations required. # Get lengths of both words len_a, len_b = len(word_a), len(word_b) # Create a DP array to store the results of sub-problems dp = [[0] * (len_b + 1) for _ in range(len_a + 1)] # Initialize the base cases for i in range(1, len_a + 1): dp[i][0] = i # Minimum operations to convert word_a[0..i] to an empty string is i deletions for j in range(1, len_b + 1): dp[0][j] = j # Minimum operations to convert an empty string to word_b[0..j] is j insertions # Fill the DP table for i in range(1, len_a + 1): for j in range(1, len_b + 1): if word_a[i - 1] == word_b[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no new operation needed else: insert_op = dp[i][j - 1] + 1 # Insert character from word_b into word_a delete_op = dp[i - 1][j] + 1 # Delete character from word_a replace_op = dp[i - 1][j - 1] + 1 # Replace character from word_a with word_b dp[i][j] = min(insert_op, delete_op, replace_op) # Take the minimum of the three operations return dp[len_a][len_b]"},{"question":"# Bubble Sort Variant Implementation # Objective Implement a function that performs a variant of the Bubble Sort algorithm in Python to sort an input list in ascending order. However, you need to optimize it to handle several base cases effectively and ensure the code does not run unnecessary iterations. # Requirements 1. Implement a function `optimized_bubble_sort(arr: List[int]) -> List[int]` that sorts the list `arr` in ascending order. 2. Improve the algorithm to terminate early if the list becomes sorted before completing all passes. 3. Ensure the implementation correctly handles edge cases such as empty lists and already sorted lists. # Input * `arr`: A list of integers. The length of the list ( text{len(arr)} leq 10^5 ). # Output * A list of integers sorted in ascending order. # Constraints * You cannot use Python’s built-in sorting functions. * Your solution should work efficiently for various input sizes up to the specified constraint. # Example ```python # Example 1 input = [64, 34, 25, 12, 22, 11, 90] output = optimized_bubble_sort(input) print(output) # Output: [11, 12, 22, 25, 34, 64, 90] # Example 2 input = [5, 1, 4, 2, 8] output = optimized_bubble_sort(input) print(output) # Output: [1, 2, 4, 5, 8] # Example 3 input = [] output = optimized_bubble_sort(input) print(output) # Output: [] # Example 4 input = [1, 2, 3, 4, 5] output = optimized_bubble_sort(input) print(output) # Output: [1, 2, 3, 4, 5] ``` # Notes 1. The focus should be on optimizing the Bubble Sort algorithm for better average-case performance. 2. Ensure the function signature matches: ```python def optimized_bubble_sort(arr: List[int]) -> List[int]: ```","solution":"def optimized_bubble_sort(arr): Sorts a list of integers in ascending order using an optimized Bubble Sort algorithm. n = len(arr) for i in range(n): # Track if any swap was made in this pass swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True # If no elements were swapped, the list is already sorted if not swapped: break return arr"},{"question":"# Stack Implementation & Evaluation Objective You are required to implement a stack using either an array-based or a linked-list-based approach. Your implementation should follow the Stack ADT defined below. Details 1. Implement the `AbstractStack` class as described, either using an array-based or linked-list-based method (`ArrayStack` or `LinkedListStack`). 2. Your stack should support the following operations: - `push(item)`: Add an item to the top of the stack. - `pop()`: Remove and return the item from the top of the stack. - `peek()`: Return (but do not remove) the item at the top of the stack. - `is_empty()`: Return a boolean indicating if the stack is empty. Function Signatures Based on the given interface, your solution should have: - **Initialization**: - `__init__(self, size=10)` for `ArrayStack` - `__init__(self)` for `LinkedListStack` - **Operations**: - `push(self, value)` - `pop(self)` - `peek(self)` - `is_empty(self)` - **Utilities** (Already Defined): - `__len__(self)` - `__str__(self)` - `__iter__(self)` Input/Output Formats - **Initialization**: - `ArrayStack` can be initialized with an optional size argument that defines initial capacity. - **Operations will have the following effects**: - `push(item)`: Adds `item` to the stack. - `pop() -> item`: Returns and removes the topmost element of the stack. - `peek() -> item`: Returns the topmost element without removing it. - `is_empty() -> bool`: Returns `True` if the stack is empty, `False` otherwise. Constraints 1. The stack implementation must handle dynamic resizing for the array-based approach. 2. Ensure proper error handling: - `pop()` and `peek()` methods should raise an `IndexError` when the stack is empty. 3. You cannot use Python\'s built-in list methods like `append` and `pop`. # Example ``` # Initialize stack with size 3 stack = ArrayStack(3) # Add elements to stack stack.push(10) stack.push(20) stack.push(30) # Peek the topmost element (should return 30) print(stack.peek()) # Output: 30 # Pop the topmost element (should return 30 and remove it) print(stack.pop()) # Output: 30 # Check if stack is empty (should return False) print(stack.is_empty()) # Output: False # Print the current stack (should output representation of stack) print(stack) # Output: \'Top-> 20 10\' # Continue operations as needed # ... ``` Note: The example demonstrates the expected usage and output for the `ArrayStack`. Similar behavior should be observed for the `LinkedListStack`. Implement the stack and test your solution for correctness.","solution":"class ArrayStack: def __init__(self, size=10): self.size = size self.stack = [None] * self.size self.top = -1 def push(self, value): if self.top + 1 >= self.size: self._resize() self.top += 1 self.stack[self.top] = value def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") value = self.stack[self.top] self.stack[self.top] = None self.top -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[self.top] def is_empty(self): return self.top == -1 def _resize(self): new_size = self.size * 2 new_stack = [None] * new_size for i in range(self.size): new_stack[i] = self.stack[i] self.stack = new_stack self.size = new_size def __len__(self): return self.top + 1 def __str__(self): return \'Top-> \' + \' \'.join(str(self.stack[i]) for i in range(self.top, -1, -1)) def __iter__(self): for i in range(self.top, -1, -1): yield self.stack[i]"},{"question":"# Scenario You are working on a project that requires generating all possible permutations of a list of distinct numbers to test various combinations for a configuration problem. Since the list could be long, optimizing performance is also crucial. # Task Write a function `unique_permutations(nums)` that generates all unique permutations of a list of distinct integers. # Function Signature ```python def unique_permutations(nums: List[int]) -> List[List[int]]: pass ``` # Input - A list `nums` of distinct integers with 1 <= len(nums) <= 10. # Output - A list of lists, where each list is a unique permutation of `nums`. # Constraints - The function should handle input lists of up to 10 elements efficiently. - It should not use built-in functions explicitly designed for generating permutations. - Try to implement using both a recursive approach and an iterative (generator) approach for full understanding. # Example ```python assert unique_permutations([1, 2, 3]) == [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] assert unique_permutations([4, 5]) == [ [4, 5], [5, 4] ] assert unique_permutations([6]) == [ [6] ] ``` # Note Consider edge cases such as an empty list (return []), single-element list, and larger lists up to the given constraint.","solution":"from typing import List def unique_permutations(nums: List[int]) -> List[List[int]]: Returns all unique permutations of a list of distinct integers. def permute(nums): if len(nums) == 1: return [nums] permutations = [] for i in range(len(nums)): # Extract the current element current = nums[i] # Extract the remaining elements remaining = nums[:i] + nums[i+1:] # Recur for the remaining elements for p in permute(remaining): permutations.append([current] + p) return permutations # Call the recursive permutation function return permute(nums)"},{"question":"# FizzBuzz Enhancement Context: You are tasked with improving a simple yet classic algorithm known as FizzBuzz. The original FizzBuzz algorithm iterates over numbers from 1 to N, replacing multiples of 3 with \\"Fizz\\", multiples of 5 with \\"Buzz\\", and multiples of both 3 and 5 with \\"FizzBuzz\\". However, in this enhanced version, you will extend the functionality further: 1. Allow additional custom word mappings for multiples beyond just 3 and 5. 2. Enable a case insensitive manner for custom word mappings. 3. Include a toggle to return a dictionary mapping the integers to their respective FizzBuzz values. Task: Write a function `enhanced_fizzbuzz(n, mappings=None, return_dict=False)` with the following: - **Parameters**: - `n` (int): The upper limit of numbers (1 to N) to consider. Must be at least 1. - `mappings` (dict): A dictionary where keys are integers and values are strings to replace multiples of the key. Default is `{3: \\"Fizz\\", 5: \\"Buzz\\"}`. - `return_dict` (bool): If True, the function returns a dictionary mapping each integer to its FizzBuzz value. Otherwise, it returns a list. Default is False. - **Output**: A list or dictionary (determined by `return_dict`) with numbers from 1 to N replaced according to the mappings and rules outlined above. Constraints: - Input `n` must be a positive integer. - Keys of `mappings` must be positive integers. - Values of `mappings` must be non-empty strings. - Case insensitivity should be respected when checking for existing mappings. - Performance should be linear with respect to N. Example: ```python n = 15 mappings = {3: \\"Fizz\\", 5: \\"Buzz\\", 7: \\"Jazz\\"} return_dict = True enhanced_fizzbuzz(n, mappings, return_dict) ``` **Output**: ```python { 1: 1, 2: 2, 3: \\"Fizz\\", 4: 4, 5: \\"Buzz\\", 6: \\"Fizz\\", 7: \\"Jazz\\", 8: 8, 9: \\"Fizz\\", 10: \\"Buzz\\", 11: 11, 12: \\"Fizz\\", 13: 13, 14: \\"Jazz\\", 15: \\"FizzBuzz\\" } ``` **Hints**: 1. Consider using a helper function to handle the mapping and replacement logic. 2. Carefully handle edge cases such as erroneous input values.","solution":"def enhanced_fizzbuzz(n, mappings=None, return_dict=False): Generates the FizzBuzz values for a range from 1 to N with custom mappings. Arguments: n : int : The upper limit of numbers (1 to N) to consider. Must be at least 1. mappings : dict : A dictionary where keys are integers and values are strings to replace multiples of the key. Default is {3: \\"Fizz\\", 5: \\"Buzz\\"}. return_dict : bool : If True, the function returns a dictionary mapping each integer to its FizzBuzz value. Otherwise, it returns a list. Default is False. Returns: List or Dictionary : A list or dictionary with numbers from 1 to N replaced according to the mappings and rules. if not isinstance(n, int) or n < 1: raise ValueError(\\"The upper limit \'n\' must be an integer greater than or equal to 1.\\") if mappings is None: mappings = {3: \\"Fizz\\", 5: \\"Buzz\\"} final_mappings = {int(k): str(v) for k, v in mappings.items()} result = {} for i in range(1, n + 1): s = \'\' for k, v in final_mappings.items(): if i % k == 0: s += v result[i] = s if s else i return result if return_dict else list(result.values())"},{"question":"You are given a basic implementation of a Priority Queue using a linear array. The current implementation prioritizes for extraction based on the lowest priority value. Your task is to modify and enhance this implementation to include the following functions: 1. `update_priority(item, new_priority)`: Update the priority of an existing item. If the item does not exist, it should remain unchanged. 2. `peek()`: Return the item with the lowest priority without removing it from the queue. 3. `is_empty()`: Return `True` if the priority queue is empty, and `False` otherwise. # Input Format: Your methods will receive the following inputs: * `update_priority`: Takes in `item` and `new_priority`. * `peek`: No inputs. * `is_empty`: No inputs. # Output Format: Your methods will provide the following outputs: * `update_priority`: No return value. Updates the priority of the item if found. * `peek`: Return the item with the lowest priority. * `is_empty`: Boolean value indicating if the queue is empty. # Constraints: * The priority values will be integers. * The `push` and `pop` methods should maintain their original behavior and constraints. # Example: ```python pq = PriorityQueue(items=[4, 5, 6], priorities=[1, 3, 2]) pq.push(3, priority=0) print(pq) # PriorityQueue([3: 0, 4: 1, 6: 2, 5: 3]) pq.update_priority(6, new_priority=4) print(pq) # PriorityQueue([3: 0, 4: 1, 5: 3, 6: 4) print(pq.peek()) # 3 print(pq.is_empty()) # False pq.pop() print(pq) # PriorityQueue([4: 1, 5: 3, 6: 4]) ``` You must modify the `PriorityQueue` class to implement these functions.","solution":"class PriorityQueue: def __init__(self, items=None, priorities=None): if items is None: items = [] if priorities is None: priorities = [] self.queue = list(zip(items, priorities)) self.queue.sort(key=lambda x: x[1]) def push(self, item, priority): self.queue.append((item, priority)) self.queue.sort(key=lambda x: x[1]) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty PriorityQueue\\") return self.queue.pop(0)[0] def update_priority(self, item, new_priority): found = False for i in range(len(self.queue)): if self.queue[i][0] == item: self.queue[i] = (item, new_priority) found = True break if found: self.queue.sort(key=lambda x: x[1]) def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty PriorityQueue\\") return self.queue[0][0] def is_empty(self): return len(self.queue) == 0 def __repr__(self): return \\"PriorityQueue(\\" + \\", \\".join([f\\"{item}: {priority}\\" for item, priority in self.queue]) + \\")\\""},{"question":"**Scenario**: You are working on a text analyzer that compares text patterns with sentence structures. One feature involves verifying whether given sentences comply with specific patterns, which is essential for structured data extraction. **Objective**: Implement the function `word_pattern(pattern, sentence)` to verify if a given sentence follows a specific pattern. **Function Signature**: ```python def word_pattern(pattern: str, sentence: str) -> bool: ``` Input Specifications: 1. `pattern` (str): A string representing the desired pattern, only containing lowercase letters (\'a\' to \'z\'). Length constraints: `1 <= len(pattern) <= 100`. 2. `sentence` (str): A string representing the sentence, words are non-empty and separated by a single space. Each word consists of lowercase letters (\'a\' to \'z\'). Length constraints: `1 <= len(sentence) <= 300`. Output Specifications: - Return `True` if the sentence follows the same pattern; otherwise, return `False`. Constraints: - Each character in `pattern` maps to a word in `sentence`, and no two characters map to the same word and vice versa. - The number of words in the `sentence` must be equal to the number of characters in the `pattern`. Examples: - Example 1: ```python pattern = \\"abba\\" sentence = \\"dog cat cat dog\\" Output: True ``` - Example 2: ```python pattern = \\"abba\\" sentence = \\"dog cat cat fish\\" Output: False ``` - Example 3: ```python pattern = \\"aaaa\\" sentence = \\"dog cat cat dog\\" Output: False ``` - Example 4: ```python pattern = \\"abba\\" sentence = \\"dog dog dog dog\\" Output: False ``` Key Points: - Ensure the function handles edge cases, such as differing numbers of pattern characters and words. - Consider and handle the scenario where words repeat in the `sentence`. - Implement proper checking for word-to-character correspondence to maintain the bijection property. **Note**: Avoid using libraries or methods that over-complicate the solution or add unnecessary overhead. Focus on clarity and efficiency.","solution":"def word_pattern(pattern: str, sentence: str) -> bool: words = sentence.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: char_to_word[char] = word if word in word_to_char: if word_to_char[word] != char: return False else: word_to_char[word] = char return True"},{"question":"You are working on a large-scale data compression algorithm. Part of your task is to develop utility functions for manipulating specific bits within an integer value efficiently. Your assignment is to implement a class `BitManipulator` which includes methods for getting, setting, clearing, and updating bits at specified positions. Class Signature: ```python class BitManipulator: def __init__(self, num: int): pass def get_bit(self, i: int) -> int: pass def set_bit(self, i: int) -> None: pass def clear_bit(self, i: int) -> None: pass def update_bit(self, i: int, bit: int) -> None: pass def get_number(self) -> int: pass ``` # Method Detail: 1. **__init__(self, num: int)**: Initialize the class with the initial integer. 2. **get_bit(self, i: int) -> int**: Return the bit at position `i`. 3. **set_bit(self, i: int) -> None**: Set the bit at position `i` to 1. 4. **clear_bit(self, i: int) -> None**: Clear the bit at position `i` (set it to 0). 5. **update_bit(self, i: int, bit: int) -> None**: Update the bit at position `i` to the given `bit` (either 0 or 1). 6. **get_number(self) -> int**: Return the current integer value. # Example Usage ```python bm = BitManipulator(10) # Binary: 1010 print(bm.get_bit(1)) # Output: 1 bm.set_bit(0) print(bm.get_number()) # Output: 11 (Binary: 1011) bm.clear_bit(1) print(bm.get_number()) # Output: 9 (Binary: 1001) bm.update_bit(2, 1) print(bm.get_number()) # Output: 13 (Binary: 1101) ``` # Constraints - You may assume that integer inputs are non-negative (i.e., >=0) - bit position `i` will always be a non-negative integer within the range of typical integer size (e.g., within 0 to 31 for 32-bit integers). - `bit` argument in `update_bit` will always be either 0 or 1. Ensure you handle edge cases appropriately and consider both performance and clarity in your implementation.","solution":"class BitManipulator: def __init__(self, num: int): self.num = num def get_bit(self, i: int) -> int: Returns the bit at position i. return (self.num >> i) & 1 def set_bit(self, i: int) -> None: Sets the bit at position i to 1. self.num |= (1 << i) def clear_bit(self, i: int) -> None: Clears the bit at position i (sets it to 0). self.num &= ~(1 << i) def update_bit(self, i: int, bit: int) -> None: Updates the bit at position i to the given bit (either 0 or 1). # First clear the bit at position i, then set it to the new value if bit is 1 bit = (bit & 1) # Ensure bit is either 0 or 1 self.num = (self.num & ~(1 << i)) | (bit << i) def get_number(self) -> int: Returns the current integer value. return self.num"},{"question":"# Segment Tree Range Query You are provided with a `SegmentTree` class, which constructs a segment tree based on an input array and a provided function. This segment tree can then be used to perform range queries efficiently. Task You need to implement a new method in the `SegmentTree` class called `update` that allows updating an element at a specific index in the original array. Moreover, adjust the segment tree accordingly to reflect this update. # Method Signature ```python def update(self, index: int, value): Updates the element at specified index to the new value and adjusts the segment tree. :param index: The index of the element to update :param value: The new value to be placed at the specified index ``` # Input and Output 1. **Input**: * An instance of the `SegmentTree` initialized with an array and a function. * An integer `index` representing the position of the element to update. * A value of the same type as the elements in the array, representing the new value. 2. **Output**: * The `update` method should modify the tree structure and update internal nodes if necessary. # Constraints * `0 <= index < len(arr)` * The `value` will always be of the same type as elements of `arr`. # Example ```python # Initial Segment Tree mytree = SegmentTree([2, 4, 5, 3, 4], max) # Initial Queries print(mytree.query(2, 4)) # Output: 5 (max in range [2, 4]) print(mytree.query(0, 3)) # Output: 5 (max in range [0, 3]) # Update value at index 3 mytree.update(3, 7) # Post-Update Queries print(mytree.query(2, 4)) # Output: 7 (max in range [2, 4] is updated to 7) print(mytree.query(0, 3)) # Output: 7 (max in range [0, 3] after update) ``` # Notes * Ensure that your implementation is efficient and correctly maintains the segment tree properties after the update. * Consider edge cases where the index is at the boundaries of the array.","solution":"class SegmentTree: def __init__(self, arr, func): Initialize the Segment Tree with an array `arr` and a function `func` to be used for range queries. The length of the tree will be approximately 2 * 2^ceil(log2(len(arr))) - 1. self.n = len(arr) self.func = func self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr): # Initialize leaves in tree array for i in range(self.n): self.tree[self.n + i] = arr[i] # Initialize internal nodes in tree array for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[2 * i], self.tree[2 * i + 1]) def query(self, left, right): Query in the range [left, right] inclusive. left += self.n right += self.n res = None while left <= right: if left % 2 == 1: res = self.tree[left] if res is None else self.func(res, self.tree[left]) left += 1 if right % 2 == 0: res = self.tree[right] if res is None else self.func(res, self.tree[right]) right -= 1 left //= 2 right //= 2 return res def update(self, index, value): Update the element at specified index to the new value and adjusts the segment tree. # Set value at position index index += self.n self.tree[index] = value # Move upward and update parents while index > 1: index //= 2 self.tree[index] = self.func(self.tree[2 * index], self.tree[2 * index + 1]) # Example usage # mytree = SegmentTree([2, 4, 5, 3, 4], max) # print(mytree.query(2, 4)) # Output: 5 # mytree.update(3, 7) # print(mytree.query(2, 4)) # Output: 7"},{"question":"# Merging Intervals for Scheduled Events You are responsible for managing a schedule of events in a calendar application. Each event is represented as a time interval with a start and end time. Your job is to write a function `merge_scheduled_events` that takes a list of intervals and merges any overlapping intervals. # Function Signature ```python def merge_scheduled_events(events: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pass ``` # Input * `events`: A list of tuples (start, end) where `start` and `end` are integers representing the start and end times of an event. The list may contain between 1 and 10^4 intervals. The `start` will always be less than `end`. # Output * A list of merged intervals in the form of tuples (start, end). The intervals must be non-overlapping and sorted by their start times. # Constraints * The events are not sorted initially. * Events are considered overlapping if they share at least one moment in time. * The length of the output should be minimized — merge as many overlapping events as possible. # Example ```python # Example 1 events = [(1, 3), (2, 6), (8, 10), (15, 18)] assert merge_scheduled_events(events) == [(1, 6), (8, 10), (15, 18)] # Example 2 events = [(1, 4), (4, 5)] assert merge_scheduled_events(events) == [(1, 5)] ``` # Note * Ensure your implementation efficiently handles up to 10^4 intervals. * Consider edge cases such as having intervals that are already non-overlapping or having only one interval. # Evaluation Criteria * **Correctness**: The function should correctly merge overlapping intervals and return a sorted list of merged intervals. * **Performance**: The implemented solution should run efficiently within the given constraints. * **Edge Cases Handling**: Special and edge cases should be handled gracefully.","solution":"from typing import List, Tuple def merge_scheduled_events(events: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merges overlapping time intervals in a list of scheduled events. :param events: List of tuples containing the start and end times of events. :return: List of merged intervals sorted by their start times. if not events: return [] # Sort the events by their start time events.sort(key=lambda x: x[0]) merged = [] current_start, current_end = events[0] for start, end in events[1:]: if start <= current_end: current_end = max(current_end, end) else: merged.append((current_start, current_end)) current_start, current_end = start, end merged.append((current_start, current_end)) return merged"},{"question":"# Matrix Chain Multiplication Optimization Objective Write a function that determines the optimal order of matrix multiplications to minimize the total number of scalar multiplications required. Function Signature ```python def matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]: ``` Input 1. `array`: A list of integers where (array[i]) represents the dimension of matrix (Ai). Output - Return a tuple of two elements: 1. A 2D list `matrix` where `matrix[i][j]` contains the minimum number of scalar multiplications needed to multiply matrices from Ai to Aj. 2. A 2D list `sol` where `sol[i][j]` contains the index (k) that achieved the optimal cost of multiplying the chain from Ai to Aj. Constraints 1. The length of `array` will be at least 2 and at most 100. 2. All dimensions in `array` are positive integers and will fit within a 32-bit signed integer. Example ```python # Example usage: array = [30, 35, 15, 5, 10, 20, 25] matrix, solution = matrix_chain_order(array) print(matrix[1][len(array)-1]) # Expected Output: The minimum number of multiplications needed for the given matrix dimensions. print_optimal_solution(solution, 1, len(array)-1) # Expected Output: A human-readable string representing the order of matrix multiplications. ``` Note - The `print_optimal_solution` function should be implemented to display the optimal order of matrix multiplication based on the `solution` matrix. - Consider edge cases such as the smallest possible input size or matrices that cannot be multiplied due to dimension misalignment.","solution":"from typing import List, Tuple def matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]: n = len(array) # m[i][j] is the minimum number of scalar multiplications needed to compute the matrix A[i]A[i+1]...A[j] = A[i..j] m = [[0 for _ in range(n)] for _ in range(n)] # s[i][j] is the index that achieved the optimal cost in m[i][j] s = [[0 for _ in range(n)] for _ in range(n)] # l is chain length. for l in range(2, n): # length from 2 to n-1 for i in range(1, n-l+1): j = i+l-1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k+1][j] + array[i-1]*array[k]*array[j] if q < m[i][j]: m[i][j] = q s[i][j] = k return m, s def print_optimal_solution(s: List[List[int]], i: int, j: int) -> str: if i == j: return f\\"A{i}\\" else: return f\\"({print_optimal_solution(s, i, s[i][j])} x {print_optimal_solution(s, s[i][j]+1, j)})\\""},{"question":"# Combination Sum Problem with Dynamic Programming **Objective**: Implement a function to find the number of combinations of elements from a given list that sum up to a target value using dynamic programming. **Context**: You are designing a software module that needs to calculate the number of ways to generate a specific total using elements from a given array. This is commonly applicable in financial modeling, game scoring systems, or combinatorial problems. # Task Write a function `combination_sum(nums, target)` that takes in a list of positive integers `nums` and an integer `target`, and returns the number of possible combinations that add up to the target. Each number in `nums` may be used as many times as needed. Input: - `nums`: List of unique positive integers. - `target`: A positive integer representing the combination sum target. Output: - An integer representing the number of possible combinations that sum up to the target value. Constraints: - All integers in `nums` are positive. - There are no duplicate numbers in `nums`. - Different sequences of the same combination are considered distinct. Example: ```plaintext nums = [1, 2, 3] target = 4 The possible combination ways are: (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) Therefore the output should be: 7 ``` # Follow-up Questions: 1. What changes if negative numbers are allowed in the given array? 2. How would you modify the function to handle negative numbers while preventing infinite combinations? # Function Signature ```python def combination_sum(nums: List[int], target: int) -> int: ``` **Note**: Please ensure that your solution uses dynamic programming and explain the chosen approach in your comments.","solution":"def combination_sum(nums, target): Returns the number of possible combinations that sum up to the target value using elements from the given list. Each element can be used multiple times. # Create a list to store the number of combinations for every value up to the target dp = [0] * (target + 1) # Base case: One way to sum to zero (using no elements) dp[0] = 1 # Iterate over each value from 1 to target for i in range(1, target + 1): # Check with each number in nums for num in nums: if i - num >= 0: dp[i] += dp[i - num] # The result is the number of combinations to form the target return dp[target]"},{"question":"# **Run-Length Encoding and Decoding** Problem Description: Run-Length Encoding (RLE) is a form of lossless data compression in which runs of data (sequences in which the same data value occurs in many consecutive elements) are stored as a single data value and count. This is useful for data that contains many such runs. For example, in simple graphic images such as icons, line drawings, and animations. You are required to implement two functions, `encode_rle` and `decode_rle`, to compress and decompress a given string using Run-Length Encoding. # Task: 1. **Encode Function**: Compress the input string using Run-Length Encoding. 2. **Decode Function**: Decompress the encoded string back to its original form. # Input & Output Formats: **Encoding**: - **Input**: A string containing the data to be encoded. (e.g., \\"AAAABBBCCDAA\\") - **Output**: A string representing the encoded data. (e.g., \\"4A3B2C1D2A\\") **Decoding**: - **Input**: A string containing the encoded data. (e.g., \\"4A3B2C1D2A\\") - **Output**: A string representing the original data. (e.g., \\"AAAABBBCCDAA\\") # Constraints: 1. The input string for encoding will consist only of uppercase English letters and will have a length between 0 and 1000. 2. The encoded string for decoding will follow the pattern resulting from Run-Length Encoding and will have a length where the count of characters falls within the range of 1 to 1000. # Implementation: Complete the given functions `encode_rle` and `decode_rle` as defined below: ```python def encode_rle(input): Gets a stream of data and compresses it under a Run-Length Encoding. :param input: The data to be encoded. :return: The encoded string. pass def decode_rle(input): Gets a stream of data and decompresses it under a Run-Length Decoding. :param input: The data to be decoded. :return: The decoded string. pass ``` # Example: ```python # Example 1: # Encoding data = \\"AAABBBCC\\" encoded = encode_rle(data) print(encoded) # Output: 3A3B2C # Decoding encoded_data = \\"3A3B2C\\" decoded = decode_rle(encoded_data) print(decoded) # Output: AAABBBCC ```","solution":"def encode_rle(input): Gets a stream of data and compresses it under a Run-Length Encoding. :param input: The data to be encoded. :return: The encoded string. if not input: return \\"\\" result = [] count = 1 prev_char = input[0] for char in input[1:]: if char == prev_char: count += 1 else: result.append(f\\"{count}{prev_char}\\") count = 1 prev_char = char result.append(f\\"{count}{prev_char}\\") return \'\'.join(result) def decode_rle(input): Gets a stream of data and decompresses it under a Run-Length Decoding. :param input: The data to be decoded. :return: The decoded string. result = [] count = \\"\\" for char in input: if char.isdigit(): count += char else: result.append(char * int(count)) count = \\"\\" return \'\'.join(result)"},{"question":"**Problem Statement:** You are working on a simulation that involves the frequent calculation of powers of transition matrices. To improve performance, you need to implement matrix exponentiation using repeated squaring. **Task**: Implement a function `matrix_power(matrix: list, exponent: int) -> list` that computes the power of a square matrix to a given exponent using repeated squaring. **Input Format**: - `matrix`: A list of lists where each inner list represents a row of the square matrix. The matrix will always be non-empty and square. - `exponent`: A non-negative integer representing the power to which the matrix should be raised. **Output Format**: - Return the resulting matrix after raising the input matrix to the specified exponent. **Function Signature**: ```python def matrix_power(matrix: list, exponent: int) -> list: pass ``` **Constraints**: - The maximum dimension of the matrix is (100 times 100). - The elements of the matrix are integers and can be both positive and negative. - The exponent will be a non-negative integer and can be as large as (10^9). **Example**: ```python matrix = [[2, 0], [0, 2]] exponent = 3 print(matrix_power(matrix, exponent)) # Output: # [[8, 0], # [0, 8]] matrix = [[1, 2], [3, 4]] exponent = 2 print(matrix_power(matrix, exponent)) # Output: # [[ 7, 10], # [15, 22]] ``` **Explanation**: In the first example, the matrix ([ [2, 0], [0, 2] ])^3)) results in ([ [8, 0], [0, 8] ]). In the second example, the matrix ([ [1, 2], [3, 4] ])^2) results in ([ [7, 10], [15, 22] ]).","solution":"def matrix_power(matrix: list, exponent: int) -> list: Raises a matrix to the given exponent using repeated squaring. Args: matrix (list of list of ints): A square matrix. exponent (int): The exponent to which the matrix is raised. Returns: list of list of ints: The resulting matrix after exponentiation. def matrix_multiply(A, B): n = len(A) # Initialize the result matrix with zeros result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): for k in range(n): result[i][j] += A[i][k] * B[k][j] return result def matrix_identity(n): # Generate an identity matrix of size n x n return [[1 if i == j else 0 for j in range(n)] for i in range(n)] n = len(matrix) result = matrix_identity(n) base = matrix while exponent > 0: if exponent % 2 == 1: result = matrix_multiply(result, base) base = matrix_multiply(base, base) exponent //= 2 return result"},{"question":"**Problem Statement: Frequent Element Limiting** Given a list `lst` of integers and an integer `N`, your task is to create a function that constructs a new list where no element appears more than `N` times. The order of elements in the resulting list must be the same as in the original list. # Function Signature ```python def limit_frequencies(lst: List[int], N: int) -> List[int]: ``` # Input 1. `lst` (list of integers): The input list of integers. 2. `N` (integer): The maximum number of times an element can appear in the new list. # Output Returns a list where each element from the original list appears no more than `N` times. # Constraints * 0 ≤ len(lst) ≤ 10^5 * -10^6 ≤ lst[i] ≤ 10^6 * 0 ≤ N ≤ 10^5 # Example ```python assert limit_frequencies([1, 2, 3, 1, 2, 1, 2, 3], 2) == [1, 2, 3, 1, 2, 3] assert limit_frequencies([1, 2, 3, 1, 2, 1, 2, 3], 0) == [] assert limit_frequencies([], 3) == [] assert limit_frequencies([1, 2, 3], 3) == [1, 2, 3] ``` # Explanation 1. In the first example, elements `[1, 2, 3, 1, 2, 3]` appear with the maximum limit of 2 times each. 2. In the second example, since `N` is 0, no element can appear. 3. In the third example, the input list is empty so the result will also be empty. 4. In the fourth example, element limits are not reached so the result is the same as input. # Notes * Ensure efficient implementations preferably with O(n) time complexity. * Consider edge cases and optimize the performance of your solution.","solution":"def limit_frequencies(lst, N): Returns a list where no element appears more than N times. if N == 0: return [] count = {} result = [] for num in lst: if count.get(num, 0) < N: result.append(num) count[num] = count.get(num, 0) + 1 return result"},{"question":"# Insertion Sort Implementation and Optimization Background You are tasked with improving a basic sorting algorithm for an interactive application where users can visualize the sorting process. The application is mainly used for educational purposes to demonstrate how different sorting algorithms work. One of the algorithms to be visualized is the Insertion Sort. Task 1. Implement the Insertion Sort algorithm as a function in Python. 2. Optimize the function to use a binary search for finding the insertion point and compare it against the basic implementation. 3. Provide two modes for the function: * Normal sorting mode. * Simulation mode, which prints the state of the list after each outer loop iteration. Function Definition Implement the function `insertion_sort` with the following signature: ```python def insertion_sort(arr, simulation=False, optimized=False): Sorts a list of elements using Insertion Sort algorithm. Parameters: arr (list): The input list of elements to be sorted. simulation (bool): If True, prints the state of the list after each iteration. optimized (bool): If True, uses binary search to find the insertion point. Returns: list: The sorted list of elements. ``` Requirements 1. **Input**: * `arr`: A list of comparable elements (integers, floats, strings, etc.). * `simulation`: A boolean to trigger the printing of the sorting process. * `optimized`: A boolean to enable the optimized version using binary search. 2. **Output**: * A list of elements sorted in ascending order. 3. **Constraints**: * The algorithm should maintain stability and sort in-place. * Handle edge cases like an empty list or a list with a single element. Bonus * Analyze the performance difference between the basic and optimized versions by measuring the runtime on different datasets (e.g., nearly sorted, randomly sorted, and reverse sorted lists). Example ```python # Basic Usage print(insertion_sort([5, 2, 9, 1, 5, 6])) # Output: [1, 2, 5, 5, 6, 9] # Simulation Mode insertion_sort([5, 2, 9, 1, 5, 6], simulation=True) # Output: # iteration 0 : 5 2 9 1 5 6 # iteration 1 : 2 5 9 1 5 6 # iteration 2 : 2 5 9 1 5 6 # iteration 3 : 2 5 1 9 5 6 # iteration 4 : 2 5 1 5 9 6 # iteration 5 : 2 5 1 5 6 9 # Optimized Mode print(insertion_sort([5, 2, 9, 1, 5, 6], optimized=True)) # Output: [1, 2, 5, 5, 6, 9] ``` Notes * No external libraries should be used for sorting. * Ensure the code runs efficiently for the given constraints.","solution":"def insertion_sort(arr, simulation=False, optimized=False): Sorts a list of elements using Insertion Sort algorithm. Parameters: arr (list): The input list of elements to be sorted. simulation (bool): If True, prints the state of the list after each iteration. optimized (bool): If True, uses binary search to find the insertion point. Returns: list: The sorted list of elements. def binary_search(subarray, target): Helper function to perform binary search on the subarray. low, high = 0, len(subarray) - 1 while low <= high: mid = (low + high) // 2 if subarray[mid] == target: return mid elif subarray[mid] < target: low = mid + 1 else: high = mid - 1 return low n = len(arr) for i in range(1, n): key = arr[i] if optimized: # Use binary search to find the correct position to insert key. pos = binary_search(arr[:i], key) # Shift elements right to make space for key. arr = arr[:pos] + [key] + arr[pos:i] + arr[i + 1 :] else: j = i - 1 # Move elements of arr[0..i-1], that are greater than key, # to one position ahead of their current position. while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") return arr"},{"question":"# Question Given an encoded message containing digits, each letter from \'A\' to \'Z\' is mapped to a number from \'1\' to \'26\' (e.g., \'A\' -> \'1\', \'B\' -> \'2\', ..., \'Z\' -> \'26\'). Write a function that determines the total number of ways to decode this message. Requirements: 1. Implement the function `decode_ways(enc_mes: str) -> int` 2. The function should return the number of ways to decode the input message. # Input - `enc_mes` (a string representing the encoded message, containing digits only). # Output - An integer representing the total number of ways to decode the message. # Constraints - The string is non-empty and contains only digits (0-9). - Leading 0s are not considered as valid encodings (e.g., \\"012\\" is invalid). # Performance Requirements - The implementation should be efficient, aiming for O(n) time complexity and O(1) additional space complexity. # Example ```python print(decode_ways(\\"12\\")) # Output: 2 (AB or L) print(decode_ways(\\"226\\")) # Output: 3 (BZ, VF, BBF) print(decode_ways(\\"0\\")) # Output: 0 (invalid encoding) print(decode_ways(\\"10\\")) # Output: 1 (J) ``` # Edge Cases to Consider - Input like \\"0\\" should return 0 because \'0\' is not a valid encoding. - Inputs with multiple \'0\'s in invalid positions like \\"100\\" should return 0. - Inputs using all possible valid digit combinations should efficiently return the correct count.","solution":"def decode_ways(enc_mes: str) -> int: This function calculates the number of ways to decode a given encoded message containing digits, where each letter is mapped to a number from \'1\' to \'26\'. :param enc_mes: A string of digits representing the encoded message. :return: Total number of ways to decode the message. if not enc_mes or enc_mes[0] == \'0\': return 0 n = len(enc_mes) prev = 1 current = 1 for i in range(1, n): temp = current if enc_mes[i] == \'0\': if enc_mes[i-1] in (\'1\', \'2\'): current = prev else: return 0 elif enc_mes[i-1] == \'1\' or (enc_mes[i-1] == \'2\' and enc_mes[i] <= \'6\'): current += prev prev = temp return current"},{"question":"**Context**: For this task, you are required to implement a sorting algorithm that efficiently sorts a list of integers given specific constraints. **Problem Statement**: Implement the `pigeonhole_sort` function which sorts an array of integers. The function will receive an array and must return the sorted array. Ensure that your implementation is efficient and handles possible edge cases effectively. Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: pass ``` Input Format - A list `arr` of integers, where `1 <= len(arr) <= 10^5`. - Each integer in the list will be in the range `-10^3 <= arr[i] <= 10^3`. Output Format - A sorted list `arr`. Constraints - The implementation should have O(n + Range) time complexity, where `Range` is the difference between the maximum and minimum values in the list. - Minimize the use of extra space as much as possible. Example ```python # Example 1 arr = [8, 3, 2, 7, 4, 6, 8] print(pigeonhole_sort(arr)) # Output: [2, 3, 4, 6, 7, 8, 8] # Example 2 arr = [1, 0, -3, 2, -1, 3, -2] print(pigeonhole_sort(arr)) # Output: [-3, -2, -1, 0, 1, 2, 3] ``` Notes - Consider handling cases with duplicate values efficiently. - Account for the possibility of negative integers in the input list. Tips - Ensure to test your code with edge cases like all elements being the same, arrays with max and min values close to input size, and arrays containing negative integers.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: if not arr: return [] min_val = min(arr) max_val = max(arr) range_size = max_val - min_val + 1 pigeonholes = [0] * range_size for number in arr: pigeonholes[number - min_val] += 1 index = 0 for i in range(range_size): while pigeonholes[i] > 0: arr[index] = i + min_val index += 1 pigeonholes[i] -= 1 return arr"},{"question":"# Question: Implement an Enhanced Merge Sort Given an array of integers, implement an optimized version of the Merge Sort algorithm. The algorithm should: 1. Use a threshold to switch to Insertion Sort for small subarrays. 2. Be stable. 3. Be efficient in both time and space. # Function Signature ```python def optimized_merge_sort(arr: List[int], threshold: int) -> List[int]: Sorts an array using an optimized merge sort approach that switches to insertion sort for small subarrays. Parameters: arr (List[int]): The array of integers to sort. threshold (int): The threshold under which to use insertion sort. Returns: List[int]: The sorted array. pass ``` # Constraints - 1 <= len(arr) <= 10^5 (Typical large input size for stress testing) - -10^9 <= arr[i] <= 10^9 (Diverse range of integer values) # Example - Input: `arr = [34, 7, 23, 32, 5, 62, 32], threshold = 4` - Output: `[5, 7, 23, 32, 32, 34, 62]` # Requirements - You are expected to properly divide the array, identify when to switch to insertion sort, and merge the sorted subarrays efficiently. - Ensure your code handles typical edge cases, such as empty arrays or arrays with one element. - The solution should retain the stability of the sorting method. - Avoid unnecessary uses of extra space beyond what is required for the merge process. **Note**: The provided function signature, examples, and constraints should be followed precisely.","solution":"from typing import List def insertion_sort(arr: List[int], left: int, right: int) -> None: for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def merge(arr: List[int], left: int, mid: int, right: int) -> None: n1 = mid - left + 1 n2 = right - mid left_sub = arr[left:mid + 1] right_sub = arr[mid + 1:right + 1] i = j = 0 k = left while i < n1 and j < n2: if left_sub[i] <= right_sub[j]: arr[k] = left_sub[i] i += 1 else: arr[k] = right_sub[j] j += 1 k += 1 while i < n1: arr[k] = left_sub[i] i += 1 k += 1 while j < n2: arr[k] = right_sub[j] j += 1 k += 1 def optimized_merge_sort(arr: List[int], threshold: int) -> List[int]: def merge_sort_rec(arr: List[int], left: int, right: int) -> None: if left < right: if right - left + 1 <= threshold: insertion_sort(arr, left, right) else: mid = (left + right) // 2 merge_sort_rec(arr, left, mid) merge_sort_rec(arr, mid + 1, right) merge(arr, left, mid, right) merge_sort_rec(arr, 0, len(arr) - 1) return arr"},{"question":"You have been provided with an implementation of a directed graph. The task involves extending this implementation with new functionalities. Specifically, you need to write a method that detects the presence of cycles in the directed graph. # Implementation Function ```python def has_cycle(directed_graph: DirectedGraph) -> bool: This function should detect if there\'s a cycle in the directed graph. Parameters: directed_graph (DirectedGraph): The directed graph instance. Returns: bool: True if the graph contains one or more cycles, False otherwise. pass ``` # Input and Output * **Input**: An instance of `DirectedGraph`, which can have any number of nodes and directed edges. * **Output**: A boolean value, `True` if the graph contains any cycle, `False` otherwise. # Constraints * You can assume the graph has at least one node. * Nodes are uniquely named strings. # Example Consider the following usage of the graph implementation: ```python graph_data = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'], # A cycle: A -> B -> C -> A \'D\': [\'E\'], \'E\': [] } g = DirectedGraph(graph_data) print(has_cycle(g)) # Expected Output: True graph_data = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [], \'D\': [\'E\'], \'E\': [] } g = DirectedGraph(graph_data) print(has_cycle(g)) # Expected Output: False ``` # Notes - The function you implement should be efficient and ideally work within O(V + E) time complexity where V is the number of nodes and E is the number of edges. - Consider using depth-first search (DFS) to detect cycles in the graph.","solution":"class DirectedGraph: def __init__(self, adjacency_list): self.adjacency_list = adjacency_list def has_cycle(directed_graph: DirectedGraph) -> bool: This function detects if there\'s a cycle in the directed graph using DFS. Parameters: directed_graph (DirectedGraph): The directed graph instance. Returns: bool: True if the graph contains one or more cycles, False otherwise. def dfs(node, visited, rec_stack): visited.add(node) rec_stack.add(node) for neighbor in directed_graph.adjacency_list.get(node, []): if neighbor not in visited: if dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True rec_stack.remove(node) return False visited = set() rec_stack = set() for node in directed_graph.adjacency_list: if node not in visited: if dfs(node, visited, rec_stack): return True return False"},{"question":"# Question You have been given a set of fundamental bit manipulation functions that allow specific bits in an integer to be retrieved, set, cleared, and updated. Your task is to implement a function called `bit_counter(num, bit_value)` that counts the number of bits set to `bit_value` (either 0 or 1) in the binary representation of a given integer `num`. Function Signature ```python def bit_counter(num: int, bit_value: int) -> int: ``` Input * `num` (int): An integer whose bits are to be analyzed. * `bit_value` (int): The bit value to count (either 0 or 1). Output * Return the count of bits in `num` that are equal to `bit_value`. Constraints * The value of `num` can be any 32-bit integer. * `bit_value` is guaranteed to be either 0 or 1. Examples ```python assert bit_counter(5, 1) == 2 # Binary: 0000000000000101 (two \'1\' bits) assert bit_counter(5, 0) == 30 # Binary: 0000000000000101 (thirty \'0\' bits) assert bit_counter(-1, 1) == 32 # Binary (2\'s complement of -1 for 32-bits): 11111111111111111111111111111111 (thirty-two \'1\' bits) assert bit_counter(0, 0) == 32 # Binary: 00000000000000000000000000000000 (thirty-two \'0\' bits) ``` Notes 1. Ensure that you handle both positive and negative integers correctly by considering their binary representation in two\'s complement form. 2. Explain any assumptions or additional considerations in your implementation. Hint Use the provided bit manipulation functions to achieve an efficient solution.","solution":"def bit_counter(num: int, bit_value: int) -> int: Counts the number of bits set to `bit_value` (either 0 or 1) in the binary representation of a given integer `num`. Parameters: - num: An integer whose bits are to be analyzed. - bit_value: The bit value to count (either 0 or 1). Returns: - The count of bits in `num` that are equal to `bit_value`. # Function implementation # Handle the special case for -num if num < 0: num = num & 0xFFFFFFFF bin_representation = f\\"{num:032b}\\" return bin_representation.count(str(bit_value))"},{"question":"You have to implement a function called `find_all_primes(n)` that generates a list of all prime numbers less than a given integer `n` using an optimized version of the Sieve of Eratosthenes algorithm. # Function Signature ```python def find_all_primes(n: int) -> List[int]: ``` # Input * An integer `n` where (2 leq n leq 10^6). # Output * A list of all prime numbers that are less than the integer `n`, ordered from smallest to largest. # Constraints * You should handle non-positive and non-integer inputs by raising a `ValueError` with the message `\\"\'n\' must be a positive integer.\\"` * The function should be optimized and should avoid checking even numbers. # Example ```python find_all_primes(10) # Output: [2, 3, 5, 7] find_all_primes(20) # Output: [2, 3, 5, 7, 11, 13, 17, 19] find_all_primes(1) # Output: raises ValueError(\\"\'n\' must be a positive integer.\\") find_all_primes(2) # Output: [] ``` # Scenario You are tasked with generating a list of prime numbers efficiently for a cryptographic application where generating primes frequently and quickly is crucial. The optimized algorithm implemented by avoiding even numbers will be a performance booster. Ensure correctness and handle edge cases gracefully.","solution":"from typing import List def find_all_primes(n: int) -> List[int]: Generate a list of all prime numbers less than a given integer n using the Sieve of Eratosthenes algorithm. Args: - n: int - An integer where 2 <= n <= 10^6. Returns: - List of prime numbers less than n. Raises: - ValueError: If n is not a positive integer. if not isinstance(n, int) or n <= 0: raise ValueError(\\"\'n\' must be a positive integer.\\") if n < 2: return [] # Sieve of Eratosthenes sieve = [True] * n sieve[0] = sieve[1] = False # We know 0 and 1 are not primes for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start * start, n, start): sieve[multiple] = False return [num for num in range(2, n) if sieve[num]]"},{"question":"# Binary Search Tree Deletion Operation Scenario You have been provided with a Binary Search Tree implementation that has methods for insertion, searching, calculating the size, and different types of traversals. Now, you need to extend its functionality by implementing a node deletion operation. Task Write a method `delete(self, data)` that removes a node with the specified value from the BST while maintaining the BST properties. Instructions: 1. **Function Name**: `delete` 2. **Input**: An integer `data` representing the value of the node to be deleted. 3. **Behavior**: - If the node to be deleted is a leaf node, simply remove it. - If the node to be deleted has only one child, replace the node with its child. - If the node to be deleted has two children, find the in-order successor (smallest element in the right subtree), replace the node\'s value with the successor\'s value, and then delete the successor. Detailed Steps: 1. Start from the root node and search for the node with the given value. 2. Depending on the node\'s number of children, apply one of the three deletion strategies (none, one, two children). 3. Ensure the BST properties are preserved after deletion. Constraints: - Assume that all values are unique. - The tree does not contain duplicate values. - The values are non-negative integers. Example: ```python bst = BST() bst.insert(20) bst.insert(10) bst.insert(30) bst.insert(5) bst.insert(15) bst.insert(25) bst.insert(35) bst.insert(1) bst.insert(7) # Initial tree # 20 # / # 10 30 # / / # 5 15 25 35 # / # 1 7 bst.delete(10) # After deleting node 10, with two children: # 20 # / # 15 30 # / / # 5 N 25 35 # / # 1 7 ```","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, data): if not self.root: self.root = TreeNode(data) else: self._insert(self.root, data) def _insert(self, node, data): if data < node.val: if node.left is None: node.left = TreeNode(data) else: self._insert(node.left, data) else: if node.right is None: node.right = TreeNode(data) else: self._insert(node.right, data) def delete(self, data): self.root = self._delete_node(self.root, data) def _delete_node(self, root, key): if root is None: return root if key < root.val: root.left = self._delete_node(root.left, key) elif key > root.val: root.right = self._delete_node(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left min_larger_node = self._get_min(root.right) root.val = min_larger_node.val root.right = self._delete_node(root.right, root.val) return root def _get_min(self, node): current = node while current.left is not None: current = current.left return current def inorder(self, node, values): if node: self.inorder(node.left, values) values.append(node.val) self.inorder(node.right, values) def get_inorder(self): values = [] self.inorder(self.root, values) return values"},{"question":"You are required to write a Python implementation of an extended version of the ZigZagIterator which can handle multiple input lists beyond just two. # Objective Create a class `ZigZagIteratorMultiple` that initializes with an arbitrary number of lists and iterates through them in a zigzag manner. The iterator should cycle through each list, picking elements one by one in sequence, and skip lists that are exhausted. # Function Signature ```python class ZigZagIteratorMultiple: def __init__(self, lists: List[List[int]]): # Initializes the iterator with any number of input lists. def next(self) -> int: # Returns the next element in the zigzag iteration. def has_next(self) -> bool: # Returns True if there are more elements to iterate over, False otherwise. ``` # Input Format * `lists` is a list of lists, where each sublist contains integers. Each sublist can have 0 or more elements. # Output Format * `next` should return the next integer from the lists in zigzag order. * `has_next` should return a boolean indicating if there are more elements to iterate through. # Example Given the following lists: ```python l1 = [1, 2] l2 = [3, 4, 5, 6] l3 = [7, 8, 9] it = ZigZagIteratorMultiple([l1, l2, l3]) while it.has_next(): print(it.next()) ``` The expected output should be: ``` 1 3 7 2 4 8 5 9 6 ``` # Constraints * The sublists can have different lengths, and some can be empty. * All integers fit within the standard 32-bit integer range. # Performance Requirements * The time complexity should be O(T) where T is the total number of elements in all lists. * The space complexity should be O(L) where L is the number of input lists.","solution":"from collections import deque class ZigZagIteratorMultiple: def __init__(self, lists): # Initialize the deque with indexes of the non-empty lists self.queue = deque([(lst, 0) for lst in lists if lst]) def next(self): # Get the next element in the zigzag order if self.has_next(): lst, idx = self.queue.popleft() value = lst[idx] if idx + 1 < len(lst): self.queue.append((lst, idx + 1)) return value raise Exception(\\"No more elements\\") def has_next(self): # Check if there are more elements to iterate return bool(self.queue)"},{"question":"Advanced Binary Search Tree Operations Context: You are working on an enhanced Binary Search Tree (BST) implementation that not only includes basic operations like insertion, search, size calculation, and various traversal methods, but also maintains certain extra functionalities ensuring the tree does not remain excessively unbalanced. Your task is to implement methods to check the height of the tree, find the minimum and maximum element, and ensure tree remains balanced upon insertions. Task: 1. **Implement the following methods in your BST class**: - `find_min`: Return the minimum element in the BST. - `find_max`: Return the maximum element in the BST. - `height`: Return the height of the BST. 2. **Function Specifications**: - `find_min()`: - **Inputs**: None - **Outputs**: Integer, or `None` if the tree is empty. - `find_max()`: - **Inputs**: None - **Outputs**: Integer, or `None` if the tree is empty. - `height()`: - **Inputs**: None - **Outputs**: Integer representing the height of the BST. Height of an empty tree is -1. 3. **Constraints**: - The BST should handle at least the first 1000 integers in random insertion order. - All methods should ideally run in O(h) time complexity, where h is the height of the tree. Method Signatures: ```python class BST: def find_min(self) -> int: pass def find_max(self) -> int: pass def height(self) -> int: pass ``` # Example Usages Consider the following operations based on the provided tree: ```python # Initializing the tree and inserting elements bst = BST() bst.insert(10) bst.insert(15) bst.insert(6) bst.insert(4) bst.insert(9) bst.insert(12) bst.insert(24) bst.insert(7) bst.insert(20) bst.insert(30) bst.insert(18) # Find minimum and maximum elements print(bst.find_min()) # Output: 4 print(bst.find_max()) # Output: 30 # Calculate height of the tree print(bst.height()) # Output: 4 ``` Implement your functions considering the structure and methods of the initially provided BST class.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if root is None: return Node(key) else: if root.val < key: root.right = self._insert(root.right, key) else: root.left = self._insert(root.left, key) return root def find_min(self): if self.root is None: return None current = self.root while current.left is not None: current = current.left return current.val def find_max(self): if self.root is None: return None current = self.root while current.right is not None: current = current.right return current.val def height(self): return self._height(self.root) def _height(self, node): if node is None: return -1 left_height = self._height(node.left) right_height = self._height(node.right) return max(left_height, right_height) + 1"},{"question":"# Question: You are given a set of items, each having a value and a weight, and a knapsack with a specified capacity. Your task is to write a function that returns the maximum summarized value of the items that can be fit in the knapsack without exceeding its capacity. Function Signature ```python def get_maximum_value(items: List[Tuple[int, int]], capacity: int) -> int: ``` Input: - `items`: A list of tuples, where each tuple consists of two integers `(value, weight)` representing the value and weight of the item respectively. - `capacity`: An integer representing the maximum weight capacity of the knapsack. Output: - An integer representing the maximum sum of values that can fit in the knapsack without exceeding the capacity. Constraints: - All item weights and the capacity are non-negative integers. - Values range of items and capacity are constrained within reasonable operational limits (e.g., less than 2000). Example: ```python items = [(60, 5), (50, 3), (70, 4), (30, 2)] capacity = 5 print(get_maximum_value(items, capacity)) # Output: 80 (items valued 50 and 30 can both be fit in the knapsack) ``` Detailed Requirements: 1. Implement a dynamic programming solution similar to the provided example. 2. Ensure the solution handles typical edge cases, such as zero capacity and items with weights exceeding the capacity. 3. Optimize the performance for larger inputs by ensuring the solution follows the discussed complexity constraints. Good luck!","solution":"from typing import List, Tuple def get_maximum_value(items: List[Tuple[int, int]], capacity: int) -> int: Return the maximum sum of values that can fit in the knapsack without exceeding the capacity. n = len(items) # Create a 2D DP array with (n+1)x(capacity+1) dimensions initialized to 0 dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] # Build the DP table for i in range(1, n + 1): value, weight = items[i-1] for w in range(capacity + 1): if weight <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + value) else: dp[i][w] = dp[i-1][w] return dp[n][capacity]"},{"question":"**Problem Statement**: You\'ve been assigned a task to help optimize a scheduling system. Two subsystems utilize timer interrupts that reset based on their respective counts. To achieve synchronization in their executions, you need to calculate the Least Common Multiple (LCM) of their interrupt counts. However, your solution must also handle scenarios where interrupt counts could be represented in binary form and may include trailing zeros. An incorrect count could lead to misalignment in synchronization, affecting the entire system’s performance. **Implement the `synchronize_interrupts(int a, int b)` function**: **Function Signature**: ```python def synchronize_interrupts(a: int, b: int) -> int: Returns the least common multiple of a and b, considering any trailing zeros in the binary forms of the inputs. ``` **Input Format**: - Two positive integers `a` (1 ≤ a ≤ 10^9) and `b` (1 ≤ b ≤ 10^9). **Output Format**: - Return a single integer, representing the LCM adjusted for any trailing zeros in the binary representations of `a` and `b`. **Constraints**: - Inputs `a` and `b` are guaranteed to be positive integers. **Examples**: Example 1: ```python assert synchronize_interrupts(8, 20) == 40 ``` Example 2: ```python assert synchronize_interrupts(4, 5) == 20 ``` **Explanation**: - You should first remove any trailing zeros by shifting until you encounter a \'1\' in each of the input numbers\' binary representation. - Proceed to compute the LCM of the adjusted numbers. - Adjust back the result by calculating the trailing zeros and shifting the result accordingly.","solution":"import math def remove_trailing_zeros(n): Removes trailing zeros from the binary representation of n. while n % 2 == 0: n //= 2 return n def synchronize_interrupts(a, b): Returns the least common multiple of a and b, considering any trailing zeros in the binary forms of the inputs. a_adjusted = remove_trailing_zeros(a) b_adjusted = remove_trailing_zeros(b) lcm_adjusted = (a_adjusted * b_adjusted) // math.gcd(a_adjusted, b_adjusted) trailing_zeros_a = (a & -a).bit_length() - 1 trailing_zeros_b = (b & -b).bit_length() - 1 max_trailing_zeros = max(trailing_zeros_a, trailing_zeros_b) return lcm_adjusted << max_trailing_zeros"},{"question":"You are given a specific value `value` in cents, and a list of coin denominations `coins`. Your task is to write a function that computes the number of different ways to make up that value using the coins provided. The order of the coins does not matter. # Function Signature ```python def count(coins: List[int], value: int) -> int: pass ``` # Input * `coins`: A list of integers representing the denominations of the coins. (`1 <= len(coins) <= 50`) * `value`: An integer representing the target value you need to make using the coins. (`0 <= value <= 1000`) # Output * Return the number of ways to make `value` using the provided coin denominations. # Example ```python assert count([1, 2, 3], 4) == 4 # => [1, 1, 1, 1], [1, 1, 2], [2, 2], [1, 3] assert count([2, 5, 3, 6], 10) == 5 # => [2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 2, 6], [2, 3, 5], [5, 5] ``` # Constraints and Considerations 1. The function should handle cases where it\'s impossible to make the exact change. 2. The function should work efficiently for the input limits. 3. Consider edge cases like `value = 0` or when `coins` is empty. # Additional Notes * Ensure that the solution handles varying coin denominations and small to moderately large `value` inputs efficiently. * The function should be robust against invalid inputs like negative values or non-integer inputs.","solution":"from typing import List def count(coins: List[int], value: int) -> int: Returns the number of ways to make up \'value\' using the denominations in \'coins\' # Initialize a list to store the number of ways to achieve each value from 0 to \'value\' dp = [0] * (value + 1) dp[0] = 1 # There is one way to make 0 value, which is using no coins # Update the dp array to account for each coin for coin in coins: for i in range(coin, value + 1): dp[i] += dp[i - coin] return dp[value]"},{"question":"You are given an array with `n` objects colored red, white, or blue, sorted so that objects of the same color are adjacent, with the colors in the order red, white, and blue. Here, we use the integers `0`, `1`, and `2` to represent the colors red, white, and blue respectively. Your task is to sort the array in-place without using any sorting functions from the library. The goal is to ensure: * All `0`s (red) come before `1`s (white). * All `1`s (white) come before `2`s (blue). * This needs to be done in one pass and using constant space (O(1) extra space). # Function Signature ```python def sort_colors(nums: List[int]) -> None: Modify nums in-place so that objects are sorted by color order with no extra space used. ``` # Input * `nums`: A list of integers where each integer is either `0`, `1`, or `2`. The length of `nums` is `n` (0 ≤ n ≤ 10^5). # Output * The function should modify the input list in-place, such that it is sorted in the order of `0`s, `1`s, and `2`s. # Constraints * The function should run in O(n) time complexity. * The function should use O(1) additional space. # Example ```python # Example 1 nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 2, 2] # Example 2 nums = [2, 0, 1] sort_colors(nums) print(nums) # Output: [0, 1, 2] ``` # Notes * You can use multiple pointers to manipulate the elements in the array. * Avoid unnecessary swaps to optimize in-place operations.","solution":"def sort_colors(nums): Modify nums in-place so that objects are sorted by color order with no extra space used. # Pointers for the three partitions low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: # Red nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: # White mid += 1 else: # Blue nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"Context You have been tasked with developing a new feature in a simulation game where players claim territories on a grid map. Each territory can be either land or water, and players can only claim land. The goal is to count the number of distinct territories after each claim operation. Problem Statement Write a function `num_islands(n, m, positions)` that counts the number of islands after each position is claimed. The function should simulate land claiming on an initially water-covered grid of size `n x m`. Islands are formed by connecting adjacent lands horizontally or vertically. # Input * An integer `n` (1 ≤ n ≤ 1000) - the number of rows in the grid. * An integer `m` (1 ≤ m ≤ 1000) - the number of columns in the grid. * A list `positions` containing tuples of integers (0 ≤ x < n, 0 ≤ y < m) - the positions being claimed sequentially as land. # Output * A list of integers representing the number of islands after each claim in `positions`. # Constraints * `positions`\' length will not exceed 100,000 * It is guaranteed that there are no duplicates in positions. # Example ```python def num_islands(n, m, positions): # Implement your solution here pass # Example test case print(num_islands(3, 3, [(0, 0), (0, 1), (1, 2), (2, 1)])) # Output should be [1, 1, 2, 3] ``` Edge Cases 1. Claiming land at a position already claimed (no effect, should maintain the count of islands). 2. Claims at the boundary positions. 3. Continuous claims forming a single large island reducing the count of islands.","solution":"def num_islands(n, m, positions): Returns a list of the number of islands after each position is claimed. # Helper function to find the root of a cell def find(parent, i): if parent[i] != i: parent[i] = find(parent, parent[i]) return parent[i] # Helper function to union two cells def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 # Direction vectors for moving up, down, left, right directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] parent = {} rank = {} count = 0 result = [] for (x, y) in positions: if (x, y) in parent: result.append(count) continue parent[(x, y)] = (x, y) rank[(x, y)] = 0 count += 1 for d in directions: nx, ny = x + d[0], y + d[1] if (nx, ny) in parent: if find(parent, (nx, ny)) != find(parent, (x, y)): union(parent, rank, (x, y), (nx, ny)) count -= 1 result.append(count) return result"},{"question":"Scenario Given an array where each element appears exactly three times except for one element which appears exactly once, develop an efficient algorithm to find the element that appears only once. Your solution should have linear runtime complexity and should not use extra memory. Task Write a Python function: ```python def find_unique_number(arr: List[int]) -> int: pass ``` Input * `arr` - An array of integers (List[int]) where: * Every integer appears exactly three times, except one integer that appears exactly once. * The array contains at least one integer and can have up to 10^6 integers. Output * Returns a single integer which is the one that appears only once in the array. Constraints * You can assume that: * The input array is non-empty. * There is exactly one such unique integer. Example Input: ```python find_unique_number([2, 2, 3, 2]) ``` Output: ```python 3 ``` Input: ```python find_unique_number([0, 1, 0, 1, 0, 1, 99]) ``` Output: ```python 99 ``` Performance Requirements * The expected time complexity is O(n). * The expected space complexity is O(1). Hints * Use bitwise operations to track the occurrences of each bit across all integers in the array. * Specifically, consider how the bits of a number can help determine the single occurrence number when taken modulo 3.","solution":"from typing import List def find_unique_number(arr: List[int]) -> int: # Initialize variables to store the state of bits ones, twos = 0, 0 for num in arr: # \\"twos\\" holds the bits which appear twice twos |= ones & num # \\"ones\\" holds the bits which appear once ones ^= num # \\"threes\\" holds the bits which appear three times threes = ones & twos # If a bit appears three times, clear that bit in ones and twos ones &= ~threes twos &= ~threes return ones"},{"question":"# Implement Your Own CircularQueue Scenario: You have been given an ArrayQueue and a LinkedListQueue implementation. Your task is to implement a `CircularQueue` class. A CircularQueue is a linear data structure that follows the FIFO principle but follows a circular manner. Requirements: 1. Use a fixed-size array to store the elements of the queue. 2. Implement the core queue operations: `enqueue`, `dequeue`, `peek`, `is_empty`, and `size`. Constraints: 1. Do not use Python\'s built-in list methods for dynamic behavior (e.g., `append`, `pop`). 2. You can assume the initial capacity is always greater than 0. 3. Ensure that your implementation handles wrap-around correctly and efficiently. Input and Output * Input: Capacity `k` (integer), Sequence of operations (`enqueue` and `dequeue` with respective values). * Output: Result from sequence of `peek` operations after performing the required operations. Example: ```python # Example input capacity = 5 operations = [(\\"enqueue\\", 10), (\\"enqueue\\", 20), (\\"enqueue\\", 30), (\\"dequeue\\", None), (\\"enqueue\\", 40), (\\"peek\\", None)] # Expected output [20] ``` Implementation: Define the `CircularQueue` class with the following methods: - `__init__(self, capacity)`: Initialize the queue with the given capacity. - `enqueue(self, value)`: Add a value to the rear of the queue. - `dequeue(self)`: Remove the front item from the queue and return it. - `peek(self)`: Return the front item without removing it. - `is_empty(self)`: Return whether the queue is empty. - `size(self)`: Return the number of elements in the queue. ```python class CircularQueue: def __init__(self, capacity): self._array = [None] * capacity self._front = 0 self._rear = 0 self._size = 0 self._capacity = capacity def __len__(self): return self._size def is_empty(self): return self._size == 0 def enqueue(self, value): if self._size == self._capacity: raise OverflowError(\\"Queue is full\\") self._array[self._rear] = value self._rear = (self._rear + 1) % self._capacity self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self._array[self._front] self._array[self._front] = None self._front = (self._front + 1) % self._capacity self._size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._array[self._front] def size(self): return self._size ``` Test your implementation with given scenarios to validate its correctness and completeness.","solution":"class CircularQueue: def __init__(self, capacity): self._array = [None] * capacity self._front = 0 self._rear = 0 self._size = 0 self._capacity = capacity def is_empty(self): return self._size == 0 def enqueue(self, value): if self._size == self._capacity: raise OverflowError(\\"Queue is full\\") self._array[self._rear] = value self._rear = (self._rear + 1) % self._capacity self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self._array[self._front] self._array[self._front] = None self._front = (self._front + 1) % self._capacity self._size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._array[self._front] def size(self): return self._size"},{"question":"Objective Design a function that validates and converts integers between specified bases (between 2 and 36). Your function must handle edge cases and optimize performance for both conversion directions. Detailed Requirements 1. Implement the function `int_to_base(num, base)` that converts a given integer `num` to a string representation in the specified `base`. * **Input**: * `num`: Integer (can be negative or zero). * `base`: Integer (2 <= base <= 36). * **Output**: * String representing `num` in the given `base`. 2. Implement the function `base_to_int(str_to_convert, base)` that converts a string representation of a number in the specified `base` to an integer. * **Input**: * `str_to_convert`: String representing a number in the `base`. * `base`: Integer (2 <= base <= 36). * **Output**: * Integer representation of `str_to_convert` in the given `base`. Constraints * Your implementation should handle both positive and negative integers. * Ensure that input bases are between 2 and 36. * Optimize your implementations to handle reasonably large numbers efficiently. * Validate the input string in `base_to_int` to ensure all characters are valid for the given base. Example Usage ```python # Example calls for int_to_base int_to_base(255, 16) # Expected output: \'FF\' int_to_base(-77, 8) # Expected output: \'-115\' int_to_base(5, 2) # Expected output: \'101\' # Example calls for base_to_int base_to_int(\'FF\', 16) # Expected output: 255 base_to_int(\'-115\', 8) # Expected output: -77 base_to_int(\'101\', 2) # Expected output: 5 ``` Ensure thorough testing on edge cases such as zero and negative values, as well as valid/invalid inputs for both functions.","solution":"def int_to_base(num, base): Convert an integer to a string representation in the specified base. Parameters: num (int): The integer to convert. base (int): The base to convert to (2 <= base <= 36). Returns: str: The string representation of the number in the specified base. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36, inclusive\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" is_negative = num < 0 num = abs(num) result = [] while num: result.append(digits[num % base]) num = num // base if is_negative: result.append(\'-\') return \'\'.join(reversed(result)) def base_to_int(str_to_convert, base): Convert a string representation of a number in the specified base to an integer. Parameters: str_to_convert (str): The string representation of the number. base (int): The base of the given string representation (2 <= base <= 36). Returns: int: The integer representation of the string in the specified base. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36, inclusive\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" is_negative = str_to_convert[0] == \'-\' if is_negative: str_to_convert = str_to_convert[1:] value = 0 for char in str_to_convert: if char.upper() not in digits[:base]: raise ValueError(f\\"Invalid character \'{char}\' for base {base}\\") value = value * base + digits.index(char.upper()) return -value if is_negative else value"},{"question":"# Background Working with strings is a common task in many programming problems. Reversing a string is a fundamental operation that can be achieved through various methods including recursion, iteration, and using Python\'s built-in capabilities. Understanding the different ways to reverse a string and their trade-offs helps enhance problem-solving skills and deepen comprehension of algorithmic strategies. # Task Implement a function `reverse_string(s: str) -> str` that reverses a given string `s` using the following four methods: 1. **Recursive Method** 2. **Iterative Method** 3. **Pythonic Method** 4. **Ultra Pythonic Method** # Function Definitions 1. `reverse_recursive(s: str) -> str` 2. `reverse_iterative(s: str) -> str` 3. `reverse_pythonic(s: str) -> str` 4. `reverse_ultra_pythonic(s: str) -> str` # Expected Input and Output - **Input**: A single string (1 ≤ length of `s` ≤ 10^5). - **Output**: The reversed string. # Constraints - The string may contain ASCII characters, including letters, numbers, and special characters. - You must implement all four methods. # Performance Requirements - The methods should handle large strings efficiently. - Avoid unnecessary recursive depth in the recursive method. # Example ```python s = \\"Hello, World!\\" assert reverse_recursive(s) == \\"!dlroW ,olleH\\" assert reverse_iterative(s) == \\"!dlroW ,olleH\\" assert reverse_pythonic(s) == \\"!dlroW ,olleH\\" assert reverse_ultra_pythonic(s) == \\"!dlroW ,olleH\\" ``` # Additional Context Understanding these different approaches will help you determine the most suitable algorithm for various constraints in future problems.","solution":"def reverse_recursive(s: str) -> str: Reverses a given string `s` using recursion. if len(s) <= 1: return s else: return s[-1] + reverse_recursive(s[:-1]) def reverse_iterative(s: str) -> str: Reverses a given string `s` using an iterative method. reversed_str = \\"\\" for char in s: reversed_str = char + reversed_str return reversed_str def reverse_pythonic(s: str) -> str: Reverses a given string `s` using Python slicing. return s[::-1] def reverse_ultra_pythonic(s: str) -> str: Reverses a given string `s` using the built-in reversed function and join. return \'\'.join(reversed(s))"},{"question":"# Question **Problem Statement:** You are given a Binary Search Tree (BST) with the following structure for its nodes: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Your task is to convert the BST into a sorted Doubly Linked List (DLL) in-place. Implement the function `bin_tree_to_list(root)` to achieve this. Each node in the doubly linked list should point to the next node (right) and the previous node (left) in its final form. # Function Signature: ```python def bin_tree_to_list(root: TreeNode) -> TreeNode: pass ``` # Inputs: * `root` (TreeNode): The root of the binary search tree. # Outputs: * Returns the head of the converted doubly linked list (TreeNode). # Constraints: * The number of nodes in the tree will be in the range `[0, 1000]`. * `-10^5 <= Node.val <= 10^5` # Performance Requirements: * The solution should have a time complexity of O(n) where n is the number of nodes. * The space complexity should be O(h) due to the call stack. # Example: Input: ``` 4 / 2 5 / 1 3 ``` Output: ``` 1 <-> 2 <-> 3 <-> 4 <-> 5 ``` Your task is to: 1. Implement the function `bin_tree_to_list`. 2. Ensure it runs efficiently within the provided constraints. 3. Handle all edge cases including empty trees and single-node trees. You can use the following utility function to visualize the structure of the resulting doubly linked list: ```python def print_tree(root): while root: print(root.val, end=\\" <-> \\" if root.right else \\"n\\") root = root.right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bin_tree_to_list(root: TreeNode) -> TreeNode: if not root: return None def convert(node): nonlocal first, last if not node: return # Recursively convert the left subtree convert(node.left) # Process the current node if last: # Link the previous node (last) with the current one (node) last.right = node node.left = last else: # If this is the smallest node, set it as first first = node last = node # Recursively convert the right subtree convert(node.right) first, last = None, None convert(root) return first"},{"question":"# Context: You\'re developing a utility function that needs to join URL segments or file paths seamlessly. You aim to avoid common pitfalls like double slashes or trailing slashes. Implement a robust function to handle these cases effectively. # Task: You are to implement a function `join_with_slash(base: str, suffix: str) -> str` that takes two string parameters, `base` and `suffix`, and returns a combined path string. This function should ensure: - Only one slash exists between `base` and `suffix`. - Any leading slashes in `suffix` and trailing slashes in `base` should be removed. - It handles both URL segments and file paths in Unix-style format. Input: - `base` (str): the base path or URL segment. - `suffix` (str): the suffix path or additional URL segment. Output: - Returns a single string representing the combined path or URL segment. Constraints: - The inputs will only contain printable ASCII characters. - Special characters like slashes (`/`) are handled specifically as mentioned. # Example: ```python assert join_with_slash(\'http://example.com\', \'about\') == \'http://example.com/about\' assert join_with_slash(\'http://example.com/\', \'about\') == \'http://example.com/about\' assert join_with_slash(\'path/to/dir\', \'file\') == \'path/to/dir/file\' assert join_with_slash(\'path/to/dir/\', \'/file\') == \'path/to/dir/file\' ``` # Performance Requirement: - The function should be efficient enough to handle typical URL/path lengths (up to 2048 characters) within acceptable time and space limits.","solution":"def join_with_slash(base: str, suffix: str) -> str: Joins the base URL/path with the suffix, ensuring only one slash between them. Args: base (str): The base URL/path. suffix (str): The suffix to be added to the base. Returns: str: The combined URL/path. if base.endswith(\'/\'): base = base.rstrip(\'/\') if suffix.startswith(\'/\'): suffix = suffix.lstrip(\'/\') return f\\"{base}/{suffix}\\""},{"question":"**Context**: You are building a simple command-based text editor that supports undo operations. For this, you\'ll need to efficiently manage a sequence of operations using a stack data structure. **Task**: Implement a `CommandStack` class using the Stack ADT provided in the code snippet above. The `CommandStack` class should support the following operations: 1. **execute(command)**: Push a command to the top of the stack. 2. **undo()**: Pop the most recent command from the stack and return it. 3. **redo(last_command)**: Push the last undone command back to the stack. **Requirements**: - Use either `ArrayStack` or `LinkedListStack` from the provided snippets. - Validate commands to ensure that they follow a simple `str` format with at least one character. - Ensure that any attempt to undo or redo an operation on an empty stack is handled gracefully. # Implementation ```python class CommandStack: def __init__(self, stack_type=\'array\'): if stack_type == \'array\': self._stack = ArrayStack() elif stack_type == \'linkedlist\': self._stack = LinkedListStack() else: raise ValueError(\\"Invalid stack type. Use \'array\' or \'linkedlist\'.\\") self._undo_stack = ArrayStack() def execute(self, command): if not command or not isinstance(command, str): raise ValueError(\'Command must be a non-empty string.\') self._stack.push(command) # Clear the undo stack if a new command is executed self._undo_stack = ArrayStack() def undo(self): if self._stack.is_empty(): raise IndexError(\\"Nothing to undo.\\") command = self._stack.pop() self._undo_stack.push(command) return command def redo(self): if self._undo_stack.is_empty(): raise IndexError(\\"Nothing to redo.\\") command = self._undo_stack.pop() self._stack.push(command) return command ``` **Example:** ```python cs = CommandStack(stack_type=\'array\') cs.execute(\'Type A\') cs.execute(\'Type B\') assert cs.undo() == \'Type B\' assert cs.redo() == \'Type B\' ``` # Note: - You may modify or expand the `ArrayStack` and `LinkedListStack` classes as needed. - You must handle edge cases gracefully and raise appropriate exceptions for invalid operations.","solution":"class ArrayStack: def __init__(self): self._data = [] def push(self, element): self._data.append(element) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self._data.pop() def is_empty(self): return len(self._data) == 0 class CommandStack: def __init__(self, stack_type=\'array\'): if stack_type == \'array\': self._stack = ArrayStack() else: raise ValueError(\\"Invalid stack type. Use \'array\'.\\") self._undo_stack = ArrayStack() def execute(self, command): if not command or not isinstance(command, str): raise ValueError(\'Command must be a non-empty string.\') self._stack.push(command) self._undo_stack = ArrayStack() def undo(self): if self._stack.is_empty(): raise IndexError(\\"Nothing to undo.\\") command = self._stack.pop() self._undo_stack.push(command) return command def redo(self): if self._undo_stack.is_empty(): raise IndexError(\\"Nothing to redo.\\") command = self._undo_stack.pop() self._stack.push(command) return command"},{"question":"# Function Implementation N-Tuple Sum Problem Given an array of integers and an integer `n`, write a function to find all unique `n`-tuples in the array that sum up to a specified target. The function should work with custom summation, comparison, and equality-checking closures. **Function Signature**: ```python def n_sum(n, nums, target, sum_closure=None, compare_closure=None, same_closure=None): ``` Input * `n`: An integer ( (2 leq n leq 4) ) representing the number of elements in the tuple. * `nums`: A list of integers. * `target`: An integer value representing the target sum. * `sum_closure`: A function that takes two elements from `nums` and returns their sum (default simple addition). * `compare_closure`: A function that compares a calculated sum to the `target`, returns -1, 0, or 1 (default simple comparison). * `same_closure`: A function checking equality between two `nums` elements (default equality). Output A list of unique lists, each containing `n` integers that sum up to `target`. Constraints * Use of the default summation and comparison closure is allowed if not custom ones are provided. * The function should avoid returning duplicate tuples. Performance Requirements * Time Complexity: Better or matching (O(n^{(n/2)})) * Space Complexity: Should efficiently handle recursion and storage. Example **Basic Example:** Given: ```python n = 4 nums = [1, 0, -1, 0, -2, 2] target = 0 ``` Expected Output: ```python [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] ``` **Advanced Example:** Given: ```python n = 2 nums = [[-3, 0], [-2, 1], [2, 2], [3, 3], [8, 4], [-9, 5]] target = -5 # Custom Sum Function def sum(a, b): return [a[0] + b[1], a[1] + b[0]] # Custom Compare Function def compare(num, target): if num[0] < target: return -1 elif num[0] > target: return 1 else: return 0 ``` Expected Output: ```python [[-9, 5], [8, 4]] ``` Implement the function `n_sum` to solve the problem as described above.","solution":"from itertools import combinations def n_sum(n, nums, target, sum_closure=None, compare_closure=None, same_closure=None): if sum_closure is None: sum_closure = lambda a, b: a + b if compare_closure is None: compare_closure = lambda sum_value, target: (sum_value > target) - (sum_value < target) if same_closure is None: same_closure = lambda a, b: a == b nums.sort() result = [] def find_n_sum(start, n, target, path): if n == 2: # two-pointer splitting left, right = start, len(nums) - 1 while left < right: current_sum = sum_closure(nums[left], nums[right]) comparison_result = compare_closure(current_sum, target) if comparison_result == 0: result.append(path + [nums[left], nums[right]]) left_temp, right_temp = nums[left], nums[right] while left < right and same_closure(nums[left], left_temp): left += 1 while left < right and same_closure(nums[right], right_temp): right -= 1 elif comparison_result < 0: left += 1 else: right -= 1 else: # n > 2. for i in range(start, len(nums) - n + 1): if i > start and same_closure(nums[i], nums[i - 1]): continue if sum_closure(nums[i], nums[i]) * n > target: break if sum_closure(nums[i], nums[-1]) * n < target: continue find_n_sum(i + 1, n - 1, sum_closure(target, -nums[i]), path + [nums[i]]) find_n_sum(0, n, target, []) return result"},{"question":"# Challenging Programming Question Scenario You are working on a number analysis tool that helps verify interesting properties of integers in a given range. One such property is that a number can be represented as the sum of its digits each raised to consecutive powers starting from 1. For instance, 89 can be represented as (8^1 + 9^2 = 89). Task Write a function `find_sum_dig_powers(low, high)` that finds all numbers between `low` and `high` (inclusive) that can be expressed in this manner. Function Signature ```python def find_sum_dig_powers(low: int, high: int) -> List[int]: ``` Input * `low`: An integer representing the lower bound of the range. * `high`: An integer representing the upper bound of the range. Output * A list of integers that satisfy the described property within the given range. Constraints * (1 leq text{low} leq text{high} leq 10^6) * The solution should be efficient in terms of both time and space complexity. Example ```python # Example Usage: print(find_sum_dig_powers(1, 100)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] ``` Ensure that your implementation correctly identifies all such numbers in the given range and adheres to the input/output formats strictly.","solution":"def find_sum_dig_powers(low, high): Finds numbers in the range [low, high] that can be expressed as the sum of their digits each raised to consecutive powers starting from 1. result = [] for num in range(low, high + 1): str_num = str(num) sum_of_powers = sum(int(digit) ** (idx + 1) for idx, digit in enumerate(str_num)) if sum_of_powers == num: result.append(num) return result"},{"question":"# Question Given the following implementation of a binary tree serialization and deserialization: ```python class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root): def build_string(node): if node: vals.append(str(node.val)) build_string(node.left) build_string(node.right) else: vals.append(\\"#\\") vals = [] build_string(root) return \\" \\".join(vals) def deserialize(data): def build_tree(): val = next(vals) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = build_tree() node.right = build_tree() return node vals = iter(data.split()) return build_tree() ``` # Task **Problem Scenario**: You are given a serialization-deserialization framework for a binary tree. Your task is to enhance the given framework with an additional function that will: * **validate_tree**: This function should receive the root of a binary tree and a list of integers representing values to search for in the tree. Write the implementation of the `validate_tree` function that checks whether all the values in the list are present in the binary tree. The function should return a list of boolean values indicating the presence of each value in the tree. # Function Signature ```python def validate_tree(root: TreeNode, values: List[int]) -> List[bool]: pass ``` # Input * `root`: The root node of the binary tree (or None for an empty tree). * `values`: A list of integers to search for in the binary tree. # Output * A list of boolean values, each indicating the presence (True) or absence (False) of the corresponding integer in the binary tree. # Example ```python # Construct binary tree manually root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) values = [1, 5, 6] # Expected Output: [True, True, False] print(validate_tree(root, values)) ``` (Note: Tree construction is shown above for clarity. Actual testing might use the provided serialize-deserialize functions.) # Constraints * Do not modify the original tree structure. * Optimize for both time and space where applicable. * The length of the `values` list should be considered for performance.","solution":"class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root): def build_string(node): if node: vals.append(str(node.val)) build_string(node.left) build_string(node.right) else: vals.append(\\"#\\") vals = [] build_string(root) return \\" \\".join(vals) def deserialize(data): def build_tree(): val = next(vals) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = build_tree() node.right = build_tree() return node vals = iter(data.split()) return build_tree() def validate_tree(root: TreeNode, values: list[int]) -> list[bool]: def tree_values(node): if not node: return set() return {node.val} | tree_values(node.left) | tree_values(node.right) tree_vals = tree_values(root) return [val in tree_vals for val in values]"},{"question":"# Quick Sort Optimization Challenge Context You are given a list of integers that needs to be sorted using the Quick Sort algorithm. Implement an optimized version of the Quick Sort algorithm that incorporates the \\"median-of-three\\" method for pivot selection and ensures tail call optimization for better handling of deep recursion scenarios. Task Write a function `optimized_quick_sort` that takes a list of integers and sorts it in ascending order. The implementation should: 1. Use the \\"median-of-three\\" rule to select the pivot. 2. Implement tail recursion to avoid deep recursion stack overflows. Function Signature ```python def optimized_quick_sort(arr: List[int]) -> List[int]: ``` Input - A list of integers `arr` where 0 <= len(arr) <= 10^5 and each element is in the range of -10^9 to 10^9. Output - Return the sorted list in ascending order. Constraints - Your algorithm must handle edge cases efficiently (empty list, list with a single element, lists with many duplicate elements). Performance Requirements - The sorting algorithm should run in O(n log n) time complexity on average. - Optimize for space to ensure that the stack depth due to recursion is minimized. Example ```python assert optimized_quick_sort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10] assert optimized_quick_sort([]) == [] assert optimized_quick_sort([1]) == [1] assert optimized_quick_sort([4, 4, 4, 4, 4, 4]) == [4, 4, 4, 4, 4, 4] ```","solution":"from typing import List def optimized_quick_sort(arr: List[int]) -> List[int]: Sorts a list of integers using an optimized quick sort algorithm. The pivot selection uses the median-of-three method and tail call optimization is implemented. def quick_sort(low, high): while low < high: pivot_index = partition(low, high) # Tail call optimization: recur on the smaller sub-array first if pivot_index - low < high - pivot_index: quick_sort(low, pivot_index - 1) low = pivot_index + 1 # Tail call for the right part else: quick_sort(pivot_index + 1, high) high = pivot_index - 1 # Tail call for the left part def median_of_three(low, high): mid = (low + high) // 2 if arr[high] < arr[low]: arr[low], arr[high] = arr[high], arr[low] if arr[mid] < arr[low]: arr[mid], arr[low] = arr[low], arr[mid] if arr[high] < arr[mid]: arr[high], arr[mid] = arr[mid], arr[high] return mid def partition(low, high): median = median_of_three(low, high) arr[median], arr[high] = arr[high], arr[median] # Move pivot to end pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 quick_sort(0, len(arr) - 1) return arr"},{"question":"# Context You work for a data analysis company where client datasets often include both valid and out-of-bound entries. As part of the preprocessing pipeline, it is essential to filter out invalid entries to conform to clients\' range restrictions on the data. # Problem Statement Write a function `filtered_values` that takes: - an array of integers `data` - optional integer limits `lower_bound` and `upper_bound` The function must filter elements in `data` such that: - Only elements greater than or equal to `lower_bound` (if provided) - Only elements less than or equal to `upper_bound` (if provided) If either `lower_bound` or `upper_bound` is `None`, ignore that bound. # Input - `data`: A list of integers. - `lower_bound` (optional): An integer (default is `None`). - `upper_bound` (optional): An integer (default is `None`). # Output - A list of integers containing only elements within the specified range. # Constraints - The input list `data` will contain at most 10^6 numbers. - Each number in `data` is in the range [-10^9, 10^9]. - The bounds `lower_bound` and `upper_bound` (when given) will be in the range [-10^9, 10^9]. # Example ```python # Example 1 data = [1, 3, 5, 7, 9] lower_bound = 3 upper_bound = 7 print(filtered_values(data, lower_bound, upper_bound)) # Output: [3, 5, 7] # Example 2 data = [1, 2, 3, 4, 5] lower_bound = None upper_bound = 3 print(filtered_values(data, lower_bound, upper_bound)) # Output: [1, 2, 3] # Example 3 data = [1, 2, 3, 4, 5] lower_bound = 2 upper_bound = None print(filtered_values(data, lower_bound, upper_bound)) # Output: [2, 3, 4, 5] # Example 4 data = [10, 20, 30, 40, 50] lower_bound = 25 upper_bound = 100 print(filtered_values(data, lower_bound, upper_bound)) # Output: [30, 40, 50] # Example 5 data = [] lower_bound = 1 upper_bound = 10 print(filtered_values(data, lower_bound, upper_bound)) # Output: [] ```","solution":"def filtered_values(data, lower_bound=None, upper_bound=None): Filters values within the specified bounds. Parameters: - data : list of int - lower_bound : int or None (optional) - upper_bound : int or None (optional) Returns: - list of int if lower_bound is None and upper_bound is None: return data if lower_bound is None: return [x for x in data if x <= upper_bound] if upper_bound is None: return [x for x in data if x >= lower_bound] return [x for x in data if lower_bound <= x <= upper_bound]"},{"question":"# Task: You are required to implement a Binary Search Tree (BST) with its core functionalities: insert, search, delete, and in-order traversal. # Function Signatures: * You need to implement the following methods: 1. `insert(val: int) -> None` 2. `search(val: int) -> bool` 3. `delete(val: int) -> None` 4. `inorder_traversal() -> List[int]` # Input: - `val` is an integer value to be inserted, searched or deleted in/from the BST. # Output: - For `search`, return `True` if the value exists in the BST, otherwise `False`. - For `inorder_traversal`, return a list of integers representing the in-order traversal of the BST. # Constraints: - Values for `val` in the BST operations can range from `-10^5` to `10^5`. - You may assume all values are unique when using `insert` and `delete`. # Example: ```python # Initialize the BST bst = BST() # Insert values bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) bst.insert(6) bst.insert(8) # Search for values assert bst.search(5) == True assert bst.search(9) == False # In-order traversal assert bst.inorder_traversal() == [2, 3, 4, 5, 6, 7, 8] # Delete values bst.delete(3) assert bst.inorder_traversal() == [2, 4, 5, 6, 7, 8] bst.delete(7) assert bst.inorder_traversal() == [2, 4, 5, 6, 8] ``` Implement the class `BST` with the methods as specified above.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val): if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert(node.left, val) else: if node.right is None: node.right = TreeNode(val) else: self._insert(node.right, val) def search(self, val): return self._search(self.root, val) def _search(self, node, val): if node is None: return False if node.val == val: return True elif val < node.val: return self._search(node.left, val) else: return self._search(node.right, val) def delete(self, val): self.root = self._delete(self.root, val) def _delete(self, node, val): if node is None: return node if val < node.val: node.left = self._delete(node.left, val) elif val > node.val: node.right = self._delete(node.right, val) else: if node.left is None: return node.right elif node.right is None: return node.left min_larger_node = self._get_min(node.right) node.val = min_larger_node.val node.right = self._delete(node.right, min_larger_node.val) return node def _get_min(self, node): current = node while current.left is not None: current = current.left return current def inorder_traversal(self): result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node, result): if node: self._inorder_traversal(node.left, result) result.append(node.val) self._inorder_traversal(node.right, result)"},{"question":"**Scenario:** You are working as a software engineer at a company focusing on data transmission and error correction. One of your tasks involves analyzing binary arrays, where each element can either be a 0 or 1. To optimize the transmission sequences, you are required to identify the position in the array where flipping a 0 to 1 would result in the longest contiguous sequence of 1s. **Question:** Write a function `find_optimal_flip` that uses the binary array to determine the index of the 0 that should be flipped to 1 to achieve the longest continuous sequence of 1s. **Function Signature:** ```python def find_optimal_flip(arr: List[int]) -> int: ``` **Inputs:** * `arr`: A list of integers representing a binary array (contains only 0s and 1s). **Outputs:** * Return the index of the 0 that should be flipped to 1 to get the longest continuous sequence of 1s. If there are no 0s in the array, return `-1`. **Constraints:** * The length of the array: (1 leq len(arr) leq 10^6). * Every element in the array is either 0 or 1. **Examples:** ```python assert find_optimal_flip([1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1]) == 3 assert find_optimal_flip([1, 0, 1]) == 1 assert find_optimal_flip([1, 1, 1]) == -1 assert find_optimal_flip([0, 0, 0]) == 0 ``` Note: Ensure your solution is optimized for performance and handles edge cases effectively.","solution":"from typing import List def find_optimal_flip(arr: List[int]) -> int: Finds the index of the 0 that should be flipped to 1 to get the longest continuous sequence of 1s in the binary array. Args: arr (List[int]): The binary array containing only 0s and 1s. Returns: int: The index of the 0 to flip, or -1 if no 0s are present. n = len(arr) if 0 not in arr: return -1 longest_sequence = 0 flip_index = -1 prev_zero_position = -1 prev_prev_zero_position = -1 max_len_index = -1 for i in range(n): if arr[i] == 0: if i - prev_prev_zero_position > longest_sequence: longest_sequence = i - prev_prev_zero_position flip_index = prev_zero_position prev_prev_zero_position = prev_zero_position prev_zero_position = i if n - prev_prev_zero_position > longest_sequence: flip_index = prev_zero_position return flip_index"},{"question":"# Word Square Construction Challenge **Objective**: Given a set of words of equal length, design a function to find all possible word squares. Input * `words` (List[str]): A list containing between 1 and 1000 unique words, all of the same length, with length between 1 and 5. Each word contains only lowercase English alphabet characters. Output * `List[List[str]]`: A list of lists, where each inner list represents a valid word square. Constraints * You should find all valid word squares, regardless of order. * Each word must be of the same length to construct a valid word square. Example ```python def word_squares(words: List[str]) -> List[List[str]]: # Your implementation here pass # Example 1 print(word_squares([\\"area\\",\\"lead\\",\\"wall\\",\\"lady\\",\\"ball\\"])) # Expected Output: # [ # [\\"wall\\",\\"area\\",\\"lead\\",\\"lady\\"], # [\\"ball\\",\\"area\\",\\"lead\\",\\"lady\\"] # ] # Example 2 print(word_squares([\\"abat\\",\\"baba\\",\\"atan\\",\\"atal\\"])) # Expected Output: # [ # [\\"baba\\",\\"abat\\",\\"baba\\",\\"atal\\"], # [\\"baba\\",\\"abat\\",\\"baba\\",\\"atal\\"] # ] ``` **Scenario**: Imagine you\'re developing a word puzzle game where players uncover hidden words forming perfect squares. Implementing efficient backtracking and prefix searching strategies as described will be crucial to generating these puzzles quickly and accurately.","solution":"from typing import List from collections import defaultdict class TrieNode: def __init__(self): self.children = {} self.words = [] class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.words.append(word) def search_by_prefix(self, prefix): node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] return node.words def word_squares(words: List[str]) -> List[List[str]]: def backtracking(step): if step == N: results.append(word_square[:]) return prefix = \'\'.join(word_square[i][step] for i in range(step)) for candidate in trie.search_by_prefix(prefix): word_square.append(candidate) backtracking(step + 1) word_square.pop() N = len(words[0]) trie = Trie() for word in words: trie.insert(word) results = [] word_square = [] for word in words: word_square.append(word) backtracking(1) word_square.pop() return results"},{"question":"# Question: Implement an Enhanced Hash Table with Custom Load Factor Thresholds You have learned about the Hash Table data structure and how it stores key-value pairs efficiently. A Hash Table usually maintains ample performance due to its near-constant time operations. However, performance could degrade under high load, requiring the table to resize. Your task is to extend the `ResizableHashTable` class to accept a custom load factor threshold for resizing. The hash table should be resized dynamically when the load factor exceeds the given threshold. Your Task 1. **Define a class `CustomLoadFactorHashTable` extending `ResizableHashTable`**. 2. **Constructor**: Accept an optional parameter `load_factor_threshold` (default set to 0.67, equivalent to 2/3) indicating the load factor at which the table should resize. 3. **Override the `put` method** to check the custom load factor before resizing. 4. Newly defined class should retain all other functionalities of `ResizableHashTable`. Input and Output Formats - The new class should follow Python\'s dictionary-like interface. - You do not need to handle input/output directly; focus on correctly implementing the class and methods. Constraints - Assume only integer keys are used. - The hash table resizable starting size is 8. - Test cases will cover insertion, look-up, deletion, and resizing using the custom load factor. Example Usage ```python # Initialize with default load factor threshold (0.67) htable = CustomLoadFactorHashTable() htable.put(1, \\"One\\") htable.put(2, \\"Two\\") # ... add more elements to trigger resize based on load factor assert htable.get(1) == \\"One\\" assert htable.get(100) is None # Element does not exist del htable[1] assert htable.get(1) is None # Element deleted # Initialize with a custom load factor threshold htable_custom = CustomLoadFactorHashTable(load_factor_threshold=0.5) htable_custom.put(1, \\"One\\") # ... custom logic to verify resizing at lower threshold ```","solution":"class ResizableHashTable: def __init__(self): self.size = 8 self.table = [None] * self.size self.count = 0 def _hash(self, key): return hash(key) % self.size def put(self, key, value): index = self._hash(key) if self.table[index] is None: self.table[index] = [] for i, (k, v) in enumerate(self.table[index]): if k == key: self.table[index][i] = (key, value) return self.table[index].append((key, value)) self.count += 1 if self.count / self.size > 0.75: # default load factor threshold in the base class self._resize() def get(self, key): index = self._hash(key) if self.table[index] is None: return None for k, v in self.table[index]: if k == key: return v return None def delete(self, key): index = self._hash(key) if self.table[index] is None: return for i, (k, v) in enumerate(self.table[index]): if k == key: del self.table[index][i] self.count -= 1 return def _resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.count = 0 for bucket in old_table: if bucket: for key, value in bucket: self.put(key, value) class CustomLoadFactorHashTable(ResizableHashTable): def __init__(self, load_factor_threshold=0.67): super().__init__() self.load_factor_threshold = load_factor_threshold def put(self, key, value): index = self._hash(key) if self.table[index] is None: self.table[index] = [] for i, (k, v) in enumerate(self.table[index]): if k == key: self.table[index][i] = (key, value) return self.table[index].append((key, value)) self.count += 1 if self.count / self.size > self.load_factor_threshold: self._resize()"},{"question":"You are a professional security consultant specializing in advising banks and wealthy homeowners on how to keep their assets safe. One of your key tasks is to evaluate a sequence of houses for a notorious thief and predict the maximum amount of money the thief can steal given certain security constraints. **Problem Statement**: Imagine each house in a street has a certain amount of money hidden inside, and given a list of non-negative integers representing the amount of money in each house, you need to determine the maximum amount of money the thief can rob tonight without alerting the police. The constraint is that adjacent houses have a security system connected, and breaking into two adjacent houses would trigger the alarm. This means the thief cannot rob two directly adjacent houses on the same night. **Function Signature**: ```python def house_robber(houses: List[int]) -> int: ``` **Input**: - `houses (List[int])`: A list of non-negative integers where each integer represents the amount of money in the corresponding house. **Output**: - `int`: The maximum amount of money the thief can rob without triggering the alarm. **Constraints**: - The length of the list could be zero and up to 100,000. - Each amount of money is a non-negative integer and does not exceed 1,000. **Example**: ```python assert house_robber([2, 7, 9, 3, 1]) == 12 assert house_robber([1, 2, 3, 1]) == 4 assert house_robber([5, 5, 10, 100, 10, 5]) == 110 assert house_robber([]) == 0 assert house_robber([10]) == 10 ``` **Considerations**: * Pay special attention to edge cases such as an empty list or a list with only one element. * Ensure the solution is optimized for large inputs within the constraints.","solution":"from typing import List def house_robber(houses: List[int]) -> int: Determines the maximum amount of money the thief can steal without triggering the alarm, given the constraint that adjacent houses cannot be robbed on the same night. if not houses: return 0 if len(houses) == 1: return houses[0] n = len(houses) dp = [0] * n dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1]"},{"question":"Scenario: You are given a set of items, each with a weight and a value. Your task is to determine the maximum total value that can be carried in a knapsack with a specified capacity. You can choose to include or exclude each item individually (0/1 nature), but you cannot take a fractional amount of an item. Function Signature: ```python def get_maximum_value(items: List[Tuple[int, int]], capacity: int) -> int: pass ``` # Requirements: 1. Implement the function `get_maximum_value` that calculates the maximum value possible given the list of items and the knapsack capacity. 2. The function takes two parameters: - `items`: A list of tuples where each tuple consists of two integers. The first integer represents the value of an item, and the second integer represents the weight of the item. - `capacity`: An integer representing the maximum weight the knapsack can carry. 3. The function should return an integer representing the maximum summarized value that can be obtained by fitting the selected items into the knapsack. Constraints: - (1 leq text{len(items)} leq 100) - (1 leq text{capacity} leq 1000) - All item values and weights are integers between 1 and 100. # Performance Requirements: - The algorithm should run in O(n * m) time complexity and use O(m) space complexity, where n is the number of items and m is the knapsack\'s capacity. Example: ```python items = [(60, 5), (50, 3), (70, 4), (30, 2)] capacity = 5 # Expected output: 80 (items with values 50 and 30 fit into the knapsack) print(get_maximum_value(items, capacity)) # Output: 80 ``` Notes: - Consider the edge cases where the capacity is zero, all items have a weight exceeding the capacity, and where some items have zero value. - Aim to write clear and concise code with appropriate comments explaining the steps of your solution.","solution":"from typing import List, Tuple def get_maximum_value(items: List[Tuple[int, int]], capacity: int) -> int: Calculates the maximum value that fits into the knapsack with given capacity. :param items: A list of tuples where each tuple consists of two integers (value, weight). :param capacity: An integer representing the maximum weight the knapsack can carry. :return: The maximum value that can be obtained by fitting items into the knapsack. # dp[i] will be storing the maximum value with i capacity dp = [0] * (capacity + 1) for value, weight in items: # Go through weights backwards to avoid overwriting previous results we depend on for cap in range(capacity, weight - 1, -1): dp[cap] = max(dp[cap], dp[cap - weight] + value) return dp[capacity]"},{"question":"# Scenario: You are working as a software engineer for a logistics company that often needs to compute the shortest delivery route between warehouses spread across a city. The city can be represented as a directed, fully connected graph where each warehouse is a node and every road between them has a weight representing travel time. Your task is to implement an optimized version of Dijkstra\'s Algorithm that will efficiently compute the shortest path from a specific warehouse to all other warehouses. # Problem Description: Implement a function `optimized_dijkstra(graph, src)` that computes the shortest path from a given source vertex to all other vertices in the directed weighted graph using a priority queue to optimize performance. # Function Signature: ```python def optimized_dijkstra(graph: List[List[int]], src: int) -> List[int]: pass ``` # Input: - `graph`: A 2D list where `graph[i][j]` represents the weight of the edge from vertex `i` to vertex `j`. A value of 0 means there is no direct edge. - `src`: An integer representing the source vertex. # Output: - A list of integers where the i-th element represents the shortest distance from the source vertex to the i-th vertex. If a vertex is not reachable, the distance should be represented as `float(\\"inf\\")`. # Constraints: - The number of vertices (length of graph list) is between 2 and 2000. - Edge weights are non-negative integers. # Example: ```python graph = [ [0, 10, 0, 30, 100], [10, 0, 50, 0, 0], [0, 50, 0, 20, 10], [30, 0, 20, 0, 60], [100, 0, 10, 60, 0] ] src = 0 print(optimized_dijkstra(graph, src)) # Output: [0, 10, 60, 30, 70] ``` # Note: - Optimize the algorithm using a priority queue (min-heap) to achieve better time complexity.","solution":"import heapq from typing import List def optimized_dijkstra(graph: List[List[int]], src: int) -> List[int]: Compute the shortest paths from the source vertex to all other vertices using Dijkstra\'s algorithm optimized with a priority queue. :param graph: 2D list where graph[i][j] represents the weight of the edge from vertex i to vertex j. :param src: An integer representing the source vertex. :return: A list of integers where the i-th element represents the shortest distance from the source vertex to the i-th vertex. n = len(graph) dist = [float(\'inf\')] * n dist[src] = 0 priority_queue = [(0, src)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > dist[current_vertex]: continue for neighbor in range(n): if graph[current_vertex][neighbor] != 0: distance = current_distance + graph[current_vertex][neighbor] if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return dist"},{"question":"Ordered Insert Position You are provided with a helper method `search_insert` that implements binary search to find the appropriate insertion position of a target value in a given sorted array. Your task is to create a function that uses this helper method to insert multiple values into an initially empty sorted array and return the resultant sorted array. Function Signature ```python def ordered_insert(arr: List[int], values: List[int]) -> List[int]: ``` Input - `arr`: An initially empty list that will hold the sorted integers. - `values`: A list of integers to be inserted into `arr`. Output - Returns the sorted list `arr` after all values have been inserted. Example ```python arr = [] values = [5, 1, 4, 2, 3] # After ordered_insert is called: # arr should be [1, 2, 3, 4, 5] ordered_insert(arr, values) ``` Constraints 1. Assume all values in `values` are unique. 2. The length of `values` is in the range [1, 10^4]. 3. Each element in `values` is in the range [-10^5, 10^5]. Guidelines - Use the `search_insert` method provided. - Don\'t sort `arr` directly at any time. Use the helper method to find the correct position and insert each value into `arr`. Notes - Maintaining the list in sorted order during inserts should be done using the binary search mechanism provided in `search_insert`.","solution":"from typing import List def search_insert(arr: List[int], target: int) -> int: Helper method to find the insertion position for a target value in a sorted array. left, right = 0, len(arr) while left < right: mid = (left + right) // 2 if arr[mid] < target: left = mid + 1 else: right = mid return left def ordered_insert(arr: List[int], values: List[int]) -> List[int]: Insert each value from the list \'values\' into the sorted list \'arr\' at the correct position. for value in values: pos = search_insert(arr, value) arr.insert(pos, value) return arr"},{"question":"# Binary Min Heap Implementation and Application You are tasked with extending and applying a min heap data structure to solve a practical problem. Objective Implement a `BinaryHeap` class with the functionality to perform operations such as insertion and deletion of the minimum element. Then, use the implemented class to solve the following problem: **Problem Statement**: Given a stream of integers, find the K-th smallest element in the stream at any point in time. Function Signatures ```python class BinaryHeap: def __init__(self): Initializes an empty min heap. pass def insert(self, val: int) -> None: Inserts an element into the min heap. pass def remove_min(self) -> int: Removes and returns the minimum element from the min heap. pass def find_kth_smallest(self, k: int) -> int: Finds and returns the K-th smallest element in the heap. pass ``` Input/Output Format * **Input**: 1. Stream of integers provided one by one. 2. An integer K indicating the position of the smallest element required. * **Output**: * For each insertion, return the K-th smallest element in the min heap if possible, otherwise indicate that it is not possible. Constraints * 1 <= K <= N, where N is the number of elements inserted so far. * The elements in the heap are distinct. Example ```python heap = BinaryHeap() print(heap.insert(10)) # Unable to find 1st smallest print(heap.insert(2)) # 2 (1st smallest) print(heap.insert(5)) # 5 (2nd smallest) print(heap.insert(7)) # 7 (3rd smallest) print(heap.insert(1)) # 7 (4th smallest) # The heap at this point will be able to provide the K-th smallest element print(heap.find_kth_smallest(2)) # 2 (2nd smallest) ``` Performance Requirements * Ensure that the solution efficiently supports the dynamic updating of the heap and can quickly retrieve the K-th smallest element using the implemented methods.","solution":"import heapq class BinaryHeap: def __init__(self): Initializes an empty min heap. self.min_heap = [] def insert(self, val: int) -> None: Inserts an element into the min heap. heapq.heappush(self.min_heap, val) def remove_min(self) -> int: Removes and returns the minimum element from the min heap. if self.min_heap: return heapq.heappop(self.min_heap) raise IndexError(\'remove_min from an empty heap\') def find_kth_smallest(self, k: int) -> int: Finds and returns the K-th smallest element in the heap. if k <= len(self.min_heap): return heapq.nsmallest(k, self.min_heap)[-1] raise ValueError(\'k is larger than the number of elements in the heap\')"},{"question":"**Scenario**: You are given a large dataset, which is suspected to be uniformly distributed, and you need to frequently search for specific values in the dataset. The goal is to minimize the search time as much as possible given the suspected uniform distribution. Due to the size of the dataset, a more efficient algorithm than binary search is desired. **Task**: Write a function, `advanced_interpolation_search`, to search for a target value in a given sorted array. Your solution must handle edge cases effectively and optimize the search process by utilizing interpolation search principles. Additionally, consider worst-case performance and provide enhancements to manage skewed distributions. **Function Signature**: ```python def advanced_interpolation_search(array: List[int], search_key: int) -> int: :param array: Sorted array to search in (list of integers). :param search_key: The value to search for (integer). :return: The index of the search_key if found, otherwise -1. ``` **Constraints**: * The array will have at most (10^6) elements. * Elements in the array are guaranteed to be integers. * The array may contain duplicate values. * The search key may not be present in the array. * Optimize for scenarios where the array is uniformly distributed but manage non-uniform cases effectively. **Examples**: ```python >>> advanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], 17) 4 >>> advanced_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) 2 >>> advanced_interpolation_search([1]*1000000, 1) 0 >>> advanced_interpolation_search([10, 20, 30, 40, 50], 25) -1 >>> advanced_interpolation_search([], 10) -1 ``` Explain any enhancements to the basic interpolation search and how they improve performance in the context of large datasets with suspected uniform distribution. **Performance Requirements**: Your solution should aim for the best possible average-case performance while maintaining robustness against worst-case scenarios.","solution":"from typing import List def advanced_interpolation_search(array: List[int], search_key: int) -> int: Perform an enhanced interpolation search on a sorted array. :param array: Sorted array to search in (list of integers). :param search_key: The value to search for (integer). :return: The index of the search_key if found, otherwise -1. low = 0 high = len(array) - 1 while low <= high and array[low] <= search_key <= array[high]: if array[low] == array[high]: if array[low] == search_key: return low else: break pos = low + ((search_key - array[low]) * (high - low) // (array[high] - array[low])) if array[pos] == search_key: return pos elif array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Scenario The process of binary exponentiation is essential when dealing with the need for computing large powers efficiently. This method, which illustrates core concepts of divide-and-conquer, logarithmic reduction, and modular arithmetic, is commonly applied in various fields including cryptography and numerical computations. # Task You are asked to implement a function that efficiently computes ( a^n ) modulo `mod`, using both iterative and recursive binary exponentiation. # Function Signature ```python def power(a: int, n: int, mod: int = None): Calculate a ^ n iteratively. If \'mod\' is specified, return the result modulo \'mod\'. :param a: Base integer :param n: Exponent integer :param mod: Modulus integer (optional) :return: Result of a ^ n (or (a ^ n) % mod if \'mod\' is specified) pass def power_recur(a: int, n: int, mod: int = None): Calculate a ^ n recursively. If \'mod\' is specified, return the result modulo \'mod\'. :param a: Base integer :param n: Exponent integer :param mod: Modulus integer (optional) :return: Result of a ^ n (or (a ^ n) % mod if \'mod\' is specified) pass ``` # Input - `a` (int): Base integer (0 <= a <= 10^9). - `n` (int): Exponent integer (0 <= n <= 10^9). - `mod` (int): Optional modulus integer (1 <= mod <= 10^9). # Output - Returns the integer result which is ( a^n ). If `mod` is given, returns ( a^n mod text{mod} ). # Constraints - Use efficient algorithms (binary exponentiation) to achieve O(log(n)) time complexity. - Consider the edge cases: - ( a = 0 ) and ( n > 0 ) should return 0. - ( n = 0 ) should return 1 as any number to the power 0 is 1. - Ensure correct application of the modulo operation if `mod` is provided. # Examples ```python print(power(2, 10)) # Output: 1024 print(power(2, 10, 1000)) # Output: 24 print(power_recur(2, 10)) # Output: 1024 print(power_recur(2, 10, 1000)) # Output: 24 ``` Implement the required functions ensuring the correct application of both iterative and recursive binary exponentiation algorithms. Consider performance implications and handle edge cases appropriately.","solution":"def power(a: int, n: int, mod: int = None): Calculate a ^ n iteratively. If \'mod\' is specified, return the result modulo \'mod\'. result = 1 base = a while n > 0: if n % 2 == 1: result = result * base if mod: result %= mod base = base * base if mod: base %= mod n //= 2 return result if not mod else result % mod def power_recur(a: int, n: int, mod: int = None): Calculate a ^ n recursively. If \'mod\' is specified, return the result modulo \'mod\'. if n == 0: return 1 if n == 1: return a % mod if mod else a half_pow = power_recur(a, n // 2, mod) half_pow = half_pow * half_pow if mod: half_pow %= mod if n % 2 == 0: return half_pow else: return (half_pow * a) % mod if mod else half_pow * a"},{"question":"You are given an implementation of the Bitonic Sort algorithm, a parallelizable sorting algorithm that can sort arrays of sizes that are powers of two in both increasing and decreasing order. The provided implementation is non-parallel and works for arrays where the length is a power of two. Your task is to implement this algorithm in a parallelizable manner using Python\'s multiprocessing or threading libraries. # Function Signature ```python def parallel_bitonic_sort(arr, reverse=False): Sorts the array arr in bitonic sequence in parallel. Args: arr : List[int] : The array to be sorted. reverse : bool : If True, sorts the array in descending order, otherwise in ascending order. Returns: List[int] : Sorted array in the specified order. pass ``` # Input * `arr`: List of integers (length must be a power of two). * `reverse`: Boolean value determining whether sorting is in descending order or not (default is False). # Output * Returns a new list of integers, sorted in the specified order. # Example ```python assert parallel_bitonic_sort([3, 7, 2, 8, 6, 4, 5, 1]) == [1, 2, 3, 4, 5, 6, 7, 8] assert parallel_bitonic_sort([3, 7, 2, 8, 6, 4, 5, 1], reverse=True) == [8, 7, 6, 5, 4, 3, 2, 1] ``` # Constraints * Length of the array must be a power of two. * You may assume all elements in the array are distinct. # Additional Notes * Leverage Python\'s `multiprocessing` or `threading` libraries to handle parallelization. * Perform error handling to raise a `ValueError` if the length of the input array is not a power of two.","solution":"from multiprocessing import Process, Manager def compare_and_swap(arr, i, j, direction): if direction == (arr[i] > arr[j]): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr, start, length, direction): if length > 1: mid = length // 2 for i in range(start, start + mid): compare_and_swap(arr, i, i + mid, direction) bitonic_merge(arr, start, mid, direction) bitonic_merge(arr, start + mid, mid, direction) def bitonic_sort_subarray(arr, start, length, direction): if length > 1: mid = length // 2 bitonic_sort_subarray(arr, start, mid, True) # Sort in ascending order bitonic_sort_subarray(arr, start + mid, mid, False) # Sort in descending order bitonic_merge(arr, start, length, direction) def parallel_bitonic_sort(arr, reverse=False): Sorts the array arr in bitonic sequence in parallel. Args: arr : List[int] : The array to be sorted. reverse : bool : If True, sorts the array in descending order, otherwise in ascending order. Returns: List[int] : Sorted array in the specified order. # Check if the length of arr is a power of two if len(arr) & (len(arr) - 1) != 0: raise ValueError(\\"Length of the array must be a power of two.\\") with Manager() as manager: shared_arr = manager.list(arr) length = len(shared_arr) process = Process(target=bitonic_sort_subarray, args=(shared_arr, 0, length, not reverse)) process.start() process.join() return list(shared_arr)"},{"question":"Task You need to implement a function to find the `n`-th digit in a sequence where all positive integers are concatenated in order (e.g., \\"123456789101112...\\"). Function Signature ```python def find_nth_digit(n: int) -> int: pass ``` Input - `n` (1 ≤ n ≤ 2 * 10^9): An integer representing the position of the digit to find in the concatenated sequence. Output - An integer representing the `n`-th digit in the sequence. Examples Input: `3` Output: `3` Input: `10` Output: `1` Input: `15` Output: `2` Constraints and Performance Requirements - Ensure your solution is optimized for very large values of `n` up to 2 billion. - Avoid generating the entire concatenated sequence to find the digit. Context You are tasked with building a part of a large-scale digit indexing system. This function will be critical in efficiently retrieving specific digits from a theoretically infinite concatenated sequence of numbers. Your implementation should align with the complexity and performance requirements given.","solution":"def find_nth_digit(n: int) -> int: length = 1 count = 9 start = 1 # Loop to find the range in which `n` falls while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Finding the exact number that contains the nth digit start += (n - 1) // length num_str = str(start) return int(num_str[(n - 1) % length])"},{"question":"Array Rotation You are given an array of integers and an integer k. Write a function to rotate the array to the right by k steps, implementing the most efficient algorithm among the three versions provided. Function Signature ```python def rotate_array(arr: List[int], k: int) -> List[int]: pass ``` Input and Output * **Input**: * `arr` (List of integers): An array of n integers where 1 ≤ n ≤ 10^5. * `k` (integer): An integer representing the number of steps to rotate the array by 0 ≤ k ≤ 10^9. * **Output**: * The function should return a new list representing the rotated array. Constraints: - You are required to use the most efficient solution in terms of time and space complexity. - Do not use any external libraries. Example: ```python arr = [1,2,3,4,5,6,7] k = 3 rotate_array(arr, k) => [5,6,7,1,2,3,4] ``` Explanation: We need to rotate the array to the right by 3 steps. The array [1,2,3,4,5,6,7] when rotated by 3 steps to the right becomes [5,6,7,1,2,3,4]. This result should be returned by the function.","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. n = len(arr) if n == 0: return arr k = k % n # In case k is larger than the array length return arr[-k:] + arr[:-k]"},{"question":"# Question Given a graph represented by an adjacency matrix, implement a function `is_bipartite_graph(adj_matrix)` to determine if the graph is bipartite. Use Breadth-First Search for this task. Function Signature ```python def is_bipartite_graph(adj_matrix: List[List[int]]) -> bool: pass ``` Input * `adj_matrix`: A List of Lists representing the adjacency matrix of the graph. - `adj_matrix[i][j]` is `1` if there is an edge between vertex `i` and vertex `j`, otherwise, it is `0`. - The matrix is square with dimensions n x n, where `n` is the number of vertices. Output * Return `True` if the graph is bipartite, otherwise return `False`. Constraints * `1 <= n <= 1000`, where `n` is the number of vertices. * The graph will contain no negative weights and will be undirected. Example ```python assert is_bipartite_graph([ [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0] ]) == True assert is_bipartite_graph([ [0, 1, 1, 0], [1, 0, 1, 0], [1, 1, 0, 1], [0, 0, 1, 0] ]) == False ``` # Instructions 1. Implement the `is_bipartite_graph` function. 2. Handle cases where the graph is disconnected. 3. Consider graphs with self-loops. Additional Notes * A bipartite graph can be defined as one in which vertices can be divided into two sets, such that no two vertices within the same set are adjacent. * Leverage BFS to try and color the graph in two colors and check whether the graph can be successfully colored. * If any adjacent vertex pairs have the same color, the graph is not bipartite.","solution":"from typing import List from collections import deque def is_bipartite_graph(adj_matrix: List[List[int]]) -> bool: n = len(adj_matrix) colors = [-1] * n # -1 indicates no color assigned yet for start in range(n): if colors[start] == -1: # unvisited node queue = deque([start]) colors[start] = 0 # Assign the first color while queue: node = queue.popleft() current_color = colors[node] for neighbor in range(n): if adj_matrix[node][neighbor] == 1: # there is an edge if colors[neighbor] == -1: # if the neighbor hasn\'t been colored yet colors[neighbor] = 1 - current_color # assign the opposite color queue.append(neighbor) elif colors[neighbor] == current_color: # if the neighbor has the same color return False return True"},{"question":"Design a function that finds the nth digit in the infinite sequence formed by concatenating the positive integers sequentially (e.g., \\"123456789101112...\\"). Implement the function `find_nth_digit(n)` which returns the `n`-th digit of the sequence. # Input Format: * An integer `n` (1 <= n <= 2*10^9) # Output Format: * Return the single digit as an integer. # Example: ``` find_nth_digit(3) -> 3 # The sequence starts with \\"123...\\", the 3rd digit is \\"3\\". find_nth_digit(11) -> 0 # The sequence runs as \\"...91011...,\\" the 11th digit being \\"0\\". find_nth_digit(12) -> 1 # Continuing from above, 12th position has \\"1\\". ``` # Constraints: * Your solution should have a time complexity of O(log n). # Notes: Consider edge cases such as `n` corresponding to digits crossing multiple boundaries (e.g., 9 to 10 or 99 to 100, etc.). Your implementation should handle large values of `n` efficiently.","solution":"def find_nth_digit(n): Finds the nth digit in the infinite sequence of concatenated positive integers. Args: n (int): The position of the digit to find. Returns: int: The digit at the nth position. length = 1 # Current length of numbers we are counting (1 for [1-9], 2 for [10-99], ... ) count = 9 # Count of numbers having the current length (`9` for `1-9`, `90` for `10-99`, ...) start = 1 # The first number of the current length (1, 10, 100, ...) while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Find the actual number and digit start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"# Problem Description You are given two strings, `haystack` and `needle`. Implement the function `find_substring(haystack: str, needle: str) -> int` to return the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`. # Inputs * `haystack`: A string of length `m` (1 <= m <= 10^5). * `needle`: A string of length `n` (0 <= n <= 10^4). # Outputs * An integer representing the index of the first occurrence of `needle` in `haystack`. If `needle` does not exist in `haystack`, return `-1`. # Constraints * If `needle` is an empty string, return 0. * You are expected to handle cases where `needle` is longer than `haystack`, returning `-1`. # Performance Requirements * Your implementation should be efficient enough to handle the upper limits of string lengths. * Though the naive approach is acceptable, you might soon learn that more optimized algorithms would be beneficial for larger datasets. # Example ```python def find_substring(haystack: str, needle: str) -> int: # [Implement the function as described] pass # Example usage: print(find_substring(\\"hello\\", \\"ll\\")) # Output: 2 print(find_substring(\\"aaaaa\\", \\"bba\\")) # Output: -1 print(find_substring(\\"\\", \\"\\")) # Output: 0 print(find_substring(\\"abc\\", \\"\\")) # Output: 0 print(find_substring(\\"abc\\", \\"abcd\\")) # Output: -1 ``` Use the provided test cases to verify your solution and consider additional edge cases to ensure robustness.","solution":"def find_substring(haystack: str, needle: str) -> int: Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. if needle == \\"\\": return 0 return haystack.find(needle)"},{"question":"Background In fields like Bioinformatics, strings often need to be repeated and checked for substrings to identify genetic markers. As a practical application, imagine you need to find the minimum number of times a DNA sequence (string A) must be repeated such that another sequence (string B) is a part of it. Task You are given two strings, A and B. Implement a function `min_repeats(A: str, B: str) -> int` to find the minimum number of times A has to be repeated so that B is a substring of the repeated A. If no such repeat count is possible, return -1. Input * `A`: A non-empty string, representing the base sequence (1 <= len(A) <= 10000). * `B`: A non-empty string, representing the sequence to be checked (1 <= len(B) <= 10000). Output * An integer indicating the minimum number of repetitions required. Return -1 if B cannot be a substring of any repeated form of A. Constraints * Both strings A and B consist of lowercase English letters. Example ```python assert min_repeats(\\"abcd\\", \\"cdabcdab\\") == 3 assert min_repeats(\\"abc\\", \\"cabcabca\\") == 4 assert min_repeats(\\"a\\", \\"aaaaa\\") == 5 assert min_repeats(\\"abc\\", \\"def\\") == -1 ``` Performance Your solution should aim to handle efficiently within the specified input size constraints.","solution":"def min_repeats(A: str, B: str) -> int: Returns the minimum number of times A needs to be repeated so that B is a substring. If it\'s not possible, return -1. len_A = len(A) len_B = len(B) # Optimize by checking up to len(B) / len(A) + 2 repetitions max_repeats = len_B // len_A + 2 repeated_A = \\"\\" for i in range(1, max_repeats + 1): repeated_A += A if B in repeated_A: return i return -1"},{"question":"# Question You are given a string as input. Your task is to write a function that removes any reoccurring characters from the string while preserving the order of their first appearance. The resulting string should contain no duplicates and must retain the initial order of characters. Function Signature: ```python def remove_reoccurring_characters(s: str) -> str: pass ``` Input: * A single string `s` with a maximum length of 1000 characters. * Constraints: * The string consists of printable ASCII characters (spaces, letters, digits, punctuation). Output: * Return a new string which represents the original string without any reoccurring characters. Example: 1. Input: `\\"programming\\"` Output: `\\"progamin\\"` 2. Input: `\\"abracadabra\\"` Output: `\\"abrcd\\"` 3. Input: `\\"aaaaaaa\\"` Output: `\\"a\\"` Additional Constraints: * The solution should have a time complexity of O(n) and a space complexity of O(n), where n is the length of the input string. Bonus: Improve the function to handle very large strings more efficiently by using better intermediate data structures.","solution":"def remove_reoccurring_characters(s: str) -> str: Removes reoccurring characters while preserving the order of their first appearance. seen = set() result = [] for char in s: if char not in seen: result.append(char) seen.add(char) return \'\'.join(result)"},{"question":"You are given a singly linked list of integers. Write a function `is_sorted(head: Optional[ListNode]) -> bool` that determines whether the linked list is sorted in non-decreasing order. If the linked list is empty, consider it sorted. Function Signature ```python def is_sorted(head: Optional[ListNode]) -> bool: ``` # Input - `head`: The head node of the singly linked list. `head` is either a `ListNode` object or `None`. # Output - Returns `True` if the linked list is sorted in non-decreasing order. Returns `False` otherwise. # Example Example 1: ```python Input: head = None Output: True Explanation: An empty list is considered sorted. ``` Example 2: ```python Input: head -> [1 -> 2 -> 3 -> 4] Output: True Explanation: The list is in increasing order. ``` Example 3: ```python Input: head -> [1 -> 2 -> -1 -> 3] Output: False Explanation: The list is not in increasing order because -1 < 2. ``` # Constraints - The number of nodes in the linked list is in the range `[0, 10^4]`. - `-10^5 <= Node.val <= 10^5` # Context Imagine you are monitoring a series of transactions for a financial application, ensuring they are processed in chronological order. Implementing this function helps verify that transaction history lists are in order before further processing or storage.","solution":"from typing import Optional class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head: Optional[ListNode]) -> bool: if not head: return True curr = head while curr and curr.next: if curr.val > curr.next.val: return False curr = curr.next return True"},{"question":"# Stooge Sort in Action Context: Stooge Sort is primarily a theoretical sorting algorithm, known for its inefficiency in practical applications. It serves as an example of recursive sorting techniques. Problem Statement: Given an array of integers, implement the Stooge Sort algorithm to sort the elements in non-decreasing order. Function Signature: ```python def stoogesort(arr: List[int], l: int, h: int) -> None: # Your code here ``` # Input * `arr`: A list of integers (1 <= len(arr) <= 1000, -10^6 <= arr[i] <= 10^6) * `l`: The starting index of the array (0 <= l < len(arr)) * `h`: The ending index of the array (0 <= h < len(arr)) # Output * The function should return `None`. The array `arr` should be sorted in place. # Constraint: * You must use the Stooge Sort algorithm. * The function should handle small arrays efficiently without encountering stack overflow. # Example ```python arr = [5, 3, 2, 8, 1, 4] stoogesort(arr, 0, len(arr)-1) print(arr) # Outputs: [1, 2, 3, 4, 5, 8] ``` # Note: * Pay attention to the base and recursive cases to ensure correct functionality. * Consider edge cases with the smallest input sizes and arrays with duplicate elements.","solution":"from typing import List def stoogesort(arr: List[int], l: int, h: int) -> None: if l >= h: return # If the element at index l is greater than the element at index h, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort the first 2/3 of the array stoogesort(arr, l, h - t) # Recursively sort the last 2/3 of the array stoogesort(arr, l + t, h) # Recursively sort the first 2/3 of the array again stoogesort(arr, l, h - t)"},{"question":"# Background You are given a simple sorting algorithm called \\"Exchange Sort\\" which compares each pair of elements in the list and swaps them if they are in the wrong order. However, due to its quadratic time complexity, this algorithm is quite inefficient for large datasets. Your task is to implement this algorithm and then improve its efficiency using a more performant sorting algorithm of your choice. # Task 1. Implement the provided \\"Exchange Sort\\" to practice understanding and identifying the mechanics of the algorithm. 2. Implement an optimized sorting algorithm with better performance, such as Quick Sort, Merge Sort, or Heap Sort. 3. Compare the performance of both algorithms on various datasets. # Requirements 1. Write a function `exchange_sort(arr: List[int]) -> List[int]` that sorts the array using the Exchange Sort algorithm. 2. Write a function `optimized_sort(arr: List[int]) -> List[int]` that sorts the array using a more efficient sorting algorithm. 3. Write a function `compare_sorts()` to demonstrate and compare the performance of `exchange_sort` and `optimized_sort` on different datasets, including edge cases like empty arrays and arrays with one element. # Constraints * Array elements will be integers. * The length of the array can be up to 100,000 elements. * The values in the array can range between -1,000,000 and 1,000,000. # Input and Output Format The function `exchange_sort` and `optimized_sort` should take a list of integers as input and return a sorted list. The function `compare_sorts` should print the time taken by both functions for sorting arrays of varying sizes. # Performance Expectations * `exchange_sort` is expected to have O(n^2) time complexity. * `optimized_sort` should have an average-case time complexity better than O(n^2), ideally O(n log n). # Example ```python def exchange_sort(arr): # Implement the provided exchange sort algorithm pass def optimized_sort(arr): # Implement a more efficient sorting algorithm pass def compare_sorts(): # Test and compare both sorting functions on sample datasets pass # Example usage arr = [34, 7, 23, 32, 5, 62] print(exchange_sort(arr)) # Output: [5, 7, 23, 32, 34, 62] print(optimized_sort(arr)) # Output: [5, 7, 23, 32, 34, 62] compare_sorts() ```","solution":"def exchange_sort(arr): Sorts the array using the Exchange Sort algorithm. n = len(arr) for i in range(n): for j in range(i+1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr def optimized_sort(arr): Sorts the array using Python\'s built-in Timsort algorithm. return sorted(arr) def compare_sorts(): import time import random sizes = [0, 1, 10, 100, 1000, 10000, 100000] for size in sizes: arr = [random.randint(-1000000, 1000000) for _ in range(size)] start_time = time.time() exchange_sorted = exchange_sort(arr.copy()) exchange_sort_time = time.time() - start_time start_time = time.time() optimized_sorted = optimized_sort(arr.copy()) optimized_sort_time = time.time() - start_time assert exchange_sorted == optimized_sorted, \\"Sorting methods did not produce the same result!\\" print(f\\"Array size: {size}\\") print(f\\" - Exchange Sort Time: {exchange_sort_time:.6f} seconds\\") print(f\\" - Optimized Sort Time: {optimized_sort_time:.6f} seconds\\") print()"},{"question":"**Scenario**: You are working on a data processing system that handles large streams of events. Each event is represented as an integer in a list. To control the load, you need to ensure that each type of event appears at most N times in the processed list. Ordering should be preserved. **Task**: Implement the function `process_events(events: List[int], max_occurrences: int) -> List[int]` that takes a list of events and an integer N. The function should return a list where each integer from `events` appears at most N times, in the same order as they first appear in `events`. **Input Format**: * `events` - a list of integers representing event types. * `max_occurrences` - an integer N specifying the maximum allowed occurrences of each event type. **Output Format**: * Return a list of integers where each integer from `events` appears at most N times. **Constraints**: * The input list `events` can have up to 10^5 integers. * `max_occurrences` is a non-negative integer. **Example**: ```python assert process_events([1,2,3,1,2,1,2,3], 2) == [1,2,3,1,2,3] assert process_events([20,37,20,21], 1) == [20,37,21] assert process_events([], 2) == [] assert process_events([1,2,3], 0) == [] ``` **Explanation**: * In the first example, the number 1 and 2 can\'t appear more than 2 times, so the third occurrence of 1 and 2 are removed, leaving the list as [1,2,3,1,2,3]. * In the second example, since the max occurrences is 1, each number appears at most once.","solution":"def process_events(events, max_occurrences): Restrict each event type to appear at most max_occurrences times in the list. Parameters: events (List[int]): A list of integers representing event types. max_occurrences (int): The maximum allowed occurrences of each event type. Returns: List[int]: The list with each event type appearing at most max_occurrences times. from collections import defaultdict occurrences = defaultdict(int) result = [] for event in events: if occurrences[event] < max_occurrences: result.append(event) occurrences[event] += 1 return result"},{"question":"# Invert a Binary Tree Scenario You are given a binary tree, where each node may have two children or no children. Your task is to write a function that inverts the binary tree. Inverting a binary tree means swapping the left and right child of every node. Function Signature ```python def invert_binary_tree(root: TreeNode) -> None: ``` In this function: * `root` is the root node of the binary tree. Input Format * The input is a reference to the root node of the tree. * TreeNode is a class defined as follows: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` Output Format * The function modifies the binary tree in place and does not return any value. Constraints 1. The number of nodes in the tree is in the range `[0, 10^4]`. 2. The values of the nodes are unique. Performance Requirements * The function should operate in O(n) time complexity. * The function should use O(h) space complexity due to the recursion stack, where h is the height of the tree. Example Consider the binary tree below: ``` 4 / 2 7 / / 1 3 6 9 ``` Calling `invert_binary_tree` on this tree should transform it to: ``` 4 / 7 2 / / 9 6 3 1 ```","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def invert_binary_tree(root): if root is None: return # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees invert_binary_tree(root.left) invert_binary_tree(root.right)"},{"question":"# AVL Tree Operations Implementation As a software developer working on a high-performance database management system, you need to ensure efficient data insertions, deletions, and lookups. You\'ve decided to implement an AVL tree to maintain the sorted data in a balanced manner. Your task is to complete the implementation of an AVL tree with the following operations: 1. **Insert**: Insert a key into the AVL tree while maintaining the balance. 2. **Delete**: Delete a key from the AVL tree and ensure the tree remains balanced. 3. **Find**: Check if a key exists in the AVL tree. 4. **In-order Traversal**: Return a list of all elements in the AVL tree in sorted (in-order) manner. # Function Signature Your AVL tree class should have the following method signatures: ```python class AvlTree: def __init__(self): # Initializes an empty AVL tree. def insert(self, key): # Inserts key into the AVL tree. def delete(self, key): # Deletes key from the AVL tree. def find(self, key) -> bool: # Checks if the key exists in the AVL tree. # Returns True if key exists, False otherwise. def in_order_traversal(self) -> list: # Returns a list of all keys in the AVL tree in sorted order. ``` # Constraints - Keys are unique integers. - Operations to handle edge cases like inserting into an empty tree or deleting a non-existent key should be properly managed. - You should aim for O(log n) complexity for each of the primary operations (insert, delete, find). # Input and Output Formats ```python # Example Usage avl_tree = AvlTree() avl_tree.insert(10) avl_tree.insert(20) avl_tree.insert(5) avl_tree.delete(10) print(avl_tree.find(20)) # Output: True print(avl_tree.find(10)) # Output: False print(avl_tree.in_order_traversal()) # Output: [5, 20] ```","solution":"class AVLNode: def __init__(self, key): self.key = key self.height = 1 self.left = None self.right = None class AvlTree: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return AVLNode(key) if key < node.key: node.left = self._insert(node.left, key) elif key > node.key: node.right = self._insert(node.right, key) else: return node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._balance(node) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._balance(node) def find(self, key) -> bool: return self._find(self.root, key) def _find(self, node, key): if not node: return False if key == node.key: return True elif key < node.key: return self._find(node.left, key) else: return self._find(node.right, key) def in_order_traversal(self) -> list: result = [] self._in_order_traversal(self.root, result) return result def _in_order_traversal(self, node, result): if not node: return self._in_order_traversal(node.left, result) result.append(node.key) self._in_order_traversal(node.right, result) def _get_height(self, node): if not node: return 0 return node.height def _balance(self, node): balance = self._get_balance(node) if balance > 1 and self._get_balance(node.left) >= 0: return self._right_rotate(node) if balance > 1 and self._get_balance(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and self._get_balance(node.right) <= 0: return self._left_rotate(node) if balance < -1 and self._get_balance(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left)"},{"question":"# 1-Sparse Recovery Algorithm Coding Question Objective: Write a function to determine if a dynamic stream of non-negative tuples results in a single unique non-repeating element after cancellations. Problem Statement: Given a stream of tuples, where each tuple contains a number and a sign (`+`/`-`), write a function `one_sparse(array)` that determines if the stream is 1-sparse. The stream is 1-sparse if all elements in the stream cancel each other out in such a way that there is only one unique number remaining. Function Signature: ```python def one_sparse(array: List[Tuple[int, str]]) -> Optional[int]: ``` Inputs: * `array`: A list of tuples `[(number, \'sign\'), ...]` where: * `number` is an integer representing the value. * `sign` is a character `\'+\'` or `\'-\'` indicating the addition or subtraction of the number. Output: * Returns the single remaining unique number if the stream is 1-sparse. * Returns `None` if the stream is not 1-sparse. Constraints: * The tuples in the array always have non-negative numbers (including zero) with valid signs. * The size of the array can be large, implying efficiency consideration. Examples: 1. `one_sparse([(4,\'+\'), (2,\'+\'),(2,\'-\'),(4,\'+\'),(3,\'+\'),(3,\'-\')])` should return `4` 2. `one_sparse([(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\')])` should return `2` 3. `one_sparse([(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(1,\'+\')])` should return `None` Implementation Tips: * Handle edge cases where stream elements cancel out entirely or have more than one remaining unique number. * Ensure bitwise operations are correctly implemented for the bit summation check.","solution":"from typing import List, Tuple, Optional def one_sparse(array: List[Tuple[int, str]]) -> Optional[int]: Determine if the stream is 1-sparse by cancelling out pairs. :param array: List of tuples containing a number and its corresponding sign \'+\' or \'-\'. :return: The unique number if the stream is 1-sparse, otherwise None. if not array: return None # Dictionary to keep the net count of each number counts = {} for value, sign in array: if sign == \'+\': counts[value] = counts.get(value, 0) + 1 elif sign == \'-\': counts[value] = counts.get(value, 0) - 1 # Filter out the non-zero count numbers remaining = [key for key, count in counts.items() if count != 0] # If exactly one number does not cancel out, return it if len(remaining) == 1: return remaining[0] return None"},{"question":"# Question: Removing a Bit from an Integer Context: You are working on a project that involves low-level data manipulation and need to implement an efficient way to remove specific bits from integers. Efficient bit manipulation is critical for the performance of the system, especially when dealing with large volumes of data. Task: Write a function `remove_bit(num: int, i: int) -> int` that removes the bit at position `i` from the binary representation of the integer `num`. Bit positions are zero-indexed from the right. Input: - `num`: an integer (1 <= num <= 10^9) - `i`: an integer (0 <= i < number of bits in `num`) Output: - Return the integer value obtained after removing the bit at position `i`. Function Signature: ```python def remove_bit(num: int, i: int) -> int: pass ``` Example: ```python # Example 1 num = 21 # binary: 10101 i = 2 print(remove_bit(num, i)) # Output: 9 (binary: 1001) # Example 2 num = 21 # binary: 10101 i = 4 print(remove_bit(num, i)) # Output: 5 (binary: 101) # Example 3 num = 21 # binary: 10101 i = 0 print(remove_bit(num, i)) # Output: 10 (binary: 1010) ``` Constraints: - Your solution must run in O(1) time complexity. - Handle edge cases such as removing the least or most significant bit correctly. - You may assume that valid indices are provided. Good luck, and remember to thoroughly test your code against a variety of cases, including edge cases.","solution":"def remove_bit(num: int, i: int) -> int: Removes the bit at position i from the binary representation of num. Bit positions are zero-indexed from the right. # Calculate the mask for the bits we want to keep left_part = num >> (i + 1) # bits to the left of the i-th bit right_part = num & ((1 << i) - 1) # bits to the right of the i-th bit # Combine the left and right parts to form the new number result = (left_part << i) | right_part return result"},{"question":"You are given a positive integer `n`. The number of ways in which `n` can be written as a sum of positive integers is called its partition number. Write a function to calculate the partition number of `n` using the dynamic programming approach. # Function Signature: ```python def find_partition_count(n: int) -> int: ``` # Input: - A single integer `n` (1 <= n <= 100). # Output: - An integer representing the number of different ways to write `n` as a sum of positive integers. # Example: ```python find_partition_count(4) # Returns: 5 find_partition_count(7) # Returns: 15 ``` # Explanation: For `n = 4`: - The possible partitions are: - 4 - 3 + 1 - 2 + 2 - 2 + 1 + 1 - 1 + 1 + 1 + 1 Thus, the function should return `5`. For `n = 7`: - The possible partitions are: - 7 - 6 + 1 - 5 + 2 - 5 + 1 + 1 - 4 + 3 - 4 + 2 + 1 - 4 + 1 + 1 + 1 - 3 + 3 + 1 - 3 + 2 + 2 - 3 + 2 + 1 + 1 - 3 + 1 + 1 + 1 + 1 - 2 + 2 + 2 + 1 - 2 + 2 + 1 + 1 + 1 - 2 + 1 + 1 + 1 + 1 + 1 - 1 + 1 + 1 + 1 + 1 + 1 + 1 Hence, the function should return `15`. # Constraints: 1. You may use additional helper functions as needed. 2. The algorithm should be efficient, with a time complexity of O(n^2).","solution":"def find_partition_count(n: int) -> int: # Using dynamic programming to find the number of partitions for n. # Initialize a list to store the number of partitions for each value up to n partition = [0] * (n + 1) # There is exactly one way to partition 0, which is not using any parts. partition[0] = 1 # Iterate through each number i from 1 to n for i in range(1, n + 1): # Update partition counts for every number >= i for j in range(i, n + 1): partition[j] += partition[j - i] # The number of partitions of n is stored in partition[n] return partition[n]"},{"question":"# Coding Task: Shortest Path in a Directed Graph Objective Implement a function to calculate the shortest path from a source node to a target node in a directed graph. You must utilize the provided DirectedGraph, Node, and DirectedEdge classes. Details 1. **Function**: `shortest_path(graph: DirectedGraph, start: str, end: str) -> list[str]` 2. **Input**: * `graph`: An instance of `DirectedGraph`. * `start`: The name of the start node (string). * `end`: The name of the end node (string). 3. **Output**: * A list of node names (strings) representing the shortest path from start to end, inclusive. * If no path exists, return an empty list. 4. **Constraints**: * Assume all edge weights are 1. * The graph may contain cycles. Example Usage ```python # Create the graph graph_data = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'D\', \'E\'], \'D\': [\'F\'], \'E\': [\'F\'], \'F\': [] } graph = DirectedGraph(graph_data) # Find the shortest path result = shortest_path(graph, \'A\', \'F\') print(result) # Expected Output: [\'A\', \'B\', \'D\', \'F\'] or [\'A\', \'C\', \'D\', \'F\'] ``` Function Signature ```python def shortest_path(graph: DirectedGraph, start: str, end: str) -> list[str]: # Your implementation here pass ``` Notes * Use BFS (Breadth-First Search) to implement the shortest path finding, due to uniform edge weights. * Handle edge cases such as non-existent start/end nodes appropriately.","solution":"from collections import deque class DirectedGraph: def __init__(self, graph_dict): self.graph_dict = graph_dict def shortest_path(graph: DirectedGraph, start: str, end: str) -> list[str]: if start not in graph.graph_dict or end not in graph.graph_dict: return [] queue = deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() if current_node == end: return path visited.add(current_node) for neighbor in graph.graph_dict.get(current_node, []): if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return []"},{"question":"# Flatten Nested Arrays **Scenario:** You are working on a data analytics project where you need to process large datasets stored in nested JSON-like formats. To facilitate simpler data manipulation, you need to flatten these nested arrays into single-level arrays. Your task is to implement a function that can handle this flattening process. **Task:** Implement a function `flatten_nested_arrays` that takes a nested array and returns a flattened version of it. Nested arrays can include other arrays at any level, and the function should produce a single array containing all the elements in the order they appeared. # Function Signature: ```python def flatten_nested_arrays(nested_list: list) -> list: pass ``` # Input: - `nested_list`: A list that may contain other nested lists, strings, or other types of elements. # Output: - A single flattened list containing all elements in the same order as they appeared in the nested structure. # Constraints: - Elements in the nested list can be of any type, but strings should be treated as atomic. - The depth of nested arrays is not limited, but you can assume that the input will not result in stack overflow for typical test cases. # Example: ```python assert flatten_nested_arrays([1, [2, [3, 4], 5], 6]) == [1, 2, 3, 4, 5, 6] assert flatten_nested_arrays([[\'a\', [\'b\', \'c\'], \'d\'], \'e\']) == [\'a\', \'b\', \'c\', \'d\', \'e\'] assert flatten_nested_arrays([[], [[]], [[[]]]]) == [] assert flatten_nested_arrays([1, \'string\', [2, \'more\', [\'nested\', \'strings\']]]) == [1, \'string\', 2, \'more\', \'nested\', \'strings\'] ``` # Requirements: - Your implementation should handle deeply nested lists efficiently. - Aim for a time complexity of O(n), where n is the total number of elements in the nested list. - Minimize the space complexity where possible, avoiding unnecessary memory usage. # Notes: - Think about edge cases like empty lists or lists containing only empty lists. - Be mindful of handling strings correctly as atomic units.","solution":"def flatten_nested_arrays(nested_list: list) -> list: Recursively flattens nested lists into a single-level list. flat_list = [] for item in nested_list: if isinstance(item, list): flat_list.extend(flatten_nested_arrays(item)) else: flat_list.append(item) return flat_list"},{"question":"# Question: Implement and Optimize Comb Sort with Custom Shrink Factor You are provided with a partially optimized comb sort algorithm. Your task is to: 1. Complete the implementation of the comb sort. 2. Optimize it by allowing a custom shrink factor, and ensure the sort works efficiently for various types of input. 3. Write a function `optimized_comb_sort` that accepts an array of integers and returns the sorted array. Function Signature ```python def optimized_comb_sort(arr: list, shrink: float) -> list: ``` Input - `arr`: A list of integers to be sorted. - `shrink`: A floating-point number indicating the shrink factor (common choices range from 1.3 to 1.5). Output - A sorted list of integers. Constraints - The shrink factor should be greater than 1.0 and less than 2.0 - The input list can have 1 to 10^4 integers - The integers can range between -10^6 and 10^6 Example ```python print(optimized_comb_sort([34, 8, 64, 51, 32, 21], 1.3)) # Output should be: [8, 21, 32, 34, 51, 64] print(optimized_comb_sort([5, 2, 9, 1, 5, 6], 1.5)) # Output should be: [1, 2, 5, 5, 6, 9] ``` Requirements - Your code should handle edge cases (like already sorted arrays, arrays with one element, arrays with all identical elements) - Optimize the gap reductions to enhance performance Consider different input scenarios provided in examples to ensure correctness.","solution":"def optimized_comb_sort(arr: list, shrink: float) -> list: Performs an optimized comb sort on the input list using the provided shrink factor. Parameters: arr (list): A list of integers to be sorted. shrink (float): A floating-point number indicating the shrink factor. Returns: list: The sorted list of integers. if not (1.0 < shrink < 2.0): raise ValueError(\\"Shrink factor should be greater than 1.0 and less than 2.0\\") n = len(arr) gap = n sorted = False while not sorted: gap = int(gap / shrink) if gap <= 1: gap = 1 sorted = True i = 0 while i + gap < n: if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False i += 1 return arr"},{"question":"**Problem Statement: Interpolation Search** You are given a sorted array of integers in increasing order. Your task is to implement the Interpolation Search algorithm to find the index of a given search key in the array. The function should return the index of the found element or `-1` if the element is not present. # Function Signature: ```python def interpolation_search(array: List[int], search_key: int) -> int: ... ``` # Input: - `array` (List[int]): The sorted array of integers to be searched. You may assume this array has unique elements. - `search_key` (int): The integer value to be searched within the array. # Output: - Returns an integer which is the index of the search_key in the array if found; otherwise, returns `-1`. # Constraints: - The elements of the array will be in the range of (-10^9) to (10^9). - The length of the array `n` will be between 0 and (10^6). - The function should have an average time complexity of (O(log log n)) and a worst-case time complexity of (O(n)). # Examples: 1. **Example 1**: ```python interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) ``` Output: ```python 2 ``` 2. **Example 2**: ```python interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) ``` Output: ```python -1 ``` 3. **Example 3**: ```python interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) ``` Output: ```python -1 ``` # Edge Cases to Consider: 1. When the array is empty. 2. When the search_key is not present in the array. 3. When the search_key is present multiple times in the array (though this won’t happen as per given constraint). Make sure to handle any edge cases and write a solution that optimizes both the time complexity as well as maintains the integrity of the algorithm.","solution":"def interpolation_search(array, search_key): Interpolation search function to find the index of the search_key in the sorted array. :param array: List[int]. A sorted list of integers. :param search_key: int. The integer value to search for. :return: int. The index of the search_key in the array, or -1 if not found. if not array: return -1 low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 pos = low + ((high - low) * (search_key - array[low]) // (array[high] - array[low])) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"Scenario: You\'re working on a project that involves analyzing sequences of data logs to identify periodic patterns. Your task is to write a function that determines if a given string can be constructed by repeating a smaller substring more than once. # Task: Write a function `is_repeated_substring(s: str) -> bool` that checks if a non-empty string can be constructed by taking a substring and appending multiple copies of the substring together. Function Signature: ```python def is_repeated_substring(s: str) -> bool: pass ``` Input: * `s` (string): A non-empty string consisting only of lowercase English letters. Output: * `bool`: Returns `True` if the string can be constructed by repeating a substring, `False` otherwise. Constraints: * The input string will have a length between 1 and 10,000. # Examples: ```python assert is_repeated_substring(\\"abab\\") == True # \\"ab\\" repeated twice assert is_repeated_substring(\\"aba\\") == False # No repeated substring assert is_repeated_substring(\\"abcabcabcabc\\") == True # \\"abc\\" repeated four times ``` # Performance Requirements: * Your solution should have a time complexity of O(n), where n is the length of the string. * Your solution should have a space complexity of O(n). # Additional Notes: * Consider all possible substrings and ensure your function handles edge cases appropriately. * Pay attention to potential performance bottlenecks and optimize for speed and memory efficiency where possible.","solution":"def is_repeated_substring(s: str) -> bool: Check if the string can be constructed by repeating a substring. n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: # i should be a divisor of n substring = s[:i] if substring * (n // i) == s: return True return False"},{"question":"# Question: Encode and Decode Elias Gamma and Delta Codes Given the implementations of Elias Gamma and Delta encoding, you are required to implement the decoding functions for these codes. The decoding functions must correctly revert an encoded Elias Gamma or Delta string back into the integer. **Function Signatures**: - `def decode_elias_gamma(code: str) -> int` - `def decode_elias_delta(code: str) -> int` Input and Output Formats - **decode_elias_gamma(code: str) -> int**: - **Input**: A string `code` containing the Elias Gamma encoded representation of an integer. - **Output**: The integer that was encoded. - **decode_elias_delta(code: str) -> int**: - **Input**: A string `code` containing the Elias Delta encoded representation of an integer. - **Output**: The integer that was encoded. Constraints - The code strings will be valid encoding strings created using the provided `elias_gamma` and `elias_delta` functions. - You can assume the encoded integers are positive. # Detailed Requirements 1. **Gamma Decoding**: - Find the length of the unary prefix which corresponds to 1 + ⌊log₂(x)⌋. - Calculate the binary part and combine it with the unary part to obtain the original integer. 2. **Delta Decoding**: - Decode the Elias Gamma part to find 1 + ⌊log₂(x)⌋. - Use this length to determine the binary part, and combine them to get the original integer. Example ```python # Gamma Encoding and Decoding encoded_gamma = elias_gamma(10) # \'0001010\' decoded_gamma = decode_elias_gamma(encoded_gamma) # 10 # Delta Encoding and Decoding encoded_delta = elias_delta(10) # \'00001010\' decoded_delta = decode_elias_delta(encoded_delta) # 10 ``` Write your implementations for the functions `decode_elias_gamma` and `decode_elias_delta`.","solution":"def decode_elias_gamma(code: str) -> int: Decodes an Elias Gamma encoded integer. Parameters: code (str): The Elias Gamma encoded string. Returns: int: The decoded integer. # Find the length of unary prefix unary_prefix_length = 0 while code[unary_prefix_length] == \'0\': unary_prefix_length += 1 # Total length of the original number\'s binary representation total_length = unary_prefix_length + 1 # Extract the binary part from the code (after the unary prefix) binary_part = code[unary_prefix_length: 2 * unary_prefix_length + 1] # Decode the integer return int(binary_part, 2) def decode_elias_delta(code: str) -> int: Decodes an Elias Delta encoded integer. Parameters: code (str): The Elias Delta encoded string. Returns: int: The decoded integer. # First, decode the Gamma part to get the length of the actual binary representation minus one unary_prefix_length = 0 while code[unary_prefix_length] == \'0\': unary_prefix_length += 1 # Total length of the Gamma encoded number gamma_length = unary_prefix_length + 1 # Extract the actual length of the binary representation length_binary_part = code[unary_prefix_length: 2 * unary_prefix_length + 1] length_of_binary = int(length_binary_part, 2) # Rest part of the code is the actual binary representation of the number minus one (1 << (length_of_binary - 1) will be added later) start_index = 2 * unary_prefix_length + 1 binary_part = code[start_index: start_index + length_of_binary - 1] # Decode the integer if binary_part: return (1 << (length_of_binary - 1)) + int(binary_part, 2) else: return 1 << (length_of_binary - 1)"},{"question":"# Question You are tasked to implement a modified version of the Cocktail Shaker Sort with an additional step considering elements could be repeated. Your task is to sort the array and then remove duplicates, but maintaining the order of the first occurrences of the elements. Input * A list of integers `arr` where `0 <= len(arr) <= 10^4`. Output * Returns a sorted list of integers with duplicates removed in the order of their first occurrences. Constraints * You cannot use any built-in functions that directly remove duplicates. * Do not use additional data structures (like sets or dictionaries). # Function Signature ```python def cocktail_shaker_sort_and_deduplicate(arr: list) -> list: # Your code here ``` # Example Example 1 ```python input: arr = [5, 1, 1, 2, 4, 7, 6, 1, 5] output: [1, 2, 4, 5, 6, 7] Explanation: The array is sorted as [1, 1, 1, 2, 4, 5, 5, 6, 7], then duplicate elements are removed leading to [1, 2, 4, 5, 6, 7]. ``` Example 2 ```python input: arr = [] output: [] Explanation: input array is empty. ``` # Notes * The key requirement is that sorting must be performed using Cocktail Shaker Sort, and duplicates should be removed so that their order of first appearance is preserved post sorting.","solution":"def cocktail_shaker_sort_and_deduplicate(arr): Sorts the array using Cocktail Shaker Sort and removes duplicates while maintaining the order of their first occurrences. n = len(arr) if n == 0: return arr start = 0 end = n - 1 while start <= end: swapped = False # Traverse from left to right like bubble sort for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If no element was swapped, the array is sorted already if not swapped: break # Otherwise, reset the flag for the next phase swapped = False # Update the end point for the inner loop end -= 1 # Traverse from right to left, doing the same comparison for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True # Update the start point for the next loop start += 1 # Remove duplicates while maintaining the order of their first occurrences result = [] for num in arr: if num not in result: result.append(num) return result"},{"question":"# Objective Conduct a comprehensive analysis of your understanding of Tries and Backtracking algorithms by implementing a function that finds all the words from a given list that can be formed in a word search grid. # Problem Description You\'re given a 2D board of characters and a list of words. Find all words in the board that exist in the given word list. Each word must be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. A word cannot use the same cell twice in one word. Function Signature ```python def find_words(board: List[List[str]], words: List[str]) -> List[str]: pass ``` # Input 1. `board`: A 2D list of characters (dimensions m x n). 2. `words`: A list of strings representing the set of words to find in the board. # Output - A list of strings representing the words found from the list in the board. # Constraints - The length of the word list `words` will be at most 10^3. - The length of each word will be at most 10. - The total number of cells `m x n` in the board will not exceed 12. - All words contain only lowercase English letters. # Example ```python board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] assert find_words(board, words) == [\\"oath\\", \\"eat\\"] ``` # Guidelines - Construct a trie from the given words for efficient search. - Use backtracking to explore all possible word paths starting from each cell in the board. - Ensure cells are not reused in the same word. - Prune the search path once it becomes clear that a valid word cannot be formed.","solution":"class TrieNode: def __init__(self): self.children = {} self.word = None def add_word(root, word): node = root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.word = word def find_words(board, words): def backtrack(row, col, parent): letter = board[row][col] curr_node = parent.children[letter] if curr_node.word: result.add(curr_node.word) curr_node.word = None # to avoid duplicate entries # Mark the cell as visited by replacing it with \'#\' board[row][col] = \'#\' for row_offset, col_offset in [(0, 1), (1, 0), (0, -1), (-1, 0)]: new_row, new_col = row + row_offset, col + col_offset if 0 <= new_row < len(board) and 0 <= new_col < len(board[0]): if board[new_row][new_col] in curr_node.children: backtrack(new_row, new_col, curr_node) # Restore the cell board[row][col] = letter root = TrieNode() for word in words: add_word(root, word) result = set() for row in range(len(board)): for col in range(len(board[0])): if board[row][col] in root.children: backtrack(row, col, root) return list(result)"},{"question":"You are given a list of student names, and you need to find the position of a specific student\'s name within this list. If the student\'s name is not present, return -1. Your task is to implement the function `find_student_index` to achieve this. # Function Signature ```python def find_student_index(names: List[str], student_name: str) -> int: pass ``` # Input - `names` (List[str]): A list of student names (strings). - `student_name` (str): The name of the student to search for. # Output - Returns the index (int) of the first occurrence of the student\'s name in the list. If not found, returns -1. # Constraints - The length of the list `names` will be between 0 and 10^5. - Each name in the list is a non-empty string. - The student\'s name to search for is a non-empty string. # Requirements - Must operate with linear time complexity O(n). - Do not use any libraries or built-in functions that perform the search for you. # Example ```python names = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Diana\\"] student_name = \\"Charlie\\" assert find_student_index(names, student_name) == 2 names = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"Diana\\"] student_name = \\"Eve\\" assert find_student_index(names, student_name) == -1 ``` # Scenario Consider a database in a university\'s student management system where you need to find a specific student\'s name in the database quickly. Implementing an efficient search functionality becomes crucial as the size of the student body grows. # Instructions: 1. Write the function `find_student_index` as described above. 2. Ensure your solution handles all described edge cases. 3. Test your code against the provided examples as well as additional test cases to ensure its correctness and efficiency.","solution":"from typing import List def find_student_index(names: List[str], student_name: str) -> int: Returns the index of the first occurrence of student_name in the list names. If the student_name is not found, returns -1. :param names: List of student names :param student_name: Name of the student to search for :return: Index of the first occurrence of student_name, or -1 if not found for index, name in enumerate(names): if name == student_name: return index return -1"},{"question":"Minimum Delete Operations to Make Strings Identical Problem Description Given two strings `word1` and `word2`, you are tasked with writing a function `min_distance_dp` that computes the minimum number of deletions required to make the two strings identical. Function Signature ```python def min_distance_dp(word1: str, word2: str) -> int: ``` Input - `word1` (a string, 1 <= len(word1) <= 500). - `word2` (a string, 1 <= len(word2) <= 500). Output - An integer representing the minimum number of deletion operations required. Examples 1. **Example 1**: - Input: `word1 = \\"sea\\", word2 = \\"eat\\"` - Output: `2` - Explanation: Deleting \'s\' from \\"sea\\" results in \\"ea\\", and deleting \'t\' from \\"eat\\" also results in \\"ea\\". Thus, 2 operations. 2. **Example 2**: - Input: `word1 = \\"abcd\\", word2 = \\"bace\\"` - Output: `4` - Explanation: Deleting \'d\' from \\"abcd\\" and `ce` from \\"bace\\" results in \\"abc\\" and \\"ba\\". Constraints - Your solution should handle the above input limits efficiently. - Aim to achieve a low runtime complexity and consider time-space tradeoffs. Additional Requirements - Perform input validation to handle edge cases such as empty strings appropriately. - Optimize the solution to work within given bounds.","solution":"def min_distance_dp(word1: str, word2: str) -> int: Returns the minimum number of deletions required to make the two strings identical. m, n = len(word1), len(word2) # Create a dp table dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp table for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The length of longest common subsequence lcs_length = dp[m][n] # Minimum deletions required min_deletions = (m - lcs_length) + (n - lcs_length) return min_deletions"},{"question":"You are implementing a simulation system that models various colored balls. The balls can be one of three colors: red, white, or blue, represented by the integers 0, 1, and 2 respectively. Given an array of balls, you need to write a function `sort_colors` that sorts the balls such that the balls of the same color are next to each other and in the order red (0), white (1), and blue (2). # Function Signature ```python def sort_colors(nums: List[int]) -> None: Sorts the input list nums in-place such that balls of the same color are adjacent, and the colors are in the order of red (0), white (1), and blue (2). Args: nums (List[int]): A list of integers where 0 represents red, 1 represents white, and 2 represents blue. Returns: None: The function modifies the list in-place and returns None. ``` # Input and Output * **Input**: - nums: a list of integers, where each integer is either 0, 1, or 2. * **Output**: - The function should modify the input list in-place to sort it as specified and should not return any value. # Constraints * The length of the array `n` can be in the range [0, 10^5]. * Do not use the library\'s sort function; implement the sort in-place. * Try to maintain a time complexity of O(n). # Example ```python nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output should be [0, 0, 1, 1, 2, 2] ``` # Notes Consider edge cases such as: 1. An empty list `[]`. 2. An already sorted list `[0, 0, 1, 1, 2, 2]`. 3. A list with all elements the same `[1, 1, 1, 1, 1]`. **Your task** is to implement the `sort_colors` function according to the specifications and constraints provided.","solution":"def sort_colors(nums): Sorts the input list nums in-place such that balls of the same color are adjacent, and the colors are in the order of red (0), white (1), and blue (2). Args: nums (List[int]): A list of integers where 0 represents red, 1 represents white, and 2 represents blue. Returns: None: The function modifies the list in-place and returns None. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: # nums[mid] == 2 nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"# Context You are required to implement a Binary Tree data structure and various algorithms to perform operations on it. Understanding these fundamental tree operations is essential for solving more complex problems efficiently. # Problem Statement Implement the following functions: 1. **min_depth(root: TreeNode) -> int**: - Compute the minimum depth of a binary tree. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. 2. **print_tree(root: TreeNode) -> None**: - Print the values of the nodes of the tree using pre-order traversal. # Constraints - Assume all node values are integers. - The tree can contain up to 10,000 nodes. - Node values can be positive or negative. # Function Definitions ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_depth(root: TreeNode) -> int: # Your implementation here pass def print_tree(root: TreeNode) -> None: # Your implementation here pass ``` # Example ```python # Example usage: tree = TreeNode(10) tree.left = TreeNode(12) tree.right = TreeNode(15) tree.left.left = TreeNode(25) tree.left.left.right = TreeNode(100) tree.left.right = TreeNode(30) tree.right.left = TreeNode(36) print_tree(tree) # Expected output: # 10 12 25 100 30 15 36 depth = min_depth(tree) print(\\"Minimum Depth:\\", depth) # Expected output: # Minimum Depth: 3 ``` # Requirements - Ensure your `min_depth` function efficiently computes the minimum depth without redundantly processing nodes. - Your `print_tree` function must display node values in the correct order as shown in the example. - Handle edge cases such as empty trees (root is `None`).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_depth(root: TreeNode) -> int: if not root: return 0 queue = [(root, 1)] while queue: node, depth = queue.pop(0) if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) def print_tree(root: TreeNode) -> None: def pre_order(node): if not node: return print(node.val, end=\\" \\") pre_order(node.left) pre_order(node.right) pre_order(root) print() # for new line after printing all elements"},{"question":"# Rotate Array Problem Scenario You are developing a feature in a game where players can move an array of prizes to the right by a certain number of steps. This feature should be efficient and handle various edge cases. Task Write a function `rotate_array` that rotates an array of `n` elements to the right by `k` steps. You need to implement this function using the in-place method (similar to `rotate_v2`). Input and Output Format * **Input**: * `array`: a list of integers representing the array to be rotated. * `k`: an integer representing the number of steps to rotate the array to the right. * **Output**: * The rotated array (in-place), i.e., do not return anything from the function. Modify the array directly. * **Constraints**: * 0 ≤ len(array) ≤ 10^5 * 0 ≤ k ≤ 10^9 # Function Signature ```python def rotate_array(array: List[int], k: int) -> None: pass ``` Examples 1. Example 1: ```python array = [1, 2, 3, 4, 5, 6, 7] k = 3 rotate_array(array, k) # After calling the function, array should be modified to [5, 6, 7, 1, 2, 3, 4] ``` 2. Example 2: ```python array = [-1, -100, 3, 99] k = 2 rotate_array(array, k) # After calling the function, array should be modified to [3, 99, -1, -100] ``` Requirements * Ensure the function handles large values of `k` efficiently. * Take into account edge cases such as an empty array or when `k` is much larger than the array length. * Aim to achieve O(n) time complexity and O(1) additional space complexity.","solution":"from typing import List def rotate_array(array: List[int], k: int) -> None: Rotates the array to the right by k steps in-place. n = len(array) if n == 0: return k = k % n # Normalize k to handle cases where k > n if k == 0: return # Reverse the whole array reverse(array, 0, n - 1) # Reverse the first k elements reverse(array, 0, k - 1) # Reverse the remaining n-k elements reverse(array, k, n - 1) def reverse(array: List[int], start: int, end: int) -> None: Helper function to reverse elements in the array from index start to end. while start < end: array[start], array[end] = array[end], array[start] start += 1 end -= 1"},{"question":"Remove Range from Linked List Context Imagine you are working on a project that involves maintaining a large dataset in a linked list format. You are tasked with writing a function that can remove a segment of the dataset based on specific start and end indices. Task Write a function `remove_range_optimized` that takes the head of a linked list and two indices, `start` and `end`, and efficiently removes all elements from index `start` to index `end` (inclusive). ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_range_optimized(head, start, end): # Your code here ``` Function Specifications **Input**: * `head`: The head node of a singly linked list (`ListNode` type). * `start`: An integer representing the starting index (inclusive). * `end`: An integer representing the ending index (inclusive). **Output**: * The function should return the head of the modified linked list. **Constraints**: * The start and end indices will always be valid (0 <= start <= end < size of the list where size is the number of nodes in the list). Example ```python # Example linked list creation node6 = ListNode(92) node5 = ListNode(0, node6) node4 = ListNode(23, node5) node3 = ListNode(7, node4) node2 = ListNode(41, node3) node1 = ListNode(98, node2) head = ListNode(12, node1) head = ListNode(9, head) head = ListNode(4, head) head = ListNode(17, head) head = ListNode(13, head) head = ListNode(8, head) # Example function call new_head = remove_range_optimized(head, 3, 8) # Expected linked list: [8 -> 13 -> 17 -> 23 -> 0 -> 92] ``` Requirements * Ensure to handle edge cases such as the start index being 0 or end index being the last element in the list. * Try to minimize the traversal to just once over the linked list to improve efficiency. * Include error handling for potential scenarios where the provided start and end indices might not be in sequence or exceed the list boundaries.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_range_optimized(head, start, end): Removes elements from index start to index end (inclusive) from the linked list. dummy = ListNode(0) # Create a dummy node to handle edge cases dummy.next = head prev = dummy # Move prev to the node before the start position for _ in range(start): prev = prev.next # Remove the nodes from start to end current = prev.next for _ in range(end - start + 1): current = current.next # Link the previous part to the part after the end prev.next = current return dummy.next"},{"question":"# Question: Optimize Selection Sort and Add Stability Selection Sort is a simple sorting algorithm that, unfortunately, is not stable and has a quadratic time complexity. Your task is to optimize the given implementation of Selection Sort and modify it to make it stable while maintaining O(n^2) complexity. **Function Signature**: ```python def stable_selection_sort(arr: List[int]) -> List[int]: Sorts the array using an optimized stable selection sort algorithm. ``` # Requirements: 1. **Input**: A list of integers **arr** where 1 <= len(arr) <= 10^3. 2. **Output**: A new list where elements are sorted in non-decreasing order. 3. **Stability**: The algorithm must maintain the relative order of equal elements. # Constraints: 1. The algorithm should be as optimized as possible but must retain O(n^2) complexity. 2. Avoid using in-built sorting functions. # Example: ```python Input: [4, 3, 2, 4, 1] Output: [1, 2, 3, 4, 4] ``` # Explanation: In the example, the two `4`s are in the same relative order after sorting as they were in the original array, hence the algorithm is stable. Use your understanding of selection sort as the starting point. Consider how you can tweak the selection process or the swap operations to maintain stability.","solution":"from typing import List def stable_selection_sort(arr: List[int]) -> List[int]: Sorts the array using an optimized stable selection sort algorithm. n = len(arr) # One by one move the boundary of the unsorted subarray for i in range(n): # Find the minimum element in the unsorted array min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j # Move the minimum element at the beginning of the unsorted array key = arr[min_idx] # Shift all elements to the right of min_idx while min_idx > i: arr[min_idx] = arr[min_idx - 1] min_idx -= 1 arr[i] = key return arr"},{"question":"# Creating a Resizable Hash Table with Quadratic Probing **Objective**: Implement a resizable hash table (`ResizableHashTable`) that uses quadratic probing for collision resolution. # Requirements 1. **Hash Function**: - Implement a custom `hash_function` that accepts a key and returns an integer value. - This function should minimize collisions for a diverse set of keys. 2. **Quadratic Probing**: - Modify the put and get methods to utilize quadratic probing instead of linear probing. - Quadratic probing calculates new index as `(hash + i^2) % size` where `i` is the number of collisions for the current operation. 3. **Resizing**: - Ensure the hash table doubles in size when the number of elements reaches at least two-thirds of the table capacity. - Rehash all existing key-value pairs after resizing. 4. **Operations**: - Implement methods for inserting (`put`), retrieving (`get`), and deleting (`del_`) key-value pairs. - Preserve the functionalities from the initial code snippet (len, in, __getitem__, __setitem__, __delitem__). # Input/Output Formats - **Input**: - `key` (integer): The key to insert, retrieve, or delete. - `value` (any): The value corresponding to the key (for insert operation). - **Output**: - Varies depending on the operation. Insert returns nothing, retrieve returns the value or None, and delete returns nothing. # Constraints - Key space can be large, so ensure your hash function distributes keys uniformly. - Handle all edge cases, such as inserting None values or deleting non-existent keys. # Example Scenario ```python # Create a resizable hash table hash_table = ResizableHashTable() # Insert key-value pairs hash_table.put(10, \'apple\') hash_table.put(20, \'banana\') hash_table.put(30, \'cherry\') # Retrieve values print(hash_table.get(10)) # Output: \'apple\' print(hash_table.get(40)) # Output: None # Delete a key hash_table.del_(20) # Attempt to retrieve deleted key print(hash_table.get(20)) # Output: None # Length of hash table print(len(hash_table)) # Output: 2 (keys 10 and 30 are still present) ``` # Notes - Ensure your implementation handles dynamic resizing efficiently and maintains performance close to O(1) on average for all operations. - Document and test your code thoroughly.","solution":"class ResizableHashTable: def __init__(self, initial_capacity=8): self.capacity = initial_capacity self.size = 0 self.table = [None] * self.capacity def hash_function(self, key): return key % self.capacity def put(self, key, value): if self.size >= 2 / 3 * self.capacity: self.resize() index = self.hash_function(key) i = 0 while self.table[(index + i ** 2) % self.capacity] is not None and self.table[(index + i ** 2) % self.capacity][0] != key: i += 1 self.table[(index + i ** 2) % self.capacity] = (key, value) self.size += 1 def get(self, key): index = self.hash_function(key) i = 0 while self.table[(index + i ** 2) % self.capacity] is not None: if self.table[(index + i ** 2) % self.capacity][0] == key: return self.table[(index + i ** 2) % self.capacity][1] i += 1 return None def del_(self, key): index = self.hash_function(key) i = 0 while self.table[(index + i ** 2) % self.capacity] is not None: if self.table[(index + i ** 2) % self.capacity][0] == key: self.table[(index + i ** 2) % self.capacity] = None self.size -= 1 return i += 1 def resize(self): old_table = self.table self.capacity *= 2 self.size = 0 self.table = [None] * self.capacity for item in old_table: if item is not None: self.put(item[0], item[1]) def __len__(self): return self.size def __contains__(self, key): return self.get(key) is not None def __getitem__(self, key): result = self.get(key) if result is None: raise KeyError(f\'Key {key} not found in hash table.\') return result def __setitem__(self, key, value): self.put(key, value) def __delitem__(self, key): if key not in self: raise KeyError(f\'Key {key} not found in hash table.\') self.del_(key)"},{"question":"You are tasked with implementing a function to sort an array of integers using Bogo Sort. However, to demonstrate your understanding of more efficient algorithms and their properties, you should also provide an optimized solution using a more practical sorting method. You will write two functions: 1. **bogo_sort(arr)**: A function to sort the array using Bogo Sort. 2. **quick_sort(arr)**: A function to sort the array using Quick Sort. # Input Format 1. **bogo_sort(arr)**: - Takes a list `arr` of integers as input. 2. **quick_sort(arr)**: - Takes a list `arr` of integers as input. # Output Format 1. **bogo_sort(arr)**: - Returns the sorted list of integers. 2. **quick_sort(arr)**: - Returns the sorted list of integers. # Constraints - The length of the list `arr` will be between 1 and 100 (for quick_sort). Use smaller sizes for testing bogo_sort, such as length between 1 and 5. - The integers in `arr` will be in the range -1000 to 1000. # Performance Requirements - **bogo_sort(arr)**: No specific performance requirements other than the implementation of Bogo Sort. - **quick_sort(arr)**: Expected to perform significantly better than Bogo Sort, with average-case time complexity of O(n log n). # Function Signature ```python def bogo_sort(arr: List[int]) -> List[int]: pass def quick_sort(arr: List[int]) -> List[int]: pass ``` # Example Input ```python arr = [3, 2, 1] ``` Output ```python # Using Bogo Sort print(bogo_sort(arr)) # [1, 2, 3], eventually # Using Quick Sort print(quick_sort(arr)) # [1, 2, 3] ``` # Notes - Explain in your comments the basic idea behind the Quick Sort implementation. - Compare and contrast the performance of the two sorting methods in comments. - Provide a small test suite to validate both sorting methods.","solution":"import random def bogo_sort(arr): Bogo Sort is a highly inefficient sorting algorithm based on the generate and test paradigm. It successively generates permutations of its input until it finds one that is sorted. def is_sorted(arr): return all(arr[i] <= arr[i+1] for i in range(len(arr) - 1)) while not is_sorted(arr): random.shuffle(arr) return arr def quick_sort(arr): Quick Sort is an efficient sorting algorithm that uses the divide and conquer approach. It picks an element as a pivot and partitions the given array around the picked pivot. The array is divided into two halves based on the pivot, and recursively sorted. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"# Counting Sort Function Implementation Challenge Objective Write a function implementing Counting Sort to sort an array of integers, including cases with negative numbers. Function Signature ```python def counting_sort(arr: List[int]) -> List[int]: ``` Input * `arr`: List of integers. The integers can be negative, zero or positive. The length of `arr` is `n` (1 ≤ `n` ≤ 10^5). Output * Returns a new list of integers sorted in non-decreasing order. Constraints * The integers in `arr` are within the range of -10^5 to 10^5. Instructions 1. Ensure the function handles negative numbers correctly. 2. Consider the efficiency of the function in terms of both time and space complexities. 3. Ensure stability (the relative order of elements with the same value remains the same). Example ```python # Example input arr = [-5, -10, 0, -3, 8, 5, -1, 10] # Example output [-10, -5, -3, -1, 0, 5, 8, 10] ``` # Additional Notes 1. Do not use built-in sorting functions. 2. Focus on writing clear and efficient code with comments where necessary. 3. Think about edge cases such as arrays with duplicate values or all elements being the same.","solution":"from typing import List def counting_sort(arr: List[int]) -> List[int]: if not arr: return arr # Find the minimum and maximum values in the array min_value = min(arr) max_value = max(arr) # Create a count array with size based on the range of the input values range_of_elements = max_value - min_value + 1 count = [0] * range_of_elements # Store the count of each element for num in arr: count[num - min_value] += 1 # Update the count array to store cumulative count for i in range(1, range_of_elements): count[i] += count[i - 1] # Create output array to store sorted elements output = [0] * len(arr) # Build the output array using the cumulative count for num in reversed(arr): output[count[num - min_value] - 1] = num count[num - min_value] -= 1 return output"},{"question":"# Flatten Nested Arrays You are given two functions that flatten nested arrays (or more generally, any iterable except strings) into a single-level array. The first function `flatten` returns a list, while the second function `flatten_iter` returns an iterator. You are required to implement the function `flatten_iter` iteratively without using recursion. Function Signature ```python def flatten_iter(iterable: Iterable) -> Iterable: # Write your code here pass ``` Input - An nested iterable, which could have lists nested to an arbitrary depth. Output - A single-level iterable where all nested elements are flattened. Constraints - You must not use recursion. - The input may include any combination of integers, floats, strings, and nested lists. Example ```python # Provided example print(list(flatten_iter([1, [2, [3, 4], 5], 6, [[7], 8]]))) # Output: [1, 2, 3, 4, 5, 6, 7, 8] # Additional cases print(list(flatten_iter([]))) # Output: [] print(list(flatten_iter([[], [1, [2, [3]], 4], []]))) # Output: [1, 2, 3, 4] print(list(flatten_iter([\'a\', [\'b\', [\'c\']]]))) # Output: [\'a\', \'b\', \'c\'] print(list(flatten_iter([[1, [2]], \'text\', [\'a\', [\'b\']]]))) # Output: [1, 2, \'text\', \'a\', \'b\'] ``` Note - Test edge cases such as nested empty lists or deeply nested structures. - Ensure that the solution handles strings correctly, i.e., it should not iterate over characters of the string or flatten them. Performance Requirements - Time complexity should be O(n), where n is the number of elements. - Avoid excess memory usage or stack overflow errors.","solution":"from collections.abc import Iterable def flatten_iter(iterable: Iterable) -> Iterable: Flattens a nested iterable into a single-level iterable. stack = [iter(iterable)] while stack: try: current = next(stack[-1]) if isinstance(current, Iterable) and not isinstance(current, (str, bytes)): stack.append(iter(current)) else: yield current except StopIteration: stack.pop()"},{"question":"# Context Separate Chaining Hash Tables are a common way to implement hash tables where collisions are handled by chaining elements in the same bucket using a linked list. In this problem, we will enhance our understanding of this data structure by extending its capabilities. # Problem Statement Modify the `SeparateChainingHashTable` to have the following additional functionalities: 1. **Resize**: Implement an automatic resize mechanism where the hash table doubles its size when the load factor exceeds 0.75 and rehashes all existing keys. 2. **Keys and Values**: Implement methods to return all keys and all values currently stored in the hash table. # Specifications 1. Implement the following methods in the `SeparateChainingHashTable` class: - `def resize(self):` - `def keys(self): -> list` - `def values(self): -> list` 2. The `resize` method should double the size of the underlying array and rehash all current elements. # Expected Function Signatures ```python class SeparateChainingHashTable: ... def resize(self): # Resizes the hash table and rehashes all elements def keys(self) -> list: # Returns a list of all keys in the hash table def values(self) -> list: # Returns a list of all values in the hash table ``` # Constraints - The maximum number of operations (put, get, del_) is 10^5. - The maximum unique keys are 10^4. # Examples ```python table = SeparateChainingHashTable() table.put(\'apple\', 1) table.put(\'banana\', 2) table.put(\'grape\', 3) print(table.keys()) # [\'apple\', \'banana\', \'grape\'] print(table.values()) # [1, 2, 3] table.resize() print(len(table._table)) # Should reflect new size after resizing # Insert more values to trigger resize for i in range(100): table.put(f\'key{i}\', i) # Check if all values are still accessible after resize assert table.get(\'apple\') == 1 assert table.get(\'banana\') == 2 assert table.get(\'grape\') == 3 assert table.get(\'key99\') == 99 ```","solution":"class SeparateChainingHashTable: def __init__(self, initial_capacity=8): self._capacity = initial_capacity self._size = 0 self._table = [[] for _ in range(self._capacity)] def _hash(self, key): return hash(key) % self._capacity def put(self, key, value): if self._size / self._capacity > 0.75: self.resize() index = self._hash(key) for kvp in self._table[index]: if kvp[0] == key: kvp[1] = value return self._table[index].append([key, value]) self._size += 1 def get(self, key): index = self._hash(key) for kvp in self._table[index]: if kvp[0] == key: return kvp[1] return None def del_(self, key): index = self._hash(key) for i, kvp in enumerate(self._table[index]): if kvp[0] == key: self._table[index].pop(i) self._size -= 1 return def resize(self): new_capacity = self._capacity * 2 new_table = [[] for _ in range(new_capacity)] for bucket in self._table: for kvp in bucket: new_index = hash(kvp[0]) % new_capacity new_table[new_index].append(kvp) self._capacity = new_capacity self._table = new_table def keys(self): result = [] for bucket in self._table: for kvp in bucket: result.append(kvp[0]) return result def values(self): result = [] for bucket in self._table: for kvp in bucket: result.append(kvp[1]) return result"},{"question":"# Palindromic Linked List Check Given a singly linked list, implement a function that checks whether the list is a palindrome. You are provided with three different code snippets that check for palindromes using different methods. Understand the logic and characteristics of these methods before implementing your own solution. **Function Signature:** ```python def is_palindrome_improved(head): # Your code here ``` # Input * The input `head` is the head node of a singly linked list where each node has the following structure: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` # Output * Return `True` if the linked list is a palindrome, otherwise return `False`. # Constraints * The number of nodes in the list is in the range `[0, 10^5]`. * `-10^5 <= Node.val <= 10^5` # Performance Requirements * The solution must operate in O(n) time complexity and use O(1) additional space (i.e., in-place changes and constant extra space). # Examples ```python # Example 1 # Input: head = [1, 2, 2, 1] # Output: True # Example 2 # Input: head = [1, 2] # Output: False ``` # Scenario / Context You are tasked with improving upon the methods provided to ensure the most efficient and memory-conscious implementation. In a real-time data processing system where memory constraints are critical, achieving the required task with minimal memory overhead is imperative.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome_improved(head): if not head: return True # Step 1: Find the end of the first half and reverse the second half def reverse_list(head): previous = None current = head while current: next_node = current.next current.next = previous previous = current current = next_node return previous def end_of_first_half(head): fast = head slow = head while fast.next and fast.next.next: fast = fast.next.next slow = slow.next return slow first_half_end = end_of_first_half(head) second_half_start = reverse_list(first_half_end.next) # Step 2: Check whether there is a palindrome result = True first_position = head second_position = second_half_start while result and second_position: if first_position.val != second_position.val: result = False first_position = first_position.next second_position = second_position.next # Step 3: Restore the list and return the result first_half_end.next = reverse_list(second_half_start) return result"},{"question":"# Problem: Secure Communication Setup In the field of information security, one common problem is to securely establish a communication channel between two parties. One way to do this is through the Diffie-Hellman key exchange protocol, which relies on computing large powers with a modulus efficiently. You are required to implement a function that computes the modular exponentiation of given integers. This method must be efficient to handle large numbers commonly used in cryptography. Function Signature ```python def secure_modular_exponentiation(base: int, exponent: int, mod: int) -> int: ``` Input - `base` (0 <= base <= 10^9): The base number. - `exponent` (0 <= exponent <= 10^9): The exponent to be applied on the base. - `mod` (2 <= mod <= 10^9): The modulus value to ensure results are within certain bounds. Output - Returns `(base ** exponent) % mod` as an integer. Constraints - Time complexity should be `O(log exponent)`. - Space complexity should be `O(1)`. - The exponent should be non-negative. Example ```python assert secure_modular_exponentiation(4, 13, 497) == 445 assert secure_modular_exponentiation(2, 10, 1024) == 0 assert secure_modular_exponentiation(7, 256, 13) == 9 assert secure_modular_exponentiation(5, 0, 123) == 1 ``` In these examples: 1. `4^13 % 497 = 445` 2. `2^10 % 1024 = 0` 3. `7^256 % 13 = 9` 4. `5^0 % 123 = 1` (any number to the power of 0 is 1 mod any number) Note Remember to handle possible edge cases where the base or exponent might be zero.","solution":"def secure_modular_exponentiation(base: int, exponent: int, mod: int) -> int: Computes (base ** exponent) % mod using an efficient algorithm called modular exponentiation by squaring. result = 1 base = base % mod while exponent > 0: if (exponent % 2) == 1: # If exponent is odd result = (result * base) % mod exponent = exponent >> 1 # Divide the exponent by 2 base = (base * base) % mod # Square the base return result"},{"question":"You are given two non-negative integers, A and B. Your task is to write a function that determines the minimal number of bits you would need to flip to convert integer A to integer B. # Implementation Requirements Implement the function `count_flips_to_convert(a: int, b: int) -> int` that takes two non-negative integers `a` and `b` and returns the minimal number of bits that need to be flipped to transform `a` to `b`. # Input and Output * **Input**: * `a` and `b` are non-negative integers (0 <= a, b <= 10^9). * **Output**: * A single integer representing the minimal number of bit flips required. # Constraints * The function should be optimized to run in O(n) time complexity where n is the number of bits in the integer. # Examples 1. **Example 1:** * Input: `a = 29`, `b = 15` * Output: `2` * Explanation: 29 in binary is `11101`, and 15 in binary is `01111`. There are 2 bits that differ (the second and the third from the right). 2. **Example 2:** * Input: `a = 0`, `b = 7` * Output: `3` * Explanation: 0 in binary is `00000`, and 7 in binary is `00111`. There are 3 bits that differ. 3. **Example 3:** * Input: `a = 5`, `b = 5` * Output: `0` * Explanation: No bits need to be flipped since both integers are the same. # Additional Notes * Ensure your function handles very large integers efficiently. * Consider edge cases such as very small input values or when both inputs are the same. # Function Signature ```python def count_flips_to_convert(a: int, b: int) -> int: pass ```","solution":"def count_flips_to_convert(a, b): Returns the minimal number of bits that need to be flipped to transform `a` to `b`. Parameters: a (int): The initial integer. b (int): The target integer. Returns: int: The number of bits to be flipped. # XOR of a and b will give us a number where each bit is 1 if the corresponding bits of a and b are different xor_val = a ^ b # Count the number of 1s in the binary representation of xor_val count = 0 while xor_val: xor_val = xor_val & (xor_val - 1) # This operation reduces the number of set bits by one count += 1 return count"},{"question":"# Question You are given an unsorted list of integers. Your task is to implement the Pancake Sort algorithm to sort the list. Pancake Sorting is a variation of the selection sort wherein you repeatedly flip (reverse) subarrays to move the largest unsorted element to its correct position. Write a function `pancake_sort(arr)` that takes in a list of integers `arr` and returns a new list that is the sorted version of `arr`. Input Format - A list of integers `arr` with `1 <= len(arr) <= 1000`, and `-10^6 <= arr[i] <= 10^6`. Output Format - A list of integers which is the sorted version of the input list. # Example ```python pancake_sort([3, 2, 4, 1]) # Output: [1, 2, 3, 4] pancake_sort([10, 5, 7, 3, 2]) # Output: [2, 3, 5, 7, 10] ``` Constraints - You should ensure that your function runs within acceptable time, given the constraints. # Explanation To help understand your implementation, provide a brief explanation of how your function achieves the sorting using the Pancake Sort algorithm. This can include details about how you find the maximum element in each iteration, and how you use reversals to move it to its correct position.","solution":"def flip(arr, k): Reverses the order of the first k elements in the array arr. arr[:k] = arr[:k][::-1] def find_max_index(arr, n): Finds the index of the maximum element in arr upto the first n elements. return max(range(n), key=lambda i: arr[i]) def pancake_sort(arr): Sorts the array arr using the Pancake Sort algorithm. n = len(arr) for size in range(n, 1, -1): # Find the index of the maximum element in arr[0:size] max_index = find_max_index(arr, size) # If max element is not at its final position, move it if max_index != size - 1: # First flip to move max element to index 0 flip(arr, max_index + 1) # Second flip to move max element to its final position flip(arr, size) return arr"},{"question":"# Problem: Enhanced Bogo Sort **Background**: Alice is learning about sorting algorithms in her computer science class. She has encountered the Bogo Sort algorithm and finds it fascinating despite its impracticality. She wants to explore it further by implementing a slightly modified version that stops after a certain number of iterations, even if the array is not sorted, to avoid infinite loops. **Objective**: Write a function called `enhanced_bogo_sort` that sorts an array using a modification of the Bogo Sort algorithm. The function should randomly shuffle the array and check if it is sorted. However, it should stop after a specified number of iterations, even if the array is not sorted. **Function Signature**: ```python def enhanced_bogo_sort(arr: list, max_iterations: int) -> list: pass ``` **Expected Input and Output**: * **Input**: * `arr` - A list of integers, which can be empty or contain duplicates. * `max_iterations` - An integer indicating the maximum number of iterations before the algorithm stops. * **Output**: * Returns the sorted array if it gets sorted within the given number of iterations, otherwise returns the array in its current state. **Constraints**: * `len(arr)` can be between 0 and 1000. * `0 <= max_iterations <= 10^6`. * The elements in `arr` are integers in the range ([-10^9, 10^9]). **Example**: ```python arr = [3, 2, 5, 1, 4] max_iterations = 100 print(enhanced_bogo_sort(arr, max_iterations)) # Example output: [1, 2, 3, 4, 5] if sorted, or some partially sorted array otherwise arr = [1, 2, 3, 4, 5] max_iterations = 10 print(enhanced_bogo_sort(arr, max_iterations)) # Output: [1, 2, 3, 4, 5] arr = [5, 4, 3, 2, 1] max_iterations = 0 print(enhanced_bogo_sort(arr, max_iterations)) # Output: [5, 4, 3, 2, 1] ``` **Performance Requirements**: * The function should handle arrays with up to 1000 elements efficiently within the constraints of max_iterations. **Additional Notes**: * Consider edge cases such as an already sorted array, arrays with one element, and very large `max_iterations` values. * Use built-in functions where appropriate to manage array shuffling and checks. Good luck!","solution":"import random def is_sorted(arr): Helper function to check if the array is sorted. return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) def enhanced_bogo_sort(arr, max_iterations): Sort the array using an enhanced version of Bogo Sort. If the array is not sorted within the given number of iterations, return the best effort sorted array. :param arr: List of integers to be sorted :param max_iterations: Maximum number of iterations to attempt sorting :return: Sorted array if possible, or best effort sorted array otherwise iterations = 0 while iterations < max_iterations: if is_sorted(arr): break random.shuffle(arr) iterations += 1 return arr"},{"question":"Question: Generate All Abbreviations of a Word # Scenario: You are working on a text compression tool that needs to generate all possible abbreviations for a given word. An abbreviation can replace any number of contiguous characters with a numeric count of those characters. # Task: Write a function `generate_abbreviations(word: str) -> List[str]` that receives a single string input and returns a list of all possible abbreviations of the input word. # Input: - `word`: a string with 1 ≤ len(word) ≤ 20, consisting of only lowercase alphabetic characters. # Output: - The function should return a list of strings representing all possible abbreviations of the input word. # Constraints: - Ensure that the function performs efficiently under the given constraints. - Handle cases where the input string is very short or very long within the specified range. # Example: ```python word = \\"word\\" # Possible abbreviations: # [\'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', # \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', # \'2rd\', \'2r1\', \'3d\', \'4\'] generate_abbreviations(\\"word\\") ``` # Performance Requirement: Given the constraint that the input word length is at most 20, your solution should aim to efficiently generate all possible abbreviations, keeping both time and space complexity within reasonable bounds.","solution":"from typing import List def generate_abbreviations(word: str) -> List[str]: def backtrack(pos: int, cur: str, count: int, res: List[str]): if pos == len(word): if count > 0: cur += str(count) res.append(cur) else: # Abbreviate this character backtrack(pos + 1, cur, count + 1, res) # Keep this character backtrack(pos + 1, cur + (str(count) if count > 0 else \'\') + word[pos], 0, res) result = [] backtrack(0, \'\', 0, result) return result"},{"question":"# Question: Transitive Closure Matrix of a Directed Graph Context Given a directed graph with a set number of vertices, you are tasked with determining the reachability of all pairs of vertices. Specifically, you need to construct the transitive closure matrix of the graph, where matrix[i][j] is 1 if a path exists from vertex i to vertex j, otherwise 0. Task Complete the following function: ```python from typing import List def find_transitive_closure(vertex_count: int, edges: List[tuple]) -> List[List[int]]: Finds and returns the transitive closure matrix of a given directed graph. Args: vertex_count (int): The number of vertices in the graph. edges (List[tuple]): A list of tuples, where each tuple (source, target) represents a directed edge in the graph. Returns: List[List[int]]: A matrix of size vertex_count x vertex_count representing the transitive closure of the graph. # Your code here ``` * **Inputs**: * `vertex_count` is an integer representing the number of vertices (0-indexed) in the directed graph. * `edges` is a list of tuples, where each tuple (source, target) represents a directed edge between vertices `source` and `target`. * **Outputs**: * A 2D list (matrix) of size vertex_count x vertex_count that represents the transitive closure of the graph. If there is a path from vertex i to vertex j, matrix[i][j] should be 1; otherwise, 0. * **Constraints**: * All vertices are distinct. * The number of vertices is at least 1 and at most 500. * The number of edges is at most 5000. Example ```python # Example Input vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3)] # Example Output closure_matrix = find_transitive_closure(vertex_count, edges) # Expected closure_matrix: # [[1, 1, 1, 1], # [0, 1, 1, 1], # [0, 0, 1, 1], # [0, 0, 0, 1]] ``` Your implementation will be evaluated based on correctness, efficiency, and clarity.","solution":"from typing import List def find_transitive_closure(vertex_count: int, edges: List[tuple]) -> List[List[int]]: Finds and returns the transitive closure matrix of a given directed graph. Args: vertex_count (int): The number of vertices in the graph. edges (List[tuple]): A list of tuples, where each tuple (source, target) represents a directed edge in the graph. Returns: List[List[int]]: A matrix of size vertex_count x vertex_count representing the transitive closure of the graph. # Initialize the closure matrix with 0\'s closure_matrix = [[0] * vertex_count for _ in range(vertex_count)] # Populating the initial reachability based on direct edges for i in range(vertex_count): closure_matrix[i][i] = 1 # Every vertex can reach itself for source, target in edges: closure_matrix[source][target] = 1 # Floyd-Warshall algorithm to compute transitive closure for k in range(vertex_count): for i in range(vertex_count): for j in range(vertex_count): closure_matrix[i][j] = closure_matrix[i][j] or (closure_matrix[i][k] and closure_matrix[k][j]) return closure_matrix"},{"question":"You are given a sorted list of integers, and two other integers `lo` and `hi`. Your task is to write a function `potential_gaps` that identifies the ranges of missing numbers between `lo` and `hi`. # Function Signature: ```python def potential_gaps(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: ``` # Input: * `arr`: A sorted list of integers which can be empty or contain duplicates. * `lo`: An integer representing the lower bound of the range. * `hi`: An integer representing the upper bound of the range. # Output: * A list of tuples, where each tuple represents a range of missing numbers in the form `(start, end)`. # Constraints: * 1 ≤ len(arr) ≤ 10^4 * -10^6 ≤ lo, hi ≤ 10^6 * lo ≤ hi # Example: - Example 1: ```python arr = [3, 5] lo = 1 hi = 10 result = potential_gaps(arr, lo, hi) # Expected Output: [(1, 2), (4, 4), (6, 10)] ``` - Example 2: ```python arr = [] lo = 1 hi = 5 result = potential_gaps(arr, lo, hi) # Expected Output: [(1, 5)] ``` - Example 3: ```python arr = [1, 3, 6, 7, 10] lo = 0 hi = 10 result = potential_gaps(arr, lo, hi) # Expected Output: [(0, 0), (2, 2), (4, 5), (8, 9)] ``` # Requirements: - Ensure your solution is optimized for time and space. - Handle edge cases appropriately. - Assume input list will always be sorted. If not sorted, mention that in solution constraints. Write the function `potential_gaps` to complete the task.","solution":"from typing import List, Tuple def potential_gaps(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: gaps = [] prev_end = lo - 1 for num in arr: if num > prev_end + 1: gaps.append((prev_end + 1, num - 1)) if num > hi: break prev_end = num if prev_end < hi: gaps.append((prev_end + 1, hi)) return gaps"},{"question":"# Task As a software engineer, you have been given the task to implement an efficient topological sort function for a Directed Acyclic Graph (DAG). The aim is to determine a linear order of vertices in the graph that respects the dependency direction of edges. # Functional Requirements 1. Your function should accept a directed graph represented as an adjacency list. 2. The function should return a list that represents the topological order of the vertices. 3. If the graph contains a cycle, your function should raise a `ValueError` indicating a cycle is present. # Input * The graph will be a dictionary where keys are nodes and values are lists of adjacent nodes. # Output * A list of nodes in topologically sorted order. # Constraints * Assume the number of vertices (V) and edges (E) conforms to (1 leq V, E leq 10^5). # Example ```python graph = { 5: [2, 0], 4: [0, 1], 3: [1], 2: [3], 1: [], 0: [] } top_sort(graph) # Output could be [4, 5, 2, 3, 1, 0] or any other valid topological order ``` # Additional Context Topological sorting is particularly useful in scenarios where you need to respect dependency chains, such as: * Task scheduling systems. * Resolving build dependencies in software projects. # Your Task Implement the function `top_sort` with the above specifications and constraints. ```python def top_sort(graph): Return a list of nodes in topological sort order. Args: graph (dict): The DAG represented as an adjacency list. Returns: list: The topologically sorted order of nodes. Raises: ValueError: If a cycle is detected in the graph. # implementation here ```","solution":"def top_sort(graph): Return a list of nodes in topological sort order. Args: graph (dict): The DAG represented as an adjacency list. Returns: list: The topologically sorted order of nodes. Raises: ValueError: If a cycle is detected in the graph. from collections import defaultdict, deque # Calculate in-degrees of all nodes in_degree = defaultdict(int) for node in graph: in_degree[node] = 0 for node in graph: for neighbor in graph[node]: in_degree[neighbor] += 1 # Initialize queue with all nodes having zero in-degree zero_in_degree_queue = deque([node for node in in_degree if in_degree[node] == 0]) topo_order = [] while zero_in_degree_queue: current_node = zero_in_degree_queue.popleft() topo_order.append(current_node) # Decrease the in-degree of the neighboring nodes for neighbor in graph[current_node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # Check if the topological order includes all nodes if len(topo_order) != len(in_degree): raise ValueError(\\"Graph contains a cycle\\") return topo_order"},{"question":"# Matrix Chain Multiplication Optimization You are working on optimizing computational operations in a scientific simulation involving several matrices. Given a sequence of matrices, your task is to determine the most efficient way to multiply these matrices together. The goal is to minimize the number of scalar multiplications. Specifically, given an array `p` of dimensions such that the matrix A_i has dimensions p[i-1] x p[i], determine the minimum number of multiplications needed and the optimal order of multiplicands. Function Signature ```python def matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]: Calculates the minimum number of multiplications needed to multiply a chain of matrices. Params: ------- array : List[int] List of the dimensions of each matrix in the chain. Returns: -------- Tuple[List[List[int]], List[List[int]]] A tuple containing two matrices: - The first matrix represents the minimum number of multiplications needed. - The second matrix represents the split points for the optimal order of multiplication. ``` Input - List of integers `array` where the length of the list is `n + 1` which represents the dimensions of `n` matrices (array of size N where the dimensions of the ith matrix are `array[i-1] x array[i]`). Output - A tuple containing two 2D lists: - The first 2D list represents the minimum number of scalar multiplications needed. - The second 2D list represents the k-values to record where to split the product to achieve the optimization. Constraints - The length of `array` will be at most 100. - The dimensions provided will be in the range [1, 10^3]. Example ```python array = [30, 35, 15, 5, 10, 20, 25] matrix, sol = matrix_chain_order(array) assert matrix[1][6] == 15125 # This should also print the optimal bracketing of matrices, for example: ( (A1 (A2 A3)) ((A4 A5) A6) ) ``` Requirements - Use dynamic programming to solve this problem. - The implementation should efficiently handle the given constraints. - Make sure to consider edge cases such as very small arrays.","solution":"from typing import List, Tuple def matrix_chain_order(array: List[int]) -> Tuple[List[List[int]], List[List[int]]]: Calculates the minimum number of multiplications needed to multiply a chain of matrices. Params: ------- array : List[int] List of the dimensions of each matrix in the chain. Returns: -------- Tuple[List[List[int]], List[List[int]]] A tuple containing two matrices: - The first matrix represents the minimum number of multiplications needed. - The second matrix represents the split points for the optimal order of multiplication. n = len(array) - 1 m = [[0] * (n + 1) for _ in range(n + 1)] s = [[0] * (n + 1) for _ in range(n + 1)] # l is the chain length for l in range(2, n + 1): # l = 2 to n for i in range(1, n - l + 2): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + array[i - 1] * array[k] * array[j] if q < m[i][j]: m[i][j] = q s[i][j] = k return m, s"},{"question":"Implement a function `get_histogram` that takes a list of numerical data as input and returns a dictionary representing the histogram of the input values. The dictionary should map each unique element to its frequency count in the list. # Function Signature ```python def get_histogram(input_list: list) -> dict: ``` # Input * `input_list` (list): A list of integers. Example: `[2, 3, 5, 5, 5, 6, 4, 3, 7]`. # Output * A dictionary where keys are unique elements from `input_list` and values are their corresponding counts. Example: `{2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1}`. # Constraints * The elements in `input_list` will be integers where `-10^6 <= element <= 10^6`. * The length of `input_list` will be between `0` and `10^5`. # Performance Requirements Your solution should run in O(n) time complexity and use O(k) space complexity, where n is the length of the input list and k is the number of unique elements in the list. # Example ```python assert get_histogram([3, 3, 2, 1]) == {1: 1, 2: 1, 3: 2} assert get_histogram([]) == {} assert get_histogram([5, 5, 5, 5]) == {5: 4} ``` # Edge Cases * The input list is empty. * The input list has all identical elements.","solution":"def get_histogram(input_list: list) -> dict: Given a list of integers, return a dictionary representing the histogram of the input values. Each unique element will map to its frequency count in the list. histogram = {} for num in input_list: if num in histogram: histogram[num] += 1 else: histogram[num] = 1 return histogram"},{"question":"# Problem: Count Islands After Each Land Addition Objective Implement the `num_islands` function that processes a list of positions where land is added in a grid, and returns the number of islands after each addition operation. Detailed Instructions 1. **Function Signature**: `def num_islands(positions: List[Tuple[int, int]], grid_size: Tuple[int, int]) -> List[int]:` 2. **Argument Descriptions**: * `positions` - a list of tuples, where each tuple represents `(row, col)` coordinates where the land is added. * `grid_size` - a tuple (`M`, `N`) representing the size of the grid (M x N). 3. **Output**: * A list of integers, where each integer represents the number of islands after each land addition. 4. **Constraints**: * The grid is initially filled with water (`0\'s`). * An island is formed by vertically or horizontally adjacent lands (`1\'s`). * Assume all edges of the grid are surrounded by water. 5. **Performance Requirements**: * Efficiently handle up to 10⁴ addition operations on a grid of size 1000 x 1000. Scenario You are given a `M x N` grid initially filled with water. Each position in the `positions` list is transformed to land. Determine the number of islands in the grid after each transformation. Example ```python # Example: 3x3 grid positions = [(0, 0), (0, 1), (1, 2), (2, 1)] grid_size = (3, 3) # Explanation: # Initially: # 0 0 0 # 0 0 0 # 0 0 0 # After (0, 0): # 1 0 0 # 0 0 0 Number of islands = 1 # 0 0 0 # After (0, 1): # 1 1 0 # 0 0 0 Number of islands = 1 # 0 0 0 # After (1, 2): # 1 1 0 # 0 0 1 Number of islands = 2 # 0 0 0 # After (2, 1): # 1 1 0 # 0 0 1 Number of islands = 3 # 0 1 0 assert num_islands(positions, grid_size) == [1, 1, 2, 3] ```","solution":"from typing import List, Tuple class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size self.count = 0 def find(self, p): if p != self.parent[p]: self.parent[p] = self.find(self.parent[p]) return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 self.count -= 1 def set_parent(self, p): self.count += 1 self.parent[p] = p def num_islands(positions: List[Tuple[int, int]], grid_size: Tuple[int, int]) -> List[int]: M, N = grid_size uf = UnionFind(M * N) grid = [[0] * N for _ in range(M)] results = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for r, c in positions: if grid[r][c] == 1: results.append(uf.count) continue grid[r][c] = 1 index = r * N + c uf.set_parent(index) for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < M and 0 <= nc < N and grid[nr][nc] == 1: uf.union(index, nr * N + nc) results.append(uf.count) return results"},{"question":"# Question: Implement Pigeonhole Sort with Modifications Given an array of integers, implement a modified version of the Pigeonhole Sort algorithm that can handle negative integers and return the sorted array. Optimize the algorithm to avoid excessive memory usage when possible. Input - An array of integers, `arr`, where each integer can be negative. Output - A sorted array of integers. Constraints - The length of the array, `n`, is between 1 and 10^5. - The integer values of the array elements range from -10^5 to 10^5. Example ```python Input: [-5, -10, 0, 5, 3, -2, 9] Output: [-10, -5, -2, 0, 3, 5, 9] Input: [1, 5, 3, 7, 2, 8] Output: [1, 2, 3, 5, 7, 8] ``` Requirements - Ensure that your implementation efficiently handles negative values. - Analyze time and space complexity for your solution.","solution":"def pigeonhole_sort(arr): Sorts an array of integers using a modified version of the Pigeonhole Sorting algorithm. This version can handle negative integers. if not arr: return [] min_val = min(arr) max_val = max(arr) size = max_val - min_val + 1 # Create an array of pigeonholes pigeonholes = [0] * size # Populate the pigeonholes for number in arr: pigeonholes[number - min_val] += 1 # Generate the sorted array idx = 0 for j in range(size): while pigeonholes[j] > 0: arr[idx] = j + min_val idx += 1 pigeonholes[j] -= 1 return arr"},{"question":"Alice is an engineer working on a project that requires connecting multiple computers in an office using the least amount of cable. Each pair of computers is connected by a unique cable which has a different length, representing the weight of the edge. She wants to ensure that all computers are connected directly or indirectly using the minimum total length of cables. To solve this, she needs to find the Minimum Spanning Tree (MST) of the network represented by the computers and cables. # Task Write a function to implement Kruskal\'s algorithm to find the MST and return the sum of the weights of the MST. ```python def kruskal_mst(vertex_count, edges): Args: vertex_count (int): Number of vertices (computers) in the network. edges (list of tuples): List of tuples where each tuple represents an edge in the format (source, target, weight). Returns: int: Sum of the weights of the MST. # Write your implementation here pass ``` # Input Format 1. `vertex_count` (V): an integer, the number of vertices (computers). 2. `edges`: a list of tuples where each tuple (source, target, weight) represents an edge in the network. The source and target nodes are 0-indexed integers. # Output Format An integer representing the sum of the weights of the MST. # Constraints - 1 ≤ V ≤ 10^5 - 0 ≤ E ≤ 10^5 (E is the number of edges) - Each edge has weight w such that 1 ≤ w ≤ 10^6 # Example **Input** ```python vertex_count = 5 edges = [(0, 1, 1), (0, 2, 3), (1, 2, 1), (1, 3, 6), (2, 3, 4)] ``` **Output** ```python 6 ``` **Explanation** The edges in the MST for the given graph are [(0, 1, 1), (1, 2, 1), (2, 3, 4)]. The sum of the weights is 1 + 1 + 4 = 6. # Notes - Ensure to correctly handle all edge cases including disconnected graphs and cases where the number of edges is less than `vertex_count - 1`.","solution":"def kruskal_mst(vertex_count, edges): Args: vertex_count (int): Number of vertices (computers) in the network. edges (list of tuples): List of tuples where each tuple represents an edge in the format (source, target, weight). Returns: int: Sum of the weights of the MST. # Helper function to find the root of a given vertex def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) # Helper function to perform union of two subsets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 # Sort all the edges in non-decreasing order of their weight edges.sort(key=lambda item: item[2]) parent = [] rank = [] # Create V subsets with single elements for node in range(vertex_count): parent.append(node) rank.append(0) mst_weight = 0 # Initialize result # Number of edges to be taken is equal to V-1 e = 0 # Number of edges in MST # Index variable used for sorted edges i = 0 # Loop while the MST is not yet formed while e < vertex_count - 1 and i < len(edges): # Pick the smallest edge and increment the index u, v, w = edges[i] i = i + 1 x = find(parent, u) y = find(parent, v) # If including this edge does not cause a cycle, include it in the result # and increase the index of the result for the next edge if x != y: e = e + 1 mst_weight += w union(parent, rank, x, y) return mst_weight"},{"question":"# Flatten Nested Arrays Context You are given a multi-dimensional array which may contain nested arrays to arbitrary levels. Your task is to flatten this array into a single-dimensional array containing all the elements in breadth-first order. You will need to consider that the elements can be of any type. Task Implement two functions: 1. `flatten(input_array)`: This function takes a list `input_array` which may contain nested lists and returns a flat list with all the elements. 2. `flatten_iter(input_array)`: This function takes a list `input_array` which may contain nested lists and returns a generator that produces a flat list with all elements. Specifications * **Input**: A nested list `input_array` containing integers or other lists. * **Output**: * For `flatten(input_array)`: a single-dimensional list containing all the elements of `input_array`. * For `flatten_iter(input_array)`: a generator object that yields elements of `input_array` one by one. * **Constraints**: * Nested lists can be arbitrarily deep. * Elements within the lists can be of any type. * Handle string elements correctly as whole items, not to be split by characters. Example ```python input_array = [1, [2, [3, [4]], 5], 6, [[7, 8], 9], 10] # Function Call print(flatten(input_array)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] generator = flatten_iter(input_array) print(list(generator)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ``` Performance * Aim for an `O(n)` solution in time complexity, where `n` is the number of elements in the entire nested structure. * Ensure that auxiliary space usage does not exceed `O(n)`.","solution":"from collections import deque def flatten(input_array): Flattens a nested list into a single-dimensional list. res = [] queue = deque([input_array]) while queue: current = queue.popleft() if isinstance(current, list): queue.extendleft(current[::-1]) else: res.append(current) return res def flatten_iter(input_array): Flattens a nested list into a single-dimensional list using a generator. queue = deque([input_array]) while queue: current = queue.popleft() if isinstance(current, list): queue.extendleft(current[::-1]) else: yield current"},{"question":"You are given a square matrix and need to perform several transformations such as rotating clockwise, rotating counterclockwise, and inverting from top left to bottom right and bottom left to top right. Each transformation should be implemented efficiently. # Your Tasks 1. **Function Name**: `rotate_clockwise(matrix)` - **Input**: A square matrix (2D list) of integers. - **Output**: A new square matrix rotated 90 degrees clockwise. 2. **Function Name**: `rotate_counterclockwise(matrix)` - **Input**: A square matrix (2D list) of integers. - **Output**: A new square matrix rotated 90 degrees counterclockwise. 3. **Function Name**: `top_left_invert(matrix)` - **Input**: A square matrix (2D list) of integers. - **Output**: A new square matrix inverted based on the top-left to bottom-right diagonal. 4. **Function Name**: `bottom_left_invert(matrix)` - **Input**: A square matrix (2D list) of integers. - **Output**: A new square matrix inverted based on the bottom-left to top-right diagonal. # Requirements - Consider edge cases with non-standard matrices (empty or single element matrices). - **Constraints**: 1 <= matrix dimension <= 100 - Functions must have a time complexity of O(n^2) and the space complexity should be optimized to the degree possible. # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(rotate_clockwise(matrix)) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] print(rotate_counterclockwise(matrix)) # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] print(top_left_invert(matrix)) # Output: # [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9] # ] print(bottom_left_invert(matrix)) # Output: # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1] # ] ``` # Goal Implement these functions ensuring correct transformations and considerations for edge cases.","solution":"def rotate_clockwise(matrix): Rotates the given square matrix 90 degrees clockwise. n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def rotate_counterclockwise(matrix): Rotates the given square matrix 90 degrees counterclockwise. n = len(matrix) return [[matrix[j][n - i - 1] for j in range(n)] for i in range(n)] def top_left_invert(matrix): Inverts the given square matrix based on the top-left to bottom-right diagonal. n = len(matrix) return [[matrix[j][i] for j in range(n)] for i in range(n)] def bottom_left_invert(matrix): Inverts the given square matrix based on the bottom-left to top-right diagonal. n = len(matrix) return [[matrix[n - j - 1][n - i - 1] for j in range(n)] for i in range(n)]"},{"question":"# Question: Implement and Optimize an Exponentiation Algorithm with Modulo Context You are tasked with implementing a highly efficient exponentiation function that is essential in cryptographic operations, where large numbers are often involved. Objective Write a function `optimized_power` that computes the power of a given base raised to an exponent, optionally with a modulus, using both iterative and recursive binary exponentiation methods. Function Signature ```python def optimized_power(a: int, n: int, mod: int = None) -> int: pass ``` Input * `a` (int): The base, an integer. * `n` (int): The exponent, a non-negative integer. * `mod` (Optional[int]): The modulus, an optional integer. Output * Return the result of `a` raised to the power `n`. If `mod` is provided, return the result as `(a^n) % mod`. Constraints * `1 <= a <= 10^9` * `0 <= n <= 10^9` * `1 <= mod <= 10^9` (if mod is provided) Requirements 1. Implement both iterative and recursive binary exponentiation algorithms within the function. 2. Ensure the function handles edge cases effectively, especially when `n` is zero. 3. Choose the most optimal method based on input size or constraints (e.g., switch to iterative method for large `n` to avoid recursion limits). Example ```python # Example 1 print(optimized_power(2, 10)) # Expected Output: 1024 # Example 2 print(optimized_power(2, 10, 1000)) # Expected Output: 24 ```","solution":"def optimized_power(a: int, n: int, mod: int = None) -> int: Computes a^n % mod using iterative binary exponentiation. Parameters: a (int): The base integer. n (int): The exponent, a non-negative integer. mod (Optional[int]): The modulus. Returns: int: The result of a^n (or (a^n) % mod if mod is provided). def iterative_exponentiation(base, exp, modulus): result = 1 base = base % modulus if modulus else base while exp > 0: if exp % 2 == 1: result = (result * base) % modulus if modulus else result * base exp = exp // 2 base = (base * base) % modulus if modulus else base * base return result if mod: return iterative_exponentiation(a, n, mod) else: return iterative_exponentiation(a, n, None)"},{"question":"Question: Convert Binary Tree to Doubly Linked List # Problem Statement Given the root of a binary tree, convert the tree into a doubly linked list in-place where the left and right pointers of tree nodes are used as previous and next pointers in the linked list. The doubly linked list should be in sorted order according to the in-order traversal of the binary tree. # Input - A `TreeNode` class that has the following attributes: - `val`: Integer value of the node. - `left`: Pointer to the left child node. - `right`: Pointer to the right child node. # Output - The head of the doubly linked list where each node points to the next node using the `right` pointer and to the previous node using the `left` pointer. # Constraints - The number of nodes in the tree will be in the range `[0, 1000]`. - Node values are unique integers. # Performance - The solution should run in O(N) time where N is the number of nodes in the binary tree. - The auxiliary space used should be O(H) where H is the height of the tree. # Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_to_doubly_linked_list(root: TreeNode) -> TreeNode: :param root: TreeNode - The root of the binary tree. :return: TreeNode - The head of the doubly linked list. def print_linked_list(head: TreeNode) -> None: :param head: TreeNode - The head of the doubly linked list. :return: None. ``` # Example Input: ```plaintext 4 / 2 5 / 1 3 ``` Output: Doubly Linked List in sorted order: ```plaintext 1 <-> 2 <-> 3 <-> 4 <-> 5 ``` The function `print_linked_list` should output: ```plaintext 1 2 3 4 5 ``` # Notes - The helper function `print_linked_list` is provided to help verify the result by printing the values of the nodes in the doubly linked list. - Ensure that all edge cases such as empty trees and single node trees are handled appropriately.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_to_doubly_linked_list(root: TreeNode) -> TreeNode: :param root: TreeNode - The root of the binary tree. :return: TreeNode - The head of the doubly linked list. if not root: return None # Helper function to convert the tree into doubly linked list using in-order traversal def inorder(node): nonlocal last, head if not node: return # Recursively convert the left subtree inorder(node.left) # Adjust pointers if last: last.right = node node.left = last else: head = node last = node # Recursively convert the right subtree inorder(node.right) # Initialize \'last\' and \'head\' pointers last, head = None, None inorder(root) return head def print_linked_list(head: TreeNode) -> None: :param head: TreeNode - The head of the doubly linked list. :return: None. while head: print(head.val) head = head.right"},{"question":"Scenario You are developing a game where each level requires the player to collect a specified number of perfect squares to proceed to the next level. You need to implement a function that determines the minimum number of perfect square numbers which sum to a given integer `n`. Problem Description Write a function `minimum_perfect_squares(n)` that takes an integer `n` and returns the minimum count of perfect square numbers that sum to `n`. Constraints * The integer `n` will be between 1 and (10^4). * Follow the outlined mathematical constraints and shortcuts to ensure optimal performance. Input * An integer `n`, where (1 leq n leq 10^4). Output * An integer representing the minimum number of perfect squares needed to sum up to `n`. Function Signature ```python def minimum_perfect_squares(n: int) -> int: pass ``` Example ```python assert minimum_perfect_squares(9) == 1 # 9 = 3^2 assert minimum_perfect_squares(10) == 2 # 10 = 3^2 + 1^2 assert minimum_perfect_squares(12) == 3 # 12 = 2^2 + 2^2 + 2^2 assert minimum_perfect_squares(31) == 4 # 31 = 5^2 + 2^2 + 1^2 + 1^2 ``` Additional Notes * Ensure that your solution is both time-efficient and memory-efficient considering the constraints. * Pay attention to edge cases such as the smallest and largest possible values of `n`. * Do not use any built-in library functions that directly solve the problem.","solution":"def minimum_perfect_squares(n: int) -> int: Returns the minimum number of perfect squares which sum up to n. if n <= 0: raise ValueError(\\"Input must be a positive integer\\") # Initialize a list to store the minimum number of perfect squares up to n dp = [float(\'inf\')] * (n + 1) dp[0] = 0 # Base case: the minimum number of perfect squares to sum up to 0 is 0 # Iterate through all numbers from 1 to n for i in range(1, n + 1): j = 1 while j * j <= i: dp[i] = min(dp[i], dp[i - j * j] + 1) j += 1 return dp[n]"},{"question":"**Scenario**: You are given a singly linked list that represents a sequence of numbers. In certain scenarios, parts of this sequence are deemed unnecessary or erroneous, and you need to remove segments of this sequence efficiently. **Task**: Implement a function `remove_range` that removes a contiguous segment of a singly linked list from a specified start index to an end index inclusive. Ensure that your solution handles edge cases and maintains optimal performance. **Function Signature**: ```python def remove_range(head, start, end): # Input: head - the head node of a singly linked list. # start - the starting index of the range to remove (inclusive). # end - the ending index of the range to remove (inclusive). # Output: The head node of the modified linked list. pass ``` **Constraints**: 1. 0 <= `start` < `end` < number of elements in the list. 2. The linked list does not have any cycles. **Example**: ```python # Helper class and function to create and print the linked list class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def print_linked_list(head): current = head while current is not None: print(current.value, end=\\" -> \\" if current.next else \\"\\") current = current.next print() # Example usage # Creating the list [8, 13, 17, 4, 9, 12, 98, 41, 7, 23, 0, 92] nodes = [ListNode(val) for val in [8, 13, 17, 4, 9, 12, 98, 41, 7, 23, 0, 92]] for i in range(len(nodes) - 1): nodes[i].next = nodes[i + 1] head = nodes[0] # Removing nodes from index 3 to 8 head = remove_range(head, 3, 8) # Output the modified linked list print_linked_list(head) # Output should be: 8 -> 13 -> 17 -> 23 -> 0 -> 92 ``` **Expected Output**: By calling the function `remove_range(head, 3, 8)`, the linked list should be modified to `[8, 13, 17, 23, 0, 92]`. **Notes**: - We provide a `ListNode` class for creating the linked list and a helper function to print the list. - You may assume that the linked list and indices provided are valid as per the constraints outlined.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_range(head, start, end): Removes a contiguous segment of a singly linked list from start index to end index inclusive. if start == 0: # if start is 0, we need to reassign head for _ in range(end + 1): if head: head = head.next return head current = head count = 0 while current is not None and count < start - 1: current = current.next count += 1 # current now points to the node just before the start index node_before_start = current for _ in range(end - start + 1): if current: current = current.next # Connect the node before start index to the node after end index node_before_start.next = current.next if current else None return head # Helper function to create linked list from a list of values def create_linked_list(values): if not values: return None head = ListNode(values[0]) current = head for value in values[1:]: current.next = ListNode(value) current = current.next return head # Helper function to convert linked list to list (for easy comparison) def linked_list_to_list(head): result = [] current = head while current: result.append(current.value) current = current.next return result"},{"question":"# Integer Decomposition Problem Objective: Given a positive integer `decompose`, your task is to write a function `int_divide(decompose)` to find and count the number of ways `decompose` can be decomposed into sums of smaller non-negative integers. Requirements: * The solution must use dynamic programming principles. * Your solution must handle the provided constraints efficiently. Input: * A single integer, `decompose` (1 ≤ `decompose` ≤ 100). Output: * A single integer representing the number of decompositions of the given integer. Example: **Example 1:** * Input: 4 * Output: 5 **Explanation:** ``` 4=4 4=3+1 4=2+2 4=2+1+1 4=1+1+1+1 ``` **Example 2:** * Input: 7 * Output: 15 **Explanation:** ``` 7=7 7=6+1 7=5+2 7=5+1+1 7=4+3 7=4+2+1 7=4+1+1+1 7=3+3+1 7=3+2+2 7=3+2+1+1 7=3+1+1+1+1 7=2+2+2+1 7=2+2+1+1+1 7=2+1+1+1+1+1 7=1+1+1+1+1+1+1 ``` Constraints: * Implement the function `int_divide(decompose)` without using global variables. * Aim for a time complexity of O(n^2) and space complexity of O(n^2). Function Signature: ```python def int_divide(decompose: int) -> int: # Your code here pass ``` **Note:** Make sure to handle edge cases like `decompose = 1` where the only decomposition is itself.","solution":"def int_divide(decompose): Returns the number of ways `decompose` can be decomposed into sums of smaller non-negative integers. dp = [1] + [0] * decompose for i in range(1, decompose + 1): for j in range(i, decompose + 1): dp[j] += dp[j - i] return dp[decompose]"},{"question":"You are given an array of integers, and you need to efficiently handle two types of operations: 1. **Update**: Update the value at a specific index in the array. 2. **Query**: Calculate the prefix sum from the start of the array to a given index. You are required to implement a Fenwick Tree (Binary Indexed Tree) that supports these operations efficiently. # Inputs - `n` (integer): The number of elements in the initial array. - `arr` (list of integers): The initial array of integers. - `q` (integer): The number of operations. - `operations` (list of tuples): A list of operations where each operation is either: * (\'update\', index, value): Update the element at `index` to `value`. * (\'query\', index): Calculate the sum of elements from index `0` to `index`. # Outputs - For each \'query\' operation, output the calculated sum. # Constraints - 1 <= n <= 1000 - |arr[i]| <= 10^5 - 1 <= q <= 1000 - 0 <= index < n # Example ```python # Input n = 5 arr = [1, 7, 3, 0, 7] q = 3 operations = [ (\'update\', 1, 10), (\'query\', 3), (\'query\', 4) ] # Output # After first update, new arr = [1, 10, 3, 0, 7] # Queries would yield: 13 # sum(1 + 10 + 3 + 0) 20 # sum(1 + 10 + 3 + 0 + 7) ``` # Implementation Complete the methods inside the `FenwickTree` class as defined below to handle the specified operations: ```python class FenwickTree: def __init__(self, freq): self.arr = freq self.n = len(freq) self.bit_tree = self.construct() def get_sum(self, i): Returns sum of arr[0..i]. # Complete this function def update_bit(self, i, v): Updates element at index `i` to `v` and adjusts binary indexed tree. # Complete this function def construct(self): Constructs the binary indexed tree. # Complete this function def handle_operations(n, arr, q, operations): ft = FenwickTree(arr) results = [] for op in operations: if op[0] == \'update\': ft.update_bit(op[1], op[2]) elif op[0] == \'query\': results.append(ft.get_sum(op[1])) return results # Example usage n = 5 arr = [1, 7, 3, 0, 7] q = 3 operations = [ (\'update\', 1, 10), (\'query\', 3), (\'query\', 4) ] print(handle_operations(n, arr, q, operations)) # Should print [13, 20] ```","solution":"class FenwickTree: def __init__(self, freq): self.n = len(freq) self.arr = freq self.bit_tree = [0] * (self.n + 1) self.construct() def construct(self): for i in range(self.n): self.update_bit_util(i, self.arr[i]) def update_bit_util(self, i, diff): i += 1 while i <= self.n: self.bit_tree[i] += diff i += i & -i def update_bit(self, i, v): original_value = self.arr[i] self.arr[i] = v diff = v - original_value self.update_bit_util(i, diff) def get_sum(self, i): sum = 0 i += 1 while i > 0: sum += self.bit_tree[i] i -= i & -i return sum def handle_operations(n, arr, q, operations): ft = FenwickTree(arr) results = [] for op in operations: if op[0] == \'update\': ft.update_bit(op[1], op[2]) elif op[0] == \'query\': results.append(ft.get_sum(op[1])) return results # Example usage n = 5 arr = [1, 7, 3, 0, 7] q = 3 operations = [ (\'update\', 1, 10), (\'query\', 3), (\'query\', 4) ] print(handle_operations(n, arr, q, operations)) # Should print [13, 20]"},{"question":"Cocktail Shaker Sort Implementation Enhancement # Scenario Context: You are working for a company that processes numerous datasets and needs efficient sorting algorithms to minimize processing time. While the basic implementation of the Cocktail Shaker Sort works, you need to optimize and ensure it handles a range of edge cases efficiently. # Task: Implement an optimized version of the Cocktail Shaker Sort algorithm. Your implementation should include enhancements such as: * Early termination when the list is found to be sorted before completing the full cycle. * Adjust the range of elements to be checked on subsequent passes after each complete iteration (both forward and backward). # Function Signature: ```python def optimized_cocktail_shaker_sort(arr: list) -> list: Sorts the given list in ascending order using an optimized version of the Cocktail Shaker Sort algorithm. Parameters: arr (list): List of comparable elements to be sorted. Returns: list: The sorted list in ascending order. ``` # Input Format: * An array of (N) integers, where (1 leq N leq 10^5). # Output Format: * A sorted array of (N) integers in ascending order. # Constraints: * Ensure your implementation handles the following edge cases efficiently: * A list that is already sorted. * A list that is in reverse order. * Lists with repetitive elements. # Performance Requirements: * The solution should aim to minimize the number of swaps and passes through the list. # Examples: ```python # Example 1: arr = [3, 2, 1] print(optimized_cocktail_shaker_sort(arr)) # Output: [1, 2, 3] # Example 2: arr = [5, 1, 4, 2, 8, 0] print(optimized_cocktail_shaker_sort(arr)) # Output: [0, 1, 2, 4, 5, 8] # Example 3: arr = [7, 7, 8, 5, 9, 10, 3, 2, 1, 4, 6, 5] print(optimized_cocktail_shaker_sort(arr)) # Output: [1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 9, 10] ```","solution":"def optimized_cocktail_shaker_sort(arr: list) -> list: Sorts the given list in ascending order using an optimized version of the Cocktail Shaker Sort algorithm. Parameters: arr (list): List of comparable elements to be sorted. Returns: list: The sorted list in ascending order. n = len(arr) start = 0 end = n - 1 swapped = True while swapped: swapped = False # Traverse from left to right similar to bubble sort for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If nothing moved, then the array is sorted if not swapped: break # Otherwise, reset the swapped flag so that it can be used in the next stage swapped = False # Move the end point back by one, because the item at the end is already in the correct position end -= 1 # Traverse from right to left, doing the same comparison as above for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True # Increase the starting point, because the last stage would have moved the next smallest number to the right place start += 1 return arr"},{"question":"You are tasked with writing two functions, `encode` and `decode`, to handle the conversion of a list of strings into a single string for transmission/storage and back into the original list of strings. * The `encode` function should take a list of strings and concatenate them into a single string with specific delimiters and lengths for each string. * The `decode` function should take a single encoded string and revert it back into the original list of strings. # Function Specifications ```python def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. :param strs: List of strings to encode. :return: Encoded single string representing the list. pass def decode(s: str) -> List[str]: Decodes a single string back to a list of strings. :param s: Encoded string to decode. :return: List of original strings. pass ``` # Constraints 1. The encoded string must contain all necessary information to accurately reconstruct the original list of strings. 2. You may assume that no individual string in the list will contain the delimiter character (\\":\\"). # Example ```python # Example Usage input_list = [\\"hello\\", \\"world\\"] encoded_str = encode(input_list) decoded_list = decode(encoded_str) assert encoded_str == \\"5:hello5:world\\" assert decoded_list == input_list ``` # Edge Cases 1. The input list may contain empty strings. 2. Ensure that your implementation can handle large lists and long strings without excessive computational overhead. # Performance Requirements - The solution should be efficient with a linear complexity relative to the total input size.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. :param strs: List of strings to encode. :return: Encoded single string representing the list. return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s: str) -> List[str]: Decodes a single string back to a list of strings. :param s: Encoded string to decode. :return: List of original strings. i = 0 result = [] while i < len(s): j = s.find(\':\', i) length = int(s[i:j]) i = j + 1 result.append(s[i:i + length]) i += length return result"},{"question":"# Roman Numeral to Integer Conversion with Enhanced Error Handling You are tasked with improving a Roman numeral conversion function, \'roman_to_int\', that converts a Roman numeral string into an integer. The current implementation assumes the input is valid and well-formed but does not handle invalid inputs. Function Signature ```python def roman_to_int(s: str) -> int: ``` Input - `s`: A string representing a Roman numeral, guaranteed to be within the range from 1 to 3999. Output - An integer representing the integer value of the input Roman numeral. Constraints 1. The input string `s` is guaranteed to only contain valid Roman numeral characters (I, V, X, L, C, D, M). 2. The input string may have a maximum length of 15 characters. Requirements 1. Extend the function to validate the input before processing: - Ensure the Roman numeral string follows the correct subtractive combination rules. - Return -1 if the string does not represent a valid Roman numeral within the allowed range. Example Scenarios 1. Input: \\"III\\" Output: 3 2. Input: \\"IV\\" Output: 4 3. Input: \\"MMXXI\\" Output: 2021 4. Input: \\"IC\\" (Invalid Roman numeral) Output: -1 ```python def roman_to_int(s: str) -> int: # Your code here pass # Sample testing if __name__ == \\"__main__\\": test_cases = [\\"III\\", \\"IV\\", \\"MMXXI\\", \\"IC\\", \\"DCXXI\\"] for roman in test_cases: print(f\\"Roman: {roman} -> Integer: {roman_to_int(roman)}\\") ``` Question Context Expand and test the roman_to_int function to ensure it not only converts properly formed Roman numerals but also identifies invalid sequences and handles them gracefully.","solution":"def roman_to_int(s: str) -> int: if not s: return -1 # Map of Roman numeral characters to integer values roman_map = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } # Valid subtraction patterns valid_subtractions = { \'IV\', \'IX\', \'XL\', \'XC\', \'CD\', \'CM\' } # Check for invalid patterns i = 0 while i < len(s): if i < len(s) - 1: pair = s[i] + s[i + 1] if s[i] not in roman_map or s[i+1] not in roman_map: return -1 if pair not in valid_subtractions and roman_map[s[i]] < roman_map[s[i+1]]: return -1 elif s[i] not in roman_map: return -1 i += 1 # Calculating the integer value of the Roman numeral total = 0 prev_value = 0 for char in reversed(s): value = roman_map[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"# Tree Traversal Challenge **Context**: You are working on a project that involves analyzing binary search trees (BSTs). One of the key operations you need to perform regularly is traversing the tree to retrieve its elements in sorted order. To demonstrate your understanding of tree traversal algorithms, particularly in a BST context, you\'ll implement both iterative and recursive in-order traversal methods. **Task**: Write a function `inorder` to perform an in-order traversal of a binary tree iteratively. Also, write a function `inorder_rec` to perform an in-order traversal recursively. **Function Signatures**: ```python def inorder(root: Node) -> List[int]: pass def inorder_rec(root: Node, res: List[int] = None) -> List[int]: pass ``` **Input**: - `root`: A reference to the root node of the binary tree (Node). - For `inorder_rec`, an optional argument `res` (initially None) is used to accumulate the traversal results. **Output**: - A List of integers representing the node values in in-order sequence. **Constraints**: 1. You may assume that all `Node` values are unique integers. 2. The binary tree can have up to 10^4 nodes. 3. Tree nodes must be instances of the provided `Node` class. **Node Class Definition**: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` **Example**: ```python n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 # Example usage: assert inorder(n1) == [25, 50, 75, 100, 125, 150, 175] assert inorder_rec(n1) == [25, 50, 75, 100, 125, 150, 175] ```","solution":"from typing import List class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder(root: Node) -> List[int]: result = [] stack = [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_rec(root: Node, res: List[int] = None) -> List[int]: if res is None: res = [] if root: inorder_rec(root.left, res) res.append(root.val) inorder_rec(root.right, res) return res"},{"question":"# Question: Implement a Cycle Sort Function Scenario: You are given an array `arr` of numbers that you want to sort in ascending order using the Cycle Sort algorithm. The Cycle Sort algorithm is known for its minimal write operations but has a higher time complexity compared to some other sorting algorithms. Your task is to implement this sorting algorithm, ensuring that the array is sorted in place with minimal writing operations. Task: Implement a function `cycle_sort(arr)` that sorts an array of integers in ascending order using the Cycle Sort algorithm. The function should return the sorted array. Input: - `arr` (list of int): An unsorted array of integers, where 1 <= len(arr) <= 1000 and -10^5 <= arr[i] <= 10^5. Output: - The function should return the sorted list of integers. Example: ```python print(cycle_sort([3, 6, 2, 1, 5])) # Output: [1, 2, 3, 5, 6] print(cycle_sort([1, 3, 3, 3, 5, 5, 2, 4])) # Output: [1, 2, 3, 3, 3, 4, 5, 5] ``` # Requirements: - Your implementation must follow the Cycle Sort algorithm. - You must sort the array in place (no additional arrays or data structures should be used). - Consider and handle common edge cases and potential errors as discussed.","solution":"def cycle_sort(arr): Sorts the input list using Cycle Sort algorithm. Parameters: - arr (list of int): The list of integers to be sorted. Returns: - list of int: The sorted list. writes = 0 # To count the number of writes # Loop through the array to find cycles to rotate. for cycle_start in range(0, len(arr) - 1): item = arr[cycle_start] # Find where to put the item. pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position. if pos == cycle_start: continue # Otherwise, put the item there or right after any duplicates. while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle. while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Question **Scenario**: A developer needs to write a custom base conversion tool for their application. The input to this tool can either be a decimal number that needs to be converted to a specified base (between 2 and 36) or vice versa. Write functions to handle both conversions accurately and efficiently. **Objective**: You need to implement two functions: 1. `int_to_base(num, base)`: Converts a given integer number into a given base and returns the string representation. 2. `base_to_int(str_to_convert, base)`: Converts a string representation of a number in a given base back to its integer value. # Function Definitions 1. `int_to_base(num, base)` - **Input**: - `num` (int): The number to convert. It can be positive, negative, or zero. - `base` (int): The base to which `num` should be converted. Must be an integer between 2 and 36 (inclusive). - **Output**: - `str`: The string representation of `num` in the given base. 2. `base_to_int(str_to_convert, base)` - **Input**: - `str_to_convert` (str): The string representation of the number in the specified base. - `base` (int): The base in which `str_to_convert` is written. Must be an integer between 2 and 36 (inclusive). - **Output**: - `int`: The integer representation of `str_to_convert`. # Constraints - The input base for both functions will always be between 2 and 36 inclusive. - The input string for `base_to_int` will always be a valid representation in the given base. # Examples 1. `int_to_base(5, 2)` should return `\'101\'`. 2. `base_to_int(\'F\', 16)` should return `15`. 3. `int_to_base(-9, 3)` should return `\'-100\'`. 4. `base_to_int(\'10\', 10)` should return `10`. # Performance Requirements - The functions should be efficient enough to handle very large integers up to the order of (10^{18}) and string representations of corresponding lengths. Write the two functions `int_to_base` and `base_to_int` in Python.","solution":"def int_to_base(num, base): Converts a given integer number into a given base and returns the string representation. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" negative = num < 0 num = abs(num) result = \\"\\" while num: result = digits[num % base] + result num //= base if negative: result = \\"-\\" + result return result def base_to_int(str_to_convert, base): Converts a string representation of a number in a given base back to its integer value. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") str_to_convert = str_to_convert.strip().upper() digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" value_map = {ch: i for i, ch in enumerate(digits)} negative = str_to_convert[0] == \'-\' start = 1 if negative else 0 result = 0 for char in str_to_convert[start:]: result = result * base + value_map[char] if negative: result = -result return result"},{"question":"# Flatten Nested Arrays **Scenario**: In data processing tasks, it\'s common to receive input where elements are nested within each other, making it difficult to apply uniform operations. You need to write a function that can transform any nested iterable into a single flattened iterable. **Task**: Write a Python function `flatten_array(nested_array)` that takes a nested array of any depth and returns a single flat array. Requirements 1. The function should return a one-dimensional list with all the elements from the nested array. 2. Non-iterable elements (except strings) should be simply added to the result list. 3. Strings, though iterable, should be treated as atomic values. Input - `nested_array` (list): A possibly nested list of elements. The nested lists can contain any mix of integers, strings, or other lists. Output - A one-dimensional list where all nested elements are flattened into a single list. Constraints - You may not use any built-in flattening functions. - Aim to handle moderately nested arrays efficiently. Performance - Handle varying input sizes and depths gracefully. ```python def flatten_array(nested_array): Flattens a nested array (list) into a single-dimensional list. Args: nested_array (list): A potentially nested list of integers, strings, or lists. Returns: list: A one-dimensional list with all elements from the nested list. # Your code here # Example nested_array = [1, [2, [3, 4], 5], [6, 7], [[8]], 9] print(flatten_array(nested_array)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` **Edge Cases to Consider**: - An empty list (e.g., `[]`). - Mixed element types. - Varying levels of nesting (e.g., `[[[], []], [[]]]`). - Strings inside nested lists.","solution":"def flatten_array(nested_array): Flattens a nested array (list) into a single-dimensional list. Args: nested_array (list): A potentially nested list of integers, strings, or lists. Returns: list: A one-dimensional list with all elements from the nested list. def flatten(nested): for item in nested: if isinstance(item, list): yield from flatten(item) else: yield item return list(flatten(nested_array))"},{"question":"# Merge Sort Implementation and Extension You are tasked to implement the Merge Sort algorithm with a slight twist. Instead of sorting a list of integers, you are required to sort a list of tuples based on the sum of the elements in the tuples. Your implementation should maintain the stability of the original sorting algorithm. Requirements 1. Write a function `merge_sort_tuples` that takes a list of tuples of integers as input and returns a list of tuples sorted by the sum of their elements. 2. Implement the `merge` function for combining two lists of tuples. 3. Ensure that your functions handle edge cases such as empty lists or lists with repeated tuples. 4. Maintain the stability of the algorithm, i.e., tuples with the same sum should appear in the same order as they appear in the input list. 5. Your implementation should be efficient with a time complexity of O(n log n). Function Signature ```python def merge_sort_tuples(arr: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pass def merge(left: List[Tuple[int, int]], right: List[Tuple[int, int]], merged: List[Tuple[int, int]]) -> None: pass ``` Input and Output Formats * **Input**: A list of tuples of integers, e.g., `[(3, 4), (1, 2), (5, 1), (2, 2)]` * **Output**: A list of tuples sorted by the sum of their elements, e.g., `[(1, 2), (2, 2), (3, 4), (5, 1)]` Constraints * You may assume that the input list contains at most 10^6 elements. * Each tuple contains exactly two integers. Example ```python >>> merge_sort_tuples([(3, 4), (1, 2), (5, 1), (2, 2)]) [(1, 2), (2, 2), (5, 1), (3, 4)] ``` Notes * Be sure to use meaningful variable names and include comments in your code to ensure readability. * You may create additional helper functions if needed.","solution":"from typing import List, Tuple def merge_sort_tuples(arr: List[Tuple[int, int]]) -> List[Tuple[int, int]]: if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort_tuples(arr[:mid]) right = merge_sort_tuples(arr[mid:]) return merge(left, right) def merge(left: List[Tuple[int, int]], right: List[Tuple[int, int]]) -> List[Tuple[int, int]]: merged = [] i = j = 0 while i < len(left) and j < len(right): if sum(left[i]) <= sum(right[j]): merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 # Append remaining elements, if any merged.extend(left[i:]) merged.extend(right[j:]) return merged"},{"question":"# Invert a Binary Tree You are given a binary tree and need to write a function to invert it, effectively transforming it into its mirror image. Consider the definition and the function signature provided below. Implement the function `invertTree` that inverts a binary tree rooted at `root`. Function Signature ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def invertTree(root: TreeNode) -> TreeNode: pass ``` Input - `root`: The root node of a binary tree, where each node contains an integer. Output - Return the root node of the inverted binary tree. Constraints - The number of nodes in the tree is in the range `[0, 1000]`. - The value of each node is an integer in the range `[-1000, 1000]`. Example: *Example 1:* ```python Input: 4 / 2 7 / / 1 3 6 9 Output: 4 / 7 2 / / 9 6 3 1 ``` *Example 2:* ```python Input: 2 / 1 3 Output: 2 / 3 1 ``` *Example 3:* ```python Input: [] Output: [] ``` In your implementation, remember to handle edge cases such as an empty tree or a tree with a single node.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def invertTree(root: TreeNode) -> TreeNode: if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the children invertTree(root.left) invertTree(root.right) return root"},{"question":"Find the First Occurrence using Binary Search You are provided with a sorted array of integers and a target integer. Your task is to write a function that finds the index of the first occurrence of the target integer using the binary search method. The function should return -1 if the target is not found in the array. Note that the array is sorted in ascending order. Function Signature ```python def find_first_occurrence(array: List[int], target: int) -> int: pass ``` Input * `array`: A list of integers sorted in ascending order `array[i] <= array[i + 1]` (0 ≤ i < n-1). * `target`: An integer to search for in the array. Output * Return an integer representing the index of the first occurrence of the target. If the target is not found, return -1. Constraints * 0 ≤ len(array) ≤ 10^5 * -10^9 ≤ array[i], target ≤ 10^9 Example ```python # Example 1: array = [1, 2, 2, 3, 4, 5] target = 2 find_first_occurrence(array, target) # Output: 1 # Example 2: array = [1, 2, 3, 4, 5] target = 6 find_first_occurrence(array, target) # Output: -1 # Example 3: array = [2, 2, 2, 2, 2] target = 2 find_first_occurrence(array, target) # Output: 0 ``` Explanation - In Example 1, the target 2 appears first at index 1. - In Example 2, the target 6 is not present in the array, so the function returns -1. - In Example 3, the target 2 appears continuously in the array, but the first occurrence is at index 0. Implement the function considering the above aspects and analyze its edge cases and performance.","solution":"from typing import List def find_first_occurrence(array: List[int], target: int) -> int: left, right = 0, len(array) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == target: result = mid right = mid - 1 # to find the first occurrence elif array[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"# AVL Tree Custom Function Implementation Your task is to extend the given `AvlTree` class, by adding a method `find_min` that returns the minimum value stored in the AVL Tree. You also need to implement a method `search` which allows searching if a particular value exists in the AVL Tree. Method Details: 1. **`find_min(self) -> int`**: - **Input**: No input parameters. - **Output**: Returns the key of the node with the minimum value in the AVL Tree. - **Edge Case**: If the tree is empty, return `None`. 2. **`search(self, key: int) -> bool`**: - **Input**: An integer key to search within the AVL Tree. - **Output**: Returns `True` if the key exists in the AVL Tree, otherwise returns `False`. Constraints & Limitations: - The key values inserted into the AVL Tree are unique integers. - Both methods should run in O(log n) time complexity. # Example ```python # Sample usage after implementing methods avl_tree = AvlTree() avl_tree.insert(10) avl_tree.insert(20) avl_tree.insert(5) avl_tree.insert(4) avl_tree.insert(7) print(avl_tree.find_min()) # Output: 4 print(avl_tree.search(7)) # Output: True print(avl_tree.search(19)) # Output: False ``` Implement the methods within the given `AvlTree` class: ```python class AvlTree(object): # Existing methods... def find_min(self): Find the minimum value in the AVL Tree # Your code here ... def search(self, key): Search for a key in the AVL Tree # Your code here ... # Add the find_min and search methods to the given AvlTree class. ```","solution":"class AvlTree(object): class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = self.TreeNode(key) else: self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return self.TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._right_rotate(node) if balance < -1 and key > node.right.key: return self._left_rotate(node) if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def find_min(self): Find the minimum value in the AVL Tree if not self.root: return None current = self.root while current.left: current = current.left return current.key def search(self, key): Search for a key in the AVL Tree return self._search(self.root, key) def _search(self, node, key): if not node: return False if key == node.key: return True elif key < node.key: return self._search(node.left, key) else: return self._search(node.right, key)"},{"question":"# Trimmed Mean Function You are tasked with creating a function `trimmean(arr, per)` that calculates a trimmed mean of a list of numerical values. The function trims a percentage of the smallest and largest values from the list before computing the mean, reducing the effect of outliers. Function Signature ```python def trimmean(arr: List[float], per: float) -> float: ``` Parameters - `arr`: A list of floating-point numbers (`List[float]`). - `per`: A floating-point number representing the percentage of values to trim from the top and bottom (`float`). Returns - `float`: The trimmed mean of the array. Constraints - The percentage `per` will be between 0 and 100 (inclusive). - The list `arr` will have at least 3 elements. - The trimmed values will be evenly distributed; if the percentage to trim is such that it leaves fewer than 1 element, ensure to handle this gracefully. Detailed Description 1. Calculate the ratio for trimming by dividing `per` by 200. 2. Sort the array. 3. Compute the number of elements to trim from both ends of the sorted array. 4. Trim the specified percentage of smallest and largest values. 5. Calculate the mean of the remaining values. Scenario Example Imagine you are a judge in a diving competition where each dive is scored. To compute the average score fairly for each dive, the highest and lowest `per` percent of scores need to be discarded. Implement this logic in your function. Input & Output Example ```python # Example 1 arr = [50, 20, 30, 40, 10] per = 40 # Expected trimmed mean = 30.0 print(trimmean(arr, per)) # Should print 30.0 ``` Additional Constraints - Ensure that the trimmed mean calculation does not result in division by zero. - Handle scenarios where very few elements make the trimmed mean calculation infeasible. - Aim for a time complexity of O(n log n) or better and a space complexity of O(n).","solution":"from typing import List def trimmean(arr: List[float], per: float) -> float: Calculates the trimmed mean of a list of floating-point numbers. Parameters: arr: List[float] - A list of floating-point numbers. per: float - The percentage of values to trim from the top and bottom. Returns: float - The trimmed mean of the array. if len(arr) < 3: raise ValueError(\\"Array must have at least 3 elements.\\") trim_count = int(len(arr) * (per / 100) / 2) sorted_arr = sorted(arr) if trim_count == 0: # If trim_count is 0, do not trim any elements trimmed_arr = sorted_arr else: trimmed_arr = sorted_arr[trim_count:-trim_count] return sum(trimmed_arr) / len(trimmed_arr)"},{"question":"Task Given a sorted list of integers and an integer key to search for, write a function `optimized_interpolation_search` that performs an efficient search for the key using the interpolation search algorithm. Use the following signature: ```python def optimized_interpolation_search(array: List[int], search_key: int) -> int: ``` Input - `array`: A sorted list of integers (sorted in increasing order). - `search_key`: An integer to search in the array. Output - Return the index of `search_key` in `array` if it is present. Otherwise, return `-1`. Constraints - Ensure that the function handles edge cases and optimizes for scenarios where the dataset is uniformly distributed. - Avoid division-by-zero errors by adding necessary checks. - Consider integer overflow/underflow scenarios in calculation steps. Examples ```python >>> optimized_interpolation_search([10, 20, 30, 40, 50, 60], 40) 3 >>> optimized_interpolation_search([100, 200, 300, 400, 500], 250) -1 >>> optimized_interpolation_search([1, 3, 7, 8, 11], 10) -1 >>> optimized_interpolation_search([], 1) -1 ``` Explanation 1. **Example 1**: The search_key `40` is in position `3` in the array. 2. **Example 2**: The search_key `250` is not present in the array. 3. **Example 3**: The search_key `10` is not present in the array and so returns `-1`. 4. **Example 4**: The array is empty, leading to an immediate return of `-1`. Good luck!","solution":"from typing import List def optimized_interpolation_search(array: List[int], search_key: int) -> int: Performs an efficient search for the search_key in a sorted array using the interpolation search algorithm. Returns the index of search_key in array if present, otherwise returns -1. if not array: return -1 low, high = 0, len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: # Avoid division by zero and calculate position if array[high] == array[low]: if array[low] == search_key: return low else: return -1 pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) # Check if pos is out of bounds if pos < 0 or pos > len(array) - 1: return -1 # Condition of search_key found if array[pos] == search_key: return pos # If search_key is larger, search in the upper part elif array[pos] < search_key: low = pos + 1 # If search_key is smaller, search in the lower part else: high = pos - 1 return -1"},{"question":"# Question: Implement Tree Preorder Traversal Given a binary tree, implement a function `preorder_traversal` to perform a preorder traversal of the tree and return the list of visited node values. There are two versions of the function to implement: iterative and recursive. Function Signature ```python def preorder_traversal(root: Optional[Node]) -> List[int]: pass def preorder_traversal_recursive(root: Optional[Node]) -> List[int]: pass ``` Input * `root`: The root node of the binary tree (of type `Node`). Output * Returns a list of integers representing the values of nodes visited in preorder. Constraints * The number of nodes in the tree will be in the range `[0, 10^4]`. * The values of the nodes are integers in the range `[-10^4, 10^4]`. Example ```python # Example Tree: # 1 # / # 2 3 # / # 4 5 root = Node(1, Node(2, Node(4), Node(5)), Node(3)) assert preorder_traversal(root) == [1, 2, 4, 5, 3] assert preorder_traversal_recursive(root) == [1, 2, 4, 5, 3] ``` Requirements 1. Implement the preorder traversal using an iterative approach. 2. Implement the preorder traversal using a recursive approach. 3. Ensure the functions handle edge cases effectively, such as empty trees. 4. Optimize for both time and space complexity as per the complexities outlined in the analysis section. Evaluation Criteria * **Correctness**: Your implementation should return correct preorder traversal results for any valid binary tree. * **Efficiency**: Your solution should be able to handle large trees efficiently within the given constraints. * **Edge Cases**: Your implementation should account for and handle edge cases, such as empty trees, single-node trees, etc.","solution":"from typing import List, Optional class Node: def __init__(self, val: int, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.val = val self.left = left self.right = right def preorder_traversal(root: Optional[Node]) -> List[int]: Iteratively performs a preorder traversal of the binary tree. :param root: The root node of the binary tree. :return: A list of node values in preorder. if root is None: return [] stack, result = [root], [] while stack: node = stack.pop() if node: result.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return result def preorder_traversal_recursive(root: Optional[Node]) -> List[int]: Recursively performs a preorder traversal of the binary tree. :param root: The root node of the binary tree. :return: A list of node values in preorder. def helper(node: Optional[Node], result: List[int]): if node: result.append(node.val) helper(node.left, result) helper(node.right, result) result = [] helper(root, result) return result"},{"question":"**Title**: Bit Manipulation Practice **Objective**: Implement a function that leverages fundamental bit manipulation operations. **Scenario**: You are developing software for a new hardware device that requires efficient bit-level data handling. To ensure optimal performance, you need to efficiently perform bit operations to retrieve, set, clear, and update specific bits in a user-specified integer. Write a function `bit_manipulation(num, operations)` where: - `num` is an integer that represents the data you are manipulating. - `operations` is a list of tuples where each tuple represents an operation. The structure of the tuple is (`operation_type`, `index`, `value`), where: - `operation_type` is one of the strings \'get\', \'set\', \'clear\', or \'update\'. - `index` is the bit position on which the operation should be performed. - `value` is only provided for \'update\' operations and represents the bit (0 or 1) to which the bit at `index` should be set. The function should return a list of results for \'get\' operations and the final state of the number after all operations are performed. # Input: - `num`: An integer. - `operations`: A list of tuples with the structure described above. # Output: - A list where each element corresponds to the result of \'get\' operations in the order they were encountered, followed by the final state of the integer. # Function Signature: ```python def bit_manipulation(num: int, operations: [(str, int, int)]) -> [int]: pass ``` # Constraints: - `num` will be a non-negative integer. - `index` will be a non-negative integer and within valid range (usually 0 to 31 for a 32-bit integer). - `value` will always be either 0 or 1 and appears only in \'update\' operations. - All strings for `operation_type` will be correctly provided as one of: \'get\', \'set\', \'clear\', \'update\'. # Example: ```python # Input: num = 29 # Binary: 11101 operations = [(\'get\', 0, 0), (\'set\', 1, 0), (\'clear\', 3, 0), (\'update\', 2, 0)] # Explanation: # Initial Binary: 11101 # get bit at position 0: result is 1 # set bit at position 1: Binary becomes 11111 # clear bit at position 3: Binary becomes 10111 # update bit at position 2 to 0: Binary becomes 10011 # Output: [1, 19] ``` # Notes: - Your implementation should handle different operations sequentially in the provided order. - Pay careful attention to edge cases such as operations on already-set or clear bits and ensure that all operations are performed efficiently.","solution":"def bit_manipulation(num, operations): results = [] for operation in operations: op_type = operation[0] index = operation[1] if op_type == \'get\': results.append((num >> index) & 1) elif op_type == \'set\': num |= (1 << index) elif op_type == \'clear\': num &= ~(1 << index) elif op_type == \'update\': value = operation[2] if value: num |= (1 << index) else: num &= ~(1 << index) results.append(num) return results"},{"question":"# Question Run-Length Encoding Challenge You are required to implement the Run-Length Encoding (RLE) and Run-Length Decoding algorithms. These algorithms compress sequences of identical consecutive characters by encoding the count of characters followed by the character itself and decompress the encoded strings back to their original form. Function Signatures - `def encode_rle(input: str) -> str:` - `def decode_rle(input: str) -> str:` Input 1. **Input for `encode_rle`**: - A string `input` (0 ≤ len(input) ≤ 1000) containing the data to be encoded. 2. **Input for `decode_rle`**: - A string `input` (0 ≤ len(input) ≤ 1000) containing the encoded data. Output 1. **Output for `encode_rle`**: - A string representing the encoded sequence using run-length encoding. 2. **Output for `decode_rle`**: - A string representing the original data decoded from the encoded sequence. Examples - Example for `encode_rle`: ```python encode_rle(\\"aaabbc\\") # Returns \\"3a2b1c\\" encode_rle(\\"hhheeelllloooo\\") # Returns \\"3h3e3l4o\\" encode_rle(\\"\\") # Returns \\"\\" encode_rle(\\"abcd\\") # Returns \\"1a1b1c1d\\" ``` - Example for `decode_rle`: ```python decode_rle(\\"3a2b1c\\") # Returns \\"aaabbc\\" decode_rle(\\"3h3e3l4o\\") # Returns \\"hhheeelllloooo\\" decode_rle(\\"\\") # Returns \\"\\" decode_rle(\\"1a1b1c1d\\") # Returns \\"abcd\\" ``` Constraints - The encoded input for decoding will always be valid (i.e., every numeric count will be followed by a valid character). **Considerations**: 1. Ensure the code handles edge cases such as empty strings correctly. 2. Validate that your functions perform efficiently for the given input size constraints.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded = [] count = 1 prev_char = input[0] for char in input[1:]: if char == prev_char: count += 1 else: encoded.append(f\\"{count}{prev_char}\\") prev_char = char count = 1 encoded.append(f\\"{count}{prev_char}\\") return \'\'.join(encoded) def decode_rle(input: str) -> str: if not input: return \\"\\" decoded = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) else: decoded.append(char * count) count = 0 return \'\'.join(decoded)"},{"question":"Scenario Imagine you are working on analyzing user activity in a native app. You want to determine which actions are performed most frequently. You receive logs of user actions as lists of actions (strings), and you need to find out which actions were most frequently performed. If there are multiple actions with the highest frequency, list all of them. Task Write a function `most_frequent_actions(logs: List[str]) -> List[str]` that takes a list of action logs and returns a list of the most frequently performed actions. If there are multiple actions with the same highest frequency, return all of them in any order. Input - `logs`: A list of strings representing actions performed by users. (1 <= len(logs) <= 10^6) Output - A list of strings representing the action(s) with the highest frequency. If multiple actions have the highest frequency, include all those actions. Constraints - The input list can have a length up to 1,000,000 elements. - Each action is a string and length of each action string can be up to 100 characters. Example ```python assert most_frequent_actions([\\"login\\", \\"click\\", \\"login\\", \\"logout\\", \\"click\\", \\"register\\", \\"click\\"]) == [\\"click\\"] assert most_frequent_actions([\\"register\\", \\"login\\", \\"logout\\", \\"login\\", \\"logout\\", \\"register\\"]) == [\\"register\\", \\"login\\", \\"logout\\"] ```","solution":"from collections import Counter from typing import List def most_frequent_actions(logs: List[str]) -> List[str]: Returns the list of the most frequently performed actions. If there are multiple actions with the highest frequency, returns all of them in any order. if not logs: return [] action_counts = Counter(logs) max_frequency = max(action_counts.values()) most_frequent = [action for action, count in action_counts.items() if count == max_frequency] return most_frequent"},{"question":"You are provided with a singly linked list where each node contains a string. Your task is to implement two functions to remove duplicate nodes from this list, one using a set and the other without using any additional memory (sets, arrays, etc.). Function 1: `remove_dups` ```python def remove_dups(head: Node) -> None: Removes duplicates from the linked list using a set. Args: head (Node): The head node of the linked list. Returns: None: This function modifies the linked list in place and returns nothing. ``` Function 2: `remove_dups_without_set` ```python def remove_dups_without_set(head: Node) -> None: Removes duplicates from the linked list without using any additional memory. Args: head (Node): The head node of the linked list. Returns: None: This function modifies the linked list in place and returns nothing. ``` # Constraints * The linked list node class is defined as follows: ```python class Node: def __init__(self, val: str): self.val = val self.next = None ``` * You may assume all strings are lowercase English letters. * The list can contain from 0 to 10^4 nodes. # Requirements 1. Write efficient implementations for both `remove_dups` and `remove_dups_without_set`. 2. Ensure the functions handle all edge cases including empty lists and lists with repeated elements. 3. Your solutions should correctly update the linked list nodes and maintain proper links after duplicates are removed. 4. The `remove_dups` function should run in O(N) time and use O(N) space, while `remove_dups_without_set` should run in O(N^2) time but use O(1) additional space. # Example ```python # Node Definition: class Node: def __init__(self, val: str): self.val = val self.next = None # Example usage: a1 = Node(\\"a\\") a2 = Node(\\"a\\") b = Node(\\"b\\") c = Node(\\"c\\") c2 = Node(\\"c\\") a1.next = a2 a2.next = b b.next = c c.next = c2 remove_dups(a1) # Resulting list should be: \\"a\\" -> \\"b\\" -> \\"c\\" remove_dups_without_set(a1) # Resulting list should be: \\"a\\" -> \\"b\\" -> \\"c\\" ``` # Notes: * You do not need to define the `Node` class in your solution. * Focus on the correctness and efficiency of your functions.","solution":"class Node: def __init__(self, val: str): self.val = val self.next = None def remove_dups(head: Node) -> None: Removes duplicates from the linked list using a set. Args: head (Node): The head node of the linked list. Returns: None: This function modifies the linked list in place and returns nothing. if not head: return seen = set() current = head seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_dups_without_set(head: Node) -> None: Removes duplicates from the linked list without using any additional memory. Args: head (Node): The head node of the linked list. Returns: None: This function modifies the linked list in place and returns nothing. current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"You are given a string containing digits from 2 to 9 inclusive. Each digit maps to a set of characters, similar to the old telephone keypads. The mapping of digits to characters is given below: - 2: \\"abc\\" - 3: \\"def\\" - 4: \\"ghi\\" - 5: \\"jkl\\" - 6: \\"mno\\" - 7: \\"pqrs\\" - 8: \\"tuv\\" - 9: \\"wxyz\\" Write a function `letter_combinations(digits)` that takes the digit string and returns all possible letter combinations that the number could represent. The function should return the combinations in lexicographical order. # Input Format * A string containing digits from 2 to 9. # Output Format * A list of strings representing the possible letter combinations. # Constraints * The input string length will not exceed 4 digits. * All digits in the input string are guaranteed to be in the range \'2\' to \'9\'. # Performance Requirements * Your function should be efficient in both time and space, considering the constraints. # Example ```python assert letter_combinations(\\"23\\") == [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] assert letter_combinations(\\"\\") == [] assert letter_combinations(\\"2\\") == [\\"a\\", \\"b\\", \\"c\\"] ``` **Note**: Do not use any pre-existing libraries or functions that directly solve the problem - write the algorithm from scratch.","solution":"def letter_combinations(digits): Given a string containing digits from 2 to 9, return all possible letter combinations that the number could represent based on the traditional telephone keypad. The function should return the combinations in lexicographical order. if not digits: return [] digit_to_char = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_chars = digit_to_char[digits[index]] for char in possible_chars: path.append(char) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"**Goal**: Construct a full binary tree from given preorder and postorder traversal arrays and obtain its inorder traversal. **Scenario**: A software company is working on a new feature for their web-based visualization tool. The tool is supposed to reconstruct a full binary tree using preorder and postorder traversal data and then display it using inorder traversal. You are assigned to implement this functionality. **Task**: Implement a function `construct_inorder_tree(pre, post)` that: 1. Constructs a binary tree using the given preorder (`pre`) and postorder (`post`) traversal arrays of a full binary tree. 2. Returns the inorder traversal of the constructed binary tree as a list of integers. **Function Signature**: ```python def construct_inorder_tree(pre: List[int], post: List[int]) -> List[int]: ``` **Input/Output Format**: - **Input**: 1. `pre`: A list of integers representing the preorder traversal of a full binary tree. 2. `post`: A list of integers representing the postorder traversal of the same full binary tree. - **Output**: A list of integers indicating the inorder traversal of the constructed full binary tree. **Constraints**: - The input arrays represent a valid full binary tree where each tree node has 0 or 2 children. **Example**: ```python pre = [1, 2, 4, 5, 3, 6, 7] post = [4, 5, 2, 6, 7, 3, 1] assert construct_inorder_tree(pre, post) == [4, 2, 5, 1, 6, 3, 7] ``` **Additional Information**: - You are expected to handle trees with varying depths efficiently. - Utilize the properties of the preorder and postorder traversal arrays to minimize the build time.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(pre, pre_start, pre_end, post, post_start, post_end): if pre_start > pre_end or post_start > post_end: return None root = TreeNode(pre[pre_start]) if pre_start == pre_end or post_start == post_end: return root left_root_val = pre[pre_start + 1] left_size = post.index(left_root_val) - post_start + 1 root.left = build_tree(pre, pre_start + 1, pre_start + left_size, post, post_start, post_start + left_size - 1) root.right = build_tree(pre, pre_start + left_size + 1, pre_end, post, post_start + left_size, post_end - 1) return root def inorderTraversal(root): result = [] stack = [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def construct_inorder_tree(pre, post): root = build_tree(pre, 0, len(pre) - 1, post, 0, len(post) - 1) return inorderTraversal(root)"},{"question":"**Objective:** Implement a function to find the intersection node of two linked lists. **Scenario:** Imagine a scenario where two energy networks represented as linked lists combine at a certain point. Each network starts independently but merges into a single pipeline after some distance. As a network engineer, you need to identify the exact merging (intersection) point to ensure efficient monitoring and maintenance. **Task:** Write a function `find_intersection(head1, head2)` that takes the heads of two linked lists and returns the node where the two lists intersect. If no intersection exists, return `None`. # Function signature ```python class Node(object): def __init__(self, val=None): self.val = val self.next = None def find_intersection(head1, head2): Returns the intersection node of two linked lists if present, else None. pass ``` # Input - head1, head2: (Node) Heads of the two linked lists. # Output - (Node) The intersection node or `None` if they do not intersect. # Constraints - Assume the lists do not contain cycles. # Example ```python class Node(object): def __init__(self, val=None): self.val = val self.next = None # create linked list as: # 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # 2 -> 4 -> 6 a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f intersect_node = find_intersection(a1, a2) assert intersect_node.val == 7 ``` **Note:** You may use the above example for testing your implementation. **Requirements:** 1. Use optimal time and space complexity. 2. Keep code neat and well-commented. 3. Write a small suite of tests to validate edge cases.","solution":"class Node(object): def __init__(self, val=None): self.val = val self.next = None def find_intersection(head1, head2): Returns the intersection node of two linked lists if present, else None. if not head1 or not head2: return None # Calculate the length of both linked lists def get_length(head): length = 0 while head: length += 1 head = head.next return length length1 = get_length(head1) length2 = get_length(head2) # Align both pointers to start at the same position from the end while length1 > length2: head1 = head1.next length1 -= 1 while length2 > length1: head2 = head2.next length2 -= 1 # Traverse both lists together to find the intersection while head1 and head2: if head1 == head2: return head1 head1 = head1.next head2 = head2.next return None"},{"question":"Implement a Circular Doubly Linked List You are required to implement a circular doubly linked list. This type of list is a variant of doubly linked lists where the last node points back to the first node, making the list circular. Similarly, the first node\'s previous pointer points to the last node. Thus, it allows traversal from any node in either direction in a circular manner. # Functionality Requirements: 1. **Initialization**: Create an empty circular doubly linked list. 2. **Insertion**: Insert nodes at the beginning, end, and at any specific position. 3. **Deletion**: Delete nodes from the beginning, end, and any specific position. 4. **Traversal**: Implement a method to traverse the list and return elements in a list form. 5. **Search**: Search for a value within the list and return its position. # Constraints: - All positional indices are 0-based. - Avoid using Python\'s built-in list or collection data types. # Method Signatures: ```python class CircularDoublyLinkedList: def __init__(self): # Initialize your data structure here pass def insert_at_beginning(self, value: int) -> None: # Insert a new node with the specified value at the beginning pass def insert_at_end(self, value: int) -> None: # Insert a new node with the specified value at the end pass def insert_at_position(self, position: int, value: int) -> None: # Insert a new node with the specified value at the given position pass def delete_from_beginning(self) -> None: # Delete the node at the beginning of the list pass def delete_from_end(self) -> None: # Delete the node at the end of the list pass def delete_from_position(self, position: int) -> None: # Delete the node at the given position pass def traverse_list(self) -> list: # Traverse the list and return the values in a list form pass def search(self, value: int) -> int: # Search for the value in the list and return its position, else return -1 pass ``` # Example: ```python # Example Usage cdll = CircularDoublyLinkedList() cdll.insert_at_beginning(10) cdll.insert_at_end(20) cdll.insert_at_position(1, 15) # List: 10 <-> 15 <-> 20 (circular) cdll.delete_from_beginning() # List: 15 <-> 20 (circular) cdll.delete_from_end() # List: 15 (circular) print(cdll.traverse_list()) # Output: [15] print(cdll.search(15)) # Output: 0 print(cdll.search(10)) # Output: -1 ``` # Notes: - Assume that the input values for positions are always valid. - Ensure that your implementation handles both small and large datasets efficiently.","solution":"class CircularDoublyLinkedList: class Node: def __init__(self, value): self.value = value self.next = None self.prev = None def __init__(self): self.head = None def insert_at_beginning(self, value): new_node = self.Node(value) if self.head is None: new_node.next = new_node new_node.prev = new_node self.head = new_node else: tail = self.head.prev new_node.next = self.head new_node.prev = tail self.head.prev = new_node tail.next = new_node self.head = new_node def insert_at_end(self, value): new_node = self.Node(value) if self.head is None: new_node.next = new_node new_node.prev = new_node self.head = new_node else: tail = self.head.prev tail.next = new_node new_node.prev = tail new_node.next = self.head self.head.prev = new_node def insert_at_position(self, position, value): if position == 0: self.insert_at_beginning(value) else: new_node = self.Node(value) current = self.head for _ in range(position): current = current.next new_node.next = current new_node.prev = current.prev current.prev.next = new_node current.prev = new_node def delete_from_beginning(self): if self.head is None: return elif self.head.next == self.head: self.head = None else: tail = self.head.prev self.head = self.head.next self.head.prev = tail tail.next = self.head def delete_from_end(self): if self.head is None: return elif self.head.next == self.head: self.head = None else: tail = self.head.prev tail.prev.next = self.head self.head.prev = tail.prev def delete_from_position(self, position): if self.head is None: return elif position == 0: self.delete_from_beginning() else: current = self.head for _ in range(position): current = current.next current.prev.next = current.next current.next.prev = current.prev def traverse_list(self): values = [] if self.head is None: return values current = self.head while True: values.append(current.value) current = current.next if current == self.head: break return values def search(self, value): if self.head is None: return -1 current = self.head index = 0 while True: if current.value == value: return index current = current.next index += 1 if current == self.head: break return -1"},{"question":"# Diffie-Hellman Key Exchange Function and Testing Introduction Alice and Bob want to establish a secure communication channel. They will use the Diffie-Hellman Key Exchange protocol to share a secret key. Your task is to complete the implementation of this protocol, considering efficiency and correctness. Task 1. **Function Implementation**: - Enhance the provided functions for prime checking, Euler’s Totient function, order calculation, primitive root finding. - Implement the full Diffie-Hellman key exchange process ensuring robust error handling and edge case management. 2. **Testing & Verification**: - Write your own test cases to verify the functionalities of prime checking, totient calculations, order finding, and finally, the key exchange. Function Signatures You have the following function signatures to fill in and enhance: ```python def prime_check(num: int) -> bool: pass def euler_totient(n: int) -> int: pass def find_order(a: int, n: int) -> int: pass def find_primitive_root(n: int) -> list: pass def alice_private_key(p: int) -> int: pass def alice_public_key(a_pr_k: int, a: int, p: int) -> int: pass def bob_private_key(p: int) -> int: pass def bob_public_key(b_pr_k: int, a: int, p: int) -> int: pass def alice_shared_key(b_pu_k: int, a_pr_k: int, p: int) -> int: pass def bob_shared_key(a_pu_k: int, b_pr_k: int, p: int) -> int: pass def diffie_hellman_key_exchange(a: int, p: int, option=None) -> bool: pass ``` **Inputs**: - `a`: An integer, potential primitive root (1 ≤ a ≤ p-1). - `p`: A large prime number (≥ 2). **Outputs**: - Returns a boolean indicating if the shared keys produced are equal. **Constraints**: - The function should work efficiently for values up to 1000000. - Handle invalid and edge inputs gracefully. **Example**: Given: ```python a = 2 p = 11 diffie_hellman_key_exchange(a, p) ``` Output: ``` Shared key calculated by Alice = 4 Shared key calculated by Bob = 4 True ``` Deliverable Improve code snippets and write test cases demonstrating the efficacy and correctness of all functions involved in the Diffie-Hellman key exchange.","solution":"import random from math import gcd # Function to check if a number is prime def prime_check(num: int) -> bool: if num <= 1: return False if num == 2 or num == 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True # Euler\'s Totient function def euler_totient(n: int) -> int: if n == 1: return 1 result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result # Function to find the order of a modulo n def find_order(a: int, n: int) -> int: if gcd(a, n) != 1: return 0 order = 1 current = a % n while current != 1: current = (current * a) % n order += 1 return order # Function to find a primitive root of n def find_primitive_root(n: int) -> list: if not prime_check(n): raise ValueError(\\"Input must be a prime number\\") phi = euler_totient(n) candidates = [] for i in range(2, n): if find_order(i, n) == phi: candidates.append(i) return candidates # Generate Alice\'s private key def alice_private_key(p: int) -> int: return random.randint(2, p - 2) # Generate Alice\'s public key def alice_public_key(a_pr_k: int, a: int, p: int) -> int: return pow(a, a_pr_k, p) # Generate Bob\'s private key def bob_private_key(p: int) -> int: return random.randint(2, p - 2) # Generate Bob\'s public key def bob_public_key(b_pr_k: int, a: int, p: int) -> int: return pow(a, b_pr_k, p) # Compute the shared key by Alice def alice_shared_key(b_pu_k: int, a_pr_k: int, p: int) -> int: return pow(b_pu_k, a_pr_k, p) # Compute the shared key by Bob def bob_shared_key(a_pu_k: int, b_pr_k: int, p: int) -> int: return pow(a_pu_k, b_pr_k, p) # Diffie-Hellman Key Exchange def diffie_hellman_key_exchange(a: int, p: int, option=None) -> bool: if not prime_check(p): raise ValueError(\\"The number p must be a prime\\") if a not in find_primitive_root(p): raise ValueError(\\"The number a must be a primitive root of p\\") a_pr_k = alice_private_key(p) b_pr_k = bob_private_key(p) a_pu_k = alice_public_key(a_pr_k, a, p) b_pu_k = bob_public_key(b_pr_k, a, p) alice_shared = alice_shared_key(b_pu_k, a_pr_k, p) bob_shared = bob_shared_key(a_pu_k, b_pr_k, p) return alice_shared == bob_shared"},{"question":"Context You are developing a system to classify data points based on their similarity to known examples. The system needs a function to determine the class of an input point by finding the most similar point in the training set using the nearest neighbor algorithm. Task Implement the nearest neighbor algorithm to classify an input vector. You will be given the coordinates of the input vector and a training dataset. Each entry in the training dataset includes coordinates of a training vector and its associated class label. Function Signature ```python def nearest_neighbor_classification(input_vector: tuple, training_set: dict) -> str: Classifies the input vector by finding the nearest neighbor in the training set. Arguments: input_vector -- a tuple representing a point in the n-dimensional space (e.g., (x1, x2, ..., xn)) training_set -- a dictionary where keys are tuple representing points in the n-dimensional space and values are the class labels of these points (e.g., {(x1, y1, ...): \\"class_label\\", ...}) Returns: The class label of the closest point in the training set. ``` Input: - `input_vector`: a tuple of integers or floats representing the coordinates of the input vector. - `training_set`: a dictionary where the keys are tuples of integers or floats (representing the coordinates of training vectors) and the values are strings (representing the class labels of these vectors). Output: - A string representing the class label of the nearest neighbor in the training set. Constraints: - All vectors (inputs and keys in training_set) have the same length. - The training set contains at least one vector. - Labels are non-empty strings. Example ```python # Example case input_vector = (1.0, 2.0) training_set = { (2.0, 3.0): \\"A\\", (5.0, 4.0): \\"B\\", (1.5, 1.8): \\"A\\" } assert nearest_neighbor_classification(input_vector, training_set) == \\"A\\" ``` Notes - You may assume that the Euclidean distance calculation is correctly implemented. - Handle potential edge cases, like vectors being equally distant to multiple points, as suitable (for instance, select the first when tied).","solution":"import math def nearest_neighbor_classification(input_vector: tuple, training_set: dict) -> str: Classifies the input vector by finding the nearest neighbor in the training set. Arguments: input_vector -- a tuple representing a point in the n-dimensional space (e.g., (x1, x2, ..., xn)) training_set -- a dictionary where keys are tuple representing points in the n-dimensional space and values are the class labels of these points (e.g., {(x1, y1, ...): \\"class_label\\", ...}) Returns: The class label of the closest point in the training set. def euclidean_distance(point1, point2): return math.sqrt(sum((a - b) ** 2 for a, b in zip(point1, point2))) nearest_neighbor = None min_distance = float(\'inf\') for point, label in training_set.items(): distance = euclidean_distance(input_vector, point) if distance < min_distance: min_distance = distance nearest_neighbor = label return nearest_neighbor"},{"question":"You are provided with the task of improving and testing the efficiency of exponentiation calculations. Leveraging the concept of Binary Exponentiation, write a function that accepts a base `a`, an exponent `n`, and an optional modulus `mod`, and returns the result of `a` raised to the power `n`, optionally modulo `mod`. # Function Signature ```python def binary_exponentiation(a: int, n: int, mod: int = None) -> int: pass ``` # Input - `a` (Integer): The base integer value. - `n` (Integer): The exponent integer value. - `mod` (Integer, Optional): The modulus value for modulo operation. Default is None. - Constraints: ( 0 leq a, n leq 10^9 ) - In the case `mod` is provided, ( 1 leq mod leq 10^9 ) # Output - Returns (Integer): The result of ( a^n ) if `mod` is None. - Returns (Integer): The result of ( (a^n) % mod ) if `mod` is provided. # Examples 1. `binary_exponentiation(2, 10)` returns `1024` 2. `binary_exponentiation(2, 10, 1000)` returns `24` 3. `binary_exponentiation(10, 5)` returns `100000` 4. `binary_exponentiation(10, 5, 1000)` returns `0` # Constraints - Ensure the function efficiently computes the result within the provided constraints. - Consider edge cases such as when a or n are zero. # Instructions 1. Implement the function `binary_exponentiation` using an **iterative approach**. 2. Optionally, you can implement additional checks or enhancements in your solution. 3. Provide a brief explanation of your approach and any optimizations you applied. Good luck!","solution":"def binary_exponentiation(a: int, n: int, mod: int = None) -> int: Computes a^n using binary exponentiation, optionally modulo `mod`. result = 1 base = a while n > 0: if n % 2 == 1: result = result * base if mod: result %= mod base = base * base if mod: base %= mod n //= 2 return result if not mod else result % mod"},{"question":"# Cycle Sort Implementation Challenge Problem Statement Given an array of integers, your task is to implement the Cycle Sort algorithm to sort the array in ascending order. Cycle Sort is a comparison-based sorting algorithm that works by finding cycles in the permutation of the array and then rotating the elements within these cycles into the correct positions. Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: ``` Input - A list of integers `arr` where ( 1 leq |arr| leq 10^3 ). Elements can be negative or positive and lie within the range of 32-bit signed integers. Output - Return the list sorted in ascending order. Constraints - You must use the Cycle Sort algorithm as described. - The algorithm should sort the list in place and should not use any extra space beyond a few temporary variables. Example Input and Output ```python # Example 1 input_arr = [4, 3, 2, 1] output_arr = cycle_sort(input_arr) # Output: [1, 2, 3, 4] # Example 2 input_arr = [1, 2, 3, 4] output_arr = cycle_sort(input_arr) # Output: [1, 2, 3, 4] # Example 3 input_arr = [1, 5, 4, -1, 0] output_arr = cycle_sort(input_arr) # Output: [-1, 0, 1, 4, 5] ``` Notes - Carefully handle all edge cases mentioned in the algorithm analysis. - Ensure your function is efficient within the constraints provided.","solution":"def cycle_sort(arr): Function to sort an array using Cycle Sort algorithm. n = len(arr) # Traverse array elements and put them to the correct location for start in range(0, n-1): item = arr[start] # Find the position where we put the element pos = start for i in range(start+1, n): if arr[i] < item: pos += 1 # If the element is already in the correct position if pos == start: continue # Ignore all duplicate elements while item == arr[pos]: pos += 1 # Put the item to its right position arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != start: pos = start for i in range(start+1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"Given a binary tree, implement a function to return its preorder traversal as a list of values. You can choose to implement either an iterative or recursive approach. Function Signature: ```python def preorder_traversal(root: Optional[Node]) -> List[int]: ``` Input: - A single `root` node of a binary tree. The node\'s class is defined as: ```python class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output: - A list of integers representing the preorder traversal of the binary tree. Constraints: 1. The number of nodes in the tree will be in the range `[0, 10^4]`. 2. `-10^5 <= Node.val <= 10^5` 3. The tree may be highly skewed or balanced. Example: ```python # Example usage: # Given binary tree [1, None, 2, 3] # 1 # # 2 # / # 3 root = Node(1, None, Node(2, Node(3))) # The expected output is [1, 2, 3] assert preorder_traversal(root) == [1, 2, 3] ``` Guidelines: 1. Handle edge cases such as an empty tree, trees with only left children, only right children, and very deep trees. 2. Ensure the solution is optimized for both time and space complexity. 3. Avoid using any in-built libraries for tree traversal to ensure understanding of the core algorithm. 4. Document code to explain the approach clearly.","solution":"from typing import List, Optional class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def preorder_traversal(root: Optional[Node]) -> List[int]: Returns the preorder traversal of a binary tree. Args: root (Optional[Node]): The root of the binary tree. Returns: List[int]: The preorder traversal as a list of integers. def helper(node: Optional[Node], result: List[int]): if node is None: return result.append(node.val) # Visit the root helper(node.left, result) # Traverse left subtree helper(node.right, result) # Traverse right subtree result = [] helper(root, result) return result"},{"question":"# Sorting Integers Using Pivot-Enhanced Quick Sort Context You are working as a software engineer for a logistics company. Your task is to develop a sorting module that will be frequently used in the backend systems for sorting operational data. Given the nature of the data, you need to ensure that your sorting algorithm performs efficiently on average, but also handles edge cases gracefully to avoid performance degradation. Objective Implement a function `enhanced_quick_sort` that sorts a given list of integers. The pivot selection should be optimized to ensure better performance in the average and worst cases. Specifically, use the \\"median of three\\" strategy (median of the first, middle, and last elements) to choose the pivot. Function Signature ```python def enhanced_quick_sort(arr: list[int], simulation: bool = False) -> list[int]: pass ``` Input - `arr`: A list of integers to be sorted (0 ≤ len(arr) ≤ 10^5). - `simulation`: A boolean flag indicating whether to print simulation steps (optional, default is False). Output - A list of integers sorted in ascending order. Requirements 1. Use the quick sort algorithm with an optimized pivot selection method (median of three). 2. The function should handle edge cases where the input list is empty or contains elements that are all the same. 3. When `simulation` is set to `True`, print intermediate steps of array status after each partitioning. 4. Consider performance and ensure that time complexity remains O(n log(n)) on average. Example ```python >>> enhanced_quick_sort([3, 6, 8, 10, 1, 2, 1]) [1, 1, 2, 3, 6, 8, 10] >>> enhanced_quick_sort([10, 7, 8, 9, 1, 5], simulation=True) # Output showing simulation steps ``` *Note: Do not use Python\'s built-in sorting functions.*","solution":"def enhanced_quick_sort(arr: list[int], simulation: bool = False) -> list[int]: if len(arr) <= 1: return arr def median_of_three(low, high): mid = (low + high) // 2 a, b, c = arr[low], arr[mid], arr[high] if a > b: if a < c: return low elif b > c: return mid else: return high else: if a > c: return low elif b < c: return mid else: return high def partition(low, high): m_index = median_of_three(low, high) arr[low], arr[m_index] = arr[m_index], arr[low] pivot = arr[low] left = low + 1 right = high while True: while left <= right and arr[left] <= pivot: left += 1 while left <= right and arr[right] >= pivot: right -= 1 if left > right: break arr[left], arr[right] = arr[right], arr[left] arr[low], arr[right] = arr[right], arr[low] if simulation: print(arr) return right def quick_sort(low, high): if low < high: pivot_index = partition(low, high) quick_sort(low, pivot_index - 1) quick_sort(pivot_index + 1, high) quick_sort(0, len(arr) - 1) return arr"},{"question":"# Scenario You are a software engineer tasked with implementing an algorithm to detect cycles in network messages represented as linked lists. Efficient detection is crucial as any delays can cause significant communication breakdowns. # Task Write a function `is_cyclic` to determine if a given singly linked list has a cycle in it. # Requirements 1. Implement the function `is_cyclic` using the two-pointer technique. 2. Your solution should minimize space complexity to O(1). 3. The function should handle all edge cases effectively. # Function Signature ```python class Node: def __init__(self, x): self.val = x self.next = None def is_cyclic(head): :type head: Node :rtype: bool # Your code here ``` # Input Format * The function will receive a head node of a singly linked list. * The node is defined with both `val` (value) and `next` (reference to the next node). # Output Format * Return `True` if there\'s a cycle, otherwise return `False`. # Constraints * The number of nodes in the linked list is finite. * Nodes in the linked list will only contain valid integer values. # Examples 1. Example 1: ```python # Creating a linked list: 3 -> 2 -> 0 -> -4 head = Node(3) second = Node(2) third = Node(0) fourth = Node(-4) head.next = second second.next = third third.next = fourth fourth.next = second # Cycle here assert is_cyclic(head) == True ``` 2. Example 2: ```python # Creating a linked list: 1 -> 2 head = Node(1) second = Node(2) head.next = second second.next = None # No cycle assert is_cyclic(head) == False ``` # Explanation * In Example 1, the linked list has a cycle where the last node points back to the second node. * In Example 2, the linked list does not form a cycle and ends at the second node.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def is_cyclic(head): Determines if the given singly linked list has a cycle in it using the two-pointer technique. :type head: Node :rtype: bool if not head or not head.next: return False slow = head fast = head.next while fast is not None and fast.next is not None: if slow == fast: return True slow = slow.next fast = fast.next.next return False"},{"question":"Scenario: A financial application contains a Binary Search Tree (BST) that stores different interest rates. A user can query the system to find the interest rate closest to their target interest rate. Implement a function that efficiently finds the closest interest rate in the BST. Question: Given a non-empty binary search tree and a target value, write a function that finds the value in the BST closest to the target. # Function Signature: ```python def closest_value(root, target): :type root: TreeNode :type target: float :rtype: int ``` # Input: - `root`: The root node of the binary search tree. `TreeNode` is a class with attributes `val` (integer), `left` (TreeNode or None), and `right` (TreeNode or None). - `target`: A floating-point number representing the target value. # Output: - Return the value (integer) present in the BST that is closest to the target value. # Constraints: - The tree is non-empty and exactly one unique value in the BST is closest to the target. - Values in the BST are unique. - The BST has typical properties where: - left subtree values are lesser than the node\'s value. - right subtree values are greater than the node\'s value. # Example: ```python # Example Tree # 4 # / # 2 5 # / # 1 3 # Input: root = [4,2,5,1,3], target = 3.714286 # Output: 4 # Example usage: root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(3) assert closest_value(root, 3.714286) == 4 ``` # Explanation: In the given BST, the closest value to the target 3.714286 is 4. # Performance Requirements: - Ensure an average time complexity of O(log n) (where n is the number of nodes). - Optimize for balanced trees but handle unbalanced trees gracefully.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def closest_value(root, target): Returns the value in the BST that is closest to the target. :type root: TreeNode :type target: float :rtype: int closest = root.val current = root while current: if abs(current.val - target) < abs(closest - target): closest = current.val if target < current.val: current = current.left else: current = current.right return closest"},{"question":"# Bitwise Manipulation Problem Given two integers, write a function to determine the minimal number of bits you would need to flip in the binary representation of one integer to convert it to another integer. This type of problem can help ascertain one\'s understanding of low-level bitwise manipulations, useful for fault detection/correction and cryptography. Function Signature ```python def count_flips_to_convert(a: int, b: int) -> int: // Your code here ``` Parameters * `a` (int): The first integer value (0 <= a <= 2^31 - 1). * `b` (int): The second integer value (0 <= b <= 2^31 - 1). Returns * `int`: The minimal number of bits that need to be flipped to convert `a` to `b`. Example Input: ```python count_flips_to_convert(29, 15) ``` Output: ```python 2 ``` *Explanation*: The binary representations of 29 (11101) and 15 (01111) differ by two bits. Constraints 1. Both integers `a` and `b` should be non-negative. 2. The time complexity should be linear concerning the number of bits in the integers. 3. The space complexity should be constant O(1). Scenario Imagine you are working on network transmission systems and need to detect and correct errors in transmitted data. You would require a minimal bit-flip calculation algorithm to optimize and ensure data integrity. This problem simulates a simplified version of such a requirement.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the minimal number of bits that need to be flipped to convert integer a to integer b. # XOR of a and b will give a number where the bits are 1 # wherever a and b differ xor = a ^ b # Count the number of 1s in the XOR result count = 0 while xor: # Increment count if the last bit is 1 count += xor & 1 # Shift right to check the next bit xor >>= 1 return count"},{"question":"You are tasked with creating a utility function that normalizes a given file path to its absolute path. This involves resolving any user-specific shortcuts and validating that the provided path actually exists in the file system. # Requirements * Implement a function `normalize_path(path)` that: - Takes a string `path` representing a file path. - Returns the absolute path after expanding any user-specific shortcuts. - Ensures the path exists; otherwise, raises a `FileNotFoundError`. # Input * A single string `path` representing the file path. # Output * A string representing the absolute path. # Constraints * The input path will be a non-empty string. * The path may contain user-specific shortcuts (e.g., `~` or `~username`). # Example ```python normalize_path(\\"~/myfile.txt\\") # Should return the absolute path to the given file if it exists. normalize_path(\\"~/nonexistentfile.txt\\") # Should raise a FileNotFoundError. ``` # Note * You may use standard Python libraries for path operations. * Ensure proper exception handling and validation of path existence.","solution":"import os def normalize_path(path): Normalize the given file path to its absolute path, expanding any user-specific shortcuts and ensuring the path exists in the file system. Parameters: path (str): The file path to be normalized. Returns: str: The absolute path if it exists. Raises: FileNotFoundError: If the path does not exist in the file system. # Expand the user-specific shortcuts and get the absolute path absolute_path = os.path.abspath(os.path.expanduser(path)) # Check if the path exists if not os.path.exists(absolute_path): raise FileNotFoundError(f\\"The path \'{absolute_path}\' does not exist.\\") return absolute_path"},{"question":"# Scenario You are building a library system which stores book IDs in a sorted array. One of the features needed is to find the last occurrence of a book ID when there are multiple copies of the same book. # Task Implement a function `find_last_occurrence(books, book_id)` that finds the index of the last occurrence of `book_id` in a sorted array `books`. If the book ID does not exist in the array, the function should return `-1`. # Input: - `books`: List[int] — A sorted list of integers representing book IDs. - `book_id`: int — An integer representing the book ID to search for. # Output: - Returns an int representing the index of the last occurrence of `book_id` in `books`. If `book_id` is not found, return `-1`. # Constraints: - The list `books` will have at most 10^6 elements. - The book IDs will be integers ranging from -10^9 to 10^9. - The list `books` is guaranteed to be sorted in non-decreasing order. # Example: ```python assert find_last_occurrence([1, 3, 3, 3, 5, 6], 3) == 3 assert find_last_occurrence([1, 2, 2, 2, 3, 3, 4], 2) == 3 assert find_last_occurrence([1, 2, 3, 4, 5], 6) == -1 assert find_last_occurrence([], 3) == -1 ``` # Additional Constraints: - You must implement the function in O(log n) time complexity.","solution":"def find_last_occurrence(books, book_id): left, right = 0, len(books) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if books[mid] == book_id: result = mid left = mid + 1 elif books[mid] < book_id: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Coding Challenge: Stooge Sort Implementation and Analysis Context: You are tasked to implement a sorting algorithm called Stooge Sort. The Stooge Sort algorithm operates by recursively sorting portions of the array until the whole array is sorted. Even though Stooge Sort is notoriously inefficient for large datasets due to its high time complexity, this exercise will help you practice recursion and understand algorithm analysis. Problem Statement: Write a function `stoogesort(arr, l, h)` that sorts an array `arr` of integers using the Stooge Sort algorithm. The function should: 1. Swap the first and last elements if the first element is larger. 2. Recursively sort: * The first two-thirds of the array. * The last two-thirds of the array. * The first two-thirds of the array again to ensure sorting. 3. Handle edge cases such as arrays of size 1 or 2, and already sorted arrays. Input: * An array of integers `arr` to be sorted. * Two integer indices `l` and `h`, representing the current subsection of the array being sorted. Output: * The function should modify the array in place and not return any value. Constraints: * The initial call will always be `stoogesort(arr, 0, len(arr)-1)`. * The length of `arr` will be at most `100`. Example: ```python arr = [2, 4, 5, 3, 1] stoogesort(arr, 0, len(arr)-1) print(arr) # Output: [1, 2, 3, 4, 5] ``` Additional Instructions: 1. Ensure your implementation handles the edge cases. 2. Analyze and comment on the time complexity of your solution. 3. Discuss in a brief paragraph the practical applications of stooge sort (if any) and where you might prefer other sorting algorithms over stooge sort. You might use the provided code snippet for reference, but ensure to build and comment your solution distinctly, explaining each part of your code.","solution":"def stoogesort(arr, l, h): Sorts an array in place using the Stooge Sort algorithm. Parameters: arr (list): The array to be sorted. l (int): The starting index of the subsection of the array to be sorted. h (int): The ending index of the subsection of the array to be sorted. Returns: None if l >= h: return # Swap if the first element is larger than the last element if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than two elements in the array subsection if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort the first two-thirds stoogesort(arr, l, h - t) # Recursively sort the last two-thirds stoogesort(arr, l + t, h) # Recursively sort the first two-thirds again stoogesort(arr, l, h - t)"},{"question":"# Problem Description You are given an array of sorted characters containing only lowercase letters, and a target letter. Your task is to write a function that finds the smallest element in the array that is greater than the given target letter while considering the wrap-around scenario (i.e., if the target is \'z\' and the list contains \'a\', the answer should be \'a\'). # Function Signature ```python def find_next_greatest_letter(letters: List[str], target: str) -> str: ``` # Input Format - `letters`: A list of sorted characters `letters` containing only lowercase letters. - `target`: A single character `target` that needs to be matched against the list. # Output Format - Return the smallest character in the list that is greater than the target character. # Constraints - The length of `letters` will be in the range `[2, 10^4]`. - Each character in `letters` is a lowercase letter. - The list `letters` will be sorted and it may contain duplicates. - The `target` will be a single lowercase letter. # Examples 1. Input: `letters = [\\"c\\", \\"f\\", \\"j\\"]`, `target = \\"a\\"` Output: `\\"c\\"` 2. Input: `letters = [\\"c\\", \\"f\\", \\"j\\"]`, `target = \\"c\\"` Output: `\\"f\\"` 3. Input: `letters = [\\"c\\", \\"f\\", \\"j\\"]`, `target = \\"d\\"` Output: `\\"f\\"` # Requirements You need to implement the function efficiently considering edge cases like wrap-around scenario and handling target that might be at the end or beginning of the list. # Note * Aim for an optimal solution with time complexity O(log N) using binary search or a similar efficient approach.","solution":"from typing import List def find_next_greatest_letter(letters: List[str], target: str) -> str: left, right = 0, len(letters) - 1 if target >= letters[-1]: return letters[0] while left < right: mid = (left + right) // 2 if letters[mid] > target: right = mid else: left = mid + 1 return letters[left]"},{"question":"# Simplify Unix-Style File Paths Given an absolute path for a file (Unix-style), you need to simplify it to its canonical form. The canonical path should: - Start with a single slash \'/\'. - Have no trailing slashes. - Only consist of the directory names and single slashes separating them. - Resolve \'.\' which refers to the current directory. - Resolve \'..\' which moves up to the parent directory. Input and Output Formats * **Input**: A single string representing the absolute path (Unix-style). * **Output**: A single string representing the simplified canonical path. Constraints 1. The input string length does not exceed 10,000 characters. 2. The input string is a valid Unix path. Performance Requirements The function should run in linear time relative to the length of the input string. Example Scenarios 1. **Example 1:** - **Input**: `\\"/home/\\"` - **Output**: `\\"/home\\"` 2. **Example 2:** - **Input**: `\\"/a/./b/../../c/\\"` - **Output**: `\\"/c\\"` 3. **Example 3:** - **Input**: `\\"/../\\"` - **Output**: `\\"/\\"` 4. **Example 4:** - **Input**: `\\"/home//foo/\\"` - **Output**: `\\"/home/foo\\"` Edge Cases - Input containing multiple slashes should be simplified to a single slash. - Navigation above the root directory (using `..` from the root) should remain at the root. Implement the following function: ```python def simplify_path(path): :type path: str :rtype: str # Your code here ```","solution":"def simplify_path(path): Simplifies a given Unix-style file path to its canonical form. :type path: str :rtype: str stack = [] # Split the initial path by slash parts = path.split(\'/\') for part in parts: if part == \'\' or part == \'.\': # Ignore empty part and current directory part \'.\' continue elif part == \'..\': # Pop from stack if not empty if stack: stack.pop() else: # Valid directory name, push to stack stack.append(part) # Join stack to form canonical path return \'/\' + \'/\'.join(stack)"},{"question":"# Problem Description You are given a function that checks if a number is a \\"Magic Number\\". Your task is to implement a similar function to test if a number is *actually* magic, based on the problem constraints provided. # Function Signature ```python def is_magic_number(n: int) -> bool: Checks if the input number n is a magic number. Parameters: n (int): The input number to check Returns: bool: True if n is a magic number, False otherwise pass ``` # Input - An integer `n` (0 <= n <= 10^15) which you need to check for being a magic number. # Output - Return `True` if the number is a magic number. - Return `False` otherwise. # Constraints 1. The input number can range from 0 up to 10^15. 2. You must handle edge cases, including very small (single-digit) numbers and the largest possible numbers within the given range. # Performance Requirements - Your implementation should have a time complexity of O(d), where d is the number of digits in `n`. - The space complexity should be O(1). # Example ```python assert is_magic_number(50113) == True assert is_magic_number(1234) == True assert is_magic_number(199) == True assert is_magic_number(111) == False assert is_magic_number(1024) == True assert is_magic_number(28) == False ``` # Scenario Consider you\'re part of a team working on a fintech application, and you need to identify special \\"Magic Numbers\\" from a list of transaction IDs which follow the rules defined. Implement and test your solution to automate the identification process.","solution":"def is_magic_number(n: int) -> bool: Checks if the input number n is a magic number. Parameters: n (int): The input number to check Returns: bool: True if n is a magic number, False otherwise if n == 0: return True while n > 0: digit = n % 10 if digit not in {0, 1, 5}: return False n //= 10 return True"},{"question":"# Question: Matrix Transformations You are given a square matrix `matrix` of size `n x n` where `n >= 1`. Write three functions to perform specific transformations on this matrix: 1. **Rotate the Matrix 90 Degrees Clockwise:** ```python def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: # Your code here ``` 2. **Diagonal Inversion from Top-left to Bottom-right:** ```python def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: # Your code here ``` 3. **Diagonal Inversion from Bottom-left to Top-right:** ```python def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: # Your code here ``` You should not use any libraries for these transformations but rather manipulate the matrix in place or through basic list operations. # Input and Output - **Input**: A 2D list of integers `matrix` representing an `n x n` matrix. - **Output**: A new 2D list that represents the transformed matrix for each function. # Constraints - The input matrix will always be a non-empty square matrix (i.e., the number of rows equals the number of columns). - Elements of the matrix will be integers. # Example Given the input matrix: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` - After `rotate_clockwise(matrix)`, the returned matrix should be: ```python [ [7, 4, 1], [8, 5, 2], [9, 3, 0] ] ``` - After `top_left_invert(matrix)`, the returned matrix should be: ```python [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] ``` - After `bottom_left_invert(matrix)`, the returned matrix should be: ```python [ [9, 6, 3], [8, 5, 2], [7, 4, 1] ] ``` Create and implement these functions to accurately transform the matrix as described.","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotate the matrix 90 degrees clockwise. n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: Diagonal inversion from top-left to bottom-right. n = len(matrix) return [[matrix[j][i] for j in range(n)] for i in range(n)] def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: Diagonal inversion from bottom-left to top-right. n = len(matrix) return [[matrix[n - j - 1][n - i - 1] for j in range(n)] for i in range(n)]"},{"question":"# Question: Minimal Bit Flips to Convert Integers Given two integers A and B, write a function `count_flips_to_convert(A: int, B: int) -> int` to determine the minimal number of bits you need to flip to convert integer A to integer B. For instance, to convert the integer 29 to 15 (binary representation of 29 is 11101 and 15 is 01111), you must flip two bits: the third and the fifth bits. Input * Two integers, `A` and `B`, where (0 ≤ A, B ≤ 10^9). Output * An integer representing the minimal number of bits to flip. Constraints * Both integers will be non-negative. * The input integers will fit within the standard 32-bit integer ranges. Example ```python count_flips_to_convert(29, 15) -> 2 count_flips_to_convert(1, 1) -> 0 count_flips_to_convert(0, 8) -> 1 ``` Scenario Imagine you are working on a digital communication system and you need to calculate the minimal number of bit changes needed to fix a corrupted data transmission. Implement the `count_flips_to_convert` function to automate this process.","solution":"def count_flips_to_convert(A: int, B: int) -> int: Returns the minimal number of bits needed to flip to convert integer A to integer B. xor_result = A ^ B return bin(xor_result).count(\'1\')"},{"question":"You are tasked with designing a software feature that validates the structure of emails. Specifically, your task is to determine if the local parts (the section before the \'@\' symbol) of two emails are isomorphic. Two local parts are considered isomorphic if characters in the first local part can be replaced to get the second local part, with the same one-to-one character mapping. Write a function `is_isomorphic_emails(local1, local2)` that takes two strings representing the local parts of two emails and returns `True` if they are isomorphic, and `False` otherwise. Example: ```python print(is_isomorphic_emails(\\"abc\\", \\"xyz\\")) # True print(is_isomorphic_emails(\\"foo\\", \\"bar\\")) # False print(is_isomorphic_emails(\\"paper\\", \\"title\\")) # True ``` Constraints: * All characters in the local parts are ASCII characters. * The length of the strings will not exceed 10^4. * Only the local parts of the email addresses are considered, so \'@\' symbols or domain names are not included in the input strings. Input: * `local1`: A string representing the first local part. * `local2`: A string representing the second local part. Output: * Returns `True` if the local parts are isomorphic, otherwise returns `False`. Implement the `is_isomorphic_emails` function to solve this task.","solution":"def is_isomorphic_emails(local1, local2): Determines if two local parts of emails are isomorphic. if len(local1) != len(local2): return False mapping1 = {} mapping2 = {} for c1, c2 in zip(local1, local2): if c1 in mapping1: if mapping1[c1] != c2: return False else: mapping1[c1] = c2 if c2 in mapping2: if mapping2[c2] != c1: return False else: mapping2[c2] = c1 return True"},{"question":"You are required to implement a function that calculates the number of digits of an integer in constant time. This function will be used in a variety of scenarios, such as formatting numbers for display and performing numeric analyses. # Function Signature ```python def num_digits(n: int) -> int: pass ``` # Input * `n` (int): A non-floating point integer. (`|n| <= 10**18`) # Output * Returns an integer representing the number of digits in the given integer `n`. # Examples ```python assert num_digits(12345) == 5 assert num_digits(-9876) == 4 assert num_digits(0) == 1 assert num_digits(1000000000) == 10 ``` # Constraints * The function should handle both positive and negative numbers. * The function should return `1` for the input `0`. * The solution should execute in constant time, O(1). # Note * Ensure your solution considers edge cases such as very large positive and negative integers. * Avoid using any string conversion methods (like `str(n)`) to determine the number of digits. * Your implementation should utilize mathematical operations.","solution":"import math def num_digits(n: int) -> int: Returns the number of digits in an integer n. if n == 0: return 1 else: return int(math.log10(abs(n))) + 1"},{"question":"# Task: Compute the Skyline of a City You are given a list of buildings in a city, where each building is represented by a triplet of integers `[Li, Ri, Hi]`, where `Li` and `Ri` are the x coordinates of the left and right edge of the i-th building, respectively, and `Hi` is its height. The task is to produce the city\'s skyline. The skyline is represented as a list of \\"key points\\" which define the outer contour formed by the buildings when viewed from a distance. A key point is the left endpoint of a horizontal line segment. # Requirements - **Input Format**: - `buildings`: `List of List[int]` - Each building is represented by `[Li, Ri, Hi]` where `0 ≤ Li, Ri ≤ INT_MAX`, `0 < Hi ≤ INT_MAX`, and `Ri - Li > 0`. - **Output Format**: - A list of key points `[x, y]` representing the skyline. - **Constraints**: - The number of buildings is between [0, 10000]. - Consecutive horizontal lines of the same height should be merged. # Example: Input: ```python buildings = [[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]] ``` Output: ```python [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]] ``` # Implementation Details Implement the function `get_skyline(buildings)` that takes the list of buildings and returns the skyline as specified.","solution":"from heapq import heappush, heappop from collections import defaultdict def get_skyline(buildings): events = [] for L, R, H in buildings: events.append((L, -H, R)) events.append((R, 0, 0)) events.sort() res = [[0, 0]] pq = [(0, float(\'inf\'))] for x, negH, R in events: while pq[0][1] <= x: heappop(pq) if negH != 0: heappush(pq, (negH, R)) maxH = -pq[0][0] if res[-1][1] != maxH: res.append([x, maxH]) return res[1:]"},{"question":"# Programming Assessment Question: Implement and Analyze Prim\'s Algorithm Scenario You are tasked with designing a computer network that ensures all cities in a region are connected with the minimum possible cost. Your region is represented as a graph where nodes are cities and edges are the costs of laying network cables between pairs of cities. You need to implement Prim\'s algorithm to find the weight of the Minimum Spanning Tree (MST) to help estimate this cost efficiently. Requirements 1. **Function Name**: `calculate_mst_weight` 2. **Input**: A dictionary `graph` representing the network costs between cities. The keys are cities and the values are lists of tuples, where each tuple consists of the cost to connect to another city and the corresponding city. - Example format: ```python graph = { \'a\': [(3, \'b\'), (8, \'c\')], \'b\': [(3, \'a\'), (5, \'d\')], \'c\': [(8, \'a\'), (2, \'d\'), (4, \'e\')], \'d\': [(5, \'b\'), (2, \'c\'), (6, \'e\')], \'e\': [(4, \'c\'), (6, \'d\')] } ``` 3. **Output**: An integer representing the total cost of the MST. Return -1 if no spanning tree exists for the input graph. Constraints 1. Graph is connected and undirected. 2. Edges can have non-negative weights only. 3. Nodes will be represented by strings for simplicity. Performance Requirements * Your implementation should be efficient with a time complexity of O(E log V). * Use a priority queue to manage the edges as you find the MST. Function Signature ```python def calculate_mst_weight(graph: Dict[str, List[Tuple[int, str]]]) -> int: # Implement your function here, following Prim\'s Algorithm pass ``` **Note:** Ensure your solution checks for cycles, handles disconnected graphs appropriately, and provides a minimum spanning tree only when possible.","solution":"from heapq import heappop, heappush from typing import Dict, List, Tuple def calculate_mst_weight(graph: Dict[str, List[Tuple[int, str]]]) -> int: if not graph: return -1 # Start with an arbitrary node and use a priority queue start_node = next(iter(graph)) visited = set() min_heap = [(0, start_node)] # (cost, node) total_weight = 0 while min_heap: cost, node = heappop(min_heap) if node in visited: continue visited.add(node) total_weight += cost for edge_cost, neighbor in graph[node]: if neighbor not in visited: heappush(min_heap, (edge_cost, neighbor)) # If all nodes were visited, the graph was connected if len(visited) == len(graph): return total_weight return -1 # If not all nodes were visited, the graph is disconnected"},{"question":"<|Analysis Begin|> # Core Identification - **Algorithm/Data Structure**: Separate Chaining Hash Table - **Type**: Data Structure - **Purpose**: To manage a collection of key-value pairs and provide efficient lookups, insertions, and deletions while handling hash collisions using linked lists. # Complexity - **Time Complexity**: - Average case: O(1) for `put`, `get`, and `del_` - Worst case: O(n) when all elements hash to the same bucket - **Space Complexity**: O(n + m) where n is the number of elements and m is the size of the table (array of fixed size), with additional space for linked list nodes. # Principles The Separate Chaining Hash Table handles collisions by maintaining a linked list at each bucket in the hash table. When a new key-value pair is inserted, it is placed in the list corresponding to the bucket determined by the hash function. # Characteristics & Applications - **Properties**: - Utilizes linked list for handling collisions. - Keys that hash to the same bucket are stored in the same list. - **Common Use Cases**: - Implementation of associative arrays, dictionaries, or sets. - Applications requiring efficient key-value pair storage and retrieval. - **Strengths/Limitations**: - **Strengths**: Handles collisions gracefully, simple to implement, and allows for dynamic resizing. - **Limitations**: Potential clustering, which can degrade performance; space overhead due to linked lists. # Implementation Challenges - **Edge Cases**: - Handling insertion of duplicate keys. - Ensuring proper deletion when the key is at different positions in the linked list. - **Performance Bottlenecks**: High load factor (number of elements per bucket) can degrade performance to O(n). - **Error Scenarios**: Incorrect handling of linked list pointers can lead to memory leaks or incorrect deletions. - **Optimization Points**: Implement resizing of the hash table to maintain a low load factor, optimize the hash function for uniform distribution. <|Analysis End|> <|Question Begin|> # Problem Statement You are given an incomplete implementation of a Separate Chaining Hash Table, a common data structure used for implementing dictionaries with efficient average-case time complexity for insertions, deletions, and lookups. # Task Your task is to extend the current implementation by adding a method to resize the hash table when the load factor exceeds a specified threshold. Resizing involves creating a new, larger table and rehashing all existing key-value pairs into the new table. # Requirements 1. Implement a `resize` method that doubles the size of the table and rehashes all existing elements. 2. Modify the `put` method to call `resize` if the load factor exceeds 0.75 after the insertion. # Method Signature ```python def resize(self) -> None: Resize the hashtable to double its current size and rehash all existing elements. ``` # Input and Output Formats - **Input**: There is no direct input to the `resize` method, but it will be called internally by the `put` method. The hash table should automatically manage resizing based on the number of elements. - **Output**: The `resize` method does not return anything but internally updates the hash table\'s size and rehashes the existing elements. # Constraints - The hash table should maintain the correct mappings of all key-value pairs after resizing. - You can assume that the keys are of `str` type, and the values can be of any data type. - The initial size of the hash table is a prime number, to ensure spread across buckets. ```python import unittest class Node(object): def __init__(self, key=None, value=None, next=None): self.key = key self.value = value self.next = next class SeparateChainingHashTable(object): _empty = None def __init__(self, size=11): self.size = size self._len = 0 self._table = [self._empty] * size def put(self, key, value): if self._len / self.size > 0.75: self.resize() hash_ = self.hash(key) node_ = self._table[hash_] if node_ is self._empty: self._table[hash_] = Node(key, value) else: while node_.next is not None: if node_.key == key: node_.value = value return node_ = node_.next if node_.key == key: node_.value = value else: node_.next = Node(key, value) self._len += 1 def get(self, key): hash_ = self.hash(key) node_ = self._table[hash_] while node_ is not self._empty: if node_.key == key: return node_.value node_ = node_.next return None def del_(self, key): hash_ = self.hash(key) node_ = self._table[hash_] pre_node = None while node_ is not None: if node_.key == key: if pre_node is None: self._table[hash_] = node_.next else: pre_node.next = node_.next self._len -= 1 return pre_node = node_ node_ = node_.next def hash(self, key): return hash(key) % self.size def __len__(self): return self._len def __getitem__(self, key): return self.get(key) def __delitem__(self, key): return self.del_(key) def __setitem__(self, key, value): self.put(key, value) def resize(self): # Your implementation goes here pass # You can test your implementation using the following unittest class: class TestSeparateChainingHashTable(unittest.TestCase): def test_resize(self): table = SeparateChainingHashTable(size=2) table.put(\'key1\', \'value1\') table.put(\'key2\', \'value2\') table.put(\'key3\', \'value3\') # This should trigger a resize self.assertEqual(table.size, 4) self.assertEqual(table.get(\'key1\'), \'value1\') self.assertEqual(table.get(\'key2\'), \'value2\') self.assertEqual(table.get(\'key3\'), \'value3\') if __name__ == \\"__main__\\": unittest.main() ``` Make sure your `resize` method correctly handles the resizing and rehashing of elements without losing any data.","solution":"class Node(object): def __init__(self, key=None, value=None, next=None): self.key = key self.value = value self.next = next class SeparateChainingHashTable(object): _empty = None def __init__(self, size=11): self.size = size self._len = 0 self._table = [self._empty] * size def put(self, key, value): if self._len / self.size > 0.75: self.resize() hash_ = self.hash(key) node_ = self._table[hash_] if node_ is self._empty: self._table[hash_] = Node(key, value) else: while node_.next is not None: if node_.key == key: node_.value = value return node_ = node_.next if node_.key == key: node_.value = value else: node_.next = Node(key, value) self._len += 1 def get(self, key): hash_ = self.hash(key) node_ = self._table[hash_] while node_ is not self._empty: if node_.key == key: return node_.value node_ = node_.next return None def del_(self, key): hash_ = self.hash(key) node_ = self._table[hash_] pre_node = None while node_ is not None: if node_.key == key: if pre_node is None: self._table[hash_] = node_.next else: pre_node.next = node_.next self._len -= 1 return pre_node = node_ node_ = node_.next def hash(self, key): return hash(key) % self.size def __len__(self): return self._len def __getitem__(self, key): return self.get(key) def __delitem__(self, key): return self.del_(key) def __setitem__(self, key, value): self.put(key, value) def resize(self): new_size = self.size * 2 new_table = [self._empty] * new_size for i in range(self.size): node_ = self._table[i] while node_ is not self._empty: new_hash = hash(node_.key) % new_size if new_table[new_hash] is self._empty: new_table[new_hash] = Node(node_.key, node_.value) else: current = new_table[new_hash] while current.next is not None: current = current.next current.next = Node(node_.key, node_.value) node_ = node_.next self._table = new_table self.size = new_size"},{"question":"You are given a sorted array of integers in non-decreasing order. Your task is to implement a function that finds the index of a given target value using the interpolation search algorithm. If the target value is not present in the array, the function should return -1. Your implementation should handle edge cases effectively and ensure optimal performance for large, uniformly distributed datasets. # Input 1. An integer array `arr` of size `n` where (1 leq n leq 10^5). 2. An integer `target` which needs to be searched in the array. # Output An integer index of the `target` in the array, or -1 if the `target` is not present. # Constraints 1. The elements of `arr` are sorted in non-decreasing order. 2. ( -10^9 leq arr[i], text{target} leq 10^9 ) for (0 leq i < n). # Example ```python def interpolation_search(arr: List[int], target: int) -> int: # Your code here # Example Calls assert interpolation_search([5, 10, 12, 14, 17, 20, 21], 17) == 4 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], 7) == -1 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], 5) == 0 ``` # Requirements 1. Implement the function `interpolation_search(arr: List[int], target: int) -> int`. 2. The function should return the index of `target` in `arr`, and -1 if `target` is not found. 3. The function should have a time complexity closer to (O(log(log(n)))) in the average case. Ensure your solution accounts for edge cases and performs efficiently for large input sizes.","solution":"def interpolation_search(arr, target): Returns the index of the target in the sorted array arr using interpolation search. Returns -1 if the target is not found. low = 0 high = len(arr) - 1 while low <= high and target >= arr[low] and target <= arr[high]: if low == high: if arr[low] == target: return low return -1 pos = low + ((high - low) // (arr[high] - arr[low]) * (target - arr[low])) if arr[pos] == target: return pos if arr[pos] < target: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Scenario: You are tasked to implement a solution to flatten deeply nested lists. This task is common in data preprocessing and manipulation scenarios where heterogeneous nested lists have to be transformed into uniform flat lists for analysis and processing. # Problem Statement: Write a Python function `flatten(input_arr)` which takes a potentially nested list of elements and returns a single flattened list. The function should recursively process each element, flattening it if it is a list or directly appending it otherwise. Implement an iterative version of the flattening function `flatten_iter(iterable)` that produces a flat list in a memory-efficient manner using Python generators. # Function Signature: ```python def flatten(input_arr: list) -> list: # returns flattened list def flatten_iter(iterable) -> Iterable: # returns a generator for flattened list ``` # Input Format: 1. `input_arr` (list): A nested list where elements can be integers, floats, strings, or other lists containing similar elements. 2. `iterable` (collection.abc.Iterable): A potentially nested collection of similar elements. # Output Format: 1. `flatten`: Return a list with all nested elements flattened. 2. `flatten_iter`: Return an iterator that yields elements in a flattened manner. # Constraints: - Do not use any built-in flattening methods or libraries. - Handle cases with deeply nested lists. - Strings should be treated as scalar values, not iterable. # Example: ```python Example 1: input_arr = [1, [2, [3, 4]], 5] # Output: [1, 2, 3, 4, 5] flatten(input_arr) # Should return [1, 2, 3, 4, 5] Example 2: iterable = [1, [2, [\'three\'], [[4.5], [5]]], \'six\'] # Output: [1, 2, \'three\', 4.5, 5, \'six\'] list(flatten_iter(iterable)) # Should return [1, 2, \'three\', 4.5, 5, \'six\'] ``` Ensure your implementation handles various edge cases such as empty arrays, mixed data types, and deeply nested structures.","solution":"from collections.abc import Iterable def flatten(input_arr): Flattens a deeply nested list into a single list. flat_list = [] def _flatten(elem): if isinstance(elem, list): for sub_elem in elem: _flatten(sub_elem) else: flat_list.append(elem) _flatten(input_arr) return flat_list def flatten_iter(iterable): Flattens a deeply nested iterable into a single flat list using generators. stack = [iter(iterable)] while stack: try: elem = next(stack[-1]) if isinstance(elem, list): stack.append(iter(elem)) else: yield elem except StopIteration: stack.pop()"},{"question":"Context You are given a dataset represented as an array of integers. Your task is to write a function that finds the most frequent integer (or integers) in the array. In case there are multiple integers with the same frequency, return all of them in a list. The solution should handle the case where the array might be empty and return an empty list accordingly. Requirements * Input: An array of integers. * Output: A list containing the most frequent integer(s) in the input array. The function should be efficient in terms of time and space complexity, ideally linear O(n) time complexity. Constraints * The array can have a maximum length of 100,000. * The integers in the array range from -10^6 to 10^6. Function Signature ```python def most_frequent_elements(arr: List[int]) -> List[int]: pass ``` Example *Example 1*: ```python Input: [1, 1, 2, 2, 3, 4] Output: [1, 2] ``` *Example 2*: ```python Input: [1, 2, 2, 3, 3, 3, 4, 4, 4] Output: [3, 4] ``` *Example 3*: ```python Input: [5] Output: [5] ``` *Example 4*: ```python Input: [] Output: [] ``` Notes * If the input array is empty, return an empty list. * Do not use any built-in library functions that do the frequency calculation automatically. Implement the counting logic manually.","solution":"from collections import defaultdict from typing import List def most_frequent_elements(arr: List[int]) -> List[int]: Returns a list of the most frequent integer(s) in the array. In case of a tie, returns all the integers with the maximum frequency. if not arr: return [] frequency = defaultdict(int) # Count the frequency of each element for num in arr: frequency[num] += 1 # Find the maximum frequency max_freq = max(frequency.values()) # Collect all elements with the maximum frequency most_frequent = [num for num, freq in frequency.items() if freq == max_freq] return most_frequent"},{"question":"Problem Context: You\'re tasked with developing a new feature for a tree visualization tool. This tool needs to list all root-to-leaf paths in a binary tree in a readable format, using the depth-first search strategy. Task: Write a function `binary_tree_paths(root)` that takes the root of a binary tree and returns a list of all root-to-leaf paths formatted as strings of node values connected by \'->\'. Assume the input is provided as a tree node class with attributes `val`, `left`, and `right`. Function Signature: ```python def binary_tree_paths(root): # your code here ``` Input: - `root`: The root node of the binary tree. Each node in the tree has `val`, `left`, and `right` attributes, where `val` is an integer value, and `left` and `right` are either `None` or other tree nodes. Output: - A list of strings, each representing a root-to-leaf path. Constraints: - Tree nodes will have integer values in the range [-100, 100]. - The number of nodes in the tree will not exceed 1000. Example: Given the following binary tree: ``` 1 / 2 3 5 ``` - Input: `root` representing the tree above. - Output: `[\\"1->2->5\\", \\"1->3\\"]` Additional Notes: - Focus on clarity and efficiency. - Handle edge cases like an empty tree or a tree with only one node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): Given the root of a binary tree, returns all root-to-leaf paths in a list as strings formatted with \'->\'. if not root: return [] paths = [] def dfs(node, current_path): if node: current_path += str(node.val) if not node.left and not node.right: # if leaf node paths.append(current_path) else: current_path += \'->\' dfs(node.left, current_path) dfs(node.right, current_path) dfs(root, \\"\\") return paths"},{"question":"In this problem, you are required to write a function that calculates the number of digits in an integer, including handling edge cases effectively. Function Signature: ```python def num_digits(n: int) -> int: ``` # Input: - An integer `n` where `-10^9 <= n <= 10^9`. # Output: - An integer representing the number of digits in `n`. # Constraints: 1. If `n` is 0, the number of digits should be 1. 2. If `n` is negative, count the digits of its absolute value. # Examples: ```python num_digits(1234) -> 4 num_digits(-1234) -> 4 num_digits(0) -> 1 num_digits(999999999) -> 9 num_digits(-999999999) -> 9 ``` # Scenario: Imagine you are writing a numeric analysis tool that needs to perform with strict performance guarantees. You are tasked with implementing the `num_digits` function to count the number of digits in an integer efficiently. This function will be called frequently, so it needs to handle up to the maximum constraints efficiently. # Constraints: - The input integer `n` can range between `-10^9` and `10^9`. - You should achieve this in constant time O(1) and use constant space O(1). # Explanation: - The function should handle zero appropriately, considering it has one digit. - Negative numbers should be converted to their absolute value before counting the number of digits. Implement the `num_digits` function with these requirements in mind.","solution":"def num_digits(n: int) -> int: Calculate the number of digits in the integer n. If n is negative, count the digits of its absolute value. If n is 0, return 1 as 0 has one digit. :param n: Input integer :return: Number of digits in the input integer if n == 0: return 1 return len(str(abs(n)))"},{"question":"# Coding Exercise: Enhanced Jump Search **Scenario**: Your task is to enhance and implement an optimized version of the Jump Search algorithm, taking into account edge cases and performance improvements. Imagine you’re part of a software engineering team that needs an efficient searching algorithm to integrate into a large-scale database system for quick retrieval of records. **Problem**: Implement a function `optimized_jump_search` that efficiently finds the index of a given `target` value in a sorted list `arr` of integers. The list could be very large, so consider optimizations that minimize the number of comparisons. **Function Signature**: ```python def optimized_jump_search(arr: List[int], target: int) -> int: pass ``` **Inputs**: - `arr` (List[int]): A sorted list of integers. - `target` (int): The integer value to search for. **Returns**: - int: The index of the `target` value in `arr` if found, otherwise -1. **Constraints**: - All elements in `arr` are distinct. - 0 <= len(arr) <= 10^6 - -10^9 <= arr[i], target <= 10^9 **Example**: ```python # Example 1: arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21] target = 15 print(optimized_jump_search(arr, target)) # Output: 7 # Example 2: arr = [2, 4, 6, 8, 10, 12] target = 5 print(optimized_jump_search(arr, target)) # Output: -1 # Example 3: arr = [-10, -3, 0, 1, 4, 7] target = -10 print(optimized_jump_search(arr, target)) # Output: 0 ``` **Requirements**: 1. Your method should follow the principles of jump search. 2. Ensure that the chosen block size minimizes the number of comparisons. 3. Handle edge cases, where the target is out of bounds, efficiently. 4. Aim to reduce the overall time complexity even further if possible by implementing any relevant optimizations.","solution":"import math from typing import List def optimized_jump_search(arr: List[int], target: int) -> int: n = len(arr) if n == 0: return -1 # List is empty # Finding the optimal block size to be jumped step = int(math.sqrt(n)) prev = 0 # Finding the block where the element is present (if it is present) while prev < n and arr[min(step, n) - 1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 # Doing a linear search for target in the block beginning with prev while prev < min(step, n): if arr[prev] == target: return prev prev += 1 return -1"},{"question":"# RSA Encryption Coding Challenge Objective Implement functions to generate RSA keys, encrypt, and decrypt text messages. This exercise will test your understanding of RSA encryption, prime number generation, and modular arithmetic. Scenario You are working on a secure communication application. To ensure that messages can be securely transmitted between users, you need to implement RSA encryption and decryption. Task Complete the following three functions: 1. `generate_key_pairs(k: int) -> tuple`: Generates and returns the public and private RSA keys. 2. `encrypt_message(message: str, public_key: tuple) -> list`: Encrypts a string message using the provided public key. 3. `decrypt_message(encrypted_message: list, private_key: tuple) -> str`: Decrypts a list of encrypted values using the private key to return the original string message. Function Specifications 1. **Function: `generate_key_pairs(k: int) -> tuple`** - **Input**: Integer `k`, the number of bits in the modulus `n`. - **Output**: A tuple containing: - Public key as a tuple `(e, n)`. - Private key as a tuple `(d, n)`. 2. **Function: `encrypt_message(message: str, public_key: tuple) -> list`** - **Input**: - `message`: The message to be encrypted as a string. - `public_key`: A tuple `(e, n)` where `e` is the encryption exponent and `n` is the modulus. - **Output**: A list of integers representing the encrypted message. 3. **Function: `decrypt_message(encrypted_message: list, private_key: tuple) -> str`** - **Input**: - `encrypted_message`: The encrypted message as a list of integers. - `private_key`: A tuple `(d, n)` where `d` is the decryption exponent and `n` is the modulus. - **Output**: The decrypted message as a string. Constraints 1. You must implement your own prime number generator and modular inverse function. 2. The message to be encrypted will only contain ASCII characters. 3. You can assume that the functions will be tested with reasonable inputs that fit within typical integer bounds. Example ```python public_key, private_key = generate_key_pairs(16) message = \\"Hello\\" encrypted_message = encrypt_message(message, public_key) decrypted_message = decrypt_message(encrypted_message, private_key) assert decrypted_message == message ```","solution":"import random from sympy import isprime, mod_inverse def generate_prime_candidate(length): Generate an odd integer randomly p = random.getrandbits(length) # apply a mask to set MSB and LSB to 1 p |= (1 << length - 1) | 1 return p def generate_prime_number(length=1024): Generate a prime number of \'length\' bits p = 4 while not isprime(p): p = generate_prime_candidate(length) return p def generate_key_pairs(k): Generates and returns the public and private RSA keys. # Generate two large prime numbers p and q p = generate_prime_number(k//2) q = generate_prime_number(k//2) n = p * q # modulus phi = (p - 1) * (q - 1) # Euler\'s totient # Choose an integer e such that 1 < e < phi and gcd(e, phi) is 1 (e and phi are coprime) e = random.randrange(2, phi) g = gcd(e, phi) while g != 1: e = random.randrange(2, phi) g = gcd(e, phi) # Calculate d such that (d * e) % phi == 1 d = mod_inverse(e, phi) return (e, n), (d, n) def gcd(a, b): Return the greatest common divisor using Euclid\'s Algorithm. while b != 0: a, b = b, a % b return a def encrypt_message(message, public_key): Encrypts a string message using the provided public key. e, n = public_key encrypted_message = [(ord(char) ** e) % n for char in message] return encrypted_message def decrypt_message(encrypted_message, private_key): Decrypts a list of encrypted values using the private key to return the original string message. d, n = private_key decrypted_message = \'\'.join([chr((char ** d) % n) for char in encrypted_message]) return decrypted_message"},{"question":"# Longest Common Subsequence Problem Scenario: You are working on a genomic research to compare DNA sequences and identify the common subsequence between two given DNA strands. This requires finding the longest sequence that appears in both strands, potentially with other characters in between. Task: Write a function `longest_common_subsequence(dna1: str, dna2: str) -> int` that takes two strings representing DNA sequences and returns the length of the longest common subsequence. Requirements: 1. The function should use dynamic programming to solve the problem. 2. Ensure optimal time and space usage where feasible. 3. Handle edge cases such as empty strings or completely non-matching sequences. Input: * Two strings `dna1` and `dna2` containing only lowercase English letters. Output: * Returns an integer representing the length of the longest common subsequence. Constraints: 1. The lengths of `dna1` and `dna2` will not exceed 1000 characters. Example: ```python def test_longest_common_subsequence(): assert longest_common_subsequence(\\"abcdgh\\", \\"aedfhr\\") == 3, \\"Test case 1 failed\\" assert longest_common_subsequence(\\"abc\\", \\"abc\\") == 3, \\"Test case 2 failed\\" assert longest_common_subsequence(\\"abc\\", \\"def\\") == 0, \\"Test case 3 failed\\" assert longest_common_subsequence(\\"\\", \\"abc\\") == 0, \\"Test case 4 failed\\" assert longest_common_subsequence(\\"abcd\\", \\"xyzabcduvw\\") == 4, \\"Test case 5 failed\\" print(\\"All test cases pass\\") if __name__ == \\"__main__\\": test_longest_common_subsequence() ```","solution":"def longest_common_subsequence(dna1: str, dna2: str) -> int: Returns the length of the longest common subsequence between two DNA sequences. m, n = len(dna1), len(dna2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if dna1[i - 1] == dna2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"Interpolation Search Enhancement Problem Statement: You are provided with an implementation of the interpolation search algorithm, which is efficient for searching in uniformly distributed arrays. However, there are several edge cases and performance issues in the current implementation. Your task is to enhance the interpolation_search function to handle these edge cases and optimize the performance. Specifically, you should: 1. Ensure that the function handles arrays with uniform and non-uniform distributions. 2. Handle the edge case where `(array[high] == array[low])` to avoid division by zero. 3. Make the function robust to input arrays with duplicate elements. 4. Ensure the function returns the correct result for all valid inputs. Function Signature: ```python def enhanced_interpolation_search(array: List[int], search_key: int) -> int: pass ``` Input: * `array`: A list of integers, which may contain duplicate values. * `search_key`: An integer value to be searched in the array. Output: * The function should return the index of the search key if found, otherwise -1. Constraints: * The array will contain at least one element and at most `10^6` elements. * All integers in the `array` are within the range `[-10^9, 10^9]`. Example: ```python assert enhanced_interpolation_search([10, 20, 30, 40, 50], 30) == 2 assert enhanced_interpolation_search([1, 2, 2, 3, 3], 2) == 1 # could be index 1 or 2 assert enhanced_interpolation_search([1, 2, 2, 2, 3], 2) in [1, 2, 3] assert enhanced_interpolation_search([1, 2, 3, 4, 5], 6) == -1 assert enhanced_interpolation_search([-10, -5, 0, 5, 10], -5) == 1 assert enhanced_interpolation_search([42, 42, 42, 42, 42], 42) in [0, 1, 2, 3, 4] ``` Notes: 1. Pay close attention to avoid division by zero errors when `array[high] == array[low]`. 2. Ensure the solution is efficient in terms of both time and space complexity. Good luck!","solution":"def enhanced_interpolation_search(array, search_key): Interpolation search function that handles edge cases and optimizes performance. :param array: List of integers to search within :param search_key: Integer value to search for :return: The index of the search_key if found, otherwise -1 low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 # Probing position with keeping uniform distribution in mind if array[high] - array[low] == 0: if array[low] == search_key: return low return -1 pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) # Boundary conditions to avoid out of index errors pos = max(low, min(pos, high)) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Maximum Flow Problem Using Dinic\'s Algorithm Scenario You are tasked with developing an optimal traffic routing system for a city. The city\'s road network is represented as a directed graph where intersections correspond to vertices and roads correspond to edges. The capacity of an edge represents the maximum number of vehicles that can travel on that road per unit time. You need to determine the maximum number of vehicles that can travel from a designated source intersection to a sink intersection simultaneously. Objective Implement a function to compute the maximum flow in a directed graph using Dinic\'s Algorithm. Function Specification ```python def dinic(capacity: List[List[int]], source: int, sink: int) -> int: Calculate the maximum flow from source to sink in a flow network. :param capacity: 2D list representing the capacity of each edge in the graph. capacity[i][j] is the capacity from vertex i to vertex j. If there is no edge between i and j, capacity[i][j] should be zero. :param source: The source vertex. :param sink: The sink vertex. :return: The maximum flow from source to sink in the given network. ``` Constraints 1. The graph is a directed graph. 2. The capacity will be a square matrix of size v*v with non-negative integers. 3. 1 <= v <= 500, where v is the number of vertices in the network. 4. 0 <= capacity[i][j] <= 10^9 Input - A 2D list `capacity` of size v*v where capacity[i][j] represents the capacity of the edge from vertex i to vertex j. - An integer `source` representing the source vertex. - An integer `sink` representing the sink vertex. Output - An integer representing the maximum flow from the source to the sink. Example ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 print(dinic(capacity, source, sink)) # Output should be 23 ``` The function should compute and return the maximum flow from the source to the sink in the given graph. **Note**: Make sure your solution is efficient and handles the constraints effectively.","solution":"from collections import deque from typing import List def dinic(capacity: List[List[int]], source: int, sink: int) -> int: n = len(capacity) flow = [[0] * n for _ in range(n)] level = [-1] * n queue = deque() def bfs(): nonlocal level, queue level = [-1] * n level[source] = 0 queue.clear() queue.append(source) while queue: u = queue.popleft() for v in range(n): if level[v] < 0 and flow[u][v] < capacity[u][v]: level[v] = level[u] + 1 queue.append(v) return level[sink] >= 0 def dfs(u, f): if u == sink: return f total_flow = 0 for v in range(n): if level[v] == level[u] + 1 and flow[u][v] < capacity[u][v]: current_flow = min(f, capacity[u][v] - flow[u][v]) temp_flow = dfs(v, current_flow) if temp_flow > 0: flow[u][v] += temp_flow flow[v][u] -= temp_flow total_flow += temp_flow f -= temp_flow if f == 0: break return total_flow max_flow = 0 while bfs(): max_flow += dfs(source, float(\'Inf\')) return max_flow"},{"question":"You are given an array of integers where you need to implement a function to sort the array using Gnome Sort and then return the sorted array. Analyze the algorithm\'s performance, and provide a solution that handles specified edge cases effectively. # Function Signature ```python def gnome_sort(arr: List[int]) -> List[int]: pass ``` # Input and Output - **Input**: A list of integers `arr` with the following constraints: - (1 leq text{len}(arr) leq 10^3) - ( -10^4 leq text{arr[i]} leq 10^4 ) - **Output**: A list of integers sorted in non-decreasing order. # Examples ```python # Example 1 arr = [34, 2, -5, 17] print(gnome_sort(arr)) # Output: [-5, 2, 17, 34] # Example 2 arr = [5, 3, 8, 4, 2] print(gnome_sort(arr)) # Output: [2, 3, 4, 5, 8] # Example 3 arr = [1, 1, 1, 1, 1] print(gnome_sort(arr)) # Output: [1, 1, 1, 1, 1] ``` # Constraints - Focus on correctly implementing the Gnome Sort algorithm based on the provided guidelines. - Thoroughly test the code with various edge cases, such as already sorted arrays, arrays with identical elements, and arrays with different lengths. - Aim for a solution that works within the given input size constraints efficiently.","solution":"def gnome_sort(arr): Sorts the provided list using the Gnome Sort algorithm. Gnome Sort is similar to insertion sort but moving elements to their position like a garden gnome sorting garden paths. Parameters: arr (list of int): Input list of integers to be sorted Returns: list of int: Sorted list of integers index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"**Question**: Implement a function to right-rotate an array of integers by k steps efficiently. # Scenario: You are given an array of `n` integers and an integer `k`. Your task is to rotate the array to the right by `k` steps. # Requirements: - Write a function `rotate_array(array, k)` that takes an array of integers and an integer k and returns the array rotated to the right by k steps. - Your implementation should be efficient in terms of time complexity. - The elements should be rotated in-place, but you can return the modified array for verification. # Input: - array: List[int] (0 <= len(array) <= 10^5, elements are integers) - k: int (0 <= k <= 10^5) # Output: - List[int]: Rotated array by k steps to the right. # Examples: 1. Input: array = [1, 2, 3, 4, 5, 6, 7], k = 3 Output: [5, 6, 7, 1, 2, 3, 4] 2. Input: array = [1, 2, 3, 4, 5], k = 7 Output: [4, 5, 1, 2, 3] 3. Input: array = [0, 0, 0, 1], k = 2 Output: [0, 1, 0, 0] # Constraints: - The input array can be empty or contain only one element. - Variable `k` can be greater than the length of the array. - Your solution should handle in-place modifications correctly and avoid using extra space for another array. # Points to Consider: - Array boundaries for left and right rotations. - Optimization for performance: Ensure your solution has O(n) time complexity. - Cover edge cases like an empty array or rotations greater than the array length. **Function Signature:** ```python def rotate_array(array: List[int], k: int) -> List[int]: pass ```","solution":"from typing import List def rotate_array(array: List[int], k: int) -> List[int]: n = len(array) if n == 0: return array k = k % n # In case k is larger than the array length array[:] = array[-k:] + array[:-k] return array"},{"question":"Context: You are developing a cryptographic tool that relies on number theory. To complete this tool, you need to implement two critical mathematical functions. One will compute the modular inverse, which is essential for decrypting messages. Task: Implement the following two functions: 1. `extended_gcd(a: int, b: int) -> [int, int, int]`: * This function should implement the Extended Euclidean Algorithm. It should return a tuple `(s, t, gcd)` where `s` and `t` are such that `a * s + b * t = gcd(a, b)`. 2. `modular_inverse(a: int, m: int) -> int`: * This function should return the modular inverse of `a` under modulo `m`. If `a` and `m` are not coprime, it should raise a `ValueError` with the message `\\"a and m must be coprime\\"`. Input and Output Formats: - For `extended_gcd(a: int, b: int) -> [int, int, int]`: * Input: Two integers `a` and `b`. * Output: A list `[s, t, gcd]`. - For `modular_inverse(a: int, m: int) -> int`: * Input: Two integers `a` and `m`, where `1 <= a, m <= 10^9` and `a` and `m` are coprime. * Output: A single integer, the modular inverse of `a` modulo `m`. Constraints: - `1 <= a, b <= 10^9`. - `1 <= a, m <= 10^9`, and `a` must be coprime with `m`. Examples: 1. For `extended_gcd(30, 20)`, the output should be `[1, -1, 10]` since `30 * 1 + 20 * (-1) = 10`. 2. For `modular_inverse(3, 11)`, the output should be `4` since `3 * 4 ≡ 1 (mod 11)`. Ensure your implementation is efficient and handles edge cases effectively.","solution":"def extended_gcd(a, b): Implements the Extended Euclidean Algorithm. Returns a tuple (s, t, gcd) where s and t are such that a * s + b * t = gcd(a, b). if a == 0: return (0, 1, b) else: s1, t1, gcd = extended_gcd(b % a, a) s = t1 - (b // a) * s1 t = s1 return (s, t, gcd) def modular_inverse(a, m): Returns the modular inverse of a under modulo m. If a and m are not coprime, raises a ValueError with the message \\"a and m must be coprime\\". s, t, gcd = extended_gcd(a, m) if gcd != 1: raise ValueError(\\"a and m must be coprime\\") else: return s % m"},{"question":"# Scenario You are developing a system that processes large datasets, and sorting these datasets efficiently is crucial. You\'ve decided to use Merge Sort due to its consistent performance and stability. # Task Implement the Merge Sort algorithm in Python following the principles described. The function should take an array of integers and return a sorted array in ascending order. Additionally, implement an optimized in-place merge operation to reduce memory overhead. # Requirements * Expected Input: * An array of integers `arr` (1 ≤ len(arr) ≤ 10^5, -10^9 ≤ arr[i] ≤ 10^9). * Expected Output: * A sorted array of integers in ascending order. * Constraints: * Your implementation should aim to use O(n) extra space for the merge operation. * The solution should handle large arrays efficiently within the time limits. Function Signature: ```python def merge_sort(arr: List[int]) -> List[int]: ``` # Example ```python # Example-1 input_arr = [34, 7, 23, 32, 5, 62] output_arr = merge_sort(input_arr) # Output: [5, 7, 23, 32, 34, 62] # Example-2 input_arr = [1, 3, 2, 6, 4, 5] output_arr = merge_sort(input_arr) # Output: [1, 2, 3, 4, 5, 6] ``` # Notes * Consider handling empty or single-element arrays explicitly. * Aim to optimize the merge operation to perform in-place merging to minimize space overhead.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts the given array using the merge sort algorithm with optimized in-place merge. if len(arr) > 1: mid = len(arr) // 2 left_half = arr[:mid] right_half = arr[mid:] merge_sort(left_half) merge_sort(right_half) merge(arr, left_half, right_half) return arr def merge(arr: List[int], left_half: List[int], right_half: List[int]): i = j = k = 0 # Copy data to temp arrays L[] and R[] while i < len(left_half) and j < len(right_half): if left_half[i] < right_half[j]: arr[k] = left_half[i] i += 1 else: arr[k] = right_half[j] j += 1 k += 1 # Checking if any element was left while i < len(left_half): arr[k] = left_half[i] i += 1 k += 1 while j < len(right_half): arr[k] = right_half[j] j += 1 k += 1"},{"question":"# Zigzag Iterator Extended You are given k sorted lists of integers. Your task is to implement a `ZigZagIteratorK` class that outputs elements in a zigzag (interleaving) order from all the k lists until all lists are exhausted. Requirements: - **Initialization**: - `__init__(self, lists: List[List[int]])`: Initialize the iterator with the list of lists. - **Methods**: - `next(self) -> int`: Returns the next element in the zigzag sequence. - `has_next(self) -> bool`: Returns `True` if there are still elements remaining in the lists, otherwise `False`. # Constraints: - All lists contain integers. - The number of lists (k) can vary and they can be of unequal lengths. - Your solution should optimize for both timing and space complexity. # Example: ```python lists = [[1, 2, 3], [4, 5, 6, 7], [8, 9]] it = ZigZagIteratorK(lists) result = [] while it.has_next(): result.append(it.next()) print(result) ``` **Output**: ``` [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` This means the element order from multiple lists should be interleaved as much as possible, moving from one list to the next.","solution":"from typing import List from collections import deque class ZigZagIteratorK: def __init__(self, lists: List[List[int]]): self.queue = deque() for idx, lst in enumerate(lists): if lst: # only non-empty lists are added to the queue self.queue.append((idx, 0)) self.lists = lists def next(self) -> int: if not self.has_next(): raise Exception(\\"No more elements\\") idx, elem_idx = self.queue.popleft() elem = self.lists[idx][elem_idx] # If there are more elements in the current list, add the next index to the queue if elem_idx + 1 < len(self.lists[idx]): self.queue.append((idx, elem_idx + 1)) return elem def has_next(self) -> bool: return len(self.queue) > 0"},{"question":"Question: You are given a unique and fun task to demonstrate your understanding of sorting algorithms and probabilities through the implementation of Bogo Sort. However, due to its infamous inefficiency, you are required to implement `limited_bogo_sort` that limits the number of shuffling attempts to a maximum threshold. If the sorting is not successful within this threshold, the function should return an appropriate failure message along with the attempted array state. Function Signature: ```python def limited_bogo_sort(arr: list, threshold: int, simulation: bool = False) -> tuple: Perform Bogo Sort but limit to a number of attempts defined by the threshold. Args: arr (list): The input list of integers to be sorted. threshold (int): The maximum number of shuffle attempts. simulation (bool): If True, print each iteration of array state. Returns: tuple: Contains a message (str) indicating success or failure, and the array. ``` Input and Output: * **Input**: - `arr`: List of integers which you need to sort. - `threshold`: Integer value to limit the number of shuffling attempts. - `simulation`: Boolean value, if `True`, prints detailed log of each iteration. * **Output**: - A tuple containing: 1. A **message** string indicating \\"Sorted Successfully\\" or \\"Failed to Sort\\". 2. The **resultant array** after attempted shuffles. Constraints: * The input list can have a length of up to 10 elements. * Elements are integers between -1000 to 1000. * The threshold value is a positive integer, typically provided between 1 and 1000. Example: ```python print(limited_bogo_sort([3, 2, 1], threshold=100, simulation=True)) # Output: (\'Failed to Sort\', [some permutation of input after 100 attempts]) ``` Performance Requirements: - Ensure the random shuffle implementation is efficient and unbiased. - Efficiently check if the array is sorted after each shuffle.","solution":"import random def limited_bogo_sort(arr: list, threshold: int, simulation: bool = False) -> tuple: Perform Bogo Sort but limit to a number of attempts defined by the threshold. Args: arr (list): The input list of integers to be sorted. threshold (int): The maximum number of shuffle attempts. simulation (bool): If True, print each iteration of array state. Returns: tuple: Contains a message (str) indicating success or failure, and the array. def is_sorted(arr): Check if the array is sorted in ascending order. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True attempts = 0 while attempts < threshold: if is_sorted(arr): return (\\"Sorted Successfully\\", arr) random.shuffle(arr) attempts += 1 if simulation: print(f\\"Attempt {attempts}: {arr}\\") return (\\"Failed to Sort\\", arr)"},{"question":"Scenario: You are tasked with developing a utility for a software system that processes large numerical datasets. One of the requirements is to analyze the number of digits in the numbers being processed to impose certain constraints and optimizations. Your task is to implement a function to calculate the number of digits in an integer. Function Details * **Function Name**: `num_digits` * **Input**: A single integer `n` * Constraints: * -10^18 ≤ `n` ≤ 10^18 * **Output**: An integer, the number of digits in the input number. Requirements: * Handle both positive and negative numbers. * Handle zero correctly. * Implement the function to run in constant time O(1). Example ```python >>> num_digits(12345) 5 >>> num_digits(0) 1 >>> num_digits(-123) 3 >>> num_digits(999999999999999999) 18 ``` Implement the function below: ```python import math def num_digits(n): # Your code here ``` Ensure your function passes the example test cases.","solution":"def num_digits(n): Returns the number of digits in an integer n. Handles both positive and negative numbers, and zero. # Convert the number to its absolute value and then to string abs_str = str(abs(n)) # The length of this string is the number of digits return len(abs_str)"},{"question":"You are provided with an integer stack. Your task is to replace every element in the stack with two occurrences of that element. Implement the function `stutter_stack` which follows this behavior using auxiliary storage. # Function Signature ```python def stutter_stack(stack: list[int]) -> list[int]: ``` # Input - `stack`: A list of integers representing the stack where the last element of the list is the top of the stack. # Output - The function should return the modified stack where each original element is repeated twice. # Constraints - The stack can contain up to `10^5` elements. - Each element in the stack is an integer between `-10^9` and `10^9`. # Requirements - Use a **queue** as auxiliary storage for your implementation. - Ensure the original order of elements is maintained after duplication. - Optimize for both time and space complexity. # Example ```python stack = [3, 7, 1, 14, 9] stutter_stack(stack) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` # Edge Cases - When the stack is empty, the output should be an empty stack. - When the stack contains one element `[x]`, the output should be `[x, x]`.","solution":"from collections import deque def stutter_stack(stack: list[int]) -> list[int]: Replaces every element in the stack with two occurrences of that element. Uses a queue as auxiliary storage to maintain order. Args: stack (list[int]): The input stack where the last element is the top of the stack. Returns: list[int]: The modified stack with each element repeated twice. queue = deque() # Transfer elements to the queue and double them while stack: elem = stack.pop() queue.appendleft(elem) queue.appendleft(elem) # Transfer elements back to the stack while queue: stack.append(queue.popleft()) return stack"},{"question":"Given a non-negative integer, determine if it is a Magic Number. A Magic Number is a number which eventually reduces to 1 when the sum of its digits is repeatedly calculated until a single digit is obtained. Write a function `is_magic_number(n: int) -> bool` that determines if the input number `n` is a Magic Number. # Input * `n` (non-negative integer) # Output * A boolean value. Return `True` if `n` is a Magic Number; otherwise, return `False`. # Constraints * `0 <= n <= 10^9` # Examples 1. Input: `50113` Output: `True` 2. Input: `1234` Output: `True` 3. Input: `199` Output: `True` 4. Input: `111` Output: `False` # Notes * Ensure your solution handles the maximum constraint efficiently. * Consider edge cases where `n` is 0 or a single-digit number.","solution":"def is_magic_number(n: int) -> bool: Determines if the given number is a Magic Number. A Magic Number eventually reduces to 1 when the sum of its digits is repeatedly calculated until a single digit is obtained. Parameters: n (int): The non-negative integer number. Returns: bool: True if n is a Magic Number, False otherwise. if n == 0: return False # 0 is not considered a magic number in this context while n >= 10: n = sum(int(digit) for digit in str(n)) return n == 1"},{"question":"Implement a function to determine the longest common prefix among an array of strings using the vertical scanning method. If there is no common prefix, return an empty string. Write a function `longest_common_prefix(strs)` that: - **Input**: Receives a list of strings `strs` where: - The number of strings `1 <= len(strs) <= 200`. - The length of each string `0 <= len(str) <= 200`. - **Output**: Returns the longest common prefix string. # Constraints: - If the input list is empty, return an empty string. - All given strings consist of lowercase English letters. # Requirements: - The solution should exhibit efficient performance for the given constraints. # Example: ```python Example 1: Input: [\\"flower\\",\\"flow\\",\\"flight\\"] Output: \\"fl\\" Example 2: Input: [\\"dog\\",\\"racecar\\",\\"car\\"] Output: \\"\\" Explanation: There is no common prefix among the input strings. ``` # Additional Information: You need to handle edge cases such as when the list is empty or contains only one string. Consider performance implications of your algorithm in explaining your solution. **Note**: Do not use example code provided in the prompt directly. Formulate your own solution based on the vertical scan principle discussed. Good luck! Your solution should demonstrate clarity, efficiency, and correctness.","solution":"def longest_common_prefix(strs): Determines the longest common prefix string among an array of strings. Args: strs (list of str): A list of strings to process. Returns: str: The longest common prefix string. If there is no common prefix, returns an empty string. if not strs: return \\"\\" # Take the first string as reference for i in range(len(strs[0])): char = strs[0][i] for string in strs[1:]: # If char doesn\'t match or we reach the end of a string if i >= len(string) or string[i] != char: return strs[0][:i] return strs[0]"},{"question":"# Stack Implementation and Balanced Parentheses Checker **Scenario**: You are tasked with developing a utility to check for balanced parentheses in an expression. This is a crucial utility in compilers and interpreters to ensure that code blocks and expressions are correctly structured. **Task**: Implement a function `is_balanced` that takes an expression (string) consisting of various types of brackets `()`, `[]`, `{}`, and checks if they are balanced. Use the `Stack` data structure you\'ve learned to implement this function. **Specifications**: 1. Implement the `Stack` class based on either array or linked list as shown in the previous code snippets. 2. Implement the function `is_balanced(expression: str) -> bool`. **Constraints**: - The expression contains only brackets `()`, `[]`, `{}`. - Length of the expression is at most (10^4). **Input**: - A string `expression` containing the brackets. **Output**: - Return a boolean value. `True` if the expression is balanced, otherwise `False`. **Examples**: 1. For the input `\\"{[()()]}\\"`, the output should be `True`. 2. For the input `\\"{[(])}\\"`, the output should be `False`. **Edge Cases**: - Ensure that expressions such as `\\"[]\\"`, `\\"{}\\"` return `True`. - Ensure that expressions such as `\\"]]\\"`, `\\"{\\"`, `\\"[()\\"` return `False`. **Performance Requirements**: - The solution should be efficient with respect to both time and space complexities. **Starter Code**: ```python class LinkedListStack: # Implement the LinkedListStack as previously defined ... def is_balanced(expression: str) -> bool: stack = LinkedListStack() matching_bracket = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in expression: if char in \'([{\': stack.push(char) else: if stack.is_empty() or stack.pop() != matching_bracket[char]: return False return stack.is_empty() ``` You are required to complete `LinkedListStack` based on the previously defined structure and finish the `is_balanced` function to pass all examples and constraints.","solution":"class Node: def __init__(self, value=None, next=None): self.value = value self.next = next class LinkedListStack: def __init__(self): self.head = None def push(self, value): new_node = Node(value, self.head) self.head = new_node def pop(self): if self.is_empty(): return None value = self.head.value self.head = self.head.next return value def is_empty(self): return self.head is None def is_balanced(expression: str) -> bool: stack = LinkedListStack() matching_bracket = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in expression: if char in \'([{\': stack.push(char) elif char in \')]}\': if stack.is_empty() or stack.pop() != matching_bracket[char]: return False return stack.is_empty()"},{"question":"You have been tasked to implement an optimized sorting algorithm that effectively sorts an array of integers in non-decreasing order with improved performance over the traditional Stooge Sort, while still using a divide-and-conquer approach. # Problem Statement Write a Python function named `optimized_sort` that takes a list of integers as input and sorts it in non-decreasing order. The goal is to optimize the performance over traditional Stooge Sort while maintaining simplicity and in-place sorting. # Input * A list of integers `arr` of length `n` (1 <= n <= 10^5). # Output * The sorted list in non-decreasing order. # Function Signature ```python def optimized_sort(arr: List[int]) -> List[int]: pass ``` # Constraints * You can use any sorting algorithm that meets the criteria of improved performance over Stooge Sort. * Your solution should aim for time complexity better than O(n^(2.709)) and space complexity no worse than O(n). Aim for O(n log n) time complexity. * Do not use built-in sort functions. * The algorithm should be in-place, i.e., it should utilize constant additional space. # Example ```python Input: arr = [64, 25, 12, 22, 11] Output: [11, 12, 22, 25, 64] ``` # Notes Feel free to add helper functions if necessary. Explain your approach and why you chose the specific sorting algorithm in comments within your code.","solution":"from typing import List def optimized_sort(arr: List[int]) -> List[int]: Sorts the array in non-decreasing order using QuickSort method. This method leverages the divide-and-conquer approach and has an average time complexity of O(n log n) with an in-place sorting mechanism. def quicksort(arr, low, high): if low < high: partition_index = partition(arr, low, high) quicksort(arr, low, partition_index - 1) quicksort(arr, partition_index + 1, high) def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 quicksort(arr, 0, len(arr) - 1) return arr"},{"question":"Scenario: You are working on a software for a library management system which organizes books in a BST structure based on their unique identifier (ID). Sometimes, you need to find the previous book in the sequence based on the in-order traversal of the tree. The predecessor in this context helps in identifying which book was added prior to the current one in case-we need to reverse the order of recent additions. Task: Write a function `find_inorder_predecessor(root, node)` which takes in the root of a BST and a node representing the book\'s ID, and returns the ID of the in-order predecessor of that node. If the predecessor does not exist, return `None`. Input Format: - `root`: The root of the BST. - `node`: A node in the BST with a unique identifier `val`. Output Format: - Return the in-order predecessor of `node` or `None` if it doesn\'t exist. # Constraints: 1. The BST will not contain duplicate values. 2. The node will always be a valid reference within the tree or `None`. # Function Signature: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_inorder_predecessor(root: TreeNode, node: TreeNode) -> TreeNode: # your code here ``` Example: ```python # Example Tree # 20 # / # 10 30 # / # 25 root = TreeNode(20) root.left = TreeNode(10) root.right = TreeNode(30) root.right.left = TreeNode(25) node = root.right # node with value 30 # Expected Output: 25 print(find_inorder_predecessor(root, node).val) ``` Notes: 1. You can assume the input tree is always a valid binary search tree. 2. Be cautious about edge cases where the node might be the smallest element or the tree is empty.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_inorder_predecessor(root, node): def find_max(node): while node.right: node = node.right return node predecessor = None current = root while current: if node.val > current.val: predecessor = current current = current.right elif node.val < current.val: current = current.left else: if current.left: predecessor = find_max(current.left) break return predecessor"},{"question":"# Scenario Consider the problem of teaching a new concept of sorting algorithms complexity to your students. You decide to use Bogo Sort as an example of a highly inefficient sorting algorithm due to its purely random nature. You want your students to understand not just how it works but also why it is inefficient comparatively. Problem Statement Write a Python function `bogo_sort_with_stats(arr: List[int]) -> Tuple[List[int], int]` that performs the Bogo Sort on a given list `arr`. Additionally, it should return the number of iterations (shuffling attempts) it took to sort the array correctly. **Function Signature:** ```python def bogo_sort_with_stats(arr: List[int]) -> Tuple[List[int], int]: ``` # Input * `arr`: A list of integers which needs to be sorted. # Output * A tuple where: * The first element is the sorted list. * The second element is the integer count of the iterations it took to sort the array. # Constraints * The function should handle arrays of varying sizes but it\'s recommended to keep your test sizes small (less than 10 elements) due to the inherent inefficiency of Bogo Sort. # Example Example 1 Input: `[2, 1, 3]` Output: `([1, 2, 3], <iteration_count>)` Note: `<iteration_count>` is the number of times the algorithm had to shuffle the array to sort it correctly, which will vary due to randomness. # Performance The function, due to the nature of Bogo Sort, is inherently impractical for large input sizes. Students should expect that the function will likely run indefinitely if applied on relatively larger arrays due to random nature. # Challenge Objective * This problem will challenge students\' understanding of algorithm efficiency and concept of sorting. * Students will need to correctly implement the sorting condition checks and be able to run their solution to see the glaring inefficiency of Bogo Sort by observing the number of shuffles required.","solution":"import random from typing import List, Tuple def bogo_sort_with_stats(arr: List[int]) -> Tuple[List[int], int]: Performs Bogo Sort on the given list and returns the sorted list along with the number of iterations it took to sort the array. def is_sorted(arr: List[int]) -> bool: Check if the array is sorted in ascending order. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True iterations = 0 # to count the number of shuffles while not is_sorted(arr): random.shuffle(arr) iterations += 1 return arr, iterations"},{"question":"Enhanced Insertion Sort Problem Statement You are tasked with enhancing the Insertion Sort algorithm to handle larger arrays more efficiently while maintaining its in-place sorting property. Your optimized version should terminate early if the array is already sorted at any point during the iteration. Write a function `enhanced_insertion_sort` that performs the following operations: 1. Sorts the input array using an optimized Insertion Sort algorithm. 2. If the array is already sorted at any point, the function should terminate early. Function Signature ```python def enhanced_insertion_sort(arr: list) -> list: pass ``` Input * `arr` (list): A list of integers. Constraints: - (1 leq text{len}(arr) leq 10^5) - (-10^9 leq text{arr[i]} leq 10^9) Output * Returns a list of integers sorted in non-decreasing order. Performance Requirements * The algorithm should run efficiently for large datasets with up to (10^5) elements. * The time complexity should ideally be better than (O(n^2)) for nearly sorted arrays. Example 1. **Input**: `[10, 1, 9, 3, 2, 11, 7, 5, 6]` **Output**: `[1, 2, 3, 5, 6, 7, 9, 10, 11]` 2. **Input**: `[1, 2, 3, 4, 5]` **Output**: `[1, 2, 3, 4, 5]` (Already sorted, early termination) 3. **Input**: `[5, 4, 3, 2, 1]` **Output**: `[1, 2, 3, 4, 5]` (Worst-case scenario)","solution":"def enhanced_insertion_sort(arr: list) -> list: Sorts the input array using an optimized Insertion Sort algorithm that terminates early if the array is already sorted at any point during the iteration. n = len(arr) for i in range(1, n): key = arr[i] j = i - 1 while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key # Check if the array is already sorted at this point is_sorted = True for k in range(n - 1): if arr[k] > arr[k + 1]: is_sorted = False break if is_sorted: break return arr"},{"question":"**Scenario:** You work for a data analytics company that frequently processes large datasets. You have been tasked to implement an efficient sorting algorithm to sort a user\'s dataset in ascending order. The array can contain both positive and negative integers. **Task:** Implement a function `quick_sort` that takes an array of integers and returns the sorted array. Your implementation should be efficient in both time and space. However, to demonstrate your understanding, you must implement a version that prints the array after each partition step to illustrate the sorting process. **Function Signature:** ```python def quick_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` **Input:** - `arr`: List of integers where -10^6 ≤ arr[i] ≤ 10^6 - `simulation` (optional): Boolean flag to turn on/off simulation print. Defaults to `False`. **Output:** - A new list of integers sorted in ascending order. **Constraints:** - 1 ≤ len(arr) ≤ 10^4 **Example:** ```python quick_sort([3, 6, 8, 10, 1, 2, 1]) ``` Output: ``` [1, 1, 2, 3, 6, 8, 10] ``` **Special Requirement:** If `simulation` is set to `True`, your function should print the state of the list after each partition step to help visualize the sorting process. Example: ``` iteration 0: 3 6 8 10 1 2 1 iteration 1: 1 2 8 10 1 3 6 ... ``` *You are not required to handle inputs with less than one element as the problem should be constrained to arrays with at least one element.* **Note:** - You can use helper functions if needed. - Consider edge cases like arrays with duplicate values or already sorted arrays.","solution":"from typing import List def quick_sort(arr: List[int], simulation: bool = False) -> List[int]: def quick_sort_helper(arr, low, high, iteration): if low < high: pivot_index = partition(arr, low, high, iteration) quick_sort_helper(arr, low, pivot_index - 1, iteration + 1) quick_sort_helper(arr, pivot_index + 1, high, iteration + 1) def partition(arr, low, high, iteration): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] if simulation: print(f\'iteration {iteration}:\', \' \'.join(map(str, arr))) return i + 1 quick_sort_helper(arr, 0, len(arr) - 1, 0) return arr"},{"question":"# Transitive Closure Calculation Suppose you are working on a network analysis problem, where you are given a directed graph representing connectivity between nodes. Your goal is to determine the reachability of nodes, i.e., find out if there\'s a path from any node `u` to another node `v`. Your task is to implement the transitive closure of the graph using Depth-First Search (DFS). # Implementation Details 1. **Class Definition**: Implement a class `Graph` which represents a directed graph using adjacency lists. 2. **Methods**: - `__init__(self, vertices: int)`: Initializes the graph. - `add_edge(self, source: int, target: int)`: Adds a directed edge from `source` to `target`. - `transitive_closure(self) -> List[List[int]]`: Computes and returns the transitive closure matrix of the graph. 3. **Constraints**: - The number of vertices `V` will be in the range [1, 100]. - The number of edges `E` will be in the range [0, 10,000]. # Input and Output Format Input: - `V` (integer): Number of vertices. - `edges` (List of tuples): Each tuple consists of two integers (u, v) representing a directed edge from vertex `u` to vertex `v`. Output: - A 2D list (List[List[int]]): Transitive closure matrix of the graph, where `result[i][j] = 1` if there\'s a path from vertex `i` to vertex `j`, otherwise `0`. # Example: ```python graph = Graph(4) graph.add_edge(0, 1) graph.add_edge(1, 2) graph.add_edge(2, 3) closure = graph.transitive_closure() # Output should be: # [ # [1, 1, 1, 1], # [0, 1, 1, 1], # [0, 0, 1, 1], # [0, 0, 0, 1] # ] ``` The output matrix shows the reachability of nodes. For example, from node 0, you can reach all other nodes (0, 1, 2, 3). From node 1, you can reach nodes 1, 2, and 3, and so on.","solution":"class Graph: def __init__(self, vertices: int): self.V = vertices self.adj_list = [[] for _ in range(vertices)] def add_edge(self, source: int, target: int): self.adj_list[source].append(target) def transitive_closure(self) -> list: closure = [[0] * self.V for _ in range(self.V)] def dfs(source: int, v: int): closure[source][v] = 1 for neighbor in self.adj_list[v]: if not closure[source][neighbor]: dfs(source, neighbor) for i in range(self.V): dfs(i, i) return closure"},{"question":"You\'re working on a project that deals with a large dataset of timestamps that are sorted in increasing order. Your task is to implement a function using an efficient search algorithm to quickly find the index of a specific timestamp, if it exists. Implement an efficient search algorithm that locates the index of a given timestamp in a sorted list of timestamps leveraging what you\'ve learned from the Interpolation Search algorithm. # Function Signature: ```python def find_timestamp_index(timestamps: List[int], search_timestamp: int) -> int: pass ``` # Input: * `timestamps` (List[int]): A sorted list of timestamps in POSITIVE (+ve) Unix Time (in seconds format). * `search_timestamp` (int): The timestamp to find. # Output: * Returns the index of the search_timestamp in the list, else returns -1. # Constraints: * The list `timestamps` will have at most (10^6) elements. * Each element in `timestamps` will be a valid Unix timestamp (positive integer), in increasing order. * `search_timestamp` will be a positive integer Unix timestamp. # Example: ```python find_timestamp_index([1616000000, 1616003600, 1616007200, 1616010800, 1616014400], 1616007200) # Returns: 2 find_timestamp_index([1616000000, 1616003600, 1616007200, 1616010800, 1616014400], 1616018000) # Returns: -1 ``` # Notes: 1. Your implementation should leverage the principles of Interpolation Search to achieve an efficient solution. 2. Consider all outlined edge cases and handle them appropriately. 3. Ensure your solution is optimized for large datasets up to the given constrain limits.","solution":"from typing import List def find_timestamp_index(timestamps: List[int], search_timestamp: int) -> int: Performs interpolation search to find the index of the search_timestamp in the list of timestamps. Args: timestamps (List[int]): A sorted list of timestamps. search_timestamp (int): The timestamp to find. Returns: int: The index of the search_timestamp if it exists; otherwise, -1. lo = 0 hi = len(timestamps) - 1 while lo <= hi and search_timestamp >= timestamps[lo] and search_timestamp <= timestamps[hi]: if lo == hi: if timestamps[lo] == search_timestamp: return lo return -1 pos = lo + int(((float(hi - lo) / (timestamps[hi] - timestamps[lo])) * (search_timestamp - timestamps[lo]))) if timestamps[pos] == search_timestamp: return pos if timestamps[pos] < search_timestamp: lo = pos + 1 else: hi = pos - 1 return -1"},{"question":"# Scenario: Your team is developing a scientific calculator that needs to compute square roots with a high degree of precision in a resource-constrained environment. To achieve this, you decide to implement a square root approximation algorithm that ensures the computed value is within a predefined precision limit from the actual square root. # Objective: Implement a function using the Babylonian method to approximate the square root of a given positive integer `N` within a specified precision `P`. # Function Signature: ```python def square_root(N: int, P: float = 0.001) -> float: Computes the square root of N with a precision factor of P. Args: N : int : A positive integer whose square root we need to approximate. P : float : The precision factor such that the output x is within P of the actual square root. Returns: float : An approximate square root of N within the precision P. ``` # Input: * A positive integer `N` (1 ≤ N ≤ 10^9). * A float `P` (0 < P < 1), specifying the required precision (default value of 0.001). # Output: * A float representing the approximate square root of `N`. # Constraints: * Ensure that the result has an absolute error less than `P`. * Aim for an efficient solution that balances time and space complexity. # Example: ```python assert abs(square_root(5) - 2.236) < 0.001 # Example 1: Within the default precision assert abs(square_root(9, 0.00001) - 3.0) < 0.00001 # Example 2: Higher precision requirement ``` # Notes: * Ensure proper handling of edge cases such as N being a perfect square. * Consider the impact of precision on the number of iterations and performance. * Avoid floating-point arithmetic issues wherever possible.","solution":"def square_root(N: int, P: float = 0.001) -> float: Computes the square root of N with a precision factor of P using the Babylonian method. Args: N : int : A positive integer whose square root we need to approximate. P : float : The precision factor such that the output x is within P of the actual square root. Returns: float : An approximate square root of N within the precision P. if N < 0: raise ValueError(\\"N must be a non-negative integer.\\") if N == 0 or N == 1: return N x = N y = 1 while abs(x - y) > P: x = (x + y) / 2 y = N / x return x"},{"question":"# Question: Implement a Memory-Efficient Bitonic Sort You are tasked with implementing a memory-efficient version of the Bitonic Sort algorithm. The given bitonic sort algorithm is recursive and involves significant memory usage due to array splitting and merging. Your job is to modify this algorithm to work in-place as much as possible, reducing its memory footprint. # Function Signature ```python def inplace_bitonic_sort(arr: List[int], reverse: bool = False) -> None: pass ``` # Input * `arr` (List[int]): The list of integers to sort. The size of the list is guaranteed to be a power of 2. * `reverse` (bool): A flag indicating if the array should be sorted in descending order. The default value is False, meaning the array should be sorted in ascending order. # Output * The function should return `None`. The list `arr` should be sorted in-place. # Constraints * The input array will have a size that is a power of 2 (e.g., 2, 4, 8, 16, ...). * You are not allowed to use additional arrays or lists apart from minor auxiliary storage. # Example ```python arr = [3, 7, 4, 8, 6, 2, 1, 5] inplace_bitonic_sort(arr) print(arr) # Output: [1, 2, 3, 4, 5, 6, 7, 8] arr = [10, 30, 11, 20, 22, 15, 7, 5] inplace_bitonic_sort(arr, reverse=True) print(arr) # Output: [30, 22, 20, 15, 11, 10, 7, 5] ``` # Performance Requirements * The function should run efficiently with a time complexity of O(nlog(n)^2). # Scenario You have been hired by a company specializing in high-performance computing. They are transitioning their codebase to use modern in-place sorting techniques to conserve memory without sacrificing speed. Your contribution, developing an optimized in-place Bitonic Sort, will directly impact their future scalability and efficiency.","solution":"from typing import List def inplace_bitonic_sort(arr: List[int], reverse: bool = False) -> None: def compare_and_swap(i, j, direction): if (direction == (arr[i] > arr[j])): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(low, cnt, direction): if cnt > 1: k = cnt // 2 for i in range(low, low + k): compare_and_swap(i, i + k, direction) bitonic_merge(low, k, direction) bitonic_merge(low + k, k, direction) def bitonic_sort(low, cnt, direction): if cnt > 1: k = cnt // 2 bitonic_sort(low, k, True) # sort in ascending order bitonic_sort(low + k, k, False) # sort in descending order bitonic_merge(low, cnt, direction) bitonic_sort(0, len(arr), not reverse)"},{"question":"# Maximum Depth of Binary Tree Challenge Context You are given the task to compute the maximum depth of a binary tree, which is the number of nodes along the longest path from the root node down to the farthest leaf node. Given the structure of a binary tree where each node has a value and links to a left and right child, implement the function `max_depth(root)` to compute this value. # Function Signature ```python def max_depth(root: TreeNode) -> int: ``` # Input - `root`: The root node of the binary tree, which can be `None` if the tree is empty. Each node is an instance of `TreeNode`. # Output - Return an integer representing the maximum depth of the tree. # Constraints - The Functions `TreeNode` is defined as follows: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` - Consider both recursive and iterative (using BFS) implementations. Expected to handle cases with hundreds of nodes efficiently. # Example ```python # Example Tree Structure # 10 # / # 12 15 # / / # 25 30 36 # # The output should be 3 because [10->12->25] or [10->12->30] are two paths with 3 nodes each. if __name__ == \\"__main__\\": tree = TreeNode(10) tree.left = TreeNode(12) tree.right = TreeNode(15) tree.left.left = TreeNode(25) tree.left.right = TreeNode(30) tree.right.left = TreeNode(36) print(max_depth(tree)) # Output: 3 ``` # Notes - Think about edge cases such as an empty tree (should return 0). - Both iterative (using queue) and recursive (depth-first search) approaches should be considered for implementing the solution.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_depth(root: TreeNode) -> int: if not root: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Question You are implementing an enhanced anagram detector that can handle not only lowercase English letters but also uppercase letters and numeric digits. # Task Write a function `enhanced_anagram(s1: str, s2: str) -> bool` that returns `True` if `s1` and `s2` are anagrams, considering all alphanumeric characters (a-z, A-Z, 0-9). Two strings are anagrams if they contain the same characters with the same frequencies, regardless of order. # Input * `s1` and `s2`: Two strings (0 ≤ len(s1), len(s2) ≤ 10^5) containing alphanumeric characters. # Output * Return `True` if the strings are anagrams, `False` otherwise. # Performance Requirements Your function should have a time complexity of O(n) and a space complexity of O(1). # Example ```python print(enhanced_anagram(\\"bat123\\", \\"tab312\\")) # True print(enhanced_anagram(\\"bat123\\", \\"tab31A\\")) # False print(enhanced_anagram(\\"abcABC\\", \\"CBAacb\\")) # True print(enhanced_anagram(\\"hello\\", \\"llohe\\")) # True print(enhanced_anagram(\\"hello\\", \\"world\\")) # False print(enhanced_anagram(\\"\\", \\"\\")) # True ``` *Constraints*: * Both strings can include lowercase and uppercase letters as well as digits from 0 to 9. * The function must handle large inputs efficiently within the given time complexity.","solution":"def enhanced_anagram(s1, s2): Determines if s1 and s2 are anagrams considering alphanumeric characters. from collections import Counter return Counter(s1) == Counter(s2)"},{"question":"# Integer Decomposition Problem Problem Statement Given a positive integer `n`, write a function `int_divide(n)` to compute the total number of ways to decompose `n` into sums of non-negative integers. Each number in the sum can be used multiple times. Order of numbers in the sum does not matter (e.g., `n = 4` can be decomposed as `4`, `3+1`, `2+2`, `2+1+1`, `1+1+1+1`). Input * A single positive integer `n` (1 ≤ n ≤ 1000). Output * An integer representing the number of ways to decompose `n`. Constraints * The function should run efficiently for `n` up to 1000. Example 1. Input: `4` Output: `5` Explanation: The number of decompositions of 4 are `4`, `3+1`, `2+2`, `2+1+1`, `1+1+1+1`. 2. Input: `7` Output: `15` Explanation: The number of decompositions of 7 are: `7`, `6+1`, `5+2`, `5+1+1`, `4+3`, `4+2+1`, `4+1+1+1`, `3+3+1`, `3+2+2`, `3+2+1+1`, `3+1+1+1+1`, `2+2+2+1`, `2+2+1+1+1`, `2+1+1+1+1+1`, `1+1+1+1+1+1+1`. Tips - Think about how we can build the problem up using a dynamic programming table. - Consider how subproblems relate to each other in terms of current integer parts and remaining values. Function Signature ```python def int_divide(n): # Your code here ``` Your task is to implement the function `int_divide(n)` that computes the number of ways to decompose `n`.","solution":"def int_divide(n): Compute the total number of ways to decompose \'n\' into sums of non-negative integers. # Create a list to store the number of ways to decompose each number up to n dp = [1] + [0] * n # Fill the dp array for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"**Scenario**: You are working on a sports analytics project where you need to compute the mean score of athletes while neglecting some extreme values to avoid outliers. **Question**: Implement a function `trimmean(scores, percentage)` that receives an array of integer scores and a percentage. The function calculates and returns the trimmed mean by neglecting the given percentage of the highest and lowest scores. # Function Signature: ```python def trimmean(scores, percentage): ``` # Input: - `scores`: A list of integers representing the scores of athletes. `1 <= len(scores) <= 10^5` - `percentage`: A float representing the percentage of extreme values to discard. `0.0 <= percentage <= 100.0` # Output: - Returns a float representing the trimmed mean of the scores after discarding the given percentage of lower and upper scores. # Constraints: - The trimmed mean should make use of sorting the array. - Handle the edge cases appropriately, such as when the number of elements to discard is not an integer. # Examples: ```python assert trimmean([10, 20, 30, 40, 50], 20) == 30.0 assert trimmean([5, 1, 4, 8, 7, 10, 3, 2, 9, 6], 20) == 5.5 assert trimmean([1, 2, 3, 4, 5, 6], 40) == 3.5 assert trimmean([10, 20, 30], 0) == 20.0 ``` **Edge Cases to Consider**: - Small arrays where the truncation percentage is high. - Arrays where truncating `percentage` results in fractions for counts of elements to be trimmed.","solution":"def trimmean(scores, percentage): Calculates the trimmed mean of the given scores by excluding the specified percentage of the lowest and highest values. :param scores: List of integer scores. :param percentage: The percentage of extreme values to discard. :return: Trimmed mean as a float. n = len(scores) if n == 0: return 0.0 # Sort the scores sorted_scores = sorted(scores) # Calculate the number of elements to trim from each end trim_count = int((percentage / 100.0) * n / 2) # Get the range to consider for trimmed mean trimmed_scores = sorted_scores[trim_count : n - trim_count] # Calculate trimmed mean trimmed_mean = sum(trimmed_scores) / len(trimmed_scores) return trimmed_mean"},{"question":"# Sliding Window Median Given a stream of integers, create a class `SlidingWindowMedian` that calculates the median of all integers in a sliding window of a specified size. The median is the middle value in an ordered list of numbers. If the list contains an even number of elements, the median is the average of the two middle elements. You need to implement the following functions: - `__init__(self, size: int)`: Initialize the data structure with the window size `size`. - `next(self, val: int) -> float`: Process `val` and return the median of the last `size` numbers. Input - `size`: an integer representing the size of the sliding window (`1 <= size <= 10^5`) - `val`: values will be given one at a time in non-decreasing order and will be integers in the range `[-10^5, 10^5]`. Output - The median value as a float. Example ```python if __name__ == \\"__main__\\": m = SlidingWindowMedian(3) assert m.next(1) == 1 assert m.next(10) == 5.5 assert m.next(3) == 3 assert m.next(5) == 5 ``` Constraints - Your solution should optimize for both time and space. - Ensure performance is efficient for the maximum constraints.","solution":"import bisect from collections import deque class SlidingWindowMedian: def __init__(self, size: int): self.size = size self.window = deque() self.sorted_window = [] def next(self, val: int) -> float: self.window.append(val) bisect.insort(self.sorted_window, val) if len(self.window) > self.size: removed_val = self.window.popleft() index = bisect.bisect_left(self.sorted_window, removed_val) self.sorted_window.pop(index) return self._get_median() def _get_median(self) -> float: n = len(self.sorted_window) if n % 2 == 0: return (self.sorted_window[n // 2 - 1] + self.sorted_window[n // 2]) / 2.0 else: return float(self.sorted_window[n // 2])"},{"question":"Partitioning a Linked List Scenario Suppose you\'re working on a system that processes sequences of numeric data coming as a stream. One frequent task is to reorganize this data by a specific threshold value for later analysis. Specifically, you need to partition the sequence so that all numbers less than a given threshold come before those equal to or greater than the threshold. Task Given a singly linked list and a number `x`, write a function that partitions the linked list so that all nodes with values less than `x` come before nodes with values greater than or equal to `x`. The order of nodes in each partition should be preserved as they appear in the original list. Function Signature ```python def partition(head: Node, x: int) -> Node: ``` Input - `head`: The head of a singly linked list where each node contains an integer value. - `x`: An integer value used for the partition. Output - The head of the partitioned linked list. Constraints - The values of each node and `x` are all integers. - You may assume that the linked list does not contain any cycles. Example ```python # Define the linked list: 3 -> 5 -> 8 -> 5 -> 10 -> 2 -> 1 head = Node(3) head.next = Node(5) head.next.next = Node(8) head.next.next.next = Node(5) head.next.next.next.next = Node(10) head.next.next.next.next.next = Node(2) head.next.next.next.next.next.next = Node(1) # Partition value x = 5 # Call partition function new_head = partition(head, x) # The resulting linked list should be: # 3 -> 2 -> 1 -> 5 -> 8 -> 5 -> 10 ``` Additional Examples 1. **Input**: - Linked list: 1 -> 4 -> 3 -> 2 -> 5 -> 2 - Partition value: 3 - **Output**: 1 -> 2 -> 2 -> 4 -> 3 -> 5 2. **Input**: - Linked list: 5 -> 6 -> 7 -> 8 - Partition value: 5 - **Output**: 5 -> 6 -> 7 -> 8 3. **Input**: - Linked list: (Empty list) - Partition value: Any value - **Output**: (Empty list) Constraints * The values of the linked list nodes and x are between -10^6 and 10^6. * The linked list contains at most 10^4 nodes. Notes * Consider all edge cases such as an empty list or all nodes having the same value.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def partition(head: Node, x: int) -> Node: if head is None: return None less_head = Node(0) more_head = Node(0) less = less_head more = more_head current = head while current: if current.val < x: less.next = current less = less.next else: more.next = current more = more.next current = current.next more.next = None less.next = more_head.next return less_head.next"},{"question":"Scenario You are working on a text editor that has an interesting feature: vowel reversal. Whenever a particular operation is triggered, all the vowels in the selected text are reversed, with other characters remaining in their original positions. Task Given a string `s` consisting of both vowels and consonants, implement a function `reverse_vowel(s)` that reverses the vowels in the string, leaving all other characters in their original positions. Function Signature ```python def reverse_vowel(s: str) -> str: ``` Input Format * A single string `s` (1 ≤ |s| ≤ 10^5) consisting of letters of the English alphabet. Output Format * Returns a new string with the vowels reversed and other characters in their original positions. Constraints * Vowels are considered: \'a\', \'e\', \'i\', \'o\', \'u\', and their uppercase counterparts \'A\', \'E\', \'I\', \'O\', \'U\'. * The solution should have a linear time complexity, i.e., (O(n)) where (n) is the length of the string. Example ```python # Example 1 reverse_vowel(\\"hello\\") # Output: \\"holle\\" # Example 2 reverse_vowel(\\"leetcode\\") # Output: \\"leotcede\\" ```","solution":"def reverse_vowel(s: str) -> str: vowels = \'aeiouAEIOU\' s_list = list(s) left, right = 0, len(s) - 1 while left < right: while left < right and s_list[left] not in vowels: left += 1 while left < right and s_list[right] not in vowels: right -= 1 if left < right: s_list[left], s_list[right] = s_list[right], s_list[left] left += 1 right -= 1 return \'\'.join(s_list)"},{"question":"# Question: Shortest Distance from Gate to Empty Room - Optimized Solution You are given an m x n 2D grid initialized with these three possible values: -1: A wall or an obstacle. 0: A gate. INF: Infinity means an empty room. We use the value 2^31 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647. Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should remain filled with INF. **Function Signature**: ```python def optimized_walls_and_gates(rooms: List[List[int]]) -> None: # Your implementation here ``` **Input**: * `rooms` (List[List[int]]) - A 2D grid of integers representing the state of rooms. **Output**: * The function should modify the grid in place. No value returns are needed. **Constraints**: * 1 <= m, n <= 250 * grid[i][j] is -1, 0, or INF (2147483647). # Instructions * Use Breadth-First Search (BFS) instead of DFS to optimize the distance propagation to nearest gates. * Ensure that each empty room is visited at most once by each BFS iteration. * Take care to handle edge cases effectively. # Example Scenario Given the 2D grid: INF -1 0 INF INF INF INF -1 INF -1 INF -1 0 -1 INF INF The output grid should be: 3 -1 0 1 2 2 1 -1 1 -1 2 -1 0 -1 3 4","solution":"from collections import deque from typing import List def optimized_walls_and_gates(rooms: List[List[int]]) -> None: if not rooms: return rows, cols = len(rooms), len(rooms[0]) gates = deque() # Collect all gates\' positions for r in range(rows): for c in range(cols): if rooms[r][c] == 0: gates.append((r, c)) # Perform multi-source BFS directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while gates: x, y = gates.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and rooms[nx][ny] == 2147483647: rooms[nx][ny] = rooms[x][y] + 1 gates.append((nx, ny))"},{"question":"Problem Statement Given two strings `s` and `t` which consist of only lowercase letters, where `t` is generated by shuffling `s` and then adding one more letter at a random position, write a function to find the letter that was added to `t`. Function Signature ```python def find_difference(s: str, t: str) -> str: ``` Input - `s` (str): A string of lowercase letters with length n (0 ≤ n ≤ 10^5). - `t` (str): A string derived by shuffling `s` and appending an additional character, hence its length is n + 1. Output - Return the character that was added to create `t`. Example ```python assert find_difference(\\"abcd\\", \\"abecd\\") == \'e\' assert find_difference(\\"\\", \\"y\\") == \'y\' assert find_difference(\\"a\\", \\"aa\\") == \'a\' ``` Constraints 1. `s` and `t` consist only of lowercase English letters. 2. Length constraints are 0 ≤ len(s) ≤ 10^5 and len(t) = len(s) + 1 Implementation Details 1. Implement the function using the XOR property to efficiently find the differing character. 2. Ensure your function handles edge cases such as `s` being empty. 3. The function should run in O(n) time with O(1) additional space. Scenario Imagine you are maintaining a word verification tool that checks the integrity of words being processed. During this processing, a new character is occasionally added to the words. Your task is to identify the added character to ensure word accuracy.","solution":"def find_difference(s: str, t: str) -> str: Find the character that was added to string t, which was generated by shuffling string s and adding one more letter at a random position. :param s: input string consisting of lowercase letters. :param t: string derived by shuffling s and adding one more letter. :return: character that was added. xor_result = 0 for char in s: xor_result ^= ord(char) for char in t: xor_result ^= ord(char) return chr(xor_result)"},{"question":"# Question: Decoding Ways Given an encoded message where each character is a digit from \'0\' to \'9\' and mappings are defined as follows: ``` \'A\' -> 1 \'B\' -> 2 ... \'Z\' -> 26 ``` Write a function `num_decodings(enc_mes: str) -> int` that determines the total number of ways to decode the given encoded message. # Input: - `enc_mes`: A string of length `n`, comprising digits \'0\' to \'9\'. # Output: - An integer representing the total number of ways to decode the message. # Constraints: - `1 <= n <= 10^4` - The string does not contain any characters other than digits \'0\' through \'9\'. # Example: ```python assert num_decodings(\\"12\\") == 2 assert num_decodings(\\"226\\") == 3 assert num_decodings(\\"0\\") == 0 assert num_decodings(\\"10\\") == 1 ``` # Explanation: - For `enc_mes = \\"12\\"`, there are two decodings possible: \\"AB\\" (1, 2) and \\"L\\" (12). - For `enc_mes = \\"226\\"`, the possible decodings are: \\"BZ\\" (2, 26), \\"VF\\" (22, 6), and \\"BBF\\" (2, 2, 6). - For `enc_mes = \\"0\\"`, no decodings are possible as \'0\' does not map to any letter. - For `enc_mes = \\"10\\"`, there is only one valid decoding: \\"J\\" (10). Consider edge cases such as strings starting with \'0\' and ensure that your function handles them correctly by returning 0. # Notes: - Pay attention to invalid substrings that cannot be decoded and how they propagate through the string. - Apply dynamic programming to efficiently calculate the number of decoding ways.","solution":"def num_decodings(enc_mes: str) -> int: Given an encoded message containing digits, determine the total number of ways to decode it. if not enc_mes or enc_mes[0] == \'0\': return 0 n = len(enc_mes) dp = [0] * (n + 1) # dp[i] means the number of ways to decode the substring enc_mes[:i] dp[0] = 1 # There\'s one way to decode an empty string for i in range(1, n + 1): # Check the single digit encode if enc_mes[i - 1] != \'0\': dp[i] += dp[i - 1] # Check the two digit encode if i > 1 and enc_mes[i - 2] != \'0\' and 10 <= int(enc_mes[i - 2:i]) <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"**Title**: Enhanced Search in Sorted Array **Context**: You are provided with a sorted array of integers and a search key. Your task is to implement an enhanced version of the ternary search algorithm to locate the search key in the array efficiently. This function should be robust and handle edge cases gracefully. You need to ensure the search routine obeys a strict time complexity constraint. **Function Definition**: Implement the following function: ```python def enhanced_ternary_search(arr: List[int], key: int) -> int: Find the given value (key) in an array sorted in ascending order. Returns the index of the value if found, and -1 otherwise. **Input**: - `arr`: A list of integers sorted in ascending order with a length between 0 and 10^5. - `key`: An integer to be searched for in the array. **Output**: - Return the index of the key if found, and -1 otherwise. **Constraints**: - Try to maintain a time complexity of O(log3(N)). - Handle edge cases such as empty arrays or key values that aren\'t present in the array. **Example**: ```python assert enhanced_ternary_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 4) == 3 assert enhanced_ternary_search([10, 20, 30, 40, 50], 35) == -1 assert enhanced_ternary_search([], 3) == -1 assert enhanced_ternary_search([1, 5, 7, 9, 15], 1) == 0 assert enhanced_ternary_search([2, 4, 6, 8, 8], 8) == 3 # finding the first occurrence if duplicate ``` **Notes**: - Focus on the clear and correct implementation of the search algorithm. - Ensure that your function handles cases where the array is empty or does not contain the search key appropriately. - Avoid unnecessary recomputations and aim for efficiency.","solution":"from typing import List def enhanced_ternary_search(arr: List[int], key: int) -> int: Find the given value (key) in an array sorted in ascending order. Returns the index of the value if found, and -1 otherwise. def ternary_search(l, r, key): if r >= l: third = (r - l) // 3 mid1 = l + third mid2 = r - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: return ternary_search(l, mid1 - 1, key) elif key > arr[mid2]: return ternary_search(mid2 + 1, r, key) else: return ternary_search(mid1 + 1, mid2 - 1, key) return -1 return ternary_search(0, len(arr) - 1, key)"},{"question":"Simulate a Real-Time Stock Price Stream Using Min Heap In this problem, you are required to simulate a real-time stream of stock prices and efficiently determine the `k` smallest stock prices seen so far. You will use an algorithm similar to the `min_heap_sort` to maintain a min heap of the `k` smallest prices. Write a function `track_k_smallest_prices(prices, k)` that takes a list of stock prices `prices` and an integer `k`, and returns a list consisting of the `k` smallest prices in the order they appeared. # Input - `prices`: A list of integers representing the stock prices. - `k`: An integer representing the number of smallest prices to track (1 <= k <= len(prices)). # Output - A list of integers representing the `k` smallest stock prices in the order they appeared in the input list. # Constraints - You need to maintain the min heap property and ensure that the `k` smallest prices are always tracked during the stream processing. - The function should be efficient in terms of both time and space complexity. - Optimize the heap operations to handle large input sizes efficiently. # Example ```python def track_k_smallest_prices(prices, k): pass # Example 1 prices = [5, 2, 4, 7, 1, 3, 6, 8] k = 3 print(track_k_smallest_prices(prices, k)) # Output: [5, 2, 1] # Example 2 prices = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] k = 5 print(track_k_smallest_prices(prices, k)) # Output: [10, 9, 8, 7, 6] ``` # Note 1. You are not allowed to use built-in sorting functions. 2. Your task is to implement the min heap operations effectively to ensure that the `k` smallest stock prices are tracked based on the stream of prices seen so far. 3. Think through edge cases such as the input list having repeated elements or being entirely sorted/reverse sorted.","solution":"import heapq def track_k_smallest_prices(prices, k): Track the k smallest stock prices in the order they appeared. if not prices or k <= 0: return [] min_heap = [] result = [] for price in prices: if len(min_heap) < k: heapq.heappush(min_heap, -price) result.append(price) elif -price > min_heap[0]: heapq.heappop(min_heap) heapq.heappush(min_heap, -price) result.append(price) else: continue # Skip this price as it is not among the k smallest return sorted([-x for x in min_heap]) # Return the k smallest in ascending order"},{"question":"You are given a 2D grid of `m` x `n` cells, each cell representing either water (0) or land (1). In the beginning, all the cells are filled with water. We want to implement a function that, given a list of positions to operate, counts the number of islands after each operation. An island is formed by connecting adjacent lands horizontally or vertically, and it is surrounded by water. # Scenario Imagine a 3x3 grid to start with and the following operations: - `positions = [[0,0], [0,1], [1,2], [2,1]]` Initially, the 2D grid is filled with water: ``` 0 0 0 0 0 0 0 0 0 ``` # Adding Land Operations 1. `addLand(0, 0)`: ``` 1 0 0 0 0 0 0 0 0 ``` Number of islands = 1 2. `addLand(0, 1)`: ``` 1 1 0 0 0 0 0 0 0 ``` Number of islands = 1 3. `addLand(1, 2)`: ``` 1 1 0 0 0 1 0 0 0 ``` Number of islands = 2 4. `addLand(2, 1)`: ``` 1 1 0 0 0 1 0 1 0 ``` Number of islands = 3 # Function Signature **Function Name**: `num_islands` **Input**: List of tuples `positions` indicating the cells being turned from water to land. **Output**: List of integers representing the number of islands after each operation. # Constraints 1. m, n ≤ 1000 2. 1 ≤ len(positions) ≤ m * n 3. 0 ≤ position[i][j] < m and n # Notes * Use a Union-Find data structure to manage connectivity and efficiently compute the number of islands after each operation. * Implement `addLand` to update the grid, and use union-find operations to manage and count connected components. # Example ```python positions = [[0,0], [0,1], [1,2], [2,1]] print(num_islands(positions)) # Output: [1, 1, 2, 3] ```","solution":"class UnionFind: def __init__(self, total): self.parent = list(range(total)) self.rank = [1] * total self.count = 0 # number of connected components def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) # path compression return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def add(self, x): self.count += 1 self.parent[x] = x def num_islands(positions, m, n): def index(x, y): return x * n + y union_find = UnionFind(m * n) grid = [[0] * n for _ in range(m)] results = [] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for x, y in positions: if grid[x][y] == 1: results.append(union_find.count) continue grid[x][y] = 1 id = index(x, y) union_find.add(id) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1: union_find.union(id, index(nx, ny)) results.append(union_find.count) return results"},{"question":"Scenario A delivery robot follows a series of moves on a 2D grid. The robot starts at the origin position (0, 0) and can move up (U), down (D), left (L), or right (R). Your task is to determine if the given sequence of moves will cause the robot to return to its original starting position. Task You need to implement a function `judge_circle(moves)` that takes a string of moves and returns `True` if the robot returns to the origin, otherwise `False`. Input * A single string `moves` consisting of characters \'U\', \'D\', \'L\', \'R\'. Each character indicates a move direction. Output * A boolean value `True` if the robot returns to the origin after completing the sequence of moves, otherwise `False`. Constraints * 1 ≤ length of `moves` ≤ 10^4 Example ```python def judge_circle(moves): dict_moves = { \'U\' : 0, \'D\' : 0, \'R\' : 0, \'L\' : 0 } for char in moves: if char in dict_moves: dict_moves[char] = dict_moves[char] + 1 return dict_moves[\'L\'] == dict_moves[\'R\'] and dict_moves[\'U\'] == dict_moves[\'D\'] # Example 1 print(judge_circle(\\"UD\\")) # Output: True # Example 2 print(judge_circle(\\"LL\\")) # Output: False ``` Explanation * In Example 1, the moves \\"UD\\" cancel each other out, returning the robot to the origin. * In Example 2, the move \\"LL\\" does not have corresponding right moves to return to the origin.","solution":"def judge_circle(moves): Determines if a series of moves returns the robot to the origin position. Args: moves (str): A string of characters where \'U\' is up, \'D\' is down, \'L\' is left, and \'R\' is right. Returns: bool: True if the robot returns to the origin, False otherwise. # Initialize the coordinates at the origin x, y = 0, 0 # Iterate through each move and update the coordinates for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 # The robot returns to the origin if coordinates are both zero return x == 0 and y == 0"},{"question":"# Interpolation Search Enhancement Implement an enhanced version of the interpolation search algorithm that handles specific edge cases and optimizes performance. The goal is to improve the algorithm\'s robustness for real-world applications. Input: - A sorted list of integers `array` (potentially having duplicates and non-uniform distribution) where `1 <= len(array) <= 10^5`. - An integer `search_key` to be located. Output: - Index of `search_key` in `array` if found; otherwise, `-1`. Task: - Modify the given interpolation search function to handle the following: - Perform early exit if all elements in the search range are the same. - Handle cases where the array contains duplicate values. - Optimize calculation and estimation formula to limit unnecessary position calculations. # Constraints: - The function should only use a constant amount of extra memory. - It should terminate within a reasonable time for the given input size. # Example: ```python def enhanced_interpolation_search(array: List[int], search_key: int) -> int: # Your implementation here # Example Function Calls print(enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], 17)) # Output: 4 print(enhanced_interpolation_search([10], 10)) # Output: 0 print(enhanced_interpolation_search([3, 3, 3], 3)) # Output: 0 print(enhanced_interpolation_search([-10, -5, 0, 5, 10], 0)) # Output: 2 print(enhanced_interpolation_search([1, 1, 1, 1, 1], 2)) # Output: -1 ``` # Additional Task: After completing the function, provide a brief written reflection (50-100 words) on how you optimized the algorithm and handled the edge cases, explaining your reasoning.","solution":"def enhanced_interpolation_search(array, search_key): Function to perform enhanced interpolation search on the sorted list `array`. Returns the index of `search_key` if found, otherwise returns -1. low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: # Early exit if all elements in the current range are the same if array[low] == array[high]: if array[low] == search_key: return low else: return -1 # Calculate the position using interpolation formula pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Question: Finding the Intersection Node of Two Singly Linked Lists As a software developer, you are tasked with determining whether two singly linked lists intersect at some common node. If they do, you should return the intersecting node itself, not just the value. If they do not intersect, return `None`. You are given the following `Node` class to represent the linked list nodes: ```python class Node(object): def __init__(self, val=None): self.val = val self.next = None ``` # Function Signature ```python def find_intersection(h1: Node, h2: Node) -> Node: ``` # Input - `h1` (Node): The head node of the first singly linked list. - `h2` (Node): The head node of the second singly linked list. # Output - Return the intersecting node if it exists, otherwise return `None`. # Constraints - Each list has at least one node (head). - The linked lists span from Node integers 1 to 10000. # Example ```python # List 1: 1 -> 3 -> 5 -> 7 -> 9 -> 11 # List 2: 2 -> 4 -> 6 -> 7 -> 9 -> 11 # Intersecting node\'s value is 7 a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d # Intersection d.next = e e.next = f assert find_intersection(a1, a2).val == 7 ``` # Hints - Consider initializing the longer and shorter lists to align their starting points. - Traverse both lists simultaneously to detect and return the intersection point. Write a function `find_intersection` that correctly identifies the intersecting node. Ensure your implementation is efficient and handles all edge cases mentioned.","solution":"class Node(object): def __init__(self, val=None): self.val = val self.next = None def find_intersection(h1: Node, h2: Node) -> Node: def get_length(node): length = 0 while node: length += 1 node = node.next return length len1 = get_length(h1) len2 = get_length(h2) if len1 > len2: h1, h2 = h2, h1 len1, len2 = len2, len1 # Move the longer list\'s pointer forward by the difference in lengths for _ in range(len2 - len1): h2 = h2.next while h1 and h2: if h1 is h2: return h1 h1 = h1.next h2 = h2.next return None"},{"question":"Given a sorted array of integers, implement a function `interpolation_search` to locate the position of a given search key. The array is guaranteed to have uniformly distributed elements. Function Signature ```python def interpolation_search(array: List[int], search_key: int) -> int: ``` Input * `array` (List[int]): A sorted list of integers. * `search_key` (int): The integer value to search for within the array. Output * Returns the index of the `search_key` in `array` if it is found. * Returns `-1` if the `search_key` is not present in the array. Constraints * The array only contains integers. * The array will have at least one element. * The array is sorted in non-decreasing order. * The integer values are uniformly distributed within the array. Performance Requirements * Aim for (O(log log n)) time complexity for best case scenarios with appropriate average performance. Example ```python assert interpolation_search([3, 4, 7, 9, 12, 14, 18, 21], 12) == 4 assert interpolation_search([5, 8, 10, 15, 22, 25], 10) == 2 assert interpolation_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 10) == -1 assert interpolation_search([100, 200, 300, 400, 500], 100) == 0 assert interpolation_search([100, 200, 300, 400, 500], 600) == -1 ```","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: # Avoid division by zero if array[high] == array[low] if array[low] == array[high]: if array[low] == search_key: return low else: return -1 # Probing the position with the interpolation formula pos = low + ((search_key - array[low]) * (high - low) // (array[high] - array[low])) # Check if the search_key is found at pos if array[pos] == search_key: return pos # If search_key is larger, search in the upper half if array[pos] < search_key: low = pos + 1 # If search_key is smaller, search in the lower half else: high = pos - 1 return -1"},{"question":"Objective: Implement a function to find the single unique number in a list of integers where every other number appears exactly twice. Context: You are given a list of integers, where each integer appears exactly twice except for one integer that appears once. Your task is to identify the single number that does not have a pair. Function Specifications: * **Function Name**: `find_single_number` * **Input**: * `nums` (List[int]): A list of integers. * **Output**: * Returns an integer, the single number that appears only once in the list. Constraints: * The input list will contain at least one element. * Exactly one element will appear only once, while all others will appear exactly twice. * Your solution should have a linear runtime complexity (O(n)). * You should not use extra memory; the space complexity should be O(1). Example: ```python find_single_number([2, 2, 1]) # returns 1 find_single_number([4, 1, 2, 1, 2]) # returns 4 find_single_number([1]) # returns 1 ``` Hints: * Use bitwise operations to solve this problem efficiently.","solution":"def find_single_number(nums): Finds the single number that appears only once in the list where every other number appears twice. Args: nums (List[int]): A list of integers Returns: int: The single number that appears only once unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Question: Finding the Modal Values with Variants Given an array of integers, create a function that identifies the most frequently occurring elements. Your function should handle cases where multiple elements have the highest frequency, returning all such elements in a list. An empty array should return an empty list. # Function Signature ```python def find_modes(arr: List[int]) -> List[int]: pass ``` # Input - `arr` (List[int]): An array of integers, not necessarily sorted. # Output - (List[int]): A list of integers representing the modal values (the most frequent elements). # Constraints - The array can contain both positive and negative integers. - The array length will not exceed 10^6 elements. - The elements\' values will be within the range of -10^6 to 10^6. # Example ```python assert find_modes([1, 1, 2, 2, 3, 4]) == [1, 2] assert find_modes([1, 1, 1, 2, 3, 3, 3, 4, 4, 4]) == [1, 3, 4] assert find_modes([5]) == [5] assert find_modes([]) == [] assert find_modes([-1, -1, 2, 2]) == [-1, 2] ``` # Notes - Your function should handle an input array of any size efficiently. - Consider edge cases such as empty arrays or arrays with all unique elements. - Make sure to write clean and readable code with appropriate variable names.","solution":"from typing import List from collections import Counter def find_modes(arr: List[int]) -> List[int]: if not arr: return [] frequency_counter = Counter(arr) max_frequency = max(frequency_counter.values()) modes = [key for key, value in frequency_counter.items() if value == max_frequency] return modes"},{"question":"# Matrix Transformation Challenge **Scenario**: You are developing a 2D game and need to rotate and invert game boards, represented by 2D matrices, for various gameplay mechanics. To ensure your game performs smoothly, you need efficient algorithms to transform these matrices. **Objective**: Write Python functions to perform each of the following transformations on a given N x N matrix: 1. Rotate the matrix 90 degrees clockwise. 2. Rotate the matrix 90 degrees counterclockwise. 3. Invert the matrix along the top-left to bottom-right diagonal. 4. Invert the matrix along the bottom-left to top-right diagonal. **Function Specifications**: 1. `rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]` - **Input**: A 2D matrix of integers. - **Output**: A new matrix representing the input matrix rotated 90 degrees clockwise. 2. `rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]` - **Input**: A 2D matrix of integers. - **Output**: A new matrix representing the input matrix rotated 90 degrees counterclockwise. 3. `top_left_invert(matrix: List[List[int]]) -> List[List[int]]` - **Input**: A 2D matrix of integers. - **Output**: A new matrix representing the input matrix inverted along its top-left to bottom-right diagonal. 4. `bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]` - **Input**: A 2D matrix of integers. - **Output**: A new matrix representing the input matrix inverted along its bottom-left to top-right diagonal. **Constraints**: - Each function must handle matrices of size NxN, where 1 <= N <= 100. - Do not modify the input matrix in-place; return a new matrix. - Aim for clarity and efficiency in your implementations. **Performance Requirements**: Ensure that each function has a time complexity of O(N^2) and a space complexity of O(N^2). **Examples**: ```python input_matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Output for clockwise rotation [[7, 4, 1], [8, 5, 2], [9, 6, 3]] # Output for counterclockwise rotation [[3, 6, 9], [2, 5, 8], [1, 4, 7]] # Output for top-left diagonal inversion [[1, 4, 7], [2, 5, 8], [3, 6, 9]] # Output for bottom-left diagonal inversion [[9, 6, 3], [8, 5, 2], [7, 4, 1]] ``` Provide efficient implementations for these functions to help transform matrices, facilitating your game development operations.","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: Returns the matrix rotated 90 degrees clockwise. n = len(matrix) rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: Returns the matrix rotated 90 degrees counterclockwise. n = len(matrix) rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[n - 1 - j][i] = matrix[i][j] return rotated def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: Returns the matrix inverted along the top-left to bottom-right diagonal. n = len(matrix) inverted = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): inverted[j][i] = matrix[i][j] return inverted def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: Returns the matrix inverted along the bottom-left to top-right diagonal. n = len(matrix) inverted = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): inverted[n - 1 - j][n - 1 - i] = matrix[i][j] return inverted"},{"question":"Scenario You have been hired by a large company to implement a search functionality for their database of sorted user IDs. They expect the search function to be very efficient since the database can grow large over time. You are tasked with writing both iterative and recursive versions of the binary search algorithm. Task Write two functions that implement binary search to find the position of a target value in a sorted array: 1. An iterative version. 2. A recursive version. Function Specifications 1. **Iterative Version**: - **Function Name**: `binary_search_iterative` - **Inputs**: - `array`: a list of integers, sorted in ascending order. - `target`: an integer, the value to search for. - **Output**: an integer representing the index of the target in the array, or -1 if the target is not found. 2. **Recursive Version**: - **Function Name**: `binary_search_recursive` - **Inputs**: - `array`: a list of integers, sorted in ascending order. - `low`: an integer, the starting index of the current subarray. - `high`: an integer, the ending index of the current subarray. - `target`: an integer, the value to search for. - **Output**: an integer representing the index of the target in the array, or -1 if the target is not found. Constraints - The array will have a length of at most (10^6). - All values in the array are distinct integers. - The target value can be any integer. Performance Requirements Both implementations should have a time complexity of O(log n). Example ```python # Iterative version array = [1, 3, 5, 7, 9, 11] target = 5 print(binary_search_iterative(array, target)) # Output: 2 # Recursive version array = [1, 3, 5, 7, 9, 11] low = 0 high = len(array) - 1 target = 8 print(binary_search_recursive(array, low, high, target)) # Output: -1 ``` Expectations - Use the provided input-output format strictly. - Ensure robust handling of edge cases such as empty arrays and targets not present in the array.","solution":"def binary_search_iterative(array, target): Perform binary search in an iterative manner to find the target in the sorted array. :param array: List of sorted integers. :param target: Integer value to search for. :return: Index of the target if found, otherwise -1. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: low = mid + 1 else: high = mid - 1 return -1 def binary_search_recursive(array, low, high, target): Perform binary search in a recursive manner to find the target in the sorted array. :param array: List of sorted integers. :param low: Starting index of the current subarray. :param high: Ending index of the current subarray. :param target: Integer value to search for. :return: Index of the target if found, otherwise -1. if low > high: return -1 mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: return binary_search_recursive(array, mid + 1, high, target) else: return binary_search_recursive(array, low, mid - 1, target)"},{"question":"# Insertion Sort with Visualization You are required to implement an Insertion Sort function that sorts an array of integers in ascending order. Additionally, the function should print the array at each iteration to provide a visualization of the sorting process. Function Signature ```python def insertion_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` Input - `arr` (List[int]): A list of integers to be sorted. - `simulation` (bool): A boolean flag indicating whether to print the array after each outer loop iteration (default is False). Output - Returns a sorted list of integers. Constraints - The length of `arr` is at most 1000. - Each integer in `arr` is in the range from `-1000` to `1000`. Example ```python arr = [5, 2, 9, 1, 5, 6] print(insertion_sort(arr, simulation=True)) ``` Output: ``` iteration 0 : 5 2 9 1 5 6 iteration 1 : 2 5 9 1 5 6 iteration 2 : 2 5 9 1 5 6 iteration 3 : 1 2 5 9 5 6 iteration 4 : 1 2 5 5 9 6 iteration 5 : 1 2 5 5 6 9 ``` # Task 1. Implement the `insertion_sort` function as described. 2. Ensure the function prints the array after each outer loop iteration when `simulation` is set to True. 3. Handle edge cases such as empty arrays and arrays with a single element. 4. Optimize and test your function to handle the constraints efficiently.","solution":"from typing import List def insertion_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts the array in ascending order using the insertion sort algorithm. If simulation is True, prints the array at each outer loop iteration. Args: arr (List[int]): The list of integers to be sorted. simulation (bool): Whether to print the array at each iteration. Default is False. Returns: List[int]: The sorted list. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(f\\"iteration {i-1} :\\", \' \'.join(map(str, arr))) return arr"},{"question":"# Scenario You are helping to optimize a transportation network where the cost of moving from one station to another is captured in a matrix. You need to determine the minimum cost required to travel from the first station to the last station. The matrix is structured in such a way that only forward movements (i.e., from an ith station to a jth station where i < j) have a defined cost. # Task Write a function `find_min_cost(matrix: List[List[int]]) -> int` that computes the minimum cost to travel from the first station to the last station using the provided cost matrix. # Input - `matrix`: A list of lists of integers, where `matrix[i][j]` represents the cost of moving from station `i` to station `j` for `i < j`. The elements where `i >= j` are either `-1` or a large value (e.g., `inf`). The matrix is of size `N x N`. # Output - Return an integer, which is the minimum cost to reach the last station from the first station. # Constraints - The size of the matrix ( N ) is between 2 and 100. - The cost values in the matrix are between 1 and 10^4 or are set to (-1) or `inf` where `i >= j`. # Performance Requirements - Your solution should have a time complexity of (O(N^2)) and a space complexity of (O(N)). # Example ```python # Example input cost_matrix = [ [0, 15, 80, 90], [-1, 0, 40, 50], [-1, -1, 0, 70], [-1, -1, -1, 0] ] # Expected output # The minimum cost to reach the last station is 65 minimum_cost = find_min_cost(cost_matrix) print(minimum_cost) # Output: 65 ``` **Note:** The provided matrix guarantees that values where `i >= j` do not influence the calculation and are represented by `-1` or `inf`.","solution":"def find_min_cost(matrix): Given a cost matrix where cell (i, j) (i < j) represents the cost to travel from station i to station j, find the minimum cost from station 0 to station N-1. N = len(matrix) min_cost = [float(\'inf\')] * N min_cost[0] = 0 for i in range(N): for j in range(i + 1, N): if matrix[i][j] != -1: # assuming -1 represents non-usable paths min_cost[j] = min(min_cost[j], min_cost[i] + matrix[i][j]) return min_cost[N-1]"},{"question":"Implement Modified Binary Search Scenario You have been provided with a sorted list of integers representing a dataset. Your task is to implement a modified binary search function that not only finds the target element but also returns the range of indices (starting and ending positions) where this target element appears consecutively. If the element doesn\'t exist, the function should return [-1, -1]. # Function Signature ```python def find_range(arr: List[int], target: int) -> List[int]: Args: arr (List[int]): A list of sorted integers. target (int): Target integer to search for in the array. Returns: List[int]: A list containing two integers, [start, end] representing the starting and ending positions of the target element. If the target is not present, return [-1, -1]. ``` # Input * A sorted list of integers `arr` (1 <= len(arr) <= 10^5). * An integer `target`. # Output * A list of two integers representing the starting and ending indices of the continuous range of the target value within the array. If the target is not found, return [-1, -1]. # Constraints * The array `arr` is sorted in ascending order. * Time complexity should not exceed O(log N). # Example ```python assert find_range([5, 7, 7, 8, 8, 10], 8) == [3, 4] assert find_range([5, 7, 7, 8, 8, 10], 6) == [-1, -1] assert find_range([1, 1, 1, 1, 1], 1) == [0, 4] assert find_range([], 1) == [-1, -1] assert find_range([1, 2, 3, 4, 5], 3) == [2, 2] ``` # Requirements 1. Your function should make use of the binary search algorithm as its core. 2. You are encouraged to create helper functions to find the start and end indices separately.","solution":"from typing import List def find_range(arr: List[int], target: int) -> List[int]: def find_start(arr, target): left, right = 0, len(arr) - 1 start = -1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: start = mid right = mid - 1 elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return start def find_end(arr, target): left, right = 0, len(arr) - 1 end = -1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: end = mid left = mid + 1 elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return end start = find_start(arr, target) if start == -1: return [-1, -1] end = find_end(arr, target) return [start, end]"},{"question":"# Pancake Sorting Assessment Question Scenario You have been hired as an intern at a software company. Your first task is to implement a classic sorting algorithm that sorts a stack of pancakes by size. Specifically, you need to sort arbitrary arrays using the Pancake Sort algorithm. The goal is to familiarize yourself with sorting mechanics and to practice array manipulation. Problem Statement Write a function `pancake_sort(arr)` that takes as input a list of integers `arr` and returns a list where the integers are sorted in ascending order. You must use the pancake sorting algorithm to accomplish this. Function Signature ```python def pancake_sort(arr: List[int]) -> List[int]: # implementation ``` Input * `arr`: A list of integers. The size of `arr` (N) will be between 0 and 10^3. Output * A sorted list of integers in ascending order. Constraints * Your solution should have a time complexity of O(N^2). * You should not use any built-in sorting functions or libraries. Example ```python # Example 1 assert pancake_sort([3, 2, 4, 1]) == [1, 2, 3, 4] # Example 2 assert pancake_sort([0, -1, 5, 3, 2]) == [-1, 0, 2, 3, 5] ``` Additional Notes Consider edge cases where: * The input array is empty (e.g., `[]`). * The input array contains a single element (e.g., `[5]`). * The input array is already sorted (e.g., `[1, 2, 3, 4]`). * The input array is sorted in reverse order (e.g., `[4, 3, 2, 1]`). Implement the function following best practices to ensure it is robust, efficient, and handles all edge cases correctly.","solution":"from typing import List def flip(arr: List[int], k: int) -> None: Helper function to reverse the order of the first k elements of the array. arr[:k] = arr[:k][::-1] def find_max_index(arr: List[int], n: int) -> int: Helper function to find the index of the maximum element in the arr[0:n]. max_index = 0 for i in range(1, n): if arr[i] > arr[max_index]: max_index = i return max_index def pancake_sort(arr: List[int]) -> List[int]: Sorts the array using the pancake sorting algorithm and returns the sorted array. n = len(arr) for size in range(n, 1, -1): max_index = find_max_index(arr, size) if max_index != size - 1: flip(arr, max_index + 1) flip(arr, size) return arr"},{"question":"# Question: You are given a sorted array of integers and a target integer `query`. Your task is to write a function that finds the index of the last occurrence of the `query` in the array using an efficient algorithm with a time complexity of O(log n). Function Signature: ```python def last_occurrence(array: List[int], query: int) -> int: Finds the last occurrence of an integer in a sorted list. Args: array (List[int]): A list of integers sorted in increasing order. query (int): The integer to find the last occurrence of. Returns: int: The index of the last occurrence of the query in the array, or -1 if not found. ``` Input: - `array`: A list of n integers where 1 <= n <= 10^5. All integers are sorted in increasing order. - `query`: An integer which can be positive or negative and within the integer range. Output: - Return the index of the last occurrence of the `query` in the array. If the `query` is not present in the array, return -1. Constraints: - The array is guaranteed to be sorted in non-decreasing order. Scenario: Imagine you are working on an application to track the frequency distribution of specific events represented as integer codes that happen over time. For efficiently determining the last occurrence of an event code in a vast historical record (represented as a sorted array), you need to implement this function. Performance Requirement: The runtime complexity of your solution must be O(log n) due to the potential large size of the array. # Example: ```python assert last_occurrence([1, 2, 2, 2, 3, 3, 4], 2) == 3 assert last_occurrence([1, 1, 1, 1], 1) == 3 assert last_occurrence([1, 3, 3, 5, 5, 5, 8, 8], 4) == -1 assert last_occurrence([], 5) == -1 assert last_occurrence([1], 1) == 0 ``` **Explanation**: 1. In the first example, `2` occurs last at index `3`. 2. In the second example, `1` occurs last at index `3`. 3. In the third example, `4` is not in the array so the return is `-1`. 4. In the fourth example, the array is empty so the return is `-1`. 5. In the last example, the single element `1` is found at index `0`. Implement the `last_occurrence` function to achieve the given requirements.","solution":"from typing import List def last_occurrence(array: List[int], query: int) -> int: Finds the last occurrence of an integer in a sorted list. Args: array (List[int]): A list of integers sorted in increasing order. query (int): The integer to find the last occurrence of. Returns: int: The index of the last occurrence of the query in the array, or -1 if not found. left, right = 0, len(array) - 1 last_index = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: last_index = mid left = mid + 1 # Continue searching to the right for the last occurrence elif array[mid] < query: left = mid + 1 else: right = mid - 1 return last_index"},{"question":"# Ternary Search Implementation and Analysis **Context**: You are tasked with optimizing the search operation in a log file analysis tool. Given the large size of log files stored as sorted arrays of timestamps, you need to implement an efficient search mechanism. You\'ve decided to use the Ternary Search algorithm due to its promising logarithmic search performance. **Task**: Implement the `ternary_search` function with the signature `ternary_search(left, right, key, arr)` to locate the index of the given `key` in the sorted array `arr`. **Function Signature**: ```python def ternary_search(left, right, key, arr): Find the given value (key) in an array sorted in ascending order. Returns the index of the value if found, and -1 otherwise. If the index is not in the range left..right (i.e., left <= index <= right), returns -1. ``` **Inputs**: - `left` (int): The starting index of the array segment to be searched. - `right` (int): The ending index of the array segment to be searched. - `key` (int/float): The value to be searched for. - `arr` (List[int/float]): The sorted array of numbers. **Outputs**: - (int): The index of the `key` in the array if found; otherwise, -1. **Constraints**: - The array `arr` is non-empty and sorted in ascending order. - The value of `left` is initialized to 0 and `right` to len(arr) - 1 for the full array search. - The function should handle edge cases, such as the key not being present in the array or the array being empty. **Performance Requirements**: - Must operate within O(log3(N)) time complexity. - Aim for an O(1) space complexity. # Example: ```python # Example usage: arr = [1, 2, 3, 5, 9, 15, 17, 19, 23, 25] key = 15 result = ternary_search(0, len(arr) - 1, key, arr) print(result) # Output should be the index of 15 in arr, 5 in this case. ``` Implement the function now.","solution":"def ternary_search(left, right, key, arr): Find the given value (key) in an array sorted in ascending order. Returns the index of the value if found, and -1 otherwise. If the index is not in the range left..right (i.e., left <= index <= right), returns -1. while left <= right: third = (right - left) // 3 mid1 = left + third mid2 = right - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"# Question **Title**: Implementing Enhanced Quick Sort **Description**: In this exercise, we will implement an enhanced version of the Quick Sort algorithm to handle some common weaknesses, such as poor performance on already sorted arrays. Specifically, we will improve the pivot selection strategy to ensure more balanced partitions. **Requirements**: 1. Implement the function `enhanced_quick_sort(arr)`. It should sort an array using the Quick Sort algorithm, but with an optimized pivot selection strategy. 2. The pivot should be chosen using the \\"median-of-three\\" method, which considers the first, middle, and last elements of the array and chooses the median of these three values as the pivot. 3. The function should operate in-place and return the sorted array. **Input**: - A list of integers `arr` **Output**: - A list of integers `arr`, sorted in ascending order **Constraints**: - `1 <= len(arr) <= 10^5` - `-10^9 <= arr[i] <= 10^9` for each integer `arr[i]` **Performance Requirements**: - The algorithm should achieve an average-case time complexity of O(n log n). **Example**: ```python Input: [3, 6, 8, 10, 1, 2, 1] Output: [1, 1, 2, 3, 6, 8, 10] Input: [5, 4, 3, 2, 1] Output: [1, 2, 3, 4, 5] ``` **Function Signature**: ```python def enhanced_quick_sort(arr: List[int]) -> List[int]: pass # Necessary helper functions or additional code can be defined or imported as needed. ``` **Hints**: 1. You may need to define additional helper functions (e.g., for partitioning the array and choosing the pivot). 2. Consider edge cases such as arrays with duplicate elements or very small arrays.","solution":"from typing import List def enhanced_quick_sort(arr: List[int]) -> List[int]: def median_of_three(low, high): mid = (low + high) // 2 a, b, c = arr[low], arr[mid], arr[high] pivot = sorted([a, b, c])[1] if pivot == a: return low elif pivot == b: return mid else: return high def partition(low, high): pivot_index = median_of_three(low, high) pivot_value = arr[pivot_index] arr[pivot_index], arr[low] = arr[low], arr[pivot_index] border = low for i in range(low, high + 1): if arr[i] < pivot_value: border += 1 arr[i], arr[border] = arr[border], arr[i] arr[low], arr[border] = arr[border], arr[low] return border def quick_sort_recursive(low, high): if low < high: pivot_index = partition(low, high) quick_sort_recursive(low, pivot_index - 1) quick_sort_recursive(pivot_index + 1, high) quick_sort_recursive(0, len(arr) - 1) return arr"},{"question":"# Scenario You are working on a data cleaning application that limits the frequency of elements in streaming data. Given a sequence of events represented by integers, you need to ensure no event appears more than a specified number of times (N). # Task Implement the function `limit_event_frequency` that takes a list of integers `events` and an integer `N`, and returns a new list where each integer appears at most N times, while preserving the order of their first appearances. # Input Format - `events`: A list of integers where 1 ≤ len(events) ≤ 10^6. - `N`: An integer where 0 ≤ N ≤ len(events). # Output Format - A list of integers where each integer appears at most N times in the order they first appear in `events`. # Constraints - The elements of the list can be any valid integer. - Aim for a solution with a time complexity of O(n). # Example ```python def limit_event_frequency(events, N): # Your implementation here # Example usage: # Events List: [5, 3, 5, 7, 5, 3, 7, 7, 5] # Limit N: 2 # Result: [5, 3, 5, 7, 3, 7] print(limit_event_frequency([5, 3, 5, 7, 5, 3, 7, 7, 5], 2)) ``` # Explanation In this example, the number 5 appears 4 times initially, but only the first 2 occurrences are allowed in the output as N=2. Similarly, 3 and 7 appear multiple times, but only their first 2 occurrences are retained. # Additional Test Cases - Input: `[1,2,2,3,1,2,3]`, N = 1; Output: `[1,2,3]` - Input: `[1,2,2,3,1,2,3]`, N = 2; Output: `[1,2,2,3,1]` - Input: `[1,2,3,4,5]`, N = 0; Output: `[]`","solution":"def limit_event_frequency(events, N): This function takes a list of integers and an integer N, and returns a new list where each integer appears at most N times, preserving the order of their first appearances. if N == 0: return [] from collections import defaultdict frequency = defaultdict(int) result = [] for event in events: if frequency[event] < N: result.append(event) frequency[event] += 1 return result # Example usage: # Events List: [5, 3, 5, 7, 5, 3, 7, 7, 5] # Limit N: 2 # Result: [5, 3, 5, 7, 3, 7] print(limit_event_frequency([5, 3, 5, 7, 5, 3, 7, 7, 5], 2))"},{"question":"# Question: Implement an Enhanced Sorting Algorithm You are a software engineer tasked with sorting a list of integers that may contain negative numbers, zeros, and positive integers. To test your understanding of different sorting techniques, you are required to implement an optimized version of the sorting algorithm provided. To make the task more challenging and realistic: 1. **Identify edge cases**: Consider scenarios like empty lists, single-element lists, or lists with identical elements. 2. **Implement improvements**: Although the basic exchange sort works, you are expected to enhance its efficiency wherever possible. 3. **Measure performance**: Compare the performance of your optimized version against the standard exchange sort for different list sizes (e.g., increasing size of input lists). # Input - A list of integers (which can be negative, zero, or positive). # Output - A sorted list of integers in non-decreasing order. # Constraints - The list length will not exceed 10^4. - The integer values range between -10^6 and 10^6. # Requirements - Your implementation should be optimized for both time and space complexity compared to traditional exchange sort. - Your solution should handle large datasets efficiently and handle edge cases gracefully. # Function Signature ```python def optimized_sort(arr: list) -> list: # Your implementation here ``` # Example ```python # Example 1 input: [4, 2, -3, 1, 0, -1] output: [-3, -1, 0, 1, 2, 4] # Example 2 input: [4] output: [4] # Example 3 input: [1, 1, 1, 1] output: [1, 1, 1, 1] # Example 4 input: [] output: [] ``` Your task is to write the `optimized_sort` function that meets the above specifications and demonstrates significant improvements over the simple exchange sort function provided.","solution":"def optimized_sort(arr: list) -> list: Optimized sorting algorithm using Python\'s built-in Timsort. This algorithm works efficiently for both large and small datasets and is well-suited to handle edge cases. return sorted(arr)"},{"question":"Context: You are given an array of integers, and you need to create a data structure to support efficient update and prefix sum query operations. Task: Implement a class `FenwickTree` that supports the following methods: 1. **`__init__(self, nums: List[int]) -> None:`** - Constructor to initialize the Fenwick Tree using the given list of integers `nums`. 2. **`update(self, index: int, value: int) -> None:`** - Update the element at position `index` to a new value `value`. 3. **`sum_range(self, index: int) -> int:`** - Return the sum of elements from the start of the array to the given index `index` (inclusive). Constraints: - The number of elements in the array will be between 1 and (10^5). - The element values will be between (-10^5) and (10^5). - You must implement this efficiently with respect to both time and space. Input: - The constructor of the class `FenwickTree` will receive a list of integers `nums`. - The method `update` will receive two integers `index` and `value`. - The method `sum_range` will receive one integer `index`. Output: - The `update` method should not return anything. - The `sum_range` method should return a single integer, the sum of elements from the start of the array to the given index. Example: ```python # Initialize Fenwick Tree with array [1, 7, 3] fenwick_tree = FenwickTree([1, 7, 3]) # Get the sum of the first 2 elements (index 0 to 2) assert fenwick_tree.sum_range(2) == 11 # Update element at index 1 to the new value 5 fenwick_tree.update(1, 5) # Get the updated sum of the first 2 elements (index 0 to 2) assert fenwick_tree.sum_range(2) == 9 ``` Implementation: Below is a skeleton code to help you get started: ```python from typing import List class FenwickTree: def __init__(self, nums: List[int]) -> None: self.n = len(nums) self.bit = [0] * (self.n + 1) self.arr = nums for i in range(self.n): self.update(i, nums[i]) def update(self, index: int, value: int) -> None: delta = value - self.arr[index] self.arr[index] = value i = index + 1 while i <= self.n: self.bit[i] += delta i += i & (-i) def sum_range(self, index: int) -> int: i = index + 1 s = 0 while i > 0: s += self.bit[i] i -= i & (-i) return s ``` Note: - Ensure you handle the indexing correctly to avoid off-by-one errors. - Test your solution with various edge cases and large input sizes to confirm its efficiency and correctness.","solution":"from typing import List class FenwickTree: def __init__(self, nums: List[int]) -> None: self.n = len(nums) self.bit = [0] * (self.n + 1) self.arr = nums[:] for i in range(self.n): self._update_internal(i, nums[i]) def _update_internal(self, index: int, delta: int) -> None: i = index + 1 while i <= self.n: self.bit[i] += delta i += i & -i def update(self, index: int, value: int) -> None: delta = value - self.arr[index] self.arr[index] = value self._update_internal(index, delta) def sum_range(self, index: int) -> int: i = index + 1 s = 0 while i > 0: s += self.bit[i] i -= i & -i return s"},{"question":"You are given an array of integers, and you need to perform two types of operations efficiently: 1. **Query the sum** of the first `i` elements of the array. 2. **Update the value** of an element at a specified position in the array. To achieve this, implement a Fenwick Tree (Binary Indexed Tree) with the following functionalities: Function Signatures ```python class FenwickTree: def __init__(self, arr: List[int]): Initializes the Fenwick Tree with the given array. :param arr: List[int] - The input array. def update(self, index: int, value: int): Updates the value at the specified index. :param index: The index of the element to update. :param value: The new value to set at the specified index. def prefix_sum(self, index: int) -> int: Returns the prefix sum from index 0 to the specified index. :param index: The ending index of the range [0, index]. :return: The sum of the elements from index 0 to the specified index. ``` Input 1. `arr`: List of non-negative integers (1 <= len(arr) <= 1000, 0 <= arr[i] <= 1000). 2. `operations`: List of operations to be performed, where each operation is a tuple (type, index, value). - `type` can be \'update\' or \'query\'. - For \'update\', you will receive (index, value). - For \'query\', you will receive (index,). Output For each query operation, return the resulting prefix sum in the order of queries. Example Input: ```python arr = [1, 2, 3, 4, 5] operations = [(\'query\', 3), (\'update\', 1, 10), (\'query\', 3), (\'update\', 4, 5), (\'query\', 4)] ``` Output: ```python [10, 19, 24] ``` Explanation: - First `query(3)` => sum([1, 2, 3, 4]) = 10. - Then `update(1, 10)` changes array to [1, 10, 3, 4, 5]. - Second `query(3)` => sum([1, 10, 3, 4]) = 19. - Then `update(4, 5)` changes array to [1, 10, 3, 4, 5]. - Third `query(4)` => sum([1, 10, 3, 4, 5]) = 24. Ensure your solution is efficient with respect to the constraints.","solution":"class FenwickTree: def __init__(self, arr): Initializes the Fenwick Tree with the given array. :param arr: List[int] - The input array. self.size = len(arr) self.tree = [0] * (self.size + 1) self.arr = arr[:] for i, value in enumerate(arr): self._add(i + 1, value) def _add(self, index, value): while index <= self.size: self.tree[index] += value index += index & -index def _sum(self, index): result = 0 while index > 0: result += self.tree[index] index -= index & -index return result def update(self, index, value): Updates the value at the specified index. :param index: The index of the element to update (0-based). :param value: The new value to set at the specified index. index += 1 # Convert to 1-based index current_value = self.arr[index - 1] self.arr[index - 1] = value diff = value - current_value self._add(index, diff) def prefix_sum(self, index): Returns the prefix sum from index 0 to the specified index. :param index: The ending index of the range [0, index] (0-based). :return: The sum of the elements from index 0 to the specified index. return self._sum(index + 1)"},{"question":"# Question Scenario: You are developing a command-line application that often requires manipulating file paths provided by the user. To ensure the paths are correctly interpreted, you need a utility function that converts any relative or shorthand paths into their full absolute path equivalents. Given this requirement, implement the `full_path` function. Task: Implement a function `full_path(file_path: str) -> str` that takes a string input representing a file path and returns the absolute path equivalent. Input: - `file_path` (str): A string representing a file path which may be in shorthand (e.g., `~` for the home directory) or relative form. Output: - A string representing the resolved absolute path of the file. Constraints: - The input will be a valid string, though it may be empty. - The function must handle various user home directory shorthands (both `~` and `~username`). - The function should handle paths with mixed or double slashes correctly. # Examples ```python >>> full_path(\'~/file.txt\') \'/home/username/file.txt\' # Assuming username\'s home directory is /home/username >>> full_path(\'../somefolder/somefile.txt\') \'/abs/path/to/currentdir/../somefolder/somefile.txt\' # Assuming currentdir is /abs/path/to/currentdir >>> full_path(\'\') \'/home/username/\' # Assuming the home directory or current directory is returned if input is empty ``` Hints: - Utilize the `os.path` module. - Ensure to handle the user home directory resolution and conversion to an absolute path in a two-step process.","solution":"import os def full_path(file_path: str) -> str: Converts the provided file path to its full absolute path. This function handles relative paths, home directory shorthand (`~`), and tilde with username. Parameters: - file_path (str): The file path to convert to an absolute path. Returns: - str: The absolute path of the file. if not file_path: return os.path.abspath(os.path.expanduser(\\"~\\")) expanded_path = os.path.expanduser(file_path) absolute_path = os.path.abspath(expanded_path) return absolute_path"},{"question":"# Question: Implement Pigeonhole Sort You are tasked with implementing the pigeonhole sort algorithm to sort an array of integers. The algorithm is suitable for cases where the number of elements and the possible range of values are somewhat comparable. Implement the function `pigeonhole_sort`: Function Signature: ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` Input - `arr` (List[int]): A list of integers to be sorted. Length of the list is denoted as `n` (1 <= n <= 10^6), and the elements range between any 32-bit signed integer values. Output - Returns the sorted list in ascending order. Constraints - The function must handle arrays with both positive and negative integers properly. - Efficient sorting is required within the constraints provided. Example ```python assert pigeonhole_sort([8, 3, 2, 7, 4]) == [2, 3, 4, 7, 8] assert pigeonhole_sort([-5, 6, -2, 8, -1]) == [-5, -2, -1, 6, 8] assert pigeonhole_sort([]) == [] assert pigeonhole_sort([5]) == [5] ``` Note - Ensure handling of edge cases like an already sorted list, an array with all elements being the same, very large and very small integers, and an empty array. - Consider the performance implications of the range of values relative to the number of elements in the array.","solution":"def pigeonhole_sort(arr): Sorts an array of integers using the pigeonhole sorting algorithm. The algorithm is suitable for cases where the number of elements and the possible range of values are somewhat comparable. Parameters: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list of integers. if not arr: # If the list is empty, return an empty list return [] min_val = min(arr) max_val = max(arr) size = max_val - min_val + 1 # Initialize holes holes = [0] * size # Fill holes for number in arr: holes[number - min_val] += 1 # Reconstruct the sorted array sorted_arr = [] for index, count in enumerate(holes): sorted_arr += [index + min_val] * count return sorted_arr"},{"question":"**Background**: You are managing a streaming service that logs every user action. However, due to some spamming activity, specific user actions (like \'play\', \'pause\', \'skip\') may appear excessively in the logs. To analyze user behavior cleanly, you need to filter the logs so that no action appears more than a defined number of times. **Problem Statement**: Write a Python function `filter_user_actions(logs: List[str], max_occurrences: int) -> List[str]` which receives a sequence of user actions `logs` and an integer `max_occurrences`. The function should return a list of actions filtered such that each action appears at most `max_occurrences` times, maintaining the initial action order. **Input:** - `logs`: A list of strings where each string is a user action. - `max_occurrences`: An integer that specifies the maximum allowable occurrences for each action. **Output:** - A list of strings that represents the filtered sequence of user actions limited to `max_occurrences` times per action. **Constraints:** - The function should have a time complexity of ( O(n) ). - No other libraries apart from `collections.defaultdict` are allowed for implementation. **Examples**: ```python >>> filter_user_actions([\'play\', \'pause\', \'play\', \'play\', \'skip\', \'pause\', \'play\'], 2) [\'play\', \'pause\', \'play\', \'skip\', \'pause\'] >>> filter_user_actions([\'play\', \'play\', \'play\', \'pause\'], 1) [\'play\', \'pause\'] >>> filter_user_actions([], 0) [] ``` **Explanation**: - In the first example, the resulting list limits \'play\' and \'pause\' to 2 occurrences. - In the second example, both \'play\' and \'pause\' are limited to 1 occurrence each. - An empty list returns an empty list. Ensure your function is efficient and well-tested against edge cases like empty input, minimum/maximum values for `max_occurrences`, and large lists.","solution":"from typing import List from collections import defaultdict def filter_user_actions(logs: List[str], max_occurrences: int) -> List[str]: Filters the logs so that each action appears at most `max_occurrences` times. Parameters: logs (List[str]): The list of user actions. max_occurrences (int): The maximum number of times any action can appear in the list. Returns: List[str]: The filtered list of user actions. action_count = defaultdict(int) filtered_logs = [] for action in logs: if action_count[action] < max_occurrences: filtered_logs.append(action) action_count[action] += 1 return filtered_logs"},{"question":"Scenario You are a part of a logistics team responsible for maximizing the value of goods transported in a truck. Each item has a specific value and weight, and the truck has a weight limit capacity. To maximize the benefit of each trip, you need to determine the maximum total value of items you can load without exceeding the truck\'s weight capacity. Task Implement a function `maximize_knapsack_value` to determine the maximum total value of items that can be loaded into the truck. Input * `items`: A list of tuples, where each tuple contains two integers: - `value`: Integer representing the value of the item. - `weight`: Integer representing the weight of the item. * `capacity`: An integer representing the weight capacity of the knapsack (truck). Output * Returns an integer representing the maximum value achievable within the given weight capacity. Constraints * The number of items will be between 1 and 1000. * The weight of each item will be between 1 and 1000. * The capacity of the knapsack will be between 1 and 10000. Example ```python def maximize_knapsack_value(items, capacity): # Implement your solution here pass # Example 1 items = [(60, 5), (50, 3), (70, 4), (30, 2)] capacity = 5 print(maximize_knapsack_value(items, capacity)) # Output: 80 # Example 2 items = [(100, 20), (200, 30), (300, 50)] capacity = 60 print(maximize_knapsack_value(items, capacity)) # Output: 300 ``` # Explanation In Example 1, you can select items with values 50 and 30, which both fit into the knapsack of capacity 5, giving a total value of 80. In Example 2, only one item can be selected due to the high weight of each item relative to the capacity, hence the maximum value is 300.","solution":"def maximize_knapsack_value(items, capacity): This function calculates the maximum value of items that can be put into the knapsack without exceeding the given weight capacity. Parameters: items (list of tuples): Each tuple contains two integers (value, weight) of the item. capacity (int): The maximum weight the knapsack can carry. Returns: int: The maximum value of the items that can be put into the knapsack. # Number of items n = len(items) # Create a 2D dp array where dp[i][w] will hold the maximum value # that can be attained with weight less than or equal to w using the first i items. dp = [[0] * (capacity + 1) for _ in range(n + 1)] # Fill dp array for i in range(1, n + 1): for w in range(1, capacity + 1): value, weight = items[i-1] if weight <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + value) else: dp[i][w] = dp[i-1][w] # The value of the last cell is the answer. return dp[n][capacity]"},{"question":"# Question: Fenwick Tree Implementation for Range Queries and Updates You are tasked with implementing a Fenwick Tree (Binary Indexed Tree) to handle efficient sum queries and update operations on an array. Your implementation should support the following operations: 1. **Initialize Tree**: Construct a Fenwick Tree from a given list of integers. 2. **Range Sum Query**: Calculate the sum of elements from the start of the array to a given index. 3. **Update Value**: Update the value of a specific element in the array and adjust the tree accordingly. # Input Format - **Initialization**: A list of integers representing the initial array. - **Operations**: A list of operations, where each operation is represented as a tuple. The first element of the tuple is a string (\\"sum\\" or \\"update\\") indicating the type of operation. For \\"sum\\" operations, the second element is the index up to which the sum needs to be calculated. For \\"update\\" operations, the second and third elements are the index to update and the new value, respectively. # Output Format For each \\"sum\\" operation, print the calculated sum of elements from the start of the array up to the specified index. # Constraints * Array size: ( 1 leq n leq 10^5 ) * Update and query operations: ( 1 leq text{num_operations} leq 10^5 ) * Value range: ( -10^4 leq text{arr[i]}, text{new_value} leq 10^4 ) # Function Signature ```python class FenwickTree: def __init__(self, arr: List[int]): # Your code here def update(self, index: int, value: int) -> None: # Your code here def prefix_sum(self, index: int) -> int: # Your code here def process_operations(self, operations: List[Tuple[str, ...]]) -> List[int]: # Your code here # Example usage: # fenwick_tree = FenwickTree([1, 2, 3, 4, 5]) # operations = [(\\"sum\\", 3), (\\"update\\", 1, 10), (\\"sum\\", 3)] # result = fenwick_tree.process_operations(operations) # print(result) # Output: [10, 18] ``` Write your solution to implement the Fenwick Tree and handle the operations as described.","solution":"from typing import List, Tuple class FenwickTree: def __init__(self, arr: List[int]): self.n = len(arr) self.tree = [0] * (self.n + 1) # Fenwick Tree structure using 1-based indexing self.array = arr[:] for i in range(self.n): self._add(i + 1, arr[i]) def _add(self, index: int, value: int): while index <= self.n: self.tree[index] += value index += index & -index def update(self, index: int, value: int) -> None: index += 1 # Convert to 1-based index diff = value - self.array[index - 1] self.array[index - 1] = value self._add(index, diff) def prefix_sum(self, index: int) -> int: index += 1 # Convert to 1-based index sum_ = 0 while index > 0: sum_ += self.tree[index] index -= index & -index return sum_ def process_operations(self, operations: List[Tuple[str, ...]]) -> List[int]: results = [] for operation in operations: if operation[0] == \\"sum\\": result = self.prefix_sum(operation[1]) results.append(result) elif operation[0] == \\"update\\": self.update(operation[1], operation[2]) return results"},{"question":"# Dijkstra’s Shortest Path: Implementation Over Adjacency List You are asked to implement Dijkstra’s shortest path algorithm over an undirected, weighted graph represented with an adjacency list. The goal is to calculate the shortest path from a given source node to all other nodes in the graph. Function Signature ```python def dijkstra(graph: dict, src: int) -> dict: pass ``` Input * `graph` : dict - A dictionary representing the adjacency list of the graph where keys are node labels and values are lists of tuples `(neighbor, weight)`. - Example: `{0: [(1, 4), (2, 1)], 1: [(0, 4), (2, 2), (3, 5)], 2: [(0, 1), (1, 2), (3, 8)], 3: [(1, 5), (2, 8)]}` * `src` : int - An integer representing the source node from which shortest paths are calculated. Output * A dictionary where keys are node labels and values are the shortest path distances from the source node. Constraints * The graph is connected (there is at least one path between any two nodes). * Node labels are unique, non-negative integers. * No negative edge weights. * Assume there are at most 1000 nodes and 10,000 edges. Scenario In a city with multiple intersections as nodes and roads as weighted edges, you are building a navigation system that finds the shortest path from a given starting intersection to all other intersections in the city. This information is crucial to provide optimal routing instructions. Example ```python graph = { 0: [(1, 4), (2, 1)], 1: [(0, 4), (2, 2), (3, 5)], 2: [(0, 1), (1, 2), (3, 8)], 3: [(1, 5), (2, 8)] } src = 0 output = dijkstra(graph, src) ``` Expected output: ```python { 0: 0, 1: 3, 2: 1, 3: 8 } ``` # Notes * Ensure your function handles edge cases such as nodes with no outgoing edges.","solution":"import heapq def dijkstra(graph: dict, src: int) -> dict: Implements Dijkstra\'s shortest path algorithm using a priority queue. :param graph: A dictionary representing the adjacency list of the graph where keys are node labels and values are lists of tuples `(neighbor, weight)`. :param src: An integer representing the source node from which shortest paths are calculated. :return: A dictionary where keys are node labels and values are the shortest path distances from the source node. # Initialize distances dictionary with infinity distances = {node: float(\'inf\') for node in graph} distances[src] = 0 # Priority queue to process nodes in order of their distance from src priority_queue = [(0, src)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the current distance is greater than the recorded, skip processing if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Task Write a function that computes all possible combinations of a given number\'s factors. # Function Signature ```python def factor_combinations(n: int) -> List[List[int]]: Computes all unique combinations of factors of n. ``` # Input * An integer `n` such that `1 <= n <= 10^7`. # Output * A list of lists - each containing a combination of factors of the given number. # Example ```python assert factor_combinations(1) == [] assert factor_combinations(37) == [] assert factor_combinations(32) == [ [2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2] ] ``` # Constraints * Your solution should handle inputs efficiently up to `10^7`. * Do not return combinations containing the number itself as a product (i.e., `[n]`). # Notes * Consider optimization techniques to handle very large numbers. * Think about edge cases like prime numbers and `1`.","solution":"from typing import List def factor_combinations(n: int) -> List[List[int]]: def backtrack(start, target, path, result): if target == 1: if len(path) > 1: result.append(path[:]) return for i in range(start, target + 1): if target % i == 0: path.append(i) backtrack(i, target // i, path, result) path.pop() result = [] backtrack(2, n, [], result) return result"},{"question":"# Question Scenario: You are a software developer tasked with writing a function to analyze sequences of moves made by a robot in a 2D plane to determine if it returns to its starting position. Each sequence describes the moves as a string of characters, and you need to ensure that the robot follows valid movements and check if the sequence brings it back to the origin (0,0). Problem: Write a function `judge_circle(moves)` that receives a string `moves` representing a sequence of movements (consisting of characters \'U\', \'D\', \'L\', \'R\' for Up, Down, Left, and Right respectively). The function should return `True` if the robot returns to its starting position after completing the sequence, and `False` otherwise. Input and Output Formats: - **Input**: A string `moves` with valid characters \'U\', \'D\', \'L\', \'R\'. - **Output**: A boolean value `True` if the robot returns to the origin, `False` otherwise. Constraints: - The `moves` string length is at most 10000 characters. - The input string only contains valid characters \'U\', \'D\', \'L\', \'R\'. Performance Requirements: Ensure the function runs efficiently within the given constraints. Example: 1. Input: `\\"UD\\"` Output: `True` 2. Input: `\\"LL\\"` Output: `False` 3. Input: `\\"UDLR\\"` Output: `True` ```python def judge_circle(moves): dict_moves = { \'U\': 0, \'D\': 0, \'R\': 0, \'L\': 0 } for char in moves: dict_moves[char] += 1 return dict_moves[\'L\'] == dict_moves[\'R\'] and dict_moves[\'U\'] == dict_moves[\'D\'] # Test Cases print(judge_circle(\\"UD\\")) # Expected: True print(judge_circle(\\"LL\\")) # Expected: False print(judge_circle(\\"UDLR\\")) # Expected: True print(judge_circle(\\"\\")) # Expected: True ```","solution":"def judge_circle(moves): Determines if the robot returns to the origin after following the sequence of moves. Parameters: moves (str): A string representing the sequence of moves (\'U\', \'D\', \'L\', \'R\'). Returns: bool: True if the robot returns to the origin, False otherwise. x, y = 0, 0 for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0"},{"question":"# Diffie-Hellman Key Exchange Implementation Scenario Alice and Bob want to securely share a secret key using the Diffie-Hellman key exchange method. You are required to implement the algorithm to facilitate this secure key exchange. Function Implementation **Function 1: Prime Check** ```python def prime_check(num): Return True if num is a prime number else return False. pass ``` **Function 2: Euler\'s Totient Function** ```python def euler_totient(n): Return the count of numbers coprime to n. pass ``` **Function 3: Find Order** ```python def find_order(a, n): Return the order of a modulo n or -1 if it doesn\'t exist. pass ``` **Function 4: Find Primitive Roots** ```python def find_primitive_root(n): Return a list of all primitive roots of n. pass ``` **Function 5: Diffie-Hellman Key Exchange** ```python def diffie_hellman_key_exchange(a, p, option=None): Perform Diffie-Hellman key exchange and return the shared key. pass ``` Expected Input and Output 1. The prime_check function should accept an integer and return a boolean. 2. The euler_totient function should accept an integer n and return an integer. 3. The find_order function should accept integers a and n, returning an integer. 4. The find_primitive_root function should accept an integer n and return a list of integers. 5. The diffie_hellman_key_exchange function should accept integers a, p, and an optional parameter option, returning a boolean indicating the success of the key exchange. Constraints 1. `1 <= num <= 10^6` 2. `1 <= n <= 10^6` 3. `1 <= a < p, where p is prime` Performance Requirements 1. Ensure prime checking and totient function calculations are optimized. 2. Avoid unnecessary recalculations in key exchange processes. Example ```python # Example usage: p = 23 # Example prime number a = 5 # Example primitive root of 23 # Execute key exchange result = diffie_hellman_key_exchange(a, p) print(result) # Should print True if successful ``` Note: Ensure error handling for invalid inputs where `a` is not a primitive root of `p` or `p` is not prime.","solution":"from math import isqrt def prime_check(num): Return True if num is a prime number else return False. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def euler_totient(n): Return the count of numbers coprime to n. amount = 0 for k in range(1, n + 1): if gcd(n, k) == 1: amount += 1 return amount def gcd(a, b): while b: a, b = b, a % b return a def find_order(a, n): Return the order of a modulo n or -1 if it doesn\'t exist. if prime_check(n) and prime_check(a): order = 1 current = a % n while current != 1: current = (current * a) % n order += 1 return order return -1 def find_primitive_root(n): Return a list of all primitive roots of n. results = [] if not prime_check(n): return results phi = n - 1 required_set = set(num for num in range(1, phi + 1) if gcd(num, n) == 1) for g in range(1, n): actual_set = set(pow(g, powers, n) for powers in range(1, phi + 1)) if required_set == actual_set: results.append(g) return results def diffie_hellman_key_exchange(a, p, option=None): Perform Diffie-Hellman key exchange and return the shared key. if not prime_check(p): return False primitive_roots = find_primitive_root(p) if a not in primitive_roots: return False # Alice\'s private key a_private = 6 # Bob\'s private key b_private = 15 # Calculate public keys A = pow(a, a_private, p) B = pow(a, b_private, p) # Calculate shared secret keys shared_secret_Alice = pow(B, a_private, p) shared_secret_Bob = pow(A, b_private, p) return shared_secret_Alice == shared_secret_Bob"},{"question":"# AVL Tree Coding Assessment Context You have been tasked to enhance search efficiency in an application where data is frequently inserted and queried. Using the AVL tree data structure, your goal is to implement and test the insertion functionality while ensuring the tree remains balanced. Requirements: 1. Implement the `insert` function for an AVL tree that maintains balance by performing appropriate rotations as necessary. 2. Write a function `is_balanced(tree)` that checks if the AVL tree is balanced. A tree is balanced if, for every node, the difference in height between the left and right subtrees is at most one. 3. Write a function `in_order_traversal(tree)` that returns a list of the tree\'s elements in ascending order. Constraints: 1. Duplicate keys should not be inserted. 2. Each inserted element will be a unique integer within the range of -10^4 to 10^4. Functions: - `insert(tree, key)`: Inserts a key into the AVL tree. - `is_balanced(tree)`: Checks if the AVL tree is balanced. - `in_order_traversal(tree)`: Returns a list of elements in ascending order. Sample Input: ```python keys = [10, 20, 30, 40, 50, 25] avl_tree = AvlTree() for key in keys: avl_tree.insert(key) print(in_order_traversal(avl_tree)) print(is_balanced(avl_tree)) ``` Expected Output: ```python [10, 20, 25, 30, 40, 50] True ``` Implement these functionalities and ensure the AVL tree maintains balance after each insertion.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = Node(key) else: self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return Node(key) if key < node.key: node.left = self._insert(node.left, key) elif key > node.key: node.right = self._insert(node.right, key) else: return node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) # Left Left Case if balance > 1 and key < node.left.key: return self._right_rotate(node) # Right Right Case if balance < -1 and key > node.right.key: return self._left_rotate(node) # Left Right Case if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) # Right Left Case if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def is_balanced(self): def check(node): if not node: return True, 0 left_balanced, left_height = check(node.left) right_balanced, right_height = check(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return balanced, 1 + max(left_height, right_height) balanced, _ = check(self.root) return balanced def in_order_traversal(self): def traverse(node): if not node: return [] return traverse(node.left) + [node.key] + traverse(node.right) return traverse(self.root)"},{"question":"# Linked List Pair Swapping Given a singly linked list, swap every two adjacent nodes and return its head. Write a function to accomplish this where the function signature is: ```python def swap_pairs(head: Node) -> Node: ``` Input * A singly linked list represented by its head node. You have access to the `Node` class as defined below: ```python class Node: def __init__(self, x): self.val = x self.next = None ``` Output * The head node of the modified list after swapping every two adjacent nodes. Constraints 1. The algorithm must use constant space. You may not use any additional data structures like lists or arrays. 2. You may not modify the values in the list\'s nodes directly. Only the nodes themselves can be rearranged. Example ```python # Given 1->2->3->4, return the list as 2->1->4->3. head = Node(1) head.next = Node(2) head.next.next = Node(3) head.next.next.next = Node(4) new_head = swap_pairs(head) # new_head now points to the list 2 -> 1 -> 4 -> 3 ``` Scenario Jennifer works on a project that requires reordering elements within a list of tasks dynamically. Each task is represented by a node in a singly linked list. Due to a recent change in requirements, the tasks need to be executed in pairs with every consecutive pair swapped. Implementing this as an in-place operation ensures the system remains efficient with minimal overhead.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def swap_pairs(head: Node) -> Node: Function to swap every two adjacent nodes in a singly linked list. Args: head (Node): Head node of the singly linked list. Returns: Node: Head node of the modified list after swapping. if not head or not head.next: return head # Initialize a dummy node to help with the swaps dummy = Node(0) dummy.next = head prev = dummy while prev.next and prev.next.next: # Nodes to be swapped first = prev.next second = prev.next.next # Perform the swap prev.next = second first.next = second.next second.next = first # Move the prev pointer two nodes ahead prev = first return dummy.next"},{"question":"Path Resolver Utility **Scenario**: You are developing a configuration reader for an application. It needs to handle various file path formats provided by users in a configuration file. Paths can be relative, absolute, or use user-relative notation using the `~` character. To ensure consistency in file handling, you need to resolve these paths to their absolute form. **Task**: Write a function `resolve_path(file_path: str) -> str` that converts a given file path to its absolute path. Function Signature ```python def resolve_path(file_path: str) -> str: ``` Input: * **file_path** (`str`): The file path to convert. It can be absolute, relative, or user-relative. Output: * **str**: The absolute path equivalent to the input path. Constraints: * The function should be tested on various OS environments: * Windows (where paths might include drive letters like `C:`) * UNIX-like systems (where paths can start with `~` or `/`). Examples: ```python print(resolve_path(\\"~/documents/project/file.txt\\")) # Output: \'/absolute/path/to/home/documents/project/file.txt\' print(resolve_path(\\"../another_folder/file.txt\\")) # Output: \'/absolute/path/to/current/working/directory/../another_folder/file.txt\' print(resolve_path(\\"/usr/local/bin\\")) # Output: \'/usr/local/bin\' ``` Notes: 1. The function should handle cases where the user-relative path (`~`) does not correspond to an actual user or directory. 2. Ensure that paths are correctly expanded based on the current working environment.","solution":"import os def resolve_path(file_path: str) -> str: Converts a given file path to its absolute path. Parameters: file_path (str): The file path to convert. It can be absolute, relative, or user-relative. Returns: str: The absolute path equivalent to the input path. return os.path.abspath(os.path.expanduser(file_path))"},{"question":"# Context: You are given an array of words and an array of symbols. Your task is to create a function that replaces the longest matching symbol within each word with a bracketed version of that symbol. # Objective: Write a function `match_and_replace(words, symbols)` that performs the following: 1. For each word in the `words` array, identify the longest symbol it contains. 2. Replace the longest symbol in the word with its bracketed version (e.g., symbol `cro` in `Microsoft` should be replaced to form `Mi[cro]soft`). 3. If no symbol in the symbols list matches the word, the word remains unchanged. # Input: * `words (List[str])`: an array of strings. * `symbols (List[str])`: an array of symbol strings. # Output: * `List[str]`: an array of strings where each word\'s longest matching symbol is replaced by the bracketed version of that symbol. # Constraints: * Symbols and words are non-empty and comprise only alphabetical characters. * You can assume there are no repeated symbols or words. # Examples: **Example 1:** ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] output = [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` **Example 2:** ```python words = [\'Hello\', \'World\'] symbols = [\'zl\', \'xy\'] output = [\'Hello\', \'World\'] ``` # Function Signature: ```python from typing import List def match_and_replace(words: List[str], symbols: List[str]) -> List[str]: # Your code here. pass ``` Performance Requirements: Your solution should handle large arrays efficiently. Aim for a time complexity of (O(S cdot L_S + W cdot L_W)).","solution":"from typing import List def match_and_replace(words: List[str], symbols: List[str]) -> List[str]: symbols = sorted(symbols, key=len, reverse=True) # Sort symbols by length in descending order def replace_longest_symbol(word: str) -> str: for symbol in symbols: if symbol in word: return word.replace(symbol, f\'[{symbol}]\', 1) return word return [replace_longest_symbol(word) for word in words]"},{"question":"# Pancake Sort Implementation You have been tasked to implement the **Pancake Sort** algorithm, which sorts an array by repetitively flipping subarrays. Write a function `pancake_sort(arr: List[int]) -> List[int]` that sorts the provided list of integers using the Pancake Sort technique. Input - `arr`: A list of integers. The list may be empty or contain duplicates but without any explicit constraints on the range or size. Output - Return the sorted version of the input list, `arr`. Example ```python assert pancake_sort([3, 2, 4, 1]) == [1, 2, 3, 4] assert pancake_sort([8, 5, 7, 3, 2]) == [2, 3, 5, 7, 8] assert pancake_sort([1]) == [1] assert pancake_sort([]) == [] ``` Performance Requirements - The algorithm should have a time complexity of O(N^2), where N is the number of elements in the list. Additional Context Pancake Sort is designed to demonstrate the use of prefix reversals for sorting purposes. While it may not be viable for large datasets, this exercise will solidify your understanding of in-place sorting techniques and help develop your ability to think through algorithmic problems creatively. Implement the function following the provided constraints and input/output formats. Ensure that you consider edge cases and optimize where feasible within the given complexity requirements.","solution":"def flip(arr, k): Helper function to reverse the order of the first k elements of the array. arr[:k] = arr[:k][::-1] def pancake_sort(arr): Function to sort the array using Pancake Sort technique. n = len(arr) for size in range(n, 1, -1): # Find index of the maximum element in arr[0:size] max_index = arr.index(max(arr[:size])) # Move maximum element to the end of the current array slice if max_index != size - 1: # Flip the maximum element to the front if it\'s not already there if max_index != 0: flip(arr, max_index + 1) # Flip the current array slice to move the maximum element to the end flip(arr, size) return arr"},{"question":"# Matrix Multiplication Function Introduction You have been given two matrices, and you need to implement a function to multiply them. This function should handle edge cases such as incompatible matrices and raise appropriate exceptions. Function Signature ```python def matrix_multiply(multiplicand: list, multiplier: list) -> list: ... ``` Input Format - `multiplicand`: a list of lists representing the first matrix (A). Each sublist represents a row in the matrix. - `multiplier`: a list of lists representing the second matrix (B). Each sublist represents a row in the matrix. Output Format - The function should return the resultant matrix (C) after multiplication, which is also represented as a list of lists. - If the matrices are not compatible for multiplication, the function should raise an Exception with the message \\"Multiplicand matrix not compatible with Multiplier matrix.\\" Constraints - Both matrices will contain only integer values. - Dimensions of the matrices will be such that (0 < m, n, p leq 100), where: - `m` is the number of rows in the first matrix. - `n` is the number of columns in the first matrix (and rows in the second matrix). - `p` is the number of columns in the second matrix. Example ```python # Example 1 multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [5, 6], [7, 8] ] matrix_multiply(multiplicand, multiplier) # Expected Output: # [ # [19, 22], # [43, 50] # ] # Example 2 multiplicand = [ [2, 4], [1, 3], [0, 0] ] multiplier = [ [3, 4, 2], [1, 6, 5] ] matrix_multiply(multiplicand, multiplier) # Expected Output: # [ # [10, 32, 24], # [ 6, 22, 17], # [ 0, 0, 0] # ] # Example 3 multiplicand = [ [1] ] multiplier = [ [2] ] matrix_multiply(multiplicand, multiplier) # Expected Output: # [ # [2] # ] ``` Write your function to meet these specifications, ensuring it effectively handles edge cases and maintains optimal complexity.","solution":"def matrix_multiply(multiplicand: list, multiplier: list) -> list: # Get the dimensions of the multiplicand and multiplier matrices m = len(multiplicand) n = len(multiplicand[0]) p = len(multiplier[0]) # Check if matrices can be multiplied if len(multiplier) != n: raise Exception(\\"Multiplicand matrix not compatible with Multiplier matrix\\") # Initialize the result matrix with zeroes result = [[0] * p for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Topological Sorting with Iterator-Based Traversal **Context**: You are part of a project team working on a build automation tool. The tool must determine the correct order to compile files based on their dependencies. Each file depends on zero or more other files, modeled as a Directed Acyclic Graph (DAG). **Objective**: Implement an iterator-based version of topological sort. This will allow files to be compiled in an iterative manner without needing the entire order in memory at once. # Task Write a function `top_sort_iterator(graph)` that takes a graph representation as its input and returns an iterator that yields nodes in topological order. The graph is represented as an adjacency list where each key is a node and its values are the nodes it points to. # Input - `graph`: A dictionary, where `graph[node]` is a list of nodes (dependencies) that node has edges pointing to. # Output - An iterator that yields nodes in topological order. # Constraints - The graph is a DAG (no cycles). - Nodes are represented as strings. - The graph may have multiple independent subgraphs. # Performance Requirements Ensure that your solution works efficiently with time complexity O(V + E) and space complexity O(V), where `V` is the number of vertices and `E` is the number of edges. # Example ```python graph = { \'a\': [\'b\', \'c\'], \'b\': [\'d\'], \'c\': [\'d\'], \'d\': [] } iterator = top_sort_iterator(graph) print(list(iterator)) # Output could be [\'a\', \'b\', \'c\', \'d\'] or [\'a\', \'c\', \'b\', \'d\'] ``` # Important Notes - Multiple correct topological orders can exist due to independent subgraphs or multiple valid paths. - You must handle and raise an exception if the input graph contains cycles (`ValueError` with the message \\"cycle detected\\").","solution":"from collections import deque, defaultdict def top_sort_iterator(graph): Takes a DAG in the form of an adjacency list and returns an iterator that yields nodes in topological order. # Count the number of incoming edges for each node in_degree = {node: 0 for node in graph} for node in graph: for neighbor in graph[node]: in_degree[neighbor] += 1 # Initialize a queue with nodes with no incoming edges queue = deque([node for node in in_degree if in_degree[node] == 0]) visited_count = 0 while queue: node = queue.popleft() yield node visited_count += 1 for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If number of visited nodes is not equal to the number of nodes in the graph, there is a cycle if visited_count != len(graph): raise ValueError(\\"cycle detected\\")"},{"question":"# Matrix Transformation Coding Challenge You are tasked with implementing several matrix transformation functions, demonstrating your understanding of algorithm design and matrix manipulations. # Problem Statement Implement the following functions: 1. `rotate_clockwise(matrix)`: Rotate the given `n x n` matrix 90 degrees clockwise. 2. `rotate_counterclockwise(matrix)`: Rotate the given `n x n` matrix 90 degrees counterclockwise. 3. `top_left_invert(matrix)`: Invert the top-left to bottom-right axis of the given `n x n` matrix. 4. `bottom_left_invert(matrix)`: Invert the bottom-left to top-right axis of the given `n x n` matrix. # Input and Output Format * Input: A 2D list `matrix` containing `n x n` integers. * Output: A new 2D list `transformed_matrix` containing the transformed elements. **Constraints**: 1. Matrix size can be up to `100 x 100`. 2. Elements can be any integer between `-10^9` and `10^9`. 3. The matrix is guaranteed to be non-empty and well-formed (each row has the same length). # Function Signatures ```python def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: pass def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: pass def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: pass def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: pass ``` # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] assert rotate_clockwise(matrix) == [ [7, 4, 1], [8, 5, 2], [9, 6, 3], ] assert rotate_counterclockwise(matrix) == [ [3, 6, 9], [2, 5, 8], [1, 4, 7], ] assert top_left_invert(matrix) == [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] assert bottom_left_invert(matrix) == [ [9, 6, 3], [8, 5, 2], [7, 4, 1], ] ``` # Additional Requirement - Ensure your implementation is efficient in terms of both time and space complexity. - Handle edge cases such as empty matrices or single-element matrices appropriately.","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the input n x n matrix 90 degrees clockwise. n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the input n x n matrix 90 degrees counterclockwise. n = len(matrix) return [[matrix[j][n - i - 1] for j in range(n)] for i in range(n)] def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: Inverts the input n x n matrix along the top-left to bottom-right diagonal. n = len(matrix) inverted_matrix = [row[:] for row in matrix] for i in range(n): for j in range(i + 1, n): inverted_matrix[i][j], inverted_matrix[j][i] = matrix[j][i], matrix[i][j] return inverted_matrix def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: Inverts the input n x n matrix along the bottom-left to top-right diagonal. n = len(matrix) inverted_matrix = [row[:] for row in matrix] for i in range(n): for j in range(n - i - 1): inverted_matrix[i][j], inverted_matrix[n - j - 1][n - i - 1] = matrix[n - j - 1][n - i - 1], matrix[i][j] return inverted_matrix"},{"question":"# Question: Repeated Substring Pattern Given a non-empty string, determine if it can be constructed by taking a substring of it and appending multiple copies of the substring together. Implement the function `repeat_substring(s)` such that: Input - **s**: A non-empty string of lowercase alphabets (1 <= len(s) <= 10^4). Output - **return**: Boolean value, `True` if the string can be constructed by repeating a substring, `False` otherwise. # Examples ```plaintext repeat_substring(\\"abab\\") -> True // Explanation: It\'s the substring \\"ab\\" twice. repeat_substring(\\"aba\\") -> False // Explanation: It cannot be formed by repeating any substring. repeat_substring(\\"abcabcabcabc\\") -> True // Explanation: It\'s the substring \\"abc\\" four times. ``` # Constraints 1. You may not use built-in functions or libraries that directly solve the problem. 2. Consider performance implications for the upper constraint of string length. 3. Handle edge cases such as single character strings. # Notes - The function should be implemented with a time complexity of O(n) and space complexity of O(n). - Ensure you cover various test cases to validate the correctness of your implementation.","solution":"def repeat_substring(s): Determine if the string can be constructed by repeating a substring. :param s: A non-empty string of lowercase alphabets :return: True if the string can be constructed by repeating a substring, False otherwise # Create a string by combining the string with itself and removing the first and last character n = len(s) new_s = (s + s)[1:-1] # Check if the original string is present in the new string return s in new_s"},{"question":"# Scenario: You are tasked with developing an efficient system to minimize the cost of broadcasting messages to all nodes in a network. Each subset of nodes can be reached by certain transmitters at different costs. Your goal is to determine a cost-effective set of transmitters to cover all nodes in the network. # Problem Statement Implement the function `optimal_set_cover` and `greedy_set_cover`. Function Signature: ```python def optimal_set_cover(universe: set, subsets: dict, costs: dict) -> List[str]: pass def greedy_set_cover(universe: set, subsets: dict, costs: dict) -> List[str]: pass ``` Input: - **universe** (set): Set of all elements (nodes) to be covered. - **subsets** (dict): Dictionary where keys are subset names, and values are sets of elements each subset can cover. - **costs** (dict): Dictionary where keys are subset names and values are the costs associated with those subsets. Output: - **optimal_set_cover**: List of subset names representing the minimum cost cover. - **greedy_set_cover**: List of subset names representing the efficient (though not necessarily minimum cost) cover. # Constraints: - The `universe` will contain between 1 and 20 elements. - The `subsets` will contain between 1 and 20 subsets. - Each subset will contain between 1 and ( |universe| ) elements. - The cost of any subset will be a positive integer between 1 and 100. # Performance Requirements: - Your optimal solution should prioritize accuracy over efficiency due to its exponential time complexity for small inputs. - The greedy solution should aim for a balance between efficiency and a reasonably close-to-optimal cost. # Example: ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} # Sample Output for Optimal Solution optimal_result = optimal_set_cover(universe, subsets, costs) # Should output a minimal cost set cover; one possible output: # optimal_result = [\'S2\', \'S3\'] # Sample Output for Greedy Solution greedy_result = greedy_set_cover(universe, subsets, costs) # Should output a reasonable set cover within feasible time; one possible output: # greedy_result = [\'S3\'] ``` # Additional Note: - Ensure your solution correctly handles cases where subsets do not fully cover the universe. - Assume inputs are valid in terms of the subsets always having potential to cover the universe when combined. Submit your solution as a single Python script implementing both functions.","solution":"from typing import List, Set, Dict def optimal_set_cover(universe: Set[int], subsets: Dict[str, Set[int]], costs: Dict[str, int]) -> List[str]: from itertools import combinations n = len(subsets) best_cost = float(\'inf\') best_cover = [] # We generate all possible combinations of subsets subset_keys = list(subsets.keys()) for r in range(1, n+1): for comb in combinations(subset_keys, r): combined_set = set() total_cost = 0 for subset_name in comb: combined_set |= subsets[subset_name] total_cost += costs[subset_name] if combined_set == universe and total_cost < best_cost: best_cost = total_cost best_cover = list(comb) return best_cover def greedy_set_cover(universe: Set[int], subsets: Dict[str, Set[int]], costs: Dict[str, int]) -> List[str]: selected_subsets = [] covered_elements = set() while covered_elements != universe: best_subset = None best_cost_effectiveness = float(\'inf\') for subset_name, subset in subsets.items(): uncovered_elements = subset - covered_elements if not uncovered_elements: continue cost_effectiveness = costs[subset_name] / len(uncovered_elements) if cost_effectiveness < best_cost_effectiveness: best_cost_effectiveness = cost_effectiveness best_subset = subset_name if best_subset is None: break # Should not happen in valid input as per the problem statement selected_subsets.append(best_subset) covered_elements |= subsets[best_subset] return selected_subsets"},{"question":"# Question: Robotic Return Path You are tasked with determining whether a robot, starting at the origin (0,0), returns to the original point after performing a given sequence of moves. The robot can follow these specific moves: - \'U\' (Up): Move one unit up the y-axis. - \'D\' (Down): Move one unit down the y-axis. - \'L\' (Left): Move one unit left on the x-axis. - \'R\' (Right): Move one unit right on the x-axis. You need to write a function `robot_returns` which takes a single input string `moves`. The function should return `True` if the sequence of moves returns the robot to the origin, and `False` otherwise. Function Signature ```python def robot_returns(moves: str) -> bool: ``` Input * `moves` (1 <= len(moves) <= 10^4): A string containing the sequence of moves consisting of the characters \'U\', \'D\', \'L\', and \'R\' only. Output * Return `True` if the robot returns to the origin, otherwise `False`. Constraints * The input string will only contain \'U\', \'D\', \'L\', and \'R\'. * The input string will have a length between 1 and 10^4. Examples 1. Input: `\\"UD\\"` Output: `True` 2. Input: `\\"LL\\"` Output: `False` 3. Input: `\\"\\"` Output: `True` 4. Input: `\\"UUDDLLRR\\"` Output: `True` Explanation In example 1, the moves \\"UD\\" move the robot up and then down, returning it to the origin. In example 2, the moves \\"LL\\" move the robot left twice, leaving it at (-2,0), so it does not return to the origin. In example 3, no moves are made, so the robot remains at the origin. In example 4, the moves balance out such that the robot returns to the origin. Implementation Constraints Your solution should aim for efficient time complexity due to the potential size of input.","solution":"def robot_returns(moves: str) -> bool: Determine if the robot returns to the origin after the given sequence of moves. x, y = 0, 0 for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0"},{"question":"# Scenario You\'re working on a project that requires you to generate a list of numbers from 1 to N while applying specific substitution rules. You need to ensure that this implementation is efficient and handles errors gracefully. # Coding Challenge Write a function `custom_fizzbuzz(n, fizz=3, buzz=5)` where: - `n` is an integer greater than or equal to 1. - `fizz` is an integer defaulting to 3. - `buzz` is an integer defaulting to 5. The function should return an array containing numbers from 1 to N, but with the following substitutions: - Replace multiples of `fizz` with the string \\"Fizz\\". - Replace multiples of `buzz` with the string \\"Buzz\\". - Replace multiples of both `fizz` and `buzz` with the string \\"FizzBuzz\\". # Input and Output Formats **Input:** - `n`: Integer (≥ 1) - `fizz`: Integer (> 0), optional - `buzz`: Integer (> 0), optional **Output:** - A list of integers and strings following the FizzBuzz rules stated above. # Constraints 1. 1 ≤ n ≤ 10,000 2. fizz, buzz > 0 # Performance Requirements The function should operate within O(n) time complexity and use O(n) space complexity. # Examples ```python custom_fizzbuzz(15) # Output: [1, 2, \\"Fizz\\", 4, \\"Buzz\\", \\"Fizz\\", 7, 8, \\"Fizz\\", \\"Buzz\\", 11, \\"Fizz\\", 13, 14, \\"FizzBuzz\\"] custom_fizzbuzz(15, 4, 6) # Output: [1, 2, 3, \\"Fizz\\", 5, \\"Buzz\\", 7, \\"Fizz\\", 9, 10, 11, \\"FizzBuzz\\", 13, 14, 15] ```","solution":"def custom_fizzbuzz(n, fizz=3, buzz=5): Returns a list from 1 to n following the FizzBuzz rules. - Replace multiples of `fizz` with \\"Fizz\\". - Replace multiples of `buzz` with \\"Buzz\\". - Replace multiples of both `fizz` and `buzz` with \\"FizzBuzz\\". if n < 1: raise ValueError(\\"n must be greater than or equal to 1\\") if fizz <= 0 or buzz <= 0: raise ValueError(\\"fizz and buzz must be greater than 0\\") result = [] for i in range(1, n + 1): if i % fizz == 0 and i % buzz == 0: result.append(\\"FizzBuzz\\") elif i % fizz == 0: result.append(\\"Fizz\\") elif i % buzz == 0: result.append(\\"Buzz\\") else: result.append(i) return result"},{"question":"# Maze Shortest Path Finder **Context:** You are working on a pathfinding module for a maze-solving robot. The robot must find the shortest path from the top-left to the bottom-right corner of a maze. However, it can only step on cells marked with a 1. The robot can move up, down, left, or right. The first column (top-left cell) is not included in the answer if it is part of the path. If no path exists, return -1. # Function Signature ```python def find_path(maze: List[List[int]]) -> int: ``` # Input - **maze** (List[List[int]]): A 2D list representing the maze. The maze[i][j] cell can either be: - `1` representing a walkable cell. - `0` representing a blocked cell. # Output - **Returns** (int): The length of the shortest path from the top-left to the bottom-right, excluding the starting cell. If no path exists, return -1. # Constraints - The maze will always be a n x m grid where 1 <= n, m <= 100. - The starting cell (maze[0][0]) is always 1 and should be included in the path length count. # Example ```python # Example 1 maze1 = [ [1, 0, 1, 1, 1, 1], [1, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1], [1, 1, 1, 0, 1, 1] ] print(find_path(maze1)) # Output: 14 # Example 2 maze2 = [ [1, 0, 0], [0, 1, 1], [0, 1, 1] ] print(find_path(maze2)) # Output: -1 ``` # Requirements - Implement and use a Depth-First Search (DFS) approach or any suitable algorithm to solve the problem. - Ensure the solution efficiently handles edge cases and large inputs within reasonable execution times. - Consider revisiting strategies to avoid unnecessary recomputation. # Notes - You are allowed to modify the provided `dfs` function or create new helper functions as needed.","solution":"from typing import List from collections import deque def find_path(maze: List[List[int]]) -> int: n, m = len(maze), len(maze[0]) if maze[0][0] == 0 or maze[n-1][m-1] == 0: return -1 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, 1)]) visited = [[False] * m for _ in range(n)] visited[0][0] = True while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist - 1 # Exclude the start point for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and maze[nx][ny] == 1: visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return -1"},{"question":"Heap Sort is a well-known algorithm that sorts an array in-place using the properties of the heap data structure. We have two variations: `max_heap_sort` and `min_heap_sort`, which use max-heap and min-heap respectively to achieve ascending order sorting. Task Given the following partial implementations of heap sort, your task is to: 1. Implement the missing parts in the existing functions to complete the heap sort functionality. 2. Add functionality to handle specific edge cases. # Functions to Implement - `max_heap_sort(arr, simulation=False)`: Sorts an array using max-heap. - `max_heapify(arr, end, simulation, iteration)`: Helper function for max heapify operation. - `min_heap_sort(arr, simulation=False)`: Sorts an array using min-heap. - `min_heapify(arr, start, simulation, iteration)`: Helper function for min heapify operation. Input - `arr`: List of integers to be sorted. - `simulation`: Boolean flag to simulate and print each iteration. Output - Returns a sorted array in ascending order. Constraints - You must use the heap sort algorithm. - The solution must be in-place (should not use extra array storage). # Example ```python # Example 1 arr = [4, 10, 3, 5, 1] print(max_heap_sort(arr)) # Output: [1, 3, 4, 5, 10] # Example 2 arr = [4, 10, 3, 5, 1] print(min_heap_sort(arr)) # Output: [1, 3, 4, 5, 10] # Example 3: Edge cases arr = [] print(max_heap_sort(arr)) # Output: [] arr = [1] print(max_heap_sort(arr)) # Output: [1] # Example 4: All elements same arr = [2, 2, 2, 2, 2] print(min_heap_sort(arr)) # Output: [2, 2, 2, 2, 2] ``` # Additional Requirement - Ensure that your implementation correctly handles edge cases such as an empty array, single-element arrays, and arrays with all elements being the same. - Consider implementing additional logging or printing to handle the `simulation` flag for debugging purposes.","solution":"def max_heapify(arr, n, i): Helper function to maintain the max-heap property. largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] max_heapify(arr, n, largest) def max_heap_sort(arr): Sorts an array using max-heap. n = len(arr) for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] max_heapify(arr, i, 0) return arr def min_heapify(arr, n, i): Helper function to maintain the min-heap property. smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] < arr[smallest]: smallest = left if right < n and arr[right] < arr[smallest]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] min_heapify(arr, n, smallest) def min_heap_sort(arr): Sorts an array using min-heap. n = len(arr) for i in range(n // 2 - 1, -1, -1): min_heapify(arr, n, i) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] min_heapify(arr, i, 0) arr.reverse() return arr"},{"question":"# Cycle Detection in a Linked List **Context**: A software engineer is tasked with detecting cycles in a network protocol based on linked lists structures. A common issue in such protocols is the creation of loops which may cause infinite routing paths or data loss. Your task is to implement an algorithm to reliably detect cycles in these linked lists. # Objective Write a function that, given the head of a linked list, determines if there is a cycle in it. # Function Specification ```python def has_cycle(head: Node) -> bool: Determines if the linked list has a cycle. :param head: Node - The head of the linked list. :return: bool - True if cycle exists, False otherwise. ``` # Input - `head` (Node): The head node of the linked list. # Output - `bool`: Returns `True` if there is a cycle in the linked list, otherwise `False`. # Constraints - The function must use (O(1)) extra space. - The number of nodes in the list can be up to (10^6). # Example ```python # Example 1: node1 = Node(3) node2 = Node(2) node3 = Node(0) node4 = Node(-4) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node2 # cycle assert has_cycle(node1) == True # Example 2: node1 = Node(1) node2 = Node(2) node1.next = node2 node2.next = node1 # cycle assert has_cycle(node1) == True # Example 3: node1 = Node(1) assert has_cycle(node1) == False ``` # Explanation 1. In the first example, the linked list [3 -> 2 -> 0 -> -4 -> 2] has a cycle. 2. In the second example, the linked list [1 -> 2 -> 1] has a cycle. 3. In the third example, the linked list [1] does not have a cycle. Implement the function `has_cycle` to perform this task efficiently and correctly. # Hints - Use the two-pointer technique to detect cycles efficiently. - Consider edge cases like an empty list or a single-node list.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def has_cycle(head: Node) -> bool: Determines if the linked list has a cycle. :param head: Node - The head of the linked list. :return: bool - True if cycle exists, False otherwise. if not head: return False slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# Description Cycle Sort is an in-place sorting algorithm, known for its uniqueness in operation by minimizing the number of writes during the sort. Imagine you are given a task to sort a list of integers using the Cycle Sort algorithm. Your task is to implement the Cycle Sort algorithm and output the sorted list. # Requirements Implement a function `cycle_sort(arr)` that sorts an input list `arr` using the Cycle Sort algorithm. # Input Format * An integer list `arr` containing `N` elements, where `1 <= N <= 1000`. # Output Format * A list containing the sorted elements of the original list `arr`. # Constraints * The function should be in-place, meaning it should sort the list without using extra space. * The list can contain negative or positive integers, and duplicates may be present. # Example Example 1 Input: ``` arr = [3, 1, 2, 1, 5] ``` Output: ``` [1, 1, 2, 3, 5] ``` Example 2 Input: ``` arr = [9, 7, 8, 5, 6, 5] ``` Output: ``` [5, 5, 6, 7, 8, 9] ``` # Notes * Pay attention to handling of duplicates. * Comprehensive handling of edge cases such as an already sorted list or a list with all elements being the same is expected.","solution":"def cycle_sort(arr): Perform Cycle Sort on the array. n = len(arr) for cycle_start in range(0, n - 1): item = arr[cycle_start] # Find the position where we put the element. pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Otherwise, put the item to the right position while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"# Insertion Sort Enhancements Using the Insertion Sort algorithm above as a foundation, enhance the algorithm to handle larger datasets more efficiently. Implement a function `enhanced_insertion_sort` that: 1. Uses binary search to find the correct position of the element to be inserted, reducing the number of comparisons. 2. Maintains the stability of the sort. 3. The function should sort the given list of integers in ascending order. **Function Signature:** ```python def enhanced_insertion_sort(arr: List[int]) -> List[int]: pass ``` **Input:** - A list of integers `arr` of length `n` (1 ≤ n ≤ 10^5). **Output:** - A new list of integers sorted in ascending order. **Constraints:** - Use the in-place sorting to manage space efficiently. - Ensure the algorithm remains stable. **Performance Requirements:** The enhanced solution should handle larger datasets more efficiently than the standard Insertion Sort. Example ``` Input: [64, 34, 25, 12, 22, 11, 90] Output: [11, 12, 22, 25, 34, 64, 90] Input: [5, 2, 9, 1, 5, 6] Output: [1, 2, 5, 5, 6, 9] ``` You may define helper functions if needed, such as a function to perform binary search for the insertion position.","solution":"from typing import List def binary_search(arr: List[int], val: int, start: int, end: int) -> int: Perform a binary search to find the insertion position for val in arr[start:end] while start < end: mid = (start + end) // 2 if arr[mid] < val: start = mid + 1 else: end = mid return start def enhanced_insertion_sort(arr: List[int]) -> List[int]: Sorts the array of integers in ascending order using an enhanced insertion sort algorithm that uses binary search to determine the insertion position. n = len(arr) for i in range(1, n): key = arr[i] # Find the insertion position using binary search pos = binary_search(arr, key, 0, i) # Shift elements to make room for the key arr = arr[:pos] + [key] + arr[pos:i] + arr[i+1:] return arr"},{"question":"# Scenario Suppose you are developing a text processing tool that needs to locate specific words or phrases within a large body of text. Efficient substring searching is crucial for this functionality. # Problem Statement Implement a function `find_substring_index(haystack: str, needle: str) -> int` that searches for the first occurrence of the substring `needle` in the string `haystack`. The function should return the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. # Input and Output Format - **Input**: - `haystack`: A non-null string in which you are searching for the substring. - `needle`: A non-null string that you need to find within `haystack`. - **Output**: An integer representing the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not found. # Constraints 1. The length of `haystack` and `needle` can range from 0 to 500,000. 2. Searching should handle all Unicode characters correctly. # Example ```python # Example 1 haystack = \\"hello\\" needle = \\"ll\\" # Output: 2 # Example 2 haystack = \\"aaaaa\\" needle = \\"bba\\" # Output: -1 # Example 3 haystack = \\"\\" needle = \\"a\\" # Output: -1 # Example 4 haystack = \\"testing\\" needle = \\"\\" # Output: 0 ``` Use efficient string handling mechanisms and consider edge cases for optimal performance. # Performance Requirements Ensure performance is optimized to handle the upper constraints effectively. Consider crafting a solution that minimizes unnecessary comparisons and redundant computations. Write the function `find_substring_index` to solve the described problem.","solution":"def find_substring_index(haystack: str, needle: str) -> int: Returns the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. if needle == \\"\\": return 0 return haystack.find(needle)"},{"question":"# Scenario You\'ve been tasked with designing a stepping game on a smartphone where a player must climb a flight of stairs by taking either 1 or 2 steps at a time. To determine the minimum number of ways the player can reach the top, you\'d like to implement a function that calculates all the distinct ways the player can climb to a specified step. The steps number will be a positive integer and it’s a mandatory part of the game to know the efficiency of the solution for better player experience. # Problem Statement Given a positive integer `steps`, write a function `find_ways_to_climb` that returns the number of distinct ways to reach the `steps`-th stair. # Function Signature ```python def find_ways_to_climb(steps: int) -> int: ``` # Input * An integer, `steps (1 ≤ steps ≤ 10^6)`: the total number of steps to the top. # Output * Return an integer representing the number of distinct ways to reach the top. # Constraints * The solution should aim to use the least amount of space possible without sacrificing readability and clarity of the code. * Consider the performance implications for `steps` as large as 10^6. # Examples Example 1 Input: ```python steps = 2 ``` Output: ```python 2 ``` Explanation: There are two ways to climb to the top for 2 steps: 1. 1 step + 1 step 2. 2 steps Example 2 Input: ```python steps = 3 ``` Output: ```python 3 ``` Explanation: There are three ways to climb to the top for 3 steps: 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step Example 3 Input: ```python steps = 4 ``` Output: ```python 5 ``` Explanation: There are five ways to climb to the top for 4 steps: 1. 1 step + 1 step + 1 step + 1 step 2. 1 step + 1 step + 2 steps 3. 1 step + 2 steps + 1 step 4. 2 steps + 1 step + 1 step 5. 2 steps + 2 steps # Notes * Ensure your solution is optimized in terms of both time and space complexity. * Handle larger values of steps efficiently.","solution":"def find_ways_to_climb(steps: int) -> int: Returns the number of distinct ways to climb a given number of steps by taking either 1 or 2 steps at a time. # If the number of steps is 0, 1, 2, the known answers are 1, 1, and 2 respectively. if steps == 1: return 1 elif steps == 2: return 2 # Initialize previous two ways of doing the steps prev1, prev2 = 1, 2 # Compute the number of ways using a loop, for _ in range(3, steps + 1): # Current number of ways is the sum of the ways for the previous two steps curr = prev1 + prev2 # Update previous two values for the next iteration prev1, prev2 = prev2, curr # The answer is in prev2 because it will at the last step of the loop, # contain the number of ways for the given \\"steps\\" return prev2"},{"question":"You need to implement a function that checks whether a given singly linked list is sorted in ascending order. The list is considered sorted if each node’s value is less than or equal to the value of the following node. If the list is empty, it is considered sorted. # Function Signature ```python def is_sorted(head) -> bool: ``` # Input Format - `head`: A reference to the head node of a singly linked list. Each node in the linked list has two attributes: - `val`: An integer value. - `next`: A reference to the next node in the linked list or `None` if it is the last node. # Output Format - Return `True` if the list is sorted in ascending order, otherwise return `False`. # Constraints - The list has at most 10^5 nodes. - Each node\'s value is an integer. # Examples **Example 1:** ``` Input: head = 1 -> 2 -> 3 -> 4 Output: True ``` **Example 2:** ``` Input: head = 1 -> 2 -> -1 -> 3 Output: False ``` **Example 3:** ``` Input: head = None Output: True ``` **Example 4:** ``` Input: head = 5 -> 5 -> 6 Output: True ``` # Explanation 1. In the first example, each node\'s value is less than the next node’s value. 2. In the second example, the list has 2 followed by -1, which violates the ascending order condition. 3. In the third example, an empty list is considered sorted by definition. 4. In the fourth example, duplicate values are allowed as long as they do not violate the non-decreasing order. # Additional Information - This algorithm should run efficiently with a time complexity of O(n) and space complexity of O(1).","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head) -> bool: Checks if a singly linked list is sorted in ascending order. Parameters: head (ListNode): The head node of the singly linked list. Returns: bool: True if the list is sorted in ascending order, False otherwise. # An empty list or a single node list is considered sorted if not head or not head.next: return True current = head while current.next: if current.val > current.next.val: return False current = current.next return True"},{"question":"**Question**: Implement an optimized version of the bubble sort algorithm that minimizes the number of comparisons in each pass by identifying if the list is already sorted and stops when no swaps are made in a pass. Additionally, modify the implementation to sort the list in descending order when a flag is provided. # Requirements * Your function should be named `optimized_bubble_sort`. * It should accept two arguments: - `arr` (a list of integers). - `descending` (a boolean flag, default is `False`). * If `descending` is `True`, the list should be sorted in descending order; otherwise, it should be sorted in ascending order. * Return the sorted list. # Constraints * The algorithm should handle lists of varying lengths, including edge cases such as empty lists and lists with one element. * Ensure the algorithm operates within the time and space complexities discussed. # Input/Output Formats ```plaintext Input Standard: optimized_bubble_sort(arr, descending) Example: optimized_bubble_sort([5, 1, 4, 2, 8], False) Output: [1, 2, 4, 5, 8] optimized_bubble_sort([5, 1, 4, 2, 8], True) Output: [8, 5, 4, 2, 1] ``` **Considerations**: * Consider both typical and edge cases in your implementation and testing. * Think about performance and aim to minimize unnecessary comparisons and swaps. * Provide clear and concise inline comments to explain your logic.","solution":"def optimized_bubble_sort(arr, descending=False): Optimized Bubble Sort algorithm that sorts a list in either ascending or descending order. Parameters: arr (list): The list to be sorted. descending (bool): If True, sort the list in descending order; otherwise, sort in ascending order. Returns: list: The sorted list. n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if (descending and arr[j] < arr[j+1]) or (not descending and arr[j] > arr[j+1]): arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if not swapped: break return arr"},{"question":"# Question You are given a list of URLs as strings. Your task is to write a function `extract_domains` that extracts the primary domain name from each URL and returns these domain names in a list. Function Signature ```python def extract_domains(urls: List[str]) -> List[str]: ``` Input * `urls`: A list of strings, where each string is a valid URL. Output * Returns a list of domain names as strings. Constraints * Do not use libraries such as `re` (regular expressions) or `urlparse`. You are allowed to use the `.split()` method. * The string may or may not contain \\"http://\\", \\"https://\\", or \\"www.\\". Examples ```python assert extract_domains([\\"http://github.com/SaadBenn\\"]) == [\\"github\\"] assert extract_domains([\\"http://www.zombie-bites.com\\", \\"https://www.cnet.com\\"]) == [\\"zombie-bites\\", \\"cnet\\"] assert extract_domains([\\"ftp://www.example.com\\", \\"https://test.co.uk\\", \\"www.sub.domain.com\\"]) == [\\"example\\", \\"test\\", \\"sub\\"] ``` Ensure that your solution considers various URL formats, including those without \\"www\\" and those with different schemes (e.g., \\"https\\", \\"ftp\\").","solution":"from typing import List def extract_domains(urls: List[str]) -> List[str]: def get_domain(url): url = url.replace(\\"http://\\", \\"\\").replace(\\"https://\\", \\"\\").replace(\\"ftp://\\", \\"\\").replace(\\"www.\\", \\"\\") return url.split(\'/\')[0].split(\'.\')[0] return [get_domain(url) for url in urls]"},{"question":"# Question: Design a Multi-Functional Stack Context: You are developing a text editor that supports both undo and redo operations. You need two stacks—one for storing undo operations and one for storing redo operations. To efficiently manage these operations, you will design a stack that supports an additional method, `duplicate_top`, which pushes a copy of the top element to the stack. This is useful in undo operations where an undone action might need to be redone immediately. Task: Implement the class `MultiFunctionalStack` which extends from either `ArrayStack` or `LinkedListStack`. This stack should include the following methods: - `push(self, value)`: Adds an item to the stack. - `pop(self)`: Removes and returns the most recent item from the stack. - `peek(self)`: Returns the most recent item without removing it. - `duplicate_top(self)`: Duplicates the top item and pushes it onto the stack. - `is_empty(self)`: Returns `True` if the stack is empty, otherwise `False`. Method Signatures: ```python class MultiFunctionalStack(ArrayStack or LinkedListStack): def push(self, value): pass def pop(self): pass def peek(self): pass def duplicate_top(self): pass def is_empty(self): pass ``` # Input and Output Format: * The provided methods have their respective input and output formats as per traditional stack operations: - `push(value)`: Adds `value` to the stack. - `pop()`: Removes and returns the top value from the stack. - `peek()`: Returns but does not remove the top value from the stack. - `duplicate_top()`: Duplicates the top value and pushes it onto the stack. - `is_empty()`: Returns `True` if the stack is empty, otherwise `False`. # Constraints: 1. Assume stack elements are of any hashable type. 2. `duplicate_top` should raise an error if attempted on an empty stack. 3. You can choose to inherit from either `ArrayStack` or `LinkedListStack`. # Performance Requirements: - The implementation of `MultiFunctionalStack` should maintain the time complexity of `O(1)` for `push`, `pop`, `peek`, and `duplicate_top`. - Proper handling and raising of errors for operations on an empty stack.","solution":"class MultiFunctionalStack: def __init__(self): self.stack = [] def push(self, value): Adds an item to the stack. self.stack.append(value) def pop(self): Removes and returns the most recent item from the stack. if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def peek(self): Returns the most recent item without removing it. if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def duplicate_top(self): Duplicates the top item and pushes it onto the stack. if self.is_empty(): raise IndexError(\\"duplicate from empty stack\\") self.stack.append(self.stack[-1]) def is_empty(self): Returns True if the stack is empty, otherwise False. return len(self.stack) == 0"},{"question":"# Binary Search Tree Traversal and Sum **Scenario**: You are provided with a Binary Search Tree (BST) and need to perform certain operations involving tree traversal and sum calculation. Implement these operations in a well-optimized manner to ensure efficiency even for larger trees. **Task**: You need to implement the function `sumBSTValuesInRange()` that computes the sum of all node values within a given range ([L, R]) inclusively. Input: * An instance of `TreeNode` representing the root of the BST. * Two integers (L) and (R) defining the range ([L, R]). Output: * An integer representing the sum of values of all nodes within the range ([L, R]). Function Signature: ```python def sumBSTValuesInRange(root: TreeNode, L: int, R: int) -> int: pass ``` Constraints: * All node values in the BST are unique integers. * (1 leq text{Number of nodes} leq 10^4). * (-10^5 leq text{Node value} leq 10^5). * (-10^5 leq L leq R leq 10^5). Example: ```python # Define the BST root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(3) root.left.right = TreeNode(7) root.right.right = TreeNode(18) # Range [7, 15] assert sumBSTValuesInRange(root, 7, 15) == 32 ``` Explanation: * Nodes with values 7, 10, and 15 fall within the range ([7, 15]), and their sum is (32).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumBSTValuesInRange(root: TreeNode, L: int, R: int) -> int: def dfs(node): if not node: return 0 if node.val < L: return dfs(node.right) elif node.val > R: return dfs(node.left) else: return node.val + dfs(node.left) + dfs(node.right) return dfs(root)"},{"question":"You are given a square matrix (a list of lists) representing a 2D grid of integer elements. Implement four different functions to manipulate this matrix with the following operations: 1. Rotate the matrix 90 degrees clockwise. 2. Rotate the matrix 90 degrees counterclockwise. 3. Invert the matrix relative to the top-left-to-bottom-right diagonal. 4. Invert the matrix relative to the bottom-left-to-top-right diagonal. # Function Signature ```python def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: # Your code here def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: # Your code here def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: # Your code here def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: # Your code here ``` # Input - `matrix` (List[List[int]]): A square matrix of integers with dimensions n x n (1 ≤ n ≤ 1000). # Output - Returns a new matrix after performing the respective transformations. # Constraints * The input matrix is guaranteed to be a square matrix. * Handle the edge case of an empty matrix (n=0). # Example Input ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` Outputs ```python rotate_clockwise(matrix) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] rotate_counterclockwise(matrix) # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] top_left_invert(matrix) # Output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] bottom_left_invert(matrix) # Output: # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1] # ] ``` # Note * Ensure to handle cases where the matrix dimensions are 0 (empty matrices). * Aim for O(n^2) time complexity for each function to handle the maximum input size efficiently.","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotate the given square matrix 90 degrees clockwise. :param matrix: List of lists representing the square matrix. :return: Rotated matrix. n = len(matrix) if n == 0: return [] return [[matrix[n-j-1][i] for j in range(n)] for i in range(n)] def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: Rotate the given square matrix 90 degrees counterclockwise. :param matrix: List of lists representing the square matrix. :return: Rotated matrix. n = len(matrix) if n == 0: return [] return [[matrix[j][n-i-1] for j in range(n)] for i in range(n)] def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: Invert the given square matrix relative to the top-left-to-bottom-right diagonal. :param matrix: List of lists representing the square matrix. :return: Inverted matrix. n = len(matrix) if n == 0: return [] return [[matrix[j][i] for j in range(n)] for i in range(n)] def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: Invert the given square matrix relative to the bottom-left-to-top-right diagonal. :param matrix: List of lists representing the square matrix. :return: Inverted matrix. n = len(matrix) if n == 0: return [] return [[matrix[n-j-1][n-i-1] for j in range(n)] for i in range(n)]"},{"question":"Problem Statement You are given a list of sorted characters `letters` containing only lowercase letters and a target letter `target`. Write a function to find the smallest element in the list that is larger than the given target. Letters wrap around, meaning that if the target is \'z\' and letters contain [\'a\', \'b\'], the answer should be \'a\'. Your task is to implement the function using **binary search** to achieve logarithmic time complexity. Function Signature ```python def find_next_greatest_letter(letters: List[str], target: str) -> str: # your implementation here ``` Input * `letters`: A list of sorted characters containing only lowercase letters. * `target`: A single character. Output * Return the smallest character in the list that is larger than the given target. Example ```python # Example 1 letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"a\\" assert find_next_greatest_letter(letters, target) == \\"c\\" # Example 2 letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"c\\" assert find_next_greatest_letter(letters, target) == \\"f\\" # Example 3 letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"d\\" assert find_next_greatest_letter(letters, target) == \\"f\\" ``` Constraints * The list `letters` is sorted in non-decreasing order. * Letters wrap around. * Your solution should aim to have a time complexity of O(log N). Additional Information * Ensure your solution handles edge cases where the target is smaller than the smallest letter or larger than the largest letter in the list.","solution":"from typing import List def find_next_greatest_letter(letters: List[str], target: str) -> str: low, high = 0, len(letters)-1 while low <= high: mid = (low + high) // 2 if letters[mid] <= target: low = mid + 1 else: high = mid - 1 # If low exceeds the length of array, wrap around to letters[0] return letters[low % len(letters)]"},{"question":"You are tasked with developing a function that determines the minimum number of delete operations required to make two given strings identical. The function should utilize dynamic programming principles to find an optimal solution efficiently. # Requirements - **Input**: Two strings `word1` and `word2`. - **Output**: An integer representing the minimum number of delete operations required. # Constraints - The lengths of the input strings, `word1` and `word2`, can be up to 1000 characters each. - Both strings consist of lowercase English letters only. # Performance - Your solution must run within a time complexity of O(N*M), where N and M are the lengths of `word1` and `word2` respectively. - The space complexity should be O(N*M). However, consider possible space optimizations. # Example - **Input**: `word1 = \\"sea\\"`, `word2 = \\"eat\\"` - **Output**: `2` - **Explanation**: - You need one operation to delete \'s\' from \\"sea\\" to make it \\"ea\\". - Then, another operation to delete \'t\' from \\"eat\\" to make it \\"ea\\". # Instructions 1. Implement a function `min_delete_operations(word1, word2)` that takes in two strings and returns an integer. 2. Use dynamic programming to solve the problem effectively. 3. Optimize the solution for both time and space complexity where possible.","solution":"def min_delete_operations(word1, word2): Returns the minimum number of delete operations required to make two given strings identical. # Initialize lengths of the two strings len1, len2 = len(word1), len(word2) # Create a 2D DP array dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] # Build the DP table for i in range(1, len1 + 1): for j in range(1, len2 + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The length of the longest common subsequence lcs_length = dp[len1][len2] # Minimum deletions needed min_deletions = (len1 - lcs_length) + (len2 - lcs_length) return min_deletions"},{"question":"# Shell Sort Implementation Task Shell Sort is a significant step above insertion sort and bubble sort, particularly for medium-sized datasets. Given its relative complexity and the effect of gap sequences on performance, implementing and optimizing Shell Sort can be a valuable exercise in understanding sorting algorithms. Task Description Write a function called `optimized_shell_sort` that sorts a list of integers using the Shell Sort algorithm. Your implementation should leverage Sedgewick\'s gap sequence for better performance. Input * A list of integers, `arr` with `1 <= len(arr) <= 10^5`. Output * A list of integers sorted in ascending order. Constraints * The function must ensure that the list is sorted in-place. * Your solution must handle very large lists, so optimize both time and space complexity. Example ```python def optimized_shell_sort(arr): pass # Sample Input arr = [5, 3, 8, 4, 2, 7, 1, 10] # Sample Output [1, 2, 3, 4, 5, 7, 8, 10] assert optimized_shell_sort([5, 3, 8, 4, 2, 7, 1, 10]) == [1, 2, 3, 4, 5, 7, 8, 10] assert optimized_shell_sort([4, 2, 8, 0]) == [0, 2, 4, 8] assert optimized_shell_sort([1]) == [1] ``` **Note**: It\'s crucial that you use Sedgewick\'s sequence and ensure the list is modified in-place. Consider all edge cases, such as empty lists or lists with repeated elements.","solution":"def optimized_shell_sort(arr): Sorts the input list using the Shell Sort algorithm with Sedgewick\'s gap sequence. n = len(arr) # Generate Sedgewick\'s gap sequence gaps = [] k = 0 while True: gap = 9 * (4**k - 2**k) + 1 if k % 2 == 0 else 8 * 2**k - 6 * 2**((k + 1) // 2) + 1 if gap > n: break gaps.append(gap) k += 1 gaps.reverse() # Sorting in descending order needed for shell sort for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"Doubly Linked List Operations **Context**: You are developing a text editor that supports undo and redo functionalities. To efficiently manage these operations, you need a Doubly Linked List that supports bidirectional traversal. You are tasked with implementing a `DoublyLinkedList` class along with the required methods to support insertion, deletion, and traversal operations. **Task**: Implement a `DoublyLinkedList` class with the following methods: 1. `append(value: int) -> None`: Adds a new node with the given value to the end of the list. 2. `prepend(value: int) -> None`: Adds a new node with the given value to the start of the list. 3. `delete(value: int) -> bool`: Deletes the first node with the given value from the list. Returns `True` if the node was found and deleted, `False` otherwise. 4. `reverse() -> None`: Reverses the list in place. 5. `to_list() -> list`: Returns a list of the current elements in the linked list from head to tail. **Input/Output Formats**: - `append(value: int) -> None` - Input: An integer `value` - Output: None - `prepend(value: int) -> None` - Input: An integer `value` - Output: None - `delete(value: int) -> bool` - Input: An integer `value` - Output: A boolean value `True` if deletion was successful, `False` otherwise - `reverse() -> None` - Input: None - Output: None - `to_list() -> list` - Input: None - Output: A list of integers representing the current elements in the linked list **Constraints**: - The list should handle empty states gracefully. - The list should support integer values for node data. **Example**: ```python dll = DoublyLinkedList() dll.append(1) dll.append(2) dll.append(3) dll.prepend(0) print(dll.to_list()) # Output: [0, 1, 2, 3] dll.delete(2) print(dll.to_list()) # Output: [0, 1, 3] dll.reverse() print(dll.to_list()) # Output: [3, 1, 0] ``` Implement the `DoublyLinkedList` class based on the requirements above.","solution":"class Node: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, value: int) -> None: new_node = Node(value) if self.tail is None: self.head = self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def prepend(self, value: int) -> None: new_node = Node(value) if self.head is None: self.head = self.tail = new_node else: self.head.prev = new_node new_node.next = self.head self.head = new_node def delete(self, value: int) -> bool: current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev return True current = current.next return False def reverse(self) -> None: current = self.head self.tail = current prev = None while current: next_node = current.next current.next = prev current.prev = next_node prev = current current = next_node self.head = prev def to_list(self) -> list: result = [] current = self.head while current: result.append(current.value) current = current.next return result"},{"question":"Context You are part of a team developing a search feature for a large dataset of sorted numerical values. Efficient and fast retrievals are critical due to the high volume of queries. Implementing a binary search to find the first occurrence of a given number will optimize performance. Task Write a function `first_occurrence(array, query)` that takes a sorted list of integers, `array`, and an integer `query`, and returns the index of the first occurrence of `query` in `array`. If the query number is not found, the function should return `-1`. Input * Ordered list of integers `array` where array[i] <= array[i + 1]. * Integer `query` to be searched in the array. Output * Integer representing the index of the first occurrence of `query` in `array`, or `-1` if the query is not found. Constraints * The array can be empty. * The array contains at most (10^6) elements. * The values in the array and the `query` can be in the range ([-10^9, 10^9]). Example ```python # Example 1: array = [1, 2, 2, 3, 4, 5] query = 2 # Output: 1 (First occurrence of 2 is at the index 1) # Example 2: array = [1, 2, 3, 4, 5, 6, 7, 8, 9] query = 5 # Output: 4 (First occurrence of 5 is at the index 4) # Example 3: array = [1, 2, 2, 3, 4, 5] query = 6 # Output: -1 (Query 6 does not exist in the array) ``` Implementation Template You may use the following template to get started: ```python def first_occurrence(array, query): low, high = 0, len(array) - 1 while low <= high: mid = low + (high - low) // 2 if array[mid] < query: low = mid + 1 else: high = mid - 1 if low < len(array) and array[low] == query: return low return -1 ``` Ensure your implementation handles edge cases and performs efficiently under the given constraints.","solution":"def first_occurrence(array, query): low, high = 0, len(array) - 1 result = -1 while low <= high: mid = low + (high - low) // 2 if array[mid] == query: result = mid high = mid - 1 # look on the left side for the first occurrence elif array[mid] < query: low = mid + 1 else: high = mid - 1 return result"},{"question":"You are given a sequence of unique integers from 0 to n with one integer missing. Your task is to write a function that finds and returns the missing integer from the sequence. If no integer is missing, return the next integer in the sequence. Implement both the XOR based method and the sum-based method. Function Signature ```python def find_missing_number(nums: List[int]) -> int: def find_missing_number2(nums: List[int]) -> int: ``` Input * `nums` (List[int]): A list of unique integers in the range [0, n] with one integer missing. Output * (int): The missing integer, or the next integer in the sequence if none are missing. Examples ```python assert find_missing_number([4, 1, 3, 0, 6, 5, 2]) == 7 assert find_missing_number2([4, 1, 3, 0, 6, 5, 2]) == 7 assert find_missing_number([0, 1, 3]) == 2 assert find_missing_number2([0, 1, 3]) == 2 assert find_missing_number([0, 1, 2, 3]) == 4 assert find_missing_number2([0, 1, 2, 3]) == 4 ``` Constraints * You may assume that the input list `nums` will have at least one element and will contain unique integers only. * The integers in the list will be in the range `[0, n]` where `n` is the length of the list. * Your implementations should handle large lists efficiently with time complexity of O(n) and space complexity of O(1). Performance Requirements * Ensure that your program runs efficiently on large lists (up to 10^6 elements).","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Find the missing number using the XOR-based method. n = len(nums) total_xor = 0 array_xor = 0 for i in range(n + 1): total_xor ^= i for num in nums: array_xor ^= num return total_xor ^ array_xor def find_missing_number2(nums: List[int]) -> int: Find the missing number using the sum-based method. n = len(nums) total_sum = n * (n + 1) // 2 array_sum = sum(nums) return total_sum - array_sum"},{"question":"# Decoding Run-Length Encoded Strings You are tasked with writing a function to decode strings that use a run-length encoding format. The encoding rule for strings is k[encoded_string], where the encoded_string inside the square brackets is repeated exactly k times. The input string is always valid with no extra white spaces, and the brackets are well-formed. Function Signature ```python def decode_string(s: str) -> str: ``` Input - `s`: A string containing run-length encoded format (1 ≤ |s| ≤ 30). Output - Returns the decoded string. Assumptions: 1. `k` is always a positive integer. 2. The original data does not contain any digits other than those used for encoding. 3. Valid input - no spaces, proper bracket matching. Constraints: 1. **Time Complexity**: Your solution should run in O(n) time where n is the length of the string. 2. **Space Complexity**: Your solution should use O(n) space. Examples 1. Given `s = \\"3[a]2[bc]\\"`, return \\"aaabcbc\\". 2. Given `s = \\"3[a2[c]]\\"`, return \\"accaccacc\\". 3. Given `s = \\"2[abc]3[cd]ef\\"`, return \\"abcabccdcdcdef\\". Implementation Details Implement the function using a stack-based approach to manage the decoding process. Ensure your solution handles nested encodings and is efficient within the provided constraints. Consider edge cases such as the minimal and maximal length input strings.","solution":"def decode_string(s: str) -> str: stack = [] current_num = 0 current_string = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \\"\\" current_num = 0 elif char == \']\': last_string, num = stack.pop() current_string = last_string + num * current_string else: current_string += char return current_string"},{"question":"# Merge Sort and Array Shuffling Context You\'re creating a large dataset of records that need to be sorted and later analyzed. The dataset is generated randomly, sorted for specific analyses, and shuffled again for testing purposes. Task Write two functions: 1. **merge_sort(arr)** 2. **shuffle_array(arr)** The first function, `merge_sort`, should implement the Merge Sort algorithm to sort an array in ascending order. The second function, `shuffle_array`, should randomly shuffle the elements of the array. Detailed Requirements # merge_sort(arr) - **Input**: A list of integers `arr` of size `n` (1 <= n <= 10^5). - **Output**: A sorted list of integers in ascending order. - **Constraints**: * Ensure the algorithm runs within O(n log n) time complexity. * Avoid using any additional Python libraries with built-in sort functions. * Implement in-place sorting to optimize for space. * Handle edge cases such as empty arrays, arrays with one element, and arrays with all identical elements. # shuffle_array(arr) - **Input**: A list of integers `arr` of size `n` (1 <= n <= 10^5). - **Output**: The same list of integers, but shuffled in a random order. - **Constraints**: * Ensure each permutation of the array is equally likely. * Implement an in-place shuffle to optimize for space. # Execution Requirements - The `merge_sort` function should sort large arrays efficiently and handle edge cases gracefully. - The `shuffle_array` function should randomize the elements uniformly and in-place. - Expected average execution time for both functions combined should be under a few seconds for the upper limit of `n`. ```python # Implement the merge_sort function here def merge_sort(arr): if len(arr) <= 1: return arr mid = len(arr) // 2 left, right = merge_sort(arr[:mid]), merge_sort(arr[mid:]) merge(left, right, arr) return arr def merge(left, right, merged): left_cursor, right_cursor = 0, 0 while left_cursor < len(left) and right_cursor < len(right): if left[left_cursor] <= right[right_cursor]: merged[left_cursor + right_cursor] = left[left_cursor] left_cursor += 1 else: merged[left_cursor + right_cursor] = right[right_cursor] right_cursor += 1 for left_cursor in range(left_cursor, len(left)): merged[left_cursor + right_cursor] = left[left_cursor] for right_cursor in range(right_cursor, len(right)): merged[left_cursor + right_cursor] = right[right_cursor] # Implement the shuffle_array function here import random def shuffle_array(arr): n = len(arr) for i in range(n - 1, 0, -1): j = random.randint(0, i) arr[i], arr[j] = arr[j], arr[i] ``` Testing Test your functions with various cases including: - Arrays of varying sizes (including edge cases). - Arrays with duplicate values. - Already sorted arrays and reverse sorted arrays. - Assess the randomness of the shuffled array.","solution":"def merge_sort(arr): if len(arr) <= 1: return arr mid = len(arr) // 2 left, right = merge_sort(arr[:mid]), merge_sort(arr[mid:]) merge(left, right, arr) return arr def merge(left, right, merged): left_cursor, right_cursor = 0, 0 while left_cursor < len(left) and right_cursor < len(right): if left[left_cursor] <= right[right_cursor]: merged[left_cursor + right_cursor] = left[left_cursor] left_cursor += 1 else: merged[left_cursor + right_cursor] = right[right_cursor] right_cursor += 1 for left_cursor in range(left_cursor, len(left)): merged[left_cursor + right_cursor] = left[left_cursor] for right_cursor in range(right_cursor, len(right)): merged[left_cursor + right_cursor] = right[right_cursor] import random def shuffle_array(arr): n = len(arr) for i in range(n - 1, 0, -1): j = random.randint(0, i) arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Question: Filter Events by Timestamp You are developing a data processing module for a surveillance camera system. This module receives a list of events, each represented by a timestamp (an integer). Your task is to filter these events based on given minimum and maximum timestamp values to focus on events of interest. Write a function `filter_events(events: List[int], min_time: Optional[int] = None, max_time: Optional[int] = None) -> List[int]` that filters `events` based on the given time range. If `min_time` is not provided, it means that there\'s no lower bound on the timestamps. Similarly, if `max_time` is not provided, it means there\'s no upper bound. # Input - `events` (List[int]): A list of integers representing event timestamps. - `min_time` (Optional[int]): The minimum time limit (inclusive). Defaults to `None`. - `max_time` (Optional[int]): The maximum time limit (inclusive). Defaults to `None`. # Output - List[int]: A list of timestamps that fall within the specified time range. # Constraints - The number of timestamps ( n ) will be ( 0 leq n leq 10^6 ). - The timestamps will be integers within the range of valid 32-bit integer values. - The function should run efficiently with a time complexity of ( O(n) ). # Example Usage ```python # Example 1 events = [10, 15, 20, 25, 30, 35] min_time = 15 max_time = 30 assert filter_events(events, min_time, max_time) == [15, 20, 25, 30] # Example 2 events = [100, 200, 300, 400, 500] min_time = 150 max_time = None assert filter_events(events, min_time) == [200, 300, 400, 500] # Example 3 events = [] min_time = 10 max_time = 100 assert filter_events(events, min_time, max_time) == [] # Example 4 events = [1, 2, 3, 4, 5] min_time = None max_time = 3 assert filter_events(events, max_time=max_time) == [1, 2, 3] ``` # Notes - If both `min_time` and `max_time` are `None`, return the original list since all timestamps are considered valid.","solution":"from typing import List, Optional def filter_events(events: List[int], min_time: Optional[int] = None, max_time: Optional[int] = None) -> List[int]: Filters the events based on the given minimum and maximum time limits. :param events: List of event timestamps. :param min_time: The minimum timestamp to include (inclusive). :param max_time: The maximum timestamp to include (inclusive). :return: List of filtered event timestamps. filtered_events = [] for event in events: if (min_time is None or event >= min_time) and (max_time is None or event <= max_time): filtered_events.append(event) return filtered_events"},{"question":"Move Zeros to the End You are given an array of elements, which may include integers, strings, booleans, etc. Write a function `move_zeros(Array: List[Any]) -> List[Any]` that moves all the zeroes to the end of the array while preserving the order of the other elements. # Input: * An array of elements (`Array`), where `Array` can contain any data type. # Output: * A new array where all zeroes are moved to the end, and the order of non-zero elements is preserved. # Constraints: * The array length will be in the range [0, 10^6]. * The array can contain characters, booleans, and numbers. # Performance Requirement: * The algorithm should have a time complexity of O(n). # Examples: 1. Input: `[False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"]` Output: `[False, 1, 1, 2, 1, 3, \\"a\\", 0, 0]` 2. Input: `[0, \\"zero\\", 0, 3, 9, 0]` Output: `[\\"zero\\", 3, 9, 0, 0, 0]` 3. Input: `[0, 0, 0, 0]` Output: `[0, 0, 0, 0]` 4. Input: `[1, 2, 3, 4, 5]` Output: `[1, 2, 3, 4, 5]` # Implementation Hint: Make sure to avoid treating boolean `False` as zero. Booleans should not be moved with the zeroes in the final result. # Edge Cases to Consider: * Arrays with no zeroes should remain unchanged. * Arrays with only zeroes should remain the same size but filled with zeroes. * Arrays with boolean `False` should retain their order and not be treated as zeros.","solution":"from typing import List, Any def move_zeros(Array: List[Any]) -> List[Any]: Moves all the occurrences of zero to the end of the array while preserving the order of other elements. # First, collect all non-zero elements non_zeros = [item for item in Array if item != 0 or type(item) == bool] # Calculate the number of zeros to append zero_count = len(Array) - len(non_zeros) # Append zeros to the list of non-zero elements result = non_zeros + [0] * zero_count return result"},{"question":"# Problem: Maximum Flow with Intermediate Constraints You are provided with a flow network represented by a capacity matrix. Compute the maximum flow from a given source to a sink using the algorithms discussed. Additionally, incorporate an intermediate constraint where a certain node must be visited exactly once within the flow from the source to sink. Function Signature ```python def constrained_max_flow(capacity: List[List[int]], source: int, sink: int, intermediate: int) -> int: pass ``` Input * `capacity`: A 2D list (matrix) of integers where `capacity[i][j]` represents the capacity of the directed edge from node `i` to node `j`. If there is no edge, `capacity[i][j]` is zero. * `source`: An integer representing the source node. * `sink`: An integer representing the sink node. * `intermediate`: An integer representing the node that must be visited exactly once in any feasible flow path. Output * The function should return an integer representing the maximum flow from `source` to `sink` in the network while visiting `intermediate` exactly once. Example ```python capacity = [ [0, 10, 10, 0], [0, 0, 1, 10], [0, 0, 0, 10], [0, 0, 0, 0] ] source = 0 sink = 3 intermediate = 2 print(constrained_max_flow(capacity, source, sink, intermediate)) # Output: 10 ``` Constraints * All capacities in the matrix are non-negative integers. * The graph has at most 1000 vertices. Requirements * Implement the function `constrained_max_flow` using Dinic\'s algorithm for optimal performance. * Make sure to handle edge cases such as no path through the intermediate node. * Ensure your solution optimally respects the constraints and performs within acceptable limits for large graphs.","solution":"from collections import deque def bfs(capacity, source, sink, parent): visited = [False] * len(capacity) queue = deque([source]) visited[source] = True while queue: current = queue.popleft() for next in range(len(capacity)): if not visited[next] and capacity[current][next] > 0: queue.append(next) visited[next] = True parent[next] = current if next == sink: return True return False def edmonds_karp(capacity, source, sink): parent = [-1] * len(capacity) max_flow = 0 while bfs(capacity, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, capacity[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] capacity[u][v] -= path_flow capacity[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow def constrained_max_flow(capacity, source, sink, intermediate): if source == intermediate or sink == intermediate: return 0 n = len(capacity) first_leg_capacity = [row[:] for row in capacity] max_flow_1 = edmonds_karp(first_leg_capacity, source, intermediate) second_leg_capacity = [row[:] for row in capacity] max_flow_2 = edmonds_karp(second_leg_capacity, intermediate, sink) return min(max_flow_1, max_flow_2)"},{"question":"You need to implement a function that converts a sorted array into a height-balanced Binary Search Tree (BST). The primary goal is to ensure the tree remains balanced to optimize the efficiency of subsequent operations. # Function Signature ```python def sorted_array_to_bst(arr: List[int]) -> Optional[TreeNode]: Converts a sorted array into a height-balanced BST. Parameters: arr (List[int]): A list of integers sorted in ascending order. Returns: TreeNode: The root node of the height-balanced BST. ``` # Input * `arr` - a list of integers sorted in ascending order, with a length of `n` (0 <= n <= 10^4). # Output * The root node of the height-balanced BST constructed from the input array. # Constraints * The length of the array will be in the range [0, 10^4]. * All values in the array are unique. # Example Example 1: * Input: arr = [-10, -3, 0, 5, 9] * Output: A height-balanced BST where: ``` 0 / -10 5 -3 9 ``` Example 2: * Input: arr = [1, 3] * Output: A height-balanced BST where: ``` 3 / 1 ``` # Notes Ensure that the BST constructed is height-balanced and adheres to the properties of the Binary Search Tree.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(arr: List[int]) -> Optional[TreeNode]: if not arr: return None def convert_to_bst(left, right): if left > right: return None mid = (left + right) // 2 root = TreeNode(arr[mid]) root.left = convert_to_bst(left, mid - 1) root.right = convert_to_bst(mid + 1, right) return root return convert_to_bst(0, len(arr) - 1)"},{"question":"# Question: You are working as a financial consultant for a high-profile client who is planning to invest in real estate along a street where each property returns a certain amount of rent each month. However, due to certain regulations, your client cannot invest in adjacent properties. Write a function `maximum_rent` that will receive a list of non-negative integers representing the rental value of each property along the street. Your function should determine the maximum amount of rent that your client can collect without violating the regulations of investing in adjacent properties. Function Signature: ```python def maximum_rent(rent_values: List[int]) -> int: pass ``` Input: * `rent_values` (List[int]): List of non-negative integers representing monthly rental values of properties. Output: * Return an integer, the maximum amount of rent that can be collected without investing in adjacent properties. Constraints: * You may assume that the total number of properties does not exceed 10^4. * Each rental value is a non-negative integer ranging from 0 to 10^5. Example: ```python # Example 1 rent_values = [2, 7, 9, 3, 1] print(maximum_rent(rent_values)) # Output: 12 # Example 2 rent_values = [10, 1, 2, 6, 3, 8] print(maximum_rent(rent_values)) # Output: 24 ``` Explanation: - For the first example, the maximum amount of rent is achieved by renting the 1st, 3rd, and 5th properties (2 + 9 + 1 = 12). - For the second example, the optimal strategy would be renting the 1st and 4th properties (10 + 6 + 8 = 24), ignoring the adjacent properties. Note: Your solution should be efficient to handle large input sizes within the constraints provided.","solution":"from typing import List def maximum_rent(rent_values: List[int]) -> int: Determine the maximum amount of rent that can be collected without investing in adjacent properties. if not rent_values: return 0 n = len(rent_values) if n == 1: return rent_values[0] # Initialize the maximum rent values for the first two properties prev2 = rent_values[0] prev1 = max(rent_values[0], rent_values[1]) # Iterate over the rest of the properties for i in range(2, n): current = max(prev1, prev2 + rent_values[i]) prev2 = prev1 prev1 = current return prev1"},{"question":"# Pigeonhole Sort Implementation and Testing Given the following code snippet of the pigeonhole sort algorithm, your task is to: 1. **Implement the pigeonhole sort function** ensuring it can handle arrays with negative integers efficiently. 2. **Test your implementation** with various input cases to ensure correctness and performance: - An array of mixed positive and negative integers. - An array with all identical elements. - An empty array. - An array with a large range of values. - An array already sorted in ascending or descending order. Note: You are expected to implement handling for negative integers as the original provided snippet doesn\'t. ```python def pigeonhole_sort(arr): Max = max(arr) Min = min(arr) size = Max - Min + 1 holes = [0]*size for i in arr: holes[i-Min] += 1 i = 0 for count in range(size): while holes[count] > 0: holes[count] -= 1 arr[i] = count + Min i += 1 return arr ``` Input Format * An array `arr` of integers, which can include both positive and negative numbers. Output Format * A sorted array in ascending order. Constraints * The length of the array `n` is such that `1 <= n <= 10^6`. * The range of array values is such that `-10^6 <= arr[i] <= 10^6`. Example ```python # Input arr = [8, 3, 2, 7, 4, 6, 8] # Expected Output [2, 3, 4, 6, 7, 8, 8] # Input arr = [-5, -10, 0, -3, 8, 5, -1, 10] # Expected Output [-10, -5, -3, -1, 0, 5, 8, 10] # Input arr = [1] # Expected Output [1] # Input arr = [] # Expected Output [] ``` **Requirements**: * Write the function `pigeonhole_sort` as described. * Test the function with various input arrays to guarantee its correctness and performance. * Ensure the function handles edge cases appropriately.","solution":"def pigeonhole_sort(arr): if not arr: return arr Max = max(arr) Min = min(arr) size = Max - Min + 1 holes = [0] * size for x in arr: holes[x - Min] += 1 i = 0 for count in range(size): while holes[count] > 0: holes[count] -= 1 arr[i] = count + Min i += 1 return arr"},{"question":"# Coding Challenge You have been given an integer `n`. Your task is to write a function `next_power_of_two` that finds the smallest power of two greater than or equal to `n`. Function Signature ```python def next_power_of_two(n: int) -> int: ``` Input * An integer `n` (where `-2^31 <= n <= 2^31 - 1`). Output * Return an integer that is the smallest power of two greater than or equal to `n`. If `n` is non-positive, return `1` as the smallest power of two. Constraints * The solution must run in constant O(1) time complexity. * The function should handle edge cases such as negative numbers, zero, and very large numbers properly. Example 1. `next_power_of_two(5)` should return `8`. 2. `next_power_of_two(16)` should return `16`. 3. `next_power_of_two(0)` should return `1`. 4. `next_power_of_two(-10)` should return `1`. Notes * Powers of two are defined as numbers like 1, 2, 4, 8, 16, etc.","solution":"def next_power_of_two(n: int) -> int: This function returns the smallest power of two greater than or equal to n. If n is zero or negative, the function returns 1. if n <= 0: return 1 power = 1 while power < n: power <<= 1 return power"},{"question":"# Prime Number Validation Checker You have been assigned to develop a function that can verify whether a number is prime. Based on a given algorithm, you need to write a function called `is_prime` that implements this logic efficiently. # Input - An integer `n` (1 <= n <= 10^12). # Output - A boolean value (`True` or `False`) indicating whether `n` is a prime number. # Constraints - Your solution should be optimized to handle the upper limit of `n` efficiently. # Performance Requirements - The solution should have a time complexity of O(√n) and space complexity of O(1). # Function Signature ```python def is_prime(n: int) -> bool: pass ``` # Example - Input: `n = 29` - Output: `True` - Input: `n = 15` - Output: `False` # Context Prime checking functions are crucial in various fields within computer science, including cryptography, numerical algorithms, and coding theory. Ensuring that your function can accurately and efficiently determine the primality of numbers is essential for reliable software.","solution":"def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Quick Sort Implementation Given an array of integers, implement the Quick Sort algorithm to sort the array in ascending order. You need to handle different edge cases such as: - An already sorted array. - An array with all identical elements. - An empty array or an array with a single element. Your implementation should include a function `quick_sort(arr)`. The function should return the sorted array. # Input - `arr`: A list of integers `arr` (0 <= len(arr) <= 10^3, -10^4 <= arr[i] <= 10^4) # Output - A list of integers sorted in ascending order. # Constraints 1. The algorithm should correctly handle large input sizes up to 1000 elements. 2. The algorithm should work efficiently within an average case time complexity of O(n log(n)). 3. You should use the Lomuto partition scheme for simplicity. # Example ```python # Example 1 input = [3, 6, 8, 10, 1, 2, 1] output = [1, 1, 2, 3, 6, 8, 10] # Example 2 input = [1, 2, 3, 4, 5] output = [1, 2, 3, 4, 5] # Example 3 input = [5, 4, 3, 2, 1] output = [1, 2, 3, 4, 5] ``` # Additional Notes Implementing and testing edge cases will be essential to ensure your solution is robust and handles all typical scenarios.","solution":"def quick_sort(arr): Sorts an array of integers in ascending order using the Quick Sort algorithm. def partition(low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort_helper(low, high): if low < high: pi = partition(low, high) quick_sort_helper(low, pi - 1) quick_sort_helper(pi + 1, high) quick_sort_helper(0, len(arr) - 1) return arr"},{"question":"You are working as a software engineer at a company that deals with dynamic scheduling. Your task is to create a min-heap class that supports efficient insertion and deletion of tasks (represented as integers) based on their priority. # Requirements Implement a MinHeap class using a binary heap data structure. This class should provide the following methods: 1. **Insert**: Add a new integer into the heap while maintaining the min-heap property. 2. **Remove Min**: Remove and return the minimum element (root) from the heap, ensuring the heap remains a min-heap. 3. **Peek Min**: Return the minimum element without removing it. If the heap is empty, return None. # Input & Output - The `insert(val)` method takes an integer `val` and inserts it into the min-heap. - The `remove_min()` method removes and returns the minimum element from the heap. If the heap is empty, it should return None. - The `peek_min()` method returns the minimum element from the heap without removing it. If the heap is empty, it should return None. # Constraints - The methods should handle cases where the heap is empty. - The min-heap should be implemented using a list to store the heap elements. - The operations should maintain optimal time complexity (`O(log N)` for insertion and deletion). # Function Signature The class should be constructed as follows: ```python class MinHeap: def __init__(self): Constructor for creating an empty heap. pass def insert(self, val): Inserts a value into the heap. pass def remove_min(self): Removes and returns the minimum value from the heap. pass def peek_min(self): Returns the minimum value from the heap without removing it. pass ``` # Example ```python # Initialize the heap heap = MinHeap() heap.insert(5) heap.insert(3) heap.insert(8) heap.insert(1) print(heap.peek_min()) # Should return 1 print(heap.remove_min()) # Should return and remove 1 print(heap.peek_min()) # Should return 3 heap.insert(0) print(heap.peek_min()) # Should return 0 ``` # Note Make sure to handle edge cases such as removing or peeking from an empty heap.","solution":"class MinHeap: def __init__(self): Constructor for creating an empty heap. self.heap = [] def insert(self, val): Inserts a value into the heap. self.heap.append(val) self._sift_up(len(self.heap) - 1) def remove_min(self): Removes and returns the minimum value from the heap. if not self.heap: return None if len(self.heap) == 1: return self.heap.pop() min_val = self.heap[0] self.heap[0] = self.heap.pop() self._sift_down(0) return min_val def peek_min(self): Returns the minimum value from the heap without removing it. if not self.heap: return None return self.heap[0] def _sift_up(self, index): parent = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] self._sift_up(parent) def _sift_down(self, index): left_child = 2 * index + 1 right_child = 2 * index + 2 smallest = index if left_child < len(self.heap) and self.heap[left_child] < self.heap[smallest]: smallest = left_child if right_child < len(self.heap) and self.heap[right_child] < self.heap[smallest]: smallest = right_child if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._sift_down(smallest)"},{"question":"# Flatten Nested Arrays Problem Statement You are given an array that may contain nested arrays of arbitrary depth. Your task is to write a function that flattens this nested array into a single-level array while preserving the order of elements. Input The input is a single nested array potentially containing other arrays or scalar values. Scalar values can be integers, floats, strings, etc., but not dictionaries or custom objects. Output The function should return a flat list containing all the elements from the nested arrays in their original order. Constraints 1. The function should handle an array of arbitrary depth. 2. The input array will not contain null values or undefined elements. 3. The goal is to write a clean and efficient solution. Consider both time and space complexities. # Function Signature ```python def flatten_nested_array(nested_array: list) -> list: pass ``` # Examples ```python assert flatten_nested_array([1, [2, [3, 4], 5], 6]) == [1, 2, 3, 4, 5, 6] assert flatten_nested_array([[1, 2, [3, 4]], [[5], 6]]) == [1, 2, 3, 4, 5, 6] assert flatten_nested_array([1, [2, [3, [4, [5]]]]]) == [1, 2, 3, 4, 5] assert flatten_nested_array([[], [1, [2, []]], [3, [4, [5]]]]) == [1, 2, 3, 4, 5] ``` # Requirements 1. Implement the function using recursion as shown in the provided snippet. 2. Optionally, optimize with an iterative approach that avoids hitting recursion limits for very deeply nested arrays. Good luck and ensure your code is well-commented and readable.","solution":"def flatten_nested_array(nested_array: list) -> list: Flattens a nested array into a single-level array while preserving the order of elements. Parameters: nested_array (list): A nested array containing integers, floats, strings, or other nested arrays. Returns: list: A single-level list with all elements from the nested array. flat_list = [] def flatten(element): if isinstance(element, list): for item in element: flatten(item) else: flat_list.append(element) flatten(nested_array) return flat_list"},{"question":"# Word Pattern Matching Background: You are working on software that needs to validate text patterns. Given a pattern and a string, you need to check if there\'s a one-to-one correspondence between the characters in the pattern and the words in the string. Task: Write a function named `word_pattern` to determine if the string follows the same pattern provided. Input: - A string `pattern` consisting of lowercase letters. - A string `s` consisting of lowercase words separated by a single space. Output: - Return `True` if `s` follows the pattern, else return `False`. Constraints: - `1 <= len(pattern) <= 500` - `1 <= len(s) <= 5000` - The pattern contains only lowercase letters. - The words in `s` are separated by a single space and consist only of lowercase letters. Example: ```python assert word_pattern(\\"abba\\", \\"dog cat cat dog\\") == True assert word_pattern(\\"abba\\", \\"dog cat cat fish\\") == False assert word_pattern(\\"aaaa\\", \\"dog cat cat dog\\") == False assert word_pattern(\\"abba\\", \\"dog dog dog dog\\") == False ``` Performance Requirements: - The implementation should have a time complexity of O(n) and space complexity of O(m), where n is the number of characters in the pattern and words in the string, and `m` is the number of unique characters in the pattern. Additional Context: Consider various edge cases such as: - Patterns and strings of different lengths. - Repetition of words and pattern characters that do not match expected bijections.","solution":"def word_pattern(pattern, s): Determine if the string s follows the same pattern given. Args: pattern (str): A string consisting of lowercase letters that represent the pattern. s (str): A string of words separated by single spaces. Returns: bool: True if s follows the pattern, else False. words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for p, w in zip(pattern, words): if p in char_to_word: if char_to_word[p] != w: return False else: char_to_word[p] = w if w in word_to_char: if word_to_char[w] != p: return False else: word_to_char[w] = p return True"},{"question":"# Question You are working on a data preprocessing task where consistency in binary data is crucial. A portion of your task involves upgrading a categorical binary array to maximize sequential continuity. Specifically, you need to find the index of a \'0\' which, if replaced with a \'1\', would result in the longest contiguous segment of \'1\'s. **Function Signature**: ```python def find_index_to_maximize_ones(arr: List[int]) -> int: ``` # Input - `arr`: A list of integers consisting of only 0s and 1s (representing the binary array). # Output - Returns the index of \'0\' to be replaced with \'1\' to get the longest contiguous 1s sequence. - If no \'0\' is present, return -1. # Constraints - The array will have at least one element. - Elements in the array are either 0 or 1. # Examples 1. Example 1: - `Input`: [1, 0, 1, 1, 0, 1] - `Output`: 1 2. Example 2: - `Input`: [1, 1, 1, 1, 0, 1] - `Output`: 4 3. Example 3: - `Input`: [1, 1, 1, 1, 1] - `Output`: -1 # Detailed Requirement Develop the function `find_index_to_maximize_ones` in Python which accurately processes the input to return the replacement index while ensuring O(n) time complexity with minimal space footprint.","solution":"from typing import List def find_index_to_maximize_ones(arr: List[int]) -> int: max_length = 0 max_index = -1 prev_zero_index = -1 prev_prev_zero_index = -1 current_length = 0 for i in range(len(arr)): if arr[i] == 1: current_length += 1 else: # When we hit a zero, we calculate the sequence length when this zero is flipped sequence_length = i - prev_prev_zero_index if sequence_length > max_length: max_length = sequence_length max_index = prev_zero_index # Update indices of zeros prev_prev_zero_index = prev_zero_index prev_zero_index = i # Reset the current length for the next segment calculation current_length = i - prev_prev_zero_index # In case the best index to flip was not updated due to there being only one zero if current_length + 1 > max_length and prev_zero_index != -1: max_index = prev_zero_index return max_index"},{"question":"Context In a word puzzle game, you are required to determine if two given words can be rearranged to form anagrams of each other. The words include both uppercase and lowercase letters, and they may also contain digits and special characters. Write a function to implement this functionality. Task Write a function `is_anagram` that determines if two strings are anagrams, considering all possible characters. Function Signature ```python def is_anagram(s1: str, s2: str) -> bool: ``` Input * `s1` (str): A string containing alphanumeric characters and possibly special characters. * `s2` (str): A string containing alphanumeric characters and possibly special characters. Output * `bool`: `True` if `s1` and `s2` are anagrams; otherwise, `False`. Constraints * The strings can contain uppercase and lowercase letters, digits, and special characters. * Consider both alphabetical case and occurrences of special characters. # Example ```python # Example 1 print(is_anagram(\\"apple\\", \\"pleap\\")) # Output: True # Example 2 print(is_anagram(\\"apple\\", \\"appeal\\")) # Output: False # Example 3 print(is_anagram(\\"123\\", \\"231\\")) # Output: True # Example 4 print(is_anagram(\\"Hello, World!\\", \\"Woldl, erHlo!\\")) # Output: True ``` Considerations * Handle Unicode characters if necessary. * Optimize the function to operate efficiently on large inputs.","solution":"def is_anagram(s1: str, s2: str) -> bool: Determines if two given strings are anagrams of each other. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s1 and s2 are anagrams, otherwise False. # Anagrams must be of the same length if len(s1) != len(s2): return False # Sort both strings and compare return sorted(s1) == sorted(s2)"},{"question":"# Question: Bidirectional Word Ladder You are given two words, `begin_word` and `end_word`, and a list of allowed intermediate words `word_list`. Your task is to write a function that finds the length of the shortest transformation sequence from `begin_word` to `end_word`. You can transform a word by changing only one letter at a time, and each transformed word must exist in the provided `word_list`. Input Description: * `begin_word`: a string of lowercase alphabetical characters. * `end_word`: a string of lowercase alphabetical characters. * `word_list`: a list of strings of lowercase alphabetical characters. Each word in the list has the same length as `begin_word` and `end_word`. Output Description: * Return an integer representing the length of the shortest transformation sequence from `begin_word` to `end_word`, including the begin and end words. * If no such transformation sequence exists, return -1. Constraints: * All words have the same length. * All words contain only lowercase alphabetical characters. * The solution must handle cases where `begin_word` is identical to `end_word`. Example: ```python begin_word = \\"hit\\" end_word = \\"cog\\" word_list = [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"] # Expected output: 5 # Explanation: One shortest transformation is \\"hit\\" -> \\"hot\\" -> \\"dot\\" -> \\"dog\\" -> \\"cog\\". ``` Additional Notes: * The given list `word_list` does not necessarily include the `begin_word`. * Ensure the function handles the provided constraints efficiently in terms of time and space complexities. * Consider all edge cases as mentioned in the analysis. Template: ```python def ladder_length(begin_word, end_word, word_list): :type begin_word: str :type end_word: str :type word_list: List[str] :rtype: int # Your code goes here ```","solution":"from collections import deque def ladder_length(begin_word, end_word, word_list): :type begin_word: str :type end_word: str :type word_list: List[str] :rtype: int if end_word not in word_list: return -1 word_set = set(word_list) queue = deque([(begin_word, 1)]) visited = set(begin_word) while queue: current_word, length = queue.popleft() if current_word == end_word: return length for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i+1:] if next_word in word_set and next_word not in visited: visited.add(next_word) queue.append((next_word, length + 1)) return -1"},{"question":"# Binary Search Tree Modification Challenge **Context**: Consider an existing implementation of a Binary Search Tree (BST) with standard operations like insertion, search, and traversal. To expand the functionality, we aim to add operations that can provide insights on tree properties and transformations. **Task**: Implement the following additional functionalities in the BST class: 1. **Height Calculation**: - Function Name: `height()` - Description: We need to calculate the height of the tree. The height is the number of edges on the longest path from the root to a leaf. - Input: None - Output: Returns an integer representing the height of the tree. 2. **Leaf Counting**: - Function Name: `leaf_count()` - Description: Determine the total number of leaf nodes in the tree (nodes that do not have any children). - Input: None - Output: Returns an integer representing the count of leaf nodes. 3. **Minimum and Maximum Value**: - Function Name: `find_min()`, `find_max()` - Description: Find the minimum and maximum values stored in the BST. - Input: None - Output: * `find_min()` to return the minimum value in the tree. * `find_max()` to return the maximum value in the tree. **Examples**: ```python bst = BST() bst.insert(10) bst.insert(15) bst.insert(6) bst.insert(4) bst.insert(9) bst.insert(12) bst.insert(24) bst.insert(7) bst.insert(20) bst.insert(30) bst.insert(18) assert bst.height() == 4 assert bst.leaf_count() == 5 assert bst.find_min() == 4 assert bst.find_max() == 30 ``` **Constraints**: * You can assume that the values inserted into the BST are always integers. * The BST tree will have at least one node when any of the new functions are called. Implement these methods following the above specifications.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def height(self): def _height(root): if root is None: return -1 # base case: since height of empty tree is -1 else: left_height = _height(root.left) right_height = _height(root.right) return 1 + max(left_height, right_height) return _height(self.root) def leaf_count(self): def _leaf_count(root): if root is None: return 0 if root.left is None and root.right is None: return 1 else: return _leaf_count(root.left) + _leaf_count(root.right) return _leaf_count(self.root) def find_min(self): current = self.root while current.left is not None: current = current.left return current.val def find_max(self): current = self.root while current.right is not None: current = current.right return current.val"},{"question":"# Question: Vowel Reversal Algorithm Refactor the following function to reverse only the vowels in a given string `s` using the two-pointer technique. Your goal is to identify and swap the vowels from both ends of the string. Ensure you handle edge cases such as strings without vowels, single character strings, and strings where all characters are vowels. **Function Signature**: ```python def reverse_vowel(s: str) -> str: ``` **Input**: * A single string `s` (0 <= len(s) <= 10^5): The input string. **Output**: * A string in which the vowels in `s` are reversed in their positions while other characters remain the same. **Constraints**: * The input string will contain only printable ASCII characters. # Examples: ```python assert reverse_vowel(\\"hello\\") == \\"holle\\" assert reverse_vowel(\\"leetcode\\") == \\"leotcede\\" assert reverse_vowel(\\"aA\\") == \\"Aa\\" assert reverse_vowel(\\"bcdfg\\") == \\"bcdfg\\" ``` **Explanation**: * In the first example, vowels \'e\' and \'o\' are swapped. * In the second example, \'e\', \'e\', \'o\', \'e\' are reversed resulting in \'leotcede\'. * In the third example, \'a\' and \'A\' are swapped. * In the fourth example, no vowels present, thus no changes. **Notes**: Handle all edge cases gracefully. Optimize the solution to handle long strings efficiently using the two-pointer approach.","solution":"def reverse_vowel(s: str) -> str: vowels = set(\\"aeiouAEIOU\\") s = list(s) # Convert the string to a list for easier manipulation i, j = 0, len(s) - 1 while i < j: if s[i] not in vowels: i += 1 elif s[j] not in vowels: j -= 1 else: s[i], s[j] = s[j], s[i] i += 1 j -= 1 return \\"\\".join(s)"},{"question":"String Reversal Function Using Stack (Intermediate Level) # Objective Your task is to implement a function that reverses a given string using a stack data structure. This approach tests your understanding of stack operations and basic string manipulation. # Function Signature ```python def reverse_using_stack(s: str) -> str: pass ``` # Input * `s` (string): The input string that needs to be reversed. * Constraints: (0 leq text{len}(s) leq 10^5) # Output * (string): The reversed string. # Performance Requirements * The solution should have a time complexity of O(n) and a space complexity of O(n), where n is the length of the input string. # Example ```python assert reverse_using_stack(\\"hello\\") == \\"olleh\\" assert reverse_using_stack(\\"world\\") == \\"dlrow\\" assert reverse_using_stack(\\"\\") == \\"\\" assert reverse_using_stack(\\"a\\") == \\"a\\" assert reverse_using_stack(\\"ab\\") == \\"ba\\" ``` # Requirements * You must utilize a stack data structure to reverse the string. * Edge cases such as empty strings and single character strings should be appropriately handled. # Hints * A stack is a Last-In-First-Out (LIFO) structure. * You can use Python\'s `list` as a stack by utilizing its `append` and `pop` methods. # Context This question assesses your understanding of stacks, a fundamental data structure. It also requires you to handle edge cases effectively and implement a solution that meets the specified performance criteria.","solution":"def reverse_using_stack(s: str) -> str: stack = [] # Push all characters of string to stack for char in s: stack.append(char) # Pop all characters from stack and construct reversed string reversed_s = \\"\\" while stack: reversed_s += stack.pop() return reversed_s"},{"question":"Problem Statement You are given two strings, `A` and `B`. Your task is to find the minimum number of times you need to concatenate the string `A` with itself such that `B` becomes a substring of the resulting string. If there is no such solution, return -1. # Function Signature ```python def repeat_string(A: str, B: str) -> int: ``` # Input * `A` : A string of length between 1 and 10000. * `B` : A string of length between 1 and 10000. # Output * Return an integer representing the minimum number of concatenations required. Return -1 if no such solution exists. # Constraints * 1 <= len(A) <= 10000 * 1 <= len(B) <= 10000 # Example ```python assert repeat_string(\\"abcd\\", \\"cdabcdab\\") == 3 # \\"abcdabcdabcd\\" contains \\"cdabcdab\\" assert repeat_string(\\"a\\", \\"aa\\") == 2 # \\"aa\\" contains \\"aa\\" assert repeat_string(\\"abc\\", \\"def\\") == -1 # \\"def\\" cannot be formed ``` # Points to Note * You need to consider edge cases such as the following: * When `A` or `B` is empty. * When `B` is already a substring of `A`. * Optimize string concatenation to avoid performance pitfalls for large strings. # Testing * Include diverse test cases to cover edge cases, regular cases, and performance considerations. * Write clean, efficient code that adheres to the outlined constraints.","solution":"def repeat_string(A: str, B: str) -> int: Finds the minimum number of times `A` needs to be concatenated with itself such that `B` becomes a substring of the resulting string. Returns -1 if no such solution exists. if not A or not B: return -1 repeats = 1 extended_A = A while len(extended_A) < len(B): extended_A += A repeats += 1 if B in extended_A: return repeats extended_A += A repeats += 1 if B in extended_A: return repeats return -1"},{"question":"<|Analysis Begin|> # Algorithm Analysis Core Identification * **Algorithm/Data Structure**: This code defines two classes, `Monomial` and `Polynomial`. * **Algorithm Type**: The provided code is mainly focused on the implementation of polynomial algebra through object-oriented techniques. * **Main Purpose**: The classes are designed to handle arithmetic operations on monomials and polynomials efficiently. This includes addition, subtraction, multiplication, and division. * **Complexity**: - **Time Complexity**: Operations like addition, subtraction, multiplication, and division on monomials have a time complexity of O(n), where n is the number of variables in the monomials involved. For polynomials, the complexities can scale up to O(m*n), where m and n are the number of monomials in the operands. - **Space Complexity**: Space complexity is generally linear in relation to the number of variables for a monomial, and linear in the number of monomials for a polynomial. Core Principles * **Key Mechanisms**: - **Initialization**: Monomials and Polynomials are defined by their variables and coefficients. - **Arithmetic Operations**: Arithmetic operators are overloaded to provide intuitive functionality. - **Normalization**: Methods like `clean`, `inverse`, and `_rationalize_if_possible` ensure that monomials and polynomials are in a simplified form. Characteristics & Applications * **Properties**: - **Polynomial Arithmetic**: Supports standard polynomial operations, ensuring correct handling of edge cases such as zero coefficients. - **Hashable Monomials**: Making monomials hashable allows for efficient polynomial simplification. * **Common Use Cases**: - **Symbolic Computation**: Handling symbolic mathematics, such as in computer algebra systems. - **Algebraic Manipulation**: Useful in situations requiring algebraic manipulation, such as in solving algebraic expressions or optimization problems. * **Strengths/Limitations**: - **Strengths**: - Seamless arithmetic operations between monomials and polynomials. - Uses Python\'s `fraction` module to handle rational numbers, thus ensuring precision. - **Limitations**: - Limited handling of polynomial division beyond monomial denominators. - Potential inefficiencies in handling extremely large polynomials due to lack of internal optimizations like combining like terms early. Implementation Challenges * **Edge Cases**: - Monomials with zero coefficients. - Arithmetic operations resulting in zero monomials or polynomials. - Variable exponents becoming zero or negative. * **Performance Bottlenecks**: - Handling large polynomials due to the lack of early combination or simplification of like terms. - Using sets for arithmetic which could have a higher overhead for massive collections. * **Error Scenarios**: - Division by zero. - Substitution where not all variables are provided values. - Arithmetic on incompatible types or structures. * **Optimization Points**: - Efficiency improvements through caching, or by early combination of like terms. - Enhanced support for polynomial-polynomial division. <|Analysis End|> <|Question Begin|> # Polynomial Arithmetic and Simplification Background You\'re working in a domain where symbolic mathematics frequently appear. You\'ve been provided with code for `Monomial` and `Polynomial` classes to handle polynomial algebra. These classes already support many operations like addition, subtraction, multiplication, and division of monomials and polynomials. Your task is to extend this code to support some more complex polynomial operations. One of the crucial operations needed is combining like terms efficiently. Objective Implement a method within the `Polynomial` class that combines like terms in the polynomial. This method should iterate through the `self.monomials` set and combine monomials that have the same variables into a single monomial with the summed coefficients. Problem Statement You need to implement a method `combine_like_terms` in the `Polynomial` class. This method will combine all monomials in the polynomial that have the same variables. Input * A `Polynomial` object, which contains a set of `Monomial` objects. Output * The output should be a new `Polynomial` object with combined like terms. Constraints 1. Polynomial can contain any number of monomials. 2. Monomials with zero coefficients should not appear in the final simplified polynomial. 3. Utilize the existing Monomial functionality to check for equality of monomials up to scalar multiples. Example ```python poly = Polynomial([ Monomial({1: 2}, 3), # 3a_1^2 Monomial({1: 2}, -1), # -a_1^2 Monomial({2: 1}, 2) # 2a_2 ]) simplified_poly = poly.combine_like_terms() print(simplified_poly) # Output should be: Polynomial(\'2a_1^2 + 2a_2\') ``` Implementation ```python def combine_like_terms(self): Combine like terms in the polynomial. Returns: Polynomial: A new Polynomial instance with combined like terms. combined_monomials = {} for monomial in self.monomials: key = tuple(sorted(monomial.variables.items())) if key in combined_monomials: combined_monomials[key] = combined_monomials[key] + monomial else: combined_monomials[key] = monomial final_monomials = [m.clean() for m in combined_monomials.values() if m.coeff != 0] return Polynomial(final_monomials) # Add this method to the Polynomial class and test with the provided example. ``` Your task is to integrate this `combine_like_terms` method into the `Polynomial` class and test it with various polynomial instances to verify its functionality.","solution":"class Monomial: def __init__(self, variables, coeff=1): # variables is a dictionary where keys are variable identifiers and values are their exponents self.variables = variables self.coeff = coeff def __eq__(self, other): return self.variables == other.variables def __hash__(self): return hash(frozenset(self.variables.items())) def __add__(self, other): if self.variables == other.variables: return Monomial(self.variables, self.coeff + other.coeff) raise ValueError(\\"Cannot add monomials with different variables\\") def __mul__(self, other): if isinstance(other, Monomial): new_vars = self.variables.copy() for var, exp in other.variables.items(): if var in new_vars: new_vars[var] += exp else: new_vars[var] = exp return Monomial(new_vars, self.coeff * other.coeff) else: return Monomial(self.variables, self.coeff * other) def clean(self): # Remove variables with an exponent of 0 new_vars = {var: exp for var, exp in self.variables.items() if exp != 0} return Monomial(new_vars, self.coeff) def __repr__(self): vars_str = \'\'.join([f\'a_{var}^{exp} \' for var, exp in self.variables.items()]).strip() return f\'{self.coeff}{vars_str}\' class Polynomial: def __init__(self, monomials=None): self.monomials = monomials or [] def combine_like_terms(self): combined_monomials = {} for monomial in self.monomials: key = tuple(sorted(monomial.variables.items())) if key in combined_monomials: combined_monomials[key] = combined_monomials[key] + monomial else: combined_monomials[key] = monomial final_monomials = [m.clean() for m in combined_monomials.values() if m.coeff != 0] return Polynomial(final_monomials) def __repr__(self): return \' + \'.join([str(m) for m in self.monomials]) # Example usage poly = Polynomial([ Monomial({1: 2}, 3), # 3a_1^2 Monomial({1: 2}, -1), # -a_1^2 Monomial({2: 1}, 2) # 2a_2 ]) simplified_poly = poly.combine_like_terms() print(simplified_poly) # Output should be: Polynomial(2a_1^2 + 2a_2)"},{"question":"You are given a directed graph representing a network of one-way connections between nodes. Your task is to determine if the graph is strongly connected, meaning there is a path from every node to every other node and vice versa. # Function Signature ```python def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: pass ``` # Input/Output * **Input**: * `vertex_count (int)`: The number of vertices in the graph. * `edges (List[Tuple[int, int]]`: A list of tuples where each tuple represents a directed edge from the first vertex to the second. * **Output**: * `bool`: Return `True` if the graph is strongly connected; otherwise, return `False`. # Constraints * The graph will have at most 1000 vertices. * Only valid vertex indices (0 ≤ u, v < vertex_count) will be given for the edges. * The graph might be sparse or dense. # Example ```python assert is_strongly_connected(4, [(0, 1), (1, 2), (2, 0), (0, 3), (3, 0)]) == True assert is_strongly_connected(4, [(0, 1), (1, 2), (2, 0), (3, 0)]) == False ``` # Explanation In the first example, there is a path from every node to every other node and vice versa, hence the function returns `True`. In the second example, there is no path from node 0 to node 3, and vice versa, hence the function returns `False`. # Implementation Using the principles of the given algorithm: 1. Create a graph using the provided vertices and edges. 2. Check if all nodes are reachable from the starting node. 3. Reverse the graph and check the reachability again. 4. If both checks pass, the graph is strongly connected.","solution":"from typing import List, Tuple def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: def dfs(graph, start, visited): stack = [start] while stack: node = stack.pop() if not visited[node]: visited[node] = True stack.extend(graph[node]) # function to construct the graph def construct_graph(vertex_count, edges): graph = [[] for _ in range(vertex_count)] for u, v in edges: graph[u].append(v) return graph # construct the original graph graph = construct_graph(vertex_count, edges) # Step 1: Run DFS from any vertex (vertex 0) and check if all vertices are reachable visited = [False] * vertex_count dfs(graph, 0, visited) if not all(visited): return False # Step 2: Construct the reversed graph reversed_graph = construct_graph(vertex_count, [(v, u) for u, v in edges]) # Step 3: Run DFS from the same vertex (vertex 0) in the reversed graph visited = [False] * vertex_count dfs(reversed_graph, 0, visited) # If all vertices are reachable in the reversed graph, the graph is strongly connected return all(visited)"},{"question":"# Question You are given a class `BitManipulator` with methods for getting, setting, clearing, and updating bits in the binary representation of an integer. Your task is to complete the implementation of the `BitManipulator` class with the following methods: 1. **`get_bit(num: int, i: int) -> bool`**: Returns `True` if the bit at index `i` in the binary representation of `num` is `1`, and `False` otherwise. 2. **`set_bit(num: int, i: int) -> int`**: Sets the bit at index `i` to `1` and returns the new number. 3. **`clear_bit(num: int, i: int) -> int`**: Sets the bit at index `i` to `0` and returns the new number. 4. **`update_bit(num: int, i: int, bit: int) -> int`**: Updates the bit at index `i` to the value `bit` (either `0` or `1`) and returns the new number. # Constraints: * `num` will be a non-negative integer. * `i` will be a non-negative integer such that `i < 32` (considering a 32-bit integer). * `bit` will be either `0` or `1`. # Example Usage ```python bitmanip = BitManipulator() assert bitmanip.get_bit(5, 0) == True # 5 in binary is 101 assert bitmanip.get_bit(5, 1) == False # 5 in binary is 101 assert bitmanip.set_bit(5, 1) == 7 # 5 -> 101, setting bit 1 -> 111 = 7 assert bitmanip.clear_bit(5, 0) == 4 # 5 -> 101, clearing bit 0 -> 100 = 4 assert bitmanip.update_bit(5, 1, 1) == 7 # 5 -> 101, update bit 1 to 1 -> 111 = 7 assert bitmanip.update_bit(5, 2, 0) == 1 # 5 -> 101, update bit 2 to 0 -> 001 = 1 ``` # Your Task: Implement the `BitManipulator` class methods as described.","solution":"class BitManipulator: def get_bit(self, num: int, i: int) -> bool: Returns True if the bit at index i in the binary representation of num is 1, False otherwise. return (num & (1 << i)) != 0 def set_bit(self, num: int, i: int) -> int: Sets the bit at index i to 1 and returns the new number. return num | (1 << i) def clear_bit(self, num: int, i: int) -> int: Sets the bit at index i to 0 and returns the new number. return num & ~(1 << i) def update_bit(self, num: int, i: int, bit: int) -> int: Updates the bit at index i to the value bit (either 0 or 1) and returns the new number. mask = ~(1 << i) num_cleared = num & mask return num_cleared | (bit << i)"},{"question":"# Scenario A programming contest organization is designing a problem where participants need to calculate the number of ways to pick committees from a group of people. The organization wants an efficient solution that can handle large inputs without exceeding typical recursion limits. # Question Implement an iterative version of the function `binomial_coefficient` to calculate the binomial coefficient ( C(n, k) ) using dynamic programming for the contest scenario described above. # Function Signature ```python def binomial_coefficient(n: int, k: int) -> int: Calculate the binomial coefficient C(n, k) using an iterative approach. :param n: Number of items to choose from (n must be >= k and n, k >= 0) :param k: Number of items to choose :return: Binomial coefficient C(n, k) ``` # Input * **n**: Integer (0 <= n <= 1000) * **k**: Integer (0 <= k <= 1000, n must be >= k) # Output * Returns the binomial coefficient ( C(n, k) ). # Constraints * Ensure the function is efficient and handles large values of ( n ) and ( k ). * Avoid using recursion to prevent stack overflow. # Example ```python print(binomial_coefficient(5, 2)) # Should return 10 print(binomial_coefficient(10, 3)) # Should return 120 print(binomial_coefficient(1000, 500)) # Should return a large integer ``` # Notes * Use an iterative approach with dynamic programming to store intermediate results to improve efficiency. * The solution should have a time complexity of ( O(n times k) ) and a space complexity of ( O(n times k) ).","solution":"def binomial_coefficient(n: int, k: int) -> int: Calculate the binomial coefficient C(n, k) using an iterative approach with dynamic programming. :param n: Number of items to choose from (n must be >= k and n, k >= 0) :param k: Number of items to choose :return: Binomial coefficient C(n, k) if k > n: return 0 if k == 0 or k == n: return 1 # Create a 2D array to store results of subproblems C = [[0] * (k + 1) for _ in range(n + 1)] for i in range(n + 1): for j in range(min(i, k) + 1): if j == 0 or j == i: C[i][j] = 1 else: C[i][j] = C[i-1][j-1] + C[i-1][j] return C[n][k]"},{"question":"**Scenario**: You are given an array of integers and want to filter the array to include only elements within a specified range. This is a common requirement in data processing where you might want to focus only on relevant numerical data. **Task**: Implement a function that filters the array based on provided minimum and maximum limits. If no minimum or maximum limit is provided, consider the entire range of the array\'s values. # Function Signature ```python def limit(arr, min_lim=None, max_lim=None): Filters the given array so that only elements in the specified range are included. Parameters: arr (list): List of integers to be filtered. min_lim (int, optional): Minimum limit of the range (inclusive). Default is None, which means no minimum limit. max_lim (int, optional): Maximum limit of the range (inclusive). Default is None, which means no maximum limit. Returns: list: A new list containing only elements within the specified range. ``` # Input 1. `arr` (list): A list of integers where each integer ( -10^9 leq arr[i] leq 10^9 ) and ( 0 leq len(arr) leq 10^5 ). 2. `min_lim` (int or Optional): The minimum value of the range (inclusive). If None, use the minimum value found in the array. 3. `max_lim` (int or Optional): The maximum value of the range (inclusive). If None, use the maximum value found in the array. # Output - A filtered list of integers that are within the range `[min_lim, max_lim]`. # Constraints - The function should have a time complexity of O(n). - The function should be robust with zero or large-sized input arrays. - Follow the principle of inclusive range: an element equal to `min_lim` or `max_lim` should be included. # Examples ```python # Example 1: print(limit([1, 2, 3, 4, 5], None, 3)) # Output: [1, 2, 3] # Example 2: print(limit([10, 20, 30, 40, 50], 20, 40)) # Output: [20, 30, 40] # Example 3: print(limit([5, 7, 9, 11, 13], 7, None)) # Output: [7, 9, 11, 13] # Example 4: print(limit([], None, None)) # Output: [] ``` **Note**: You must ensure that the implementation handles a variety of edge cases, including empty arrays and undefined bounds (`min_lim`, `max_lim`).","solution":"def limit(arr, min_lim=None, max_lim=None): Filters the given array so that only elements in the specified range are included. Parameters: arr (list): List of integers to be filtered. min_lim (int, optional): Minimum limit of the range (inclusive). Default is None, which means no minimum limit. max_lim (int, optional): Maximum limit of the range (inclusive). Default is None, which means no maximum limit. Returns: list: A new list containing only elements within the specified range. if min_lim is None: if arr: min_lim = min(arr) else: min_lim = -float(\'inf\') # effectively no minimum limit in an empty array case if max_lim is None: if arr: max_lim = max(arr) else: max_lim = float(\'inf\') # effectively no maximum limit in an empty array case return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"You are given a tree with the following structure where each node can have multiple sub-nodes, and each sub-node can either be a string or another tree. Your task is to implement a function that performs a depth-first traversal of this tree and prints its contents in a hierarchical format. The output should be formatted such that sub-elements at each level are appropriately indented to reflect their hierarchy. Write a function `pretty_tree_print(tree: Dict[str, Union[str, Dict]]) -> None` that takes a dictionary representing the tree and prints its contents. **Input:** - The input dictionary `tree` has: - Keys as strings representing identifiers. - Values as lists, where list elements can be strings or dictionaries representing further nested structures. **Output:** - The function should print each identifier followed by its sub-elements. - Each hierarchical level should be indented with each level indented by further 2 spaces (or a tab). **Constraints:** - The tree can have indefinite depth and breadth. - Both strings and dictionaries can appear at any level of the tree. **Example:** For the tree: ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', {\'Computer\': 5, \'TV\': 6}], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', {\'Computer\': 3, \'Quin\': {\'Computer\': 3}}], \'e\': [\'Quin\', {\'Book\': 5, \'TV\': 2}], \'f\': [\'Adam\', \'Computer\', 7] } ``` The function should print: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 TV -> 6 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 Quin -> Computer -> 3 e -> Quin -> Book -> 5 TV -> 2 f -> Adam -> Computer -> 7 ``` **Implementation Details:** - Treat each non-string element by recursively traversing it. - Ensure correct indentation for nested elements.","solution":"def pretty_tree_print(tree, indent_level=0): Recursive function to print the tree structure in a hierarchical format. :param tree: The input tree as a dictionary. :param indent_level: The current level of indentation (used in recursive calls). for key, value in tree.items(): indent = \' \' * indent_level print(f\\"{indent}{key} ->\\", end=\' \') if isinstance(value, list): print() for item in value: if isinstance(item, str) or isinstance(item, int): print(f\\"{indent} {item}\\") elif isinstance(item, dict): pretty_tree_print(item, indent_level + 1) # Example Usage tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', {\'Computer\': 5, \'TV\': 6}], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', {\'Computer\': 3, \'Quin\': {\'Computer\': 3}}], \'e\': [\'Quin\', {\'Book\': 5, \'TV\': 2}], \'f\': [\'Adam\', \'Computer\', 7] } pretty_tree_print(tree)"},{"question":"# **Unique Path Count with Dynamic Programming** Given a grid of dimensions (m times n), write a function `count_paths(m, n)` that returns the number of unique paths from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1). You are allowed to move only right or down at any point in time. Input: - `m`: an integer representing the number of rows in the grid (1 ≤ m ≤ 1000) - `n`: an integer representing the number of columns in the grid (1 ≤ n ≤ 1000) Output: - Return an integer representing the number of unique paths from (a[0][0]) to (a[m-1][n-1]). Constraints: - You can only move right or down at any point in time. - Ensure the function handles edge cases like 1xn or mx1 grids. Examples: ```python assert count_paths(3, 3) == 6 # Paths are well known in Pascal\'s triangle assert count_paths(1, 5) == 1 # Only one straight path assert count_paths(2, 2) == 2 # These are paths like \\"RR\\", \\"DD\\" ``` Performance requirements: - Ensure your solution runs efficiently within the constraints mentioned. Notes: - Do not use global variables. - The function should be self-contained with correct input validation.","solution":"def count_paths(m, n): Returns the number of unique paths from top-left corner to bottom-right corner of a grid of dimensions m x n. if m <= 0 or n <= 0: return 0 # Create a 2D list initialized to 0 dp = [[0] * n for _ in range(m)] # Initialize the first column and first row for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Diophantine Equation Solver **Problem Statement**: Implement a function to solve the Diophantine equation ( ax + by = gcd(a, b) ) using the Extended Euclidean Algorithm. **Function Signature**: ```python def solve_diophantine(a: int, b: int) -> Tuple[int, int, int]: Solves the equation ax + by = gcd(a, b) to find x, y and gcd(a, b). Parameters: a (int): The first integer coefficient. b (int): The second integer coefficient. Returns: Tuple[int, int, int]: A tuple containing (x, y, gcd(a, b)) ``` **Input**: - Two integers `a` and `b` where ( |a|, |b| leq 10^9 ). **Output**: - A tuple of three integers: (x), (y), and (g), where ( a times x + b times y = g ) and ( g = gcd(a, b) ). **Constraints**: - Implement the function efficiently with a time complexity of ( O(log(min(a, b))) ). - Handle edge cases such as when ( a ) or ( b ) is zero. **Performance Requirements**: - Ensure the function computes the result within a reasonable time for the given constraints. **Examples**: ```python assert solve_diophantine(30, 12) == (-1, 3, 6) assert solve_diophantine(101, 10) == (1, -10, 1) assert solve_diophantine(0, 5) == (0, 1, 5) assert solve_diophantine(7, 0) == (1, 0, 7) ``` **Context**: You are working on an encryption algorithm where you need to find modular inverses for large integers. To achieve this, you need to implement the Extended Euclidean Algorithm to solve for coefficients in Bézout\'s identity and determine the greatest common divisor.","solution":"from typing import Tuple def extended_gcd(a: int, b: int) -> Tuple[int, int, int]: Implementation of the Extended Euclidean Algorithm. Returns x, y, and gcd such that a*x + b*y = gcd. if b == 0: return (1, 0, a) else: x1, y1, gcd = extended_gcd(b, a % b) x = y1 y = x1 - (a // b) * y1 return x, y, gcd def solve_diophantine(a: int, b: int) -> Tuple[int, int, int]: Solves the equation ax + by = gcd(a, b) to find x, y and gcd(a, b). Parameters: a (int): The first integer coefficient. b (int): The second integer coefficient. Returns: Tuple[int, int, int]: A tuple containing (x, y, gcd(a, b)) x, y, g = extended_gcd(a, b) return x, y, g"},{"question":"# Question Given an integer array `arr`, implement two different heap sort functions: one using a max heap and one using a min heap. Your task is to use these functions to sort the array in ascending order and return the sorted array. **Requirements**: 1. Implement the functions `max_heap_sort(arr)` and `min_heap_sort(arr)`. 2. Both functions should sort the input array in ascending order using their respective heap methods. 3. You must handle edge cases such as empty arrays and arrays with a single element. **Function Definitions**: 1. `max_heap_sort(arr: List[int]) -> List[int]` 2. `min_heap_sort(arr: List[int]) -> List[int]` **Input and Output Details**: * **Input**: * An array of integers where `arr[i]` can be any integer within the 32-bit range. * **Output**: * A new array sorted in ascending order. **Example**: ```python Input: arr = [3, 5, 1, 2, 4] Output for max_heap_sort(arr): [1, 2, 3, 4, 5] Output for min_heap_sort(arr): [1, 2, 3, 4, 5] ``` **Constraints**: * The length of the array (`n`) is not limited, but you should strive to ensure that your solutions handle typical edge cases efficiently. * Performance is critical: ensure that the implementations conform to O(n log n) time complexity. **Clarifications**: * You do not need to simulate the sorting steps. * Both functions should directly modify and return the sorted array. *Your solution will be evaluated based on correctness, efficiency, and handling of edge cases.*","solution":"def max_heap_sort(arr): Sort the array in ascending order using max heap. def heapify(arr, n, i): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest) n = len(arr) for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0) return arr def min_heap_sort(arr): Sort the array in ascending order using min heap. def heapify(arr, n, i): smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] < arr[smallest]: smallest = left if right < n and arr[right] < arr[smallest]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] heapify(arr, n, smallest) n = len(arr) for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0) arr.reverse() return arr"},{"question":"# Stack Implementation and Parentheses Matching **Scenario**: You\'re tasked with developing a function that checks if the parentheses in a given string are balanced. A balanced string means that each opening parenthesis has a corresponding closing parenthesis, and they are correctly nested. **Function to Implement**: You need to implement a function `is_balanced(s: str) -> bool` that uses a stack to determine if a string consisting of `(` and `)` characters is balanced. **Input and Output**: * **Input**: A string `s` that consists of `(` and `)` characters. * **Output**: A boolean value; `True` if the string is balanced, `False` otherwise. **Constraints**: 1. The input string will have a maximum length of 10^4 characters. 2. You must implement the function using a stack. 3. You should handle potential edge cases, such as empty strings or strings starting with a closing parenthesis. **Performance Requirements**: Your solution should be efficient in both time and space complexity. **Example**: ```python print(is_balanced(\\"((()))\\")) # Should return True print(is_balanced(\\"(()\\")) # Should return False print(is_balanced(\\")(\\")) # Should return False print(is_balanced(\\"()()\\")) # Should return True ``` * **Hints**: * Use a stack to keep track of opening parentheses. * For each closing parenthesis, check if there is a corresponding opening parenthesis in the stack.","solution":"def is_balanced(s: str) -> bool: Determine if the given string of parentheses is balanced. A string is balanced if every opening parenthesis has a corresponding closing parenthesis, and they are correctly nested. :param s: Input string consisting of \'(\' and \')\' characters. :return: True if the string is balanced, False otherwise. stack = [] for char in s: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"**Prime Sequence Generator** # Description You are tasked with creating an algorithm to generate a sequence of the first `k` prime numbers. The function should utilize the primality checking logic to ensure each number in the sequence is prime. # Function Signature ```python def generate_primes(k: int) -> List[int]: Generates a list of the first \'k\' prime numbers. Parameters: k (int): The number of prime numbers to generate, k > 0 Returns: List[int]: A list containing the first \'k\' prime numbers. ``` # Input * An integer `k` (1 ≤ k ≤ 10^5) representing the number of primes to generate. # Output * A list of the first `k` prime numbers. # Constraints and Notes * The solution must be efficient enough to handle large `k` within a reasonable time frame. * Ensure the prime_check function logic is used to determine the primality of numbers. * Consider both time and space complexities when designing the algorithm. # Example ```python >>> generate_primes(5) [2, 3, 5, 7, 11] >>> generate_primes(10) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] ``` # Edge Cases * Handling the smallest (`k = 1`) and largest (`k = 10^5`) valid inputs. * Ensuring no unnecessary computations are performed by avoiding redundant checks. Solve the problem by implementing the function signature provided above.","solution":"from typing import List def is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def generate_primes(k: int) -> List[int]: primes = [] num = 2 while len(primes) < k: if is_prime(num): primes.append(num) num += 1 return primes"},{"question":"You are required to enhance and optimize an existing function that prints the structure of a tree stored as a nested dictionary. The tree is represented by: * `key`: a node of the tree. * `value`: a list where each element is either another dictionary (a sub-tree) or a value to be printed directly. The existing implementation has several inefficiencies, including repeated lookups and suboptimal handling of different data types within the tree structure. Task Write a function `enhanced_tree_print(tree)` that improves upon the existing `tree_print` function by addressing the optimization points and ensuring it handles a variety of edge cases. Your function should: * Traverse the tree efficiently. * Print the structure with appropriate indentation. * Handle mixed types of values within the tree properly. * Avoid redundant lookups. Constraints * Assume the tree depth does not exceed 100 levels. * The tree can have a mix of strings and integers as node names or values. Function Signature ```python def enhanced_tree_print(tree: dict) -> None: pass ``` Example Given the following tree: ```python tree = { \'a\': [\'Adam\', {\'Book\': 4}], \'b\': [\'Bill\', {\'Computer\': 5}, {\'TV\': 6}], \'Jill\': [{\'Sports\': 1}], \'c\': [\'Bill\', {\'Sports\': 3}], \'d\': [\'Adam\', {\'Computer\': 3}, {\'Quin\': {\'Computer\': 3}}], \'e\': [\'Quin\', {\'Book\': 5}, {\'TV\': 2}], \'f\': [\'Adam\', {\'Computer\': 7}] } ``` The `enhanced_tree_print(tree)` should produce: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` Notes * Ensure to handle deeply nested structures properly. * Your solution should maintain clarity and be conceptually easy to follow.","solution":"def enhanced_tree_print(tree: dict) -> None: def print_branch(branch, indent=\\"\\"): if isinstance(branch, dict): for key, value in branch.items(): print(indent + str(key)) print_branch(value, indent + \\" -> \\") elif isinstance(branch, list): for value in branch: print_branch(value, indent) else: print(indent + str(branch)) for key, value in tree.items(): print(str(key)) print_branch(value, \\" -> \\")"},{"question":"Find the k-th Smallest Element in a Binary Search Tree (BST) You are given a binary search tree (BST) and an integer k. Your task is to implement a function to find and return the k-th smallest element in the BST. # Input - The function will receive the root of a binary search tree (BST) and an integer k. - `root` is a reference to the root node of the BST. - Each node in the BST has the following attributes: - `val` (an integer): The value of the node. - `left` (a reference to the left child node; can be None). - `right` (a reference to the right child node; can be None). - The integer `k` represents the position (1-based) of the smallest element you need to find. # Output - The function should return the value of the k-th smallest element in the BST. # Constraints - 1 <= k <= Number of nodes in the BST. - The BST consists of unique values. # Example Example 1 Input: ``` 3 / 1 4 2 ``` k = 1 Output: ``` 1 ``` Example 2 Input: ``` 5 / 3 6 / 2 4 / 1 ``` k = 3 Output: ``` 3 ``` # Implementation Notes - Use in-order traversal to process nodes in ascending order. - Manage the in-order sequence with either recursion or an iterative approach using a stack.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): This function returns the k-th smallest element in the BST. def in_order_traversal(node): if not node: return [] return in_order_traversal(node.left) + [node.val] + in_order_traversal(node.right) # Perform in-order traversal to get all elements in sorted order elements = in_order_traversal(root) # Return the k-th smallest element (1-based index, hence k-1) return elements[k-1]"},{"question":"# FizzBuzz Enhanced FizzBuzz is a classic coding problem often used in interviews to assess basic programming ability. In its traditional form, you must generate a list of numbers from 1 to N, replacing numbers divisible by 3 with \\"Fizz\\", divisible by 5 with \\"Buzz\\", and divisible by both 3 and 5 with \\"FizzBuzz\\". In this enhanced version, you are asked to: 1. Implement the traditional FizzBuzz. 2. Extend the implementation to accept a list of (number, replacement_string) tuples that specify additional rules for replacing numbers. For example, you might receive a rule (7, \\"Foo\\") that means numbers divisible by 7 are replaced with \\"Foo\\". Your function should: - Accept two parameters: an integer n and a list of (number, replacement_string) tuples. - Generate the FizzBuzz sequence from 1 to n considering all replacement rules. - Return the resulting list. Input - **n** (integer): A positive integer (n >= 1). - **rules** (list of tuples): Each tuple contains an integer and a string, representing a number and its replacement string. Output - List of length n where the i-th element contains the number i+1 or the corresponding replacement string based on the rules. # Constraints - n >= 1. - Each replacement string will have at least one character. - Replacement rules are unique and non-conflicting. # Example ```python def enhanced_fizzbuzz(n, rules): # Your implementation here pass print(enhanced_fizzbuzz(15, [(3, \\"Fizz\\"), (5, \\"Buzz\\")])) # Output: [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] print(enhanced_fizzbuzz(20, [(4, \\"Quack\\"), (6, \\"Duck\\")])) # Output: [1, 2, 3, \'Quack\', 5, \'Duck\', 7, \'Quack\', 9, 10, 11, \'QuackDuck\', 13, 14, 15, \'Quack\', 17, \'Duck\', 19, \'Quack\'] ``` # Additional Notes - Your code should handle input validation ensuring n is a positive integer and rules are formatted correctly. - Consider edge cases where n is 1 or the rules list is empty.","solution":"def enhanced_fizzbuzz(n, rules): Generate a list from 1 to n, replacing numbers based on provided rules. Parameters: n (int): The upper limit of the range. rules (list of tuples): A list containing (number, replacement_string) tuples. Returns: list: A list with numbers or replacement strings based on provided rules. output = [] for i in range(1, n + 1): replacement = \\"\\" for number, replacement_string in rules: if i % number == 0: replacement += replacement_string output.append(replacement if replacement else i) return output"},{"question":"Design and Implement a Resizable Hash Table with Quadratic Probing **Objective**: Implement a resizable hash table that resolves collisions using quadratic probing instead of linear probing to mitigate clustering. # Details 1. **Class Name**: `QuadraticProbingHashTable` 2. **Inheritance**: This class should inherit from `ResizableHashTable`. # Method Specifications 1. **Constructor**: Create new instances initializing with a default size. 2. **put(key, value)**: Modify this method to use quadratic probing during insertion. 3. **get(key)**: Adjust this method to utilize quadratic probing while searching. 4. **del_(key)**: Alter this method to implement quadratic probing during deletion. # Input and Output Format - **put(key, value)**: - Input: - `key` (int): The key to be inserted (or updated). - `value` (any): The value associated with the key. - Output: None. Inserts the key-value pair into the hash table. - **get(key)**: - Input: - `key` (int): The key to be retrieved. - Output: The value associated with the key, or `None` if the key is not present. - **del_(key)**: - Input: - `key` (int): The key to be deleted. - Output: None. Removes the key-value pair from the hash table. # Constraints: - The hash table should handle integer keys. - Ensure the hash table resizes correctly at load factor of 2/3. - Quadratic probing should be defined as follows: `hash = (hash + i^2) % size`, where `i` is the probe number. # Performance Requirements: - Maintain O(1) average time complexity for `put`, `get`, and `del_` operations. - Ensure efficient resizing with an approximate time complexity of O(n) during the resize operation. # Example: ```python ht = QuadraticProbingHashTable() ht.put(10, \'A\') ht.put(21, \'B\') print(ht.get(10)) # Output: \'A\' print(ht.get(21)) # Output: \'B\' ht.del_(10) print(ht.get(10)) # Output: None ``` # Edge Cases: - Handle insertion in a full table. - Ensure deleted slots (marked by `_deleted`) do not cause infinite loops during probing. - Correctly manage duplicate key insertions (overwrites existing values).","solution":"class ResizableHashTable: def __init__(self): self.capacity = 8 # Initial capacity self.size = 0 # Number of elements in the table self.table = [None] * self.capacity self.load_factor_threshold = 2/3 # Load factor threshold for resizing def _hash(self, key): return key % self.capacity def _resize(self): old_table = self.table self.capacity *= 2 self.table = [None] * self.capacity self.size = 0 for entry in old_table: if entry and entry != \'_deleted\': self.put(entry[0], entry[1]) class QuadraticProbingHashTable(ResizableHashTable): def put(self, key, value): if self.size / self.capacity >= self.load_factor_threshold: self._resize() idx = self._hash(key) i = 1 while self.table[idx] is not None and self.table[idx] != \'_deleted\' and self.table[idx][0] != key: idx = (idx + i ** 2) % self.capacity i += 1 if self.table[idx] is None or self.table[idx] == \'_deleted\': self.size += 1 self.table[idx] = (key, value) def get(self, key): idx = self._hash(key) i = 1 while self.table[idx] is not None: if self.table[idx] != \'_deleted\' and self.table[idx][0] == key: return self.table[idx][1] idx = (idx + i ** 2) % self.capacity i += 1 return None def del_(self, key): idx = self._hash(key) i = 1 while self.table[idx] is not None: if self.table[idx] != \'_deleted\' and self.table[idx][0] == key: self.table[idx] = \'_deleted\' self.size -= 1 return idx = (idx + i ** 2) % self.capacity i += 1"},{"question":"# Question: Implement a Combined Heap Sort Algorithm Scenario Assume you are employed in a company that processes large amounts of data for analytical purposes. You need to sort this data efficiently to perform further analysis. You are required to implement a custom sorting function that can use either Max Heap Sort or Min Heap Sort based on the user\'s demand. Task 1. Create a single function named `combined_heap_sort` which takes two parameters: * `arr` (a list of integers) * `heap_type` (a string which can be either `\'max\'` or `\'min\'` indicating the type of heap sort to be used) 2. Depending on `heap_type`, the function should use the corresponding heap functions provided to sort the input array `arr` in ascending order. # Function Signature ```python def combined_heap_sort(arr: List[int], heap_type: str) -> List[int]: ``` # Input * `arr` (List of Integers): The array of integers to be sorted. * `heap_type` (String): A string indicating the type of heap sort to use (`\'max\'` for Max Heap Sort, `\'min\'` for Min Heap Sort). # Output * Returns a new list of integers sorted in ascending order based on the specified heap type. # Constraints * `heap_type` must be either `\'max\'` or `\'min\'`. * Avoid using Python\'s built-in sorting functions. * The input array may contain up to `10^6` elements. # Performance Requirements * Expected to run in O(n log n) time complexity. * Extra space usage should be O(1). Example ```python # Example usage: arr = [4, 10, 3, 5, 1] print(combined_heap_sort(arr, \'max\')) # Output should be [1, 3, 4, 5, 10] arr = [4, 10, 3, 5, 1] print(combined_heap_sort(arr, \'min\')) # Output should be [1, 3, 4, 5, 10] ```","solution":"def combined_heap_sort(arr, heap_type): Sorts an array using either max heap sort or min heap sort based on heap_type. def heapify(arr, n, i, max_heap): largest_or_smallest = i left = 2 * i + 1 right = 2 * i + 2 if max_heap: if left < n and arr[left] > arr[largest_or_smallest]: largest_or_smallest = left if right < n and arr[right] > arr[largest_or_smallest]: largest_or_smallest = right else: if left < n and arr[left] < arr[largest_or_smallest]: largest_or_smallest = left if right < n and arr[right] < arr[largest_or_smallest]: largest_or_smallest = right if largest_or_smallest != i: arr[i], arr[largest_or_smallest] = arr[largest_or_smallest], arr[i] heapify(arr, n, largest_or_smallest, max_heap) def heap_sort(arr, max_heap): n = len(arr) for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i, max_heap) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0, max_heap) if not max_heap: arr.reverse() max_heap = heap_type == \'max\' heap_sort(arr, max_heap) return arr"},{"question":"Scenario You are working on a real-time analytics system where you need to analyze a stream of numbered events. Each event in the stream is represented by a tuple where the first element is an integer value and the second element is a sign (\'+\' or \'-\') indicating if this value is to be added or subtracted. Your task is to determine if the numbered events in the stream reduce to a single unique non-zero number when accounting for their signs. If so, return that number, otherwise return `None`. Problem Statement Implement the function `one_sparse(array)` that takes a list of tuples `array`, where each tuple consists of an integer and a sign (\'+\' or \'-\'). - **Input**: A list of tuples, where each tuple is of the form (number: int, sign: str). - **Output**: A single integer value if the stream is 1-sparse, otherwise `None`. # Constraints 1. Each value in the tuples will be a non-negative integer. 2. The sign will strictly be either \'+\' or \'-\'. 3. The input list can be empty or have up to 10**4 entries. 4. You may assume 32-bit integers for value processing. # Function Signature ```python def one_sparse(array: List[Tuple[int, str]]) -> Optional[int]: pass ``` # Example ```python # Example 1: input_array = [(4,\'+\'), (2,\'+\'),(2,\'-\'),(4,\'+\'),(3,\'+\'),(3,\'-\')] # Output: 4 # Example 2: input_array = [(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\')] # Output: 2 # Example 3: input_array = [(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(1,\'+\')] # Output: None ``` Notes - Ensure your implementation correctly uses bitwise operations to track the contributions of different values. - Pay careful attention to edge cases as listed in the analysis. - Efficiency in both time and space is crucial given the potential size of the input stream.","solution":"from typing import List, Tuple, Optional def one_sparse(array: List[Tuple[int, str]]) -> Optional[int]: # Dictionary to count occurrences of each number counter = {} for number, sign in array: if sign == \'+\': if number in counter: counter[number] += 1 else: counter[number] = 1 elif sign == \'-\': if number in counter: counter[number] -= 1 # Remove the number from counter if its count becomes zero if counter[number] == 0: del counter[number] else: counter[number] = -1 # Only return the number if there is exactly one number left with a non-zero count if len(counter) == 1: for key in counter: if counter[key] != 0: return key return None"},{"question":"In graph theory, a *strongly connected component* (SCC) of a directed graph is a maximal subset of vertices such that every vertex in the subset is reachable from every other vertex in the subset. A graph is said to be *strongly connected* if every vertex is part of a single SCC. Your task is to implement a function to determine whether a given graph is strongly connected. Function Signature ```python def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: \'\'\' Determine if the directed graph is strongly connected. Parameters: - vertex_count: An integer representing the number of vertices in the graph. - edges: A list of tuples, where each tuple (u, v) represents a directed edge from vertex u to vertex v. Returns: - A boolean value indicating whether the graph is strongly connected or not. \'\'\' ``` Input * `vertex_count`: An integer, `1 <= vertex_count <= 1000`, representing the number of vertices in the graph. * `edges`: A list of tuples, each `(u, v)` where `0 <= u, v < vertex_count`, indicating a directed edge from vertex `u` to vertex `v`. The number of edges `E` is such that `0 <= E <= 10000`. Output * Return `True` if the graph is strongly connected, otherwise return `False`. Constraints * The graph does not contain any self-loops (edges from a vertex to itself). * There are no duplicate edges. Example ```python print(is_strongly_connected(5, [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4), (4, 1)])) # Output: True print(is_strongly_connected(4, [(0, 1), (1, 2), (2, 0), (2, 3)])) # Output: False ``` Additional Context In your implementation, you should create a Graph class similar to the one provided, with methods to perform DFS, reverse the graph, and check for strong connectivity. You will utilize the properties of DFS and graph inversion to achieve the solution efficiently.","solution":"from typing import List, Tuple def dfs(graph: List[List[int]], v: int, visited: List[bool]): Depth first search stack = [v] while stack: node = stack.pop() if not visited[node]: visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: stack.append(neighbor) def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: # Create the adjacency list for the original graph graph = [[] for _ in range(vertex_count)] for u, v in edges: graph[u].append(v) # Step 1: Do a DFS from any vertex. We\'ll choose vertex 0. visited = [False] * vertex_count dfs(graph, 0, visited) # If any vertex is not visited, the graph is not strongly connected if not all(visited): return False # Step 2: Create the transpose of the graph transposed_graph = [[] for _ in range(vertex_count)] for u, v in edges: transposed_graph[v].append(u) # Step 3: Do a DFS on the transposed graph from the same vertex visited = [False] * vertex_count dfs(transposed_graph, 0, visited) # If any vertex is not visited in the transposed graph, it\'s not strongly connected return all(visited)"},{"question":"# Quick Sort in Practice Problem Statement: Implement a function `quick_sort(arr)` that sorts an array using the Quick Sort algorithm. Additionally, implement a simulation feature that prints the state of the array after each partitioning step, to better understand the sorting process. Function Signature: ```python def quick_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` Input: - `arr`: A list of integers that need to be sorted. - `simulation`: A boolean flag (default is False) – when set to True, the function should print the array after each partitioning step. Output: - The function should return a sorted list of integers. Constraints: - All elements in the array are integers. - Size of the array (n): 0 <= n <= 10^5 Requirements: 1. **Partition** the array around a pivot element efficiently. 2. **Print** array after each partition if `simulation` is `True`. 3. Ensure the algorithm works within the given constraints and is optimized for performance where possible. Example Usage: ```python arr = [3, 6, 8, 10, 1, 2, 1] print(quick_sort(arr)) # Output: [1, 1, 2, 3, 6, 8, 10] arr = [3, 6, 8, 10, 1, 2, 1] quick_sort(arr, simulation=True) # Output: # iteration 1 : 1 1 8 10 3 2 6 # iteration 2 : 1 1 2 3 6 10 8 ``` Additional Information: - Approach the problem step-by-step, testing individual components. - Pay attention to edge cases, such as empty arrays and arrays with identical elements. - Think about how to choose a good pivot to avoid worst-case performance. - Consider implementing optimizations like switching to insertion sort for small arrays or using different pivot selection strategies.","solution":"def quick_sort(arr, simulation=False): def _quick_sort(items, low, high, iteration=0): if low < high: p, new_iteration = partition(items, low, high, iteration) _quick_sort(items, low, p, new_iteration) _quick_sort(items, p + 1, high, new_iteration) def partition(items, low, high, iteration): pivot = items[(low + high) // 2] left = low right = high while True: while items[left] < pivot: left += 1 while items[right] > pivot: right -= 1 if left >= right: if simulation: print(f\'iteration {iteration + 1}:\', \' \'.join(map(str, items))) return right, iteration + 1 items[left], items[right] = items[right], items[left] left += 1 right -= 1 if simulation: print(f\'iteration {iteration + 1}:\', \' \'.join(map(str, items))) iteration += 1 if arr: _quick_sort(arr, 0, len(arr) - 1) return arr"},{"question":"# Merge Sort Implementation with Custom Comparison Function Information: Merge Sort is a versatile sorting algorithm with a consistent time complexity of O(n log(n)). It divides the array into smaller subarrays, sorts them individually, and then merges them back together. This task involves implementing the Merge Sort algorithm but with a twist: you need to allow a custom comparison function that determines the order. Task: Write a function `merge_sort_custom` which performs Merge Sort with a custom comparison function provided by the user. Function Signature: ```python def merge_sort_custom(arr: list, compare: callable) -> list: # Function body ``` Parameters: - `arr` (list): A list of elements to be sorted. - `compare` (callable): A comparison function that takes two elements and returns a boolean indicating the order. Returns: - (list): The sorted list. Example: ```python def custom_compare(x, y): return x < y # Standard ascending order arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3] sorted_arr = merge_sort_custom(arr, custom_compare) print(sorted_arr) # Output: [1, 1, 2, 3, 3, 4, 5, 5, 6, 9] ``` Constraints: - Your implementation should handle empty arrays and arrays with a single element. - You must preserve the relative order of equal elements (stability). - The custom comparison function will determine the sorting order. Requirements: - Implement the sorting algorithm using the divide-and-conquer approach. - Do not use any built-in sorting functions. - Ensure efficient handling of memory. Use the given `merge_sort` and `merge` structure as a reference for designing your solution, but adapt it to accommodate the custom comparison function.","solution":"def merge_sort_custom(arr: list, compare: callable) -> list: Performs merge sort on the provided array using the custom comparison function. Parameters: arr (list): The list of elements to be sorted. compare (callable): The comparison function that returns True if the first argument should come before the second. Returns: list: The sorted list. if len(arr) <= 1: return arr def merge(left, right, compare): merged = [] i, j = 0, 0 while i < len(left) and j < len(right): if compare(left[i], right[j]): merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 merged.extend(left[i:]) merged.extend(right[j:]) return merged mid = len(arr) // 2 left = merge_sort_custom(arr[:mid], compare) right = merge_sort_custom(arr[mid:], compare) return merge(left, right, compare)"},{"question":"You are given a large integer ( n ) and an integer ( k ). Using the Rabin-Miller Primality Test, determine whether ( n ) is a probable prime. # Function Signature: ```python def is_prime(n: int, k: int) -> bool: pass ``` # Input: * `n` (integer): The number to be tested for primality (`n >= 2`). * `k` (integer): The number of iterations to run the test to determine the probability of primality. # Output: * Return `True` if ( n ) is most likely prime with a probability of failure `4 ** -k`, otherwise return `False`. # Constraints: * You may assume ( n ) is reasonably large (e.g., up to ( 10^{12} )). * The number of tests ( k ) will be a small positive integer (e.g., ( k leq 10 )). # Example: ```python assert is_prime(17, 5) == True assert is_prime(18, 5) == False ``` # Notes: 1. Ensure to handle edge cases such as small values of ( n ) separately. 2. Optimize the modular exponentiation part effectively. 3. Provide reasons for chosen specific values (e.g., number 2 in range of random witness generation).","solution":"import random def is_prime(n: int, k: int) -> bool: Determine if n is a probable prime using the Rabin-Miller Primality Test. :param n: The number to be tested for primality. :param k: The number of iterations to run the test. :return: True if n is a probable prime, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Decompose (n - 1) = d * 2^r r, d = 0, n - 1 while d % 2 == 0: r += 1 d //= 2 def miller_rabin_test(a): x = pow(a, d, n) if x == 1 or x == n - 1: return True for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return True return False for _ in range(k): a = random.randint(2, n - 2) if not miller_rabin_test(a): return False return True"},{"question":"You are given two sorted linked lists. Your task is to write a function that merges these two linked lists into a single sorted linked list. The merged list should be constructed by alternating between the nodes of the two lists whenever possible. # Function Signature ```python def merge_two_lists_alternate(l1: Node, l2: Node) -> Node: pass ``` # Input * Two linked lists represented by their head nodes `l1` and `l2` where each node consists of: - `val` (integer): value of the node. - `next`: pointer to the next node (or `None` if it is the end of the list). # Output * Return the head node of the new linked list formed by merging the two given lists in an alternating manner. # Constraints * The length of the linked lists is between 0 and 1000. * The linked list nodes contain integer values, and the lists are already sorted in ascending order. # Example ```python Input: 1->3->5, 2->4->6 Output: 1->2->3->4->5->6 Input: 1->2, 3->4->5->6 Output: 1->3->2->4->5->6 Input: None, 1->2->3 Output: 1->2->3 ``` **Note**: Your solution should handle both the iterative and recursive merging strategies, but ensure you maintain the alternating pattern in the resultant merged list.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_lists_alternate(l1: Node, l2: Node) -> Node: if not l1: return l2 if not l2: return l1 # Using two pointers to keep track of nodes in l1 and l2 head = l1 # Starting with the head of l1. p1, p2 = l1, l2 # Alternately merging nodes from l1 and l2 while p1 and p2: temp1 = p1.next temp2 = p2.next p1.next = p2 # Link current node of l1 to current node of l2 if temp1 is None: break # If the end of l1 is reached, we are done p2.next = temp1 # Link current node of l2 to the next node of l1 # Move the pointers forward p1 = temp1 p2 = temp2 return head"},{"question":"# Path Finding in Weighted Graphs You are given a weighted, directed graph represented as an adjacency list where nodes are identified by integers. Write a Python function `dijkstra_shortest_path(graph, start, end)` that finds the shortest path from `start` to `end` using Dijkstra\'s algorithm. Function Signature ```python def dijkstra_shortest_path(graph: Dict[int, Dict[int, int]], start: int, end: int) -> List[int]: ``` Input - `graph`: A dictionary where the keys are node identifiers, and the values are dictionaries with neighboring nodes as keys and edge weights as values. - `start` (int): The starting node identifier. - `end` (int): The destination node identifier. Output - A list of node identifiers representing the shortest path from `start` to `end`. If no path exists, return an empty list. Constraints - The graph will have at most 1,000 nodes and 10,000 edges. - The edge weights are positive integers. Example ```python graph = { 0: {1: 4, 2: 1}, 1: {3: 1}, 2: {1: 2, 3: 5}, 3: {} } start = 0 end = 3 print(dijkstra_shortest_path(graph, start, end)) # Output: [0, 2, 1, 3] ``` Notes - Consider edge cases like graphs with multiple nodes but no edges, or nodes that are isolated. - Ensure your solution handles graphs with cycles and large graphs efficiently. Hints - Use a priority queue to select the next node with the smallest tentative distance. - Keep track of the shortest path tree and backtrack once you reach the destination node.","solution":"import heapq def dijkstra_shortest_path(graph, start, end): # Priority queue to hold nodes to explore pq = [(0, start)] # Dictionary to track shortest known distance to each node distances = {node: float(\'inf\') for node in graph} distances[start] = 0 # Dictionary to track the path taken to each node previous_nodes = {node: None for node in graph} while pq: current_distance, current_node = heapq.heappop(pq) # If we reached the end node, reconstruct the path if current_node == end: path = [] while current_node is not None: path.append(current_node) current_node = previous_nodes[current_node] return path[::-1] # If a shorter path to current_node has already been found, skip this one if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(pq, (distance, neighbor)) # If there is no path to the end node return []"},{"question":"# Question Consider implementing a function `advanced_stutter` that works efficiently for larger stacks. Both `first_stutter` and `second_stutter` implementations provided above duplicate each element in a stack using auxiliary storage (stack or queue). Implement `advanced_stutter` using an approach that minimizes time complexity to O(n) and space complexity to O(1). Objective: Write a function `advanced_stutter` that takes a stack as input and replaces every value in the stack with two occurrences of that value, but with optimized space usage. Specifications: - **Input**: A stack represented by a list of integers, e.g., [3, 7, 1, 14, 9]. - **Output**: The modified stack with each element duplicated, e.g., [3, 3, 7, 7, 1, 1, 14, 14, 9, 9]. Constraints: 1. You can assume non-null input. 2. The space complexity must not exceed O(1), i.e., no additional storage apart from the input stack itself. 3. Time complexity should remain O(n). Example: ```python # Input stack = [3, 7, 1, 14, 9] # Call output_stack = advanced_stutter(stack) # Output print(output_stack) # Should print [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` Additional Notes: Your implementation should consider all test cases (with various elements and sizes) and handle possible edge cases optimally. Reflect on how in-place data manipulation can be efficiently maintained throughout stack operations.","solution":"def advanced_stutter(stack): This function takes a stack (represented as a list) and duplicates each element in place with minimal space overhead. original_length = len(stack) i = 0 while i < original_length * 2: # Duplicate and shift the elements to the right stack.insert(i, stack[i]) i += 2 return stack"},{"question":"You have been given two strings: `text` and `pattern`. Your task is to implement the Rabin-Karp algorithm to find all starting indices of substrings in `text` which match the `pattern`. If no such substring is found, return an empty list. # Function Signature: ```python def find_pattern_indices(text: str, pattern: str) -> List[int]: pass ``` # Input: - `text`: A string which can contain alphabets (both uppercase and lowercase). - `pattern`: A string which can contain alphabets (both uppercase and lowercase). # Output: - A list of integers representing the starting indices of each occurrence of `pattern` in `text`. If no such substring exists, return an empty list. # Constraints: - The length of `text` and `pattern` will be between 1 and 10^5. - You need to handle both uppercase and lowercase characters without case sensitivity. - Optimize for efficiency to handle the upper limits of the input sizes. # Example: ```python assert find_pattern_indices(\\"abracadabra\\", \\"abra\\") == [0, 7] assert find_pattern_indices(\\"abcdefg\\", \\"hij\\") == [] assert find_pattern_indices(\\"aaaaa\\", \\"aa\\") == [0, 1, 2, 3] ``` # Notes: 1. Your implementation should handle case insensitivity, so treating \'A\' and \'a\' as the same character. 2. Ensure that your function efficiently computes the hash values and moves the window over the text to find matches. 3. Consider edge cases such as when the `text` or `pattern` is empty or when `pattern` is longer than `text`.","solution":"from typing import List def find_pattern_indices(text: str, pattern: str) -> List[int]: def calculate_hash(s: str, p: int, m: int) -> int: Calculate the hash value of a string using a base p and modulus m. h = 0 for char in s: h = (h * p + ord(char)) % m return h if len(pattern) == 0 or len(text) == 0 or len(pattern) > len(text): return [] # Constants for hash computation BASE = 256 MODULUS = 10**9 + 7 pattern_length = len(pattern) text_length = len(text) # Preprocess the pattern and text to be case insensitive pattern = pattern.lower() text = text.lower() pattern_hash = calculate_hash(pattern, BASE, MODULUS) current_hash = calculate_hash(text[:pattern_length], BASE, MODULUS) # Precompute the highest base multiplier for rolling hash highest_base = 1 for _ in range(pattern_length - 1): highest_base = (highest_base * BASE) % MODULUS results = [] # Sliding over the text to find matching hashes for i in range(text_length - pattern_length + 1): if current_hash == pattern_hash: if text[i:i + pattern_length] == pattern: results.append(i) if i < text_length - pattern_length: current_hash = (current_hash - ord(text[i]) * highest_base) % MODULUS current_hash = (current_hash * BASE + ord(text[i + pattern_length])) % MODULUS current_hash = (current_hash + MODULUS) % MODULUS # Ensure positive hash value return results"},{"question":"**Problem Statement**: Write a function called `length_of_max_subarray` which not only finds the maximum sum subarray but also returns the length of that subarray. # Input and Output: * **Input**: A list of integers, `array`. * **Output**: A tuple containing two elements: 1. The maximum sum (integer). 2. The length of the subarray contributing to that maximum sum (integer). # Constraints: 1. The array will contain at least one element with a maximum size of 10^6 elements. 2. The array elements are integers in the range of [-10^6, 10^6]. # Function Signature: ```python def length_of_max_subarray(array: List[int]) -> Tuple[int, int]: ``` # Example: ```python array = [1, 2, -3, 4, 5, -7, 23] print(length_of_max_subarray(array)) # Output should be (25, 3) ``` # Explanation: For the given example, the maximum sum subarray is `[4, 5, -7, 23]` with a sum of 25, which spans 4 elements. Thus, the output will be `(25, 4)`. # Note: Make sure your code efficiently handles large inputs and considers edge cases, such as arrays with only negative numbers.","solution":"from typing import List, Tuple def length_of_max_subarray(array: List[int]) -> Tuple[int, int]: max_sum = float(\'-inf\') current_sum = 0 max_length = 0 current_length = 0 for num in array: if current_sum + num > num: current_sum += num current_length += 1 else: current_sum = num current_length = 1 if current_sum > max_sum: max_sum = current_sum max_length = current_length elif current_sum == max_sum: max_length = max(max_length, current_length) return (max_sum, max_length)"},{"question":"You are given a binary tree with the following node definition: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Write a function that converts this binary tree into a doubly linked list in-place. The doubly linked list should be in the same order as an in-order traversal of the binary tree. # Function Signature ```python def convert_bst_to_doubly_linked_list(root: TreeNode) -> TreeNode: pass ``` # Input * A binary tree root node `root` of type `TreeNode`. # Output * The head node of the resultant doubly linked list. # Constraints 1. The number of nodes in the tree is in the range [0, 10^4]. 2. -10^5 <= TreeNode.val <= 10^5 # Example Example 1 ```plaintext Input: 4 / 2 5 / 1 3 Output: 1 <-> 2 <-> 3 <-> 4 <-> 5 ``` Example 2 ```plaintext Input: None Output: None ``` # Requirements * You must not use any additional data structure (e.g., arrays or lists) extensive enough to hold all the nodes. * The doubly linked list should be created in-place. * Thoroughly handle edge cases such as empty trees or trees with only one node. * Aim for an efficient solution, preferably O(n) time complexity.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def convert_bst_to_doubly_linked_list(root: TreeNode) -> TreeNode: if not root: return None def inorder_traversal(node): Performs an in-order traversal of the tree and converts it to a doubly linked list. nonlocal last, head if not node: return # Traverse the left subtree inorder_traversal(node.left) # Process the current node if last: last.right = node node.left = last else: head = node # Initialize head if this is the first node last = node # Update the last processed node # Traverse the right subtree inorder_traversal(node.right) last, head = None, None inorder_traversal(root) return head"},{"question":"You are given a system that needs to encode and decode lists of strings for transmission over a network. Your task is to implement two functions, `encode` and `decode`, that serialize and deserialize the list of strings accurately. # Function Specifications `encode` ```python def encode(strs): Encodes a list of strings to a single string. :param strs: List[str] - A list of strings to encode :return: str - The encoded single string ``` * **Input**: A list of strings `strs`. * **Output**: A single string that consists of the encoded version of the input list of strings. * **Examples**: ```python encode([\\"abc\\", \\"def\\"]) -> \\"3:abc3:def\\" encode([\\"hello\\", \\"world\\"]) -> \\"5:hello5:world\\" ``` `decode` ```python def decode(s): Decodes a single string to a list of strings. :param s: str - The encoded single string :return: List[str] - The decoded list of strings ``` * **Input**: A single encoded string `s`. * **Output**: A list of strings that were encoded in `s`. * **Examples**: ```python decode(\\"3:abc3:def\\") -> [\\"abc\\", \\"def\\"] decode(\\"5:hello5:world\\") -> [\\"hello\\", \\"world\\"] ``` # Constraints * All strings in the input lists contain only printable ASCII characters. * No string has a length greater than 10^4. * The total number of strings will not exceed 10^5. Use the provided code structure and ensure your implementation correctly handles edge cases.","solution":"def encode(strs): Encodes a list of strings to a single string. :param strs: List[str] - A list of strings to encode :return: str - The encoded single string encoded_str = \\"\\".join(f\\"{len(s)}:{s}\\" for s in strs) return encoded_str def decode(s): Decodes a single string to a list of strings. :param s: str - The encoded single string :return: List[str] - The decoded list of strings decoded_list = [] i = 0 while i < len(s): j = s.find(\\":\\", i) length = int(s[i:j]) i = j + 1 decoded_list.append(s[i:i + length]) i += length return decoded_list"},{"question":"# Binary Heap Implementation Tasks As a software engineer specializing in data structures, you\'re asked to complete the implementation of a Min Heap in Python using the provided class structure as a starting point. The specific methods you need to complete are: 1. **insert(val: int) -> None**: - Insert the value `val` into the heap, maintaining the heap property. - Complexity: O(log N) 2. **remove_min() -> int**: - Remove and return the smallest element in the heap, maintaining the heap property. - Complexity: O(log N) 3. **find_kth_smallest(k: int) -> int**: - Find and return the k-th smallest element in the heap without modifying the heap. - Complexity: Should be efficient, ideally O(k log N) # Constraints - `0 <= val <= 10^6` - The heap can contain at most `10^4` elements. - k will always be valid (1 <= k <= current_size of heap). # Example ```python heap = BinaryHeap() heap.insert(4) heap.insert(50) heap.insert(7) heap.insert(55) heap.insert(90) heap.insert(87) heap.insert(2) print(heap.remove_min()) # Output: 2 print(heap.search_kth_smallest(3)) # Output: 7 ``` # Function Signature ```python class BinaryHeap: def __init__(self): # Initialization def perc_up(self, i): # Percolate up method def perc_down(self, i): # Percolate down method def min_child(self, i): # Find min child method def insert(self, val: int) -> None: # Insert value into the heap def remove_min(self) -> int: # Remove and return the minimum value def find_kth_smallest(self, k: int) -> int: # Return the k-th smallest value without modifying the heap ``` Write the implementations for `insert()`, `remove_min()`, and `find_kth_smallest()` methods to ensure the binary heap operates correctly and efficiently.","solution":"import heapq class BinaryHeap: def __init__(self): self.heap = [] def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def perc_down(self, i): while (i * 2) <= len(self.heap) - 1: mc = self.min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def min_child(self, i): if i * 2 + 1 > len(self.heap) - 1: return i * 2 else: if self.heap[i * 2] < self.heap[i * 2 + 1]: return i * 2 else: return i * 2 + 1 def insert(self, val: int) -> None: Insert the value `val` into the heap, maintaining the heap property. Complexity: O(log N) self.heap.append(val) heapq.heapify(self.heap) def remove_min(self) -> int: Remove and return the smallest element in the heap, maintaining the heap property. Complexity: O(log N) return heapq.heappop(self.heap) def find_kth_smallest(self, k: int) -> int: Find and return the k-th smallest element in the heap without modifying the heap. Complexity: Should be efficient, ideally O(k log N) return heapq.nsmallest(k, self.heap)[-1]"},{"question":"**Objective**: Implement a function to sort an array using heap sort, and handle potential performance and edge case scenarios effectively. # Scenario You\'ve been hired by a tech firm to develop a sorting utility that can handle large datasets efficiently. The utility should employ heap sort, taking into account the algorithm\'s performance and edge conditions. Your solution needs to be well-optimized, with particular attention to edge cases and error handling. # Problem Statement Write a function `enhanced_heap_sort` that sorts an array in ascending order using heap sort. You should focus on optimizing the heap construction and handling edge cases effectively. Input * A list of integers `arr` which may be empty or contain duplicate values. * A boolean `simulation` which, when set to True, should print each iteration of the array during sorting (useful for debugging and visual understanding). Output * A list of integers sorted in ascending order. Function Signature ```python def enhanced_heap_sort(arr, simulation=False) -> list: pass ``` Constraints * The function should handle arrays of length up to (10^6). * Ensure the sort is in-place with a space complexity of O(1). Performance Requirements * The function should have a time complexity of O(n log n). * Aim to minimize the number of swaps and heapify operations. Example ```python # Example 1 arr = [4, 10, 3, 5, 1] print(enhanced_heap_sort(arr)) # Output: [1, 3, 4, 5, 10] # Example 2 arr = [1, 1, 1, 1, 1] print(enhanced_heap_sort(arr)) # Output: [1, 1, 1, 1, 1] # Example 3 (Edge Case) arr = [] print(enhanced_heap_sort(arr)) # Output: [] # Example 4 (Simulation) arr = [3, 2, 1, 4] enhanced_heap_sort(arr, simulation=True) ``` # Additional Requirements * Implement a helper function `heapify(arr, n, i, is_max_heap, simulation)` within `enhanced_heap_sort` to facilitate heap operations. * Provide comments explaining the core operational steps involved. * Validate the input to handle unexpected scenarios gracefully and mitigate runtime errors.","solution":"def enhanced_heap_sort(arr, simulation=False): def heapify(arr, n, i, simulation): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[largest] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] if simulation: print(f\\"Heapify swapping: {arr}\\") heapify(arr, n, largest, simulation) n = len(arr) if n == 0: return [] # Build a maxheap. for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i, simulation) if simulation: print(f\\"Building heap: {arr}\\") # One by one extract elements for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] if simulation: print(f\\"Heap sort swapping: {arr}\\") heapify(arr, i, 0, simulation) return arr"},{"question":"# Scenario You are working on optimizing a low-level system algorithm where control over individual bits in a binary representation is crucial. You have a function `remove_bit(num, i)` which allows you to remove the bit at a specified position `i` from the binary representation of the integer `num`. # Task Implement the `remove_bit` function following the detailed constraints and requirements below: Function Signature ```python def remove_bit(num: int, i: int) -> int: ``` Input - **num**: A positive integer (0 ≤ num < 2^31). - **i**: An integer representing the position of the bit to be removed (0 ≤ i < number of bits in num). Output - Returns a new integer after removing the bit at the specified position `i` from the binary representation of `num`. Constraints - You cannot use any libraries that simplify bit manipulation (e.g., directly converting to/from binary string representation). - Consider the behavior when attempting to remove a bit outside the current binary length of `num`. - The function should efficiently handle the bit removal in O(1) time complexity. # Examples 1. ```python remove_bit(0b10101, 2) # Output: 0b1001 (9) ``` 2. ```python remove_bit(0b10101, 4) # Output: 0b101 (5) ``` 3. ```python remove_bit(0b10101, 0) # Output: 0b1010 (10) ``` These examples illustrate handling of different positions, including the least significant bit and higher bits, showcasing effective bit manipulation. # Note Write the function in a way that it thoroughly accounts for edge cases and handles incorrect input gracefully. Provide robust error checking and ensure that the logic accurately performs as specified for all valid inputs.","solution":"def remove_bit(num: int, i: int) -> int: Removes the bit at position i from the binary representation of num. Args: - num (int): the integer to remove the bit from. (0 ≤ num < 2^31) - i (int): the position of the bit to be removed. (0 ≤ i < number of bits in num) Returns: - int: the new integer with the bit at position i removed. if num < 0 or num >= (1 << 31): raise ValueError(\\"num must be a non-negative integer less than 2^31.\\") if i < 0 or i >= num.bit_length(): raise ValueError(\\"bit position i is out of range.\\") mask1 = (1 << i) - 1 # Mask all bits lower than i mask2 = num >> (i + 1) << i # Shift right and then mask higher bits and shift left result = (num & mask1) | mask2 # Combine the lower bits and the adjusted higher bits return result"},{"question":"# Scenario You are tasked with developing a system that efficiently processes large batches of data, where each piece of data is represented by a 32-bit unsigned integer. As part of the data preprocessing, you need to reverse the bits of each integer. This transformation is crucial for subsequent stages of the processing pipeline. # Problem Statement Write a function `reverse_bits` that takes an integer `n` (32-bit unsigned integer) and returns the integer that results from reversing the bits of `n`. # Function Signature ```python def reverse_bits(n: int) -> int: pass ``` # Input * `n` (int): A 32-bit unsigned integer (0 <= n <= 2^32 - 1). # Output * `int`: The integer obtained by reversing the bits of the input integer `n`. # Example ```python reverse_bits(43261596) # Returns: 964176192 # Explanation: # 43261596 in binary is 00000010100101000001111010011100 # The reversed bits form 00111001011110000010100101000000, which is 964176192 in decimal. reverse_bits(0) # Returns: 0 # Explanation: # 0 in binary is 00000000000000000000000000000000, which remains the same when reversed. ``` # Constraints * Your solution must run in O(1) time and use O(1) additional space.","solution":"def reverse_bits(n: int) -> int: Reverses the bits of a 32-bit unsigned integer. result = 0 for i in range(32): result = (result << 1) | (n & 1) n >>= 1 return result"},{"question":"# File Path Resolution Scenario: As a backend developer, you need to handle user-provided file paths in a consistent manner for several batch processing scripts. Users can provide these paths in various forms, including relative paths, absolute paths, and user home directory shortcuts (e.g., `~`). Your task is to ensure that these paths get resolved to their absolute form to avoid any path-related issues during script execution. Problem Statement: Write a Python function named `resolve_file_path` that takes a string `file` as input, representing a file path. The function should return the absolute path of the file. If the input path uses a home directory shortcut (`~`), it should be expanded to the full path of the user\'s home directory. The solution should handle typical edge cases and ensure the resulting path is in absolute format. Input Format: - A single string `file`, which is the path to be resolved. Output Format: - A single string, which is the absolute path of the file. Constraints: - The input path might be relative or absolute. - The input path might contain the user directory shortcut (`~`). Example: ```python # Input file = \\"~/documents/test.txt\\" # Output \\"/home/username/documents/test.txt\\" (assuming user\'s home directory is /home/username) # Input file = \\"notes/meeting.md\\" # Output \\"/home/username/current_directory/notes/meeting.md\\" (assuming current directory is /home/username/current_directory) ``` Function Signature: ```python def resolve_file_path(file: str) -> str: pass ``` Note: - You are not required to handle invalid paths or ensure the existence of the file at the resolved path. - Consider the function\'s time complexity and aim to optimize where possible.","solution":"import os def resolve_file_path(file: str) -> str: Resolves the provided file path to an absolute path, expanding the home directory shortcut if used. Parameters: file (str): The file path to resolve. Returns: str: The absolute path of the file. return os.path.abspath(os.path.expanduser(file))"},{"question":"# FizzBuzz Coding Challenge Context FizzBuzz is a classic programming problem used to teach the basics of iteration and conditionals. You are required to implement the function `custom_fizzbuzz` which modifies the traditional FizzBuzz by including additional \\"rulesets\\". This will help assess your ability to adapt and extend simple algorithms for more complex scenarios. Objective Write a function `custom_fizzbuzz(n, ruleset)` that returns a list of numbers from 1 to n following FizzBuzz rules, where the `ruleset` parameter allows additional or modified rules. Function Signature: ```python def custom_fizzbuzz(n: int, ruleset: dict) -> list: ``` Parameters - `n` (int): A positive integer greater than or equal to 1. - `ruleset` (dict): A dictionary where keys are integers and values are strings. If a number is divisible by the key, its output should be the corresponding string value. Example Input: ```python n = 15 ruleset = {3: \\"Fizz\\", 5: \\"Buzz\\", 7: \\"Pop\\"} ``` Example Output: ```python [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', \'Pop\', 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, \'Pop\', \'FizzBuzz\'] ``` Instructions: 1. Validate the input: - Raise a `ValueError` if `n` is less than 1. - Raise a `TypeError` if `n` is None or `ruleset` is not a dictionary. 2. Iterate from 1 through n. 3. For each number, determine its output based on the following: - If the number is divisible by multiple rule keys, concatenate their corresponding values (e.g., if divisible by 3 and 5, concatenate \\"Fizz\\" and \\"Buzz\\"). - If not divisible by any key, use the number itself. 4. Store results in a list and return it at the end. Constraints: - You may assume `n` will never be less than 1 in the real usage of the function, but handle invalid cases appropriately. - The ruleset can have multiple keys and values, and should correctly handle conjunctions (like \\"FizzBuzz\\" for 15). Notes: - Ensure your implementation handles edge cases such as an empty ruleset. - Pay attention to the order of concatenation based on the keys in the ruleset.","solution":"def custom_fizzbuzz(n: int, ruleset: dict) -> list: Returns a list of numbers from 1 to n following modified FizzBuzz rules with the ruleset parameter that maps divisors to their string values. Parameters: - n (int): A positive integer greater than or equal to 1. - ruleset (dict): A dictionary where keys are integers and values are strings. Returns: - list: A list of numbers and/or strings based on the custom ruleset. Raises: - ValueError: If n is less than 1. - TypeError: If n is None or ruleset is not a dictionary. if not isinstance(n, int) or n < 1: raise ValueError(\\"The input \'n\' must be a positive integer greater than or equal to 1.\\") if not isinstance(ruleset, dict): raise TypeError(\\"The input \'ruleset\' must be a dictionary.\\") result = [] for i in range(1, n + 1): current_output = \\"\\" for key in sorted(ruleset.keys()): if i % key == 0: current_output += ruleset[key] if current_output == \\"\\": current_output = i result.append(current_output) return result"},{"question":"Context You are given an array of integers and your task is to sort this array in ascending order using a specific sorting algorithm, Selection Sort. This algorithm works by repetitively finding the minimum element from the unsorted part of the array and placing it at the beginning. Task Implement the function `optimized_selection_sort(arr)` that sorts an array of integers in ascending order using the Selection Sort algorithm. Your implementation should also include improvements to early termination if the array becomes sorted before all iterations finish. Function Signature ```python def optimized_selection_sort(arr: List[int]) -> List[int]: pass ``` Input * `arr` (List[int]): A list of integers which can be negative, zero or positive. The length of the list can be up to 10^4. Output * Returns a sorted list of integers in ascending order. Constraints * Aim to minimize the number of operations compared to the traditional Selection Sort if possible. * The implementation should handle edge cases such as an empty array or an already sorted array efficiently. Performance * The algorithm must be correctly implemented with a time complexity of O(n^2) but aims to handle already sorted arrays more efficiently. * Space complexity should remain O(1). Example ```python # Example 1 input = [64, 25, 12, 22, 11] output = optimized_selection_sort(input) print(output) # Output should be [11, 12, 22, 25, 64] # Example 2 input = [3, 1, 2, 1, 2, 4, 5] output = optimized_selection_sort(input) print(output) # Output should be [1, 1, 2, 2, 3, 4, 5] # Example 3 input = [1, 2, 3, 4, 5] output = optimized_selection_sort(input) print(output) # Output should be [1, 2, 3, 4, 5] ``` Notes * You might want to add a check to terminate early if the array gets sorted before the end of all iterations.","solution":"from typing import List def optimized_selection_sort(arr: List[int]) -> List[int]: Sorts an array of integers in ascending order using an optimized Selection Sort algorithm. n = len(arr) for i in range(n): min_idx = i is_sorted = True for j in range(i + 1, n): if arr[j] < arr[min_idx]: min_idx = j is_sorted = False if arr[j] < arr[j - 1]: is_sorted = False # Swap the found minimum element with the first element arr[i], arr[min_idx] = arr[min_idx], arr[i] # If the array is already sorted, break early if is_sorted: break return arr"},{"question":"You are required to implement a data structure called `RandomizedSet` that simulates a set allowing for average O(1) time complexity for common operations. Specifically, you need to implement three methods for this data structure: `insert`, `remove`, and `random_element`. # Function Signatures ```python class RandomizedSet: def __init__(self): pass def insert(self, val: int) -> bool: pass def remove(self, val: int) -> bool: pass def random_element(self) -> int: pass ``` # Methods 1. **`__init__`**: - Initializes the data structure with an empty data set. 2. **`insert(self, val: int) -> bool`**: - Inserts an element `val` into the set if it is not already present. - Returns `True` if the element was successfully inserted, `False` otherwise. 3. **`remove(self, val: int) -> bool`**: - Removes an element `val` from the set if it is present. - Returns `True` if the element was successfully removed, `False` otherwise. 4. **`random_element(self) -> int`**: - Returns a random element from the set. - If the set is empty, raises an exception. # Input and Output Formats - **`insert(val)`**: - Input: An integer `val` to be inserted into the set. - Output: A boolean indicating success or failure. - **`remove(val)`**: - Input: An integer `val` to be removed from the set. - Output: A boolean indicating success or failure. - **`random_element()`**: - Input: None - Output: An integer randomly selected from the current set elements. # Constraints - All input elements for `val` are integers. - Ensure that if the set is empty, calling `random_element` should appropriately handle the exception. # Task Implement the `RandomizedSet` class with the methods as described and ensure they achieve the average O(1) time complexity requirement. Additionally, focus on handling the edge cases gracefully and ensuring robustness. # Example ```python # Example Usage: rset = RandomizedSet() print(rset.insert(1)) # Output: True print(rset.insert(1)) # Output: False print(rset.insert(2)) # Output: True print(rset.remove(1)) # Output: True print(rset.remove(3)) # Output: False print(rset.random_element()) # Output: 2 (or any element that is randomly selected from the set) ``` Implement your solution within the defined structure and verify its correctness against various test cases.","solution":"import random class RandomizedSet: def __init__(self): self.data = {} self.values = [] def insert(self, val: int) -> bool: if val in self.data: return False self.data[val] = len(self.values) self.values.append(val) return True def remove(self, val: int) -> bool: if val not in self.data: return False last_element = self.values[-1] idx_to_delete = self.data[val] self.values[idx_to_delete] = last_element self.data[last_element] = idx_to_delete self.values.pop() del self.data[val] return True def random_element(self) -> int: if not self.values: raise Exception(\\"Set is empty, no elements to return.\\") return random.choice(self.values)"},{"question":"# Question You are tasked with implementing an extended version of the Atbash cipher that includes only the letters from the English alphabet while retaining the transformation rules between cases (upper and lower case). Additionally, this version should ignore any digits but preserve their positions. Other non-alphabetic characters (e.g., punctuation) should just pass through unchanged. # Function Signature ```python def extended_atbash(s: str) -> str: ``` # Input * A string `s` that can contain alphabetic characters, digits, punctuation, and whitespace. # Output * A string where each alphabetic character from `s` is transformed according to the Atbash cipher, and all other characters (including digits) are left unchanged. # Constraints * The input string `s` can have a length of up to 1000 characters. # Example ```python print(extended_atbash(\\"Hello, World! 123\\")) # Outputs: \\"Svool, Dliow! 123\\" ``` # Notes * Uppercase letters map to their reverse uppercase letters, and lowercase letters map to their reverse lowercase letters. * Digits and punctuation remain unaffected. * Handle mixed content appropriately.","solution":"def extended_atbash(s: str) -> str: def atbash_char(c): if \'A\' <= c <= \'Z\': return chr(ord(\'Z\') - ord(c) + ord(\'A\')) elif \'a\' <= c <= \'z\': return chr(ord(\'z\') - ord(c) + ord(\'a\')) else: return c return \'\'.join(atbash_char(c) for c in s)"},{"question":"**Question:** You have been given the structure of a binary tree. Your task is to implement a function that will determine the maximum depth of this binary tree using a BFS approach. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. # Input: - The input will be the root node of a binary tree. You may assume the binary tree node class is defined as follows: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` # Output: - The function should return an integer representing the maximum depth of the binary tree. # Constraints: - The number of nodes in the tree is at most 10^5. # Performance Requirements: - The time complexity should be O(n), where n is the number of nodes in the tree. - The space complexity should be O(max_width), where max_width is the maximum width of the tree. # Example: Input: ```python tree = TreeNode(10) tree.left = TreeNode(12) tree.right = TreeNode(15) tree.left.left = TreeNode(25) tree.left.left.right = TreeNode(100) tree.left.right = TreeNode(30) tree.right.left = TreeNode(36) ``` Expected Output: ``` 4 ``` (The maximum depth of the tree is 4 as the longest path is 10 -> 12 -> 25 -> 100) # Additional Information: - You may use any standard libraries or data structures which might help you optimally solve the problem. Implement the function below: ```python def max_height(root: TreeNode) -> int: # Your code goes here ```","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_height(root: TreeNode) -> int: if not root: return 0 queue = deque([(root, 1)]) max_depth = 0 while queue: node, depth = queue.popleft() max_depth = max(max_depth, depth) if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return max_depth"},{"question":"Given a list of distinct integers, you are required to implement a function that returns all possible permutations of the list. You should use a recursive approach to solve this problem. Function Signature ```python def find_permutations(nums: List[int]) -> List[List[int]]: # TODO: implement this function ``` Input - `nums`: A list of distinct integers. (1 ≤ len(nums) ≤ 7, -10 ≤ nums[i] ≤ 10) Output - A list of lists, where each inner list is a unique permutation of the input integers. Constraints - The input list is guaranteed to contain distinct integers. - The function should not use any built-in permutation functions from libraries. - Make sure your implementation handles edge cases such as empty list or single-element list. Example ```python assert find_permutations([1, 2, 3]) == [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] assert find_permutations([0, 1]) == [ [0, 1], [1, 0] ] assert find_permutations([1]) == [ [1] ] print(find_permutations([])) # should return [[]] representing that permutation of empty list is empty list itself. ``` Description This problem tests your understanding of recursion as well as your ability to solve combinatorial problems. Make sure your solution is efficient and clean, and consider edge cases (like empty or single-element lists). The given constraints require the solution to handle up to 7 elements, so your implementation should manage up to 5040 permutations efficiently within the provided limits.","solution":"from typing import List def find_permutations(nums: List[int]) -> List[List[int]]: if len(nums) == 0: return [[]] elif len(nums) == 1: return [nums] result = [] for i in range(len(nums)): num = nums[i] rem_nums = nums[:i] + nums[i+1:] for perm in find_permutations(rem_nums): result.append([num] + perm) return result"},{"question":"You are given a directed network graph where each edge has a positive integer capacity. Your task is to compute the maximum flow from the source node to the sink node using one of the algorithms discussed: Ford-Fulkerson, Edmonds-Karp, or Dinic\'s algorithm. # Input: - The graph is represented as a matrix `capacity` with ( n times n ) dimensions, where ( n ) is the number of vertices. - `capacity[i][j]` represents the capacity of the edge from node ( i ) to node ( j ). - If `capacity[i][j]` is 0, there is no edge from ( i ) to ( j ). - An integer `source` representing the source node. - An integer `sink` representing the sink node. # Output: - Return an integer representing the maximum flow from the source to the sink. # Constraints: - ( n leq 500 ) (Number of vertices) - ( 0 leq capacity[i][j] leq 10^6 ) - The graph is a simple graph (no self-loops, no parallel edges). # Performance Requirements: - Your solution should handle large dense graphs efficiently, preferably in polynomial time. # Example: ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 assert max_flow(capacity, source, sink) == 23 ``` # Implementation: Implement the function `max_flow(capacity, source, sink)` using one of the algorithms discussed. ```python def max_flow(capacity, source, sink): # Your implementation here pass ```","solution":"from collections import deque def bfs(capacity, source, sink, parent): Perform BFS to find a path from source to sink with available capacity. Returns True if a path is found and False otherwise. visited = [False] * len(capacity) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v, cap in enumerate(capacity[u]): if not visited[v] and cap > 0: # If not visited and there\'s capacity parent[v] = u visited[v] = True if v == sink: return True queue.append(v) return False def max_flow(capacity, source, sink): Implementation using the Edmonds-Karp algorithm (BFS based Ford-Fulkerson). n = len(capacity) parent = [-1] * n max_flow = 0 # Augment the flow while there is a path from source to sink while bfs(capacity, source, sink, parent): # Find the maximum flow through the path found. path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, capacity[parent[s]][s]) s = parent[s] # update capacities of the edges and reverse edges along the path v = sink while v != source: u = parent[v] capacity[u][v] -= path_flow capacity[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"Question You are given two non-negative integers represented as strings. Your task is to write a function that adds these two numbers and returns their sum, also represented as a string. You must perform the addition without using any arithmetic operators (`+`, `-`, `*`, `/`). Instead, you should use bitwise operations to achieve this. # Function Signature ```python def add_strings_bitwise(num1: str, num2: str) -> str: ``` # Input * `num1` (String): The first non-negative integer in string format. (1 <= len(num1) <= 10^5) * `num2` (String): The second non-negative integer in string format. (1 <= len(num2) <= 10^5) # Output * A string representing the sum of the two input integers. # Example ```python print(add_strings_bitwise(\\"123\\", \\"456\\")) # Output: \\"579\\" print(add_strings_bitwise(\\"0\\", \\"0\\")) # Output: \\"0\\" print(add_strings_bitwise(\\"1111\\", \\"1111\\"))# Output: \\"2222\\" ``` # Constraints - Your solution should handle very large numbers efficiently within the specified input size. - Leading zeros in the input numbers should be ignored. - Consider edge cases where one of the numbers may be significantly larger in length than the other. - Ensure your function runs efficiently in terms of time and space complexity. # Hint You may find it helpful to repeatedly apply the bitwise addition technique on each pair of digits from right to left, similarly to how you would perform manual addition, but remember to manage carries correctly at each step.","solution":"def add_strings_bitwise(num1: str, num2: str) -> str: Adds two non-negative integers represented as strings using bitwise operations. # Converts strings to integers def str_to_int(s: str) -> int: result = 0 for char in s: result = result * 10 + (ord(char) - ord(\'0\')) return result # Converts integers to strings def int_to_str(n: int) -> str: if n == 0: return \\"0\\" result = [] while n > 0: result.append(chr(n % 10 + ord(\'0\'))) n //= 10 return \'\'.join(reversed(result)) # Bitwise addition using iterative bitwise operations def bitwise_add(a: int, b: int) -> int: while b: carry = a & b a = a ^ b b = carry << 1 return a # Convert string inputs to integers for bitwise operations number1 = str_to_int(num1) number2 = str_to_int(num2) # Get the result of bitwise addition result = bitwise_add(number1, number2) # Convert the result back to a string return int_to_str(result)"},{"question":"Context: Imagine you are developing a low-level system where standard arithmetic operations are restricted. Instead, you must use bitwise operations to compute results. Task: Implement a function to multiply two non-negative integers without using the \'*\' operator. Similar to the provided bitwise addition code snippet, your solution must rely solely on bitwise operations. Function Signature: ```python def multiply(x: int, y: int) -> int: Multiplies two non-negative integers without using the \'*\' operator. Parameters: x (int): Non-negative integer y (int): Non-negative integer Returns: int: The result of multiplying x and y pass ``` Input: * Two non-negative integers, `x` and `y`. Output: * An integer representing the product of `x` and `y`. Constraints: * 0 <= x <= 10^6 * 0 <= y <= 10^6 * Must not use the \'*\' operator. Performance Requirements: * The solution should be efficient with optimal time complexity considering the constraints. * Minimize the use of additional space. Example: ```python assert multiply(3, 5) == 15 assert multiply(0, 7) == 0 assert multiply(4, 6) == 24 assert multiply(1, 1) == 1 assert multiply(7, 8) == 56 assert multiply(123, 456) == 56088 ``` Hints: 1. You may consider adding one of the integers iteratively while treating bit positions like the binary multiplication algorithm. 2. Use shifting and addition (your bitwise add function) to achieve the result.","solution":"def bitwise_add(a, b): while b != 0: carry = a & b a = a ^ b b = carry << 1 return a def multiply(x: int, y: int) -> int: result = 0 while y > 0: if y & 1: result = bitwise_add(result, x) x <<= 1 y >>= 1 return result"},{"question":"# AVL Tree Implementation and Balancing An AVL tree is a self-balancing binary search tree where the difference in heights between left and right subtrees cannot be more than one. The tree maintains its height balance by performing rotations during insertion and deletion operations. Task Implement the following methods of an AVL tree: 1. **Insert (key)**: Inserts a key into the AVL tree. 2. **Rebalance**: Rebalances the AVL tree if the balance factor of any node becomes less than -1 or greater than 1. 3. **Update Heights**: Updates the heights of the nodes in the tree. 4. **Update Balances**: Updates the balance factors of the nodes in the tree. 5. **Rotate Right**: Performs a right rotation. 6. **Rotate Left**: Performs a left rotation. Function Signatures ```python def insert(self, key: int) -> None def re_balance(self) -> None def update_heights(self, recursive=True) -> None def update_balances(self, recursive=True) -> None def rotate_right(self) -> None def rotate_left(self) -> None ``` Expected Input and Output 1. **Insert (key)** - Input: `key` (an integer to be inserted into the AVL tree) - Output: None 2. **Rebalance** - Input: None - Output: None 3. **Update Heights** - Input: `recursive` (a boolean value specifying whether to update heights recursively) - Output: None 4. **Update Balances** - Input: `recursive` (a boolean value specifying whether to update balances recursively) - Output: None 5. **Rotate Right** - Input: None - Output: None 6. **Rotate Left** - Input: None - Output: None Constraints or Limitations - The AVL tree should maintain the balance property after each insertion. - The tree should handle edge cases like duplicate keys and empty trees gracefully. - Ensure that the tree does not enter an infinite loop due to incorrect balance factor calculations. Scenario Imagine you are designing a memory management system where quick insertion, deletion, and search are critical. You choose to use an AVL tree to ensure that the operations remain efficient even as the dataset grows. Implement the required AVL tree methods to facilitate this.","solution":"class AVLNode: def __init__(self, key, parent=None): self.key = key self.left = None self.right = None self.parent = parent self.height = 1 self.balance = 0 class AVLTree: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = AVLNode(key) else: self._insert(self.root, key) self.re_balance() def _insert(self, node, key): if key < node.key: if node.left: self._insert(node.left, key) else: node.left = AVLNode(key, node) else: if node.right: self._insert(node.right, key) else: node.right = AVLNode(key, node) self.update_heights(node) self.update_balances(node) def re_balance(self, node=None): if node is None: node = self.root while node: self.update_heights(node) self.update_balances(node) if node.balance > 1: if node.left.balance < 0: self.rotate_left(node.left) self.rotate_right(node) elif node.balance < -1: if node.right.balance > 0: self.rotate_right(node.right) self.rotate_left(node) node = node.parent def update_heights(self, node, recursive=True): if node: if recursive: if node.left: self.update_heights(node.left) if node.right: self.update_heights(node.right) node.height = 1 + max(self.get_height(node.left), self.get_height(node.right)) def update_balances(self, node, recursive=True): if node: if recursive: if node.left: self.update_balances(node.left) if node.right: self.update_balances(node.right) node.balance = self.get_height(node.left) - self.get_height(node.right) def rotate_right(self, node): new_root = node.left node.left = new_root.right if new_root.right: new_root.right.parent = node new_root.parent = node.parent if node.parent is None: self.root = new_root elif node == node.parent.right: node.parent.right = new_root else: node.parent.left = new_root new_root.right = node node.parent = new_root self.update_heights(node) self.update_balances(node) def rotate_left(self, node): new_root = node.right node.right = new_root.left if new_root.left: new_root.left.parent = node new_root.parent = node.parent if node.parent is None: self.root = new_root elif node == node.parent.left: node.parent.left = new_root else: node.parent.right = new_root new_root.left = node node.parent = new_root self.update_heights(node) self.update_balances(node) def get_height(self, node): if not node: return 0 return node.height"},{"question":"# Context Suppose you are tasked to implement a sort function for a robotic arm in a warehouse, which sorts packages based on their weights quickly and efficiently. Given that the packages stream in dynamically, the sorting algorithm needs to adapt quickly without consuming excessive memory. # Task Implement the Quick Sort algorithm to sort an array of integers representing the weights of packages. Ensure that your implementation handles the following requirements: * Select the pivot for partitioning using the median-of-three method to mitigate the worst-case performance. * Optimize for performance by switching to Insertion Sort for partitions smaller than 10 elements. * Implement the algorithm to be purely in-place with no additional memory allocations. # Function Signature ```python def optimized_quick_sort(arr): Sorts the array of integers in ascending order using an optimized Quick Sort. Parameters: arr: list of int: A list of integers to be sorted. Returns: None: The list is sorted in place. ``` # Constraints * The list may contain up to 10,000 integers. * The integers may range from -10^6 to 10^6. # Example Input: ```python weights = [34, -5, 42, 0, 2000, -2000, 3] ``` Output: ```python # The weights list should be sorted in-place weights = [-2000, -5, 0, 3, 34, 42, 2000] ``` # Notes * Take care to handle edge cases such as an empty array or an array with one element. * Ensure your method switches to Insertion Sort for small subarrays to enhance performance.","solution":"def optimized_quick_sort(arr): def median_of_three(lo, mid, hi): if arr[lo] > arr[mid]: arr[lo], arr[mid] = arr[mid], arr[lo] if arr[lo] > arr[hi]: arr[lo], arr[hi] = arr[hi], arr[lo] if arr[mid] > arr[hi]: arr[mid], arr[hi] = arr[hi], arr[mid] return mid def partition(low, high): mid = (low + high) // 2 pivot_index = median_of_three(low, mid, high) pivot = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] i = low for j in range(low, high): if arr[j] < pivot: arr[i], arr[j] = arr[j], arr[i] i += 1 arr[i], arr[high] = arr[high], arr[i] return i def insertion_sort(low, high): for i in range(low + 1, high + 1): key = arr[i] j = i - 1 while j >= low and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def quick_sort(low, high): if low < high: if high - low < 10: # Use insertion sort for smaller partitions insertion_sort(low, high) else: p = partition(low, high) quick_sort(low, p - 1) quick_sort(p + 1, high) if arr: quick_sort(0, len(arr) - 1)"},{"question":"# Pattern Matching Bijection Problem Given a pattern and a string `str`, you are required to implement a function `pattern_match(pattern, string)` that determines whether `str` follows the same pattern. **Definition**: To follow the same pattern means there should be a full match, such that there is a bijection (one-to-one correspondence) between a letter in the `pattern` and a non-empty substring in `str`. # Example Cases Example 1: - **Input**: - `pattern = \\"abab\\"` - `str = \\"redblueredblue\\"` - **Output**: `True` - **Explanation**: Here, \'a\' maps to \\"red\\" and \'b\' maps to \\"blue\\". Example 2: - **Input**: - `pattern = \\"aaaa\\"` - `str = \\"asdasdasdasd\\"` - **Output**: `True` - **Explanation**: Here, each \'a\' maps to \\"asd\\". Example 3: - **Input**: - `pattern = \\"aabb\\"` - `str = \\"xyzabcxzyabc\\"` - **Output**: `False` - **Explanation**: No consistent mapping from pattern to string makes a full match. # Function Signature ```python def pattern_match(pattern: str, string: str) -> bool: :type pattern: str :type string: str :rtype: bool ``` # Constraints - Both `pattern` and `str` contain only lowercase English letters. - The length of the `pattern` is between 1 and 20. - The length of `str` is between 1 and 100. # Requirements - Your solution should be optimized to handle the worst-case scenarios efficiently. - You may assume valid input is provided, but consider all edge cases. - Performance should be reasonable, you must strive to reduce unnecessary recursive calls. # Tips - Think carefully about the rules of bijection and map accordingly. - Consider using helper functions to assist with recursion and backtracking. - Be vigilant about terminating conditions in your recursive implementation to avoid infinite loops.","solution":"def pattern_match(pattern: str, string: str) -> bool: def backtrack(p_idx, s_idx, p_to_s, s_to_p): # If both the pattern and string are fully traversed if p_idx == len(pattern) and s_idx == len(string): return True # If one is fully traversed but the other isn\'t if p_idx == len(pattern) or s_idx == len(string): return False current_pattern_char = pattern[p_idx] for end in range(s_idx + 1, len(string) + 1): current_substring = string[s_idx:end] if current_pattern_char in p_to_s: if p_to_s[current_pattern_char] == current_substring: if backtrack(p_idx + 1, s_idx + len(current_substring), p_to_s, s_to_p): return True elif current_substring not in s_to_p: p_to_s[current_pattern_char] = current_substring s_to_p[current_substring] = current_pattern_char if backtrack(p_idx + 1, s_idx + len(current_substring), p_to_s, s_to_p): return True del p_to_s[current_pattern_char] del s_to_p[current_substring] return False return backtrack(0, 0, {}, {})"},{"question":"Scenario You are provided with a Binary Search Tree (BST) containing integer values. The task is to evaluate a special sum where each node\'s value is multiplied by its depth in the tree, and then these products are summed. The root node is at depth 1, its children are at depth 2, and so on. Instructions Write a function `depth_sum` that computes and returns this weighted sum for the given BST. You will be provided with a class `Node` for tree nodes and a class `bst` to create and manage the spanning tree. ```python class Node: def __init__(self, data): self.data = data self.left = None self.right = None class bst: def __init__(self): self.root = None def insert(self, val): if self.root is None: self.root = Node(val) else: self._insert(self.root, val) def _insert(self, root, val): if val < root.data: if root.left is None: root.left = Node(val) else: self._insert(root.left, val) else: if root.right is None: root.right = Node(val) else: self._insert(root.right, val) def depth_sum(root): :param root: Root of the binary search tree (Node) :return: Integer representing the weighted sum of all node values by their depth def recur_depth_sum(node, depth): if node is None: return 0 return depth * node.data + recur_depth_sum(node.left, depth + 1) + recur_depth_sum(node.right, depth + 1) return recur_depth_sum(root, 1) ``` Example Given the following BST: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` The weighted sum is calculated as: ``` 1*9 + 2*(6 + 12) + 3*(3 + 8 + 10 + 15) + 4*(7 + 18) = 9 + 2*(18) + 3*(36) + 4*(25) = 9 + 36 + 108 + 100 = 253 ``` Constraints * The number of nodes in the BST will be in the range [1, 1000]. * The value of nodes will be unique integers in the range [-10^4, 10^4]. Performance Requirements Ensure that your solution is efficient and runs within acceptable time limits for the given constraints. **Notes:** - Pay attention to edge cases such as trees with only one node. - Handle unbalanced trees efficiently.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class bst: def __init__(self): self.root = None def insert(self, val): if self.root is None: self.root = Node(val) else: self._insert(self.root, val) def _insert(self, root, val): if val < root.data: if root.left is None: root.left = Node(val) else: self._insert(root.left, val) else: if root.right is None: root.right = Node(val) else: self._insert(root.right, val) def depth_sum(root): :param root: Root of the binary search tree (Node) :return: Integer representing the weighted sum of all node values by their depth def recur_depth_sum(node, depth): if node is None: return 0 return depth * node.data + recur_depth_sum(node.left, depth + 1) + recur_depth_sum(node.right, depth + 1) return recur_depth_sum(root, 1)"},{"question":"# Bit Swap Challenge In this challenge, you are required to implement a function to swap adjacent bits of a given integer. Swapping adjacent bits means that every pair of bits in the binary representation of the integer should be swapped. For example, swapping the bits of the integer `22` (which is `010110` in binary) results in the integer `41` (which is `101001` in binary). Function Signature ```python def swap_pair(num: int) -> int: Swap odd and even bits in an integer with as few instructions as possible. :param num: The integer whose bits are to be swapped. :return: The integer resulting from swapping adjacent bits of the input integer. pass ``` Example ```python print(swap_pair(22)) # Output should be 41 print(swap_pair(10)) # Output should be 5 ``` Constraints 1. The input integer `num` will be between `0` and `2^32 - 1`. 2. You should use bitwise operations to solve the problem. 3. Aim for a solution with O(1) time complexity.","solution":"def swap_pair(num: int) -> int: Swap odd and even bits in an integer with as few instructions as possible. :param num: The integer whose bits are to be swapped. :return: The integer resulting from swapping adjacent bits of the input integer. # Mask all odd bits with the binary number pattern 101010... odd_bits = (num & 0xAAAAAAAA) >> 1 # Mask all even bits with the binary number pattern 010101... even_bits = (num & 0x55555555) << 1 # Combine the shifted bits return odd_bits | even_bits"},{"question":"You are working on a combinatorial calculator, and one of the critical functions is computing the binomial coefficient ( C(n, k) ), representing the number of ways to choose ( k ) elements from a set of ( n ) elements. The binomial coefficient can be defined recursively using the following relationships: [ C(n, 0) = C(n, n) = 1 ] [ C(n, k) = C(n-1, k-1) times frac{n}{k} ] [ C(n, k) = C(n, n-k) text{ (for optimization)} ] Implement the `recursive_binomial_coefficient` function to compute the binomial coefficient using the properties outlined above. Ensure your implementation handles edge cases and optimizes performance for large values of ( n ) and ( k ). # Function Signature ```python def recursive_binomial_coefficient(n: int, k: int) -> int: Computes the binomial coefficient C(n, k) using recursion. Args: - n (int): The size of the set (n >= 0) - k (int): The number of chosen items (0 <= k <= n) Returns: - int: The binomial coefficient C(n, k) Raises: - ValueError: If n < k ``` # Input - **n**: Integer (0 <= n <= 1000) - **k**: Integer (0 <= k <= n) # Output - An integer representing ( C(n, k) ) # Constraints 1. Ensure your solution handles input constraints correctly. 2. Your implementation should be efficient enough to handle larger values within constraints. 3. Handle invalid inputs gracefully by raising an appropriate error.","solution":"def recursive_binomial_coefficient(n: int, k: int) -> int: Computes the binomial coefficient C(n, k) using recursion. Args: - n (int): The size of the set (n >= 0) - k (int): The number of chosen items (0 <= k <= n) Returns: - int: The binomial coefficient C(n, k) Raises: - ValueError: If n < k or if n < 0 or k < 0 if n < 0 or k < 0: raise ValueError(\\"n and k must be non-negative\\") if k > n: raise ValueError(\\"k cannot be greater than n\\") # Apply optimization by using C(n, k) = C(n, n-k) if k > n-k if k > n - k: k = n - k # Base cases if k == 0 or k == n: return 1 # Recursive relation return recursive_binomial_coefficient(n-1, k-1) + recursive_binomial_coefficient(n-1, k)"},{"question":"Scenario You have been hired to help optimize the search operations on a large dataset formatted as a rectangular matrix. The matrix is specifically constructed such that each row and each column is sorted in non-decreasing order. Your task is to write a function that efficiently searches for a specific integer key within the matrix and returns the position if found, or indicates that the key is not present. Problem Statement Write a function `search_in_a_sorted_matrix` that takes the following inputs: - `mat`: A list of lists representing the row-wise and column-wise sorted matrix. - `key`: An integer to be searched within the matrix. The function should return: - A tuple (`row_index`, `column_index`) if the key is found, where `row_index` and `column_index` are zero-based indices. - The string `\'Key not found\'` if the key does not exist in the matrix. Constraints - The matrix can have up to 10,000 rows and 10,000 columns (`1 <= m, n <= 10000`). - The elements within the matrix `mat[i][j]` are integers in the range `-10^9 to 10^9`. Performance Requirements - The solution should run in O(m+n) time complexity. Example ```python def search_in_a_sorted_matrix(mat, key): # Your implementation here # Example usage mat = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 print(search_in_a_sorted_matrix(mat, key)) # Output should be: (1, 2) key = 6 print(search_in_a_sorted_matrix(mat, key)) # Output should be: \'Key not found\' ``` Implement the `search_in_a_sorted_matrix` function as described above.","solution":"def search_in_a_sorted_matrix(mat, key): Searches for a key in a matrix where each row and each column is sorted in non-decreasing order. Args: mat : List of Lists, where each row and column is sorted. key : Integer, the value to search for. Returns: Tuple (row_index, column_index) if the key is found, else \'Key not found\'. if not mat or not mat[0]: return \'Key not found\' rows = len(mat) cols = len(mat[0]) # Start from the top right corner of the matrix row = 0 col = cols - 1 while row < rows and col >= 0: if mat[row][col] == key: return (row, col) elif mat[row][col] > key: col -= 1 else: row += 1 return \'Key not found\'"},{"question":"# Objective You are working on a system that processes network packets. Each packet\'s header contains a 32-bit integer representing various encoded fields. One of these fields requires you to determine how many bits are set to 1 (Hamming weight). To efficiently process these packets in real-time, you must implement an optimal solution using bitwise operations. # Problem Statement Write a function `count_hamming_weight(n: int) -> int` that takes a 32-bit unsigned integer and returns the number of \'1\' bits in its binary representation. # Function Signature ```python def count_hamming_weight(n: int) -> int: pass ``` # Input * An integer `n` that represents a 32-bit unsigned integer (0 ≤ n < 2^32). # Output * An integer representing the number of \'1\' bits in the binary representation of `n`. # Constraints * You must use an iterative approach similar to Brian Kernighan\'s algorithm. * Aim for optimal performance with a time complexity of O(k), where k is the number of 1s in the binary representation of the given number `n`. # Example ```python print(count_hamming_weight(11)) # Output: 3, since 11 in binary is 00000000000000000000000000001011. print(count_hamming_weight(128)) # Output: 1, since 128 in binary is 00000000000000000000000010000000. print(count_hamming_weight(255)) # Output: 8, since 255 in binary is 00000000000000000000000011111111. ``` # Additional Considerations * Ensure your function runs efficiently even if the input `n` has a large number of 1s. * Test your function with edge cases such as the smallest (0) and largest (4294967295) possible unsigned 32-bit integers.","solution":"def count_hamming_weight(n: int) -> int: Returns the number of \'1\' bits in the binary representation of n. count = 0 while n: n &= (n - 1) count += 1 return count"},{"question":"# Symmetric Binary Tree Check: Recursive and Iterative Approaches Scenario: Consider a binary tree where we need to determine if it is symmetric around its center. Symmetry in this context means that the left subtree is a mirror reflection of the right subtree. Problem Statement: Write two functions to check whether a given binary tree is symmetric. 1. **Recursive Approach**: Implement the function `is_symmetric_recursive(root)` that uses recursion. 2. **Iterative Approach**: Implement the function `is_symmetric_iterative(root)` that uses an iterative approach with a stack. Input: * A binary tree represented by its root node. Each node contains an integer value and two pointers/references to its left and right children. Output: * Return `True` if the binary tree is symmetric, otherwise return `False`. Constraints: * The number of nodes in the tree is in the range `[0, 1000]`. * Node values are in the range `[-1000, 1000]`. Example: ```python # Example 1: # Input: root = [1, 2, 2, 3, 4, 4, 3] # Output: True # Example 2: # Input: root = [1, 2, 2, null, 3, null, 3] # Output: False ``` Implementation Details: * You need to handle edge cases such as an empty tree (which should return `True`). * For the iterative approach, use a stack to simulate the recursive traversal manually.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric_recursive(root): def is_mirror(t1, t2): if t1 is None and t2 is None: return True if t1 is None or t2 is None: return False return (t1.val == t2.val) and is_mirror(t1.right, t2.left) and is_mirror(t1.left, t2.right) return is_mirror(root, root) def is_symmetric_iterative(root): if root is None: return True stack = [(root.left, root.right)] while stack: t1, t2 = stack.pop() if t1 is None and t2 is None: continue if t1 is None or t2 is None or t1.val != t2.val: return False stack.append((t1.left, t2.right)) stack.append((t1.right, t2.left)) return True"},{"question":"# Question Context The urban planning department is analyzing the road connectivity within a city. Streets (edges) connect various intersections (nodes). The department wants to understand how many isolated road networks (connected components) exist in the city. Your task is to write a function to count these components using Depth-First Search (DFS). Task Implement the function `count_road_networks(nodes: int, roads: List[Tuple[int, int]]) -> int` that takes: - An integer `nodes` representing the number of intersections. - A list of tuples `roads` where each tuple contains two integers representing the intersections connected by a road. This function should return an integer representing the number of isolated road networks (connected components). # Input - `nodes`: An integer `1 <= nodes <= 1000`, denoting the number of intersections. - `roads`: A list of tuples `0 <= len(roads) <= 5000`, each tuple representing a bidirectional road between two intersections. # Output - Return an integer denoting the number of connected components in the undirected graph. # Constraints - Each road connects exactly two intersections. - Intersections are labeled from 1 through `nodes`. # Example ```python # Example input nodes = 7 roads = [(1, 2), (2, 4), (4, 5), (5, 6), (3, 7)] # Expected output: 2 # Example input nodes = 5 roads = [(1, 2), (2, 3), (3, 4)] # Expected output: 2 ``` # Function Signature ```python from typing import List, Tuple def count_road_networks(nodes: int, roads: List[Tuple[int, int]]) -> int: pass ``` Performance Requirements - Ensure the function runs efficiently within the constraints.","solution":"from typing import List, Tuple def count_road_networks(nodes: int, roads: List[Tuple[int, int]]) -> int: def dfs(node): stack = [node] while stack: current = stack.pop() if not visited[current]: visited[current] = True stack.extend(graph[current]) graph = {i: [] for i in range(1, nodes + 1)} for u, v in roads: graph[u].append(v) graph[v].append(u) visited = [False] * (nodes + 1) components = 0 for node in range(1, nodes + 1): if not visited[node]: dfs(node) components += 1 return components"},{"question":"You are given a binary tree and need to determine its minimum depth. Implement a function that accurately finds this value using multiple methods. **Function Signature**: ```python def find_min_depth(root: TreeNode) -> int ``` # Input: * A single `TreeNode` object `root` representing the root of the binary tree. # Output: * An integer representing the minimum depth of the binary tree. # Constraints: 1. The number of nodes in the binary tree is in the range [0, 10^4]. 2. `-1000 <= Node.val <= 1000` # Example: Given the binary tree as follows: ``` 3 / 9 20 / 15 7 ``` Calling `find_min_depth` on this tree should return `2`. # Requirements: 1. Implement both a recursive depth-first approach and an iterative breadth-first approach to solve the problem. 2. Ensure your solution efficiently handles the edge cases, such as an empty tree or a tree with only one node. 3. Analyze and compare the time and space complexity between the two methods in your comments. # Hints: * Consider how each method handles null nodes and different tree shapes (e.g., unbalanced trees). * Test the function with diverse test cases to ensure reliability.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_min_depth(root: TreeNode) -> int: Finds the minimum depth of a binary tree using both BFS and DFS methods. if not root: return 0 def dfs(node): if not node: return float(\'inf\') if not node.left and not node.right: return 1 return 1 + min(dfs(node.left), dfs(node.right)) def bfs(node): queue = deque([(node, 1)]) while queue: current, depth = queue.popleft() if not current.left and not current.right: return depth if current.left: queue.append((current.left, depth + 1)) if current.right: queue.append((current.right, depth + 1)) return min(dfs(root), bfs(root))"},{"question":"You are given two strings, `haystack` and `needle`. Your task is to implement a function `find_substring(haystack: str, needle: str) -> int` that returns the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. # Input Format: - `haystack`: A string of length n (1 ≤ n ≤ 10^4) - `needle`: A string of length m (1 ≤ m ≤ 10^4) # Output Format: - Return an integer that is the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. # Constraints: - The function should handle cases where `needle` is empty. In such cases, return 0 as specified. - Consider edge cases where `needle` is longer than `haystack`. # Example: ``` Example 1: Input: haystack = \\"hello\\", needle = \\"ll\\" Output: 2 Example 2: Input: haystack = \\"aaaaa\\", needle = \\"bba\\" Output: -1 ``` # Performance Requirements: - The solution should ideally aim to be efficient in terms of time complexity while remaining readable and maintainable. - A solution that improves on the naive O(n*m) complexity is favored, though a correct O(n*m) solution is also acceptable. # Scenario: Imagine you\'re working on a basic text editor feature that allows users to find and highlight a specific word or phrase within a larger document efficiently. Implementing an optimal string search function is crucial for providing a smooth user experience. # Function Signature: ```python def find_substring(haystack: str, needle: str) -> int: # Your code here ```","solution":"def find_substring(haystack: str, needle: str) -> int: Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. If needle is an empty string, returns 0. if not needle: return 0 h_len = len(haystack) n_len = len(needle) if n_len > h_len: return -1 # Iterate through the haystack to find the needle for i in range(h_len - n_len + 1): if haystack[i:i + n_len] == needle: return i return -1"},{"question":"# Question: As a software engineer tasked with implementing a symbolic algebra system, you are to create a simple program that computes the polynomial multiplication as detailed in the given Monomial and Polynomial classes. Your task is to thoroughly test the given Monomial and Polynomial classes by implementing a function that multiplies two given polynomials and returns the simplified polynomial. **Function Signature:** ```python def multiply_polynomials(poly1: Polynomial, poly2: Polynomial) -> Polynomial: ``` # Inputs: * `poly1` (Polynomial): The first polynomial. * `poly2` (Polynomial): The second polynomial. # Outputs: * `Polynomial`: The result of multiplying `poly1` and `poly2`, simplified to remove the zero coefficient terms if any. # Constraints: * Ensure the multiplication handles zero coefficients correctly. * Successfully manage edge cases like empty polynomials or polynomials resulting in just scalar values. * Utilize the provided Monomial and Polynomial classes exclusively for arithmetic operations. # Example: ```python # Example usage p1 = Polynomial([Monomial({1: 1}, 3), Monomial({2: 2}, -1)]) # Represents 3a1 - a2^2 p2 = Polynomial([Monomial({1: 1}, 2), Monomial({2: 1}, 1)]) # Represents 2a1 + a2 result = multiply_polynomials(p1, p2) print(result) # Expected output: Polynomial representing 6a1^2 + 3a1a2 - 2a1a2 - a2^3 ``` # Notes: * The provided implementation uses exact arithmetic with fractions for coefficients. * Using the `Polynomial` and `Monomial` classes correctly handles simplification. **Ensure the output is simplified and that coefficients of zero are dropped.**","solution":"class Monomial: def __init__(self, powers, coefficient): # Example: for 3a1^2 * a2, powers = {1: 2, 2: 1}, coefficient = 3 self.powers = powers self.coefficient = coefficient def __mul__(self, other): if not isinstance(other, Monomial): raise TypeError(\\"Can only multiply by another Monomial\\") result_coefficient = self.coefficient * other.coefficient result_powers = self.powers.copy() for var, power in other.powers.items(): if var in result_powers: result_powers[var] += power else: result_powers[var] = power return Monomial(result_powers, result_coefficient) def __eq__(self, other): if not isinstance(other, Monomial): return False return self.powers == other.powers and self.coefficient == other.coefficient class Polynomial: def __init__(self, monomials): self.monomials = monomials self.simplify() def add_monomials(self, new_monomials): self.monomials.extend(new_monomials) self.simplify() def simplify(self): simplified = {} for monomial in self.monomials: key = frozenset(monomial.powers.items()) if monomial.coefficient == 0: continue if key in simplified: simplified[key].coefficient += monomial.coefficient else: simplified[key] = Monomial(monomial.powers, monomial.coefficient) self.monomials = [m for m in simplified.values() if m.coefficient != 0] def __mul__(self, other): if not isinstance(other, Polynomial): raise TypeError(\\"Can only multiply by another Polynomial\\") result_monomials = [] for monomial1 in self.monomials: for monomial2 in other.monomials: result_monomials.append(monomial1 * monomial2) return Polynomial(result_monomials) def __eq__(self, other): return sorted(self.monomials, key=lambda m: (sorted(m.powers.items()), m.coefficient)) == sorted(other.monomials, key=lambda m: (sorted(m.powers.items()), m.coefficient)) def multiply_polynomials(poly1, poly2): return poly1 * poly2"},{"question":"# Linked List Task Scenario You are given the skeleton of a singly linked list node class. Your task is to extend this class and implement a singly linked list with various operations. This exercise is aimed at testing your ability to manipulate linked lists and understand their properties. Task Implement a singly linked list class with the following methods: 1. `append(value)`: Append a node with the given value at the end of the list. 2. `prepend(value)`: Insert a node with the given value at the beginning of the list. 3. `delete(value)`: Delete the first node containing the given value. 4. `find(value)`: Return the node with the given value, or `None` if not found. 5. `to_list()`: Convert the linked list into a Python list and return it. Constraints * Handle edge cases such as operations on an empty list, and ensure proper memory management. * Ensure methods run within optimal time complexity for the given operations. Input and Output * Methods will be called individually with the respective parameters. * The `to_list` method should return a list representation that will be checked for correctness. # Implementation Skeleton Here is a starting structure to guide your implementation: ```python class SinglyLinkedListNode: def __init__(self, value): self.value = value self.next = None class SinglyLinkedList: def __init__(self): self.head = None def append(self, value): # Implement this method pass def prepend(self, value): # Implement this method pass def delete(self, value): # Implement this method pass def find(self, value): # Implement this method pass def to_list(self): # Implement this method pass ```","solution":"class SinglyLinkedListNode: def __init__(self, value): self.value = value self.next = None class SinglyLinkedList: def __init__(self): self.head = None def append(self, value): new_node = SinglyLinkedListNode(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def prepend(self, value): new_node = SinglyLinkedListNode(value) new_node.next = self.head self.head = new_node def delete(self, value): if not self.head: return if self.head.value == value: self.head = self.head.next return current = self.head while current.next and current.next.value != value: current = current.next if current.next: current.next = current.next.next def find(self, value): current = self.head while current: if current.value == value: return current current = current.next return None def to_list(self): result = [] current = self.head while current: result.append(current.value) current = current.next return result"},{"question":"Nth Digit Finder Coding Problem # Objective Write a function to find the nth digit in the sequence of positive integers (1, 2, 3, ...). The sequence concatenates all positive integers into a single string (e.g., \\"1234567891011121314...\\"). # Function Signature ```python def find_nth_digit(n: int) -> int: ``` # Input - `n` (1 <= n <= 2 * 10^9): An integer representing the position of the digit in the sequence. # Output - The function must return an integer which is the nth digit in the sequence. # Description 1. Start by identifying the length of the number (in digits) that contains the nth digit. Initially, the length is 1 (single-digit numbers). 2. Gradually expand the digit length while adjusting the value of `n`. 3. Once the digit length is determined, calculate the exact number within that length range that contains the nth digit. 4. Convert the number to a string and retrieve the digit based on `n`. # Constraints - You should ensure the function runs efficiently for the upper limit of `n`. - Optimize string operations and integer arithmetic to handle large `n` values effectively. # Example ```python print(find_nth_digit(3)) # Output: 3 -> The sequence is \\"123\\", so the 3rd digit is 3. print(find_nth_digit(11)) # Output: 0 -> The sequence is \\"12345678910\\", so the 11th digit is 0. print(find_nth_digit(190)) # Output: 1 -> The 190th digit is from the number \\"99\\", followed by \\"100\\", hence it is 1. ``` # Notes - Include edge case handling for transitions between digit lengths. - The solution should be robust to handle the largest possible values of `n`.","solution":"def find_nth_digit(n: int) -> int: # Initialize the starting parameters length = 1 count = 9 start = 1 # Find the range in which the nth digit lies while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Find the actual number where the digit is located start += (n - 1) // length s = str(start) # Return the specific digit in the number return int(s[(n - 1) % length])"},{"question":"# Resizable Hash Table Implementation Context In this task, you will implement a resizable hash table similar to a dictionary, which can dynamically adjust its size when the load factor exceeds a certain threshold. This ensures that operations like insertion, deletion, and retrieval maintain average O(1) time complexity. Objective You are provided with a partial implementation of a fixed-size hash table. Your task is to complete the implementation by adding a feature to handle resizing dynamically as more data is added, and to implement a new feature to optimize lookups. Core Requirements 1. **Dynamic Resizing**: Implement a method to double the size of the hash table when it is two-thirds full. 2. **Efficient Lookups**: Implement a lookup function that can retrieve multiple keys in one call. # Function to Implement You need to implement the following functions within the `ResizableHashTable` class. 1. **`resize()`**: Double the size of the hash table and rehash all existing keys. 2. **`get_multiple(keys: List[int]) -> List[Any]`**: Return the values for all specified keys in one call. If a key does not exist, return `None` for that key. # Input and Output Formats 1. **`resize()`**: * No input or output. * It internally modifies the size of the hash table. 2. **`get_multiple(keys: List[int]) -> List[Any]`**: * **Input**: `keys` - A list of integer keys. * **Output**: A list of values corresponding to the keys. If a key is not found, include `None` for that key. # Performance Requirements 1. **Time Complexity**: - Average-case O(1) for insertion, deletion, and lookup. 2. **Space Complexity**: - Should handle dynamic resizing within O(n) space complexity where `n` is the number of elements in the hash table. # Contraints 1. `key` is assumed to be an integer. 2. The initial minimum size of the hash table should be 8. Example Usage ```python hash_map = ResizableHashTable() hash_map.put(1, \\"A\\") hash_map.put(2, \\"B\\") hash_map.get_multiple([1, 2, 3]) # Output: [\\"A\\", \\"B\\", None] hash_map.put(3, \\"C\\") ```","solution":"class ResizableHashTable: def __init__(self): self._size = 8 self._count = 0 self._table = [None] * self._size def _hash(self, key): return key % self._size def put(self, key, value): if self._count / self._size >= 2/3: self.resize() index = self._hash(key) while self._table[index] is not None: if self._table[index][0] == key: self._table[index] = (key, value) return index = (index + 1) % self._size self._table[index] = (key, value) self._count += 1 def get(self, key): index = self._hash(key) start_index = index while self._table[index] is not None: if self._table[index][0] == key: return self._table[index][1] index = (index + 1) % self._size if index == start_index: break return None def resize(self): old_table = self._table self._size *= 2 self._table = [None] * self._size self._count = 0 for item in old_table: if item is not None: self.put(item[0], item[1]) def get_multiple(self, keys): return [self.get(key) for key in keys]"},{"question":"**Problem Statement: Regular Expression Matcher** You are given an input string `str_a` and a pattern `str_b`. Implement a function to check whether `str_a` matches the pattern `str_b`. The pattern supports the following special characters: - `.`: Matches any single character. - `*`: Matches zero or more of the preceding elements. The matching should cover the entire input string, meaning that at the end of the matching process, the whole string should be consumed by the pattern. **Function Signature:** ```python bool is_match(const char* str_a, const char* str_b) ``` **Input:** - `str_a`: A non-nullable string (1 ≤ length ≤ 1000). - `str_b`: A non-nullable string pattern containing elements to match against `str_a` (1 ≤ length ≤ 1000). **Output:** - Return `True` if `str_a` matches `str_b`, otherwise return `False`. **Examples:** ```python is_match(\\"aa\\", \\"a\\") -> False is_match(\\"aa\\", \\"aa\\") -> True is_match(\\"aaa\\", \\"aa\\") -> False is_match(\\"aa\\", \\"a*\\") -> True is_match(\\"aa\\", \\".*\\") -> True is_match(\\"ab\\", \\".*\\") -> True is_match(\\"aab\\", \\"c*a*b\\") -> True ``` **Constraints:** - Ensure the function runs efficiently with `O(n * m)` time and space complexity, where `n` is the length of `str_a` and `m` is the length of `str_b`. - Handle all edge cases, including empty string scenarios, patterns ending with `*`, and special characters mixed with regular alphabet characters. **Performance Requirements:** - The solution should be optimized to handle up to the upper constraints within reasonable time and memory limits.","solution":"def is_match(str_a, str_b): Checks if the input string str_a matches the pattern str_b. :param str_a: string :param str_b: pattern string :return: bool # Initialize DP table dp = [[False] * (len(str_b) + 1) for _ in range(len(str_a) + 1)] # Empty pattern matches empty string dp[0][0] = True # Fill the table for patterns with \'*\' for j in range(1, len(str_b) + 1): if str_b[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Fill the DP table for i in range(1, len(str_a) + 1): for j in range(1, len(str_b) + 1): if str_b[j - 1] == \'.\' or str_b[j - 1] == str_a[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif str_b[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] if str_b[j - 2] == \'.\' or str_b[j - 2] == str_a[i - 1] else False) return dp[len(str_a)][len(str_b)]"},{"question":"**Run-Length Encoding/Decoding** You are given a dataset that requires efficient storage. Your task is to implement functions to encode the data using Run-Length Encoding (RLE) and decode it back to its original form. # Function 1: Encode Write a function `encode_rle(input: str) -> str` that takes a string of data and returns its run-length encoded form. **Input**: - `input`: A string containing the original data (0 <= len(input) <= 10^5). **Output**: - A string representing the run-length encoded version of the input. # Function 2: Decode Write a function `decode_rle(input: str) -> str` that takes a run-length encoded string and returns the original data. **Input**: - `input`: A run-length encoded string (properly formatted). **Output**: - A string representing the original data decoded from the encoded input. # Example: ```python input_data = \\"aaabccdddd\\" encoded = encode_rle(input_data) # Expected output: \\"3a1b2c4d\\" decoded = decode_rle(encoded) # Expected output: \\"aaabccdddd\\" ``` # Constraints: - The encode function should handle edge cases and ensure correct encoding for non-repetitive characters. - The decode function should ensure that the input is properly formatted and can be decompressed back to the original string. - Consider performance and optimize to run efficiently for the upper input limits.","solution":"def encode_rle(input: str) -> str: Encode the input string using Run-Length Encoding (RLE). if not input: return \\"\\" encoded = [] count = 1 prev_char = input[0] for char in input[1:]: if char == prev_char: count += 1 else: encoded.append(f\\"{count}{prev_char}\\") prev_char = char count = 1 encoded.append(f\\"{count}{prev_char}\\") return \\"\\".join(encoded) def decode_rle(input: str) -> str: Decode the input string from its Run-Length Encoding (RLE) form. if not input: return \\"\\" decoded = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) else: decoded.append(char * count) count = 0 return \\"\\".join(decoded)"},{"question":"# Shell Sort Implementation and Enhancement Given the Shell Sort algorithm\'s theoretical and practical implications, your task is to implement and enhance this sorting algorithm. # Implementation Tips: 1. Focus on using an optimal gap sequence. 2. Ensure the algorithm is robust against various edge cases. 3. Implement error handling to manage incorrect inputs effectively. # Task: Write a function `enhanced_shell_sort` that takes a list of integers, sorts it in ascending order using the Shell Sort algorithm with Sedgewick’s gap sequence, and returns the sorted list. # Function Signature: ```python def enhanced_shell_sort(arr: List[int]) -> List[int]: ``` # Input: - `arr` (List[int]): A list of integers that may be sorted or unsorted, with lengths up to 10^5. # Output: - Returns the sorted list (List[int]). # Constraints: - You may assume all elements in the list are within the range of 32-bit signed integers. # Performance Requirements: - Aim for a worst-case time complexity better than O(n^2), ideally approaching O(n log(n)), achievable with an optimal gap sequence. # Example: ```python # Example Input arr = [23, 34, 12, 54, 2, 3] # Example Output print(enhanced_shell_sort(arr)) # Output: [2, 3, 12, 23, 34, 54] ``` # Notes: * Basis of enhancement: Implement Sedgewick\'s gap sequence for improved performance. * Address edge cases: such as empty arrays or arrays with a single element. * Handle large inputs efficiently with the aim of enhancing performance. You may test your solution with various input cases to ensure it meets the stated constraints and performance requirements.","solution":"from typing import List def enhanced_shell_sort(arr: List[int]) -> List[int]: def sedgewick_gaps(n): seq = [] k = 0 gap = 1 while gap < n: if k % 2 == 0: gap = 9 * (2 ** k - 2 ** int(k / 2)) + 1 else: gap = 8 * 2 ** k - 6 * 2 ** int((k + 1) / 2) + 1 seq.append(gap) k += 1 return seq[::-1] n = len(arr) gaps = sedgewick_gaps(n) for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Code Assessment: Radix Sort Custom Implementation Objective Given a list of non-negative integers, implement a custom variant of Radix Sort that sorts the list in descending order. Task Requirements 1. Implement a function `custom_radix_sort(arr: List[int]) -> List[int]` that: * Sorts the list using a digit-based sorting technique similar to radix sort. * Produces an output array sorted in descending order. 2. Ensure that the implementation handles typical edge cases, such as: * An empty list. * A list with all identical elements. 3. Performance should be reasonably efficient, considering the typical time complexity of radix sort. Input * A list of non-negative integers, `arr`, of length at most 10,000. Output * A new list where the integers are sorted in descending order. Example ```python # Example 1 input: [170, 45, 75, 90, 802, 24, 2, 66] output: [802, 170, 90, 75, 66, 45, 24, 2] # Example 2 input: [1, 2, 3, 4, 5] output: [5, 4, 3, 2, 1] ``` Ensure your implementation adheres to the constraints and handles edge cases effectively.","solution":"def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[(index % 10)] += 1 for i in range(8, -1, -1): count[i] += count[i + 1] for i in range(n - 1, -1, -1): index = arr[i] // exp output[count[(index % 10)] - 1] = arr[i] count[(index % 10)] -= 1 for i in range(n): arr[i] = output[i] def custom_radix_sort(arr): if len(arr) == 0: return [] max1 = max(arr) exp = 1 while max1 // exp > 0: counting_sort(arr, exp) exp *= 10 return arr"},{"question":"# Radix Sort with Custom Base **Context**: You have been tasked with implementing a version of the radix sort algorithm that sorts an array of non-negative integers but allows for the digits to be interpreted in any arbitrary base `b` (2-10). **Objective**: Write a function `custom_base_radix_sort(arr, base)` that sorts a list of non-negative integers `arr` using the specified `base` and returns the sorted list. **Function Signature**: ```python def custom_base_radix_sort(arr: List[int], base: int) -> List[int]: pass ``` **Input**: * `arr`: List of non-negative integers (1 ≤ |arr| ≤ 10^5, 0 ≤ arr[i] ≤ 10^9). * `base`: Integer, the base in which the digits are to be interpreted (2 ≤ base ≤ 10). **Output**: * Returns a list of integers sorted in ascending order. **Constraints**: * All integers in the input list `arr` are non-negative. * The base value will always be between 2 and 10 inclusive. **Example**: ```python # Example 1 arr = [170, 45, 75, 90, 802, 24, 2, 66] base = 10 print(custom_base_radix_sort(arr, base)) # Output: [2, 24, 45, 66, 75, 90, 170, 802] # Example 2 arr = [13, 1, 7, 20, 5] base = 2 print(custom_base_radix_sort(arr, base)) # Output: [1, 5, 7, 13, 20] ``` **Edge Cases to Consider**: * An empty input list should return an empty list. * Lists where all elements are the same. * Lists with single element. * High or low base values impact on digit extraction and bucket allocation.","solution":"def custom_base_radix_sort(arr, base): if len(arr) == 0: return arr max_value = max(arr) exp = 1 # Exponent to extract digit while max_value // exp > 0: arr = counting_sort_by_digit(arr, exp, base) exp *= base return arr def counting_sort_by_digit(arr, exp, base): n = len(arr) output = [0] * n count = [0] * base # Count occurrences of digits for number in arr: index = (number // exp) % base count[index] += 1 # Change count[i] so it contains the actual final position of this digit in output array for i in range(1, base): count[i] += count[i - 1] # Build the output array by traversing the input array from the end for i in reversed(range(n)): index = (arr[i] // exp) % base output[count[index] - 1] = arr[i] count[index] -= 1 return output"},{"question":"# Scenario You have been assigned to work on a networking tool that maps connections within a computer network. The connections are represented as a singly linked list of nodes, but due to a configuration issue, some connections may form cycles. To ensure network stability, you need to detect any cycles within these connections efficiently. # Task Write a function `is_cyclic(head: Node) -> bool` that determines if a given singly linked list has a cycle in it. # Input * `head`: The head node of the singly linked list. # Output * Return `True` if the linked list contains a cycle, otherwise return `False`. # Constraints * You are not allowed to use any additional data structures (e.g., sets or dictionaries). * The algorithm should run in O(n) time complexity and use O(1) space complexity. # Performance Requirements * The function should handle linked lists with up to 10^5 nodes efficiently. # Examples ```python # Example 1 # Input: head = [3 -> 2 -> 0 -> -4] with a cycle that connects -4 back to 2 # Output: True # Example 2 # Input: head = [1 -> 2] with a cycle that connects 2 back to 1 # Output: True # Example 3 # Input: head = [1] with no cycle # Output: False ``` Implement the function: ```python class Node: def __init__(self, x): self.val = x self.next = None def is_cyclic(head: Node) -> bool: # Your code here pass ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def is_cyclic(head: Node) -> bool: Detect if a singly linked list has a cycle. :param head: The head node of the singly linked list. :return: True if there is a cycle, otherwise False. if not head or not head.next: return False slow = head fast = head.next while fast and fast.next: if slow == fast: return True slow = slow.next fast = fast.next.next return False"},{"question":"# Question Problem Statement You are asked to implement a simple RSA encryption system. Your program will generate RSA keys, encrypt a message using the public key, and decrypt it using the private key. You are provided with template functions, and your task is to complete them, ensuring they handle edge cases appropriately. Implementation Requirements 1. Complete the `generate_key` function to produce valid RSA keys. 2. Implement modular inverse calculation in `modinv` function efficiently. 3. Ensure your functions handle very small and large values correctly. Input * `k` (int) : A positive integer, number of bits in `n`. * `data` (int): A number to be encrypted and decrypted. Constraints * `16 <= k <= 1024` (Key size in bits) Output * Tuple `(n, e, d)` : RSA key components. * `E` (int): Encrypted data. * `D` (int): Decrypted data, which should match the original data. Example ```python n, e, d = generate_key(16) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data print(f\\"Public Key: (n={n}, e={e})\\") print(f\\"Private Key: (d={d})\\") print(f\\"Encrypted: {encrypted}\\") print(f\\"Decrypted: {decrypted}\\") ``` Functions to Implement ```python import random def generate_key(k, seed=None): Generate RSA public and private keys. Args: k : int : Number of bits in the modulus \'n\' Returns: (n, e, d) : Tuple of integers representing the keys. # Your code here def modinv(a, m): Calculate the modular inverse of \'a\' mod \'m\'. Args: a : int : The number to calculate the inverse of. m : int : The modulus. Returns: int : The inverse of \'a\' mod \'m\'. # Your code here def encrypt(data, e, n): Encrypt the data with the public key components. Args: data : int : The data to encrypt. e : int : The public exponent. n : int : The modulus. Returns: int : The encrypted data. return pow(int(data), int(e), int(n)) def decrypt(data, d, n): Decrypt the data with the private key components. Args: data : int : The encrypted data. d : int : The private exponent. n : int : The modulus. Returns: int : The decrypted data. return pow(int(data), int(d), int(n)) ``` Test your code with various values of `data` and key sizes to ensure the robustness of your implementation.","solution":"import random from sympy import isprime, mod_inverse def generate_key(k, seed=None): if seed: random.seed(seed) def get_prime(bits): while True: num = random.getrandbits(bits) if isprime(num): return num e = 65537 half_bits = k // 2 while True: p = get_prime(half_bits) q = get_prime(half_bits) n = p * q if n.bit_length() == k: break phi = (p - 1) * (q - 1) d = mod_inverse(e, phi) return n, e, d def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception(\'Modular inverse does not exist\') else: return x % m def egcd(a, b): if a == 0: return b, 0, 1 g, x1, y1 = egcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return g, x, y def encrypt(data, e, n): return pow(int(data), int(e), int(n)) def decrypt(data, d, n): return pow(int(data), int(d), int(n))"},{"question":"# Question: Reverse Each Word in a String while Preserving Word Order Write a function `reverse_each_word_preserve_order` that takes a string `s` as input and returns a new string where each word in the input string is reversed but the order of the words remains the same. For the purposes of this problem, a word is defined as a sequence of characters separated by spaces. You should handle multiple spaces and punctuation correctly. Also, ensure that your function operates efficiently for large inputs. Function Signature ```python def reverse_each_word_preserve_order(s: str) -> str: pass ``` # Input * A single string `s` where 1 <= len(s) <= 10^5. * The string consists of printable ASCII characters. # Output * A single string where each word in `s` is reversed, but the order of the words is the same. # Constraints * Leading or trailing spaces should be trimmed. * If there are multiple spaces between words, they should be reduced to a single space in the output. # Examples: ```python assert reverse_each_word_preserve_order(\\" hello world \\") == \\"olleh dlrow\\" assert reverse_each_word_preserve_order(\\"Reverse each word in this sentence!\\") == \\"esreveR hcae drow ni siht !ecnetnes\\" assert reverse_each_word_preserve_order(\\" such a lovely day! \\") == \\"hcus a ylevlo !yad\\" ``` # Performance Requirements * The solution should have a time complexity of O(n), where n is the length of the input string. * The space complexity should ideally be O(n).","solution":"def reverse_each_word_preserve_order(s: str) -> str: Given a string s, this function reverses each word within the string while preserving the order of the words. # Split the input string by spaces to handle multiple spaces words = s.split() # Reverse each word in the list of words reversed_words = [word[::-1] for word in words] # Join the reversed words back into a single string with a single space separating each word return \' \'.join(reversed_words)"},{"question":"# Scenario: You are working on a software that generates complex passwords by merging simpler words together. However, to ensure the security and correctness of these passwords, you need to verify if a given password can be formed by interleaving characters from two known words while maintaining their respective order. # Problem: Write a function `is_password_merge(s, part1, part2)` that determines if a string `s` can be formed from two other strings `part1` and `part2`. The characters in `part1` and `part2` must appear in the same order as they are in `s`. # Function Signature: ```python def is_password_merge(s: str, part1: str, part2: str) -> bool: pass ``` # Input: - `s` (string): Target string to be formed by merging `part1` and `part2`. - `part1` (string): First source string that contributes to the final string. - `part2` (string): Second source string that contributes to the final string. # Output: - Return `True` if `s` can be formed by merging `part1` and `part2`. Otherwise, return `False`. # Constraints: - The length of strings `s`, `part1`, and `part2` will be at most 1000. - Characters in `s`, `part1`, and `part2` will be lowercase English letters. # Examples: ```python assert is_password_merge(\\"codewars\\", \\"cdw\\", \\"oears\\") == True assert is_password_merge(\\"codewars\\", \\"cdw\\", \\"oear\\") == False assert is_password_merge(\\"abc\\", \\"abc\\", \\"\\") == True assert is_password_merge(\\"abc\\", \\"\\", \\"abc\\") == True assert is_password_merge(\\"abcde\\", \\"ace\\", \\"bd\\") == True assert is_password_merge(\\"abcd\\", \\"ab\\", \\"cd\\") == True assert is_password_merge(\\"abcd\\", \\"ab\\", \\"dcb\\") == False ```","solution":"def is_password_merge(s, part1, part2): Determines if a string s can be formed by merging part1 and part2. # If the combined length of part1 and part2 does not match the length of s, return False if len(s) != len(part1) + len(part2): return False # Create a DP table to store results of subproblems dp = [[False] * (len(part2) + 1) for _ in range(len(part1) + 1)] # Initialize DP table dp[0][0] = True # Fill the DP table for i in range(len(part1) + 1): for j in range(len(part2) + 1): if i > 0 and s[i + j - 1] == part1[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] if j > 0 and s[i + j - 1] == part2[j - 1]: dp[i][j] = dp[i][j] or dp[i][j - 1] # The answer will be in the bottom-right corner of the table return dp[len(part1)][len(part2)]"},{"question":"# Disjoint Set Forest Using Union-Find Background You’re provided with the code for a Union-Find (or Disjoint Set) data structure, which efficiently supports union and find operations. This structure is employed to solve several real-world problems, including connectivity in networks and clustering. Problem Statement Given a grid of `n` rows and `m` columns where initially all cells are water (`0`), implement a class `IslandCounter` that can efficiently handle the following operations: 1. **AddLand**: Converts water at a specified location into land (`1`). 2. **CountIslands**: Returns the number of islands after each AddLand operation. An island is defined as a group of adjacent lands formed by connecting horizontally or vertically. Diagonal connections do not form part of the same island. Input Format - An integer `n` representing the number of rows in the grid. - An integer `m` representing the number of columns in the grid. - A list of tuples `positions`, where each tuple contains two integers representing the row and column indices for the AddLand operation. Output Format A list of integers, where each integer represents the number of islands after each AddLand operation. Example ```python n = 3 m = 3 positions = [(0, 0), (0, 1), (1, 2), (2, 1)] ``` Constraints - ( 1 leq n, m leq 1000 ) - Each element in positions is unique and valid within the grid bounds. Implementation Requirements - Implement the `IslandCounter` class. - Ensure that all operations are optimized for performance. Expected Methods ```python class IslandCounter: def __init__(self, n, m): pass def addLand(self, row, col): pass def countIslands(self): pass ``` # Example Usage ```python # Initialize the IslandCounter with a grid of size 3x3 counter = IslandCounter(3, 3) results = [] # Each addLand call modifies the grid and subsequent countIslands call retrieves the number of islands for position in [(0, 0), (0, 1), (1, 2), (2, 1)]: counter.addLand(position[0], position[1]) results.append(counter.countIslands()) print(results) # Output should be [1, 1, 2, 3] ```","solution":"class IslandCounter: def __init__(self, n, m): self.n = n self.m = m self.parent = [-1] * (n * m) self.rank = [0] * (n * m) self.count = 0 self.grid = [[0] * m for _ in range(n)] def find(self, i): if self.parent[i] != i: self.parent[i] = self.find(self.parent[i]) # Path compression return self.parent[i] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: # Union by rank if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def addLand(self, row, col): if self.grid[row][col] == 1: return index = row * self.m + col self.parent[index] = index self.count += 1 self.grid[row][col] = 1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for d in directions: newRow, newCol = row + d[0], col + d[1] if 0 <= newRow < self.n and 0 <= newCol < self.m and self.grid[newRow][newCol] == 1: self.union(index, newRow * self.m + newCol) def countIslands(self): return self.count"},{"question":"# Factorial Calculation with Modulo Option # Objective Implement efficient and robust functions to calculate the factorial of a non-negative integer both iteratively and recursively, with an optional module operation. # Problem Description Write two functions, `factorial_iter(n, mod=None)` and `factorial_recur(n, mod=None)`, to calculate the factorial of a non-negative integer ( n ): 1. `factorial_iter(n, mod=None)`: Uses an iterative approach. 2. `factorial_recur(n, mod=None)`: Uses a recursive approach. Each function should compute and return the factorial of ( n ). If `mod` parameter is provided, the function should return ( n! % mod ). # Function Signature ```python def factorial_iter(n: int, mod: int = None) -> int: pass def factorial_recur(n: int, mod: int = None) -> int: pass ``` # Input - ( n ): A non-negative integer (0 ≤ ( n ) ≤ 10^6). - ( mod ): An optional positive integer for the modulo operation (1 ≤ ( mod ) ≤ 10^6). # Output - Return the factorial of ( n ). If `mod` is specified, return ( n! % mod ). # Constraints - ( n ) is a non-negative integer. - When provided, ( mod ) is a positive integer greater than zero. - Both ( n ) and ( mod ) will fit within the constraints mentioned. # Requirements - Implement two functions `factorial_iter` and `factorial_recur`. - Ensure your code handles edge cases and invalid inputs appropriately. # Examples 1. `factorial_iter(5)` - Expected Output: 120 2. `factorial_iter(5, 3)` - Expected Output: 0 (because 120 % 3 = 0) 3. `factorial_recur(0)` - Expected Output: 1 4. `factorial_recur(7, 10)` - Expected Output: 0 (because 5040 % 10 = 0) # Performance Requirements - Ensure that the solutions handle large values of ( n ) efficiently within reasonable time limits.","solution":"def factorial_iter(n: int, mod: int = None) -> int: result = 1 for i in range(2, n + 1): result *= i if mod: result %= mod return result def factorial_recur(n: int, mod: int = None) -> int: if n == 0 or n == 1: return 1 else: result = n * factorial_recur(n - 1, mod) if mod: result %= mod return result"},{"question":"# Scenario You are developing a feature for a statistics software that heavily uses combinatorial mathematics to perform calculations involving binomial coefficients. Since the software process user-defined large datasets, the efficiency of calculation is a priority. # Problem Statement Implement an efficient function to compute the combination `C(n, r)` using memoization to handle large inputs efficiently. # Function Signature ```python def optimized_combination(n: int, r: int) -> int: pass ``` # Input * `n` (0 <= n <= 1000): The total number of items. * `r` (0 <= r <= n): The number of items to choose from the total. # Output * Returns the value of `C(n, r)` which is the number of ways to choose `r` items from `n` items without repetition and without considering order. # Constraints * Inputs will be within the provided range, ensuring integer results. # Requirements * The implementation must use memoization to ensure efficient computation. * The function should return the correct combinatorial value even for larger inputs within range limits. # Examples 1. `optimized_combination(5, 3)` should return `10` 2. `optimized_combination(10, 0)` should return `1` 3. `optimized_combination(100, 50)` should return `100891344545564193334812497256` **Note**: You are not required to handle invalid inputs (like `n < r`) based on the given constraints.","solution":"def optimized_combination(n: int, r: int) -> int: Computes the combination C(n, r) efficiently using memoization. memo = {} def combination(n, r): if r == 0 or r == n: return 1 if (n, r) in memo: return memo[(n, r)] memo[(n, r)] = combination(n - 1, r - 1) + combination(n - 1, r) return memo[(n, r)] return combination(n, r)"},{"question":"# Large Integer Multiplication Given two non-negative integers `num1` and `num2` represented as strings, write a function `multiply(num1: str, num2: str) -> str` that returns the product of `num1` and `num2` as a string. **Constraints**: - The length of both `num1` and `num2` is less than 110. - Both `num1` and `num2` contain only digits 0-9. - Both `num1` and `num2` do not contain any leading zeros (except for the number \\"0\\" itself). - You must not use any built-in BigInteger library or convert the inputs to integers directly. **Performance Requirements**: - The time complexity should not exceed (O(m times n)), where (m) and (n) are the lengths of `num1` and `num2`. - You should efficiently handle string operations to avoid unnecessary overhead. **Examples**: ``` multiply(\\"123\\", \\"456\\") -> \\"56088\\" multiply(\\"99\\", \\"99\\") -> \\"9801\\" multiply(\\"123456789\\", \\"987654321\\") -> \\"121932631112635269\\" ``` **Scenario**: Consider you\'re working on a financial application that handles calculations with extremely large monetary values beyond standard integer storage capacity. Your task is to implement the core multiplication function that must operate on string representations of these large numbers. **Implementation**: Implement the function `multiply(num1: str, num2: str) -> str` to compute the product of the two string numbers. ```python def multiply(num1: str, num2: str) -> str: # Your code here # Test Cases if __name__ == \\"__main__\\": print(multiply(\\"123\\", \\"456\\")) # Expected: \\"56088\\" print(multiply(\\"99\\", \\"99\\")) # Expected: \\"9801\\" print(multiply(\\"123456789\\", \\"987654321\\")) # Expected: \\"121932631112635269\\" print(multiply(\\"1\\", \\"23\\")) # Expected: \\"23\\" print(multiply(\\"0\\", \\"10000\\")) # Expected: \\"0\\" print(multiply(\\"100\\", \\"10000\\"))# Expected: \\"1000000\\" ```","solution":"def multiply(num1: str, num2: str) -> str: if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" len1, len2 = len(num1), len(num2) result = [0] * (len1 + len2) for i in range(len1 - 1, -1, -1): for j in range(len2 - 1, -1, -1): product = (ord(num1[i]) - ord(\'0\')) * (ord(num2[j]) - ord(\'0\')) temp_sum = result[i + j + 1] + product result[i + j + 1] = temp_sum % 10 result[i + j] += temp_sum // 10 # Remove leading zeroes pos = 0 while pos < len(result) and result[pos] == 0: pos += 1 return \'\'.join(map(str, result[pos:]))"},{"question":"# Red-Black Tree Deletion Challenge You are provided with a Red-Black Tree implementation. You are required to implement a function that deletes a node with a specific value from the Red-Black Tree while maintaining all Red-Black Tree properties. # Function Signature ```python def delete_value(rb_tree: RBTree, value: int) -> None: # your code here ``` # Input * `rb_tree`: an instance of `RBTree`. * `value`: an integer value to be deleted from the tree. # Output The function should modify the tree in place. It does not need to return any value. # Constraints * The value to be deleted will exist in the Red-Black Tree. * The tree can have up to 10^5 nodes. # Example Initial Tree: ``` 11(B) / 2(R) 14(B) / 1(B) 7(R) 15(R) / 5(B) 8(B) / 4(R) ``` Function Call: ```python delete_value(rb_tree, 7) ``` Resulting Tree: ``` 11(B) / 2(R) 14(B) / 1(B) 5(R) 15(R) / 4(B) 8(B) ``` # Performance Requirements * The function should operate in O(log n) time complexity for balanced Red-Black Trees. * The space complexity should be O(1), extra space.","solution":"class Node: def __init__(self, value, color, left=None, right=None, parent=None): self.value = value self.color = color # \'R\' for RED, \'B\' for BLACK self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.NIL = Node(0, \'B\') # Sentinel node self.root = self.NIL def search(self, root, key): if root == self.NIL or key == root.value: return root if key < root.value: return self.search(root.left, key) return self.search(root.right, key) def minimum(self, node): while node.left != self.NIL: node = node.left return node def delete_value(self, value): self.delete_node_helper(self.root, value) def delete_node_helper(self, node, key): z = self.NIL while node != self.NIL: if node.value == key: z = node if node.value <= key: node = node.right else: node = node.left if z == self.NIL: print(\\"Couldn\'t find key in the tree\\") return y = z y_original_color = y.color if z.left == self.NIL: x = z.right self.rb_transplant(z, z.right) elif z.right == self.NIL: x = z.left self.rb_transplant(z, z.left) else: y = self.minimum(z.right) y_original_color = y.color x = y.right if y.parent == z: x.parent = y else: self.rb_transplant(y, y.right) y.right = z.right y.right.parent = y self.rb_transplant(z, y) y.left = z.left y.left.parent = y y.color = z.color if y_original_color == \'B\': self.fix_delete(x) def rb_transplant(self, u, v): if u.parent == None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def fix_delete(self, x): while x != self.root and x.color == \'B\': if x == x.parent.left: s = x.parent.right if s.color == \'R\': s.color = \'B\' x.parent.color = \'R\' self.left_rotate(x.parent) s = x.parent.right if s.left.color == \'B\' and s.right.color == \'B\': s.color = \'R\' x = x.parent else: if s.right.color == \'B\': s.left.color = \'B\' s.color = \'R\' self.right_rotate(s) s = x.parent.right s.color = x.parent.color x.parent.color = \'B\' s.right.color = \'B\' self.left_rotate(x.parent) x = self.root else: s = x.parent.left if s.color == \'R\': s.color = \'B\' x.parent.color = \'R\' self.right_rotate(x.parent) s = x.parent.left if s.left.color == \'B\' and s.right.color == \'B\': s.color = \'R\' x = x.parent else: if s.left.color == \'B\': s.right.color = \'B\' s.color = \'R\' self.left_rotate(s) s = x.parent.left s.color = x.parent.color x.parent.color = \'B\' s.left.color = \'B\' self.right_rotate(x.parent) x = self.root x.color = \'B\' def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.NIL: y.left.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.NIL: y.right.parent = x y.parent = x.parent if x.parent == None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y"},{"question":"You are tasked with writing a function that converts an integer to a specified endian byte array format and vice versa, ensuring efficiency and correctness. There are existing implementations to guide you, but your solution should handle very large integers and optimize for performance where possible. # Part 1: Integer to Byte Array Conversion Write a function `int_to_bytes_optimized(num, endian)` that converts an integer `num` into a byte array using the specified `endian` format. Input * `num`: An integer (positive). * `endian`: A string, either `\\"big\\"` or `\\"little\\"`, specifying the endian format. Output * A byte array representing the integer in the specified endian format. Constraints * 0 ≤ `num` ≤ 2^64 - 1 * `endian` will always be `\\"big\\"` or `\\"little\\"`. --- # Part 2: Byte Array to Integer Conversion Write a function `bytes_to_int_optimized(bytestr, endian)` that converts a byte array `bytestr` into an integer using the specified `endian` format. Input * `bytestr`: A byte array. * `endian`: A string, either `\\"big\\"` or `\\"little\\"`, specifying the endian format. Output * An integer represented by the byte array in the specified endian format. Constraints * The byte array will have a length of 0 to 8 bytes. * `endian` will always be `\\"big\\"` or `\\"little\\"`. # Example ```python # Example 1: Integer to Byte Array Conversion print(int_to_bytes_optimized(305419896, \\"big\\")) # Output: b\'x12x34x56x78\' print(int_to_bytes_optimized(305419896, \\"little\\")) # Output: b\'x78x56x34x12\' # Example 2: Byte Array to Integer Conversion print(bytes_to_int_optimized(b\'x12x34x56x78\', \\"big\\")) # Output: 305419896 print(bytes_to_int_optimized(b\'x78x56x34x12\', \\"little\\")) # Output: 305419896 ``` # Notes * You may not use library functions that directly convert integers to bytes or vice versa. * Ensure your code is efficient and readable.","solution":"def int_to_bytes_optimized(num, endian): Converts an integer to a byte array in the specified endian format. Parameters: - num: the integer to convert - endian: a string, either \\"big\\" or \\"little\\" Returns: - A byte array representing the integer in the specified endian format result = [] while num > 0: result.append(num & 0xff) # Extract the least significant byte num >>= 8 # Shift right by 8 bits to get the next byte if not result: result.append(0) # Handle the case when num is 0 if endian == \\"big\\": result.reverse() return bytes(result) def bytes_to_int_optimized(bytestr, endian): Converts a byte array to an integer in the specified endian format. Parameters: - bytestr: the byte array to convert - endian: a string, either \\"big\\" or \\"little\\" Returns: - An integer represented by the byte array in the specified endian format if endian == \\"little\\": bytestr = bytestr[::-1] result = 0 for byte in bytestr: result = (result << 8) | byte return result"},{"question":"# Context You are working as a software developer in a company that deals with large datasets represented as arrays. Often, as part of the data processing pipeline, you need to cyclically rotate arrays to the right. Your team is evaluating various methods for this operation to identify the most efficient approach for different scenarios. # Task Implement a function to rotate an array of `n` elements to the right by `k` steps using different strategies. You will be given a series of test cases to validate the correctness and efficiency of your implementations. **Specifications:** 1. **Function Signature**: ```python def rotate(array: List[int], k: int) -> List[int]: ``` 2. **Input**: * `array`: A list of integers of length `n` (0 <= n <= 10^5) * `k`: An integer (0 <= k <= 10^5) 3. **Output**: * Returns a list representing the array rotated `k` steps to the right. 4. **Constraints**: * Aim for O(n) time complexity. * Try to minimize space complexity where possible. # Examples: 1. Example 1: * Input: `rotate([1, 2, 3, 4, 5, 6, 7], 3)` * Output: `[5, 6, 7, 1, 2, 3, 4]` 2. Example 2: * Input: `rotate([1, 2, 3, 4, 5, 6], 2)` * Output: `[5, 6, 1, 2, 3, 4]` 3. Example 3: * Input: `rotate([1, 2], 3)` * Output: `[2, 1]` # Edge Cases: Test your implementation against these edge cases: * An empty array or an array with one element. * `k` is 0. * `k` is greater than the length of the array (use modulo operation). # Constraints Analysis: * Ensure your function can handle large arrays efficiently. * Optimize memory usage wherever possible. Implement and evaluate your function, considering the time and space complexities for the various approaches.","solution":"from typing import List def rotate(array: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. :param array: A list of integers :param k: Number of steps to rotate the array :return: Rotated array n = len(array) if n == 0: return array k = k % n # To handle cases where k is greater than n return array[-k:] + array[:-k]"},{"question":"# Stack-based Problem: Evaluating Postfix Expressions Problem Statement: Given a postfix expression (also known as Reverse Polish Notation), write a function to evaluate the expression using a stack. The function should support basic arithmetic operations: addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`). Assume the input expression is a string of space-separated tokens. Input Format: * A string `expression` containing a valid postfix expression consisting of integers and the operators `+`, `-`, `*`, `/`. Output Format: * An integer or float value which is the result of the postfix expression evaluation. Constraints: * Each token in the expression is separated by a single space. * Division in the expression should perform floating-point division (`/`). * Valid input expression is guaranteed. Example: ```python expression = \\"3 4 + 2 * 7 /\\" evaluate_postfix(expression) # Output: 2.0 expression = \\"5 1 2 + 4 * + 3 -\\" evaluate_postfix(expression) # Output: 14 ``` # Objective: Implement the function `evaluate_postfix(expression: str) -> float`. Use the Stack ADT implemented via ArrayStack or LinkedListStack to solve the problem. # Function Signature: ```python def evaluate_postfix(expression: str) -> float: pass ``` # Explanation: 1. Parse the `expression` string into tokens. 2. Use a stack to evaluate the expression: * Push operands onto the stack. * When an operator is encountered, pop the requisite number of operands, apply the operator, and push the result back onto the stack. 3. Ensure to handle edge cases such as division by zero appropriately.","solution":"def evaluate_postfix(expression: str) -> float: stack = [] tokens = expression.split() for token in tokens: if token.isdigit() or token.replace(\'.\', \'\', 1).isdigit(): # Handling integer and float tokens stack.append(float(token)) else: operand2 = stack.pop() operand1 = stack.pop() if token == \'+\': stack.append(operand1 + operand2) elif token == \'-\': stack.append(operand1 - operand2) elif token == \'*\': stack.append(operand1 * operand2) elif token == \'/\': stack.append(operand1 / operand2) return stack[0]"},{"question":"You are provided with a linked list data structure. Your task is to implement a function that will check whether a given linked list is sorted in ascending order. You should handle edge cases like empty lists and single-element lists effectively. # Function Signature ```python def is_sorted(head: ListNode) -> bool: pass ``` # Input - `head`: The head node of a singly linked list, where `ListNode` is predefined as: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` # Output - Returns `True` if the list is sorted in ascending order, and `False` otherwise. # Constraints - The number of nodes in the linked list can range from 0 to 10^4. - Each node\'s value will be an integer in the range [-10^5, 10^5]. # Example 1. Input: `(head = None)` - Output: `True` - Explanation: An empty list is considered sorted. 2. Input: ```python head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) ``` - Output: `True` - Explanation: The list is sorted: 1 -> 2 -> 3. 3. Input: ```python head = ListNode(1) head.next = ListNode(3) head.next.next = ListNode(2) ``` - Output: `False` - Explanation: The list is not sorted: 1 -> 3 -> 2. # Notes - You must ensure your solution handles all edge cases, including empty lists and single-element lists. - Aim for an optimal solution in terms of time and space complexity.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head: ListNode) -> bool: Check if the linked list is sorted in ascending order. :param head: ListNode, the head of the singly linked list :return: bool, True if the list is sorted in ascending order, False otherwise if not head or not head.next: return True current = head while current.next: if current.val > current.next.val: return False current = current.next return True"},{"question":"Write a Python function that flattens a nested array of arbitrary depth into a single-dimensional array. Your function should correctly handle all edge cases, and it should perform efficiently. Additionally, implement a generator function that flattens the array, producing elements in a lazy manner. # Input * A nested array, `input_list`, consisting of integers, strings, and other lists. The depth of nesting can be variable and arbitrary. # Output * A one-dimensional list containing all the elements from the nested input array. * A generator that yields each element of the array one by one. # Constraints 1. Strings within the list should not be split. 2. Elements in the final flattened list should maintain their original order. 3. The input array length and nesting depth can be very large. # Example ```python input_list = [1, [2, [3, 4]], [5, [6, 7, [8]], 9], 10] flattened_list(input_list): Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] flattened_generator = flatten_generator(input_list) Output (iteration): 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ``` # Task Implement the following functions: ```python def flatten(input_list): # Implement your code here pass def flatten_generator(input_list): # Implement your code here pass ``` # Note 1. Provide your own test cases that you believe will thoroughly test the functionality of your implementations. 2. Your code should handle deeply nested structures and large amounts of data efficiently.","solution":"def flatten(input_list): Returns a flattened version of the input nested list. result = [] stack = [input_list] while stack: current = stack.pop() if isinstance(current, list): stack.extend(current[::-1]) # reverse to maintain order else: result.append(current) return result def flatten_generator(input_list): A generator that yields elements of the input nested list in a flattened manner. stack = [input_list] while stack: current = stack.pop() if isinstance(current, list): stack.extend(current[::-1]) else: yield current"},{"question":"Problem Statement You are required to implement a function `multiply_matrices` that takes two 2-dimensional matrices (lists of lists) as input and returns their product, if possible. Implement the function to handle the following specifications: 1. **Input Format**: * Two matrices, `matrix1` and `matrix2`, where each matrix is represented as a list of lists of integers. 2. **Output Format**: * A matrix (list of lists of integers), representing the product of `matrix1` and `matrix2`. 3. **Constraints**: * The number of columns in `matrix1` must be equal to the number of rows in `matrix2`. If not, raise an appropriate Exception. * Matrices can be of any size, but they will always be non-empty and have non-zero positive dimensions. 4. **Performance**: * Aim to achieve a straightforward O(n^3) solution as provided, without any external libraries. Function Signature ```python def multiply_matrices(matrix1: list, matrix2: list) -> list: # Your code here pass ``` Example ```python # Example 1 matrix1 = [ [1, 2], [3, 4] ] matrix2 = [ [5, 6], [7, 8] ] print(multiply_matrices(matrix1, matrix2)) # Output: [[19, 22], [43, 50]] # Example 2 matrix1 = [ [2, 3], [0, 1], [4, 1] ] matrix2 = [ [1, 2, 1], [0, 1, 0] ] print(multiply_matrices(matrix1, matrix2)) # Output: [[2, 7, 2], [0, 1, 0], [4, 9, 4]] ``` Notes 1. Ensure your function handles edge cases, such as incompatible dimensions, with proper exception handling. 2. Initialization and multiplication steps should be carefully implemented to match the typical matrix multiplication process.","solution":"def multiply_matrices(matrix1, matrix2): Multiplies two matrices and returns the resultant matrix. :param matrix1: List of lists, representing the first matrix :param matrix2: List of lists, representing the second matrix :return: List of lists, representing the product of the two matrices :raises ValueError: If the matrices have incompatible dimensions rows_matrix1 = len(matrix1) cols_matrix1 = len(matrix1[0]) rows_matrix2 = len(matrix2) cols_matrix2 = len(matrix2[0]) if cols_matrix1 != rows_matrix2: raise ValueError(\\"Incompatible dimensions for matrix multiplication\\") # Resultant matrix will have dimensions rows_matrix1 x cols_matrix2 result = [[0 for _ in range(cols_matrix2)] for _ in range(rows_matrix1)] for i in range(rows_matrix1): for j in range(cols_matrix2): for k in range(cols_matrix1): result[i][j] += matrix1[i][k] * matrix2[k][j] return result"},{"question":"# Scenario You are tasked with implementing a secure but simple encryption system for a basic text messaging app. Due to the simplicity requirements, the Atbash cipher is chosen as the encryption method. The Atbash cipher is a substitution cipher where each letter of the alphabet is mapped to its reverse (i.e., \'a\' becomes \'z\', \'b\' becomes \'y\', and so on). # Task Create a function `atbash(s: str) -> str` that takes a string `s` and returns the string with each letter substituted according to the Atbash cipher rules. Non-alphabetic characters should remain unchanged. # Input and Output Formats * **Input**: A string `s` containing alphabetic and non-alphabetic characters. * **Output**: A string with each alphabetic character substituted and all non-alphabetic characters unchanged. # Constraints * The input string `s` will not contain more than 10^6 characters. * The input string `s` may contain uppercase, lowercase letters, and other symbols. # Examples 1. **Input**: \\"Attack at dawn\\" **Output**: \\"Zggzxp zg wzdm\\" 2. **Input**: \\"Hello, World!\\" **Output**: \\"Svool, Dliow!\\" 3. **Input**: \\"1234!?\\" **Output**: \\"1234!?\\" # Additional Notes * Pay special attention to performance as the input string can be quite large. * Ensure that your solution handles edge cases effectively.","solution":"def atbash(s: str) -> str: Encrypts the input string using the Atbash cipher. Parameters: s (str): The input string containing alphabetic and non-alphabetic characters. Returns: str: The encrypted string with each letter substituted according to the Atbash cipher rules. def substitute(char): if \'a\' <= char <= \'z\': return chr(ord(\'a\') + ord(\'z\') - ord(char)) if \'A\' <= char <= \'Z\': return chr(ord(\'A\') + ord(\'Z\') - ord(char)) return char return \'\'.join(substitute(c) for c in s)"},{"question":"Optimized GCD and LCM Calculator Context You are a developer tasked with enhancing the performance of a numeric utility library. Your goal is to write highly optimized functions for calculating the greatest common divisor (GCD) and the least common multiple (LCM) of given integers. Your functions should also correctly handle edge cases and invalid inputs. Task Implement two functions: 1. `optimized_gcd(a, b)`: - Computes the GCD of two integers `a` and `b` using any efficient algorithm of your choice. 2. `optimized_lcm(a, b)`: - Computes the LCM of two integers `a` and `b` using your `optimized_gcd` function. Requirements * **Input**: - `optimized_gcd(a: int, b: int) -> int` where `a`, `b` are integers (can be negative). - `optimized_lcm(a: int, b: int) -> int` where `a`, `b` are integers (cannot be zero). * **Output**: - `optimized_gcd` should return the greatest common divisor of `a` and `b`. - `optimized_lcm` should return the least common multiple of `a` and `b`. * **Constraints**: - Ensure `optimized_gcd` correctly handles negative values and zero as input, raising appropriate errors when necessary. - Ensure `optimized_lcm` raises an error when either `a` or `b` is zero. Performance - Aim for O(log(min(a, b))) time complexity for `optimized_gcd`. - Aim for O(log(min(a, b))) time complexity for `optimized_lcm` considering it relies on `optimized_gcd`. Example ```python >>> optimized_gcd(54, 24) 6 >>> optimized_gcd(-54, 24) 6 >>> optimized_lcm(54, 24) 216 >>> optimized_lcm(0, 24) Traceback (most recent call last): ... ValueError: Input arguments must be non-zero ```","solution":"def optimized_gcd(a, b): Computes the greatest common divisor (GCD) of two integers a and b. Uses the Euclidean algorithm. Parameters: a (int): first integer b (int): second integer Returns: int: the GCD of a and b while b: a, b = b, a % b return abs(a) def optimized_lcm(a, b): Computes the least common multiple (LCM) of two integers a and b using the GCD. Parameters: a (int): first integer b (int): second integer Returns: int: the LCM of a and b Raises: ValueError: if either a or b is zero if a == 0 or b == 0: raise ValueError(\\"Input arguments must be non-zero\\") return abs(a * b) // optimized_gcd(a, b)"},{"question":"Merging Sorted Linked Lists Problem Statement You are given two linked lists where each node contains an integer value, and the linked lists are sorted in ascending order. Your task is to write a function that merges these two linked lists into a new sorted linked list. Input - Two linked lists `l1` and `l2`, where each linked list node contains an integer value. Output - A singly linked list that contains all the nodes from `l1` and `l2` in sorted order. Function Signature ```python def merge_sorted_linked_lists(l1: Node, l2: Node) -> Node: pass ``` Constraints - Each linked list will have 0 to 10^4 nodes. - Each node\'s value is an integer within the range `[-10^4, 10^4]`. Example ```python # Helper function to create a linked list from a list of values def create_linked_list(values): if not values: return None head = Node(values[0]) current = head for value in values[1:]: current.next = Node(value) current = current.next return head # Helper function to print linked list def print_linked_list(node): while node: print(node.val, end=\\" -> \\") node = node.next print(\\"None\\") l1 = create_linked_list([1, 2, 4]) l2 = create_linked_list([1, 3, 4]) merged_list = merge_sorted_linked_lists(l1, l2) print_linked_list(merged_list) ``` # Expected Output ``` 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> None ``` Performance Requirements - The function should run within O(n + m) time complexity. - Space complexity should be O(1) for the iterative solution or O(n + m) for the recursive solution due to stack usage. Implement the function `merge_sorted_linked_lists` to solve the problem.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sorted_linked_lists(l1: Node, l2: Node) -> Node: # Create a dummy node to serve as the starting point dummy = Node(0) current = dummy # While both linked lists have nodes while l1 is not None and l2 is not None: # Compare the values of the two nodes and take the smaller one if l1.val <= l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next # Move to the next node current = current.next # If there are remaining nodes in l1 or l2, append them if l1 is not None: current.next = l1 else: current.next = l2 # The merged linked list is the next node of the dummy node return dummy.next"},{"question":"# Question: You are given an array that may contain nested arrays of varying depths, and you need to flatten this array into a single-level list. The elements of the array can be numbers, strings, or even other arrays. Your task is to implement the following two functions: 1. **flatten(input_arr: List[Any]) -> List[Any]**: - This function should take a nested list `input_arr` and return a new flattened list. - The function must be able to handle strings correctly by not splitting them into characters. 2. **flatten_iter(iterable: Iterable[Any]) -> Iterator[Any]**: - This function should take a nested iterable `iterable` and return an iterator that yields elements of the single-level output sequentially. You need to implement these functions without using any imported libraries other than `collections.abc.Iterable`. Example ```python # Example usage: input_arr = [1, [2, [3, [4, [5]]]], \'hello\', [6, [\'world\']]] print(flatten(input_arr)) # Output: [1, 2, 3, 4, 5, \'hello\', 6, \'world\'] iterable = [1, [2, [3, [4, \'hello\']]]] print(list(flatten_iter(iterable))) # Output: [1, 2, 3, 4, \'hello\'] ``` # Constraints - **Input array can contain integers, strings, and other arrays.** - **Recursion depth will not exceed Python\'s default recursion limit.** - **Strings should be treated as atomic so that individual characters are not separated.** # Additional Requirements - **Your solution should ensure efficient handling of very large input structures.** - **Handle edge cases like empty arrays gracefully.**","solution":"from collections.abc import Iterable from typing import List, Any, Iterator, Union def flatten(input_arr: List[Any]) -> List[Any]: Flattens a nested list `input_arr` into a single-level list. Args: input_arr (List[Any]): The nested list to flatten. Returns: List[Any]: A new single-level list with all elements. def _flatten(arr: List[Any]) -> List[Any]: for item in arr: if isinstance(item, list): yield from _flatten(item) else: yield item return list(_flatten(input_arr)) def flatten_iter(iterable: Iterable[Any]) -> Iterator[Any]: Flattens a nested iterable `iterable` and yields elements one by one. Args: iterable (Iterable[Any]): The nested iterable to flatten. Returns: Iterator[Any]: An iterator that yields flattened elements. for item in iterable: if isinstance(item, Iterable) and not isinstance(item, (str, bytes)): yield from flatten_iter(item) else: yield item"},{"question":"Context You are tasked with maintaining a list of scores from a set of exams. The scores must remain sorted in ascending order for efficient retrieval and updates. To accomplish this, you need to write a function that inserts each new score into the correct position in the list. Task Using the principles of the binary search algorithm provided, implement a function `insert_and_sort(scores, new_score)` which takes a list of integer scores and an integer `new_score`, and returns a new list with the `new_score` correctly placed while ensuring the list remains sorted. Function Signature ```python def insert_and_sort(scores: List[int], new_score: int) -> List[int]: pass ``` Input * `scores`: A list of integer scores sorted in non-decreasing order. (0 ≤ len(scores) ≤ 10^5) * `new_score`: An integer score to insert. (-10^6 ≤ new_score ≤ 10^6) Output * A new list of integer scores including the `new_score`, sorted in non-decreasing order. Constraints - The list `scores` is guaranteed to be sorted. - The length of the list is up to 100,000 elements. - The score values range from -1,000,000 to 1,000,000. Example ```python assert insert_and_sort([1, 3, 5, 6], 5) == [1, 3, 5, 5, 6] assert insert_and_sort([1, 3, 5, 6], 2) == [1, 2, 3, 5, 6] assert insert_and_sort([1, 3, 5, 6], 7) == [1, 3, 5, 6, 7] assert insert_and_sort([1, 3, 5, 6], 0) == [0, 1, 3, 5, 6] assert insert_and_sort([], 4) == [4] ``` Explanation: - The `insert_and_sort` function should first find the correct index using binary search and then insert the new score at that index while maintaining the order. Notes: - Pay attention to edge cases such as inserting into an empty list or inserting values at the beginning or end of the list. - Ensure your implementation is efficient and can handle the constraints provided.","solution":"from typing import List def insert_and_sort(scores: List[int], new_score: int) -> List[int]: Inserts a new score into the sorted list of scores, maintaining the sorted order. # Binary search to find the correct insertion point left, right = 0, len(scores) while left < right: mid = (left + right) // 2 if scores[mid] < new_score: left = mid + 1 else: right = mid # Insert the new score at the found position return scores[:left] + [new_score] + scores[left:]"},{"question":"# Cooley-Tukey FFT Implementation You are required to implement the Cooley-Tukey Fast Fourier Transform (FFT) algorithm. This algorithm transforms a sequence of complex numbers into their Discrete Fourier Transform (DFT). # Function Signature ```python def fft(x: List[complex]) -> List[complex]: pass ``` # Input - A list `x` of complex numbers representing the sequence to be transformed. - The length of `x` is guaranteed to be a power of 2. # Output - A list of complex numbers representing the DFT of the input sequence. # Constraints - The length of the input list `x` is always a power of 2. - The length of `x` will be between 1 and 2^14 inclusive. # Example ```python # Example 1 input = [2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j] output = fft(input) # Expected Output: [8+8j, 2j, 2-2j, -2+0j] # The result can slightly vary in precision due to floating-point arithmetic. # Example 2 input = [1.0+0j, 2.0+0j, 3.0+0j, 4.0+0j, 5.0+0j, 6.0+0j, 7.0+0j, 8.0+0j] output = fft(input) # Expected Output: [36+0j, -4+9.656854j, -4+4j, -4+1.656854j, -4+0j, -4-1.656854j, -4-4j, -4-9.656854j] # The result can slightly vary in precision due to floating-point arithmetic. ``` # Requirements 1. Implement the function without using any external libraries except standard libraries for complex number manipulations. 2. Ensure the function handles complex numbers accurately. 3. Consider edge cases like input lengths of 1, 2, etc. # Notes - Floating point arithmetic might lead to small differences in precision. - Focus on creating an efficient and accurate implementation.","solution":"from typing import List import cmath def fft(x: List[complex]) -> List[complex]: Performs the Cooley-Tukey FFT algorithm (radix-2 FFT). N = len(x) if N <= 1: return x even_part = fft(x[0::2]) odd_part = fft(x[1::2]) T = [cmath.exp(-2j * cmath.pi * k / N) * odd_part[k] for k in range(N // 2)] return [even_part[k] + T[k] for k in range(N // 2)] + [even_part[k] - T[k] for k in range(N // 2)]"},{"question":"# Question: You are given an array `nums` of size `n` where `n` is an even number, consisting of integers such that exactly two elements appear only once, and all other elements appear exactly twice. Your task is to write a function `find_single_numbers(nums)` that identifies the two elements that appear only once. Your algorithm should have a time complexity of O(N) and a space complexity of O(1). Input: * A list of integers `nums` with length `n`, where (2 leq n leq 10^6). * All integers in the list fit within the range of a 32-bit signed integer. * Exactly two elements in the list appear once, while all other elements appear exactly twice. Output: * A list of two integers `[a, b]`, where `a` and `b` are the two unique elements. The order of the output does not matter. Example: ```python # Example 1 nums = [1, 2, 1, 3, 2, 5] # Output should be [3, 5] or [5, 3] # Example 2 nums = [1, 2, 4, 4, 2, 3] # Output should be [1, 3] or [3, 1] ``` Constraints: 1. You must achieve a time complexity of O(N). 2. You must use only constant extra space, i.e., O(1) space complexity. Function Signature: ```python def find_single_numbers(nums: List[int]) -> List[int]: pass ```","solution":"from typing import List def find_single_numbers(nums: List[int]) -> List[int]: # First pass, get the XOR of the two unique numbers xor = 0 for num in nums: xor ^= num # Get the rightmost set bit (mask) mask = xor & (-xor) # Divide all numbers into two groups and get the XOR of each group a, b = 0, 0 for num in nums: if num & mask: a ^= num else: b ^= num return [a, b]"},{"question":"# Question: Optimized Dijkstra\'s Algorithm Implementation Dijkstra\'s algorithm is a well-known algorithm for finding the shortest paths between nodes in a graph with non-negative edge weights. However, the classic Dijkstra\'s algorithm using an adjacency matrix and array can be inefficient for larger graphs. Task: Your task is to implement an optimized version of Dijkstra\'s algorithm using a priority queue (min-heap) for selecting the vertex with the minimum distance. This change should improve the time complexity of the algorithm. Function Signature: ```python def dijkstra_optimized(graph: List[List[int]], src: int) -> List[int]: pass ``` Input: * `graph`: A list of lists representing a weighted directed graph, where `graph[u][v]` is the weight of the edge from vertex `u` to vertex `v`. If there is no edge, the value is `float(\'inf\')`. * `src`: An integer representing the source vertex. Output: * Returns a list of distances where the distance at index `i` represents the shortest distance from the source vertex to vertex `i`. Constraints: * The graph has `V` vertices where `1 <= V <= 1000`. * The graph\'s weights are non-negative integers. Example: ```python graph = [ [0, 1, 4, float(\'inf\')], [float(\'inf\'), 0, 4, 2], [float(\'inf\'), float(\'inf\'), 0, 3], [float(\'inf\'), float(\'inf\'), float(\'inf\'), 0] ] src = 0 result = dijkstra_optimized(graph, src) print(result) # Output: [0, 1, 4, 3] ``` Notes: * Instead of the adjacency matrix approach, use a priority queue to efficiently get the vertex with the minimum distance. * Consider all vertices and edges in the graph while building the optimized solution. Happy coding!","solution":"import heapq from typing import List def dijkstra_optimized(graph: List[List[int]], src: int) -> List[int]: Implements Dijkstra\'s algorithm using a priority queue for efficient retrieval of the minimum distance vertex. V = len(graph) dist = [float(\'inf\')] * V dist[src] = 0 min_heap = [(0, src)] # (distance, vertex) while min_heap: current_dist, current_vertex = heapq.heappop(min_heap) if current_dist > dist[current_vertex]: continue for neighbor in range(V): if graph[current_vertex][neighbor] != float(\'inf\'): # There is an edge distance = current_dist + graph[current_vertex][neighbor] if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return dist"},{"question":"# Scenario You are working on a software application that checks the integrity of user-entered codes which consist of lowercase letters only. Your task is to implement an efficient function that determines if two given strings are anagrams. # Task Write a function `are_anagrams(s1: str, s2: str) -> bool` that determines if the two input strings `s1` and `s2` are anagrams of each other. # Input - `s1` (string): A string containing only lowercase letters (\'a\'-\'z\'). - `s2` (string): A string containing only lowercase letters (\'a\'-\'z\'). # Output - Returns `True` if `s1` and `s2` are anagrams, otherwise `False`. # Constraints - 1 ≤ len(s1), len(s2) ≤ 100,000 # Performance Requirements - Your solution should run in `O(n)` time, where `n` is the length of the strings. # Examples ```python assert are_anagrams(\\"apple\\", \\"pleap\\") == True assert are_anagrams(\\"apple\\", \\"ppale\\") == True assert are_anagrams(\\"apple\\", \\"cherry\\") == False assert are_anagrams(\\"\\", \\"\\") == True assert are_anagrams(\\"a\\", \\"a\\") == True assert are_anagrams(\\"ab\\", \\"ba\\") == True assert are_anagrams(\\"a\\"*100000, \\"a\\"*99999 + \\"b\\") == False ``` # Edge Cases - Both strings empty: should return `True`. - Strings of different lengths: should return `False`. - Strings with all identical letters except one: should return `False`.","solution":"from collections import Counter def are_anagrams(s1: str, s2: str) -> bool: Determines if two input strings are anagrams. Parameters: s1 (str): A string containing only lowercase letters. s2 (str): A string containing only lowercase letters. Returns: bool: True if s1 and s2 are anagrams, otherwise False. return Counter(s1) == Counter(s2)"},{"question":"# Ternary Search Enhancement Task Context: You are working in a software engineering team, and your task is to search through a large sorted dataset efficiently. You have been assigned to implement and enhance the ternary search algorithm. The default version provided performs well, but there is a need to extend it with additional functionalities, including handling error scenarios and looking for ranges of target values. Problem Statement: You are required to implement a robust version of the ternary search algorithm with the following features: 1. **Standard Ternary Search**: Find the index of a given key in a sorted array. 2. **Range Search**: Return the range [start_index, end_index] of a given key in a sorted array. If the key does not exist, return `[-1, -1]`. Input: - `arr`: A list of integers sorted in ascending order. - `key`: An integer value to search for in the array. Output: - For standard ternary search function, return an integer index of the key if found, otherwise -1. - For range search function, return a list containing two integers representing the start and end indexes of the key in the array. If the key is not present, return `[-1, -1]`. Constraints: - The input array `arr` has a length of at most (10^6). - Each element of `arr` is an integer within the range ([-10^9, 10^9]). Example: ```python arr = [1, 2, 2, 2, 3, 5, 6] key = 2 # Ternary Search expected output: 1 (or 2 or 3) # Range Search expected output: [1, 3] ``` Implementation: Define two functions with the following signatures: ```python def enhanced_ternary_search(arr, key): # Your code here def range_search(arr, key): # Your code here ```","solution":"def enhanced_ternary_search(arr, key): Ternary search to find the index of a given key in a sorted array. If the key is found, return its index. Otherwise, return -1. left, right = 0, len(arr) - 1 while left <= right: third = (right - left) // 3 mid1 = left + third mid2 = right - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1 def range_search(arr, key): Searches for the starting and ending index of a given key in a sorted array. If the key is present, return [start_index, end_index]. Otherwise, return [-1, -1]. def find_start(arr, key): left, right = 0, len(arr) - 1 start = -1 while left <= right: mid = (left + right) // 2 if arr[mid] == key: start = mid right = mid - 1 elif arr[mid] < key: left = mid + 1 else: right = mid - 1 return start def find_end(arr, key): left, right = 0, len(arr) - 1 end = -1 while left <= right: mid = (left + right) // 2 if arr[mid] == key: end = mid left = mid + 1 elif arr[mid] < key: left = mid + 1 else: right = mid - 1 return end start = find_start(arr, key) if start == -1: return [-1, -1] end = find_end(arr, key) return [start, end]"},{"question":"# Scenario You are working on a project involving cryptographic computations with extremely large numerical values. Directly converting these values to integers could lead to overflow, increasing the importance of handling such values via string manipulations efficiently. # Problem Statement **Task**: Write a function `multiply(num1: str, num2: str) -> str` that takes two non-negative integers `num1` and `num2` represented as strings and returns the product of `num1` and `num2` as a string. You must not use any built-in BigInteger library or convert the inputs directly to integers. Input - `num1` and `num2` are strings of length less than 110. - Both strings contain only digits (`0-9`). - Input strings do not contain leading zeros. Output - A string representing the product of `num1` and `num2`. Example **Example 1**: ```python num1 = \\"123\\" num2 = \\"456\\" Expected Output: \\"56088\\" ``` **Example 2**: ```python num1 = \\"13\\" num2 = \\"25\\" Expected Output: \\"325\\" ``` Constraints - Time Complexity: The solution should run in O(n * m) where n and m are the lengths of num1 and num2 respectively. - Space Complexity: The solution should efficiently manage the memory usage within O(n + m). # Requirements - Consider edge cases such as multiplying by zero and by one. - Ensure the implementation maintains precision without converting values to native integers. **Implement**: ```python def multiply(num1: str, num2: str) -> str: # Your implementation here pass ``` Additionally, ensure to test your function with various test cases to validate its correctness and performance: - Small and large values of `num1` and `num2`. - Edge cases like \\"0\\" and \\"1\\". - Variable input lengths approaching the maximum constraint.","solution":"def multiply(num1: str, num2: str) -> str: # Base cases if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" if num1 == \\"1\\": return num2 if num2 == \\"1\\": return num1 # Initialize the result array with zeros result = [0] * (len(num1) + len(num2)) # Reverse the input strings for easier calculation num1, num2 = num1[::-1], num2[::-1] # Multiply each digit and add the results to the result array for i in range(len(num1)): for j in range(len(num2)): product = int(num1[i]) * int(num2[j]) result[i + j] += product result[i + j + 1] += result[i + j] // 10 result[i + j] %= 10 # Remove leading zeros and convert to string while result[-1] == 0: result.pop() return \'\'.join(map(str, result[::-1]))"},{"question":"Scenario: You are working on a new feature for a text analysis tool, which involves finding patterns within repeated text blocks. One specific function you need is to determine the minimum number of repetitions of a base string `A` such that another string `B` becomes its substring at least once. Problem Description: Write a function `minimum_repetitions(A: str, B: str) -> int` that takes two strings `A` and `B` as input. The function should return the minimum number of times `A` must be repeated so that `B` is a substring of the repeated string. If `B` cannot be a substring of the repeated `A` no matter how many times `A` is repeated, return -1. Input: * A: string (1 ≤ len(A) ≤ 10000) * B: string (1 ≤ len(B) ≤ 10000) Output: * An integer representing the minimum number of repetitions of `A` needed, or -1 if it\'s not possible. Examples: ```python # Example 1 A = \\"abcd\\" B = \\"cdabcdab\\" # minimum_repetitions(A, B) should return 3 # Example 2 A = \\"abc\\" B = \\"cabcabca\\" # minimum_repetitions(A, B) should return 4 # Example 3 A = \\"abc\\" B = \\"acbacbacb\\" # minimum_repetitions(A, B) should return -1 ``` Constraints: * Consider edge cases like single character strings and larger lengths where one cannot be a substring of the repeated other. * Ensure your function is optimized for performance, considering the lengths and potential number of repetitions required. Write your implementation below: ```python def minimum_repetitions(A: str, B: str) -> int: count = 1 tmp = A max_count = len(B) // len(A) + 2 # Adding 2 to ensure boundary checking while B not in tmp: tmp += A count += 1 if count > max_count: return -1 return count ```","solution":"def minimum_repetitions(A: str, B: str) -> int: # Minimum initial repetitions to ensure B can be a substring count = 1 extended_A = A # Calculate maximum repetitions needed max_reps = (len(B) // len(A)) + 2 # Plus 2 to cover edge cases # Keep appending A to itself until B is a substring or max_reps reached while B not in extended_A: extended_A += A count += 1 if count > max_reps: return -1 return count"},{"question":"# Question: Robot Movement Validation Context A robot starts at position (0, 0) on a flat grid. You are given a sequence of its movements in a string format where each character represents a move. The valid moves are: - \'U\' (Up) - \'D\' (Down) - \'L\' (Left) - \'R\' (Right) You need to determine if the sequence of moves makes the robot return to its original position (0, 0) after executing all moves. Problem Statement Write a function `robot_returns_to_origin(moves: str) -> bool` that takes a string of moves and returns a boolean indicating whether the robot returns to the origin (0, 0). # Input - A string `moves` (0 <= len(moves) <= 10^4) containing valid characters \'U\', \'D\', \'L\', \'R\'. # Output - A boolean value: - `True`: If the moves sequence results in the robot returning to the origin. - `False`: Otherwise. Example ```python # Example 1 input: \\"UD\\" output: True # Example 2 input: \\"LL\\" output: False # Example 3 input: \\"\\" output: True # Example 4 input: \\"RRDD\\" output: False # Example 5 input: \\"UDLR\\" output: True ``` Constraints - You must ensure your solution checks balance between opposite movements. - Do not assume additional constraints or make amends to the input string. Notes - The solution should strive for a time complexity of (O(n)). Tips - Consider using a simple counting mechanism to tally moves in the opposing direction. - Ensure your solution handles edge cases such as an empty input string correctly.","solution":"def robot_returns_to_origin(moves: str) -> bool: Returns True if the sequence of moves brings the robot back to the origin (0, 0), else False. x, y = 0, 0 # Starting coordinates for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0"},{"question":"You are given an integer array representing a sequence of daily temperatures. Your task is to find the maximum change between two days, where each day is represented by an index in the array. However, unlike Kadane\'s Algorithm which finds the maximum sum of a contiguous subarray, you are required to find the maximum absolute difference between any two days (indices) `i` and `j` such that `i < j`. Implement the function ```max_temperature_change(temps: List[int]) -> int```, which takes in a list of integers `temps` representing daily temperatures, and returns the maximum possible change in temperature between any two days. Input - `temps`: A list of integers representing temperatures. Output - An integer representing the maximum absolute difference between temperatures on any two days. Example ```python def max_temperature_change(temps: List[int]) -> int: # implement the solution here pass # Example temps = [30, 20, 25, 27, 30, 50] print(max_temperature_change(temps)) # Output: 30 temps = [-10, -20, 0, 10, -5] print(max_temperature_change(temps)) # Output: 30 ``` Constraints - The input list will contain at least 2 elements. - Each element in the list is an integer within the range [-10^4, 10^4]. Note: Ensure your solution runs efficiently on large input sizes.","solution":"from typing import List def max_temperature_change(temps: List[int]) -> int: Finds the max absolute temperature change between any two days in the given list of temperatures. :param temps: List[int] - List of daily temperatures. :return: int - Maximum absolute temperature change between any two days. min_temp = temps[0] max_temp = temps[0] for temp in temps: if temp < min_temp: min_temp = temp if temp > max_temp: max_temp = temp return max_temp - min_temp"},{"question":"You are provided with the implementation of a matrix multiplication algorithm. Your task is to write a function `multiply` that takes two compatible two-dimensional matrices (`multiplicand` and `multiplier`) and returns their product. Function Signature ```python def multiply(multiplicand: list, multiplier: list) -> list: pass ``` # Input - `multiplicand`: A list of lists of integers representing the first matrix. Each sub-list represents a row of the matrix. - `multiplier`: A list of lists of integers representing the second matrix. Each sub-list represents a row of the matrix. # Output - A list of lists of integers representing the product matrix. # Constraints - All matrices will contain non-empty lists and integers. - The number of columns in `multiplicand` will be equal to the number of rows in `multiplier`. # Example ```python multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [5, 6], [7, 8] ] # Expected output # [ # [1*5 + 2*7, 1*6 + 2*8], # [3*5 + 4*7, 3*6 + 4*8] # ] multiply(multiplicand, multiplier) # Output: [[19, 22], [43, 50]] ``` # Requirements - The function should correctly handle all valid matrix dimensions. - Raise an exception if the matrices are not compatible for multiplication. # Additional Information This question evaluates your understanding of nested loops and matrix operations. Focus on correctly implementing the multiplication logic and ensure you handle edge cases effectively.","solution":"def multiply(multiplicand: list, multiplier: list) -> list: Multiply two compatible matrices and return the resulting matrix. if len(multiplicand[0]) != len(multiplier): raise ValueError(\\"Incompatible matrices for multiplication\\") result = [[0 for _ in range(len(multiplier[0]))] for _ in range(len(multiplicand))] for i in range(len(multiplicand)): for j in range(len(multiplier[0])): for k in range(len(multiplier)): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result # Example usage # multiplicand = [ # [1, 2], # [3, 4] # ] # multiplier = [ # [5, 6], # [7, 8] # ] # Output: [[19, 22], [43, 50]] # print(multiply(multiplicand, multiplier))"},{"question":"Context You are given a string, and your task is to reverse the positions of vowels in the string. Vowels are those characters that are either \'a\', \'e\', \'i\', \'o\', \'u\' or their upper-case variants. The remaining characters should stay in their original positions. The goal is to practice the application of the two-pointer technique and string manipulation. Function Signature ```python def reverse_vowel(s: str) -> str: pass ``` Input * A single string `s` where `0 <= len(s) <= 10^5` Output * A string with reversed positions of the vowels from the input string. Constraints * The given string may include uppercase and lowercase letters. * Do not use extra space beyond the input string. Example ```python assert reverse_vowel(\\"hello\\") == \\"holle\\" assert reverse_vowel(\\"leetcode\\") == \\"leotcede\\" assert reverse_vowel(\\"aA\\") == \\"Aa\\" assert reverse_vowel(\\"\\") == \\"\\" assert reverse_vowel(\\"bcdfg\\") == \\"bcdfg\\" ``` Explanation 1. `reverse_vowel(\\"hello\\")`: * Original string: \\"hello\\" * Reversed vowels: \\"holle\\" (o and e switched) 2. `reverse_vowel(\\"leetcode\\")`: * Original string: \\"leetcode\\" * Reversed vowels: \\"leotcede\\" (o, e, and e switched) 3. `reverse_vowel(\\"aA\\")`: * Original string: \\"aA\\" * Reversed vowels: \\"Aa\\" (a and A switched) 4. `reverse_vowel(\\"\\")`: * Original string: \\"\\" * Reversed vowels: \\"\\" (no vowels to reverse) 5. `reverse_vowel(\\"bcdfg\\")`: * Original string: \\"bcdfg\\" * Reversed vowels: \\"bcdfg\\" (no vowels in the string) Write your function using the two-pointer technique to achieve optimal performance.","solution":"def reverse_vowel(s: str) -> str: Reverses the positions of vowels in the given string. :param s: Input string :return: String with the positions of vowels reversed vowels = set(\'aeiouAEIOU\') s = list(s) left, right = 0, len(s) - 1 while left < right: while left < right and s[left] not in vowels: left += 1 while left < right and s[right] not in vowels: right -= 1 if left < right: s[left], s[right] = s[right], s[left] left += 1 right -= 1 return \'\'.join(s)"},{"question":"# Ternary Search Implementation and Analysis You have just learned about ternary search, which is a divide and conquer algorithm used for finding the position of a target element in a sorted array by repeatedly dividing the search interval into three parts. **Problem Statement**: Implement the `ternary_search` function. Given a sorted array of integers `arr`, an integer `key`, and the boundaries `left` and `right`, your task is to find the index of `key` in `arr`. If the key is not present in the array, return `-1`. **Function Signature**: ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: ``` # Input * `left` (int): The starting index of the search range (0 ≤ left < len(arr)). * `right` (int): The ending index of the search range (0 ≤ right < len(arr)). * `key` (int): The value to search for. * `arr` (List[int]): Sorted array of integers (each -10^9 ≤ arr[i] ≤ 10^9). # Output * Return the index of `key` if it is found within the `left`..`right` range. Otherwise, return `-1`. # Constraints * You must ensure that the search range (left, right) is always valid and within the array bounds. * The array should be searched using ternary search algorithm principles. # Example ```python # Example 1 arr = [1, 2, 4, 5, 6, 8, 10] key = 5 left = 0 right = len(arr) - 1 assert ternary_search(left, right, key, arr) == 3 # Example 2 arr = [1, 2, 4, 5, 6, 8, 10] key = 3 left = 0 right = len(arr) - 1 assert ternary_search(left, right, key, arr) == -1 # Example 3 arr = [3, 4, 5, 9, 10, 13, 19] key = 19 left = 0 right = len(arr) - 1 assert ternary_search(left, right, key, arr) == 6 # Example 4 arr = [1, 1, 1, 1, 1] key = 1 left = 0 right = len(arr) - 1 assert ternary_search(left, right, key, arr) in [0, 1, 2, 3, 4] ``` **Note**: Be cautious about edge cases such as when the array is very small or when the key is present at the bounds of the array.","solution":"from typing import List def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: Perform a ternary search on the given sorted array to find the index of the key. :param left: The starting index of the search range :param right: The ending index of the search range :param key: The value to search for :param arr: The sorted array of integers :return: The index of the key if found, otherwise -1 while left <= right: third = (right - left) // 3 mid1 = left + third mid2 = right - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"You are working on a classification problem where you need to classify a new data point based on its nearest neighbor from a set of pre-labeled training data points. Implementing an efficient and effective solution is crucial for handling high-dimensional and large-volume data. # Problem Statement Implement the `nearest_neighbor` function to classify a new data point based on the nearest neighbor algorithm. Optimize your implementation to handle high-dimensional datasets efficiently. # Function Signature ```python def nearest_neighbor(x: tuple, tSet: dict) -> str: pass ``` # Input - `x`: A tuple representing the new data point to classify. You can assume that the dimensionality of `x` is consistent with vectors in `tSet`. - `tSet`: A dictionary where the keys are tuples representing training data points, and the values are their corresponding classes. # Output - Return the class (value from the `tSet`) of the closest training data point. # Constraints and Requirements - Ensure that your function handles cases where the training set is empty by returning `None`. - Optimize your solution to avoid excessive computation time and memory usage. # Example ```python x = (2, 3) tSet = { (1, 2): \'A\', (3, 4): \'B\', (0, 1): \'A\' } nearest_neighbor(x, tSet) ``` Expected output: `\'A\'` # Considerations - Provide ample comments and documentation to explain your code. - Ensure that your function is robust against edge cases, such as empty training sets or data points of varying lengths. - Discuss any trade-offs you make with algorithm complexity.","solution":"from math import sqrt def nearest_neighbor(x: tuple, tSet: dict) -> str: Classify a new data point x based on the nearest neighbor algorithm using the given set of pre-labeled training data points tSet. Parameters: x (tuple): A tuple representing the new data point to classify. tSet (dict): A dictionary where keys are tuples representing training data points, and values are their corresponding classes. Returns: str: The class of the closest training data point. if not tSet: return None def euclidean_distance(point1: tuple, point2: tuple) -> float: return sqrt(sum((a - b) ** 2 for a, b in zip(point1, point2))) closest_point = min(tSet.keys(), key=lambda point: euclidean_distance(point, x)) return tSet[closest_point]"},{"question":"# Question: Maximum Depth of Binary Tree You are provided with a binary tree and your task is to find its maximum depth. The maximum depth is defined as the number of nodes along the longest path from the root node down to the farthest leaf node. Write a function `max_depth(root)` that takes the root of the binary tree as an input and returns an integer representing its maximum depth. # Input Format: - The root node of the binary tree, which is an instance of `TreeNode`. # Output Format: - A single integer representing the maximum depth of the tree. # Constraints: - The number of nodes in the tree is in the range `[0, 10^4]`. - Node values are integers. # Example: Consider the following tree: ``` 10 / 12 15 / 25 30 100 ``` The function call `max_depth(root)` should return `4`, since the longest path is 4 nodes: `10 -> 12 -> 25 -> 100`. You are required to handle the following edge cases: 1. An empty tree should return a depth of 0. 2. A tree with only one node should return a depth of 1. # Implementation Details: - Do not import any external libraries other than those provided. - Optimize your solution for a large number of nodes in terms of both time and space complexity.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_depth(root): Returns the maximum depth of the binary tree. if not root: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"Implement and Extend Segment Tree **Problem Statement**: You are provided a Segment Tree class that supports efficient range queries and updates. Your task is to extend the functionality of this Segment Tree by adding support to return a range of results, instead of just the aggregated result, while maintaining the original query function. Implement the following methods in the `SegmentTree` class: 1. `range_query(self, l, r)`: This method should return a list of results for each segment in the range `[l, r]`. Each element in the list should represent the result of applying the `function` on the respective segment. **Function Signatures**: ```python class SegmentTree: def __init__(self, arr, function): # Already implemented def build_tree(self): # Already implemented def update(self, p, v): # Already implemented def query(self, l, r): # Already implemented def range_query(self, l, r): # Implement this method ``` **Input Format**: - `l` and `r` are integers representing the start and end indices of the segment range. **Output Format**: - Return a list of results for each segment in the range `[l, r]`. **Constraints**: - The function used for the segment tree is commutative and associative. - Indices `l`, `r` are within the bounds of the array used to initialize the Segment Tree. **Examples**: ```python arr = [2, 4, 5, 3, 4] mytree = SegmentTree(arr, max) print(mytree.range_query(1, 4)) # Expected Output: [4, 5, 5, 4] arr = [4, 5, 2, 3, 4, 43, 3] mytree = SegmentTree(arr, lambda a, b: a + b) print(mytree.range_query(0, 2)) # Expected Output: [4, 9, 11] ``` **Explanation**: - For the first example, the `range_query` method should return the maximum value at each index from 1 to 4, comprehensively considering the initialized function. - Similarly, the second example should sum the elements within the range for each segment. **Guidelines**: - Ensure your method is efficient and operates within O(log N) time complexity where possible. - Handle edge cases, such as when `l` and `r` are at the bounds of the array.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.arr = arr self.function = function self.tree = [0] * (2 * self.n) self.build_tree() def build_tree(self): # Initialize leaves of the tree for i in range(self.n): self.tree[self.n + i] = self.arr[i] # Initialize internal nodes of the tree for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, p, value): # Update leaf node p += self.n self.tree[p] = value # Update internal nodes i = p while i > 1: i //= 2 self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def query(self, l, r): res = None l += self.n r += self.n + 1 while l < r: if l % 2: res = self.tree[l] if res is None else self.function(res, self.tree[l]) l += 1 if r % 2: r -= 1 res = self.tree[r] if res is None else self.function(res, self.tree[r]) l //= 2 r //= 2 return res def range_query(self, l, r): # Collect results for each segment in the range [l, r] return [self.query(i, i) for i in range(l, r + 1)]"},{"question":"You are tasked with designing an efficient algorithm to compute the minimum number of moves required to determine with certainty the highest floor from which an egg can be dropped without breaking. You start with a certain number of eggs and a building with a specified number of floors. Function Signature You need to implement the function: ```python def min_moves_to_find_threshold(K: int, N: int) -> int: K: Number of eggs N: Number of floors Returns the minimum number of moves in the worst-case scenario. ``` # Input - `K` (1 <= K <= 100): Number of eggs. - `N` (1 <= N <= 1000): Number of floors in the building. # Output - Return the minimum number of moves required to determine the critical threshold floor `F` in the worst-case scenario. # Constraints - You can drop an egg from any floor. - If the egg breaks, can\'t be used again. - The goal is to minimize the worst-case attempts to find the correct floor `F`. # Performance Requirements - Your solution should be optimized within the constraints provided. - Handling up to 100 eggs and 1000 floors efficiently is expected. # Example ```python # Example case 1 print(min_moves_to_find_threshold(1, 2)) # Output: 2 # Example case 2 print(min_moves_to_find_threshold(2, 6)) # Output: 3 ```","solution":"def min_moves_to_find_threshold(K: int, N: int) -> int: K: Number of eggs N: Number of floors Returns the minimum number of moves in the worst-case scenario. # If we have one egg, we have to do a linear search dp = [[0] * (N + 1) for _ in range(K + 1)] m = 0 while dp[K][m] < N: m += 1 for k in range(1, K + 1): dp[k][m] = dp[k - 1][m - 1] + dp[k][m - 1] + 1 return m"},{"question":"Given a set of distinct integers, `nums`, implement a function `all_subsets(nums)` that returns all possible subsets (the power set) of the given set. Input: - A list of distinct integers `nums` where `0 <= len(nums) <= 20` and `-10 <= nums[i] <= 10`. Output: - A list containing all possible subsets of `nums`. Each subset should be represented as a list, and the solution set must not contain duplicate subsets. The subsets can be returned in any order. Example: ```python all_subsets([1, 2, 3]) # Expected Output: # [ # [], # [1], # [2], # [3], # [1, 2], # [1, 3], # [2, 3], # [1, 2, 3] # ] all_subsets([]) # Expected Output: # [ # [] # ] ``` Constraints: - Ensure that the algorithm efficiently handles the combinations. - The implementation should not assume a sorted array. Implement the function `all_subsets(nums)` to solve the problem effectively.","solution":"def all_subsets(nums): Returns all possible subsets of the given list of distinct integers. Parameters: nums (list): A list of distinct integers. Returns: list: A list of lists representing all possible subsets of the given set. result = [] n = len(nums) # Using bitwise operation to generate all subsets for i in range(1 << n): subset = [] for j in range(n): if i & (1 << j): subset.append(nums[j]) result.append(subset) return result"},{"question":"# Keyboard Row Challenge You have an input list of words. Your task is to implement a function that returns the words which can be typed using letters of the alphabet only from one row of an American QWERTY keyboard. Function Signature ```python def find_keyboard_row(words: List[str]) -> List[str]: ``` # Input - `words`: A list of strings where each string represents a word. The words consist of only English alphabet characters and are non-empty. # Output - Returns a list of strings containing all the words from the input list that can be typed using letters from only one row of the American keyboard. # Constraints - Each word in the input list `words` will have a length in the range [1, 100]. - The total number of words provided will be at most 1000. # Performance Requirements - The solution should be efficient with a time complexity around (O(n cdot m)), where (n) is the number of words and (m) is the average length of each word. # Example ```python Input: [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] Output: [\\"Alaska\\", \\"Dad\\"] ``` # Context Imagine you are developing a typing recommendation system where you need to filter out words to suggest based on specific category constraints, i.e., the words that can be typed using letters from only one row of a typical QWERTY keyboard. This function will help in finding such words efficiently.","solution":"from typing import List def find_keyboard_row(words: List[str]) -> List[str]: This function returns the list of words which can be typed using letters from only one row of an American QWERTY keyboard. # Define the three rows of a QWERTY keyboard row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") def is_one_row(word): Helper function to check if a word can be typed on one row of QWERTY keyboard word_set = set(word.lower()) return word_set <= row1 or word_set <= row2 or word_set <= row3 # Filter words which can be typed using only one row return [word for word in words if is_one_row(word)]"},{"question":"# Coding Challenge: Implement a Robust Maximum Flow Solver Given the implementations of three different maximum flow algorithms (Ford-Fulkerson, Edmonds-Karp, and Dinic\'s Algorithm), your task is to implement a function which can decide which algorithm to use based on the given graph parameters. Function Signature ```python def max_flow_solver(capacity: List[List[int]], source: int, sink: int) -> int: pass ``` Input - **capacity**: A 2D list of integers where `capacity[i][j]` represents the capacity of the edge from node `i` to node `j`. If `capacity[i][j] = 0`, there is no direct edge from node `i` to node `j`. - **source**: An integer representing the source node. - **sink**: An integer representing the sink node. Output - Returns an integer representing the maximum flow from the source node to the sink node. Constraints - The number of vertices `V` (length of `capacity`) is between 1 and 1000. - The capacity of edges is non-negative and does not exceed (10^6). Performance Requirements - Choose the most efficient algorithm based on graph properties: - For very dense graphs with high capacities, Dinic\'s Algorithm tends to perform better. - For sparse graphs or graphs with lower capacities, Edmonds-Karp Algorithm may be more effective. Requirements - Your function should be optimized to choose and execute the best algorithm according to the graph\'s characteristics. - Handle edge cases such as no path existing from source to sink, and nodes with all outgoing/incoming capacities filled or zero.","solution":"from typing import List from collections import deque def bfs(capacity, source, sink, parent): visited = [False] * len(capacity) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v in range(len(capacity)): if visited[v] == False and capacity[u][v] > 0: queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def edmonds_karp(capacity, source, sink): parent = [-1] * len(capacity) max_flow = 0 while bfs(capacity, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, capacity[parent[s]][s]) s = parent[s] max_flow += path_flow v = sink while v != source: u = parent[v] capacity[u][v] -= path_flow capacity[v][u] += path_flow v = parent[v] return max_flow def dinic_bfs(capacity, source, sink, level): queue = deque([source]) level[source] = 0 while queue: u = queue.popleft() for v in range(len(capacity)): if level[v] < 0 and capacity[u][v] > 0: level[v] = level[u] + 1 queue.append(v) return level[sink] >= 0 def dinic_dfs(capacity, ptr, u, sink, flow, level): if u == sink: return flow while ptr[u] < len(capacity): v = ptr[u] if level[v] == level[u] + 1 and capacity[u][v] > 0: df = dinic_dfs(capacity, ptr, v, sink, min(flow, capacity[u][v]), level) if df > 0: capacity[u][v] -= df capacity[v][u] += df return df ptr[u] += 1 return 0 def dinics_algorithm(capacity, source, sink): total_flow = 0 level = [-1] * len(capacity) while dinic_bfs(capacity, source, sink, level): ptr = [0] * len(capacity) while True: flow = dinic_dfs(capacity, ptr, source, sink, float(\'Inf\'), level) if flow == 0: break total_flow += flow level = [-1] * len(capacity) return total_flow def graph_density(capacity): edges = sum(len([1 for cap in row if cap > 0]) for row in capacity) vertices = len(capacity) if vertices == 0: return 0 return edges / (vertices ** 2) def max_flow_solver(capacity: List[List[int]], source: int, sink: int) -> int: density = graph_density(capacity) if density < 0.1: return edmonds_karp(capacity, source, sink) else: return dinics_algorithm(capacity, source, sink)"},{"question":"# Question Context You are working as a software engineer tasked with developing a robust internal tool for the engineering team. Your goal is to create an efficient data structure that allows team members to add words to a dictionary and support complex word search queries, including those with wildcard characters. Problem Statement Implement a class `WordDictionary` that supports the following methods: 1. **add_word(word: str) -> None**: Adds a word to the word dictionary. 2. **search(word: str) -> bool**: Returns whether the word (or a pattern with wildcard characters \\".\\") is in the word dictionary. Requirements 1. A word contains only lowercase alphabets (\'a\' to \'z\'). 2. A wildcard character, \\".\\", in the search string can match any single character. 3. The add_word operation will be called at least once before any search operations. Constraints * The length of the word being added or searched is between 1 and 500. * The total number of words in the dictionary does not exceed 10000. Example ```python # Example usage: word_dict = WordDictionary() word_dict.add_word(\\"bad\\") word_dict.add_word(\\"dad\\") word_dict.add_word(\\"mad\\") print(word_dict.search(\\"pad\\")) # Expected output: False print(word_dict.search(\\"bad\\")) # Expected output: True print(word_dict.search(\\".ad\\")) # Expected output: True print(word_dict.search(\\"b..\\")) # Expected output: True ``` Implementation Define the `WordDictionary` class with appropriate method implementations. Make sure your solution is optimized for both time and space complexities while handling edge cases.","solution":"class WordDictionary: def __init__(self): Initialize the WordDictionary data structure. self.words = [] def add_word(self, word: str) -> None: Adds a word to the dictionary. self.words.append(word) def search(self, word: str) -> bool: Returns whether the word (or a pattern with wildcard characters \\".\\") is in the word dictionary. def is_match(word, pattern): if len(word) != len(pattern): return False for w, p in zip(word, pattern): if p != \'.\' and w != p: return False return True for w in self.words: if is_match(w, word): return True return False"},{"question":"# Question: Implementing and Extending a Markov Chain Background You are given a basic implementation of a Markov Chain which consists of functions to choose the next state based on a given state and its transition probabilities. The Markov Chain represents a stochastic model where the probability of moving from one state to another is predefined. Task 1. Implement a function `simulate_markov_chain` that: * Accepts a Markov Chain `chain`, a starting state `start_state`, and the number of steps `n`. * Simulates and returns a list of states representing the path taken through the chain over `n` steps. 2. Extend the Markov Chain to handle cases where transition probabilities may result in an absorbing state. * If an absorbing state (a state with no transitions) is detected, your function should be able to terminate and return the path taken so far. Function Signature ```python def simulate_markov_chain(chain: dict, start_state: str, n: int) -> list: pass ``` Input * `chain` (dict): A dictionary representing the Markov Chain where keys are states and values are sub-dictionaries representing state transitions. * `start_state` (str): The initial state for the Markov Chain. * `n` (int): The number of steps to simulate. Output * Returns a list of states (list of strings) representing the sequence of states from the start state through `n` steps or until reaching an absorbing state. Example ```python chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3}, \'B\': {} } print(simulate_markov_chain(chain, \'A\', 5)) # Possible output: [\'A\', \'E\', \'A\', \'A\', \'E\'] print(simulate_markov_chain(chain, \'B\', 5)) # Possible output: [\'B\'] ``` Constraints * Assume that the input chain will have at least one state and valid transition probability values. * Sum of transition probabilities for each state will be equal to 1. * The start state is guaranteed to be a state within the chain. Requirements * Ensure your solution efficiently handles the simulation and accounts for absorbing states. * Document any assumptions and edge cases considered.","solution":"import random def simulate_markov_chain(chain: dict, start_state: str, n: int) -> list: Simulates a Markov Chain for a given number of steps starting from a given state. Parameters: chain (dict): A dictionary representing the Markov Chain. start_state (str): The starting state of the Markov Chain. n (int): The number of steps to simulate. Returns: list: A list of states representing the path taken through the chain. current_state = start_state path = [current_state] for _ in range(n): if current_state not in chain or not chain[current_state]: # Absorbing state detected (no transitions from current_state) break next_state = random.choices( population=list(chain[current_state].keys()), weights=list(chain[current_state].values()) )[0] path.append(next_state) current_state = next_state return path"},{"question":"Design and implement a function `optimized_exchange_sort` that enhances the given exchange sort algorithm to handle an early stopping scenario. If the list becomes sorted before all the iterations are complete, the algorithm should detect this and terminate early to save unnecessary comparisons. # Function Signature ```python def optimized_exchange_sort(arr: list) -> list: ``` # Input Format * A list `arr` of integers of length `n` (0 ≤ n ≤ 10^5). # Output Format * The function should return a new list sorted in ascending order. # Constraints 1. The list can contain both positive, negative integers, and zeros. 2. The solution should optimize where possible, especially for nearly sorted arrays. # Example Input and Output Example 1 * Input: `[64, 25, 12, 22, 11]` * Output: `[11, 12, 22, 25, 64]` Example 2 * Input: `[5, 1, 4, 2, 8]` * Output: `[1, 2, 4, 5, 8]` Example 3 * Input: `[5, 5, 5, 5, 5]` * Output: `[5, 5, 5, 5, 5]` # Performance Requirements * Implement an optimized version that handles nearly sorted arrays more efficiently by terminating early if no elements were swapped in the previous pass. * Your algorithm should still maintain the O(n^2) worst-case complexity for consistency with traditional exchange sort but aim for improved performance in practical cases. # Scenario You are given a list of scores from a class test that is mostly sorted. Your task is to write a function `optimized_exchange_sort` that sorts the scores effectively and efficiently, especially benefiting from the early detection of sorted sequences. This will help in saving substantial computation time compared to traditional bubble sort.","solution":"def optimized_exchange_sort(arr: list) -> list: Optimized exchange sort algorithm that stops early if the array is already sorted before completing all iterations. Args: arr (list): A list of integers that needs to be sorted. Returns: list: A new list sorted in ascending order. n = len(arr) sorted_arr = arr.copy() for i in range(n): swapped = False for j in range(n - i - 1): if sorted_arr[j] > sorted_arr[j + 1]: sorted_arr[j], sorted_arr[j + 1] = sorted_arr[j + 1], sorted_arr[j] swapped = True if not swapped: break return sorted_arr"},{"question":"**Scenario**: You are tasked with designing a system for printing out a hierarchical representation of entity-attribute-value structures stored in a nested dictionary. Each entity can have multiple attributes, and for each attribute, they can have one or more values. **Objective**: Implement a function `enhanced_tree_print` that prints the tree in a readable format so that each entity is easily distinguishable with its attributes and values listed in an indented manner. **Requirement**: - **Function Name**: `enhanced_tree_print` - **Input**: A nested dictionary `tree`. - **Output**: Print the tree structure while preserving hierarchical order. # Input Format - A nested dictionary where each key represents an entity. - Each key\'s value is a list containing tuples of sub-elements, where tuples represent attributes and their respective values. # Output Format - The function should print to stdout. - The structure should visually represent the hierarchy through indentation. - Example output for the provided structure in the code snippets should maintain: ``` a -> Adam -> Book -> 4 -> Computer -> 7 b -> Bill -> Computer -> 5 -> TV -> 6 Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 ``` # Constraints - Entity and Attribute names will be strings. - Values will be integers or strings. - Attributes are unique for each entity. # Performance Requirements - Optimal tree traversal ensuring minimized repetitive lookups. # Example Consider the following input: ```python tree = { \'a\': [(\'Adam\', \'Book\', 4), (\'Adam\', \'Computer\', 7)], \'b\': [(\'Bill\', \'Computer\', 5), (\'Bill\', \'TV\', 6), (\'Jill\', \'Sports\', 1)], \'c\': [(\'Bill\', \'Sports\', 3)], \'d\': [(\'Adam\', \'Computer\', 3), (\'Quin\', \'Computer\', 3)], \'e\': [(\'Quin\', \'Book\', 5), (\'Quin\', \'TV\', 2)] } ``` Expected print output: ``` a -> Adam -> Book -> 4 -> Computer -> 7 b -> Bill -> Computer -> 5 -> TV -> 6 Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 ``` Implement the `enhanced_tree_print` function based on the above requirements.","solution":"def enhanced_tree_print(tree): Function to print a nested dictionary in a readable format with hierarchical order. for key, values in tree.items(): for i, (entity, attribute, value) in enumerate(values): if i == 0: print(f\\"{key} -> {entity} -> {attribute} -> {value}\\") else: print(f\\" {entity} -> {attribute} -> {value}\\") # Example usage tree = { \'a\': [(\'Adam\', \'Book\', 4), (\'Adam\', \'Computer\', 7)], \'b\': [(\'Bill\', \'Computer\', 5), (\'Bill\', \'TV\', 6), (\'Jill\', \'Sports\', 1)], \'c\': [(\'Bill\', \'Sports\', 3)], \'d\': [(\'Adam\', \'Computer\', 3), (\'Quin\', \'Computer\', 3)], \'e\': [(\'Quin\', \'Book\', 5), (\'Quin\', \'TV\', 2)] } enhanced_tree_print(tree)"},{"question":"Question: Generate Power Set Using Bit Manipulation **Context**: As part of a larger system, you need to generate all possible subsets (the power set) of a given set of distinct integers to evaluate various combination possibilities. # Problem Statement Create a function `generate_subsets(nums: List[int]) -> Set[tuple]` that takes a list of distinct integers and returns a set of all possible subsets represented as tuples. # Parameters - **Input**: - `nums` (List[int]): A list of distinct integers. - **Output**: - `Set[tuple]`: A set containing all possible subsets of the input list, where each subset is represented as a tuple. # Constraints - The integers in `nums` are distinct. - Do not use any libraries or functions that directly generate subsets/powersets. # Example ```python # Example 1 nums = [1, 2] print(generate_subsets(nums)) # Expected Output: {(), (1,), (2,), (1, 2)} # Example 2 nums = [1, 2, 3] print(generate_subsets(nums)) # Expected Output: {(), (1,), (2,), (3,), (1,2,), (1,3,), (2,3,), (1,2,3)} # Example 3 nums = [] print(generate_subsets(nums)) # Expected Output: {()} ``` # Edge Cases 1. An empty list should return a set containing an empty tuple. 2. Ensure the function works correctly with the minimum and maximum sizes of `nums` based on constraints. # Performance Considerations 1. Ensure the function handles input sizes optimally within the constraints, keeping in mind the exponential growth of the number of subsets. ```python def generate_subsets(nums): :param nums: List[int] :return: Set[tuple] pass # You can use the provided test cases and add additional ones to validate your solution. ``` Develop the function `generate_subsets` to solve the problem as described. Ensure that your implementation can handle all specified edge cases and constraints effectively.","solution":"from typing import List, Set, Tuple def generate_subsets(nums: List[int]) -> Set[Tuple[int, ...]]: Generates all possible subsets of a given list of distinct integers. :param nums: List[int] - A list of distinct integers. :return: Set[Tuple[int, ...]] - A set containing all possible subsets of the input list, where each subset is represented as a tuple. subsets = set() n = len(nums) # There are 2^n possible subsets for a set of n elements for i in range(2**n): subset = [] for j in range(n): # Check if the j-th bit in the i-th counter is set if i & (1 << j): subset.append(nums[j]) subsets.add(tuple(subset)) return subsets"},{"question":"# Assessment Question Context: You are involved in managing an automated warehouse where packages are handled and tracked using a stack-based system due to the sequential nature of package processing. Occasionally, due to updates or cancellations, the smallest package (identified by some attribute, for example, package ID) needs to be removed efficiently. Task: Write a function `remove_min(stack: list) -> list` that takes a stack of integers represented as a list and removes the smallest integer from the stack. The function should return the updated stack while maintaining the original order of the other elements. Constraints: - Assume there are no duplicate minimum values for simplicity. - The stack can contain both positive and negative integers. - The function should handle edge cases like an empty stack gracefully. Input: - `stack`: A list of integers representing a stack, where the last element of the list is the top of the stack. Output: - The updated list (stack) with the smallest integer removed. # Example: ```python # Example 1: stack = [2, 8, 3, -6, 7, 3] result = remove_min(stack) print(result) # Output: [2, 8, 3, 7, 3] # Example 2: stack = [5, -2, 1, 9, 0] result = remove_min(stack) print(result) # Output: [5, 1, 9, 0] # Example 3: stack = [] result = remove_min(stack) print(result) # Output: [] ``` # Additional Notes: - Ensure that the function has a time complexity of O(n) and a space complexity not exceeding O(n). - Consider providing clear comments within the function to describe key steps and logic. - You are not allowed to use any built-in Python functions that directly solve this problem (e.g., `min`).","solution":"def remove_min(stack): Removes the smallest integer from the stack and returns the updated stack. Parameters: stack (list): A list of integers representing a stack, where the last element of the list is the top of the stack. Returns: list: The updated stack with the smallest integer removed. if not stack: return stack # Return an empty stack if the input is empty. # Initialize the minimum value and the position where it occurs min_value = stack[0] min_index = 0 # Iterate through the stack to find the smallest value and its index for i in range(1, len(stack)): if stack[i] < min_value: min_value = stack[i] min_index = i # Remove the smallest element by reconstructing the stack without the min element updated_stack = stack[:min_index] + stack[min_index + 1:] return updated_stack"},{"question":"# Context You are working on a data preprocessing module where you need to filter values in arrays before passing them on for further analysis. Often, you need to limit the values to a specified range. Given an array of numbers, you need to implement a function that filters this array and returns only the elements within the specified range. # Task Write a function `limited_array` that takes the following parameters: - **arr**: List of numbers (integers or floats). - **min_val**: Minimum value for the range (inclusive). If `None`, there is no lower limit. - **max_val**: Maximum value for the range (inclusive). If `None`, there is no upper limit. The function should return a list containing only the numbers within the specified range. # Input & Output Formats **Input**: - `arr` : List of numbers (integers or floats). Example: `[1, 12, -5, 23, 45, 95]` - `min_val` : Integer or float or `None`. Example: `10` - `max_val` : Integer or float or `None`. Example: `50` **Output**: - List of numbers within the specified range. Example: `[12, 23, 45]` # Constraints - The input array can have up to 10^6 elements. - Each element in the array can be an integer or float. - Either `min_val` or `max_val` can be `None`. # Examples 1. `limited_array([1, 12, -5, 23, 45, 95], 10, 50)` should return `[12, 23, 45]` 2. `limited_array([10, 20, 30, 40, 50, 60], None, 35)` should return `[10, 20, 30]` 3. `limited_array([5, 15, 25, 35, 45], 20, None)` should return `[25, 35, 45]` 4. `limited_array([], 5, 10)` should return `[]` 5. `limited_array([1, 2, 3, 4, 5], None, None)` should return `[1, 2, 3, 4, 5]` # Implementation Implement the following function in Python: ```python def limited_array(arr, min_val=None, max_val=None): # Your code goes here pass ```","solution":"def limited_array(arr, min_val=None, max_val=None): Filters the input array and returns only the elements within the specified range. Parameters: arr (list): List of numbers (integers or floats). min_val (int/float/None): Minimum value for the range (inclusive). max_val (int/float/None): Maximum value for the range (inclusive). Returns: list: A list containing only the numbers within the specified range. if min_val is None and max_val is None: return arr filtered_array = [] for num in arr: if (min_val is None or num >= min_val) and (max_val is None or num <= max_val): filtered_array.append(num) return filtered_array"},{"question":"Coding Assessment Question # Scenario You are developing a URL redirection service that needs to ensure all redirected URLs are clean and consistent. Part of this task involves removing duplicate query string parameters from the URLs and optionally removing specific query parameters defined by the user. # Problem Statement Write a function `clean_url(url: str, params_to_strip: List[str] = []) -> str` that performs the following tasks: 1. **Removes Duplicate Parameters**: If a query parameter appears more than once, only the first occurrence is retained. 2. **Optionally Removes Specified Parameters**: If the `params_to_strip` list is provided, the function should remove any query parameter whose name is in this list. # Input * **url** (str): The URL to be cleaned. It can be an empty string or a valid URL. * **params_to_strip** (list): A list of parameter names to remove from the URL\'s query string. This list is optional and defaults to an empty list. # Output * **(str)**: The cleaned URL with duplicates and specified parameters removed. # Constraints * The URL can contain any valid characters including alphanumeric, \'-\', \'_\', \'.\', \'!\', \'~\', \'*\', \\"\'\\", \'(\', \')\', \';\', \':\', \'@\', \'&\', \'=\', \'+\', \',\', \'/\', \'?\', and \'%\'. * The URL can be empty or contain only the domain name without any query parameters. # Examples ```python assert clean_url(\\"www.example.com?a=1&b=2&a=3\\", []) == \\"www.example.com?a=1&b=2\\" assert clean_url(\\"www.example.com?a=1&b=2&b=3&c=4\\", [\\"b\\"]) == \\"www.example.com?a=1&c=4\\" assert clean_url(\\"www.example.com?a=1&b=2&c=3&b=4&d=5\\", [\\"c\\", \\"d\\"]) == \\"www.example.com?a=1&b=2\\" assert clean_url(\\"www.example.com\\", []) == \\"www.example.com\\" assert clean_url(\\"\\", [\\"a\\", \\"b\\"]) == \\"\\" assert clean_url(\\"www.example.com?a=1&b=2&a=2\\", [\\"a\\"]) == \\"www.example.com?b=2\\" ``` # Solution Outline 1. Parse the URL to isolate the query string. 2. Use a dictionary to track the first occurrence of each parameter. 3. Construct the cleaned URL while excluding specified parameters. # Performance Requirements * The solution should handle URLs with up to 1000 query parameters efficiently. * The impact of removing specified parameters should not significantly degrade performance.","solution":"from typing import List from urllib.parse import urlencode, urlparse, urlunparse, parse_qsl def clean_url(url: str, params_to_strip: List[str] = []) -> str: Cleans the provided URL by removing duplicate query parameters and optionally removing specified query parameters. :param url: The URL to be cleaned. :param params_to_strip: List of parameter names to remove from the URL\'s query string. :return: Cleaned URL. if not url: return url # Parse URL into components parsed_url = urlparse(url) # Parse query parameters from the URL and remove duplicates query_params = parse_qsl(parsed_url.query, keep_blank_values=True) seen = set() cleaned_params = [] for key, value in query_params: if key not in seen and key not in params_to_strip: seen.add(key) cleaned_params.append((key, value)) # Rebuild query string with cleaned parameters cleaned_query_string = urlencode(cleaned_params) # Rebuild the full URL with the cleaned query string cleaned_url = urlunparse(parsed_url._replace(query=cleaned_query_string)) return cleaned_url"},{"question":"# Problem Description: Given a list of integers, you need to implement a function `custom_bubble_sort` that sorts the list using bubble sort. The function should also accept an optional boolean flag, `simulation`. If `simulation` is set to `True`, the function should print each iteration of the sorting process in a specific format; otherwise, it should simply return the sorted list. # Function Signature: ```python def custom_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` # Input: * `arr` (List[int]): A list of integers that needs to be sorted. * `simulation` (bool, optional): A boolean flag to print the sorting process. Default is `False`. # Output: * The function should return the sorted list of integers. # Constraints: * The length of `arr` can be in the range [0, 10^3]. * Each element in `arr` can be in the range [-10^3, 10^3]. # Performance Requirements: * The function must handle all edge cases efficiently. # Example: ```python # Example 1 arr = [3, 1, 4, 1, 5, 9, 2, 6] result = custom_bubble_sort(arr) print(result) # Output: [1, 1, 2, 3, 4, 5, 6, 9] # Example 2 (with simulation) arr = [5, 1, 4, 2, 8] custom_bubble_sort(arr, simulation=True) # Expected output: # iteration 0 : 5 1 4 2 8 # iteration 1 : 1 5 4 2 8 # iteration 2 : 1 4 5 2 8 # iteration 3 : 1 4 2 5 8 # iteration 4 : 1 4 2 5 8 -> No change, so sorting stops ``` Implement the `custom_bubble_sort` function, ensuring the implementation is clear, demonstrates the understanding of the Bubble Sort algorithm, handles edge cases, and includes an optional step-by-step simulation process.","solution":"from typing import List def custom_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: n = len(arr) for i in range(n): swapped = False if simulation: print(f\'iteration {i} : {\\" \\".join(map(str, arr))}\') # Perform the bubble sort for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if not swapped: break return arr"},{"question":"Context: You are given a binary tree. Your task is to perform an inorder traversal of the tree. While doing this, you will also need to extend the functionality to incorporate a node filtering mechanism. Function Signature: ```python def filtered_inorder(root: Node, filter_func: callable) -> list[int]: Perform inorder traversal of a binary tree and filter nodes based on `filter_func`. Args: - root (Node): The root node of the binary tree. - filter_func (callable): A function that takes an integer value and returns True if this node should be included in the result, False otherwise. Returns: - list[int]: The inorder traversal list of node values after applying the filter. pass ``` Input Constraints: * Node values are integers and can be any valid integer (`int`). * The `filter_func` is any function that returns `True` for the integers that should be included in the traversal result and `False` otherwise. * Tree nodes can be `None`. Output: * A list of integers, representing the values of nodes that pass the filter function, in inorder traversal order. Example: Consider the binary tree given below: ``` 10 / 5 20 / / 3 8 15 30 ``` * For `filter_func = lambda x: x > 10` * The expected output: `[15, 20, 30]` * For `filter_func = lambda x: x % 2 == 0` * The expected output: `[10, 20, 30]` Problem: Implement the `filtered_inorder` function that returns the inorder traversal of the binary tree, filtered based on the provided `filter_func`.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def filtered_inorder(root: Node, filter_func: callable) -> list[int]: Perform inorder traversal of a binary tree and filter nodes based on `filter_func`. Args: - root (Node): The root node of the binary tree. - filter_func (callable): A function that takes an integer value and returns True if this node should be included in the result, False otherwise. Returns: - list[int]: The inorder traversal list of node values after applying the filter. def inorder(node: Node): if node is None: return [] # Traverse the left subtree result = inorder(node.left) # Visit the node itself if it passes the filter if filter_func(node.val): result.append(node.val) # Traverse the right subtree result.extend(inorder(node.right)) return result return inorder(root)"},{"question":"# Objective: Write a function that detects whether a given sentence is a pangram for the lowercase Latin alphabet. # Scenario: A linguistic validation tool needs to ensure that input text messages are fully inclusive of every letter from \'a\' to \'z\' at least once. Implement a function to determine if the given sentence fits this criterion. # Function Details: **Function Name**: `is_pangram` **Input**: - `sentence` (str): A string containing the sentence to be checked. The string can include uppercase and lowercase letters, spaces, punctuation, and numeric characters. **Output**: - A boolean value: `True` if the input string is a pangram, `False` otherwise. # Constraints: 1. The sentence can have a length ranging from 0 to 10^6. 2. The function should handle upper and lower case characters by treating them equivalently. 3. Non-alphabet characters are to be ignored in the pangram check. # Example: ```python >>> is_pangram(\\"The quick brown fox jumps over the lazy dog\\") True >>> is_pangram(\\"The quick brown fox.\\") False >>> is_pangram(\\"\\") False >>> is_pangram(\\"abcdefghijklmnopqrstuvwxyz\\") True ``` # Hints: 1. Utilize a `set` to manage and track letter occurrences efficiently. 2. Convert letters to lowercase and ignore non-alphabetic symbols while processing.","solution":"def is_pangram(sentence): Checks if a given sentence is a pangram, meaning it contains every letter from \'a\' to \'z\' at least once. Parameters: sentence (str): The sentence to be checked for being a pangram. Returns: bool: True if the sentence is a pangram, False otherwise. # Create a set of all alphabets alphabet_set = set(\'abcdefghijklmnopqrstuvwxyz\') # Create a set with lowercase alphabets in the sentence sentence_set = set(ch.lower() for ch in sentence if ch.isalpha()) # Check if sentence_set contains all elements of alphabet_set return alphabet_set <= sentence_set"},{"question":"A binary tree node is defined as follows: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` Given two binary trees, write a function `is_same_tree(tree1, tree2)` to check if they are equal or not. **Two binary trees are considered equal if they are structurally identical and the nodes have the same value.** # Function Signature ```python def is_same_tree(tree1: TreeNode, tree2: TreeNode) -> bool: # Your implementation here ``` # Input - `tree1`, `tree2`: TreeNode, the roots of the two binary trees. # Output - Return `True` if the trees are equal, otherwise return `False`. # Constraints - The number of nodes in either tree does not exceed 10^4. - Node values are within the range of `[-1000, 1000]`. # Performance Requirements - The solution should have a time complexity of O(min(N, M)), where N and M are the number of nodes in the trees. - The solution should have a space complexity of O(min(height1, height2)), where height1 and height2 are the respective heights of the two trees. # Examples ```python # Example 1 tree1 = TreeNode(1, TreeNode(2), TreeNode(3)) tree2 = TreeNode(1, TreeNode(2), TreeNode(3)) assert is_same_tree(tree1, tree2) == True # Example 2 tree1 = TreeNode(1, TreeNode(2)) tree2 = TreeNode(1, None, TreeNode(2)) assert is_same_tree(tree1, tree2) == False # Example 3 tree1 = TreeNode(1, TreeNode(2), TreeNode(1)) tree2 = TreeNode(1, TreeNode(1), TreeNode(2)) assert is_same_tree(tree1, tree2) == False ``` Create the function `is_same_tree()` to determine whether two binary trees are identical.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_same_tree(tree1: TreeNode, tree2: TreeNode) -> bool: # If both nodes are None, trees are identical up to this node if not tree1 and not tree2: return True # If one of the nodes is None, trees are not identical if not tree1 or not tree2: return False # If values of both nodes are different, trees are not identical if tree1.value != tree2.value: return False # Recursively check the left and right subtrees return is_same_tree(tree1.left, tree2.left) and is_same_tree(tree1.right, tree2.right)"},{"question":"# Problem Description A software company requires a function to verify if a given string is a palindrome, especially for ensuring the uniqueness of user identifiers. To achieve this, you must implement a function that considers only alphanumeric characters and is case-insensitive. Given the potential for strings with various formats (spaces, punctuation, mixed cases), you are to implement a solution that efficiently determines if a string is a palindrome. # Function Specification Implement the function `is_palindrome_advanced(s)` which takes a single argument: * `s` (str): the string to check. The function should return a boolean: * `True` if the string is a palindrome. * `False` if it is not. # Constraints * The input string `s` can be empty. * The input string `s` can contain uppercase, lowercase, numbers, spaces, and punctuation/special characters. # Input and Output * Example Input: `\\"A man, a plan, a canal: Panama\\"` * Example Output: `True` * Example Input: `\\"race a car\\"` * Example Output: `False` # Requirements 1. The function should handle strings with punctuation, spaces, and mixed cases efficiently. 2. You must minimize space complexity; avoid using additional data structures if possible. # Evaluation Criteria * Accuracy in identifying valid palindromes across varied formats. * Efficiency in time and space complexity. * Code readability and adherence to pythonic practices.","solution":"def is_palindrome_advanced(s): Checks if the given string is a palindrome considering only alphanumeric characters and is case-insensitive. # Sanitize the string by removing non-alphanumeric characters and converting to lower case cleaned_s = \'\'.join(char.lower() for char in s if char.isalnum()) # Check if the sanitized string is a palindrome return cleaned_s == cleaned_s[::-1]"},{"question":"# Merge Sort Optimization Problem Merge Sort is a well-known sorting algorithm based on a divide-and-conquer approach. It offers consistent O(n log(n)) time complexity due to its recurrent halving and merging strategy. However, one of its drawbacks is its space complexity, caused by the need to allocate additional space for auxiliary arrays during the merge process. Task: **Optimize** the provided Merge Sort algorithm to perform the merging step in place with minimized additional space while maintaining its stability and O(n log(n)) time complexity. # Function Requirements: Implement a function `merge_sort_inplace(arr: List[int]) -> List[int]` that: 1. Sorts the given list `arr` in ascending order using Merge Sort. 2. Minimizes additional space during the merging process. 3. Does not create multiple copies of the array or unnecessary list allocations. 4. Maintains the stability of the sorting algorithm. # Code Constraints: - The input list `arr` contains integer elements. - The length of `arr` is between 0 and 1000, inclusive. # Example Usage: ```python merge_sort_inplace([38, 27, 43, 3, 9, 82, 10]) ``` Expected Output: ``` [3, 9, 10, 27, 38, 43, 82] ``` **Implementation Details**: To attain in-place merging, one possible approach is to iteratively perform the merge directly within the original array. Consider utilizing temporary storage only when merging two halves, then overwrite the existing segments with sorted elements. Remember, the key challenge is balancing in-place modification with control over indices and partitions during the sort-and-merge steps.","solution":"def merge_sort_inplace(arr): In-place merge sort implementation. def merge(arr, start, mid, end): start2 = mid + 1 # If the direct merge is already sorted if arr[mid] <= arr[start2]: return # Two pointers to maintain start of both arrays to merge while start <= mid and start2 <= end: # If element 1 is in right place if arr[start] <= arr[start2]: start += 1 else: value = arr[start2] index = start2 # Shift all the elements between element 1 # element 2, right by 1. while index != start: arr[index] = arr[index - 1] index -= 1 arr[start] = value # Update all the pointers start += 1 mid += 1 start2 += 1 def merge_sort(arr, l, r): if l < r: m = l + (r - l) // 2 merge_sort(arr, l, m) merge_sort(arr, m + 1, r) merge(arr, l, m, r) merge_sort(arr, 0, len(arr) - 1) return arr # Example usage print(merge_sort_inplace([38, 27, 43, 3, 9, 82, 10]))"},{"question":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return them as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. # Function Signature ```python def add_two_numbers(left: Node, right: Node) -> Node: ``` # Input Format * The `left` and `right` inputs are of `Node` type and can be represented as follows: `Node(2) -> Node(4) -> Node(3)` representing the number `342`. # Output Format * The function should return a linked list which represents the sum of the two input numbers: `Node(7) -> Node(0) -> Node(8)` representing the number `807`. # Constraints * The number of nodes in the linked list is in the range `[1, 100]`. * Each node contains a single digit (`0-9`). # Example ```python # Example 1: # Input number1 = Node(2) number1.next = Node(4) number1.next.next = Node(3) number2 = Node(5) number2.next = Node(6) number2.next.next = Node(4) # Output # 807 represented as a linked list: 7 -> 0 -> 8 result = add_two_numbers(number1, number2) # should return Node(7) -> Node(0) -> Node(8) ``` # Unit Tests You are required to write unit tests to cover various edge cases including, but not limited to: * Number of different lengths. * Resulting in a carry into a new, most significant digit. * Numbers with different leading zeros.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(left: Node, right: Node) -> Node: Adds two numbers represented as linked lists in reverse order. Parameters: left (Node): The head of the first linked list. right (Node): The head of the second linked list. Returns: Node: The head of the linked list representing the sum of the two numbers. dummy_head = Node(0) current = dummy_head carry = 0 while left is not None or right is not None: left_val = left.val if left is not None else 0 right_val = right.val if right is not None else 0 total = left_val + right_val + carry carry = total // 10 current.next = Node(total % 10) current = current.next if left is not None: left = left.next if right is not None: right = right.next if carry > 0: current.next = Node(carry) return dummy_head.next"},{"question":"You are given a potentially deeply nested array which may contain other arrays (sub-arrays). Your task is to implement a function `flatten_array` that takes such a nested array as input and returns a single, flattened array where all the elements appear in the same order as they did in the original nested structure. Function Signature ```python def flatten_array(nested_arr: list) -> list: pass ``` Input * `nested_arr` (list): A list that may contain nested lists, non-iterables, and strings. Output * `list`: A single-dimensional list with all elements from the nested structure. Constraints 1. Elements of the `nested_arr` are non-negative integers, strings, or nested lists. 2. The depth of nested lists will not exceed 1000 to prevent stack overflow in recursion. Examples ```python flatten_array([[1, 2, [3]], 4]) # [1, 2, 3, 4] flatten_array([1, [2, [3, 4]], 5]) # [1, 2, 3, 4, 5] flatten_array([[[[[1]]]]]) # [1] flatten_array([\'a\', [\'b\', [\'c\']]]) # [\'a\', \'b\', \'c\'] ``` Scenario Imagine you\'re working on a project that processes hierarchical data structures, and you need a flat data structure for easier manipulation. Implement this function to convert any nested data structure into a simple list for further data processing.","solution":"def flatten_array(nested_arr: list) -> list: def _flatten_helper(element): if isinstance(element, list): for item in element: yield from _flatten_helper(item) else: yield element return list(_flatten_helper(nested_arr))"},{"question":"# Subset Generation Challenge Problem Statement You are given a list of distinct integers, `nums`. Your task is to write a function `custom_subsets(nums)` that returns all possible subsets (the power set) of the list. The solution set must not contain duplicate subsets, and the subsets should be returned as a set of tuples. Function Signature ```python def custom_subsets(nums: List[int]) -> Set[Tuple[int]]: pass ``` Input * A list of distinct integers `nums` with `0 <= len(nums) <= 20`. Output * A set of tuples, where each tuple is a subset of `nums`. Example ```python # Example 1 input: nums = [1, 2, 3] output: { (), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3) } # Example 2 input: nums = [] output: {()} ``` Constraints * The list `nums` contains distinct integers with a length of at most 20. * The order of subsets within the output set does not matter. Notes * Make sure your function handles the edge case where `nums` is an empty list. * Consider using bit representation for generating subsets as it offers a concise and efficient approach. Challenge: Write the `custom_subsets` function to generate all possible subsets of the input list `nums` using bit manipulation. Ensure the solution handles different edge cases correctly and includes comprehensive error handling. **Performance:** Although the function\'s complexity is exponential due to the nature of the subset generation problem, strive to keep the implementation efficient and readable through proper use of bit manipulation.","solution":"from typing import List, Set, Tuple def custom_subsets(nums: List[int]) -> Set[Tuple[int]]: Generates all possible subsets of the input list nums. Each subset is returned as a tuple within a set of tuples. subsets = set() n = len(nums) # There are 2^n possible subsets for a list of length n. for i in range(2**n): subset = [] for j in range(n): # Check if the j-th bit in the integer i is set if i & (1 << j): subset.append(nums[j]) subsets.add(tuple(subset)) return subsets"},{"question":"# RandomizedSet Implementation **Scenario**: You are tasked with designing and implementing a custom data structure called `RandomizedSet` that supports insertion, deletion, and random selection of elements in average O(1) time complexity. This data structure will be particularly useful in scenarios where you need to efficiently manage a dynamic collection and retrieve elements uniformly at random. **Function Specifications**: 1. **Initialization**: `RandomizedSet()` - Initializes the data structure. 2. **Insert**: `insert(val: int) -> bool` - Inserts an element `val` into the set if not already present. Returns `True` if the element was inserted, `False` otherwise. 3. **Remove**: `remove(val: int) -> bool` - Removes an element `val` from the set if present. Returns `True` if the element was removed, `False` otherwise. 4. **Random Element**: `random_element() -> int` - Retrieves a random element from the set. Each element must have the same probability of being returned. **Input/Output**: * `insert(val: int) -> bool` * Inserts an element into the set. Returns `True` if inserted, `False` if already present. * `remove(val: int) -> bool` * Removes an existing element from the set. Returns `True` if removed, `False` if not present. * `random_element() -> int` * Returns a random element from the set. **Constraints**: 1. All values for `val` will be integers within the range from -10^6 to 10^6. 2. Performance must be maintained within average O(1) time complexity for insertions, deletions, and random element retrieval operations. **Example**: ```python rset = RandomizedSet() print(rset.insert(1)) # Output: True print(rset.insert(2)) # Output: True print(rset.insert(1)) # Output: False print(rset.remove(1)) # Output: True print(rset.remove(1)) # Output: False print(rset.random_element()) # Output: Randomly 2 or any other present element ``` Implement the `RandomizedSet` class according to the specifications above.","solution":"import random class RandomizedSet: def __init__(self): Initialize the data structure. self.data_list = [] self.data_map = {} def insert(self, val: int) -> bool: Inserts an element into the set. Returns `True` if inserted, `False` if already present. if val in self.data_map: return False self.data_map[val] = len(self.data_list) self.data_list.append(val) return True def remove(self, val: int) -> bool: Removes an element from the set if present. Returns `True` if removed, `False` otherwise. if val not in self.data_map: return False index = self.data_map[val] last_element = self.data_list[-1] self.data_list[index] = last_element self.data_map[last_element] = index self.data_list.pop() del self.data_map[val] return True def random_element(self) -> int: Retrieves a random element from the set. Each element has the same probability of being returned. return random.choice(self.data_list)"},{"question":"# Context You are working on optimizing a database system that uses a self-balancing binary search tree to manage indexes. Red-Black Trees are chosen due to their efficiency in insert, delete, and search operations. You are tasked with implementing a part of this system. # Task Implement methods for inserting and finding the largest and smallest values in a Red-Black Tree. The tree should maintain its balancing properties after each insertion. # Function Signature: ```python class RBNode: def __init__(self, val, is_red, parent=None, left=None, right=None): # initialization as per the provided snippet class RBTree: def __init__(self): # initialization as per the provided snippet def insert(self, val): Insert a node with the given value into the Red-Black Tree. :param val: Value to be inserted. :type val: int # Your code goes here... def find_min(self): Find the minimum value in the Red-Black Tree. :return: Minimum value. :rtype: int # Your code goes here... def find_max(self): Find the maximum value in the Red-Black Tree. :return: Maximum value. :rtype: int # Your code goes here... # Example Usage: rb_tree = RBTree() values = [20, 15, 30, 10, 18, 25, 40] for value in values: rb_tree.insert(value) print(\\"Minimum value:\\", rb_tree.find_min()) # Output should be 10 print(\\"Maximum value:\\", rb_tree.find_max()) # Output should be 40 ``` # Inputs - `val` (int): The integer value to be inserted into the tree. # Outputs - The methods `find_min` and `find_max` should return integers representing the smallest and largest values in the tree respectively. # Constraints - Do not use built-in data structures from libraries which defeat the purpose of the implementation. - Insert values must be unique. # Performance Requirements - Ensure that all operations maintain the Red-Black tree properties and perform within O(log n) time complexity.","solution":"class RBNode: def __init__(self, val, is_red=True, parent=None, left=None, right=None): self.val = val self.is_red = is_red self.parent = parent self.left = left self.right = right class RBTree: def __init__(self): self.root = None def insert(self, val): new_node = RBNode(val) if not self.root: self.root = new_node else: self._insert(self.root, new_node) self._fix_insert(new_node) def _insert(self, current, new_node): if new_node.val < current.val: if current.left: self._insert(current.left, new_node) else: current.left = new_node new_node.parent = current else: if current.right: self._insert(current.right, new_node) else: current.right = new_node new_node.parent = current def _fix_insert(self, node): while node != self.root and node.parent.is_red: if node.parent == node.parent.parent.left: uncle = node.parent.parent.right if uncle and uncle.is_red: node.parent.is_red = False uncle.is_red = False node.parent.parent.is_red = True node = node.parent.parent else: if node == node.parent.right: node = node.parent self._rotate_left(node) node.parent.is_red = False node.parent.parent.is_red = True self._rotate_right(node.parent.parent) else: uncle = node.parent.parent.left if uncle and uncle.is_red: node.parent.is_red = False uncle.is_red = False node.parent.parent.is_red = True node = node.parent.parent else: if node == node.parent.left: node = node.parent self._rotate_right(node) node.parent.is_red = False node.parent.parent.is_red = True self._rotate_left(node.parent.parent) self.root.is_red = False def _rotate_left(self, node): right = node.right node.right = right.left if right.left: right.left.parent = node right.parent = node.parent if not node.parent: self.root = right elif node == node.parent.left: node.parent.left = right else: node.parent.right = right right.left = node node.parent = right def _rotate_right(self, node): left = node.left node.left = left.right if left.right: left.right.parent = node left.parent = node.parent if not node.parent: self.root = left elif node == node.parent.left: node.parent.left = left else: node.parent.right = left left.right = node node.parent = left def find_min(self): node = self.root while node.left: node = node.left return node.val def find_max(self): node = self.root while node.right: node = node.right return node.val"},{"question":"# Assessing String Anagram You are given two strings ( s ) and ( t ). Write a function `is_anagram(s: str, t: str) -> bool` that determines if ( t ) is an anagram of ( s ). An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Input - ( s ) and ( t ): two strings (1 ≤ length of ( s ), ( t ) ≤ 10^5). The strings will contain only lowercase alphabets. Output - Return `True` if ( t ) is an anagram of ( s ), and `False` otherwise. Constraints - You may assume the string contains only lowercase alphabets. Performance Requirements - Your implementation should aim for O(n) time complexity and O(1) additional space complexity, considering the fixed alphabet size. Example ``` Input: s = \\"anagram\\", t = \\"nagaram\\" Output: true Input: s = \\"rat\\", t = \\"car\\" Output: false ``` Notes - Optimize your solution to handle scenarios where the two strings have different lengths early. Scenario Imagine you\'re developing a feature for a word game where you need to verify if a shuffled version of a given word can be formed from another list of letters. This function can quickly verify the feasibility of the shuffling, ensuring smooth gameplay. Implement `is_anagram` ensuring optimal performance and correctness.","solution":"def is_anagram(s: str, t: str) -> bool: Determines if `t` is an anagram of `s`. if len(s) != len(t): return False char_count = [0] * 26 # There are 26 lowercase English letters for char in s: char_count[ord(char) - ord(\'a\')] += 1 for char in t: char_count[ord(char) - ord(\'a\')] -= 1 if char_count[ord(char) - ord(\'a\')] < 0: return False return True"},{"question":"Remove a Range from a Linked List You are given a singly linked list and two indices `start` and `end`. Your task is to implement the function `remove_range(head, start, end)` that removes the elements from the linked list starting at index `start` to index `end` (inclusive). Function Signature: ```python def remove_range(head: ListNode, start: int, end: int) -> ListNode: ``` Input: - `head`: ListNode, the head of the singly linked list. - `start`: int, the start index (0-based) where removal begins. - `end`: int, the end index (0-based) where removal ends. Output: - The function should return the head of the modified list. Constraints: - The list is non-empty. - `0 <= start <= end < length of list`. - Assume the ListNode class is defined as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Example: ```python # Example 1: # Input List: 8 -> 13 -> 17 -> 4 -> 9 -> 12 -> 98 -> 41 -> 7 -> 23 -> 0 -> 92 # Calling remove_range with start=3, end=8 # Output List: 8 -> 13 -> 17 -> 23 -> 0 -> 92 # Example 2: # Input List: 1 -> 2 -> 3 -> 4 -> 5 # Calling remove_range with start=0, end=2 # Output List: 4 -> 5 ``` Notes: - Ensure to handle the case where the removal starts from the head node. - Implementation should be efficient both in terms of time and space. - Carefully handle the linked list pointers to avoid breaking the integrity of the list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_range(head: ListNode, start: int, end: int) -> ListNode: if head is None: return None dummy = ListNode(0) dummy.next = head prev = dummy # Find the node just before the start of the range to be removed for _ in range(start): prev = prev.next # Remove the range from start to end current = prev.next for _ in range(end - start + 1): if current is not None: current = current.next prev.next = current return dummy.next"},{"question":"Context You are tasked with enhancing the Comb Sort algorithm to address its performance when dealing with lists that are nearly sorted. You need to write an optimized version of Comb Sort that not only reduces the average time complexity but also handles certain edge cases more efficiently. Instructions Implement an optimized version of Comb Sort where the shrink factor dynamically adjusts based on the percentage of sorted elements in the list. 1. **Function Signature**: ```python def optimized_comb_sort(arr: List[int]) -> List[int]: ``` 2. **Input**: * `arr` (List[int]): A list of integers to be sorted. 3. **Output**: * Returns a list of integers sorted in non-decreasing order. 4. **Constraints**: * 1 ≤ len(arr) ≤ 10^5 * -10^9 ≤ arr[i] ≤ 10^9 5. **Performance Requirements**: * Your solution should handle edge cases like already sorted lists, reverse-sorted lists, and uniformly valued lists efficiently. * Average case time complexity must be improved compared to standard Comb Sort. Example ```python assert optimized_comb_sort([5, 3, 7, 1, 9]) == [1, 3, 5, 7, 9] assert optimized_comb_sort([1, 2, 3, 4]) == [1, 2, 3, 4] assert optimized_comb_sort([4, 3, 2, 1]) == [1, 2, 3, 4] assert optimized_comb_sort([5, 5, 5, 5]) == [5, 5, 5, 5] ``` Notes * Focus on finding a balance between the gap reduction and the number of swaps. * Consider using additional metrics to track how sorted the array is during the execution, which can help better adjust the shrink factor dynamically.","solution":"from typing import List def optimized_comb_sort(arr: List[int]) -> List[int]: def get_next_gap(gap): # Shrink factor for Comb Sort approximation is set to 1.3 as per average case analysis gap = int(gap / 1.3) if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# String Isomorphism Checker: Advanced Version **Problem Statement**: Write a function `is_advanced_isomorphic` to determine if two strings `s` and `t` are isomorphic, applying the same rules as the basic version. However, enhance your solution to ignore non-alphabetic characters when making the comparisons. The function should treat alphabetical characters case insensitively (e.g., \'A\' will be treated the same as \'a\'). **Input**: - `s`: A string containing alphanumeric characters. - `t`: A string containing alphanumeric characters. - The length of both strings will not exceed 10^4. **Output**: - Return `True` if `s` and `t` are isomorphic incorporating the new rules. Otherwise, return `False`. **Constraints**: - Both `s` and `t` are not equal in size and may contain non-alphabetical characters. **Examples**: 1. Input: `s = \\"Paper!3\\"`, `t = \\"Title#3\\"` Output: True 2. Input: `s = \\"Fo%o\\"`, `t = \\"Ba@r\\"` Output: False 3. Input: `s = \\"Cat@12cAT\\"`, `t = \\"Dog@12dOG\\"` Output: True **Explanation**: The function `is_advanced_isomorphic` should handle non-alphabetic characters by ignoring them and treating all alphabetic characters in a case-insensitive manner. **Implementation Requirements**: - Optimize for time and space efficiency. - Ensure the solution passes edge cases for mixed characters. You can assume that: - Uppercase and lowercase letters are treated as the same character. - Non-alphabetical characters should be ignored in comparing the mappings. **Starting Point**: ```python def is_advanced_isomorphic(s, t): # Implement your solution here pass # Feel free to add additional helper methods if needed ```","solution":"def is_advanced_isomorphic(s, t): Determines if two strings s and t are isomorphic, considering only alphabetic characters and ignoring case. def normalize(word): # Normalize the word by filtering out non-alphabetic chars and converting to lower case return \'\'.join([ch.lower() for ch in word if ch.isalpha()]) s, t = normalize(s), normalize(t) if len(s) != len(t): return False s_to_t, t_to_s = {}, {} for char_s, char_t in zip(s, t): if (char_s in s_to_t and s_to_t[char_s] != char_t) or (char_t in t_to_s and t_to_s[char_t] != char_s): return False s_to_t[char_s] = char_t t_to_s[char_t] = char_s return True"},{"question":"# Shell Sort - Array Sorting Function We have analyzed the Shell Sort algorithm, which sorts an array using a sequence of gap-based comparisons. This algorithm is more efficient than simple quadratic algorithms for medium-sized arrays, especially when the array is partially sorted. Problem Description You are required to write a function `shell_sort_custom(arr, gap_sequence)` that accepts an array of integers and a list defining a custom gap sequence. The function should sort the array using the provided gap sequence. Function Signature ```python def shell_sort_custom(arr, gap_sequence): Sort the array using Shell Sort with a provided gap sequence. Parameters: arr (list of int): The list of integers to be sorted. gap_sequence (list of int): The sequence of gap values to use in the Shell Sort. Returns: list of int: The sorted list of integers. ``` Examples Example 1: ```python arr = [8, 5, 4, 2, 1, 3, 7, 6] gap_sequence = [5, 3, 1] print(shell_sort_custom(arr, gap_sequence)) # Output: [1, 2, 3, 4, 5, 6, 7, 8] ``` Example 2: ```python arr = [19, 2, 31, 45, 6, 11, 121, 27] gap_sequence = [4, 2, 1] print(shell_sort_custom(arr, gap_sequence)) # Output: [2, 6, 11, 19, 27, 31, 45, 121] ``` Constraints * Input array length: (1 leq n leq 10^5) * Elements in array: ( -10^9 leq arr[i] leq 10^9 ) * The gap sequence should always end with 1. * The gap sequence should have gaps greater than or equal to 1 and reduce logically (i.e., should follow descending order). Performance Requirements * The implementation should be efficient in terms of time complexity, ideally close to O(n log n) using appropriate gap sequences. Use the provided gap sequence accurately to ensure the array is sorted correctly, considering edge cases such as reverse-ordered lists, duplicate elements, and already sorted lists.","solution":"def shell_sort_custom(arr, gap_sequence): Sort the array using Shell Sort with a provided gap sequence. Parameters: arr (list of int): The list of integers to be sorted. gap_sequence (list of int): The sequence of gap values to use in the Shell Sort. Returns: list of int: The sorted list of integers. n = len(arr) for gap in gap_sequence: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Task: Improved Selection Sort **Objective**: Write a python function which implements an improved version of selection sort that: - Stops early if the array becomes sorted before all iterations are completed. - Counts the total number of swaps made during the sorting process. **Function Signature**: ```python def improved_selection_sort(arr: List[int], simulation: bool = False) -> Tuple[List[int], int]: Sorts an array using improved selection sort and counts the number of swaps. Parameters: arr (List[int]): The list to be sorted. simulation (bool): If True, print the array at each iteration of the outer loop. Returns: Tuple[List[int], int]: The sorted list and the number of swaps performed. # Implementation here ``` # Input: - `arr`: A list of integers. (1 <= len(arr) <= 1000) and (-10^3 <= arr[i] <= 10^3) - `simulation` (optional): A boolean flag indicating whether to print the array\'s state after each outer loop iteration. # Output: - Returns the sorted list and the total number of swaps made as a tuple. # Constraints: - The solution should handle lists with up to 1000 elements efficiently. - Reducing unnecessary operations for already sorted or partially sorted lists can be a useful optimization. # Performance Requirements: - The time complexity still remains O(n^2) due to nested loops, but unnecessary cycles should be minimized. - The implementation should operate within O(1) extra space, i.e., in-place sorting. # Example: ```python arr = [64, 25, 12, 22, 11] print(improved_selection_sort(arr, simulation=True)) # Should output the sorted array and number of swaps # iteration 0 : 11 25 12 22 64 # iteration 1 : 11 12 25 22 64 # iteration 2 : 11 12 22 25 64 # iteration 3 : 11 12 22 25 64 # iteration 4 : 11 12 22 25 64 # ( [11, 12, 22, 25, 64], 4 ) ``` When the `simulation` is set to True, the function should print the array at each iteration of the outer loop, similar to the provided selection sort implementation.","solution":"from typing import List, Tuple def improved_selection_sort(arr: List[int], simulation: bool = False) -> Tuple[List[int], int]: n = len(arr) swap_count = 0 for i in range(n - 1): min_index = i sorted_flag = True for j in range(i + 1, n): if arr[j] < arr[min_index]: min_index = j sorted_flag = False if sorted_flag: break if min_index != i: arr[i], arr[min_index] = arr[min_index], arr[i] swap_count += 1 if simulation: print(f\'Iteration {i} : {arr}\') return arr, swap_count"},{"question":"You are given a non-empty list of integers where every element appears exactly twice, except for one element which appears only once. Your task is to implement a function that finds this single one using an efficient algorithm with linear time complexity and constant space complexity. # Function Signature ```python def single_number(nums: List[int]) -> int: Returns the single number that appears an odd number of times. :param nums: List[int] - List of integers where every element appears exactly twice except one. :return: int - The single number that appears only once. ``` # Input - `nums`: A list of integers. Constraints: * The list is non-empty. * Every element in the list appears exactly twice, except for one element which appears only once. # Output - Returns the integer that appears only once in the `nums` list. # Example ```python # Example 1 Input: [2, 2, 3, 4, 4] Output: 3 # Example 2 Input: [4, 1, 2, 1, 2] Output: 4 # Example 3 Input: [1] Output: 1 ``` # Constraints - You must implement the function with a time complexity of O(n). - You should not use any extra memory, implying space complexity of O(1). # Note - Ensure to handle edge cases such as lists with a single element and verify the function works with positive, negative, and zero values.","solution":"from typing import List def single_number(nums: List[int]) -> int: Returns the single number that appears only once in the list where every element appears exactly twice except one. :param nums: List[int] - List of integers where every element appears exactly twice except one. :return: int - The single number that appears only once. result = 0 for num in nums: result ^= num return result"},{"question":"Context You are tasked to write functions that perform common search tasks on an array of integers. To evaluate your understanding, you need to design and implement a function to find the last occurrence of a given integer in the array using linear search. Requirements * Implement a function `find_last_occurrence(array, query)`. * The function should take: * `array` (a list of integers) * `query` (an integer to search for). * The function should return: * The **index** of the last occurrence of the `query` if it exists. * `-1` if `query` is not present in the array. * You should consider edge cases, such as: * The array is empty. * The `query` does not exist in the array. **Input** * `array`: List of integers `[-10^3 <= array[i] <= 10^3]` * `query`: Integer `[-10^3 <= query <= 10^3]` **Output** * Integer representing the last index of occurrence of the query element in the array, or -1 if not found. **Example** ```python # Example 1: array = [1, 2, 3, 4, 2, 5, 1, 2] query = 2 # should return 7 because the last occurrence of 2 is at index 7. # Example 2: array = [10, 22, 30, 47, 53] query = 29 # should return -1 because 29 is not present in the array. ```","solution":"def find_last_occurrence(array, query): Returns the index of the last occurrence of query in the array. If the query does not exist in the array, returns -1. last_index = -1 for i in range(len(array)): if array[i] == query: last_index = i return last_index"},{"question":"# Array Rotation Challenge You are tasked with rotating an array of `n` elements to the right by `k` steps. Implement the rotation function in at least two different ways, demonstrating an in-depth understanding of time and space complexity considerations. You need to write two functions: 1. `rotate_in_place(array, k)`: - Rotate the array in-place and have constant space complexity. - Use the array-reversing technique. 2. `rotate_with_slicing(array, k)`: - Create a new rotated array using slicing methods. - Ensure the function accomplishes rotation in linear time. Function Signatures ```python def rotate_in_place(array: list[int], k: int) -> None: # Rotate array in-place using reversing technique def rotate_with_slicing(array: list[int], k: int) -> list[int]: # Return a new rotated array using slicing ``` Input and Output - **Input**: - `array`: A list of integers representing the array to rotate. - `k`: An integer representing the number of rotation steps. - **Output**: - For `rotate_in_place`: No return value, modify `array` in-place. - For `rotate_with_slicing`: Return a new list that is the rotated version of `array`. Constraints - 1 ≤ `n` ≤ 10^5 - 0 ≤ `k` ≤ 10^5 - -10^9 ≤ array[i] ≤ 10^9 - You may assume that `k` is a non-negative integer. # Examples Example 1 ```python array = [1, 2, 3, 4, 5, 6, 7] k = 3 rotate_in_place(array, k) # After calling function, array becomes: [5, 6, 7, 1, 2, 3, 4] rotated_array = rotate_with_slicing(array, k) # rotated_array should be: [5, 6, 7, 1, 2, 3, 4] ``` Example 2 ```python array = [-1, -100, 3, 99] k = 2 rotate_in_place(array, k) # After calling function, array becomes: [3, 99, -1, -100] rotated_array = rotate_with_slicing(array, k) # rotated_array should be: [3, 99, -1, -100] ``` # Scenario Consider a situation where you have a queue of tasks in an array, and the system periodically shifts assignments. Implementing these rotations efficiently helps in mimicking the effect of rotating tasks without the need to constantly create new structures, optimizing both time and memory usage.","solution":"def rotate_in_place(array, k): Rotate the array to the right by k steps in-place using the array-reversing technique. n = len(array) k = k % n # In case k is larger than n reverse(array, 0, n - 1) reverse(array, 0, k - 1) reverse(array, k, n - 1) def reverse(array, start, end): while start < end: array[start], array[end] = array[end], array[start] start += 1 end -= 1 def rotate_with_slicing(array, k): Rotate the array to the right by k steps using slicing and return the new array. n = len(array) k = k % n # In case k is larger than n return array[-k:] + array[:-k]"},{"question":"# Prime Numbers within a Specified Range Scenario You\'re designing a feature for a cryptographic application that requires frequent checking for prime numbers within large ranges. For optimal performance, you need to implement a solution efficiently finding all prime numbers within a given range `[m, n]`. Task Write a function `find_primes_in_range(m: int, n: int) -> List[int]`: **Function Signature**: ```python def find_primes_in_range(m: int, n: int) -> List[int]: pass ``` **Input**: * `m` (int): Start of the range (inclusive), `1 <= m <= 10^6`. * `n` (int): End of the range (inclusive), `m <= n <= 10^6`. **Output**: * A list of integers containing all prime numbers within the range `[m, n]`. **Constraints**: * The function should efficiently handle the given input constraints. * Implement your solution to handle edge cases effectively. Example ```python assert find_primes_in_range(1, 10) == [2, 3, 5, 7] assert find_primes_in_range(10, 20) == [11, 13, 17, 19] assert find_primes_in_range(1, 1) == [] assert find_primes_in_range(20, 20) == [] ``` **Performance Requirements**: * The solution should have a time complexity better than O(n^2). Consider an optimized approach to reduce redundancies.","solution":"from typing import List def is_prime(num: int) -> bool: Helper function to check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def find_primes_in_range(m: int, n: int) -> List[int]: Returns a list of all prime numbers in the range [m, n]. primes = [] for num in range(m, n + 1): if is_prime(num): primes.append(num) return primes"},{"question":"# Path Resolution Function Scenario Your task is to create a function that transforms a provided file path into an absolute path. This function should handle both relative paths and paths that include a leading tilde (`~`). The function must ensure the final path is absolute and properly expanded. Problem Statement Implement a function named `resolve_path` that takes a single string argument representing a file path. The function should return the absolute path after expanding any user directory symbols. Function Signature ```python def resolve_path(file_path: str) -> str: ``` Input * `file_path` (str): A file path in string format. This can include relative paths, absolute paths, or paths starting with `~` to represent the user\'s home directory. Output * Returns a string representing the absolute path. Constraints * You should assume the input is always a valid string. * The function needs to be implemented without using any try-except blocks. * Performance should be optimal given typical file path lengths. Examples ```python assert resolve_path(\\"~/Documents/notes.txt\\") == \\"/home/username/Documents/notes.txt\\" assert resolve_path(\\"../../../etc/passwd\\") == \\"/etc/passwd\\" ``` Detailed Requirements 1. Expand any `~` to the user\'s home directory. 2. Convert any relative paths to their absolute equivalents. 3. Return the final absolute path string. Remember to handle various edge cases such as deeply nested relative paths.","solution":"import os def resolve_path(file_path: str) -> str: Resolves a given file path to an absolute path, expanding ~ to the home directory if present. Parameters: file_path (str): A file path in string format. Returns: str: The absolute path. return os.path.abspath(os.path.expanduser(file_path))"},{"question":"# Question: Implement LSD Radix Sort **Context**: You are given a list of non-negative integers that represents a sequence of priorities in a task management system. Your task is to sort this list in ascending order using the LSD (Least Significant Digit) variant of Radix Sort. The list can be very large, so the algorithm must be efficient in terms of both time and space complexity. **Function Signature**: ```python def radix_sort(arr: List[int], simulation: bool=False) -> List[int]: pass ``` **Input**: * `arr`: A list of non-negative integers. * `simulation`: A boolean, default `False`. If `True`, print the array after each digit sorting iteration to show the sorting progress. **Output**: * A sorted list of integers in ascending order. **Constraints**: * The length of `arr` will not exceed (10^6) elements. * Each number in `arr` will not exceed (10^9). **Performance Requirements**: * Ensure the sorting algorithm operates within the time complexity of O(nk). **Edge Cases**: * An empty list should return an empty list. * A list with one element should return the same list. * A list where all elements are the same. **Examples**: ```python assert radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802] assert radix_sort([]) == [] assert radix_sort([5]) == [5] assert radix_sort([7, 7, 7]) == [7, 7, 7] ``` **Note**: * Negative numbers are outside the scope of this problem and should not be included in the test cases.","solution":"def counting_sort(arr, exp, simulation): n = len(arr) output = [0] * n # the output array elements that will have sorted arr count = [0] * 10 # initialize count array as 0 # store count of occurrences in count[] for i in range(n): index = arr[i] // exp count[index % 10] += 1 # change count[i] so that count[i] now contains actual position of # this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # build the output array i = n - 1 while i >= 0: index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 for i in range(len(arr)): arr[i] = output[i] if simulation: print(arr) def radix_sort(arr, simulation=False): max1 = max(arr) if arr else 0 # use 0 if the list is empty exp = 1 while max1 // exp > 0: counting_sort(arr, exp, simulation) exp *= 10 return arr"},{"question":"# Problem: Optimizing Cuts for Maximum Profit **Scenario**: You are tasked with developing a function to assist a carpenter in maximizing profit from cutting a rod of wood. The carpenter has a rod of length `n`, and you are provided an array `prices` where the `i`-th element represents the price of a rod piece of length `i+1`. Your goal is to determine the maximum profit obtainable by cutting the rod into pieces and selling them. **Function Specifications**: - Implement the function `def max_profit(prices: List[int]) -> int:`. - The function should take a list of integers `prices` and return an integer representing the maximum obtainable profit. **Input**: - `prices`: A list of non-negative integers where `1 <= len(prices) <= 1000` and `0 <= prices[i] <= 10^6`. **Output**: - Integer representing the maximum profit achievable. # Constraints - Consider all possible ways to cut the rod. - Ensure the algorithm has an effective time complexity to handle the upper constraints efficiently. - Optimize the memory usage to avoid excess consumption. # Example **Input**: `[1, 5, 8, 9, 10, 17, 17, 20]` **Output**: `22` **Explanation**: The best way to cut the rod is in two pieces of length 2 and 6 and sell them at prices 5 and 17 respectively. # Notes - The list `prices` will always contain at least one price and at most 1000 prices. - Ensure to handle edge cases such as all prices being the same or varying significantly.","solution":"def max_profit(prices): Returns the maximum profit obtainable by cutting a rod and selling the pieces based on given prices. n = len(prices) dp = [0] * (n + 1) for i in range(1, n + 1): max_val = -1 for j in range(i): max_val = max(max_val, prices[j] + dp[i - j - 1]) dp[i] = max_val return dp[n]"},{"question":"Objective You are tasked with writing code to determine the number of possible combinations of a set of positive integers that sum up to a given target value. You will implement both top-down and bottom-up dynamic programming approaches to solve this problem. Additionally, you should consider how the problem changes if negative numbers are allowed and suggest necessary constraints. Problem Statement Given an integer array `nums` consisting of positive numbers with no duplicates, and an integer `target`, write functions to find the number of possible combinations that add up to `target`. # Function Definitions 1. **Top-Down Approach** ```python def combination_sum_topdown(nums, target): Find number of possible combinations in nums that add up to target, in top-down manner. Args: nums (List[int]): A list of positive integers without duplicates. target (int): The required target sum. Returns: int: The number of possible combinations that add up to target. pass # your implementation here ``` 2. **Bottom-Up Approach** ```python def combination_sum_bottom_up(nums, target): Find number of possible combinations in nums that add up to target, in bottom-up manner. Args: nums (List[int]): A list of positive integers without duplicates. target (int): The required target sum. Returns: int: The number of possible combinations that add up to target. pass # your implementation here ``` Input * `nums`: A list of unique positive integers, e.g., `[1, 2, 3]`. * `target`: A positive integer, e.g., `4`. Output * Return an integer representing the count of possible combinations that add up to `target`. Example ```python nums = [1, 2, 3] target = 4 # Possible combination ways: # (1, 1, 1, 1) # (1, 1, 2) # (1, 2, 1) # (1, 3) # (2, 1, 1) # (2, 2) # (3, 1) # Output: 7 print(combination_sum_topdown(nums, target)) # Expected output: 7 print(combination_sum_bottom_up(nums, target)) # Expected output: 7 ``` Follow-Up 1. **Negative Numbers**: What if negative numbers are allowed in the array `nums`? - Would it be possible to complete the problem using the same approach? - If not, what additional constraints or limitations would you have to place to handle negative numbers correctly? Constraints 1. All elements in `nums` are positive and unique. 2. The `target` is a positive integer. 3. For negative numbers, a solution must include conditions to avoid infinite combinations (such as limiting the number of uses of negative numbers).","solution":"def combination_sum_topdown(nums, target): Find number of possible combinations in nums that add up to target, in top-down manner. Args: nums (List[int]): A list of positive integers without duplicates. target (int): The required target sum. Returns: int: The number of possible combinations that add up to target. from functools import lru_cache @lru_cache(None) def dfs(remaining): if remaining == 0: return 1 if remaining < 0: return 0 count = 0 for num in nums: count += dfs(remaining - num) return count return dfs(target) def combination_sum_bottom_up(nums, target): Find number of possible combinations in nums that add up to target, in bottom-up manner. Args: nums (List[int]): A list of positive integers without duplicates. target (int): The required target sum. Returns: int: The number of possible combinations that add up to target. dp = [0] * (target + 1) dp[0] = 1 # There is one way to make 0, by not choosing any number for i in range(1, target + 1): for num in nums: if i - num >= 0: dp[i] += dp[i - num] return dp[target]"},{"question":"# Question: Implement Optimized Shell Sort To assess your understanding of sorting algorithms and data structures, we want you to implement an enhanced version of the Shell Sort algorithm. The primary improvement lies in optimizing the gap sequence used in the sorting process. Your task is to: 1. Implement an optimized version of the Shell Sort algorithm with an improved gap sequence. 2. Ensure the algorithm efficiently handles edge cases and minimizes the time complexity. Scenario You are a software engineer tasked with sorting a large dataset of numerical values for a transaction processing system. Efficient sorting can significantly optimize the processing time of transactions within the system. Function Signature ```python def optimized_shell_sort(arr: list) -> list: ``` Input - `arr` (List): A list of integers that needs to be sorted. Output - (List): A sorted list of integers. Constraints - The length of the array, `n`, will be in the range [0, 10^5]. - The elements of the array will be integers in the range [-10^9, 10^9]. Requirements 1. Implement the optimized Shell Sort with an improved gap sequence. 2. Your implementation should efficiently handle edge cases such as empty lists and single-element lists. 3. Ensure the final implementation minimizes time complexity and is optimized for large input sizes. Example ```python print(optimized_shell_sort([23, 12, 1, 8, 34, 54, 2, 90])) # Output: [1, 2, 8, 12, 23, 34, 54, 90] print(optimized_shell_sort([45, 23, 9, 89, 17])) # Output: [9, 17, 23, 45, 89] ``` **Hints**: - Consider using Sedgewick\'s gap sequence for improved performance. - Ensure your implementation is robust and can handle large inputs efficiently.","solution":"def optimized_shell_sort(arr: list) -> list: Optimized Shell Sort using Sedgewick\'s gap sequence. def get_sedgewick_gaps(size): gaps = [] k = 0 while True: gap1 = 9 * (4**k - 2**k) + 1 gap2 = (2**(k + 2)) * (2**(k + 2) - 3) + 1 if gap1 < size: gaps.append(gap1) if gap2 < size: gaps.append(gap2) if gap1 >= size and gap2 >= size: break k += 1 gaps = sorted(gaps, reverse=True) return gaps n = len(arr) if n < 2: return arr gaps = get_sedgewick_gaps(n) for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"Scenario You are developing a scheduling application where tasks need to be managed in a way that ensures the highest priority task (represented by the highest value) is always on top. You decide to use a stack data structure that maintains this order automatically. You need to implement such a data structure that ensures every insertion keeps the stack sorted. Task Implement a class `OrderedStack` that maintains the stack in a sorted order at all times. The stack should work efficiently for the following operations: - `push(item)`: Insert an item into the stack according to its value. - `pop()`: Remove the top item from the stack and return it. - `peek()`: Return the top item without removing it. - `is_empty()`: Check if the stack is empty. - `size()`: Return the number of items in the stack. Constraints: - Items inserted into the stack will be integers. - The stack should maintain the highest item on the top throughout all operations. Input and Output Formats: - **Input**: - Each method of the class may be called multiple times. - The sequence of operations will be given in the form of method calls in a main function (or any calling environment). - **Output**: - The `pop()` method should return the integer at the top of the stack. - The `peek()` method should return the integer at the top of the stack without removing it. - The `is_empty()` method should return a boolean indicating if the stack is empty. - The `size()` method should return the current number of items in the stack. # Example: ```python # Example usage: stack = OrderedStack() stack.push(10) stack.push(5) stack.push(20) stack.push(15) print(stack.pop()) # Output: 20 print(stack.peek()) # Output: 15 print(stack.is_empty()) # Output: False print(stack.size()) # Output: 3 ``` Implement the `OrderedStack` class based on the code snippet provided above.","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, item): # Insert item in the correct position to maintain order if self.is_empty() or item >= self.stack[-1]: self.stack.append(item) else: temp_stack = [] while not self.is_empty() and self.stack[-1] > item: temp_stack.append(self.pop()) self.stack.append(item) while temp_stack: self.push(temp_stack.pop()) def pop(self): if not self.is_empty(): return self.stack.pop() raise IndexError(\\"pop from empty stack\\") def peek(self): if not self.is_empty(): return self.stack[-1] raise IndexError(\\"peek from empty stack\\") def is_empty(self): return len(self.stack) == 0 def size(self): return len(self.stack)"},{"question":"Context: You have been tasked with simulating the random behavior of a user navigating through different pages on a website. The user\'s navigation pattern can be modeled using a Markov Chain where each page represents a state, and browsing behavior defines transition probabilities from one page to another. Problem Statement: Write a Python function named `simulate_user_navigation` which uses a Markov Chain to simulate a user\'s page navigation behavior on a website. The function should take the following inputs: - `chain` (dict): A dictionary where each key is a page (state), and the value is another dictionary representing the transition probabilities to the next pages (states). - `start_page` (str): The page where the user starts their navigation. - `num_steps` (int): The number of steps (transitions) to simulate. The function should return a list of pages representing the sequence of pages the user visits, starting from the `start_page` and following the Markov Chain for `num_steps` transitions. Input: - `chain`: A dictionary with page transitions and their probabilities. Example: ```python { \'Home\': {\'About\': 0.1, \'Products\': 0.6, \'Home\': 0.3}, \'About\': {\'Home\': 0.8, \'Products\': 0.2}, \'Products\': {\'Home\': 0.6, \'About\': 0.1, \'Products\': 0.3} } ``` - `start_page`: A string representing the starting page, e.g., `\'Home\'`. - `num_steps`: An integer representing the number of steps to simulate. Output: - A list of pages (strings) visited during the simulation, including the starting page. Constraints: - Assume that the sum of probabilities for each state equals 1.0. - The `chain` dictionary is non-empty and contains valid transition probabilities. # Example Usage: ```python def simulate_user_navigation(chain, start_page, num_steps): # Your implementation here # Example chain = { \'Home\': {\'About\': 0.1, \'Products\': 0.6, \'Home\': 0.3}, \'About\': {\'Home\': 0.8, \'Products\': 0.2}, \'Products\': {\'Home\': 0.6, \'About\': 0.1, \'Products\': 0.3} } start_page = \'Home\' num_steps = 5 simulate_user_navigation(chain, start_page, num_steps) # Possible output: [\'Home\', \'Products\', \'Home\', \'Home\', \'Home\', \'About\'] ``` Requirements: - Ensure that you use the principles of Markov Chains for state transitions. - Define a helper function `__choose_state()` to handle the random choice based on probabilities. - Implement the main function `simulate_user_navigation()` which returns the sequence of pages visited.","solution":"import random def __choose_state(transitions): Choose the next state based on the given transition probabilities. Args: - transitions (dict): A dictionary of states and their corresponding probabilities. Returns: - next_state (str): The chosen next state. states = list(transitions.keys()) probabilities = list(transitions.values()) next_state = random.choices(states, probabilities)[0] return next_state def simulate_user_navigation(chain, start_page, num_steps): Simulate user navigation on a website using a Markov Chain. Args: - chain (dict): A dictionary where each key is a page (state), and the value is another dictionary representing the transition probabilities to the next pages (states). - start_page (str): The page where the user starts their navigation. - num_steps (int): The number of steps (transitions) to simulate. Returns: - visited_pages (list): A list of pages representing the sequence of pages the user visits. visited_pages = [start_page] current_page = start_page for _ in range(num_steps): next_page = __choose_state(chain[current_page]) visited_pages.append(next_page) current_page = next_page return visited_pages"},{"question":"In this assignment, you are required to implement a secure communication setup using the Diffie-Hellman Key Exchange algorithm. Given a large prime number ( p ) and its primitive root ( a ), Alice and Bob need to securely exchange secret keys over an unsecured channel. The algorithm includes the following steps: 1. Verify if ( p ) is a prime number. 2. Calculate the primitive root of ( p ) and ensure ( a ) is one of them. 3. Generate private keys for Alice and Bob. 4. Compute the public keys for Alice and Bob using their private keys. 5. Exchange public keys between Alice and Bob. 6. Compute the shared secret key using each other\'s public keys and their private keys. You need to implement the key components of this algorithm, encapsulated in the following functions: 1. `prime_check(num)`: Check if `num` is a prime number. 2. `find_primitive_root(n)`: Return all primitive roots of `n`. 3. `alice_private_key(p)`: Generate Alice\'s private key. 4. `bob_private_key(p)`: Generate Bob\'s private key. 5. `alice_public_key(a_pr_k, a, p)`: Calculate Alice\'s public key. 6. `bob_public_key(b_pr_k, a, p)`: Calculate Bob\'s public key. 7. `alice_shared_key(b_pu_k, a_pr_k, p)`: Calculate Alice\'s shared key. 8. `bob_shared_key(a_pu_k, b_pr_k, p)`: Calculate Bob\'s shared key. 9. `diffie_hellman_key_exchange(a, p)`: Perform the key exchange and verify the shared keys. # Input and Output Input - An integer ( p ), the prime number. - An integer ( a ), the primitive root of ( p ). Output - Boolean: `True` if the keys successfully exchange and match, `False` otherwise. - Intermediate prints for educational purposes (Alice\'s private/public keys, Bob’s private/public keys, and the shared keys). Constraints - ( 1 leq p leq 10^9 ) - ( 1 leq a < p ) # Example Input ``` p = 23 a = 5 ``` Output ``` True Prints: Alice\'s private key: [some private key] Alice\'s public key: [corresponding public key] Bob\'s private key: [some private key] Bob\'s public key: [corresponding public key] Shared key calculated by Alice = [shared key] Shared key calculated by Bob = [shared key] ``` Ensure to handle potential errors such as non-prime ( p ) and incorrect ( a ).","solution":"import random from sympy import isprime, primerange def prime_check(num): Check if the given number is a prime number. return isprime(num) def find_primitive_root(n): Find primitive roots of \'n\'. def gcd(a, b): while b: a, b = b, a % b return a def power(x, y, p): res = 1 x = x % p while y > 0: if y & 1: res = (res * x) % p y = y >> 1 x = (x * x) % p return res required_set = {num for num in range(1, n) if gcd(num, n) == 1} roots = [] for g in range(1, n): actual_set = {power(g, powers, n) for powers in range(1, n)} if required_set == actual_set: roots.append(g) return roots def alice_private_key(p): Generate Alice\'s private key. return random.randint(2, p - 2) def bob_private_key(p): Generate Bob\'s private key. return random.randint(2, p - 2) def alice_public_key(a_pr_k, a, p): Calculate Alice\'s public key. return pow(a, a_pr_k, p) def bob_public_key(b_pr_k, a, p): Calculate Bob\'s public key. return pow(a, b_pr_k, p) def alice_shared_key(b_pu_k, a_pr_k, p): Calculate Alice\'s shared key. return pow(b_pu_k, a_pr_k, p) def bob_shared_key(a_pu_k, b_pr_k, p): Calculate Bob\'s shared key. return pow(a_pu_k, b_pr_k, p) def diffie_hellman_key_exchange(a, p): Perform Diffie-Hellman key exchange. # Step 1: Verify if p is a prime number if not prime_check(p): print(f\\"{p} is not a prime number.\\") return False # Step 2: Check if a is a primitive root of p primitive_roots = find_primitive_root(p) if a not in primitive_roots: print(f\\"{a} is not a primitive root of {p}.\\") return False # Step 3-5: Generate private and public keys for Alice and Bob a_pr_k = alice_private_key(p) b_pr_k = bob_private_key(p) a_pu_k = alice_public_key(a_pr_k, a, p) b_pu_k = bob_public_key(b_pr_k, a, p) # Print intermediate keys print(f\\"Alice\'s private key: {a_pr_k}\\") print(f\\"Alice\'s public key: {a_pu_k}\\") print(f\\"Bob\'s private key: {b_pr_k}\\") print(f\\"Bob\'s public key: {b_pu_k}\\") # Step 6: Compute shared secret keys shared_key_alice = alice_shared_key(b_pu_k, a_pr_k, p) shared_key_bob = bob_shared_key(a_pu_k, b_pr_k, p) # Print shared keys print(f\\"Shared key calculated by Alice = {shared_key_alice}\\") print(f\\"Shared key calculated by Bob = {shared_key_bob}\\") # Ensure both shared keys match return shared_key_alice == shared_key_bob"},{"question":"You are working for an online library that maintains a sorted list of book identifiers (integer values in increasing order). Your task is to implement a function `first_occurrence` that finds the first occurrence of a given book identifier in the sorted list using Binary Search. This function must efficiently handle large datasets. # Input - A list of integers `array`, which is sorted in increasing order and may contain duplicate values. - An integer `query`, representing the book identifier you need to find. # Output - Return the index of the first occurrence of `query` in the `array`. If `query` is not present, return `-1`. # Constraints - The length of `array` (n) will be in the range [0, 10^6]. - The integer values in `array` and `query` can be in the range of [-10^9, 10^9]. - The solution must have a time complexity of O(log n). # Example ```python assert first_occurrence([1, 2, 2, 3, 3, 3, 4], 3) == 3 assert first_occurrence([1, 2, 2, 3, 3, 3, 4], 2) == 1 assert first_occurrence([1, 2, 2, 3, 3, 3, 4], 5) == -1 assert first_occurrence([], 1) == -1 ``` # Notes - You need to handle edge cases where the list is empty or the query is not present in the list. - Consider that your solution should perform well with very large arrays within the given constraints.","solution":"def first_occurrence(array, query): Finds the first occurrence of a given book identifier in the sorted list using Binary Search. Parameters: array (List[int]): A sorted list of integers. query (int): An integer representing the book identifier to find. Returns: int: The index of the first occurrence of query in array; -1 if not found. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid right = mid - 1 # Continue to search in the left half elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Pancake Sort and Validation **Context**: You are given a list of unordered numbers. Your task is to write a function to sort the numbers using the Pancake Sort algorithm. Additionally, you need to write a function to validate if the array is sorted correctly. **Requirements**: Implement two functions: 1. `pancake_sort(arr)`: - **Input**: A list of integers `arr`. - **Output**: A list of integers sorted in ascending order. 2. `is_sorted(arr)`: - **Input**: A list of integers `arr`. - **Output**: Returns `True` if the list is sorted in ascending order, else returns `False`. **Constraints**: - The array `arr` contains at most 10^3 elements. - The elements in the array are in the range [-10^3, 10^3]. **Example**: ```python arr = [3, 6, 2, 1, 7, 5] sorted_arr = pancake_sort(arr) print(sorted_arr) # Output should be [1, 2, 3, 5, 6, 7] print(is_sorted(sorted_arr)) # Output should be True arr2 = [4, 2, 6, 5, 3, 1] sorted_arr2 = pancake_sort(arr2) print(sorted_arr2) # Output should be [1, 2, 3, 4, 5, 6] print(is_sorted(sorted_arr2)) # Output should be True ``` **Note**: Ensure you handle edge cases like an empty array or an array with only one element.","solution":"def pancake_sort(arr): def flip(arr, k): arr[:k] = arr[:k][::-1] n = len(arr) for size in range(n, 1, -1): max_index = max(range(size), key=arr.__getitem__) if max_index != size - 1: if max_index != 0: flip(arr, max_index + 1) flip(arr, size) return arr def is_sorted(arr): return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))"},{"question":"Extended Base Conversion You are working on a software that needs to frequently convert numbers between various bases. You are provided with two fundamental functions for base conversion – `int_to_base` and `base_to_int`. Now, you need to extend these functionalities to handle some additional features. **Task**: Implement a function `extended_base_conversion` that accepts a string representation of an integer `num_str`, its current base `from_base`, and a target base `to_base`. The function should convert the `num_str` from `from_base` to its equivalent representation in `to_base`. # Requirements: 1. The `num_str` can be negative. 2. Both `from_base` and `to_base` are integers between 2 and 36, inclusive. 3. Handle any necessary validations, such as invalid characters in the `num_str` for the given `from_base`. # Input: - `num_str` (string): The number in string format to be converted. - `from_base` (integer): The base of `num_str`. - `to_base` (integer): The base to which `num_str` should be converted. # Output: - The string representation of `num_str` in the `to_base` system. # Example: ```python extended_base_conversion(\\"-1A\\", 16, 8) # should return \'-32\' extended_base_conversion(\\"101\\", 2, 10) # should return \'5\' extended_base_conversion(\\"Z\\", 36, 10) # should return \'35\' ``` # Constraints: - Assume only valid integers will be provided for `from_base` and `to_base`. # Implementation: Your task is to write the function `extended_base_conversion` using the provided helper functions `int_to_base` and `base_to_int`. ```python def extended_base_conversion(num_str, from_base, to_base): # Write your code here. pass ```","solution":"def int_to_base(num, base): Converts an integer to a given base and returns the string representation. if num == 0: return \\"0\\" digits = [] is_negative = False if num < 0: is_negative = True num = -num while num > 0: digits.append(int(num % base)) num = num // base if is_negative: return \'-\' + \'\'.join(\\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\"[d] for d in reversed(digits)) else: return \'\'.join(\\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\"[d] for d in reversed(digits)) def base_to_int(num_str, base): Converts a string representation of a number in a given base to an integer. num_str = num_str.strip().upper() if num_str[0] == \'-\': return -int(num_str[1:], base) return int(num_str, base) def extended_base_conversion(num_str, from_base, to_base): Converts num_str from from_base to to_base. # Convert from the original base to an integer num = base_to_int(num_str, from_base) # Convert from the integer to the target base result = int_to_base(num, to_base) return result"},{"question":"# Problem Description You are tasked with writing a function that improves upon the provided nearest neighbor algorithm by handling edge cases, optimizing performance, and managing error scenarios more robustly. Problem Details You need to implement a function `optimized_nearest_neighbor` that, given an input vector and a labeled dataset, returns the label of the nearest neighbor using the Euclidean distance. Additionally, you must handle the following: 1. **Edge Cases**: Ensure the dataset is not empty and all vectors have the same dimensionality. 2. **Error Scenarios**: Properly handle cases where input data may be malformed. 3. **Performance Improvement**: Implement a more efficient search mechanism for large datasets with high dimensionality, such as using KD-Trees. 4. **Output**: Return the label of the nearest neighbor or a clear error message in case of invalid input. Function Signature ```python def optimized_nearest_neighbor(x: tuple, tSet: dict) -> str: Improved version of nearest neighbor algorithm. Arguments: x -- input vector (tuple of numeric values) tSet -- training set (dictionary where keys are tuples representing vectors, and values are their corresponding labels) Returns: Label of the nearest neighbor or error message. ``` Constraints * The input vector and the vectors in the training set will contain at most 1000 elements. * The dimensions of the input vector and each vector in the training set will be between 1 and 100 inclusive. * You may use libraries to implement advanced data structures like KD-Trees. Example ```python # Example usage: x = (2, 3) tSet = { (1, 2): \\"A\\", (3, 4): \\"B\\", (5, 6): \\"C\\" } print(optimized_nearest_neighbor(x, tSet)) # Output might be \\"A\\" depending on Euclidean distance calculation. ```","solution":"from scipy.spatial import KDTree import numpy as np def optimized_nearest_neighbor(x, tSet): Improved version of nearest neighbor algorithm. Arguments: x -- input vector (tuple of numeric values) tSet -- training set (dictionary where keys are tuples representing vectors, and values are their corresponding labels) Returns: Label of the nearest neighbor or error message. # Check if the training set is empty if not tSet: return \\"Error: Training set is empty.\\" # Ensure all vectors have the same dimensionality dim = len(x) for vec in tSet.keys(): if len(vec) != dim: return \\"Error: Inconsistent dimensionality between input vector and training set vectors.\\" # Convert the training set to lists for KDTree vectors = list(tSet.keys()) labels = list(tSet.values()) # Build KD-Tree and query the nearest neighbor kdtree = KDTree(vectors) distance, index = kdtree.query(x) return labels[index]"},{"question":"# Question You are provided with the lengths of two sides of a right-angled triangle. Your task is to write a function `find_third_side` that determines the length of the missing (third) side. The function should be able to correctly handle and return errors for invalid inputs. Function Signature ```python def find_third_side(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> str: pass ``` Input - `opposite` (float or str): Length of the side opposite the right angle, or \\"?\\" if this side\'s length is unknown. - `adjacent` (float or str): Length of the side adjacent to the right angle, or \\"?\\" if this side\'s length is unknown. - `hypotenuse` (float or str): Length of the hypotenuse, or \\"?\\" if this side\'s length is unknown. Output - Returns a string indicating the length of the unknown side. - For example, \\"Opposite = 4.0\\". - Raise a ValueError with an appropriate message for invalid inputs, such as: - Non-numeric values (other than \\"?\\"). - Negative or zero lengths (as side lengths must be positive). - Configurations that violate the triangle inequality theorem (e.g., given lengths that cannot form a right triangle). Constraints - Only one side will be marked as \\"?\\". - The given sides will form a valid right-angled triangle if the input values are valid. - Perform input validation to ensure meaningful error messages. Example ```python assert find_third_side(3.0, 4.0, \\"?\\") == \\"Hypotenuse = 5.0\\" assert find_third_side(\\"?\\", 4.0, 5.0) == \\"Opposite = 3.0\\" assert find_third_side(3.0, \\"?\\", 5.0) == \\"Adjacent = 4.0\\" ```","solution":"from typing import Union import math def find_third_side(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> str: # Validate input values def validate_and_convert(value, name): if isinstance(value, str): if value == \\"?\\": return \\"?\\" try: value = float(value) except ValueError: raise ValueError(f\\"Invalid value for {name}\\") if isinstance(value, (int, float)): value = float(value) if not isinstance(value, (float)) or value <= 0: raise ValueError(f\\"Invalid value for {name}\\") return value opposite = validate_and_convert(opposite, \\"opposite\\") adjacent = validate_and_convert(adjacent, \\"adjacent\\") hypotenuse = validate_and_convert(hypotenuse, \\"hypotenuse\\") # Count how many \\"?\\" are in the inputs unknowns = [opposite, adjacent, hypotenuse].count(\\"?\\") if unknowns != 1: raise ValueError(\\"Exactly one side must be unknown (represented as \'?\').\\") if hypotenuse == \\"?\\": # Hypotenuse is the longest side in a right triangle result = math.sqrt(opposite ** 2 + adjacent ** 2) return f\\"Hypotenuse = {result:.1f}\\" if opposite == \\"?\\": if hypotenuse <= adjacent: raise ValueError(\\"Hypotenuse must be the longest side in a right triangle.\\") result = math.sqrt(hypotenuse ** 2 - adjacent ** 2) return f\\"Opposite = {result:.1f}\\" if adjacent == \\"?\\": if hypotenuse <= opposite: raise ValueError(\\"Hypotenuse must be the longest side in a right triangle.\\") result = math.sqrt(hypotenuse ** 2 - opposite ** 2) return f\\"Adjacent = {result:.1f}\\" raise ValueError(\\"Invalid input configuration.\\")"},{"question":"# Stooge Sorting Challenge Description You are tasked with implementing a version of the Stooge Sort algorithm. Stooge Sort is an inefficient, yet academically interesting sorting algorithm that repeatedly sorts parts of an array in an overlapping fashion. Your goal is to implement this algorithm correctly, ensuring it handles various edge cases and sorts a list of integers in non-decreasing order. Function Signature ```python def stooge_sort(arr: List[int], l: int, h: int) -> None: # Your code here ``` Input * `arr`: A list of integers to be sorted. * `l`: Starting index of the list segment to be sorted. * `h`: Ending index of the list segment to be sorted. Constraints * The list `arr` will have at most `10^3` elements. * Elements of the list are integers within the range of `-10^6` to `10^6`. * Recursion depth should not exceed practical memory limits. Output * The function sorts the list `arr` in place in non-decreasing order. Example **Input:** ```python arr = [5, 3, 2, 4, 1] stooge_sort(arr, 0, len(arr) - 1) print(arr) ``` **Output:** ```python [1, 2, 3, 4, 5] ``` Edge Cases * Single element list should remain unchanged. * Already sorted lists should remain unchanged. * Reverse sorted lists should become sorted correctly. Notes * Consider what happens with small segments of the array (`l` and `h` nearby). * Ensure to handle large values without causing stack overflow errors.","solution":"from typing import List def stooge_sort(arr: List[int], l: int, h: int) -> None: if l >= h: return # Swap if the first element is greater than the last element if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the segment if h - l + 1 > 2: third = (h - l + 1) // 3 # Recursively sort the first 2/3 of the segment stooge_sort(arr, l, h - third) # Recursively sort the last 2/3 of the segment stooge_sort(arr, l + third, h) # Recursively sort the first 2/3 of the segment again stooge_sort(arr, l, h - third)"},{"question":"# Task Write a function named `flatten_array` which takes a nested array (a list of elements where some elements can be lists themselves) and returns a single flat array containing all the elements of the nested structure. Your task is to implement both a recursive solution and an iterative solution using Python\'s generator functions. # Specifications * **Function 1**: `def flatten_array_recursive(nested_array: List[Any]) -> List[Any]:` * **Input**: A list `nested_array` that can contain elements of any type, including other lists. * **Output**: A single list with all elements from the nested list at the top level. * **Constraints**: * Handle any level of nested lists. * Maintain the order of elements as they appear in the input. * The implementation should handle arrays with mixed data types (integers, strings, etc.). * **Function 2**: `def flatten_array_generator(nested_array: Iterable[Any]) -> Iterator[Any]:` * **Input**: An iterable `nested_array` that can contain elements of any type, including other iterables. * **Output**: A generator that yields elements from the nested iterable one at a time, in a flat structure. * **Constraints**: * Handle any level of nested iterables. * Maintain the order of elements as they appear in the input. * The implementation should handle arrays with mixed data types (integers, strings, etc.). # Examples ```python # Example Usage for Recursive Function print(flatten_array_recursive([1, [2, [3, 4]], 5])) # Output: [1, 2, 3, 4, 5] print(flatten_array_recursive([\'a\', [\'b\', [\'c\', \'d\']], \'e\'])) # Output: [\'a\', \'b\', \'c\', \'d\', \'e\'] # Example Usage for Generator Function print(list(flatten_array_generator([1, [2, [3, 4]], 5]))) # Output: [1, 2, 3, 4, 5] print(list(flatten_array_generator([\'a\', [\'b\', [\'c\', \'d\']], \'e\']))) # Output: [\'a\', \'b\', \'c\', \'d\', \'e\'] ``` # Evaluation Criteria * Correctness: The functions must return correct flattened arrays/lists as per the specifications. * Efficiency: Your solution should handle large and deeply nested arrays with reasonable performance. * Code Quality: Ensure that your code is clean and readable, with appropriate comments explaining your logic where needed.","solution":"from typing import List, Any, Iterable, Iterator def flatten_array_recursive(nested_array: List[Any]) -> List[Any]: Flattens a nested list recursively. Args: nested_array (List[Any]): A list that can contain elements of any type, including other lists. Returns: List[Any]: A single list with all elements from the nested list. flat_list = [] for item in nested_array: if isinstance(item, list): flat_list.extend(flatten_array_recursive(item)) else: flat_list.append(item) return flat_list def flatten_array_generator(nested_array: Iterable[Any]) -> Iterator[Any]: Flattens a nested iterable using a generator. Args: nested_array (Iterable[Any]): An iterable that can contain elements of any type, including other iterables. Yields: Iterator[Any]: Elements from the nested iterable in a flat structure. for item in nested_array: if isinstance(item, Iterable) and not isinstance(item, (str, bytes)): yield from flatten_array_generator(item) else: yield item"},{"question":"You are given the root of a binary tree. Implement a function to perform a preorder depth-first traversal on the tree. The function should return a list of the node values in preorder sequence. Function Signature ```python def preorder_traversal(root: Node) -> List[int]: pass ``` # Input: - `root`: The root node of the binary tree. The node is an instance of the provided `Node` class. # Output: - A list of integers representing the node values in preorder traversal sequence. # Constraints: - The number of nodes in the tree is in the range [0, 10^4]. - The values of the nodes are unique integers. # Example: ```python # Creating a sample tree # 1 # / # 2 3 # / # 4 5 6 root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.right = Node(6) preorder_traversal(root) # Output: [1, 2, 4, 5, 3, 6] ``` # Requirements: 1. Implement an iterative approach for the preorder traversal. 2. Ensure the solution handles edge cases such as null trees and unbalanced trees. 3. Validate your solution with different tree configurations.","solution":"from typing import List, Optional class Node: def __init__(self, val:int, left:Optional[\'Node\']=None, right:Optional[\'Node\']=None): self.val = val self.left = left self.right = right def preorder_traversal(root: Optional[Node]) -> List[int]: if root is None: return [] stack = [root] result = [] while stack: node = stack.pop() result.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return result"},{"question":"Context: You are provided with an implementation of a directed graph that manages its nodes and edges internally. A directed graph can represent numerous real-world scenarios such as task scheduling where certain tasks must precede others. Task: Implement a function `find_all_paths` that computes all possible paths from a given start node to an end node in the graph. Each path should be represented as a list of node names. Your function should be able to handle cycles within the graph and avoid infinite loops. Function Signature: ```python def find_all_paths(graph, start, end): Computes all paths from start to end node in given graph. Args: graph (DirectedGraph): The directed graph to search. start (str): The name of the starting node. end (str): The name of the destination node. Returns: List[List[str]]: A list of all paths, each represented by a list of node names. pass ``` Input/Output Examples: ```python # Example Usage graph_data = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"C\\", \\"D\\"], \\"C\\": [\\"D\\"], \\"D\\": [\\"C\\"], \\"E\\": [\\"F\\"], \\"F\\": [\\"C\\"] } graph = DirectedGraph(graph_data) # Example: # find_all_paths(graph, \\"A\\", \\"D\\") may return: # [[\\"A\\", \\"B\\", \\"C\\", \\"D\\"], [\\"A\\", \\"B\\", \\"D\\"], [\\"A\\", \\"C\\", \\"D\\"]] # Example: # find_all_paths(graph, \\"E\\", \\"D\\") may return: # [[\\"E\\", \\"F\\", \\"C\\", \\"D\\"]] ``` Constraints: * The graph is directed and the function should account for directed paths. * Nodes are identified uniquely by names (strings). * Avoid infinite loops in presence of cycles. * Focus on returning *all* distinct paths; the order of paths or nodes in them is not critical. Expect the function to traverse the graph and return all possible paths promptly. Performance considerations should efficiently manage node traversal without redundant calculations or unnecessary memory usage.","solution":"class DirectedGraph: def __init__(self, graph_data): self.graph = graph_data def find_all_paths(graph, start, end): def dfs(current_node, path): if current_node == end: result.append(list(path)) return for neighbor in graph.graph.get(current_node, []): if neighbor not in path: # avoid cycles path.append(neighbor) dfs(neighbor, path) path.pop() result = [] dfs(start, [start]) return result"},{"question":"# Summarize Ranges in a Sorted Array You are given a sorted array of distinct integers. Your task is to summarize the array by identifying and grouping continuous ranges of numbers together. For each group of continuous numbers, you need to depict the start and end of the range in a specific format. If a number stands alone and is not part of any continuous range, that number should be listed by itself. Function Signature ```python def summarize_ranges(array: List[int]) -> List[str]: ``` Input - `array` (List[int]): A sorted list of distinct integers, 0 <= len(array) <= 10^4. Output - List[str]: A list of strings where each string represents a continuous range or a standalone number from the array. Example ```python summarize_ranges([0, 1, 2, 4, 5, 7]) # Returns: [\\"0-2\\", \\"4-5\\", \\"7\\"] summarize_ranges([0, 2, 3, 4, 6, 8, 9]) # Returns: [\\"0\\", \\"2-4\\", \\"6\\", \\"8-9\\"] summarize_ranges([]) # Returns: [] summarize_ranges([3]) # Returns: [\\"3\\"] ``` Constraints and Considerations 1. The input array is sorted and contains distinct integers. 2. You need to accurately identify and group ranges, ensuring proper formatting. 3. Handle edge cases where the array is empty, contains only one element, or contains no continuous ranges. 4. Ensure that your solution is efficient and operates within the specified time and space complexity.","solution":"def summarize_ranges(array): if not array: return [] ranges = [] start = array[0] end = array[0] for i in range(1, len(array)): if array[i] == end + 1: end = array[i] else: if start == end: ranges.append(str(start)) else: ranges.append(f\\"{start}-{end}\\") start = array[i] end = array[i] if start == end: ranges.append(str(start)) else: ranges.append(f\\"{start}-{end}\\") return ranges"},{"question":"# Missing Ranges Finder Your task is to implement a function that finds and returns ranges of missing integers given an input array, and a specified lower and upper bound inclusive. Function Signature ```python def find_missing_ranges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: ``` Input - **arr** (List[int]): A list of sorted integers. - **lo** (int): The lower bound (inclusive). - **hi** (int): The upper bound (inclusive). Output - Returns a list of tuples where each tuple represents a range of missing integers between `lo` and `hi` inclusive. Example ```python arr = [3, 5] lo = 1 hi = 10 output = [(1, 2), (4, 4), (6, 10)] ``` Constraints - The array `arr` is guaranteed to be sorted. - The elements in the array lie within the range `[lo, hi]` or are equal to `lo` or `hi`. - The values for `lo` and `hi` will adhere to the constraint: `lo <= hi` - The length of the array `arr` will not exceed 10^5. Performance Requirements - The solution should run in `O(n)` time complexity, where `n` is the length of the input array. - The solution should use `O(1)` extra space complexity, excluding the space required for the output list. Scenario: You are provided an ID management service that tracks usage within a range. However, due to some operational issues, you\'ve lost track of some of the IDs used. Use the given information to devise an algorithm that helps identify the missing ranges of IDs within the provided range. Implement the function `find_missing_ranges` to determine these gaps.","solution":"from typing import List, Tuple def find_missing_ranges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: Finds the ranges of missing integers between the given bounds `lo` and `hi`. missing_ranges = [] # Include the bounds at the edges previous = lo - 1 for num in arr: if num > previous + 1: missing_ranges.append((previous + 1, num - 1)) previous = num # Check the range between the last value in `arr` and `hi` if hi > previous: missing_ranges.append((previous + 1, hi)) return missing_ranges"},{"question":"# Matrix Chain Multiplication Problem Given an array `dims` where `dims[i-1] x dims[i]` represents the dimensions of the ith matrix in a sequence, write a function `matrix_chain_order(dims)` that returns the minimum number of scalar multiplications needed to multiply the sequence of matrices. Also, provide another function `print_optimal_order(sol, i, j)` to print the optimal order of multiplications. Function Definitions * `matrix_chain_order(dims: List[int]) -> Tuple[int, List[List[int]]]:` * **Input**: * `dims`: A list of integers where `dims[i-1] x dims[i]` represents the ith matrix. * **Output**: * Returns a tuple where the first element is the minimum number of scalar multiplications needed, and the second element is a 2D list containing the optimal split points. * `print_optimal_order(sol: List[List[int]], i: int, j: int) -> None:` * **Input**: * `sol`: 2D list returned by `matrix_chain_order` indicating the optimal split point for each subproblem. * `i`: Starting index of the matrices. * `j`: Ending index of the matrices. * **Output**: * Prints the optimal parenthesization of matrix multiplication. Example ```python dims = [30, 35, 15, 5, 10, 20, 25] # Calculate the minimum number of scalar multiplications matrix, sol = matrix_chain_order(dims) print(\\"Minimum number of multiplications is:\\", matrix) # Print the optimal order of multiplications print(\\"The optimal order of matrix multiplication is:\\") print_optimal_order(sol, 1, len(dims) - 1) ``` Constraints * The length of `dims` will be between 2 and 100 inclusive. * Elements of `dims` will be between 1 and 1000 inclusive. Implement the function with optimal time and space complexity.","solution":"from typing import List, Tuple def matrix_chain_order(dims: List[int]) -> Tuple[int, List[List[int]]]: n = len(dims) - 1 m = [[0] * (n + 1) for _ in range(n + 1)] sol = [[0] * (n + 1) for _ in range(n + 1)] for length in range(2, n + 1): for i in range(1, n - length + 2): j = i + length - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + dims[i - 1] * dims[k] * dims[j] if q < m[i][j]: m[i][j] = q sol[i][j] = k return m[1][n], sol def print_optimal_order(sol: List[List[int]], i: int, j: int) -> None: if i == j: print(f\\"M{i}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_order(sol, i, sol[i][j]) print_optimal_order(sol, sol[i][j] + 1, j) print(\\")\\", end=\\"\\")"},{"question":"# Question: Minimum Deletion Operations to Make Two Strings the Same Given two words `word1` and `word2`, write a function to find the minimum number of steps required to make `word1` and `word2` the same. In each step, you can delete one character in either string. **Function Signature:** ```python def min_deletions_to_make_same(word1: str, word2: str) -> int: ``` **Input:** * `word1` (string): The first input word. * `word2` (string): The second input word. **Output:** * `int`: The minimum number of steps required. **Constraints:** * The length of both `word1` and `word2` will not exceed 1000. **Example:** ```plaintext Example 1: Input: word1 = \\"sea\\", word2 = \\"eat\\" Output: 2 Explanation: Following deletions: 1) \\"sea\\" -> \\"ea\\" 2) \\"eat\\" -> \\"ea\\" Example 2: Input: word1 = \\"intention\\", word2 = \\"execution\\" Output: 8 ``` **Notes:** 1. Think about using dynamic programming to optimize the solution. 2. Consider edge cases where either of the strings is empty. 3. Focus on efficiency as the length of strings can be large. Using the given analysis and snippets, implement the DP solution to find the optimal number of deletions required.","solution":"def min_deletions_to_make_same(word1: str, word2: str) -> int: Returns the minimum number of deletion steps required to make two words the same. This is based on finding the length of the longest common subsequence (LCS) between the words. len1, len2 = len(word1), len(word2) # Create a DP table to store lengths of longest common subsequence dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] # Fill the dp table for i in range(1, len1 + 1): for j in range(1, len2 + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The length of the longest common subsequence lcs = dp[len1][len2] # Minimum deletions to make the strings the same return (len1 - lcs) + (len2 - lcs)"},{"question":"**Scenario**: You\'re developing a simple in-memory database to store a collection of integers that need to be dynamically updated and queried. To maintain efficient operations, you decide to use a Binary Search Tree (BST) as your underlying data structure. **Task**: Implement a class `BST` with the following functionality: 1. `insert(value: int) -> None`: Insert a value into the BST. 2. `search(value: int) -> bool`: Return `True` if the value exists in the BST, `False` otherwise. 3. `delete(value: int) -> None`: Remove a value from the BST (if it exists). 4. `inorder_traversal() -> List[int]`: Return a list of all values in the BST using in-order traversal. **Input/Output Formats**: * Input to `insert`, `search`, and `delete` methods will be a single integer `value`. * Output from `search` method will be a boolean. * Output from `inorder_traversal` method will be a list of integers representing the in-order traversal of the BST. **Constraints**: 1. The values inserted into the BST will be unique. 2. All values will be integers within the range: [-10^4, 10^4]. 3. Maximum number of operations (insert, search, delete, or traversal) in a single session will not exceed 10^4. **Example**: ```python # Example usage: bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) print(bst.search(3)) # Output: True print(bst.search(6)) # Output: False bst.delete(3) print(bst.search(3)) # Output: False print(bst.inorder_traversal()) # Output: [5, 7] ``` **Performance**: - Ensure all operations (search, insert, delete) operate in O(log n) time on average. - The in-order traversal should be O(n). Design your BST class as described and ensure thorough testing of each method.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value: int) -> None: if not self.root: self.root = Node(value) else: self._insert(self.root, value) def _insert(self, current: Node, value: int) -> None: if value < current.value: if current.left is None: current.left = Node(value) else: self._insert(current.left, value) elif value > current.value: if current.right is None: current.right = Node(value) else: self._insert(current.right, value) def search(self, value: int) -> bool: return self._search(self.root, value) def _search(self, current: Node, value: int) -> bool: if current is None: return False if value == current.value: return True elif value < current.value: return self._search(current.left, value) else: return self._search(current.right, value) def delete(self, value: int) -> None: self.root = self._delete(self.root, value) def _delete(self, current: Node, value: int) -> Node: if current is None: return current if value < current.value: current.left = self._delete(current.left, value) elif value > current.value: current.right = self._delete(current.right, value) else: if current.left is None: return current.right elif current.right is None: return current.left # Node with two children: Get the inorder successor min_larger_node = self._get_min(current.right) current.value = min_larger_node.value current.right = self._delete(current.right, min_larger_node.value) return current def _get_min(self, node: Node) -> Node: current = node while current.left is not None: current = current.left return current def inorder_traversal(self) -> list: result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node: Node, result: list) -> None: if node is not None: self._inorder_traversal(node.left, result) result.append(node.value) self._inorder_traversal(node.right, result)"},{"question":"# Question You are tasked to implement a function that converts a given integer to its Roman numeral representation. The function must precisely follow the standard Roman numeral system with constraints as specified below. Function Signature ```python def int_to_roman(num: int) -> str: ``` Input - `num`: an integer, guaranteed to be in the range from 1 to 3999. Output - Returns the Roman numeral representation of the integer as a string. Constraints - The input integer will always be between 1 and 3999 inclusive. Performance Requirements - The solution should have a time complexity of O(1) and use constant space. Example ```python assert int_to_roman(1) == \\"I\\" assert int_to_roman(3999) == \\"MMMCMXCIX\\" assert int_to_roman(58) == \\"LVIII\\" assert int_to_roman(1994) == \\"MCMXCIV\\" ``` Scenario You are developing a historical document editor where dates need to be printed in the classical Roman numeral format. Your task is to implement the conversion algorithm that will allow the editor to convert any given year date within the range to its Roman numeral equivalent. Implementation Notes - Consider using predefined lists for thousands, hundreds, tens, and units to simplify the mapping from integers to Roman numerals. - Ensure thorough testing for edge cases like the smallest and largest possible values.","solution":"def int_to_roman(num: int) -> str: Converts an integer to its Roman numeral representation. :param num: Integer to convert (1 <= num <= 3999) :return: Roman numeral representation as a string val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = \'\' i = 0 while num > 0: for _ in range(num // val[i]): roman_numeral += syb[i] num -= val[i] i += 1 return roman_numeral"},{"question":"Context: You are given a sorted list of integers, where the elements may represent intervals/sections within a larger dataset. Your task is to summarize contiguous ranges into concise interval representations for easier viewing and analysis. Task: Implement a function `summarize_ranges(array: List[int]) -> List[str]` that takes a sorted list `array` of integers, and returns a list of strings, each representing a concise summary of contiguous ranges found in the input list. Input Format: * A list of integers `array`, which is sorted in non-decreasing order. * Length of the list will be within the range `[0, 10^4]`. * Values in the list will be within the range `[-10^5, 10^5]`. Output Format: * A list of strings, each string summarizing a contiguous range in the format: - For single-element ranges, the element itself (e.g., \\"3\\"). - For multi-element contiguous ranges, the start and end separated by a dash (e.g., \\"2-5\\"). Constraints: * Individual integers in the list are unique. * The list is always sorted in ascending order. Example: 1. Input: `[0, 1, 2, 4, 5, 7]` Output: `[\\"0-2\\", \\"4-5\\", \\"7\\"]` 2. Input: `[1, 3, 5, 7]` Output: `[\\"1\\", \\"3\\", \\"5\\", \\"7\\"]` 3. Input: `[]` Output: `[]` 4. Input: `[0]` Output: `[\\"0\\"]` Please ensure your implementation handles all edge cases appropriately, such as arrays with only one element, or no elements at all. Function Signature: ```python from typing import List def summarize_ranges(array: List[int]) -> List[str]: # Your code here ```","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: if not array: return [] result = [] start = array[0] end = array[0] for i in range(1, len(array)): if array[i] == end + 1: end = array[i] else: if start == end: result.append(str(start)) else: result.append(f\\"{start}-{end}\\") start = array[i] end = array[i] if start == end: result.append(str(start)) else: result.append(f\\"{start}-{end}\\") return result"},{"question":"# **Interval Management: Merge and Query** **Scenario**: As an engineer in charge of managing time slots for an application, you need to write methods to handle intervals of time efficiently. Specifically, you need to merge overlapping intervals and determine if a given point in time falls within any of the non-overlapping time slots. **Task**: Implement a class `IntervalManager` with the following functionalities: - **Initialize**: Start with an empty list of intervals. - **Add Interval**: Add a new interval to the list. - **Merge Intervals**: Merge all overlapping intervals in the list. - **Query Point**: Check if a given point lies within any interval in the merged list. **Input/Output Formats**: - **Initialization**: `IntervalManager()` - **Add Interval**: `add_interval(start, end)` - **Input**: `start` and `end` integers signifying the start and end of the interval. - **Merge Intervals**: `merge_intervals()` - **Output**: A list of merged intervals. - **Query Point**: `query_point(x)` - **Input**: `x` an integer representing a time point. - **Output**: Boolean value indicating if `x` is within any interval. **Constraints**: - Assume `start` is always less than `end` in `add_interval`. - The intervals can be in any order and may overlap. **Example**: ```python manager = IntervalManager() manager.add_interval(1, 5) manager.add_interval(3, 7) manager.add_interval(10, 12) manager.add_interval(9, 11) print(manager.merge_intervals()) # Output: [(1, 7), (9, 12)] print(manager.query_point(4)) # Output: True print(manager.query_point(8)) # Output: False ``` **Implementation Requirements**: 1. Ensure the solution handles overlapping intervals correctly. 2. Make use of efficient sorting and merging techniques. 3. Optimize for both time and space where possible.","solution":"class IntervalManager: def __init__(self): self.intervals = [] def add_interval(self, start, end): self.intervals.append((start, end)) def merge_intervals(self): if not self.intervals: return [] self.intervals.sort() merged = [self.intervals[0]] for current in self.intervals[1:]: last = merged[-1] if current[0] <= last[1]: merged[-1] = (last[0], max(last[1], current[1])) else: merged.append(current) self.intervals = merged return self.intervals def query_point(self, x): for start, end in self.intervals: if start <= x <= end: return True return False"},{"question":"Objective Your task is to implement a missing function in the provided Monomial and Polynomial classes to demonstrate your understanding of symbolic computation and polynomial algebra. Problem Statement A polynomial can be simplified by combining like terms and removing terms with zero coefficients. Extend the functionality of the `Polynomial` class by implementing the `simplify` method. This method should merge like monomials and remove any terms with zero coefficients. Function Signature ```python def simplify(self) -> Polynomial: Simplify the polynomial by combining like terms and removing zero coefficients. ``` Input and Output * **Input**: The function will not take any input as it operates directly on a Polynomial instance. * **Output**: The function should return a simplified instance of the Polynomial. Constraints * Do not use any external libraries. * Make sure to preserve the original Polynomial\'s monomials while merging and simplifying. Example ```python # Creating example monomials m1 = Monomial({1:1}, 2) m2 = Monomial({2:3, 1:-1}, -1) m3 = Monomial({1:1}, 3) m4 = Monomial({1:1}, -5) m5 = Monomial({3: 0}, 0) # This represents 0 p = Polynomial([m1, m2, m3, m4, m5]) # (2a_1) + (-a_2^3a_1^-1) + (3a_1) + (-5a_1) + 0 # After simplification: (-a_2^3a_1^-1) + 0 simplified_p = p.simplify() print(simplified_p) # Should print representation without zero terms and combined 2a_1, 3a_1, and -5a_1 as a zero term. ``` # Notes * You may add any helper functions within the Polynomial class as required. * Consider possible edge cases such as all terms canceling each other out to result in a zero polynomial. Happy coding!","solution":"class Monomial: def __init__(self, variables, coefficient): self.variables = variables # A dictionary where keys are variable identifiers (like 1 for x, 2 for y) and values are their exponents. self.coefficient = coefficient def __eq__(self, other): return isinstance(other, Monomial) and self.variables == other.variables and self.coefficient == other.coefficient def __hash__(self): return hash((frozenset(self.variables.items()), self.coefficient)) def can_be_combined(self, other): return self.variables == other.variables def combine_with(self, other): if self.can_be_combined(other): self.coefficient += other.coefficient def is_zero(self): return self.coefficient == 0 class Polynomial: def __init__(self, monomials=None): if monomials is None: monomials = [] self.monomials = monomials def simplify(self): combined_monomials = {} for monomial in self.monomials: variable_tuple = frozenset(monomial.variables.items()) if variable_tuple in combined_monomials: combined_monomials[variable_tuple].combine_with(monomial) else: combined_monomials[variable_tuple] = Monomial(monomial.variables.copy(), monomial.coefficient) # Remove zero coefficient monomials simplified_monomials = [monomial for monomial in combined_monomials.values() if not monomial.is_zero()] return Polynomial(simplified_monomials) def __eq__(self, other): if not isinstance(other, Polynomial): return False return sorted(self.monomials, key=lambda x: frozenset(x.variables.items())) == sorted(other.monomials, key=lambda x: frozenset(x.variables.items())) def __repr__(self): return \\" + \\".join([f\\"{mono.coefficient}{\'\'.join([f\'a_{k}^{v}\' for k, v in sorted(mono.variables.items())])}\\" for mono in self.monomials]) # Creating example monomials m1 = Monomial({1:1}, 2) m2 = Monomial({2:3, 1:-1}, -1) m3 = Monomial({1:1}, 3) m4 = Monomial({1:1}, -5) m5 = Monomial({3: 0}, 0) # This represents 0 p = Polynomial([m1, m2, m3, m4, m5]) # (2a_1) + (-a_2^3a_1^-1) + (3a_1) + (-5a_1) + 0 # After simplification: (-a_2^3a_1^-1) + 0 simplified_p = p.simplify() print(simplified_p) # Should print representation without zero terms and combined 2a_1, 3a_1, and -5a_1 as a zero term."},{"question":"Word Pattern Verification # Objective You are tasked with implementing a function that verifies if a given string follows a specified pattern. This function should ensure a bijection (one-to-one correspondence) between each character in the pattern and each word in the string. # Function Signature ```python def word_pattern(pattern: str, s: str) -> bool: pass ``` # Input - `pattern` (str): A string containing lowercase alphabetical characters. - `s` (str): A string containing words separated by single spaces. # Output - `bool`: Returns `True` if the string follows the given pattern; otherwise, returns `False`. # Example ```python assert word_pattern(\\"abba\\", \\"dog cat cat dog\\") == True assert word_pattern(\\"abba\\", \\"dog cat cat fish\\") == False assert word_pattern(\\"aaaa\\", \\"dog cat cat dog\\") == False assert word_pattern(\\"abba\\", \\"dog dog dog dog\\") == False ``` # Constraints - The `pattern` string contains only lowercase alphabetical characters. - The string `s` contains lowercase words separated by a single space. - Both `pattern` and `s` are non-empty. # Explanation 1. Split the input string `s` into words. 2. Check if the length of `pattern` matches the number of words. 3. Create a bijective mapping between characters in the pattern and words in the string. 4. Ensure that each character maps to one word and vice versa without conflicts. # Task Implement the `word_pattern` function following the guidelines mentioned.","solution":"def word_pattern(pattern: str, s: str) -> bool: Verifies if a given string follows a specified pattern. Ensures a bijection between each character in the pattern and each word in the string. words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: char_to_word[char] = word if word in word_to_char: if word_to_char[word] != char: return False else: word_to_char[word] = char return True"},{"question":"You are tasked to develop a word dictionary that supports adding new words and searching for words using regular expressions. The search queries can include the dot character `\'.\'`, which can represent any letter. Implement the following two classes: 1. **WordDictionary (Trie-based)** - **add_word(self, word: str) -> None**: Adds the word to the trie. - **search(self, word: str) -> bool**: Returns true if there is any string in the trie that matches the given word or pattern, otherwise returns false. 2. **WordDictionary2 (Dictionary-based)** - **add_word(self, word: str) -> None**: Adds the word to the dictionary. - **search(self, word: str) -> bool**: Returns true if there is any string in the dictionary that matches the given word or pattern, otherwise returns false. # Constraints - You can assume that all input strings consist of lowercase letters `a-z`. - Input words and patterns have a maximum length of `10^3`. - The total number of words added won\'t exceed `10^5`. # Example ```python # Using Trie-based implementation word_dict = WordDictionary() word_dict.add_word(\\"bad\\") word_dict.add_word(\\"dad\\") word_dict.add_word(\\"mad\\") assert word_dict.search(\\"pad\\") == False assert word_dict.search(\\"bad\\") == True assert word_dict.search(\\".ad\\") == True assert word_dict.search(\\"b..\\") == True # Using Dictionary-based implementation word_dict2 = WordDictionary2() word_dict2.add_word(\\"bad\\") word_dict2.add_word(\\"dad\\") word_dict2.add_word(\\"mad\\") assert word_dict2.search(\\"pad\\") == False assert word_dict2.search(\\"bad\\") == True assert word_dict2.search(\\".ad\\") == True assert word_dict2.search(\\"b..\\") == True ``` # Requirements 1. Your solution should be efficient in terms of both time and space. 2. Handle edge cases gracefully, such as searching for patterns that do not exist in the dictionary. 3. Ensure the implementation is scalable and can handle the upper limits provided in the constraints.","solution":"from collections import defaultdict import re class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: return self._search_recursive(word, self.root) def _search_recursive(self, word: str, node: TrieNode) -> bool: for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if self._search_recursive(word[i + 1:], child): return True return False elif char in node.children: node = node.children[char] else: return False return node.is_end_of_word class WordDictionary2: def __init__(self): self.words_dict = defaultdict(set) def add_word(self, word: str) -> None: self.words_dict[len(word)].add(word) def search(self, word: str) -> bool: if len(word) not in self.words_dict: return False pattern = re.compile(f\\"^{word}\\") for candidate in self.words_dict[len(word)]: if pattern.match(candidate): return True return False"},{"question":"# Question **Context**: You are working with binary search trees (BSTs) and need to determine the height of a given BST to help analyze its balance and efficiency. Given the structure of a BST, calculate its height using a recursive approach. The height of a tree is defined as the number of edges on the longest path from the root node to a leaf. **Task**: Write a Python function `height` that takes the root node of a binary search tree and returns its height. **Function Signature**: ```python def height(root: Node) -> int: ``` **Input**: * `root` (Node): The root node of a binary search tree. **Output**: * (int): The height of the tree. The height of an empty tree is 0. **Constraints**: * You can assume that the number of nodes in the tree is at most 10^4. * The values of the nodes are unique integers. **Example**: Consider the tree: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` The tree has a height of 4. **Additional Scenario and Context**: Binary Search Trees (BSTs) are widely used in various domains such as databases and filesystems, where efficient searching and sorting operations are critical. Understanding the height of the BST can help optimize these systems by maintaining balanced trees. **Performance Requirements**: Your solution should have a time complexity of O(n) and a space complexity of O(h). **Testing**: Additional tests will be performed on the function to ensure it correctly handles edge cases, such as: * Empty trees. * Trees with only left or only right children (skewed trees). ```python import unittest class TestSuite(unittest.TestCase): def setUp(self): self.tree = bst() self.tree.insert(9) self.tree.insert(6) self.tree.insert(12) self.tree.insert(3) self.tree.insert(8) self.tree.insert(10) self.tree.insert(15) self.tree.insert(7) self.tree.insert(18) def test_height(self): self.assertEqual(4, height(self.tree.root)) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def height(root: Node) -> int: Calculates the height of a binary search tree. if root is None: return 0 left_height = height(root.left) right_height = height(root.right) return max(left_height, right_height) + 1"},{"question":"You are given an array of integers `numbers` that is already sorted in ascending order and an integer `target`. Write a function `find_two_sum` to find two unique numbers in the array such that they add up to the `target`. The function should return the indices of the two numbers as a list `[index1, index2]` (both indices are not zero-based, and index1 < index2). You may assume that each input would have exactly one solution, and you may not use the same element twice. # Function Signature ```python def find_two_sum(numbers: List[int], target: int) -> List[int]: pass ``` # Input * `numbers`: A list of integers sorted in ascending order (1 ≤ len(numbers) ≤ 10^4) * `target`: An integer (-10^5 ≤ target ≤ 10^5) # Output * A list containing two integers `[index1, index2]` where index1 < index2. # Examples ```python assert find_two_sum([2, 7, 11, 15], 9) == [1, 2] assert find_two_sum([1, 2, 3, 4, 4, 9, 56, 90], 8) == [4, 5] assert find_two_sum([2, 3, 4], 6) == [1, 3] ``` # Constraints * Each input list has exactly one solution. * You may not use the same element twice. # Notes * Aim to implement the solution with a linear time complexity O(n). * Consider edge cases where the smallest or largest elements form the pair. * Ensure the function can handle large input sizes within the constraints.","solution":"def find_two_sum(numbers, target): Returns the indices of two numbers in a sorted array that add up to the target. Indices are not zero-based and index1 < index2. left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1 return [] # Example test cases print(find_two_sum([2, 7, 11, 15], 9)) # should return [1, 2] print(find_two_sum([1, 2, 3, 4, 4, 9, 56, 90], 8)) # should return [4, 5] print(find_two_sum([2, 3, 4], 6)) # should return [1, 3]"},{"question":"# Array Rotation Challenge Given an array of n elements, write a function to rotate the array to the right by k steps. You need to implement and compare three different methods to perform this rotation: 1. Using iterative approach (`rotate_v1`). 2. Using reversal segments of the array (`rotate_v2`). 3. Using slicing and concatenation (`rotate_v3`). Function Signatures ```python def rotate_v1(array, k): Rotate the entire array \'k\' times T(n)- O(nk) :type array: List[int] :type k: int :rtype: void Do not return anything, modify array in-place instead. pass def rotate_v2(array, k): Reverse segments of the array, followed by the entire array T(n)- O(n) :type array: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. pass def rotate_v3(array, k): Slice and concatenate the array to achieve the rotation T(n)- O(n) Space- O(n) :type array: List[int] :type k: int :rtype: List[int] - return new rotated array pass ``` Constraints - You may assume the input array is of type `List[int]`. - 0 ≤ k ≤ 10^9 Performance Requirements - Ensure the implementation of `rotate_v2` achieves a time complexity of O(n). Example ```python # Example Input array = [1, 2, 3, 4, 5, 6, 7] k = 3 # Example Output # For rotate_v1, it should modify array in place to [5, 6, 7, 1, 2, 3, 4] # For rotate_v2, it should modify array in place to [5, 6, 7, 1, 2, 3, 4] # For rotate_v3, it should return new rotated array [5, 6, 7, 1, 2, 3, 4] # Example Execution print(rotate_v1([1, 2, 3, 4, 5, 6, 7], 3)) # Output: [5, 6, 7, 1, 2, 3, 4] print(rotate_v2([1, 2, 3, 4, 5, 6, 7], 3)) # Output: [5, 6, 7, 1, 2, 3, 4] print(rotate_v3([1, 2, 3, 4, 5, 6, 7], 3)) # Output: [5, 6, 7, 1, 2, 3, 4] ```","solution":"def rotate_v1(array, k): Rotate the entire array \'k\' times using an iterative approach. T(n)- O(n*k) :type array: List[int] :type k: int :rtype: void Do not return anything, modify array in-place instead. n = len(array) k = k % n # to account for cases where k > n for _ in range(k): previous = array[-1] for i in range(n): array[i], previous = previous, array[i] def rotate_v2(array, k): Reverse segments of the array, followed by the entire array T(n)- O(n) :type array: List[int] :type k: int :rtype: void Do not return anything, modify array in-place instead. def reverse(arr, start, end): while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 n = len(array) k = k % n # to account for cases where k > n reverse(array, 0, n-1) reverse(array, 0, k-1) reverse(array, k, n-1) def rotate_v3(array, k): Slice and concatenate the array to achieve the rotation T(n)- O(n) Space- O(n) :type array: List[int] :type k: int :rtype: List[int] - return new rotated array n = len(array) k = k % n # to account for cases where k > n return array[-k:] + array[:-k]"},{"question":"# Number of Digits in an Integer **Background**: You need to determine the number of digits in an integer for various numeric operations. Given an efficient mathematical approach, implement a function that performs this task. **Problem Statement**: Write a function `count_digits(n)` that computes the number of digits in the given integer `n`. Your function should take into account both positive and negative numbers as well as zero. **Function Signature**: ```python def count_digits(n: int) -> int: pass ``` # Input/Output **Input**: * `n (int)`: The integer whose number of digits will be counted. **Output**: * `int`: The number of digits in the integer `n`. # Constraints: * -10^10 <= n <= 10^10 * n will be a valid integer within the specified range. # Example: ```python assert count_digits(12345) == 5 assert count_digits(-9876) == 4 assert count_digits(0) == 1 assert count_digits(1000000000) == 10 ``` # Additional Notes: * Your implementation should ensure efficiency and correctness. * Handle edge cases effectively, such as zero and negative numbers. * Consider performance, especially with larger integers within the allowed range.","solution":"def count_digits(n: int) -> int: Returns the number of digits in the given integer n. Args: n (int): The integer whose digits will be counted. Returns: int: The number of digits in the integer. return len(str(abs(n)))"},{"question":"# Intermediate Difficulty: Deleting a Specific Node in a Singly Linked List Background You are given a singly linked list and a reference to a node that needs to be deleted. You will not have access to the head of the list, only the node that needs to be removed. Typical deletion operations in linked lists usually require access to the head node to properly adjust pointers. In this task, you will need to implement an efficient deletion method with the constraints provided. Problem Requirements Implement the function `delete_node(node)` which modifies the linked list in-place by deleting the given `node`. The node to be deleted will not be the tail node. Function Signature ```python def delete_node(node: Node) -> None: ``` Input - A single parameter `node` of type `Node`. This node is guaranteed not to be the tail node of the list and not `None`. Output - The function does not need to return anything. It should modify the linked list directly by removing the referenced node. Example Given the linked list `1 -> 2 -> 3 -> 4 -> 5` and you are asked to delete node `3`, the structure after deletion should be `1 -> 2 -> 4 -> 5`. Constraints - Nodes should be instances of the `Node` class with the properties `val` and `next`. - You cannot return the modified list. Instead, the list must be altered in-place. Additional Information - If attempting to delete the last node or passing a `None`, the function should raise an appropriate error. ```python import unittest class Node: Class definition for a singly linked list node. def __init__(self, x): self.val = x self.next = None def delete_node(node: Node) -> None: Deletes a given node (not the tail) from a singly linked list. if node is None or node.next is None: raise ValueError(\\"Cannot delete the last node in this manner or a non-existent node.\\") # Copy data from the next node to the current node node.val = node.next.val # Bypass the next node node.next = node.next.next class TestDeleteNode(unittest.TestCase): def test_delete_node(self): # Prepare the linked list 1 -> 2 -> 3 -> 4 -> 5 head = Node(1) current = head for i in range(2, 6): current.next = Node(i) current = current.next # Delete node 3 node3 = head.next.next # Node with value 3 delete_node(node3) # Verify the structure is now 1 -> 2 -> 4 -> 5 expected_values = [1, 2, 4, 5] current = head for value in expected_values: self.assertEqual(current.val, value) current = current.next self.assertIsNone(current) with self.assertRaises(ValueError): delete_node(current) # Trying to delete the tail if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: Class definition for a singly linked list node. def __init__(self, x): self.val = x self.next = None def delete_node(node: Node) -> None: Deletes a given node (not the tail) from a singly linked list. if node is None or node.next is None: raise ValueError(\\"Cannot delete the last node in this manner or a non-existent node.\\") # Copy data from the next node to the current node node.val = node.next.val # Bypass the next node node.next = node.next.next"},{"question":"# Question: Reverse a Subsection of a Singly Linked List Given a singly linked list, write a function to reverse a subsection of the list given the start and end positions (1-indexed). Example: Input: ``` LinkedList: 1 -> 2 -> 3 -> 4 -> 5 Start: 2, End: 4 ``` Output: ``` LinkedList: 1 -> 4 -> 3 -> 2 -> 5 ``` # Function Signature: ```python def reverse_subsection(head: ListNode, start: int, end: int) -> ListNode: :param head: ListNode, head of the singly linked list :param start: int, the starting position of the subsection to be reversed (1-indexed) :param end: int, the ending position of the subsection to be reversed (1-indexed) :return: ListNode, head of the modified linked list ``` # Constraints: * The starting and ending positions will always be valid. * The linked list will have at least one element. * `1 <= start <= end <= length of linked list`. # Scenario: Suppose you are working on a programming language\'s built-in list-like data structure, and you need to implement a feature that allows users to efficiently reverse a specific section of the list. Your task is to implement this feature in the most optimal way using linked lists. # Performance Requirements: * Time Complexity: O(n) * Space Complexity: O(1)","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_subsection(head: ListNode, start: int, end: int) -> ListNode: if not head or start == end: return head dummy = ListNode(0) dummy.next = head prev = dummy # Move `prev` to the node before the reversing section for _ in range(start - 1): prev = prev.next # `curr` is the first node of the reversing section curr = prev.next for _ in range(end - start): next = curr.next curr.next = next.next next.next = prev.next prev.next = next return dummy.next"},{"question":"**Scenario**: You have been tasked with developing a library for an analytics tool that processes large datasets. One of the common operations in this tool is to quickly find ranges of specific values in sorted arrays. Given your expertise in efficient searching algorithms, you are to implement an optimized function to find the starting and ending positions of a target value in a sorted array. # Function Specification Write a Python function named `search_range` that accepts two parameters: 1. `nums` (List[int]): A list of integers sorted in ascending order. 2. `target` (int): An integer target value. The function should return a list of two integers representing the starting and ending positions of the target value within the `nums` list. If the target is not found, return `[-1, -1]`. # Input Format * `nums`: A list of integers `nums` sorted in ascending order. * `target`: An integer representing the target value to search for in the `nums` list. # Output Format The function should return a list `[start, end]`, where: * `start` is the index of the first occurrence of the target in the list. * `end` is the index of the last occurrence of the target in the list. * If the target is not found, return `[-1, -1]`. # Constraints * The length of the `nums` list will be in the range `[0, 10^5]`. * The `nums` list elements will be in the range `[-10^9, 10^9]`. * The `target` will be in the range `[-10^9, 10^9]`. # Performance Requirements * The solution should aim for logarithmic time complexity where possible. * Memory usage should be kept minimal, aiming for constant space complexity. # Example ```python # Example 1 nums = [5,7,7,8,8,8,10] target = 8 Output: [3, 5] # Example 2 nums = [5,7,7,8,8,8,10] target = 11 Output: [-1, -1] ``` # Solution Template Here is a template you can use to implement your solution: ```python def search_range(nums, target): :type nums: List[int] :type target: int :rtype: List[int] def find_first(nums, target): low, high = 0, len(nums) - 1 while low <= high: mid = (low + high) // 2 if nums[mid] < target: low = mid + 1 elif nums[mid] > target: high = mid - 1 else: if mid == 0 or nums[mid-1] != target: return mid high = mid - 1 return -1 def find_last(nums, target): low, high = 0, len(nums) - 1 while low <= high: mid = (low + high) // 2 if nums[mid] < target: low = mid + 1 elif nums[mid] > target: high = mid - 1 else: if mid == len(nums) - 1 or nums[mid+1] != target: return mid low = mid + 1 return -1 start = find_first(nums, target) if start == -1: return [-1, -1] end = find_last(nums, target) return [start, end] ```","solution":"def search_range(nums, target): :type nums: List[int] :type target: int :rtype: List[int] def find_first(nums, target): low, high = 0, len(nums) - 1 while low <= high: mid = (low + high) // 2 if nums[mid] < target: low = mid + 1 elif nums[mid] > target: high = mid - 1 else: if mid == 0 or nums[mid-1] != target: return mid high = mid - 1 return -1 def find_last(nums, target): low, high = 0, len(nums) - 1 while low <= high: mid = (low + high) // 2 if nums[mid] < target: low = mid + 1 elif nums[mid] > target: high = mid - 1 else: if mid == len(nums) - 1 or nums[mid+1] != target: return mid low = mid + 1 return -1 start = find_first(nums, target) if start == -1: return [-1, -1] end = find_last(nums, target) return [start, end]"},{"question":"# Inverting a Matrix Problem Statement Given an invertible ( n times n ) matrix, write a function `invert_matrix(matrix)` that returns its inverse. If the input matrix is not invertible or invalid, return appropriate error messages as specified. Your solution should handle matrices of arbitrary size where possible and optimize for performance and memory usage where feasible. Function Signature ```python def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: pass ``` Input * `matrix`: A list of lists where each inner list represents a row of the matrix. The matrix is guaranteed to have float entries. Output * An `n x n` list of lists representing the inverse of the matrix. * Return the following specific error conditions: - Return `[[-1]]` if the input is not a matrix. - Return `[[-2]]` if the matrix is not square. - Return `[[-3]]` if the matrix is too small (0x0 or 1x1). - Return `[[-4]]` if the matrix is singular (determinant is zero). Constraints * ( 2 leq n leq 10 ) * Elements of matrix are floats. Example ```python # Example 1: matrix = [ [2, 5], [1, 3] ] print(invert_matrix(matrix)) # Output: [[3.0, -5.0], [-1.0, 2.0]] # Example 2: matrix = [ [1, 2], [2, 4] ] print(invert_matrix(matrix)) # Output: [[-4]] ``` Notes 1. Ensure to handle edge cases properly, including non-matrix structures, non-square matrices, and singular matrices. 2. Utilize helper functions to break down the solution into manageable steps. 3. Make sure to implement an efficient determinant calculation to handle larger matrices within the constraint. 4. Aim for clarity and correctness in your implementation.","solution":"from typing import List import numpy as np def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: # Check if input is a list of lists if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): return [[-1]] # Check if matrix is square n = len(matrix) if any(len(row) != n for row in matrix): return [[-2]] # Check if matrix is too small if n < 2: return [[-3]] # Convert matrix to numpy array matrix_np = np.array(matrix) # Check if matrix is singular determinant = np.linalg.det(matrix_np) if determinant == 0: return [[-4]] # Compute the inverse using numpy inverse = np.linalg.inv(matrix_np) return inverse.tolist()"},{"question":"# Advanced Coding Assessment: Diffie-Hellman Key Exchange Simulation **Objective**: Implement an advanced Diffie-Hellman key exchange algorithm that securely allows two parties to exchange keys over an insecure channel and enhance it in a way that optimizes the computation of primitive roots. **Scenario**: You are securing a communication channel between two parties, Alice and Bob, using the Diffie-Hellman key exchange. The exchanged keys will allow them to communicate confidentially. You need to implement the key exchange in Python, ensuring it handles large prime values efficiently. **Requirements**: 1. **Function `secure_diffie_hellman_key_exchange(p: int, a: int) -> bool`**: - Validates and performs Diffie-Hellman key exchange. - Inputs `p` must be a large prime number. - Input `a` must be a primitive root modulo `p`. - Returns True if Alice and Bob compute the same shared key, False otherwise. 2. **Function `optimized_find_primitive_root(p: int) -> list`**: - Efficiently finds all primitive roots of p using optimized methods (e.g., pre-computation, efficient checks). - Input `p` is a prime number. - Returns a list of all primitive roots of `p`. **Constraints**: - Max value for `p` is `10^9`. - Ensure the functions handle edge cases and performance bottlenecks gracefully. **Performance Requirements**: - Efficient computation avoiding nested iterations where possible. - Handle large prime numbers within reasonable time and space complexity. **Input/Output**: - Function `secure_diffie_hellman_key_exchange`: - Input: `p` (prime number), `a` (primitive root of `p`) - Output: Boolean indicating if keys match. - Function `optimized_find_primitive_root`: - Input: `p` (prime number) - Output: List of integers. Use the following template: ```python import math from random import randint def prime_check(num): Return True if num is a prime number. if num <= 1: return False if num == 2 or num == 3: return True if num % 2 == 0 or num % 3 == 0: return False j = 5 while j * j <= num: if num % j == 0 or num % (j + 2) == 0: return False j += 6 return True def find_order(a, n): if math.gcd(a, n) != 1: return -1 for i in range(1, n): if pow(a, i) % n == 1: return i return -1 def euler_totient(n): result = n for i in range(2, int(n ** 0.5) + 1): if n % i == 0: while n % i == 0: n //= i result -= result // i if n > 1: result -= result // n return result def alice_private_key(p): return randint(1, p - 1) def alice_public_key(a_pr_k, a, p): return pow(a, a_pr_k) % p def bob_private_key(p): return randint(1, p - 1) def bob_public_key(b_pr_k, a, p): return pow(a, b_pr_k) % p def alice_shared_key(b_pu_k, a_pr_k, p): return pow(b_pu_k, a_pr_k) % p def bob_shared_key(a_pu_k, b_pr_k, p): return pow(a_pu_k, b_pr_k) % p def optimized_find_primitive_root(p): # TODO: Implement optimized algorithm to find all primitive roots of p. pass def secure_diffie_hellman_key_exchange(p, a): if prime_check(p) is False: print(f\\"{p} is not a prime number\\") return False if optim_find_pr(p).index(a) == -1: print(f\\"{a} is not a primitive root of {p}\\") return False a_pr_k = alice_private_key(p) a_pu_k = alice_public_key(a_pr_k, a, p) b_pr_k = bob_private_key(p) b_pu_k = bob_public_key(b_pr_k, a, p) a_sh_k = alice_shared_key(b_pu_k, a_pr_k, p) b_sh_k = bob_shared_key(a_pu_k, b_pr_k, p) return a_sh_k == b_sh_k ``` Ensure you implement `optimized_find_primitive_root` efficiently and test `secure_diffie_hellman_key_exchange` across a variety of large prime numbers for correctness and performance.","solution":"import math from random import randint def prime_check(num): Return True if num is a prime number. if num <= 1: return False if num == 2 or num == 3: return True if num % 2 == 0 or num % 3 == 0: return False j = 5 while j * j <= num: if num % j == 0 or num % (j + 2) == 0: return False j += 6 return True def order(a, p): Return the order of a modulo p. if math.gcd(a, p) != 1: return -1 for i in range(1, p): if pow(a, i, p) == 1: return i return -1 def euler_totient(n): Calculate Euler\'s Totient function for n. result = n for i in range(2, int(n ** 0.5) + 1): if n % i == 0: while n % i == 0: n //= i result -= result // i if n > 1: result -= result // n return result def find_primitive_roots(p): Finds all primitive roots of p. roots = [] phi = euler_totient(p) for g in range(1, p): if order(g, p) == phi: roots.append(g) return roots def alice_private_key(p): return randint(1, p - 1) def alice_public_key(a_pr_k, a, p): return pow(a, a_pr_k, p) def bob_private_key(p): return randint(1, p - 1) def bob_public_key(b_pr_k, a, p): return pow(a, b_pr_k, p) def alice_shared_key(b_pu_k, a_pr_k, p): return pow(b_pu_k, a_pr_k, p) def bob_shared_key(a_pu_k, b_pr_k, p): return pow(a_pu_k, b_pr_k, p) def optimized_find_primitive_root(p): Optimized algorithm to find all primitive roots of p. # Step 1: Find all prime factors of phi(p) phi = euler_totient(p) prime_factors = set() n = phi for i in range(2, int(phi ** 0.5) + 1): if n % i == 0: prime_factors.add(i) while n % i == 0: n //= i if n > 1: prime_factors.add(n) # Step 2: Find the first primitive root for g in range(2, p): flag = True for factor in prime_factors: if pow(g, phi // factor, p) == 1: flag = False break if flag: break # Step 3: Collect all primitive roots based on the first one found primitive_roots = [] for k in range(1, phi): if math.gcd(k, phi) == 1: primitive_roots.append(pow(g, k, p)) return primitive_roots def secure_diffie_hellman_key_exchange(p, a): if not prime_check(p): print(f\\"{p} is not a prime number\\") return False # Find all primitive roots of p all_primitive_roots = optimized_find_primitive_root(p) if a not in all_primitive_roots: print(f\\"{a} is not a primitive root of {p}\\") return False a_pr_k = alice_private_key(p) a_pu_k = alice_public_key(a_pr_k, a, p) b_pr_k = bob_private_key(p) b_pu_k = bob_public_key(b_pr_k, a, p) a_sh_k = alice_shared_key(b_pu_k, a_pr_k, p) b_sh_k = bob_shared_key(a_pu_k, b_pr_k, p) return a_sh_k == b_sh_k"},{"question":"Question You are given a partially implemented Binary Search Tree (BST) class with methods to `insert`, `search`, `size`, and `traverse` the tree in different orders. Your task is to add methods that will count the number of leaf nodes in the tree and another method to balance the tree. # Part 1: Counting Leaf Nodes Write a method `count_leaves` that counts the number of leaf nodes in the BST. **Function Signature**: ```python def count_leaves(self) -> int: pass ``` **Requirements**: * The function should return the count of leaf nodes in the tree. # Part 2: Tree Balancing Implement a method `balance` that balances the BST to maintain its average-case time complexity of O(log N). **Function Signature**: ```python def balance(self) -> None: pass ``` **Requirements**: * The function should modify the tree in place to balance it. # Example: Assume the BST was created as outlined in the provided code snippets. ```python tree = BST() tree.insert(10) tree.insert(15) tree.insert(6) tree.insert(4) tree.insert(9) tree.insert(12) tree.insert(24) tree.insert(7) tree.insert(20) tree.insert(30) tree.insert(18) print(tree.count_leaves()) # Output should be 6. tree.balance() ``` **Notes**: * Balanced tree might vary, ensuring average O(log N) time complexity for insert/search operations. * You should leverage inorder traversal to reconstruct a balanced tree using sorted nodes. **Constraints**: * You should handle edge cases such as an empty tree. Implement the above methods in the existing `BST` class and provide sufficient test cases to validate your implementation.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = TreeNode(key) else: self._insert(root.left, key) else: if root.right is None: root.right = TreeNode(key) else: self._insert(root.right, key) def search(self, key) -> bool: return self._search(self.root, key) def _search(self, root, key) -> bool: if root is None: return False if root.val == key: return True elif key < root.val: return self._search(root.left, key) else: return self._search(root.right, key) def size(self) -> int: return self._size(self.root) def _size(self, root) -> int: if root is None: return 0 else: return 1 + self._size(root.left) + self._size(root.right) def inorder_traversal(self) -> list: result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, root, result): if root: self._inorder_traversal(root.left, result) result.append(root.val) self._inorder_traversal(root.right, result) def count_leaves(self) -> int: return self._count_leaves(self.root) def _count_leaves(self, root) -> int: if root is None: return 0 if root.left is None and root.right is None: return 1 return self._count_leaves(root.left) + self._count_leaves(root.right) def balance(self) -> None: # Get nodes in sorted order nodes = self.inorder_traversal() # Build balanced BST from sorted nodes self.root = self._build_balanced_tree(nodes) def _build_balanced_tree(self, nodes: list): if not nodes: return None mid = len(nodes) // 2 root = TreeNode(nodes[mid]) root.left = self._build_balanced_tree(nodes[:mid]) root.right = self._build_balanced_tree(nodes[mid+1:]) return root"},{"question":"**Question: Managing Network of Friends Using Disjoint Sets** **Context**: You\'re developing a social network application. Users can send friend requests and accept them. Once accepted, the friend request establishes a friendship, connecting two users. We need to manage these friendships to check if two users are friends (either directly or indirectly through mutual friends). **Task**: Implement a function `friends_log` using the Union-Find data structure to manage friendship connections on the social network. **Function Signature**: ```python def friends_log(events: List[Tuple[str, int, int]]) -> List[bool]: ``` **Expected Input**: - `events`: A list of tuples where each tuple contains an event: - `(\\"friend\\", user1, user2)`: Indicates user1 and user2 became friends. - `(\\"check\\", user1, user2)`: Checks if user1 and user2 are friends (directly or indirectly connected). **Expected Output**: - Returns a list of booleans representing the results of \\"check\\" events in the same order they appear in `events`. **Constraints**: - You can assume the number of users and events are both in the range `[1, 10^4]`. - Users will be represented by unique integers. - The operations should be highly efficient given the constraints. **Examples**: ```python events = [ (\\"friend\\", 1, 2), (\\"friend\\", 2, 3), (\\"check\\", 1, 3), (\\"check\\", 1, 4), (\\"friend\\", 3, 4), (\\"check\\", 1, 4) ] # Output: [True, False, True] events = [ (\\"friend\\", 1, 5), (\\"friend\\", 2, 6), (\\"check\\", 1, 5), (\\"check\\", 2, 6), (\\"check\\", 1, 6), (\\"friend\\", 1, 6), (\\"check\\", 1, 2) ] # Output: [True, True, False, True] ``` **Explanation**: - In the first example: - 1 and 2 become friends. - 2 and 3 become friends. - Checking if 1 and 3 are friends returns true as they are indirectly connected through 2. - Checking if 1 and 4 returns false, as 4 is not connected. - 3 and 4 become friends. - Checking if 1 and 4 returns true, they are now indirectly connected. - In the second example: - 1 and 5 become friends. - 2 and 6 become friends. - Checking if 1 and 5 returns true as they are directly connected. - Checking if 2 and 6 returns true for the same reason. - Checking if 1 and 6 before any connection returns false. - After 1 and 6 become friends, and checking if 1 and 2 are connected returns true (1-5-6-2).","solution":"def friends_log(events): parent = {} rank = {} def find(u): if u != parent[u]: parent[u] = find(parent[u]) return parent[u] def union(u, v): root_u = find(u) root_v = find(v) if root_u != root_v: if rank[root_u] > rank[root_v]: parent[root_v] = root_u elif rank[root_u] < rank[root_v]: parent[root_u] = root_v else: parent[root_v] = root_u rank[root_u] += 1 results = [] for event in events: action, user1, user2 = event if user1 not in parent: parent[user1] = user1 rank[user1] = 0 if user2 not in parent: parent[user2] = user2 rank[user2] = 0 if action == \\"friend\\": union(user1, user2) elif action == \\"check\\": results.append(find(user1) == find(user2)) return results"},{"question":"# Context: You are working on a text processing system where you need to determine if a given text can be segmented into valid words based on a predefined dictionary. This feature is critical as it is used in applications like spell-checking, auto-correction, and text suggestion. # Task: Write a function `is_word_segmentable` that takes a string `text` and a list of words `word_dict`. Your task is to determine if the string `text` can be segmented into a space-separated sequence of one or more dictionary words. # Function Signature: ```python def is_word_segmentable(text: str, word_dict: List[str]) -> bool: ``` # Input: * `text` (0 <= len(text) <= 30000): A string representing the text to be segmented. * `word_dict` (0 <= len(word_dict) <= 5000): A list of non-empty words. # Output: * Return `True` if `text` can be segmented into one or more words found in `word_dict`. * Return `False` otherwise. # Constraints: * You can assume the dictionary does not contain duplicate words. * The words in the dictionary do not contain spaces or special characters, only lowercase alphabets. # Example: ```python assert is_word_segmentable(\\"leetcode\\", [\\"leet\\", \\"code\\"]) == True assert is_word_segmentable(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) == True assert is_word_segmentable(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == False assert is_word_segmentable(\\"abcd\\", [\\"a\\", \\"abc\\", \\"b\\", \\"cd\\"]) == True ``` # Performance Requirements: * The implementation should have time complexity O(N^2) and space complexity O(N), where N is the length of the input string `text`. # Hints: 1. Consider using dynamic programming to keep track of possible segmentations. 2. Use a boolean array to store intermediate results and avoid redundant calculations.","solution":"def is_word_segmentable(text: str, word_dict: list) -> bool: Determine if the string `text` can be segmented into one or more words found in `word_dict`. word_set = set(word_dict) dp = [False] * (len(text) + 1) dp[0] = True for i in range(1, len(text) + 1): for j in range(i): if dp[j] and text[j:i] in word_set: dp[i] = True break return dp[len(text)]"},{"question":"# Subset Generation with Constraints Problem Statement You are given a list of distinct integers, `nums`. Your task is to write a function `constrained_subsets(nums, min_size, max_size)` that returns all possible subsets of the given list where each subset\'s size is between `min_size` and `max_size` (inclusive). The solution set must not contain duplicate subsets. Input Format - `nums`: A list of distinct integers (e.g., `[1, 2, 3]`). - `min_size`: An integer representing the minimum size of the subsets to be included (e.g., `1`). - `max_size`: An integer representing the maximum size of the subsets to be included (e.g., `2`). Output Format - A set of tuples, where each tuple is a subset of the input list `nums`, and the size of each subset is between `min_size` and `max_size`. Constraints - `0 <= min_size <= max_size <= len(nums) <= 20` - The elements of `nums` are distinct integers. - The order within subsets does not matter, but each subset should be represented as a sorted tuple. Example ```python constrained_subsets([1, 2, 3], 1, 2) ``` # Output: ``` { (1,), (2,), (3,), (1, 2), (1, 3), (2, 3) } ``` Performance Requirements - Function should handle inputs efficiently up to the maximum constraint (`len(nums) = 20`). Implementation Details 1. Generate all possible subsets using a similar approach as demonstrated earlier. 2. Filter the subsets based on the given constraints (`min_size` and `max_size`). 3. Return the resulting set of tuples.","solution":"from itertools import combinations def constrained_subsets(nums, min_size, max_size): Generate all possible subsets of `nums` where each subset\'s size is between `min_size` and `max_size`. Parameters: nums (List[int]): List of distinct integers. min_size (int): Minimum size of the subset. max_size (int): Maximum size of the subset. Returns: Set[Tuple[int]]: A set of tuples, each representing a valid subset. all_subsets = set() for size in range(min_size, max_size + 1): for combo in combinations(nums, size): all_subsets.add(combo) return all_subsets"},{"question":"You are given a square matrix `mat` of size `d x d` and an integer `n`. Implement a function called `matrix_power` that computes the power `n` of the given matrix using the matrix exponentiation algorithm discussed. # Function Signature ```python def matrix_power(mat: list, n: int) -> list: Computes the power \'n\' of the given square matrix \'mat\'. :param mat: A list of lists representing the square matrix of dimension d x d. :param n: An integer representing the exponent to which the matrix is to be raised. :return: A list of lists representing the matrix raised to the power \'n\'. ``` # Input * `mat`: A list of lists where each sub-list represents a row in a `d x d` matrix and each element of the sub-list is an integer. (1 <= d <= 100) * `n`: An integer (-10^9 <= n <= 10^9). # Output * A list of lists representing the matrix `mat` raised to the power `n`. # Constraints * The elements of `mat` are integers in the range (-10^9, 10^9). * The matrix `mat` is guaranteed to be non-empty and square. * If `n` == 0, return the identity matrix of the same dimension as `mat`. * If `n` < 0, compute the inverse of the matrix raised to the absolute value of `n`, if invertible. If not invertible, return an empty list. # Requirements * Your implementation should have a time complexity of O(d^3 log(|n|)) for matrix exponentiation operations. * You should appropriately handle edge cases like n=0, and ensure to return an identity matrix for these cases. # Example ```python # Example 1 mat = [[2, 0], [0, 2]] n = 3 print(matrix_power(mat, n)) # Output: [[8, 0], [0, 8]] # Example 2 mat = [[1, 2], [3, 4]] n = 2 print(matrix_power(mat, n)) # Output: [[7, 10], [15, 22]] # Example 3 mat = [[1, 0], [0, 1]] n = 0 print(matrix_power(mat, n)) # Output: [[1, 0], [0, 1]] ```","solution":"def matrix_power(mat, n): def matrix_multiply(A, B): size = len(A) result = [[0] * size for _ in range(size)] for i in range(size): for j in range(size): for k in range(size): result[i][j] += A[i][k] * B[k][j] return result def identity_matrix(size): return [[1 if i == j else 0 for j in range(size)] for i in range(size)] def matrix_exponentiate(base, exp): size = len(base) result = identity_matrix(size) while exp > 0: if exp % 2 == 1: result = matrix_multiply(result, base) base = matrix_multiply(base, base) exp = exp // 2 return result # If n is zero, return the identity matrix if n == 0: return identity_matrix(len(mat)) # If n is negative, calculate the inverse of the matrix if n < 0: # Simple placeholder for inversion, assumes invertible matrix # In reality you\'d have to implement/find an inversion algorithm like Gauss-Jordan elimination import numpy as np try: mat = np.linalg.inv(mat).tolist() n = -n except np.linalg.LinAlgError: return [] return matrix_exponentiate(mat, n)"},{"question":"# Question: You are working as a software developer interning at a company that builds predictive models for traffic simulation. One of the core components of these models is to predict the next traffic state at any given time based on the current state and a predefined probability distribution. Your task is to implement a function that takes an initial state and simulates the sequence of traffic states using a given Markov chain. Problem Statement: Implement a function `markov_chain_sequence(chain: dict, start_state: str, num_steps: int) -> list` that generates a sequence of states based on the provided Markov chain. The function should start from the `start_state` and generate a total of `num_steps` states. Function Signature: ```python def markov_chain_sequence(chain: dict, start_state: str, num_steps: int) -> list: pass ``` Input: - `chain`: A dictionary representing the Markov chain. - `start_state`: The starting state for the Markov chain. - `num_steps`: The total number of states to generate, including the starting state. Output: - A list of strings representing the sequence of states. Constraints: - The chain dictionary is properly formatted and probabilities sum to 1 for each state. - `num_steps` is a positive integer, and `start_state` is a valid state within the chain. Example Usage: ```python chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } start_state = \'A\' num_steps = 5 result = markov_chain_sequence(chain, start_state, num_steps) print(result) # Possible output: [\'A\', \'E\', \'A\', \'A\', \'E\'] ``` **Make sure to handle edge cases where probabilities are extremely small or situations where chain states form a recurrence or cyclic behavior.**","solution":"import random def markov_chain_sequence(chain, start_state, num_steps): Generates a sequence of states based on a Markov chain starting from a given state. Args: chain (dict): A dictionary representing the Markov chain. start_state (str): The starting state for the Markov chain. num_steps (int): The total number of states to generate, including the starting state. Returns: list: A list of strings representing the sequence of states. state_sequence = [start_state] current_state = start_state for _ in range(num_steps - 1): next_states = list(chain[current_state].keys()) probabilities = list(chain[current_state].values()) next_state = random.choices(next_states, probabilities)[0] state_sequence.append(next_state) current_state = next_state return state_sequence"},{"question":"# Next Higher Number with Same Digits **Objective:** Implement a function `next_bigger(num: int) -> int` that finds the next higher number using the same set of digits as the given number. If such a number is not possible, the function should return -1. **Constraints:** - The input number will be a non-negative integer. - The function must handle edge cases such as repeated digits and single-digit numbers. - Do not use any external libraries for sorting or permutation generation. **Input:** - An integer `num`, where 0 ≤ num ≤ 10^9. **Output:** - Return the next larger number formed by the same digits, or -1 if no such number exists. **Examples:** ```python next_bigger(38276) # should return 38627 next_bigger(12345) # should return 12354 next_bigger(1528452) # should return 1528524 next_bigger(138654) # should return 143568 next_bigger(54321) # should return -1 next_bigger(999) # should return -1 next_bigger(5) # should return -1 ``` **Scenario Context:** You are working as a software developer where task scheduling is based on permutations of task IDs denoted by digits. To optimize scheduling, you need to determine the next possible permutation of a given numeric task ID that is larger than the current one. Implement the required function accordingly. **Note:** - The implemented function should be efficient, and while you can assume typical integer constraints, ensure it handles up to 10 digits appropriately. - Include necessary edge case checks in your code to prevent erroneous outputs.","solution":"def next_bigger(num: int) -> int: Returns the next higher number using the same set of digits as the given number. If no such number is possible, return -1. digits = list(str(num)) length = len(digits) # Traverse the number from right to left for i in range(length - 2, -1, -1): if digits[i] < digits[i + 1]: break else: # No such digit was found, return -1 return -1 # Find the smallest digit on the right side of (i)\'th digit, # which is larger than digits[i] for j in range(length - 1, i, -1): if digits[j] > digits[i]: break # Swap the found smallest digit with digits[i] digits[i], digits[j] = digits[j], digits[i] # Sort the digits beyond i and return the number digits = digits[:i + 1] + sorted(digits[i + 1:]) return int(\'\'.join(digits))"},{"question":"# Coding Problem: Fenwick Tree for Frequency Counting Context: Consider a dataset representing the number of occurrences of different items. You need to efficiently compute the prefix sum of occurrences (i.e., the total number of occurrences up to a certain item) and handle updates in this dataset. Problem Statement: Implement a class `FrequencyCounter` that uses a Fenwick Tree (Binary Indexed Tree) to store and manipulate the frequency data. The class should support the following operations: 1. **Initializing the dataset with the initial frequencies** 2. **Updating the frequency of a specific item** 3. **Computing the total frequency of items up to a given index** Methods to Implement: 1. `__init__(self, freq: List[int]) -> None`: Initialize with the list of initial frequencies. 2. `update_frequency(self, index: int, frequency: int) -> None`: Update the frequency of the item at a given index. 3. `total_frequency_up_to(self, index: int) -> int`: Return the total frequency of items from the start up to the given index. Input: * The list of initial frequencies, `freq`, with 1 ≤ len(freq) ≤ 10^5 and 0 ≤ freq[i] ≤ 10^6. * Update queries specifying an index (0-based) and a frequency. * Frequency sum queries specifying an index (0-based). Output: * Results of the sum queries. Constraints: 1. Ensure that the operations are performed in O(log n) time. 2. Handle large inputs efficiently. 3. Handle edge cases as specified above. Example: ```python # Initialize with frequency [1, 2, 3, 4, 5] fc = FrequencyCounter([1, 2, 3, 4, 5]) # Update frequency of item at index 3 to 6 fc.update_frequency(3, 6) # Now the frequency array is [1, 2, 3, 6, 5] # Query total frequency up to index 2 print(fc.total_frequency_up_to(2)) # Output: 6 # Query total frequency up to index 4 print(fc.total_frequency_up_to(4)) # Output: 17 ``` Requirements: 1. Focus on performance and correctness. 2. Provide ample documentation and comments in the code for clarity.","solution":"class FrequencyCounter: def __init__(self, freq): Initialize the FrequencyCounter with the list of initial frequencies. self.n = len(freq) self.tree = [0] * (self.n + 1) for i in range(self.n): self._update_tree(i, freq[i]) def _update_tree(self, index, delta): An internal helper function to update the Fenwick Tree. index += 1 while index <= self.n: self.tree[index] += delta index += index & -index def update_frequency(self, index, frequency): Update the frequency of the item at the given index. current_freq = self.total_frequency_up_to(index) - self.total_frequency_up_to(index - 1) delta = frequency - current_freq self._update_tree(index, delta) def total_frequency_up_to(self, index): Return the total frequency of items from the start up to the given index. sum_freq = 0 index += 1 while index > 0: sum_freq += self.tree[index] index -= index & -index return sum_freq"},{"question":"You are tasked with implementing the maximum flow algorithms in a flow network represented by an adjacency matrix. Your goal is to write a function that accurately computes the maximum flow from a specified source to a sink using each of the three algorithms provided. # Function Requirements 1. **ford_fulkerson**: Implement the Ford-Fulkerson algorithm using Depth First Search (DFS). 2. **edmonds_karp**: Implement Edmonds-Karp algorithm using Breadth First Search (BFS). 3. **dinic**: Implement Dinic\'s algorithm utilizing layered networks and blocking flows. # Input & Output Formats - **Input**: - `capacity` (List[List[int]]): A 2D list where `capacity[i][j]` represents the capacity of the edge from node `i` to node `j`. If there is no edge from node `i` to node `j`, this value should be zero. - `source` (int): The source vertex from where the flow starts. - `sink` (int): The sink vertex where the flow ends. - **Output**: - An integer representing the maximum flow from the source to the sink. # Constraints & Limitations - The number of vertices (`V`) is between 1 and 100. - The capacity of each edge (`capacity[i][j]`) is between 0 and 1000. # Performance Requirements - Ensure your implementation adheres to the specified time complexities: - **Ford-Fulkerson**: O(Ef) - **Edmonds-Karp**: O(VE^2) - **Dinic\'s**: O(V^2E) # Example ```python # Example input capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 # Calling Ford-Fulkerson max_flow_ff = ford_fulkerson(capacity, source, sink) print(max_flow_ff) # Output: 23 # Calling Edmonds-Karp max_flow_ek = edmonds_karp(capacity, source, sink) print(max_flow_ek) # Output: 23 # Calling Dinic\'s max_flow_dinic = dinic(capacity, source, sink) print(max_flow_dinic) # Output: 23 ``` Implement the three different algorithms in Python and test to ensure they provide the correct maximum flow for a given input.","solution":"def ford_fulkerson(capacity, source, sink): Returns the maximum flow from source to sink using the Ford-Fulkerson algorithm. def dfs_flow(source, sink, flow): visited[source] = True if source == sink: return flow for neighbor in range(len(capacity)): res_capacity = capacity[source][neighbor] - flow_passed[source][neighbor] if not visited[neighbor] and res_capacity > 0: current_flow = min(flow, res_capacity) temp_flow = dfs_flow(neighbor, sink, current_flow) if temp_flow > 0: flow_passed[source][neighbor] += temp_flow flow_passed[neighbor][source] -= temp_flow return temp_flow return 0 n = len(capacity) flow_passed = [[0]*n for _ in range(n)] max_flow = 0 while True: visited = [False]*n flow = dfs_flow(source, sink, float(\'Inf\')) if flow == 0: break max_flow += flow return max_flow def edmonds_karp(capacity, source, sink): Returns the maximum flow from source to sink using the Edmonds-Karp algorithm. from collections import deque def bfs_flow(): visited = [-1] * len(capacity) queue = deque([source]) visited[source] = source path_flow = [float(\'Inf\')] * len(capacity) while queue: current_node = queue.popleft() for neighbor in range(len(capacity)): res_capacity = capacity[current_node][neighbor] - flow_passed[current_node][neighbor] if visited[neighbor] == -1 and res_capacity > 0: visited[neighbor] = current_node path_flow[neighbor] = min(path_flow[current_node], res_capacity) if neighbor == sink: return path_flow[sink], visited queue.append(neighbor) return 0, visited n = len(capacity) flow_passed = [[0]*n for _ in range(n)] max_flow = 0 while True: flow, visited = bfs_flow() if flow == 0: break max_flow += flow v = sink while v != source: u = visited[v] flow_passed[u][v] += flow flow_passed[v][u] -= flow v = u return max_flow def dinic(capacity, source, sink): Returns the maximum flow from source to sink using Dinic\'s algorithm. from collections import deque def bfs_level_graph(): level = [-1]*len(capacity) queue = deque([source]) level[source] = 0 while queue: current_node = queue.popleft() for neighbor in range(len(capacity)): res_capacity = capacity[current_node][neighbor] - flow_passed[current_node][neighbor] if level[neighbor] == -1 and res_capacity > 0: level[neighbor] = level[current_node] + 1 queue.append(neighbor) return level def dfs_flow(current_node, current_flow, level): if current_node == sink: return current_flow flow_achieved = 0 for neighbor in range(len(capacity)): res_capacity = capacity[current_node][neighbor] - flow_passed[current_node][neighbor] if level[neighbor] == level[current_node] + 1 and res_capacity > 0: new_flow = min(current_flow, res_capacity) temp_flow = dfs_flow(neighbor, new_flow, level) if temp_flow > 0: flow_passed[current_node][neighbor] += temp_flow flow_passed[neighbor][current_node] -= temp_flow current_flow -= temp_flow flow_achieved += temp_flow if current_flow == 0: break return flow_achieved n = len(capacity) flow_passed = [[0]*n for _ in range(n)] max_flow = 0 while True: level = bfs_level_graph() if level[sink] == -1: break flow = dfs_flow(source, float(\'Inf\'), level) while flow: max_flow += flow flow = dfs_flow(source, float(\'Inf\'), level) return max_flow"},{"question":"# Counting Number of Digits Objective Write a function `num_of_digits` in Python that calculates the number of digits in a given integer using mathematical properties. Your implementation should achieve O(1) time complexity. Input - An integer `n` where `-10^18 <= n <= 10^18`. Output - An integer representing the number of digits in the input integer. Constraints 1. Handle both positive and negative integers. 2. For `n = 0` return 1. 3. The function should execute in constant time. Example ```python num_of_digits(12345) # Output: 5 num_of_digits(-12345) # Output: 5 num_of_digits(0) # Output: 1 ``` Instructions 1. Implement the function `num_of_digits(n)` adhering to the guidelines provided. 2. Use the `math.log10` function for calculating logarithms as needed. 3. Ensure to handle edge cases explicitly as per the problem constraints.","solution":"import math def num_of_digits(n): Returns the number of digits in the given integer n. if n == 0: return 1 # Take absolute value to handle negative numbers n = abs(n) return math.floor(math.log10(n)) + 1"},{"question":"# Question: Implement a Bogo Sort Context Bogo Sort is a very inefficient sorting algorithm that repeatedly shuffles an array until it is sorted. Though not useful for actual sorting needs, it serves as a good exercise in understanding sorting algorithms and complexity. Task Your task is to implement a function that performs Bogo Sort on a list of integers. The function should: 1. Shuffle the list randomly until it is sorted. 2. Return the sorted list. Input * A list of integers `arr` with 1 <= len(arr) <= 10. Output * The sorted list of integers. Constraints * You must use Python\'s `random.shuffle` method in your implementation. * Ensure your solution is understandable and well-commented. Example ```python def bogo_sort(arr): # Your code here # Example Usage bogo_sort([3, 2, 1]) # => [1, 2, 3] ``` # Additional Information While this implementation is for educational purposes, be aware that Bogo Sort is highly inefficient. In a real-world scenario, other sorting algorithms should be used.","solution":"import random def is_sorted(arr): Check if the given list is sorted in ascending order. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def bogo_sort(arr): Perform a Bogo Sort on the given list of integers. Shuffle the list randomly until it is sorted. Return the sorted list. while not is_sorted(arr): random.shuffle(arr) return arr"},{"question":"# Krishnamurthy Number Identification Problem Statement: You are tasked with determining whether a given integer is a Krishnamurthy number. A Krishnamurthy number is defined as a number whose sum of the factorials of its digits equals the number itself. Write a function `is_krishnamurthy(n: int) -> bool` to accomplish this task. Input: * An integer `n` where (0 leq n leq 10^6). Output: * Returns `True` if `n` is a Krishnamurthy number, otherwise `False`. Constraints: * Factorials used for digits (0-9) should be computed efficiently. * The function should handle edge cases efficiently. Scenario: You are developing a number classification tool for a mathematics software. One of the features of this tool is to identify Krishnamurthy numbers. The developers want to ensure that the implementation is both time-efficient and correct for all valid inputs. Example: ``` Input: 145 Output: True Input: 123 Output: False ``` Guidance: 1. Implement a helper function to compute the factorial of a single digit using a precomputed array. 2. Use this helper function to compute the sum of the factorials of all digits in the input number. 3. Compare the computed sum with the original number to determine if it is a Krishnamurthy number. ```python def is_krishnamurthy(n: int) -> bool: # Precompute the factorial of digits 0 - 9 factorial = [1] * 10 for i in range(1, 10): factorial[i] = factorial[i - 1] * i # Compute sum of factorials of digits original_number = n sum_of_digits = 0 while n > 0: digit = n % 10 sum_of_digits += factorial[digit] n //= 10 # Compare the sum with the original number return sum_of_digits == original_number ```","solution":"def is_krishnamurthy(n: int) -> bool: # Precompute the factorial of digits 0 - 9 factorial = [1] * 10 for i in range(1, 10): factorial[i] = factorial[i - 1] * i # Compute sum of factorials of digits original_number = n sum_of_digits = 0 while n > 0: digit = n % 10 sum_of_digits += factorial[digit] n //= 10 # Compare the sum with the original number return sum_of_digits == original_number"},{"question":"# Word Search Puzzle You have been given a 2D board of characters and a list of words. Your task is to implement a function that finds all the words from the given list that can be formed by consecutively adjacent letters on the board. Letters can be horizontally or vertically adjacent and each letter on the board can only be used once per word. Function Signature ```python def find_words(board: List[List[str]], words: List[str]) -> List[str]: pass ``` # Input: 1. `board`: A 2-D list of lowercase letters. 2. `words`: A list of words to search for in the board. # Output: - Return a list of all words found in the board. # Constraints: - The board will have at most 12 rows and 12 columns. - The words list will have at most 500 words. - Each word will have at most 10 characters. # Example: ```python # Example Input: board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] # Example Output: [\\"oath\\", \\"eat\\"] ``` # Additional Notes: 1. Words that appear more than once should be listed only once in the output. 2. The order of words in the output list does not matter. # Constraints to Consider: 1. Avoid revisiting cells. 2. Ensure efficient search by leveraging Trie and backtracking.","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_word = True def find_words(board: List[List[str]], words: List[str]) -> List[str]: def backtrack(r, c, node, path): if node.is_word: found_words.add(path) node.is_word = False # Prevent duplicates in the result if r < 0 or r >= len(board) or c < 0 or c >= len(board[0]) or (r, c) in visited: return char = board[r][c] if char not in node.children: return visited.add((r, c)) for (dr, dc) in directions: backtrack(r + dr, c + dc, node.children[char], path + char) visited.remove((r, c)) if not board or not words: return [] trie = Trie() for word in words: trie.insert(word) found_words = set() visited = set() directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for r in range(len(board)): for c in range(len(board[0])): if board[r][c] in trie.root.children: backtrack(r, c, trie.root, \'\') return list(found_words)"},{"question":"You have been tasked with designing a `filter_duplicates` function that limits the number of times an element appears in the list while preserving the original order. For instance, given a list `lst` and an integer `N`, the function should ensure no element appears more than `N` times. Function Signature ```python def filter_duplicates(lst: List[int], max_occurrences: int) -> List[int]: ``` Input * `lst`: A list of integers. ((0 leq |lst| leq 10^5)). * `max_occurrences`: An integer representing the maximum number of times any element is allowed to appear. Output Return a new list that contains elements from the original list but without any element appearing more than `max_occurrences` times. The order of elements should be preserved. Constraints * Elements of `lst` are integers. * `max_occurrences` is a non-negative integer. Example ```python assert filter_duplicates([1, 2, 3, 1, 2, 1, 2, 3], 2) == [1, 2, 3, 1, 2, 3] assert filter_duplicates([20, 37, 20, 21], 1) == [20, 37, 21] assert filter_duplicates([], 2) == [] ``` Detailed Instructions 1. Create a blank list called `result` that will hold the final filtered elements. 2. Use a dictionary to keep track of occurrences of each element. 3. Iterate through each element of the input list `lst`. 4. For each element, if the count of that element in the dictionary is less than `max_occurrences`, add the element to `result` and increment its count in the dictionary. 5. Return the final list `result`. You must ensure that your solution is optimal with a time complexity of O(n). **Note**: Implement the function `filter_duplicates` which strictly follows the aforementioned constraints and requirements.","solution":"from typing import List def filter_duplicates(lst: List[int], max_occurrences: int) -> List[int]: Returns a new list with elements from the original list, but without any element appearing more than max_occurrences times. Parameters: lst (List[int]): The original list of integers. max_occurrences (int): The maximum number of times any element is allowed to appear. Returns: List[int]: A new list that limits the number of times each element appears. if max_occurrences == 0: return [] result = [] counts = {} for elem in lst: if counts.get(elem, 0) < max_occurrences: result.append(elem) counts[elem] = counts.get(elem, 0) + 1 return result"},{"question":"# Question: Annotate Words with Symbols You are given a list of words and a list of symbols. Your task is to highlight the longest matching symbol found within each word by enclosing the symbol in square brackets. If a word contains multiple matches of different lengths, the longest match should be chosen. If multiple symbols of the same length are present, the first encountered symbol should be used. Input: - `words` (List of strings): A list of words. - `symbols` (List of strings): A list of symbols. Output: - A list of annotated words where symbols are enclosed in square brackets. Constraints: - The symbols list can contain up to 1000 unique symbols. - The words list can contain up to 1000 words, with each word having a length of up to 100 characters. - If no matching symbol is found in a word, the word should be returned unchanged. Performance Requirements: - The function should operate efficiently even with the upper constraints. Example: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] # Expected Output: # [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` # Function Signature: Implement the following function in Python: ```python def annotate_words(words: List[str], symbols: List[str]) -> List[str]: # Your code here ``` # Hints: 1. Consider preprocessing the symbol list to expedite the lookup process. 2. Efficient pattern matching is crucial; consider data structures that can help reduce redundant searches.","solution":"from typing import List def annotate_words(words: List[str], symbols: List[str]) -> List[str]: def find_longest_match(word, symbols): longest_match = \\"\\" for symbol in symbols: if symbol in word and len(symbol) > len(longest_match): longest_match = symbol elif symbol in word and len(symbol) == len(longest_match): if word.index(symbol) < word.index(longest_match): longest_match = symbol return longest_match annotated_words = [] for word in words: longest_match = find_longest_match(word, symbols) if longest_match: word = word.replace(longest_match, f\'[{longest_match}]\', 1) annotated_words.append(word) return annotated_words"},{"question":"# Minimal Bit Flips Problem You are tasked with writing a function that determines the minimal number of bits you would need to flip to convert one integer to another. In other words, given two integers, the function should compute how many bit positions are different between their binary representations. Function Signature ```python def count_flips_to_convert(a: int, b: int) -> int: ``` Input * Two integers, `a` and `b` where (0 leq a, b leq 2^{31} - 1). Output * An integer representing the number of bit positions that differ between the binary representations of `a` and `b`. Example ```python # Example 1 Input: a = 29, b = 15 Output: 2 # Explanation: Binary representation of 29 is 11101 and 15 is 01111. The differing bits are at positions 3 and 4. # Example 2 Input: a = 0, b = 0 Output: 0 # Explanation: Both numbers are the same, so no bits need to be flipped. ``` Constraints * The inputs will always be valid 32-bit non-negative integers. * Minimize the time complexity as much as possible, aiming for a solution that works in linear time with respect to the number of bits in the integer representation. Guidelines 1. Use the XOR bitwise operation to identify differing bits. 2. Implement a bit counting technique to count the number of differing bits. 3. Ensure the function handles edge cases accurately, such as when `a` and `b` are equal.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Determines the minimal number of bits needed to flip to convert integer a to integer b. Parameters: a (int): The first integer. b (int): The second integer. Returns: int: The number of bit positions that differ between a and b. # XOR between a and b will give a number where differing bits are set to 1 xor_result = a ^ b # Count number of 1s in binary representation of xor_result count = 0 while xor_result: count += xor_result & 1 xor_result >>= 1 return count"},{"question":"# Question: Flatten Nested Arrays You are given a list that may contain nested lists, and your task is to create two functions that flatten these lists into a single-level list or iterator, respectively. Function 1: `flatten_nested_list(input_array)` * **Input**: A possibly nested list of elements. Elements can be of any data type. * **Output**: A single-level list containing all the nested elements in their original order. * **Constraints**: * The function should be able to handle lists nested to any depth. * Do not use any libraries other than the standard Python library. Function 2: `flatten_nested_generator(input_array)` * **Input**: A possibly nested list of elements. * **Output**: An iterator (such as a generator) that yields each element in the flattened structure in their original order. * **Constraints**: * The function should be able to handle lists nested to any depth. * Do not use any libraries other than the standard Python library. Example ```python # Example input input_array = [1, [2, [3, 4], 5], 6, [[7, 8], 9], 10] # Expected output for flatten_nested_list print(flatten_nested_list(input_array)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # Expected output for flatten_nested_generator print(list(flatten_nested_generator(input_array))) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ``` Performance Requirements * The functions should operate efficiently with both shallow and deeply nested structures. * The recursion depth should be managed appropriately to avoid hitting Python\'s recursion limit for very deep inputs.","solution":"def flatten_nested_list(input_array): Flattens a nested list of elements into a single-level list. :param input_array: A possibly nested list of elements. :return: A single-level list containing all the nested elements in their original order. def flatten(arr): for elem in arr: if isinstance(elem, list): yield from flatten(elem) else: yield elem return list(flatten(input_array)) def flatten_nested_generator(input_array): Flattens a nested list of elements into a single-level iterator. :param input_array: A possibly nested list of elements. :return: An iterator (generator) that yields each element in the flattened structure in their original order. def flatten(arr): for elem in arr: if isinstance(elem, list): yield from flatten(elem) else: yield elem return flatten(input_array)"},{"question":"# Question: Generate All Possible Permutations with Constraints Given a list of distinct integers, write a Python function to generate all possible permutations adhering to the following constraints: 1. If a specific integer, denoted as `k`, is present in the list, it must always be at the beginning of each permutation. 2. If `k` is not present, generate permutations normally. Your function should return a list of lists, where each inner list represents a distinct permutation of the given elements. Ensure your solution is efficient in terms of both time and space complexities. Input * `elements`: A list of distinct integers. `2 <= len(elements) <= 9` * `k`: An integer which the permutations need to start with if `k` is present in `elements`. Output * A list of lists containing all possible permutations according to the constraints provided. Example ```python # Example 1 elements = [1, 2, 3] k = 1 # Output: [[1, 2, 3], [1, 3, 2]] # Example 2 elements = [4, 5, 6] k = 7 # Output: [[4, 5, 6], [4, 6, 5], [5, 4, 6], [5, 6, 4], [6, 4, 5], [6, 5, 4]] # Example 3 elements = [4, 7, 6] k = 7 # Output: [[7, 4, 6], [7, 6, 4]] ``` Implement the function `permute_with_constraints(elements: List[int], k: int) -> List[List[int]]`. Constraints 1. The function should be implemented using recursion or an iterative approach without relying on external libraries. 2. You may assume that the elements are always distinct.","solution":"from typing import List def permute_with_constraints(elements: List[int], k: int) -> List[List[int]]: def backtrack(path, remaining): if not remaining: permutations.append(path) return for i in range(len(remaining)): backtrack(path + [remaining[i]], remaining[:i] + remaining[i+1:]) if k in elements: elements.remove(k) permutations = [] backtrack([k], elements) else: permutations = [] backtrack([], elements) return permutations"},{"question":"# Question: Implement a Binary Tree Postorder Traversal Algorithm Given a binary tree, implement a function that returns the postorder traversal of its nodes\' values using both iterative and recursive approaches. Implement the following two functions: 1. `postorder_iterative(root: Node) -> List[int]`: This should return the postorder traversal as a list of integers using an iterative approach. 2. `postorder_recursive(root: Node) -> List[int]`: This should return the postorder traversal as a list of integers using a recursive approach. # Input Format: * The input will be a binary tree represented by its `root` node. # Output Format: * Both functions should return a list of integers, representing the node values in postorder traversal order. # Constraints: 1. The number of nodes in the tree is in the range [0, 10^4]. 2. The values of the nodes are unique integers in the range [-10^4, 10^4]. # Example: Consider the binary tree given below: ``` 1 / 2 3 / 4 5 ``` **Input**: ```python root = Node(1, Node(2, Node(4), Node(5)), Node(3)) ``` **Output**: ```python postorder_iterative(root) -> [4, 5, 2, 3, 1] postorder_recursive(root) -> [4, 5, 2, 3, 1] ``` # Notes: - Ensure to handle edge cases like an empty tree. - Validate through multiple test cases with varying tree depths, including very deep or balanced trees.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def postorder_recursive(root): Returns the postorder traversal of the binary tree using recursion. result = [] def helper(node): if not node: return helper(node.left) helper(node.right) result.append(node.value) helper(root) return result def postorder_iterative(root): Returns the postorder traversal of the binary tree using iteration. if not root: return [] result, stack = [], [root] while stack: node = stack.pop() result.append(node.value) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return result[::-1]"},{"question":"Context: You are part of a navigation software team that needs to find if a path exists between any two given points on a city map modeled as a directed graph. Your task is to determine whether there is a path between two specific points using Depth-First Search (DFS). Objective: Implement a function that, given a list of directed edges and a pair of nodes, determines if there is any path from the first node to the second one. Requirements: 1. Implement the necessary graph structure with DFS traversal. 2. Ensure your solution handles typical edge cases: cycles, disconnected components, and self-loops. 3. Avoid excessive memory usage in deep recursion scenarios. Function Signature: ```python def is_reachable(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: pass ``` Parameters: - `vertex_count` (int): The number of vertices in the graph. - `edges` (List[Tuple[int, int]]): A list of tuples where each tuple represents a directed edge (source, target). - `source` (int): The starting node. - `target` (int): The target node. Returns: - `bool`: True if there is a path from the source node to the target node, otherwise False. Constraints: - `0 <= source, target < vertex_count` - `vertex_count >= 1` - The graph may have at most `vertex_count * (vertex_count - 1)` directed edges. Example: ```python assert is_reachable(5, [(0, 1), (0, 2), (1, 2), (2, 0), (2, 3), (3, 3)], 1, 3) == True assert is_reachable(5, [(0, 1), (0, 2), (1, 2), (2, 0), (2, 3), (3, 3)], 3, 1) == False assert is_reachable(3, [(0, 1), (1, 2)], 0, 2) == True assert is_reachable(3, [(0, 1), (1, 2)], 2, 0) == False ``` Implement the function ensuring it adheres to the constraints and effectively determines the path existence between given nodes using DFS.","solution":"def is_reachable(vertex_count: int, edges: list, source: int, target: int) -> bool: from collections import defaultdict # Build the adjacency list for the graph graph = defaultdict(list) for src, dst in edges: graph[src].append(dst) # Helper function for DFS traversal def dfs(v, visited): if v == target: return True visited.add(v) for neighbor in graph[v]: if neighbor not in visited: if dfs(neighbor, visited): return True return False # Start DFS from the source node return dfs(source, set())"},{"question":"Scenario: You are tasked with improving the task scheduler for an operating system. The current system uses a priority queue implemented with a linear array, which performs well for retrieval but can become slow with frequent insertions. To better manage the tasks, you\'ve been asked to upgrade the priority queue to use a binary heap, improving the insertion time complexity. Task: Implement a `BinaryHeapPriorityQueue` class that uses a binary heap instead of a linear array for the priority queue. The class should support the following operations: 1. **`push(item, priority=None)`** - Insert an item with the given priority. If the priority is not provided, default to the item\'s value. 2. **`pop()`** - Remove and return the item with the lowest priority. Requirements: - You must use a binary heap to maintain the heap property and ensure efficient insertion. - The `push` method should have a time complexity of O(log n). - The `pop` method should also have a time complexity of O(log n). **Function Signatures:** ```python class BinaryHeapPriorityQueue: def __init__(self): Initialize an empty priority queue using a binary heap. pass def push(self, item, priority=None): Insert an item into the priority queue with the given priority. If priority is not provided, use the item\'s value as its priority. :param item: item to be added to the priority queue. :param priority: priority of the item. pass def pop(self): Remove and return the item with the lowest priority from the priority queue. :return: item with the lowest priority. pass def size(self): Return the number of items in the priority queue. :return: size of the priority queue. pass ``` Constraints: - The priority queue should always maintain the heap property. - If `pop` is called on an empty queue, return `None`. - Handle both integers and strings as item values with appropriate priorities. Example Usage: ```python pq = BinaryHeapPriorityQueue() pq.push(10) pq.push(5, priority=1) pq.push(7) print(pq.pop()) # Outputs: 5 (since it has the highest priority 1) print(pq.pop()) # Outputs: 7 (next smallest item) print(pq.size()) # Outputs: 1 ``` Build and test your implementation to ensure it fulfills the above requirements.","solution":"import heapq class BinaryHeapPriorityQueue: def __init__(self): Initialize an empty priority queue using a binary heap. self.heap = [] def push(self, item, priority=None): Insert an item into the priority queue with the given priority. If priority is not provided, use the item\'s value as its priority. :param item: item to be added to the priority queue. :param priority: priority of the item. if priority is None: priority = item heapq.heappush(self.heap, (priority, item)) def pop(self): Remove and return the item with the lowest priority from the priority queue. :return: item with the lowest priority. if self.heap: return heapq.heappop(self.heap)[1] return None def size(self): Return the number of items in the priority queue. :return: size of the priority queue. return len(self.heap)"},{"question":"Context You have been tasked with developing a feature for a text editor that provides real-time suggestions as users type. To achieve this, you will implement a Trie (prefix tree) data structure. Your Trie should be capable of inserting words, searching for exact matches, and suggesting words based on prefixes. Requirements Implement the following methods in the Trie class: * `insert(word: str) -> None`: Adds the word to the Trie. * `search(word: str) -> bool`: Returns True if the word is in the Trie, otherwise returns False. * `starts_with(prefix: str) -> bool`: Returns True if there is any word in the Trie that starts with the given prefix, otherwise returns False. Constraints * All words consist of lowercase English letters (a-z). * The input words and prefixes are non-empty. Input and Output * The input and output specifications for each method are: * `insert(word: str) -> None`: No return value. * `search(word: str) -> bool`: Returns a boolean indicating if the word exists. * `starts_with(prefix: str) -> bool`: Returns a boolean indicating if any word starts with the given prefix. Performance Requirements * Your implementation should handle multiple insertions and searches efficiently. Example ```python # Initialize the trie trie = Trie() # Insert words trie.insert(\\"apple\\") trie.insert(\\"app\\") # Search for words print(trie.search(\\"apple\\")) # Output: True print(trie.search(\\"app\\")) # Output: True print(trie.search(\\"apc\\")) # Output: False # Search for prefixes print(trie.starts_with(\\"app\\")) # Output: True print(trie.starts_with(\\"apl\\")) # Output: False ``` Edge Cases to Consider * Inserting and searching for the same word multiple times. * Searching or starting with a non-existent prefix. * Empty prefix or word handling. Write only the methods for the Trie class. You may assume that all other parts, such as the TrieNode class, are provided.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): Initialize the Trie with an empty root node. self.root = TrieNode() def insert(self, word: str) -> None: Insert a word into the Trie. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: Search for a word in the Trie and return True if it exists. node = self._search_prefix(word) return node is not None and node.is_end_of_word def starts_with(self, prefix: str) -> bool: Check if any word in the Trie starts with the given prefix. return self._search_prefix(prefix) is not None def _search_prefix(self, prefix: str): Helper function to search for a prefix in the Trie. node = self.root for char in prefix: if char in node.children: node = node.children[char] else: return None return node"},{"question":"# Question You are given the task of implementing a function to check if a singly linked list is sorted in strictly increasing order (each element must be greater than the preceding one). Unlike the `is_sorted` function provided, which checks for non-decreasing order, your function must ensure that no two consecutive elements are equal. Implementation Write a function `is_strictly_increasing(head)` that takes the `head` of a singly linked list and returns `True` if the list is sorted in strictly increasing order, otherwise returns `False`. Function Signature ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def is_strictly_increasing(head: ListNode) -> bool: ``` Inputs * `head` - The head of the singly linked list, which is an instance of `ListNode`. Each node in the list has a `value` and a `next` pointer. Outputs * `Boolean` value - `True` if the list is sorted in strictly increasing order; otherwise `False`. Constraints and Notes * The list can have zero or more elements. * Each node contains an integer value. * Any list with less than two nodes is considered sorted in a strictly increasing order. Examples ```python # List: None assert is_strictly_increasing(None) == True # List: 1 -> 2 -> 3 -> 4 head1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) assert is_strictly_increasing(head1) == True # List: 1 -> 2 -> 2 -> 3 head2 = ListNode(1, ListNode(2, ListNode(2, ListNode(3)))) assert is_strictly_increasing(head2) == False # List: 1 -> 3 -> 2 -> 4 head3 = ListNode(1, ListNode(3, ListNode(2, ListNode(4)))) assert is_strictly_increasing(head3) == False ```","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def is_strictly_increasing(head: ListNode) -> bool: Checks if a singly linked list is sorted in strictly increasing order. if not head or not head.next: return True current = head while current.next: if current.value >= current.next.value: return False current = current.next return True"},{"question":"# RSA Encryption and Decryption Objective Write a Python function that will generate RSA keys, encrypt and decrypt a message. Implement the following requirements: 1. **Key Generation**: - Implement the RSA key generation algorithm to produce a pair of RSA keys (public and private). - Ensure the keys are of the specified bit length. 2. **Encryption**: - Implement a function to encrypt a given plaintext message using the public key. 3. **Decryption**: - Implement a function to decrypt the encrypted message using the private key. Function Prototypes ```python def generate_key(k: int) -> tuple: Generate RSA keys. Args: - k (int): Bit length of the modulus n. Returns: - tuple: A tuple containing (n, e, d) where (n, e) is the public key and (n, d) is the private key. pass def encrypt(message: int, public_key: tuple) -> int: Encrypt a message using the RSA public key. Args: - message (int): The message to be encrypted. - public_key (tuple): The RSA public key as (n, e). Returns: - int: Encrypted message. pass def decrypt(encrypted_message: int, private_key: tuple) -> int: Decrypt a message using the RSA private key. Args: - encrypted_message (int): The encrypted message to be decrypted. - private_key (tuple): The RSA private key as (n, d). Returns: - int: Decrypted message. pass ``` Constraints - `k` (bit length of n) will be between 16 and 1024 bits. - Ensure appropriate error handling for non-integer inputs. - Performance: Max allowed time for key generation is 5 seconds for all inputs. Example Usage ```python n, e, d = generate_key(32) message = 42 encrypted_message = encrypt(message, (n, e)) decrypted_message = decrypt(encrypted_message, (n, d)) assert decrypted_message == message ``` Notes - Use `pow` function for modular exponentiation `(a**b) % c`. - Edge cases to handle: Ensure `p` and `q` are distinct primes and `e` is coprime with `(p-1)(q-1)`.","solution":"import random from sympy import isprime, mod_inverse def generate_key(k: int) -> tuple: Generate RSA keys. Args: - k (int): Bit length of the modulus n. Returns: - tuple: A tuple containing (n, e, d) where (n, e) is the public key and (n, d) is the private key. def generate_prime(bits): while True: p = random.getrandbits(bits) if isprime(p): return p half_k = k // 2 p = generate_prime(half_k) q = generate_prime(half_k) while p == q: q = generate_prime(half_k) n = p * q phi = (p - 1) * (q - 1) e = 65537 # Commonly used prime exponent d = mod_inverse(e, phi) return (n, e, d) def encrypt(message: int, public_key: tuple) -> int: Encrypt a message using the RSA public key. Args: - message (int): The message to be encrypted. - public_key (tuple): The RSA public key as (n, e). Returns: - int: Encrypted message. n, e = public_key return pow(message, e, n) def decrypt(encrypted_message: int, private_key: tuple) -> int: Decrypt a message using the RSA private key. Args: - encrypted_message (int): The encrypted message to be decrypted. - private_key (tuple): The RSA private key as (n, d). Returns: - int: Decrypted message. n, d = private_key return pow(encrypted_message, d, n)"},{"question":"# Transitive Closure Matrix You are given a directed graph with `V` vertices numbered from 0 to V-1. The graph is represented using an adjacency matrix, where `graph[i][j]` is 1 if there is a direct edge from vertex `i` to vertex `j`, and 0 otherwise. You need to find the transitive closure of the graph using Depth First Search (DFS). Function Signature ```python def transitive_closure(V: int, graph: List[List[int]]) -> List[List[int]]: pass ``` Input - **V**: an integer `V` (2 <= V <= 100), the number of vertices in the graph. - **graph**: a list of lists (V x V matrix) containing integers (0 or 1) representing the adjacency matrix. Output - Return a list of lists (V x V matrix) containing integers (0 or 1) representing the transitive closure matrix of the graph. Example ```python V = 4 graph = [ [1, 1, 0, 0], [0, 1, 1, 0], [0, 0, 1, 1], [0, 0, 0, 1] ] transitive_closure(V, graph) ``` Expected output: ```python [ [1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1] ] ``` Constraints - Use depth-first search for the solution. - The time complexity should be reasonable to work within the input constraints. **Scenario**: Imagine this graph is a representation of a communication network between servers. The transitive closure will help determine if a message sent from one server can reach another, either directly or indirectly through intermediate servers.","solution":"from typing import List def dfs(graph: List[List[int]], reach: List[List[int]], v: int, source: int): Helper function to perform DFS from source vertex. for i in range(len(graph)): if graph[source][i] and not reach[v][i]: reach[v][i] = 1 dfs(graph, reach, v, i) def transitive_closure(V: int, graph: List[List[int]]) -> List[List[int]]: reach = [[0] * V for _ in range(V)] for v in range(V): reach[v][v] = 1 dfs(graph, reach, v, v) return reach"},{"question":"# Gnome Sort Optimization Problem Statement You are given an array of integers that needs to be sorted. Using the Gnome Sort algorithm described in the analysis, implement an optimized version that ensures the whole array is sorted as efficiently as possible. Function Signature ```python def optimized_gnome_sort(arr: List[int]) -> List[int]: # Your code goes here ``` Input * `arr` (list of ints): A list `arr` containing the integers to be sorted. The length of the list is between 1 and 10^4. Output * Returns a list of integers sorted in non-decreasing order. Constraints * Your implementation must handle arrays with up to 10,000 integers efficiently. * Focus on minimizing the number of swaps and comparisons to improve the runtime from a naive implementation. Example ```python Example 1: Input: [34, 2, 10, -9] Output: [-9, 2, 10, 34] Example 2: Input: [1, 2, 3, 4, 5] Output: [1, 2, 3, 4, 5] Example 3: Input: [5, 4, 3, 2, 1] Output: [1, 2, 3, 4, 5] ``` Special Considerations Consider the appropriate handling of very large arrays and scenarios where the array may already be partially or fully sorted. Ensure to take advantage of any inherent order within the array to reduce the number of operations where possible.","solution":"def optimized_gnome_sort(arr): Optimized Gnome Sort implementation that attempts to minimize the number of swaps and comparisons. n = len(arr) index = 0 while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Ordered Stack Problem Scenario You are working on a system that requires maintaining an ordered sequence of elements while adhering to stack (Last In, First Out) principles. This means that while elements should always be retrieved in reverse order of their insertion, they should also be sorted by their values within the stack. Task Implement the `OrderedStack` class as described, ensuring the elements are always in sorted order when pushed. Focus on writing correct and efficient methods for `push`, `pop`, `peek`, and ensure to handle edge cases properly. Functions to Implement 1. `OrderedStack.push(item)`: Inserts `item` into the stack while maintaining order. 2. `OrderedStack.pop()`: Removes and returns the top element of the stack. 3. `OrderedStack.peek()`: Returns the top element of the stack without removing it. 4. `OrderedStack.is_empty()`: Checks whether the stack is empty. 5. `OrderedStack.size()`: Returns the number of elements in the stack. Constraints - You may assume all elements are integers. - You should handle the case where `pop` or `peek` is called on an empty stack by raising an appropriate error. - The maximum number of elements pushed can be up to 10,000. Input/Output Examples 1. **Input**: ```python stack = OrderedStack() stack.push(5) stack.push(3) stack.push(7) stack.push(2) print(stack.pop()) # Output: 7 print(stack.peek()) # Output: 5 print(stack.size()) # Output: 3 ``` 2. **Output**: ``` 7 5 3 ``` These examples illustrate the sequence of operations and expected outputs to help you verify your implementation.","solution":"class OrderedStack: def __init__(self): Initialize an empty OrderedStack. self.stack = [] def push(self, item): Inserts item into the stack while maintaining order. self.stack.append(item) self.stack.sort() def pop(self): Removes and returns the top element of the stack. if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def peek(self): Returns the top element of the stack without removing it. if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def is_empty(self): Checks whether the stack is empty. return len(self.stack) == 0 def size(self): Returns the number of elements in the stack. return len(self.stack)"},{"question":"Given an undirected graph represented as a dictionary where keys are vertices and values are sets of adjacent vertices, write a function `find_large_cliques` to find all cliques of size at least `k` within the graph. A clique is a subset of vertices such that for any two vertices in the clique, there exists an edge connecting them directly. # Function Signature ```python def find_large_cliques(edges: Dict[str, Set[str]], k: int) -> List[List[str]]: pass ``` # Input * `edges`: A dictionary where each key is a vertex (string) and each value is a set of vertices (strings) directly connected to the key vertex by an edge. * `k`: An integer, the minimum number of vertices in the cliques to be identified. # Output * A list of lists, where each sublist represents a clique of size at least `k` found in the graph. # Constraints * The vertices are represented as alphanumeric strings. * The number of vertices `n` will be in the range [1, 20]. * The value of `k` will be in the range [1, n]. * The function should be able to handle graphs with up to 380 edges (n*(n-1)/2 for n=20). # Performance Requirements * The solution should efficiently handle sparse graphs, potentially leveraging optimization techniques discussed. # Example ```python edges = { \\"A\\": {\\"B\\", \\"C\\"}, \\"B\\": {\\"A\\", \\"C\\", \\"D\\"}, \\"C\\": {\\"A\\", \\"B\\", \\"D\\"}, \\"D\\": {\\"B\\", \\"C\\"} } k = 3 print(find_large_cliques(edges, k)) # Output: [[\'A\', \'B\', \'C\'], [\'B\', \'C\', \'D\']] ``` # Additional Notes - In the provided example, vertices \\"A\\", \\"B\\", and \\"C\\" form a clique since they are all connected to each other. Similarly, \\"B\\", \\"C\\", and \\"D\\" form another clique. - Ensure that the returned cliques contain unique sets of vertices. # Edge Cases * Handling graphs with no edges. * Handling cases where no cliques meet the size requirement. * Handling the presence of isolated vertices.","solution":"from typing import List, Dict, Set def find_large_cliques(edges: Dict[str, Set[str]], k: int) -> List[List[str]]: def is_clique(candidate): Check if the given candidate list of vertices forms a clique. for i in range(len(candidate)): for j in range(i + 1, len(candidate)): if candidate[j] not in edges[candidate[i]]: return False return True def find_cliques(current_clique, nodes): Backtrack to find cliques starting from the current clique. cliques = [] for i, v in enumerate(nodes): new_clique = current_clique + [v] if len(new_clique) >= k and is_clique(new_clique): cliques.append(new_clique) cliques.extend(find_cliques(new_clique, nodes[i+1:])) return cliques vertices = list(edges.keys()) large_cliques = find_cliques([], vertices) # Remove duplicates by converting to set of frozensets and back to list unique_cliques = [list(clique) for clique in set(frozenset(clique) for clique in large_cliques)] return unique_cliques"},{"question":"<|Analysis Begin|> # Core Identification * **Algorithm/Data Structure**: The algorithm involves *integer base conversion*, specifically for converting an integer to a different base (from base 10 to any base) and from any base to an integer (base to base 10). * **Complexity**: - **int_to_base**: Time complexity is O(log_b(N)), where N is the integer and b is the base. Space complexity is O(log_b(N)) due to the string representation of the resulting base. - **base_to_int**: Time complexity is O(K) where K is the length of the digit string. Space complexity is O(1). * **Principles**: - **int_to_base**: Uses repeated division by the base, collecting the remainders (digits in the new base) until the integer becomes zero. - **base_to_int**: Processes each digit of the input string from the least significant to the most significant, converting and summing their respective values, weighted by increasing powers of the base. # Characteristics & Applications * **Properties**: - Accurate conversion between numeral systems (e.g., binary, octal, hexadecimal). - Handles both positive and negative integers in `int_to_base`. * **Common Use Cases**: - Encoding integers (e.g., in URLs or short URLs). - Computer science applications (storage and transmission in different numeral systems). - Cryptographic applications, context-sensitive encoding. * **Strengths/Limitations**: - Strength: Efficient conversion for positive and negative integers. - Limitation: Maximum base handled is 36 due to reliance on alphanumeric characters. - Suitable for relatively small bases and integers that fit within typical data type limits. # Implementation Challenges * **Edge Cases**: - Handling zero correctly in `int_to_base`. - Correctly reversing the digit string in negative number scenarios. - Managing invalid characters in `base_to_int`. * **Performance Bottlenecks**: - Large integers may cause performance degradation due to the number of operations. - Repeated string concatenation can be slow; consider using lists and joining. * **Error Scenarios**: - Non-integer input, negative bases, bases greater than 36 can lead to erroneous outcomes. * **Optimization Points**: - Avoiding string concatenation with lists for `int_to_base`. - Ensuring proper validation for input characters. <|Analysis End|> <|Question Begin|> # Base Conversion Challenge You are tasked with implementing a function that efficiently converts an integer from one base to another, inclusive of both positive and negative integers. **Function Definition:** ```python def convert_base(num: int, base: int) -> str: Convert the given integer \'num\' to its string representation in the specified \'base\'. :param num: an integer to convert (can be negative or positive) :param base: an integer, the base to convert to (2 <= base <= 36) :return: the string representation of the integer in the specified base pass ``` **Input:** - An integer `num`, which can be zero, positive, or negative. - An integer `base`, where 2 <= base <= 36. **Output:** - A string that represents the integer `num` in the given `base`. **Constraints:** - You must handle negative integers correctly. - Assume that inputs are always valid for this function’s constraints. - The solution should be efficient in terms of both time and space complexity. **Performance Requirements:** - The function should run in O(log_b|num|) time complexity and O(log_b|num|) space complexity. **Example:** ```python assert convert_base(5, 2) == \'101\' assert convert_base(-5, 2) == \'-101\' assert convert_base(15, 16) == \'F\' assert convert_base(-255, 16) == \'-FF\' assert convert_base(0, 8) == \'0\' ``` # Requirements: 1. Convert a positive or negative integer to a specific base in a string format. 2. Efficiently handle the conversion in the respective complexities. 3. Ensure the correctness through proper test cases and edge considerations such as zero, negative numbers, and maximum base. Implement this function to demonstrate comprehension of numeral systems and base conversions. Pay close attention to the performance and edge cases.","solution":"def convert_base(num: int, base: int) -> str: Convert the given integer \'num\' to its string representation in the specified \'base\'. :param num: an integer to convert (can be negative or positive) :param base: an integer, the base to convert to (2 <= base <= 36) :return: the string representation of the integer in the specified base if num == 0: return \'0\' digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" sign = \'-\' if num < 0 else \'\' num = abs(num) result = [] while num: result.append(digits[num % base]) num //= base if sign: result.append(sign) return \'\'.join(reversed(result))"},{"question":"Coding Assessment Question # Context You are given a board of characters representing a 2D grid and a list of words. Your task is to find all words from the list that exist in the grid. A word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. # Task Implement a function `find_words(board, words)` that returns a list of all words found in the 2D grid. # Input - `board` (List[List[str]]): A 2D list of characters, representing the board. - `words` (List[str]): A list of words to search in the board. # Output - Returns a list of found words. # Examples ```python board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"] print(find_words(board, words)) # Output: [\\"oath\\", \\"eat\\"] ``` # Constraints - The number of rows and columns in the board are between 1 and 12. - The number of words and the length of each word is between 1 and 10. - All words and board characters are lowercase English letters. # Performance Requirements - The solution should efficiently handle backtracking with Trie to avoid redundant prefix searches, keeping performance within reasonable limits for the given constraints. # Implementation Requirements - Use a Trie to optimize prefix matching. - Implement backtracking to explore and confirm each word in the grid. - Ensure each cell is used at most once per word.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def find_words(board, words): def backtrack(r, c, node, path, res): if node.is_end_of_word: res.add(path) node.is_end_of_word = False # to avoid duplicate entries if r < 0 or r >= len(board) or c < 0 or c >= len(board[0]): return char = board[r][c] if char not in node.children: return board[r][c] = \\"#\\" # mark as visited node = node.children[char] for row_offset, col_offset in [(0, 1), (1, 0), (0, -1), (-1, 0)]: backtrack(r + row_offset, c + col_offset, node, path + char, res) board[r][c] = char # unmark as visited trie = Trie() for word in words: trie.insert(word) result = set() for row in range(len(board)): for col in range(len(board[0])): if board[row][col] in trie.root.children: backtrack(row, col, trie.root, \\"\\", result) return list(result)"},{"question":"# Problem: Implement Zigzag Level Order Traversal for a Binary Tree Given a binary tree, write a function to return the zigzag level order traversal of its nodes\' values. (i.e., from left to right, then right to left for the next level and alternate between). # Function Signature ```python def zigzag_level_order(root: Node) -> List[List[int]]: ``` # Input - `root`: Root node of the binary tree as a `Node` object. - `Node` is defined as: ```python class Node: def __init__(self, val: int, left: Optional[Node] = None, right: Optional[Node] = None): self.val = val self.left = left self.right = right ``` # Output - Returns a list of lists of integers representing the zigzag level order traversal of the given binary tree. # Constraints - The number of nodes in the tree will be in the range [0, 1000]. - `Node.val` is an integer. # Example ```python # Constructing a binary tree: # 3 # / # 9 20 # / # 15 7 n1 = Node(3) n2 = Node(9) n3 = Node(20) n4 = Node(15) n5 = Node(7) n1.left, n1.right = n2, n3 n3.left, n3.right = n4, n5 # Calling the function: print(zigzag_level_order(n1)) # Output: [[3], [20, 9], [15, 7]] ``` # Points to Consider - Ensure proper handling of the alternating zigzag pattern. - Consider edge cases like an empty tree or a tree with only one node. Good luck!","solution":"from typing import List, Optional class Node: def __init__(self, val: int, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.val = val self.left = left self.right = right def zigzag_level_order(root: Optional[Node]) -> List[List[int]]: if not root: return [] result = [] current_level = [root] left_to_right = True while current_level: level_values = [node.val for node in current_level] if not left_to_right: level_values.reverse() result.append(level_values) next_level = [] for node in current_level: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) current_level = next_level left_to_right = not left_to_right return result"},{"question":"# Problem: Optimized Shortest Path with Edge Weights You are given a directed, weighted graph represented as an adjacency list. Each key in the dictionary represents a node, and the values are dictionaries where the keys are the neighboring nodes and the values are the edge weights. Your task is to implement a function to find the shortest path from a start node to an end node using Dijkstra\'s algorithm. Function Signature ```python def dijkstra_shortest_path(graph: Dict[str, Dict[str, int]], start: str, end: str) -> List[str]: Calculate the shortest path between the start node and end node in the graph. pass ``` Input - `graph`: A dictionary representing the graph. Each key is a node, and the associated value is a dictionary of neighboring nodes and their respective edge weights. - `start`: A string representing the starting node. - `end`: A string representing the destination node. Output - A list of nodes representing the shortest path from `start` to `end`. Constraints 1. Assume all edge weights are positive integers. 2. If no path exists, return an empty list. 3. Optimize for both time and space complexity. Example ```python graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'C\': 2, \'D\': 5}, \'C\': {\'D\': 1}, \'D\': {} } start, end = \'A\', \'D\' print(dijkstra_shortest_path(graph, start, end)) # Output: [\'A\', \'B\', \'C\', \'D\'] ``` Hint: Use a priority queue (min-heap) to efficiently get the node with the smallest distance that has not been processed yet.","solution":"import heapq from typing import Dict, List, Tuple def dijkstra_shortest_path(graph: Dict[str, Dict[str, int]], start: str, end: str) -> List[str]: Calculate the shortest path between the start node and end node in the graph using Dijkstra\'s algorithm. # Priority queue (min-heap) to store (distance, node) pq = [(0, start)] # Dictionary to store the shortest distance to each node distances = {node: float(\'inf\') for node in graph} distances[start] = 0 # Dictionary to store the previous node to reconstruct the path prev_nodes = {node: None for node in graph} while pq: current_distance, current_node = heapq.heappop(pq) # If we reached the end node, reconstruct the path if current_node == end: path = [] while current_node: path.append(current_node) current_node = prev_nodes[current_node] return path[::-1] # If distance is greater than the currently known distance, skip processing if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node].items(): distance = current_distance + weight # Only consider this new path if it is better if distance < distances[neighbor]: distances[neighbor] = distance prev_nodes[neighbor] = current_node heapq.heappush(pq, (distance, neighbor)) # If we exit the loop without returning, there\'s no path return []"},{"question":"# Problem: Swap Successive Pairs in a Stack You\'re working on an algorithm that processes batches of tasks represented as a stack. You need to transform the stack such that every successive pair of numbers is switched. If there is an odd number of elements, the top-most element should remain in its place after swapping the other pairs. Given the following transformations: * Example 1: `bottom [3, 8, 17, 9, 1, 10] top` should become `bottom [8, 3, 9, 17, 10, 1] top` * Example 2: `bottom [3, 8, 17, 9, 1] top` should become `bottom [8, 3, 9, 17, 1] top` Implement a function `switch_pairs` that performs the above transformation using efficient storage and without using additional complex data structures. **Function Signature:** ```python def switch_pairs(stack: list[int]) -> list[int]: ``` **Input**: * `stack`: A list of integers representing a stack, where the last element of the list is considered the top of the stack. **Output**: * A list of integers where successive pairs of elements from the input stack are swapped. **Constraints**: * The stack can have at most 10^4 elements. * Each element in the stack is an integer in the range [-10^9, 10^9]. **Examples**: ```python assert switch_pairs([3, 8, 17, 9, 1, 10]) == [8, 3, 9, 17, 10, 1] assert switch_pairs([3, 8, 17, 9, 1]) == [8, 3, 9, 17, 1] assert switch_pairs([]) == [] assert switch_pairs([5]) == [5] ``` # Requirements: 1. Your solution should cover edge cases such as an empty stack, a single element stack, and stacks with an odd number of elements. 2. Try to make your implementation as efficient in terms of both time and space complexity. 3. Avoid using additional native complex data structures like dictionaries apart from what is required (stack/queue). # Guidelines: 1. Write your code in a function called `switch_pairs`. 2. Ensure all edge cases are handled correctly. 3. Only use Python\'s native data structures and do not import any additional libraries.","solution":"def switch_pairs(stack): Switch successive pairs in a stack. :param stack: List of integers representing the stack (last element is the top of the stack). :return: A new list with successive pairs of elements swapped. # Make a copy of the stack to keep original intact swapped_stack = stack[:] # Iterate over the stack in steps of 2 to switch pairs for i in range(0, len(swapped_stack) - 1, 2): swapped_stack[i], swapped_stack[i + 1] = swapped_stack[i + 1], swapped_stack[i] return swapped_stack"},{"question":"- Height of a Binary Search Tree Problem Statement: Given the `Node` and `BST` classes defined below, implement a method `height` that calculates the height of a Binary Search Tree (BST). The height of the tree is defined as the longest path from the root node down to the furthest leaf node. The height of a single node tree is 0, and the height of an empty tree should be -1. ```python class Node(object): def __init__(self, data): self.data = data self.left = None self.right = None class BST(object): def __init__(self): self.root = None def insert(self, data): if self.root: return self._insert(self.root, data) else: self.root = Node(data) return True def _insert(self, root, data): if root.data == data: return False elif data < root.data: if root.left: return self._insert(root.left, data) else: root.left = Node(data) return True else: if root.right: return self._insert(root.right, data) else: root.right = Node(data) return True ``` Input Format: You will be given multiple operations to execute on the tree. Each operation will be either an insertion (`insert`), followed by the data to insert or a `height` query to compute the height of the tree. Output Format: For each `height` query, return the height of the tree. Constraints: * Values for insertion will be unique positive integers. * Maximum number of insertions: 1000 Example: ```plaintext insert 10 insert 15 insert 6 insert 4 insert 9 insert 12 insert 24 height ``` Expected Output: ```plaintext 3 ``` Implementation: Implement the `height` method in the `BST` class: ```python class BST(object): ... def height(self): # Your implementation here ``` Additional Notes: * Ensure the `height` function handles edge cases such as an empty tree and a single node tree. * Consider the scalability and test the function with complex and deep trees.","solution":"class Node(object): def __init__(self, data): self.data = data self.left = None self.right = None class BST(object): def __init__(self): self.root = None def insert(self, data): if self.root: return self._insert(self.root, data) else: self.root = Node(data) return True def _insert(self, root, data): if root.data == data: return False elif data < root.data: if root.left: return self._insert(root.left, data) else: root.left = Node(data) return True else: if root.right: return self._insert(root.right, data) else: root.right = Node(data) return True def height(self): return self._height(self.root) def _height(self, node): if node is None: return -1 left_height = self._height(node.left) right_height = self._height(node.right) return max(left_height, right_height) + 1"},{"question":"# Objective Implement a function named `cocktail_shaker_sort` that sorts a given list of integers in ascending order using the Cocktail Shaker Sort algorithm. # Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` # Input * `arr`: A list of integers, `arr` (1 <= len(arr) <= 10^4), where each element is an integer (-10^6 <= arr[i] <= 10^6). # Output * Returns a new list of integers that is the sorted version of `arr`. # Constraints * The function should operate within a quadratic time complexity of O(N^2). * You may not use Python\'s built-in sort function. # Scenario Fiona is a computer science student who recently encountered the Cocktail Shaker Sort algorithm. She decides to implement this sorting technique to arrange her list of project scores in ascending order. Help Fiona by implementing the `cocktail_shaker_sort` function. # Example ```python assert cocktail_shaker_sort([6, 3, 8, 5, 2]) == [2, 3, 5, 6, 8] assert cocktail_shaker_sort([-1, -3, 0, 2, -2]) == [-3, -2, -1, 0, 2] assert cocktail_shaker_sort([10, 7, 10, 5]) == [5, 7, 10, 10] assert cocktail_shaker_sort([]) == [] assert cocktail_shaker_sort([5]) == [5] ``` # Explanation 1. **Example 1**: The list `[6, 3, 8, 5, 2]` is sorted first from left-to-right resulting in `[3, 6, 5, 2, 8]`, then from right-to-left sorting gives `[2, 3, 5, 6, 8]`. 2. **Example 2**: Lists with negative numbers and zero are supported. 3. **Example 3**: Lists with duplicate elements should retain the same relative order of equivalently valued elements.","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts a list of integers in ascending order using the Cocktail Shaker Sort algorithm. n = len(arr) if n < 2: return arr # No need to sort if the list has less than 2 elements start = 0 end = n - 1 while start <= end: swapped = False # traverse the list from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break # otherwise, reset the swapped flag so that it can be used in the next stage swapped = False end -= 1 # traverse the list from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True start += 1 return arr"},{"question":"# Hash Table Enhancement: Frequency Counter You are required to enhance the provided `ResizableHashTable` class by implementing a frequency counter. This counter will keep track of the number of times a specific key has been added or updated with a new value. Your task is to extend the existing classes and add methods to get and reset the frequency of a given key. Objective - Implement a method `frequency_of(key)` which returns the number of times the key has been added or updated. - Implement a method `reset_frequency(key)` which resets the frequency counter for the specified key. - Ensure that these functions maintain the time complexity primarily within O(1). Input - When invoking `put(key, value)`, it should internally update the frequency count for that key. - `frequency_of(key)` should take a single integer key and return an integer representing its frequency. - `reset_frequency(key)` should take a single integer key and reset its frequency count. Output - `frequency_of(key)` returns the frequency of the specified key, or `None` if the key does not exist. - `reset_frequency(key)` should return `True` if the key exists and was reset, otherwise `False`. # Constraints - The keys and values are non-negative integers. - The table dynamically resizes when it reaches two-thirds of its capacity. # Example ```python ht = ResizableHashTable() ht.put(5, \'value1\') ht.put(5, \'value2\') print(ht.frequency_of(5)) # Output: 2 ht.put(6, \'value1\') ht.reset_frequency(5) print(ht.frequency_of(5)) # Output: 0 print(ht.frequency_of(6)) # Output: 1 ``` # Additional Notes - Focus on creating an efficient solution that scales well with the number of entries. - Do not modify the existing hash, rehash, or resizing methods directly but extend functionality appropriately.","solution":"class ResizableHashTable: def __init__(self, initial_capacity=8): self.capacity = initial_capacity self.size = 0 self.table = [None] * self.capacity self.load_factor = 0.66 self.frequency_table = {} def hash_function(self, key): return key % self.capacity def put(self, key, value): if self.size / self.capacity >= self.load_factor: self._resize() index = self.hash_function(key) while self.table[index] is not None and self.table[index][0] != key: index = (index + 1) % self.capacity if self.table[index] is None: self.size += 1 self.table[index] = (key, value) if key in self.frequency_table: self.frequency_table[key] += 1 else: self.frequency_table[key] = 1 def get(self, key): index = self.hash_function(key) while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % self.capacity return None def _resize(self): old_table = self.table self.capacity *= 2 self.size = 0 self.table = [None] * self.capacity for item in old_table: if item is not None: self.put(item[0], item[1]) def frequency_of(self, key): return self.frequency_table.get(key, None) def reset_frequency(self, key): if key in self.frequency_table: self.frequency_table[key] = 0 return True return False"},{"question":"# Shell Sort Implementation with Optimal Gap Sequence Scenario: Your task is to implement the Shell Sort algorithm with an improved gap sequence to efficiently sort an array of integers. Use the Hibbard gap sequence, which is defined as (1, 3, 7, 15, 31, ...) up to the largest number not exceeding half the size of the input array. Function Signature: ```python def optimized_shell_sort(arr: list[int]) -> list[int]: ``` Input: - `arr`: A list of integers (`1 <= len(arr) <= 10^5`, `-10^6 <= arr[i] <= 10^6`). Output: - A list of integers sorted in ascending order. Constraints: - The function should sort the list in place, with a time complexity better than O(n^2). - You are required to use the Hibbard gap sequence for improving sorting efficiency. Example: ```python >>> optimized_shell_sort([12, 34, 54, 2, 3]) [2, 3, 12, 34, 54] >>> optimized_shell_sort([37, -5, 0, 10, -1, 12]) [-5, -1, 0, 10, 12, 37] ``` Additional Notes: - Ensure to handle edge cases such as an empty list or a list with a single element. - Think about optimizing array access within the gap sequence to avoid redundancy.","solution":"def optimized_shell_sort(arr: list[int]) -> list[int]: Sorts the array using the Shell Sort algorithm with Hibbard gap sequence. n = len(arr) gap = 1 gaps = [] # Generate Hibbard gap sequence while gap < n: gaps.append(gap) gap = 2 * gap + 1 # Sort using the generated gap sequence for gap in reversed(gaps): for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Alternating Bits Checker Function Scenario: A bit manipulation operation is required to ensure the integrity of a data signal converter. The converter is designed to alternate signal states represented by bits. To validate the integrity of the data signal, you must implement a function that checks whether the bits of a number alternate between 0 and 1. Task: Write a function `has_alternating_bits(n: int) -> bool` that determines if the binary representation of a positive integer `n` has alternating bits. The function should return `True` if the bits alternate; `False` otherwise. Requirements: 1. **Input Format**: - A positive integer `n` (1 <= n <= 2^31-1). 2. **Output Format**: - Boolean value `True` or `False`. 3. **Constraints**: - Your solution must handle edge cases like the smallest and largest possible values of `n`. - Your solution should be efficient in terms of time complexity. Aim for O(1) if possible. Example: ```python # Example 1 input: 5 output: True # Explanation: 5 in binary is \'101\'. The bits alternate. # Example 2 input: 7 output: False # Explanation: 7 in binary is \'111\'. The bits do not alternate. # Example 3 input: 10 output: True # Explanation: 10 in binary is \'1010\'. The bits alternate. # Example 4 input: 3 output: False # Explanation: 3 in binary is \'11\'. The bits do not alternate. ``` Note: - You may use helper functions to simplify your code if necessary. - Ensure your function checks all edge cases to avoid errors.","solution":"def has_alternating_bits(n: int) -> bool: Determines if the binary representation of an integer has alternating bits. Parameters: n (int): A positive integer (1 <= n <= 2^31-1) Returns: bool: True if the binary representation of n has alternating bits, False otherwise. # Get the binary representation of n without the \'0b\' prefix binary_str = bin(n)[2:] # Check if every adjacent bit is different for i in range(len(binary_str) - 1): if binary_str[i] == binary_str[i + 1]: return False return True"},{"question":"# String Decoding using Stacks Context: You are working on a data processing task where you need to decode encoded strings. The strings are encoded in a specific format where patterns are repeated based on a numeric multiplier. Task: Given an encoded string `s`, implement a function `decode_string(s)` that returns its decoded string. Rules: * Encoding rule: `k[encoded_string]` where the encoded_string inside the square brackets is repeated exactly `k` times. * The encoding is guaranteed to be always valid. Input Format: * A single string `s` (1 <= |s| <= 30,000), which consists of lower case English letters, digits, and square brackets. Output Format: * Return a single decoded string. Constraints: 1. Ensure the string follows the encoding rules; no extra white spaces. 2. Assumptions: * The input string is always valid. * Digits signify only the repeat numbers. Examples: Example 1: ``` Input: s = \\"3[a]2[bc]\\" Output: \\"aaabcbc\\" ``` Example 2: ``` Input: s = \\"3[a2[c]]\\" Output: \\"accaccacc\\" ``` Example 3: ``` Input: s = \\"2[abc]3[cd]ef\\" Output: \\"abcabccdcdcdef\\" ``` Function Signature: ```python def decode_string(s: str) -> str: # Your code here pass ``` Guidance: * Consider crafting comprehensive test cases, covering nested and un-nested encoded segments. * Stress-test for deeply nested structures and possible performance bottlenecks. * Think about edge cases like empty strings or strings with multiple nested levels.","solution":"def decode_string(s: str) -> str: Decodes the encoded string using the defined rules. stack = [] current_num = 0 current_str = \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': # Push the current number and the current string onto the stack stack.append((current_str, current_num)) # Reset current string and current number current_str = \'\' current_num = 0 elif char == \']\': # Pop the stack to get the last string and number prev_str, num = stack.pop() # The current string is repeated `num` times and added to `prev_str` current_str = prev_str + num * current_str else: current_str += char return current_str"},{"question":"# Word Segmentation Using Dynamic Programming **Objective**: Write a function to determine if a given string can be segmented into a space-separated sequence of one or more dictionary words. # Function Signature ```python def word_break(word: str, word_dict: set) -> bool: :param word: a non-empty string to be segmented :param word_dict: a set containing a list of dictionary words :return: True if the word can be segmented, False otherwise ``` # Input 1. **word**: A non-empty string `word` (1 <= len(word) <= 300). 2. **word_dict**: A set `word_dict` containing a list of non-empty dictionary words (0 <= len(word_dict) <= 10^4). # Output - **Return**: `True` if the word can be segmented, `False` otherwise. # Constraints - The dictionary does not contain duplicate words. - All words in the dictionary are non-empty. - Performance Requirement: The solution should run efficiently for the input limits. # Example ```python word = \\"leetcode\\" word_dict = {\\"leet\\", \\"code\\"} # Returns: True word = \\"applepenapple\\" word_dict = {\\"apple\\", \\"pen\\"} # Returns: True word = \\"catsandog\\" word_dict = {\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"} # Returns: False ``` # Scenario Imagine you are developing a feature for a text editor that automatically divides input text into valid words using a predefined dictionary. This feature should allow users to input text without spaces and have the editor intelligently insert spaces to form valid words. Your task is to implement the core function that determines if such segmentation is possible. # Implementation Your task is to implement the function `word_break` using dynamic programming as outlined in the core identification. The function must efficiently check all possible substrings to validate whether the input string can be fully segmented into words present in the given dictionary.","solution":"def word_break(word: str, word_dict: set) -> bool: Returns True if the word can be segmented into one or more dictionary words from word_dict. n = len(word) if not word_dict: return False # dp[i] will be True if word[0:i] can be segmented into dictionary words dp = [False] * (n + 1) dp[0] = True # An empty string can always be segmented for i in range(1, n + 1): for j in range(i): if dp[j] and word[j:i] in word_dict: dp[i] = True break return dp[n]"},{"question":"# Problem: Rotate Right - Singly-Linked List *Scenario*: As an accomplished software engineer at a high-performance computing firm, you have been tasked with manipulating linked lists to optimize data streams. One such task involves writing a function to rotate a singly linked list to the right by `k` places. You need to ensure that your function efficiently handles large lists and edge cases while maintaining clarity in the implementation. # Function Requirements: Function Signature: ```python def rotate_right(head: ListNode, k: int) -> ListNode: pass ``` # Input: - `head`: The starting node of the singly-linked list. - `k`: A non-negative integer which denotes the number of positions to rotate the list to the right. # Output: - The head node of the rotated linked list. # Constraints/Limitations: - `0 <= k <= 10^9` - The number of nodes in the linked list can be up to `10^5`. # Example: Consider the following linked list and rotation: ```plaintext Input: 1->2->3->4->5->NULL, k = 2 Output: 4->5->1->2->3->NULL ``` # Edge Cases: - Empty list (head is `None`). - Single-node list. - `k` is zero or larger than the length of the list. # Performance Requirements: - The algorithm should run in O(n) time complexity and use O(1) extra space. # Testing: Ensure your function handles the following test cases: 1. Rotate a list with no elements. 2. Rotate a list with a single element. 3. Rotate a list where `k` is greater than the number of nodes. 4. Rotate a list where `k` is zero. 5. Rotate a list multiple times to ensure correct behavior.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotate_right(head: ListNode, k: int) -> ListNode: if not head or not head.next or k == 0: return head # Find the length of the list and also the last node length = 1 old_tail = head while old_tail.next: old_tail = old_tail.next length += 1 # Find the effective rotation k = k % length if k == 0: return head # Find new tail: (length - k % length - 1)th node # and new head: (length - k % length)th node new_tail = head for _ in range(length - k - 1): new_tail = new_tail.next new_head = new_tail.next # Break the loop new_tail.next = None old_tail.next = head return new_head"},{"question":"You are given a graph as an adjacency list. Each key in the dictionary represents a node, and the corresponding value is another dictionary containing adjacent nodes and their respective edge weights. Your task is to implement a function that determines whether a single-source shortest path from a specified source to all other vertices exists. If the graph contains a negative weight cycle that is reachable from the source, the function should return False, otherwise, it should return True. **Function Signature:** ```python def single_source_shortest_path(graph: dict, source: str) -> bool: ``` **Input:** - `graph`: A dictionary representing the graph. - Example: ```python graph = { \'a\': {\'b\': 6, \'e\': 7}, \'b\': {\'c\': 5, \'d\': -4, \'e\': 8}, \'c\': {\'b\': -2}, \'d\': {\'a\': 2, \'c\': 7}, \'e\': {\'b\': -3} } ``` - `source`: A string representing the starting node for the shortest path calculation. **Output:** - Return `True` if the shortest path exists without encountering a negative weight cycle from the source to any other vertices. - Return `False` if there is any reachable negative weight cycle from the source. **Constraints:** - The graph contains at most 1000 nodes. - Edge weights can be negative, zero, or positive integers. - All node names are lowercase alphabetic characters. **Example:** ```python graph = { \'a\': {\'b\': 6, \'e\': 7}, \'b\': {\'c\': 5, \'d\': -4, \'e\': 8}, \'c\': {\'b\': -2}, \'d\': {\'a\': 2, \'c\': 7}, \'e\': {\'b\': -3} } print(single_source_shortest_path(graph, \'a\')) # Output: True ``` **Notes:** - You should initialize the shortest path weights and predecessor nodes correctly. - Iterate over all edges multiple times to ensure the shortest path estimates are accurate. - Check for negative weight cycles in the end.","solution":"def single_source_shortest_path(graph: dict, source: str) -> bool: Determines whether a single-source shortest path from the specified source to all other vertices exists. Returns False if there is any reachable negative weight cycle, otherwise True. import math # Step 1: Initialize distances and predecessors dist = {node: math.inf for node in graph} dist[source] = 0 # Step 2: Relax edges repeatedly for _ in range(len(graph) - 1): for u in graph: for v, weight in graph[u].items(): if dist[u] + weight < dist[v]: dist[v] = dist[u] + weight # Step 3: Check for negative weight cycles for u in graph: for v, weight in graph[u].items(): if dist[u] + weight < dist[v]: return False # Negative weight cycle found return True"},{"question":"# Scenario You are developing a typing training application that helps users improve their typing speed. As part of the application features, you need to identify words that can be typed using letters from just one row of an American keyboard. # Objective Implement a function that returns a list of words that can be typed using letters from only one row of an American keyboard. # Function Signature ```python def find_keyboard_row(words: List[str]) -> List[str]: ``` # Input * `words` (List[str]): A list of words where each word contains only alphabetical characters. # Output * List[str]: A list of words that can be typed with one row of an American keyboard. # Constraints * Each word consists of English letters (both uppercase and lowercase). * The input list can contain up to 10^4 words. # Sample Input/Output * Input: [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] * Output: [\\"Alaska\\", \\"Dad\\"] * Input: [\\"Tomato\\", \\"kitchen\\", \\"Zoo\\", \\"Face\\"] * Output: [\\"Kitchen\\", \\"Zoo\\"] # Performance Requirements Ensure that your solution efficiently handles up to 10,000 words without significant performance degradation. # Notes * Remember to convert each word to a comparable case (e.g., all lowercase) to facilitate the subset operations. * You can assume all inputs are valid for this context.","solution":"from typing import List def find_keyboard_row(words: List[str]) -> List[str]: row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") def can_be_typed(word): word_set = set(word.lower()) return word_set.issubset(row1) or word_set.issubset(row2) or word_set.issubset(row3) result = [word for word in words if can_be_typed(word)] return result"},{"question":"# Queue-based Multi-level Printer Job Scheduler You are tasked with implementing a multi-level printer job scheduler using the Queue ADT. The scheduler should prioritize different levels of print jobs: high, medium, and low. Jobs of higher priority should always be processed before lower-priority jobs. Within each priority level, jobs should follow the FIFO order. Your task is to create a `PrinterJobScheduler` class that supports the following methods: 1. **add_job(priority: str, job_id: int) -> None**: - Adds a print job with a given `job_id` and `priority` (\'high\', \'medium\', \'low\') to the scheduler. 2. **get_next_job() -> int**: - Retrieves and removes the next job to be printed based on the priority, returning its `job_id`. If there are no jobs, raise a `ValueError` with the message \\"No jobs available\\". 3. **peek_next_job() -> int**: - Retrieves (but does not remove) the next job to be printed, returning its `job_id`. If there are no jobs, raise a `ValueError` with the message \\"No jobs available\\". 4. **is_empty() -> bool**: - Returns `True` if there are no jobs in the scheduler, `False` otherwise. **Input Constraints**: - `priority` is always one of \'high\', \'medium\', or \'low\'. - `job_id` is a unique integer for each job. - Assume a reasonable upper bound (e.g., 1000 jobs) for simplicity. **Output Format**: - Implement the `PrinterJobScheduler` class with the described methods. **Example**: ```python scheduler = PrinterJobScheduler() scheduler.add_job(\'high\', 101) scheduler.add_job(\'low\', 102) scheduler.add_job(\'medium\', 103) scheduler.add_job(\'high\', 104) print(scheduler.get_next_job()) # Output: 101 print(scheduler.peek_next_job()) # Output: 104 print(scheduler.get_next_job()) # Output: 104 print(scheduler.is_empty()) # Output: False print(scheduler.get_next_job()) # Output: 103 print(scheduler.get_next_job()) # Output: 102 print(scheduler.is_empty()) # Output: True ```","solution":"from collections import deque class PrinterJobScheduler: def __init__(self): self.high_priority = deque() self.medium_priority = deque() self.low_priority = deque() def add_job(self, priority: str, job_id: int) -> None: if priority == \'high\': self.high_priority.append(job_id) elif priority == \'medium\': self.medium_priority.append(job_id) elif priority == \'low\': self.low_priority.append(job_id) def get_next_job(self) -> int: if self.high_priority: return self.high_priority.popleft() if self.medium_priority: return self.medium_priority.popleft() if self.low_priority: return self.low_priority.popleft() raise ValueError(\\"No jobs available\\") def peek_next_job(self) -> int: if self.high_priority: return self.high_priority[0] if self.medium_priority: return self.medium_priority[0] if self.low_priority: return self.low_priority[0] raise ValueError(\\"No jobs available\\") def is_empty(self) -> bool: return not (self.high_priority or self.medium_priority or self.low_priority)"},{"question":"# Problem: Sum Calculation using Bitwise Operations Objective Write a function that takes two non-negative integers and returns their sum using only bitwise operations. Function Signature ```python def bitwise_addition(x: int, y: int) -> int: ``` Input - `x` (int): First non-negative integer (0 <= x <= 10^9) - `y` (int): Second non-negative integer (0 <= y <= 10^9) Output - (int): The sum of `x` and `y`. Constraints - You must not use the \'+\' operator, or any other arithmetic operators. - The function should handle edge cases like the addition of zero, large numbers, and ensure no overflow (considering typical 32-bits or 64-bits signed integers). Example ```python # Example 1 Input: x = 2, y = 3 Output: 5 # Example 2 Input: x = 1000000000, y = 1000000000 Output: 2000000000 ``` Scenario In a hardware design course, you\'re given an assignment to implement basic arithmetic operations using bitwise operations due to the simplicity and efficiency these operations provide at the hardware level.","solution":"def bitwise_addition(x: int, y: int) -> int: while y != 0: carry = x & y x = x ^ y y = carry << 1 return x"},{"question":"Task Implement an insertion sort algorithm for a list of integers and use a binary search function to determine the correct position for each element during the insertion process. This will help improve the efficiency of your insertion sort. Scenario You are given a list of grades for a class, but they are not sorted. Your task is to sort the list of grades in ascending order using an optimized insertion sort algorithm. The binary search helper function provided will be integral to determining where each grade should be inserted. Function Signature ```python def binary_search(array, val): Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. :param array: List[int] :param val: int :return: int # Implementation provided in the code snippet above. def insertion_sort_with_binary_search(array): Sorts \'array\' using insertion sort algorithm optimized with binary search. :param array: List[int] :return: List[int] - Sorted list in ascending order # Your implementation here ``` Constraints * `len(array) <= 10^4` * Each element in `array` is an integer where ( -10^4 leq array[i] leq 10^4 ) Example ```python array = [4, 2, 7, 1, 3] print(insertion_sort_with_binary_search(array)) # Output: [1, 2, 3, 4, 7] ``` Requirements 1. Implement the `binary_search` function based on the provided code. 2. Write the `insertion_sort_with_binary_search` function which utilizes `binary_search` to sort the list. 3. Ensure your function handles and tests the edge cases and constraints mentioned.","solution":"def binary_search(array, val): Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. :param array: List[int] :param val: int :return: int low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == val: return mid elif array[mid] < val: low = mid + 1 else: high = mid - 1 return low def insertion_sort_with_binary_search(array): Sorts \'array\' using insertion sort algorithm optimized with binary search. :param array: List[int] :return: List[int] - Sorted list in ascending order sorted_array = [] for val in array: pos = binary_search(sorted_array, val) sorted_array.insert(pos, val) return sorted_array"},{"question":"You are provided with a road-map used in calculating factorials which include both iterative and recursive methods. Your task is to extend and optimize these methods to handle a more complex scenario. You need to write a function that computes factorials while accommodating additional constraints and optimizing for specific conditions. Function Requirements: The function `optimized_factorial` should: 1. Take two parameters: - `n` (a non-negative integer) - `mod` (an optional positive integer for modulus operation) 2. Calculate the factorial of the given `n`. 3. Apply modulus operation if the `mod` parameter is provided. 4. Handle very large values of `n` efficiently by incorporating optimization techniques. 5. Ensure that the function does not hit recursion limit for large `n`. 6. Raise appropriate exceptions for invalid inputs. Input/Output Format: - **Input**: Two inputs will be provided: 1. `n` - A non-negative integer where 0 ≤ n ≤ 10^6 2. `mod` (optional) - A positive integer where 1 ≤ mod ≤ 10^9 - **Output**: A single integer which is the factorial of `n`, optionally reduced by `mod`. ```python def optimized_factorial(n: int, mod: int = None) -> int: # Implementation here pass # Example Usage: print(optimized_factorial(5)) # 120 print(optimized_factorial(5, 3)) # 0 (120 % 3) print(optimized_factorial(0)) # 1 ``` Constraints: 1. `0 ≤ n ≤ 10^6` 2. If provided, `1 ≤ mod ≤ 10^9` Hints: - Think about how to reduce unnecessary computations especially for large values of n. - Explore using iterative over recursive approach to handle large `n` effectively.","solution":"def optimized_factorial(n: int, mod: int = None) -> int: Calculate the factorial of n and optionally take the modulus with mod. Parameters: n (int): Non-negative integer to calculate the factorial of. mod (int): Positive integer for taking modulus of the factorial result. Returns: int: The factorial of n optionally reduced by mod. if not isinstance(n, int) or n < 0: raise ValueError(\\"n must be a non-negative integer.\\") if mod is not None and (not isinstance(mod, int) or mod <= 0): raise ValueError(\\"mod must be a positive integer if provided.\\") result = 1 if mod: for i in range(2, n + 1): result = (result * i) % mod else: for i in range(2, n + 1): result *= i return result"},{"question":"# Removal of Duplicate Nodes in a Linked List Given a singly linked list, your task is to implement a function that removes all duplicate nodes from the list. There are two conditions in which you should implement the solution: Method 1: Using Additional Space Write a function `remove_dups(head)` that removes duplicates from a linked list using additional space (e.g., a set to keep track of seen values). Method 2: Without Using Additional Space Write a function `remove_dups_without_set(head)` that removes duplicates without using any additional space (apart from the given linked list nodes). **Specifications**: - **Input**: A singly linked list `head` where each node contains a string value. - **Output**: The modified linked list with duplicates removed. Function Signatures ```python class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head: Node) -> None: # Your code here def remove_dups_without_set(head: Node) -> None: # Your code here ``` # Constraints: - The linked list can contain up to 10^5 nodes. - Each node\'s value is a string of maximum length 100. # Example: ```python # Example Linked List: \\"A\\" -> \\"A\\" -> \\"B\\" -> \\"C\\" -> \\"D\\" -> \\"C\\" -> \\"F\\" -> \\"G\\" a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g remove_dups(a1) # After calling remove_dups(a1), the list should be: \\"A\\" -> \\"B\\" -> \\"C\\" -> \\"D\\" -> \\"F\\" -> \\"G\\" remove_dups_without_set(a1) # After calling remove_dups_without_set(a1), the list should still be: \\"A\\" -> \\"B\\" -> \\"C\\" -> \\"D\\" -> \\"F\\" -> \\"G\\" ``` **Note**: Implement a helper function `print_linked_list(head)` to test and validate your solution. ```python def print_linked_list(head: Node) -> None: result = [] current = head while current: result.append(current.val) current = current.next print(\\" -> \\".join(result)) ``` Ensure your code efficiently handles the linked list operations as per the given constraints and specifications.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head): Remove duplicates from a linked list using additional space. if not head: return seen = set() current = head prev = None while current: if current.val in seen: prev.next = current.next else: seen.add(current.val) prev = current current = current.next def remove_dups_without_set(head): Remove duplicates from a linked list without using additional space. current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next def print_linked_list(head): result = [] current = head while current: result.append(current.val) current = current.next return \\" -> \\".join(result)"},{"question":"# FizzBuzz with Custom Rules You are tasked with extending the classic FizzBuzz problem to include additional substitution rules and enhanced input validation. Implement a function `custom_fizzbuzz(n, rules)` that takes an integer `n` and a dictionary `rules`, where keys are integers and values are strings. The function should return an array containing the numbers from 1 to `n`, with substitutions based on the following: 1. If a number is a multiple of any of the keys in the rules dictionary, substitute the number with the corresponding value. 2. If a number is a multiple of multiple keys, concatenate their corresponding values (in increasing order of the keys). 3. If no substitutions apply, include the number itself in the final list. Input: * `n`: An integer greater than 0 * `rules`: A dictionary where keys are positive integers and values are strings. For example, `{3: \'Fizz\', 5: \'Buzz\', 7: \'Bazz\'}` Output: * A list where each element is either a substituted string or an integer. Constraints: * `1 <= n <= 100000` * The rules dictionary will have at most 10 entries. * Keys in the rules dictionary will be greater than 0 and less than or equal to 100. Example: ```python custom_fizzbuzz(15, {3: \'Fizz\', 5: \'Buzz\'}) # Returns: [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] custom_fizzbuzz(15, {2: \'Bizz\', 3: \'Fizz\', 5: \'Buzz\', 7: \'Bazz\'}) # Returns: [1, \'Bizz\', \'Fizz\', \'Bizz\', \'Buzz\', \'BizzFizz\', 7, \'Bizz\', \'Fizz\', \'BizzBuzz\', 11, \'BizzFizz\', 13, \'BizzBazz\', \'FizzBuzz\'] ``` Consider edge cases and ensure your function handles large values of `n` efficiently.","solution":"def custom_fizzbuzz(n, rules): Returns a list of numbers from 1 to n with substitutions based on the rules dictionary. :param n: An integer indicating the range 1 to n (inclusive) :param rules: A dictionary containing substitution rules where keys are multipliers and values are substitution strings :return: A list containing numbers or substituted strings based on the rules result = [] for i in range(1, n + 1): substitution = \\"\\" for key in sorted(rules.keys()): if i % key == 0: substitution += rules[key] if substitution == \\"\\": result.append(i) else: result.append(substitution) return result"},{"question":"# Prime Number Identifier Objective Design an advanced function to detect prime numbers using an optimized approach that extends beyond the provided implementation. Problem Statement You are tasked to develop an enhanced primality testing function. The primary objective is to maintain or improve the performance characteristics while ensuring robustness against edge cases and large input values. Function Signature ```python def optimized_prime_check(n: int) -> bool: Return True if n is a prime number, else return False. ``` Input * An integer `n` such that `2 ≤ n ≤ 10^9`. Output * Return `True` if `n` is a prime number, else return `False`. Requirements 1. Your implementation should be optimized for both time and space. 2. Consider edge cases as given in the analysis. 3. Ensure that your solution works efficiently even for large values of `n`. 4. Optimize the algorithm to minimize the number of divisions performed. Example ```python assert optimized_prime_check(7) == True assert optimized_prime_check(10) == False assert optimized_prime_check(104729) == True # 10000th prime number assert optimized_prime_check(1000000000) == False ``` Hints 1. Leverage mathematical properties of prime numbers. 2. Use efficient divisibility checks and consider numbers of the form `6k ± 1`. You are free to adopt advanced techniques or improve upon the classic approach to meet the problem constraints effectively.","solution":"def optimized_prime_check(n: int) -> bool: Returns True if n is a prime number, else returns False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"You are tasked with implementing a function that calculates the factorial of a number using an iterative approach. Your function should also support calculating the factorial modulo a given number if a modulo value is provided. # Function Signature ```python def compute_factorial(n: int, mod: int = None) -> int: pass ``` # Input - `n`: A non-negative integer ( ( 0 leq n leq 10^6 ) ). - `mod`: An optional positive integer ( ( 1 leq mod leq 10^9 + 7 ) ). # Output - The function returns the factorial of `n`. If `mod` is provided, it should return the factorial modulo `mod`. # Constraints - `n` will be a non-negative integer. - If `mod` is provided, it will be a positive integer. # Requirements - Your implementation should efficiently compute the factorial and handle large values of ( n ) up to ( 10^6 ). # Example ```python compute_factorial(5) # Output: 120 compute_factorial(5, 3) # Output: 0 (since 120 % 3 == 0) compute_factorial(0) # Output: 1 compute_factorial(7, 100) # Output: 4 (since 5040 % 100 == 40) ``` # Explanation 1. `compute_factorial(5)` computes ( 5! = 5 times 4 times 3 times 2 times 1 = 120 ). 2. `compute_factorial(5, 3)` computes ( 120 mod 3 = 0 ). 3. `compute_factorial(0)` recognizes the base case ( 0! = 1 ). 4. `compute_factorial(7, 100)` computes ( 5040 mod 100 = 40 ). Your task is to implement the function `compute_factorial` that fulfills the above requirements.","solution":"def compute_factorial(n: int, mod: int = None) -> int: Computes the factorial of a non-negative integer n. If mod is provided, returns the factorial of n modulo mod. :param n: non-negative integer to compute the factorial of :param mod: optional positive integer to take the modulo with :return: factorial of n (or factorial % mod if mod is provided) result = 1 for i in range(1, n + 1): result *= i if mod: result %= mod return result"},{"question":"# Coding Challenge Scenario: You are tasked with implementing a custom `RandomizedSet` class to manage a collection of elements with unique properties and follow the outlined requirements. The `RandomizedSet` should be capable of fast insertions, deletions, and retrieval of random elements. This class can significantly be utilized in scenarios demanding constant time operations on these functionalities. Requirements: Implement the `RandomizedSet` class with the following methods: 1. `__init__(self)`: Initializes an empty set. 2. `insert(self, val: int) -> bool`: Inserts an item `val` to the set if not already present. Returns `True` if the item was not present, `False` otherwise. 3. `remove(self, val: int) -> bool`: Removes an item `val` from the set if present. Returns `True` if the item was present, `False` otherwise. 4. `get_random(self) -> int`: Returns a random element from the current set of elements. Each element must have the same probability of being returned. Input and Output Formats: - **insert()**: - Input: an integer value `val`. - Output: a Boolean indicating the success of the operation. - **remove()**: - Input: an integer value `val`. - Output: a Boolean indicating the success of the operation. - **get_random()**: - Input: None. - Output: an integer value randomly selected from the set. # Example: ```python # Initialize an empty set randomized_set = RandomizedSet() # Insert elements to the set print(randomized_set.insert(1)) # Output: True print(randomized_set.insert(2)) # Output: True print(randomized_set.insert(1)) # Output: False # Remove elements from the set print(randomized_set.remove(1)) # Output: True print(randomized_set.remove(1)) # Output: False # Get a random element from the set # (Output will vary as it selects a random element) print(randomized_set.get_random()) # Output: 2 ``` # Constraints: - All integer values in the insert and remove operations lie within the range [−10^6, 10^6]. - The `get_random` method can only be called if there\'s at least one element in the set. **Performance Note**: Ensure your solution maintains the required average O(1) time complexity for all operations, and adheres to constraints to avoid errors such as retrieving an element from an empty set.","solution":"import random class RandomizedSet: def __init__(self): Initialize your data structure here. self.dict = {} self.list = [] def insert(self, val: int) -> bool: Inserts a value to the set if not present. Returns true if the item was not present, false otherwise. if val in self.dict: return False self.dict[val] = len(self.list) self.list.append(val) return True def remove(self, val: int) -> bool: Removes a value from the set if present. Returns true if the item was present, false otherwise. if val not in self.dict: return False # Swap the element with the last element to remove it in O(1) time complexity last_element = self.list[-1] idx_to_remove = self.dict[val] self.list[idx_to_remove] = last_element self.dict[last_element] = idx_to_remove # Remove the last element self.list.pop() del self.dict[val] return True def get_random(self) -> int: Get a random element from the set. return random.choice(self.list)"},{"question":"# Two Sum Problem with Sorted Array You are given an array of integers `numbers` sorted in ascending order and an integer `target`. Your task is to write a function `optimized_two_sum` that finds and returns the 1-based indices of the two numbers that add up to the `target`. **Function Signature**: ```python def optimized_two_sum(numbers: List[int], target: int) -> List[int]: pass ``` # Input - `numbers` (List[int]): A list of integers sorted in ascending order. - `target` (int): The integer target sum. # Output - List[int]: A list containing the 1-based indices of the two numbers such that they add up to the target. # Constraints - Each input will have exactly one solution. - You cannot use the same element twice. - Indices returned should be in ascending order (index1 < index2). - The list `numbers` contains at least two integers. # Example ```python # Example 1: numbers = [2, 7, 11, 15] target = 9 # Returns: # [1, 2] (Since numbers[0] + numbers[1] = 2 + 7 = 9) # Example 2: numbers = [1, 2, 3, 4, 4, 9, 11, 15] target = 8 # Returns: # [4, 5] (Since numbers[3] + numbers[4] = 4 + 4 = 8) ``` # Requirements - Ensure your algorithm runs in linear time O(N) and uses constant space O(1). - Do not use additional data structures such as hash tables or perform nested iterations. # Task Implement the function `optimized_two_sum` using the two-pointer approach. Validate the indices are returned in 1-based format as required. ```python from typing import List def optimized_two_sum(numbers: List[int], target: int) -> List[int]: left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1 ```","solution":"from typing import List def optimized_two_sum(numbers: List[int], target: int) -> List[int]: Returns 1-based indices of the two numbers in \'numbers\' that sum up to \'target\'. The input list \'numbers\' is sorted in ascending order. Parameters: - numbers (List[int]): A list of integers sorted in ascending order. - target (int): The integer target sum. Returns: - List[int]: A list containing the 1-based indices of the two numbers that add up to the target. left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1"},{"question":"Encode and Decode a List of Strings You are tasked with designing an algorithm to encode a list of strings into a single string and then decode it back to the original list. Your implementation should handle strings of varying lengths, including edge cases such as empty strings or lists. Implement two functions: 1. `encode(strs: List[str]) -> str` - **Input**: A list of strings `strs`. - **Output**: A single string that represents the encoded version of the list. 2. `decode(s: str) -> List[str]` - **Input**: A string `s` which is the encoded version of a list of strings. - **Output**: The original list of strings. # Example Given the input: ``` strs = [\\"hello\\", \\"world\\", \\"\\", \\"python\\", \\"3.8\\"] ``` Your encoded string might look like: ``` encoded_str = \\"5:hello5:world0:6:python3:3.8\\" ``` Decoding this should return: ``` [\\"hello\\", \\"world\\", \\"\\", \\"python\\", \\"3.8\\"] ``` # Constraints * The input strings can contain any printable characters. * The length of the encoded string should not exceed 10^5 characters. * Do not use libraries that serialize or deserialize objects directly. # Requirements * Ensure your functions handle edge cases such as empty strings and lists. * Maintain efficiency with a time complexity of O(n) and space complexity of O(n), where n is the total length of all strings combined.","solution":"def encode(strs): Encodes a list of strings to a single string. :param strs: List of strings to encode :return: Encoded string return \'\'.join(f\\"{len(s)}:{s}\\" for s in strs) def decode(s): Decodes a single string to a list of strings. :param s: Encoded string :return: List of original strings decoded = [] i = 0 while i < len(s): j = i while s[j] != \':\': j += 1 length = int(s[i:j]) decoded.append(s[j+1:j+1+length]) i = j + 1 + length return decoded"},{"question":"You are required to implement a new data structure, `RandomizedCollection`, which allows duplicate elements but still supports average O(1) time complexity for insertion, deletion, and retrieving a random element. Your `RandomizedCollection` class should support the following operations: 1. `insert(val: int) -> bool`: Adds an item `val` to the collection. Returns `True` if the item was not in the collection, `False` otherwise. 2. `remove(val: int) -> bool`: Removes one occurrence of `val` from the collection. Returns `True` if the item was present, `False` otherwise. 3. `get_random() -> int`: Returns a random element from the current collection of elements. Each element should have the same probability of being returned. # Constraints: - All integers passed to `insert` and `remove` will be within the range of a 32-bit signed integer. - The operations will be called at most (10^4) times. # Example: ```python rc = RandomizedCollection() print(rc.insert(1)) # True print(rc.insert(1)) # False print(rc.insert(2)) # True print(rc.remove(1)) # True print(rc.get_random()) # 1 or 2 print(rc.remove(2)) # True print(rc.get_random()) # 1 print(rc.remove(1)) # True print(rc.get_random()) # Raises an error as the collection is empty ``` # Implementation Guidelines: 1. You may use a combination of data structures to achieve average O(1) time complexity. 2. Be cautious of edge cases such as handling empty collections or dealing with duplicates. 3. Make sure your implementation is efficient both in terms of time and space.","solution":"import random from collections import defaultdict class RandomizedCollection: def __init__(self): self.values = [] self.indices = defaultdict(set) def insert(self, val: int) -> bool: self.values.append(val) self.indices[val].add(len(self.values) - 1) return len(self.indices[val]) == 1 def remove(self, val: int) -> bool: if val not in self.indices or len(self.indices[val]) == 0: return False remove_index = self.indices[val].pop() # Get an index of the value to be removed last_value = self.values[-1] self.values[remove_index] = last_value # Move the last element to the place of the removed element if self.indices[last_value]: self.indices[last_value].add(remove_index) self.indices[last_value].discard(len(self.values) - 1) self.values.pop() # Remove the last element if not self.indices[val]: del self.indices[val] return True def get_random(self) -> int: if not self.values: raise IndexError(\\"get_random() cannot be called on an empty collection\\") return random.choice(self.values)"},{"question":"# Scenario: You are building a range query system for a financial analytics application. It processes large amounts of stock price data, allowing users to efficiently query the maximum price in a range or update a stock\'s price at a specific day. To achieve this, you will implement a Segment Tree data structure. # Problem Statement: Implement a `SegmentTree` class that supports efficient range queries and element updates on an array. The `SegmentTree` class should work with any commutative binary function provided at initialization. Class Definition: ```python class SegmentTree: def __init__(self, arr, function): Initialize the segment tree with an array `arr` and a commutative function `function`. :param arr: List of elements to be stored in the Segment Tree. :param function: A commutative binary function to combine elements. pass def update(self, p, v): Update the value at index `p` in the original array to `v`. :param p: Index to update. :param v: New value. pass def query(self, l, r): Query the combined result over the range [l, r]. :param l: Left index of the range (inclusive). :param r: Right index of the range (inclusive). :return: Result of the commutative function applied over the range. pass ``` Input and Output Formats: - `__init__`: - Input: `arr` (list of elements), `function` (commutative function) - Output: A `SegmentTree` object - `update`: - Input: `p` (index to update), `v` (new value) - Output: None - `query`: - Input: `l` (left index), `r` (right index) - Output: Result of the commutative function over the range [l, r] # Example: ```python mytree = SegmentTree([2, 4, 5, 3, 4], max) print(mytree.query(2, 4)) # Should output: 5 mytree.update(3, 6) print(mytree.query(0, 3)) # Should output: 6 mytree2 = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(mytree2.query(0, 6)) # Should output: 64 mytree2.update(2, -10) print(mytree2.query(0, 6)) # Should output: 52 ``` # Constraints: 1. The input array size will be between 1 and 10^5. 2. The commutative function will always return the same type as its inputs. 3. Integer values in the input array will be within the range [-10^9, 10^9]. Ensure your implementation handles edge cases and performs efficiently for large arrays.","solution":"class SegmentTree: def __init__(self, arr, function): Initialize the segment tree with an array `arr` and a commutative function `function`. :param arr: List of elements to be stored in the Segment Tree. :param function: A commutative binary function to combine elements. self.n = len(arr) self.function = function self.tree = [None] * (2 * self.n) # Segment tree array # Fill the leaves in tree array with the input array for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, p, v): Update the value at index `p` in the original array to `v`. :param p: Index to update. :param v: New value. # Set value at the position p p += self.n self.tree[p] = v # Move upward and update the ancestors while p > 1: p //= 2 self.tree[p] = self.function(self.tree[2 * p], self.tree[2 * p + 1]) def query(self, l, r): Query the combined result over the range [l, r]. :param l: Left index of the range (inclusive). :param r: Right index of the range (inclusive). :return: Result of the commutative function applied over the range. # Transform to the segment tree indexation l += self.n r += self.n + 1 res = None while l < r: if l % 2 == 1: if res is None: res = self.tree[l] else: res = self.function(res, self.tree[l]) l += 1 if r % 2 == 1: r -= 1 if res is None: res = self.tree[r] else: res = self.function(res, self.tree[r]) l //= 2 r //= 2 return res"},{"question":"# Pattern Matching with Optimized Data Structure Utilization You are tasked with finding and marking specific patterns (symbols) in a collection of words. Your implemented algorithm should select the longest symbol match for each word and surround it with square brackets (\'[]\'). If no symbol matches, the word should remain unchanged. # Requirements: 1. **Input**: * `words` - A list of strings containing the words to be processed. (e.g., `[\'Amazon\', \'Microsoft\', \'Google\']`) * `symbols` - A list of strings containing the symbol patterns to find and mark. (e.g., `[\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\']`) 2. **Output**: * A list of words where for each word, the first (left-most) instance of the longest symbol match is surrounded by square brackets. If no symbol from the list is found in a word, the word remains unchanged. # Constraints: * Assume the length of words and symbols does not exceed 1000. * Each word length and symbol length is between 1 and 100. * Symbols should be matched as is, without case-insensitivity. # Performance: Your implementation should efficiently handle the inputs and provide the results in a reasonable time frame, making use of optimized data structures if necessary. # Example: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] # Expected Output: result = [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` # Implementation: Implement the following function: ```python def mark_longest_symbol(words, symbols): # Your optimized implementation here ``` # Hints: 1. Consider using a Trie to store the symbols for efficient pattern matching within the words. 2. Ensure that the longest matching symbol is prioritized. 3. You may need to handle overlapping symbols carefully.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_symbol = False self.symbol_length = 0 class Trie: def __init__(self): self.root = TrieNode() def insert(self, symbol): node = self.root for char in symbol: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_symbol = True node.symbol_length = len(symbol) def search_longest(self, word): node = self.root max_len = 0 max_pos = -1 for i in range(len(word)): cur_node = node for j in range(i, len(word)): if word[j] not in cur_node.children: break cur_node = cur_node.children[word[j]] if cur_node.is_end_of_symbol and cur_node.symbol_length > max_len: max_len = cur_node.symbol_length max_pos = i return max_pos, max_len def mark_longest_symbol(words, symbols): trie = Trie() for symbol in symbols: trie.insert(symbol) marked_words = [] for word in words: pos, length = trie.search_longest(word) if length > 0: marked_word = word[:pos] + \'[\' + word[pos:pos+length] + \']\' + word[pos+length:] marked_words.append(marked_word) else: marked_words.append(word) return marked_words"},{"question":"# Task Description You are given a string `s` and a list of words `wordDict`. Your task is to implement a function `count_sentences(s, wordDict)` that returns the number of possible sentences that can be formed by segmenting the string such that all resulting words are contained in the word dictionary. # Function Signature ```python def count_sentences(s: str, wordDict: list) -> int: ``` # Input - `s`: A non-empty string consisting of lowercase English letters. - `wordDict`: A list of non-empty words consisting of lowercase English letters. # Output - Return the number of valid sentences formed by segmenting the string `s` where each word is present in the `wordDict`. # Constraints - The length of `s` will not exceed 1000. - No guarantees are made about the size of `wordDict`. # Example ```python # Example 1 s = \\"appletablet\\" wordDict = [\\"apple\\", \\"tablet\\", \\"app\\", \\"let\\", \\"able\\", \\"t\\"] assert count_sentences(s, wordDict) == 3 # The possible sentences are [\\"apple tablet\\", \\"app let able t\\", \\"apple table t\\"] # Example 2 s = \\"thing\\" wordDict = [\\"thing\\"] assert count_sentences(s, wordDict) == 1 # The possible sentence is [\\"thing\\"] # Example 3 s = \\"pineapple\\" wordDict = [\\"pine\\", \\"apple\\", \\"pineapple\\", \\"pen\\", \\"applepen\\"] assert count_sentences(s, wordDict) == 2 # The possible sentences are [\\"pine apple\\", \\"pineapple\\"] ``` # Notes - Consider using memoization or dynamic programming to optimize your solution and avoid redundant computations. - You should handle edge cases such as strings with no valid segmentations and strings that are themselves dictionary words effectively.","solution":"def count_sentences(s: str, wordDict: list) -> int: word_set = set(wordDict) # Convert list to set for O(1) lookups memo = {} def _count_sentences(i): if i in memo: return memo[i] if i == len(s): return 1 total_count = 0 for j in range(i + 1, len(s) + 1): if s[i:j] in word_set: total_count += _count_sentences(j) memo[i] = total_count return total_count return _count_sentences(0)"},{"question":"# Scenario A telecommunications company needs to ensure that their signals represented by numbers have alternating binary bits to minimize interference. They want an effective way to verify this property. # Task Implement a function `has_alternating_bits(n: int) -> bool` that takes a positive integer `n` and returns `True` if its binary representation has alternating bits, otherwise returns `False`. # Function Signature ```python def has_alternating_bits(n: int) -> bool: pass ``` # Input * A positive integer `n` (1 ≤ n ≤ 2^31 - 1). # Output * Returns a boolean `True` if the number has alternating bits in its binary representation, otherwise `False`. # Constraints * You should aim for an efficient solution both in terms of time and space. * Handle the edges cases gracefully. * Make sure your solution passes all possible test cases. # Examples ```python # Example 1 # Input: 5 # Output: True # Explanation: The binary representation of 5 is 101 which has alternating bits. # Example 2 # Input: 7 # Output: False # Explanation: The binary representation of 7 is 111 which does not have alternating bits. # Example 3 # Input: 11 # Output: False # Explanation: The binary representation of 11 is 1011 which does not have alternating bits. # Example 4 # Input: 10 # Output: True # Explanation: The binary representation of 10 is 1010 which has alternating bits. def has_alternating_bits(n): first_bit = 0 second_bit = 0 while n: first_bit = n & 1 if n >> 1: second_bit = (n >> 1) & 1 if not first_bit ^ second_bit: return False else: return True n = n >> 1 return True def has_alternating_bits_fast(n): mask1 = int(\'aaaaaaaa\', 16) # for bits ending with zero (...1010) mask2 = int(\'55555555\', 16) # for bits ending with one (...0101) return mask1 == (n + (n ^ mask1)) or mask2 == (n + (n ^ mask2)) ```","solution":"def has_alternating_bits(n: int) -> bool: Return True if the binary representation of n has alternating bits, otherwise return False. current_bit = n % 2 n = n // 2 while n > 0: next_bit = n % 2 if current_bit == next_bit: return False current_bit = next_bit n = n // 2 return True"}]'),O={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:z,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},S={class:"search-container"},C={class:"card-container"},L={key:0,class:"empty-state"},F=["disabled"],R={key:0},Y={key:1};function j(r,e,l,c,a,s){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",S,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),y(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>a.searchQuery=o),placeholder:"Search..."},null,512),[[_,a.searchQuery]]),a.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>a.searchQuery="")}," ✕ ")):u("",!0)]),t("div",C,[(n(!0),i(b,null,v(s.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),s.displayedPoems.length===0?(n(),i("div",L,' No results found for "'+d(a.searchQuery)+'". ',1)):u("",!0)]),s.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:a.isLoading,onClick:e[2]||(e[2]=(...o)=>s.loadMore&&s.loadMore(...o))},[a.isLoading?(n(),i("span",Y,"Loading...")):(n(),i("span",R,"See more"))],8,F)):u("",!0)])}const P=p(O,[["render",j],["__scopeId","data-v-5b84673f"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/52.md","filePath":"drive/52.md"}'),D={name:"drive/52.md"},U=Object.assign(D,{setup(r){return(e,l)=>(n(),i("div",null,[x(P)]))}});export{M as __pageData,U as default};
