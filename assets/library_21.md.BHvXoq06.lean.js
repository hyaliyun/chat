import{_ as h,o as r,c as n,a as t,m as d,t as m,C as g,M as p,U as b,f as u,F as x,p as v,e as y,q as w}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function R(i,e,l,c,s,a){return r(),n("div",q,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),d(m(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),d(m(l.poem.solution),1)])])])}const j=h(k,[["render",R],["__scopeId","data-v-fb241e8c"]]),F=JSON.parse(`[{"question":"from collections import defaultdict from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups a list of words into anagrams. :param words: List of strings :return: List of lists of grouped anagram strings >>> group_anagrams(['bat']) [['bat']] >>> group_anagrams(['bat', 'cat', 'dog']) [['bat'], ['cat'], ['dog']] >>> group_anagrams(['bat', 'tab', 'tap', 'pat']) [['bat', 'tab'], ['tap', 'pat']] >>> group_anagrams(['ab', 'ba', 'abc', 'bca', 'cab', 'xy', 'yx']) [['ab', 'ba'], ['abc', 'bca', 'cab'], ['xy', 'yx']] >>> group_anagrams(['abc', 'bca', 'cab', 'abc']) [['abc', 'bca', 'cab', 'abc']] anagram_dict = defaultdict(list) # Implementation here return list(anagram_dict.values())","solution":"from collections import defaultdict def group_anagrams(words): Groups a list of words into anagrams. :param words: List of strings :return: List of lists of grouped anagram strings anagram_dict = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagram_dict[sorted_word].append(word) return list(anagram_dict.values())"},{"question":"def add_digits(num: int) -> int: Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. >>> add_digits(0) 0 >>> add_digits(5) 5 >>> add_digits(38) 2 >>> add_digits(1234) 1 >>> add_digits(987654) 3 >>> add_digits(99999) 9 >>> add_digits(10000) 1","solution":"def add_digits(num): Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. if num == 0: return 0 else: return 1 + (num - 1) % 9"},{"question":"def max_billboards(heights, k): Returns the maximum number of billboards that can be installed such that no two billboards overlap when viewed from the front. Parameters: heights (list of int): Heights of the buildings. k (int): Height of the billboards. Returns: int: Maximum number of billboards that can be installed. def test_all_buildings_shorter_than_k(): assert max_billboards([3, 2, 1], 4) == 0 def test_all_buildings_taller_than_k(): assert max_billboards([5, 6, 7], 4) == 3 def test_some_buildings_taller_than_k(): assert max_billboards([5, 1, 6, 3, 7], 4) == 3 def test_heights_with_gaps(): assert max_billboards([1, 4, 1, 4, 1], 4) == 2 def test_mixed_heights(): assert max_billboards([2, 4, 2, 4, 4], 4) == 3 def test_no_buildings(): assert max_billboards([], 4) == 0","solution":"def max_billboards(heights, k): Returns the maximum number of billboards that can be installed such that no two billboards overlap when viewed from the front. Parameters: heights (list of int): Heights of the buildings. k (int): Height of the billboards. Returns: int: Maximum number of billboards that can be installed. if not heights: return 0 max_billboards = 0 for i, height in enumerate(heights): if height >= k: max_billboards += 1 while i + 1 < len(heights) and heights[i + 1] >= k: i += 1 return max_billboards"},{"question":"def remove_invalid_parentheses(s: str) -> List[str]: Remove the minimum number of invalid parentheses to make the string valid. Return all possible results in any order. >>> remove_invalid_parentheses(\\"()())()\\") ['()()()', '(())()'] >>> remove_invalid_parentheses(\\"(a)())()\\") ['(a)()()', '(a())()'] >>> remove_invalid_parentheses(\\")(\\") [\\"\\"] :param s: A string containing lowercase alphabets and parentheses :return: A list of strings with all possible valid combinations","solution":"def remove_invalid_parentheses(s): def is_valid(string): balance = 0 for char in string: if char == '(': balance += 1 elif char == ')': balance -= 1 if balance < 0: return False return balance == 0 level = {s} while True: valid = list(filter(is_valid, level)) if valid: return valid next_level = set() for item in level: for i in range(len(item)): if item[i] in ('(', ')'): next_level.add(item[:i] + item[i+1:]) level = next_level # Example Usage # print(remove_invalid_parentheses(\\"()())()\\")) # Output: ['()()()', '(())()']"},{"question":"from typing import List, Tuple def min_max_diff_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Find the path with the minimum possible maximum height difference from start to end in the grid. >>> min_max_diff_path([ ... [1, 2, 1], ... [2, 3, 2], ... [1, 2, 1] ... ], (0, 0), (2, 2)) 1 >>> min_max_diff_path([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ], (0, 0), (2, 2)) 0 >>> min_max_diff_path([ ... [1, 2, 3], ... [2, 3, 4], ... [3, 4, 5] ... ], (0, 0), (2, 2)) 1 >>> min_max_diff_path([ ... [1, 100, 1], ... [100, 1, 100], ... [1, 100, 1] ... ], (0, 0), (2, 2)) 99 >>> min_max_diff_path([ ... [1, 2, 3, 4], ... [1, 2, 3, 4], ... [1, 2, 3, 4], ... [1, 2, 3, 4] ... ], (0, 0), (3, 3)) 1","solution":"from heapq import heappush, heappop from typing import List, Tuple def min_max_diff_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Find the path with the minimum possible maximum height difference from start to end in the grid. n = len(grid) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] min_heap = [(0, start[0], start[1])] visited = set() while min_heap: max_diff, row, col = heappop(min_heap) if (row, col) == end: return max_diff if (row, col) in visited: continue visited.add((row, col)) for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < n and 0 <= c < n: next_diff = abs(grid[row][col] - grid[r][c]) heappush(min_heap, (max(max_diff, next_diff), r, c))"},{"question":"class WordFilter: def __init__(self, words: List[str]): Initializes the object with the words. pass def f(self, prefix: str, suffix: str) -> int: Returns the index of the word with the given prefix and suffix, or -1 if no such word exists. pass # Test Cases def test_word_filter_found(): wf = WordFilter([\\"apple\\", \\"banana\\", \\"grape\\", \\"cherry\\", \\"pineapple\\", \\"grapefruit\\"]) assert wf.f(\\"gr\\", \\"e\\") == 2 assert wf.f(\\"pi\\", \\"e\\") == 4 def test_word_filter_not_found(): wf = WordFilter([\\"apple\\", \\"banana\\", \\"grape\\", \\"cherry\\", \\"pineapple\\", \\"grapefruit\\"]) assert wf.f(\\"to\\", \\"e\\") == -1 assert wf.f(\\"pi\\", \\"t\\") == -1 def test_word_filter_empty_list(): wf = WordFilter([]) assert wf.f(\\"a\\", \\"b\\") == -1 def test_word_filter_prefix_suffix_exact_match(): wf = WordFilter([\\"apple\\", \\"banana\\", \\"grape\\", \\"cherry\\", \\"pineapple\\", \\"grapefruit\\"]) assert wf.f(\\"apple\\", \\"apple\\") == 0 assert wf.f(\\"banana\\", \\"banana\\") == 1 def test_word_filter_multiple_matches(): wf = WordFilter([\\"abcd\\", \\"abcf\\", \\"abgh\\", \\"abfh\\", \\"abzb\\"]) assert wf.f(\\"ab\\", \\"h\\") == 3 # should return the highest index assert wf.f(\\"ab\\", \\"d\\") == 0 # should return the only match","solution":"class WordFilter: def __init__(self, words): Initializes the object with the words. self.words = words def f(self, prefix, suffix): Returns the index of the word with the given prefix and suffix, or -1 if no such word exists. for i in range(len(self.words) - 1, -1, -1): word = self.words[i] if word.startswith(prefix) and word.endswith(suffix): return i return -1"},{"question":"def encodeString(s: str) -> str: Encodes the given string s as per Mr. Smith's special cipher technique. Parameters: s (str): A string consisting of lowercase letters only. Returns: str: The encoded string. >>> encodeString(\\"a\\") == \\"a\\" >>> encodeString(\\"aaabbcccc\\") == \\"a3b2c4\\" >>> encodeString(\\"hhhhh\\") == \\"h5\\" >>> encodeString(\\"xyz\\") == \\"xyz\\" >>> encodeString(\\"aabcccccaaa\\") == \\"a2bc5a3\\" >>> encodeString(\\"abcdef\\") == \\"abcdef\\" >>> encodeString(\\"\\") == \\"\\" >>> encodeString(\\"aaabbbcc\\") == \\"a3b3c2\\"","solution":"def encodeString(s: str) -> str: Encodes the given string s as per Mr. Smith's special cipher technique. Parameters: s (str): A string consisting of lowercase letters only. Returns: str: The encoded string. if not s: return s # Return the empty string if the input is empty. encoded = [] current_char = s[0] count = 1 for i in range(1, len(s)): if s[i] == current_char: count += 1 else: if count > 1: encoded.append(f\\"{current_char}{count}\\") else: encoded.append(current_char) current_char = s[i] count = 1 # Add the last character (or group) if count > 1: encoded.append(f\\"{current_char}{count}\\") else: encoded.append(current_char) return ''.join(encoded)"},{"question":"def shortest_palindrome(s: str) -> str: Returns the shortest palindrome p such that s can be formed by appending zero or more characters to the end of p. >>> shortest_palindrome(\\"a\\") == \\"a\\" >>> shortest_palindrome(\\"racecar\\") == \\"racecar\\" >>> shortest_palindrome(\\"abcd\\") == \\"dcbabcd\\" >>> shortest_palindrome(\\"race\\") == \\"ecarace\\" >>> shortest_palindrome(\\"\\") == \\"\\" >>> shortest_palindrome(\\"aa\\") == \\"aa\\" >>> shortest_palindrome(\\"ab\\") == \\"bab\\"","solution":"def shortest_palindrome(s): Returns the shortest palindrome p such that s can be formed by appending zero or more characters to the end of p. if s == s[::-1]: return s rev_s = s[::-1] for i in range(len(s)): if s.startswith(rev_s[i:]): return rev_s[:i] + s return \\"\\""},{"question":"def evaluate_expression(s: str) -> int: Evaluates a mathematical expression provided as a string containing non-negative integers and the operators +, -, *, /. Returns the integer result of the expression evaluation. >>> evaluate_expression(\\"3+2*2\\") == 7 >>> evaluate_expression(\\" 3/2 \\") == 1 >>> evaluate_expression(\\"3+5 / 2 \\") == 5 >>> evaluate_expression(\\"10 + 20 * 3 / 4 - 5\\") == 20 >>> evaluate_expression(\\"14-3/2\\") == 13 def test_evaluate_expression(): assert evaluate_expression(\\"3+2*2\\") == 7 assert evaluate_expression(\\" 3/2 \\") == 1 assert evaluate_expression(\\"3+5 / 2 \\") == 5 assert evaluate_expression(\\"10 + 20 * 3 / 4 - 5\\") == 20 assert evaluate_expression(\\"14-3/2\\") == 13 def test_evaluate_expression_empty_string(): assert evaluate_expression(\\"\\") == 0 def test_evaluate_expression_single_number(): assert evaluate_expression(\\"42\\") == 42 assert evaluate_expression(\\"0\\") == 0","solution":"def evaluate_expression(s): Evaluates a mathematical expression provided as a string containing non-negative integers and the operators +, -, *, /. Returns the integer result of the expression evaluation. if not s: return 0 s = s.replace(' ', '') num, stack, sign = 0, [], \\"+\\" for i in range(len(s)): if s[i].isdigit(): num = num * 10 + int(s[i]) if s[i] in \\"+-*/\\" or i == len(s) - 1: if sign == \\"+\\": stack.append(num) elif sign == \\"-\\": stack.append(-num) elif sign == \\"*\\": stack.append(stack.pop() * num) elif sign == \\"/\\": stack.append(int(stack.pop() / num)) sign = s[i] num = 0 return sum(stack)"},{"question":"def minimize_max_workload(workload, servers_count): Distribute the workload among servers to minimize the maximum workload assigned to any server. The workload assigned to each server must be contiguous. Args: workload (List[int]): The amount of work each server can handle. servers_count (int): The number of servers available. Returns: int: The minimized maximum workload assigned to any server. >>> minimize_max_workload([10, 20, 30, 40, 50], 1) 150 >>> minimize_max_workload([10, 10, 10, 10, 10], 5) 10 >>> minimize_max_workload([10, 20, 30, 40, 50], 2) 90 >>> minimize_max_workload([7, 2, 5, 10, 8], 2) 18 >>> minimize_max_workload([1, 2], 4) 2","solution":"def minimize_max_workload(workload, servers_count): def canDistribute(max_workload): server_count = 1 current_workload = 0 for w in workload: if current_workload + w > max_workload: server_count += 1 current_workload = 0 current_workload += w if server_count > servers_count: return False return True low, high = max(workload), sum(workload) while low < high: mid = (low + high) // 2 if canDistribute(mid): high = mid else: low = mid + 1 return low"},{"question":"class CustomStack: def __init__(self, maxSize: int): Initializes the CustomStack object with a maximum size. pass def push(self, x: int) -> None: Place element x on top of the stack if the size of the stack is less than the overall limit of the stack. pass def pop(self) -> int: Remove and return the element on the top of the stack. Return -1 if the stack is empty. pass def increment(self, k: int, val: int) -> None: Increment the bottom k elements of the stack by val. If there are fewer than k elements, increment all the elements of the stack. pass # Unit tests def test_initialization(): stack = CustomStack(3) assert stack.maxSize == 3 assert stack.stack == [] def test_push_within_limit(): stack = CustomStack(3) stack.push(1) stack.push(2) stack.push(3) assert stack.stack == [1, 2, 3] def test_push_beyond_limit(): stack = CustomStack(3) stack.push(1) stack.push(2) stack.push(3) stack.push(4) assert stack.stack == [1, 2, 3] def test_pop_from_non_empty(): stack = CustomStack(3) stack.push(1) stack.push(2) assert stack.pop() == 2 assert stack.stack == [1] def test_pop_from_empty(): stack = CustomStack(3) assert stack.pop() == -1 def test_increment_within_limit(): stack = CustomStack(3) stack.push(1) stack.push(2) stack.push(3) stack.increment(2, 2) assert stack.stack == [3, 4, 3] def test_increment_beyond_limit(): stack = CustomStack(3) stack.push(1) stack.push(2) stack.push(3) stack.increment(5, 3) assert stack.stack == [4, 5, 6] def test_increment_on_empty_stack(): stack = CustomStack(3) stack.increment(2, 5) assert stack.stack == []","solution":"class CustomStack: def __init__(self, maxSize: int): Initializes the CustomStack object with a maximum size. self.maxSize = maxSize self.stack = [] def push(self, x: int) -> None: Place element x on top of the stack if the size of the stack is less than the overall limit of the stack. if len(self.stack) < self.maxSize: self.stack.append(x) def pop(self) -> int: Remove and return the element on the top of the stack. Return -1 if the stack is empty. if self.stack: return self.stack.pop() else: return -1 def increment(self, k: int, val: int) -> None: Increment the bottom k elements of the stack by val. If there are fewer than k elements, increment all the elements of the stack. num_elements_to_increment = min(k, len(self.stack)) for i in range(num_elements_to_increment): self.stack[i] += val"},{"question":"def maxOverlappingEvents(events: List[List[int]]) -> int: Returns the maximum number of overlapping events at any time. >>> maxOverlappingEvents([[1, 4], [2, 5], [7, 9], [5, 8]]) == 2 >>> maxOverlappingEvents([[1, 2], [3, 4]]) == 1 >>> maxOverlappingEvents([[1, 4], [2, 5]]) == 2 >>> maxOverlappingEvents([[1, 4], [2, 5], [3, 6]]) == 3 >>> maxOverlappingEvents([[1, 5], [2, 6], [3, 7], [4, 8]]) == 4 >>> maxOverlappingEvents([[1, 5], [5, 8]]) == 2 >>> maxOverlappingEvents([[1, 3], [2, 5], [4, 7], [5, 8], [3, 6], [6, 9]]) == 4 >>> maxOverlappingEvents([[1, 2], [10, 12], [15, 20], [21, 25], [2, 4]]) == 2","solution":"def maxOverlappingEvents(events): Returns the maximum number of overlapping events at any time. times = [] for start, end in events: times.append((start, 'start')) times.append((end + 1, 'end')) times.sort() current_overlaps = 0 max_overlaps = 0 for time, event_type in times: if event_type == 'start': current_overlaps += 1 max_overlaps = max(max_overlaps, current_overlaps) elif event_type == 'end': current_overlaps -= 1 return max_overlaps"},{"question":"from typing import List def rob(arr: List[int]) -> int: Returns the maximum amount of money you can rob without alerting the police. :param arr: List[int] - an array of positive integers representing money in each house :return: int - the maximum amount of money that can be robbed >>> rob([100]) 100 >>> rob([100, 200]) 200 >>> rob([1, 2, 3, 1]) 4 >>> rob([2, 7, 9, 3, 1]) 12 >>> rob([1, 3, 1, 3, 100]) 103 >>> rob([]) 0 >>> rob([5, 3, 4, 11, 2]) 16","solution":"def rob(arr): Returns the maximum amount of money you can rob without alerting the police. :param arr: List[int] - an array of positive integers representing money in each house :return: int - the maximum amount of money that can be robbed if not arr: return 0 n = len(arr) if n == 1: return arr[0] dp = [0] * len(arr) dp[0] = arr[0] dp[1] = max(arr[0], arr[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + arr[i]) return dp[-1]"},{"question":"def longest_valid_block(arr: List[int], d: int, t: int) -> Tuple[int, int]: Find the starting index and length of the longest valid block. Args: arr: List[int] - A 0-indexed integer array representing colors. d: int - The maximum allowable difference between the maximum and minimum element in the block. t: int - The minimum length of the block. Returns: Tuple[int, int] - A tuple containing the starting index and length of the longest valid block. >>> longest_valid_block([0, 0, 0, 0, 0], 0, 2) (0, 5) >>> longest_valid_block([1, 1, 2, 2, 2, 1], 0, 2) (2, 3) >>> longest_valid_block([1, 2, 3, 4, 5], 0, 2) (0, 0) >>> longest_valid_block([1, 1, 1, 1], 0, 5) (0, 0) >>> longest_valid_block([1, 1, 2, 2, 1, 1], 0, 2) (0, 2) >>> longest_valid_block([1, 2, 2, 2, 3, 1], 2, 2) (1, 3)","solution":"def longest_valid_block(arr, d, t): n = len(arr) longest_block = (0, 0) # (starting index, length) i = 0 while i < n: j = i while j < n and arr[j] == arr[i]: j += 1 block_length = j - i if block_length >= t and (arr[i] <= arr[i] + d): if block_length > longest_block[1]: longest_block = (i, block_length) i = j return longest_block"},{"question":"import heapq class TrapRainWater: def __init__(self, heightMap: List[List[int]]): Initializes the object with the height map. def calculateTrappedWater(self) -> List[List[int]]: Calculates the trapped water for each cell and returns a 2D map. def trap(self, row: int, col: int) -> int: Returns the maximum height of water that can be trapped at the specified cell without causing water overflow to lower neighboring cells. If the location is out of the grid, return -1. >>> height_map = [ ... [1,4,3,1,3,2], ... [3,2,1,4,2,2], ... [2,3,3,2,4,1] ... ] >>> trapRainWater = TrapRainWater(height_map) >>> trapRainWater.trap(1, 2) 2 >>> height_map = [ ... [1,3,1], ... [3,4,3], ... [1,3,1] ... ] >>> trapRainWater = TrapRainWater(height_map) >>> trapRainWater.trap(0, 0) 0 >>> trapRainWater.trap(2, 2) 0 >>> height_map = [ ... [3,3,3,3], ... [3,3,3,3], ... [3,3,3,3], ... [3,3,3,3] ... ] >>> trapRainWater = TrapRainWater(height_map) >>> trapRainWater.trap(1, 1) 0 >>> trapRainWater.trap(2, 2) 0 >>> height_map = [ ... [1,2,3], ... [4,5,6], ... [7,8,9] ... ] >>> trapRainWater = TrapRainWater(height_map) >>> trapRainWater.trap(-1, 0) -1 >>> trapRainWater.trap(3, 1) -1 >>> trapRainWater.trap(1, 3) -1","solution":"import heapq class TrapRainWater: def __init__(self, heightMap): self.heightMap = heightMap if not heightMap or not heightMap[0]: self.m = 0 self.n = 0 else: self.m = len(heightMap) self.n = len(heightMap[0]) self.trappedWaterMap = self.calculateTrappedWater() def calculateTrappedWater(self): if not self.heightMap or self.m < 3 or self.n < 3: return [[0] * self.n for _ in range(self.m)] trappedWater = [[0] * self.n for _ in range(self.m)] visited = [[False] * self.n for _ in range(self.m)] heap = [] # Push all the boundary cells into the heap and mark them as visited. for i in range(self.m): heapq.heappush(heap, (self.heightMap[i][0], i, 0)) heapq.heappush(heap, (self.heightMap[i][self.n-1], i, self.n-1)) visited[i][0] = visited[i][self.n-1] = True for j in range(1, self.n-1): heapq.heappush(heap, (self.heightMap[0][j], 0, j)) heapq.heappush(heap, (self.heightMap[self.m-1][j], self.m-1, j)) visited[0][j] = visited[self.m-1][j] = True # Directions for moving in 4-connectivity: up, down, left, right. directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < self.m and 0 <= ny < self.n and not visited[nx][ny]: trappedWater[nx][ny] = max(0, height - self.heightMap[nx][ny]) newHeight = max(height, self.heightMap[nx][ny]) heapq.heappush(heap, (newHeight, nx, ny)) visited[nx][ny] = True return trappedWater def trap(self, row, col): if row < 0 or row >= self.m or col < 0 or col >= self.n: return -1 return self.trappedWaterMap[row][col]"},{"question":"from typing import List def min_steps_to_reach_end(grid: List[List[int]]) -> int: Returns the minimum number of steps required to reach the bottom-right corner of the grid from the top-left corner. If it is not possible, return -1. >>> min_steps_to_reach_end([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == -1 >>> min_steps_to_reach_end([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 4 >>> min_steps_to_reach_end([[1, 2, 3], [1, 2, 3], [1, 1, 1]]) == 4 >>> min_steps_to_reach_end([[1, 2, 3], [2, 3, 4], [3, 4, 5]]) == -1 >>> min_steps_to_reach_end([[1]]) == 0","solution":"from collections import deque def min_steps_to_reach_end(grid): Returns the minimum number of steps required to reach the bottom-right corner of the grid from the top-left corner. If it is not possible, return -1. if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if row == rows - 1 and col == cols - 1: return dist for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols: if (new_row, new_col) not in visited and grid[new_row][new_col] <= grid[row][col]: visited.add((new_row, new_col)) queue.append((new_row, new_col, dist + 1)) return -1"},{"question":"from collections import Counter def longest_subsequence(s: str, k: int) -> int: Returns the length of the longest subsequence where the difference between the number of characters that occur the most often and the number of characters that occur the least often is at most k. Parameters: s (str): The input string consisting of only lowercase English letters. k (int): The maximum allowable difference between the most frequent and the least frequent characters. Returns: int: The length of the longest subsequence. >>> longest_subsequence(\\"aabbcc\\", 0) 6 >>> longest_subsequence(\\"aabbcc\\", 1) 6 >>> longest_subsequence(\\"abc\\", 0) 3 >>> longest_subsequence(\\"aabbcc\\", -1) 0 >>> longest_subsequence(\\"aabbccddddd\\", 10) 11 >>> longest_subsequence(\\"\\", 2) 0 >>> longest_subsequence(\\"aaaaa\\", 1) 5 >>> longest_subsequence(\\"a\\", 0) 1","solution":"from collections import Counter def longest_subsequence(s, k): Returns the length of the longest subsequence where the difference between the number of characters that occur the most often and the number of characters that occur the least often is at most k. Parameters: s (str): The input string consisting of only lowercase English letters. k (int): The maximum allowable difference between the most frequent and the least frequent characters. Returns: int: The length of the longest subsequence. if not s: return 0 max_len = 0 for freq in range(1, len(s) + 1): counter = Counter(s) subseq_len = sum(min(freq, count) for count in counter.values()) if max(counter.values()) - min(counter.values()) <= k: max_len = max(max_len, subseq_len) return max_len"},{"question":"def min_time_units(tasks: List[List[int]]) -> int: Calculates the minimum number of time units required to finish all tasks. Args: tasks (list of list of int): A 2D list where each sub-list represents a task with its start and end times [start, end]. Returns: int: The minimum number of time units required to finish all tasks. >>> min_time_units([[1, 2], [2, 3], [3, 4]]) 3 >>> min_time_units([[5, 6]]) 1 >>> min_time_units([]) 0 >>> min_time_units([[1, 3], [2, 4], [3, 5]]) 3 >>> min_time_units([[1, 4], [10, 15], [20, 25]]) 3","solution":"def min_time_units(tasks): Calculates the minimum number of time units required to finish all tasks. Args: tasks (list of list of int): A 2D list where each sub-list represents a task with its start and end times [start, end]. Returns: int: The minimum number of time units required to finish all tasks. return len(tasks)"},{"question":"def min_difference(nums: List[int]) -> int: Returns the minimized difference between the max and min elements after removing one element from the array. >>> min_difference([1, 2, 3]) == 0 >>> min_difference([3, 3, 3]) == 0 >>> min_difference([1, 5, 6, 14, 15]) == 5 >>> min_difference([9, 4, 1, 7]) == 2 >>> min_difference([10, 20, 30, 40, 50, 60, 70, 80]) == 50 >>> min_difference([1]) == 0 >>> min_difference([-10, 0, 10, 20]) == 10 >>> min_difference([5, 5, 5, 5, 5]) == 0 >>> min_difference([10, 8, 7, 7, 8, 7, 10]) == 1","solution":"def min_difference(nums): Returns the minimized difference between the max and min elements after removing one element from the array. if len(nums) <= 3: return 0 # If we have 3 or fewer elements, we can remove one to make all elements the same. nums.sort() n = len(nums) # Consider removing one of the following: # Remove the largest element, remove the smallest element, # Remove the second largest element, remove the second smallest element, # Remove the third largest element, remove the third smallest element, # Remove the fourth largest element, remove the fourth smallest element # Removing either of the elements from the above ensures the minimized difference. return min(nums[n-2] - nums[1], nums[n-1] - nums[2], nums[n-3] - nums[0])"},{"question":"def get_next_state(mat): Returns the next state of the m x n binary matrix 'mat' according to the Game of Life rules. >>> get_next_state([ ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0] ... ]) == [ ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0] ... ] >>> get_next_state([ ... [0, 0, 0, 0, 0], ... [0, 0, 1, 0, 0], ... [0, 0, 1, 0, 0], ... [0, 0, 1, 0, 0], ... [0, 0, 0, 0, 0] ... ]) == [ ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 1, 1, 1, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0] ... ] >>> get_next_state([ ... [0, 1, 0, 0], ... [0, 0, 1, 0], ... [1, 1, 1, 0], ... [0, 0, 0, 0] ... ]) == [ ... [0, 0, 0, 0], ... [1, 0, 1, 0], ... [0, 1, 1, 0], ... [0, 1, 0, 0] ... ] >>> get_next_state([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> get_next_state([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == [ ... [1, 0, 1], ... [0, 0, 0], ... [1, 0, 1] ... ] pass","solution":"def get_next_state(mat): Returns the next state of the m x n binary matrix 'mat' according to the Game of Life rules. m, n = len(mat), len(mat[0]) dirs = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] def count_live_neighbors(x, y): count = 0 for dx, dy in dirs: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and mat[nx][ny] == 1: count += 1 return count next_state = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): live_neighbors = count_live_neighbors(i, j) if mat[i][j] == 1: if live_neighbors < 2 or live_neighbors > 3: next_state[i][j] = 0 else: next_state[i][j] = 1 elif mat[i][j] == 0 and live_neighbors == 3: next_state[i][j] = 1 return next_state"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a well-formed arithmetic expression containing +, -, *, /, (, ) and digits. The integer division should truncate toward zero. :param expression: str, arithmetic expression to be evaluated :return: int, result of the evaluation >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"3/2\\") 1 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") 23 >>> evaluate_expression(\\"2*(3+(4*5))\\") 46 >>> evaluate_expression(\\"10+(2*6)/4\\") 13 >>> evaluate_expression(\\"10/3\\") 3 >>> evaluate_expression(\\"18/7\\") 2 >>> evaluate_expression(\\"123+456*789\\") 123 + 456 * 789 >>> evaluate_expression(\\"100/10*10\\") 100 >>> evaluate_expression(\\"10-37/5\\") 10 - 37 // 5 >>> evaluate_expression(\\"(1-2)*5\\") -5","solution":"def evaluate_expression(expression): Evaluates a well-formed arithmetic expression containing +, -, *, /, (, ) and digits. The integer division should truncate toward zero. :param expression: str, arithmetic expression to be evaluated :return: int, result of the evaluation def calc(op, second, first): if op == '+': return first + second elif op == '-': return first - second elif op == '*': return first * second elif op == '/': return int(first / second) # integer division truncating toward zero def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def apply_operations(operators, values): while operators and operators[-1] != '(': values.append(calc(operators.pop(), values.pop(), values.pop())) operators = [] values = [] i = 0 while i < len(expression): if expression[i].isdigit(): j = i while j < len(expression) and expression[j].isdigit(): j += 1 values.append(int(expression[i:j])) i = j - 1 elif expression[i] == '(': operators.append(expression[i]) elif expression[i] == ')': apply_operations(operators, values) operators.pop() # popping the '(' elif expression[i] in ('+', '-', '*', '/'): while operators and precedence(operators[-1]) >= precedence(expression[i]): values.append(calc(operators.pop(), values.pop(), values.pop())) operators.append(expression[i]) i += 1 apply_operations(operators, values) return values[-1]"},{"question":"from typing import List from collections import Counter import re def count_anagrams(arr: List[str], target: str) -> int: Returns the number of strings in the array that are anagrams of the target. Ignores case and non-alphabetic characters. >>> count_anagrams([\\"Listen\\", \\"Silent\\", \\"Enlist\\"], \\"inlets\\") == 3 >>> count_anagrams([\\"Listen\\", \\"Apple\\", \\"Silent\\", \\"Monkey\\"], \\"inlets\\") == 2 >>> count_anagrams([\\"Hello\\", \\"World\\", \\"Python\\"], \\"orange\\") == 0 >>> count_anagrams([\\"L!i@st#en\\", \\"Sil%en^t\\", \\"E&n*l(i)s_t\\"], \\"Inlets!\\") == 3 >>> count_anagrams([], \\"target\\") == 0 >>> count_anagrams([\\"listen\\", \\"silent\\"], \\"\\") == 0 >>> count_anagrams([\\"!@#\\", \\"^&*()\\"], \\"!@#%^&*()\\") == 2","solution":"from collections import Counter import re def count_anagrams(arr, target): Returns the number of strings in the array that are anagrams of the target. Ignores case and non-alphabetic characters. def clean_string(s): return ''.join(re.findall(r'[a-zA-Z]', s)).lower() cleaned_target = clean_string(target) target_counter = Counter(cleaned_target) count = 0 for string in arr: cleaned_string = clean_string(string) if Counter(cleaned_string) == target_counter: count += 1 return count"},{"question":"def evaluateExpression(expression: str) -> int: Evaluates a given arithmetic expression string containing positive integers, parentheses, and the binary operators '+' and '-'. >>> evaluateExpression(\\"1 + 2\\") 3 >>> evaluateExpression(\\"1 + (2 - 3) + 4\\") 4 >>> evaluateExpression(\\"42\\") 42 >>> evaluateExpression(\\"1 + (2 + (3 - 4))\\") 2 >>> evaluateExpression(\\"(1 + (2 + (3 + (4 - 5)))) + 6\\") 11","solution":"def evaluateExpression(expression): Evaluates a given arithmetic expression string containing positive integers, parentheses, and the binary operators '+' and '-'. def evaluate(tokens): stack = [] num = 0 sign = 1 # 1 represents positive, -1 represents negative result = 0 while tokens: token = tokens.pop(0) if token.isdigit(): num = int(token) result += sign * num elif token == '+': sign = 1 elif token == '-': sign = -1 elif token == '(': # Evaluate the expression inside the parenthesis result += sign * evaluate(tokens) elif token == ')': # End of the current parenthesis evaluation break return result tokens = [] idx = 0 while idx < len(expression): char = expression[idx] if char.isdigit(): num = char while idx + 1 < len(expression) and expression[idx + 1].isdigit(): num += expression[idx + 1] idx += 1 tokens.append(num) elif char in \\"+-()\\": tokens.append(char) idx += 1 return evaluate(tokens)"},{"question":"def is_complete_binary_tree(arr): Return true if the input level order traversal list represents a complete binary tree, else false. >>> is_complete_binary_tree([1, 2, 3, 4, 5, 6]) True >>> is_complete_binary_tree([1, 2, 3, 4, 5, None, 7]) False >>> is_complete_binary_tree([1, 2, 3, 4, 5, 6, 7]) True >>> is_complete_binary_tree([1]) True >>> is_complete_binary_tree([]) True >>> is_complete_binary_tree([1, 2, 3, 4, 5, None, None]) True >>> is_complete_binary_tree([1, 2, 3, 4, None, None, 7]) False","solution":"def is_complete_binary_tree(arr): Return true if the input level order traversal list represents a complete binary tree, else false. n = len(arr) if n == 0: return True # A complete binary tree can have null values at the end, but not between nodes # Traverse the list, stopping if we get a null and ensuring no node appears after a null end_of_tree_found = False for i in range(n): if arr[i] is None: end_of_tree_found = True elif end_of_tree_found: return False return True"},{"question":"def can_jump(nums: List[int]) -> bool: Determine if you can reach the last index in the array. :param nums: List[int] - List of integers where each element represents the max number of steps you can jump forward :return: bool - True if you can reach the last index, otherwise False. >>> can_jump([2, 3, 1, 1, 4]) == True >>> can_jump([3, 2, 1, 0, 4]) == False >>> can_jump([0]) == True >>> can_jump([10, 1, 0, 0, 0]) == True >>> can_jump([1, 0, 0, 0, 0]) == False >>> can_jump([2, 5, 0, 0]) == True >>> can_jump([1, 2, 3]) == True","solution":"def can_jump(nums): Determine if you can reach the last index in the array. :param nums: List[int] - List of integers where each element represents the max number of steps you can jump forward :return: bool - True if you can reach the last index, otherwise False. max_reachable = 0 for i, jump in enumerate(nums): if i > max_reachable: return False max_reachable = max(max_reachable, i + jump) return True"},{"question":"def minOperations(num1: int, num2: int) -> int: Returns the minimum number of operations needed to reduce \`num1\` to zero using given constraints or -1 if it is impossible. >>> minOperations(8, 3) 1 >>> minOperations(10, 4) 2 >>> minOperations(10, 1) -1 >>> minOperations(0, 3) 0 >>> minOperations(1023, 11) 10 >>> minOperations(17, 5) 2","solution":"def minOperations(num1, num2): operations = 0 while num1 > 0: if num2 == 0: return -1 k = 0 while (1 << (k+1)) <= num1: k += 1 num1 -= (1 << k) num2 -= 1 operations += 1 return operations"},{"question":"def count_unique_reactions(element: str, effectPairs: List[List[str]]) -> int: Returns the number of unique special reactions in the element. :param element: String, the elemental string. :param effectPairs: List of pairs of characters representing special reactions. :return: Integer, number of unique special reactions. >>> count_unique_reactions(\\"abcabc\\", [[\\"a\\", \\"b\\"], [\\"b\\", \\"c\\"]]) == 2 >>> count_unique_reactions(\\"abcabc\\", [[\\"d\\", \\"e\\"], [\\"f\\", \\"g\\"]]) == 0 >>> count_unique_reactions(\\"abcabc\\", [[\\"a\\", \\"b\\"]]) == 1 >>> count_unique_reactions(\\"abcabc\\", [[\\"a\\", \\"b\\"], [\\"b\\", \\"c\\"], [\\"c\\", \\"a\\"]]) == 3 >>> count_unique_reactions(\\"ababab\\", [[\\"a\\", \\"b\\"], [\\"b\\", \\"a\\"]]) == 2 >>> count_unique_reactions(\\"aabaaca\\", [[\\"a\\", \\"a\\"], [\\"c\\", \\"a\\"]]) == 2","solution":"def count_unique_reactions(element, effectPairs): Returns the number of unique special reactions in the element. :param element: String, the elemental string. :param effectPairs: List of pairs of characters representing special reactions. :return: Integer, number of unique special reactions. unique_reactions = set() effects_set = {(pair[0], pair[1]) for pair in effectPairs} for i in range(len(element) - 1): if (element[i], element[i + 1]) in effects_set: unique_reactions.add(element[i] + element[i + 1]) return len(unique_reactions)"},{"question":"def check_tic_tac_toe(board: List[List[str]]) -> str: Check the state of a Tic-Tac-Toe game. Args: board : List[List[str]] : 2D list representing the Tic-Tac-Toe board Returns: str : Result of the game ('X', 'O', 'Draw', or 'Pending') >>> check_tic_tac_toe([['X', 'X', 'X'], ['O', '', ''], ['O', '', '']]) == 'X' >>> check_tic_tac_toe([['X', 'O', 'X'], ['X', 'O', ''], ['O', 'O', '']]) == 'O' >>> check_tic_tac_toe([['X', 'O', ''], ['O', 'X', ''], ['', 'O', 'X']]) == 'X' >>> check_tic_tac_toe([['X', 'O', 'O'], ['O', 'X', 'X'], ['X', 'X', 'O']]) == 'Draw' >>> check_tic_tac_toe([['X', 'O', ''], ['X', '', 'O'], ['O', 'X', '']]) == 'Pending'","solution":"def check_tic_tac_toe(board): Check the state of a Tic-Tac-Toe game. Args: board : List[List[str]] : 2D list representing the Tic-Tac-Toe board Returns: str : Result of the game ('X', 'O', 'Draw', or 'Pending') n = len(board) def check_winner(char): # Check rows and columns for i in range(n): if all(board[i][j] == char for j in range(n)) or all(board[j][i] == char for j in range(n)): return True # Check diagonals if all(board[i][i] == char for i in range(n)) or all(board[i][n-1-i] == char for i in range(n)): return True return False if check_winner('X'): return 'X' if check_winner('O'): return 'O' # Check for any empty cells for row in board: if '' in row: return 'Pending' return 'Draw'"},{"question":"def min_jumps(arr: List[int]) -> int: Returns the minimum number of jumps required for the frog to reach the last position of the array. If it is not possible to reach the last position, return -1. :param arr: List[int] - array of integers representing the number of steps a frog can jump :return: int - minimum number of jumps to reach the last position, or -1 if not possible >>> min_jumps([2, 3, 1, 1, 4]) 2 >>> min_jumps([3, 2, 1, 0, 4]) -1 >>> min_jumps([0]) 0 >>> min_jumps([2, 1, 1, 1, 1]) 3 >>> min_jumps([1, 4, 3, 2, 6, 7, 6, 8, 9, 10]) 3 >>> min_jumps([0, 2, 3, 1, 1, 1]) -1 >>> min_jumps([2, 0, 0, 1, 4]) -1","solution":"def min_jumps(arr): Returns the minimum number of jumps required for the frog to reach the last position of the array. If it is not possible to reach the last position, return -1. :param arr: List[int] - array of integers representing the number of steps a frog can jump :return: int - minimum number of jumps to reach the last position, or -1 if not possible n = len(arr) if n == 1: return 0 if arr[0] == 0: return -1 jumps = 0 max_reach = 0 steps = 0 for i in range(n): max_reach = max(max_reach, i + arr[i]) if i == steps: if i == max_reach: return -1 steps = max_reach jumps += 1 if steps >= n - 1: return jumps return -1"},{"question":"def max_mushrooms(grid): Returns the maximum number of mushrooms Mario can collect from the first column to the last column. >>> max_mushrooms([[0, 2, 2, 2]]) == 6 >>> max_mushrooms([[1], [2], [3], [4]]) == 4 >>> max_mushrooms([ [1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2]]) == 16 >>> max_mushrooms([]) == 0 >>> max_mushrooms([[0, 0], [0, 0]]) == 0 >>> max_mushrooms([ [1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 3 >>> max_mushrooms([ [10, 10, 2], [1, 50, 1], [5, 1, 100]]) == 160","solution":"def max_mushrooms(grid): Returns the maximum number of mushrooms Mario can collect from the first column to the last column. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a memoization table to store the maximum mushrooms collected to each cell dp = [[0] * n for _ in range(m)] # Initialize the first column of dp with the values of the grid for i in range(m): dp[i][0] = grid[i][0] # Fill the dp table for j in range(1, n): for i in range(m): max_from_left = dp[i][j-1] # from left if i > 0: max_from_left_up = dp[i-1][j-1] # from left-up else: max_from_left_up = 0 if i < m-1: max_from_left_down = dp[i+1][j-1] # from left-down else: max_from_left_down = 0 dp[i][j] = grid[i][j] + max(max_from_left, max_from_left_up, max_from_left_down) # The result is the maximum value in the last column return max(dp[i][n-1] for i in range(m))"},{"question":"from typing import List def trapRainWater(heightMap: List[List[int]]) -> int: Calculate the amount of rainwater trapped in a given grid of heights. >>> trapRainWater([ ... [1, 4, 3], ... [3, 2, 5], ... [4, 3, 6] ... ]) == 1 >>> trapRainWater([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 0 >>> trapRainWater([[0]]) == 0 >>> trapRainWater([ ... [1, 4, 3, 1, 3, 2], ... [3, 2, 1, 3, 2, 4], ... [2, 3, 3, 2, 3, 1] ... ]) == 4 >>> trapRainWater([[1, 2, 3, 4, 3, 2, 1]]) == 0 >>> trapRainWater([[1], [2], [3], [4], [3], [2], [1]]) == 0 >>> trapRainWater([]) == 0 pass","solution":"import heapq def trapRainWater(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False]*n for _ in range(m)] heap = [] for i in range(m): for j in range(n): if i == 0 or i == m-1 or j == 0 or j == n-1: heapq.heappush(heap, (heightMap[i][j], i, j)) visited[i][j] = True directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] water_trapped = 0 while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: water_trapped += max(0, height - heightMap[nx][ny]) visited[nx][ny] = True heapq.heappush(heap, (max(height, heightMap[nx][ny]), nx, ny)) return water_trapped"},{"question":"def count_students_not_in_correct_positions(arr): Returns the number of students not standing in their correct positions after sorting the array in non-decreasing order. Parameters: arr (list): List of integers representing student heights. Returns: int: Number of students not in correct positions. >>> count_students_not_in_correct_positions([1, 1, 4, 2, 1, 3]) 3 >>> count_students_not_in_correct_positions([1, 2, 3, 4, 5]) 0 >>> count_students_not_in_correct_positions([5, 4, 3, 2, 1]) 4 >>> count_students_not_in_correct_positions([2, 2, 2, 2]) 0 >>> count_students_not_in_correct_positions([1, 3, 2, 4]) 2 >>> count_students_not_in_correct_positions([]) 0","solution":"def count_students_not_in_correct_positions(arr): Returns the number of students not standing in their correct positions after sorting the array in non-decreasing order. Parameters: arr (list): List of integers representing student heights. Returns: int: Number of students not in correct positions. sorted_arr = sorted(arr) count = 0 for original, sorted_value in zip(arr, sorted_arr): if original != sorted_value: count += 1 return count"},{"question":"def captureRegions(board: List[List[str]]) -> None: Modify the input board. In a captured region on the board, all \`O\`s must be flipped to \`X\`s. Args: board (List[List[str]]): The grid of characters \`X\` and \`O\`. Example: >>> board = [ ... [\\"X\\", \\"X\\", \\"X\\", \\"X\\"], ... [\\"X\\", \\"O\\", \\"O\\", \\"X\\"], ... [\\"X\\", \\"X\\", \\"O\\", \\"X\\"], ... [\\"X\\", \\"O\\", \\"X\\", \\"X\\"] ... ] >>> captureRegions(board) >>> board [['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'O', 'X', 'X']] # Unit Tests def test_captureRegions_1(): board = [ [\\"X\\", \\"X\\", \\"X\\", \\"X\\"], [\\"X\\", \\"O\\", \\"O\\", \\"X\\"], [\\"X\\", \\"X\\", \\"O\\", \\"X\\"], [\\"X\\", \\"O\\", \\"X\\", \\"X\\"] ] captureRegions(board) assert board == [ [\\"X\\", \\"X\\", \\"X\\", \\"X\\"], [\\"X\\", \\"X\\", \\"X\\", \\"X\\"], [\\"X\\", \\"X\\", \\"X\\", \\"X\\"], [\\"X\\", \\"O\\", \\"X\\", \\"X\\"] ] def test_captureRegions_2(): board = [ [\\"X\\", \\"X\\", \\"X\\"], [\\"X\\", \\"O\\", \\"X\\"], [\\"X\\", \\"X\\", \\"X\\"] ] captureRegions(board) assert board == [ [\\"X\\", \\"X\\", \\"X\\"], [\\"X\\", \\"X\\", \\"X\\"], [\\"X\\", \\"X\\", \\"X\\"] ] def test_captureRegions_3(): board = [ [\\"X\\", \\"O\\", \\"X\\"], [\\"O\\", \\"O\\", \\"O\\"], [\\"X\\", \\"O\\", \\"X\\"] ] captureRegions(board) assert board == [ [\\"X\\", \\"O\\", \\"X\\"], [\\"O\\", \\"O\\", \\"O\\"], [\\"X\\", \\"O\\", \\"X\\"] ] def test_captureRegions_4(): board = [ [\\"O\\", \\"O\\", \\"O\\"], [\\"O\\", \\"X\\", \\"O\\"], [\\"O\\", \\"O\\", \\"O\\"] ] captureRegions(board) assert board == [ [\\"O\\", \\"O\\", \\"O\\"], [\\"O\\", \\"X\\", \\"O\\"], [\\"O\\", \\"O\\", \\"O\\"] ] def test_captureRegions_empty(): board = [] captureRegions(board) assert board == []","solution":"from typing import List def captureRegions(board: List[List[str]]) -> None: if not board: return rows, cols = len(board), len(board[0]) def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or board[r][c] != 'O': return board[r][c] = 'E' # Mark this 'O' as escaped because it is connected to the border # Perform DFS in all four directions dfs(r+1, c) dfs(r-1, c) dfs(r, c+1) dfs(r, c-1) # Start DFS from 'O's on the borders for i in range(rows): dfs(i, 0) dfs(i, cols-1) for j in range(cols): dfs(0, j) dfs(rows-1, j) # Flip all 'O' to 'X' (captured) and all 'E' back to 'O' (escaped) for i in range(rows): for j in range(cols): if board[i][j] == 'O': board[i][j] = 'X' elif board[i][j] == 'E': board[i][j] = 'O'"},{"question":"from typing import List def has_subarray_with_sum(nums: List[int], k: int) -> bool: Determines if there exists a contiguous subarray whose sum is equal to k. :param nums: List of integers :param k: Integer, target sum :return: Boolean, True if such subarray exists, otherwise False >>> has_subarray_with_sum([1, 2, 3, 4, 5], 9) True >>> has_subarray_with_sum([1, 2, 3, 4, 5], 20) False >>> has_subarray_with_sum([5], 5) True >>> has_subarray_with_sum([5], 3) False >>> has_subarray_with_sum([0, 1, 2, 3], 0) True >>> has_subarray_with_sum([-1, -2, -3, -4, -5], -10) True >>> has_subarray_with_sum([1, -1, 2, 3, -2, 4], 5) True","solution":"def has_subarray_with_sum(nums, k): Determines if there exists a contiguous subarray whose sum is equal to k. :param nums: List of integers :param k: Integer, target sum :return: Boolean, True if such subarray exists, otherwise False current_sum = 0 sum_dict = {0: 1} for num in nums: current_sum += num if current_sum - k in sum_dict: return True sum_dict[current_sum] = sum_dict.get(current_sum, 0) + 1 return False"},{"question":"def min_swaps_to_make_equal(arr1, arr2): Given two integer arrays arr1 and arr2 of the same length, return the minimum number of operations needed to make both arrays equal. If it's not possible, return -1. Example: >>> min_swaps_to_make_equal([1, 2, 3, 4], [1, 3, 2, 4]) 1 >>> min_swaps_to_make_equal([4, 3, 2, 1], [1, 2, 3, 4]) 2","solution":"def min_swaps_to_make_equal(arr1, arr2): Returns the minimum number of operations needed to make arr1 equal to arr2. If it's not possible, returns -1. if sorted(arr1) != sorted(arr2): return -1 count = 0 i = 0 while i < len(arr1): if arr1[i] != arr2[i]: idx_to_swap = arr1.index(arr2[i], i) arr1[i], arr1[idx_to_swap] = arr1[idx_to_swap], arr1[i] count += 1 else: i += 1 return count"},{"question":"def word_break(s: str, dict: List[str]) -> List[str]: Given a string \`s\` and a list of words \`dict\`, return all the sentences that can be formed by concatenating words from \`dict\`. Each word from \`dict\` can be used multiple times in the concatenation, and the sentences should be sorted lexicographically. The words in the sentences should be separated by a single space. >>> word_break(\\"catsanddog\\", [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]) [\\"cat sand dog\\", \\"cats and dog\\"] >>> word_break(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) [\\"pine apple pen apple\\", \\"pine applepen apple\\", \\"pineapple pen apple\\"] >>> word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) [] >>> word_break(\\"aab\\", [\\"a\\", \\"aa\\", \\"b\\"]) [\\"a a b\\", \\"aa b\\"] >>> word_break(\\"aaaa\\", [\\"a\\"]) [\\"a a a a\\"]","solution":"def word_break(s, dict): from collections import defaultdict def _word_break(s, dict, memo): if s in memo: return memo[s] if not s: return [''] res = [] for word in dict: if s.startswith(word): sublist = _word_break(s[len(word):], dict, memo) for sub in sublist: res.append(word + (\\"\\" if sub == \\"\\" else \\" \\") + sub) memo[s] = sorted(res) return memo[s] memo = {} return _word_break(s, dict, memo)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_sum_path(root: TreeNode) -> int: Given a binary tree where each node contains an integer value, returns the maximum sum path from the root node to any leaf node. A leaf node is a node that does not have any children. >>> root = TreeNode(1) >>> max_sum_path(root) 1 >>> root = TreeNode(1, TreeNode(2, TreeNode(4))) >>> max_sum_path(root) 7 >>> root = TreeNode(1, None, TreeNode(3, None, TreeNode(5))) >>> max_sum_path(root) 9 >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> max_sum_path(root) 4 >>> root = TreeNode(1, TreeNode(2, TreeNode(4, None, TreeNode(7))), TreeNode(3, TreeNode(5), TreeNode(6))) >>> max_sum_path(root) 14","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_sum_path(root): Returns the maximum sum path from root to any leaf node. if root is None: return 0 if root.left is None and root.right is None: return root.val left_sum = max_sum_path(root.left) right_sum = max_sum_path(root.right) return root.val + max(left_sum, right_sum)"},{"question":"def increasing_triplet(nums: List[int]) -> bool: Returns true if there exists a subsequence of length 3 that forms an increasing triplet subsequence. Otherwise, returns false. >>> increasing_triplet([1, 2, 3, 4, 5]) == True >>> increasing_triplet([5, 4, 3, 2, 1]) == False >>> increasing_triplet([2, 1, 5, 0, 4, 6]) == True >>> increasing_triplet([-1, -2, -3, -4, -5]) == False >>> increasing_triplet([-1, 0, -2, 2, 3]) == True >>> increasing_triplet([1, 1, 1, 1]) == False >>> increasing_triplet([1, 2, 2, 3]) == True >>> increasing_triplet([1, 2]) == False >>> increasing_triplet([1]) == False","solution":"def increasing_triplet(nums): Returns true if there exists a subsequence of length 3 that forms an increasing triplet subsequence. Otherwise, returns false. if not nums or len(nums) < 3: return False first = float('inf') second = float('inf') for n in nums: if n <= first: first = n elif n <= second: second = n else: return True return False"},{"question":"def longest_word(words: List[str]) -> str: Find the longest word that can be built one character at a time by other words in words. Return the longest word that can be built from other words in the array. >>> longest_word([\\"a\\", \\"banana\\", \\"app\\", \\"appl\\", \\"ap\\", \\"apply\\", \\"apple\\"]) == \\"apple\\" >>> longest_word([\\"w\\", \\"wo\\", \\"wor\\", \\"worl\\", \\"world\\", \\"word\\"]) == \\"world\\" >>> longest_word([]) == \\"\\" >>> longest_word([\\"cat\\", \\"bat\\", \\"rat\\"]) == \\"\\" >>> longest_word([\\"a\\", \\"ab\\", \\"abc\\", \\"abd\\", \\"abcd\\", \\"abcde\\"]) == \\"abcde\\" >>> longest_word([\\"a\\"]) == \\"a\\" >>> longest_word([\\"a\\", \\"x\\", \\"c\\", \\"v\\", \\"b\\"]) == \\"a\\"","solution":"def longest_word(words): Find the longest word that can be built one character at a time by other words in words. Return the longest word that can be built from other words in the array. words.sort() word_set = {\\"\\"} longest = \\"\\" for word in words: if word[:-1] in word_set: word_set.add(word) if len(word) > len(longest): longest = word return longest"},{"question":"from typing import List def find_concatenations(words: List[str], n: int) -> List[str]: Returns all unique concatenations of words from the dictionary that are exactly length n, sorted lexicographically. Each word can be used at most once in each concatenation. Parameters: words (list of str): The dictionary of words. n (int): The target length of concatenations. Returns: list of str: All valid concatenations sorted lexicographically. >>> find_concatenations([\\"cat\\", \\"dog\\", \\"fish\\"], 6) [\\"catdog\\", \\"dogcat\\"] >>> find_concatenations([\\"cat\\", \\"dog\\"], 5) [] >>> find_concatenations([\\"sing\\", \\"song\\"], 4) [\\"sing\\", \\"song\\"] >>> find_concatenations([\\"a\\", \\"b\\", \\"c\\"], 2) [\\"ab\\", \\"ac\\", \\"ba\\", \\"bc\\", \\"ca\\", \\"cb\\"] >>> find_concatenations([\\"x\\", \\"y\\", \\"z\\"], 1) [\\"x\\", \\"y\\", \\"z\\"] >>> find_concatenations([], 4) [] >>> find_concatenations([\\"a\\", \\"a\\", \\"b\\"], 2) [\\"aa\\", \\"ab\\", \\"ba\\"]","solution":"from itertools import permutations def find_concatenations(words, n): Returns all unique concatenations of words from the dictionary that are exactly length n, sorted lexicographically. Each word can be used at most once in each concatenation. Parameters: words (list of str): The dictionary of words. n (int): The target length of concatenations. Returns: list of str: All valid concatenations sorted lexicographically. result = set() for r in range(1, len(words) + 1): for perm in permutations(words, r): concat_str = ''.join(perm) if len(concat_str) == n: result.add(concat_str) return sorted(result)"},{"question":"from typing import List from collections import Counter def sum_of_elements_with_minimum_frequency(nums: List[int], threshold: int) -> int: Return the sum of all elements in nums that have the minimum frequency greater than or equal to threshold. >>> sum_of_elements_with_minimum_frequency([1, 2, 2, 3, 3, 3], 2) 5 >>> sum_of_elements_with_minimum_frequency([1, 2, 3, 4, 5], 1) 15 >>> sum_of_elements_with_minimum_frequency([1, 1, 1, 1, 1], 5) 1 >>> sum_of_elements_with_minimum_frequency([1, 2, 2, 3, 3, 3], 3) 3 >>> sum_of_elements_with_minimum_frequency([], 1) 0 >>> sum_of_elements_with_minimum_frequency([1, 2, 2, 3, 3, 3], 6) 0 >>> sum_of_elements_with_minimum_frequency([-1, -2, -2, -3, -3, -3], 2) -5 >>> sum_of_elements_with_minimum_frequency([1, 2, 3, 4, 5], 10) 0","solution":"def sum_of_elements_with_minimum_frequency(nums, threshold): from collections import Counter # Count the frequency of each element freq = Counter(nums) # Filter elements with frequency greater than or equal to the threshold filtered_elements = [num for num, count in freq.items() if count >= threshold] # Sum the filtered elements return sum(filtered_elements)"},{"question":"def kth_smallest(matrix: List[List[int]], k: int) -> int: Returns the kth smallest number in an n x n matrix where each row is sorted in increasing order. :param matrix: List[List[int]], the n x n matrix :param k: int, the kth smallest number to find :return: int, the kth smallest number in the matrix >>> kth_smallest([ ... [1, 5, 9], ... [10, 11, 13], ... [12, 13, 15] ... ], 8) 13 >>> kth_smallest([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ], 5) 5 >>> kth_smallest([ ... [1, 3, 7], ... [2, 6, 8], ... [5, 9, 10] ... ], 4) 5 >>> kth_smallest([[3]], 1) 3 >>> kth_smallest([ ... [1, 2], ... [1, 3] ... ], 2) 1 >>> kth_smallest([ ... [1, 9], ... [2, 10] ... ], 2) 2","solution":"import heapq def kth_smallest(matrix, k): Returns the kth smallest number in an n x n matrix where each row is sorted in increasing order. :param matrix: List[List[int]], the n x n matrix :param k: int, the kth smallest number to find :return: int, the kth smallest number in the matrix n = len(matrix) min_heap = [] # Initialize the heap with the first element of each row. for r in range(min(k, n)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract the min k times. for _ in range(k - 1): num, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return heapq.heappop(min_heap)[0]"},{"question":"def has_single_peak(nums: List[int]) -> bool: Determines if there is a single peak element in a circular array. A peak element is an element that is greater than its neighbors. In a circular array, the neighbors of an element at index \`i\` are: - at index \`(i - 1 + n) % n\` - at index \`(i + 1) % n\` Returns \`True\` if there is a single peak element, otherwise \`False\`. >>> has_single_peak([1, 2, 3, 1]) True >>> has_single_peak([3, 1, 2]) True >>> has_single_peak([2, 1, 3]) True >>> has_single_peak([1, 1, 1]) False >>> has_single_peak([1, 3, 2, 3, 1]) False >>> has_single_peak([1]) False >>> has_single_peak([2, 1]) True >>> has_single_peak([1, 2]) True >>> has_single_peak([2, 2, 2, 2]) False","solution":"def has_single_peak(nums): Determines if there is a single peak element in a circular array. A peak element is an element that is greater than its neighbors. In a circular array, the neighbors of an element at index \`i\` are: - at index \`(i-1 + n) % n\` - at index \`(i+1) % n\` Returns \`True\` if there is a single peak element, otherwise \`False\`. n = len(nums) peak_count = 0 for i in range(n): prev_idx = (i - 1 + n) % n next_idx = (i + 1) % n if nums[i] > nums[prev_idx] and nums[i] > nums[next_idx]: peak_count += 1 if peak_count > 1: return False return peak_count == 1"},{"question":"def min_steps_to_unique_chars(s: str) -> int: Determines the minimum number of step operations required to make all characters in the string unique. >>> min_steps_to_unique_chars(\\"abcde\\") == 0 >>> min_steps_to_unique_chars(\\"aaaaa\\") == 4 >>> min_steps_to_unique_chars(\\"aabbcc\\") == 3 >>> min_steps_to_unique_chars(\\"\\") == 0 >>> min_steps_to_unique_chars(\\"a\\") == 0 >>> min_steps_to_unique_chars(\\"abcabcabc\\") == 6","solution":"def min_steps_to_unique_chars(s: str) -> int: Determines the minimum number of step operations required to make all characters in the string unique. Parameters: s (str): The input string consisting of lowercase English letters. Returns: int: The minimum number of steps required to make all characters unique. count = 0 seen = set() for char in s: if char in seen: count += 1 else: seen.add(char) return count"},{"question":"def max_height_difference(heights: List[int]) -> int: Returns the maximum difference in heights between any two buildings such that the taller building is to the right of the shorter one. >>> max_height_difference([1, 2, 3, 4, 5]) 4 >>> max_height_difference([5, 1, 9, 3, 7, 4]) 8 >>> max_height_difference([1, 3, 2, 5, 4, 8]) 7 >>> max_height_difference([6, 5, 4, 3, 2, 1]) 0 >>> max_height_difference([7, 2, 14, 6, 5, 11]) 12 >>> max_height_difference([1, 100]) 99 >>> max_height_difference([100, 1]) 0 >>> max_height_difference([7, 1, 5, 3, 6, 4]) 5 pass # implement the function here","solution":"def max_height_difference(heights): Returns the maximum difference in heights between any two buildings such that the taller building is to the right of the shorter one. max_diff = 0 min_height = heights[0] for height in heights: if height > min_height: max_diff = max(max_diff, height - min_height) min_height = min(min_height, height) return max_diff"},{"question":"def can_construct(s: str, word_list: List[str]) -> bool: Determine if the string \`s\` can be constructed by concatenating words from the list such that each word can be used at most once. >>> can_construct(\\"applebanana\\", [\\"apple\\", \\"banana\\"]) == True >>> can_construct(\\"dogcat\\", [\\"cat\\", \\"dog\\"]) == True >>> can_construct(\\"leetcode\\", [\\"leet\\", \\"code\\"]) == True >>> can_construct(\\"applebanana\\", [\\"apple\\", \\"ban\\"]) == False >>> can_construct(\\"dogcat\\", [\\"cat\\", \\"dog\\", \\"mouse\\"]) == True >>> can_construct(\\"leetcode\\", [\\"leet\\", \\"code\\", \\"eet\\"]) == True >>> can_construct(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == False >>> can_construct(\\"\\", [\\"apple\\", \\"banana\\"]) == True >>> can_construct(\\"appleapple\\", [\\"apple\\", \\"banana\\"]) == False >>> can_construct(\\"apple\\", [\\"apple\\"]) == True >>> can_construct(\\"banana\\", [\\"apple\\"]) == False","solution":"def can_construct(s, word_list): from collections import Counter def backtrack(remaining_s, counter): if not remaining_s: return True for word in counter: if counter[word] > 0 and remaining_s.startswith(word): counter[word] -= 1 if backtrack(remaining_s[len(word):], counter): return True counter[word] += 1 return False word_counter = Counter(word_list) return backtrack(s, word_counter)"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: 'TreeNode' = None, right: 'TreeNode' = None): self.val = val self.left = left self.right = right def right_side_view(root: Optional[TreeNode]) -> List[int]: Returns an array of integers representing the right side view of the binary tree. >>> right_side_view(None) [] >>> right_side_view(TreeNode(1)) [1] >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> right_side_view(root) [1, 3] >>> root = TreeNode(1, TreeNode(2, TreeNode(3))) >>> right_side_view(root) [1, 2, 3] >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) >>> right_side_view(root) [1, 2, 3] >>> root = TreeNode(1, TreeNode(2, None, TreeNode(5)), TreeNode(3, None, TreeNode(4))) >>> right_side_view(root) [1, 3, 4]","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: 'TreeNode' = None, right: 'TreeNode' = None): self.val = val self.left = left self.right = right def right_side_view(root: Optional[TreeNode]) -> List[int]: Returns an array of integers representing the right side view of the binary tree. if not root: return [] result = [] queue = [root] while queue: level_length = len(queue) for i in range(level_length): node = queue.pop(0) if i == level_length - 1: result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of a 2D grid of dimensions m x n. You can only move either down or right at any point in time. Parameters: m (int): number of rows n (int): number of columns Returns: int: number of unique paths >>> unique_paths(1, 1) 1 >>> unique_paths(2, 2) 2 >>> unique_paths(3, 3) 6 >>> unique_paths(3, 2) 3 >>> unique_paths(7, 3) 28 >>> unique_paths(3, 7) 28 >>> unique_paths(10, 10) 48620 >>> unique_paths(20, 20) 35345263800 # Your code here","solution":"def unique_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of a 2D grid of dimensions m x n. You can only move either down or right at any point in time. Parameters: m (int): number of rows n (int): number of columns Returns: int: number of unique paths # Create a 2D array 'dp' with dimensions m x n filled with 0 dp = [[0] * n for _ in range(m)] # Fill the first row and first column with 1s, since there's only one way to get to any cell # directly in the first row or first column for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill in the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def max_unstable_block_length(heights: List[int]) -> int: Return the maximum length of any unstable block of heights. >>> max_unstable_block_length([1]) 1 >>> max_unstable_block_length([1, 2, 3, 4, 5]) 5 >>> max_unstable_block_length([5, 4, 3, 2, 1]) 5 >>> max_unstable_block_length([1, 3, 2, 5, 4]) 5 >>> max_unstable_block_length([3, 3, 3, 3, 3]) 1 >>> max_unstable_block_length([10, 5, 3, 6, 1, 9, 4, 2]) 8 >>> max_unstable_block_length([1, 1, 1, 1, 1]) 1","solution":"def max_unstable_block_length(heights): def is_strictly_increasing(arr): return all(arr[i] < arr[i + 1] for i in range(len(arr) - 1)) max_length = 0 n = len(heights) for start in range(n): for end in range(start + 1, n + 1): block = heights[start:end] if is_strictly_increasing(sorted(block)): max_length = max(max_length, end - start) return max_length"},{"question":"def smallest_integer_with_digit_sum(n: int) -> int: Given an integer n (1 <= n <= 10^9), returns the smallest integer k such that the sum of the digits of k is equal to n. >>> smallest_integer_with_digit_sum(1) 1 >>> smallest_integer_with_digit_sum(5) 5 >>> smallest_integer_with_digit_sum(9) 9 >>> smallest_integer_with_digit_sum(10) 19 >>> smallest_integer_with_digit_sum(18) 99 >>> smallest_integer_with_digit_sum(27) 999 >>> smallest_integer_with_digit_sum(12) 39 >>> smallest_integer_with_digit_sum(21) 399 >>> smallest_integer_with_digit_sum(30) 3999","solution":"def smallest_integer_with_digit_sum(n): Returns the smallest integer k such that the sum of the digits of k is equal to n. if n <= 9: return n else: k = \\"\\" while n > 0: if n >= 9: k = \\"9\\" + k n -= 9 else: k = str(n) + k n = 0 return int(k)"},{"question":"def contains_nearby_duplicate(nums: List[int], k: int) -> bool: Determine if the array contains any duplicate elements within k distance from each other. >>> contains_nearby_duplicate([1, 2, 3, 1], 3) True >>> contains_nearby_duplicate([1, 0, 1, 1], 1) True >>> contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 2) False >>> contains_nearby_duplicate([1, 2, 3, 4, 1], 1) False >>> contains_nearby_duplicate([1, 2, 3, 4, 5], 3) False >>> contains_nearby_duplicate([], 1) False >>> contains_nearby_duplicate([1], 1) False >>> contains_nearby_duplicate([1, 1, 1, 1], 1) True >>> contains_nearby_duplicate([1, 1, 1, 1], 2) True >>> contains_nearby_duplicate([1, 1, 1, 1], 3) True","solution":"def contains_nearby_duplicate(nums, k): Determine if the array contains any duplicate elements within k distance from each other. :param nums: List[int] - The input array of integers. :param k: int - The maximum distance between duplicate elements. :return: bool - True if such elements exist, otherwise False. num_indices = {} for i, num in enumerate(nums): if num in num_indices and i - num_indices[num] <= k: return True num_indices[num] = i return False"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a given arithmetic expression with no parentheses. The expression contains numbers and the operators +, -, *, and /. Division follows integer division rules for two integers and floating-point division otherwise. >>> evaluate_expression(\\"2 + 3\\") 5.0 >>> evaluate_expression(\\"10 - 6\\") 4.0 >>> evaluate_expression(\\"4 * 5\\") 20.0 >>> evaluate_expression(\\"8 / 2\\") 4.0 >>> evaluate_expression(\\"7.5 / 2.5\\") 3.0 >>> evaluate_expression(\\"2 + 3 * 4 - 5 / 5\\") 13.0 >>> evaluate_expression(\\"10 + 20 / 2 * 3 - 5 / 2.0\\") 37.5 >>> evaluate_expression(\\"2 - 3 - 5\\") -6.0 >>> evaluate_expression(\\"1 + 2 + 3 + 4 + 5\\") 15.0","solution":"def evaluate_expression(expression): Evaluates a given arithmetic expression with no parentheses. # Splitting the expression by space character tokens = expression.split() # Stack for numbers and operators num_stack = [] op_stack = [] # Precedence of operators precedence = {'+':1, '-':1, '*':2, '/':2} def apply_operator(op): Apply the operator to the top two values in the num_stack. right = num_stack.pop() left = num_stack.pop() if op == '+': num_stack.append(left + right) elif op == '-': num_stack.append(left - right) elif op == '*': num_stack.append(left * right) elif op == '/': if isinstance(left, int) and isinstance(right, int): num_stack.append(left // right) else: num_stack.append(left / right) for token in tokens: if token.isdigit() or ('.' in token): num_stack.append(float(token) if '.' in token else int(token)) else: while (op_stack and precedence[op_stack[-1]] >= precedence[token]): apply_operator(op_stack.pop()) op_stack.append(token) while op_stack: apply_operator(op_stack.pop()) return float(num_stack[0])"},{"question":"def product_except_self(nums): Given an array nums of integers, this function returns an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The solution must be achieved in O(n) time complexity and without using division. >>> product_except_self([1,2,3,4]) [24, 12, 8, 6] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] from solution import product_except_self def test_product_except_self_example1(): assert product_except_self([1,2,3,4]) == [24, 12, 8, 6] def test_product_except_self_example2(): assert product_except_self([-1, 1, 0, -3, 3]) == [0, 0, 9, 0, 0] def test_product_except_self_single_element(): assert product_except_self([10]) == [1] def test_product_except_self_two_elements(): assert product_except_self([2, 3]) == [3, 2] def test_product_except_self_all_zeros(): assert product_except_self([0, 0, 0]) == [0, 0, 0] def test_product_except_self_mix(): assert product_except_self([2, 3, 4, 5]) == [60, 40, 30, 24] assert product_except_self([-1, -1, -1, -1]) == [-1, -1, -1, -1] def test_product_except_self_negative_values(): assert product_except_self([1, -2, 3, -4]) == [24, -12, 8, -6]","solution":"def product_except_self(nums): Given an array nums of integers, this function returns an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. length = len(nums) answer = [1] * length # Calculate the products of all elements before each element prefix = 1 for i in range(length): answer[i] = prefix prefix *= nums[i] # Calculate the products of all elements after each element and multiply with prefix products suffix = 1 for i in range(length - 1, -1, -1): answer[i] *= suffix suffix *= nums[i] return answer"},{"question":"def first_distinct_letter(s: str) -> str: Returns the character with the smallest index in the original string that is a distinct letter. If there is no distinct letter, return '_'. >>> first_distinct_letter(\\"aabbcc\\") == '_' >>> first_distinct_letter(\\"abcde\\") == 'a' >>> first_distinct_letter(\\"aabcdd\\") == 'b' >>> first_distinct_letter(\\"aabbccx\\") == 'x' >>> first_distinct_letter(\\"swiss\\") == 'w' >>> first_distinct_letter(\\"\\") == '_' >>> first_distinct_letter(\\"a\\") == 'a' >>> first_distinct_letter(\\"abac\\") == 'b' # Add your code here","solution":"def first_distinct_letter(s): Returns the character with the smallest index in the original string that is a distinct letter. If there is no distinct letter, return '_'. from collections import Counter # Count the occurrences of each character in the string char_count = Counter(s) # Iterate through the string and return the first character with count 1 for char in s: if char_count[char] == 1: return char # If there is no distinct character, return '_' return '_'"},{"question":"from typing import List def search_matrix(grid: List[List[int]], target: int) -> bool: Determines if the target value exists in an n x n grid. Each row of the grid represents a non-decreasing sequence from left to right, and each column represents a non-decreasing sequence from top to bottom. :param grid: List of lists representing the n x n grid. :param target: Integer target to search for in the grid. :return: True if the target exists in the grid, otherwise False. >>> grid = [ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ] >>> search_matrix(grid, 5) True >>> search_matrix(grid, 20) False >>> search_matrix([], 1) False >>> search_matrix([[1]], 1) True >>> search_matrix([[1]], 2) False >>> search_matrix(grid, 31) False","solution":"from typing import List def search_matrix(grid: List[List[int]], target: int) -> bool: Determines if the target value exists in the n x n grid. Each row of the grid is a non-decreasing sequence from left to right. Each column of the grid is a non-decreasing sequence from top to bottom. :param grid: List of lists representing the n x n grid. :param target: Integer target to search for in the grid. :return: True if the target exists in the grid, otherwise False. if not grid or not grid[0]: return False rows, cols = len(grid), len(grid[0]) row, col = rows - 1, 0 while row >= 0 and col < cols: if grid[row][col] == target: return True elif grid[row][col] > target: row -= 1 else: col += 1 return False"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"ABCDEF\\") 6 >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"abcd\\") 4 >>> length_of_longest_substring(\\"ABCDefGHI\\") 9 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"Z\\") 1 >>> length_of_longest_substring(\\"aAbBcC\\") 6 >>> length_of_longest_substring(\\"AaAa\\") 2","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) max_length = 0 start = 0 used_chars = {} for i in range(n): if s[i] in used_chars and start <= used_chars[s[i]]: start = used_chars[s[i]] + 1 else: max_length = max(max_length, i - start + 1) used_chars[s[i]] = i return max_length"},{"question":"from typing import List def three_sum(nums: List[int]) -> List[List[int]]: Given an array of integers, determines whether there are three distinct elements \`a\`, \`b\`, \`c\` in the array such that \`a + b + c = 0\`. Returns all triplets from the array that meet the criteria. The solution set must not contain duplicate triplets. >>> three_sum([0, 0, 0]) [[0, 0, 0]] >>> sorted(three_sum([-1, 0, 1, 2, -1, -4])) [[-1, -1, 2], [-1, 0, 1]] >>> sorted(three_sum([-2, 0, 1, 1, 2])) [[-2, 0, 2], [-2, 1, 1]] >>> three_sum([1, 2, 3]) [] >>> sorted(three_sum([-1, -1, 0, 1, 1])) [[-1, 0, 1]] >>> three_sum([]) [] >>> three_sum([1]) [] >>> three_sum([1, -1]) []","solution":"def three_sum(nums): Given an array of integers, determines whether there are three distinct elements \`a\`, \`b\`, \`c\` in the array such that \`a + b + c = 0\`. Returns all triplets from the array that meet the criteria. The solution set must not contain duplicate triplets. nums.sort() result = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, len(nums) - 1 while left < right: s = nums[i] + nums[left] + nums[right] if s == 0: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif s < 0: left += 1 else: right -= 1 return result"},{"question":"def remove_occurrences(s: str, part: str) -> str: Remove all occurrences of 'part' in 's' until no more 'part' is found. >>> remove_occurrences(\\"daabcbaabcbc\\", \\"abc\\") \\"dab\\" >>> remove_occurrences(\\"axxxxyyyyb\\", \\"xy\\") \\"ab\\" >>> remove_occurrences(\\"aaaaa\\", \\"b\\") \\"aaaaa\\" >>> remove_occurrences(\\"\\", \\"abc\\") \\"\\" >>> remove_occurrences(\\"abcabcabc\\", \\"abc\\") \\"\\" >>> remove_occurrences(\\"xxyyzzxxyy\\", \\"xy\\") \\"zz\\" >>> remove_occurrences(\\"short\\", \\"thisislonger\\") \\"short\\"","solution":"def remove_occurrences(s, part): Remove all occurrences of 'part' in 's' until no more 'part' is found. :param s: Input string to remove parts from. :param part: Substring to be removed. :return: Final string after all replacements. while part in s: s = s.replace(part, \\"\\") return s"},{"question":"def max_height(grid: List[List[int]]) -> int: Returns the maximum height achievable in the grid while maintaining the height order. >>> max_height([[1]]) == 1 >>> max_height([[2, 2], [2, 2]]) == 2 >>> max_height([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 9 >>> max_height([[0, -1], [-2, -3]]) == 0 >>> max_height([[1, 3, 2], [6, 4, 5], [9, 7, 8]]) == 9","solution":"def max_height(grid): Returns the maximum height achievable in the grid while maintaining the height order. In general, this is the maximum value present in the grid because we are allowed only to increment the value with no restrictions. max_val = float('-inf') for row in grid: for val in row: if val > max_val: max_val = val return max_val"},{"question":"def restore_string(s: str, indices: list) -> str: Restores the string s according to the provided indices array. >>> restore_string(\\"aiohn\\", [3, 1, 4, 2, 0]) \\"nihao\\" >>> restore_string(\\"abcde\\", [0, 1, 2, 3, 4]) \\"abcde\\" >>> restore_string(\\"abcdef\\", [5, 4, 3, 2, 1, 0]) \\"fedcba\\" >>> restore_string(\\"aabbcc\\", [1, 0, 3, 2, 5, 4]) \\"aabbcc\\" >>> restore_string(\\"z\\", [0]) \\"z\\"","solution":"def restore_string(s: str, indices: list) -> str: Restores the string s according to the provided indices array shuffled = [''] * len(s) for i, index in enumerate(indices): shuffled[index] = s[i] return ''.join(shuffled)"},{"question":"def max_chocolate(m, n, chocolate, k): Returns the maximum amount of chocolate pieces that can be collected after making k breaks. Parameters: m (int): number of rows in the chocolate bar n (int): number of columns in the chocolate bar chocolate (list[list[int]]): m x n matrix representing the chocolate bar k (int): number of breaks Returns: int: maximum amount of chocolate pieces that can be collected >>> max_chocolate(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1) 45 >>> max_chocolate(2, 2, [[1, 2], [3, 4]], 1) 10 >>> max_chocolate(2, 3, [[5, 6, 7], [8, 9, 10]], 0) 45","solution":"def max_chocolate(m, n, chocolate, k): Returns the maximum amount of chocolate pieces that can be collected after making k breaks. Parameters: m (int): number of rows in the chocolate bar n (int): number of columns in the chocolate bar chocolate (list[list[int]]): m x n matrix representing the chocolate bar k (int): number of breaks Returns: int: maximum amount of chocolate pieces that can be collected # dp[i][j][b] will store the max chocolate we can collect with b breaks considering the chocolate bar from (0,0) to (i,j) dp = [[[0] * (k + 1) for _ in range(n)] for _ in range(m)] # Initialize DP table for 0 breaks for i in range(m): for j in range(n): dp[i][j][0] = sum(chocolate[x][y] for x in range(i + 1) for y in range(j + 1)) # Process the DP table for 1 to k breaks for b in range(1, k + 1): for i in range(m): for j in range(n): dp[i][j][b] = dp[i][j][b-1] # Start with no additional breaks # Try breaking horizontally (above the breaking line) for x in range(i): dp[i][j][b] = max(dp[i][j][b], dp[x][j][b-1] + sum(chocolate[s][t] for s in range(x + 1, i + 1) for t in range(j + 1))) # Try breaking vertically (left of the breaking line) for y in range(j): dp[i][j][b] = max(dp[i][j][b], dp[i][y][b-1] + sum(chocolate[s][t] for s in range(i + 1) for t in range(y + 1, j + 1))) # The answer is the maximum chocolate we can collect with k breaks considering the whole bar return dp[m - 1][n - 1][k]"},{"question":"def gcd(a, b): Returns the greatest common divisor of a and b. while b: a, b = b, a % b return a def lcm(a, b): Returns the least common multiple of a and b. return abs(a * b) // gcd(a, b) def minimum_time_to_meet(n, d): Returns the minimum time t required such that every car meets at the same position on a circular track of length n, given that each car moves d units per unit time. pass","solution":"import math def gcd(a, b): Returns the greatest common divisor of a and b. while b: a, b = b, a % b return a def lcm(a, b): Returns the least common multiple of a and b. return abs(a * b) // gcd(a, b) def minimum_time_to_meet(n, d): Returns the minimum time t required such that every car meets at the same position on a circular track of length n, given that each car moves d units per unit time. return lcm(n, d)"},{"question":"def generate_badge_names(badges: str, names: List[str]) -> List[str]: Generates a list of badge names for each employee name using each available badge. :param badges: A string of unique badge characters :param names: A list of employee names :return: A list of generated badge names >>> generate_badge_names(\\"pq\\", [\\"John\\", \\"Jane\\"]) [\\"pJohn\\", \\"qJohn\\", \\"pJane\\", \\"qJane\\"] >>> generate_badge_names(\\"a\\", [\\"Alice\\"]) [\\"aAlice\\"] >>> generate_badge_names(\\"abc\\", [\\"Alice\\"]) [\\"aAlice\\", \\"bAlice\\", \\"cAlice\\"] >>> generate_badge_names(\\"b\\", [\\"Bob\\", \\"Ben\\"]) [\\"bBob\\", \\"bBen\\"] >>> generate_badge_names(\\"\\", [\\"Alice\\", \\"Bob\\"]) [] >>> generate_badge_names(\\"abc\\", []) [] >>> generate_badge_names(\\"\\", []) []","solution":"def generate_badge_names(badges, names): Generates a list of badge names for each employee name using each available badge. :param badges: A string of unique badge characters :param names: A list of employee names :return: A list of generated badge names badge_names = [] for name in names: for badge in badges: badge_names.append(f\\"{badge}{name}\\") return badge_names"},{"question":"def longest_substring_same_char_after_removals(s: str, k: int) -> int: You are given a string \`s\` consisting of lowercase letters and an integer \`k\`. You are allowed to remove at most \`k\` characters from the string. Your goal is to determine the length of the longest substring that contains the same character after making the allowed removals. >>> longest_substring_same_char_after_removals(\\"aabbcc\\", 2) 4 >>> longest_substring_same_char_after_removals(\\"aabbccc\\", 2) 5 >>> longest_substring_same_char_after_removals(\\"aaabbb\\", 3) 6 >>> longest_substring_same_char_after_removals(\\"abcd\\", 1) 2 >>> longest_substring_same_char_after_removals(\\"\\", 2) 0 >>> longest_substring_same_char_after_removals(\\"aaaa\\", 0) 4 >>> longest_substring_same_char_after_removals(\\"aabbcc\\", 10) 6","solution":"def longest_substring_same_char_after_removals(s, k): from collections import defaultdict if not s: return 0 left = 0 max_len = 0 max_count = 0 count = defaultdict(int) for right, char in enumerate(s): count[char] += 1 max_count = max(max_count, count[char]) while (right - left + 1) - max_count > k: count[s[left]] -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"from typing import List def minPathSum(grid: List[List[int]]) -> int: Given a grid of size m x n filled with non-negative integers, find a path from the top left to the bottom right which minimizes the sum of all numbers along its path. You can only move to the right or down from a cell. :param grid: List[List[int]], 2D list representing the grid :return: int, minimum sum possible to reach the bottom-right corner >>> minPathSum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> minPathSum([[3]]) 3 >>> minPathSum([[1, 2, 5], [3, 2, 1]]) 6 >>> minPathSum([]) 0","solution":"def minPathSum(grid): Given a grid of size m x n filled with non-negative integers, find a path from the top left to the bottom right which minimizes the sum of all numbers along its path. You can only move to the right or down from a cell. :param grid: List[List[int]], 2D list representing the grid :return: int, minimum sum possible to reach the bottom-right corner if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Initialize the DP table with the same dimensions as the grid dp = [[0] * cols for _ in range(rows)] # Fill the DP table for i in range(rows): for j in range(cols): if i == 0 and j == 0: dp[i][j] = grid[i][j] # Starting point elif i == 0: dp[i][j] = dp[i][j-1] + grid[i][j] # First row (can only come from the left) elif j == 0: dp[i][j] = dp[i-1][j] + grid[i][j] # First column (can only come from above) else: dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # Choose min from top or left return dp[rows-1][cols-1]"},{"question":"def canMakePalindrome(s: str, queries: List[List[int]]) -> List[bool]: Determines if the given substrings in each query can be transformed into a palindrome by changing at most \`distancei\` characters. Args: s: A string of lowercase English letters. queries: A list of lists, where each list contains three integers \`[starti, endi, distancei]\`. Returns: A list of boolean values indicating whether each substring can be transformed into a palindrome. >>> canMakePalindrome(\\"abcda\\", [[3, 3, 0], [0, 4, 1], [0, 3, 1], [0, 3, 2]]) == [True, True, False, True] >>> canMakePalindrome(\\"a\\", [[0, 0, 0]]) == [True] >>> canMakePalindrome(\\"abcd\\", [[0, 3, 4], [0, 3, 3], [0, 3, 2], [0, 3, 1], [0, 3, 0]]) == [True, True, True, False, False] >>> canMakePalindrome(\\"aabbcc\\", [[0, 5, 3], [1, 4, 1], [2, 2, 0], [0, 1, 1]]) == [True, True, True, True] >>> canMakePalindrome(\\"abcdef\\", [[0, 5, 2]]) == [False] >>> canMakePalindrome(\\"abcdefg\\", [[0, 4, 1]]) == [False] >>> canMakePalindrome(\\"racecar\\", [[0, 6, 0], [0, 6, 1], [0, 3, 2], [1, 4, 2]]) == [True, True, True, True] >>> canMakePalindrome(\\"\\", [[0, 0, 0]]) == [True] pass","solution":"def canMakePalindrome(s, queries): Determines if the given substrings in each query can be transformed into a palindrome by changing at most \`distancei\` characters. Args: s: A string of lowercase English letters. queries: A list of lists, where each list contains three integers \`[starti, endi, distancei]\`. Returns: A list of boolean values indicating whether each substring can be transformed into a palindrome. def is_palindrome_possible(sub_str, max_changes): left = 0 right = len(sub_str) - 1 changes = 0 while left < right: if sub_str[left] != sub_str[right]: changes += 1 if changes > max_changes: return False left += 1 right -= 1 return True result = [] for start, end, max_changes in queries: substring = s[start:end+1] result.append(is_palindrome_possible(substring, max_changes)) return result"},{"question":"def rob(nums: List[int]) -> int: You are given a list of non-negative integers nums, representing the amount of money of each house in a row. You are a robber who wants to maximize the amount of money you can steal, but you cannot steal from two adjacent houses because they will raise an alarm. Return the maximum amount of money you can rob without triggering the alarm. :param nums: List of non-negative integers representing money in each house. :return: The maximum amount of money you can rob.","solution":"def rob(nums): Returns the maximum amount of money you can rob without triggering the alarm. :param nums: List of non-negative integers representing money in each house. :return: The maximum amount of money you can rob. if not nums: return 0 if len(nums) == 1: return nums[0] # Initialize the two previous robbery amounts prev2 = 0 prev1 = nums[0] for i in range(1, len(nums)): current = max(prev1, prev2 + nums[i]) prev2 = prev1 prev1 = current return prev1"},{"question":"def min_transformations(words: List[str], target: str) -> int: Returns the minimum number of transformations required to transform any word from the list to the target string. Each transformation consists of changing one character to another. Parameters: words (list): List of words target (str): Target string Returns: int: Minimum number of transformations or -1 if transformation is not possible >>> min_transformations([\\"abc\\", \\"def\\", \\"ghi\\"], \\"abd\\") 1 >>> min_transformations([\\"abc\\", \\"def\\", \\"ghi\\"], \\"zzz\\") 3 >>> min_transformations([\\"abc\\", \\"aec\\", \\"afc\\"], \\"xyz\\") 3 >>> min_transformations([\\"abc\\", \\"def\\", \\"ghi\\"], \\"abc\\") 0","solution":"def min_transformations(words, target): Returns the minimum number of transformations required to transform any word from the list to the target string. Each transformation consists of changing one character to another. Parameters: words (list): List of words target (str): Target string Returns: int: Minimum number of transformations or -1 if transformation is not possible if not words or not target: return -1 min_trans = float('inf') for word in words: if len(word) != len(target): continue transformations = sum(1 for w, t in zip(word, target) if w != t) min_trans = min(min_trans, transformations) return min_trans if min_trans != float('inf') else -1"},{"question":"def compute_expression(s: str) -> int: Computes the result of the given arithmetic expression string \`s\`. Supports +, -, *, / operations with standard operator precedence. >>> compute_expression(\\"1+1\\") == 2 >>> compute_expression(\\"4-2\\") == 2 >>> compute_expression(\\"3*4\\") == 12 >>> compute_expression(\\"10/2\\") == 5 >>> compute_expression(\\"2+3*2\\") == 8 >>> compute_expression(\\"3+2*2-1\\") == 6 >>> compute_expression(\\"10+2*5/2\\") == 15 >>> compute_expression(\\"10+2*5-3/1\\") == 17","solution":"def compute_expression(s): Computes the result of the given arithmetic expression string \`s\`. Supports +, -, *, / operations with standard operator precedence. def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(left / right) # Helper function for precedence def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 # Shunting yard algorithm to convert the expression to postfix notation operators = [] values = [] i = 0 while i < len(s): if s[i].isdigit(): num = 0 while i < len(s) and s[i].isdigit(): num = num * 10 + int(s[i]) i += 1 values.append(num) i -= 1 else: while (operators and precedence(operators[-1]) >= precedence(s[i])): apply_operator(operators, values) operators.append(s[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"def can_form_arithmetic_sequence(nums: List[int]) -> bool: Given an integer array \`nums\`, determine whether there is a sequence of numbers in the array that can form an arithmetic sequence. An arithmetic sequence is a sequence of numbers such that the difference between successive numbers is constant. >>> can_form_arithmetic_sequence([3, 6, 9, 12]) == True >>> can_form_arithmetic_sequence([5, 10, 15, 20, 25]) == True >>> can_form_arithmetic_sequence([1, 2, 3, 4, 2, 6, 8]) == True >>> can_form_arithmetic_sequence([1, 2, 4, 5, 7]) == False >>> can_form_arithmetic_sequence([10, 13, 15, 18]) == False >>> can_form_arithmetic_sequence([1, 11, 21, 31]) == True >>> can_form_arithmetic_sequence([1, 10, 100, 1000]) == False >>> can_form_arithmetic_sequence([-5, -1, 3, 7]) == True >>> can_form_arithmetic_sequence([-10, 0, 10, 20, 30]) == True >>> can_form_arithmetic_sequence([-3, -1, 1, 3]) == True >>> can_form_arithmetic_sequence([-2, 0, 2, 4, 6]) == True","solution":"def can_form_arithmetic_sequence(nums): Returns True if there is at least one subsequence in nums that can form an arithmetic sequence. nums.sort() n = len(nums) for i in range(n - 2): diff = nums[i + 1] - nums[i] arithmetic = True for j in range(i + 1, n - 1): if nums[j + 1] - nums[j] != diff: arithmetic = False break if arithmetic: return True return False"},{"question":"def longest_equal_substring(s: str) -> int: Determine the length of the longest substring that contains equal numbers of 'a', 'b', and 'c'. >>> longest_equal_substring(\\"abcabc\\") 6 >>> longest_equal_substring(\\"abcabca\\") 6 >>> longest_equal_substring(\\"aaabbb\\") 0 >>> longest_equal_substring(\\"cccccc\\") 0 >>> longest_equal_substring(\\"\\") 0 >>> longest_equal_substring(\\"a\\") 0 >>> longest_equal_substring(\\"abc\\") 3 >>> longest_equal_substring(\\"aabbcc\\") 6 >>> longest_equal_substring(\\"aaaabbbbcccc\\") 12 >>> longest_equal_substring(\\"abcaabbcc\\") 9","solution":"def longest_equal_substring(s): def to_key(a, b): return a - b n = len(s) if n == 0: return 0 count_a, count_b, count_c = 0, 0, 0 count_map = { (0, 0): -1 } max_len = 0 for i in range(n): if s[i] == 'a': count_a += 1 elif s[i] == 'b': count_b += 1 elif s[i] == 'c': count_c += 1 key = (to_key(count_a, count_b), to_key(count_a, count_c)) if key in count_map: max_len = max(max_len, i - count_map[key]) else: count_map[key] = i return max_len"},{"question":"def longest_ones(nums: List[int], k: int) -> int: Returns the maximum number of consecutive 1s in the array if you can flip at most k 0s. >>> longest_ones([1,1,1,0,0,0,1,1,1,1,0], 2) 6 >>> longest_ones([1,1,1,1,1], 1) 5 >>> longest_ones([0,0,0,0], 2) 2 >>> longest_ones([1,0,1,1,0,1], 1) 4 >>> longest_ones([0,1,0,1,0], 0) 1 >>> longest_ones([0,0,0,0,0], 5() { assert longest_ones([0,0,0,0,0], 5) == 5 def test_alternating(): assert longest_ones([1,0,1,0,1,0,1,0], 2) == 5","solution":"def longest_ones(nums, k): Returns the maximum number of consecutive 1s in the array if you can flip at most k 0s. :param nums: List[int] - List of integers containing 0s and 1s :param k: int - Maximum number of 0s that can be flipped :return: int - Maximum number of consecutive 1s left = 0 max_consecutive_ones = 0 zero_count = 0 for right in range(len(nums)): if nums[right] == 0: zero_count += 1 while zero_count > k: if nums[left] == 0: zero_count -= 1 left += 1 max_consecutive_ones = max(max_consecutive_ones, right - left + 1) return max_consecutive_ones"},{"question":"def create_target_array(nums: List[int], index: List[int]) -> List[int]: Creates the target array based on the nums and index arrays. Parameters: nums (list): A list of numbers to be inserted. index (list): A list of indices at which to insert the numbers from nums. Returns: list: The target array after all insertions. pass def test_create_target_array_example(): nums = [0, 1, 2, 3, 4] index = [0, 1, 2, 2, 1] assert create_target_array(nums, index) == [0, 4, 1, 3, 2] def test_create_target_array_single_element(): nums = [5] index = [0] assert create_target_array(nums, index) == [5] def test_create_target_array_duplicates(): nums = [1, 2, 2, 3] index = [0, 1, 1, 2] assert create_target_array(nums, index) == [1, 2, 3, 2] def test_create_target_array_reverse(): nums = [4, 3, 2, 1] index = [0, 0, 0, 0] assert create_target_array(nums, index) == [1, 2, 3, 4] def test_create_target_array_complex(): nums = [2, 3, 1, 4, 0] index = [0, 1, 2, 3, 4] assert create_target_array(nums, index) == [2, 3, 1, 4, 0] def test_create_target_array_same_elements(): nums = [1, 1, 1, 1] index = [0, 1, 2, 3] assert create_target_array(nums, index) == [1, 1, 1, 1]","solution":"def create_target_array(nums, index): Creates the target array based on the nums and index arrays. Parameters: nums (list): A list of numbers to be inserted. index (list): A list of indices at which to insert the numbers from nums. Returns: list: The target array after all insertions. target = [] for num, idx in zip(nums, index): target.insert(idx, num) return target"},{"question":"class TextEditor: Text editor that supports undo and redo functionalities. >>> editor = TextEditor() >>> editor.getText() '' >>> >>> editor.addText(\\"Hello\\") >>> editor.getText() 'Hello' >>> >>> editor.undo() >>> editor.getText() '' >>> >>> editor.redo() >>> editor.getText() 'Hello' >>> >>> editor.addText(\\" World\\") >>> editor.getText() 'Hello World' >>> >>> editor.undo() >>> editor.getText() 'Hello' >>> >>> editor.undo() >>> editor.getText() '' >>> >>> editor.redo() >>> editor.getText() 'Hello' >>> >>> editor.redo() >>> editor.getText() 'Hello World' >>> >>> editor.undo() >>> editor.getText() 'Hello' >>> >>> editor.undo() >>> editor.addText(\\"d\\") >>> editor.getText() 'd' >>> >>> editor.redo() >>> editor.getText() 'd' def __init__(self): pass def addText(self, text): pass def undo(self): pass def redo(self): pass def getText(self): pass","solution":"class TextEditor: def __init__(self): self.history = [] self.redo_stack = [] self.current_text = \\"\\" def addText(self, text): self.history.append(self.current_text) self.redo_stack.clear() # Clear the redo stack as new operation invalidates the redo history self.current_text += text def undo(self): if self.history: last_state = self.history.pop() self.redo_stack.append(self.current_text) self.current_text = last_state def redo(self): if self.redo_stack: redo_state = self.redo_stack.pop() self.history.append(self.current_text) self.current_text = redo_state def getText(self): return self.current_text"},{"question":"def min_swaps_to_balance(s: str) -> int: Returns the minimum number of swaps required to make the string balanced or -1 if it is impossible to balance the string. >>> min_swaps_to_balance(\\"xxyy\\") 0 >>> min_swaps_to_balance(\\"xyxy\\") 0 >>> min_swaps_to_balance(\\"xyyx\\") 1 >>> min_swaps_to_balance(\\"yxyx\\") 1 >>> min_swaps_to_balance(\\"xxxy\\") -1 >>> min_swaps_to_balance(\\"xyyy\\") -1 >>> min_swaps_to_balance(\\"x\\") -1 >>> min_swaps_to_balance(\\"y\\") -1 >>> min_swaps_to_balance(\\"\\") 0","solution":"def min_swaps_to_balance(s): Returns the minimum number of swaps required to make the string balanced or -1 if it is impossible to balance the string. # Check if it's possible to balance the string cnt_x = s.count('x') cnt_y = s.count('y') if cnt_x != cnt_y: return -1 # Calculate minimum swaps # Approach: Calculate the number of swaps needed to balance 'xy' -> 'yx' or vice versa swaps = 0 balance = 0 for char in s: if char == 'x': balance += 1 else: balance -= 1 # If temporarily balance goes negative, it means a swap is needed if balance < 0: swaps += 1 balance = 1 return swaps"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def has_cycle(head): Determines if the linked list has a cycle. :param head: The head of the singly linked list. :return: True if there is a cycle, otherwise False. >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(3) >>> node1.next = node2 >>> node2.next = node3 >>> has_cycle(node1) False >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(3) >>> node1.next = node2 >>> node2.next = node3 >>> node3.next = node1 >>> has_cycle(node1) True >>> node1 = ListNode(1) >>> has_cycle(node1) False >>> node1 = ListNode(1) >>> node1.next = node1 >>> has_cycle(node1) True >>> has_cycle(None) False","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def has_cycle(head): Determines if the linked list has a cycle. :param head: The head of the singly linked list. :return: True if there is a cycle, otherwise False. if not head: return False slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"def max_sum_subarray(nums): Returns the maximum value of the sum of the elements of any contiguous subarray of size at least 2. Args: nums: List of integers. Returns: The maximum sum of any contiguous subarray of size at least 2. Raises: ValueError: If the array has fewer than 2 elements. Example: >>> max_sum_subarray([1, 2, 3, 4, 5]) # 1+2+3+4+5 = 15 15 >>> max_sum_subarray([1, -2, 3, 4, -1, 2, 1, -5, 4]) # 3+4-1+2+1 = 9 9 >>> max_sum_subarray([-1, -2, -3, -4]) # -1-2 = -3 -3 >>> max_sum_subarray([0, 0, 0, 0]) # 0+0 = 0 0 >>> max_sum_subarray([4, 5]) # 4+5 = 9 9 >>> max_sum_subarray([1, -3, 2, 1, -1]) # 2+1 = 3 3 >>> max_sum_subarray([-3, 1, 3, -1, 2]) # 1+3-1+2 = 5 5","solution":"def max_sum_subarray(nums): Returns the maximum value of the sum of the elements of any contiguous subarray of size at least 2. if len(nums) < 2: raise ValueError(\\"Array should have at least 2 elements\\") max_sum = float('-inf') current_sum = nums[0] for i in range(1, len(nums)): current_sum += nums[i] if i >= 1: max_sum = max(max_sum, current_sum) current_sum = max(current_sum, nums[i]) return max_sum"},{"question":"from typing import List def filter_tasks_by_prime_factors(tasks: List[int], k: int) -> List[int]: A company has a legacy software system with a list of tasks to complete, each of which is represented by an integer array \`tasks\`. A task can either be approved or denied based on a strict approval criterion. Each task is approved only if it has more than \`k\` unique prime factors. The company wants to filter out all tasks that do not meet this criterion. Given an integer \`k\` and an array of integers \`tasks\`, return an array of integers representing the tasks that have more than \`k\` unique prime factors. >>> filter_tasks_by_prime_factors([6, 10, 14, 15], 2) [] >>> filter_tasks_by_prime_factors([30, 42, 60, 70], 2) [30, 42, 60, 70] >>> filter_tasks_by_prime_factors([6, 30, 10, 42, 14, 60], 2) [30, 42, 60] >>> filter_tasks_by_prime_factors([], 2) [] >>> filter_tasks_by_prime_factors([90, 210, 2310], 4) [2310]","solution":"from math import isqrt def prime_factors_count(n): Returns the count of unique prime factors of n. count = 0 i = 2 while i <= isqrt(n): if n % i == 0: count += 1 while n % i == 0: n //= i i += 1 if n > 1: count += 1 return count def filter_tasks_by_prime_factors(tasks, k): Returns a list of tasks that have more than k unique prime factors. return [task for task in tasks if prime_factors_count(task) > k]"},{"question":"def can_partition_k_subarrays_with_n_distinct(arr, k, n): Determines if the array can be partitioned into k subarrays each with exactly n distinct integers. Parameters: arr (list): List of integers which may contain duplicates. k (int): The number of subarrays. n (int): The number of distinct integers required in each subarray. Returns: bool: True if the partition is possible, False otherwise. def test_partition_possible(): assert can_partition_k_subarrays_with_n_distinct([1, 2, 3, 1, 2, 3, 4, 5], 2, 3) == True def test_not_enough_elements(): assert can_partition_k_subarrays_with_n_distinct([1, 2, 3, 1, 2, 3, 4, 5], 4, 3) == False def test_exact_partition(): assert can_partition_k_subarrays_with_n_distinct([1, 1, 2, 2, 3, 3], 2, 3) == True def test_not_enough_distinct_elements(): assert can_partition_k_subarrays_with_n_distinct([1, 1, 1, 1, 1], 2, 2) == False def test_single_partition_possible(): assert can_partition_k_subarrays_with_n_distinct([1, 2, 3, 4, 5], 1, 5) == True def test_single_partition_not_possible(): assert can_partition_k_subarrays_with_n_distinct([1, 2, 3], 1, 4) == False","solution":"def can_partition_k_subarrays_with_n_distinct(arr, k, n): Determines if the array can be partitioned into k subarrays each with exactly n distinct integers. Parameters: arr (list): List of integers which may contain duplicates. k (int): The number of subarrays. n (int): The number of distinct integers required in each subarray. Returns: bool: True if the partition is possible, False otherwise. if len(arr) < k * n: return False from collections import Counter # Count frequencies of elements in the array counter = Counter(arr) # Check if we have enough counts to partition into k subarrays each with n distinct elements for count in counter.values(): if count >= k: k -= 1 if k == 0: return True return k == 0"},{"question":"def maximum_minimum_path(grid: List[List[int]]) -> int: Given a grid of size \`m x n\` consisting of non-negative integers, find a path from the top-left corner to the bottom-right corner of the grid such that the minimum value in that path is maximized. You can move up, down, left or right. Return the maximum of the minimum values over all possible paths. >>> maximum_minimum_path([ >>> [5, 4, 5], >>> [1, 2, 6], >>> [7, 4, 6] >>> ]) == 4 >>> maximum_minimum_path([ >>> [2, 2, 1, 2, 2, 2], >>> [1, 2, 2, 2, 1, 2] >>> ]) == 2 >>> maximum_minimum_path([ >>> [3, 4, 6, 3, 4], >>> [0, 2, 1, 1, 7], >>> [8, 8, 3, 2, 7], >>> [3, 2, 4, 9, 8], >>> [4, 1, 2, 0, 0], >>> [4, 6, 5, 4, 3] >>> ]) == 3 >>> maximum_minimum_path([[1]]) == 1 >>> maximum_minimum_path([ >>> [1, 1, 1], >>> [1, 1, 1], >>> [1, 1, 1] >>> ]) == 1","solution":"def maximum_minimum_path(grid): from heapq import heappush, heappop import sys directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] m, n = len(grid), len(grid[0]) pq = [(-grid[0][0], 0, 0)] visited = [[False] * n for _ in range(m)] visited[0][0] = True min_value = grid[0][0] while pq: value, x, y = heappop(pq) min_value = min(min_value, -value) if x == m - 1 and y == n - 1: return min_value for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True heappush(pq, (-grid[nx][ny], nx, ny)) return -1"},{"question":"def minOperationsToAlternate(s: str) -> int: Given a string \`s\` that consists only of the characters 'a', 'b', and 'c', this function returns the minimum number of operations required to make the string alternating, i.e., no two adjacent characters are the same. An operation consists of replacing any character in \`s\` with either 'a', 'b', or 'c'. Consider both possible patterns (starting with 'a' or starting with 'b') and return the smallest number of operations needed. >>> minOperationsToAlternate('aab') 1 >>> minOperationsToAlternate('abc') 1 >>> minOperationsToAlternate('aaaa') 2 >>> minOperationsToAlternate('abab') 0 >>> minOperationsToAlternate('bbbbbb') 3 >>> minOperationsToAlternate('babab') 0 >>> minOperationsToAlternate('a') 0 >>> minOperationsToAlternate('bb') 1 >>> minOperationsToAlternate('') 0","solution":"def minOperationsToAlternate(s: str) -> int: This function returns the minimum number of operations required to make the string \`s\` alternating. n = len(s) if n == 0: return 0 # Pattern 1: \\"ababab...\\" pattern1 = ''.join(['a' if i % 2 == 0 else 'b' for i in range(n)]) # Pattern 2: \\"babab...\\" pattern2 = ''.join(['b' if i % 2 == 0 else 'a' for i in range(n)]) # Count mismatches with each pattern operations1 = sum(1 for i in range(n) if s[i] != pattern1[i]) operations2 = sum(1 for i in range(n) if s[i] != pattern2[i]) # Return the minimum number of operations return min(operations1, operations2)"},{"question":"def length_of_longest_substring_k_distinct(s: str, m: int) -> int: Returns the length of the longest substring with at most m distinct characters. >>> length_of_longest_substring_k_distinct(\\"eceba\\", 2) 3 >>> length_of_longest_substring_k_distinct(\\"a\\", 1) 1 >>> length_of_longest_substring_k_distinct(\\"a\\", 2) 1 >>> length_of_longest_substring_k_distinct(\\"aaaa\\", 1) 4 >>> length_of_longest_substring_k_distinct(\\"aaaa\\", 2) 4 >>> length_of_longest_substring_k_distinct(\\"abcdef\\", 6) 6 >>> length_of_longest_substring_k_distinct(\\"abcde\\", 10) 5 >>> length_of_longest_substring_k_distinct(\\"\\", 2) 0 >>> length_of_longest_substring_k_distinct(\\"abc\\", 0) 0 >>> length_of_longest_substring_k_distinct(\\"abaccc\\", 2) 4 >>> length_of_longest_substring_k_distinct(\\"aabacbebebe\\", 3) 7","solution":"def length_of_longest_substring_k_distinct(s: str, m: int) -> int: Returns the length of the longest substring with at most m distinct characters. if m == 0 or not s: return 0 from collections import defaultdict n = len(s) left = right = 0 max_length = 0 char_count = defaultdict(int) while right < n: char_count[s[right]] += 1 while len(char_count) > m: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def subarray_sum(arr, k): Returns the number of subarrays whose elements sum up to k. >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([1, -1, 1], 1) 3 >>> subarray_sum([1], 1) 1 >>> subarray_sum([1], 2) 0 >>> subarray_sum([1, 2, 3], 3) 2 >>> subarray_sum([0, 0, 0, 0], 0) 10 >>> subarray_sum([1, 2, 3], 100) 0","solution":"def subarray_sum(arr, k): Returns the number of subarrays whose elements sum up to k. current_sum = 0 sum_counts = {0: 1} count = 0 for num in arr: current_sum += num if (current_sum - k) in sum_counts: count += sum_counts[current_sum - k] if current_sum in sum_counts: sum_counts[current_sum] += 1 else: sum_counts[current_sum] = 1 return count"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root: Optional[TreeNode]) -> List[List[int]]: Given a binary tree, return the breadth-first traversal of its nodes' values as a 2D list. Each sublist contains the values of the nodes at each level from top to bottom. >>> root = TreeNode(1) >>> levelOrder(root) [[1]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> levelOrder(root) [[1], [2, 3], [4, 5, 6, 7]] >>> levelOrder(None) [] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> root.right.right.right = TreeNode(4) >>> levelOrder(root) [[1], [2], [3], [4]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> levelOrder(root) [[1], [2], [3], [4]]","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"def maxSumSubarray(nums: List[int], k: int) -> int: Returns the maximum sum of a contiguous subarray of size k. If the length of the list \`nums\` is less than \`k\`, return \`-1\`. >>> maxSumSubarray([1, 2, 3, 4, 5, 6], 3) 15 >>> maxSumSubarray([2, 1, 5, 1, 3, 2], 3) 9 >>> maxSumSubarray([1, 2, 3], 4) -1 >>> maxSumSubarray([4, 3, 2, 1], 4) 10 >>> maxSumSubarray([7], 1) 7 >>> maxSumSubarray([], 1) -1 >>> maxSumSubarray([1, 2, 1, 2, 1, 2], 2) 3 >>> maxSumSubarray([3, 3, 3, 3], 2) 6","solution":"def maxSumSubarray(nums, k): Returns the maximum sum of a contiguous subarray of size k. If the length of the list \`nums\` is less than \`k\`, return \`-1\`. if len(nums) < k: return -1 max_sum = current_sum = sum(nums[:k]) for i in range(k, len(nums)): current_sum = current_sum + nums[i] - nums[i-k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List def find_pair(nums: List[int], target: int) -> List[int]: Finds two distinct integers in the list that add up to the target and returns their indices. If there are multiple pairs, return the pair with the smallest indices. If no such pair exists, return [-1, -1]. >>> find_pair([2, 7, 11, 15], 9) [0, 1] >>> find_pair([1, 2, 3, 4, 5], 10) [-1, -1] >>> find_pair([1, 2, 3, 4, 3], 6) [1, 3] >>> find_pair([3, 3, 4, 5], 6) [0, 1] >>> find_pair([-1, -2, -3, -4], -6) [1, 3] >>> find_pair([5], 5) [-1, -1] >>> find_pair([], 5) [-1, -1]","solution":"from typing import List def find_pair(nums: List[int], target: int) -> List[int]: Finds two distinct integers in the list that add up to the target and returns their indices. If there are multiple pairs, return the pair with the smallest indices. If no such pair exists, return [-1, -1]. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return [seen[complement], i] if num not in seen: # To ensure the pair has distinct integers seen[num] = i return [-1, -1]"},{"question":"def add_digits(num: int) -> int: Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. >>> add_digits(0) 0 >>> add_digits(38) 2 >>> add_digits(12345) 6 >>> add_digits(99999) 9 >>> add_digits(123456789) 9 >>> add_digits(987654321) 9 >>> add_digits(1000000000) 1 >>> add_digits(18) 9 >>> add_digits(27) 9","solution":"def add_digits(num): Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. Uses Digital Root concept for O(1) complexity. if num == 0: return 0 elif num % 9 == 0: return 9 else: return num % 9"},{"question":"def countSquares(matrix): Count the number of square submatrices with all 1s. Parameters: matrix (List[List[int]]): The m x n matrix of zeros and ones. Returns: int: The total number of square submatrices with all 1s. >>> countSquares([[1, 1], [1, 1]]) 5 >>> countSquares([[1, 0], [1, 1]]) 3 >>> countSquares([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 14 >>> countSquares([ ... [0, 1, 1], ... [1, 1, 1], ... [0, 1, 1] ... ]) 9","solution":"def countSquares(matrix): Count the number of square submatrices with all 1s. Parameters: matrix (List[List[int]]): The m x n matrix of zeros and ones. Returns: int: The total number of square submatrices with all 1s. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] # dp table to store the size of the largest square ending at each cell count = 0 for i in range(m): for j in range(n): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 # Top row or left column else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 count += dp[i][j] return count"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition(head: ListNode, x: int) -> ListNode: Rearrange the linked list so that all nodes with values less than x come before nodes with values greater than or equal to x. The relative order of nodes in each partition should remain the same. >>> head = list_to_nodes([3, 5, 8, 5, 10, 2, 1]) >>> x = 5 >>> new_head = partition(head, x) >>> nodes_to_list(new_head) [3, 2, 1, 5, 8, 5, 10] >>> head = list_to_nodes([1, 2, 3, 4]) >>> x = 5 >>> new_head = partition(head, x) >>> nodes_to_list(new_head) [1, 2, 3, 4]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition(head: ListNode, x: int) -> ListNode: Rearrange the linked list so that all nodes with values less than x come before nodes with values greater than or equal to x. The relative order of nodes in each partition should remain the same. less_head = ListNode(0) # dummy node for less than x greater_head = ListNode(0) # dummy node for greater than or equal to x less = less_head greater = greater_head current = head while current: if current.val < x: less.next = current less = less.next else: greater.next = current greater = greater.next current = current.next # Terminate the greater list greater.next = None # Combine the less than and greater than lists less.next = greater_head.next return less_head.next"},{"question":"from typing import List def shortest_path(matrix: List[List[int]], startX: int, startY: int, endX: int, endY: int) -> int: Finds the shortest path from the start position to the end position avoiding obstacles in a grid. >>> shortest_path([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 0, 0, 2, 2) 4 >>> shortest_path([[0, 1, 0], [0, 1, 0], [0, 0, 0]], 0, 0, 2, 2) 4 >>> shortest_path([[0, 1, 0], [1, 1, 0], [0, 0, 0]], 0, 0, 2, 2) -1 >>> shortest_path([[0, 0, 0], [0, 1, 0], [0, 0, 1]], 0, 0, 2, 2) -1 >>> shortest_path([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1, 1, 1) 0","solution":"from collections import deque def shortest_path(matrix, startX, startY, endX, endY): Finds the shortest path from the start position to the end position avoiding obstacles in a grid. if matrix[startX][startY] == 1 or matrix[endX][endY] == 1: return -1 rows, cols = len(matrix), len(matrix[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right queue = deque([(startX, startY, 0)]) # x, y, distance visited = set((startX, startY)) while queue: x, y, dist = queue.popleft() if x == endX and y == endY: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and matrix[nx][ny] == 0: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"from typing import List def trap_rain_water(heights: List[int]) -> int: Calculate the total amount of trapped rainwater given the heights of buildings. :param heights: List of integers representing the heights of buildings. :return: Total volume of trapped rainwater. >>> trap_rain_water([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 >>> trap_rain_water([1,1,1,1]) == 0 >>> trap_rain_water([4]) == 0 >>> trap_rain_water([4,3,2,1]) == 0 >>> trap_rain_water([4,2,0,3,2,5]) == 9 >>> trap_rain_water([]) == 0","solution":"def trap_rain_water(heights): Calculate the total amount of trapped rainwater given the heights of buildings. :param heights: List of integers representing the heights of buildings. :return: Total volume of trapped rainwater. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate trapped water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root: TreeNode) -> bool: Returns whether the given binary tree is symmetric. :param root: TreeNode, the root of the binary tree :return: bool, True if the tree is symmetric, False otherwise >>> tree = TreeNode(1) >>> tree.left = TreeNode(2, TreeNode(3), TreeNode(4)) >>> tree.right = TreeNode(2, TreeNode(4), TreeNode(3)) >>> isSymmetric(tree) True >>> tree = TreeNode(1) >>> tree.left = TreeNode(2, None, TreeNode(3)) >>> tree.right = TreeNode(2, None, TreeNode(3)) >>> isSymmetric(tree) False >>> tree = None >>> isSymmetric(tree) True >>> tree = TreeNode(1) >>> isSymmetric(tree) True >>> tree = TreeNode(1) >>> tree.left = TreeNode(2) >>> tree.right = TreeNode(2) >>> isSymmetric(tree) True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root): Returns whether the given binary tree is symmetric. :param root: TreeNode, the root of the binary tree :return: bool, True if the tree is symmetric, False otherwise def isMirror(t1, t2): if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val) and isMirror(t1.right, t2.left) and isMirror(t1.left, t2.right) return isMirror(root, root)"},{"question":"def search_rotated_sorted_array(numbers: List[int], target: int) -> int: Search for target in a rotated sorted array and return its index or -1 if not found. :param numbers: List[int], a rotated sorted array of integers :param target: int, the target integer to find :return: int, the index of target in the array, or -1 if not present >>> search_rotated_sorted_array([4,5,6,7,0,1,2], 0) == 4 >>> search_rotated_sorted_array([4,5,6,7,0,1,2], 3) == -1 >>> search_rotated_sorted_array([], 1) == -1 >>> search_rotated_sorted_array([1], 1) == 0 >>> search_rotated_sorted_array([1], 0) == -1 >>> search_rotated_sorted_array([6,7,0,1,2,3,4,5], 4) == 6 >>> search_rotated_sorted_array([15, 18, 2, 3, 6, 12], 15) == 0 >>> search_rotated_sorted_array([15, 18, 2, 3, 6, 12], 12) == 5 >>> search_rotated_sorted_array([8,9,10,1,2,3,4,5,6,7], 1) == 3 >>> search_rotated_sorted_array([8,9,10,1,2,3,4,5,6,7], 10) == 2","solution":"def search_rotated_sorted_array(numbers, target): Search for target in a rotated sorted array and return its index or -1 if not found. :param numbers: List[int], a rotated sorted array of integers :param target: int, the target integer to find :return: int, the index of target in the array, or -1 if not present low, high = 0, len(numbers) - 1 while low <= high: mid = (low + high) // 2 if numbers[mid] == target: return mid if numbers[low] <= numbers[mid]: # Left portion is sorted if numbers[low] <= target < numbers[mid]: high = mid - 1 else: low = mid + 1 else: # Right portion is sorted if numbers[mid] < target <= numbers[high]: low = mid + 1 else: high = mid - 1 return -1"},{"question":"from typing import List def lexicographically_smallest_string(s: str, k: int) -> str: Delete characters from the string to construct the lexicographically smallest string possible that contains no more than k distinct characters. >>> lexicographically_smallest_string(\\"abcdeedcba\\", 2) \\"aabb\\" >>> lexicographically_smallest_string(\\"abcdabcdabcd\\", 2) \\"aaabbb\\" >>> lexicographically_smallest_string(\\"xyzxyzxyz\\", 1) \\"xxx\\" >>> lexicographically_smallest_string(\\"aabbcc\\", 3) \\"aabbcc\\" >>> lexicographically_smallest_string(\\"aabbcc\\", 2) \\"aabb\\" >>> lexicographically_smallest_string(\\"zzzz\\", 1) \\"zzzz\\" >>> lexicographically_smallest_string(\\"\\", 2) \\"\\" >>> lexicographically_smallest_string(\\"aaa\\", 0) \\"\\" >>> lexicographically_smallest_string(\\"a\\", 2) \\"a\\"","solution":"def lexicographically_smallest_string(s, k): from collections import Counter # Find the frequency of each character in the string counter = Counter(s) # Sort characters first by frequency (descending), then by lexicographic order (ascending) sorted_chars = sorted(counter.items(), key=lambda x: (-x[1], x[0])) # Select the k most frequent characters selected_chars = sorted_chars[:k] # Construct the resulting string using these characters result_chars = [] for char, freq in sorted(selected_chars, key=lambda x: x[0]): result_chars.extend([char] * freq) return ''.join(result_chars)"},{"question":"def max_profit(prices: List[int]) -> int: Calculate the maximum profit that can be achieved from the given list of prices. You are given a list of integers representing prices of identical items over consecutive days. You are allowed to buy and sell the item any number of times to maximize your profit, but you may not engage in multiple transactions simultaneously (you must sell your stock before buying again). :param prices: List of integer prices :return: Integer max profit >>> max_profit([7, 1, 5, 3, 6, 4]) == 7 >>> max_profit([7, 6, 4, 3, 1]) == 0 >>> max_profit([1, 2, 3, 4, 5, 6]) == 5 from solution import max_profit def test_max_profit_example_case(): assert max_profit([7, 1, 5, 3, 6, 4]) == 7 def test_max_profit_no_transaction(): assert max_profit([7, 6, 4, 3, 1]) == 0 def test_max_profit_all_increasing(): assert max_profit([1, 2, 3, 4, 5, 6]) == 5 def test_max_profit_all_decreasing(): assert max_profit([6, 5, 4, 3, 2, 1]) == 0 def test_max_profit_mixed(): assert max_profit([2, 4, 1, 7]) == 8 def test_max_profit_single_day_prices(): assert max_profit([5]) == 0 def test_max_profit_identical_prices(): assert max_profit([2, 2, 2, 2]) == 0","solution":"def max_profit(prices): Calculate the maximum profit that can be achieved from the given list of prices. :param prices: List of integer prices :return: Integer max profit max_profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i-1]: max_profit += prices[i] - prices[i-1] return max_profit"},{"question":"def max_trees_cut(heights: List[int]) -> int: Given a 0-indexed integer array \`heights\` representing the heights of trees planted in a vertical line, determine the maximum number of trees that can be cut so that the remaining trees are in non-decreasing order of their heights from left to right. You can cut any number of trees, but the relative order of the remaining trees should be preserved. Return the maximum number of trees that can be cut. >>> max_trees_cut([3, 1, 2, 1, 1, 2]) 2 >>> max_trees_cut([1, 2, 3, 4, 5]) 0 >>> max_trees_cut([5, 4, 3, 2, 1]) 4 >>> max_trees_cut([3, 3, 3, 3, 3]) 0 >>> max_trees_cut([1, 3, 2, 6, 5, 4]) 3 >>> max_trees_cut([]) 0 >>> max_trees_cut([1]) 0 >>> max_trees_cut([1, 3, 2, 2, 5, 4, 6]) 2","solution":"def max_trees_cut(heights): Returns the maximum number of trees that can be cut to ensure the remaining trees are in non-decreasing order of heights. n = len(heights) if n == 0: return 0 # Compute the Longest Increasing Subsequence (LIS) lengths dp = [1] * n for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the LIS lis_length = max(dp) # The maximum number of trees that can be cut return n - lis_length"},{"question":"def count_nice_pairs(nums: List[int]) -> int: Count the number of nice pairs in the list nums. A pair (i, j) is nice if abs(nums[i] - nums[j]) == 1 and i < j. Parameters: nums (list of int): The list of positive integers. Returns: int: The count of nice pairs. >>> count_nice_pairs([1, 2, 3, 4]) == 3 >>> count_nice_pairs([1, 3, 5, 7]) == 0 >>> count_nice_pairs([2, 2, 2, 2]) == 0 >>> count_nice_pairs([1, 10, 20, 21]) == 1 >>> count_nice_pairs([1, 2, 3, 2, 4]) == 5 >>> count_nice_pairs([1]) == 0","solution":"def count_nice_pairs(nums): Count the number of nice pairs in the list nums. A pair (i, j) is nice if abs(nums[i] - nums[j]) == 1 and i < j. Parameters: nums (list of int): The list of positive integers. Returns: int: The count of nice pairs. count = 0 n = len(nums) for i in range(n): for j in range(i + 1, n): if abs(nums[i] - nums[j]) == 1: count += 1 return count"},{"question":"def distinct_marine_life_types(grid, queries): Returns the number of distinct types of marine life for each sub-grid specified in queries. :param grid: List of lists containing integers representing marine life types. :param queries: List of lists where each inner list consists of four integers [r1, c1, r2, c2]. :return: List of integers, each representing the number of distinct types of marine life in the sub-grid. >>> grid = [ >>> [1, 2, 2], >>> [3, 1, 2], >>> [1, 2, 3] >>> ] >>> queries = [ >>> [0, 0, 2, 2] >>> ] >>> distinct_marine_life_types(grid, queries) == [3] >>> grid = [ >>> [1, 2, 2], >>> [3, 1, 2], >>> [1, 2, 3] >>> ] >>> queries = [ >>> [0, 0, 1, 1], >>> [1, 1, 2, 2], >>> [0, 0, 0, 0] >>> ] >>> distinct_marine_life_types(grid, queries) == [3, 3, 1] >>> grid = [ >>> [0, 0, 0], >>> [0, 0, 0], >>> [0, 0, 0] >>> ] >>> queries = [ >>> [0, 0, 2, 2] >>> ] >>> distinct_marine_life_types(grid, queries) == [1] >>> grid = [ >>> [1, 2], >>> [2, 3], >>> [1, 4] >>> ] >>> queries = [ >>> [0, 0, 1, 1], >>> [1, 0, 2, 1] >>> ] >>> distinct_marine_life_types(grid, queries) == [3, 4] >>> grid = [ >>> [1, 2, 3], >>> [4, 5, 6], >>> [7, 8, 9] >>> ] >>> queries = [ >>> [0, 0, 2, 2], >>> ] >>> distinct_marine_life_types(grid, queries) == [9]","solution":"def distinct_marine_life_types(grid, queries): Returns the number of distinct types of marine life for each sub-grid specified in queries. :param grid: List of lists containing integers representing marine life types. :param queries: List of lists where each inner list consists of four integers [r1, c1, r2, c2]. :return: List of integers, each representing the number of distinct types of marine life in the sub-grid. results = [] for r1, c1, r2, c2 in queries: unique_types = set() for i in range(r1, r2 + 1): for j in range(c1, c2 + 1): unique_types.add(grid[i][j]) results.append(len(unique_types)) return results"},{"question":"def min_servers_required(logs): Returns the minimum number of servers required to handle all the requests without any overlap. >>> min_servers_required([[1, 2], [3, 4], [5, 6]]) == 1 >>> min_servers_required([[1, 5], [2, 6], [3, 7]]) == 3 >>> min_servers_required([[1, 5], [6, 10], [5, 7]]) == 2 >>> min_servers_required([[1, 3], [1, 3], [1, 3]]) == 3 >>> min_servers_required([]) == 0 >>> min_servers_required([[1, 2]]) == 1","solution":"def min_servers_required(logs): Returns the minimum number of servers required to handle all the requests without any overlap. # Create separate lists for start and end times start_times = sorted([log[0] for log in logs]) end_times = sorted([log[1] for log in logs]) server_count = 0 max_servers = 0 i, j = 0, 0 # Use two pointers to traverse the start and end times while i < len(start_times) and j < len(end_times): if start_times[i] < end_times[j]: server_count += 1 max_servers = max(max_servers, server_count) i += 1 else: server_count -= 1 j += 1 return max_servers"},{"question":"def find_max_average(arr: List[int], k: int) -> float: Given an integer array arr and an integer k, find a contiguous subarray whose length is exactly k and has the maximum average value. Return the maximum average value. >>> find_max_average([1, 12, -5, -6, 50, 3], 4) 12.75 >>> find_max_average([5], 1) 5.0 >>> find_max_average([-7], 1) -7.0 >>> find_max_average([-1, -2, -3, -4], 2) -1.5 >>> find_max_average([5, 2, 3, 4], 4) 3.5 >>> find_max_average([0, 0, 0, 0], 2) 0.0","solution":"def find_max_average(arr, k): Finds the maximum average value of any contiguous subarray of length 'k'. if not arr or k <= 0 or k > len(arr): raise ValueError(\\"Invalid input parameters\\") # Compute the sum of the first 'k' elements current_sum = sum(arr[:k]) max_sum = current_sum # Traverse through the array for i in range(k, len(arr)): current_sum = current_sum - arr[i - k] + arr[i] if current_sum > max_sum: max_sum = current_sum # Return the maximum average value return max_sum / k"},{"question":"def max_sum_of_subarrays(arr, k): Returns the maximum sum of any consecutive subarray of length k. >>> max_sum_of_subarrays([1, 2, 3, 4, 5, 6], 3) 15 >>> max_sum_of_subarrays([10], 1) 10 >>> max_sum_of_subarrays([1, 2, 3, 4], 4) 10 >>> max_sum_of_subarrays([1, 2, 3], 4) 0 >>> max_sum_of_subarrays([-1, -2, -3, -4, 5, 6], 2) 11 >>> max_sum_of_subarrays([1, -2, 3, 10, -4, 7], 3) 13 >>> max_sum_of_subarrays([1, 2, 3, 4, 5, 6], 0) 0 >>> max_sum_of_subarrays([], 3) 0 >>> max_sum_of_subarrays([1, 2, 3, 4, 5], -1) 0","solution":"def max_sum_of_subarrays(arr, k): Returns the maximum sum of any consecutive subarray of length k. if len(arr) < k or k <= 0: return 0 max_sum = current_sum = sum(arr[:k]) for i in range(k, len(arr)): current_sum = current_sum - arr[i - k] + arr[i] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def find_pairs(nums, target): Finds all unique pairs of integers in the array \`nums\` whose sum equals \`target\`. Each pair is sorted internally (num1 <= num2), and the output is sorted by \`num1\` and then by \`num2\`. Parameters: nums (list): A list of integers. target (int): The target sum. Returns: list: A list of unique pairs sorted as per the criteria. pass # Unit Tests def test_find_pairs_generic_case(): assert find_pairs([1, 2, 3, 4, 5], 5) == [[1, 4], [2, 3]] def test_find_pairs_no_pair(): assert find_pairs([1, 2, 3], 7) == [] def test_find_pairs_multiple_pairs(): assert find_pairs([1, 2, 3, 2, 2, 2, 4], 4) == [[1, 3], [2, 2]] def test_find_pairs_with_negatives(): assert find_pairs([-1, 0, 1, 2], 1) == [[-1, 2], [0, 1]] def test_find_pairs_duplicates(): assert find_pairs([1, 1, 1, 1, 2, 2, 3], 4) == [[1, 3], [2, 2]] def test_find_pairs_empty_array(): assert find_pairs([], 5) == [] def test_find_pairs_single_element(): assert find_pairs([3], 3) == [] def test_find_pairs_with_zeros(): assert find_pairs([0, 0, 0, 0], 0) == [[0, 0]] def test_find_pairs_large_number(): assert find_pairs([1000000, 500000, -500000, -1000000], 0) == [[-1000000, 1000000], [-500000, 500000]]","solution":"def find_pairs(nums, target): Finds all unique pairs of integers in the array \`nums\` whose sum equals \`target\`. Each pair is sorted internally (num1 <= num2), and the output is sorted by \`num1\` and then by \`num2\`. Parameters: nums (list): A list of integers. target (int): The target sum. Returns: list: A list of unique pairs sorted as per the criteria. nums.sort() result = [] seen = set() i, j = 0, len(nums) - 1 while i < j: current_sum = nums[i] + nums[j] if current_sum == target: if (nums[i], nums[j]) not in seen: result.append([nums[i], nums[j]]) seen.add((nums[i], nums[j])) i += 1 j -= 1 elif current_sum < target: i += 1 else: j -= 1 return result"},{"question":"def get_lexicographically_smallest_string(s: str, k: int) -> str: Transform the string \`s\` into the lexicographically smallest string \`t\` by performing at most \`k\` operations. >>> get_lexicographically_smallest_string(\\"cba\\", 1) == \\"acb\\" >>> get_lexicographically_smallest_string(\\"baaca\\", 1) == \\"aacab\\" >>> get_lexicographically_smallest_string(\\"abc\\", 1) == \\"abc\\" >>> get_lexicographically_smallest_string(\\"cba\\", 2) == \\"abc\\" >>> get_lexicographically_smallest_string(\\"baaca\\", 2) == \\"aaabc\\" >>> get_lexicographically_smallest_string(\\"abc\\", 2) == \\"abc\\" >>> get_lexicographically_smallest_string(\\"aab\\", 2) == \\"aab\\" >>> get_lexicographically_smallest_string(\\"\\", 1) == \\"\\" >>> get_lexicographically_smallest_string(\\"a\\", 1) == \\"a\\" >>> get_lexicographically_smallest_string(\\"a\\", 2) == \\"a\\" >>> get_lexicographically_smallest_string(\\"z\\" * 100000, 1) == \\"z\\" * 100000 >>> get_lexicographically_smallest_string(\\"z\\" * 100000, 2) == \\"z\\" * 100000 >>> get_lexicographically_smallest_string(\\"abracadabra\\", 1) == \\"aabracadabr\\" >>> get_lexicographically_smallest_string(\\"abracadabra\\", 2) == \\"aaaaabbcdrr\\"","solution":"def get_lexicographically_smallest_string(s, k): if k == 1: # For k == 1, we can only rotate the string to get the lexicographically smallest string smallest_str = s for i in range(1, len(s)): rotated_str = s[i:] + s[:i] if rotated_str < smallest_str: smallest_str = rotated_str return smallest_str else: # For k > 1, replacing characters allows us to sort the string directly return ''.join(sorted(s))"},{"question":"def minMeetingRooms(startTime, endTime): Returns the minimum number of meeting rooms required to host all the meetings. Parameters: startTime (List[int]): List of start times of meetings. endTime (List[int]): List of end times of meetings. Returns: int: Minimum number of meeting rooms required. >>> minMeetingRooms([1, 3, 5], [2, 4, 6]) 1 >>> minMeetingRooms([1, 1, 1], [4, 4, 4]) 3 >>> minMeetingRooms([1, 2, 3], [3, 4, 5]) 2 >>> minMeetingRooms([], []) 0 >>> minMeetingRooms([1], [2]) 1 >>> minMeetingRooms([1, 3, 5, 8], [2, 6, 7, 9]) 2","solution":"def minMeetingRooms(startTime, endTime): Returns the minimum number of meeting rooms required to host all the meetings. if not startTime or not endTime or len(startTime) != len(endTime): return 0 # Sort the start and end times startTime.sort() endTime.sort() start_pointer = 0 end_pointer = 0 used_rooms = 0 max_rooms = 0 while start_pointer < len(startTime): # If the meeting starts before the earliest ending meeting ends, we need a new room. if startTime[start_pointer] < endTime[end_pointer]: used_rooms += 1 start_pointer += 1 else: # Otherwise, free up a room and move the end_pointer to the next earliest ending meeting. used_rooms -= 1 end_pointer += 1 max_rooms = max(max_rooms, used_rooms) return max_rooms"},{"question":"from typing import List def max_non_overlapping_requests(requests: List[List[int]]) -> int: Returns the maximum number of non-overlapping requests that can be accommodated. Args: requests : List[List[int]] A list of requests where each request is a list [starti, endi] Returns: int The maximum number of non-overlapping requests Examples: >>> max_non_overlapping_requests([]) == 0 >>> max_non_overlapping_requests([[1, 2]]) == 1 >>> max_non_overlapping_requests([[1, 2], [3, 4], [5, 6]]) == 3 >>> max_non_overlapping_requests([[1, 3], [2, 4], [3, 5], [4, 6]]) == 2 >>> max_non_overlapping_requests([[1, 3], [2, 3], [3, 5], [1, 2]]) == 2 >>> max_non_overlapping_requests([[1, 2], [1, 2], [1, 2]]) == 1 pass","solution":"def max_non_overlapping_requests(requests): Returns the maximum number of non-overlapping requests that can be accommodated. Args: requests : List[List[int]] A list of requests where each request is a list [starti, endi] Returns: int The maximum number of non-overlapping requests if not requests: return 0 # Sort the requests based on their end time sorted_requests = sorted(requests, key=lambda x: x[1]) count = 0 end_time = float('-inf') for request in sorted_requests: if request[0] > end_time: count += 1 end_time = request[1] return count"},{"question":"def find_peak_element(nums: List[int]) -> int: Finds the index of any peak element in a sorted array of distinct integers. A peak element is one that is greater than its neighbors. Args: nums: List[int] - a sorted array of distinct integers Returns: int - the index of a peak element >>> find_peak_element([1, 2, 3, 1]) 2 >>> find_peak_element([1, 2, 1, 3, 5, 6, 4]) 1 >>> find_peak_element([3, 2, 1]) 0 >>> find_peak_element([1, 2, 3]) 2","solution":"def find_peak_element(nums): Finds the index of any peak element in a sorted array of distinct integers. A peak element is one that is greater than its neighbors. :param nums: List[int], a sorted array of distinct integers :return: int, the index of a peak element left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"def split_array_min_largest_sum(arr: List[int], k: int) -> int: Given an array \`arr\` of integers and an integer \`k\`, return the minimum largest sum among the \`k\` non-empty subarrays. >>> split_array_min_largest_sum([7, 2, 5, 10, 8], 2) 18 >>> split_array_min_largest_sum([10], 1) 10 >>> split_array_min_largest_sum([5, 5, 5, 5, 5], 2) 15 >>> split_array_min_largest_sum([10, 20, 30, 40, 50], 5) 50 >>> split_array_min_largest_sum([1, 2, 3, 4, 5], 5) 5","solution":"def split_array_min_largest_sum(arr, k): def can_split(mid): count, current_sum = 1, 0 for num in arr: if current_sum + num > mid: count += 1 current_sum = num if count > k: return False else: current_sum += num return True low, high = max(arr), sum(arr) while low < high: mid = (low + high) // 2 if can_split(mid): high = mid else: low = mid + 1 return low"},{"question":"class ListNode: def __init__(self, data=0, N=None, R=None): self.data = data self.N = N self.R = R def copy_list_with_random_pointer(head): Create a deep copy of a linked list where each node has two pointers: 'N' (next) and 'R' (random). Args: head (ListNode): The head node of the linked list. Returns: ListNode: The head node of the deep copied linked list. >>> # Create the original list: 1 -> 2 -> 3 >>> # With R pointers: 1->R->3, 2->R->1, 3->R->2 >>> node3 = ListNode(3) >>> node2 = ListNode(2, N=node3) >>> node1 = ListNode(1, N=node2) >>> node1.R = node3 >>> node2.R = node1 >>> node3.R = node2 >>> >>> # Copy the list >>> copied_head = copy_list_with_random_pointer(node1) >>> >>> # Test the structure and values of the deep copied list >>> assert copied_head.data == 1 >>> assert copied_head.N.data == 2 >>> assert copied_head.N.N.data == 3 >>> assert copied_head.N.N.N is None >>> >>> # Test R pointers >>> assert copied_head.R.data == 3 >>> assert copied_head.N.R.data == 1 >>> assert copied_head.N.N.R.data == 2 >>> # Ensure no shared references >>> assert copied_head is not node1 >>> assert copied_head.N is not node2 >>> assert copied_head.N.N is not node3 >>> assert copied_head.R is not node3 >>> assert copied_head.N.R is not node1 >>> assert copied_head.N.N.R is not node2","solution":"class ListNode: def __init__(self, data=0, N=None, R=None): self.data = data self.N = N self.R = R def copy_list_with_random_pointer(head): if not head: return None # Creating a mapping from original nodes to their copies node_map = {} # Step 1: Copy all the nodes and store them in the hash map current = head while current: node_map[current] = ListNode(current.data) current = current.N # Step 2: Assign next (N) and random (R) pointers current = head while current: if current.N: node_map[current].N = node_map[current.N] if current.R: node_map[current].R = node_map[current.R] current = current.N # Return the head of the copied list return node_map[head]"},{"question":"def good_view_buildings(heights): Returns the indices of buildings with a good view. A building has a good view if its height is greater than or equal to the height of every other building that comes after it in the array. >>> good_view_buildings([4, 2, 3, 1]) == [0, 2, 3] >>> good_view_buildings([5, 5, 5, 5]) == [0, 1, 2, 3] >>> good_view_buildings([1, 2, 3, 4]) == [3] >>> good_view_buildings([4, 3, 2, 1]) == [0, 1, 2, 3] >>> good_view_buildings([1]) == [0] >>> good_view_buildings([1, 2]) == [1] >>> good_view_buildings([2, 1]) == [0, 1] >>> good_view_buildings([3, 1, 4, 2, 5]) == [4]","solution":"def good_view_buildings(heights): Returns the indices of buildings with a good view. A building has a good view if its height is greater than or equal to the height of every other building that comes after it in the array. n = len(heights) good_view_indices = [] max_height = 0 for i in range(n - 1, -1, -1): if heights[i] >= max_height: good_view_indices.append(i) max_height = heights[i] return good_view_indices[::-1]"},{"question":"def is_palindrome(s: str) -> bool: Checks whether the given string is a palindrome, considering only alphanumeric characters and ignoring cases. Args: s (str): input string to check Returns: bool: True if s is a palindrome, False otherwise Examples: >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"Madam In Eden, I'm Adam\\") True >>> is_palindrome(\\" \\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"not a palindrome\\") False >>> is_palindrome(\\"Palindrome 1 2 3\\") False >>> is_palindrome(\\"1234567890\\") False >>> is_palindrome(\\"Almost a palindrome\\") False","solution":"def is_palindrome(s): Checks whether the given string is a palindrome, considering only alphanumeric characters and ignoring cases. Args: s (str): input string to check Returns: bool: True if s is a palindrome, False otherwise # Convert to lower case and filter only alphanumeric characters filtered_s = ''.join(char.lower() for char in s if char.isalnum()) # Compare filtered string with its reverse return filtered_s == filtered_s[::-1]"},{"question":"def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merges overlapping intervals and returns a list of non-overlapping intervals. Args: intervals (List[List[int]]): A list of intervals [start, end]. Returns: List[List[int]]: A list of merged non-overlapping intervals. Examples: >>> merge_intervals([[1,3],[2,6],[8,10],[15,18]]) [[1,6],[8,10],[15,18]] >>> merge_intervals([[1,4],[4,5]]) [[1,5]] >>> merge_intervals([]) [] >>> merge_intervals([[1,4]]) [[1,4]] >>> merge_intervals([[1,2],[3,4],[5,6]]) [[1,2],[3,4],[5,6]] >>> merge_intervals([[1,5], [2,4], [3,3]]) [[1,5]] >>> merge_intervals([[1,10], [2,6], [7,9]]) [[1,10]] >>> merge_intervals([[1,3],[2,4],[4,6],[7,8]]) [[1,6],[7,8]] >>> merge_intervals([[1,3],[2,5],[6,8],[7,9]]) [[1,5],[6,9]]","solution":"def merge_intervals(intervals): Merges overlapping intervals and returns a list of non-overlapping intervals. Args: intervals (List[List[int]]): A list of intervals [start, end]. Returns: List[List[int]]: A list of merged non-overlapping intervals. if not intervals: return [] # Sort the intervals based on the start time intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] # If the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: last_merged[1] = max(last_merged[1], current[1]) else: merged_intervals.append(current) return merged_intervals"},{"question":"def max_path_sum(matrix): Returns the maximum sum of values along any path from the top-left corner to the bottom-right corner, moving only down or right at any point in time. >>> max_path_sum([[5]]) == 5 >>> max_path_sum([[1, 3], [2, 1]]) == 5 >>> max_path_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 29 >>> max_path_sum([[0, 0, 0], [0, 1, 0], [0, 0, 2]]) == 3 >>> max_path_sum([[1, 2], [3, 4], [5, 6]]) == 15","solution":"def max_path_sum(matrix): Returns the maximum sum of values along any path from the top-left corner to the bottom-right corner, moving only down or right at any point in time. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = matrix[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + matrix[0][j] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[m-1][n-1]"},{"question":"def maximum_elevation_difference(grid: List[List[int]]) -> int: You have a grid with n rows and m columns represented by a 2D integer array grid. Each cell in the grid contains an integer that represents the elevation at that point. Your goal is to find the maximum elevation difference between any two cells in the grid that can be reached by only moving up, down, left, or right such that the path between these two cells only includes cells with equal or increasing elevations. >>> grid = [ ... [1, 2, 2, 3], ... [2, 4, 5, 3], ... [3, 5, 6, 6], ... [4, 4, 4, 4] ... ] >>> maximum_elevation_difference(grid) 5 >>> grid = [[1]] >>> maximum_elevation_difference(grid) 0 >>> grid = [] >>> maximum_elevation_difference(grid) 0 >>> grid = [ ... [2, 2, 2], ... [2, 2, 2], ... [2, 2, 2] ... ] >>> maximum_elevation_difference(grid) 0 >>> grid = [ ... [1, 100], ... [2, 99] ... ] >>> maximum_elevation_difference(grid) 99","solution":"def maximum_elevation_difference(grid): if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) max_elevation = -float('inf') min_elevation = float('inf') visited = [[False] * m for _ in range(n)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def dfs(x, y, current_min, current_max): nonlocal max_elevation, min_elevation if visited[x][y]: return visited[x][y] = True current_min = min(current_min, grid[x][y]) current_max = max(current_max, grid[x][y]) max_elevation = max(max_elevation, current_max) min_elevation = min(min_elevation, current_min) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] >= grid[x][y]: dfs(nx, ny, current_min, current_max) for i in range(n): for j in range(m): if not visited[i][j]: dfs(i, j, grid[i][j], grid[i][j]) return max_elevation - min_elevation if max_elevation != -float('inf') and min_elevation != float('inf') else 0"},{"question":"def max_min_team_effectiveness(levels: List[int]) -> int: Returns the maximum possible effectiveness of the weakest team among all possible team pairings. :param levels: List[int], a list of skill levels. :return: int, the maximum possible effectiveness of the weakest team. >>> max_min_team_effectiveness([1, 2, 3, 4]) == 5 >>> max_min_team_effectiveness([4, 1, 2, 3]) == 5 >>> max_min_team_effectiveness([10, 20, 30, 40]) == 50 >>> max_min_team_effectiveness([5, 5, 5, 5]) == 10 >>> max_min_team_effectiveness([1, 2, 3, 4, 5, 6]) == 7 >>> max_min_team_effectiveness([1, 7, 3, 9, 5, 2]) == 10 >>> max_min_team_effectiveness([1, 1, 1, 1, 1, 12, 1, 1, 1, 1, 30, 1]) == 31","solution":"def max_min_team_effectiveness(levels): Returns the maximum possible effectiveness of the weakest team among all possible team pairings. :param levels: List[int], a list of skill levels. :return: int, the maximum possible effectiveness of the weakest team. levels.sort() n = len(levels) max_min_effectiveness = float('-inf') for i in range(n // 2): team_effectiveness = levels[i] + levels[-(i+1)] max_min_effectiveness = max(max_min_effectiveness, team_effectiveness) return max_min_effectiveness"},{"question":"def min_completion_time(times: List[int]) -> int: Returns the minimum possible time needed to complete all tasks using two workers. :param times: List[int] - An array of integers where times[i] is the time needed to complete the i-th task :return: int - The minimum time needed to complete all tasks >>> min_completion_time([5]) 5 >>> min_completion_time([5, 5]) 5 >>> min_completion_time([3, 6]) 6 >>> min_completion_time([2, 3, 7]) 7 >>> min_completion_time([1, 2, 3, 4]) 5 >>> min_completion_time([3, 1, 4, 1, 5, 9]) 12 >>> min_completion_time([5, 5, 5, 5]) 10","solution":"def min_completion_time(times): Returns the minimum possible time needed to complete all tasks using two workers. :param times: List[int] - An array of integers where times[i] is the time needed to complete the i-th task :return: int - The minimum time needed to complete all tasks times.sort(reverse=True) worker1 = 0 worker2 = 0 for time in times: if worker1 <= worker2: worker1 += time else: worker2 += time return max(worker1, worker2)"},{"question":"def splitArray(nums, k): Partition the list into exactly k contiguous subarrays such that the largest sum among these k subarrays is minimized. >>> splitArray([7,2,5,10,8], 2) 18 >>> splitArray([1,2,3,4,5], 2) 9","solution":"def splitArray(nums, k): def canSplit(nums, k, max_sum): count, current_sum = 1, 0 for num in nums: if current_sum + num > max_sum: count += 1 current_sum = num if count > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if canSplit(nums, k, mid): right = mid else: left = mid + 1 return left"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderTraversal(root: Optional[TreeNode]) -> List[List[int]]: Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level). >>> tree = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))) >>> levelOrderTraversal(tree) [[3], [9, 20], [15, 7]] >>> levelOrderTraversal(None) [] >>> single_node_tree = TreeNode(1) >>> levelOrderTraversal(single_node_tree) [[1]]","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderTraversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"import json class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Encodes a tree to a single string. :type root: TreeNode :rtype: str >>> serialize(None) == 'null' True >>> tree = TreeNode(1) >>> serialize(tree) == '[1, null, null]' True >>> tree = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))) >>> serialize(tree) == '[1, [2, null, null], [3, [4, null, null], [5, null, null]]]' True pass def deserialize(data): Decodes your encoded data to tree. :type data: str :rtype: TreeNode >>> deserialize('null') is None True >>> tree = TreeNode(1) >>> serialize(deserialize(serialize(tree))) == serialize(tree) True >>> tree = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))) >>> serialize(deserialize(serialize(tree))) == serialize(tree) True pass","solution":"import json class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Encodes a tree to a single string. :type root: TreeNode :rtype: str def helper(node): if node is None: return None return [node.val, helper(node.left), helper(node.right)] return json.dumps(helper(root)) def deserialize(data): Decodes your encoded data to tree. :type data: str :rtype: TreeNode def helper(nodes): if nodes is None: return None val, left, right = nodes node = TreeNode(val) node.left = helper(left) node.right = helper(right) return node return helper(json.loads(data))"},{"question":"def longest_consecutive_sequence(nums: [int]) -> int: Returns the length of the longest consecutive elements sequence in an unsorted list of integers. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([1, 2, 2, 3, 4]) 4 >>> longest_consecutive_sequence([10]) 1 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([10, 20, 30, 40]) 1 >>> longest_consecutive_sequence([1, 3, 5, 2, 8, 4, 7, 6]) 8 >>> longest_consecutive_sequence([-1, -2, -3, -4, 0, 1, 2, 3, 4]) 9","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive elements sequence in an unsorted list of integers. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: if (num - 1) not in num_set: current_num = num current_streak = 1 while (current_num + 1) in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def calculate_sunlight(buildings: List[int]) -> List[int]: Returns a list of integers representing the amount of sunlight each building receives. A building blocks sunlight for itself and any building to its right that is of an equal or lesser height. :param buildings: List[int] - List of integers representing heights of buildings :return: List[int] - List of integers: 1 if building receives sunlight, 0 otherwise >>> calculate_sunlight([1, 2, 3, 4, 5]) == [1, 1, 1, 1, 1] >>> calculate_sunlight([5, 4, 3, 2, 1]) == [1, 0, 0, 0, 0] >>> calculate_sunlight([1, 3, 2, 4, 3, 5]) == [1, 1, 0, 1, 0, 1] >>> calculate_sunlight([7]) == [1] >>> calculate_sunlight([2, 2, 2, 2]) == [1, 0, 0, 0] >>> calculate_sunlight([1, 2, 2, 3, 3, 2, 4]) == [1, 1, 0, 1, 0, 0, 1] >>> calculate_sunlight([]) == [] pass","solution":"from typing import List def calculate_sunlight(buildings: List[int]) -> List[int]: Returns a list of integers representing the amount of sunlight each building receives. A building blocks sunlight for itself and any building to its right that is of an equal or lesser height. :param buildings: List[int] - List of integers representing heights of buildings :return: List[int] - List of integers: 1 if building receives sunlight, 0 otherwise sunlight = [] max_height = 0 # Track the tallest building seen from the left for height in buildings: if height > max_height: sunlight.append(1) max_height = height else: sunlight.append(0) return sunlight"},{"question":"class StreamChecker: Implements a class to check if a stream of characters contains any suffix from a given list of words. Methods: StreamChecker(words: List[str]): Initializes the object with a list of words. query(letter: str) -> bool: Returns True if any suffix of the stream matches any word in the list. def __init__(self, words): Initializes the StreamChecker with the given list of words. pass def query(self, letter): Adds the letter to the stream and checks if any suffix matches any word. Parameters: - letter (str): The new letter to add to the stream. Returns: - bool: True if any suffix matches, False otherwise. pass # Tests def test_streamchecker_with_short_words(): checker = StreamChecker([\\"cd\\", \\"f\\", \\"kl\\"]) assert checker.query('a') == False assert checker.query('b') == False assert checker.query('c') == False assert checker.query('d') == True assert checker.query('e') == False assert checker.query('f') == True def test_streamchecker_with_long_words(): checker = StreamChecker([\\"abc\\", \\"xyz\\"]) assert checker.query('a') == False assert checker.query('b') == False assert checker.query('c') == True assert checker.query('x') == False assert checker.query('y') == False assert checker.query('z') == True def test_streamchecker_mixed_case(): checker = StreamChecker([\\"Hello\\", \\"World\\"]) assert checker.query('H') == False assert checker.query('e') == False assert checker.query('l') == False assert checker.query('l') == False assert checker.query('o') == True assert checker.query('W') == False assert checker.query('o') == False assert checker.query('r') == False assert checker.query('l') == False assert checker.query('d') == True def test_no_words(): checker = StreamChecker([]) assert checker.query('a') == False assert checker.query('b') == False assert checker.query('c') == False","solution":"class StreamChecker: def __init__(self, words): self.trie = {} self.stream = [] for word in words: node = self.trie for char in word[::-1]: if char not in node: node[char] = {} node = node[char] node[''] = True def query(self, letter): self.stream.append(letter) node = self.trie for char in reversed(self.stream): if '' in node: return True if char not in node: return False node = node[char] return '' in node"},{"question":"def canTransform(s: str, p: str, k: int, m: int) -> bool: Determines if the pattern \`p\` can be found as a contiguous substring in \`s\` after replacing up to \`m\` characters in a substring of length \`k\` of \`s\`. Parameters: s (str): the string in which to search for the pattern p (str): the pattern string to search for k (int): length of the substring of \`s\` to consider m (int): maximum number of character replacements allowed Returns: bool: True if the pattern can be formed, False otherwise >>> canTransform(\\"abcde\\", \\"cd\\", 5, 0) == True >>> canTransform(\\"abcde\\", \\"fg\\", 5, 2) == True >>> canTransform(\\"abcde\\", \\"bcd\\", 3, 0) == True >>> canTransform(\\"abfty\\", \\"bft\\", 5, 1) == True >>> canTransform(\\"aaaaa\\", \\"bbb\\", 3, 3) == True >>> canTransform(\\"aaaaa\\", \\"ccc\\", 2, 2) == False >>> canTransform(\\"abcde\\", \\"abcdef\\", 5, 0) == False >>> canTransform(\\"abcde\\", \\"cde\\", 3, 0) == True","solution":"def canTransform(s: str, p: str, k: int, m: int) -> bool: Determines if the pattern \`p\` can be found as a contiguous substring in \`s\` after replacing up to \`m\` characters in a substring of length \`k\` of \`s\`. Parameters: s (str): the string in which to search for the pattern p (str): the pattern string to search for k (int): length of the substring of \`s\` to consider m (int): maximum number of character replacements allowed Returns: bool: True if the pattern can be formed, False otherwise n = len(s) len_p = len(p) for i in range(n - k + 1): substring = s[i:i + k] for j in range(k - len_p + 1): window = substring[j:j + len_p] replacements = sum(1 for x, y in zip(window, p) if x != y) if replacements <= m: return True return False"},{"question":"def min_meeting_rooms(intervals: List[List[int]]) -> int: Determines the minimum number of meeting rooms required to hold all the meetings. Parameters: intervals (List[List[int]]): A list of meeting intervals where each interval is [start, end]. Returns: int: Minimum number of meeting rooms required. Examples: >>> min_meeting_rooms([]) 0 >>> min_meeting_rooms([[1, 5], [6, 10], [11, 15]]) 1 >>> min_meeting_rooms([[0, 30], [5, 10], [15, 20]]) 2 >>> min_meeting_rooms([[1, 10], [2, 9], [3, 8], [4, 7]]) 4 >>> min_meeting_rooms([[1, 4], [2, 3], [3, 5], [8, 10]]) 2 >>> min_meeting_rooms([[1, 3], [1, 2], [1, 4]]) 3 >>> min_meeting_rooms([[1, 2], [1, 2], [1, 2]]) 3 >>> min_meeting_rooms([[1, 4], [4, 7], [7, 10]]) 1 pass","solution":"def min_meeting_rooms(intervals): Determines the minimum number of meeting rooms required to hold all the meetings. Parameters: intervals (List[List[int]]): A list of meeting intervals where each interval is [start, end]. Returns: int: Minimum number of meeting rooms required. if not intervals: return 0 # Separate out the start and end times in their own lists. start_times = sorted(interval[0] for interval in intervals) end_times = sorted(interval[1] for interval in intervals) start_pointer = 0 end_pointer = 0 used_rooms = 0 # Iterate over meetings while start_pointer < len(intervals): # If there is a meeting that starts before the one that ends, we need a new room if start_times[start_pointer] < end_times[end_pointer]: used_rooms += 1 start_pointer += 1 else: # Otherwise, we can use a room that has been freed up end_pointer += 1 start_pointer += 1 return used_rooms"},{"question":"def max_distance(arr: List[int]) -> int: Returns the maximum distance the water drop can travel from the leftmost block to the right along the row. :param arr: List[int] representing the heights of blocks in a row :return: int representing the maximum distance the water drop can travel >>> max_distance([3, 2, 1, 1, 2, 1]) 5 >>> max_distance([4, 5, 6, 7]) 0 >>> max_distance([5, 5, 4, 4, 2, 2, 3, 1]) 7 >>> max_distance([1]) 0 >>> max_distance([1, 2, 3, 4, 5]) 0 >>> max_distance([]) 0","solution":"def max_distance(arr): Returns the maximum distance the water drop can travel from the leftmost block to the right along the row. :param arr: List[int] representing the heights of blocks in a row :return: int representing the maximum distance the water drop can travel max_dist = 0 current_pos = 0 # Traverse the array and find the maximum distance the water drop can travel for i in range(1, len(arr)): if arr[i] <= arr[current_pos]: max_dist = i current_pos = i return max_dist"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bst_from_preorder(preorder): Constructs a binary search tree (BST) from the given preorder traversal list. :param preorder: List[int] - The preorder traversal of the BST :return: TreeNode - The root of the constructed BST from solution import TreeNode, bst_from_preorder def test_bst_from_preorder_single_node(): root = bst_from_preorder([8]) assert root.val == 8 assert root.left is None assert root.right is None def test_bst_from_preorder_multiple_nodes(): root = bst_from_preorder([8, 5, 1, 7, 10, 12]) assert root.val == 8 assert root.left.val == 5 assert root.left.left.val == 1 assert root.left.right.val == 7 assert root.right.val == 10 assert root.right.right.val == 12 def test_bst_from_preorder_empty(): root = bst_from_preorder([]) assert root is None def test_bst_from_preorder_two_nodes(): root = bst_from_preorder([2, 1]) assert root.val == 2 assert root.left.val == 1 assert root.right is None root = bst_from_preorder([2, 3]) assert root.val == 2 assert root.left is None assert root.right.val == 3 def test_bst_from_preorder_complex(): root = bst_from_preorder([10, 5, 1, 7, 40, 50]) assert root.val == 10 assert root.left.val == 5 assert root.left.left.val == 1 assert root.left.right.val == 7 assert root.right.val == 40 assert root.right.right.val == 50","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bst_from_preorder(preorder): Constructs a binary search tree (BST) from the given preorder traversal list. :param preorder: List[int] - The preorder traversal of the BST :return: TreeNode - The root of the constructed BST if not preorder: return None root = TreeNode(preorder[0]) stack = [root] for value in preorder[1:]: node, child = stack[-1], TreeNode(value) # Adjust the right child of the stack elements while stack and stack[-1].val < value: node = stack.pop() if node.val < value: node.right = child else: node.left = child stack.append(child) return root"},{"question":"def minimum_replacements(s: str) -> int: Returns the minimum number of character replacements needed so that no two adjacent characters are the same. >>> minimum_replacements('abc') 0 >>> minimum_replacements('cbacba') 0 >>> minimum_replacements('aa') 1 >>> minimum_replacements('abcaacb') 1 >>> minimum_replacements('aaa') 1 >>> minimum_replacements('aaaa') 2 >>> minimum_replacements('abaaa') 1 >>> minimum_replacements('aabbaa') 3 >>> minimum_replacements('aaaaa') 2 >>> minimum_replacements('aaaaaa') 3 >>> minimum_replacements('abababab') 0 >>> minimum_replacements('bcbcbcbc') 0","solution":"def minimum_replacements(s: str) -> int: Returns the minimum number of character replacements needed so that no two adjacent characters are the same. Parameters: s (str): The input string consisting of 'a', 'b', and 'c' only. Returns: int: The minimum number of replacements required. replacements = 0 n = len(s) for i in range(1, n): if s[i] == s[i - 1]: replacements += 1 # Replace current character with one that is different from the next character or previous character s = s[:i] + ('b' if s[i - 1] != 'b' and (i == n - 1 or s[i + 1] != 'b') else 'a') + s[i + 1:] return replacements"},{"question":"def count_less_than(nums: List[int]) -> List[int]: Given a 0-indexed integer array nums where the elements are unique, returns a new array such that new_nums[i] is the count of numbers in nums less than nums[i]. >>> count_less_than([8, 1, 2, 3]) [3, 0, 1, 2] >>> count_less_than([10]) [0] >>> count_less_than([5, 2]) [1, 0] >>> count_less_than([1, 2, 3, 4]) [0, 1, 2, 3] >>> count_less_than([4, 3, 2, 1]) [3, 2, 1, 0] >>> count_less_than([5, 10, -1, 0]) [2, 3, 0, 1] >>> count_less_than([100, 200, 300, 50]) [1, 2, 3, 0]","solution":"def count_less_than(nums): Given a 0-indexed integer array nums where the elements are unique, returns a new array such that new_nums[i] is the count of numbers in nums less than nums[i]. return [sum(1 for y in nums if y < x) for x in nums]"},{"question":"def find_the_longest_substring(s: str) -> int: Determines the length of the longest substring where each vowel ('a', 'e', 'i', 'o', 'u') appears an even number of times. >>> find_the_longest_substring(\\"eleetminicoworoep\\") == 13 >>> find_the_longest_substring(\\"leetcodeisgreat\\") == 5 >>> find_the_longest_substring(\\"bcbcbc\\") == 6 >>> find_the_longest_substring(\\"aeiou\\") == 0 >>> find_the_longest_substring(\\"aabbcc\\") == 6 >>> find_the_longest_substring(\\"xyz\\") == 3","solution":"def find_the_longest_substring(s): Returns the length of the longest substring where each vowel ('a', 'e', 'i', 'o', 'u') appears an even number of times. n = len(s) # Vowel to the corresponding bit in the bitmask vowel_to_bit = {'a': 1, 'e': 2, 'i': 4, 'o': 8, 'u': 16} # A dictionary to store the first occurrence of every bitmask prefix_indices = {0: -1} current_mask = 0 max_length = 0 for i, ch in enumerate(s): if ch in vowel_to_bit: current_mask ^= vowel_to_bit[ch] if current_mask not in prefix_indices: prefix_indices[current_mask] = i if current_mask in prefix_indices: max_length = max(max_length, i - prefix_indices[current_mask]) return max_length"},{"question":"from typing import List def shortest_path(grid: List[List[int]], start: List[int], end: List[int]) -> int: Returns the length of the shortest path from start to end in the grid. If there is no valid path, return -1. >>> shortest_path([[0, 0, 1], [0, 0, 1], [1, 0, 0]], [0, 0], [2, 2]) 4 >>> shortest_path([[0, 1, 0], [1, 1, 0], [0, 0, 0]], [0, 0], [2, 2]) -1 >>> shortest_path([[1, 0, 0], [0, 0, 0], [0, 0, 0]], [0, 0], [2, 2]) -1 >>> shortest_path([[0, 0, 0], [0, 0, 0], [0, 0, 1]], [0, 0], [2, 2]) -1 >>> shortest_path([[0, 0, 0], [0, 0, 0], [0, 0, 0]], [0, 0], [2, 2]) 4 >>> shortest_path([[0, 0, 0], [0, 0, 0], [0, 0, 0]], [1, 1], [1, 1]) 0","solution":"from collections import deque def shortest_path(grid, start, end): Returns the length of the shortest path from start to end in the grid. rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] if grid[start[0]][start[1]] == 1 or grid[end[0]][end[1]] == 1: return -1 queue = deque([(start[0], start[1], 0)]) visited = set((start[0], start[1])) while queue: x, y, dist = queue.popleft() if (x, y) == (end[0], end[1]): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def lengthOfLongestSubstringTwoDistinct(nums: List[int]) -> int: Determine the length of the longest contiguous subarray that contains at most two distinct integers. >>> lengthOfLongestSubstringTwoDistinct([]) 0 >>> lengthOfLongestSubstringTwoDistinct([1]) 1 >>> lengthOfLongestSubstringTwoDistinct([1, 1]) 2 >>> lengthOfLongestSubstringTwoDistinct([1, 2, 1, 2, 3]) 4 >>> lengthOfLongestSubstringTwoDistinct([1, 1, 1, 1]) 4 >>> lengthOfLongestSubstringTwoDistinct([1, 2, 3, 4, 5]) 2 >>> lengthOfLongestSubstringTwoDistinct([1, 2, 1, 3, 4, 1, 2, 1, 3]) 3","solution":"def lengthOfLongestSubstringTwoDistinct(nums): Returns the length of the longest contiguous subarray containing at most two distinct integers. if not nums: return 0 left = 0 right = 0 max_len = 0 counts = {} while right < len(nums): if nums[right] in counts: counts[nums[right]] += 1 else: counts[nums[right]] = 1 while len(counts) > 2: counts[nums[left]] -= 1 if counts[nums[left]] == 0: del counts[nums[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"def find_peak(M): Given a matrix M, returns the coordinates of any peak element. A peak element is defined as an element which is not smaller than its four neighbors. >>> find_peak([[10]]) (0, 0) >>> find_peak([[10, 20, 15]]) (0, 1) >>> find_peak([[10], [20], [15]]) (1, 0) >>> find_peak([[10, 8, 10, 10], [14, 13, 12, 11], [15, 9, 11, 21], [16, 17, 19, 20]]) in [(0, 0), (0, 2), (1, 0), (2, 0), (2, 3), (3, 1), (3, 3)] >>> find_peak([[22, 15, 18], [16, 17, 14]]) (0, 0) >>> find_peak([[10, 10, 10, 10], [14, 13, 12, 11], [15, 9, 11, 21], [16, 17, 19, 20]]) in [(0, 0), (2, 3), (3, 1), (3, 3)]","solution":"def find_peak(M): Given a matrix M, returns the coordinates of any peak element. A peak element is defined as an element which is not smaller than its four neighbors. rows = len(M) cols = len(M[0]) def is_peak(r, c): val = M[r][c] if r > 0 and M[r-1][c] > val: return False if r < rows - 1 and M[r+1][c] > val: return False if c > 0 and M[r][c-1] > val: return False if c < cols - 1 and M[r][c+1] > val: return False return True for r in range(rows): for c in range(cols): if is_peak(r, c): return (r, c) return None # In case no peak is found (though there should always be at least one peak) # Example Usage # matrix = [ # [10, 8, 10, 10], # [14, 13, 12, 11], # [15, 9, 11, 21], # [16, 17, 19, 20] # ] # print(find_peak(matrix)) # Output: A peak element's coordinates, e.g., (3, 1)"},{"question":"def max_possible_element(nums: List[int]) -> int: Returns the maximum possible element value in nums after performing the operation any number of times. The maximum possible element value is the sum of all elements in the array. >>> max_possible_element([5]) == 5 >>> max_possible_element([1, 2]) == 3 >>> max_possible_element([1, 2, 3, 4]) == 10 >>> max_possible_element([-1, -2, -3]) == -6 >>> max_possible_element([-1, 2, -3, 4]) == 2 >>> max_possible_element([100, 200, 300, 400]) == 1000 pass","solution":"def max_possible_element(nums): Returns the maximum possible element value in nums after performing the operation any number of times. The maximum possible element value is the sum of all elements in the array. return sum(nums)"},{"question":"def max_difference_pairs(arr): Calculate the number of distinct ways to pick two candles so that the difference in their heights is maximum. Parameters: arr (list of int): The heights of the candles. Returns: int: The number of distinct pairs with the maximum height difference. >>> max_difference_pairs([]) == 0 >>> max_difference_pairs([5]) == 0 >>> max_difference_pairs([3, 3, 3]) == 0 >>> max_difference_pairs([1, 2, 3, 4, 5]) == 1 >>> max_difference_pairs([1, 5, 5, 1, 1]) == 6 >>> max_difference_pairs([1, 3, 1, 3]) == 4 >>> max_difference_pairs([-1, -2, -3, -4, -5]) == 1 >>> max_difference_pairs([-5, -1, -5, -1]) == 4 >>> max_difference_pairs([-2, 0, 2, 4]) == 1 >>> max_difference_pairs([-2, 0, -2, 4, 0, 4]) == 4","solution":"def max_difference_pairs(arr): Calculate the number of distinct ways to pick two candles so that the difference in their heights is maximum. Parameters: arr (list of int): The heights of the candles. Returns: int: The number of distinct pairs with the maximum height difference. if len(arr) < 2: return 0 max_height = max(arr) min_height = min(arr) max_count = arr.count(max_height) min_count = arr.count(min_height) if max_height == min_height: return 0 return max_count * min_count"},{"question":"def max_subarray_sum(arr): Finds the maximum sum of any subarray of arr using Kadane's Algorithm. Parameters: arr (list of int): The input array of integers. Returns: int: The maximum sum of any subarray. >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-1]) -1 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([0, -2, 3, -1, 2]) 4 >>> max_subarray_sum([1000000, -1, 1000000, -1, 1000000]) 2999998 >>> max_subarray_sum([]) Traceback (most recent call last): ... ValueError: Array must contain at least one element","solution":"def max_subarray_sum(arr): Finds the maximum sum of any subarray of arr using Kadane's Algorithm. Parameters: arr (list of int): The input array of integers. Returns: int: The maximum sum of any subarray. if len(arr) == 0: raise ValueError(\\"Array must contain at least one element\\") max_so_far = arr[0] max_ending_here = arr[0] for num in arr[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def rearrange_string_k_distance(s: str, k: int) -> str: Determine if the string can be rearranged such that any two adjacent characters are at least \`k\` positions apart in the resulting string. Return a possible rearranged string that meets the condition, or return an empty string if it is not possible to rearrange the characters accordingly. >>> rearrange_string_k_distance(\\"aabbcc\\", 3) in [\\"abcabc\\", \\"acbacb\\", \\"abcbac\\"] >>> rearrange_string_k_distance(\\"aabbcc\\", 2) in [\\"abacbc\\", \\"acbacb\\", \\"abcabc\\", \\"cbacba\\"] >>> rearrange_string_k_distance(\\"aaabc\\", 2) == \\"abaca\\" >>> rearrange_string_k_distance(\\"aaadbbcc\\", 2) in [\\"abacabcd\\", \\"abcdabca\\", \\"abacabad\\"] >>> rearrange_string_k_distance(\\"aaabc\\", 3) == \\"\\" >>> rearrange_string_k_distance(\\"a\\", 2) == \\"a\\" >>> rearrange_string_k_distance(\\"\\", 2) == \\"\\" >>> rearrange_string_k_distance(\\"aaaaa\\", 2) == \\"\\" >>> rearrange_string_k_distance(\\"aaaaa\\", 0) == \\"aaaaa\\" >>> rearrange_string_k_distance(\\"aaaaa\\", 1) == \\"aaaaa\\" >>> rearrange_string_k_distance(\\"aabbcc\\", 0) == \\"aabbcc\\" >>> rearrange_string_k_distance(\\"aaabbc\\", 0) == \\"aaabbc\\"","solution":"from collections import Counter from heapq import heappush, heappop from typing import List def rearrange_string_k_distance(s: str, k: int) -> str: if k == 0: return s counter = Counter(s) max_heap = [] for char, freq in counter.items(): heappush(max_heap, (-freq, char)) wait_list = [] result = [] while max_heap: freq, char = heappop(max_heap) result.append(char) wait_list.append((char, freq + 1)) if len(wait_list) < k: continue char, freq = wait_list.pop(0) if -freq > 0: heappush(max_heap, (freq, char)) if len(result) == len(s): return ''.join(result) else: return \\"\\""},{"question":"import heapq from typing import List def min_time_to_complete_tasks(arr: List[int], n: int) -> int: Determines the minimum time required to complete all tasks given n workers. Parameters: arr (list): List of positive integers representing the time required for each task. n (int): Number of workers available. Returns: int: The minimum amount of time required to complete all tasks. >>> min_time_to_complete_tasks([2, 2, 2, 2], 2) 4 >>> min_time_to_complete_tasks([5], 3) 5 >>> min_time_to_complete_tasks([1, 2, 3, 4], 4) 4 >>> min_time_to_complete_tasks([3, 3, 3, 3], 2) 6 >>> min_time_to_complete_tasks([4, 2, 3], 5) 4 >>> min_time_to_complete_tasks([4, 2, 3], 1) 9 >>> min_time_to_complete_tasks([], 3) 0 >>> min_time_to_complete_tasks([1, 2, 3], 0) Traceback (most recent call last): ... ValueError: Number of workers must be positive.","solution":"import heapq def min_time_to_complete_tasks(arr, n): Determines the minimum time required to complete all tasks given n workers. Parameters: arr (list): List of positive integers representing the time required for each task. n (int): Number of workers available. Returns: int: The minimum amount of time required to complete all tasks. if not arr: return 0 if n <= 0: raise ValueError(\\"Number of workers must be positive.\\") # Create a priority queue to store the finishing time of each worker pq = [0] * n # Distribute tasks to workers for time in arr: fastest_worker = heapq.heappop(pq) heapq.heappush(pq, fastest_worker + time) # The maximum value in the priority queue will be the minimum time required return max(pq)"},{"question":"def find_anagrams(s: str, target: str) -> List[int]: Returns a list of starting indices where anagrams of the target appear in the string s. >>> find_anagrams(\\"cbaebabacd\\", \\"abc\\") [0, 6] >>> find_anagrams(\\"abab\\", \\"ab\\") [0, 1, 2] >>> find_anagrams(\\"abcdefg\\", \\"hij\\") [] >>> find_anagrams(\\"abcdefg\\", \\"xyz\\") [] >>> find_anagrams(\\"abc\\", \\"abc\\") [0] >>> find_anagrams(\\"bac\\", \\"abc\\") [0] >>> find_anagrams(\\"aaaa\\", \\"aa\\") [0, 1, 2] >>> find_anagrams(\\"aAbBcC\\", \\"abc\\") [] >>> find_anagrams(\\"aAbBcC\\", \\"aAb\\") [0] >>> find_anagrams(\\"a\\", \\"aa\\") [] >>> find_anagrams(\\"a\\", \\"a\\") [0] >>> find_anagrams(\\"aaaa\\", \\"a\\") [0, 1, 2, 3]","solution":"from collections import Counter def find_anagrams(s, target): Returns a list of starting indices where anagrams of the target appear in the string s. target_len = len(target) target_counter = Counter(target) window_counter = Counter(s[:target_len - 1]) result = [] for i in range(target_len - 1, len(s)): window_counter[s[i]] += 1 # Include current character in the window start_index = i - target_len + 1 if window_counter == target_counter: result.append(start_index) window_counter[s[start_index]] -= 1 # Remove the start character from the window if window_counter[s[start_index]] == 0: del window_counter[s[start_index]] # Clean up the counter return result"},{"question":"def min_swaps_to_transform(s1: str, s2: str) -> int: Return the minimum number of swaps needed to transform s1 into s2. :param s1: A string consisting of lowercase English letters of equal length to s2. :param s2: A string consisting of lowercase English letters of equal length to s1. :return: The minimum number of swaps needed. >>> min_swaps_to_transform(\\"abac\\", \\"baca\\") 2 >>> min_swaps_to_transform(\\"abcd\\", \\"abcd\\") 0 >>> min_swaps_to_transform(\\"abcd\\", \\"abdc\\") 1 >>> min_swaps_to_transform(\\"abcd\\", \\"dcba\\") 2 >>> min_swaps_to_transform(\\"abcdef\\", \\"fedcba\\") 3 >>> min_swaps_to_transform(\\"aaaa\\", \\"aaaa\\") 0","solution":"def min_swaps_to_transform(s1, s2): Returns the minimum number of swaps needed to transform s1 into s2. :param s1: A string consisting of lowercase English letters. :param s2: A string consisting of lowercase English letters. :return: The minimum number of swaps needed. # Convert both strings to list of characters to allow swapping s1 = list(s1) s2 = list(s2) swaps = 0 # Iterate over both strings for i in range(len(s1)): if s1[i] != s2[i]: # Find the position in s1 where the current character of s2 is located swap_idx = s1.index(s2[i], i) # Swap the characters in s1 s1[i], s1[swap_idx] = s1[swap_idx], s1[i] swaps += 1 return swaps"},{"question":"def largestRectangleArea(heights: List[int]) -> int: Given a list of non-negative integers representing the heights of bars in a histogram, returns the area of the largest rectangle that can be formed using one or more of these bars. >>> largestRectangleArea([2, 2, 2, 2, 2]) == 10 >>> largestRectangleArea([1, 2, 3, 4, 5]) == 9 >>> largestRectangleArea([5, 4, 3, 2, 1]) == 9 >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) == 10 >>> largestRectangleArea([4]) == 4 >>> largestRectangleArea([]) == 0 >>> largestRectangleArea([1000, 1000, 1000, 1000]) == 4000 >>> largestRectangleArea([2, 1, 2]) == 3 >>> largestRectangleArea([6, 2, 5, 4, 5, 1, 6]) == 12 >>> largestRectangleArea([2, 4]) == 4","solution":"def largestRectangleArea(heights): Given a list of non-negative integers representing the heights of bars in a histogram, returns the area of the largest rectangle that can be formed using one or more of these bars. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def min_operations_to_empty_string(s: str) -> int: Returns the minimum number of operations needed to make the string empty. Args: s (str): The input string consisting only of lowercase alphabets. Returns: int: The minimum number of operations to make the string empty. >>> min_operations_to_empty_string(\\"abccba\\") 0 >>> min_operations_to_empty_string(\\"abc\\") 3 >>> min_operations_to_empty_string(\\"aabbcc\\") 0 >>> min_operations_to_empty_string(\\"a\\") 1 >>> min_operations_to_empty_string(\\"abba\\") 0 >>> min_operations_to_empty_string(\\"abcddcba\\") 0 >>> min_operations_to_empty_string(\\"abcd\\") 4 >>> min_operations_to_empty_string(\\"aabbccd\\") 1 >>> min_operations_to_empty_string(\\"\\") 0 # Edge case: empty string >>> min_operations_to_empty_string(\\"a\\"*1000) 0 # All characters same and even >>> min_operations_to_empty_string(\\"a\\" + \\"b\\"*1000) 1 # One character different and followed by all same and even","solution":"def min_operations_to_empty_string(s): Returns the minimum number of operations needed to make the string empty. Args: s (str): The input string consisting only of lowercase alphabets. Returns: int: The minimum number of operations to make the string empty. stack = [] # We will use a stack to keep track of characters for char in s: # If the character at the top of the stack is the same as the current character, remove them both if stack and stack[-1] == char: stack.pop() else: stack.append(char) # The answer is the length of the stack, as each character or adjacent pair will eventually need one operation. return len(stack)"},{"question":"def reverse_words(s: str) -> str: Reverses the order of words in the string 's'. Retains spaces only as single spaces in the result. :param s: A string representing a sequence of words separated by spaces. :return: A new string with the order of words reversed. >>> reverse_words(\\"hello\\") \\"hello\\" >>> reverse_words(\\"hello world\\") \\"world hello\\" >>> reverse_words(\\"a b c\\") \\"c b a\\" >>> reverse_words(\\" hello world \\") \\"world hello\\" >>> reverse_words(\\"\\") \\"\\" >>> reverse_words(\\" a b c \\") \\"c b a\\"","solution":"def reverse_words(s): Reverses the order of words in the string 's'. Retains spaces only as single spaces in the result. :param s: A string representing a sequence of words separated by spaces. :return: A new string with the order of words reversed. # Split the string by spaces to get the words words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list into a string with single spaces result = ' '.join(reversed_words) return result"},{"question":"def count_intervals_containing_point(intervals: List[List[int]], point: int) -> int: Returns the number of intervals that contain the given point. Parameters: intervals (list of lists): A list where each element is a list with two integers representing the start and end of the interval. point (int): The point to check for containment within the intervals. Returns: int: The number of intervals that contain the point. pass # Implement the function here # Example test cases intervals = [[1, 4], [2, 6], [5, 8]] point = 5 assert count_intervals_containing_point(intervals, point) == 2 intervals = [[1, 4], [2, 6], [5, 8]] point = 0 assert count_intervals_containing_point(intervals, point) == 0 intervals = [[1, 4], [2, 6], [5, 8]] point = 4 assert count_intervals_containing_point(intervals, point) == 2 intervals = [] point = 3 assert count_intervals_containing_point(intervals, point) == 0 intervals = [[1, 7], [3, 14], [8, 15], [10, 12]] point = 10 assert count_intervals_containing_point(intervals, point) == 3 intervals = [[1, 10]] point = 5 assert count_intervals_containing_point(intervals, point) == 1 intervals = [[1, 10]] point = 15 assert count_intervals_containing_point(intervals, point) == 0","solution":"def count_intervals_containing_point(intervals, point): Returns the number of intervals that contain the given point. Parameters: intervals (list of lists): A list where each element is a list with two integers representing the start and end of the interval. point (int): The point to check for containment within the intervals. Returns: int: The number of intervals that contain the point. count = 0 for start, end in intervals: if start <= point <= end: count += 1 return count"},{"question":"def partition_string(s: str) -> int: Given a string s, partition it into as few parts as possible so that each substring contains only one distinct character. Return the number of parts the string can be partitioned into. :param s: A string consisting of lowercase alphabets. :return: The number of parts the string can be partitioned into. >>> partition_string(\\"aaabbaac\\") 4 >>> partition_string(\\"aaaa\\") 1 >>> partition_string(\\"ababab\\") 6 >>> partition_string(\\"\\") 0 >>> partition_string(\\"a\\") 1 >>> partition_string(\\"aabbcc\\") 3 >>> partition_string(\\"abc\\") 3","solution":"def partition_string(s): Given a string s, partition it into as few parts as possible so that each substring contains only one distinct character. Return the number of parts the string can be partitioned into. :param s: A string consisting of lowercase alphabets. :return: The number of parts the string can be partitioned into. if not s: return 0 parts = 1 previous_character = s[0] for character in s[1:]: if character != previous_character: parts += 1 previous_character = character return parts"},{"question":"from typing import List def longest_palindromic_substring_length(s: str) -> int: Given a string \`s\`, you are allowed to re-arrange the characters of the string in any order, but you can only make a single re-arrangement. Determine the length of the longest palindromic substring that can be formed from the given string \`s\`. Args: s (str): The input string Returns: int: The length of the longest palindromic substring Examples: >>> longest_palindromic_substring_length(\\"a\\") 1 >>> longest_palindromic_substring_length(\\"aa\\") 2 >>> longest_palindromic_substring_length(\\"ab\\") 1 >>> longest_palindromic_substring_length(\\"aba\\") 3 >>> longest_palindromic_substring_length(\\"aabbccdde\\") 9 >>> longest_palindromic_substring_length(\\"aabbcc\\") 6 >>> longest_palindromic_substring_length(\\"abcdefg\\") 1","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring that can be formed by rearranging the characters of the input string. from collections import Counter char_count = Counter(s) length = 0 odd_found = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"def add_digits(num: int) -> int: Repeatedly add all digits of a non-negative integer \`num\` until the result has only one digit. >>> add_digits(38) 2 >>> add_digits(49) 4 >>> add_digits(12345) 6 >>> add_digits(987654) 3 >>> add_digits(999999999) 9 >>> add_digits(111111111) 9 >>> add_digits(0) 0","solution":"def add_digits(num): Repeatedly add all digits of a non-negative integer \`num\` until the result has only one digit. while num >= 10: num = sum(int(digit) for digit in str(num)) return num"},{"question":"def min_difference_sliding_window(arr: List[int], k: int) -> int: Returns the minimum possible value of the minimum difference over all sliding windows of size k. >>> min_difference_sliding_window([1, 2, 3, 4], 1) == 0 >>> min_difference_sliding_window([4, 1, 6, 2], 4) == 5 >>> min_difference_sliding_window([1, 3, 6, 7, 9], 2) == 1 >>> min_difference_sliding_window([1, 3, 6, 7, 9], 3) == 3 >>> min_difference_sliding_window([4, 6, 8, 10, 2], 2) == 2 >>> min_difference_sliding_window([4, 3, 2, 1], 0) == 0 >>> min_difference_sliding_window([4, 3, 2, 1], 5) == 0 >>> min_difference_sliding_window([], 3) == 0 >>> min_difference_sliding_window([], 1) == 0 >>> min_difference_sliding_window([5], 1) == 0 >>> min_difference_sliding_window([3], 1) == 0 >>> min_difference_sliding_window([5, 5, 5, 5], 2) == 0 >>> min_difference_sliding_window([1, 1, 1, 1], 3) == 0","solution":"def min_difference_sliding_window(arr, k): Returns the minimum possible value of the minimum difference over all sliding windows of size k. if not arr or k <= 0 or k > len(arr): return 0 min_difference = float('inf') for i in range(len(arr) - k + 1): window = arr[i:i+k] local_difference = max(window) - min(window) min_difference = min(min_difference, local_difference) return min_difference"},{"question":"def reverse_words_with_spaces(sentence: str) -> str: Reverses the words in the sentence but maintains the order and number of spaces. >>> reverse_words_with_spaces(\\"hello\\") \\"hello\\" >>> reverse_words_with_spaces(\\" hello world \\") \\" world hello \\" >>> reverse_words_with_spaces(\\"example one\\") \\"one example\\" >>> reverse_words_with_spaces(\\"this is a test\\") \\"test a is this\\" >>> reverse_words_with_spaces(\\" leading and trailing \\") \\" trailing and leading \\" >>> reverse_words_with_spaces(\\"\\") \\"\\" >>> reverse_words_with_spaces(\\" \\") \\" \\"","solution":"def reverse_words_with_spaces(sentence): Reverses the words in the sentence but maintains the order and number of spaces. Parameters: sentence (str): The input sentence containing words separated by spaces. Returns: str: The sentence with words reversed in order. words = sentence.split(' ') reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Given a 0-indexed array \`nums\` of integer values, find the maximum sum that can be obtained from any subarray of \`nums\`. A subarray is a non-empty contiguous sequence of elements within an array. Args: nums (List[int]): A list of integers. Returns: int: The maximum sum of any subarray of \`nums\`. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([0, -3, 1, 1, 0]) 2","solution":"def max_subarray_sum(nums): This function returns the maximum sum of any subarray in the given list of integers. if not nums: return 0 max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def can_obtain_by_one_operation(s1: str, s2: str) -> bool: Determines if \`s2\` can be obtained from \`s1\` by exactly one swap or one replace operation. Args: s1 (str): The original string. s2 (str): The target string. Returns: bool: True if \`s2\` can be obtained from \`s1\` by exactly one operation, False otherwise. Examples: >>> can_obtain_by_one_operation(\\"abc\\", \\"abc\\") False >>> can_obtain_by_one_operation(\\"abc\\", \\"aac\\") True >>> can_obtain_by_one_operation(\\"abc\\", \\"bac\\") True >>> can_obtain_by_one_operation(\\"abcd\\", \\"abef\\") False >>> can_obtain_by_one_operation(\\"abcd\\", \\"dcba\\") False >>> can_obtain_by_one_operation(\\"abcd\\", \\"abcde\\") False","solution":"def can_obtain_by_one_operation(s1, s2): Determines if s2 can be obtained from s1 by exactly one swap or one replace operation. Args: s1 (str): The original string. s2 (str): The target string. Returns: bool: True if s2 can be obtained from s1 by exactly one operation, False otherwise. if len(s1) != len(s2): return False # Find positions where s1 and s2 differ diff_positions = [i for i in range(len(s1)) if s1[i] != s2[i]] # If there are no differences, it means the strings are already the same if not diff_positions: return False # If there is exactly one difference, we must replace one character if len(diff_positions) == 1: return True # If there are exactly two differences, check for swap possibility if len(diff_positions) == 2: i, j = diff_positions # Check if swapping would match the strings if s1[i] == s2[j] and s1[j] == s2[i]: return True # Otherwise, it's not possible with exactly one operation return False"},{"question":"def longest_contiguous_subarray(nums): Returns the length of the longest contiguous subarray where all elements have the same value. Parameters: - nums: List[int], list of positive integers Returns: - int, the length of the longest contiguous subarray","solution":"def longest_contiguous_subarray(nums): Returns the length of the longest contiguous subarray where all elements have the same value. Parameters: - nums: List[int], list of positive integers Returns: - int, the length of the longest contiguous subarray if not nums: return 0 max_length = 0 current_length = 1 for i in range(1, len(nums)): if nums[i] == nums[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"def max_distance_with_same_height(nums: List[int]) -> int: You are given a 0-indexed integer array \`nums\` representing the heights of a set of pillars. Compute the maximum distance such that the heights of the pillars at both ends of the distance are the same. The distance between the pillars at indices \`i\` and \`j\` is defined as \`|j - i|\` where \`|x|\` represents the absolute value of \`x\`. Return the maximum distance between any two pillars that have the same height. >>> max_distance_with_same_height([1, 2, 1, 2, 3, 4, 1]) 6 >>> max_distance_with_same_height([1]) 0 >>> max_distance_with_same_height([2, 2, 2, 2]) 3 >>> max_distance_with_same_height([1, 2, 3, 4, 5]) 0 >>> max_distance_with_same_height([1, 3, 1, 2, 3, 4, 1]) 6 >>> max_distance_with_same_height([1, 5, 3, 1, 3, 2, 6, 3, 1, 7, 8, 9, 3]) 10","solution":"def max_distance_with_same_height(nums): Returns the maximum distance between any two pillars that have the same height. height_to_indices = {} for index, height in enumerate(nums): if height in height_to_indices: height_to_indices[height].append(index) else: height_to_indices[height] = [index] max_distance = 0 for indices in height_to_indices.values(): if len(indices) > 1: distance = indices[-1] - indices[0] if distance > max_distance: max_distance = distance return max_distance"},{"question":"def maxDifference(nums: List[int]) -> int: Given an integer array \`nums\`, find the maximum difference between two elements in the array such that the larger element comes after the smaller element. If no such elements exist, return \`-1\`. >>> maxDifference([7, 1, 5, 4]) 4 >>> maxDifference([9, 4, 3, 2]) -1 >>> maxDifference([1]) -1 >>> maxDifference([]) -1 >>> maxDifference([1, 2, 3, 4, 5]) 4 >>> maxDifference([5, 4, 3, 2, 1]) -1 >>> maxDifference([2, 3, 10, 2, 4, 8, 1]) 8 >>> maxDifference([1, 1, 1, 1, 1]) -1 >>> maxDifference([-3, -2, -1, -4, -5, 0]) 5 >>> maxDifference([-1, 3, -2, 4, -5, 6]) 11 pass","solution":"def maxDifference(nums): Returns the maximum difference between two elements in the array such that the larger element comes after the smaller element. If no such elements exist, returns -1. if not nums or len(nums) < 2: return -1 min_num = nums[0] max_diff = -1 for num in nums[1:]: if num > min_num: max_diff = max(max_diff, num - min_num) min_num = min(min_num, num) return max_diff"},{"question":"from typing import List def count_equal_submatrices(grid: List[List[int]]) -> int: Given a 2D integer matrix grid, return the number of submatrices that have all their elements equal. >>> count_equal_submatrices([[1]]) 1 >>> count_equal_submatrices([[1, 1], [1, 1]]) 9 >>> count_equal_submatrices([[1, 2], [2, 1]]) 4 >>> count_equal_submatrices([[1, 2, 3], [4, 1, 2], [1, 4, 1]]) 9 >>> count_equal_submatrices([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 36","solution":"def count_equal_submatrices(grid): Given a 2D integer matrix grid, returns the number of submatrices that have all their elements equal. def is_uniform_submatrix(i1, j1, i2, j2): val = grid[i1][j1] for i in range(i1, i2 + 1): for j in range(j1, j2 + 1): if grid[i][j] != val: return False return True n = len(grid) m = len(grid[0]) count = 0 for i1 in range(n): for j1 in range(m): for i2 in range(i1, n): for j2 in range(j1, m): if is_uniform_submatrix(i1, j1, i2, j2): count += 1 return count"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head: ListNode, k: int) -> ListNode: Return the head of the linked list after reversing the nodes of the list k at a time. Nodes that are left out (less than k nodes) after reversing do not need to be reversed. >>> def list_to_nodes(values): ... if not values: ... return None ... head = ListNode(values[0]) ... current = head ... for value in values[1:]: ... current.next = ListNode(value) ... current = current.next ... return head >>> def nodes_to_list(head): ... values = [] ... current = head ... while current: ... values.append(current.val) ... current = current.next ... return values >>> head = list_to_nodes([1, 2, 3, 4, 5]) >>> k = 2 >>> new_head = reverseKGroup(head, k) >>> nodes_to_list(new_head) [2, 1, 4, 3, 5] >>> head = list_to_nodes([1, 2, 3, 4, 5, 6]) >>> k = 3 >>> new_head = reverseKGroup(head, k) >>> nodes_to_list(new_head) [3, 2, 1, 6, 5, 4] >>> head = list_to_nodes([1, 2, 3, 4, 5]) >>> k = 1 >>> new_head = reverseKGroup(head, k) >>> nodes_to_list(new_head) [1, 2, 3, 4, 5] >>> head = list_to_nodes([1, 2]) >>> k = 3 >>> new_head = reverseKGroup(head, k) >>> nodes_to_list(new_head) [1, 2]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head: ListNode, k: int) -> ListNode: def reverse_linked_list(head, k): new_head = None ptr = head while k: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head count = 0 ptr = head while count < k: if not ptr: return head ptr = ptr.next count += 1 new_head = reverse_linked_list(head, k) if head: head.next = reverseKGroup(ptr, k) return new_head"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition(head, k): Partitions the linked list such that all nodes with values less than k come before nodes with values greater than or equal to k. :param head: The head of the singly linked list. :param k: The target integer value. :return: The head of the newly partitioned linked list. >>> head = create_linked_list([1, 4, 3, 2, 5, 2]) >>> k = 3 >>> linked_list_to_list(partition(head, k)) [1, 2, 2, 4, 3, 5]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition(head, k): Partitions the linked list such that all nodes with values less than k come before nodes with values greater than or equal to k. :param head: The head of the singly linked list. :param k: The target integer value. :return: The head of the newly partitioned linked list. if not head: # If the head is None, return None return None # These are dummy nodes to simplify the logic lesser_head = ListNode(0) greater_head = ListNode(0) lesser = lesser_head greater = greater_head current = head while current: if current.val < k: lesser.next = current # Place the node in the lesser list lesser = lesser.next else: greater.next = current # Place the node in the greater list greater = greater.next current = current.next greater.next = None # To prevent a possible cycle lesser.next = greater_head.next # Concatenate both lists return lesser_head.next"},{"question":"def replace_words(s: str, dictionary: List[str]) -> str: Replaces words in the string \`s\` that are present in the dictionary with the character '#'. Parameters: s (str): The input string. dictionary (list): List of words to be replaced. Returns: str: The modified string after replacements. >>> replace_words(\\"hello world\\", [\\"foo\\", \\"bar\\"]) \\"hello world\\" >>> replace_words(\\"hello world\\", [\\"world\\"]) \\"hello #\\" >>> replace_words(\\"spicy food is amazing\\", [\\"spicy\\", \\"food\\", \\"is\\", \\"amazing\\"]) \\"# # # #\\" >>> replace_words(\\"hello world\\", []) \\"hello world\\" >>> replace_words(\\"\\", [\\"world\\"]) \\"\\" >>> replace_words(\\"Hello World\\", [\\"hello\\", \\"world\\"]) \\"Hello World\\" >>> replace_words(\\"Hello World\\", [\\"Hello\\", \\"World\\"]) \\"# #\\" >>> replace_words(\\"hello hello hello\\", [\\"hello\\"]) \\"# # #\\"","solution":"def replace_words(s, dictionary): Replaces words in the string s that are present in the dictionary with the character '#'. Parameters: s (str): The input string. dictionary (list): List of words to be replaced. Returns: str: The modified string after replacements. words = s.split() dictionary_set = set(dictionary) for i, word in enumerate(words): if word in dictionary_set: words[i] = '#' return ' '.join(words)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Given the \`root\` of a BST and an integer \`k\`, returns the \`k-th\` smallest value (1-indexed) of all the values of the nodes in the BST. def test_kth_smallest(): # Tree structure: # 3 # / # 1 4 # # 2 root = TreeNode(3) root.left = TreeNode(1) root.right = TreeNode(4) root.left.right = TreeNode(2) assert kth_smallest(root, 1) == 1 assert kth_smallest(root, 2) == 2 assert kth_smallest(root, 3) == 3 assert kth_smallest(root, 4) == 4 def test_kth_smallest_single_node(): root = TreeNode(10) assert kth_smallest(root, 1) == 10 def test_kth_smallest_left_heavy(): # Tree structure: # 5 # / # 3 # / # 2 # / # 1 root = TreeNode(5) root.left = TreeNode(3) root.left.left = TreeNode(2) root.left.left.left = TreeNode(1) assert kth_smallest(root, 1) == 1 assert kth_smallest(root, 2) == 2 assert kth_smallest(root, 3) == 3 assert kth_smallest(root, 4) == 5 def test_kth_smallest_right_heavy(): # Tree structure: # 1 # # 2 # # 3 # # 4 root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) root.right.right.right = TreeNode(4) assert kth_smallest(root, 1) == 1 assert kth_smallest(root, 2) == 2 assert kth_smallest(root, 3) == 3 assert kth_smallest(root, 4) == 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Given the \`root\` of a BST and an integer \`k\`, returns the \`k-th\` smallest value (1-indexed) of all the values of the nodes in the BST. count = 0 stack = [] current = root # Iterative inorder traversal while current is not None or stack: while current is not None: stack.append(current) current = current.left current = stack.pop() count += 1 if count == k: return current.val current = current.right"},{"question":"def fire_spread_time(grid, burning_cell): Given a grid and the coordinates of a burning (live) cell, return the number of minutes it will take for the entire forest to burn down. Return -1 if it is not possible for the entire forest to burn. >>> fire_spread_time([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ], (1, 1)) 2 >>> fire_spread_time([ [0, 1, 1], [0, 1, 0], [1, 1, 1] ], (0, 1)) 3 >>> fire_spread_time([ [1, 1, 0], [1, 1, 0], [0, 0, 1] ], (0, 0)) -1 >>> fire_spread_time([[1, 1, 1, 1]], (0, 0)) 3 >>> fire_spread_time([ [1], [1], [1], [1] ], (0, 0)) 3","solution":"from collections import deque def fire_spread_time(grid, burning_cell): rows, cols = len(grid), len(grid[0]) queue = deque([burning_cell]) visited = set([burning_cell]) minutes = 0 # Directions for adjacent cells directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while queue: for _ in range(len(queue)): row, col = queue.popleft() for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and grid[new_row][new_col] == 1: queue.append((new_row, new_col)) visited.add((new_row, new_col)) if queue: minutes += 1 # Check if all cells have been burned for row in range(rows): for col in range(cols): if grid[row][col] == 1 and (row, col) not in visited: return -1 return minutes"},{"question":"from typing import List def kthSmallest(matrix: List[List[int]], k: int) -> int: Returns the k-th smallest element in a sorted n x n matrix. >>> matrix = [ ... [ 1, 5, 9], ... [10, 11, 13], ... [12, 13, 15] ... ] >>> k = 8 >>> kthSmallest(matrix, k) 13 def test_kthSmallest_default_case(): matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15] ] k = 8 assert kthSmallest(matrix, k) == 13 def test_kthSmallest_single_element(): matrix = [[1]] k = 1 assert kthSmallest(matrix, k) == 1 def test_kthSmallest_small_matrix(): matrix = [ [1, 2], [3, 4] ] k = 3 assert kthSmallest(matrix, k) == 3 def test_kthSmallest_large_k(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] k = 7 assert kthSmallest(matrix, k) == 7 def test_kthSmallest_small_k(): matrix = [ [1, 3, 5], [6, 7, 12], [11, 14, 14] ] k = 5 assert kthSmallest(matrix, k) == 7 def test_kthSmallest_negative_numbers(): matrix = [ [-5, -4, -3], [-2, -1, 0], [1, 2, 3] ] k = 4 assert kthSmallest(matrix, k) == -2 def test_kthSmallest_mixed_numbers(): matrix = [ [-10, -5, 0], [5, 10, 15], [20, 25, 30] ] k = 6 assert kthSmallest(matrix, k) == 15","solution":"from typing import List import heapq def kthSmallest(matrix: List[List[int]], k: int) -> int: Returns the k-th smallest element in a sorted n x n matrix. n = len(matrix) # Use a min-heap min_heap = [] # Initialize the heap with the first element of each row for r in range(min(n, k)): # (value, row, col) heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Remove k-1 elements from the heap val = None for _ in range(k): val, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return val"},{"question":"def min_groups(s: str) -> int: Returns the minimum number of groups needed to group characters in the string so that each group contains distinct characters that are either the same or differ by one alphabetically. >>> min_groups(\\"a\\") 1 >>> min_groups(\\"aaa\\") 3 >>> min_groups(\\"abc\\") 1 >>> min_groups(\\"ace\\") 1 >>> min_groups(\\"abacabad\\") 4","solution":"def min_groups(s): Returns the minimum number of groups needed to group characters in the string so that each group contains distinct characters that are either the same or differ by one alphabetically. alphabet = [0] * 26 for char in s: alphabet[ord(char) - ord('a')] += 1 max_groups = max(alphabet) return max_groups"},{"question":"def minMaxDivision(nums: List[int], k: int) -> int: Divide the list into k continuous subarrays so that the difference between the maximum sum of the subarrays and the minimum sum of the subarrays is minimized. Return the minimized difference. >>> minMaxDivision([7, 2, 5, 10, 8], 2) 18 >>> minMaxDivision([10], 1) 10 >>> minMaxDivision([7, 2, 5, 10, 8], 5) 10 >>> minMaxDivision([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) 17 >>> minMaxDivision([5, 5, 5, 5, 5], 2) 15","solution":"def minMaxDivision(nums, k): def can_divide(max_sum): current_sum = 0 subarrays = 1 for num in nums: if current_sum + num > max_sum: subarrays += 1 current_sum = num if subarrays > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_divide(mid): right = mid else: left = mid + 1 return left"},{"question":"def max_height_difference(grid: List[List[int]]) -> int: Calculate the maximum possible height difference between the highest and lowest cell on a path from top-left to bottom-right corner of the grid. >>> max_height_difference([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 8 >>> max_height_difference([[8, 9, 2], [7, 6, 5], [1, 4, 3]]) == 8 >>> max_height_difference([[5, 5, 5], [5, 5, 5], [5, 5, 5]]) == 0 >>> max_height_difference([[10, 2, 16, 3], [4, 25, 5, 10], [3, 12, 8, 7], [9, 7, 20, 15]]) == 23 >>> max_height_difference([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7]]) == 6 >>> max_height_difference([[42]]) == 0","solution":"def max_height_difference(grid): Calculate the maximum possible height difference between the highest and lowest cell on a path from top-left to bottom-right corner of the grid. N = len(grid) dp_min = [[0] * N for _ in range(N)] dp_max = [[0] * N for _ in range(N)] dp_min[0][0] = grid[0][0] dp_max[0][0] = grid[0][0] for i in range(1, N): dp_min[i][0] = min(dp_min[i-1][0], grid[i][0]) dp_max[i][0] = max(dp_max[i-1][0], grid[i][0]) dp_min[0][i] = min(dp_min[0][i-1], grid[0][i]) dp_max[0][i] = max(dp_max[0][i-1], grid[0][i]) for i in range(1, N): for j in range(1, N): dp_min[i][j] = min(dp_min[i-1][j], dp_min[i][j-1], grid[i][j]) dp_max[i][j] = max(dp_max[i-1][j], dp_max[i][j-1], grid[i][j]) return dp_max[N-1][N-1] - dp_min[N-1][N-1]"},{"question":"def min_operations_to_sum_k(nums: List[int], k: int) -> int: Returns the minimum number of operations required to make the sum of \`nums\` equal to \`k\`. If it is not possible, returns -1. Args: - nums (List[int]): List of integers. - k (int): Target sum. Returns: - int: Minimum number of operations or -1 if it is not possible. >>> min_operations_to_sum_k([1, 2, 3], 6) == 0 >>> min_operations_to_sum_k([1, 2, 3], 10) == 4 >>> min_operations_to_sum_k([3, 3, 3], 6) == 3 >>> min_operations_to_sum_k([1, 2, 3], -1) == 7 >>> min_operations_to_sum_k([1, 2, -3], 0) == 0 >>> min_operations_to_sum_k([1, 2, -3], 5) == 5","solution":"def min_operations_to_sum_k(nums, k): Returns the minimum number of operations required to make the sum of \`nums\` equal to \`k\`. If it is not possible, returns -1. Args: - nums (list of int): List of integers. - k (int): Target sum. Returns: - int: Minimum number of operations or -1 if it is not possible. current_sum = sum(nums) difference = abs(current_sum - k) if current_sum == k: return 0 # Since any number of increments or decrements is allowed, # we can always make up the difference by adding 1 or subtracting 1 return difference"},{"question":"def circularRob(houses: List[int]) -> int: Find the maximum amount of money you can rob tonight without alerting the police. Houses are arranged in a circular street. >>> circularRob([]) == 0 >>> circularRob([5]) == 5 >>> circularRob([2, 3]) == 3 >>> circularRob([2, 3, 2]) == 3 >>> circularRob([1, 2, 3, 1]) == 4 >>> circularRob([2, 7, 9, 3, 1]) == 11 >>> circularRob([6, 7, 1, 30, 8, 2, 4]) == 41 >>> circularRob([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 30","solution":"from typing import List def rob_linear(houses: List[int]) -> int: if not houses: return 0 if len(houses) == 1: return houses[0] if len(houses) == 2: return max(houses) dp = [0] * len(houses) dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, len(houses)): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1] def circularRob(houses: List[int]) -> int: if not houses: return 0 if len(houses) == 1: return houses[0] return max(rob_linear(houses[1:]), rob_linear(houses[:-1]))"},{"question":"def get_skyline(buildings): Returns the skyline formed by the given buildings. Each building is represented as a positive integer height. Args: - buildings: A list of positive integers representing building heights. Returns: - A list of [x, y] key points representing the skyline. >>> get_skyline([5]) [[0, 5], [1, 0]] >>> get_skyline([3, 3, 3]) [[0, 3], [3, 0]] >>> get_skyline([1, 2, 3]) [[0, 1], [1, 2], [2, 3], [3, 0]] >>> get_skyline([3, 2, 1]) [[0, 3], [1, 2], [2, 1], [3, 0]] >>> get_skyline([2, 3, 2, 1]) [[0, 2], [1, 3], [2, 2], [3, 1], [4, 0]] >>> get_skyline([]) [] >>> get_skyline([1, 3, 1, 3]) [[0, 1], [1, 3], [2, 1], [3, 3], [4, 0]] >>> get_skyline([2, 4, 4, 2]) [[0, 2], [1, 4], [3, 2], [4, 0]]","solution":"def get_skyline(buildings): Returns the skyline formed by the given buildings. Each building is represented as a positive integer height. Args: - buildings: A list of positive integers representing building heights. Returns: - A list of [x, y] key points representing the skyline. if not buildings: return [] n = len(buildings) key_points = [[0, buildings[0]]] for i in range(1, n): if buildings[i] != buildings[i - 1]: key_points.append([i, buildings[i]]) key_points.append([n, 0]) # End of the last building return key_points"},{"question":"def three_sum(arr, target): Returns a list of all unique triplets within \`arr\` that sum up to \`target\`. Each triplet is presented in ascending order and the list of triplets is in ascending order as well. >>> three_sum([1, 2, 3], 10) [] >>> three_sum([1, 2, 3, 4, 5], 6) [[1, 2, 3]] >>> three_sum([1, 0, -1, 2, -2, 3], 0) [[-2, -1, 3], [-2, 0, 2], [-1, 0, 1]] >>> three_sum([1, 1, 1, 1, 1, 1, 1], 3) [[1, 1, 1]] >>> three_sum([-1, 0, 1, 2, -1, -4], -5) [[-4, -1, 0]] from solution import three_sum def test_three_sum_no_triplets(): assert three_sum([1, 2, 3], 10) == [] def test_three_sum_single_triplet(): assert three_sum([1, 2, 3, 4, 5], 6) == [[1, 2, 3]] def test_three_sum_multiple_triplets(): assert three_sum([1, 0, -1, 2, -2, 3], 0) == [[-2, -1, 3], [-2, 0, 2], [-1, 0, 1]] def test_three_sum_duplicates(): assert three_sum([1, 1, 1, 1, 1, 1, 1], 3) == [[1, 1, 1]] def test_three_sum_negative_target(): assert three_sum([-1, 0, 1, 2, -1, -4], -5) == [[-4, -1, 0]]","solution":"def three_sum(arr, target): Returns a list of all unique triplets within \`arr\` that sum up to \`target\`. Each triplet is presented in ascending order and the list of triplets is in ascending order as well. arr.sort() triplets = [] for i in range(len(arr) - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, len(arr) - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: triplets.append([arr[i], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return triplets"},{"question":"def removeDuplicates(head): Remove duplicates from a singly linked list. The function should modify the list in place and return the head of the modified linked list. The order of the elements should be preserved. :param head: ListNode, the head of the linked list :return: ListNode, the head of the modified linked list >>> head = list_to_linkedlist([1, 2, 2, 3, 3, 3]) >>> linkedlist_to_list(removeDuplicates(head)) [1, 2, 3] >>> head = list_to_linkedlist([]) >>> linkedlist_to_list(removeDuplicates(head)) [] >>> head = list_to_linkedlist([1]) >>> linkedlist_to_list(removeDuplicates(head)) [1] >>> head = list_to_linkedlist([1, 1, 1, 1, 1]) >>> linkedlist_to_list(removeDuplicates(head)) [1] >>> head = list_to_linkedlist([1, 2, 3, 4, 5]) >>> linkedlist_to_list(removeDuplicates(head)) [1, 2, 3, 4, 5] >>> head = list_to_linkedlist([1, 2, 1, 2, 1]) >>> linkedlist_to_list(removeDuplicates(head)) [1, 2] pass class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Helper function to convert list into linked list def list_to_linkedlist(lst): if not lst: return None head = ListNode(lst[0]) current = head for val in lst[1:]: current.next = ListNode(val) current = current.next return head # Helper function to convert linked list back to a list def linkedlist_to_list(head): lst = [] current = head while current: lst.append(current.val) current = current.next return lst","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeDuplicates(head): if not head: return head current = head seen = set([current.val]) while current and current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head # Helper function to convert list into linked list def list_to_linkedlist(lst): if not lst: return None head = ListNode(lst[0]) current = head for val in lst[1:]: current.next = ListNode(val) current = current.next return head # Helper function to convert linked list back to a list def linkedlist_to_list(head): lst = [] current = head while current: lst.append(current.val) current = current.next return lst"},{"question":"from typing import List def shortest_path_to_same_island(grid: List[List[int]]) -> int: Returns the length of the shortest path from any land cell to any non-diagonal land cell of the same island. If the island is one cell, returns 0. pass # Test cases def test_single_cell_island(): grid = [[1]] assert shortest_path_to_same_island(grid) == 0 def test_two_cell_island(): grid = [ [1, 1], [0, 0] ] assert shortest_path_to_same_island(grid) == 1 def test_larger_island(): grid = [ [1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 1, 1], [0, 0, 1, 1] ] assert shortest_path_to_same_island(grid) == 1 def test_complex_island(): grid = [ [1, 1, 0, 0, 1], [1, 0, 0, 1, 1], [0, 0, 1, 1, 0], [1, 1, 1, 0, 0] ] assert shortest_path_to_same_island(grid) == 1 def test_isolated_cell(): grid = [ [0, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [1, 0, 0, 0, 0] ] assert shortest_path_to_same_island(grid) == 0","solution":"from collections import deque def shortest_path_to_same_island(grid): Returns the length of the shortest path from any land cell to any non-diagonal land cell of the same island. If the island is one cell, returns 0. def bfs(start): queue = deque([start]) visited = set([start]) distance = 0 while queue: size = len(queue) for i in range(size): x, y = queue.popleft() if (x, y) != start and grid[x][y] == 1: return distance for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited: if grid[nx][ny] == 1: queue.append((nx, ny)) visited.add((nx, ny)) distance += 1 return 0 m, n = len(grid), len(grid[0]) for i in range(m): for j in range(n): if grid[i][j] == 1: return bfs((i, j)) return 0"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree_from_level_order(values: List[Optional[int]]) -> Optional[TreeNode]: Build a binary tree from a list of values given in level order. pass def reverse_level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Perform reverse level order traversal on a binary tree. >>> reverse_level_order_traversal(TreeNode(1, TreeNode(2), TreeNode(3))) [[2, 3], [1]] pass def traverse_tree_from_array(values: List[Optional[int]]) -> List[List[int]]: Given a list representing the level order traversal of a binary tree (with null indicating no node), return the reverse level order traversal of its nodes' values. >>> traverse_tree_from_array([3, 9, 20, None, None, 15, 7]) [[15, 7], [9, 20], [3]] pass","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree_from_level_order(values): if not values: return None root = TreeNode(values[0]) queue = deque([root]) i = 1 while i < len(values): current = queue.popleft() if values[i] is not None: current.left = TreeNode(values[i]) queue.append(current.left) i += 1 if i < len(values) and values[i] is not None: current.right = TreeNode(values[i]) queue.append(current.right) i += 1 return root def reverse_level_order_traversal(root): if not root: return [] result, queue = deque(), deque([root]) while queue: level_length = len(queue) level = [] for _ in range(level_length): node = queue.popleft() level.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.appendleft(level) return list(result) def traverse_tree_from_array(values): root = build_tree_from_level_order(values) return reverse_level_order_traversal(root)"},{"question":"from typing import List from functools import cmp_to_key def largestNumber(arr: List[int]) -> str: Form the largest number possible by concatenating the elements of the array. >>> largestNumber([3, 30, 34, 5, 9]) '9534330' >>> largestNumber([10, 2]) '210' >>> largestNumber([1, 1, 1]) '111' >>> largestNumber([0, 0]) '0' >>> largestNumber([824, 938, 1399, 5607, 6973, 5703, 9609, 4398, 8247]) '9609938824824769735703560743981399'","solution":"from typing import List from functools import cmp_to_key def compare(x, y): # Comparator function to decide the order based on concatenated string comparison if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 def largestNumber(arr: List[int]) -> str: # Convert all integers to strings arr = list(map(str, arr)) # Sort the array with the custom comparator arr.sort(key=cmp_to_key(compare)) # Join all elements to form the largest number largest_num = ''.join(arr) # Handle case where all elements are zero return '0' if largest_num[0] == '0' else largest_num"},{"question":"from typing import List class LongestSubarray: def __init__(self, arr: List[int], k: int): Initializes the object with the integer array \`arr\` and the integer \`k\`. Args: arr: List[int] - array of integers k: int - maximum number of distinct elements allowed in the subarray pass def findLength(self) -> int: Returns the length of the longest subarray containing at most \`k\` distinct elements. Returns: int - length of the longest subarray with at most k distinct elements Examples: >>> LongestSubarray([1, 2, 1, 2, 3], 2).findLength() 4 >>> LongestSubarray([1, 2, 1, 3, 4], 3).findLength() 4 >>> LongestSubarray([1], 1).findLength() 1 >>> LongestSubarray([1, 2, 3, 4, 5], 1).findLength() 1 >>> LongestSubarray([1, 2, 3, 1, 2, 3], 2).findLength() 2 >>> LongestSubarray([1, 1, 1, 1], 1).findLength() 4 >>> LongestSubarray([], 2).findLength() 0 pass","solution":"from collections import defaultdict class LongestSubarray: def __init__(self, arr, k): self.arr = arr self.k = k def findLength(self): left = 0 right = 0 max_length = 0 element_count = defaultdict(int) unique_elements = 0 while right < len(self.arr): if element_count[self.arr[right]] == 0: unique_elements += 1 element_count[self.arr[right]] += 1 right += 1 while unique_elements > self.k: element_count[self.arr[left]] -= 1 if element_count[self.arr[left]] == 0: unique_elements -= 1 left += 1 max_length = max(max_length, right - left) return max_length"},{"question":"from typing import List def can_be_strictly_increasing(nums: List[int]) -> bool: Determines if it is possible to make the array strictly increasing by flipping at most one subarray. >>> can_be_strictly_increasing([1, 2, 3, 4, 5]) True >>> can_be_strictly_increasing([1, 5, 4, 3, 2, 6]) True >>> can_be_strictly_increasing([4, 3, 2, 1, 5]) True >>> can_be_strictly_increasing([1, 3, 2, 4, 5]) True >>> can_be_strictly_increasing([1, 2, 3, 5, 4]) True >>> can_be_strictly_increasing([4, 3, 2, 5, 1]) False >>> can_be_strictly_increasing([1, 2, 3, 5, 7, 8, 6, 4]) False >>> can_be_strictly_increasing([1, 1, 1, 1, 1]) False >>> can_be_strictly_increasing([1]) True >>> can_be_strictly_increasing([1, 2]) True >>> can_be_strictly_increasing([2, 1]) True","solution":"def can_be_strictly_increasing(nums): Determines if it is possible to make the array strictly increasing by flipping at most one subarray. def is_strictly_increasing(arr): Checks if the array is strictly increasing. return all(arr[i] < arr[i + 1] for i in range(len(arr) - 1)) n = len(nums) if is_strictly_increasing(nums): return True for left in range(n): for right in range(left + 1, n): flipped = nums[:left] + list(reversed(nums[left:right+1])) + nums[right+1:] if is_strictly_increasing(flipped): return True return False"},{"question":"def minimize_array_sum(arr: List[int], x: int, k: int) -> int: This function minimizes the sum of the array by performing the specified operation \`k\` times. You are given a 0-indexed integer array \`arr\` of size \`n\` and an integer \`x\`. You need to perform the following operation \`k\` times to minimize the sum of the array: In one operation, choose an element from \`arr\` and subtract \`x\` from it if and only if it does not become negative after the subtraction. Return the sum of the array after performing the operation \`k\` times. >>> minimize_array_sum([4, 3, 10, 12], 3, 2) 26 >>> minimize_array_sum([1, 2], 5, 2) 3 >>> minimize_array_sum([10], 2, 4) 2 >>> minimize_array_sum([0, 0, 0], 0, 5) 0 >>> minimize_array_sum([1, 1, 1], 5, 100) 3 # implementation goes here","solution":"def minimize_array_sum(arr, x, k): This function minimizes the sum of the array by performing the specified operation k times. import heapq # Turn array into a min heap heapq.heapify(arr) # Perform the operation k times for _ in range(k): min_value = heapq.heappop(arr) if min_value - x >= 0: min_value -= x heapq.heappush(arr, min_value) return sum(arr)"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def kth_from_end(head: ListNode, k: int) -> int: Returns the kth element from the end of the linked list. If k is greater than the number of elements, returns -1. :param head: ListNode, the head of the linked list :param k: int, the position from the end to retrieve :return: int, the value of the kth element from the end or -1 if k is out of bounds >>> head = ListNode(1) >>> head.next = ListNode(2) >>> head.next.next = ListNode(3) >>> head.next.next.next = ListNode(4) >>> head.next.next.next.next = ListNode(5) >>> kth_from_end(head, 1) 5 >>> kth_from_end(head, 2) 4 >>> kth_from_end(head, 6) -1","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def kth_from_end(head, k): Returns the kth element from the end of the linked list. If k is greater than the number of elements, returns -1. :param head: ListNode, the head of the linked list :param k: int, the position from the end to retrieve :return: int, the value of the kth element from the end or -1 if k is out of bounds fast = slow = head for _ in range(k): if not fast: return -1 fast = fast.next while fast: slow = slow.next fast = fast.next return slow.value if slow else -1"},{"question":"def rotate_string(s: str, k: int) -> str: Rotates the given string s to the right by k positions. Parameters: s (str): The input string k (int): Number of positions to rotate the string Returns: str: The rotated string >>> rotate_string(\\"abcdefg\\", 2) \\"fgabcde\\" >>> rotate_string(\\"abcdefg\\", 0) \\"abcdefg\\" >>> rotate_string(\\"abcdefg\\", 7) \\"abcdefg\\" >>> rotate_string(\\"abcdefg\\", 9) \\"fgabcde\\" >>> rotate_string(\\"a\\", 1) \\"a\\" >>> rotate_string(\\"ab\\", 1) \\"ba\\" >>> rotate_string(\\"\\", 3) \\"\\" >>> rotate_string(\\"123456\\", 3) \\"456123\\" >>> rotate_string(\\"hello\\", 2) \\"lohel\\"","solution":"def rotate_string(s, k): Rotates the given string s to the right by k positions. Parameters: s (str): The input string k (int): Number of positions to rotate the string Returns: str: The rotated string if not s: return s k = k % len(s) return s[-k:] + s[:-k]"},{"question":"def has_subarray_with_sum(arr: List[int], k: int) -> bool: Determines if there exists at least one subarray of \`arr\` whose sum is equal to \`k\`. >>> has_subarray_with_sum([1, 2, 3, 4, 5], 9) True >>> has_subarray_with_sum([1, 2, 3, 4, 5], 20) False >>> has_subarray_with_sum([5], 5) True >>> has_subarray_with_sum([5], 1) False >>> has_subarray_with_sum([1, -2, 3, 4], 6) True >>> has_subarray_with_sum([-1, -2, -3, -4], -6) True >>> has_subarray_with_sum([0, 0, 3, 0], 0) True >>> has_subarray_with_sum([-1, -1, 2, 0], 0) True >>> has_subarray_with_sum(list(range(1, 10001)), 50005000) True","solution":"def has_subarray_with_sum(arr, k): Determines if there exists a subarray with sum equal to k. Args: - arr: list of integers - k: integer, the target sum Returns: - boolean: True if there exists a subarray whose sum is equal to k, False otherwise current_sum = 0 sum_map = {0: -1} # to handle the case where the subarray starts from index 0 for idx, num in enumerate(arr): current_sum += num if current_sum - k in sum_map: return True sum_map[current_sum] = idx return False"},{"question":"def max_substrings(s: str) -> int: Given a string s consisting of only the characters 'a' and 'b', split the string into the maximum number of non-empty substrings such that each substring does not contain both 'a' and 'b' at the same time. Return the maximum number of substrings you can achieve. >>> max_substrings(\\"aaaa\\") 1 >>> max_substrings(\\"baba\\") 4 >>> max_substrings(\\"aaabbbaaa\\") 3 >>> max_substrings(\\"a\\") 1 >>> max_substrings(\\"\\") 0 >>> max_substrings(\\"aabbabbaaaabbbb\\") 6","solution":"def max_substrings(s): Splits the string into the maximum number of non-empty substrings such that each substring does not contain both 'a' and 'b' at the same time. if len(s) == 0: return 0 # Initialize count of substrings and last seen character substr_count = 1 last_seen = s[0] # Iterate over the string for char in s[1:]: if char != last_seen: substr_count += 1 last_seen = char return substr_count"},{"question":"def minimize_sum(arr: List[int]) -> int: Returns the minimum possible sum of the array after any number of swaps of three consecutive elements. >>> minimize_sum([1]) == 1 >>> minimize_sum([1, 2]) == 3 >>> minimize_sum([3, 1, 2]) == 6 >>> minimize_sum([1, 2, 3, 4, 5, 6]) == 21 >>> minimize_sum([100, 200, 300, 400]) == 1000","solution":"def minimize_sum(arr): Returns the minimum possible sum of the array after any number of swaps of three consecutive elements. Since the operation does not affect the values in the array, just their positions, the minimum sum of the array will always be the sum of the array itself. return sum(arr)"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Codec: def serialize(self, root: Optional[TreeNode]) -> str: Encodes a tree to a single string. pass def deserialize(self, data: str) -> Optional[TreeNode]: Decodes your encoded data to tree. pass # Test cases def test_serialize_deserialize(): # Instantiate codec codec = Codec() # Test with a sample Tree # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) serialized = codec.serialize(root) assert serialized == '1,2,None,None,3,4,None,None,5,None,None,' deserialized = codec.deserialize(serialized) assert deserialized.val == 1 assert deserialized.left.val == 2 assert deserialized.right.val == 3 assert deserialized.right.left.val == 4 assert deserialized.right.right.val == 5 def test_empty_tree(): codec = Codec() root = None serialized = codec.serialize(root) assert serialized == 'None,' deserialized = codec.deserialize(serialized) assert deserialized is None def test_single_node(): codec = Codec() root = TreeNode(1) serialized = codec.serialize(root) assert serialized == '1,None,None,' deserialized = codec.deserialize(serialized) assert deserialized.val == 1 assert deserialized.left is None assert deserialized.right is None","solution":"from typing import Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Codec: def serialize(self, root: Optional[TreeNode]) -> str: Encodes a tree to a single string. def rserialize(node: Optional[TreeNode]) -> str: if node is None: return 'None,' return str(node.val) + ',' + rserialize(node.left) + rserialize(node.right) return rserialize(root) def deserialize(self, data: str) -> Optional[TreeNode]: Decodes your encoded data to tree. def rdeserialize(l: list) -> Optional[TreeNode]: if l[0] == 'None': l.pop(0) return None root = TreeNode(int(l.pop(0))) root.left = rdeserialize(l) root.right = rdeserialize(l) return root data_list = data.split(',') root = rdeserialize(data_list) return root"},{"question":"def find_closest_index(arr, x): Returns the index of the element that is closest to the target value x. If there are two elements equally close, return the index of the smaller element. >>> find_closest_index([1, 2, 3, 4, 5], 3) == 2 >>> find_closest_index([1, 3, 5, 7, 9], 1) == 0 >>> find_closest_index([1, 3, 5, 7, 9], 9) == 4 >>> find_closest_index([1, 2, 3, 4, 5], 6) == 4 >>> find_closest_index([1, 3, 5, 7, 9], 8) == 3 >>> find_closest_index([1, 3, 5, 7, 9], 4) == 1 >>> find_closest_index([10, 20, 30, 40], 25) == 1 >>> find_closest_index([1, 3, 5, 7, 9], 6) == 2 >>> find_closest_index([10, 20, 30, 40], 15) == 0 >>> find_closest_index([], 5) == -1 >>> find_closest_index([5], 5) == 0 >>> find_closest_index([10], 5) == 0 >>> find_closest_index([10], 15) == 0","solution":"def find_closest_index(arr, x): Returns the index of the element that is closest to the target value x. If there are two elements equally close, return the index of the smaller element. n = len(arr) if n == 0: return -1 low, high = 0, n - 1 while low <= high: mid = (low + high) // 2 if arr[mid] == x: return mid elif arr[mid] < x: low = mid + 1 else: high = mid - 1 if low >= n: # target is greater than all elements return high if high < 0: # target is less than all elements return low if (x - arr[high]) <= (arr[low] - x): return high else: return low"},{"question":"def has_arithmetic_triplet(arr): Returns True if there exists a triple (i, j, k) such that arr[i], arr[j], and arr[k] form an arithmetic progression. >>> has_arithmetic_triplet([1, 2, 3, 4, 6]) True >>> has_arithmetic_triplet([1, 3, 5, 7, 9]) True >>> has_arithmetic_triplet([1, 2, 4, 8]) False >>> has_arithmetic_triplet([1, 2, 2, 4, 5]) False >>> has_arithmetic_triplet([]) False >>> has_arithmetic_triplet([1]) False >>> has_arithmetic_triplet([1, 2]) False >>> has_arithmetic_triplet([1, 2, 3]) True >>> has_arithmetic_triplet([2, 2, 2, 2]) True","solution":"def has_arithmetic_triplet(arr): Returns True if there exists a triple (i, j, k) such that arr[i], arr[j], and arr[k] form an arithmetic progression. n = len(arr) for i in range(n - 2): for j in range(i + 1, n - 1): for k in range(j + 1, n): if arr[j] - arr[i] == arr[k] - arr[j]: return True return False"},{"question":"def aggregate_requests(csv_log: str) -> dict: Aggregates the total number of requests for each unique IP address in the CSV formatted log. Args: csv_log (str): A string representing a CSV formatted mirror log file. Returns: dict: A dictionary with IP addresses as keys and their respective total request counts as values. pass def test_aggregate_requests_single_entry(): csv_log = \\"192.168.1.1,5\\" expected_output = { \\"192.168.1.1\\": 5 } assert aggregate_requests(csv_log) == expected_output def test_aggregate_requests_multiple_entries(): csv_log = \\"192.168.1.1,5n192.168.1.2,3n192.168.1.1,2n192.168.1.3,4\\" expected_output = { \\"192.168.1.1\\": 7, \\"192.168.1.2\\": 3, \\"192.168.1.3\\": 4 } assert aggregate_requests(csv_log) == expected_output def test_aggregate_requests_empty(): csv_log = \\"\\" expected_output = {} assert aggregate_requests(csv_log) == expected_output def test_aggregate_requests_with_zero_count(): csv_log = \\"192.168.1.1,0n192.168.1.2,0n192.168.1.3,0\\" expected_output = { \\"192.168.1.1\\": 0, \\"192.168.1.2\\": 0, \\"192.168.1.3\\": 0 } assert aggregate_requests(csv_log) == expected_output def test_aggregate_requests_large_counts(): csv_log = \\"192.168.1.1,10000n192.168.1.1,20000n192.168.1.2,30000\\" expected_output = { \\"192.168.1.1\\": 30000, \\"192.168.1.2\\": 30000 } assert aggregate_requests(csv_log) == expected_output","solution":"def aggregate_requests(csv_log): Aggregates the total number of requests for each unique IP address in the CSV formatted log. Args: csv_log (str): A string representing a CSV formatted mirror log file. Returns: dict: A dictionary with IP addresses as keys and their respective total request counts as values. lines = csv_log.split('n') request_counts = {} for line in lines: if line.strip(): ip, count = line.split(',') count = int(count) if ip in request_counts: request_counts[ip] += count else: request_counts[ip] = count return request_counts"},{"question":"def count_distinct_strings(s: str) -> int: Given a string \`s\` consists of lowercase letters and the \`*\` character. The \`*\` character can be treated as an empty string or any single letter from \`a\` to \`z\` inclusively. Return the total number of distinct strings that can be generated by replacing every \`*\` character in \`s\` with a valid character. >>> count_distinct_strings(\\"abcdef\\") == 1 >>> count_distinct_strings(\\"a*cdef\\") == 26 >>> count_distinct_strings(\\"*****\\") == 26**5 >>> count_distinct_strings(\\"abc*def\\") == 26 >>> count_distinct_strings(\\"a*b*c*\\") == 26**3 >>> count_distinct_strings(\\"*bcd*\\") == 26**2 >>> count_distinct_strings(\\"*\\") == 26 >>> count_distinct_strings(\\"**\\") == 26**2 >>> count_distinct_strings(\\"***\\") == 26**3 >>> count_distinct_strings(\\"****\\") == 26**4","solution":"def count_distinct_strings(s): Returns the total number of distinct strings that can be generated by replacing every \`*\` character in \`s\` with a valid character (a-z). # Count the number of '*' in the string star_count = s.count('*') # Each '*' can be replaced by any of 26 letters, so the total number of combinations # is 26 raised to the power of the number of '*' characters. return 26 ** star_count"},{"question":"def max_subarray_product(nums: List[int]) -> int: Returns the maximum product of any non-empty subarray of the given list of non-negative integers. >>> max_subarray_product([3]) 3 >>> max_subarray_product([0]) 0 >>> max_subarray_product([1, 2, 3, 4]) 24 >>> max_subarray_product([1, 5, 2, 3]) 30 >>> max_subarray_product([1, 0, 2, 3]) 6 >>> max_subarray_product([0, 0, 0]) 0 >>> max_subarray_product([0, 2, 0, 4]) 4 >>> max_subarray_product([0, 2, 3, 0, 4]) 6 >>> max_subarray_product([]) 0","solution":"def max_subarray_product(nums): Returns the maximum product of any non-empty subarray of the given list of non-negative integers. if not nums: return 0 max_product = nums[0] current_max = current_min = nums[0] for num in nums[1:]: if num == 0: current_max, current_min = 1, 1 continue temp_max = max(num, current_max * num, current_min * num) current_min = min(num, current_max * num, current_min * num) current_max = temp_max max_product = max(max_product, current_max) return max_product"},{"question":"def max_sequence_length(arr: List[int], d: int) -> int: Given a list of unique integers \`arr\` and an integer \`d\`, return the maximum length of a sequence of increasing integers that you can make by starting from any element in \`arr\` and repeatedly adding at most \`d\` to the current integer to reach the next element in the sequence. Each element in the sequence must be present in the original array \`arr\`. >>> max_sequence_length([1, 2, 3, 4], 1) 4 >>> max_sequence_length([1, 3, 5, 7], 2) 4 >>> max_sequence_length([1, 2, 8], 1) 2 >>> max_sequence_length([10], 5) 1 >>> max_sequence_length([10, 20, 30, 40], 10) 4 >>> max_sequence_length([1, 4, 6, 10], 3) 3 >>> max_sequence_length([1, 5, 10, 15, 20], 5) 5","solution":"def max_sequence_length(arr, d): arr_set = set(arr) dp = {x: 1 for x in arr} for num in sorted(arr): for k in range(1, d+1): if num + k in arr_set: dp[num + k] = max(dp[num + k], dp[num] + 1) return max(dp.values())"},{"question":"def find_peak_element(nums: List[int]) -> int: Finds any peak element in the given array and returns its index. :param nums: List[int] - A list of integers :return: int - Index of one of the peak elements >>> find_peak_element([1]) 0 >>> find_peak_element([1, 2]) in [0, 1] True >>> find_peak_element([2, 1]) in [0, 1] True >>> find_peak_element([1, 3, 2]) 1 >>> find_peak_element([1, 3, 2, 5, 4, 7, 6]) in [1, 3, 5] True >>> find_peak_element([1, 2, 2, 3, 3, 2, 1]) in [3, 4] True >>> find_peak_element([1, 2, 3, 4, 5]) 4 >>> find_peak_element([5, 4, 3, 2, 1]) 0 pass","solution":"def find_peak_element(nums): Finds any peak element in the given array and returns its index. :param nums: List[int] - A list of integers :return: int - Index of one of the peak elements n = len(nums) if n == 1: return 0 left, right = 0, n - 1 while left < right: mid = left + (right - left) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"def longest_increasing_subsequence(nums: List[int]) -> int: Returns the length of the longest continuous strictly increasing subsequence. >>> longest_increasing_subsequence([1, 2, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2]) == 7 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) == 1 >>> longest_increasing_subsequence([2, 2, 2, 2]) == 1 >>> longest_increasing_subsequence([1]) == 1 >>> longest_increasing_subsequence([]) == 0 >>> longest_increasing_subsequence([1, 2, 3, 4, 1, 2, 1]) == 4 >>> longest_increasing_subsequence([3, 4, 1, 2, 3, 4, 5]) == 5","solution":"def longest_increasing_subsequence(nums): Returns the length of the longest continuous strictly increasing subsequence. if not nums: return 0 max_length = 1 current_length = 1 for i in range(1, len(nums)): if nums[i] == nums[i - 1] + 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def is_match(pattern: str, s: str) -> bool: Determine if the given string \`s\` matches the given \`pattern\` which consists of characters '*' and '?'. A character '*' can be replaced by any sequence of characters (including the empty sequence), while a character '?' can be replaced by any single lowercase English letter. Return \`true\` if the entire string \`s\` matches the \`pattern\`, otherwise return \`false\`. Args: pattern (str): The pattern containing '*' and '?' characters. s (str): The string to be matched against the pattern. Returns: bool: True if \`s\` matches the \`pattern\`, False otherwise. >>> is_match(\\"\\", \\"\\") True >>> is_match(\\"\\", \\"abc\\") False >>> is_match(\\"a?\\", \\"\\") False >>> is_match(\\"abc\\", \\"abc\\") True >>> is_match(\\"a?c\\", \\"abc\\") True >>> is_match(\\"a?c\\", \\"acc\\") True >>> is_match(\\"a*\\", \\"abcdef\\") True >>> is_match(\\"a*\\", \\"a\\") True >>> is_match(\\"*\\", \\"abc\\") True >>> is_match(\\"a?c*\\", \\"abcde\\") True >>> is_match(\\"a?c*\\", \\"abcfgh\\") True >>> is_match(\\"**\\", \\"abc\\") True >>> is_match(\\"*a*\\", \\"abc\\") True >>> is_match(\\"a*b?c\\", \\"aXXXXbYc\\") True >>> is_match(\\"a*b?c\\", \\"abYc\\") True","solution":"def is_match(pattern, s): Determine if the given string \`s\` matches the given \`pattern\`. Args: pattern (str): The pattern containing '*' and '?' characters. s (str): The string to be matched against the pattern. Returns: bool: True if \`s\` matches the \`pattern\`, False otherwise. p_len = len(pattern) s_len = len(s) # Dynamic programming table where dp[i][j] indicates whether pattern[0..i-1] matches s[0..j-1] dp = [[False] * (s_len + 1) for _ in range(p_len + 1)] dp[0][0] = True # Empty pattern and empty string match # Handle patterns with '*' for i in range(1, p_len + 1): if pattern[i-1] == '*': dp[i][0] = dp[i-1][0] # '*' can match empty sequence # Fill the DP table for i in range(1, p_len + 1): for j in range(1, s_len + 1): if pattern[i-1] == '*': dp[i][j] = dp[i-1][j] or dp[i][j-1] # '*' matches zero or more characters elif pattern[i-1] == '?' or pattern[i-1] == s[j-1]: dp[i][j] = dp[i-1][j-1] # '?' matches exactly one character or characters match return dp[p_len][s_len]"},{"question":"def minSessions(tasks, sessionTime): Returns the minimum number of work sessions needed to complete all tasks. Each session duration should not exceed sessionTime. >>> minSessions([3], 5) == 1 >>> minSessions([1, 2, 3], 6) == 1 >>> minSessions([1, 2, 3, 4], 5) == 2 >>> minSessions([5, 5, 5], 5) == 3 >>> minSessions([1, 3, 5, 7], 8) == 2 >>> minSessions([1, 3, 3, 7, 8, 4], 10) == 3","solution":"def minSessions(tasks, sessionTime): Returns the minimum number of work sessions needed to complete all tasks. Each session duration should not exceed sessionTime. def canCompleteInSessions(session_counts): sessions = [0] * session_counts def backtrack(index): if index == len(tasks): return True for i in range(session_counts): if sessions[i] + tasks[index] <= sessionTime: sessions[i] += tasks[index] if backtrack(index + 1): return True sessions[i] -= tasks[index] if sessions[i] == 0: # no need to try further empty sessions break return False return backtrack(0) left, right = 1, len(tasks) while left < right: mid = (left + right) // 2 if canCompleteInSessions(mid): right = mid else: left = mid + 1 return left"},{"question":"def generate_parentheses(n: int) -> List[str]: Generate all valid combinations of n pairs of parentheses. >>> generate_parentheses(3) [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] >>> generate_parentheses(2) [\\"(())\\", \\"()()\\"] >>> generate_parentheses(1) [\\"()\\"] >>> generate_parentheses(0) [\\"\\"] >>> generate_parentheses(4) [\\"(((())))\\", \\"((()()))\\", \\"((())())\\", \\"((()))()\\", \\"(()(()))\\", \\"(()()())\\", \\"(()())()\\", \\"(())(())\\", \\"(())()()\\", \\"()((()))\\", \\"()(()())\\", \\"()(())()\\", \\"()()(())\\", \\"()()()()\\"]","solution":"def generate_parentheses(n): Generate all combinations of n pairs of valid parentheses. def backtrack(s='', left=0, right=0): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s+'(', left+1, right) if right < left: backtrack(s+')', left, right+1) result = [] backtrack() return result"},{"question":"def length_of_lis(nums: List[int]) -> int: Returns the length of the longest decreasing subsequence in the list of numbers. >>> length_of_lis([]) == 0 >>> length_of_lis([1]) == 1 >>> length_of_lis([1, 2, 3, 4, 5]) == 1 >>> length_of_lis([5, 4, 3, 2, 1]) == 5 >>> length_of_lis([9, 1, 3, 7, 5, 6, 20]) == 3 >>> length_of_lis([10, 1, 2, 3, 0, -1]) == 4","solution":"def length_of_lis(nums): Returns the length of the longest decreasing subsequence in the list of numbers. if not nums: return 0 dp = [1] * len(nums) for i in range(len(nums)): for j in range(i): if nums[i] < nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def longest_substring_with_n_distinct_chars(s: str, n: int) -> int: Finds the length of the longest substring of s that contains no more than n distinct characters. >>> longest_substring_with_n_distinct_chars(\\"\\", 1) == 0 >>> longest_substring_with_n_distinct_chars(\\"abc\\", 0) == 0 >>> longest_substring_with_n_distinct_chars(\\"a\\", 1) == 1 >>> longest_substring_with_n_distinct_chars(\\"abc\\", 4) == 3 >>> longest_substring_with_n_distinct_chars(\\"eceba\\", 2) == 3 >>> longest_substring_with_n_distinct_chars(\\"aa\\", 1) == 2 >>> longest_substring_with_n_distinct_chars(\\"abcdef\\", 3) == 3 >>> longest_substring_with_n_distinct_chars(\\"aaaa\\", 1) == 4 >>> longest_substring_with_n_distinct_chars(\\"abcba\\", 2) == 3 >>> longest_substring_with_n_distinct_chars(\\"abcba\\", 3) == 5 >>> longest_substring_with_n_distinct_chars(\\"abcba\\", 1) == 1","solution":"def longest_substring_with_n_distinct_chars(s, n): Finds the length of the longest substring of s that contains no more than n distinct characters. if n == 0 or not s: return 0 left = 0 max_length = 0 char_count = {} for right in range(len(s)): char = s[right] if char in char_count: char_count[char] += 1 else: char_count[char] = 1 while len(char_count) > n: left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def minimize_absolute_difference(arr: List[int]) -> List[int]: Divides the array into two non-empty subarrays such that the absolute difference between their sums is minimized. Returns a list with the sums of the two subarrays. :param arr: List[int] - The input array of integers :return: List[int] - A list containing the sums of the two subarrays >>> minimize_absolute_difference([1, 2]) [1, 2] >>> minimize_absolute_difference([10, 20, 30, 40, 50]) [60, 90] >>> minimize_absolute_difference([-1, -2, -3, -4, -5]) [-6, -9] >>> minimize_absolute_difference([1, -1, 3, -3, 5, -5]) [0, 0] >>> minimize_absolute_difference(list(range(1000))) [225750, 224750]","solution":"def minimize_absolute_difference(arr): Divides the array into two non-empty subarrays such that the absolute difference between their sums is minimized. Returns a list with the sums of the two subarrays. :param arr: List[int] - The input array of integers :return: List[int] - A list containing the sums of the two subarrays n = len(arr) # Initial left sum with the first element only (minimum allowed elements for left subarray) left_sum = arr[0] # Initial right sum with the sum of the remaining elements right_sum = sum(arr[1:]) # Initialize the minimum difference with the current difference min_diff = abs(left_sum - right_sum) sum_pair = [left_sum, right_sum] # Traverse the array to find the point where difference is minimized for i in range(1, n - 1): left_sum += arr[i] right_sum -= arr[i] current_diff = abs(left_sum - right_sum) # Update if the current difference is smaller if current_diff < min_diff: min_diff = current_diff sum_pair = [left_sum, right_sum] return sum_pair"},{"question":"def count_special_sequences(n: int, m: int) -> int: Returns the number of special sequences of length m where each element in the sequence A is an integer from 1 to n (inclusive) and ai is divisible by i (1-based). >>> count_special_sequences(0, 0) == 0 >>> count_special_sequences(1, 1) == 1 >>> count_special_sequences(5, 2) == 10 # [1-5] for index 1, [2,4] for index 2 >>> count_special_sequences(3, 3) == 3 # [1-3] for index 1, [2] for index 2, [3] for index 3","solution":"def count_special_sequences(n, m): Returns the number of special sequences of length m where each element in the sequence A is an integer from 1 to n (inclusive) and ai is divisible by i (1-based). if n == 0 or m == 0: return 0 # Initialize the result to 1 for the multiplicative counting result = 1 for i in range(1, m + 1): # Count numbers between 1 and n that are divisible by i divisible_count = n // i result *= divisible_count return result"},{"question":"import heapq from typing import List def findCheapestPrice(flights: List[List[int]], n: int, src: int, dst: int, k: int) -> int: Returns the cheapest price from the city \`src\` to the city \`dst\` with at most \`k\` stops. If there is no such route, returns \`-1\`. Parameters: flights (List[List[int]]): The list of flights where each flight is represented as [fromi, toi, costi]. n (int): The number of cities. src (int): The source city. dst (int): The destination city. k (int): The maximum number of stops. Return: int: The cheapest price or -1 if such route does not exist. pass def test_findCheapestPrice_example1(): flights = [[0, 1, 100], [1, 2, 100], [0, 2, 500]] assert findCheapestPrice(flights, 3, 0, 2, 1) == 200 def test_findCheapestPrice_example2(): flights = [[0, 1, 200], [1, 2, 300], [0, 2, 700]] assert findCheapestPrice(flights, 3, 0, 2, 1) == 500 def test_findCheapestPrice_no_path(): flights = [[0, 1, 100], [1, 2, 100]] assert findCheapestPrice(flights, 3, 0, 2, 0) == -1 def test_findCheapestPrice_single_city(): flights = [] assert findCheapestPrice(flights, 1, 0, 0, 0) == 0 def test_findCheapestPrice_exceed_stops(): flights = [[0, 1, 100], [1, 2, 100], [2, 3, 100], [0, 3, 500]] assert findCheapestPrice(flights, 4, 0, 3, 1) == 500 assert findCheapestPrice(flights, 4, 0, 3, 2) == 300","solution":"import heapq def findCheapestPrice(flights, n, src, dst, k): Returns the cheapest price from the city \`src\` to the city \`dst\` with at most \`k\` stops. If there is no such route, returns \`-1\`. Parameters: flights (List[List[int]]): The list of flights where each flight is represented as [fromi, toi, costi]. n (int): The number of cities. src (int): The source city. dst (int): The destination city. k (int): The maximum number of stops. Return: int: The cheapest price or -1 if such route does not exist. # Create the adjacency list for the graph graph = [[] for _ in range(n)] for fromi, toi, costi in flights: graph[fromi].append((toi, costi)) # (current_cost, stops, current_city) heap = [(0, 0, src)] prices = {(src, 0): 0} while heap: current_cost, stops, current_city = heapq.heappop(heap) if current_city == dst: return current_cost if stops <= k: for next_city, price in graph[current_city]: next_cost = current_cost + price if next_cost < prices.get((next_city, stops+1), float('inf')): prices[(next_city, stops+1)] = next_cost heapq.heappush(heap, (next_cost, stops+1, next_city)) return -1"},{"question":"def minOperations(nums: List[int], k: int) -> int: Returns the minimum number of operations required to make all elements of the array equal by incrementing every element in any subarray of length k. If it is not possible, return -1. >>> minOperations([1, 1, 1], 2) == 0 >>> minOperations([5, 5, 5, 5], 3) == 0 >>> minOperations([1, 2, 3], 1) == -1 >>> minOperations([1, 2, 2, 3], 2) == 2 >>> minOperations([1, 3, 5, 7], 2) == 6 >>> minOperations([2, 4, 6], 2) == 4 >>> minOperations([1, 50, 100], 2) == 99 >>> minOperations([1, 1, 1000000], 2) == 999999 >>> minOperations([4, 4, 4, 4], 4) == 0","solution":"def minOperations(nums, k): Returns the minimum number of operations required to make all elements of the array equal by incrementing every element in any subarray of length k. If it is not possible, return -1. n = len(nums) unique_nums = set(nums) # If k == 1, we need to make all elements the same by incrementing each element individually. if k == 1: return -1 if len(unique_nums) > 1 else 0 # If all numbers are already the same, return 0 if len(unique_nums) == 1: return 0 max_num = max(nums) min_num = min(nums) # Calculate the required number of operations required_steps = max_num - min_num return required_steps"},{"question":"def count_sunset_buildings(arr): Returns the total number of buildings with an unobstructed view of the sunset. A building has an unobstructed view if there are no taller buildings to its right. Args: arr: List[int] - a list of integers representing the heights of buildings Returns: int - the number of buildings with an unobstructed view of the sunset pass # Unit Tests def test_no_buildings(): assert count_sunset_buildings([]) == 0 def test_single_building(): assert count_sunset_buildings([4]) == 1 def test_all_increasing(): assert count_sunset_buildings([1, 2, 3, 4]) == 1 def test_all_decreasing(): assert count_sunset_buildings([4, 3, 2, 1]) == 4 def test_mixed_heights(): assert count_sunset_buildings([4, 2, 3, 1]) == 3 def test_multiple_same_heights(): assert count_sunset_buildings([3, 1, 3, 4, 2]) == 2 def test_unimodal(): assert count_sunset_buildings([1, 3, 5, 4, 2]) == 3 def test_flat_heights(): assert count_sunset_buildings([2, 2, 2, 2, 2]) == 1","solution":"def count_sunset_buildings(arr): Returns the total number of buildings with an unobstructed view of the sunset. A building has an unobstructed view if there are no taller buildings to its right. Args: arr: List[int] - a list of integers representing the heights of buildings Returns: int - the number of buildings with an unobstructed view of the sunset if not arr: return 0 total_count = 1 # The last building always has an unobstructed view max_height = arr[-1] # Traverse the list from second last to the beginning for height in reversed(arr[:-1]): if height > max_height: total_count += 1 max_height = height return total_count"},{"question":"from typing import List def can_reach_in_k_steps(n: int, edges: List[List[int]], k: int) -> bool: Determines if it is possible to reach node n-1 from node 0 within k steps in a directed graph. :param n: Number of nodes in the graph :param edges: List of edges representing the directed graph :param k: Maximum number of steps allowed :return: True if it is possible to reach node n-1 from node 0 within k steps, otherwise False def test_can_reach_in_k_steps(): # Test case 1: Simple case, direct path exists assert can_reach_in_k_steps(5, [[0, 1], [1, 2], [2, 3], [3, 4]], 4) == True # Test case 2: Direct path requires more than k steps assert can_reach_in_k_steps(5, [[0, 1], [1, 2], [2, 3], [3, 4]], 3) == False # Test case 3: No possible path because graph is disconnected assert can_reach_in_k_steps(5, [[0, 1], [2, 3], [3, 4]], 4) == False # Test case 4: Multiple paths, valid path within k steps assert can_reach_in_k_steps(5, [[0, 1], [1, 4], [0, 2], [2, 3], [3, 4]], 3) == True # Test case 5: Exact steps needed match k steps assert can_reach_in_k_steps(4, [[0, 1], [1, 2], [2, 3]], 3) == True # Test case 6: Circular path with insufficient steps assert can_reach_in_k_steps(3, [[0, 1], [1, 2], [2, 0]], 1) == False # Test case 7: Graph with direct edge leading to the target assert can_reach_in_k_steps(3, [[0, 2]], 1) == True # Run the tests test_can_reach_in_k_steps()","solution":"from collections import deque def can_reach_in_k_steps(n, edges, k): Determines if it is possible to reach node n-1 from node 0 within k steps in a directed graph. :param n: Number of nodes in the graph :param edges: List of edges representing the directed graph :param k: Maximum number of steps allowed :return: True if it is possible to reach node n-1 from node 0 within k steps, otherwise False # Representation of graph using adjacency list graph = [[] for _ in range(n)] for u, v in edges: graph[u].append(v) # BFS initialization queue = deque([(0, 0)]) # (current node, current step count) visited = set((0, 0)) # (node, step count) while queue: node, step_count = queue.popleft() # If we reached the target node within k steps if node == n-1 and step_count <= k: return True # Traverse to adjacent nodes if step_count is within bounds if step_count < k: for neighbor in graph[node]: if (neighbor, step_count + 1) not in visited: visited.add((neighbor, step_count + 1)) queue.append((neighbor, step_count + 1)) return False"},{"question":"def three_sum(nums: List[int], k: int) -> bool: Determines if there are three distinct elements in \`nums\` such that their sum is exactly equal to \`k\`. :param nums: List of integers :param k: Target integer :return: True if such a triplet exists, else False >>> three_sum([10, 15, 3, 7], 25) True >>> three_sum([1, 2, 3, 4], 10) False >>> three_sum([-5, 1, 10, 25], 21) True >>> three_sum([0, -5, 10, 25], 5) True >>> three_sum([1, 2], 3) False >>> three_sum([1, 1, 1, 2, 2, 2, 3, 3], 6) True","solution":"def three_sum(nums, k): Determines if there are three distinct elements in \`nums\` such that their sum is exactly equal to \`k\`. :param nums: List of integers :param k: Target integer :return: True if such a triplet exists, else False nums.sort() n = len(nums) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: triplet_sum = nums[i] + nums[left] + nums[right] if triplet_sum == k: return True elif triplet_sum < k: left += 1 else: right -= 1 return False"},{"question":"def rotate_image(matrix: List[List[int]]) -> None: Rotates the input n x n 2D matrix by 90 degrees clockwise in-place. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_image(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ ... [1] ... ] >>> rotate_image(matrix) >>> matrix [ [1] ] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> rotate_image(matrix) >>> matrix [ [3, 1], [4, 2] ] >>> matrix = [ ... [ 5, 1, 9, 11], ... [ 2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotate_image(matrix) >>> matrix [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] pass","solution":"def rotate_image(matrix): Rotates the input n x n 2D matrix by 90 degrees clockwise in-place. :param matrix: List[List[int]], the input n x n 2D matrix n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def two_sum(nums, target): Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to the target. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([-1, -2, -3, -4, -5], -8) [2, 4] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([5, 75, 25], 100) [1, 2]","solution":"def two_sum(nums, target): Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to the target. Args: nums : List[int] - an unsorted list of integers target : int - the target sum Returns: List[int] - indices of the two numbers that add up to the target num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i"},{"question":"def min_cost_to_buy_m_items(prices, m): Returns the minimum total cost to buy exactly m items from a contiguous subarray of prices. If it's not possible to buy exactly m items, returns -1. pass def test_basic_functionality(): prices = [3, 2, 1, 4, 5] m = 2 assert min_cost_to_buy_m_items(prices, m) == 3 # Subarray [1, 2] def test_exactly_m_items(): prices = [1, 2, 3, 4, 5] m = 5 assert min_cost_to_buy_m_items(prices, m) == 15 # Only one option: the whole array def test_m_larger_than_array(): prices = [1, 2, 3] m = 4 assert min_cost_to_buy_m_items(prices, m) == -1 # Not enough items def test_single_item_subarray(): prices = [4, 2, 3, 1, 5] m = 1 assert min_cost_to_buy_m_items(prices, m) == 1 # Minimum single item cost def test_m_equals_zero(): prices = [1, 2, 3, 4] m = 0 assert min_cost_to_buy_m_items(prices, m) == 0 # Zero items to buy def test_m_equals_array_length(): prices = [1, 2, 3, 0, 5, 4] m = 6 assert min_cost_to_buy_m_items(prices, m) == 15 # Whole array def test_large_m(): prices = [10, 1, 10, 1, 10, 1, 10] m = 3 assert min_cost_to_buy_m_items(prices, m) == 12 # Subarray [1, 10, 1]","solution":"def min_cost_to_buy_m_items(prices, m): Returns the minimum total cost to buy exactly m items from a contiguous subarray of prices. If it's not possible to buy exactly m items, returns -1. n = len(prices) if m > n: return -1 min_cost = float('inf') current_cost = sum(prices[:m]) for i in range(n - m + 1): if i > 0: current_cost = current_cost - prices[i - 1] + prices[i + m - 1] min_cost = min(min_cost, current_cost) return min_cost if min_cost != float('inf') else -1"},{"question":"from typing import List def minimize_max_sum_of_partitions(arr: List[int], m: int) -> int: Partition the array into m non-overlapping, contiguous subarrays such that the sum of the maximum subarray sum among all the partitions is minimized. Return the minimized sum of the maximum subarray sum of the partition. >>> minimize_max_sum_of_partitions([7, 2, 5, 10, 8], 2) 18 >>> minimize_max_sum_of_partitions([1, 2, 3, 4, 5], 2) 9 >>> minimize_max_sum_of_partitions([1, 4, 4], 3) 4 >>> minimize_max_sum_of_partitions([1, 2, 3, 4, 5], 1) 15 >>> minimize_max_sum_of_partitions([5, 5, 5, 5], 4) 5 >>> minimize_max_sum_of_partitions([5, 5, 5, 5], 2) 10 >>> minimize_max_sum_of_partitions([3, 1, 4, 1, 5, 9, 2, 6], 3) 14","solution":"def can_partition(arr, n, m, max_sum): count, current_sum = 1, 0 for num in arr: current_sum += num if current_sum > max_sum: count += 1 current_sum = num if count > m: return False return True def minimize_max_sum_of_partitions(arr, m): start, end = max(arr), sum(arr) result = end while start <= end: mid = (start + end) // 2 if can_partition(arr, len(arr), m, mid): result = mid end = mid - 1 else: start = mid + 1 return result"},{"question":"def max_runners_in_group(speeds: List[int], max_diff: int) -> int: Returns the maximum number of runners that can be grouped together such that the difference between the fastest and the slowest runner in the group does not exceed max_diff. :param speeds: List of integers representing the average speeds of the runners. :param max_diff: Integer representing the maximum allowed difference between the fastest and the slowest runner in a group. :return: The maximum number of runners that can be grouped together. >>> max_runners_in_group([], 5) == 0 >>> max_runners_in_group([3], 5) == 1 >>> max_runners_in_group([4, 4, 4, 4], 0) == 4 >>> max_runners_in_group([1, 2, 3, 4], 3) == 4","solution":"def max_runners_in_group(speeds, max_diff): Returns the maximum number of runners that can be grouped together such that the difference between the fastest and the slowest runner in the group does not exceed max_diff. :param speeds: List of integers representing the average speeds of the runners. :param max_diff: Integer representing the maximum allowed difference between the fastest and the slowest runner in a group. :return: The maximum number of runners that can be grouped together. if not speeds: return 0 speeds.sort() max_group_size = 1 left = 0 for right in range(1, len(speeds)): while speeds[right] - speeds[left] > max_diff: left += 1 max_group_size = max(max_group_size, right - left + 1) return max_group_size"},{"question":"from collections import OrderedDict class LRUCache: Implement a simple cache system with Least Recently Used (LRU) eviction policy. Example usage: >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) 1 >>> cache.put(3, 3) # This operation should evict key 2 >>> cache.get(2) -1 >>> cache.put(4, 4) # This operation should evict key 1 >>> cache.get(1) -1 >>> cache.get(3) 3 >>> cache.get(4) 4 def __init__(self, capacity: int): Initialize the LRU cache with a positive size capacity. pass def get(self, key: int) -> int: Returns the value of the key if the key exists in the cache, otherwise return -1. pass def put(self, key: int, value: int) -> None: Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity, evict the least recently used key. pass def test_cache_initialization(): cache = LRUCache(2) assert cache.capacity == 2 def test_put_and_get(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 cache.put(3, 3) # This operation should evict key 2 assert cache.get(2) == -1 cache.put(4, 4) # This operation should evict key 1 assert cache.get(1) == -1 assert cache.get(3) == 3 assert cache.get(4) == 4 def test_get_non_existent_key(): cache = LRUCache(2) assert cache.get(42) == -1 def test_put_existing_key(): cache = LRUCache(2) cache.put(1, 1) cache.put(1, 10) assert cache.get(1) == 10 def test_cache_over_capacity(): cache = LRUCache(3) cache.put(1, 1) cache.put(2, 2) cache.put(3, 3) assert len(cache.cache) == 3 cache.put(4, 4) assert len(cache.cache) == 3 assert cache.get(1) == -1","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): Initialize the LRU cache with a positive size capacity. self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: Returns the value of the key if the key exists in the cache, otherwise return -1. if key in self.cache: self.cache.move_to_end(key) return self.cache[key] return -1 def put(self, key: int, value: int) -> None: Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity, evict the least recently used key. if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"def min_operations_to_sort_with_target(nums: List[int], target: int) -> int: Given a 0-indexed integer array nums and an integer target, determine the minimum number of operations required to sort the array in such a way that the first element becomes the target. If it is not possible to achieve this, return -1. >>> min_operations_to_sort_with_target([5, 1, 3, 4, 2], 6) -1 >>> min_operations_to_sort_with_target([5, 1, 3, 4, 2], 5) 0 >>> min_operations_to_sort_with_target([3, 4, 2, 1, 5], 5) 4 >>> min_operations_to_sort_with_target([3, 5, 4, 2, 1], 5) 1 >>> min_operations_to_sort_with_target([5], 5) 0","solution":"def min_operations_to_sort_with_target(nums, target): Given a 0-indexed integer array nums and an integer target, determine the minimum number of operations required to sort the array in such a way that the first element becomes the target. If it is not possible to achieve this, return -1. if target not in nums: return -1 target_index = nums.index(target) if target_index == 0: return 0 # We need to count how many moves it would take to bring the target to the first position # We can do this by performing swaps moving it closer to the first position each time. return target_index"},{"question":"def distribute_water(heights: List[int], waterLevel: int) -> List[int]: Distributes water evenly across the columns up to their respective heights. >>> distribute_water([3, 1, 4], 5) == [3, 1, 1] >>> distribute_water([1, 2, 3], 6) == [1, 2, 3] >>> distribute_water([1, 2, 3], 10) == [1, 2, 3] >>> distribute_water([5, 5, 5], 15) == [5, 5, 5] >>> distribute_water([1, 2, 3], 0) == [0, 0, 0] >>> distribute_water([0, 0, 0], 5) == [0, 0, 0] >>> distribute_water([3], 5) == [3] >>> distribute_water([0], 5) == [0] >>> distribute_water([5], 5) == [5]","solution":"def distribute_water(heights, waterLevel): Distributes water evenly across the columns up to their respective heights. :param heights: List of integers representing the heights of the columns. :param waterLevel: An integer representing the initial level of water. :returns: List of integers representing the final heights of the columns after distributing water. n = len(heights) if n == 0: return [] for i in range(n): # Calculate the water that can be absorbed by the current column added_water = min(heights[i], waterLevel) heights[i] = added_water # Decrease the water level by the absorbed amount waterLevel -= added_water return heights"},{"question":"from typing import List def largest_permutation(nums: List[int]) -> List[int]: Given a list of non-negative integers nums, rearrange the digits of each number to form the largest possible integer and return the result as a list. Args: nums: List of non-negative integers Returns: List of integers with each element being the largest possible permutation of its digits. Example: >>> largest_permutation([123, 45, 9]) [321, 54, 9] >>> largest_permutation([548, 461, 7923]) [854, 641, 9732] >>> largest_permutation([0, 10, 20]) [0, 10, 20] def test_single_digit_numbers(): assert largest_permutation([5, 3, 9]) == [5, 3, 9] def test_multiple_digit_numbers(): assert largest_permutation([123, 45, 9]) == [321, 54, 9] assert largest_permutation([548, 461, 7923]) == [854, 641, 9732] def test_same_digit_numbers(): assert largest_permutation([111, 222, 333]) == [111, 222, 333] def test_mixed_numbers(): assert largest_permutation([321, 654, 987]) == [321, 654, 987] assert largest_permutation([510, 402, 730]) == [510, 420, 730] def test_empty_list(): assert largest_permutation([]) == [] def test_with_zeros(): assert largest_permutation([0, 10, 20]) == [0, 10, 20]","solution":"def largest_permutation(nums): Given a list of non-negative integers nums, rearrange the digits of each number to form the largest possible integer and return the result as a list. Args: nums: List of non-negative integers Returns: List of integers with each element being the largest possible permutation of its digits. return [int(''.join(sorted(str(num), reverse=True))) for num in nums]"},{"question":"from typing import List from collections import Counter def can_rearrange_to_palindrome(s: str, k: int) -> bool: Determines if a given string can be rearranged to form a palindrome with exactly \`k\` center characters. Parameters: s (str): the input string k (int): number of center characters desired Returns: bool: True if the string can be rearranged to form a palindrome with \`k\` center characters, otherwise False Examples: >>> can_rearrange_to_palindrome(\\"aabb\\", 0) == True >>> can_rearrange_to_palindrome(\\"aaaa\\", 5) == False >>> can_rearrange_to_palindrome(\\"aaaabb\\", 2) == True >>> can_rearrange_to_palindrome(\\"aaa\\", 1) == True >>> can_rearrange_to_palindrome(\\"a\\", 0) == False >>> can_rearrange_to_palindrome(\\"radar\\", 1) == True >>> can_rearrange_to_palindrome(\\"anything\\", -1) == False","solution":"from collections import Counter def can_rearrange_to_palindrome(s, k): Determines if a given string can be rearranged to form a palindrome with exactly \`k\` center characters. Parameters: s (str): the input string k (int): number of center characters desired Returns: bool: True if the string can be rearranged to form a palindrome with \`k\` center characters, otherwise False if k < 0 or k > len(s): return False char_counts = Counter(s) odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) return odd_count <= k"},{"question":"import heapq class MedianFinder: Data structure that supports adding integers and finding the median. def __init__(self): Initialize the MedianFinder data structure. def addNum(self, num: int) -> None: Adds an integer num to the data structure. >>> mf = MedianFinder() >>> mf.addNum(1) >>> mf.addNum(2) >>> mf.findMedian() 1.5 def findMedian(self) -> float: Returns the median of all elements so far. >>> mf = MedianFinder() >>> mf.addNum(1) >>> mf.addNum(2) >>> mf.findMedian() 1.5 >>> mf.addNum(3) >>> mf.findMedian() 2","solution":"import heapq class MedianFinder: def __init__(self): Initialize the MedianFinder data structure. self.small = [] # Max heap (inverted to use as min heap) self.large = [] # Min heap def addNum(self, num): Adds an integer num to the data structure. heapq.heappush(self.small, -num) if self.small and self.large and (-self.small[0] > self.large[0]): heapq.heappush(self.large, -heapq.heappop(self.small)) if len(self.small) > len(self.large) + 1: heapq.heappush(self.large, -heapq.heappop(self.small)) if len(self.large) > len(self.small): heapq.heappush(self.small, -heapq.heappop(self.large)) def findMedian(self): Returns the median of all elements so far. if len(self.small) > len(self.large): return -self.small[0] return (-self.small[0] + self.large[0]) / 2.0"},{"question":"def word_break(s: str, wordDict: List[str]) -> bool: Determines if the string 's' can be segmented into a sequence of one or more words from the dictionary 'wordDict'. >>> word_break(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> word_break(\\"leetcode\\", [\\"leet\\", \\"cod\\"]) False >>> word_break(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False >>> word_break(\\"\\", [\\"apple\\", \\"pen\\"]) True >>> word_break(\\"apple\\", []) False >>> word_break(\\"aaaa\\", [\\"a\\"]) True >>> word_break(\\"abcd\\", [\\"a\\", \\"abc\\", \\"b\\", \\"cd\\"]) True >>> word_break(\\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\\", [\\"a\\",\\"aa\\",\\"aaa\\",\\"aaaa\\",\\"aaaaa\\",\\"aaaaaa\\",\\"aaaaaaa\\",\\"aaaaaaaa\\",\\"aaaaaaaaa\\",\\"aaaaaaaaaa\\"]) False >>> word_break(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) True","solution":"def word_break(s, wordDict): Determines if the string 's' can be segmented into a sequence of one or more words from the dictionary 'wordDict'. Parameters: s (str): The input string. wordDict (List[str]): The list of words representing the dictionary. Returns: bool: True if the string can be segmented, otherwise False. word_set = set(wordDict) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[len(s)]"},{"question":"def max_apples(nums: List[int]) -> int: Calculates the maximum number of apples that can be collected from non-adjacent baskets. :param nums: List of positive integers representing the number of apples in each basket. :return: Maximum number of apples that can be collected under the given rule. >>> max_apples([4]) 4 >>> max_apples([4, 5]) 5 >>> max_apples([3, 2, 5]) 8 >>> max_apples([3, 2, 7, 10]) 13 >>> max_apples([3, 2, 5, 10, 7]) 15 >>> max_apples([2, 7, 9, 3, 1]) 12 >>> max_apples([]) 0 >>> max_apples([5, 5]) 5","solution":"def max_apples(nums): Calculates the maximum number of apples that can be collected from non-adjacent baskets. :param nums: List of positive integers representing the number of apples in each basket. :return: Maximum number of apples that can be collected under the given rule. if not nums: return 0 if len(nums) == 1: return nums[0] # Initialize dp array where dp[i] represents the maximum apples collected up to basket i dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"from typing import List def update_matrix(mat: List[List[int]]) -> List[List[int]]: Given a matrix mat of m x n elements where each element is either 0 or 1, update the matrix such that each cell contains the distance to the nearest 0. :param mat: List[List[int]]: The input matrix :return: List[List[int]]: The updated matrix with distances to the nearest 0 >>> update_matrix([ [0, 0, 0], [0, 1, 0], [1, 1, 1] ]) [[0, 0, 0], [0, 1, 0], [1, 2, 1]] >>> update_matrix([ [0, 0], [0, 0] ]) [[0, 0], [0, 0]] >>> update_matrix([ [1, 0], [1, 1] ]) [[1, 0], [2, 1]] >>> update_matrix([ [1, 1, 1], [1, 0, 1], [1, 1, 1] ]) [[2, 1, 2], [1, 0, 1], [2, 1, 2]]","solution":"from collections import deque def update_matrix(mat): Given a matrix mat of m x n elements where each element is either 0 or 1, update the matrix such that each cell contains the distance to the nearest 0. :param mat: List[List[int]]: The input matrix :return: List[List[int]]: The updated matrix with distances to the nearest 0 if not mat: return mat m, n = len(mat), len(mat[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # Initialize the queue with all 0's positions queue = deque([(i, j) for i in range(m) for j in range(n) if mat[i][j] == 0]) # Set initial distances to infinity for non-zero elements for i in range(m): for j in range(n): if mat[i][j] != 0: mat[i][j] = float('inf') # BFS from all 0's while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy # Check boundaries and if we found a shorter path to a cell if 0 <= nx < m and 0 <= ny < n and mat[nx][ny] > mat[x][y] + 1: mat[nx][ny] = mat[x][y] + 1 queue.append((nx, ny)) return mat"},{"question":"def find_missing_number(nums): Returns the missing integer from a list of numbers ranging from 1 to n. Args: nums (list): List of unique integers in range [1, n] except one missing integer. Returns: int: The missing integer. >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) 6 >>> find_missing_number([2, 3, 4, 5, 6]) 1 >>> find_missing_number([1, 2, 3, 4, 5, 6, 8, 9]) 7 >>> find_missing_number([10, 9, 8, 7, 6, 5, 4, 3, 2]) 1 >>> find_missing_number([i for i in range(1, 100001) if i != 50000]) 50000 >>> find_missing_number([1, 2, 4, 5]) 3","solution":"def find_missing_number(nums): Returns the missing integer from a list of numbers ranging from 1 to n. Args: nums (list): List of unique integers in range [1, n] except one missing integer. Returns: int: The missing integer. n = len(nums) + 1 expected_sum = n * (n + 1) / 2 actual_sum = sum(nums) return int(expected_sum - actual_sum)"},{"question":"from typing import List def reorganizeString(s: str) -> str: Given a string \`s\`, rearrange the characters of the string so that any two adjacent characters are not the same. If it is not possible to do so, return an empty string. If there are multiple possible answers, return any of them. >>> reorganizeString(\\"aaab\\") == \\"\\" >>> reorganizeString(\\"aab\\") in [\\"aba\\", \\"bab\\"] >>> reorganizeString(\\"a\\") == \\"a\\" >>> reorganizeString(\\"aaaa\\") == \\"\\" >>> reorganizeString(\\"aaabbc\\") in [\\"ababac\\", \\"abacab\\", \\"acabab\\", \\"acbaba\\", \\"babaca\\", \\"bacaba\\"]","solution":"from collections import Counter import heapq def reorganizeString(s): Rearranges the characters of the string so that no two adjacent characters are the same. If it is not possible, returns an empty string. # Count frequency of each character counter = Counter(s) # Create a max heap based on the frequency max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) prev_char = None prev_freq = 0 result = [] while max_heap or prev_freq < 0: if not max_heap: return \\"\\" freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq = freq + 1 prev_char = char return \\"\\".join(result)"},{"question":"from typing import List def min_subset_difference(arr: List[int]) -> int: Given an array of integers arr, partition the array into two non-empty subsets such that the difference between the sums of the two subsets is minimized. Return the minimum difference. >>> min_subset_difference([3, 1, 4, 2, 2]) 0 >>> min_subset_difference([1, 6, 11, 5]) 1","solution":"def min_subset_difference(arr): Returns the minimum difference between the sums of two partitions of the array. n = len(arr) total_sum = sum(arr) target = total_sum // 2 # Create a DP array to store subset sums dp = [[False] * (target + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, target + 1): if j >= arr[i-1]: dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]] else: dp[i][j] = dp[i-1][j] # Find the closest sum to target for j in range(target, -1, -1): if dp[n][j]: subset_sum = j break other_subset_sum = total_sum - subset_sum return abs(other_subset_sum - subset_sum)"},{"question":"def tasks_completed_and_max_time(queries, t): Returns the number of tasks that can be performed and the maximum number of seconds used. Parameters: queries (list of int): List of seconds to wait for each task to be available. t (list of int): List of seconds required to complete each task. Returns: tuple: (number of tasks that can be performed, maximum seconds used) >>> tasks_completed_and_max_time([3, 4, 5], [2, 3, 1]) == (3, 6) >>> tasks_completed_and_max_time([3, 1, 5], [2, 3, 4]) == (2, 6) >>> tasks_completed_and_max_time([1, 1, 1], [2, 3, 4]) == (0, 0) >>> tasks_completed_and_max_time([5, 5, 5], [1, 2, 3]) == (3, 6) >>> tasks_completed_and_max_time([2, 3, 4], [2, 3, 4]) == (3, 9)","solution":"def tasks_completed_and_max_time(queries, t): Returns the number of tasks that can be performed and the maximum number of seconds used. Parameters: queries (list of int): List of seconds to wait for each task to be available. t (list of int): List of seconds required to complete each task. Returns: tuple: (number of tasks that can be performed, maximum seconds used) completed_tasks = 0 max_time_used = 0 for i in range(len(queries)): if queries[i] >= t[i]: completed_tasks += 1 max_time_used += t[i] return (completed_tasks, max_time_used)"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in the given string s. >>> longest_palindromic_substring(\\"a\\") 'a' >>> longest_palindromic_substring(\\"abba\\") 'abba' >>> longest_palindromic_substring(\\"racecar\\") 'racecar' >>> longest_palindromic_substring(\\"abcde\\") in {'a', 'b', 'c', 'd', 'e'} >>> longest_palindromic_substring(\\"babad\\") in {'bab', 'aba'} >>> longest_palindromic_substring(\\"cbbd\\") 'bb' >>> longest_palindromic_substring(\\"\\") '' >>> longest_palindromic_substring(\\"a\\" * 1000) 'a' * 1000 >>> longest_palindromic_substring(\\"abcddcba\\") 'abcddcba'","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in the given string s. n = len(s) if n == 0: return \\"\\" start, max_len = 0, 1 def expand_from_center(l, r): nonlocal start, max_len while l >= 0 and r < n and s[l] == s[r]: l -= 1 r += 1 new_len = r - l - 1 if new_len > max_len: start = l + 1 max_len = new_len for i in range(n): expand_from_center(i, i) # Odd length palindrome expand_from_center(i, i + 1) # Even length palindrome return s[start:start + max_len]"},{"question":"class Library: def __init__(self, books): Initialize the Library with a list of books. :param books: List of book IDs available in the library. pass def borrowBook(self, userId, bookId): Attempts to borrow a book for the user. :param userId: The ID of the user attempting to borrow the book. :param bookId: The ID of the book to be borrowed. :return: True if the book was successfully borrowed, False otherwise. pass def returnBook(self, userId, bookId): Attempts to return a book for the user. :param userId: The ID of the user attempting to return the book. :param bookId: The ID of the book to be returned. :return: True if the book was successfully returned, False otherwise. pass def isBookBorrowed(self, bookId): Check if a book is currently borrowed. :param bookId: The ID of the book to check. :return: True if the book is borrowed, False otherwise. pass from solution import Library def test_borrowBook(): library = Library([1, 2, 3]) assert library.borrowBook(1, 1) == True assert library.borrowBook(2, 1) == False # Book 1 already borrowed assert library.borrowBook(2, 2) == True assert library.borrowBook(1, 4) == False # Book 4 does not exist def test_returnBook(): library = Library([1, 2, 3]) library.borrowBook(1, 1) assert library.returnBook(1, 1) == True assert library.returnBook(2, 1) == False # Book 1 not borrowed by userId 2 library.borrowBook(2, 1) assert library.returnBook(1, 1) == False # Book 1 borrowed by userId 2 def test_isBookBorrowed(): library = Library([1, 2, 3]) library.borrowBook(1, 1) assert library.isBookBorrowed(1) == True assert library.isBookBorrowed(2) == False library.returnBook(1, 1) assert library.isBookBorrowed(1) == False","solution":"class Library: def __init__(self, books): Initialize the Library with a list of books. :param books: List of book IDs available in the library. self.books = set(books) self.borrowed_books = {} def borrowBook(self, userId, bookId): Attempts to borrow a book for the user. :param userId: The ID of the user attempting to borrow the book. :param bookId: The ID of the book to be borrowed. :return: True if the book was successfully borrowed, False otherwise. if bookId not in self.books or bookId in self.borrowed_books: return False self.borrowed_books[bookId] = userId return True def returnBook(self, userId, bookId): Attempts to return a book for the user. :param userId: The ID of the user attempting to return the book. :param bookId: The ID of the book to be returned. :return: True if the book was successfully returned, False otherwise. if bookId not in self.borrowed_books or self.borrowed_books[bookId] != userId: return False del self.borrowed_books[bookId] return True def isBookBorrowed(self, bookId): Check if a book is currently borrowed. :param bookId: The ID of the book to check. :return: True if the book is borrowed, False otherwise. return bookId in self.borrowed_books"},{"question":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): Initializes the trie object. self.root = TrieNode() def insert(self, word: str) -> None: Inserts the string \`word\` into the trie. pass def search(self, word: str) -> bool: Returns \`true\` if the string \`word\` is in the trie (i.e., was inserted before), and \`false\` otherwise. pass def startsWith(self, prefix: str) -> bool: Returns \`true\` if there is a previously inserted string \`word\` that starts with the prefix \`prefix\`, and \`false\` otherwise. pass","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): Inserts the string \`word\` into the trie. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): Returns \`true\` if the string \`word\` is in the trie (i.e., was inserted before), and \`false\` otherwise. node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def startsWith(self, prefix): Returns \`true\` if there is a previously inserted string \`word\` that starts with the prefix \`prefix\`, and \`false\` otherwise. node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"class Stack: A fixed-size stack of integers that supports push, pop, and increment operations. Attributes: stack (List[int]): The list representing the stack. size (int): The fixed size of the stack. Methods: push(value: int) -> None: Adds value to the top of the stack if it's not full. pop() -> int: Removes and returns the value from the top of the stack if the stack is not empty. Returns -1 if empty. increment(k: int, val: int) -> None: Increments the bottom k elements of the stack by val. def __init__(self, size: int): Constructs a stack with the given size pass def push(self, value: int) -> None: Adds value to the top of the stack if the stack is not full. Args: value (int): The value to be added to the stack. Returns: None pass def pop(self) -> int: Removes and returns the value from the top of the stack if the stack is not empty. If the stack is empty, return -1. Returns: int: The value from the top of the stack, or -1 if the stack is empty. pass def increment(self, k: int, val: int) -> None: Adds val to the bottom k elements of the stack. Args: k (int): The number of bottom elements to increment. val (int): The value to add to the bottom k elements. Returns: None pass # Unit Test def test_stack_push_and_pop(): stack = Stack(3) stack.push(1) stack.push(2) stack.push(3) assert stack.pop() == 3 assert stack.pop() == 2 assert stack.pop() == 1 assert stack.pop() == -1 def test_stack_push_full(): stack = Stack(2) stack.push(1) stack.push(2) stack.push(3) # This should not be added as the stack is full assert stack.stack == [1, 2] def test_stack_increment(): stack = Stack(3) stack.push(1) stack.push(2) stack.push(3) stack.increment(2, 5) # Increment bottom 2 elements by 5 assert stack.stack == [6, 7, 3] def test_stack_increment_more_than_size(): stack = Stack(3) stack.push(1) stack.push(2) stack.increment(5, 5) # Increment all elements by 5 assert stack.stack == [6, 7]","solution":"class Stack: def __init__(self, size): self.stack = [] self.size = size def push(self, value): if len(self.stack) < self.size: self.stack.append(value) def pop(self): if self.stack: return self.stack.pop() else: return -1 def increment(self, k, val): for i in range(min(k, len(self.stack))): self.stack[i] += val"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def hasCycle(head: ListNode) -> bool: Determine if a linked list has a cycle. :param head: ListNode :return: bool >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node1.next = node2 >>> node3 = ListNode(3) >>> node2.next = node3 >>> hasCycle(node1) False >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node1.next = node2 >>> node3 = ListNode(3) >>> node2.next = node3 >>> node3.next = node1 # create a cycle >>> hasCycle(node1) True >>> node1 = ListNode(1) >>> hasCycle(node1) False >>> node1 = ListNode(1) >>> node1.next = node1 # create a cycle >>> hasCycle(node1) True >>> hasCycle(None) False","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def hasCycle(head): Determine if a linked list has a cycle. :param head: ListNode :return: bool if head is None: return False slow = head fast = head.next while slow != fast: if fast is None or fast.next is None: return False slow = slow.next fast = fast.next.next return True"},{"question":"def min_substrings_with_k_consecutive_ones(s: str, k: int) -> int: Returns the minimum number of contiguous substrings the binary string \`s\` can be divided into such that each substring contains at least \`k\` consecutive '1's. If it is not possible to achieve this, returns \`-1\`. >>> min_substrings_with_k_consecutive_ones(\\"11111\\", 2) == 1 >>> min_substrings_with_k_consecutive_ones(\\"11000111001\\", 3) == 1 >>> min_substrings_with_k_consecutive_ones(\\"11001001\\", 3) == -1 >>> min_substrings_with_k_consecutive_ones(\\"1110001111000111\\", 3) == 3 >>> min_substrings_with_k_consecutive_ones(\\"1110000111\\", 3) == 2 >>> min_substrings_with_k_consecutive_ones(\\"101010\\", 0) == -1 >>> min_substrings_with_k_consecutive_ones(\\"000000\\", 1) == -1 >>> min_substrings_with_k_consecutive_ones(\\"000\\", 2) == -1 >>> min_substrings_with_k_consecutive_ones(\\"11\\", 3) == -1 # Your code here","solution":"def min_substrings_with_k_consecutive_ones(s: str, k: int) -> int: Returns the minimum number of contiguous substrings the binary string \`s\` can be divided into such that each substring contains at least \`k\` consecutive '1's. If it is not possible to achieve this, returns \`-1\`. if k <= 0: return -1 count = 0 i = 0 n = len(s) while i < n: consecutive_ones = 0 # Count consecutive '1's while i < n and s[i] == '1': consecutive_ones += 1 i += 1 # If we found a segment with at least k '1's, increment the count if consecutive_ones >= k: count += 1 # Move to the next segment while i < n and s[i] == '0': i += 1 # If no segment with enough '1's found, return -1 if count == 0: return -1 return count"},{"question":"def min_cost_operations(nums): Given an array of n integers where n is even, this function performs n/2 operations to remove pairs of integers with the minimum cost defined as the sum of the pairs. >>> min_cost_operations([1, 2, 3, 4]) == 10 >>> min_cost_operations([1, 3, 2, 1, 4, 3]) == 14 >>> min_cost_operations([5, 1, 2, 3, 4, 6]) == 21 >>> min_cost_operations([1, 2, 2, 1, 3, 3]) == 12 >>> min_cost_operations([100, 200, 300, 400]) == 1000 >>> min_cost_operations([1000, 2000, 3000, 4000]) == 10000 >>> min_cost_operations([-1, 2, -3, 4]) == 2 >>> min_cost_operations([-5, 10, -40, 25]) == -10","solution":"def min_cost_operations(nums): Given an array of n integers where n is even, this function performs n/2 operations to remove pairs of integers with the minimum cost defined as the sum of the pairs. # Sort the array to pair smallest available values first nums.sort() total_cost = 0 n = len(nums) # Iterate over the array, taking pairs from the beginning for i in range(n // 2): total_cost += nums[i] + nums[n - 1 - i] return total_cost"},{"question":"def create_peak_sequence(nums): Rearranges nums into a peak sequence where every even-indexed element is greater than its neighboring odd-indexed elements. If multiple valid arrangements exist, returns any of them. Returns an empty array if no valid arrangement can be formed. >>> create_peak_sequence([1]) == [1] >>> create_peak_sequence([1, 2]) == [1, 2] >>> [result[0] > result[1], result[2] > result[1]] == [True, True] for result in [create_peak_sequence([1, 3, 2])] >>> [result[0] > result[1], result[2] > result[1], result[2] > result[3]] == [True, True, True] for result in [create_peak_sequence([1, 3, 2, 4])] >>> [result[0] > result[1], result[2] > result[1], result[2] > result[3], result[4] > result[3], result[4] > result[5]] == [True, True, True, True, True] for result in [create_peak_sequence([1, 2, 3, 4, 5, 6])] >>> create_peak_sequence([]) == [] >>> create_peak_sequence([2, 2, 2, 2]) == [2, 2, 2, 2] >>> [result[0] > result[1], result[2] > result[1], result[2] > result[3], result[4] > result[3], result[4] > result[5]] == [True, True, True, True, True] for result in [create_peak_sequence([-3, -1, -2, 1, 2, 3])]","solution":"def create_peak_sequence(nums): Rearranges nums into a peak sequence where every even-indexed element is greater than its neighboring odd-indexed elements. If multiple valid arrangements exist, returns any of them. Returns an empty array if no valid arrangement can be formed. # First, sort the input array nums.sort() length = len(nums) if length < 3: return nums # If the length is less than 3, any permutation is a peak sequence # Construct the peak sequence array peak_sequence = [None] * length # Place the highest elements at even indexes even_index = 0 for i in range((length + 1) // 2): peak_sequence[even_index] = nums[-(i + 1)] even_index += 2 # Place the remaining elements at odd indexes odd_index = 1 for i in range((length + 1) // 2, length): peak_sequence[odd_index] = nums[-(i + 1)] odd_index += 2 return peak_sequence"},{"question":"def max_non_overlapping_tasks(tasks: List[Tuple[int, int]]) -> int: Finds the maximum number of non-overlapping tasks that can be completed. Parameters: tasks (list): A list of tuples representing tasks (start time, end time). Returns: int: The maximum number of non-overlapping tasks that can be completed. Example: >>> max_non_overlapping_tasks([(1, 3), (2, 5), (4, 6), (7, 8)]) == 3","solution":"def max_non_overlapping_tasks(tasks): Finds the maximum number of non-overlapping tasks. Parameters: tasks (list): A list of tuples representing tasks (start time, end time). Returns: int: The maximum number of non-overlapping tasks that can be completed. # Sort tasks based on end time tasks.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in tasks: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"def longest_subarray_with_k_distinct(nums, k): Returns the length of the longest contiguous subarray that contains at most \`k\` distinct integers. Parameters: nums (list): List of integers. k (int): Maximum number of distinct integers allowed in the subarray. Returns: int: Length of the longest subarray with at most \`k\` distinct integers. Examples: >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3], 2) 4 >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3], 3) 5","solution":"def longest_subarray_with_k_distinct(nums, k): Returns the length of the longest contiguous subarray that contains at most \`k\` distinct integers. Parameters: nums (list): List of integers. k (int): Maximum number of distinct integers allowed in the subarray. Returns: int: Length of the longest subarray with at most \`k\` distinct integers. from collections import defaultdict n = len(nums) left = 0 right = 0 max_length = 0 window_count = defaultdict(int) unique_count = 0 while right < n: if window_count[nums[right]] == 0: unique_count += 1 window_count[nums[right]] += 1 right += 1 while unique_count > k: window_count[nums[left]] -= 1 if window_count[nums[left]] == 0: unique_count -= 1 left += 1 max_length = max(max_length, right - left) return max_length"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root: Optional[TreeNode]) -> List[int]: Given a binary tree, return the values of the nodes you can see ordered from top to bottom when looking at the tree from the right side. >>> rightSideView(None) [] >>> root = TreeNode(1) >>> rightSideView(root) [1] >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) >>> rightSideView(root) [1, 2, 3] >>> root = TreeNode(1, TreeNode(2, TreeNode(3), None), None) >>> rightSideView(root) [1, 2, 3] >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, None, TreeNode(6))) >>> rightSideView(root) [1, 3, 6] >>> root = TreeNode( ... 1, ... TreeNode(2, TreeNode(4), TreeNode(5)), ... TreeNode(3, TreeNode(6), TreeNode(7)) ... ) >>> rightSideView(root) [1, 3, 7] >>> root = TreeNode(1, TreeNode(2, TreeNode(4, None, TreeNode(7)), TreeNode(5)), TreeNode(3)) >>> rightSideView(root) [1, 3, 5, 7]","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root: Optional[TreeNode]) -> List[int]: if not root: return [] right_view = [] queue = [(root, 0)] while queue: node, depth = queue.pop(0) if len(right_view) == depth: right_view.append(node.val) else: right_view[depth] = node.val if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return right_view"},{"question":"def find_max_direct_reports(manager: List[int], directReports: List[List[int]]) -> int: Returns the maximum number of direct reports an employee can have after changing the manager of exactly one employee. :param manager: List of integers representing the current manager of each employee. :param directReports: 2D List where each element is a list of direct reports of an employee. :return: Integer representing the maximum number of direct reports any employee can have after one change. >>> find_max_direct_reports([-1, 0, 0, 1, 1, 2, 2], [[], [3, 4], [5, 6], [], [], [], []]) 3 >>> find_max_direct_reports([-1, 0, 0, 0, 0, 0], [[], [1, 2, 3, 4, 5], [], [], [], []]) 5 >>> find_max_direct_reports([-1, 0, 0, 1, 1, 1], [[], [3, 4, 5], [], [], [], []]) 4 >>> find_max_direct_reports([-1, 0, 1, 2, 3], [[], [2], [3], [4], []]) 2","solution":"def find_max_direct_reports(manager, directReports): Returns the maximum number of direct reports an employee can have after changing the manager of exactly one employee. :param manager: List of integers representing the current manager of each employee. :param directReports: 2D List where each element is a list of direct reports of an employee. :return: Integer representing the maximum number of direct reports any employee can have after one change. n = len(manager) # Calculate the total direct reports for each employee before any change total_direct_reports = [0] * n for i in range(n): total_direct_reports[manager[i]] += 1 max_direct_reports = max(total_direct_reports) for emp in range(1, n): old_manager = manager[emp] # Remove emp from its old_manager's direct reports total_direct_reports[old_manager] -= 1 # Try to reassign emp to every other manager for new_manager in range(n): if new_manager != old_manager: # Add emp to the new_manager's direct reports total_direct_reports[new_manager] += 1 new_max = max(total_direct_reports) max_direct_reports = max(max_direct_reports, new_max) # Restore the counts back to their original state total_direct_reports[new_manager] -= 1 # Restore the original state for the old manager total_direct_reports[old_manager] += 1 return max_direct_reports"},{"question":"def can_rearrange_to_match(s: str, t: str) -> bool: Determines if a substring of s can be rearranged to match t. >>> can_rearrange_to_match(\\"eidbaooo\\", \\"ab\\") == True >>> can_rearrange_to_match(\\"eidboaoo\\", \\"ab\\") == False >>> can_rearrange_to_match(\\"oidbcaf\\", \\"abc\\") == True >>> can_rearrange_to_match(\\"odicf\\", \\"dc\\") == False >>> can_rearrange_to_match(\\"bcdxabcdy\\", \\"bcdyabcdx\\") == True >>> can_rearrange_to_match(\\"aaacb\\", \\"abc\\") == True >>> can_rearrange_to_match(\\"hello\\", \\"lloeh\\") == True >>> can_rearrange_to_match(\\"teststring\\", \\"rint\\") == True >>> can_rearrange_to_match(\\"a\\", \\"b\\") == False >>> can_rearrange_to_match(\\"abcdef\\", \\"abcdefg\\") == False","solution":"def can_rearrange_to_match(s, t): Determines if a substring of s can be rearranged to match t. from collections import Counter len_s = len(s) len_t = len(t) if len_t > len_s: return False counter_t = Counter(t) window_counter = Counter(s[:len_t]) if window_counter == counter_t: return True for i in range(len_t, len_s): window_counter[s[i]] += 1 window_counter[s[i - len_t]] -= 1 if window_counter[s[i - len_t]] == 0: del window_counter[s[i - len_t]] if window_counter == counter_t: return True return False"},{"question":"def minCutPalindrome(s: str) -> int: Given a string \`s\`, split \`s\` into the minimum number of substrings such that each substring is a palindrome. >>> minCutPalindrome(\\"aab\\") 1 >>> minCutPalindrome(\\"a\\") 0 >>> minCutPalindrome(\\"\\") 0 pass # You can use the following unit tests to verify your solution. def test_single_character(): assert minCutPalindrome(\\"a\\") == 0 def test_two_characters_palindrome(): assert minCutPalindrome(\\"aa\\") == 0 def test_two_characters_non_palindrome(): assert minCutPalindrome(\\"ab\\") == 1 def test_three_characters_palindrome(): assert minCutPalindrome(\\"aab\\") == 1 def test_complex_case(): assert minCutPalindrome(\\"abccbc\\") == 2 def test_long_palindrome(): assert minCutPalindrome(\\"aaaa\\") == 0 def test_no_palindromic_substring(): assert minCutPalindrome(\\"abcd\\") == 3 def test_mixed_palindrome(): assert minCutPalindrome(\\"aabba\\") == 1 def test_empty_string(): assert minCutPalindrome(\\"\\") == 0","solution":"def minCutPalindrome(s): n = len(s) if n == 0: return 0 dp = [0] * n palindrome = [[False] * n for _ in range(n)] for i in range(n): minCut = i for j in range(i+1): if s[j] == s[i] and (i-j <= 1 or palindrome[j+1][i-1]): palindrome[j][i] = True minCut = 0 if j == 0 else min(minCut, dp[j-1] + 1) dp[i] = minCut return dp[-1]"},{"question":"def reverse_words_in_sentence(s: str) -> str: Reverse each word in the sentence while keeping the word order intact. Parameters: s (str): Input sentence containing words separated by spaces. Returns: str: Manipulated sentence with each word reversed but word order intact. >>> reverse_words_in_sentence(\\"hello world\\") 'olleh dlrow' >>> reverse_words_in_sentence(\\"Python is fun\\") 'nohtyP si nuf'","solution":"def reverse_words_in_sentence(s): Reverse each word in the sentence while keeping the word order intact. Parameters: s (str): Input sentence containing words separated by spaces. Returns: str: Manipulated sentence with each word reversed but word order intact. words = s.split() reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"def lexicographically_smallest_string(s: str) -> str: Returns the lexicographically smallest string by swapping 'ab' with 'ba' any number of times. >>> lexicographically_smallest_string(\\"aaaa\\") == \\"aaaa\\" >>> lexicographically_smallest_string(\\"bbbb\\") == \\"bbbb\\" >>> lexicographically_smallest_string(\\"ab\\") == \\"ab\\" >>> lexicographically_smallest_string(\\"ba\\") == \\"ab\\" >>> lexicographically_smallest_string(\\"aab\\") == \\"aab\\" >>> lexicographically_smallest_string(\\"bba\\") == \\"abb\\" >>> lexicographically_smallest_string(\\"abab\\") == \\"aabb\\" >>> lexicographically_smallest_string(\\"baba\\") == \\"aabb\\" >>> lexicographically_smallest_string(\\"aabbbb\\") == \\"aabbbb\\" >>> lexicographically_smallest_string(\\"bbbaaa\\") == \\"aaabbb\\" >>> lexicographically_smallest_string(\\"\\") == \\"\\"","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string by swapping 'ab' with 'ba' any number of times. # We'll count the number of 'a's and 'b's first a_count = s.count('a') b_count = s.count('b') # The lexicographically smallest string will have all 'a's first followed by all 'b's return 'a' * a_count + 'b' * b_count"},{"question":"def min_moves_to_k_consecutive_ones(s: str, k: int) -> int: Returns the minimum number of moves required to make the binary string s contain at least one sequence of k consecutive '1's. >>> min_moves_to_k_consecutive_ones(\\"1111\\", 3) == 0 >>> min_moves_to_k_consecutive_ones(\\"11101\\", 2) == 0 >>> min_moves_to_k_consecutive_ones(\\"0000\\", 2) == 2 >>> min_moves_to_k_consecutive_ones(\\"0000\\", 3) == 3 >>> min_moves_to_k_consecutive_ones(\\"0000\\", 4) == 4 >>> min_moves_to_k_consecutive_ones(\\"100001\\", 3) == 2 >>> min_moves_to_k_consecutive_ones(\\"0101010\\", 2) == 1 >>> min_moves_to_k_consecutive_ones(\\"0010010\\", 2) == 1 >>> min_moves_to_k_consecutive_ones(\\"01\\", 3) == float('inf') >>> min_moves_to_k_consecutive_ones(\\"1\\", 1) == 0 >>> min_moves_to_k_consecutive_ones(\\"0\\", 1) == 1 >>> min_moves_to_k_consecutive_ones(\\"0\\", 2) == float('inf')","solution":"def min_moves_to_k_consecutive_ones(s: str, k: int) -> int: Returns the minimum number of moves required to make the binary string s contain at least one sequence of k consecutive '1's. n = len(s) # Special case: If k is greater than n, it's impossible to create a k-length sequence if k > n: return float('inf') # or raise an Exception # Initialize the initial number of zeroes in the first window of size k zero_count = s[:k].count('0') min_moves = zero_count # Slide the window across the string to find the minimum moves for i in range(1, n - k + 1): if s[i-1] == '0': zero_count -= 1 if s[i+k-1] == '0': zero_count += 1 min_moves = min(min_moves, zero_count) return min_moves"},{"question":"def replace_with_right_sum(arr): Given an array of integers, replace each element with the sum of all elements to the right of it. If there are no elements to the right, the value should be 0. Parameters: arr (list of int): The input array. Returns: list of int: The transformed array. >>> replace_with_right_sum([]) == [] >>> replace_with_right_sum([5]) == [0] >>> replace_with_right_sum([5, 3]) == [3, 0] >>> replace_with_right_sum([1, 2, 3, 4]) == [9, 7, 4, 0] >>> replace_with_right_sum([0, 0, 0]) == [0, 0, 0] >>> replace_with_right_sum([-1, -2, -3, -4]) == [-9, -7, -4, 0] >>> replace_with_right_sum([3, -2, 5, -1]) == [2, 4, -1, 0]","solution":"def replace_with_right_sum(arr): Given an array of integers, replace each element with the sum of all elements to the right of it. If there are no elements to the right, the value should be 0. Parameters: arr (list of int): The input array. Returns: list of int: The transformed array. if not arr: return [] right_sum = 0 result = [0] * len(arr) for i in range(len(arr) - 1, -1, -1): result[i] = right_sum right_sum += arr[i] return result"},{"question":"def count_characters(words: List[str], chars: str) -> int: Given an array of strings \`words\` and a string \`chars\`, returns the total length of all strings in \`words\` that can be formed with the characters from \`chars\` using each character at most once. >>> count_characters([\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"], \\"atach\\") 6 >>> count_characters([\\"hello\\", \\"world\\", \\"leetcode\\"], \\"abc\\") 0 >>> count_characters([\\"apple\\", \\"orange\\", \\"banana\\"], \\"aaeppbrnlgox\\") 11 >>> count_characters([], \\"chars\\") 0 >>> count_characters([\\"hello\\", \\"world\\"], \\"\\") 0 >>> count_characters([\\"aa\\", \\"ab\\", \\"cc\\"], \\"aabc\\") 4 >>> count_characters([\\"hello\\"], \\"helo\\") 0 >>> count_characters([\\"dog\\", \\"cat\\", \\"log\\"], \\"tacgold\\") 9","solution":"def count_characters(words, chars): from collections import Counter chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) can_form = True for char in word_count: if word_count[char] > chars_count.get(char, 0): can_form = False break if can_form: total_length += len(word) return total_length"},{"question":"def max_distinct_substrings(s: str, k: int) -> int: Given a string \`s\` and an integer \`k\`, return the maximum number of substrings of length \`k\` with all distinct characters that can be removed from \`s\` without overlap. >>> max_distinct_substrings(\\"abcabc\\", 3) 2 >>> max_distinct_substrings(\\"abcabc\\", 4) 0 >>> max_distinct_substrings(\\"abcdefg\\", 3) 2 >>> max_distinct_substrings(\\"abcdefg\\", 1) 7 >>> max_distinct_substrings(\\"aaa\\", 2) 0 >>> max_distinct_substrings(\\"abacfabd\\", 3) 2 >>> max_distinct_substrings(\\"aaaaaa\\", 2) 0 >>> max_distinct_substrings(\\"\\", 3) 0 >>> max_distinct_substrings(\\"abcdefgh\\", 9) 0 >>> max_distinct_substrings(\\"abcdefghh\\", 8) 1","solution":"def max_distinct_substrings(s, k): Returns the maximum number of substrings of length k with distinct characters that can be removed from the string s without overlap. def are_all_chars_distinct(substring): return len(set(substring)) == len(substring) n = len(s) count = 0 i = 0 while i <= n - k: potential_substring = s[i:i+k] if are_all_chars_distinct(potential_substring): count += 1 i += k else: i += 1 return count"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def shortestPath(root, a, b): Determine the length of the shortest path between the nodes labeled \`a\` and \`b\` in a binary tree with \`n\` nodes, where the tree is rooted at node \`1\`. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> shortestPath(root, 4, 5) 2 >>> shortestPath(root, 4, 6) 4 >>> shortestPath(root, 3, 4) 3 >>> shortestPath(root, 2, 4) 1","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def findLCA(root, n1, n2): if root is None: return None if root.val == n1 or root.val == n2: return root left_lca = findLCA(root.left, n1, n2) right_lca = findLCA(root.right, n1, n2) if left_lca and right_lca: return root return left_lca if left_lca is not None else right_lca def findLevel(root, data, level): if root is None: return -1 if root.val == data: return level left = findLevel(root.left, data, level + 1) if left == -1: return findLevel(root.right, data, level + 1) return left def shortestPath(root, a, b): lca = findLCA(root, a, b) d1 = findLevel(lca, a, 0) d2 = findLevel(lca, b, 0) return d1 + d2"},{"question":"def longest_consecutive_subsequence(nums: List[int]) -> int: Given a list of integers, return the length of the longest subsequence such that elements in the subsequence are consecutive integers. The subsequence does not need to be contiguous. Args: nums (List[int]): The list of integers. Returns: int: The length of the longest consecutive subsequence. >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) == 4 >>> longest_consecutive_subsequence([]) == 0 >>> longest_consecutive_subsequence([42]) == 1 >>> longest_consecutive_subsequence([10, 20, 30, 40]) == 1 >>> longest_consecutive_subsequence([2, 3, 7, 3, 2, 4, 6, 8, 5, 9]) == 8 >>> longest_consecutive_subsequence([-1, -3, -2, 0, 1]) == 5 >>> longest_consecutive_subsequence([1, 2, 2, 3, 4]) == 4","solution":"def longest_consecutive_subsequence(nums): Finds the length of the longest subsequence with consecutive integers in a given list \`nums\`. Args: nums (List[int]): The list of integers. Returns: int: The length of the longest consecutive subsequence. if not nums: return 0 nums = set(nums) longest_length = 0 for num in nums: if num - 1 not in nums: # Check if it is the start of a sequence current_num = num current_length = 1 while current_num + 1 in nums: current_num += 1 current_length += 1 longest_length = max(longest_length, current_length) return longest_length"},{"question":"from typing import List def calculateWaterTrapped(heights: List[int]) -> int: Calculate the total amount of water trapped between the blocks defined by their heights. Parameters: heights (List[int]): A list of non-negative integers representing the heights of blocks Returns: int: The total amount of water trapped >>> calculateWaterTrapped([]) 0 >>> calculateWaterTrapped([1, 1, 1, 1]) 0 >>> calculateWaterTrapped([4, 2, 0]) 0 >>> calculateWaterTrapped([0, 2, 0]) 0 >>> calculateWaterTrapped([0, 1, 0, 2]) 1 >>> calculateWaterTrapped([2, 0, 2]) 2 >>> calculateWaterTrapped([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> calculateWaterTrapped([3, 3, 3, 3, 3]) 0 >>> calculateWaterTrapped([5, 4, 3, 2, 1, 2, 3, 4, 5]) 16","solution":"def calculateWaterTrapped(heights): Calculate the total amount of water trapped between the blocks defined by their heights. Parameters: heights (List[int]): A list of non-negative integers representing the heights of blocks Returns: int: The total amount of water trapped if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Compute left max heights array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Compute right max heights array right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the total water trapped for i in range(1, n-1): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def plus_one(nums: List[int]) -> List[int]: Increment the integer represented by a list of digits by one. Args: nums (list): a list of integers where each element is a digit. Returns: list: list of integers representing the incremented integer. Examples: >>> plus_one([1, 2, 3]) [1, 2, 4] >>> plus_one([9, 9, 9]) [1, 0, 0, 0] >>> plus_one([]) [1] >>> plus_one([0]) [1] >>> plus_one([9]) [1, 0] >>> plus_one([9] * 100) [1] + [0] * 100","solution":"def plus_one(nums): Increment the integer represented by a list of digits by one. Args: nums (list): a list of integers where each element is a digit. Returns: list: list of integers representing the incremented integer. n = len(nums) for i in range(n - 1, -1, -1): if nums[i] < 9: nums[i] += 1 return nums nums[i] = 0 # If we have all nines, we need an extra digit at the beginning return [1] + [0] * n"},{"question":"def find_two_unique_numbers(arr: List[int]) -> List[int]: Finds the two unique numbers in the array where every other number appears twice. :param arr: List of integers :return: List with the two unique integers >>> set(find_two_unique_numbers([1, 2, 1, 3, 2, 5])) == set([3, 5]) True >>> set(find_two_unique_numbers([4, 2, 7, 4, 3, 3])) == set([2, 7]) True >>> set(find_two_unique_numbers([10, 10, 20, 30])) == set([20, 30]) True >>> set(find_two_unique_numbers([6, 1, 1, 2, 2, 7])) == set([6, 7]) True >>> set(find_two_unique_numbers([11, 11, 23, 45])) == set([23, 45]) True >>> set(find_two_unique_numbers([99, 1, 99, 2])) == set([1, 2]) True >>> set(find_two_unique_numbers([17, 23, 23, 42, 42, 17, 9, 7])) == set([9, 7]) True","solution":"def find_two_unique_numbers(arr): Finds the two unique numbers in the array where every other number appears twice. :param arr: List of integers :return: List with the two unique integers xor_result = 0 # Step 1: XOR all elements for num in arr: xor_result ^= num # Step 2: Find a set bit in xor_result set_bit = xor_result & -xor_result # Step 3: Divide numbers into two groups and find the unique numbers num1 = 0 num2 = 0 for num in arr: if num & set_bit: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"def count_special_indices(nums: List[int]) -> int: Returns the number of special indices in the array \`nums\`. >>> count_special_indices([1, 2, 1, 3, 5, 6, 4]) 2 >>> count_special_indices([1, 2, 3, 4, 5]) 0","solution":"def count_special_indices(nums): Returns the number of special indices in the array \`nums\`. if len(nums) < 3: return 0 # There can't be any special indices in arrays shorter than 3 special_count = 0 for i in range(1, len(nums) - 1): if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]: special_count += 1 return special_count"},{"question":"def count_good_substrings(s: str) -> int: Returns the number of distinct good substrings in s. A good substring is defined as a substring where all characters are distinct. >>> count_good_substrings(\\"abc\\") 6 >>> count_good_substrings(\\"abac\\") 7 >>> count_good_substrings(\\"a\\") 1 >>> count_good_substrings(\\"aaa\\") 1 >>> count_good_substrings(\\"abcba\\") 9 >>> count_good_substrings(\\"\\") 0","solution":"def count_good_substrings(s): Returns the number of distinct good substrings in s. A good substring is defined as a substring where all characters are distinct. good_substrings = set() n = len(s) for i in range(n): seen = set() for j in range(i, n): if s[j] in seen: break seen.add(s[j]) good_substrings.add(s[i:j+1]) return len(good_substrings)"},{"question":"from collections import deque from typing import List def findShortestPath(grid: List[List[int]], sx: int, sy: int, ex: int, ey: int) -> int: Finds the length of the shortest path in a grid from start (sx, sy) to end (ex, ey). Parameters: grid (list of list of int): 2D grid representing the map with walls (1) and free spaces (0) sx (int): starting x coordinate sy (int): starting y coordinate ex (int): ending x coordinate ey (int): ending y coordinate Returns: int: length of the shortest path, or -1 if no path exists >>> grid = [ ... [0, 0, 1], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> findShortestPath(grid, 0, 0, 2, 2) 4 >>> grid = [ ... [0, 1, 1], ... [1, 1, 1], ... [0, 1, 0] ... ] >>> findShortestPath(grid, 0, 0, 2, 2) -1 >>> grid = [ ... [1, 0, 1], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> findShortestPath(grid, 0, 0, 2, 2) -1 >>> grid = [ ... [0, 0, 1], ... [0, 1, 0], ... [0, 0, 1] ... ] >>> findShortestPath(grid, 0, 0, 2, 2) -1 >>> grid = [ ... [0, 0, 1], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> findShortestPath(grid, 1, 0, 1, 0) 0 >>> grid = [ ... [0]*5, ... [0, 1, 1, 1, 0], ... [0, 1, 0, 1, 0], ... [0, 1, 0, 1, 0], ... [0]*5 ... ] >>> findShortestPath(grid, 0, 0, 4, 4) 8","solution":"from collections import deque def findShortestPath(grid, sx, sy, ex, ey): Finds the length of the shortest path in a grid from start (sx, sy) to end (ex, ey). Parameters: grid (list of list of int): 2D grid representing the map with walls (1) and free spaces (0) sx (int): starting x coordinate sy (int): starting y coordinate ex (int): ending x coordinate ey (int): ending y coordinate Returns: int: length of the shortest path, or -1 if no path exists if not grid or grid[sx][sy] != 0 or grid[ex][ey] != 0: return -1 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(sx, sy, 0)]) visited[sx][sy] = True while queue: x, y, steps = queue.popleft() if (x, y) == (ex, ey): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0: visited[nx][ny] = True queue.append((nx, ny, steps + 1)) return -1"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def has_cycle(head): Detect if the linked list has a cycle in it. :param head: The head of the linked list. :return: True if there is a cycle, False otherwise. pass def test_has_cycle_no_cycle(): # Create a linked list: 1 -> 2 -> 3 -> 4 -> None node4 = ListNode(4) node3 = ListNode(3, node4) node2 = ListNode(2, node3) node1 = ListNode(1, node2) assert not has_cycle(node1) def test_has_cycle_with_cycle(): # Create a linked list with a cycle: 1 -> 2 -> 3 -> 4 -> 2 node4 = ListNode(4) node3 = ListNode(3, node4) node2 = ListNode(2, node3) node1 = ListNode(1, node2) node4.next = node2 # Create cycle here assert has_cycle(node1) def test_has_cycle_single_node_no_cycle(): # Single node without cycle: 1 -> None node = ListNode(1) assert not has_cycle(node) def test_has_cycle_single_node_with_cycle(): # Single node with a cycle: 1 -> 1 node = ListNode(1) node.next = node assert has_cycle(node) def test_has_cycle_empty_list(): # Test for an empty list assert not has_cycle(None)","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def has_cycle(head): Detect if the linked list has a cycle in it. :param head: The head of the linked list. :return: True if there is a cycle, False otherwise. slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"def min_diff_subsequence(nums, k): Find the minimum difference between the maximum and minimum elements in any subsequence of length k. Args: - nums (list of int): List of unsorted integers. - k (int): The length of the subsequence. Returns: - int: The minimum difference or None if k is larger than the number of elements in the list. >>> min_diff_subsequence([1, 3, 6, 19, 20], 3) == 5 >>> min_diff_subsequence([4, 4, 4, 1, 4, 4], 2) == 0 >>> min_diff_subsequence([1, 3, 6, 19, 20], 5) == 19 >>> min_diff_subsequence([7, 2, 10, 25], 1) == 0 >>> min_diff_subsequence([7, 2], 3) == None >>> min_diff_subsequence([4, 8, 6, 3, 12, 7], 2) == 1","solution":"def min_diff_subsequence(nums, k): Find the minimum difference between the maximum and minimum elements in any subsequence of length k. Args: - nums (list of int): List of unsorted integers. - k (int): The length of the subsequence. Returns: - int: The minimum difference. if len(nums) < k: return None # Cannot form a subsequence of length k nums.sort() min_diff = float('inf') for i in range(len(nums) - k + 1): min_diff = min(min_diff, nums[i + k - 1] - nums[i]) return min_diff"},{"question":"def merge_and_get_k_smallest(nums1, nums2, k): Merges two sorted arrays nums1 and nums2 and returns the first k smallest elements. Parameters: nums1 (list): The first sorted array. nums2 (list): The second sorted array. k (int): The number of smallest elements to return. Returns: list: The first k smallest elements from the merged array.","solution":"def merge_and_get_k_smallest(nums1, nums2, k): Merges two sorted arrays nums1 and nums2 and returns the first k smallest elements. Parameters: nums1 (list): The first sorted array. nums2 (list): The second sorted array. k (int): The number of smallest elements to return. Returns: list: The first k smallest elements from the merged array. merged_array = [] i = j = 0 while len(merged_array) < k: if i < len(nums1) and (j >= len(nums2) or nums1[i] <= nums2[j]): merged_array.append(nums1[i]) i += 1 else: merged_array.append(nums2[j]) j += 1 return merged_array"},{"question":"def insert_and_merge_intervals(intervals: List[List[int]], new_interval: List[int]) -> List[List[int]]: Insert a new interval into the list of non-overlapping sorted intervals and merge where necessary to ensure the resulting list remains non-overlapping. >>> insert_and_merge_intervals([[1, 3], [6, 9]], [2, 5]) [[1, 5], [6, 9]] >>> insert_and_merge_intervals([[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]], [4, 9]) [[1, 2], [3, 10], [12, 16]] >>> insert_and_merge_intervals([[4, 8], [10, 12]], [1, 3]) [[1, 3], [4, 8], [10, 12]] >>> insert_and_merge_intervals([[4, 8], [10, 12]], [13, 15]) [[4, 8], [10, 12], [13, 15]] >>> insert_and_merge_intervals([[1, 3], [6, 9]], [3, 6]) [[1, 9]]","solution":"def insert_and_merge_intervals(intervals, new_interval): Insert a new interval into the list of non-overlapping sorted intervals and merge where necessary to ensure the resulting list remains non-overlapping. result = [] i = 0 n = len(intervals) # Add all intervals that end before the new interval starts unchanged while i < n and intervals[i][1] < new_interval[0]: result.append(intervals[i]) i += 1 # Merge all overlapping intervals to the new interval while i < n and intervals[i][0] <= new_interval[1]: new_interval[0] = min(new_interval[0], intervals[i][0]) new_interval[1] = max(new_interval[1], intervals[i][1]) i += 1 # Add the merged new_interval result.append(new_interval) # Add remaining intervals unchanged while i < n: result.append(intervals[i]) i += 1 return result"},{"question":"def smallestStringLength(s: str) -> int: Returns the length of the smallest string that can be obtained by removing any number of adjacent pairs of the same characters. >>> smallestStringLength(\\"abbaccd\\") == 1 >>> smallestStringLength(\\"aa\\") == 0 >>> smallestStringLength(\\"abc\\") == 3 >>> smallestStringLength(\\"a\\") == 1 >>> smallestStringLength(\\"aabccba\\") == 1 >>> smallestStringLength(\\"abbccba\\") == 3 >>> smallestStringLength(\\"\\") == 0 >>> smallestStringLength(\\"abccba\\") == 0 >>> smallestStringLength(\\"a\\" * 100000) == 0 >>> smallestStringLength(\\"ab\\" * 50000) == 100000 # Implementation here","solution":"def smallestStringLength(s): Returns the length of the smallest string that can be obtained by removing any number of adjacent pairs of the same characters. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"def longest_subarray_with_k_distinct(arr, k): Finds the length of the longest contiguous subarray with at most k distinct integers. Parameters: arr (List[int]): List of integers. k (int): Maximum number of distinct integers allowed in subarray. Returns: int: Length of the longest contiguous subarray with at most k distinct integers. >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3], 2) == 4 >>> longest_subarray_with_k_distinct([1, 2, 1, 3, 4], 2) == 3 >>> longest_subarray_with_k_distinct([1, 1, 1, 1, 1], 1) == 5 >>> longest_subarray_with_k_distinct([1, 2, 3, 4, 5], 1) == 1 >>> longest_subarray_with_k_distinct([1, 2, 3, 4, 5], 3) == 3 >>> longest_subarray_with_k_distinct([], 3) == 0 >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 1], 5) == 5 >>> longest_subarray_with_k_distinct([1, 2, 1, 4, 5, 2, 3, 5, 2, 1, 3], 3) == 5 >>> longest_subarray_with_k_distinct([1, 2], 1) == 1 >>> longest_subarray_with_k_distinct([1, 2], 2) == 2","solution":"def longest_subarray_with_k_distinct(arr, k): Finds the length of the longest contiguous subarray with at most k distinct integers. Parameters: arr (List[int]): List of integers. k (int): Maximum number of distinct integers allowed in subarray. Returns: int: Length of the longest contiguous subarray with at most k distinct integers. if not arr or k == 0: return 0 from collections import defaultdict left = 0 longest = 0 current_distinct_count = 0 frequency_map = defaultdict(int) for right in range(len(arr)): if frequency_map[arr[right]] == 0: current_distinct_count += 1 frequency_map[arr[right]] += 1 while current_distinct_count > k: frequency_map[arr[left]] -= 1 if frequency_map[arr[left]] == 0: current_distinct_count -= 1 left += 1 longest = max(longest, right - left + 1) return longest"},{"question":"def min_substrings(s: str) -> int: Returns the minimum number of substrings that you can obtain such that each substring is either \\"abc\\" or \\"acb\\". >>> min_substrings(\\"abcabc\\") == 2 >>> min_substrings(\\"acbacb\\") == 2 >>> min_substrings(\\"abcacb\\") == 2 >>> min_substrings(\\"acbacbacb\\") == 3 >>> min_substrings(\\"\\") == 0 >>> min_substrings(\\"a\\") == -1 >>> min_substrings(\\"ab\\") == -1 >>> min_substrings(\\"abcd\\") == -1 >>> min_substrings(\\"abccab\\") == -1 >>> min_substrings(\\"abcabcabc\\") == 3 >>> min_substrings(\\"abacbabccba\\") == -1 >>> min_substrings(\\"acbacbabc\\") == 3 >>> min_substrings(\\"abc\\" * 1000) == 1000 >>> min_substrings(\\"acb\\" * 1000) == 1000","solution":"def min_substrings(s): Returns the minimum number of substrings that you can obtain such that each substring is either \\"abc\\" or \\"acb\\". count = 0 i = 0 while i < len(s): if i + 2 < len(s) and (s[i:i+3] == \\"abc\\" or s[i:i+3] == \\"acb\\"): count += 1 i += 3 else: return -1 # If we cannot find a valid substring of length 3, we cannot split the string as required. return count"},{"question":"def min_moves_to_reach_end(grid): Determine the minimum number of moves required for a person to travel from the top-left corner of the grid to the bottom-right corner. Each cell can be either \`0\` or \`1\` where \`1\` means the elevator is operational and \`0\` means it is out of service. A person can only move to adjacent cells (up, down, left, right) if the elevator in the target cell is operational (\`1\`). If it is not possible to reach the bottom-right corner, return \`-1\`. >>> grid = [ ... [1, 1, 0], ... [0, 1, 0], ... [1, 1, 1] ... ] >>> min_moves_to_reach_end(grid) == 4 >>> grid = [ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ] >>> min_moves_to_reach_end(grid) == -1 >>> grid = [ ... [1] ... ] >>> min_moves_to_reach_end(grid) == 0 >>> grid = [ ... [0] ... ] >>> min_moves_to_reach_end(grid) == -1 >>> grid = [ ... [1, 1, 1, 1], ... [1, 0, 0, 1], ... [1, 1, 1, 1] ... ] >>> min_moves_to_reach_end(grid) == 5 >>> grid = [ ... [1, 0, 1, 1], ... [1, 1, 0, 1], ... [0, 1, 1, 0], ... [1, 0, 1, 1] ... ] >>> min_moves_to_reach_end(grid) == 6","solution":"from collections import deque def min_moves_to_reach_end(grid): if not grid or not grid[0] or grid[0][0] == 0 or grid[-1][-1] == 0: return -1 n, m = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (i, j, steps) visited = set((0, 0)) while queue: i, j, steps = queue.popleft() if i == n - 1 and j == m - 1: return steps for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < n and 0 <= nj < m and (ni, nj) not in visited and grid[ni][nj] == 1: visited.add((ni, nj)) queue.append((ni, nj, steps + 1)) return -1"},{"question":"def count_rectangles(points: List[List[int]]) -> int: Determine how many rectangles can be formed using any four points in the points array. A rectangle is defined by its diagonal points (x1, y1) and (x2, y2) such that its sides are parallel to the x-axis and y-axis. A valid rectangle requires that for any two points (x1, y1) and (x2, y2) there must also exist points (x1, y2) and (x2, y1) in the points array. >>> count_rectangles([[0, 0], [1, 1], [2, 2]]) == 0 >>> count_rectangles([[0, 0], [0, 1], [1, 0], [1, 1]]) == 1 >>> count_rectangles([[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2]]) == 3 >>> count_rectangles([[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]) == 9 >>> count_rectangles([[-1, -1], [-1, 0], [0, -1], [0, 0]]) == 1","solution":"def count_rectangles(points): # Convert the list of points to a set for O(1) lookup times. point_set = set(map(tuple, points)) rectangles = 0 # Iterate over all pairs of points for i in range(len(points)): for j in range(i + 1, len(points)): x1, y1 = points[i] x2, y2 = points[j] if x1 != x2 and y1 != y2: # They must form a diagonal if (x1, y2) in point_set and (x2, y1) in point_set: rectangles += 1 return rectangles // 2 # Each rectangle is counted twice, once for each diagonal"},{"question":"def max_difficulty(stages: int, difficulties: List[int]) -> int: Given the number of stages and their corresponding difficulty levels, return the maximum difficulty level that can be achieved by any participants group. >>> max_difficulty(1, [5]) == 5 >>> max_difficulty(3, [1, 2, 3]) == 3 >>> max_difficulty(4, [2, 2, 2, 2]) == 2 >>> max_difficulty(5, [4, 1, 3, 5, 2]) == 5 >>> max_difficulty(0, []) == 0","solution":"def max_difficulty(stages, difficulties): Given the number of stages and their corresponding difficulty levels, return the maximum difficulty level that can be achieved by any participants group. Parameters: stages (int): number of stages difficulties (list): difficulty levels of the stages Returns: int: maximum difficulty level if not difficulties or stages == 0: return 0 return max(difficulties)"},{"question":"def add_strings(s1: str, s2: str) -> str: Given two strings \`s1\` and \`s2\`, each representing a non-negative integer, return a string representing the sum of the two integers. The addition should be handled manually without converting the input strings to integers directly. >>> add_strings(\\"123\\", \\"456\\") \\"579\\" >>> add_strings(\\"999\\", \\"1\\") \\"1000\\" >>> add_strings(\\"123\\", \\"4567\\") \\"4690\\" >>> add_strings(\\"0\\", \\"0\\") \\"0\\" >>> add_strings(\\"9\\", \\"9\\") \\"18\\"","solution":"def add_strings(s1, s2): Returns the sum of two non-negative integers represented as strings. # Initialize the result, carry, and pointers to the end of both strings result = [] carry = 0 i, j = len(s1) - 1, len(s2) - 1 # Iterate through both strings from right to left while i >= 0 or j >= 0 or carry: # Get the digit or use 0 if the index is out of bounds digit1 = int(s1[i]) if i >= 0 else 0 digit2 = int(s2[j]) if j >= 0 else 0 # Calculate sum of digits including carry total = digit1 + digit2 + carry carry = total // 10 # Update carry for next iteration result.append(str(total % 10)) # Append the unit place of total to result i -= 1 # Move to the next digits j -= 1 # The result is reversed because we added digits from the end of the strings return ''.join(result[::-1])"},{"question":"from typing import List def maxWaterContainer(heights: List[int]) -> int: Returns the maximum amount of water the container can store. :param heights: List[int] :return: int Examples: >>> maxWaterContainer([1, 1, 1, 1]) 3 >>> maxWaterContainer([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> maxWaterContainer([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 25 >>> maxWaterContainer([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) 25 >>> maxWaterContainer([1]) 0 >>> maxWaterContainer([1, 2]) 1 >>> maxWaterContainer([]) 0 >>> maxWaterContainer([4, 4, 4, 4, 4, 4, 4, 4]) 28","solution":"def maxWaterContainer(heights): Returns the maximum amount of water the container can store. :param heights: List[int] :return: int max_water = 0 left = 0 right = len(heights) - 1 while left < right: width = right - left height = min(heights[left], heights[right]) max_water = max(max_water, width * height) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"def max_sorted_after_one_move(heights: List[int]) -> int: Determines the maximum number of people that can be sorted in non-decreasing order after performing at most one move for each person. :param heights: List[int] - List of integers representing heights :return: int - Maximum number of people that can be sorted in non-decreasing order >>> max_sorted_after_one_move([]) == 0 >>> max_sorted_after_one_move([1]) == 1 >>> max_sorted_after_one_move([1, 2, 3, 4, 5]) == 5 >>> max_sorted_after_one_move([5, 3, 1, 2, 4]) == 4 >>> max_sorted_after_one_move([2, 2, 1, 3, 2]) == 4 >>> max_sorted_after_one_move([5, 4, 3, 2, 1]) == 2","solution":"def max_sorted_after_one_move(heights): Determines the maximum number of people that can be sorted in non-decreasing order after performing at most one move for each person. :param heights: List[int] - List of integers representing heights :return: int - Maximum number of people that can be sorted in non-decreasing order n = len(heights) if n <= 1: return n max_sorted = 1 for i in range(n): current_sorted = 1 for j in range(n-1): # Check original or swapped order if heights[j] <= heights[j + 1] or (j + 2 < n and heights[j] <= heights[j + 2]): current_sorted += 1 max_sorted = max(max_sorted, current_sorted) # Try swapping adjacent elements if i + 1 < n: heights[i], heights[i + 1] = heights[i + 1], heights[i] current_sorted = 1 for j in range(n-1): if heights[j] <= heights[j + 1]: current_sorted += 1 max_sorted = max(max_sorted, current_sorted) heights[i], heights[i + 1] = heights[i + 1], heights[i] # swap back return max_sorted"},{"question":"def longest_common_subsequence(nums1: List[int], nums2: List[int]) -> int: Returns the length of the longest common subsequence between nums1 and nums2. >>> longest_common_subsequence([1, 3, 4, 1], [3, 4, 1, 2, 1, 3]) 3 >>> longest_common_subsequence([1, 2, 3], [4, 5, 6]) 0 >>> longest_common_subsequence([1, 2, 3], [1, 2, 3]) 3 >>> longest_common_subsequence([1, 2, 3], [3, 4, 5]) 1 >>> longest_common_subsequence([1, 2, 3, 4, 5, 6], [2, 4, 6, 8]) 3 >>> longest_common_subsequence([], [1, 2, 3]) 0 >>> longest_common_subsequence([1, 2, 3], []) 0 >>> longest_common_subsequence([i for i in range(1000)], [i for i in range(500, 1500)]) 500","solution":"def longest_common_subsequence(nums1, nums2): Returns the length of the longest common subsequence between nums1 and nums2. # Create a 2D DP array dp = [[0] * (len(nums2) + 1) for _ in range(len(nums1) + 1)] # Fill the DP array for i in range(1, len(nums1) + 1): for j in range(1, len(nums2) + 1): if nums1[i - 1] == nums2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The length of the longest common subsequence return dp[len(nums1)][len(nums2)]"},{"question":"def min_time_to_complete_tasks(tasks: List[int], k: int) -> int: Given an array 'tasks' where tasks[i] is the duration of the 'i'th task and an integer 'k' representing the number of workers, return the minimum possible time to complete all tasks when they are optimally assigned to the workers. >>> min_time_to_complete_tasks([3, 2, 3], 3) 3 >>> min_time_to_complete_tasks([4, 2, 1, 3, 5], 2) 8 >>> min_time_to_complete_tasks([5, 5, 5, 5, 5], 5) 5 >>> min_time_to_complete_tasks([10, 20, 30], 1) 60 >>> min_time_to_complete_tasks([2, 2, 1, 1], 5) 2","solution":"def min_time_to_complete_tasks(tasks, k): # Helper function to check if a given time limit is feasible def is_feasible(time_limit): workers = 1 current_time = 0 for task in tasks: if current_time + task <= time_limit: current_time += task else: workers += 1 if workers > k or task > time_limit: return False current_time = task return True # Binary search for the minimal time required to complete all tasks left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if is_feasible(mid): right = mid else: left = mid + 1 return left"},{"question":"def min_diagonal_sum(arr1: List[int], arr2: List[int]) -> int: Forms a 2D grid of size n x n with cell (i, j) containing the value arr1[i] * arr2[j] and returns the minimum possible value of the sum of the diagonal elements after performing row or column swaps. >>> min_diagonal_sum([1, 2, 3], [4, 5, 6]) 32 >>> min_diagonal_sum([3, 1, 2], [8, 7, 5]) 42 >>> min_diagonal_sum([1, 1, 1], [1, 1, 1]) 3 >>> min_diagonal_sum([1], [1]) 1 >>> min_diagonal_sum([5, 4, 2, 3], [9, 6, 3, 1]) 56","solution":"def min_diagonal_sum(arr1, arr2): Forms a 2D grid of size n x n with cell (i, j) containing the value arr1[i] * arr2[j] and returns the minimum possible value of the sum of the diagonal elements after performing row or column swaps. arr1.sort() arr2.sort() n = len(arr1) diagonal_sum = 0 for i in range(n): diagonal_sum += arr1[i] * arr2[i] return diagonal_sum"},{"question":"def max_pairs(paintings: List[int], d: int) -> int: Determine the maximum number of pairs of paintings that can be formed where the height difference between paintings in each pair is at most d. Each painting can only participate in one pair. Args: paintings (List[int]): A list of integers representing the height of paintings. d (int): An integer representing the maximum allowed difference in height for a pair. Returns: int: The maximum number of pairs that can be formed. Examples: >>> max_pairs([1, 2, 3, 4], 1) 2 >>> max_pairs([5, 5, 5, 5], 0) 2 >>> max_pairs([1, 10, 20, 30], 5) 0 >>> max_pairs([1, 2, 3, 8, 8, 9], 10) 3 >>> max_pairs([1, 3, 6, 9, 10], 2) 2 >>> max_pairs([], 3) 0 >>> max_pairs([1], 3) 0","solution":"def max_pairs(paintings, d): This function takes an array of painting heights and an integer d. It returns the maximum number of pairs that can be formed where the height difference between paintings in each pair is at most d. paintings.sort() n = len(paintings) i = 0 pairs = 0 while i < n - 1: if paintings[i + 1] - paintings[i] <= d: pairs += 1 i += 2 # Skip the next painting as it has been paired else: i += 1 # Move to the next painting return pairs"},{"question":"def min_cost_to_make_good_string(s: str, cost: List[int]) -> int: Returns the minimum cost required to make the string good. A string is considered good if there are no two consecutive characters that are the same. This function removes characters to achieve this while incurring the minimum cost. Parameters: s (str): The input string containing lowercase letters. cost (List[int]): The cost of deleting the i-th character in s. Returns: int: Minimum cost to make the string good. >>> min_cost_to_make_good_string(\\"abcdef\\", [1, 2, 3, 4, 5, 6]) 0 >>> min_cost_to_make_good_string(\\"aaaa\\", [1, 2, 3, 4]) 6 >>> min_cost_to_make_good_string(\\"abccbd\\", [0, 1, 2, 3, 4, 5]) 2 >>> min_cost_to_make_good_string(\\"aabbcc\\", [1, 2, 3, 4, 5, 6]) 9 >>> min_cost_to_make_good_string(\\"abab\\", [2, 3, 4, 5]) 0","solution":"def min_cost_to_make_good_string(s, cost): Returns the minimum cost required to make the string good. Parameters: s (str): The input string cost (List[int]): The cost of deleting each character in s Returns: int: Minimum cost to make the string good if not s or len(s) != len(cost): return 0 total_cost = 0 # Traverse the string to check for consecutive duplicates for i in range(1, len(s)): if s[i] == s[i - 1]: # If consecutive characters are the same, we need to delete one with the lower cost if cost[i] < cost[i - 1]: total_cost += cost[i] cost[i] = cost[i - 1] # Retain the higher cost for comparison in subsequent checks else: total_cost += cost[i - 1] return total_cost"},{"question":"def maxSubArray(nums): Finds the contiguous subarray which has the largest sum and returns that sum. :param nums: List of integers :return: Integer - maximum sum of a contiguous subarray >>> maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6 >>> maxSubArray([1, 2, 3, 4, 5]) == 15 >>> maxSubArray([-1, -2, -3, -4, -5]) == -1 >>> maxSubArray([1, -3, 2, 1, -1]) == 3 >>> maxSubArray([7]) == 7 >>> maxSubArray([-7]) == -7 >>> maxSubArray([]) == 0 >>> maxSubArray([100, -200, 300, -400, 500]) == 500 >>> maxSubArray([0, 0, 0, 0]) == 0","solution":"def maxSubArray(nums): Finds the contiguous subarray which has the largest sum and returns that sum. :param nums: List of integers :return: Integer - maximum sum of a contiguous subarray if not nums: return 0 max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def find_two_sum_indices(nums: List[int], target: int) -> List[int]: Given a list of integers nums and a target sum target, return the indices of the two numbers that add up to target. If no such numbers exist, return an empty list. >>> find_two_sum_indices([2, 7, 11, 15], 9) == [0, 1] >>> find_two_sum_indices([1, 2, 3, 4], 8) == [] >>> find_two_sum_indices([1, 3, 2, 4], 5) == [1, 2] >>> find_two_sum_indices([1], 2) == [] >>> find_two_sum_indices([], 2) == [] >>> find_two_sum_indices([-1, -2, -3, -4], -6) == [1, 3] >>> find_two_sum_indices([0, 4, 3, 0], 0) == [0, 3] >>> find_two_sum_indices([3, 3], 6) == [0, 1] pass","solution":"def find_two_sum_indices(nums, target): Given a list of integers nums and a target sum target, return the indices of the two numbers that add up to target. If no such numbers exist, return an empty list. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"from typing import List def subarray_sum(arr: List[int], k: int) -> int: Given a list of \`n\` integers, \`arr\`, and an integer \`k\`, count the number of contiguous subarrays that have a sum equal to \`k\`. >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([1, 2, 3], 7) 0 >>> subarray_sum([2, 4, 1], 7) 1 >>> subarray_sum([0, 0, 0, 0], 0) 10 >>> subarray_sum([5], 5) 1 >>> subarray_sum([5], 1) 0 >>> subarray_sum([-1, -1, 1], 0) 1 >>> subarray_sum([3, 4, 7, 2, -3, 1, 4, 2], 7) 4 >>> subarray_sum([100, -100, 200, -200, 300, -300, 400], 100) 4","solution":"def subarray_sum(arr, k): Returns the count of contiguous subarrays that sum to k. count = 0 cumulative_sum = 0 sum_dict = {0: 1} for num in arr: cumulative_sum += num if (cumulative_sum - k) in sum_dict: count += sum_dict[cumulative_sum - k] if cumulative_sum in sum_dict: sum_dict[cumulative_sum] += 1 else: sum_dict[cumulative_sum] = 1 return count"},{"question":"def min_operations_to_make_valid(s: str) -> int: Determines the minimum number of operations required to correct the parentheses sequence. An operation can be either removing or replacing a parenthesis. >>> min_operations_to_make_valid(\\"()\\") 0 >>> min_operations_to_make_valid(\\"(())\\") 0 >>> min_operations_to_make_valid(\\"\\") 0 >>> min_operations_to_make_valid(\\"((((\\") 4 >>> min_operations_to_make_valid(\\"))))\\") 4 >>> min_operations_to_make_valid(\\"(()())\\") 0 >>> min_operations_to_make_valid(\\")()(\\") 2 >>> min_operations_to_make_valid(\\"())(\\") 2 >>> min_operations_to_make_valid(\\"((()))())(\\") 2","solution":"def min_operations_to_make_valid(s): Returns the minimum number of operations required to make the parentheses sequence valid. An operation is defined as either removing or replacing a parenthesis. balance = 0 operations = 0 for char in s: if char == '(': balance += 1 else: if balance > 0: balance -= 1 else: operations += 1 # Any remaining balance indicates unbalanced opening parentheses operations += balance return operations"},{"question":"def max_elements(nums1, nums2): Returns an array where each element is the maximum of the corresponding elements from nums1 and nums2. Args: nums1 : List[int] - First input list of integers. nums2 : List[int] - Second input list of integers. Returns: List[int] - A list of maximum elements from nums1 and nums2. >>> max_elements([2, 3, 1], [1, 5, 3]) == [2, 5, 3] >>> max_elements([2, 3, 1], [2, 3, 1]) == [2, 3, 1] >>> max_elements([5, 6, 7], [1, 2, 3]) == [5, 6, 7] >>> max_elements([1, 2, 3], [5, 6, 7]) == [5, 6, 7] >>> max_elements([1, 7, 3], [4, 2, 8]) == [4, 7, 8]","solution":"def max_elements(nums1, nums2): Returns an array where each element is the maximum of the corresponding elements from nums1 and nums2. Args: nums1 : List[int] - First input list of integers. nums2 : List[int] - Second input list of integers. Returns: List[int] - A list of maximum elements from nums1 and nums2. return [max(a, b) for a, b in zip(nums1, nums2)]"},{"question":"from typing import List def check_subarray_sum(cards: List[int], k: int) -> bool: Determines if there's a non-empty subset of cards whose sum is a multiple of k. Parameters: cards (list of int): List of integer card values. k (int): The integer multiple to check against. Returns: bool: True if such a subset exists, False otherwise. Examples: >>> check_subarray_sum([23, 2, 4, 6, 7], 6) True >>> check_subarray_sum([1, 2, 3], 7) False >>> check_subarray_sum([0], 1) True >>> check_subarray_sum([1, 2, 3, 4, 5], 11) False >>> check_subarray_sum([5, 0, 0, 5], 5) True >>> check_subarray_sum([7, 3, 1, 6], 100) False # Your code here","solution":"def check_subarray_sum(cards, k): Determines if there's a non-empty subset of cards whose sum is a multiple of k. Parameters: cards (list of int): List of integer card values. k (int): The integer multiple to check against. Returns: bool: True if such a subset exists, False otherwise. if k == 0: return any(card == 0 for card in cards) prefix_sum = 0 mods = {0} for card in cards: prefix_sum += card modulus = prefix_sum % k if modulus in mods: return True mods.add(modulus) return False"},{"question":"def singleNumber(arr): Find the element that occurs only once in the array where every other element occurs exactly thrice. :param arr: list of integers :return: int, the single integer that occurs only once >>> singleNumber([2, 2, 3, 2]) 3 >>> singleNumber([0, 1, 0, 1, 0, 1, 99]) 99 >>> singleNumber([1, 1, 1, 2]) 2 >>> singleNumber([-1, -1, -1, -2]) -2 >>> singleNumber([100000, 100000, 100000, 9999999]) 9999999 >>> singleNumber([-3, -3, -3, -2, -2, -2, 7]) 7 >>> singleNumber([42]) 42","solution":"def singleNumber(arr): Find the element that occurs only once in the array where every other element occurs exactly thrice. :param arr: List[int], input list of integers :return: int, the single integer that occurs only once from collections import Counter # Count the frequency of each integer in the array count = Counter(arr) # Iterate over count dictionary to find the element that occurs only once for key, value in count.items(): if value == 1: return key"},{"question":"def largest_island(matrix: List[List[int]]) -> int: Finds the size of the largest island in the matrix. Parameters: matrix (List[List[int]]): 2D list of integers representing heights of cells in the grid. Returns: int: Size of the largest island. pass def test_empty_matrix(): assert largest_island([]) == 0 def test_single_cell_matrix(): assert largest_island([[1]]) == 1 def test_uniform_matrix(): assert largest_island([ [2, 2], [2, 2] ]) == 4 def test_different_heights_matrix(): assert largest_island([ [1, 2], [3, 4] ]) == 1 def test_multiple_islands(): assert largest_island([ [1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 1, 1], [0, 0, 1, 1] ]) == 4 def test_irregular_matrix(): assert largest_island([ [1, 1, 0, 0, 2], [1, 1, 0, 0, 2], [0, 0, 2, 2, 2], [0, 0, 1, 1, 1] ]) == 5","solution":"def largest_island(matrix): Finds the size of the largest island in the matrix. Parameters: matrix (List[List[int]]): 2D list of integers representing heights of cells in the grid. Returns: int: Size of the largest island. if not matrix: return 0 m, n = len(matrix), len(matrix[0]) visited = [[False] * n for _ in range(m)] max_island_size = 0 def dfs(i, j, height): if i < 0 or i >= m or j < 0 or j >= n or visited[i][j] or matrix[i][j] != height: return 0 visited[i][j] = True return 1 + dfs(i + 1, j, height) + dfs(i - 1, j, height) + dfs(i, j + 1, height) + dfs(i, j - 1, height) for i in range(m): for j in range(n): if not visited[i][j]: island_size = dfs(i, j, matrix[i][j]) max_island_size = max(max_island_size, island_size) return max_island_size"},{"question":"def can_be_strictly_increasing(nums: List[int], k: int) -> bool: Determine if it's possible to make the array strictly increasing by reversing or rotating exactly one subarray of length k. Args: nums (List[int]): The input integer array. k (int): The length of the subarray. Returns: bool: True if the array can be made strictly increasing, otherwise False. >>> can_be_strictly_increasing([1, 2, 3, 4], 2) True >>> can_be_strictly_increasing([4, 3, 2, 1], 4) True >>> can_be_strictly_increasing([1, 3, 2, 4], 2) True >>> can_be_strictly_increasing([4, 3, 1, 2], 2) False >>> can_be_strictly_increasing([1, 2, 3, 2], 1) False >>> can_be_strictly_increasing([5, 4, 3, 2, 1], 5) True","solution":"def can_be_strictly_increasing(nums, k): def is_strictly_increasing(arr): return all(x < y for x, y in zip(arr, arr[1:])) n = len(nums) # Check if the array is already strictly increasing if is_strictly_increasing(nums): return True for i in range(n - k + 1): # Try reversing subarray new_nums = nums[:i] + nums[i:i+k][::-1] + nums[i+k:] if is_strictly_increasing(new_nums): return True # Try rotating subarray subarray = nums[i:i+k] for j in range(1, k): rotated = subarray[j:] + subarray[:j] new_nums = nums[:i] + rotated + nums[i+k:] if is_strictly_increasing(new_nums): return True return False"},{"question":"def get_max_len(arr: List[int]) -> int: Returns the length of the longest subarray with a positive product. >>> get_max_len([1, 2, 3, 4]) == 4 >>> get_max_len([-1, -2, -3, -4]) == 4 >>> get_max_len([1, -2, -3, 4]) == 4 >>> get_max_len([0, 1, 2, -3, 4, 0, -1, -2, 3, 4]) == 4 >>> get_max_len([0]) == 0 >>> get_max_len([1]) == 1 >>> get_max_len([-1]) == 0 >>> get_max_len([]) == 0 >>> get_max_len([1, -2, -3, 4]) == 4 >>> get_max_len([0, 1, -2, -3, -4]) == 3 >>> get_max_len([-1, 2]) == 1 >>> get_max_len([1,2,-1,2]) == 2","solution":"def get_max_len(arr): Returns the length of the longest subarray with a positive product. max_len = 0 pos_len = 0 neg_len = 0 for num in arr: if num == 0: pos_len = 0 neg_len = 0 elif num > 0: pos_len += 1 if neg_len != 0: neg_len += 1 else: neg_len = 0 else: temp = pos_len if neg_len != 0: pos_len = neg_len + 1 else: pos_len = 0 neg_len = temp + 1 max_len = max(max_len, pos_len) return max_len"},{"question":"def minimum_total(triangle: List[List[int]]) -> int: Find the minimum path sum from the top to the bottom of the triangle. Each step you may move to an adjacent number on the row below. >>> minimum_total([ ... [2], ... [3, 4], ... [6, 5, 7], ... [4, 1, 8, 3] ... ]) == 11 >>> minimum_total([ ... [1] ... ]) == 1 >>> minimum_total([ ... [1], ... [2, 3] ... ]) == 3 >>> minimum_total([ ... [1], ... [1, 1], ... [1, 1, 1] ... ]) == 3 >>> minimum_total([ ... [10], ... [20, 30], ... [10, 20, 30], ... [5, 10, 20, 30] ... ]) == 45 >>> minimum_total([ ... [0], ... [0, 0], ... [0, 0, 0] ... ]) == 0","solution":"def minimum_total(triangle): Find the minimum path sum from top to bottom of the triangle. # Start from the second last row and move upwards for row in range(len(triangle) - 2, -1, -1): for col in range(len(triangle[row])): # Update the value to be itself plus the minimum of the two adjacent values from the row below triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1]) # The top element contains the minimum path sum return triangle[0][0]"},{"question":"from typing import List def max_area(heights: List[int]) -> List[int]: Return the indices [i, j] of the pair of buildings that forms the largest area. >>> max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) [1, 8] >>> max_area([1, 1]) [0, 1] >>> max_area([4, 3, 2, 1, 4]) [0, 4] >>> max_area([1, 2, 1]) [0, 2] >>> max_area([4, 4, 4, 2, 1, 4]) [0, 5] pass def test_max_area_case_1(): assert max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) == [1, 8] def test_max_area_case_2(): assert max_area([1, 1]) == [0, 1] def test_max_area_case_3(): assert max_area([4, 3, 2, 1, 4]) == [0, 4] def test_max_area_case_4(): assert max_area([1, 2, 1]) == [0, 2] def test_max_area_case_5(): assert max_area([4, 4, 4, 2, 1, 4]) == [0, 5]","solution":"def max_area(heights): max_area = 0 result = (0, 0) for i in range(len(heights)): for j in range(i + 1, len(heights)): area = (j - i) * min(heights[i], heights[j]) if area > max_area: max_area = area result = (i, j) elif area == max_area: if i < result[0] or (i == result[0] and j < result[1]): result = (i, j) return list(result)"},{"question":"from typing import List def min_moves_to_remove_stars(s: str) -> int: Given a string \`s\` consisting of lowercase English letters and the '*' character, return the minimum number of moves to make \`s\` consist only of lowercase English letters. A move consists of selecting a contiguous substring of up to two characters that contains at least one '*' character and changing both characters to any lowercase English letter. >>> min_moves_to_remove_stars(\\"a*bc*d\\") == 2 >>> min_moves_to_remove_stars(\\"****\\") == 2","solution":"def min_moves_to_remove_stars(s): Returns the minimum number of moves to make \`s\` consist only of lowercase English letters. if not s: return 0 moves = 0 i = 0 while i < len(s): if s[i] == '*': moves += 1 i += 2 else: i += 1 return moves"},{"question":"def double_array(nums: List[int]) -> List[int]: Given a list of integers, return a doubled array such that each integer in the original list appears twice consecutively in the resulting list. >>> double_array([1, 2, 3]) [1, 1, 2, 2, 3, 3] >>> double_array([]) [] >>> double_array([5]) [5, 5] >>> double_array([-1, -2, -3]) [-1, -1, -2, -2, -3, -3] >>> double_array([0, 1, -1, 2]) [0, 0, 1, 1, -1, -1, 2, 2] >>> double_array([1000, 2000, 3000]) [1000, 1000, 2000, 2000, 3000, 3000]","solution":"def double_array(nums): Returns a doubled array such that each integer in the original list appears twice consecutively in the resulting list. result = [] for num in nums: result.extend([num, num]) return result"},{"question":"def rotate(nums, k): Rotates the array \`nums\` to the right by \`k\` steps in-place with O(1) extra space. >>> nums = [1, 2, 3, 4, 5, 6, 7] >>> rotate(nums, 3) >>> nums [5, 6, 7, 1, 2, 3, 4] >>> nums = [1] >>> rotate(nums, 1) >>> nums [1] >>> nums = [1, 2, 3, 4, 5] >>> rotate(nums, 0) >>> nums [1, 2, 3, 4, 5] >>> nums = [1, 2, 3, 4, 5] >>> rotate(nums, 7) >>> nums [4, 5, 1, 2, 3] >>> nums = [1, 2, 1, 2, 1, 2] >>> rotate(nums, 2) >>> nums [1, 2, 1, 2, 1, 2]","solution":"def rotate(nums, k): Rotates the array \`nums\` to the right by \`k\` steps in-place with O(1) extra space. n = len(nums) k %= n # in case k is greater than n # Define a helper function to reverse parts of the list def reverse(array, start, end): while start < end: array[start], array[end] = array[end], array[start] start += 1 end -= 1 # Reverse the entire array reverse(nums, 0, n - 1) # Reverse the first k elements reverse(nums, 0, k - 1) # Reverse the rest of the array reverse(nums, k, n - 1)"},{"question":"from typing import List def find_pattern_indices(s: str, pattern: str) -> List[int]: Returns the starting indices of all occurrences of pattern in s where the characters of pattern can be rearranged to form another substring of s. >>> find_pattern_indices(\\"cbaebabacd\\", \\"abc\\") == [0, 6] >>> find_pattern_indices(\\"abcdefg\\", \\"hij\\") == [] >>> find_pattern_indices(\\"abababab\\", \\"aba\\") == [0, 2, 4] >>> find_pattern_indices(\\"abc\\", \\"abcd\\") == [] >>> find_pattern_indices(\\"aabbcc\\", \\"ccbbaa\\") == [0] >>> find_pattern_indices(\\"aaaaa\\", \\"a\\") == [0, 1, 2, 3, 4]","solution":"from collections import Counter def find_pattern_indices(s, pattern): Returns the starting indices of all occurrences of pattern in s where the characters of pattern can be rearranged to form another substring of s. len_p = len(pattern) len_s = len(s) if len_p > len_s: return [] pattern_count = Counter(pattern) window_count = Counter(s[:len_p-1]) result = [] for i in range(len_p-1, len_s): window_count[s[i]] += 1 if window_count == pattern_count: result.append(i-len_p+1) window_count[s[i-len_p+1]] -= 1 if window_count[s[i-len_p+1]] == 0: del window_count[s[i-len_p+1]] return result"},{"question":"def first_missing_positive(nums): Finds the smallest missing positive integer in the list nums. The algorithm runs in O(n) time and uses O(1) extra space. >>> first_missing_positive([1, 2, 0]) == 3 >>> first_missing_positive([1, 2, 3, 4, 5]) == 6 >>> first_missing_positive([3, 4, -1, 1]) == 2 >>> first_missing_positive([-1, -2, -3]) == 1 >>> first_missing_positive([2, 3, 4]) == 1 >>> first_missing_positive([]) == 1 >>> first_missing_positive([7, 8, 9, 11, 12]) == 1","solution":"def first_missing_positive(nums): Finds the smallest missing positive integer in the list nums. The algorithm runs in O(n) time and uses O(1) extra space. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def recoverTree(root: TreeNode) -> TreeNode: Recover the binary search tree by swapping the values of two nodes. Parameters: root (TreeNode): The root of the binary tree. Returns: TreeNode: The root of the recovered binary search tree. pass # Unit tests def inorder_list(root): Helper function to get the list of values by inorder traversal of the tree. if root: return inorder_list(root.left) + [root.val] + inorder_list(root.right) else: return [] def test_recover_tree_single_pair(): # Construct the tree # 3 # / # 1 4 # / # 2 root = TreeNode(3) root.left = TreeNode(1) root.right = TreeNode(4) root.right.left = TreeNode(2) # Swap 2 and 3 to make the tree: # 2 # / # 1 4 # / # 3 root.val, root.right.left.val = root.right.left.val, root.val # Recover the tree recoverTree(root) # Check the inorder traversal of the recovered tree assert inorder_list(root) == [1, 2, 3, 4] def test_recover_tree_multiple_pairs(): # Construct the tree # 6 # / # 3 8 # / / # 1 7 9 root = TreeNode(6) root.left = TreeNode(3) root.left.left = TreeNode(1) root.right = TreeNode(8) root.right.left = TreeNode(7) root.right.right = TreeNode(9) # Swap 3 and 8 to make the tree: # 6 # / # 8 3 # / / # 1 7 9 root.left.val, root.right.val = root.right.val, root.left.val # Recover the tree recoverTree(root) # Check the inorder traversal of the recovered tree assert inorder_list(root) == [1, 3, 6, 7, 8, 9] def test_recover_tree_no_swaps_needed(): # Construct the tree # 5 # / # 3 8 # / # 1 4 9 root = TreeNode(5) root.left = TreeNode(3) root.left.left = TreeNode(1) root.left.right = TreeNode(4) root.right = TreeNode(8) root.right.right = TreeNode(9) # Tree is already a BST recoverTree(root) # Check the inorder traversal of the tree assert inorder_list(root) == [1, 3, 4, 5, 8, 9] def test_recover_tree_corner_case(): # Tree with two nodes only root = TreeNode(1) root.right = TreeNode(2) # Swap the nodes root.val, root.right.val = root.right.val, root.val # Recover the tree recoverTree(root) # Check the inorder traversal of the recovered tree assert inorder_list(root) == [1, 2]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def recoverTree(root): Recover the binary search tree by swapping the values of two nodes. Parameters: root (TreeNode): The root of the binary tree. Returns: TreeNode: The root of the recovered binary search tree. def inorder_traversal(node): if node: yield from inorder_traversal(node.left) yield node yield from inorder_traversal(node.right) first_element = second_element = prev_element = TreeNode(float('-inf')) for node in inorder_traversal(root): if node.val < prev_element.val: if first_element.val == float('-inf'): first_element = prev_element second_element = node prev_element = node first_element.val, second_element.val = second_element.val, first_element.val return root"},{"question":"def count_triplets(nums: List[int]) -> int: Returns the total number of triplets (nums[i], nums[j], nums[k]) where 0 <= i < j < k < len(nums) and nums[i] < nums[j] < nums[k]. >>> count_triplets([]) == 0 >>> count_triplets([1, 2, 3]) == 1 >>> count_triplets([3, 2, 1]) == 0 >>> count_triplets([1, 2, 3, 4]) == 4 >>> count_triplets([1, 3, 2, 4]) == 2 >>> count_triplets([1, 2, 2, 3]) == 2 >>> count_triplets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 120 pass","solution":"def count_triplets(nums): Returns the total number of triplets (nums[i], nums[j], nums[k]) where 0 <= i < j < k < len(nums) and nums[i] < nums[j] < nums[k]. count = 0 n = len(nums) # Check all possible combinations of triplets for i in range(n): for j in range(i+1, n): for k in range(j+1, n): if nums[i] < nums[j] < nums[k]: count += 1 return count"},{"question":"def find_duplicate_and_missing(nums): Find the duplicate and missing numbers in the array. Args: nums (List[int]): A list of integers where each element is in the range from 1 to n, except for one element which is replaced by a duplicate. Returns: Tuple[int, int]: A tuple containing the duplicate number and the missing number. def test_find_duplicate_and_missing(): result = find_duplicate_and_missing([1, 2, 2, 4]) assert result == (2, 3) def test_find_duplicate_and_missing_single_element(): result = find_duplicate_and_missing([1, 1]) assert result == (1, 2) def test_find_duplicate_and_missing_larger_array(): result = find_duplicate_and_missing([3, 1, 2, 5, 3]) assert result == (3, 4) def test_find_duplicate_and_missing_another_case(): result = find_duplicate_and_missing([4, 3, 6, 2, 1, 1]) assert result == (1, 5) def test_find_duplicate_and_missing_more_numbers(): result = find_duplicate_and_missing([5, 7, 3, 2, 4, 7, 1, 8]) assert result == (7, 6)","solution":"def find_duplicate_and_missing(nums): Find the duplicate and missing numbers in the array. Args: nums (List[int]): A list of integers where each element is in the range from 1 to n, except for one element which is replaced by a duplicate. Returns: Tuple[int, int]: A tuple containing the duplicate number and the missing number. n = len(nums) actual_sum = sum(nums) actual_sum_sq = sum(x*x for x in nums) expected_sum = n * (n + 1) // 2 expected_sum_sq = n * (n + 1) * (2*n + 1) // 6 diff = actual_sum - expected_sum diff_sq = actual_sum_sq - expected_sum_sq sum_diff = diff_sq // diff duplicate = (diff + sum_diff) // 2 missing = sum_diff - duplicate return duplicate, missing"},{"question":"def min_distance(s1: str, s2: str) -> int: Returns the minimum number of operations required to transform s1 into s2. In one operation, you can insert one character in any position of the string, remove one character from any position of the string, or replace one character with another in any position of the string. >>> min_distance(\\"abc\\", \\"abc\\") 0 >>> min_distance(\\"abc\\", \\"abcd\\") 1 >>> min_distance(\\"\\", \\"abc\\") 3 >>> min_distance(\\"abcd\\", \\"abc\\") 1 >>> min_distance(\\"abc\\", \\"\\") 3 >>> min_distance(\\"abc\\", \\"abd\\") 1 >>> min_distance(\\"abc\\", \\"xyz\\") 3 >>> min_distance(\\"horse\\", \\"ros\\") 3 >>> min_distance(\\"intention\\", \\"execution\\") 5","solution":"def min_distance(s1, s2): Returns the minimum number of operations required to transform s1 into s2. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) return dp[m][n]"},{"question":"def longest_subarray_divisible_by_same_k(arr): Return the length of the longest subarray such that all elements are divisible by the same non-zero integer k. Note that k must be greater than 1 and should divide at least one element in the array completely. >>> longest_subarray_divisible_by_same_k([4, 8, 16, 32, 64]) 5 >>> longest_subarray_divisible_by_same_k([3, 6, 9, 12]) 4 >>> longest_subarray_divisible_by_same_k([2, 4, 8, 16, 3, 6]) 4 >>> longest_subarray_divisible_by_same_k([5, 10, 15, 20, 25, 30]) 6 >>> longest_subarray_divisible_by_same_k([7, 14, 21, 28, 4, 8]) 4 >>> longest_subarray_divisible_by_same_k([1, 2, 3, 4, 5]) 1","solution":"def longest_subarray_divisible_by_same_k(arr): def gcd(x, y): while y: x, y = y, x % y return x max_len = 0 for i in range(len(arr)): current_gcd = 0 for j in range(i, len(arr)): current_gcd = gcd(current_gcd, arr[j]) if current_gcd == 1: break max_len = max(max_len, j - i + 1) return max_len"},{"question":"def find_pattern_indices(patterns: List[str], text: str) -> List[int]: Given an array of strings \`patterns\` and a string \`text\`, return an array of integers where each element represents the starting index of a substring in \`text\` that matches any of the strings in \`patterns\`. If a pattern string occurs multiple times in the \`text\`, include each starting index. The order of indices in the output array should correspond to their occurrence in the \`text\`. >>> find_pattern_indices([\\"abc\\"], \\"abcabc\\") [0, 3] >>> find_pattern_indices([\\"abc\\", \\"def\\"], \\"abcdefabc\\") [0, 3, 6] >>> find_pattern_indices([\\"aba\\"], \\"ababa\\") [0, 2] >>> find_pattern_indices([\\"xyz\\"], \\"abcabc\\") [] >>> find_pattern_indices([], \\"abcabc\\") [] >>> find_pattern_indices([\\"abc\\"], \\"\\") [] >>> find_pattern_indices([\\"aaaa\\"], \\"aaa\\") []","solution":"def find_pattern_indices(patterns, text): Returns a list of starting indices of substrings in text that match any of the patterns. indices = [] for pattern in patterns: start = 0 while start != -1: start = text.find(pattern, start) if start != -1: indices.append(start) start += 1 # Increment to find subsequent occurrences indices.sort() # Indices should be in order of their occurrence return indices"},{"question":"def max_substrings(text: str, words: List[str]) -> int: Returns the maximum number of substrings present in the string \`text\` that match any of the strings in the \`words\` array. The substrings may overlap. >>> max_substrings(\\"ababa\\", [\\"aba\\", \\"ab\\"]) == 2 >>> max_substrings(\\"abcdefg\\", [\\"hij\\", \\"klm\\"]) == 0 >>> max_substrings(\\"aaaaa\\", [\\"aa\\", \\"aaa\\"]) == 4 >>> max_substrings(\\"bbbb\\", [\\"b\\"]) == 4 >>> max_substrings(\\"abcabcabc\\", [\\"abc\\", \\"bca\\", \\"cab\\", \\"bc\\", \\"ca\\"]) == 3 >>> max_substrings(\\"ababab\\", [\\"ab\\", \\"bab\\", \\"aba\\"]) == 3 >>> max_substrings(\\"xyzxyzxy\\", [\\"xy\\", \\"yz\\", \\"zx\\"]) == 3","solution":"def max_substrings(text, words): Returns the maximum number of substrings present in the string \`text\` that match any of the strings in the \`words\` array. The substrings may overlap. max_count = 0 for word in words: start = 0 count = 0 while start <= len(text) - len(word): if text[start:start + len(word)] == word: count += 1 start += 1 # Move only one character ahead to allow overlapping else: start += 1 max_count = max(max_count, count) return max_count"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers that add up to the target. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([1, 2, 3], 6) [] >>> two_sum([1, 3, 2, 4], 5) [1, 2] >>> two_sum([-3, 4, 3, 90], 0) [0, 2] >>> two_sum([0, 4, 3, 0], 0) [0, 3]","solution":"def two_sum(nums, target): Returns the indices of the two numbers that add up to the target. Parameters: nums (List[int]): The array of integers. target (int): The target sum. Returns: List[int]: A sorted list with the indices of the two numbers. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return sorted([num_to_index[complement], i]) num_to_index[num] = i return []"},{"question":"def min_visible_garden_height(heights): Returns the minimum height required for the garden to be visible from both sides of the street, given a list of building heights. >>> min_visible_garden_height([3, 1, 4, 1, 5]) 6 >>> min_visible_garden_height([0]) 1 >>> min_visible_garden_height([10]) 11 >>> min_visible_garden_height([5, 5, 5, 5, 5]) 6 >>> min_visible_garden_height([1, 2, 3, 4, 5]) 6 >>> min_visible_garden_height([5, 4, 3, 2, 1]) 6 >>> min_visible_garden_height([]) 1 >>> min_visible_garden_height([1, 3, 2, 4, 2]) 5","solution":"def min_visible_garden_height(heights): Returns the minimum height required for the garden to be visible from both sides of the street, given a list of building heights. if not heights: return 1 # Minimum height required if no buildings exist. tallest_building = max(heights) return tallest_building + 1"},{"question":"from typing import List def maxProfit(hours: List[int], profit: List[int], totalHours: int) -> int: Returns the maximum profit achievable by selecting a subset of projects within the given total work hours. >>> maxProfit([1, 2, 3], [10, 20, 30], 5) 50 >>> maxProfit([], [], 5) 0 >>> maxProfit([1, 2, 3], [10, 20, 30], 6) 60 >>> maxProfit([3, 4, 5], [30, 40, 50], 2) 0 >>> maxProfit([5], [50], 5) 50 >>> maxProfit([3, 4, 5, 8], [30, 40, 50, 70], 10) 90","solution":"from typing import List def maxProfit(hours: List[int], profit: List[int], totalHours: int) -> int: n = len(hours) dp = [[0] * (totalHours + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(totalHours + 1): if hours[i - 1] <= j: dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - hours[i - 1]] + profit[i - 1]) else: dp[i][j] = dp[i - 1][j] return dp[n][totalHours]"},{"question":"class MagicDictionary: A magic dictionary that allows spellchecking with exactly one character substitution. Methods ------- __init__() Initializes the dictionary object. buildDict(dictionary: List[str]) Sets the dictionary words list. search(searchWord: str) -> bool Returns True if there is any word in the dictionary that can be transformed into the searchWord by changing exactly one character. Examples -------- >>> magic_dictionary = MagicDictionary() >>> magic_dictionary.buildDict([\\"hello\\", \\"leetcode\\"]) >>> magic_dictionary.search(\\"hhllo\\") True >>> magic_dictionary.search(\\"hello\\") False >>> magic_dictionary.search(\\"hell\\") False >>> magic_dictionary.search(\\"leetcoded\\") False def __init__(self): Initialize the dictionary object. pass # Implementation goes here def buildDict(self, dictionary): Sets the dictionary words list. :param dictionary: List of words. pass # Implementation goes here def search(self, searchWord): Returns True if there is any word in the dictionary that can be transformed into the searchWord by changing exactly one character. :param searchWord: The word to search. pass # Implementation goes here if __name__ == \\"__main__\\": def test_magic_dictionary(): magic_dictionary = MagicDictionary() magic_dictionary.buildDict([\\"hello\\", \\"leetcode\\"]) assert magic_dictionary.search(\\"hhllo\\") == True # 'hello' with one character modified assert magic_dictionary.search(\\"hello\\") == False # Exact match, no characters modified assert magic_dictionary.search(\\"hell\\") == False # Different lengths assert magic_dictionary.search(\\"leetcoded\\") == False # Different lengths assert magic_dictionary.search(\\"leefcode\\") == True # 'leetcode' with one character modified assert magic_dictionary.search(\\"leatcode\\") == True # 'leetcode' with one character modified assert magic_dictionary.search(\\"abcde\\") == False # No match with dictionary words test_magic_dictionary()","solution":"class MagicDictionary: def __init__(self): Initialize the dictionary object. self.words = set() def buildDict(self, dictionary): Build the dictionary from a list of words. :param dictionary: List of words. self.words = set(dictionary) def search(self, searchWord): Returns True if there is any word in the dictionary that can be transformed into the searchWord by changing exactly one character. :param searchWord: The word to search. for word in self.words: if len(word) == len(searchWord): difference = sum(w != s for w, s in zip(word, searchWord)) if difference == 1: return True return False"},{"question":"def count_pairs(nums, target): Returns the number of distinct pairs (i, j) where 0 <= i < j < n and nums[i] * nums[j] == target. >>> count_pairs([1, 2, 3, 4], 10) 0 >>> count_pairs([1, 2, 3, 4], 6) 1 >>> count_pairs([1, 2, 2, 3, 4], 4) 2 >>> count_pairs([0, 0, 0], 0) 3 >>> count_pairs([-1, 1, -2, 2], -2) 2 >>> count_pairs([], 0) 0 >>> count_pairs([100000, 100000], 10000000000) 1","solution":"def count_pairs(nums, target): Returns the number of distinct pairs (i, j) where 0 <= i < j < n and nums[i] * nums[j] == target. count = 0 n = len(nums) # Use a set to keep track of the pairs and avoid counting the same pair more than once seen_pairs = set() for i in range(n): for j in range(i + 1, n): if nums[i] * nums[j] == target: # Ensure (i, j) is counted and not (j, i) if (i, j) not in seen_pairs: seen_pairs.add((i, j)) count += 1 return count"},{"question":"def expand_asterisks(s: str) -> List[str]: Returns all possible strings after replacing each '*' with any lowercase letter 'a' to 'z'. The returned strings are sorted in lexicographical order. >>> expand_asterisks(\\"a*b\\") ['aab', 'abb', 'acb', 'adb', 'aeb', 'afb', 'agb', 'ahb', 'aib', 'ajb', 'akb', 'alb', 'amb', 'anb', 'aob', 'apb', 'aqb', 'arb', 'asb', 'atb', 'aub', 'avb', 'awb', 'axb', 'ayb', 'azb'] >>> expand_asterisks(\\"*a*\\") ['aaa', 'aab', 'aac', ..., 'zaz'] >>> expand_asterisks(\\"abc\\") ['abc'] >>> expand_asterisks(\\"***\\") ['aaa', 'aab', ... , 'zzz'] >>> expand_asterisks(\\"\\") [] >>> expand_asterisks(\\"a**b\\") [f\\"a{ch1}{ch2}b\\" for ch1 in \\"abcdefghijklmnopqrstuvwxyz\\" for ch2 in \\"abcdefghijklmnopqrstuvwxyz\\"]","solution":"from itertools import product def expand_asterisks(s): Returns all possible strings after replacing each '*' with any lowercase letter 'a' to 'z'. The returned strings are sorted in lexicographical order. if not s: return [] # Determine the positions of the asterisks asterisk_positions = [i for i, char in enumerate(s) if char == '*'] num_asterisks = len(asterisk_positions) # Generate all combinations for the asterisks place combinations = [''.join(p) for p in product('abcdefghijklmnopqrstuvwxyz', repeat=num_asterisks)] possible_strings = [] for combo in combinations: new_string = list(s) for i, char in zip(asterisk_positions, combo): new_string[i] = char possible_strings.append(''.join(new_string)) # Return the list sorted in lexicographical order return sorted(possible_strings)"},{"question":"def max_subarray_len(nums: List[int], k: int) -> int: Returns the length of the longest contiguous subarray that sums to k. Args: nums : list[int] : list of integers k : int : target sum of subarray Returns: int : length of longest subarray with sum equal to k >>> max_subarray_len([1, -1, 5, -2, 3], 3) 4 >>> max_subarray_len([-2, -1, 2, 1], 1) 2 >>> max_subarray_len([1, 2, 3], 7) 0 >>> max_subarray_len([1, 1, 1, 1, 1, 1, 1], 3) 3","solution":"def max_subarray_len(nums, k): Returns the length of the longest contiguous subarray that sums to k. Args: nums : list[int] : list of integers k : int : target sum of subarray Returns: int : length of longest subarray with sum equal to k cumulative_sum = 0 sum_indices = {0: -1} max_length = 0 for i, num in enumerate(nums): cumulative_sum += num if (cumulative_sum - k) in sum_indices: max_length = max(max_length, i - sum_indices[cumulative_sum - k]) if cumulative_sum not in sum_indices: sum_indices[cumulative_sum] = i return max_length"},{"question":"from typing import List def min_max_pages(books: List[int], k: int) -> int: Given an array of integers representing the number of pages in each book, and an integer representing the number of students, return the minimum possible value of the maximum number of pages assigned to a student. >>> min_max_pages([100], 1) 100 >>> min_max_pages([10, 20, 30, 40], 1) 100 >>> min_max_pages([10, 20, 30, 40], 2) 60 >>> min_max_pages([12, 34, 67, 90], 2) 113 >>> min_max_pages([10, 20, 30, 40], 4) 40 >>> min_max_pages([10, 20, 30], 5) -1 >>> min_max_pages([7, 2, 5, 10, 8], 2) 18","solution":"def is_feasible(books, k, max_pages): students_required = 1 current_sum = 0 for pages in books: if current_sum + pages > max_pages: students_required += 1 current_sum = pages if students_required > k: return False else: current_sum += pages return True def min_max_pages(books, k): if len(books) < k: return -1 left, right = max(books), sum(books) result = right while left <= right: mid = (left + right) // 2 if is_feasible(books, k, mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"def longest_consecutive_subsequence(nums: List[int]) -> int: Returns the length of the longest subsequence of nums such that all elements of the subsequence are consecutive integers. >>> longest_consecutive_subsequence([1, 9, 3, 10, 2, 20]) == 3 >>> longest_consecutive_subsequence([4, 2, 1, 6, 5]) == 3 >>> longest_consecutive_subsequence([10, 20, 30, 40]) == 1 >>> longest_consecutive_subsequence([]) == 0 >>> longest_consecutive_subsequence([1, 3, 5, 7, 9]) == 1 >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) == 4","solution":"def longest_consecutive_subsequence(nums): Returns the length of the longest subsequence of nums such that all elements of the subsequence are consecutive integers. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: if num - 1 not in num_set: # start a new streak current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"from typing import List def min_moves_to_sort(arr: List[int]) -> int: Returns the minimum number of moves required to arrange people in non-decreasing order of height by moving people only to the beginning or the end of the list. >>> min_moves_to_sort([1, 2, 3, 4, 5]) 0 >>> min_moves_to_sort([5, 4, 3, 2, 1]) 4 >>> min_moves_to_sort([3, 1, 2, 4, 5]) 1 >>> min_moves_to_sort([1, 3, 5, 2, 4]) 2 >>> min_moves_to_sort([1, 2, 2, 3, 4]) 0 >>> min_moves_to_sort([1, 4, 3, 3, 2]) 3 >>> min_moves_to_sort([5]) 0 >>> min_moves_to_sort([]) 0 >>> min_moves_to_sort([1, 2, 10, 11, 12]) 0 >>> min_moves_to_sort([10, 1, 2, 3, 4]) 1","solution":"def min_moves_to_sort(arr): Returns the minimum number of moves required to arrange people in non-decreasing order of height by moving people only to the beginning or the end of the list. n = len(arr) if n == 0: return 0 # Find the longest non-decreasing subsequence from the start longest_inc_subseq_length = 1 inc_length = 1 for i in range(1, n): if arr[i] >= arr[i - 1]: inc_length += 1 longest_inc_subseq_length = max(longest_inc_subseq_length, inc_length) else: inc_length = 1 # Find the longest non-decreasing subsequence from the end longest_dec_subseq_length = 1 dec_length = 1 for i in range(n - 2, -1, -1): if arr[i] <= arr[i + 1]: dec_length += 1 longest_dec_subseq_length = max(longest_dec_subseq_length, dec_length) else: dec_length = 1 # The longest non-decreasing subsequence found will be max(longest_inc_subseq_length, longest_dec_subseq_length) max_sorted_length = max(longest_inc_subseq_length, longest_dec_subseq_length) # Minimum number of moves is total length - max sorted length return n - max_sorted_length"},{"question":"def remove_adjacent_duplicates(s: str, k: int) -> str: Removes k adjacent duplicate characters from the string s until no more such adjacent duplicate characters can be removed. Parameters: s (str): The input string consisting of only lowercase English letters. k (int): The number of adjacent duplicate characters to be removed. Returns: str: The final string after all possible adjacent duplicate character removals. >>> remove_adjacent_duplicates(\\"abcde\\", 3) \\"abcde\\" >>> remove_adjacent_duplicates(\\"deeedbbcccbdaa\\", 3) \\"aa\\" >>> remove_adjacent_duplicates(\\"pbbcggttciiippooaais\\", 2) \\"ps\\" >>> remove_adjacent_duplicates(\\"aaaa\\", 4) \\"\\" >>> remove_adjacent_duplicates(\\"abc\\", 2) \\"abc\\" >>> remove_adjacent_duplicates(\\"aabbccddeeaabbccdd\\", 2) \\"\\" >>> remove_adjacent_duplicates(\\"\\", 1) \\"\\" >>> remove_adjacent_duplicates(\\"abcd\\", 5) \\"abcd\\"","solution":"def remove_adjacent_duplicates(s, k): Removes k adjacent duplicate characters from the string s until no more such adjacent duplicate characters can be removed. Parameters: s (str): The input string consisting of only lowercase English letters. k (int): The number of adjacent duplicate characters to be removed. Returns: str: The final string after all possible adjacent duplicate character removals. stack = [] for char in s: if stack and stack[-1][0] == char: stack[-1][1] += 1 if stack[-1][1] == k: stack.pop() else: stack.append([char, 1]) result = ''.join(char * count for char, count in stack) return result"},{"question":"def longestSubstringKDistinct(s: str, k: int) -> int: Returns the length of the longest substring that contains at most k distinct characters. >>> longestSubstringKDistinct(\\"eceba\\", 2) 3 >>> longestSubstringKDistinct(\\"aa\\", 1) 2 >>> longestSubstringKDistinct(\\"abc\\", 1) 1 >>> longestSubstringKDistinct(\\"aacbbbee\\", 2) 5 >>> longestSubstringKDistinct(\\"\\", 2) 0 >>> longestSubstringKDistinct(\\"abc\\", 0) 0 >>> longestSubstringKDistinct(\\"a\\", 2) 1 >>> longestSubstringKDistinct(\\"aabbcc\\", 10) 6 >>> longestSubstringKDistinct(\\"abcdef\\", 3) 3","solution":"def longestSubstringKDistinct(s, k): Returns the length of the longest substring that contains at most k distinct characters. from collections import defaultdict # Edge case if k == 0: return 0 n = len(s) if n == 0: return 0 left, right = 0, 0 max_len = 0 char_count = defaultdict(int) while right < n: char_count[s[right]] += 1 right += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left) return max_len"},{"question":"def max_subrectangle_sum(matrix): Returns the maximum sum of any subrectangle in the given matrix. >>> max_subrectangle_sum([ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ... ]) 29 >>> max_subrectangle_sum([[3]]) 3 >>> max_subrectangle_sum([[2, 1, -3, 4, -1, 2, 1, -5, 4]]) 6 >>> max_subrectangle_sum([ ... [2], ... [1], ... [-3], ... [4], ... [-1], ... [2], ... [1], ... [-5], ... [4] ... ]) 6 >>> max_subrectangle_sum([ ... [-3, -2, -1], ... [-1, -2, -3], ... [-3, -2, -1] ... ]) -1 >>> max_subrectangle_sum([]) 0 >>> max_subrectangle_sum([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0","solution":"def max_subrectangle_sum(matrix): Returns the maximum sum of any subrectangle in the given matrix. if not matrix or not matrix[0]: return 0 def kadane(arr): Helper function to find the maximum sum of a 1D array. max_end_here = max_so_far = arr[0] for num in arr[1:]: max_end_here = max(num, max_end_here + num) max_so_far = max(max_so_far, max_end_here) return max_so_far rows, cols = len(matrix), len(matrix[0]) max_sum = float('-inf') for left_col in range(cols): temp_row_sum = [0] * rows for right_col in range(left_col, cols): for row in range(rows): temp_row_sum[row] += matrix[row][right_col] current_max_sum = kadane(temp_row_sum) max_sum = max(max_sum, current_max_sum) return max_sum"},{"question":"def words_with_prefix(words, prefix): Returns a list of all words that start with the given prefix. :param words: List of words :param prefix: Prefix string to match :return: List of words starting with the prefix >>> words_with_prefix([\\"apple\\", \\"banana\\", \\"apricot\\", \\"cherry\\", \\"blueberry\\"], \\"ap\\") ['apple', 'apricot'] >>> words_with_prefix([\\"apple\\", \\"banana\\", \\"cherry\\", \\"blueberry\\"], \\"an\\") [] >>> words_with_prefix([\\"apple\\", \\"apricot\\", \\"apply\\"], \\"ap\\") ['apple', 'apricot', 'apply'] >>> words_with_prefix([\\"apple\\", \\"banana\\", \\"apricot\\", \\"pineapple\\", \\"blueberry\\"], \\"pi\\") ['pineapple'] >>> words_with_prefix([], \\"ap\\") [] >>> words_with_prefix([\\"apple\\", \\"banana\\", \\"apricot\\", \\"cherry\\", \\"blueberry\\"], \\"\\") ['apple', 'banana', 'apricot', 'cherry', 'blueberry']","solution":"def words_with_prefix(words, prefix): Returns a list of all words that start with the given prefix. :param words: List of words :param prefix: Prefix string to match :return: List of words starting with the prefix result = [word for word in words if word.startswith(prefix)] return result"},{"question":"def find_original_index(nums, target): Finds the original index of the target in the non-rotated sorted array. Arguments: nums -- An array of integers that has been rotated. (1-indexed) target -- The target integer to find. Returns: The original index (1-indexed) of the target in the non-rotated sorted array, or -1 if the target is not found. pass # Unit Test def test_find_original_index(): # Rotation happens at different points assert find_original_index([4, 5, 1, 2, 3], 1) == 3 assert find_original_index([3, 4, 5, 1, 2], 1) == 4 assert find_original_index([1, 2, 3, 4, 5], 1) == 1 assert find_original_index([2, 3, 4, 5, 1], 1) == 5 # Target is not in the array assert find_original_index([4, 5, 1, 2, 3], 6) == -1 assert find_original_index([1, 2, 3, 4, 5], 6) == -1 # Full array is searched assert find_original_index([4, 5, 1, 2, 3], 2) == 4 assert find_original_index([3, 4, 5, 1, 2], 5) == 3 # Single element rotation assert find_original_index([1], 1) == 1 # Pivot is at the end assert find_original_index([2, 3, 4, 5, 1], 1) == 5 # Special cases with large numbers assert find_original_index([100, 200, 300, 400, 10, 20, 30], 400) == 4 assert find_original_index([100, 200, 300, 400, 10, 20, 30], 10) == 5 assert find_original_index([100, 200, 300, 400, 10, 20, 30], 1000) == -1","solution":"def find_original_index(nums, target): Finds the original index of the target in the non-rotated sorted array. Arguments: nums -- An array of integers that has been rotated. (1-indexed) target -- The target integer to find. Returns: The original index (1-indexed) of the target in the non-rotated sorted array, or -1 if the target is not found. if not nums: return -1 left, right = 0, len(nums) - 1 pivot = -1 # First, we find the pivot point where the rotation happened while left <= right: mid = (left + right) // 2 if mid < right and nums[mid] > nums[mid + 1]: pivot = mid break if mid > left and nums[mid] < nums[mid - 1]: pivot = mid - 1 break if nums[left] >= nums[mid]: right = mid - 1 else: left = mid + 1 if pivot == -1: pivot = len(nums) - 1 # Perform binary search in the rotated array def binary_search(nums, left, right, target): while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return -1 # Binary search applied on both subarrays split by pivot result = binary_search(nums, 0, pivot, target) if result != -1: return result + 1 # Convert to 1-indexed result = binary_search(nums, pivot + 1, len(nums) - 1, target) if result != -1: return result + 1 # Convert to 1-indexed return -1"},{"question":"def min_operations(s: str) -> int: Given a string \`s\` consisting of only characters 'a', 'b', and 'c', determine the minimum number of operations required to convert \`s\` into a string with no three consecutive characters being the same. In one operation, you can change any single character in the string to any other character ('a', 'b', or 'c'). Example: >>> min_operations(\\"aaabccc\\") 1 >>> min_operations(\\"abc\\") 0","solution":"def min_operations(s: str) -> int: Returns the minimum number of operations needed to ensure there are no three consecutive characters being the same in the string. operations = 0 n = len(s) i = 0 while i < n - 2: if s[i] == s[i+1] == s[i+2]: operations += 1 i += 2 # Skip next character since we need to change this one else: i += 1 return operations"},{"question":"from typing import List def maximize_interval_length(intervals: List[List[int]]) -> List[List[int]]: Find all the non-overlapping intervals from the given list that maximize the total length of intervals selected. Return the list of selected intervals sorted by their starting points. >>> maximize_interval_length([[1,3],[2,4],[3,5],[7,9]]) == [[1, 3], [7, 9]] >>> maximize_interval_length([[1,5],[2,6],[3,7],[4,8]]) == [[1, 5]] >>> maximize_interval_length([[1,3],[3,5],[6,8],[8,10]]) == [[1, 3], [6, 8]] >>> maximize_interval_length([[1,2]]) == [[1, 2]] >>> maximize_interval_length([]) == []","solution":"def maximize_interval_length(intervals): Returns the list of selected non-overlapping intervals that maximize the total length sorted by start point. # Sort intervals by their end time intervals = sorted(intervals, key=lambda x: x[1]) selected_intervals = [] last_end_time = -1 for interval in intervals: start, end = interval if start > last_end_time: selected_intervals.append(interval) last_end_time = end return selected_intervals"},{"question":"def min_moves_to_make_k_balanced(s: str, k: int) -> int: Returns the minimum number of moves required to make any substring of length k balanced. >>> min_moves_to_make_k_balanced(\\"aabcb\\", 3) 1 >>> min_moves_to_make_k_balanced(\\"aaaa\\", 1) 0 >>> min_moves_to_make_k_balanced(\\"aaaaa\\", 5) 0 >>> min_moves_to_make_k_balanced(\\"abcdef\\", 3) 2 >>> min_moves_to_make_k_balanced(\\"aabbcc\\", 4) 2 >>> min_moves_to_make_k_balanced(\\"abcde\\", 5) 4","solution":"def min_moves_to_make_k_balanced(s, k): Returns the minimum number of moves required to make any substring of length k balanced. Parameters: s (str): the input string consisting of lowercase English letters. k (int): the length of the substring to be balanced. Returns: int: minimum number of moves required. min_moves = float('inf') n = len(s) for i in range(n - k + 1): substring = s[i:i+k] char_freq = {} for ch in substring: if ch in char_freq: char_freq[ch] += 1 else: char_freq[ch] = 1 max_freq = max(char_freq.values()) moves = k - max_freq min_moves = min(min_moves, moves) return min_moves"},{"question":"def maximum_product_of_three(arr): Returns the maximum product of any three distinct numbers in the array. If the array contains fewer than three elements, return -1. >>> maximum_product_of_three([1, 2, 3, 4]) == 24 >>> maximum_product_of_three([-10, -10, 5, 2]) == 500 >>> maximum_product_of_three([-10, -3, -5, -6]) == -90 >>> maximum_product_of_three([-10, -3, 5, 6]) == 180 >>> maximum_product_of_three([1, 2]) == -1 >>> maximum_product_of_three([1, 10, 2, 6, 5, 3]) == 300 >>> maximum_product_of_three([1, 5, 5, 5]) == 125","solution":"def maximum_product_of_three(arr): Returns the maximum product of any three distinct numbers in the array. If the array contains fewer than three elements, return -1. if len(arr) < 3: return -1 arr.sort() # The maximum product of three numbers can be either: # 1. The product of the three largest numbers. # 2. The product of the two smallest numbers (most negative) and the largest number. max_product = max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1]) return max_product"},{"question":"def max_product_subarray(nums: List[int]) -> int: Given a list of non-negative integers \`nums\`, find the contiguous subarray (containing at least one number) which has the largest product, and return the product. Note that the contiguous subarray could include negative numbers as well, but the sign of the product will be determined by the even or odd count of those negative numbers. >>> max_product_subarray([1, 2, 3, 4]) 24 >>> max_product_subarray([-1, -2, -3, -4]) 24 >>> max_product_subarray([-1, -2, -3]) 6 >>> max_product_subarray([2, 3, -2, 4]) 6 >>> max_product_subarray([2]) 2 >>> max_product_subarray([-2]) -2 >>> max_product_subarray([2, 3, -2, 4, 0, -1]) 6 >>> max_product_subarray([-2, 0, -1]) 0 >>> max_product_subarray([-2, 3, -4]) 24 >>> max_product_subarray([0, 0, 0]) 0 >>> max_product_subarray([]) 0","solution":"def max_product_subarray(nums): Finds the contiguous subarray within an array (containing at least one number) which has the largest product. if not nums: return 0 max_prod = min_prod = result = nums[0] for num in nums[1:]: if num < 0: max_prod, min_prod = min_prod, max_prod max_prod = max(num, max_prod * num) min_prod = min(num, min_prod * num) result = max(result, max_prod) return result"},{"question":"def skyline_profiles(grid: List[List[int]]) -> Tuple[List[int], List[int]]: Given a 2D integer array \`grid\`, returns the skyline profiles from both top-bottom and left-right perspectives. Parameters: grid (List[List[int]]): 2D array representing the heights of buildings. Returns: Tuple[List[int], List[int]]: A tuple (left_right, top_bottom) where left_right is the list of maximum heights seen from left to right perspective and top_bottom is the list of maximum heights seen from top to bottom perspective. >>> skyline_profiles([ ... [3, 0, 8, 4], ... [2, 4, 5, 7], ... [9, 2, 6, 3], ... [0, 3, 1, 0]]) ([8, 7, 9, 3], [9, 4, 8, 7]) >>> skyline_profiles([ ... [1, 2, 3], ... [4, 5, 6]]) ([3, 6], [4, 5, 6]) >>> skyline_profiles([ ... [6, 7, 8, 7], ... [3, 4, 5, 5]]) ([8, 5], [6, 7, 8, 7]) >>> skyline_profiles([ ... [5]]) ([5], [5]) >>> skyline_profiles([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0]]) ([0, 0, 0], [0, 0, 0]) >>> skyline_profiles([]) ([], []) >>> skyline_profiles([[]]) ([], [])","solution":"def skyline_profiles(grid): Given a 2D integer array \`grid\`, returns the skyline profiles from both top-bottom and left-right perspectives. Parameters: grid (list of list of int): 2D array representing the heights of buildings. Returns: tuple: A tuple (left_right, top_bottom) where left_right is the list of maximum heights seen from left to right perspective and top_bottom is the list of maximum heights seen from top to bottom perspective. if not grid or not grid[0]: return ([], []) left_right = [max(row) for row in grid] top_bottom = [max(grid[i][j] for i in range(len(grid))) for j in range(len(grid[0]))] return (left_right, top_bottom)"},{"question":"class TreeNode: def __init__(self, operation, value=0, left=None, right=None): self.operation = operation # 'store' or 'add' self.value = value # only relevant for 'store' operations self.left = left self.right = right def compute_tree(root: TreeNode) -> int: Computes the final value of a binary tree where nodes perform 'add' or 'store' operations. >>> leaf = TreeNode('store', value=5) >>> compute_tree(leaf) 5 >>> left_leaf = TreeNode('store', value=1) >>> right_leaf = TreeNode('store', value=2) >>> root = TreeNode('add', left=left_leaf, right=right_leaf) >>> compute_tree(root) 3 >>> left_leaf = TreeNode('store', value=1) >>> right_node = TreeNode('add', left=TreeNode('store', value=2), right=TreeNode('store', value=3)) >>> root = TreeNode('add', left=left_leaf, right=right_node) >>> compute_tree(root) 6 >>> left_sub_tree = TreeNode('add', left=TreeNode('store', value=4), right=TreeNode('store', value=5)) >>> right_sub_tree = TreeNode('add', left=TreeNode('store', value=3), right=TreeNode('store', value=2)) >>> root = TreeNode('add', left=left_sub_tree, right=right_sub_tree) >>> compute_tree(root) 14 >>> left_leaf = TreeNode('store', value=7) >>> right_node = TreeNode('add', left=TreeNode('store', value=-3), right=TreeNode('store', value=4)) >>> root = TreeNode('add', left=left_leaf, right=right_node) >>> compute_tree(root) 8 # Your code here","solution":"class TreeNode: def __init__(self, operation, value=0, left=None, right=None): self.operation = operation # 'store' or 'add' self.value = value # only relevant for 'store' operations self.left = left self.right = right def compute_tree(root: TreeNode) -> int: if root.operation == 'store': return root.value elif root.operation == 'add': left_value = compute_tree(root.left) right_value = compute_tree(root.right) return left_value + right_value # Example usage: # tree = TreeNode('add', left=TreeNode('store', value=1), right=TreeNode('add', left=TreeNode('store', value=2), right=TreeNode('store', value=3))) # assert compute_tree(tree) == 6 # 1 + (2 + 3)"},{"question":"def maximumDifference(nums: List[int]) -> int: Given an integer array nums, return the maximum difference between the increasing elements of nums such that for some i < j, nums[j] > nums[i]. If no such j exists, return -1. >>> maximumDifference([7, 1, 5, 4]) 4 >>> maximumDifference([9, 4, 3, 2]) -1 >>> maximumDifference([1, 2, 3, 4, 5]) 4 >>> maximumDifference([10]) -1 >>> maximumDifference([5, 5, 5, 5]) -1 >>> maximumDifference([1, 2, -3, 4, 5]) 8 >>> maximumDifference([1, 5, 1, 5, 1]) 4","solution":"def maximumDifference(nums): Given an integer array nums, return the maximum difference between the increasing elements of nums such that for some i < j, nums[j] > nums[i]. If no such j exists, return -1. max_diff = -1 min_element = nums[0] for num in nums[1:]: if num > min_element: max_diff = max(max_diff, num - min_element) min_element = min(min_element, num) return max_diff"},{"question":"def find_max_length(s: str) -> int: Write a function that takes a string \`s\` consisting of characters \`'0'\` and \`'1'\`. The function should return the maximum length of a contiguous subarray such that the number of \`'0'\`s and the number of \`'1'\`s in this subarray are equal. Examples: >>> find_max_length(\\"0011\\") 4 >>> find_max_length(\\"010101\\") 6 >>> find_max_length(\\"001100\\") 4","solution":"def find_max_length(s): Returns the maximum length of a contiguous subarray with equal number of '0's and '1's. count_map = {0: -1} max_len = 0 count = 0 for i, char in enumerate(s): count += 1 if char == '1' else -1 if count in count_map: max_len = max(max_len, i - count_map[count]) else: count_map[count] = i return max_len"},{"question":"from typing import List, Tuple def group_and_sort_items(items: List[Tuple[str, str]]) -> List[Tuple[str, List[str]]]: Group the items by their types and then sort each group alphabetically by the item names. Finally, return the grouped and sorted list of items while maintaining the order of types as they appear in the input list. >>> items = [[\\"fruit\\", \\"apple\\"], [\\"fruit\\", \\"banana\\"], [\\"vegetable\\", \\"carrot\\"], [\\"fruit\\", \\"cherry\\"], [\\"vegetable\\", \\"beetroot\\"]] >>> group_and_sort_items(items) [[\\"fruit\\", [\\"apple\\", \\"banana\\", \\"cherry\\"]], [\\"vegetable\\", [\\"beetroot\\", \\"carrot\\"]]] >>> items = [[\\"bird\\", \\"sparrow\\"], [\\"bird\\", \\"eagle\\"], [\\"animal\\", \\"zebra\\"], [\\"animal\\", \\"aardvark\\"]] >>> group_and_sort_items(items) [[\\"bird\\", [\\"eagle\\", \\"sparrow\\"]], [\\"animal\\", [\\"aardvark\\", \\"zebra\\"]]] >>> items = [[\\"insect\\", \\"ant\\"], [\\"insect\\", \\"bee\\"], [\\"insect\\", \\"butterfly\\"], [\\"flower\\", \\"rose\\"], [\\"flower\\", \\"tulip\\"]] >>> group_and_sort_items(items) [[\\"insect\\", [\\"ant\\", \\"bee\\", \\"butterfly\\"]], [\\"flower\\", [\\"rose\\", \\"tulip\\"]]] >>> items = [[\\"fruit\\", \\"apple\\"], [\\"fruit\\", \\"cherry\\"], [\\"fruit\\", \\"banana\\"]] >>> group_and_sort_items(items) [[\\"fruit\\", [\\"apple\\", \\"banana\\", \\"cherry\\"]]] >>> items = [] >>> group_and_sort_items(items) []","solution":"def group_and_sort_items(items): from collections import defaultdict # Step 1: Group items by type grouped_items = defaultdict(list) order_of_types = [] for item_type, item_name in items: if item_type not in grouped_items: order_of_types.append(item_type) grouped_items[item_type].append(item_name) # Step 2: Sort each group alphabetically by item names result = [] for item_type in order_of_types: sorted_names = sorted(grouped_items[item_type]) result.append([item_type, sorted_names]) return result"},{"question":"def split_string(s: str, n: int) -> List[str]: Split the string s into parts of length n. If the string length is not a multiple of n, pad the last part with the character '_' (underscore) to make its length equal to n. >>> split_string(\\"abcdef\\", 2) [\\"ab\\", \\"cd\\", \\"ef\\"] >>> split_string(\\"abcdefg\\", 3) [\\"abc\\", \\"def\\", \\"g__\\"] >>> split_string(\\"abcdef\\", 1) [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\"] >>> split_string(\\"abcd\\", 4) [\\"abcd\\"] >>> split_string(\\"abc\\", 5) [\\"abc__\\"] >>> split_string(\\"\\", 3) [] >>> split_string(\\"abc\\", 10) [\\"abc_______\\"] >>> split_string(\\"abcdefghij\\", 4) [\\"abcd\\", \\"efgh\\", \\"ij__\\"]","solution":"def split_string(s, n): Split the string s into parts of length n. If the string length is not a multiple of n, pad the last part with the character '_' (underscore) to make its length equal to n. :param s: string to be split :param n: length of each part :return: list of parts result = [] for i in range(0, len(s), n): part = s[i:i+n] if len(part) < n: part += '_' * (n - len(part)) result.append(part) return result"},{"question":"def check_permutation_inclusion(s1: str, s2: str) -> bool: Determine if any permutation of s1 is a substring of s2. Args: s1: The string of which permutations are to be checked. s2: The string within which to find permutations of s1. Returns: bool: True if any permutation of s1 is a substring of s2, else False. >>> check_permutation_inclusion('ab', 'eidbaooo') True >>> check_permutation_inclusion('ab', 'eidboaoo') False >>> check_permutation_inclusion('abc', 'abc') True >>> check_permutation_inclusion('a', 'eidbaooo') True >>> check_permutation_inclusion('abc', 'defghijkl') False >>> check_permutation_inclusion('', 'eidbaooo') True >>> check_permutation_inclusion('a', '') False >>> check_permutation_inclusion('', '') True >>> check_permutation_inclusion('abcdef', 'abc') False >>> check_permutation_inclusion('abcd', 'dcba') True","solution":"def check_permutation_inclusion(s1, s2): Determine if any permutation of s1 is a substring of s2. Args: s1: The string of which permutations are to be checked. s2: The string within which to find permutations of s1. Returns: bool: True if any permutation of s1 is a substring of s2, else False. from collections import Counter if len(s1) > len(s2): return False s1_count = Counter(s1) window_count = Counter(s2[:len(s1)]) if s1_count == window_count: return True for i in range(len(s1), len(s2)): window_count[s2[i]] += 1 window_count[s2[i - len(s1)]] -= 1 if window_count[s2[i - len(s1)]] == 0: del window_count[s2[i - len(s1)]] if window_count == s1_count: return True return False"},{"question":"def can_transform(s: str, k: int) -> bool: Determines if it's possible to replace exactly k characters in s such that no two adjacent characters are the same. :param s: str, input string consisting of 'A', 'B', and 'C' :param k: int, number of characters to replace :return: bool, True if transformation is possible, otherwise False >>> can_transform(\\"ABC\\", 1) True >>> can_transform(\\"BAC\\", 2) True >>> can_transform(\\"AAB\\", 1) True >>> can_transform(\\"AAB\\", 0) False >>> can_transform(\\"AAAB\\", 2) True >>> can_transform(\\"AAAB\\", 1) False >>> can_transform(\\"ABAABA\\", 3) True >>> can_transform(\\"AAA\\", 3) True","solution":"def can_transform(s, k): Determines if it's possible to replace exactly k characters in s such that no two adjacent characters are the same. :param s: str, input string consisting of 'A', 'B', and 'C' :param k: int, number of characters to replace :return: bool, True if transformation is possible, otherwise False n = len(s) # Case when k >= n if k >= n: return True # Count adjacent same characters adjacent_count = 0 for i in range(1, n): if s[i] == s[i - 1]: adjacent_count += 1 # transformation is possible if adjacent block count <= k return adjacent_count <= k"},{"question":"from collections import Counter import heapq def rearrange_string(s: str) -> str: Rearrange the string such that no two adjacent characters are the same. If possible, return one valid rearrangement. Otherwise, return an empty string. >>> rearrange_string(\\"aab\\") == \\"aba\\" >>> rearrange_string(\\"aaab\\") == \\"\\" >>> rearrange_string(\\"a\\") == \\"a\\" >>> rearrange_string(\\"aaaa\\") == \\"\\" >>> rearrange_string(\\"aaabbc\\") in [\\"ababac\\", \\"abacab\\", \\"abacba\\", \\"abcbac\\", \\"babcab\\", \\"bacaba\\"]","solution":"from collections import Counter import heapq def rearrange_string(s): Rearrange the string such that no two adjacent characters are the same. If possible, return one valid rearrangement. Otherwise, return an empty string. # Count frequency of each character counter = Counter(s) # Create a max heap based on the counts (-ve for max heap in python) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) # Initialize the previous character and count prev_count, prev_char = 0, '' result = [] while max_heap or prev_count < 0: if not max_heap: return \\"\\" count, char = heapq.heappop(max_heap) result.append(char) # As we have used one instance of 'char', decrement the count and push previous char back into heap if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char return ''.join(result)"},{"question":"def num_submatrix_sum_target(matrix: List[List[int]], target: int) -> int: Return the number of submatrices that sum to the target value. >>> num_submatrix_sum_target([ [1, -1], [-1, 1] ], 0) 5 >>> num_submatrix_sum_target([ [0, 1, 0], [1, 1, 1], [0, 1, 0] ], 0) 4 >>> num_submatrix_sum_target([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ], 100) 0 >>> num_submatrix_sum_target([[5]], 5) 1 >>> num_submatrix_sum_target([[3]], 5) 0","solution":"def num_submatrix_sum_target(matrix, target): from collections import defaultdict m, n = len(matrix), len(matrix[0]) # To store the cumulative sum of elements in each row, column-wise. cumulative_row_sum = [[0] * (n+1) for _ in range(m)] for i in range(m): for j in range(n): cumulative_row_sum[i][j+1] = cumulative_row_sum[i][j] + matrix[i][j] result = 0 for col_start in range(n): for col_end in range(col_start, n): sum_freq = defaultdict(int) sum_freq[0] = 1 curr_sum = 0 for row in range(m): curr_sum += cumulative_row_sum[row][col_end+1] - cumulative_row_sum[row][col_start] result += sum_freq[curr_sum - target] sum_freq[curr_sum] += 1 return result"},{"question":"def min_operations_to_equal_chars(s: str) -> int: Returns the minimum number of operations needed to make all characters in the binary string equal. >>> min_operations_to_equal_chars(\\"0000\\") == 0 >>> min_operations_to_equal_chars(\\"1111\\") == 0 >>> min_operations_to_equal_chars(\\"0101\\") == 2 >>> min_operations_to_equal_chars(\\"0\\") == 0 >>> min_operations_to_equal_chars(\\"1\\") == 0 >>> min_operations_to_equal_chars(\\"0011\\") == 2 >>> min_operations_to_equal_chars(\\"00001\\") == 1 >>> min_operations_to_equal_chars(\\"11110\\") == 1 >>> min_operations_to_equal_chars(\\"1010101010\\") == 5 >>> min_operations_to_equal_chars(\\"0101010101\\") == 5","solution":"def min_operations_to_equal_chars(s): Returns the minimum number of operations needed to make all characters in the binary string equal. n = len(s) num_zeros = s.count('0') num_ones = n - num_zeros # since the rest will be ones # The strategy is to count the number of 0's and 1's and the minimum number of # operations is to flip the lesser frequency character to match the higher frequency character. return min(num_zeros, num_ones)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumNumbers(root) -> int: Returns the sum of all the numbers represented by root-to-leaf paths modulo 10^9 + 7. >>> root = TreeNode(4, TreeNode(9, TreeNode(5), TreeNode(1)), TreeNode(0)) >>> sumNumbers(root) == 1026 True >>> root = TreeNode(1) >>> sumNumbers(root) == 1 True >>> sumNumbers(None) == 0 True >>> root = TreeNode(1, TreeNode(2, TreeNode(3))) >>> sumNumbers(root) == 123 True >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) >>> sumNumbers(root) == 123 True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumNumbers(root): Returns the sum of all the numbers represented by root-to-leaf paths modulo 10^9 + 7. MOD = 10**9 + 7 def dfs(node, current_number): Depth-first search helper function to calculate the sum of numbers. if not node: return 0 current_number = current_number * 10 + node.val if not node.left and not node.right: # if it's a leaf return current_number # recursively sum the numbers from both subtrees left_sum = dfs(node.left, current_number) right_sum = dfs(node.right, current_number) return (left_sum + right_sum) % MOD return dfs(root, 0)"},{"question":"def is_palindrome_number(x: int) -> bool: Determines whether a non-negative integer is a palindrome without converting it to a string. Args: x (int): A non-negative integer. Returns: bool: True if x is a palindrome, False otherwise. >>> is_palindrome_number(121) True >>> is_palindrome_number(123) False >>> is_palindrome_number(-121) False >>> is_palindrome_number(11) True","solution":"def is_palindrome_number(x): Determines whether a non-negative integer is a palindrome without converting it to a string. Args: x (int): A non-negative integer. Returns: bool: True if x is a palindrome, False otherwise. if x < 0: return False original_x = x reversed_x = 0 while x > 0: reversed_x = reversed_x * 10 + x % 10 x //= 10 return original_x == reversed_x"},{"question":"class Node: def __init__(self, val, children=None): self.val = val self.children = children if children is not None else [] def levelOrder(root): Perform a level order traversal (breadth-first search) of an n-ary tree. Returns a list of lists representing the node values at each depth level. >>> root = Node(1, [Node(2), Node(3), Node(4)]) >>> levelOrder(root) [[1], [2, 3, 4]] >>> root = Node(1, [Node(2, [Node(5)]), Node(3, [Node(6), Node(7)]), Node(4)]) >>> levelOrder(root) [[1], [2, 3, 4], [5, 6, 7]] >>> levelOrder(None) []","solution":"class Node: def __init__(self, val, children=None): self.val = val self.children = children if children is not None else [] def levelOrder(root): Perform a level order traversal (breadth-first search) of an n-ary tree. Returns a list of lists representing the node values at each depth level. if not root: return [] queue = [(root, 0)] result = [] while queue: node, depth = queue.pop(0) if depth == len(result): result.append([]) result[depth].append(node.val) for child in node.children: queue.append((child, depth + 1)) return result"},{"question":"def find_two_subarrays_with_sum(arr: List[int], S: int) -> bool: Determines if there exist two non-overlapping continuous subarrays within \`arr\` whose sums are both equal to \`S\`. >>> find_two_subarrays_with_sum([1, 2, 3, 4, 2, 1, 3, 4], 6) True >>> find_two_subarrays_with_sum([1, 2, 3, 4, 5], 9) False >>> find_two_subarrays_with_sum([1, 2, 3, 4, 5], 15) False >>> find_two_subarrays_with_sum([1, 1, 1, 1, 1, 1, 1, 1, 1], 2) True >>> find_two_subarrays_with_sum([1, 2, 3, 1, 2, 3], 3) True","solution":"def find_two_subarrays_with_sum(arr, S): Determines if there exist two non-overlapping continuous subarrays within \`arr\` whose sums are both equal to \`S\`. def find_subarrays_with_sum(arr, S): subarrays = [] current_sum = 0 start_index = 0 for end_index, value in enumerate(arr): current_sum += value while current_sum > S and start_index <= end_index: current_sum -= arr[start_index] start_index += 1 if current_sum == S: subarrays.append((start_index, end_index)) return subarrays subarrays = find_subarrays_with_sum(arr, S) for i in range(len(subarrays)): for j in range(i + 1, len(subarrays)): if subarrays[i][1] < subarrays[j][0] or subarrays[j][1] < subarrays[i][0]: return True return False"},{"question":"def largest_island(grid: List[List[str]]) -> int: Returns the size of the largest island in the grid. >>> largest_island([ ... ['0', '1', '0'], ... ['0', '0', '0'], ... ['0', '0', '0'] ... ]) == 1 >>> largest_island([ ... ['1', '0', '0', '1'], ... ['1', '0', '0', '0'], ... ['0', '0', '1', '1'], ... ['0', '1', '1', '1'] ... ]) == 5 >>> largest_island([ ... ['0', '0', '0'], ... ['0', '0', '0'], ... ['0', '0', '0'] ... ]) == 0 >>> largest_island([ ... ['1', '1', '0', '0'], ... ['1', '1', '0', '1'], ... ['0', '0', '1', '1'], ... ['0', '1', '1', '1'] ... ]) == 6 >>> largest_island([ ... ['1', '0', '1', '0'], ... ['0', '1', '0', '1'], ... ['1', '0', '1', '0'], ... ['0', '1', '0', '1'] ... ]) == 1","solution":"def largest_island(grid): Returns the size of the largest island in the grid. if not grid: return 0 rows = len(grid) cols = len(grid[0]) visited = set() def dfs(r, c): if (r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == '0' or (r, c) in visited): return 0 visited.add((r, c)) size = 1 # Current land size += dfs(r + 1, c) size += dfs(r - 1, c) size += dfs(r, c + 1) size += dfs(r, c - 1) return size largest_size = 0 for r in range(rows): for c in range(cols): if grid[r][c] == '1' and (r, c) not in visited: island_size = dfs(r, c) largest_size = max(largest_size, island_size) return largest_size"},{"question":"def smallest_possible_string_length(s: str) -> int: Find the length of the smallest possible string after performing any number of operations on a string consisting of 'a', 'b', and 'c'. >>> smallest_possible_string_length('aaa') == 3 >>> smallest_possible_string_length('ababab') == 0 >>> smallest_possible_string_length('abacaba') == 1 >>> smallest_possible_string_length('') == 0 >>> smallest_possible_string_length('a') == 1","solution":"def smallest_possible_string_length(s): stack = [] for char in s: if stack and stack[-1] != char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"class TextEditor: A simple text editor class to simulate typing and deletion of characters. Methods: - TextEditor(): Initializes an empty text editor. - typeCharacter(c): Adds the character \`c\` to the text at the current cursor position. - deleteCharacter(): Deletes the character immediately before the current cursor position. - getText(): Returns the text currently in the editor. def __init__(self): Initialize an empty text editor. def typeCharacter(self, c): Add the character \`c\` to the text at the current cursor position. def deleteCharacter(self): Delete the character immediately before the current cursor position. def getText(self): Returns the text currently in the editor. def test_initial_text(): editor = TextEditor() assert editor.getText() == \\"\\" def test_typing_characters(): editor = TextEditor() editor.typeCharacter('a') assert editor.getText() == \\"a\\" editor.typeCharacter('b') assert editor.getText() == \\"ab\\" editor.typeCharacter('c') assert editor.getText() == \\"abc\\" def test_deleting_characters(): editor = TextEditor() editor.typeCharacter('a') editor.typeCharacter('b') editor.typeCharacter('c') assert editor.getText() == \\"abc\\" editor.deleteCharacter() assert editor.getText() == \\"ab\\" editor.deleteCharacter() assert editor.getText() == \\"a\\" editor.deleteCharacter() assert editor.getText() == \\"\\" editor.deleteCharacter() # Try deleting when empty assert editor.getText() == \\"\\" def test_editing_mixed_operations(): editor = TextEditor() editor.typeCharacter('t') editor.typeCharacter('e') editor.typeCharacter('s') editor.typeCharacter('t') assert editor.getText() == \\"test\\" editor.deleteCharacter() assert editor.getText() == \\"tes\\" editor.typeCharacter('t') editor.typeCharacter('i') editor.typeCharacter('n') editor.typeCharacter('g') assert editor.getText() == \\"testing\\" editor.deleteCharacter() editor.deleteCharacter() assert editor.getText() == \\"testi\\" editor.typeCharacter('n') editor.typeCharacter('g') assert editor.getText() == \\"testing\\"","solution":"class TextEditor: A simple text editor class to simulate typing and deletion of characters. def __init__(self): Initialize an empty text editor. self.text = [] self.cursor = 0 def typeCharacter(self, c): Add the character \`c\` to the text at the current cursor position. self.text.insert(self.cursor, c) self.cursor += 1 def deleteCharacter(self): Delete the character immediately before the current cursor position. Move the cursor one position back if possible. if self.cursor > 0: del self.text[self.cursor - 1] self.cursor -= 1 def getText(self): Returns the text currently in the editor. return ''.join(self.text)"},{"question":"def longest_ones(nums: List[int], k: int) -> int: Write a function that takes in a 0-indexed binary array \`nums\` of length \`n\`, consisting of only \`0\` and \`1\`. A subarray is a contiguous part of the array. You can flip at most \`k\` elements from \`0\` to \`1\` in the array. Return the length of the longest subarray consisting of only \`1\`'s after flipping at most \`k\` \`0\`'s. Note that the flips should be done optimally to maximize the length of the subarray. >>> longest_ones([1,1,1,1,1], 0) 5 >>> longest_ones([0,0,0,0,0], 0) 0 >>> longest_ones([1,1,0,0,1], 2) 5 >>> longest_ones([0,0,1,1,1], 2) 5 >>> longest_ones([1,0,0,1,0], 2) 4 >>> longest_ones([0,0,0,0,1], 4) 5 >>> longest_ones([1,0,0,1,1,0,1], 5) 7 >>> longest_ones([0,1,0,1,0,1,0,1], 3) 7 >>> longest_ones([1,0,1,0,1,0,1,0], 4) 8 >>> longest_ones([], 0) 0","solution":"def longest_ones(nums, k): Returns the length of the longest subarray consisting of only 1s after flipping at most k 0s to 1s. left = 0 max_length = 0 zeros_count = 0 # Use a sliding window approach for right in range(len(nums)): if nums[right] == 0: zeros_count += 1 while zeros_count > k: if nums[left] == 0: zeros_count -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def is_bipartite(graph: dict) -> bool: Determines if the given undirected graph is bipartite. >>> is_bipartite({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]}) True >>> is_bipartite({0: [1, 2, 3], 1: [0, 2], 2: [0, 1, 3], 3: [0, 2]}) False >>> is_bipartite({0: []}) True >>> is_bipartite({}) True >>> is_bipartite({0: [1], 1: [0], 2: [3], 3: [2]}) True >>> graph = {} >>> num_nodes = 1000 >>> for i in range(num_nodes): >>> graph[i] = [(i + 1) % num_nodes] >>> is_bipartite(graph) True","solution":"def is_bipartite(graph): Determines if the given undirected graph is bipartite. Args: graph (dict): The adjacency list representing the graph. Returns: bool: True if the graph is bipartite, False otherwise. from collections import deque color = {} for node in graph: if node not in color: color[node] = 0 queue = deque([node]) while queue: current = queue.popleft() for neighbor in graph[current]: if neighbor not in color: color[neighbor] = 1 - color[current] queue.append(neighbor) elif color[neighbor] == color[current]: return False return True"},{"question":"def smallestWindow(s): Find the smallest window in \`s\` that contains all the distinct characters in \`s\` at least once. If there are multiple such windows, return the one which appears first lexicographically. Args: s (str): A string consisting of lowercase Latin letters. Returns: str: The smallest window containing all distinct characters in \`s\` or an empty string if \`s\` is empty. >>> smallestWindow(\\"aabcbcdbca\\") \\"dbca\\" >>> smallestWindow(\\"aaaa\\") \\"a\\" >>> smallestWindow(\\"\\") \\"\\" >>> smallestWindow(\\"abcd\\") \\"abcd\\" >>> smallestWindow(\\"abcaa\\") \\"abc\\" >>> smallestWindow(\\"axaayz\\") \\"xaayz\\"","solution":"def smallestWindow(s): if not s: return \\"\\" # All unique characters in the string unique_chars = set(s) unique_count = len(unique_chars) n = len(s) min_window = s min_length = n + 1 left = 0 char_count = {} for right in range(n): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) == unique_count: if right - left + 1 < min_length: min_length = right - left + 1 min_window = s[left:right + 1] char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 return min_window"},{"question":"def min_students_to_move(heights: List[int]) -> int: Returns the minimum number of students that must be moved to achieve the required arrangement. >>> min_students_to_move([150, 150, 150]) == 4 >>> min_students_to_move([100, 100, 200, 200, 300, 300]) == 6 >>> min_students_to_move([100, 100, 200, 300]) == 2 >>> min_students_to_move([110, 120, 130, 140]) == 0","solution":"def min_students_to_move(heights): Returns the minimum number of students that must be moved to achieve the required arrangement. n = len(heights) if n <= 1: return 0 heights_sorted = sorted(heights) # To ensure no two students with the same height are adjacent, we must count the number of # such adjacent duplicates in the sorted list. moves = 0 for i in range(n - 1): if heights_sorted[i] == heights_sorted[i + 1]: moves += 1 return moves * 2"},{"question":"from typing import List def longest_ideal_subsequence(arr: List[int]) -> int: Return the length of the longest ideal subsequence in \`arr\`. An ideal subsequence is defined as a subsequence in which every adjacent element maintains an ascending order and the difference between any two adjacent elements in the subsequence is a prime number. >>> longest_ideal_subsequence([]) == 0 >>> longest_ideal_subsequence([5]) == 1 >>> longest_ideal_subsequence([10, 10, 10]) == 1 >>> longest_ideal_subsequence([1, 3, 7, 10]) == 3 >>> longest_ideal_subsequence([2, 3, 6, 10, 7, 11]) == 3 >>> longest_ideal_subsequence([5, 5, 5, 5, 5]) == 1 >>> longest_ideal_subsequence([11, 13, 18, 19, 14, 4, 8, 6]) == 3","solution":"from sympy import isprime def longest_ideal_subsequence(arr): if not arr: return 0 n = len(arr) dp = [1]*n # dp[i] will be the length of longest ideal subsequence ending with arr[i] for i in range(1, n): for j in range(i): if arr[i] > arr[j] and isprime(arr[i] - arr[j]): dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def numIslands2(m: int, n: int, positions: List[List[int]]) -> List[int]: Returns a list of the number of islands after each addLand operation on an m x n grid. >>> numIslands2(3, 3, [[0,0],[0,1],[1,2],[2,1]]) [1, 1, 2, 3] >>> numIslands2(3, 3, [[0,0],[0,1],[1,2],[2,1],[1,1]]) [1, 1, 2, 3, 1] >>> numIslands2(1, 1, [[0,0]]) [1] >>> numIslands2(3, 3, [[0,0],[0,0],[1,1],[0,1]]) [1, 1, 2, 1] >>> numIslands2(2, 2, [[0,0],[0,1],[1,1]]) [1, 1, 1] >>> numIslands2(2, 2, [[0,0],[1,0],[1,1]]) [1, 1, 1] # Your code here","solution":"def numIslands2(m, n, positions): Returns a list of the number of islands after each addLand operation on an m x n grid. parent = {} rank = {} def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def add(x, y): if (x, y) in parent: return 0 parent[(x, y)] = (x, y) rank[(x, y)] = 0 island_count = 1 for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]: nx, ny = x + dx, y + dy if (nx, ny) in parent: if find((nx, ny)) != find((x, y)): union((nx, ny), (x, y)) island_count -= 1 return island_count grid = [[0] * n for _ in range(m)] result = [] current_islands = 0 for x, y in positions: current_islands += add(x, y) result.append(current_islands) return result"},{"question":"from typing import List def max_increasing_subarrays(arr: List[int]) -> int: Given an array of integers \`arr\`, partition the array into subarrays such that each subarray's elements are strictly increasing. Return the maximum number of such partitions. >>> max_increasing_subarrays([1]) 1 >>> max_increasing_subarrays([1, 2, 3, 4, 5]) 1 >>> max_increasing_subarrays([5, 4, 3, 2, 1]) 5 >>> max_increasing_subarrays([1, 2, 1, 3, 2]) 3 >>> max_increasing_subarrays([1, 3, 1, 3, 1, 3]) 3 >>> max_increasing_subarrays([]) 0 >>> max_increasing_subarrays([1, 4, 6, 7, 9]) 1","solution":"def max_increasing_subarrays(arr): Given an array of integers \`arr\`, partition the array into subarrays such that each subarray's elements are strictly increasing. Return the maximum number of such partitions. if not arr: return 0 count = 1 for i in range(1, len(arr)): if arr[i] <= arr[i-1]: count += 1 return count"},{"question":"def buildings_with_sunset_view(arr): Returns the indices of the buildings that have a sunset view. A building has a sunset view if it's not blocked by any taller or equal height building to its right. :param arr: List of integers representing the heights of buildings :return: List of indices (in increasing order) of buildings with a sunset view >>> buildings_with_sunset_view([3, 3, 3, 3]) == [3] >>> buildings_with_sunset_view([4, 3, 2, 1]) == [0, 1, 2, 3] >>> buildings_with_sunset_view([1, 2, 3, 4]) == [3] >>> buildings_with_sunset_view([4, 2, 3, 1]) == [0, 2, 3] >>> buildings_with_sunset_view([1]) == [0] >>> buildings_with_sunset_view([]) == [] >>> buildings_with_sunset_view([1, 2, 3, 2, 1, 4]) == [5]","solution":"def buildings_with_sunset_view(arr): Returns the indices of the buildings that have a sunset view. A building has a sunset view if it's not blocked by any taller or equal height building to its right. :param arr: List of integers representing the heights of buildings :return: List of indices (in increasing order) of buildings with a sunset view n = len(arr) if n == 0: return [] result = [] max_height_from_right = -1 for i in range(n - 1, -1, -1): if arr[i] > max_height_from_right: result.append(i) max_height_from_right = arr[i] return sorted(result)"},{"question":"def four_sum(nums: List[int], target: int) -> List[List[int]]: Find all unique quadruplets in the list that sum up to the target value. :param nums: List of distinct integers :param target: Target sum for the quadruplets :return: List of unique quadruplets Example: >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([2, 2, 2, 2, 2], 8) [[2, 2, 2, 2]] Unit tests: from solution import four_sum def test_four_sum_example_case(): nums = [1, 0, -1, 0, -2, 2] target = 0 expected = [ [-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1] ] result = four_sum(nums, target) assert sorted(result) == sorted(expected) def test_four_sum_no_result(): nums = [1, 2, 3, 4, 5] target = 100 expected = [] result = four_sum(nums, target) assert result == expected def test_four_sum_with_negative_numbers(): nums = [-3, -1, 0, 2, 4, 5] target = 2 expected = [ [-3, -1, 2, 4] ] result = four_sum(nums, target) assert result == expected def test_four_sum_with_multiple_solutions(): nums = [2, 2, 2, 2, 2] target = 8 expected = [ [2, 2, 2, 2] ] result = four_sum(nums, target) assert result == expected def test_four_sum_large_numbers(): nums = [1000, 2000, 3000, -1000, -2000, -3000] target = 0 expected = [ [-3000, -2000, 2000, 3000], [-3000, -1000, 1000, 3000], [-2000, -1000, 1000, 2000] ] result = four_sum(nums, target) assert sorted(result) == sorted(expected)","solution":"def four_sum(nums, target): Find all unique quadruplets in the list that sum up to the target value. :param nums: List of distinct integers :param target: Target sum for the quadruplets :return: List of unique quadruplets nums.sort() quadruplets = [] n = len(nums) for i in range(n - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, n - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue left = j + 1 right = n - 1 while left < right: s = nums[i] + nums[j] + nums[left] + nums[right] if s == target: quadruplets.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif s < target: left += 1 else: right -= 1 return quadruplets"},{"question":"from typing import List def count_cells_with_greater_neighbors(matrix: List[List[int]]) -> int: Count the number of cells that have at least one neighboring cell with a greater value. Args: matrix (list of list of int): 2D integer matrix of size m x n. Returns: int: Count of cells with at least one neighboring cell with a greater value. Examples: >>> count_cells_with_greater_neighbors([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 8 >>> count_cells_with_greater_neighbors([ ... [1, 2], ... [3, 4] ... ]) 3 >>> count_cells_with_greater_neighbors([ ... [9, 9], ... [9, 9] ... ]) 0 >>> count_cells_with_greater_neighbors([ ... [1, 2, 3, 4] ... ]) 3 >>> count_cells_with_greater_neighbors([ ... [4], ... [3], ... [2], ... [1] ... ]) 3","solution":"def count_cells_with_greater_neighbors(matrix): Count the number of cells that have at least one neighboring cell with a greater value. Args: matrix (list of list of int): 2D integer matrix of size m x n. Returns: int: Count of cells with at least one neighboring cell with a greater value. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) count = 0 # Define the 8 possible neighbors for a cell (including diagonal) directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] for i in range(m): for j in range(n): current_value = matrix[i][j] for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > current_value: count += 1 break return count"},{"question":"class FileSystem: Implement a file system that can perform the following operations: * createPath: Creates a new path in the file system. * get: Retrieves the value associated with a given path. Paths are represented as strings that are separated by '/' such as '/a' and '/a/b'. Note that the root path '/' is not included in any other paths. Each path must be created sequentially, meaning that to create a path '/a/b', path '/a' must already exist. >>> fs = FileSystem() >>> fs.createPath('/a', 1) True >>> fs.createPath('/a/b', 2) True >>> fs.createPath('/a/b/c', 3) False >>> fs.get('/a') 1 >>> fs.get('/a/b') 2 >>> fs.get('/a/c') -1 def __init__(self): pass def createPath(self, path: str, value: int) -> bool: pass def get(self, path: str) -> int: pass","solution":"class FileSystem: def __init__(self): self.paths = {} def createPath(self, path: str, value: int) -> bool: # Ensure the path starts with a '/' and is not the only '/' if not path or path == '/' or path[0] != '/': return False # Split the path into parts and find the parent path parts = path.split('/') parent_path = '/'.join(parts[:-1]) # Check if parent path exists or this is trying to rewrite an existing path if parent_path and parent_path not in self.paths: return False if path in self.paths: return False # Create the new path self.paths[path] = value return True def get(self, path: str) -> int: return self.paths.get(path, -1)"},{"question":"def count_increasing_subarrays(arr, k): Returns the number of distinct subarrays of length k that have all elements in strictly increasing order. Args: arr (list of int): The input array of integers. k (int): The length of the subarray. Returns: int: The number of distinct strictly increasing subarrays of length k. >>> count_increasing_subarrays([5, 4, 3, 2, 1], 3) 0 >>> count_increasing_subarrays([1, 2, 3], 3) 1 >>> count_increasing_subarrays([1, 2, 3, 4], 2) 3 >>> count_increasing_subarrays([1, 3, 2, 4], 2) 2 >>> count_increasing_subarrays([1, 2, 3], 4) 0 >>> count_increasing_subarrays([1, 2, 3], -1) 0 >>> count_increasing_subarrays([1, 2, 3], 0) 0 >>> count_increasing_subarrays([], 2) 0 >>> count_increasing_subarrays([1, 2, 1, 2, 3], 2) 2 >>> count_increasing_subarrays([1, 2, 3, 4, 1, 2, 3, 4], 4) 1","solution":"def count_increasing_subarrays(arr, k): Returns the number of distinct subarrays of length k that have all elements in strictly increasing order. Args: arr (list of int): The input array of integers. k (int): The length of the subarray. Returns: int: The number of distinct strictly increasing subarrays of length k. if k > len(arr) or k <= 0: return 0 distinct_subarrays = set() for i in range(len(arr) - k + 1): subarray = arr[i:i+k] if all(subarray[j] < subarray[j+1] for j in range(k-1)): distinct_subarrays.add(tuple(subarray)) return len(distinct_subarrays)"},{"question":"def circular_subarray_sum(arr: List[int], k: int) -> bool: Determines if there exists a subarray in the circular array whose sum is exactly k. Args: arr (List[int]): The input array of integers. k (int): The target sum. Returns: bool: True if there is a subarray in the circular array whose sum is k, otherwise False. >>> circular_subarray_sum([1, 2, 3, 4, 5], 12) True >>> circular_subarray_sum([1, 2, 3, 4, 5], 20) False >>> circular_subarray_sum([5], 5) True >>> circular_subarray_sum([5], 3) False >>> circular_subarray_sum([2, -1, 2, -3, 4], 3) True >>> circular_subarray_sum([3, 1, -4, 1, 1], 3) True >>> circular_subarray_sum([1, 2, -3, 4], 0) True # Implement your code here.","solution":"def circular_subarray_sum(arr, k): Determines if there exists a subarray in the circular array whose sum is exactly k. n = len(arr) # Create the extended array extended_arr = arr + arr for start in range(n): current_sum = 0 for end in range(start, start + n): current_sum += extended_arr[end] if current_sum == k: return True return False"},{"question":"import heapq from typing import List def lastStoneWeight(stones: List[int]) -> int: Return the weight of the last remaining stone or 0 if no stones are left. >>> lastStoneWeight([2, 7, 4, 1, 8, 1]) 1 >>> lastStoneWeight([]) 0 >>> lastStoneWeight([5]) 5 >>> lastStoneWeight([3, 3, 3, 3]) 0 >>> lastStoneWeight([1, 3]) 2 >>> lastStoneWeight([10, 4, 2, 10]) 2 def test_example(): assert lastStoneWeight([2, 7, 4, 1, 8, 1]) == 1 def test_no_stones(): assert lastStoneWeight([]) == 0 def test_one_stone(): assert lastStoneWeight([5]) == 5 def test_all_stones_of_same_weight(): assert lastStoneWeight([3, 3, 3, 3]) == 0 def test_two_stones_of_different_weights(): assert lastStoneWeight([1, 3]) == 2 def test_multiple_stones(): assert lastStoneWeight([10, 4, 2, 10]) == 2","solution":"import heapq def lastStoneWeight(stones): Returns the weight of the last remaining stone, or 0 if there are no stones left. # Create a max-heap by pushing negative values of the stones max_heap = [-stone for stone in stones] heapq.heapify(max_heap) while len(max_heap) > 1: first = heapq.heappop(max_heap) # Largest stone second = heapq.heappop(max_heap) # Second largest stone if first != second: # If they are not equal, push the difference back into the heap heapq.heappush(max_heap, first - second) # If there are no stones left, return 0, otherwise return the weight of the last remaining stone return -max_heap[0] if max_heap else 0"},{"question":"def find_missing_and_duplicate(arr: List[int]) -> Tuple[int, int]: Return the missing integer and the duplicated integer as a tuple. >>> find_missing_and_duplicate([1, 2, 2, 4, 5]) (3, 2) >>> find_missing_and_duplicate([4, 1, 3, 3, 5]) (2, 3) >>> find_missing_and_duplicate([1, 2, 4, 4, 5]) (3, 4) >>> find_missing_and_duplicate([1, 2, 3, 4, 4]) (5, 4) >>> find_missing_and_duplicate([2, 2, 3, 4, 5]) (1, 2) >>> find_missing_and_duplicate([5, 2, 3, 4, 3]) (1, 3)","solution":"def find_missing_and_duplicate(arr): Returns the missing integer and the duplicated integer as a tuple. :param arr: list of integers :return: tuple (missing, duplicate) n = len(arr) total_sum = n * (n + 1) // 2 sum_of_arr = sum(arr) sum_of_squares = sum(x*x for x in arr) expected_sum_of_squares = sum(x*x for x in range(1, n + 1)) diff = total_sum - sum_of_arr # missing - duplicate square_diff = expected_sum_of_squares - sum_of_squares # missing^2 - duplicate^2 # missing + duplicate = square_diff / diff sum_of_numbers = square_diff // diff missing = (diff + sum_of_numbers) // 2 duplicate = sum_of_numbers - missing return (missing, duplicate)"},{"question":"def count_distinct_substrings(s: str) -> int: Returns the number of distinct substrings (not subsequences) of the input string s. >>> count_distinct_substrings(\\"a\\") == 1 >>> count_distinct_substrings(\\"ab\\") == 3 >>> count_distinct_substrings(\\"aa\\") == 2 >>> count_distinct_substrings(\\"abab\\") == 7 >>> count_distinct_substrings(\\"abcde\\") == 15 pass def test_single_character(): assert count_distinct_substrings(\\"a\\") == 1 def test_two_distinct_characters(): assert count_distinct_substrings(\\"ab\\") == 3 # \\"a\\", \\"b\\", \\"ab\\" def test_repeat_characters(): assert count_distinct_substrings(\\"aa\\") == 2 # \\"a\\", \\"aa\\" def test_mixed_characters(): assert count_distinct_substrings(\\"abab\\") == 7 # \\"a\\", \\"b\\", \\"ab\\", \\"ba\\", \\"aba\\", \\"bab\\", \\"abab\\" def test_long_string(): assert count_distinct_substrings(\\"abcde\\") == 15 # 1+2+3+4+5 = 15","solution":"def count_distinct_substrings(s): Returns the number of distinct substrings of the input string s. substrings = set() n = len(s) for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings)"},{"question":"def longest_unique_path(grid, k, n): Find the length of the longest path such that no letter repeats in any path. The path may start and end at any cell, and each step must be to an adjacent cell (including diagonals). n: integer denoting the size of the grid (k x k). k: integer representing the dimensions of the given grid. >>> longest_unique_path([['a']], 1, 1) 1 >>> longest_unique_path([['a', 'b'], ['c', 'd']], 2, 2) 4 >>> longest_unique_path([['a', 'a'], ['a', 'a']], 2, 2) 1 >>> longest_unique_path([ ['a', 'b', 'c'], ['h', 'g', 'd'], ['i', 'f', 'e'] ], 3, 3) 9 >>> longest_unique_path([ ['a', 'a', 'a'], ['a', 'z', 'a'], ['a', 'a', 'a'] ], 3, 3) 2","solution":"def longest_unique_path(grid, k, n): def is_valid(x, y): return 0 <= x < k and 0 <= y < k def dfs(x, y, visited): max_path_length = 0 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]: nx, ny = x + dx, y + dy if is_valid(nx, ny) and grid[nx][ny] not in visited: visited.add(grid[nx][ny]) max_path_length = max(max_path_length, dfs(nx, ny, visited) + 1) visited.remove(grid[nx][ny]) return max_path_length max_length = 0 for i in range(k): for j in range(k): max_length = max(max_length, dfs(i, j, set([grid[i][j]])) + 1) return max_length"},{"question":"def smallest_universal_string_length(words: List[str]) -> int: Returns the length of the smallest universal string \`s\` that can be formed from the given \`words\` array. A string \`s\` is formed by concatenating a subsequence of the \`words\` array. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. A string \`s\` is said to be universal if for every word in the \`words\` array, at least one of the characters of the word appears in \`s\`. Parameters: words (List[str]): A collection of strings. Returns: int: Length of the smallest universal string, or -1 if no universal string can be formed. Examples: >>> smallest_universal_string_length([\\"abc\\"]) 3 >>> smallest_universal_string_length([\\"abc\\", \\"def\\", \\"ghi\\"]) 9 >>> smallest_universal_string_length([\\"ab\\", \\"bc\\", \\"ca\\"]) 3 >>> smallest_universal_string_length([]) -1 >>> smallest_universal_string_length([\\"aaa\\", \\"aaa\\", \\"aaa\\"]) 1","solution":"def smallest_universal_string_length(words): Returns the length of the smallest universal string \`s\` that can be formed from the given \`words\` array. if not words: return -1 # Consider the set of characters from all words. char_set = set() for word in words: char_set = char_set.union(set(word)) # Length of the universal string will be equal to the number of distinct characters return len(char_set)"},{"question":"class TreeNode: def __init__(self, x, children=None): self.val = x self.children = children if children is not None else [] def prune_tree(node): Prunes the tree such that subtrees that are all zeroes are removed. >>> btree_to_list(prune_tree(TreeNode(1, [TreeNode(0), TreeNode(1)]))) [1, [1]] >>> prune_tree(TreeNode(0)) is None","solution":"class TreeNode: def __init__(self, x, children=None): self.val = x self.children = children if children is not None else [] def prune_tree(node): Prunes the tree such that subtrees that are all zeroes are removed. if node is None: return None # Prune children first pruned_children = [] for child in node.children: pruned_child = prune_tree(child) if pruned_child is not None: pruned_children.append(pruned_child) node.children = pruned_children # Determine if current node should be pruned if node.val == 0 and not node.children: return None return node"},{"question":"def can_partition_into_equal_subarrays(arr, length): Determine if it's possible to partition the array into \`length\` contiguous subarrays such that each subarray has an equal sum. >>> can_partition_into_equal_subarrays([1, 2, 3, 0, 3], 3) == True >>> can_partition_into_equal_subarrays([1, 1, 1, 1], 2) == True >>> can_partition_into_equal_subarrays([4, 4, 4], 1) == True >>> can_partition_into_equal_subarrays([1, 2, 3, 4, 5], 4) == False >>> can_partition_into_equal_subarrays([1, 1, 1], 2) == False >>> can_partition_into_equal_subarrays([1, 2, 3], 5) == False >>> can_partition_into_equal_subarrays([1], 1) == True >>> can_partition_into_equal_subarrays([], 1) == False >>> can_partition_into_equal_subarrays([1] * 1000000, 1) == True >>> can_partition_into_equal_subarrays([2] * 1000000, 1000000) == True","solution":"def can_partition_into_equal_subarrays(arr, length): Determine if it's possible to partition the array into \`length\` contiguous subarrays such that each subarray has an equal sum. total_sum = sum(arr) # If total_sum is not divisible by length, we can't partition the array if total_sum % length != 0: return False target_sum = total_sum // length current_sum = 0 count_subarrays = 0 for num in arr: current_sum += num if current_sum == target_sum: count_subarrays += 1 current_sum = 0 # Check if we have found exactly 'length' subarrays return count_subarrays == length"},{"question":"class MinStack: Implement a stack that supports the following operations in constant time O(1): * push(int x) -- Push element x onto the stack. * pop() -- Removes the element on top of the stack. * top() -- Get the top element of the stack. * getMin() -- Retrieve the minimum element in the stack. Example: >>> minStack = MinStack() >>> minStack.push(-2) >>> minStack.push(0) >>> minStack.push(-3) >>> minStack.getMin() # Returns -3 -3 >>> minStack.pop() >>> minStack.top() # Returns 0 0 >>> minStack.getMin() # Returns -2 -2 def __init__(self): Initialize your data structure here. pass def push(self, x: int) -> None: Push element x onto stack. pass def pop(self) -> None: Removes the element on top of the stack. pass def top(self) -> int: Get the top element. pass def getMin(self) -> int: Retrieve the minimum element in the stack. pass","solution":"class MinStack: def __init__(self): Initialize your data structure here. self.stack = [] self.min_stack = [] def push(self, x: int) -> None: Push element x onto stack. self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: Removes the element on top of the stack. if self.stack: top = self.stack.pop() if top == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: Get the top element. if self.stack: return self.stack[-1] def getMin(self) -> int: Retrieve the minimum element in the stack. if self.min_stack: return self.min_stack[-1]"},{"question":"def max_requests(requests: List[List[int]]) -> int: Determines the maximum number of non-overlapping requests that can be processed by a single server. Args: requests (List[List[int]]): A list of requests where each request is represented as [start, end]. Returns: int: The maximum number of non-overlapping requests that can be handled. pass # Unit Tests def test_max_requests_no_overlap(): # No overlapping requests requests = [[1, 3], [4, 6], [7, 10]] assert max_requests(requests) == 3 def test_max_requests_partial_overlap(): # Some requests overlap partially requests = [[1, 3], [2, 4], [4, 6]] assert max_requests(requests) == 2 def test_max_requests_completely_overlapping(): # All requests overlap requests = [[1, 3], [1, 3], [1, 3]] assert max_requests(requests) == 1 def test_max_requests_varied_lengths(): # Requests of varied lengths, some overlap requests = [[1, 2], [1, 3], [3, 4], [2, 5]] assert max_requests(requests) == 2 def test_max_requests_single_request(): # Only one request requests = [[1, 2]] assert max_requests(requests) == 1 def test_max_requests_multiple_requests(): # Multiple requests, some overlapping, optimal solution needed requests = [[1, 2], [3, 4], [0, 6], [5, 7], [8, 9], [5, 9]] assert max_requests(requests) == 4","solution":"def max_requests(requests): Determines the maximum number of non-overlapping requests that can be processed by a single server. Args: requests (List[List[int]]): A list of requests where each request is represented as [start, end]. Returns: int: The maximum number of non-overlapping requests that can be handled. # Sort the requests by their end time requests.sort(key=lambda x: x[1]) # Initialize variables to keep track of the number of processed requests and the end time of the last processed request processed_requests = 0 last_end_time = -1 # Iterate through the sorted requests for start, end in requests: # If the start time of the current request is greater than the end time of the last processed request if start > last_end_time: # Process this request processed_requests += 1 # Update the end time of the last processed request last_end_time = end return processed_requests"},{"question":"def num_matching_subseq(s: str, words: List[str]) -> int: Determine how many strings in \`words\` are subsequences of \`s\`. >>> num_matching_subseq(\\"abcdef\\", [\\"gh\\", \\"xyz\\"]) == 0 >>> num_matching_subseq(\\"abcdef\\", [\\"a\\", \\"ace\\", \\"bd\\", \\"z\\"]) == 3 >>> num_matching_subseq(\\"abcdef\\", [\\"a\\", \\"bcd\\", \\"abcdef\\", \\"ace\\"]) == 4 >>> num_matching_subseq(\\"\\", [\\"a\\", \\"b\\"]) == 0 >>> num_matching_subseq(\\"abcdef\\", []) == 0 >>> num_matching_subseq(\\"\\", []) == 0 >>> num_matching_subseq(\\"aaaaa\\", [\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\", \\"aaaaa\\", \\"b\\"]) == 5","solution":"def num_matching_subseq(s, words): Returns the number of words that are subsequences of the string \`s\`. def is_subsequence(x, y): it = iter(y) return all(c in it for c in x) count = 0 for word in words: if is_subsequence(word, s): count += 1 return count"},{"question":"def max_value_with_one_swap(arr: List[int]) -> int: Return the maximum possible value of the sequence you can achieve using at most one swap operation. The sequence is evaluated as the concatenation of its elements to form a single number. >>> max_value_with_one_swap([3, 2, 1]) 321 >>> max_value_with_one_swap([1, 9]) 91 >>> max_value_with_one_swap([1, 2, 3, 4]) 4231 >>> max_value_with_one_swap([5, 6, 1, 9]) 9615 >>> max_value_with_one_swap([2, 2, 2]) 222 >>> max_value_with_one_swap([21, 34, 56]) 563421 >>> max_value_with_one_swap([9, 8, 7]) 987","solution":"def max_value_with_one_swap(arr): Returns the maximum possible value of the sequence by performing at most one swap operation. The sequence is evaluated as the concatenation of its elements to form a single number. n = len(arr) # Convert array elements to strings for easier concatenation arr_str = [str(x) for x in arr] # Early return if array length is less than 2 if n < 2: return int(''.join(arr_str)) best_arr = arr_str.copy() max_num = int(''.join(arr_str)) for i in range(n): for j in range(i + 1, n): # Swap elements at indices i and j arr_str[i], arr_str[j] = arr_str[j], arr_str[i] current_num = int(''.join(arr_str)) if current_num > max_num: max_num = current_num best_arr = arr_str.copy() # Swap them back to try next pair arr_str[i], arr_str[j] = arr_str[j], arr_str[i] return max_num"},{"question":"from typing import List from collections import Counter import heapq def top_k_frequent(nums: List[int], k: int) -> List[int]: Retrieves the k most frequent elements from the list nums. Args: nums (List[int]): List of integers. k (int): Number of top frequent elements to return. Returns: List[int]: List of k most frequent elements. >>> top_k_frequent([1,1,1,2,2,3], 2) [1, 2] >>> top_k_frequent([1], 1) [1] >>> top_k_frequent([], 2) [] >>> top_k_frequent([1,1,1,2,2,3], 3) [1, 2, 3] >>> top_k_frequent([1,1,1,2,2,3], 0) [] >>> top_k_frequent([1,1,1,2,2,3], -1) [] >>> top_k_frequent([1,1,2,2,3,3], 2) [1, 2, 3][:2]","solution":"from typing import List import heapq from collections import Counter def top_k_frequent(nums: List[int], k: int) -> List[int]: Retrieves the k most frequent elements from the list nums. Args: nums (List[int]): List of integers. k (int): Number of top frequent elements to return. Returns: List[int]: List of k most frequent elements. if not nums or k <= 0: return [] # Count frequencies of each element in nums frequency = Counter(nums) # Use a heap to find the k most frequent elements heap = heapq.nlargest(k, frequency.keys(), key=frequency.get) return heap"},{"question":"def sunset_views(heights: List[int]) -> List[bool]: Determine whether each skyscraper has a sunset view. Parameters: heights (list): A 0-indexed list of integers representing skyscraper heights. Returns: list: A list of booleans indicating whether each skyscraper has a sunset view. >>> sunset_views([3, 3, 3, 3, 3]) == [False, False, False, False, True] >>> sunset_views([1, 2, 3, 4, 5]) == [False, False, False, False, True] >>> sunset_views([5, 4, 3, 2, 1]) == [True, True, True, True, True] >>> sunset_views([4, 3, 2, 5, 3, 8, 4]) == [False, False, False, False, False, True, True] >>> sunset_views([10]) == [True] >>> sunset_views([3, 5, 2, 4, 1]) == [False, True, False, True, True] >>> sunset_views([]) == []","solution":"def sunset_views(heights): Determine whether each skyscraper has a sunset view. Parameters: heights (list): A 0-indexed list of integers representing skyscraper heights. Returns: list: A list of booleans indicating whether each skyscraper has a sunset view. n = len(heights) result = [False] * n max_height = float('-inf') for i in range(n-1, -1, -1): if heights[i] > max_height: result[i] = True max_height = heights[i] return result"},{"question":"from typing import List, Tuple class EmployeePayroll: A company's payroll system stores information about employees in an array of records, where each record is a tuple (employeeId, salary). The company wants to understand the salaries of its employees better and perform certain operations on this data. Args: records (Tuple[int, int][]): array of employee records. Methods: getTotalPayroll() -> int: Returns the total sum of all salaries in the payroll. getAverageSalary() -> float: Returns the average salary of all employees rounded to two decimal places. getHighestSalary() -> Tuple[int, int]: Returns the record of the employee with the highest salary. >>> payroll = EmployeePayroll([(1, 5000), (2, 6000), (3, 7000)]) >>> payroll.getTotalPayroll() 18000 >>> payroll.getAverageSalary() 6000.00 >>> payroll.getHighestSalary() (3, 7000) def __init__(self, records: List[Tuple[int, int]]): pass def getTotalPayroll(self) -> int: pass def getAverageSalary(self) -> float: pass def getHighestSalary(self) -> Tuple[int, int]: pass","solution":"from typing import List, Tuple class EmployeePayroll: def __init__(self, records: List[Tuple[int, int]]): self.records = records def getTotalPayroll(self) -> int: return sum(salary for _, salary in self.records) def getAverageSalary(self) -> float: total_salary = self.getTotalPayroll() return round(total_salary / len(self.records), 2) def getHighestSalary(self) -> Tuple[int, int]: return max(self.records, key=lambda record: record[1])"},{"question":"def concatenate_strings(word1: str, word2: str) -> str: Concatenates two strings word1 and word2 in such a way that the resulting string contains both as substrings and the length is minimized. >>> concatenate_strings(\\"abc\\", \\"def\\") \\"abcdef\\" >>> concatenate_strings(\\"abc\\", \\"cde\\") \\"abcde\\" >>> concatenate_strings(\\"abc\\", \\"abc\\") \\"abc\\" >>> concatenate_strings(\\"abcdef\\", \\"defghi\\") \\"abcdefghi\\" >>> concatenate_strings(\\"hello\\", \\"world\\") \\"helloworld\\" >>> concatenate_strings(\\"aaa\\", \\"aaa\\") \\"aaa\\"","solution":"def concatenate_strings(word1, word2): Concatenates two strings word1 and word2 in such a way that the resulting string contains both as substrings and the length is minimized. def find_overlap(w1, w2): max_overlap = 0 for i in range(1, min(len(w1), len(w2)) + 1): if w1[-i:] == w2[:i]: max_overlap = i return max_overlap overlap1 = find_overlap(word1, word2) overlap2 = find_overlap(word2, word1) result1 = word1 + word2[overlap1:] result2 = word2 + word1[overlap2:] return min(result1, result2, key=len)"},{"question":"def min_operations_to_perfect(s: str) -> int: Returns the minimum number of operations required to make the string \\"perfect\\". A \\"perfect\\" string is defined as a string in which no two adjacent characters are the same. >>> min_operations_to_perfect(\\"abc\\") == 0 >>> min_operations_to_perfect(\\"a\\") == 0 >>> min_operations_to_perfect(\\"aaa\\") == 2 >>> min_operations_to_perfect(\\"bbbbb\\") == 4 >>> min_operations_to_perfect(\\"aabbcc\\") == 3 >>> min_operations_to_perfect(\\"aaabbbccc\\") == 6 >>> min_operations_to_perfect(\\"ababab\\") == 0 >>> min_operations_to_perfect(\\"cacacaca\\") == 0 >>> min_operations_to_perfect(\\"\\") == 0 >>> min_operations_to_perfect(\\"a\\") == 0 >>> min_operations_to_perfect(\\"b\\") == 0","solution":"def min_operations_to_perfect(s): Returns the minimum number of operations required to make the string \\"perfect\\". A \\"perfect\\" string is defined as a string in which no two adjacent characters are the same. if not s: return 0 # Count the number of adjacent repeated characters operations = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: operations += 1 return operations"},{"question":"def count_repeated_substrings(s: str, n: int) -> int: Returns the count of distinct substrings of length n that appear more than once in the string s. >>> count_repeated_substrings(\\"abcdef\\", 2) 0 >>> count_repeated_substrings(\\"aaaa\\", 2) 1 >>> count_repeated_substrings(\\"ababab\\", 2) 2 >>> count_repeated_substrings(\\"aaaaa\\", 5) 0 >>> count_repeated_substrings(\\"abc\\", 4) 0 >>> count_repeated_substrings(\\"xyz\\", 2) 0 >>> count_repeated_substrings(\\"abcabcabc\\", 3) 3","solution":"def count_repeated_substrings(s, n): Returns the count of distinct substrings of length n that appear more than once in the string s. if n > len(s): return 0 substring_count = {} for i in range(len(s) - n + 1): substring = s[i:i+n] if substring in substring_count: substring_count[substring] += 1 else: substring_count[substring] = 1 repeated_substrings_count = 0 for count in substring_count.values(): if count > 1: repeated_substrings_count += 1 return repeated_substrings_count"},{"question":"from typing import List def numDistinctRegions(grid: List[List[str]]) -> int: Return the number of distinct regions in the grid. A region is a connected component of cells that share the same character. Args: grid (List[List[str]]): A 2D grid of characters representing the landscape. Returns: int: Number of distinct regions. Examples: >>> grid = [['L', 'L', 'L'], ['L', 'L', 'L'], ['L', 'L', 'L']] >>> numDistinctRegions(grid) 1 >>> grid = [['W', 'W', 'W'], ['W', 'W', 'W'], ['W', 'W', 'W']] >>> numDistinctRegions(grid) 1 >>> grid = [['L', 'W', 'L'], ['W', 'L', 'W'], ['L', 'W', 'L']] >>> numDistinctRegions(grid) 9 >>> grid = [['L', 'W', 'L']] >>> numDistinctRegions(grid) 3 >>> grid = [['L'], ['W'], ['L']] >>> numDistinctRegions(grid) 3 >>> grid = [['L', 'W', 'W', 'L'], ['L', 'L', 'W', 'L'], ['W', 'L', 'L', 'W'], ['W', 'W', 'L', 'W']] >>> numDistinctRegions(grid) 5 >>> grid = [] >>> numDistinctRegions(grid) 0 >>> grid = [['L']] >>> numDistinctRegions(grid) 1 >>> grid = [['W']] >>> numDistinctRegions(grid) 1 >>> grid = [['F']] >>> numDistinctRegions(grid) 1","solution":"def numDistinctRegions(grid): if not grid: return 0 m, n = len(grid), len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] def dfs(x, y, char): stack = [(x, y)] while stack: cx, cy = stack.pop() if 0 <= cx < m and 0 <= cy < n and grid[cx][cy] == char: grid[cx][cy] = '#' for dx, dy in directions: stack.append((cx+dx, cy+dy)) regions = 0 for i in range(m): for j in range(n): if grid[i][j] != '#': regions += 1 dfs(i, j, grid[i][j]) return regions"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Given a list of integers \`nums\` and an integer \`target\`, return any two distinct indices \`(i, j)\` in the list such that \`nums[i] + nums[j] == target\`. If such indices do not exist, return an empty list. Args: nums (List[int]): List of integers. target (int): Target sum. Returns: List[int]: A list containing two distinct indices. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([1, 2, 3, 4], 8) [] >>> two_sum([3, 2, 3], 6) [0, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([], 5) [] >>> two_sum([1], 1) []","solution":"def two_sum(nums, target): Returns indices of the two numbers that add up to the target. If no such pair exists, returns an empty list. Args: nums (list of int): List of integers. target (int): Target sum. Returns: list of int: a list containing two distinct indices. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"def min_moves_to_equal_elements(arr, d): Returns the minimum number of moves to make all elements in the list 'arr' equal, with the constraint that the difference between any two elements does not exceed 'd'. If it is not possible, returns -1. >>> min_moves_to_equal_elements([1, 2, 3], 5) 2 >>> min_moves_to_equal_elements([1, 10, 20], 5) -1 >>> min_moves_to_equal_elements([], 5) 0 >>> min_moves_to_equal_elements([5], 5) 0 >>> min_moves_to_equal_elements([7, 7, 7], 5) 0 >>> min_moves_to_equal_elements([1, 9, 8], 10) 8","solution":"def min_moves_to_equal_elements(arr, d): Returns the minimum number of moves to make all elements in the list 'arr' equal, with the constraint that the difference between any two elements does not exceed 'd'. If it is not possible, returns -1. if not arr: return 0 # Check if the difference between any two elements exceeds d if max(arr) - min(arr) > d: return -1 median = sorted(arr)[len(arr) // 2] moves = sum(abs(x - median) for x in arr) return moves"},{"question":"def min_steps(nums: List[int], k: int) -> int: Returns the minimum number of moves or jumps required to reach the top of the ladder. Parameters: nums (List[int]): List of integers representing steps on a ladder. k (int): Maximum units one can jump. Returns: int: Minimum number of moves or jumps required to reach the top. >>> min_steps([0], 1) == 0 >>> min_steps([0, 1, 2, 3], 2) == 2 >>> min_steps([0, 1, 2], 1) == 2 >>> min_steps([0, 1, 2, 3, 4], 4) == 1 >>> min_steps([], 3) == 0 >>> min_steps([0, 1, 2, 3, 4, 5], 0) == float('inf')","solution":"def min_steps(nums, k): Returns the minimum number of moves or jumps required to reach the top of the ladder. Parameters: nums (List[int]): List of integers representing steps on a ladder. k (int): Maximum units one can jump. Returns: int: Minimum number of moves or jumps required to reach the top. n = len(nums) if n == 0: return 0 # Initialize a list to store the minimum steps needed to reach each step. min_steps_to_reach = [float('inf')] * n min_steps_to_reach[0] = 0 # Starting point needs 0 steps for i in range(1, n): for j in range(1, k + 1): if i - j >= 0: min_steps_to_reach[i] = min(min_steps_to_reach[i], min_steps_to_reach[i - j] + 1) return min_steps_to_reach[-1]"},{"question":"def reorganize_string(s: str) -> str: Rearranges the string s such that no two adjacent characters are the same. If not possible, returns an empty string. >>> reorganize_string(\\"aab\\") 'aba' >>> reorganize_string(\\"aaab\\") '' >>> reorganize_string(\\"a\\") 'a' >>> reorganize_string(\\"aa\\") '' >>> reorganize_string(\\"aaabbc\\") 'ababac' >>> reorganize_string(\\"aabb\\") 'abab'","solution":"import heapq from collections import Counter def reorganize_string(s): Rearranges the string s such that no two adjacent characters are the same. If not possible, returns an empty string. # Create a counter for the characters counter = Counter(s) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) prev_freq, prev_char = 0, '' result = [] while max_heap: freq, char = heapq.heappop(max_heap) # Append the current character to the result result.append(char) # If prev_freq is less than 0, push it back to the heap if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Update the previous character and frequency for the next iteration prev_freq, prev_char = freq + 1, char result_str = ''.join(result) if len(result_str) != len(s): return \\"\\" return result_str"},{"question":"def search_matrix(matrix, target): Given a target integer, return true if target is in matrix, or false otherwise. Args: matrix: List[List[int]] target : int Returns: bool pass # Example usage: # >>> search_matrix([[1, 3, 5, 7],[10, 11, 16, 20],[23, 30, 34, 60]], 3) # True # >>> search_matrix([[1, 3, 5, 7],[10, 11, 16, 20],[23, 30, 34, 60]], 16) # True # >>> search_matrix([[1, 3, 5, 7],[10, 11, 16, 20],[23, 30, 34, 60]], 50) # False","solution":"def search_matrix(matrix, target): Given a target integer, return true if target is in matrix, or false otherwise. Args: matrix: List[List[int]] target : int Returns: bool if not matrix or not matrix[0]: return False m, n = len(matrix), len(matrix[0]) # Start with an imaginary row array constructed by combining all rows left, right = 0, m * n - 1 while left <= right: mid = (left + right) // 2 mid_value = matrix[mid // n][mid % n] if mid_value == target: return True elif mid_value < target: left = mid + 1 else: right = mid - 1 return False"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups anagrams together from the given list of words. Parameters: words (list of str): A list containing words consisting of lowercase English letters. Returns: list of lists: A list of lists, where each sublist contains all anagrams from the input list, sorted in lexicographical order. The entire list is sorted based on the first word of each sublist. Example: >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\\"ate\\", \\"eat\\", \\"tea\\"], [\\"bat\\"], [\\"nat\\", \\"tan\\"]] >>> group_anagrams([\\"abc\\", \\"bca\\", \\"cat\\", \\"act\\", \\"god\\", \\"dog\\"]) [[\\"abc\\", \\"bca\\"], [\\"act\\", \\"cat\\"], [\\"dog\\", \\"god\\"]] >>> group_anagrams([\\"word\\"]) [[\\"word\\"]] >>> group_anagrams([]) []","solution":"from collections import defaultdict def group_anagrams(words): Groups anagrams together from the given list of words. Parameters: words (list of str): A list containing words consisting of lowercase English letters. Returns: list of lists: A list of lists, where each sublist contains all anagrams from the input list, sorted in lexicographical order. The entire list is sorted based on the first word of each sublist. anagrams = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) result = [sorted(group) for group in anagrams.values()] result.sort(key=lambda x: x[0]) return result"},{"question":"def min_subarray_len(nums, x): Given an integer array \`nums\` and an integer \`x\`, finds the length of the smallest subarray whose sum equals \`x\`. If no such subarray exists, returns \`-1\`. Args: nums (List[int]): The list of integers. x (int): The target sum. Returns: int: The length of the smallest subarray with sum equal to \`x\`, or -1 if no such subarray exists. Examples: >>> min_subarray_len([1, 2, 3, 4, 2, 1, 3], 7) 2 >>> min_subarray_len([1, 2, 3, 4, 5], 9) 2 >>> min_subarray_len([1, 2, 3], 7) -1 >>> min_subarray_len([1, 3, 5, 7], 100) -1 >>> min_subarray_len([7], 7) 1 >>> min_subarray_len([5], 7) -1 >>> min_subarray_len([], 7) -1 >>> min_subarray_len([10**6, 10**6, 10**6], 10**6) 1 >>> min_subarray_len([1, 2, 3, 4, 5, 6], 11) 2 >>> min_subarray_len([1, 1, 1, 1, 1, 1], 2) 2 >>> min_subarray_len([5, 1, 2, 3, 6, 7], 5) 1 >>> min_subarray_len([2, 3, 1, 4, 1, 2], 5) 2","solution":"def min_subarray_len(nums, x): Returns the length of the smallest subarray whose sum equals x. If no such subarray exists, return -1. n = len(nums) if n == 0: return -1 left, sum = 0, 0 min_length = float('inf') for right in range(n): sum += nums[right] while sum >= x: if sum == x: min_length = min(min_length, right - left + 1) sum -= nums[left] left += 1 return min_length if min_length != float('inf') else -1"},{"question":"def largestRectangleArea(grid): Given a 2D grid of lowercase English letters, this function finds the largest rectangle that contains only one distinct letter and returns its area. pass # Test cases to validate the solution def test_single_character_grid(): grid = [['a', 'a'], ['a', 'a']] assert largestRectangleArea(grid) == 4 def test_mixed_characters_grid(): grid = [['a', 'a', 'b'], ['a', 'b', 'b'], ['c', 'c', 'c']] assert largestRectangleArea(grid) == 3 def test_large_mixed_characters_grid(): grid = [ ['a', 'a', 'a', 'b', 'b'], ['a', 'a', 'a', 'b', 'c'], ['a', 'a', 'a', 'b', 'c'], ['a', 'a', 'a', 'b', 'b'], ['a', 'a', 'a', 'b', 'b'], ] assert largestRectangleArea(grid) == 15 def test_no_larger_than_1_area(): grid = [['a', 'b'], ['c', 'd']] assert largestRectangleArea(grid) == 1 def test_empty_grid(): grid = [] assert largestRectangleArea(grid) == 0 def test_one_row_grid(): grid = [['a', 'a', 'b', 'b', 'b']] assert largestRectangleArea(grid) == 3 def test_one_column_grid(): grid = [['a'], ['a'], ['b'], ['b'], ['b']] assert largestRectangleArea(grid) == 3","solution":"def largestRectangleArea(grid): Given a 2D grid of lowercase English letters, this function finds the largest rectangle that contains only one distinct letter and returns its area. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) max_area = 0 def largestRectangleInHistogram(heights): This helper function calculates the largest rectangle in a histogram represented by the heights array. stack = [] max_area = 0 heights.append(0) # Add a zero-height bar to force calculation of remaining areas in stack for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area for char in set(char for row in grid for char in row): heights = [0] * n for row in range(m): for col in range(n): if grid[row][col] == char: heights[col] += 1 else: heights[col] = 0 max_area = max(max_area, largestRectangleInHistogram(heights)) return max_area"},{"question":"def min_flips(arr: List[int]) -> int: Returns the minimum number of flips required to make all the light bulbs have the same state (all 0s or all 1s). >>> min_flips([0, 0, 0, 0]) 0 >>> min_flips([1, 1, 1, 1]) 0 >>> min_flips([0, 1, 0, 1]) 2 >>> min_flips([1, 0, 1, 0, 1]) 2 >>> min_flips([]) 0 >>> min_flips([0]) 0 >>> min_flips([1]) 0 >>> min_flips([0, 1] * 1000) 1000 >>> min_flips([1, 0] * 500) 500","solution":"def min_flips(arr): Returns the minimum number of flips required to make all the light bulbs have the same state (all 0s or all 1s). count_0 = arr.count(0) count_1 = len(arr) - count_0 # We can either turn all to 0s or all to 1s return min(count_0, count_1)"},{"question":"def min_sub_array_len(target: int, nums: List[int]) -> int: Finds the minimum length of a contiguous subarray of which the sum is greater than or equal to target. If there is no such subarray, return 0. Args: target (int): The target sum. nums (List[int]): The list of integers. Returns: int: The minimum length of a contiguous subarray with sum >= target. >>> min_sub_array_len(7, [2,3,1,2,4,3]) 2 >>> min_sub_array_len(100, [1, 2, 3, 4, 5]) 0 >>> min_sub_array_len(15, [1, 2, 3, 4, 5]) 5 >>> min_sub_array_len(11, [1, 4, 4, 2, 5, 3, 1, 2]) 3 >>> min_sub_array_len(4, [4, 4, 4, 4]) 1","solution":"def min_sub_array_len(target, nums): Finds the minimum length of a contiguous subarray of which the sum is greater than or equal to target. If there is no such subarray, return 0. n = len(nums) min_length = float('inf') left = 0 current_sum = 0 for right in range(n): current_sum += nums[right] while current_sum >= target: min_length = min(min_length, right - left + 1) current_sum -= nums[left] left += 1 return 0 if min_length == float('inf') else min_length"},{"question":"def largestRectangleArea(heights: List[int]) -> int: Returns the maximum area of a rectangle that can be formed by choosing consecutive buildings. This function aims to compute the result efficiently in O(n) time complexity. >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([2, 4]) 4 >>> largestRectangleArea([1, 1, 1, 1]) 4 >>> largestRectangleArea([6, 2, 5, 4, 5, 1, 6]) 12 >>> largestRectangleArea([1]) 1 >>> largestRectangleArea([]) 0 >>> largestRectangleArea([1, 2, 3, 4, 5]) 9 >>> largestRectangleArea([5, 4, 3, 2, 1]) 9","solution":"def largestRectangleArea(heights): Returns the maximum area of a rectangle that can be formed by choosing consecutive buildings. This function uses a stack to achieve the solution in O(n) time complexity. stack = [] # stack to keep indices of the heights array max_area = 0 # variable to store the maximum area index = 0 # current index in the heights array while index < len(heights): # If this building is higher than the building at stack top, push it to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top index top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest(height) area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area, if needed max_area = max(max_area, area) # Now pop the remaining buildings from stack and calculate area while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def searchBST(root: TreeNode, val: int) -> TreeNode: Searches for a node with value \`val\` in a binary search tree (BST) and returns the subtree rooted with that node. If such a node does not exist, returns \`None\`. def test_searchBST_node_exists(): root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(7) root.left.left = TreeNode(1) root.left.right = TreeNode(3) result = searchBST(root, 2) assert result == root.left assert result.val == 2 assert result.left.val == 1 assert result.right.val == 3 def test_searchBST_node_does_not_exist(): root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(7) root.left.left = TreeNode(1) root.left.right = TreeNode(3) result = searchBST(root, 5) assert result is None def test_searchBST_search_root(): root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(7) result = searchBST(root, 4) assert result == root assert result.val == 4 def test_searchBST_empty_tree(): result = searchBST(None, 1) assert result is None","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def searchBST(root, val): Searches for a node with value \`val\` in a binary search tree (BST) and returns the subtree rooted with that node. If such a node does not exist, returns \`None\`. while root is not None and root.val != val: if val < root.val: root = root.left else: root = root.right return root"},{"question":"from typing import List def findAllThreeSum(nums: List[int]) -> List[List[int]]: Given a list of integers, returns a list of all unique triplets such that their sum is zero. >>> findAllThreeSum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> findAllThreeSum([1, 2, -2, -1]) [] >>> findAllThreeSum([0, 0, 0, 0]) [[0, 0, 0]] >>> findAllThreeSum([]) [] >>> findAllThreeSum([1, 2, 3, 4, 5]) [] >>> findAllThreeSum([0, 0, 0, 1, 1, -1, -1, -1]) [[-1, 0, 1], [0, 0, 0]]","solution":"def findAllThreeSum(nums): Returns all unique triplets in the list which sum up to zero. nums.sort() result = [] n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue # Skip duplicates for i left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 # Skip duplicates for left while left < right and nums[right] == nums[right - 1]: right -= 1 # Skip duplicates for right left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return result"},{"question":"def longest_beautiful_segment(s: str) -> int: Returns the length of the longest beautiful segment in the string s. A beautiful segment contains each letter of the English alphabet at most once. >>> longest_beautiful_segment(\\"abcdef\\") 6 >>> longest_beautiful_segment(\\"abcabcbb\\") 3 >>> longest_beautiful_segment(\\"abcdefghijklmnopqrstuvwxyz\\") 26 >>> longest_beautiful_segment(\\"aaaaaaa\\") 1 >>> longest_beautiful_segment(\\"pwwkew\\") 3 >>> longest_beautiful_segment(\\"\\") 0","solution":"def longest_beautiful_segment(s): Returns the length of the longest beautiful segment in the string s. start = 0 max_len = 0 char_map = {} for end in range(len(s)): if s[end] in char_map: start = max(start, char_map[s[end]] + 1) char_map[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"def length_of_longest_arithmetic_subsequence(nums: List[int]) -> int: Given a list of integers \`nums\`, return the length of the longest subsequence that is both strictly increasing and its values form an arithmetic progression. An arithmetic progression is a sequence of numbers such that the difference of any two successive members is a constant. >>> length_of_longest_arithmetic_subsequence([3, 6, 9, 12]) 4 >>> length_of_longest_arithmetic_subsequence([9, 4, 7, 2, 10]) 3 from solution import length_of_longest_arithmetic_subsequence def test_example_cases(): assert length_of_longest_arithmetic_subsequence([3, 6, 9, 12]) == 4 # 3, 6, 9, 12 assert length_of_longest_arithmetic_subsequence([9, 4, 7, 2, 10]) == 3 # 4, 7, 10 def test_single_element(): assert length_of_longest_arithmetic_subsequence([1]) == 1 def test_no_arithmetic_subsequence(): assert length_of_longest_arithmetic_subsequence([1, 5, 10]) == 2 # 1, 5 or 5, 10 def test_arithmetic_subsequence_with_negatives(): assert length_of_longest_arithmetic_subsequence([-1, -5, -9, 1, -3, -7]) == 3 # -1, -5, -9 or -5, -9, -13 def test_large_numbers(): assert length_of_longest_arithmetic_subsequence([100, 200, 300, 1000, 2000]) == 3 # 100, 200, 300 def test_mixed_non_contiguous_sequence(): assert length_of_longest_arithmetic_subsequence([1, 2, 3, 5, 6, 7]) == 4 # 1, 2, 3, 4 def test_empty_list(): assert length_of_longest_arithmetic_subsequence([]) == 0","solution":"def length_of_longest_arithmetic_subsequence(nums): if not nums: return 0 # dp dictionary where dp[i][d] is the length of the longest arithmetic subsequence ending at index i with common difference d dp = {} max_length = 1 for i in range(len(nums)): for j in range(i): diff = nums[i] - nums[j] if (j, diff) in dp: dp[(i, diff)] = dp[(j, diff)] + 1 else: dp[(i, diff)] = 2 max_length = max(max_length, dp[(i, diff)]) return max_length"},{"question":"def count_occurrences(ar, x): Returns the number of occurrences of x in the sorted array ar. >>> count_occurrences([1, 2, 2, 2, 3, 4], 2) 3 >>> count_occurrences([1, 2, 3, 4, 5], 3) 1 >>> count_occurrences([1, 2, 3, 4, 5], 6) 0 >>> count_occurrences([], 1) 0 >>> count_occurrences([2, 2, 2, 2, 2], 2) 5 >>> count_occurrences([1, 2, 3, 4, 5, 5], 5) 2 >>> count_occurrences([1, 2, 3, 4, 5], 0) 0","solution":"def count_occurrences(ar, x): Returns the number of occurrences of x in the sorted array ar. def find_first_occurrence(ar, x): left, right = 0, len(ar) - 1 first_occurrence = -1 while left <= right: mid = (left + right) // 2 if ar[mid] == x: first_occurrence = mid right = mid - 1 elif ar[mid] < x: left = mid + 1 else: right = mid - 1 return first_occurrence def find_last_occurrence(ar, x): left, right = 0, len(ar) - 1 last_occurrence = -1 while left <= right: mid = (left + right) // 2 if ar[mid] == x: last_occurrence = mid left = mid + 1 elif ar[mid] < x: left = mid + 1 else: right = mid - 1 return last_occurrence first_occurrence = find_first_occurrence(ar, x) if first_occurrence == -1: return 0 last_occurrence = find_last_occurrence(ar, x) return last_occurrence - first_occurrence + 1"},{"question":"def longest_common_subsequence(s1: str, s2: str) -> str: Returns the longest common subsequence of two strings s1 and s2. If there is no common subsequence, returns an empty string. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") == \\"ace\\" >>> longest_common_subsequence(\\"abc\\", \\"abc\\") == \\"abc\\" >>> longest_common_subsequence(\\"abc\\", \\"def\\") == \\"\\" >>> longest_common_subsequence(\\"abcd\\", \\"abcd\\") == \\"abcd\\" >>> longest_common_subsequence(\\"abcdef\\", \\"acf\\") == \\"acf\\" >>> longest_common_subsequence(\\"axbycz\\", \\"abc\\") == \\"abc\\" >>> longest_common_subsequence(\\"abc\\", \\"xyz\\") == \\"\\" >>> longest_common_subsequence(\\"abcde\\", \\"fghij\\") == \\"\\" >>> longest_common_subsequence(\\"\\", \\"abc\\") == \\"\\" >>> longest_common_subsequence(\\"abc\\", \\"\\") == \\"\\" >>> longest_common_subsequence(\\"\\", \\"\\") == \\"\\" >>> longest_common_subsequence(\\"a\\" * 1000, \\"a\\" * 1000) == \\"a\\" * 1000","solution":"def longest_common_subsequence(s1, s2): Returns the longest common subsequence of two strings s1 and s2. If there is no common subsequence, returns an empty string. m, n = len(s1), len(s2) dp = [[\\"\\" for _ in range(n + 1)] for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + s1[i - 1] else: dp[i][j] = dp[i - 1][j] if len(dp[i - 1][j]) > len(dp[i][j - 1]) else dp[i][j - 1] return dp[m][n]"},{"question":"def max_profit(transactions: List[int]) -> int: Returns the maximum possible profit that can be achieved by summing up a non-empty subsequence of the transactions array. >>> max_profit([3, 5, 7, 2]) == 17 >>> max_profit([-3, -5, -7, -2]) == -2 >>> max_profit([3, -1, 2, -7, 5]) == 10 >>> max_profit([0, 0, 0, 0]) == 0 >>> max_profit([4]) == 4 >>> max_profit([-4]) == -4","solution":"def max_profit(transactions): Returns the maximum possible profit that can be achieved by summing up a non-empty subsequence of the transactions array. # Filter out the positive profits positive_profits = [t for t in transactions if t > 0] # If there are no positive profits, return the maximum single transaction if not positive_profits: return max(transactions) # Otherwise, return the sum of all positive profits return sum(positive_profits)"},{"question":"def count_pairs_with_sum(arr: List[int], target_sum: int) -> int: Counts the number of distinct pairs in the array that add up to the target sum. >>> count_pairs_with_sum([1, 2, 3, 4, 5], 10) 0 >>> count_pairs_with_sum([1, 9, 2, 3, 4], 10) 1 >>> count_pairs_with_sum([1, 2, 3, 4, 5, 6, 7, 8, 9], 10) 4 >>> count_pairs_with_sum([1, 2, 2, 3, 4, 4, 5], 6) 2 >>> count_pairs_with_sum([2, -3, 3, -2, 4, -4], 0) 3 >>> count_pairs_with_sum([], 0) 0 >>> count_pairs_with_sum([1, -1, 2, -2], 0) 2","solution":"def count_pairs_with_sum(arr, target_sum): Counts the number of distinct pairs in the array that add up to the target sum. Parameters: arr (list): List of integers target_sum (int): Target sum for the pairs Returns: int: Number of distinct pairs seen = set() pairs = set() for number in arr: complement = target_sum - number if complement in seen: pair = tuple(sorted((number, complement))) pairs.add(pair) seen.add(number) return len(pairs)"},{"question":"from typing import List def numConnectedComponents(words: List[str]) -> int: Return the number of distinct connected components in the array of words. Two words are connected if they can be formed by either swapping one character or by replacing one character with another character. Args: words (List[str]): A list of words. Returns: int: The number of distinct connected components. Examples: >>> numConnectedComponents([\\"cat\\", \\"bat\\", \\"rat\\", \\"drat\\", \\"dart\\", \\"tart\\"]) 2 >>> numConnectedComponents([\\"cat\\", \\"bat\\", \\"bet\\", \\"bot\\"]) 1 >>> numConnectedComponents([\\"aaa\\", \\"bbb\\", \\"ccc\\"]) 3 >>> numConnectedComponents([\\"solo\\"]) 1 >>> numConnectedComponents([\\"abc\\", \\"acb\\", \\"bac\\"]) 1 >>> numConnectedComponents([\\"abc\\", \\"abcd\\", \\"abx\\"]) 2","solution":"from collections import defaultdict def numConnectedComponents(words): def is_connected(word1, word2): if len(word1) != len(word2): return False diff_count = 0 diff_indices = [] for i in range(len(word1)): if word1[i] != word2[i]: diff_count += 1 diff_indices.append(i) if diff_count > 2: return False if diff_count == 1: return True # Replacement case if diff_count == 2: if word1[diff_indices[0]] == word2[diff_indices[1]] and word1[diff_indices[1]] == word2[diff_indices[0]]: return True # Swap case return False def dfs(word, visited, graph): visited.add(word) for neighbor in graph[word]: if neighbor not in visited: dfs(neighbor, visited, graph) graph = defaultdict(list) for i in range(len(words)): for j in range(i + 1, len(words)): if is_connected(words[i], words[j]): graph[words[i]].append(words[j]) graph[words[j]].append(words[i]) visited = set() components = 0 for word in words: if word not in visited: dfs(word, visited, graph) components += 1 return components"},{"question":"def min_deletions_to_make_palindrome(s: str) -> int: Returns the minimum number of deletions required to make the string \`s\` a palindrome. >>> min_deletions_to_make_palindrome(\\"racecar\\") 0 >>> min_deletions_to_make_palindrome(\\"a\\") 0 >>> min_deletions_to_make_palindrome(\\"ab\\") 1 >>> min_deletions_to_make_palindrome(\\"aebcbda\\") 2 >>> min_deletions_to_make_palindrome(\\"\\") 0 >>> min_deletions_to_make_palindrome(\\"abcda\\") 2 >>> min_deletions_to_make_palindrome(\\"aaaaaaaa\\") 0","solution":"def min_deletions_to_make_palindrome(s): Returns the minimum number of deletions required to make the string \`s\` a palindrome. def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * (n + 1) for _ in range(n + 1)] for i in range(n): for j in range(n): if s[i] == s[n - j - 1]: dp[i + 1][j + 1] = dp[i][j] + 1 else: dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]) return dp[n][n] lps_length = longest_palindromic_subsequence(s) return len(s) - lps_length"},{"question":"class TreeNode: def __init__(self, val=0): self.val = val self.children = [] def build_tree(edges, root_value): nodes = {} root = TreeNode(val=root_value) nodes[0] = root for parent, child, value in edges: if parent in nodes: parent_node = nodes[parent] else: parent_node = TreeNode() nodes[parent] = parent_node if child in nodes: child_node = nodes[child] else: child_node = TreeNode(val=value) nodes[child] = child_node parent_node.children.append(child_node) return root def prune_tree(root, threshold): Prunes the tree by removing subtrees whose total sum of node values is less than threshold. Parameters: root (TreeNode): The root node of the tree threshold (int): The threshold value Returns: TreeNode: The root of the pruned tree or None if the entire tree is pruned. >>> edges = [(0, 1, 3), (0, 2, 1), (1, 3, 4), (1, 4, 1), (2, 5, 2)] >>> root_value = 0 >>> root = build_tree(edges, root_value) >>> threshold = 4 >>> pruned_root = prune_tree(root, threshold) >>> pruned_root.val 0 >>> len(pruned_root.children) 1 >>> pruned_root.children[0].val 3 >>> len(pruned_root.children[0].children) 1 >>> pruned_root.children[0].children[0].val 4","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.children = [] def build_tree(edges, root_value): nodes = {} root = TreeNode(val=root_value) nodes[0] = root for parent, child, value in edges: if parent in nodes: parent_node = nodes[parent] else: parent_node = TreeNode() nodes[parent] = parent_node if child in nodes: child_node = nodes[child] else: child_node = TreeNode(val=value) nodes[child] = child_node parent_node.children.append(child_node) return root def prune_tree(root, threshold): def helper(node): if not node: return 0 total_sum = node.val pruned_children = [] for child in node.children: child_sum = helper(child) if child_sum >= threshold: pruned_children.append(child) total_sum += child_sum node.children = pruned_children return total_sum if root: total_sum = helper(root) if total_sum < threshold: return None return root"},{"question":"def canSecondPlayerWin(nums: List[int]) -> bool: Determines if the second player has a winning strategy given the list of tower heights. >>> canSecondPlayerWin([2, 3, 1, 8, 6, 7]) == True >>> canSecondPlayerWin([1, 2, 3, 4, 8, 7, 6, 5]) == False >>> canSecondPlayerWin([1, 1, 2, 2, 3, 3, 4, 4]) == False >>> canSecondPlayerWin([1, 2, 3, 1, 2, 3, 1, 2]) == False >>> canSecondPlayerWin([100, 2]) == True >>> canSecondPlayerWin([i for i in range(1, 51)]) == False >>> canSecondPlayerWin([i for i in range(1, 52)]) == True","solution":"def canSecondPlayerWin(nums): Determines if the second player has a winning strategy given the list of tower heights. Since the first player always chooses from the minimum height left, the second player always faces a decided set of choices. If n (number of towers) is even, the second player will always make the final pick from two towers with the 2 smallest heights, ensuring a draw or win. if len(nums) % 4 == 0: return False else: return True"},{"question":"def kth_smallest(matrix: List[List[int]], k: int) -> int: Given an n x n matrix where each of the rows and columns is sorted in ascending order, find the k-th smallest element in the matrix. :param matrix: List[List[int]], the input n x n matrix :param k: int, the position of the smallest element to find :return: int, the k-th smallest element in the matrix >>> matrix = [ ... [1, 5, 9], ... [10, 11, 13], ... [12, 13, 15] ... ] >>> kth_smallest(matrix, 8) 13 >>> matrix = [ ... [1, 2], ... [1, 3] ... ] >>> kth_smallest(matrix, 2) 1 >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> kth_smallest(matrix, 5) 5 >>> matrix = [ ... [10, 20, 30, 40], ... [15, 25, 35, 45], ... [24, 29, 37, 48], ... [32, 33, 39, 50] ... ] >>> kth_smallest(matrix, 7) 30 >>> matrix = [ ... [-5, -4, -3], ... [-2, -1, 0], ... [1, 2, 3] ... ] >>> kth_smallest(matrix, 4) -2","solution":"import heapq def kth_smallest(matrix, k): Returns the k-th smallest element in an n x n matrix that is sorted row-wise and column-wise. :param matrix: List[List[int]], the input n x n matrix :param k: int, the position of the smallest element to find :return: int, the k-th smallest element in the matrix n = len(matrix) min_heap = [] # Build a min-heap of elements from the first row. for col in range(min(k, n)): heapq.heappush(min_heap, (matrix[0][col], 0, col)) # Extract-min k-1 times from the heap. for _ in range(k - 1): element, row, col = heapq.heappop(min_heap) if row + 1 < n: heapq.heappush(min_heap, (matrix[row + 1][col], row + 1, col)) return heapq.heappop(min_heap)[0]"},{"question":"from typing import List def frequency_sort(s: str) -> str: Sorts the characters in the string based on their frequency in descending order. If two characters have the same frequency, they are sorted alphabetically. >>> frequency_sort(\\"tree\\") \\"eetr\\" >>> frequency_sort(\\"cccaaa\\") \\"cccaaa\\" >>> frequency_sort(\\"cccaaa\\") \\"aaaccc\\"","solution":"def frequency_sort(s): Sorts the characters in the string s based on their frequency in descending order. If two characters have the same frequency, they are sorted alphabetically. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Sort characters first by frequency in descending order, then alphabetically sorted_characters = sorted(freq.items(), key=lambda x: (-x[1], x[0])) # Reconstruct sorted string based on sorted characters and their frequency sorted_string = ''.join([char * count for char, count in sorted_characters]) return sorted_string"},{"question":"def largest_island_area(matrix): Given a 2D grid of 0s and 1s, find the largest island (group of connected 1s) and return its area. If there are no islands, return 0. >>> largest_island_area([[0, 0], [0, 0]]) == 0 >>> largest_island_area([[1, 0], [0, 0]]) == 1 >>> largest_island_area([[0, 1, 0], [1, 1, 0], [0, 0, 1]]) == 3 >>> largest_island_area([[1, 1, 1], [0, 1, 0], [1, 1, 1]]) == 7 >>> largest_island_area([[1, 0, 0, 1], [0, 0, 1, 0], [1, 0, 0, 1]]) == 1","solution":"def largest_island_area(matrix): Given a 2D grid of 0s and 1s, find the largest island (group of connected 1s) and return its area. If there are no islands, return 0. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or matrix[x][y] == 0: return 0 matrix[x][y] = 0 # Mark as visited area = 1 # Move in 4 directions area += dfs(x+1, y) area += dfs(x-1, y) area += dfs(x, y+1) area += dfs(x, y-1) return area max_area = 0 for i in range(m): for j in range(n): if matrix[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"def optimal_moves(todo: list, in_progress: list, done: list) -> list: Generates the optimal sequence of moves to shift all tasks from \`Todo\` to \`In Progress\` to \`Done\`. Parameters: - todo (list of str): Tasks in the \`Todo\` state. - in_progress (list of str): Tasks in the \`In Progress\` state. - done (list of str): Tasks in the \`Done\` state. Returns: - list of tuples: Each tuple is in the form (\\"task_name\\", \\"source_state\\", \\"destination_state\\"). pass # Implementation here # Unit Tests def test_optimal_moves_basic(): todo = ['task1', 'task2'] in_progress = [] done = [] expected = [ ('task1', 'Todo', 'In Progress'), ('task2', 'Todo', 'In Progress'), ('task1', 'In Progress', 'Done'), ('task2', 'In Progress', 'Done') ] assert optimal_moves(todo, in_progress, done) == expected def test_optimal_moves_with_in_progress(): todo = ['task1'] in_progress = ['task2'] done = [] expected = [ ('task1', 'Todo', 'In Progress'), ('task2', 'In Progress', 'Done'), ('task1', 'In Progress', 'Done') ] assert optimal_moves(todo, in_progress, done) == expected def test_optimal_moves_with_done(): todo = ['task1'] in_progress = [] done = ['task2'] expected = [ ('task1', 'Todo', 'In Progress'), ('task1', 'In Progress', 'Done') ] assert optimal_moves(todo, in_progress, done) == expected def test_optimal_moves_with_all_states(): todo = ['task1', 'task3'] in_progress = ['task2'] done = ['task4'] expected = [ ('task1', 'Todo', 'In Progress'), ('task3', 'Todo', 'In Progress'), ('task2', 'In Progress', 'Done'), ('task1', 'In Progress', 'Done'), ('task3', 'In Progress', 'Done') ] assert optimal_moves(todo, in_progress, done) == expected def test_optimal_moves_empty(): todo = [] in_progress = [] done = [] expected = [] assert optimal_moves(todo, in_progress, done) == expected","solution":"def optimal_moves(todo, in_progress, done): Generates the optimal sequence of moves to shift all tasks from \`Todo\` to \`In Progress\` to \`Done\`. Parameters: - todo (list of str): Tasks in the \`Todo\` state. - in_progress (list of str): Tasks in the \`In Progress\` state. - done (list of str): Tasks in the \`Done\` state. Returns: - list of tuples: Each tuple is in the form (\\"task_name\\", \\"source_state\\", \\"destination_state\\"). moves = [] # First, move everything from todo to in_progress for task in todo: moves.append((task, 'Todo', 'In Progress')) # Then, move everything from in_progress to done for task in in_progress + todo: # after moving \`todo\` tasks, they will be in \`in_progress\` moves.append((task, 'In Progress', 'Done')) return moves"},{"question":"import heapq from collections import Counter def rearrange_string(s: str) -> str: Given a string s, returns a possible rearrangement of the string such that no two adjacent characters in the original string are adjacent in the new string. If not possible, returns an empty string. >>> rearrange_string(\\"aab\\") in [\\"aba\\", \\"bab\\"] True >>> rearrange_string(\\"aaabc\\") in [\\"abcba\\", \\"bacab\\", \\"abacb\\", \\"bacba\\", \\"bcaba\\", \\"bcaab\\"] True >>> rearrange_string(\\"aaab\\") '' >>> rearrange_string(\\"a\\") 'a' >>> rearrange_string(\\"\\") '' >>> rearrange_string(\\"aaaaa\\") '' >>> rearrange_string(\\"aabbcc\\") in [\\"abacbc\\", \\"acbcab\\", \\"bcaabc\\", \\"babcac\\", \\"cbcaba\\", \\"cabacb\\"] True","solution":"import heapq from collections import Counter def rearrange_string(s): Returns a possible rearrangement of the string such that no two adjacent characters in the original string are adjacent in the new string. If not possible, returns an empty string. # Count the frequency of each character freq = Counter(s) # Create a max heap based on the character count max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) # Previous character and its count prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) # Since we use this character, we need to decrease the count if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update prev_count and prev_char prev_count, prev_char = count + 1, char rearranged_string = ''.join(result) # Check if we can achieve the desired condition if len(rearranged_string) == len(s): return rearranged_string else: return \\"\\""},{"question":"def max_rectangle_area(heights): Calculate the maximum rectangular area in the skyline formed by any subset of buildings. :param heights: List of integers representing the height of the buildings :return: Maximum rectangular area >>> max_rectangle_area([5]) == 5 >>> max_rectangle_area([1, 2, 3, 4, 5]) == 9 >>> max_rectangle_area([5, 4, 3, 2, 1]) == 9 >>> max_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 >>> max_rectangle_area([3, 3, 3, 3, 3]) == 15 >>> max_rectangle_area([]) == 0 >>> max_rectangle_area([2, 4]) == 4","solution":"def max_rectangle_area(heights): Calculate the maximum rectangular area in the skyline formed by any subset of buildings. :param heights: List of integers representing the height of the buildings :return: Maximum rectangular area stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def count_balanced_subarrays(nums: List[int], k: int) -> int: Returns the number of unique balanced subarrays where the sum of elements is exactly k. >>> count_balanced_subarrays([1], 1) == 1 >>> count_balanced_subarrays([1], 0) == 0 >>> count_balanced_subarrays([1, 1, 1], 2) == 2 >>> count_balanced_subarrays([1, 2, 3], 3) == 2 >>> count_balanced_subarrays([1, -1, 3, -2, 2], 2) == 3 >>> count_balanced_subarrays([1, 2, 3], 7) == 0 >>> count_balanced_subarrays([1, -1, 1], 5) == 0 >>> count_balanced_subarrays([], 0) == 0 >>> count_balanced_subarrays([0, 0, 0], 0) == 6 >>> count_balanced_subarrays([1, 2, -3, 3, -1], 3) == 3 count = 0 n = len(nums) # Iterate over all possible starting points of subarrays for start in range(n): current_sum = 0 # Iterate over all possible ending points of subarrays starting from 'start' for end in range(start, n): current_sum += nums[end] # Check if the current subarray sum is equal to k if current_sum == k: count += 1 return count","solution":"def count_balanced_subarrays(nums, k): Returns the number of unique balanced subarrays where the sum of elements is exactly k. count = 0 n = len(nums) # Iterate over all possible starting points of subarrays for start in range(n): current_sum = 0 # Iterate over all possible ending points of subarrays starting from 'start' for end in range(start, n): current_sum += nums[end] # Check if the current subarray sum is equal to k if current_sum == k: count += 1 return count"},{"question":"def reorganize_string(s: str) -> str: Reorganizes the input string such that no two adjacent characters are the same. If it is not possible, returns an empty string. >>> reorganize_string(\\"aab\\") in [\\"aba\\"] >>> reorganize_string(\\"aaabbc\\") in [\\"ababac\\", \\"ababca\\", \\"bacaba\\", \\"abacba\\"] >>> reorganize_string(\\"abcdef\\") == \\"abcdef\\" # already reorganized >>> reorganize_string(\\"aaab\\") == \\"\\" >>> reorganize_string(\\"aaaa\\") == \\"\\" >>> reorganize_string(\\"a\\") == \\"a\\" >>> reorganize_string(\\"\\") == \\"\\" >>> reorganize_string(\\"aaaabbbbcccc\\") in [\\"abcabcabcabc\\"] >>> reorganize_string(\\"aabb\\") in [\\"abab\\", \\"baba\\"]","solution":"import heapq from collections import Counter def reorganize_string(s): Reorganizes the input string such that no two adjacent characters are the same. If it is not possible, returns an empty string. count = Counter(s) max_heap = [(-freq, char) for char, freq in count.items()] heapq.heapify(max_heap) previous_char, previous_freq = None, 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if previous_char and previous_freq < 0: heapq.heappush(max_heap, (previous_freq, previous_char)) previous_char = char previous_freq = freq + 1 reorganized_string = \\"\\".join(result) if len(reorganized_string) == len(s): return reorganized_string else: return \\"\\""},{"question":"from typing import List def priority_return_list(borrowed_days: List[int], k: int) -> List[int]: Returns a list of books to be returned based on borrowing days exceeding k. :param borrowed_days: List[int] - List of days books have been borrowed :param k: int - Number of days threshold for a book to be flagged for return :return: List[int] - List of books to be returned >>> priority_return_list([5, 13, 8, 2, 10], 7) [13, 8, 10] >>> priority_return_list([1, 2, 3, 4, 5], 7) [] >>> priority_return_list([8, 9, 10, 11, 12], 7) [8, 9, 10, 11, 12] >>> priority_return_list([5, 8, 2, 12, 7, 9, 3], 7) [8, 12, 9] >>> priority_return_list([], 7) [] >>> priority_return_list([7, 7, 7], 7) []","solution":"def priority_return_list(borrowed_days, k): Returns a list of books to be returned based on borrowing days exceeding k. :param borrowed_days: List[int] - List of days books have been borrowed :param k: int - Number of days threshold for a book to be flagged for return :return: List[int] - List of books to be returned return [days for days in borrowed_days if days > k]"},{"question":"def can_reach_end(heights: List[int], s: int) -> bool: Determine if the robot can reach the end of the track given its strength \`s\`. Parameters: heights (list): A list of integers representing the heights of obstacles. s (int): The initial strength of the robot. Returns: bool: True if the robot can reach the end of the track, otherwise False. >>> can_reach_end([1, 2, 1, 2, 1], 5) True >>> can_reach_end([3, 2, 3, 4], 2) False >>> can_reach_end([1, 1, 1], 3) True >>> can_reach_end([1, 2, 3, 4], 4) False >>> can_reach_end([], 5) True >>> can_reach_end([2], 2) True >>> can_reach_end([3], 2) False >>> can_reach_end([1, 2, 3], 0) False","solution":"def can_reach_end(heights, s): Determine if the robot can reach the end of the track given its strength \`s\`. Parameters: heights (list): A list of integers representing the heights of obstacles. s (int): The initial strength of the robot. Returns: bool: True if the robot can reach the end of the track, otherwise False. for height in heights: if s < height: return False s -= 1 if s < 0: return False return True"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longest_consecutive_path(root: TreeNode) -> int: Given a binary tree, find the length of the longest path such that each node in the path has a consecutive value. >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> longest_consecutive_path(root) 2 >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(15) >>> root.right.right = TreeNode(20) >>> longest_consecutive_path(root) 1 >>> root = TreeNode(3) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(1) >>> root.right = TreeNode(4) >>> root.right.right = TreeNode(5) >>> longest_consecutive_path(root) 3","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longest_consecutive_path(root): def dfs(node, parent_value, length): if not node: return length current_length = length + 1 if parent_value + 1 == node.value else 1 left_length = dfs(node.left, node.value, current_length) right_length = dfs(node.right, node.value, current_length) return max(current_length, left_length, right_length) return dfs(root, root.value - 1, 0) if root else 0"},{"question":"from typing import List def min_containers(weights: List[int], maxLoad: int) -> int: Distribute items into the minimum number of containers such that the sum of the weights of the items in each container does not exceed maxLoad. Each item must be placed in exactly one container. >>> min_containers([2, 3, 4, 5], 5) 3 >>> min_containers([2, 2, 2], 6) 1 >>> min_containers([4, 4, 4, 4], 4) 4 >>> min_containers([5, 1, 3, 4, 2], 5) 3 >>> min_containers([10], 5) 1 >>> min_containers([1, 2, 3, 4, 5, 5, 6, 7, 8, 9], 10) 5 >>> min_containers([], 10) 0 >>> min_containers([5], 5) 1","solution":"from typing import List def min_containers(weights: List[int], maxLoad: int) -> int: weights.sort(reverse=True) containers = [] for w in weights: placed = False for i in range(len(containers)): if containers[i] + w <= maxLoad: containers[i] += w placed = True break if not placed: containers.append(w) return len(containers)"},{"question":"from typing import List def minNumberOfSemesters(n: int, prerequisites: List[List[int]]) -> int: Returns the minimum number of semesters required to complete all courses. If it is impossible to complete all courses, return -1. :param n: int - the total number of courses. :param prerequisites: List[List[int]] - the prerequisite relationships between the courses. :return: int - the minimum number of semesters required to complete all courses or -1 if impossible. pass def test_no_prerequisites(): assert minNumberOfSemesters(4, []) == 1 def test_simple_prerequisites(): assert minNumberOfSemesters(4, [[1, 0], [2, 1], [3, 2]]) == 4 def test_multiple_prerequisites(): assert minNumberOfSemesters(5, [[1, 0], [2, 0], [3, 1], [3, 2]]) == 3 def test_impossible_course_schedule(): assert minNumberOfSemesters(3, [[0, 1], [1, 2], [2, 0]]) == -1 def test_complex_prerequisites(): assert minNumberOfSemesters(6, [[1, 0], [2, 1], [3, 1], [3, 2], [4, 2], [5, 4]]) == 5","solution":"from collections import deque, defaultdict def minNumberOfSemesters(n, prerequisites): Returns the minimum number of semesters required to complete all courses. If it is impossible to complete all courses, return -1. :param n: int - the total number of courses. :param prerequisites: List[List[int]] - the prerequisite relationships between the courses. :return: int - the minimum number of semesters required to complete all courses or -1 if impossible. in_degree = [0] * n adj_list = defaultdict(list) for course, prereq in prerequisites: in_degree[course] += 1 adj_list[prereq].append(course) queue = deque([i for i in range(n) if in_degree[i] == 0]) semesters = 0 completed_courses = 0 while queue: num_courses_this_semester = len(queue) for _ in range(num_courses_this_semester): course = queue.popleft() completed_courses += 1 for next_course in adj_list[course]: in_degree[next_course] -= 1 if in_degree[next_course] == 0: queue.append(next_course) semesters += 1 return semesters if completed_courses == n else -1"},{"question":"def count_peaks(heights: List[int]) -> int: Returns the number of peaks in the array heights. A peak is defined as a person who is taller than both their immediate neighbors. >>> count_peaks([1, 3, 2]) 1 >>> count_peaks([1, 3, 2, 5, 4, 6, 3]) 3 >>> count_peaks([1, 2, 3]) 0 >>> count_peaks([]) 0 >>> count_peaks([1]) 0 >>> count_peaks([1, 2]) 0 >>> count_peaks([1, 2, 3, 4, 5]) 0 >>> count_peaks([5, 4, 3, 2, 1]) 0 >>> count_peaks([1, 2, 2, 3, 2, 2, 1]) 1 >>> count_peaks([1, 2, 2, 3, 2, 2, 3]) 1 >>> count_peaks([1, 2, 3, 1, 2, 3, 1]) 2","solution":"def count_peaks(heights): Returns the number of peaks in the array heights. A peak is an element which is higher than its immediate neighbors. if len(heights) < 3: return 0 peak_count = 0 for i in range(1, len(heights) - 1): if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: peak_count += 1 return peak_count"},{"question":"def minimize_max_cookies(nums: List[int], k: int) -> int: Given an array of integers \`nums\` where \`nums[i]\` represents the number of cookies in the \`i\`-th pile, distribute the cookies to \`k\` children such that the maximum number of cookies any child gets is minimized. Each child gets a contiguous block of cookies. :param nums: List of integers representing the number of cookies in each pile :param k: Number of children :return: The minimized maximum number of cookies any child can get >>> minimize_max_cookies([7, 2, 5, 10, 8], 2) 18 >>> minimize_max_cookies([10], 1) 10 >>> minimize_max_cookies([3, 3, 3, 3], 2) 6 >>> minimize_max_cookies([1, 2, 3, 4, 5], 1) 15 >>> minimize_max_cookies([1, 4, 4], 3) 4 >>> minimize_max_cookies([10, 5, 2, 7, 10], 5) 10 >>> minimize_max_cookies([5, 10, 5], 3) 10","solution":"def minimize_max_cookies(nums, k): This function distributes the cookies such that the maximum number of cookies any child gets is minimized. def canDistributeWithMaxSum(max_sum): current_sum, parts = 0, 1 for num in nums: if current_sum + num > max_sum: parts += 1 current_sum = num if parts > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if canDistributeWithMaxSum(mid): right = mid else: left = mid + 1 return left"},{"question":"class WeightManager: A class to manage weights with efficient update and range sum queries. >>> wm = WeightManager(5, [1, 2, 3, 4, 5]) >>> wm.getTotalWeight(0, 4) 15 >>> wm.updateWeight(2, 10) >>> wm.getTotalWeight(0, 4) 22 >>> wm.getTotalWeight(1, 2) 12 >>> wm.getTotalWeight(1, 3) 9 >>> wm.getTotalWeight(2, 4) 12 >>> wm.updateWeight(0, 7) >>> wm.getTotalWeight(0, 0) 7 >>> wm.getTotalWeight(0, 1) 9 >>> wm.getTotalWeight(0, 4) 21 >>> wm.updateWeight(1, 6) >>> wm.updateWeight(3, 8) >>> wm.getTotalWeight(0, 4) 23 >>> wm.getTotalWeight(1, 3) 17 def __init__(self, n, weights): Initializes the object with a list of weights. pass def updateWeight(self, index, weight): Updates the weight of an item at the given index. pass def getTotalWeight(self, start, end): Returns the sum of weights of items within the inclusive range from start to end. pass","solution":"class WeightManager: def __init__(self, n, weights): Initializes the object with a list of weights. self.n = n self.weights = weights self.tree = [0] * (2 * n) self.build_tree() def build_tree(self): Builds the segment tree for efficient range sum query. # Initialize leaves for i in range(self.n): self.tree[self.n + i] = self.weights[i] # Build the tree for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def updateWeight(self, index, weight): Updates the weight of an item at the given index. pos = index + self.n self.tree[pos] = weight # Update ancestors while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def getTotalWeight(self, start, end): Returns the sum of weights of items within the inclusive range from start to end. start += self.n end += self.n sum_weights = 0 while start <= end: if start % 2 == 1: sum_weights += self.tree[start] start += 1 if end % 2 == 0: sum_weights += self.tree[end] end -= 1 start //= 2 end //= 2 return sum_weights"},{"question":"def minWindowSubstring(s: str, t: str) -> str: Given two strings \`s\` and \`t\`, return the minimum window substring of \`s\` such that every character in \`t\` (including duplicates) is included in the window. If no such substring exists, return an empty string. If there are multiple minimum-length windows, return the one that appears first. >>> minWindowSubstring(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" >>> minWindowSubstring(\\"A\\", \\"AA\\") \\"\\" >>> minWindowSubstring(\\"ABCD\\", \\"Z\\") \\"\\" >>> minWindowSubstring(\\"\\", \\"A\\") \\"\\" >>> minWindowSubstring(\\"A\\", \\"\\") \\"\\" >>> minWindowSubstring(\\"\\", \\"\\") \\"\\" >>> minWindowSubstring(\\"A\\", \\"A\\") \\"A\\" >>> minWindowSubstring(\\"AA\\", \\"AA\\") \\"AA\\" >>> minWindowSubstring(\\"AAAAAA\\", \\"AAA\\") \\"AAA\\" >>> minWindowSubstring(\\"this is a test string\\", \\"tist\\") \\"t stri\\" pass","solution":"def minWindowSubstring(s: str, t: str) -> str: from collections import Counter, defaultdict if not s or not t: return \\"\\" # Dictionary which keeps a count of all the unique characters in t. dict_t = Counter(t) # Number of unique characters in t that need to be present in the desired window. required = len(dict_t) # Left and Right pointer l, r = 0, 0 # Formed is used to keep track of how many unique characters in t # are present in the current window in its desired frequency. # e.g. if t is \\"AABC\\" then the window must have two A's, one B and one C. # thus formed should be 3 if the window is valid. formed = 0 # Dictionary which keeps a count of all the unique characters in the current window. window_counts = defaultdict(int) # ans tuple of the form (window length, left, right) ans = float(\\"inf\\"), None, None while r < len(s): # Add one character from the right to the window character = s[r] window_counts[character] += 1 # If the frequency of the current character added equals to the # desired count in t then increment the formed count by 1. if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 # Try and contract the window till the point where it ceases to be 'desirable'. while l <= r and formed == required: character = s[l] # Save the smallest window until now. if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) # The character at the position pointed by the # \`Left\` pointer is no longer a part of the window. window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 # Move the left pointer ahead, this would help to look for a new window. l += 1 # Keep expanding the window once we are done contracting. r += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s[ans[1]: ans[2] + 1]"},{"question":"def rearrange_array(arr, k): Rearranges the array such that every k-th element remains in its original position while the rest of the array is sorted in ascending order. Parameters: - arr (List[int]): A list of distinct integers initially sorted in ascending order - k (int): An integer denoting the position interval which must remain in its original position Returns: - List[int]: The rearranged list >>> rearrange_array([1, 2, 3, 4, 5, 6, 7], 3) [1, 2, 3, 4, 5, 6, 7] >>> rearrange_array([1, 3, 5, 7, 9, 11, 13, 15], 2) [1, 3, 5, 7, 9, 11, 13, 15] >>> rearrange_array([10, 20, 30, 40, 50, 60], 3) [10, 20, 30, 40, 50, 60] >>> rearrange_array([1, 2, 3, 4, 5, 6, 7, 8, 9], 4) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> rearrange_array([1, 2, 3, 4], 5) [1, 2, 3, 4] >>> rearrange_array([], 3) [] >>> rearrange_array([5], 1) [5] >>> rearrange_array([4, 3, 1, 5, 2], 1) [4, 3, 1, 5, 2]","solution":"def rearrange_array(arr, k): Rearranges the array such that every k-th element remains in its original position while the rest of the array is sorted in ascending order. Parameters: - arr (List[int]): A list of distinct integers initially sorted in ascending order - k (int): An integer denoting the position interval which must remain in its original position Returns: - List[int]: The rearranged list n = len(arr) # Extract the elements that will stay and their indices stay_indices = [i for i in range(n) if (i+1) % k == 0] stay_elements = [arr[i] for i in stay_indices] # Extract the elements that will be rearranged move_elements = [arr[i] for i in range(n) if (i+1) % k != 0] # Sort the elements that need to be moved move_elements.sort() # Create a new array and fill in the elements result = [] move_index = 0 stay_index = 0 for i in range(n): if (i+1) % k == 0: result.append(stay_elements[stay_index]) stay_index += 1 else: result.append(move_elements[move_index]) move_index += 1 return result"},{"question":"def find_and_replace_pattern(words: List[str], pattern: str) -> List[str]: Given a list of words and a pattern, return a list of all the words that match the pattern. A word matches the pattern if there exists a permutation of letters \`p\` such that after replacing every letter \`x\` in the pattern with \`p(x)\`, we get the desired word. Ensure that each letter in the pattern maps to a unique letter in the word and vice versa. >>> find_and_replace_pattern([\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"], \\"abb\\") == [\\"mee\\", \\"aqq\\"]","solution":"def find_and_replace_pattern(words, pattern): Given an array of words and a pattern, returns an array of the words that match the given pattern. :param words: List[str] - A list of words to be matched against the pattern. :param pattern: str - The pattern to compare the words against. :return: List[str] - A list of words that match the pattern. def match_pattern(word, pattern): Helper function to determine if a word matches a given pattern. :param word: str - A word to be matched against the pattern. :param pattern: str - The pattern to compare the word against. :return: bool - True if word matches the pattern, False otherwise. if len(word) != len(pattern): return False char_mapping_word_to_pattern = {} char_mapping_pattern_to_word = {} for char_word, char_pattern in zip(word, pattern): if char_word not in char_mapping_word_to_pattern: char_mapping_word_to_pattern[char_word] = char_pattern if char_pattern not in char_mapping_pattern_to_word: char_mapping_pattern_to_word[char_pattern] = char_word if char_mapping_word_to_pattern[char_word] != char_pattern or char_mapping_pattern_to_word[char_pattern] != char_word: return False return True return [word for word in words if match_pattern(word, pattern)]"},{"question":"def previous_permutation(arr): Find the previous permutation of the given permutation array in lexicographical order. If no such permutation exists, return the permutation sorted in descending order. >>> previous_permutation([1, 2, 3]) == [3, 2, 1] >>> previous_permutation([1, 3, 2]) == [1, 2, 3] >>> previous_permutation([3, 2, 1]) == [3, 1, 2] >>> previous_permutation([2, 1, 3]) == [1, 3, 2] >>> previous_permutation([1]) == [1] >>> previous_permutation([2, 1]) == [1, 2] >>> previous_permutation([1, 2]) == [2, 1]","solution":"def previous_permutation(arr): Find the previous permutation of the given permutation array in lexicographical order. If no such permutation exists, return the permutation sorted in descending order. n = len(arr) # Step 1 - Find the largest index k such that arr[k] > arr[k + 1] k = n - 2 while k >= 0 and arr[k] <= arr[k + 1]: k -= 1 # If no such index exists, the array is sorted in ascending order if k == -1: return arr[::-1] # Step 2 - Find the largest index l > k such that arr[k] > arr[l] l = n - 1 while arr[k] <= arr[l]: l -= 1 # Step 3 - Swap the value of arr[k] with that of arr[l] arr[k], arr[l] = arr[l], arr[k] # Step 4 - Reverse the sequence from arr[k+1] to the end arr = arr[:k+1] + arr[k+1:][::-1] return arr"},{"question":"def combination_sum(n: int) -> List[List[int]]: Given an integer \`n\`, return a list of all unique combinations of numbers from \`1\` to \`n\` that sum up to \`n\`. Each number in the range \`[1, n]\` can appear at most once in the combination. The combinations can be returned in any order. >>> combination_sum(3) [[1, 2], [3]] >>> combination_sum(4) [[1, 3], [4]] >>> combination_sum(5) [[1, 4], [2, 3], [5]] >>> combination_sum(6) [[1, 2, 3], [1, 5], [2, 4], [6]] >>> combination_sum(7) [[1, 2, 4], [1, 6], [2, 5], [3, 4], [7]]","solution":"def combination_sum(n): def backtrack(start, target, path, res): if target == 0: res.append(path) return for i in range(start, n + 1): if i > target: break backtrack(i + 1, target - i, path + [i], res) result = [] backtrack(1, n, [], result) return result"},{"question":"from typing import List class FreqStack: A stack-like data structure with frequency-based popping. Methods ------- FreqStack() Initializes the stack object. void push(int x) Pushes an integer \`x\` onto the stack. int pop() Removes and returns the most frequent element in the stack. If there is a tie for the most frequent element, the element closest to the top of the stack is removed and returned. >>> stack = FreqStack() >>> stack.push(5) >>> stack.push(7) >>> stack.push(5) >>> stack.push(7) >>> stack.push(4) >>> stack.push(5) >>> stack.pop() 5 >>> stack.pop() 7 >>> stack.pop() 5 >>> stack.pop() 4 >>> stack.pop() 7 >>> stack = FreqStack() >>> stack.push(1) >>> stack.push(2) >>> stack.push(3) >>> stack.pop() 3 >>> stack.pop() 2 >>> stack.pop() 1 >>> stack = FreqStack() >>> stack.push(8) >>> stack.pop() 8 >>> stack = FreqStack() >>> stack.push(6) >>> stack.push(6) >>> stack.push(6) >>> stack.pop() 6 >>> stack.pop() 6 >>> stack.pop() 6 def __init__(self): pass def push(self, x: int) -> None: pass def pop(self) -> int: pass","solution":"from collections import defaultdict import heapq class FreqStack: def __init__(self): self.freq = defaultdict(int) self.max_heap = [] self.index = 0 def push(self, x): self.freq[x] += 1 heapq.heappush(self.max_heap, (-self.freq[x], -self.index, x)) self.index += 1 def pop(self): freq, index, x = heapq.heappop(self.max_heap) self.freq[x] -= 1 if self.freq[x] == 0: del self.freq[x] return x"},{"question":"def can_students_sit_comfortably(arr, space, n): Determine if it's possible for all students to sit comfortably in a row of seats. >>> can_students_sit_comfortably([], [], 10) True >>> can_students_sit_comfortably([5], [0], 10) True >>> can_students_sit_comfortably([1, 4, 7], [1, 1, 1], 10) True >>> can_students_sit_comfortably([1, 2], [1, 1], 10) False >>> can_students_sit_comfortably([8, 9], [1, 1], 10) False >>> can_students_sit_comfortably([0, 9], [0, 0], 10) True >>> can_students_sit_comfortably([0, 9], [1, 1], 10) False >>> can_students_sit_comfortably([2, 5, 8], [1, 1, 1], 10) True","solution":"def can_students_sit_comfortably(arr, space, n): positions = sorted(zip(arr, space)) for i in range(len(positions)): seat, required_space = positions[i] # Checking the space on the left side if i == 0: left_boundary = 0 else: left_boundary = positions[i-1][0] + positions[i-1][1] + 1 left_space = seat - left_boundary if left_space < required_space: return False # Checking the space on the right side if i == len(positions) - 1: right_boundary = n - 1 else: right_boundary = positions[i+1][0] - positions[i+1][1] - 1 right_space = right_boundary - seat if right_space < required_space: return False return True"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Determines if a binary tree is balanced. :param root: TreeNode, the root of the binary tree :return: boolean, True if the tree is balanced, False otherwise >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> is_balanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> is_balanced(root) False >>> root = None >>> is_balanced(root) True >>> root = TreeNode(1) >>> is_balanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.left.right = TreeNode(5) >>> is_balanced(root) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Determines if a binary tree is balanced. :param root: TreeNode, the root of the binary tree :return: boolean, True if the tree is balanced, False otherwise def check_balance(node): if not node: return 0, True left_depth, left_balanced = check_balance(node.left) right_depth, right_balanced = check_balance(node.right) current_balance = abs(left_depth - right_depth) <= 1 balanced = left_balanced and right_balanced and current_balance return max(left_depth, right_depth) + 1, balanced _, balanced = check_balance(root) return balanced"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def detectCycle(head): Given a linked list, return the node where the cycle begins. If there is no cycle, return None. Uses constant memory to determine the result. Args: head (ListNode): The head of the linked list. Returns: ListNode: The node where the cycle begins, or None if there is no cycle. # Unit test def test_no_cycle(): a = ListNode(1) b = ListNode(2) a.next = b assert detectCycle(a) == None def test_cycle_at_start(): a = ListNode(1) b = ListNode(2) c = ListNode(3) a.next = b b.next = c c.next = a # cycle starts at a assert detectCycle(a) == a def test_cycle_at_middle(): a = ListNode(1) b = ListNode(2) c = ListNode(3) d = ListNode(4) a.next = b b.next = c c.next = d d.next = b # cycle starts at b assert detectCycle(a) == b def test_single_node_with_cycle(): a = ListNode(1) a.next = a # cycle starts at a assert detectCycle(a) == a def test_single_node_without_cycle(): a = ListNode(1) assert detectCycle(a) == None def test_large_cycle(): # Create nodes nodes = [ListNode(i) for i in range(10)] # Link the nodes for i in range(9): nodes[i].next = nodes[i+1] nodes[9].next = nodes[4] # cycle starts at node 4 assert detectCycle(nodes[0]) == nodes[4]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def detectCycle(head): Detects the node where the cycle begins in the linked list. Args: head (ListNode): The head of the linked list. Returns: ListNode: The node where the cycle begins, or None if there is no cycle. if not head or not head.next: return None slow = head fast = head # First, determine if there is a cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: # No cycle detected return None # To find the starting node of the cycle, reset one pointer to the head # and move both pointers one step at a time until they meet slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"def min_operations_to_equal(s1: str, s2: str) -> int: Determines the minimum number of single-character substitutions required to make two strings s1 and s2 equal after at most one operation. If it's impossible to make the strings equal, returns -1. >>> min_operations_to_equal(\\"abc\\", \\"abc\\") == 0 >>> min_operations_to_equal(\\"abc\\", \\"adc\\") == 1 >>> min_operations_to_equal(\\"ab\\", \\"ba\\") == 1 >>> min_operations_to_equal(\\"abc\\", \\"aad\\") == -1 >>> min_operations_to_equal(\\"abcdef\\", \\"ghijkl\\") == -1","solution":"def min_operations_to_equal(s1, s2): Determines the minimum number of single-character substitutions required to make two strings s1 and s2 equal after at most one operation. If it's impossible to make the strings equal, returns -1. # First, count the number of different positions between s1 and s2 diff_count = sum(1 for a, b in zip(s1, s2) if a != b) # If there are no differences, no operation is needed if diff_count == 0: return 0 # If there is exactly one difference, check if it's possible to fix it with one change if diff_count == 1: return 1 # If there are exactly two differences, see if swapping the characters would work if diff_count == 2: diff_positions = [(a, b) for a, b in zip(s1, s2) if a != b] if (diff_positions[0][0] == diff_positions[1][1] and diff_positions[0][1] == diff_positions[1][0]): return 1 # If there are more than two differences, it's not possible with one operation return -1"},{"question":"def is_valid_parentheses(s: str) -> bool: Determines if the input string \`s\` consisting of parentheses \`(\` and \`)\` is valid according to the given rules. >>> is_valid_parentheses(\\"()\\") True >>> is_valid_parentheses(\\"(())\\") True >>> is_valid_parentheses(\\"()()\\") True >>> is_valid_parentheses(\\"(\\") False >>> is_valid_parentheses(\\")\\") False >>> is_valid_parentheses(\\"(()\\") False >>> is_valid_parentheses(\\"())\\") False >>> is_valid_parentheses(\\"()(())\\") True >>> is_valid_parentheses(\\"(()())\\") True >>> is_valid_parentheses(\\"()(()()())\\") True >>> is_valid_parentheses(\\"(()))\\") False >>> is_valid_parentheses(\\"((())\\") False >>> is_valid_parentheses(\\"()((())\\") False >>> is_valid_parentheses(\\")()(\\") False","solution":"def is_valid_parentheses(s): Determines if the input string \`s\` consisting of parentheses \`(\` and \`)\` is valid according to the given rules. Parameters: s (str): The input string containing parentheses. Returns: bool: True if the string is valid, False otherwise. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if len(stack) == 0 or stack[-1] != '(': return False stack.pop() return len(stack) == 0"},{"question":"from typing import List def unique_words(sentence: str) -> List[str]: Returns a list of words that appear only once in the sentence. Parameters: sentence (str): The input sentence containing words separated by spaces. Returns: List[str]: A list of unique words that appear only once in the sentence. Examples: >>> unique_words(\\"apple banana cherry\\") [\\"apple\\", \\"banana\\", \\"cherry\\"] >>> unique_words(\\"this is a test this is only a test\\") [\\"only\\"] >>> unique_words(\\"repeat repeat repeat\\") [] >>> unique_words(\\"\\") [] >>> unique_words(\\"unique\\") [\\"unique\\"] >>> unique_words(\\"Apple apple\\") [\\"Apple\\", \\"apple\\"] >>> unique_words(\\"hello! hello? hello.\\") [\\"hello!\\", \\"hello?\\", \\"hello.\\"]","solution":"from typing import List from collections import Counter def unique_words(sentence: str) -> List[str]: Returns a list of words that appear only once in the sentence. Parameters: sentence (str): The input sentence containing words separated by spaces. Returns: List[str]: A list of unique words that appear only once in the sentence. # Split the sentence into words words = sentence.split() # Count the occurrences of each word word_counts = Counter(words) # Filter the words that appear only once unique_words_list = [word for word in words if word_counts[word] == 1] return unique_words_list"},{"question":"def min_difference(arr: List[int], K: int) -> int: Returns the minimum difference between the maximum and minimum times among all possible subsets of size K. :param arr: List of integers representing the times. :param K: Size of the subset. :return: The minimum difference. >>> min_difference([1, 2, 3, 4, 5], 1) 0 >>> min_difference([1, 2, 3, 4, 5], 5) 4 >>> min_difference([10, 20, 30, 40, 50], 3) 20 >>> min_difference([5, 1, 4, 3, 2], 2) 1","solution":"def min_difference(arr, K): Returns the minimum difference between the maximum and minimum times among all possible subsets of size K. if K > len(arr): raise ValueError(\\"K should not be greater than the length of the array\\") arr.sort() min_diff = float('inf') for i in range(len(arr) - K + 1): diff = arr[i + K - 1] - arr[i] if diff < min_diff: min_diff = diff return min_diff"},{"question":"from typing import List def kthSmallest(grid: List[List[int]], k: int) -> int: Returns the k-th smallest element in the sorted matrix. >>> kthSmallest([ [1, 5, 9], [10, 11, 13], [12, 13, 15] ], 8) 13 >>> kthSmallest([ [1, 2], [1, 3] ], 2) 1 >>> kthSmallest([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ], 5) 5 >>> kthSmallest([ [1, 3, 5], [6, 7, 12], [11, 14, 14] ], 6) 11 >>> kthSmallest([ [2, 6, 8], [3, 7, 10], [5, 8, 11] ], 4) 6","solution":"import heapq def kthSmallest(grid, k): Returns the k-th smallest element in the sorted matrix. n = len(grid) min_heap = [] # Add the first column of the matrix to the heap for r in range(min(k, n)): # only need first k rows min_heap.append((grid[r][0], r, 0)) heapq.heapify(min_heap) # Remove the minimum elements from the heap k times for _ in range(k - 1): smallest, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (grid[r][c + 1], r, c + 1)) return heapq.heappop(min_heap)[0]"},{"question":"def min_refills(plants: List[int], capacity: int) -> int: Calculate the minimum number of refills needed to water all the plants. >>> min_refills([2, 2, 2], 6) == 0 >>> min_refills([2, 4, 5, 1, 2], 6) == 2 >>> min_refills([3, 3, 3, 3], 3) == 3 >>> min_refills([10, 10, 10], 10) == 2 >>> min_refills([7], 7) == 0 >>> min_refills([8], 7) == 1 >>> min_refills([1, 2, 3, 4, 5], 5) == 3 >>> min_refills([1, 2, 3, 4, 5], 6) == 2","solution":"def min_refills(plants, capacity): Calculate the minimum number of refills needed to water all the plants. Parameters: plants - list of ints, where each int represents the amount of water needed by a plant. capacity - int, represents the capacity of the watering can. Returns: int - minimum number of refills needed. refills = 0 current_water = capacity for i in range(len(plants)): if plants[i] <= current_water: current_water -= plants[i] else: refills += 1 current_water = capacity - plants[i] return refills"},{"question":"def find_odd_frequency_element(arr): Returns the element that appears an odd number of times in the input array. Args: arr (list): List of integers where every element except one appears an even number of times. Returns: int: The element that appears an odd number of times. pass # Implement the function here # Unit Tests def test_single_element(): assert find_odd_frequency_element([5]) == 5 def test_all_elements_same(): assert find_odd_frequency_element([2, 2, 2]) == 2 def test_multiple_elements(): assert find_odd_frequency_element([2, 3, 2, 3, 4]) == 4 def test_large_input(): assert find_odd_frequency_element([10, 20, 20, 10, 10, 10, 30, 30, 40]) == 40 def test_edge_case_all_pairs(): assert find_odd_frequency_element([8, 8, 9]) == 9","solution":"def find_odd_frequency_element(arr): Returns the element that appears an odd number of times in the input array. Args: arr (list): List of integers where every element except one appears an even number of times. Returns: int: The element that appears an odd number of times. result = 0 for num in arr: result ^= num # XOR operation will result in the odd frequency element return result"},{"question":"import random class RandomizedSet: Design a data structure that supports the following operations in average O(1) time complexity: 1. insert(val): Inserts a value val to the set if it is not already present. 2. remove(val): Removes a value val from the set if it is present. 3. getRandom(): Returns a random element from the set. Each element must have the same probability of being returned. def __init__(self): Initialize your data structure here. def insert(self, val: int) -> bool: Inserts a value to the set. Returns true if the set did not already contain the specified element. def remove(self, val: int) -> bool: Removes a value from the set. Returns true if the set contained the specified element. def getRandom(self) -> int: Get a random element from the set. # Unit Tests def test_insert(): rs = RandomizedSet() assert rs.insert(1) == True assert rs.insert(2) == True assert rs.insert(2) == False assert rs.insert(1) == False def test_remove(): rs = RandomizedSet() rs.insert(1) rs.insert(2) assert rs.remove(1) == True assert rs.remove(1) == False assert rs.remove(3) == False assert rs.remove(2) == True def test_getRandom(): rs = RandomizedSet() rs.insert(1) rs.insert(2) rs.insert(3) assert rs.getRandom() in [1, 2, 3] assert rs.getRandom() in [1, 2, 3] assert rs.getRandom() in [1, 2, 3] @pytest.mark.parametrize(\\"insert_values, remove_value, expected_random_elements\\", [ ([1, 2, 3], 2, [1, 3]), ([], 1, []), ([4, 5, 6], 6, [4, 5]) ]) def test_combined_operations(insert_values, remove_value, expected_random_elements): rs = RandomizedSet() for value in insert_values: rs.insert(value) rs.remove(remove_value) if expected_random_elements: assert rs.getRandom() in expected_random_elements else: with pytest.raises(IndexError): rs.getRandom()","solution":"import random class RandomizedSet: def __init__(self): Initialize your data structure here. self.vals = [] self.vals_map = {} def insert(self, val: int) -> bool: Inserts a value to the set. Returns true if the set did not already contain the specified element. if val in self.vals_map: return False self.vals.append(val) self.vals_map[val] = len(self.vals) - 1 return True def remove(self, val: int) -> bool: Removes a value from the set. Returns true if the set contained the specified element. if val not in self.vals_map: return False index = self.vals_map[val] last_element = self.vals[-1] self.vals[index] = last_element self.vals_map[last_element] = index self.vals.pop() del self.vals_map[val] return True def getRandom(self) -> int: Get a random element from the set. return random.choice(self.vals)"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_bst_from_inorder(nums: List[int]) -> Optional[TreeNode]: Construct binary search tree from the given inorder traversal list. >>> build_bst_from_inorder([]) None >>> root = build_bst_from_inorder([10]) >>> root.val 10 >>> root.left None >>> root.right None >>> nums = [2, 3, 5, 7, 11, 13, 17] >>> root = build_bst_from_inorder(nums) >>> inorder_traversal(root) == nums True pass def inorder_traversal(root): Helper function to perform inorder traversal of the binary tree. if root is None: return [] return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right)","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_bst_from_inorder(nums): Construct binary search tree from the given inorder traversal list. if not nums: return None def build(nums, left, right): if left > right: return None # Midpoint to split the nums array mid = (left + right) // 2 # Root node for this subtree root = TreeNode(nums[mid]) # Recursively build the left and right subtrees root.left = build(nums, left, mid - 1) root.right = build(nums, mid + 1, right) return root return build(nums, 0, len(nums) - 1)"},{"question":"class MinStack: Implement a data structure that supports the following operations on a stack: * push(int x) -- Push element x onto the stack. * pop() -- Removes the element on the top of the stack and returns that element. * top() -- Get the top element. * getMin() -- Retrieve the minimum element in the stack. All operations must perform in constant time. >>> min_stack = MinStack() >>> min_stack.push(3) >>> min_stack.top() 3 >>> min_stack.getMin() 3 >>> min_stack.push(5) >>> min_stack.top() 5 >>> min_stack.getMin() 3 >>> min_stack.pop() 5 >>> min_stack.top() 3 >>> min_stack.getMin() 3 >>> min_stack.push(1) >>> min_stack.push(2) >>> min_stack.getMin() 1 >>> min_stack.pop() 2 >>> min_stack.getMin() 1 >>> min_stack.pop() 1 >>> min_stack.getMin() 3 def __init__(self): Initialize data structure here. def push(self, x: int) -> None: Push element x onto the stack. def pop(self) -> int: Removes the element on the top of the stack and returns that element. def top(self) -> int: Get the top element. def getMin(self) -> int: Retrieve the minimum element in the stack.","solution":"class MinStack: def __init__(self): Initialize your data structure here. self.stack = [] self.min_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> int: if self.stack: popped = self.stack.pop() if popped == self.min_stack[-1]: self.min_stack.pop() return popped def top(self) -> int: if self.stack: return self.stack[-1] def getMin(self) -> int: if self.min_stack: return self.min_stack[-1]"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head: ListNode) -> ListNode: Detects if there is a cycle in the linked list. If there is a cycle, returns the node where the cycle begins. Otherwise, returns None. >>> head = ListNode(3) >>> node2 = ListNode(2) >>> head.next = node2 >>> node3 = ListNode(0) >>> node2.next = node3 >>> node4 = ListNode(-4) >>> node3.next = node4 >>> node4.next = node2 >>> detectCycle(head).val 2 >>> head = ListNode(1) >>> detectCycle(head) None","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head: ListNode) -> ListNode: Detects if there is a cycle in the linked list. If there is a cycle, returns the node where the cycle begins. Otherwise, returns None. if not head or not head.next: return None slow = head fast = head # Using the Floyds Tortoise and Hare algorithm to find if there is a cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected, find the entry point of the cycle entry = head while slow != entry: slow = slow.next entry = entry.next return entry return None"},{"question":"def longest_subsequence(arr: List[int], d: int) -> int: Given an integer array \`arr\` and an integer \`d\`, return the length of the longest possible subsequence that can be chosen such that the absolute difference between any two consecutive elements in the subsequence is less than or equal to \`d\`. >>> longest_subsequence([5], 10) 1 >>> longest_subsequence([1, 2, 3, 4], 1) 4 >>> longest_subsequence([1, 10, 20, 30], 1) 1 >>> longest_subsequence([8, 5, 6, 9], 3) 4 >>> longest_subsequence([1, 3, 5, 7, 9], 2) 5 >>> longest_subsequence([10, 8, 6, 4, 2], 2) 5 >>> longest_subsequence([], 1) 0 >>> longest_subsequence([1, 100], 99) 2","solution":"def longest_subsequence(arr, d): if not arr: return 0 n = len(arr) dp = [1] * n # dp[i] is the length of longest subsequence ending at index i for i in range(1, n): for j in range(i): if abs(arr[i] - arr[j]) <= d: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def count_visible_buildings(arr: List[int]) -> int: Returns the number of visible buildings from right to left. A building is deemed visible if there are no taller buildings to its right. The rightmost building is always visible. Args: arr (list): List of integers where each integer represents the height of a building. Returns: int: Number of visible buildings. >>> count_visible_buildings([1, 2, 3, 4, 5]) 1 >>> count_visible_buildings([]) 0 >>> count_visible_buildings([3, 3, 3, 3, 3]) 1 >>> count_visible_buildings([1, 3, 2, 4, 2]) 2 >>> count_visible_buildings([5, 4, 3, 2, 1]) 5 >>> count_visible_buildings([7]) 1 >>> count_visible_buildings([10, 3, 7, 1, 4, 2, 4, 6]) 3","solution":"def count_visible_buildings(arr): Returns the number of visible buildings from right to left. Args: arr (list): List of integers where each integer represents the height of a building. Returns: int: Number of visible buildings. count = 0 max_height = float('-inf') for height in reversed(arr): if height > max_height: count += 1 max_height = height return count"},{"question":"def remove_duplicates(nums): Removes duplicates in-place in the sorted array nums and returns the number of unique elements. Args: nums (List[int]): A list of integers sorted in non-decreasing order. Returns: int: The number of unique elements that remain. Examples: >>> nums = [1, 1, 2] >>> remove_duplicates(nums) 2 >>> nums[:2] [1, 2] >>> nums = [0,0,1,1,1,2,2,3,3,4] >>> remove_duplicates(nums) 5 >>> nums[:5] [0, 1, 2, 3, 4]","solution":"def remove_duplicates(nums): Removes duplicates in-place in the sorted array nums and returns the number of unique elements. Args: nums (List[int]): A list of integers sorted in non-decreasing order. Returns: int: The number of unique elements that remain. if not nums: return 0 unique_count = 1 # start with the first element which is always unique for i in range(1, len(nums)): if nums[i] != nums[unique_count - 1]: nums[unique_count] = nums[i] unique_count += 1 return unique_count"},{"question":"from typing import List def get_skyline(heights: List[int]) -> List[List[int]]: You are given an array of integers \`heights\` representing the height of buildings in a row. The task is to identify the **skyline contour** formed by these buildings. The **skyline** is represented by a list of \\"key points\\" in the format \`[x, y]\` where \`x\` is the x-coordinate of a key point and \`y\` is the height at that point. The key points should form a stair-like outline of the buildings when viewed from a distance. The highest points should create the contour, while changes in height and the start/end of buildings should be captured. Return *the \`skyline\` of the row of buildings in the form of a list of key points sorted by their x-coordinates*. >>> get_skyline([1]) [[0, 1], [1, 0]] >>> get_skyline([3, 3, 3]) [[0, 3], [3, 0]] >>> get_skyline([2, 3, 4]) [[0, 2], [1, 3], [2, 4], [3, 0]] >>> get_skyline([1, 3, 2, 4]) [[0, 1], [1, 3], [2, 2], [3, 4], [4, 0]] >>> get_skyline([3, 2, 3, 1, 5, 2, 1]) [[0, 3], [1, 2], [2, 3], [3, 1], [4, 5], [5, 2], [6, 1], [7, 0]] >>> get_skyline([]) [] pass","solution":"def get_skyline(heights): Returns the skyline contour formed by a list of building heights. if not heights: return [] skyline = [] max_height = 0 for i, height in enumerate(heights): if height != max_height: skyline.append([i, height]) max_height = height # Append the point where the last building ends skyline.append([len(heights), 0]) return skyline"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_path_sum(root: TreeNode) -> int: Identify the largest sum of node values in any of the root-to-leaf paths in a binary tree. Return the largest sum you can obtain within such a path. >>> root = TreeNode(10) >>> root.left = TreeNode(20) >>> root.right = TreeNode(5) >>> max_path_sum(root) 30 >>> root = TreeNode(10) >>> root.left = TreeNode(30) >>> root.left.left = TreeNode(50) >>> root.left.right = TreeNode(40) >>> max_path_sum(root) 90 >>> root = TreeNode(10) >>> max_path_sum(root) 10","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_path_sum(root): def helper(node): if not node: return 0 left_sum = helper(node.left) right_sum = helper(node.right) return node.val + max(left_sum, right_sum) return helper(root)"},{"question":"def max_sum_subarray(nums: List[int], k: int) -> int: Returns the maximum sum of a subarray of length k. If k is larger than the length of the array, returns 0. >>> max_sum_subarray([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) == 24 >>> max_sum_subarray([1, -2, 3, 4, -5, 6, 7, 8, 9, 10], 4) == 34 >>> max_sum_subarray([1], 1) == 1 >>> max_sum_subarray([1, 2, 3], 4) == 0 >>> max_sum_subarray([], 2) == 0 >>> max_sum_subarray([5, 5, 5, 5, 5], 2) == 10 >>> max_sum_subarray([5, 5, 5, 5, 5], 3) == 15 >>> max_sum_subarray([0, 0, 0, 0, 0], 3) == 0 >>> max_sum_subarray([-1, -2, -3, -4, -5], 2) == -3","solution":"def max_sum_subarray(nums, k): Returns the maximum sum of a subarray of length k. If k is larger than the length of the array, returns 0. n = len(nums) if k > n: return 0 # Calculate the sum of the first subarray of length k max_sum = sum(nums[:k]) current_sum = max_sum # Use sliding window to find maximum sum of subarray of length k for i in range(k, n): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def serialize_preorder(root: TreeNode) -> str: Serialize the binary tree into a string using pre-order traversal (Node -> Left Subtree -> Right Subtree). If the tree is empty, return an empty string. >>> serialize_preorder(None) == \\"\\" >>> serialize_preorder(TreeNode(1)) == \\"1\\" >>> serialize_preorder(TreeNode(1, TreeNode(2, TreeNode(3)))) == \\"1,2,3\\" >>> serialize_preorder(TreeNode(1, TreeNode(2), TreeNode(3))) == \\"1,2,3\\" >>> serialize_preorder(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6)))) == \\"1,2,4,5,3,6\\"","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def serialize_preorder(root): if not root: return \\"\\" result = [] def preorder(node): if node: result.append(str(node.value)) preorder(node.left) preorder(node.right) preorder(root) return \\",\\".join(result)"},{"question":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths for a robot to move from the top-left corner to the bottom-right corner of a grid with \`m\` rows and \`n\` columns. The robot can only move either down or right at any point in time. Args: m (int): Number of rows in the grid. n (int): Number of columns in the grid. Returns: int: Number of unique paths to reach the bottom-right corner. >>> unique_paths(2, 2) 2 >>> unique_paths(3, 3) 6 >>> unique_paths(3, 2) 3 >>> unique_paths(2, 3) 3 >>> unique_paths(1, 1) 1 >>> unique_paths(1, 5) 1 >>> unique_paths(5, 1) 1 >>> unique_paths(20, 20) 35345263800","solution":"def unique_paths(m, n): Calculate the number of unique paths for a robot to move from the top-left corner to the bottom-right corner of a grid with m rows and n columns. The robot can only move either down or right at any point in time. Args: m (int): Number of rows in the grid. n (int): Number of columns in the grid. Returns: int: Number of unique paths to reach the bottom-right corner. # Create a 2D array (list of lists) with m rows and n columns initialized to 1 dp = [[1] * n for _ in range(m)] # Start from cell (1, 1) and fill the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] # The bottom-right corner will have the answer return dp[m - 1][n - 1]"},{"question":"from typing import List def shortest_path(matrix: List[List[int]], k: int) -> int: Given a 2D grid matrix of size m x n consisting of non-negative integers, determine the length of the shortest path from the top-left cell (0, 0) to the bottom-right cell (m-1, n-1) such that the sum of all elements along the path is less than or equal to k. You can only move either down or right at any point in time. If there is no such path, return -1. >>> shortest_path([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 21) 5 >>> shortest_path([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 15) -1 >>> shortest_path([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 28) 5 >>> shortest_path([[10]], 10) 1 >>> shortest_path([[10]], 5) -1 >>> shortest_path([[1, 10, 20, 30], [1, 10, 20, 30], [1, 1, 1, 1], [50, 50, 50, 1]], 40) 7","solution":"from collections import deque def shortest_path(matrix, k): Determines the shortest path from the top-left cell to the bottom-right cell such that the sum of the path is less than or equal to k. if not matrix or not matrix[0]: return -1 m, n = len(matrix), len(matrix[0]) directions = [(0, 1), (1, 0)] queue = deque([(0, 0, matrix[0][0], 1)]) visited = set([(0, 0, matrix[0][0])]) while queue: x, y, current_sum, path_length = queue.popleft() if x == m - 1 and y == n - 1: if current_sum <= k: return path_length for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: next_sum = current_sum + matrix[nx][ny] if next_sum <= k and (nx, ny, next_sum) not in visited: visited.add((nx, ny, next_sum)) queue.append((nx, ny, next_sum, path_length + 1)) return -1"},{"question":"def min_moves_with_positive_slope(points: List[List[int]]) -> int: Returns the minimum number of moves required to move from the first point to the last point in the array, visiting each point in the order given with only positive slope allowed. >>> min_moves_with_positive_slope([[1, 2], [2, 3], [3, 4]]) 2 >>> min_moves_with_positive_slope([[1, 2], [2, 3], [3, 2]]) -1 >>> min_moves_with_positive_slope([[1, 2]]) 0 >>> min_moves_with_positive_slope([[1, 2], [2, 3]]) 1 >>> min_moves_with_positive_slope([[2, 3], [1, 2]]) -1 >>> min_moves_with_positive_slope([[i, i+1] for i in range(1, 101)]) 99 >>> min_moves_with_positive_slope([[1, 2], [1, 3], [2, 1], [3, 4]]) -1","solution":"def min_moves_with_positive_slope(points): Returns the minimum number of moves required to move from the first point to the last point in the array, visiting each point in the order given with only positive slope allowed. n = len(points) moves = 0 for i in range(n - 1): if points[i+1][0] > points[i][0] and points[i+1][1] > points[i][1]: moves += 1 else: return -1 return moves"},{"question":"def trapRainWater(height: List[int]) -> int: Given a list of integers representing the heights of buildings, calculate how much water can be trapped between the buildings after it rains. :param height: List[int] - List of non-negative integers representing the heights of the buildings. :return: int - Total amount of rainwater trapped. pass # Implement the function here # Test cases def test_trapRainWater(): assert trapRainWater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 assert trapRainWater([4, 2, 0, 3, 2, 5]) == 9 assert trapRainWater([0, 0, 0, 0]) == 0 assert trapRainWater([3, 0, 2, 0, 4]) == 7 assert trapRainWater([0, 1, 0, 1, 0]) == 1 assert trapRainWater([5, 4, 1, 2]) == 1 assert trapRainWater([]) == 0 assert trapRainWater([1, 2, 1]) == 0 assert trapRainWater([2, 0, 2]) == 2","solution":"def trapRainWater(height): Given a list of integers representing the heights of buildings, calculate how much water can be trapped between the buildings after it rains. :param height: List[int] - List of non-negative integers representing the heights of the buildings. :return: int - Total amount of rainwater trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"def maxAreaOfIsland(grid): Given a m x n grid of '0's (water) and '1's (land), returns the maximum area of an island in the grid. An island is a connected component of '1's formed by traversing north, south, east, and west. >>> grid = [ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ] >>> maxAreaOfIsland(grid) 0 >>> grid = [ ... [0, 1, 0, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0] ... ] >>> maxAreaOfIsland(grid) 3 >>> grid = [ ... [1, 1, 0, 0], ... [0, 1, 0, 1], ... [1, 0, 1, 1] ... ] >>> maxAreaOfIsland(grid) 3 >>> grid = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> maxAreaOfIsland(grid) 9 >>> grid = [ ... [1, 0, 0, 1], ... [0, 1, 0, 0], ... [1, 0, 1, 1], ... [0, 0, 0, 1] ... ] >>> maxAreaOfIsland(grid) 3","solution":"def maxAreaOfIsland(grid): Given a m x n grid of '0's (water) and '1's (land), returns the maximum area of an island in the grid. An island is a connected component of '1's formed by traversing north, south, east, and west. def dfs(x, y): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0: return 0 grid[x][y] = 0 area = 1 area += dfs(x - 1, y) area += dfs(x + 1, y) area += dfs(x, y - 1) area += dfs(x, y + 1) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"from typing import List def can_split_into_two_increasing_subsequences(nums: List[int]) -> bool: Determine if it is possible to split the array into two subsequences such that each subsequence is strictly increasing. >>> can_split_into_two_increasing_subsequences([1, 3, 5, 2, 2, 7, 6]) == False >>> can_split_into_two_increasing_subsequences([1, 2, 3, 4, 5]) == True >>> can_split_into_two_increasing_subsequences([5, 4, 3, 2, 1]) == False >>> can_split_into_two_increasing_subsequences([1, 2, 2, 3, 4, 5]) == True >>> can_split_into_two_increasing_subsequences([1]) == True","solution":"from collections import defaultdict def can_split_into_two_increasing_subsequences(nums): Returns True if nums can be split into two strictly increasing subsequences, else False. # Dictionary to store frequency of each number frequency = defaultdict(int) for num in nums: frequency[num] += 1 tails = [] # List to store end elements of increasing subsequences for num in nums: # Add new subsequence or extend if possible found = False for i in range(len(tails)): if tails[i] < num: tails[i] = num found = True break if not found: tails.append(num) if len(tails) > 2: return False return True"},{"question":"def min_stack_height_difference(arr: List[int]) -> int: You are given an integer array \`arr\` of length \`n\` representing the height of \`n\` stacked boxes. The height of a stack is the sum of the heights of individual boxes within that stack. You can separate or merge boxes to form a different configuration. The goal is to minimize the difference between the heights of the tallest and shortest stacks after re-arranging any number of boxes. Return the minimum possible difference between the height of the tallest and the shortest stacks. >>> min_stack_height_difference([5]) 5 >>> min_stack_height_difference([4, 4]) 0 >>> min_stack_height_difference([1, 2, 3]) 0 >>> min_stack_height_difference([3, 1, 4, 2, 2]) 0 >>> min_stack_height_difference([1, 2, 3, 6]) 0 >>> min_stack_height_difference([1, 1, 1, 1, 100]) 96","solution":"def min_stack_height_difference(arr): total_sum = sum(arr) n = len(arr) dp = [False] * (total_sum // 2 + 1) dp[0] = True for num in arr: for j in range(total_sum // 2, num - 1, -1): if dp[j - num]: dp[j] = True for i in range(total_sum // 2, -1, -1): if dp[i]: s1 = i break s2 = total_sum - s1 return abs(s2 - s1)"},{"question":"def calculate(s: str) -> int: Evaluates the string s which is a basic arithmetic expression containing only non-negative integers, +, -, *, / operators, and empty spaces. The integer division should truncate toward zero. Return the result of evaluating the expression. >>> calculate(\\"3+2\\") 5 >>> calculate(\\" 3+5 / 2 \\") 5 >>> calculate(\\"3+2*2\\") 7 >>> calculate(\\"3/2\\") 1 >>> calculate(\\"3+2*2-8/4\\") 5 >>> calculate(\\"42\\") 42 >>> calculate(\\" 12 + 3 \\") 15 >>> calculate(\\"14/3*2\\") 8 >>> calculate(\\"1+2*5/3+6/4*2\\") 6","solution":"def calculate(s): Evaluates the string s which is a basic arithmetic expression containing only non-negative integers, +, -, *, / operators, and empty spaces. The integer division should truncate toward zero. # This is a stack-based approach num, stack, sign = 0, [], \\"+\\" s += \\"+0\\" for c in s: if c.isdigit(): num = num * 10 + int(c) elif c in \\"+-*/\\": if sign == \\"+\\": stack.append(num) elif sign == \\"-\\": stack.append(-num) elif sign == \\"*\\": stack.append(stack.pop() * num) elif sign == \\"/\\": stack.append(int(stack.pop() / num)) sign = c num = 0 return sum(stack)"},{"question":"import heapq class MinHeap: MinHeap is a class for a minimum heap data structure where the smallest element can be retrieved and deleted efficiently. def __init__(self): Initializes the MinHeap object. self.heap = [] def insert(self, x: int): Inserts element x into the heap. :param x: integer to be inserted into the heap pass def deleteMin(self) -> int: Removes and returns the minimum element from the heap. :return: the minimum element from the heap pass def getMin(self) -> int: Returns the minimum element from the heap without removing it. :return: the minimum element from the heap pass # Unit tests def test_insert(): min_heap = MinHeap() min_heap.insert(5) assert min_heap.getMin() == 5 min_heap.insert(3) assert min_heap.getMin() == 3 min_heap.insert(7) assert min_heap.getMin() == 3 min_heap.insert(1) assert min_heap.getMin() == 1 def test_deleteMin(): min_heap = MinHeap() min_heap.insert(5) min_heap.insert(3) min_heap.insert(7) min_heap.insert(1) assert min_heap.deleteMin() == 1 assert min_heap.getMin() == 3 assert min_heap.deleteMin() == 3 assert min_heap.getMin() == 5 assert min_heap.deleteMin() == 5 assert min_heap.getMin() == 7 assert min_heap.deleteMin() == 7 def test_getMin_empty_heap(): min_heap = MinHeap() try: min_heap.getMin() except IndexError: assert True def test_deleteMin_empty_heap(): min_heap = MinHeap() try: min_heap.deleteMin() except IndexError: assert True","solution":"import heapq class MinHeap: def __init__(self): Initializes the MinHeap object. self.heap = [] def insert(self, x: int): Inserts element x into the heap. :param x: integer to be inserted into the heap heapq.heappush(self.heap, x) def deleteMin(self) -> int: Removes and returns the minimum element from the heap. :return: the minimum element from the heap return heapq.heappop(self.heap) def getMin(self) -> int: Returns the minimum element from the heap without removing it. :return: the minimum element from the heap return self.heap[0]"},{"question":"def longest_prefix(words: list, s: str) -> str: Returns the longest word from the list 'words' that is a prefix of the string 's'. If there are multiple prefixes of the same maximum length, returns the first one. If no prefix matches, returns an empty string. >>> longest_prefix([\\"apple\\", \\"app\\", \\"ape\\"], \\"application\\") 'app' >>> longest_prefix([\\"cat\\", \\"concatenate\\", \\"dog\\"], \\"concatenate\\") 'concatenate' >>> longest_prefix([\\"mouse\\", \\"keyboard\\", \\"monitor\\"], \\"computer\\") '' >>> longest_prefix([], \\"computer\\") '' >>> longest_prefix([\\"ant\\", \\"an\\", \\"a\\"], \\"antony\\") 'ant' >>> longest_prefix([\\"abc\\", \\"a\\", \\"ab\\"], \\"\\") '' >>> longest_prefix([\\"\\"], \\"any\\") '' >>> longest_prefix([\\"a\\", \\"b\\", \\"c\\"], \\"a\\") 'a'","solution":"def longest_prefix(words, s): Returns the longest word from the list 'words' that is a prefix of the string 's'. If there are multiple prefixes of the same maximum length, returns the first one. If no prefix matches, returns an empty string. longest = \\"\\" for word in words: if s.startswith(word) and len(word) > len(longest): longest = word return longest"},{"question":"def min_cost_to_palindrome(s: str) -> int: Given a string s containing only lowercase English letters, return the minimum cost required to transform s into a palindrome. You can perform the following operations on any character in s: - Change s[i] to any of its neighboring characters (i.e., you can change 'a' to 'b', 'b' to either 'a' or 'c', and so on up to 'z' which can be changed to 'y'). - The cost of performing an operation on a character s[i] is defined as the absolute difference in their positions in the alphabet. Example Usages: >>> min_cost_to_palindrome(\\"ab\\") 1 >>> min_cost_to_palindrome(\\"abcd\\") 4 >>> min_cost_to_palindrome(\\"abba\\") 0 from solution import min_cost_to_palindrome def test_min_cost_to_palindrome(): assert min_cost_to_palindrome(\\"ab\\") == 1 assert min_cost_to_palindrome(\\"abc\\") == 2 assert min_cost_to_palindrome(\\"abcd\\") == 4 assert min_cost_to_palindrome(\\"abba\\") == 0 assert min_cost_to_palindrome(\\"racecar\\") == 0 assert min_cost_to_palindrome(\\"abcba\\") == 0 assert min_cost_to_palindrome(\\"az\\") == 25","solution":"def min_cost_to_palindrome(s): Given a string s containing only lowercase English letters, return the minimum cost required to transform s into a palindrome. def char_distance(c1, c2): return abs(ord(c1) - ord(c2)) n = len(s) cost = 0 for i in range(n // 2): cost += char_distance(s[i], s[n - i - 1]) return cost"},{"question":"from typing import List def count_letters(s: str) -> List[int]: Given a string \`s\` containing only lowercase English letters, return an integer array \`answer\` where \`answer\` contains the number of occurrences of each letter in the alphabet. The array should be of size 26 where \`answer[0]\` represents the count of 'a', \`answer[1]' represents the count of 'b', and so on up to \`answer[25]\` which represents the count of 'z'. >>> count_letters('a') [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] >>> count_letters('abcdefghijklmnopqrstuvwxyz') [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] >>> count_letters('aaa') [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]","solution":"def count_letters(s): Returns an array of size 26 where each element represents the number of occurrences of a corresponding lowercase English letter in the string s. \`answer[0]\` is the count of 'a', \`answer[1]\` is the count of 'b', and so on. answer = [0] * 26 for char in s: answer[ord(char) - ord('a')] += 1 return answer"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Shuffles the characters in the string \`s\` based on the given \`indices\` array. Parameters: s (str): The original string. indices (List[int]): List of indices representing the position of each character in the shuffled string. Returns: str: The shuffled string based on \`indices\`. Examples: >>> restore_string(\\"abc\\", [0, 1, 2]) 'abc' >>> restore_string(\\"abc\\", [2, 1, 0]) 'cba' >>> restore_string(\\"aiohn\\", [3, 1, 4, 2, 0]) 'nihao' >>> restore_string(\\"aabbcc\\", [5, 4, 3, 2, 1, 0]) 'ccbbaa' >>> restore_string(\\"codeleet\\", [4, 5, 6, 7, 0, 2, 1, 3]) 'leetcode' >>> restore_string(\\"z\\", [0]) 'z' >>> restore_string(\\"\\", []) ''","solution":"def restore_string(s, indices): Shuffles the characters in the string \`s\` based on the given \`indices\` array. Parameters: s (str): The original string. indices (List[int]): List of indices representing the position of each character in the shuffled string. Returns: str: The shuffled string based on \`indices\`. # Create a list of the same length as s initialized with empty strings shuffled = [''] * len(s) # Assign each character to its new position based on the indices array for i, index in enumerate(indices): shuffled[index] = s[i] # Combine the list into a single string and return return ''.join(shuffled)"},{"question":"def numDistinctIslands(grid: List[List[str]]) -> int: Returns the number of distinct islands in the grid. >>> numDistinctIslands([['W', 'W'], ['W', 'W']]) 0 >>> numDistinctIslands([['L', 'W'], ['W', 'W']]) 1 >>> numDistinctIslands([['L', 'L'], ['L', 'L']]) 1 >>> numDistinctIslands([['L', 'W', 'L'], ['W', 'L', 'W'], ['L', 'W', 'L']]) 1 >>> numDistinctIslands([['L', 'W', 'L'], ['L', 'W', 'L'], ['L', 'W', 'L']]) 1 >>> numDistinctIslands([['L', 'W', 'L', 'W'], ['L', 'L', 'W', 'W'], ['W', 'W', 'W', 'L'], ['W', 'L', 'L', 'L']]) 3 >>> numDistinctIslands([['L', 'W', 'W', 'L'], ['L', 'L', 'W', 'L'], ['W', 'W', 'W', 'L']]) 2 >>> numDistinctIslands([['L', 'L', 'L', 'W'], ['L', 'L', 'W', 'W'], ['W', 'W', 'L', 'L']]) 2","solution":"def numDistinctIslands(grid): Returns the number of distinct islands in the grid. def dfs(r, c, direction): if (0 <= r < m and 0 <= c < n and grid[r][c] == 'L' and (r, c) not in visited): visited.add((r, c)) shape.add(direction) dfs(r + 1, c, 'D') # down dfs(r - 1, c, 'U') # up dfs(r, c + 1, 'R') # right dfs(r, c - 1, 'L') # left shape.add('B') # backtracking m, n = len(grid), len(grid[0]) visited = set() unique_islands = set() for r in range(m): for c in range(n): if grid[r][c] == 'L' and (r, c) not in visited: shape = set() dfs(r, c, 'O') # origin unique_islands.add(frozenset(shape)) return len(unique_islands)"},{"question":"from typing import List def rearrange_heights(heights: List[int]) -> List[int]: Rearranges the list of heights such that no two adjacent heights differ by 1 or less. Returns an empty list if such an arrangement is not possible. >>> rearrange_heights([1, 2, 3, 4, 5]) [some valid output as any valid output can be an answer here] >>> rearrange_heights([1, 3, 5, 7, 9]) [1, 3, 5, 7, 9] >>> rearrange_heights([7]) [7] >>> rearrange_heights([4, 4, 4]) [] >>> rearrange_heights([1, 6, 4, 3]) [some valid output as any valid output can be an answer here]","solution":"def rearrange_heights(heights): Rearranges the list of heights such that no two adjacent heights differ by 1 or less. Returns an empty list if such an arrangement is not possible. heights.sort() n = len(heights) if n < 2: return heights for i in range(1, n): if heights[i] - heights[i-1] <= 1: break else: return heights left, right = heights[:n // 2], heights[n // 2:] rearranged = [] for r, l in zip(right, left): rearranged.append(r) rearranged.append(l) if n % 2 == 1: rearranged.append(right[-1]) for i in range(1, len(rearranged)): if abs(rearranged[i] - rearranged[i-1]) <= 1: return [] return rearranged"},{"question":"from collections import Counter import heapq class Solution: def __init__(self, s: str, k: int): Initialize the object with the string s and the integer k. self.s = s self.k = k def rearrange(self) -> str: Determine if you can rearrange the characters in s such that the same characters are at least k distance apart. If it is possible, return any one of the possible rearrangements. If it is not possible, return an empty string. def test_rearrange_possible(): sol = Solution(\\"aabbcc\\", 2) result = sol.rearrange() assert sorted(result) == sorted(\\"aabbcc\\") and all(result[i] != result[i+2] for i in range(len(result)-2)) def test_rearrange_possible_small_k(): sol = Solution(\\"aabbcc\\", 1) result = sol.rearrange() assert sorted(result) == sorted(\\"aabbcc\\") def test_rearrange_impossible(): sol = Solution(\\"aaabc\\", 3) result = sol.rearrange() assert result == \\"\\" def test_rearrange_single_char(): sol = Solution(\\"aaaaa\\", 2) result = sol.rearrange() assert result == \\"\\" # impossible to rearrange def test_rearrange_k_zero(): sol = Solution(\\"aabbcc\\", 0) result = sol.rearrange() assert result == \\"aabbcc\\" def test_rearrange_different_chars(): sol = Solution(\\"abcdef\\", 3) result = sol.rearrange() assert sorted(result) == sorted(\\"abcdef\\") and all(result[i] != result[i+3] for i in range(len(result)-3, 3, -1)) def test_rearrange_equal_k_and_length(): sol = Solution(\\"abc\\", 3) result = sol.rearrange() assert sorted(result) == sorted(\\"abc\\")","solution":"import heapq from collections import Counter class Solution: def __init__(self, s, k): self.s = s self.k = k def rearrange(self): if self.k == 0: return self.s count = Counter(self.s) max_heap = [(-freq, char) for char, freq in count.items()] heapq.heapify(max_heap) result = [] queue = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) queue.append((char, freq + 1)) if len(queue) >= self.k: front = queue.pop(0) if -front[1] > 0: heapq.heappush(max_heap, (front[1], front[0])) if len(result) != len(self.s): return \\"\\" return \\"\\".join(result)"},{"question":"def can_transform_to_palindrome(s: str, n: int) -> bool: Determines if the string \`s\` can be transformed into a palindrome by inserting exactly \`n\` characters. >>> can_transform_to_palindrome(\\"abca\\", 1) True >>> can_transform_to_palindrome(\\"abc\\", 2) True >>> can_transform_to_palindrome(\\"abc\\", 1) False >>> can_transform_to_palindrome(\\"abcd\\", 3) True >>> can_transform_to_palindrome(\\"a\\", 0) True >>> can_transform_to_palindrome(\\"racecar\\", 0) True >>> can_transform_to_palindrome(\\"racecar\\", 1) False >>> can_transform_to_palindrome(\\"aebcbda\\", 2) True >>> can_transform_to_palindrome(\\"abcde\\", 4) True >>> can_transform_to_palindrome(\\"abcdefgh\\", 8) False","solution":"def can_transform_to_palindrome(s, n): Determines if the string \`s\` can be transformed into a palindrome by inserting exactly \`n\` characters. Args: s (str): The input string. n (int): The number of characters to be inserted. Returns: bool: True if the string can be transformed into a palindrome by inserting \`n\` characters, otherwise False. def longest_palindromic_subsequence_length(s): Helper function to find the length of the longest palindromic subsequence in a given string. l = len(s) dp = [[0] * l for _ in range(l)] for i in range(l): dp[i][i] = 1 for cl in range(2, l + 1): for i in range(l - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][l-1] lps_length = longest_palindromic_subsequence_length(s) min_insertions = len(s) - lps_length return min_insertions == n"},{"question":"def single_number(arr: List[int]) -> int: Find the element that appears only once in an array where every other element appears exactly three times. Args: arr: List[int] - a list of integers Returns: int - the integer that appears exactly once >>> single_number([2, 2, 3, 2]) 3 >>> single_number([0, 1, 0, 1, 0, 1, 99]) 99 >>> single_number([30000, 500, 100, 30000, 100, 30000, 100, 500, 500, -100000]) -100000 >>> single_number([0, 0, 0, -1]) -1 >>> single_number([1]*3000000 + [2]) 2","solution":"def single_number(arr): Find the element that appears only once in an array where every other element appears exactly three times. Args: arr: List[int] - a list of integers Returns: int - the integer that appears exactly once ones, twos = 0, 0 for num in arr: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"def max_sum_subarray(nums: List[int], k: int) -> Union[int, None]: Returns the maximum sum of a subarray of length exactly k. If no such subarray exists, return None. >>> max_sum_subarray([1, 2, 3, 4, 5], 2) 9 >>> max_sum_subarray([-1, -2, -3, -4, -5], 2) -3 >>> max_sum_subarray([100, 200, 300, 400], 2) 700 >>> max_sum_subarray([1, -1, 1, -1, 1], 3) 1 >>> max_sum_subarray([1, 2], 2) 3 >>> max_sum_subarray([1], 1) 1 >>> max_sum_subarray([], 1) None >>> max_sum_subarray([1, 2, 3], 0) None >>> max_sum_subarray([1, 2, 3], 4) None","solution":"def max_sum_subarray(nums, k): Returns the maximum sum of a subarray of length exactly k. If no such subarray exists, return None. n = len(nums) if k > n or k < 1: return None max_sum = float('-inf') current_sum = sum(nums[:k]) max_sum = max(max_sum, current_sum) for i in range(k, n): current_sum = current_sum + nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Restores the shuffled string according to the provided indices. Parameters: s (str): The input string. indices (list of int): The list of indices indicating the new positions of characters. Returns: str: The restored string. >>> restore_string(\\"codeleet\\", [4,5,6,7,0,2,1,3]) == \\"leetcode\\" >>> restore_string(\\"a\\", [0]) == \\"a\\" >>> restore_string(\\"\\", []) == \\"\\" >>> restore_string(\\"abc\\", [0, 1, 2]) == \\"abc\\" >>> restore_string(\\"abc\\", [2, 1, 0]) == \\"cba\\" >>> restore_string(\\"abcde\\", [4, 3, 2, 1, 0]) == \\"edcba\\"","solution":"def restore_string(s, indices): Restores the shuffled string according to the provided indices. Parameters: s (str): The input string. indices (list of int): The list of indices indicating the new positions of characters. Returns: str: The restored string. shuffled = [''] * len(s) for i, index in enumerate(indices): shuffled[index] = s[i] return ''.join(shuffled)"},{"question":"def single_number(nums: List[int]) -> int: Given a non-empty array of integers \`nums\`, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space. >>> single_number([4]) 4 >>> single_number([4, 1, 2, 1, 2]) 4 >>> single_number([2, 2, 3, 4, 4]) 3 >>> single_number([100000, 99999, 99999, 100000, -1]) -1 >>> single_number([-1, -1, -2, -2, 5]) 5","solution":"def single_number(nums): Returns the element that appears only once in the array. result = 0 for num in nums: result ^= num return result"},{"question":"def min_subarray_len(nums: List[int], goal: int) -> int: Returns the minimum length of a contiguous subarray with a sum exactly equal to goal. If no such subarray exists, returns -1. >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 1, 1, 1, 1, 1, 1], 10) -1 >>> min_subarray_len([5], 5) 1 >>> min_subarray_len([1, 2, 3, 4], 10) 4 >>> min_subarray_len([1, 2, 3, 4, 2, 4], 6) 2 >>> min_subarray_len([], 7) -1","solution":"def min_subarray_len(nums, goal): Returns the minimum length of a contiguous subarray with a sum exactly equal to goal. If no such subarray exists, returns -1. n = len(nums) min_length = float('inf') current_sum = 0 left = 0 for right in range(n): current_sum += nums[right] while current_sum >= goal: if current_sum == goal: min_length = min(min_length, right - left + 1) current_sum -= nums[left] left += 1 return min_length if min_length != float('inf') else -1"},{"question":"import heapq class MedianFinder: Design a data structure that supports adding integers to a collection and querying for the median integer efficiently. The median of a collection is the middle value if the size of the collection is odd, or the average of the two middle values if the size is even. Methods: MedianFinder() initializes an empty MedianFinder object. void addNum(int num) adds an integer \`num\` to the data structure. double findMedian() returns the median of all integers added so far. Examples: >>> mf = MedianFinder() >>> mf.addNum(1) >>> mf.findMedian() 1.0 >>> mf.addNum(2) >>> mf.findMedian() 1.5 >>> mf.addNum(3) >>> mf.findMedian() 2.0 def __init__(self): self.low = [] # max heap (inverted min-heap) self.high = [] # min heap def addNum(self, num: int) -> None: pass def findMedian(self) -> float: pass","solution":"import heapq class MedianFinder: def __init__(self): self.low = [] # max heap (inverted min-heap) self.high = [] # min heap def addNum(self, num: int) -> None: if len(self.low) == len(self.high): heapq.heappush(self.low, -heapq.heappushpop(self.high, num)) else: heapq.heappush(self.high, -heapq.heappushpop(self.low, -num)) def findMedian(self) -> float: if len(self.low) > len(self.high): return -self.low[0] return (-self.low[0] + self.high[0]) / 2.0"},{"question":"def shortest_path_to_target(grid): You are given an m x n 2D grid \`grid\` of integers. Each cell can either contain a value \`0\` (representing an empty cell), \`1\` (representing an obstacle), or \`2\` (representing a target). Starting from the top-left corner of the grid, find the shortest path to any target (a cell with value \`2\`). You can move up, down, left, or right, and cannot visit cells more than once. If there is no such path, return -1. Return the length of this shortest path. >>> grid = [ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 2] ... ] >>> shortest_path_to_target(grid) 4 >>> grid = [ ... [2, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> shortest_path_to_target(grid) 0 >>> grid = [ ... [0, 0, 0], ... [0, 2, 0], ... [0, 0, 0] ... ] >>> shortest_path_to_target(grid) 2","solution":"from collections import deque def shortest_path_to_target(grid): if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) visited = [[False] * cols for _ in range(rows)] directions = [(-1,0),(1,0),(0,-1),(0,1)] queue = deque([(0, 0, 0)]) # (x, y, steps) visited[0][0] = True if grid[0][0] == 2: return 0 while queue: x, y, steps = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and grid[nx][ny] != 1: if grid[nx][ny] == 2: return steps + 1 visited[nx][ny] = True queue.append((nx, ny, steps + 1)) return -1"},{"question":"def product_except_self(arr): Return an array where each element is the product of all the elements of the input array except the one at the same index. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([5]) [1] >>> product_except_self([2, 3]) [3, 2] >>> product_except_self([1000, 2000, 3000, 4000]) [24000000000, 12000000000, 8000000000, 6000000000]","solution":"def product_except_self(arr): Return an array where each element is the product of all the elements of the input array except the one at the same index. n = len(arr) result = [1] * n # Fill result array with products of elements to the left of each index left_product = 1 for i in range(n): result[i] = left_product left_product *= arr[i] # Multiply with the product of elements to the right of each index right_product = 1 for i in range(n - 1, -1, -1): result[i] *= right_product right_product *= arr[i] return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isBalanced(root): Determine if the binary tree is height-balanced. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(6) >>> root.left.right.left = TreeNode(7) >>> isBalanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> isBalanced(root) False >>> isBalanced(None) True >>> root = TreeNode(1) >>> isBalanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.left.left = TreeNode(5) >>> root.right.right = TreeNode(6) >>> isBalanced(root) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isBalanced(root): def check(root): if not root: return 0, True left_depth, left_balanced = check(root.left) right_depth, right_balanced = check(root.right) if not left_balanced or not right_balanced: return 0, False if abs(left_depth - right_depth) > 1: return 0, False return max(left_depth, right_depth) + 1, True _, balanced = check(root) return balanced"},{"question":"from typing import List def max_path_value(mat: List[List[int]]) -> int: Returns the maximum value in a path from the top-left corner to the bottom-right corner where each cell value in the path is greater than or equal to the value in the previous cell. If no valid path exists, return -1. >>> max_path_value([[1, 2, 4], [2, 2, 1], [3, 3, 5]]) 5 >>> max_path_value([[1, 2, 3, 4, 5]]) 5 >>> max_path_value([[1], [2], [3], [4], [5]]) 5 >>> max_path_value([[5, 4, 3], [6, 5, 5], [7, 6, 2]]) -1 >>> max_path_value([[1, 3, 2], [2, 4, 5], [2, 5, 8]]) 8 >>> max_path_value([[10]]) 10 >>> max_path_value([[1, 2]]) 2 >>> max_path_value([[2, 1]]) -1","solution":"def max_path_value(mat): Returns the maximum value in a path from the top-left corner to the bottom-right corner where each cell value in the path is greater than or equal to the value in the previous cell. if not mat or not mat[0]: return -1 m, n = len(mat), len(mat[0]) dp = [[-1] * n for _ in range(m)] dp[0][0] = mat[0][0] for i in range(m): for j in range(n): if i > 0 and dp[i-1][j] != -1 and mat[i][j] >= mat[i-1][j]: dp[i][j] = max(dp[i][j], mat[i][j]) if j > 0 and dp[i][j-1] != -1 and mat[i][j] >= mat[i][j-1]: dp[i][j] = max(dp[i][j], mat[i][j]) return dp[-1][-1]"},{"question":"def min_insertions(s: str) -> int: Return the minimum number of insertions required to form a valid string containing at least one of 'abc', 'bac', or 'cab'. >>> min_insertions(\\"abc\\") 0 >>> min_insertions(\\"ab\\") 1 >>> min_insertions(\\"a\\") 2 >>> min_insertions(\\"\\") 3 >>> min_insertions(\\"aabbcc\\") 0 >>> min_insertions(\\"aaaaaa\\") 2","solution":"def min_insertions(s): Return the minimum number of insertions required to form a valid string. from collections import Counter def contains_pattern(pattern, counter): Check if all characters in the pattern exist in the given counter. return all(counter[char] > 0 for char in pattern) min_insertions_needed = float('inf') patterns = [\\"abc\\", \\"bac\\", \\"cab\\"] for pattern in patterns: counter = Counter(s) insertions_needed = 0 for char in pattern: if counter[char] == 0: insertions_needed += 1 else: counter[char] -= 1 min_insertions_needed = min(min_insertions_needed, insertions_needed) return min_insertions_needed"},{"question":"from collections import OrderedDict class LruCache: LRU Cache class, which stands for Least Recently Used Cache. The implementation supports two methods: - \`LruCache(int capacity)\`: Initialize the LRU cache with a positive size \`capacity\`. - \`int get(int key)\`: Return the value of the key if the key exists in the cache, otherwise return -1. - \`void put(int key, int value)\`: Update or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item. Example: lru = LruCache(2) lru.put(1, 1) lru.put(2, 2) lru.get(1) # returns 1 lru.put(3, 3) # evicts key 2 lru.get(2) # returns -1 (not found) lru.put(4, 4) # evicts key 1 lru.get(1) # returns -1 (not found) lru.get(3) # returns 3 lru.get(4) # returns 4 def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass def test_lru_cache_operations(): lru = LruCache(2) lru.put(1, 1) assert lru.get(1) == 1 # Expected 1 lru.put(2, 2) assert lru.get(2) == 2 # Expected 2 lru.put(3, 3) # Evicts key 1 assert lru.get(1) == -1 # Expected -1 (not found) lru.put(4, 4) # Evicts key 2 assert lru.get(2) == -1 # Expected -1 (not found) assert lru.get(3) == 3 # Expected 3 assert lru.get(4) == 4 # Expected 4 def test_lru_cache_overwrite(): lru = LruCache(2) lru.put(1, 1) lru.put(2, 2) lru.put(1, 10) # Overwrite key 1 assert lru.get(1) == 10 # Expected 10 lru.put(3, 3) # Evicts key 2 assert lru.get(2) == -1 # Expected -1 (not found) assert lru.get(3) == 3 # Expected 3 assert lru.get(1) == 10 # Expected 10 def test_lru_cache_gets_and_puts(): lru = LruCache(3) lru.put(1, 1) lru.put(2, 2) lru.put(3, 3) lru.get(1) # Access to make key 1 most recently used lru.put(4, 4) # Evicts key 2 assert lru.get(1) == 1 # Expected 1 assert lru.get(2) == -1 # Expected -1 (not found) assert lru.get(3) == 3 # Expected 3 assert lru.get(4) == 4 # Expected 4","solution":"from collections import OrderedDict class LruCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Calculate the maximum profit from buying and selling stocks multiple times. :param prices: List of daily stock prices :return: The maximum profit achievable >>> max_profit([7, 1, 5, 3, 6, 4]) 7 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([5, 4, 3, 2, 1]) 0 >>> max_profit([1, 2, 1, 2, 1, 2]) 3 >>> max_profit([1]) 0 >>> max_profit([]) 0","solution":"def max_profit(prices): Calculate the maximum profit from buying and selling stocks multiple times. :param prices: List of daily stock prices :return: The maximum profit achievable profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: profit += prices[i] - prices[i - 1] return profit"},{"question":"def longest_path_dag(n: int, edges: List[List[int]]) -> int: Find the length of the longest path in a directed acyclic graph (DAG) with n nodes. >>> longest_path_dag(6, [[1, 2, 3], [3], [3], [4], [5], []]) == 4 >>> longest_path_dag(1, [[]]) == 0 >>> longest_path_dag(2, [[], []]) == 0 >>> longest_path_dag(3, [[1], [2], []]) == 2 >>> longest_path_dag(5, [[1, 2], [3], [3], [4], []]) == 3 >>> longest_path_dag(4, [[], [], [], []]) == 0","solution":"def longest_path_dag(n, edges): from collections import defaultdict, deque graph = defaultdict(list) indegree = [0] * n for u in range(n): for v in edges[u]: graph[u].append(v) indegree[v] += 1 topo_order = [] queue = deque([u for u in range(n) if indegree[u] == 0]) while queue: node = queue.popleft() topo_order.append(node) for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) longest = [0] * n for u in topo_order: for v in graph[u]: longest[v] = max(longest[v], longest[u] + 1) return max(longest)"},{"question":"def find_kth_smallest(nums, k): Returns the kth smallest element from the rotated sorted array nums, using a binary search approach with O(log n) time complexity. >>> find_kth_smallest([4, 5, 6, 7, 0, 1, 2], 1) == 0 >>> find_kth_smallest([4, 5, 6, 7, 0, 1, 2], 4) == 4 >>> find_kth_smallest([4, 5, 6, 7, 0, 1, 2], 5) == 5 >>> find_kth_smallest([1], 1) == 1 >>> find_kth_smallest([1, 2, 3, 4, 5], 3) == 3 >>> find_kth_smallest([3, 4, 5, 1, 2], 1) == 1 >>> find_kth_smallest([3, 4, 5, 1, 2], 5) == 5 >>> find_kth_smallest([2, 3, 4, 5, 1], 1) == 1 >>> find_kth_smallest([2, 3, 4, 5, 1], 4) == 4","solution":"def find_kth_smallest(nums, k): Returns the kth smallest element from the rotated sorted array nums. def find_pivot(nums): Helper function to find the index of the smallest element, which is the pivot point of the rotated sorted array. low, high = 0, len(nums) - 1 while low < high: mid = (low + high) // 2 if nums[mid] > nums[high]: low = mid + 1 else: high = mid return low n = len(nums) pivot = find_pivot(nums) if k <= (n - pivot): return nums[pivot + k - 1] else: return nums[k - (n - pivot) - 1]"},{"question":"import math from typing import List def minimum_variance(nums: List[int]) -> float: Returns the minimum variance of the population distribution across districts. >>> math.isclose(minimum_variance([10, 10, 10, 10]), 0, rel_tol=1e-09) True >>> math.isclose(minimum_variance([5, 15]), 25, rel_tol=1e-09) True >>> math.isclose(minimum_variance([1000000, 1000001, 1000002]), 0.6666666667, rel_tol=1e-09) True >>> math.isclose(minimum_variance([42]), 0, rel_tol=1e-09) True >>> math.isclose(minimum_variance([1, 2, 3, 4, 5]), 2, rel_tol=1e-09) True >>> math.isclose(minimum_variance([10, 30]), 100.0, rel_tol=1e-09) True","solution":"import math from typing import List def minimum_variance(nums: List[int]) -> float: Returns the minimum variance of the population distribution across districts. n = len(nums) total_population = sum(nums) mean_population = math.floor(total_population / n) # Calculate variance variance = sum([(x - mean_population) ** 2 for x in nums]) / n return variance"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largestBSTSubtree(root: TreeNode) -> int: Find the largest subset of the tree nodes that forms a Binary Search Tree (BST). Return the number of nodes in this largest BST subtree. For a given node, the left child is less than the parent node and the right child is greater than the parent node. >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(15) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(8) >>> root.right.right = TreeNode(7) >>> largestBSTSubtree(root) 3 >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(15) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(8) >>> root.right.left = TreeNode(11) >>> root.right.right = TreeNode(20) >>> largestBSTSubtree(root) 7 >>> root = TreeNode(3) >>> root.left = TreeNode(2) >>> root.right = TreeNode(15) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(9) >>> root.right.left = TreeNode(10) >>> root.right.right = TreeNode(20) >>> largestBSTSubtree(root) 3","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largestBSTSubtree(root): def postorder(node): if not node: return 0, float('inf'), float('-inf'), True left_size, left_min, left_max, left_is_bst = postorder(node.left) right_size, right_min, right_max, right_is_bst = postorder(node.right) if left_is_bst and right_is_bst and left_max < node.val < right_min: return (left_size + right_size + 1), min(node.val, left_min), max(node.val, right_max), True else: return max(left_size, right_size), 0, 0, False max_size, _, _, _ = postorder(root) return max_size"},{"question":"def erase_overlap_intervals(intervals: List[List[int]]) -> int: Given a list of intervals, returns the minimum number of intervals to be removed to make the rest of the intervals non-overlapping. >>> erase_overlap_intervals([]) 0 >>> erase_overlap_intervals([[1, 2], [3, 4], [5, 6]]) 0 >>> erase_overlap_intervals([[1, 3], [2, 4], [3, 5]]) 1 >>> erase_overlap_intervals([[1, 2], [1, 2], [1, 2]]) 2 >>> erase_overlap_intervals([[1, 4], [2, 3], [3, 5]]) 1","solution":"def erase_overlap_intervals(intervals): Given a list of intervals, returns the minimum number of intervals to be removed to make the rest of the intervals non-overlapping. if not intervals: return 0 # Sort intervals by end time intervals.sort(key=lambda interval: interval[1]) # Initialize count of removed intervals remove_count = 0 # Initialize the end time of the previous interval to the minimum possible value prev_end_time = float('-inf') for start, end in intervals: if start >= prev_end_time: # No overlap prev_end_time = end else: # Overlap remove_count += 1 return remove_count"},{"question":"def can_rearrange_string(s: str) -> bool: Determines if it's possible to rearrange the string such that no two adjacent letters are the same. :param s: input string consisting only of letters 'a' and 'b'. :return: True if it's possible to rearrange the string, otherwise False. >>> can_rearrange_string(\\"aab\\") == True >>> can_rearrange_string(\\"abab\\") == True >>> can_rearrange_string(\\"aaab\\") == False >>> can_rearrange_string(\\"aaaabbbb\\") == True >>> can_rearrange_string(\\"aaaabbbbb\\") == True >>> can_rearrange_string(\\"aaaa\\") == False >>> can_rearrange_string(\\"bbbbb\\") == False >>> can_rearrange_string(\\"\\") == True # Edge case: empty string >>> can_rearrange_string(\\"a\\") == True # Edge case: single letter 'a' >>> can_rearrange_string(\\"b\\") == True # Edge case: single letter 'b'","solution":"from collections import Counter def can_rearrange_string(s): Determines if it's possible to rearrange the string such that no two adjacent letters are the same. :param s: input string consisting only of letters 'a' and 'b'. :return: True if it's possible to rearrange the string, otherwise False. # Count occurrences of 'a' and 'b' count = Counter(s) # Get the maximum count of either 'a' or 'b' max_count = max(count['a'], count['b']) # If the maximum count is more than half the length of the string (rounded up), it's impossible to rearrange if max_count > (len(s) + 1) // 2: return False return True"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root: TreeNode, k: int) -> int: Find the k-th smallest element in a BST. :param root: TreeNode - The root of the BST :param k: int - The k-th position (1-indexed) :return: int - The value of the k-th smallest element from solution import TreeNode, kth_smallest def test_kth_smallest(): # Creating the following BST # 5 # / # 3 6 # / # 2 4 # / # 1 root = TreeNode(5) root.left = TreeNode(3) root.right = TreeNode(6) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.left.left.left = TreeNode(1) assert kth_smallest(root, 1) == 1 assert kth_smallest(root, 2) == 2 assert kth_smallest(root, 3) == 3 assert kth_smallest(root, 4) == 4 assert kth_smallest(root, 5) == 5 assert kth_smallest(root, 6) == 6 # Test with single node single_node = TreeNode(10) assert kth_smallest(single_node, 1) == 10 # Test with a different tree # 7 # / # 3 10 # / / # 1 5 9 11 another_root = TreeNode(7) another_root.left = TreeNode(3) another_root.right = TreeNode(10) another_root.left.left = TreeNode(1) another_root.left.right = TreeNode(5) another_root.right.left = TreeNode(9) another_root.right.right = TreeNode(11) assert kth_smallest(another_root, 1) == 1 assert kth_smallest(another_root, 2) == 3 assert kth_smallest(another_root, 3) == 5 assert kth_smallest(another_root, 4) == 7 assert kth_smallest(another_root, 5) == 9 assert kth_smallest(another_root, 6) == 10 assert kth_smallest(another_root, 7) == 11","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Find the k-th smallest element in a BST. :param root: TreeNode - The root of the BST :param k: int - The k-th position (1-indexed) :return: int - The value of the k-th smallest element def in_order_traversal(node): if not node: return [] return in_order_traversal(node.left) + [node.val] + in_order_traversal(node.right) inorder_elements = in_order_traversal(root) return inorder_elements[k - 1] # k is 1-indexed"},{"question":"def maxDistinctChars(s: str, k: int) -> int: Returns the maximum number of distinct characters that can appear in any substring of length k of the string s. If the length of s is smaller than k, returns the number of distinct characters in the entire string. >>> maxDistinctChars(\\"abc\\", 5) 3 >>> maxDistinctChars(\\"abc\\", 2) 2 >>> maxDistinctChars(\\"aaa\\", 2) 1 >>> maxDistinctChars(\\"abcdef\\", 3) 3 >>> maxDistinctChars(\\"aaabbb\\", 3) 2 >>> maxDistinctChars(\\"abacaba\\", 3) 3 >>> maxDistinctChars(\\"abcabcabc\\", 4) 3 >>> maxDistinctChars(\\"aaaabbbbcc\\", 3) 2 >>> maxDistinctChars(\\"abcd\\", 2) 2 >>> maxDistinctChars(\\"abcd\\", 3) 3 >>> maxDistinctChars(\\"abcd\\", 4) 4 >>> maxDistinctChars(\\"\\", 3) 0 >>> maxDistinctChars(\\"a\\", 1) 1 >>> maxDistinctChars(\\"a\\", 2) 1 >>> maxDistinctChars(\\"a\\", 0) 0","solution":"def maxDistinctChars(s, k): Returns the maximum number of distinct characters that can appear in any substring of length k of the string s. If the length of s is smaller than k, returns the number of distinct characters in the entire string. if len(s) <= k: return len(set(s)) max_distinct = 0 for i in range(len(s) - k + 1): substring = s[i:i + k] distinct_chars = len(set(substring)) max_distinct = max(max_distinct, distinct_chars) return max_distinct"},{"question":"def find_pair_with_sum(nums1, nums2, target): Given two sorted arrays nums1 and nums2 of size m and n respectively, and a target integer target, returns an index pair (i, j) such that the sum of nums1[i] and nums2[j] is equal to target. >>> find_pair_with_sum([1, 2, 3], [4, 5, 6], 7) in [(0, 2), (1, 1)] True >>> find_pair_with_sum([1, 2, 3], [2, 3, 4], 5) in [(0, 2), (1, 1), (2, 0)] True >>> find_pair_with_sum([1, 2, 3], [7, 8, 9], 5) -1 >>> find_pair_with_sum([], [1, 2, 3], 3) -1 >>> find_pair_with_sum([2], [3], 5) (0, 0) >>> find_pair_with_sum([1000000, 2000000, 3000000], [4000000, 5000000, 6000000], 9000000) (2, 2)","solution":"def find_pair_with_sum(nums1, nums2, target): Given two sorted arrays nums1 and nums2 of size m and n respectively, and a target integer target, returns an index pair (i, j) such that the sum of nums1[i] and nums2[j] is equal to target. If no such pair exists, returns -1. i, j = 0, len(nums2) - 1 while i < len(nums1) and j >= 0: current_sum = nums1[i] + nums2[j] if current_sum == target: return (i, j) elif current_sum < target: i += 1 else: j -= 1 return -1"},{"question":"class Node: def __init__(self, val=0, next=None, random=None): self.val = val self.next = next self.random = random def copy_random_list(head): Create a deep copy of a linked list where each node contains an extra random pointer. Args: head (Node): Head of the linked list to be copied. Returns: Node: Head of the copied linked list. >>> node1 = Node(1) >>> node2 = Node(2) >>> node1.next = node2 >>> node1.random = node2 >>> node2.random = node1 >>> copied = copy_random_list(node1) >>> copied.val == 1 True >>> copied.random.val == 2 True >>> copied.next.val == 2 True >>> copied.next.random.val == 1 True","solution":"class Node: def __init__(self, val=0, next=None, random=None): self.val = val self.next = next self.random = random def copy_random_list(head): if not head: return None # Step 1: Create a copy of each node and insert it right next to the original node current = head while current: new_node = Node(current.val, current.next, None) current.next = new_node current = new_node.next # Step 2: Assign random pointers to the copied nodes current = head while current: if current.random: current.next.random = current.random.next current = current.next.next # Step 3: Separate the original list and the copied list current_old_list = head current_new_list = head.next new_head = head.next while current_old_list: current_old_list.next = current_old_list.next.next if current_new_list.next: current_new_list.next = current_new_list.next.next current_old_list = current_old_list.next current_new_list = current_new_list.next return new_head"},{"question":"def num_distinct_islands(grid: List[List[int]]) -> int: Returns the number of distinct islands in the given 2D matrix grid. An island is a group of connected 1s (horizontal or vertical connections only). Two islands are considered distinct if one island is not identical to another (after potential rotations and flips). >>> grid1 = [ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 0, 0], ... [0, 0, 0, 1, 1], ... [0, 0, 0, 1, 1] ... ] >>> num_distinct_islands(grid1) 1 >>> grid2 = [ ... [1, 1, 0, 0, 1], ... [1, 1, 0, 0, 1], ... [0, 0, 0, 1, 1], ... [0, 0, 0, 1, 1] ... ] >>> num_distinct_islands(grid2) 2 >>> grid3 = [ ... [1, 0, 0, 1, 1], ... [1, 1, 1, 0, 0], ... [1, 0, 0, 1, 1], ... [0, 0, 0, 0, 0] ... ] >>> num_distinct_islands(grid3) 2 >>> grid4 = [ ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0] ... ] >>> num_distinct_islands(grid4) 0 >>> grid5 = [ ... [1, 1, 0], ... [1, 0, 0], ... [0, 0, 0] ... ] >>> num_distinct_islands(grid5) 1 >>> grid6 = [[1]] >>> num_distinct_islands(grid6) 1 >>> grid7 = [[0]] >>> num_distinct_islands(grid7) 0","solution":"def num_distinct_islands(grid): Returns the number of distinct islands in the given 2D matrix grid. :param grid: List[List[int]], 2D matrix representing the image :return: int, number of distinct islands def extract_island(r, c): island = [] stack = [(r, c)] while stack: x, y = stack.pop() if (x, y) not in visited and 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 1: visited.add((x, y)) island.append((x - r, y - c)) stack.extend([(x+1, y), (x-1, y), (x, y+1), (x, y-1)]) return island def canonical_shapes(island): # generate all rotations and flips of the island shape shapes = [] for _ in range(2): island = [(y, x) for x, y in island] # transpose for _ in range(4): island = [(-y, x) for x, y in island] # rotate 90 degrees shapes.append(sorted(island)) return min(shapes) visited = set() distinct_islands = set() for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == 1 and (r, c) not in visited: island = extract_island(r, c) distinct_islands.add(tuple(canonical_shapes(island))) return len(distinct_islands)"},{"question":"def longest_beautiful_subsequence(nums: List[int]) -> int: Returns the length of the longest beautiful subsequence with alternating parity. >>> longest_beautiful_subsequence([2, 3, 4, 5]) 4 >>> longest_beautiful_subsequence([]) 0 >>> longest_beautiful_subsequence([2, 4, 6, 8]) 1 >>> longest_beautiful_subsequence([1, 3, 5, 7]) 1 >>> longest_beautiful_subsequence([2, 1, 4, 3, 6, 5]) 6 >>> longest_beautiful_subsequence([1, 2, 3, 4, 5, 6]) 6 >>> longest_beautiful_subsequence([2, 4, 6, 1, 3, 5, 8, 7, 10]) 5 >>> longest_beautiful_subsequence([7]) 1 >>> longest_beautiful_subsequence([8]) 1","solution":"def longest_beautiful_subsequence(nums): Returns the length of the longest beautiful subsequence with alternating parity. if not nums: return 0 # Initialize dp arrays for odd and even subsequences odd_dp = [0] * len(nums) even_dp = [0] * len(nums) if nums[0] % 2 == 0: even_dp[0] = 1 odd_dp[0] = 0 else: odd_dp[0] = 1 even_dp[0] = 0 max_length = 1 for i in range(1, len(nums)): if nums[i] % 2 == 0: even_dp[i] = odd_dp[i-1] + 1 odd_dp[i] = odd_dp[i-1] else: odd_dp[i] = even_dp[i-1] + 1 even_dp[i] = even_dp[i-1] max_length = max(max_length, odd_dp[i], even_dp[i]) return max_length"},{"question":"def process_intervals_and_queries(intervals, queries): Processes a list of intervals and a list of queries to modify and query the intervals. intervals: List of pairs [start, end] representing the intervals. queries: List of pairs [query_type, x] representing the queries. Returns: List of boolean values for the third type of query. # Unit tests def test_process_intervals_and_queries_add_query(): intervals = [[1, 3], [5, 7]] queries = [[1, 4], [3, 4]] assert process_intervals_and_queries(intervals, queries) == [True] def test_process_intervals_and_queries_remove_query(): intervals = [[1, 3], [5, 7], [4, 4]] queries = [[2, 4], [3, 4]] assert process_intervals_and_queries(intervals, queries) == [False] def test_process_intervals_and_queries_contains_query_true(): intervals = [[1, 3], [5, 7]] queries = [[3, 1], [3, 6]] assert process_intervals_and_queries(intervals, queries) == [True, True] def test_process_intervals_and_queries_contains_query_false(): intervals = [[1, 3], [5, 7]] queries = [[3, 4], [3, 8]] assert process_intervals_and_queries(intervals, queries) == [False, False] def test_process_intervals_and_queries_mixed_queries(): intervals = [[1, 5], [10, 15]] queries = [[3, 2], [3, 12], [1, 6], [3, 6], [2, 6], [3, 6]] assert process_intervals_and_queries(intervals, queries) == [True, True, True, False] def test_process_intervals_and_queries_multiple_add_queries(): intervals = [] queries = [[1, 1], [1, 2], [1, 3], [3, 2], [3, 4]] assert process_intervals_and_queries(intervals, queries) == [True, False]","solution":"def process_intervals_and_queries(intervals, queries): Processes a list of intervals and a list of queries to modify and query the intervals. intervals: List of pairs [start, end] representing the intervals. queries: List of pairs [query_type, x] representing the queries. Returns: List of boolean values for the third type of query. def contains_point(interval, point): return interval[0] <= point <= interval[1] def remove_intervals_containing_point(intervals, point): return [interval for interval in intervals if not contains_point(interval, point)] results = [] for query_type, x in queries: if query_type == 1: intervals.append([x, x]) elif query_type == 2: intervals = remove_intervals_containing_point(intervals, x) elif query_type == 3: found = any(contains_point(interval, x) for interval in intervals) results.append(found) return results"},{"question":"from collections import Counter def leastInterval(tasks: List[str], n: int) -> int: Returns the minimum number of units of time required to finish all tasks with given cooldown period. >>> leastInterval(['A','A','A','B','B','B'], 2) 8 >>> leastInterval(['A','A','A','B','B','B'], 0) 6 >>> leastInterval(['A','A','A','A'], 2) 10 >>> leastInterval(['A','B','C','D','A','B'], 1) 6 >>> leastInterval(['A', 'A', 'A', 'B', 'C', 'D'], 3) 9 >>> leastInterval(['A','A','A','B','B','B','C','C','C','D','D','E','E','F'], 2) 14","solution":"from collections import Counter def leastInterval(tasks, n): Returns the minimum number of units of time required to finish all tasks with given cooldown period. task_counts = Counter(tasks) max_count = max(task_counts.values()) max_count_tasks = sum(1 for count in task_counts.values() if count == max_count) # Considering the most frequent tasks part_count = max_count - 1 part_length = n - (max_count_tasks - 1) empty_slots = part_count * part_length available_tasks = len(tasks) - max_count * max_count_tasks idles = max(0, empty_slots - available_tasks) return len(tasks) + idles"},{"question":"from typing import List def exist(board: List[List[str]], word: str) -> bool: Determines if a word exists in the board by being constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. >>> board1 = [ >>> ['A','B','C','E'], >>> ['S','F','C','S'], >>> ['A','D','E','E'] >>> ] >>> exist(board1, \\"ABCCED\\") True >>> board2 = [ >>> ['A','B','C','E'], >>> ['S','F','C','S'], >>> ['A','D','E','E'] >>> ] >>> exist(board2, \\"ABCB\\") False >>> board3 = [ >>> ['A'] >>> ] >>> exist(board3, \\"A\\") True >>> board4 = [ >>> ['A'] >>> ] >>> exist(board4, \\"B\\") False >>> board5 = [ >>> ['A','A','A','A'], >>> ['A','A','A','A'], >>> ['A','A','A','A'] >>> ] >>> exist(board5, \\"AAAAAAAAA\\") True","solution":"from typing import List def exist(board: List[List[str]], word: str) -> bool: rows, cols = len(board), len(board[0]) path = set() def dfs(r, c, i): if i == len(word): return True if (r < 0 or r >= rows or c < 0 or c >= cols or word[i] != board[r][c] or (r, c) in path): return False path.add((r, c)) res = (dfs(r + 1, c, i + 1) or dfs(r - 1, c, i + 1) or dfs(r, c + 1, i + 1) or dfs(r, c - 1, i + 1)) path.remove((r, c)) return res for row in range(rows): for col in range(cols): if dfs(row, col, 0): return True return False"},{"question":"def longest_subsequence_length(nums: List[int], divisors: List[int]) -> int: Returns the length of the longest subsequence such that each element in the subsequence is divisible by at least one element in the divisors array. :param nums: List of integers representing the original array. :param divisors: List of integers representing the divisor array. :return: Length of the longest subsequence satisfying the condition. >>> longest_subsequence_length([4, 8, 12, 16], [2, 4]) 4 >>> longest_subsequence_length([5, 7, 11, 13], [2, 4]) 0 >>> longest_subsequence_length([4, 5, 12, 13, 16, 17], [2, 4]) 3 >>> longest_subsequence_length([30], [2, 3, 5]) 1 >>> longest_subsequence_length([7], [2, 4]) 0 >>> longest_subsequence_length([], [2, 3, 4]) 0 >>> longest_subsequence_length([1, 2, 3, 4], []) 0","solution":"def longest_subsequence_length(nums, divisors): Returns the length of the longest subsequence such that each element in the subsequence is divisible by at least one element in the divisors array. :param nums: List of integers representing the original array. :param divisors: List of integers representing the divisor array. :return: Length of the longest subsequence satisfying the condition. longest_length = 0 for num in nums: if any(num % divisor == 0 for divisor in divisors): longest_length += 1 return longest_length"},{"question":"def min_partitions(s: str) -> int: Returns the minimum number of parts the string 's' can be partitioned into, such that each part contains at least one of each character 'a', 'b', and 'c'. >>> min_partitions(\\"abcabc\\") 2 >>> min_partitions(\\"aabbcc\\") 1 >>> min_partitions(\\"abc\\") 1 >>> min_partitions(\\"aaa\\") 0 >>> min_partitions(\\"bbb\\") 0 >>> min_partitions(\\"ccc\\") 0 >>> min_partitions(\\"abccbaabcabc\\") 4 >>> min_partitions(\\"\\") 0 >>> min_partitions(\\"a\\") 0 >>> min_partitions(\\"ab\\") 0 >>> min_partitions(\\"cbacba\\") 2","solution":"def min_partitions(s): Returns the minimum number of parts the string 's' can be partitioned into, such that each part contains at least one of each character 'a', 'b', and 'c'. n = len(s) if n < 3: return 0 a_count = b_count = c_count = 0 partitions = 0 for char in s: if char == 'a': a_count += 1 elif char == 'b': b_count += 1 elif char == 'c': c_count += 1 if a_count > 0 and b_count > 0 and c_count > 0: partitions += 1 a_count = b_count = c_count = 0 return partitions"},{"question":"def reorder_log_files(logs: List[str]) -> List[str]: Reorders a list of logs such that all letter-logs come before any digit-log. The letter-logs are sorted lexicographically ignoring identifier, and in case of ties, identifier is used as a tiebreaker. The digit-logs should be put in their original order. >>> reorder_log_files([\\"a1 9 2 3 1\\", \\"g1 act car\\", \\"zo4 4 7\\", \\"ab1 off key dog\\", \\"a8 act zoo\\"]) [\\"g1 act car\\", \\"a8 act zoo\\", \\"ab1 off key dog\\", \\"a1 9 2 3 1\\", \\"zo4 4 7\\"] >>> reorder_log_files([\\"a1 9 2 3 1\\", \\"zo4 4 7\\", \\"b2 5 8\\"]) [\\"a1 9 2 3 1\\", \\"zo4 4 7\\", \\"b2 5 8\\"] >>> reorder_log_files([\\"g1 act car\\", \\"ab1 off key dog\\", \\"a8 act zoo\\"]) [\\"g1 act car\\", \\"a8 act zoo\\", \\"ab1 off key dog\\"] >>> reorder_log_files([]) [] >>> reorder_log_files([\\"ab1 act car\\", \\"ab2 act car\\"]) [\\"ab1 act car\\", \\"ab2 act car\\"]","solution":"def reorder_log_files(logs): Reorders a list of logs such that all letter-logs come before any digit-log. The letter-logs are sorted lexicographically ignoring identifier, and in case of ties, identifier is used as a tiebreaker. The digit-logs should be put in their original order. letter_logs = [] digit_logs = [] for log in logs: identifier, rest = log.split(\\" \\", 1) if rest[0].isdigit(): digit_logs.append(log) else: letter_logs.append((identifier, rest)) # Sort letter-logs first by the log content, and then by the identifier in case of ties letter_logs.sort(key=lambda x: (x[1], x[0])) # Convert sorted letter logs back to their original form sorted_letter_logs = [identifier + \\" \\" + rest for identifier, rest in letter_logs] # Append digit-logs to the result return sorted_letter_logs + digit_logs"},{"question":"def can_rearrange_with_k_consecutive_vowels(s: str, k: int) -> bool: Determines if the string s can be rearranged to contain k consecutive vowels. Args: s (str): The input string. k (int): The required number of consecutive vowels. Returns: bool: True if it's possible to rearrange the string to have k consecutive vowels, else False. >>> can_rearrange_with_k_consecutive_vowels(\\"hello\\", 2) True >>> can_rearrange_with_k_consecutive_vowels(\\"education\\", 5) True >>> can_rearrange_with_k_consecutive_vowels(\\"school\\", 4) False >>> can_rearrange_with_k_consecutive_vowels(\\"aeiou\\", 5) True >>> can_rearrange_with_k_consecutive_vowels(\\"bcdf\\", 1) False >>> can_rearrange_with_k_consecutive_vowels(\\"abcdefg\\", 3) False >>> can_rearrange_with_k_consecutive_vowels(\\"a\\" * 100 + \\"b\\" * 200, 100) True >>> can_rearrange_with_k_consecutive_vowels(\\"a\\" * 50 + \\"b\\" * 200, 100) False","solution":"def can_rearrange_with_k_consecutive_vowels(s, k): Determines if the string s can be rearranged to contain k consecutive vowels. Args: s (str): The input string. k (int): The required number of consecutive vowels. Returns: bool: True if it's possible to rearrange the string to have k consecutive vowels, else False. # Define the vowels set vowels = {'a', 'e', 'i', 'o', 'u'} # Count the number of vowels in the string vowel_count = sum(1 for char in s if char in vowels) # Return whether the number of vowels is at least k return vowel_count >= k"},{"question":"def canTransform(source: str, target: str) -> bool: Check if the source binary string can be transformed into the target binary string by inverting bits or rotating right. >>> canTransform('1010', '1010') True >>> canTransform('1010', '0101') True >>> canTransform('1010', '1001') False >>> canTransform('1110', '0111') True","solution":"def canTransform(source: str, target: str) -> bool: Check if source can be transformed into target by inverting bits or rotating right. :param source: The source binary string. :param target: The target binary string. :return: True if source can be transformed into target, else False. if len(source) != len(target): return False # Generate all rotations of the source string rotations = [] current = source for _ in range(len(source)): rotations.append(current) current = current[-1] + current[:-1] # Invert the source string and generate all its rotations inverted_source = ''.join('1' if c == '0' else '0' for c in source) inverted_rotations = [] current = inverted_source for _ in range(len(inverted_source)): inverted_rotations.append(current) current = current[-1] + current[:-1] # Check if target is present in the standard or inverted rotations return target in rotations or target in inverted_rotations"},{"question":"def minPathSum(M: List[List[int]]) -> int: Calculate the minimum sum of the numbers along a path from the top-left cell to the bottom-right cell. The function only allows moving to the right or down at each step. Arguments: M -- a matrix of size m x n filled with non-negative integers (list of lists of int) Returns: int -- the minimum path sum >>> minPathSum([[5]]) 5 >>> minPathSum([[1, 2], [1, 1]]) 3 >>> minPathSum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> minPathSum([ ... [1, 3, 1, 2], ... [1, 5, 1, 3], ... [4, 2, 1, 1], ... [1, 2, 4, 1] ... ]) 9 >>> minPathSum([]) 0 >>> minPathSum([[1, 2, 3]]) 6 >>> minPathSum([[1], [2], [3]]) 6","solution":"def minPathSum(M): Calculate the minimum path sum from top-left to bottom-right of the matrix M. Args: M (list of list of int): The matrix of non-negative integers. Returns: int: The minimum path sum. if not M or not M[0]: return 0 m, n = len(M), len(M[0]) # Create a 2D dp array filled with 0s dp = [[0] * n for _ in range(m)] # Initialize the top-left cell dp[0][0] = M[0][0] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + M[i][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + M[0][j] # Fill the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + M[i][j] return dp[m-1][n-1]"},{"question":"def can_form_palindrome(s: str) -> bool: You are given a string \`s\`, consisting of lowercase English letters. You need to select a non-empty subsequence from \`s\` and re-arrange its characters to form a string that is a palindrome. Return \`true\` if it is possible to form such a palindrome; otherwise, return \`false\`. >>> can_form_palindrome(\\"aaaa\\") == True >>> can_form_palindrome(\\"civic\\") == True >>> can_form_palindrome(\\"ivicc\\") == True >>> can_form_palindrome(\\"abc\\") == False >>> can_form_palindrome(\\"a\\") == True >>> can_form_palindrome(\\"\\") == True >>> can_form_palindrome(\\"aabbccdd\\") == True","solution":"def can_form_palindrome(s): Returns true if it is possible to form a palindrome with any non-empty subsequence of \`s\`. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"def partition_labels(s: str) -> List[int]: Partition the string s into as many parts as possible so that each letter appears in at most one part. Return a list of integers representing the size of these parts. >>> partition_labels(\\"a\\") [1] >>> partition_labels(\\"abbac\\") [4, 1] >>> partition_labels(\\"ababcbacadefegdehijhklij\\") [9, 7, 8] >>> partition_labels(\\"abcdef\\") [1, 1, 1, 1, 1, 1] >>> partition_labels(\\"aaabbbcccddd\\") [3, 3, 3, 3]","solution":"def partition_labels(s): Partition the string s into as many parts as possible so that each letter appears in at most one part. Return a list of integers representing the size of these parts. last_occurrences = {char: idx for idx, char in enumerate(s)} partitions = [] start, end = 0, 0 for i, char in enumerate(s): end = max(end, last_occurrences[char]) if i == end: partitions.append(i - start + 1) start = i + 1 return partitions"},{"question":"def can_generate_by_repeating_one_char(s: str) -> bool: Determine if the string can be generated by repeating one character. >>> can_generate_by_repeating_one_char(\\"a\\") True >>> can_generate_by_repeating_one_char(\\"aaa\\") True >>> can_generate_by_repeating_one_char(\\"abc\\") False >>> can_generate_by_repeating_one_char(\\"aabb\\") False >>> can_generate_by_repeating_one_char(\\"\\") False >>> can_generate_by_repeating_one_char(\\"cccccccccc\\") True >>> can_generate_by_repeating_one_char(\\"cccccccccacd\\") False","solution":"def can_generate_by_repeating_one_char(s): Determine if the string can be generated by repeating one character. Args: s (str): The input string consisting of lowercase English letters. Returns: bool: True if the string can be generated by repeating one character, False otherwise. if not s: return False first_char = s[0] for char in s: if char != first_char: return False return True"},{"question":"from typing import List def largestNumber(nums: List[int]) -> str: Given a list of non-negative integers nums, arrange them such that they form the largest number possible. Return the result as a string. >>> largestNumber([3, 30, 34, 5, 9]) == '9534330' >>> largestNumber([1, 2, 3, 4, 5, 6, 7, 8, 9]) == '987654321' >>> largestNumber([0, 0, 0]) == '0' >>> largestNumber([10, 2]) == '210' >>> largestNumber([432, 43243]) == \\"43243432\\" >>> largestNumber([1]*10000) == '1' * 10000 >>> largestNumber([121, 12]) == '12121'","solution":"from functools import cmp_to_key def largestNumber(nums): Given a list of non-negative integers nums, arrange them such that they form the largest number possible. Return the result as a string. def compare(a, b): if a + b > b + a: return -1 elif a + b < b + a: return 1 else: return 0 # Convert the numbers to strings for easier comparison nums_str = list(map(str, nums)) # Sort nums based on the custom comparator nums_str.sort(key=cmp_to_key(compare)) # Join sorted strings largest_num = ''.join(nums_str) # Edge case: if the largest number starts with 0, the number is actually 0 if largest_num[0] == '0': return '0' return largest_num"},{"question":"def min_path_sum(matrix): Write a function that takes a 2-dimensional array matrix of size m x n where each element represents the cost of a cell to step on. You start at the top-left corner (0,0) and you must move to the bottom-right corner (m-1, n-1). You can only move right or down at each step. Return the minimum cost to reach the bottom-right corner of the matrix. >>> min_path_sum([[5]]) 5 >>> min_path_sum([[1, 2], [3, 4]]) 7 >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_sum([[1, 2, 5], [3, 2, 1]]) 6 >>> min_path_sum([]) 0 >>> min_path_sum([[1, 2, 3]]) 6 >>> min_path_sum([[1], [2], [3]]) 6","solution":"def min_path_sum(matrix): Return the minimum cost to reach from the top-left corner to the bottom-right corner of the matrix. You can only move right or down at each step. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) for i in range(1, m): matrix[i][0] += matrix[i-1][0] # Fill in the first column by adding the cell above for j in range(1, n): matrix[0][j] += matrix[0][j-1] # Fill in the first row by adding the cell to the left for i in range(1, m): for j in range(1, n): matrix[i][j] += min(matrix[i-1][j], matrix[i][j-1]) # Choose the minimum path sum from the top or from the left return matrix[-1][-1] # The bottom-right corner will contain the minimum path sum"},{"question":"def max_non_overlapping_meetings(intervals): Returns the maximum number of non-overlapping meetings that can be attended. Args: intervals: List of [start, end] times of the meetings. Returns: Integer representing the maximum number of non-overlapping meetings. Example: >>> max_non_overlapping_meetings([[1, 3], [2, 4], [3, 5]]) 2 >>> max_non_overlapping_meetings([[0, 1], [3, 5], [4, 6], [7, 8], [8, 9]]) 4","solution":"def max_non_overlapping_meetings(intervals): Returns the maximum number of non-overlapping meetings. Args: intervals: List of [start, end] times of the meetings. Returns: Integer representing the maximum number of non-overlapping meetings. # Sort intervals based on end time intervals.sort(key=lambda x: x[1]) max_meetings = 0 last_end_time = float('-inf') for start, end in intervals: if start >= last_end_time: max_meetings += 1 last_end_time = end return max_meetings"},{"question":"def search_matrix(matrix: List[List[int]], k: int) -> bool: Returns True if k is present in the 2D list matrix, otherwise False. Each row in the matrix is sorted in ascending order from left to right. Each column in the matrix is sorted in ascending order from top to bottom. >>> matrix = [ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ] >>> search_matrix(matrix, 5) True >>> search_matrix(matrix, 20) False >>> search_matrix([], 1) False >>> search_matrix([[]], 1) False >>> search_matrix([[5]], 5) True >>> search_matrix([[5]], 1) False","solution":"def search_matrix(matrix, k): Returns True if k is present in the 2D list matrix, otherwise False. Each row in the matrix is sorted in ascending order from left to right. Each column in the matrix is sorted in ascending order from top to bottom. if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == k: return True elif matrix[row][col] > k: col -= 1 else: row += 1 return False"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"aabbcc\\") 2 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"anviaj\\") 5","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters. n = len(s) char_index_map = {} max_length = 0 start = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def contains_difference(nums: List[int], k: int) -> bool: Determine if there are two distinct indices i and j in nums such that the absolute difference between nums[i] and nums[j] is exactly k. Args: nums (List[int]): A list of non-negative integers. k (int): The target difference. Returns: bool: True if there exist two distinct indices with the said property, otherwise False. >>> contains_difference([1, 7, 5, 9, 3, 2], 4) True >>> contains_difference([1, 5, 3, 1], 2) True >>> contains_difference([1, 7, 5, 9, 3, 2], 10) False >>> contains_difference([1, 1, 1, 1], 0) True >>> contains_difference([1, 2, 3], 5) False >>> contains_difference([1, 3, 1, 5, 1, 7], 2) True >>> contains_difference([1, 2, 3, 4, 5], 10) False >>> contains_difference([4, 4, 4, 4], 0) True","solution":"def contains_difference(nums, k): Returns true if there exist two distinct indices i and j in nums such that the absolute difference between nums[i] and nums[j] is exactly k, otherwise returns false. num_set = set(nums) for num in nums: if (num + k) in num_set or (num - k) in num_set: return True return False"},{"question":"def minOperationsToColorGraph(edges: List[int]) -> int: Returns the minimum number of operations needed to color the graph such that no two nodes with a direct edge between them have the same color. :param edges: List[int] - the directed acyclic graph (DAG) represented as an integer array. :return: int - the minimum number of operations needed. pass def test_simple_tree(): # Example graph: 0 -> 1, 0 -> 2 edges = [1, -1, -1] assert minOperationsToColorGraph(edges) == 2 def test_no_edges(): # Example graph: No edges edges = [-1, -1, -1, -1] assert minOperationsToColorGraph(edges) == 1 def test_chain(): # Example graph: 0 -> 1, 1 -> 2, 2 -> 3 edges = [1, 2, 3, -1] assert minOperationsToColorGraph(edges) == 4 def test_branching(): # Example graph: 0 -> 1, 0 -> 2, 1 -> 3, 1 -> 4, 2 -> 5 edges = [1, 3, 5, -1, -1, -1] assert minOperationsToColorGraph(edges) == 3","solution":"def minOperationsToColorGraph(edges): Returns the minimum number of operations needed to color the graph such that no two nodes with a direct edge between them have the same color. :param edges: List[int] - the directed acyclic graph (DAG) represented as an integer array. :return: int - the minimum number of operations needed. # Create an adjacency list from edges n = len(edges) adj = [[] for _ in range(n)] for i in range(n): if edges[i] != -1: adj[i].append(edges[i]) # Utility function for DFS to track the depth of each node def dfs(node, depth): visited[node] = True max_depth[0] = max(max_depth[0], depth) for neighbor in adj[node]: if not visited[neighbor]: dfs(neighbor, depth + 1) # Array to keep track of full depth traversal visited = [False] * n max_depth = [0] # Perform DFS on each node for i in range(n): if not visited[i]: dfs(i, 0) # The minimum number of nodes needed to be colored is maximum depth + 1 # (since each depth level requires alternation in colors) return max_depth[0] + 1"},{"question":"def min_operations_to_convert(s: str, t: str) -> int: Returns the minimum number of operations required to convert string \`s\` into string \`t\`. If it is not possible, returns -1. >>> min_operations_to_convert(\\"abc\\", \\"abc\\") 0 >>> min_operations_to_convert(\\"abbccc\\", \\"abc\\") 3 >>> min_operations_to_convert(\\"axe\\", \\"ae\\") 1 >>> min_operations_to_convert(\\"abc\\", \\"abcd\\") -1 >>> min_operations_to_convert(\\"hello\\", \\"helloo\\") -1 >>> min_operations_to_convert(\\"\\", \\"\\") 0 >>> min_operations_to_convert(\\"a\\", \\"\\") 1 >>> min_operations_to_convert(\\"\\", \\"a\\") -1 >>> min_operations_to_convert(\\"xyz\\", \\"abc\\") -1","solution":"def min_operations_to_convert(s, t): Returns the minimum number of operations required to convert string \`s\` into string \`t\`. If it is not possible, returns -1. from collections import Counter s_counter = Counter(s) t_counter = Counter(t) # Check if conversion is possible for char in t_counter: if t_counter[char] > s_counter[char]: return -1 # Calculate minimum operations min_operations = 0 for char in s_counter: if s_counter[char] > t_counter[char]: min_operations += s_counter[char] - t_counter[char] return min_operations"},{"question":"def max_depth(s: str) -> int: Computes the maximum depth of nested parentheses. Parameters: s (str): The string representing a valid parentheses sequence. Returns: int: The maximum depth of nested parentheses. Examples: >>> max_depth(\\"()\\") 1 >>> max_depth(\\"((()))\\") 3 >>> max_depth(\\"(())()()\\") 2 >>> max_depth(\\"((()()(())))\\") 4 >>> max_depth(\\"\\") 0 >>> max_depth(\\"()()\\") 1 >>> max_depth(\\"(()((())()))\\") 4 >>> max_depth(\\"(()(()))\\") 3","solution":"def max_depth(s: str) -> int: Computes the maximum depth of nested parentheses. Parameters: s (str): The string representing a valid parentheses sequence. Returns: int: The maximum depth of nested parentheses. max_depth = 0 current_depth = 0 for char in s: if char == '(': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == ')': current_depth -= 1 return max_depth"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a valid mathematical expression and returns the result as an integer. Division should truncate toward zero. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"14-3/2\\") 13 >>> evaluate_expression(\\"3+5/2\\") 5 >>> evaluate_expression(\\"2*3+4\\") 10 >>> evaluate_expression(\\"10-2*3\\") 4 >>> evaluate_expression(\\"10-5+5\\") 10 >>> evaluate_expression(\\"1+2-3*4/5\\") 1 >>> evaluate_expression(\\"10/3\\") 3 >>> evaluate_expression(\\"-10/3\\") -3 >>> evaluate_expression(\\"5+5*5/5-5\\") 5","solution":"def evaluate_expression(expression): Evaluates a valid mathematical expression and returns the result as an integer. Division should truncate toward zero. def operate(operand1, operand2, operator): if operator == '+': return operand1 + operand2 elif operator == '-': return operand1 - operand2 elif operator == '*': return operand1 * operand2 elif operator == '/': return int(operand1 / operand2) # Truncate toward zero current_number = 0 result = 0 last_operator = '+' stack = [] for i, char in enumerate(expression): if char.isdigit(): current_number = current_number * 10 + int(char) if char in '+-*/' or i == len(expression) - 1: if last_operator in '+-': if last_operator == '+': stack.append(current_number) else: stack.append(-current_number) elif last_operator in '*/': if last_operator == '*': stack.append(stack.pop() * current_number) else: stack.append(int(stack.pop() / current_number)) current_number = 0 last_operator = char return sum(stack)"},{"question":"def maxProfit(k: int, prices: List[int]) -> int: Given an array of integers \`prices\` representing the prices of items over a series of days, find the maximum profit you can achieve by buying and selling the item's shares considering that you may complete up to \`k\` transactions. However, you cannot engage in multiple transactions at the same time (you must sell the item shares before you can buy again). Return the maximum profit you can achieve. >>> maxProfit(2, []) == 0 >>> maxProfit(0, [1, 2, 3, 4, 5]) == 0 >>> maxProfit(1, [3, 2, 6, 5, 0, 3]) == 4 >>> maxProfit(2, [3, 2, 6, 5, 0, 3]) == 7 >>> maxProfit(1000, [3, 2, 6, 5, 0, 3]) == 7 >>> maxProfit(2, [5, 4, 3, 2, 1]) == 0 >>> maxProfit(2, [1, 2, 3, 4, 5, 4, 3, 2, 1]) == 4","solution":"def maxProfit(k, prices): if not prices or k == 0: return 0 n = len(prices) # If k >= n // 2, then we can complete as many transactions as we want. if k >= n // 2: return sum(max(prices[i + 1] - prices[i], 0) for i in range(n - 1)) # dp[i][j] represents the maximum profit up to day i with at most j transactions. dp = [[0] * (k + 1) for _ in range(n)] for j in range(1, k + 1): max_diff = -prices[0] for i in range(1, n): dp[i][j] = max(dp[i - 1][j], prices[i] + max_diff) max_diff = max(max_diff, dp[i][j - 1] - prices[i]) return dp[-1][-1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root, target): Determine whether there's a root-to-leaf path in the binary tree such that adding up all the values along the path equals the given target. Args: root (TreeNode): The root of the binary tree. target (int): The target sum to find. Returns: bool: True if such a path exists, otherwise False. >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.right.right.right = TreeNode(1) >>> has_path_sum(root, 22) True >>> has_path_sum(root, 26) True >>> has_path_sum(root, 18) True >>> has_path_sum(root, 23) False >>> has_path_sum(root, 5) False >>> has_path_sum(None, 0) False >>> single_node = TreeNode(1) >>> has_path_sum(single_node, 1) True >>> has_path_sum(single_node, 2) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root, target): Returns True if there's a root-to-leaf path in the binary tree such that adding up all the values along the path equals the given target. Otherwise, returns False. if not root: return False # If this is a leaf node if not root.left and not root.right: return root.val == target # Recursively check the left and right subtrees target -= root.val return has_path_sum(root.left, target) or has_path_sum(root.right, target)"},{"question":"def remove_suspicious(ids: List[str]) -> List[str]: Removes IDs that contain two consecutive identical characters. >>> remove_suspicious([\\"ABCD\\", \\"AABF\\", \\"XYXY\\", \\"ZZZZ\\", \\"MNOP\\"]) ['ABCD', 'XYXY', 'MNOP'] >>> remove_suspicious([\\"AABB\\", \\"CCDD\\", \\"EEFF\\"]) [] from typing import List def test_remove_suspicious_no_suspicious(): ids = [\\"ABCD\\", \\"XYXY\\", \\"MNOP\\"] assert remove_suspicious(ids) == [\\"ABCD\\", \\"XYXY\\", \\"MNOP\\"] def test_remove_suspicious_all_suspicious(): ids = [\\"AABB\\", \\"CCDD\\", \\"EEFF\\"] assert remove_suspicious(ids) == [] def test_remove_suspicious_mixed_ids(): ids = [\\"ABCD\\", \\"AABF\\", \\"XYXY\\", \\"ZZZZ\\", \\"MNOP\\"] assert remove_suspicious(ids) == [\\"ABCD\\", \\"XYXY\\", \\"MNOP\\"] def test_remove_suspicious_single_id_not_suspicious(): ids = [\\"ABCD\\"] assert remove_suspicious(ids) == [\\"ABCD\\"] def test_remove_suspicious_single_id_suspicious(): ids = [\\"AABB\\"] assert remove_suspicious(ids) == [] def test_remove_suspicious_empty_list(): ids = [] assert remove_suspicious(ids) == []","solution":"def remove_suspicious(ids): Removes IDs that contain two consecutive identical characters. def is_suspicious(id_): Returns True if the ID contains two consecutive identical characters. for i in range(len(id_) - 1): if id_[i] == id_[i + 1]: return True return False valid_ids = [id_ for id_ in ids if not is_suspicious(id_)] return valid_ids"},{"question":"def smallestDivisor(nums: List[int], threshold: int) -> int: Implement the function to find the smallest divisor such that the sum of the result of dividing each element in nums by d is less than or equal to the given threshold. Each division result should be rounded up to the nearest integer. >>> smallestDivisor([1, 2, 5, 9], 6) 5 >>> smallestDivisor([1, 1, 1, 1], 4) 1 >>> smallestDivisor([100, 200, 300], 3) 300 >>> smallestDivisor([10], 1) 10 >>> smallestDivisor([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 55) 1 >>> smallestDivisor([1, 1000000000], 2) 1000000000 >>> smallestDivisor([2, 3, 2, 3], 3) 3","solution":"import math def smallestDivisor(nums, threshold): def compute_sum(divisor): return sum(math.ceil(num / divisor) for num in nums) left, right = 1, max(nums) while left < right: mid = (left + right) // 2 if compute_sum(mid) > threshold: left = mid + 1 else: right = mid return left"},{"question":"def lexicographically_smallest_string(s: str) -> str: Find the lexicographically smallest string that can be obtained by changing any character in the string to the next character in alphabetical order any number of times. >>> lexicographically_smallest_string('a') == 'a' >>> lexicographically_smallest_string('b') == 'a' >>> lexicographically_smallest_string('z') == 'a' >>> lexicographically_smallest_string('abc') == 'aaa' >>> lexicographically_smallest_string('xyz') == 'aaa' >>> lexicographically_smallest_string('az') == 'aa' >>> lexicographically_smallest_string('aaaa') == 'aaaa' >>> lexicographically_smallest_string('bac') == 'aaa' >>> lexicographically_smallest_string('cab') == 'aaa' >>> lexicographically_smallest_string('za') == 'aa'","solution":"def lexicographically_smallest_string(s): Find the lexicographically smallest string that can be obtained by changing any character in the string to the next character in alphabetical order any number of times. # The lexicographically smallest string would be where every character is 'a' return 'a' * len(s)"},{"question":"def find_kth_missing_positive(nums: List[int], k: int) -> int: Finds the k-th smallest missing positive integer in a sorted array of integers. >>> find_kth_missing_positive([5, 7, 8], 2) 2 >>> find_kth_missing_positive([1, 2, 8], 5) 7 >>> find_kth_missing_positive([1, 7], 4) 5 >>> find_kth_missing_positive([9, 10], 8) 8 >>> find_kth_missing_positive([1, 2, 3, 4], 1) 5 >>> find_kth_missing_positive([1, 2, 3, 4], 2) 6 >>> find_kth_missing_positive([1], 1000) 1001","solution":"def find_kth_missing_positive(nums, k): Finds the k-th smallest missing positive integer in a sorted array of integers. :param nums: List[int] - A sorted list of integers. :param k: int - The k-th missing positive integer to find. :return: int - The k-th missing positive integer. missing_count = 0 current = 1 index = 0 while missing_count < k: if index < len(nums) and nums[index] == current: index += 1 else: missing_count += 1 if missing_count < k: current += 1 return current"},{"question":"def can_partition_three_parts_equal_sum(arr: List[int]) -> bool: Determine whether the array can be partitioned into three non-empty parts with equal sums. >>> can_partition_three_parts_equal_sum([0, 2, 1, -6, 6, -7, 9, 1, 2, 0, 1]) True >>> can_partition_three_parts_equal_sum([1, 2, 3, 4, 5, 6, 7]) False >>> can_partition_three_parts_equal_sum([3, 3, 2, 2, 4, 4]) False >>> can_partition_three_parts_equal_sum([1, 1, 1, 1, 1, 1]) True >>> can_partition_three_parts_equal_sum([3, 3, 3, 0, 0, 0, 3, 3, 3]) True >>> can_partition_three_parts_equal_sum([]) False >>> can_partition_three_parts_equal_sum([3]) False >>> can_partition_three_parts_equal_sum([1, 2]) False >>> can_partition_three_parts_equal_sum([0, 0, 0, 0, 0, 0]) True >>> can_partition_three_parts_equal_sum([999999999, 999999999, 999999999, 0, 0, 0, 999999999, 999999999, 999999999]) True","solution":"def can_partition_three_parts_equal_sum(arr): total_sum = sum(arr) # If total sum is not divisible by 3, we cannot partition it into three parts with equal sum if total_sum % 3 != 0: return False target = total_sum // 3 current_sum = 0 count = 0 for num in arr: current_sum += num if current_sum == target: count += 1 current_sum = 0 # We need at least three parts with equal sum return count >= 3"},{"question":"def distinct_substrings_in_concatenated_string(p: str) -> int: Given a string \`p\` consisting of lowercase English letters, return the number of distinct non-empty substrings of \`p\` that can be found at least once in an infinitely concatenated string consisting of \`p\` repeated indefinitely. >>> distinct_substrings_in_concatenated_string(\\"a\\") 1 >>> distinct_substrings_in_concatenated_string(\\"ab\\") 3 >>> distinct_substrings_in_concatenated_string(\\"aaa\\") 3 >>> distinct_substrings_in_concatenated_string(\\"abc\\") 6 >>> distinct_substrings_in_concatenated_string(\\"abab\\") 7","solution":"def distinct_substrings_in_concatenated_string(p): Returns the number of distinct non-empty substrings of \`p\` that can be found at least once in an infinitely concatenated string of \`p\`. n = len(p) substrings = set() for i in range(n): for j in range(i + 1, n + 1): substrings.add(p[i:j]) return len(substrings)"},{"question":"def merge_alternately(word1: str, word2: str) -> str: Merge two strings alternately starting with the first character of word1. If one string is exhausted, append the remaining characters of the other string. >>> merge_alternately(\\"abc\\", \\"xyz\\") \\"axbycz\\" >>> merge_alternately(\\"ab\\", \\"xyz\\") \\"axbyz\\" >>> merge_alternately(\\"abc\\", \\"xy\\") \\"axbyc\\" >>> merge_alternately(\\"abcd\\", \\"xy\\") \\"axbycd\\" >>> merge_alternately(\\"\\", \\"xyz\\") \\"xyz\\" >>> merge_alternately(\\"abc\\", \\"\\") \\"abc\\" >>> merge_alternately(\\"\\", \\"\\") \\"\\"","solution":"def merge_alternately(word1, word2): Merge two strings alternately starting with the first character of word1. If one string is exhausted, append the remaining characters of the other string. target = [] len1, len2 = len(word1), len(word2) i, j = 0, 0 while i < len1 or j < len2: if i < len1: target.append(word1[i]) i += 1 if j < len2: target.append(word2[j]) j += 1 return ''.join(target)"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. Args: s (str): The input string. Returns: int: The length of the longest substring with all unique characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"abcde\\") 5 >>> length_of_longest_substring(\\"aab\\") 2 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"anviaj\\") 5 >>> length_of_longest_substring(\\"tmmzuxt\\") 5 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"abcdefghijklmnopqrstuvwxyz\\") 26 >>> length_of_longest_substring(\\"!@#%^&*()\\") 10 >>> length_of_longest_substring(\\"a!a!a!a!\\") 2","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters. Args: s (str): The input string. Returns: int: The length of the longest substring with all unique characters. n = len(s) if n == 0: return 0 char_set = set() left = 0 max_length = 0 for right in range(n): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"def longest_subarray_with_two_distinct(nums: List[int]) -> int: Given an array of integers, return the length of the longest contiguous subarray that contains at most two different numbers. >>> longest_subarray_with_two_distinct([]) == 0 >>> longest_subarray_with_two_distinct([1]) == 1 >>> longest_subarray_with_two_distinct([1, 2]) == 2 >>> longest_subarray_with_two_distinct([1, 1, 1, 1, 1]) == 5 >>> longest_subarray_with_two_distinct([1, 2, 1, 3, 4]) == 3 >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 3, 4, 4, 3, 2, 1]) == 4 >>> longest_subarray_with_two_distinct([1, 2, 1, 1, 1, 3, 4, 4, 3, 2, 1]) == 5","solution":"def longest_subarray_with_two_distinct(nums): Finds the length of the longest subarray with at most two distinct numbers. if not nums: return 0 start = 0 max_len = 0 count = {} for end, num in enumerate(nums): count[num] = count.get(num, 0) + 1 while len(count) > 2: count[nums[start]] -= 1 if count[nums[start]] == 0: del count[nums[start]] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"def longestCommonPrefix(strs: List[str]) -> str: Finds the longest common prefix string amongst an array of strings. If there is no common prefix, returns an empty string. >>> longestCommonPrefix([\\"flower\\", \\"flow\\", \\"flight\\"]) 'fl' >>> longestCommonPrefix([\\"dog\\", \\"racecar\\", \\"car\\"]) '' >>> longestCommonPrefix([\\"single\\"]) 'single' >>> longestCommonPrefix([]) '' >>> longestCommonPrefix([\\"test\\", \\"test\\", \\"test\\"]) 'test' >>> longestCommonPrefix([\\"interview\\", \\"inter\\", \\"internal\\"]) 'inter' >>> longestCommonPrefix([\\"\\", \\"test\\", \\"testing\\"]) '' >>> longestCommonPrefix([\\"test\\", \\"\\", \\"testing\\"]) '' >>> longestCommonPrefix([\\"\\", \\"\\"]) ''","solution":"def longestCommonPrefix(strs): Finds the longest common prefix string amongst an array of strings. If there is no common prefix, returns an empty string. if not strs: return \\"\\" # Take the first string as a reference first_str = strs[0] for i in range(len(first_str)): char = first_str[i] for string in strs[1:]: # If i is out of range or there's a mismatch if i >= len(string) or string[i] != char: return first_str[:i] return first_str"},{"question":"def can_become_goal(s: str, goal: str) -> bool: Return True if s can become goal after some number of shifts, False otherwise. >>> can_become_goal(\\"abcde\\", \\"bcdea\\") True >>> can_become_goal(\\"abcde\\", \\"abced\\") False >>> can_become_goal(\\"\\", \\"\\") True","solution":"def can_become_goal(s, goal): Returns True if s can become goal after some number of shifts, False otherwise. if len(s) != len(goal): return False return goal in (s + s)"},{"question":"def can_transform(word1: str, word2: str) -> bool: Determine if word1 can be transformed into word2 by rearranging its characters. >>> can_transform(\\"listen\\", \\"silent\\") True >>> can_transform(\\"hello\\", \\"world\\") False >>> can_transform(\\"abc\\", \\"abcd\\") False >>> can_transform(\\"python\\", \\"python\\") True >>> can_transform(\\"aabbcc\\", \\"ccbbaa\\") True >>> can_transform(\\"abc\\", \\"bac\\") True >>> can_transform(\\"\\", \\"\\") True >>> can_transform(\\"a\\", \\"a\\") True >>> can_transform(\\"a\\", \\"b\\") False","solution":"def can_transform(word1, word2): Returns True if word1 can be transformed into word2 by rearranging its characters. Returns False otherwise. # Both words must have the same length to be transformable if len(word1) != len(word2): return False # Both words must have the same character frequencies to be transformable from collections import Counter return Counter(word1) == Counter(word2)"},{"question":"def product_of_max_and_min(arr: List[int], k: int) -> List[int]: Given an integer array \`arr\` and an integer \`k\`, return an array where for each index \`i\` (0 <= i < arr.length), contains the product of the maximum element and the minimum element among the subarrays of length \`k\` that end at index \`i\`. If there is no subarray of length \`k\` that ends at index \`i\`, the value at index \`i\` in the result should be -1. :param arr: List[int] :param k: int :return: List[int] >>> product_of_max_and_min([1, 3, 2, 5, 4], 3) == [-1, -1, 3, 10, 10] >>> product_of_max_and_min([1, 2], 3) == [-1, -1] >>> product_of_max_and_min([1, 2], 2) == [-1, 2] >>> product_of_max_and_min([5], 1) == [25] # 5 * 5 >>> product_of_max_and_min([4, 1, 3, 2, 7, 6], 2) == [-1, 4, 3, 6, 14, 42] >>> product_of_max_and_min([2, 4, 6], 4) == [-1, -1, -1]","solution":"def product_of_max_and_min(arr, k): Given an integer array \`arr\` and an integer \`k\`, returns an array where for each index \`i\` (0 <= i < arr.length), contains the product of the maximum element and the minimum element among the subarrays of length \`k\` that end at index \`i\`. If there is no subarray of length \`k\` that ends at index \`i\`, the value at index \`i\` in the result should be -1. :param arr: List[int] :param k: int :return: List[int] if k > len(arr): return [-1] * len(arr) result = [-1] * len(arr) for i in range(len(arr)): if i >= k - 1: subarray = arr[i - k + 1:i + 1] min_elem = min(subarray) max_elem = max(subarray) result[i] = min_elem * max_elem return result"},{"question":"def three_sum(arr, target_sum): Determines if there are three distinct elements in the array whose sum equals the given sum. Parameters: arr (list of int): The array of integers. target_sum (int): The target sum. Returns: bool: True if such a triplet exists, False otherwise. >>> three_sum([1, 2, 3, 4, 5], 9) True >>> three_sum([-1, 0, 1, 2, -1, -4], 0) True >>> three_sum([12, 3, 6, 1, 6, 9], 24) True >>> three_sum([1, 2, 3, 4, 5], 20) False >>> three_sum([-1, 0, 1, 2, -1, -4], 10) False >>> three_sum([12, 3, 6, 1, 6, 9], 50) False >>> three_sum([1, 2], 3) False >>> three_sum([], 0) False >>> three_sum([0, 0, 0], 0) True","solution":"def three_sum(arr, target_sum): Determines if there are three distinct elements in the array whose sum equals the given sum. Parameters: arr (list of int): The array of integers. target_sum (int): The target sum. Returns: bool: True if such a triplet exists, False otherwise. arr.sort() n = len(arr) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target_sum: return True elif current_sum < target_sum: left += 1 else: right -= 1 return False"},{"question":"def isBalanced(s: str) -> bool: Returns True if the parentheses (), curly braces {}, and square brackets [] in the string are balanced, and False otherwise. Examples: >>> isBalanced(\\"\\") True >>> isBalanced(\\"()\\") True >>> isBalanced(\\"[]\\") True >>> isBalanced(\\"{}\\") True >>> isBalanced(\\"{[()]}\\") True >>> isBalanced(\\"[({])}\\") False >>> isBalanced(\\"[\\") False >>> isBalanced(\\"}\\") False >>> isBalanced(\\"a[b{c(d)e}f]g\\") True >>> isBalanced(\\"a[b{c(d)e}f]g]\\") False >>> isBalanced(\\"(]\\") False >>> isBalanced(\\"[()]{}{[()()]()}\\") True >>> isBalanced(\\"[(])\\") False","solution":"def isBalanced(s: str) -> bool: Returns True if the parentheses (), curly braces {}, and square brackets [] in the string are balanced, and False otherwise. stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket: if not stack or stack.pop() != matching_bracket[char]: return False return not stack"},{"question":"def can_reach_end(arr: List[int], k: int) -> bool: Determine if it's possible to reach the last position from the first position given the jump rules. Parameters: arr (list of int): An array of integers representing positions on a number line. k (int): The maximum distance a person can jump from any given position. Returns: bool: True if it's possible to reach the last position from the first position, otherwise False. >>> can_reach_end([0, 5], 5) True >>> can_reach_end([0, 10, 20], 5) False >>> can_reach_end([0, 2, 4, 6, 8], 2) True >>> can_reach_end([0, 3, 6, 9], 3) True >>> can_reach_end([0], 100) True >>> can_reach_end([0, 5, 11], 5) False","solution":"def can_reach_end(arr, k): Returns whether it's possible to reach the last position from the first position following the given jump rules. Parameters: arr (list of int): An array of integers representing positions on a number line. k (int): The maximum distance a person can jump from any given position. Returns: bool: True if it's possible to reach the last position from the first position, otherwise False. n = len(arr) if n == 1: return True # We use a BFS-like approach to explore reachable positions from collections import deque queue = deque([0]) while queue: current_index = queue.popleft() current_position = arr[current_index] for next_index in range(current_index + 1, n): if arr[next_index] - current_position <= k: if next_index == n - 1: return True queue.append(next_index) else: break return False"},{"question":"class Product: def __init__(self, name: str, price: float): self.name = name self.price = price class ProductManager: def __init__(self): Initializes the ProductManager object. pass def addProduct(self, name: str, price: float): Adds a Product object with the given name and price to the list. Args: name (str): The name of the product. price (float): The price of the product. pass def findProductsWithPriceHigherThan(self, minPrice: float) -> List[str]: Returns a list of product names with a price higher than minPrice, sorted in ascending order. Args: minPrice (float): The minimum price to filter the products. Returns: List[str]: The list of product names with a higher price than minPrice. pass def getProductPrice(self, name: str) -> float: Returns the price of the product with the given name. If the product is not found, return -1.0. Args: name (str): The name of the product. Returns: float: The price of the product or -1.0 if not found. pass # Unit tests def test_add_and_find_products(): pm = ProductManager() pm.addProduct(\\"Apple\\", 1.2) pm.addProduct(\\"Banana\\", 0.5) pm.addProduct(\\"Cherry\\", 2.5) assert pm.findProductsWithPriceHigherThan(1.0) == [\\"Apple\\", \\"Cherry\\"] assert pm.findProductsWithPriceHigherThan(2.0) == [\\"Cherry\\"] assert pm.findProductsWithPriceHigherThan(3.0) == [] def test_get_product_price(): pm = ProductManager() pm.addProduct(\\"Apple\\", 1.2) pm.addProduct(\\"Banana\\", 0.5) pm.addProduct(\\"Cherry\\", 2.5) assert pm.getProductPrice(\\"Apple\\") == 1.2 assert pm.getProductPrice(\\"Banana\\") == 0.5 assert pm.getProductPrice(\\"Cherry\\") == 2.5 assert pm.getProductPrice(\\"Mango\\") == -1.0","solution":"class Product: def __init__(self, name, price): self.name = name self.price = price class ProductManager: def __init__(self): self.products = [] def addProduct(self, name, price): self.products.append(Product(name, price)) def findProductsWithPriceHigherThan(self, minPrice): result = [product.name for product in self.products if product.price > minPrice] result.sort() return result def getProductPrice(self, name): for product in self.products: if product.name == name: return product.price return -1.0"},{"question":"def lexicographically_smallest_string(s: str) -> str: Given a string 's' that contains only lowercase English letters, you can perform the operation any number of times: choose two distinct indices i and j where s[i] == s[j] and swap the characters at i and j. Return the lexicographically smallest string that can be obtained by performing the above operations. >>> lexicographically_smallest_string(\\"cba\\") == \\"abc\\" >>> lexicographically_smallest_string(\\"baca\\") == \\"aabc\\" >>> lexicographically_smallest_string(\\"dcba\\") == \\"abcd\\" >>> lexicographically_smallest_string(\\"aabbcc\\") == \\"aabbcc\\" >>> lexicographically_smallest_string(\\"zyxw\\") == \\"wxyz\\" >>> lexicographically_smallest_string(\\"bbb\\") == \\"bbb\\" >>> lexicographically_smallest_string(\\"a\\") == \\"a\\" >>> lexicographically_smallest_string(\\"\\") == \\"\\"","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be obtained by performing the given operations. # Convert the string to a list of characters chars = list(s) # Sort the characters to achieve the lexicographically smallest string chars.sort() # Join the sorted characters back into a string smallest_string = ''.join(chars) return smallest_string"},{"question":"def find_first_digit_greater_than_x(s: str, x: int) -> int: Find the index of the first digit in the string \`s\` that is greater than the given integer \`x\`. Args: s (str): Input string containing lowercase English letters and numbers. x (int): The threshold integer. Returns: int: The index of the first digit greater than \`x\`, or -1 if no such digit exists. >>> find_first_digit_greater_than_x(\\"a1b2c3d4\\", 2) 5 >>> find_first_digit_greater_than_x(\\"abcdefgh\\", 1) -1 >>> find_first_digit_greater_than_x(\\"123\\", 5) -1 >>> find_first_digit_greater_than_x(\\"1a2b3c4\\", 1) 2 >>> find_first_digit_greater_than_x(\\"\\", 2) -1 >>> find_first_digit_greater_than_x(\\"a9b8c7d6\\", 7) 1","solution":"def find_first_digit_greater_than_x(s, x): Find the index of the first digit in the string \`s\` that is greater than the given integer \`x\`. Args: s (str): Input string containing lowercase English letters and numbers. x (int): The threshold integer. Returns: int: The index of the first digit greater than \`x\`, or -1 if no such digit exists. for index, char in enumerate(s): if char.isdigit() and int(char) > x: return index return -1"},{"question":"def max_points(s: str) -> int: Returns the maximum number of points by deleting substrings such that the total points earned are maximized. >>> max_points('a') == 1 >>> max_points('ab') == 1 >>> max_points('aaa') == 9 >>> max_points('aab') == 4 >>> max_points('abcdef') == 1","solution":"def max_points(s: str) -> int: Returns the maximum number of points by deleting substrings such that the total points earned are maximized. Parameters: s (str): The input string consisting of only lowercase English letters. Returns: int: The maximum number of points. def calculate_points(freq): return max(freq**2 for freq in letter_counts.values()) letter_counts = {} for char in s: if char in letter_counts: letter_counts[char] += 1 else: letter_counts[char] = 1 return calculate_points(letter_counts)"},{"question":"from collections import deque from typing import List, Tuple def bfs_farthest_node(start: int, graph: dict, n: int) -> Tuple[int, int]: Performs BFS to find the farthest node from the start node. pass # complete this function def max_distance(n: int, edges: List[Tuple[int, int]]) -> int: Finds the maximum distance between two nodes in a tree. >>> max_distance(1, []) == 0 True >>> max_distance(2, [(1, 2)]) == 1 True >>> max_distance(3, [(1, 2), (2, 3)]) == 2 True >>> max_distance(5, [(1, 2), (1, 3), (1, 4), (1, 5)]) == 2 True >>> max_distance(5, [(1, 2), (2, 3), (2, 4), (4, 5)]) == 3 True >>> max_distance(6, [(1, 2), (1, 3), (2, 4), (3, 5), (3, 6)]) == 4 True pass # complete this function","solution":"from collections import deque def bfs_farthest_node(start, graph, n): Performs BFS to find the farthest node from the start node. visited = [False] * (n + 1) distance = [0] * (n + 1) queue = deque([start]) visited[start] = True farthest_node = start while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True distance[neighbor] = distance[node] + 1 queue.append(neighbor) if distance[neighbor] > distance[farthest_node]: farthest_node = neighbor return farthest_node, distance[farthest_node] def max_distance(n, edges): Finds the maximum distance between two nodes in a tree. if n == 1: return 0 graph = {i: [] for i in range(1, n + 1)} for u, v in edges: graph[u].append(v) graph[v].append(u) # Perform BFS from an arbitrary node to find one endpoint of the longest path start = 1 farthest_node, _ = bfs_farthest_node(start, graph, n) # Perform BFS from the farthest node found to determine the longest path in the tree other_end, max_dist = bfs_farthest_node(farthest_node, graph, n) return max_dist"},{"question":"def longestStrChain(words: List[str]) -> int: Returns the length of the longest possible chain of words where each word can be formed by adding exactly one letter to the previous word in the chain. >>> longestStrChain([\\"a\\", \\"b\\", \\"ba\\", \\"bca\\", \\"bda\\", \\"bdca\\"]) 4 >>> longestStrChain([\\"abc\\", \\"bcd\\", \\"cde\\"]) 1 >>> longestStrChain([\\"a\\"]) 1 >>> longestStrChain([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\"]) 5 >>> longestStrChain([\\"xbc\\", \\"pcxbcf\\", \\"xb\\", \\"cxbc\\", \\"pcxbc\\"]) 5 >>> longestStrChain([\\"x\\", \\"y\\", \\"yz\\", \\"xyz\\", \\"wxyz\\", \\"vwxyz\\"]) 5","solution":"def longestStrChain(words): Returns the length of the longest possible chain of words where each word can be formed by adding exactly one letter to the previous word in the chain. :param words: List of strings where each string represents a word. :return: Length of the longest chain of words. words.sort(key=len) # Sort words by length longest_chain = {} max_length = 1 for word in words: current_length = 1 # Check all possible predecessors of the current word for i in range(len(word)): predecessor = word[:i] + word[i+1:] if predecessor in longest_chain: current_length = max(current_length, longest_chain[predecessor] + 1) longest_chain[word] = current_length max_length = max(max_length, current_length) return max_length"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inOrderTraversal(root: TreeNode) -> list[int]: Traverse the binary tree in-order and return the values as a list. >>> root = TreeNode(1) >>> inOrderTraversal(root) [1] >>> root = TreeNode(3, TreeNode(2, TreeNode(1))) >>> inOrderTraversal(root) [1, 2, 3] >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) >>> inOrderTraversal(root) [1, 2, 3] >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> inOrderTraversal(root) [2, 1, 3] >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) >>> inOrderTraversal(root) [4, 2, 5, 1, 6, 3, 7] >>> inOrderTraversal(None) []","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inOrderTraversal(root: TreeNode) -> list: result = [] stack = [] current = root while current is not None or stack: while current is not None: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result"},{"question":"def addStrings(num1: str, num2: str) -> str: Given two non-negative integers num1 and num2 represented as strings, return the sum of num1 and num2 as a string. Do not convert the input strings to integers directly. The function should handle arbitrarily large numbers. >>> addStrings(\\"123\\", \\"456\\") '579' >>> addStrings(\\"999\\", \\"1\\") '1000' >>> addStrings(\\"1\\", \\"999\\") '1000' >>> addStrings(\\"99\\", \\"99\\") '198' >>> addStrings(\\"001\\", \\"009\\") '010' >>> addStrings(\\"0001\\", \\"0009\\") '0010' >>> addStrings(\\"123456789012345678901234567890\\", \\"987654321098765432109876543210\\") '1111111110111111111011111111100' >>> addStrings(\\"5\\", \\"7\\") '12' >>> addStrings(\\"0\\", \\"0\\") '0'","solution":"def addStrings(num1, num2): Given two non-negative integers num1 and num2 represented as strings, returns the sum of num1 and num2 as a string. # Make sure num1 and num2 have the same length max_len = max(len(num1), len(num2)) num1 = num1.zfill(max_len) num2 = num2.zfill(max_len) carry = 0 result = [] # Start from the end of both strings for i in range(max_len - 1, -1, -1): n1 = ord(num1[i]) - ord('0') n2 = ord(num2[i]) - ord('0') total = n1 + n2 + carry carry = total // 10 result.append(total % 10) if carry > 0: result.append(carry) # The result is currently reversed result.reverse() return ''.join(map(str, result))"},{"question":"def min_diff_pair(arr): Given an unsorted array of positive integers, find a pair of integers (a, b) such that the difference between \`a\` and \`b\` is the minimum among all pairs in the array. If there are multiple pairs with the same minimum difference, return the pair with the smallest sum. If multiple pairs have the same sum, return the pair with the smallest first element. Return the pair as a tuple \`(a, b)\` with \`a <= b\`. >>> min_diff_pair([1]) None >>> min_diff_pair([1, 2, 3, 4, 5]) (1, 2) >>> min_diff_pair([5, 4, 3, 2, 1]) (1, 2) >>> min_diff_pair([4, 2, 5, 9, 1, 8]) (1, 2) >>> min_diff_pair([1, 5, 3, 19, 18, 25]) (18, 19) >>> min_diff_pair([1, 1, 3, 3]) (1, 1) >>> min_diff_pair([1, 2, 3, 4, 1, 9]) (1, 1) >>> min_diff_pair([5, 20, 3, 2, 50, 80]) (2, 3)","solution":"def min_diff_pair(arr): Given an unsorted array of positive integers, find a pair (a, b) such that the difference between a and b is the minimum among all pairs. If multiple pairs have the same minimum difference, return the pair with the smallest sum. If multiple pairs have the same sum, return the pair with the smallest first element. Return the pair as a tuple (a, b) with a <= b. if len(arr) < 2: return None # Sort the array arr.sort() min_diff = float('inf') candidate_pairs = [] for i in range(len(arr) - 1): a, b = arr[i], arr[i + 1] diff = b - a if diff < min_diff: min_diff = diff candidate_pairs = [(a, b)] elif diff == min_diff: candidate_pairs.append((a, b)) # Find the pair with the smallest sum, and if tie, smallest first element. candidate_pairs.sort(key=lambda x: (x[0] + x[1], x[0])) return candidate_pairs[0]"},{"question":"def max_apples(grid): Returns the maximum number of apples that can be collected from the top-left to the bottom-right cell in the grid. >>> max_apples([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) 29 >>> max_apples([ [1, 0, 2], [2, 3, 1], [1, 1, 4] ]) 11 >>> max_apples([ [1, 2, 3, 4] ]) 10 >>> max_apples([]) 0","solution":"def max_apples(grid): Returns the maximum number of apples that can be collected from the top-left to the bottom-right cell in the grid. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Initialize a dp table with the same dimensions as the grid dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"from typing import List def can_finish(numCourses: int, dependencies: List[List[int]]) -> bool: Determine if you can finish all courses given the prerequisites. :param numCourses: int, the total number of courses :param dependencies: list of list of int, each element [a, b] means course a has a prerequisite course b :returns: bool, True if all courses can be finished, otherwise False >>> can_finish(2, [[1, 0]]) True >>> can_finish(2, [[1, 0], [0, 1]]) False >>> can_finish(4, [[1, 0], [2, 1], [3, 2]]) True >>> can_finish(3, [[1, 0], [2, 0], [0, 2]]) False >>> can_finish(5, [[0, 1], [1, 2], [2, 3], [3, 4], [3, 0]]) False >>> can_finish(3, []) True","solution":"from collections import defaultdict, deque def can_finish(numCourses, dependencies): Determine if you can finish all courses given the prerequisites. :param numCourses: int, the total number of courses :param dependencies: list of list of int, each element [a, b] means course a has a prerequisite course b :returns: bool, True if all courses can be finished, otherwise False adjacency_list = defaultdict(list) in_degree = {i: 0 for i in range(numCourses)} # Build the graph and compute in-degrees of nodes for dest, src in dependencies: adjacency_list[src].append(dest) in_degree[dest] += 1 # Queue for nodes with no incoming edges zero_in_degree_queue = deque([k for k in in_degree if in_degree[k] == 0]) visited_count = 0 while zero_in_degree_queue: node = zero_in_degree_queue.popleft() visited_count += 1 for neighbor in adjacency_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) return visited_count == numCourses"},{"question":"def count_unique_letter_substrings(S: str) -> int: Returns the number of unique letter substrings of the given string S. >>> count_unique_letter_substrings('a') 1 >>> count_unique_letter_substrings('ab') 3 >>> count_unique_letter_substrings('aaa') 3 >>> count_unique_letter_substrings('abc') 6 >>> count_unique_letter_substrings('abac') 8 >>> count_unique_letter_substrings('abcd') 10","solution":"def count_unique_letter_substrings(S): Returns the number of unique letter substrings of the given string S. n = len(S) total_unique_substrings = 0 for i in range(n): seen_letters = set() for j in range(i, n): if S[j] in seen_letters: break seen_letters.add(S[j]) total_unique_substrings += 1 return total_unique_substrings"},{"question":"def max_buildings_climbed(heights: List[int], bricks: int) -> int: Given \`heights\` list representing heights of buildings and \`bricks\` representing number of bricks, determine the maximum number of buildings you can climb starting from the first one with the available bricks. Args: heights (List[int]): List of building heights. bricks (int): Number of bricks available. Returns: int: Maximum number of buildings climbed. >>> max_buildings_climbed([3, 3, 3, 3, 3], 5) == 5 >>> max_buildings_climbed([3, 2, 2, 4, 1], 2) == 4 >>> max_buildings_climbed([3, 2, 1, 2, 1], 1) == 2 >>> max_buildings_climbed([10, 9, 8, 7, 6], 0) == 1 >>> max_buildings_climbed([1, 2, 3, 2, 1], 5) == 5 >>> max_buildings_climbed([8, 6, 7, 5, 6], 4) == 5","solution":"def max_buildings_climbed(heights, bricks): Given \`heights\` list representing heights of buildings and \`bricks\` representing number of bricks, determine the maximum number of buildings you can climb starting from the first one with the available bricks. Args: heights (List[int]): List of building heights. bricks (int): Number of bricks available. Returns: int: Maximum number of buildings climbed. used_bricks = 0 buildings_climbed = 1 for i in range(1, len(heights)): if heights[i] >= heights[i - 1]: buildings_climbed += 1 else: difference = heights[i - 1] - heights[i] if used_bricks + difference <= bricks: used_bricks += difference buildings_climbed += 1 else: break return buildings_climbed"},{"question":"from typing import List def search_matrix(matrix: List[List[int]], target: int) -> List[int]: Returns the position of the target value within the matrix if found, otherwise returns [-1, -1]. Args: matrix (list of list of int): 2D sorted matrix. target (int): The target value to search for. Returns: list: A list containing the row and column indices of the target if found, otherwise [-1, -1]. >>> search_matrix([ ... [0, 1, 2, 3], ... [1, 2, 3, 4], ... [2, 3, 4, 5] ...], 3) == [0, 3] >>> search_matrix([ ... [0, 1, 2, 3], ... [1, 2, 3, 4], ... [2, 3, 4, 5] ...], 6) == [-1, -1]","solution":"def search_matrix(matrix, target): Returns the position of the target value within the matrix if found, otherwise returns [-1, -1]. Args: matrix (list of list of int): 2D sorted matrix. target (int): The target value to search for. Returns: list: A list containing the row and column indices of the target if found, otherwise [-1, -1]. if not matrix or not matrix[0]: return [-1, -1] rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return [row, col] elif matrix[row][col] < target: row += 1 else: col -= 1 return [-1, -1]"},{"question":"class RangeAddition: Initializes a list of zeroes with size \`n\`, and supports range addition operations. def __init__(self, n: int): Initializes a list of zeroes with size \`n\`. def addRange(self, left: int, right: int, inc: int): Adds \`inc\` to all the elements within the inclusive range \`[left, right]\`. def getModifiedList(self) -> list[int]: Returns the modified list after all the range addition operations are performed.","solution":"class RangeAddition: def __init__(self, n): Initializes a list of zeroes with size \`n\`. self.n = n self.diff = [0] * (n + 1) # Using a difference array to optimize range updates def addRange(self, left, right, inc): Adds \`inc\` to all the elements within the inclusive range \`[left, right]\`. self.diff[left] += inc if right + 1 < self.n: self.diff[right + 1] -= inc def getModifiedList(self): Returns the modified list after all the range addition operations are performed. res = [0] * self.n res[0] = self.diff[0] for i in range(1, self.n): res[i] = res[i-1] + self.diff[i] return res"},{"question":"from typing import List def findAndReplacePattern(words: List[str], pattern: str) -> List[str]: Return a list of words that match the specified pattern. >>> findAndReplacePattern([\\"abc\\",\\"deq\\",\\"mee\\",\\"aqq\\",\\"dkd\\",\\"ccc\\"], \\"abb\\") ['mee', 'aqq'] >>> findAndReplacePattern([\\"abc\\", \\"xyz\\", \\"123\\"], \\"111\\") [] >>> findAndReplacePattern([\\"xyz\\", \\"abc\\", \\"123\\"], \\"abc\\") ['xyz', 'abc', '123'] >>> findAndReplacePattern([\\"xyz\\", \\"aaa\\", \\"bbb\\"], \\"mmm\\") ['aaa', 'bbb'] >>> findAndReplacePattern([], \\"abc\\") [] >>> findAndReplacePattern([\\"a\\", \\"b\\", \\"c\\"], \\"a\\") ['a', 'b', 'c']","solution":"def findAndReplacePattern(words, pattern): def encode(word): mapping = {} return [mapping.setdefault(char, len(mapping)) for char in word] pattern_encoded = encode(pattern) return [word for word in words if encode(word) == pattern_encoded]"},{"question":"def can_partition(nums, m, max_sum): Helper function to determine if we can partition the list into m subarrays with the given maximum sum. pass def minimize_max_sum(nums, m): Given a list of integers \`nums\` and an integer \`m\`, partition the list into \`m\` contiguous subarrays such that the maximum sum of the subarrays is minimized. Return the minimized maximum sum. >>> minimize_max_sum([7, 2, 5, 10, 8], 2) 18 >>> minimize_max_sum([1, 2, 3, 4, 5], 5) 5 >>> minimize_max_sum([1, 2, 3, 4, 5], 1) 15 >>> minimize_max_sum([1, 4, 4, 4, 5, 9, 11, 14], 3) 20 >>> minimize_max_sum([1, 2, 3, 4, 5], 2) 9 pass","solution":"def can_partition(nums, m, max_sum): Helper function to determine if we can partition the list into m subarrays with the given maximum sum. current_sum = 0 count = 1 for num in nums: if current_sum + num > max_sum: count += 1 current_sum = num if count > m: return False else: current_sum += num return True def minimize_max_sum(nums, m): Returns the minimized maximum sum of the m partitions. left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_partition(nums, m, mid): right = mid else: left = mid + 1 return left"},{"question":"from typing import List def findAnagrams(s: str, p: str) -> List[int]: Finds all start indices of p's anagrams in s and returns them as a list in ascending order. >>> findAnagrams(\\"cbaebabacd\\", \\"abc\\") [0, 6] >>> findAnagrams(\\"abcdefg\\", \\"g\\") [6] >>> findAnagrams(\\"abcdefg\\", \\"hij\\") [] >>> findAnagrams(\\"abab\\", \\"ab\\") [0, 1, 2] >>> findAnagrams(\\"\\", \\"\\") [] >>> findAnagrams(\\"a\\", \\"aa\\") []","solution":"from collections import Counter from typing import List def findAnagrams(s: str, p: str) -> List[int]: Finds all start indices of p's anagrams in s and returns them as a list in ascending order. len_s, len_p = len(s), len(p) result = [] if len_p > len_s: return result p_count = Counter(p) s_count = Counter() for i in range(len_s): s_count[s[i]] += 1 # add current char to the window if i >= len_p: if s_count[s[i - len_p]] == 1: del s_count[s[i - len_p]] # remove char at the beginning as it slides out of the window else: s_count[s[i - len_p]] -= 1 # decrement count of the char as it slides if s_count == p_count: result.append(i - len_p + 1) return result"},{"question":"def most_frequent_book(titles: List[str]) -> str: Returns the title that appears most frequently in the list of book titles. In case of a tie, returns the title that comes first lexicographically. >>> most_frequent_book([\\"A\\"]) == \\"A\\" >>> most_frequent_book([\\"A\\", \\"B\\", \\"A\\", \\"C\\", \\"A\\"]) == \\"A\\" >>> most_frequent_book([\\"A\\", \\"B\\", \\"A\\", \\"B\\"]) == \\"A\\" >>> most_frequent_book([\\"X\\", \\"Y\\", \\"Z\\"]) == \\"X\\" >>> most_frequent_book([\\"Book B\\", \\"Book A\\", \\"Book A\\", \\"Book C\\", \\"Book B\\", \\"Book B\\"]) == \\"Book B\\" >>> most_frequent_book([\\"Book Z\\", \\"Book X\\", \\"Book Y\\", \\"Book X\\", \\"Book Y\\", \\"Book Z\\"]) == \\"Book X\\"","solution":"def most_frequent_book(titles): Returns the title that appears most frequently in the list of book titles. In case of a tie, returns the title that comes first lexicographically. from collections import Counter # Count occurrences of each title title_count = Counter(titles) # Find the maximum frequency max_frequency = max(title_count.values()) # Filter titles with the maximum frequency most_frequent_titles = [title for title, count in title_count.items() if count == max_frequency] # Return the lexicographically smallest title return min(most_frequent_titles)"},{"question":"def count_divisible_pairs(arr, k): Returns the count of distinct pairs (i, j) where i < j such that arr[i] + arr[j] is divisible by k. >>> count_divisible_pairs([1, 2, 3, 4, 5], 3) 4 >>> count_divisible_pairs([1, 2, 3, 4, 5], 10) 0 >>> count_divisible_pairs([2, 2, 2, 2], 4) 6 >>> count_divisible_pairs([1, 2, 3, 4, 5, 6], 5) 3 >>> count_divisible_pairs([1, 1, 1, 1, 1], 10) 0 >>> count_divisible_pairs([1], 1) 0","solution":"def count_divisible_pairs(arr, k): Returns the count of distinct pairs (i, j) where i < j such that arr[i] + arr[j] is divisible by k. count = 0 n = len(arr) for i in range(n): for j in range(i + 1, n): if (arr[i] + arr[j]) % k == 0: count += 1 return count"},{"question":"def minMovesToRemoveKStones(nums: List[int], k: int) -> int: Returns the minimum number of moves to remove exactly k stones from the sequence. Parameters: nums (list): An array of integers where each integer represents the number of stones on a consecutive tile. k (int): The exact number of stones to be removed. Returns: int: The minimum number of moves to remove exactly k stones. >>> minMovesToRemoveKStones([5, 3, 4, 2], 8) == 2 >>> minMovesToRemoveKStones([5, 3, 4, 2], 0) == 0 >>> minMovesToRemoveKStones([1, 1, 1, 1], 4) == 4 >>> minMovesToRemoveKStones([1, 2, 3], 10) == -1 >>> minMovesToRemoveKStones([7, 2, 5], 7) == 1","solution":"def minMovesToRemoveKStones(nums, k): Returns the minimum number of moves to remove exactly k stones from the sequence. Parameters: nums (list): An array of integers where each integer represents the number of stones on a consecutive tile. k (int): The exact number of stones to be removed. Returns: int: The minimum number of moves to remove exactly k stones. if k == 0: return 0 moves = float('inf') # Traverse through each tile for i in range(len(nums)): total_stones = 0 for j in range(i, len(nums)): total_stones += nums[j] if total_stones == k: moves = min(moves, j - i + 1) break if total_stones > k: break return moves if moves != float('inf') else -1"},{"question":"from typing import List def count_k_alphabetical_strings(words: List[str], k: int) -> int: Returns the count of strings that contain at least k different alphabets. :param words: List of strings :param k: Integer representing the minimum number of different alphabets required :return: Integer count of k-alphabetical strings >>> count_k_alphabetical_strings([\\"a\\", \\"b\\", \\"c\\"], 2) 0 >>> count_k_alphabetical_strings([\\"ab\\", \\"aaa\\", \\"abc\\"], 2) 2 >>> count_k_alphabetical_strings([\\"abcd\\", \\"efgh\\"], 3) 2 >>> count_k_alphabetical_strings([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"], 3) 2 >>> count_k_alphabetical_strings([\\"abcd\\", \\"efgh\\"], 5) 0 >>> count_k_alphabetical_strings([\\"abc\\", \\"def\\", \\"ghi\\"], 3) 3","solution":"def count_k_alphabetical_strings(words, k): Returns the count of strings that contain at least k different alphabets. :param words: List of strings :param k: Integer representing the minimum number of different alphabets required :return: Integer count of k-alphabetical strings count = 0 for word in words: if len(set(word)) >= k: count += 1 return count"},{"question":"def max_items_within_budget(prices: List[int], budget: int) -> int: Determines the maximum number of items that can be bought without exceeding the budget. :param prices: List of integers representing prices of different items. :param budget: An integer representing the budget. :return: Maximum number of items that can be bought within the given budget. >>> max_items_within_budget([1, 2, 3, 4, 5], 10) 4 >>> max_items_within_budget([2, 2, 2, 2, 2], 6) 3 >>> max_items_within_budget([5, 3, 8, 1], 10) 3 >>> max_items_within_budget([10, 15, 20], 5) 0 >>> max_items_within_budget([5], 5) 1 >>> max_items_within_budget([], 5) 0 pass","solution":"def max_items_within_budget(prices, budget): Determines the maximum number of items that can be bought without exceeding the budget. :param prices: List of integers representing prices of different items. :param budget: An integer representing the budget. :return: Maximum number of items that can be bought within the given budget. # Sort the prices in ascending order prices.sort() # Initialize variables total_spent = 0 items_count = 0 # Iterate through the sorted prices and count the number of items bought within the budget for price in prices: if total_spent + price <= budget: total_spent += price items_count += 1 else: break return items_count"},{"question":"def rotate_left_by_one(n: int) -> int: Rotates the digits of the integer n by 1 position to the left. If n is negative, the negative sign is ignored during the rotation and added back in the result. Parameters: n (int): The integer to be rotated. Returns: int: The resulting integer after rotation. >>> rotate_left_by_one(12345) 23451 >>> rotate_left_by_one(-123) -231 >>> rotate_left_by_one(7) 7 >>> rotate_left_by_one(-9) -9 >>> rotate_left_by_one(0) 0 >>> rotate_left_by_one(9876543210) 8765432109 >>> rotate_left_by_one(-9876543210) -8765432109 pass","solution":"def rotate_left_by_one(n): Rotates the digits of the integer n by 1 position to the left. If n is negative, the negative sign is ignored during the rotation and added back in the result. Parameters: n (int): The integer to be rotated. Returns: int: The resulting integer after rotation. is_negative = n < 0 num_str = str(abs(n)) if len(num_str) == 1: return n # Single digit numbers remain unchanged rotated_num_str = num_str[1:] + num_str[0] rotated_num = int(rotated_num_str) return -rotated_num if is_negative else rotated_num"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def odd_even_list(head): Rearrange the linked list such that all nodes with odd indices appear before nodes with even indices. >>> head = create_linked_list([1, 2, 3, 4, 5]) >>> new_head = odd_even_list(head) >>> result = linked_list_to_list(new_head) >>> result [1, 3, 5, 2, 4] pass # Helper function to create a linked list from a list def create_linked_list(lst): if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head # Helper function to convert linked list to list def linked_list_to_list(head): result = [] while head: result.append(head.val) head = head.next return result","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def odd_even_list(head): if not head or not head.next: return head odd = head even = head.next even_head = even while even and even.next: odd.next = odd.next.next even.next = even.next.next odd = odd.next even = even.next odd.next = even_head return head # Helper function to create a linked list from a list def create_linked_list(lst): if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head # Helper function to convert linked list to list def linked_list_to_list(head): result = [] while head: result.append(head.val) head = head.next return result"},{"question":"def num_islands(grid: List[List[int]]) -> int: Given a non-empty 2D array \`grid\` of integers representing a land map where \`0\` represents water and \`1\` represents land, identify the number of distinct islands. An island is a group of \`1\`s (land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. >>> num_islands([ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 1, 0]]) 2 >>> num_islands([ [0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> num_islands([ [1, 1, 1], [1, 1, 1], [1, 1, 1]]) 1 >>> num_islands([ [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]) 6 >>> num_islands([ [1, 0, 0], [0, 1, 0], [0, 0, 1]]) 3","solution":"def num_islands(grid): Returns the number of distinct islands in the given 2D grid. if not grid: return 0 def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 # mark as visited for dx, dy in directions: nx, ny = x + dx, y + dy dfs(nx, ny) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: islands += 1 dfs(i, j) return islands"},{"question":"def find_min(nums: List[int]) -> int: Find the minimum element in a rotated sorted array. >>> find_min([1, 2, 3, 4, 5]) == 1 >>> find_min([3, 4, 5, 1, 2]) == 1 >>> find_min([1]) == 1 >>> find_min([2, 1]) == 1 >>> find_min([6, 7, 1, 2, 3, 4, 5]) == 1 >>> find_min([1, 2, 3, 4, 5, 6, 7]) == 1 >>> find_min([4, 5, 6, 1, 2, 3]) == 1 >>> find_min([2, 3, 4, 5, 6, 1]) == 1 >>> find_min([1, 2, 3, 4, 5, 6]) == 1","solution":"def find_min(nums): Find the minimum element in a rotated sorted array. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[right]: left = mid + 1 else: right = mid return nums[left]"},{"question":"def max_area(heights: List[int]) -> int: Returns the maximum area of water that can be contained between the buildings. :param heights: List[int] representing the heights of buildings. :return: int representing the maximum area of water. pass from solution import max_area def test_max_area_example_case(): assert max_area([1,8,6,2,5,4,8,3,7]) == 49 def test_max_area_all_equal(): assert max_area([1,1,1,1]) == 3 def test_max_area_decreasing_heights(): assert max_area([4,3,2,1]) == 4 def test_max_area_mixed_heights(): assert max_area([1,2,4,3]) == 4 def test_max_area_two_elements(): assert max_area([1,2]) == 1 assert max_area([2,2]) == 2 def test_max_area_single_element(): assert max_area([5]) == 0 def test_max_area_large_input(): assert max_area([1000] * 1000) == 999000","solution":"def max_area(heights): Returns the maximum area of water that can be contained between the buildings. :param heights: List[int] representing the heights of buildings. :return: int representing the maximum area of water. left, right = 0, len(heights) - 1 max_area = 0 while left < right: width = right - left height = min(heights[left], heights[right]) max_area = max(max_area, width * height) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class ImmutableLinkedListIterator: Initializes the iterator with the head of the linked list. ImmutableLinkedListIterator(ListNode head) Returns the next element in the linked list and moves the pointer to the next element. int next() Returns true if there are still elements in the linked list. boolean hasNext() Returns the number of elements in the linked list that are smaller than x. int countSmaller(int x)","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class ImmutableLinkedListIterator: def __init__(self, head: ListNode): self.head = head self.current = head def next(self) -> int: if self.current is not None: val = self.current.val self.current = self.current.next return val def hasNext(self) -> bool: return self.current is not None def countSmaller(self, x: int) -> int: count = 0 node = self.head while node is not None: if node.val < x: count += 1 node = node.next return count"},{"question":"def partition_string(s: str) -> List[int]: Partitions the string into as few substrings as possible such that each substring contains only one unique character. Returns the list of the lengths of the substrings after partitioning. >>> partition_string(\\"aaabbbcc\\") [3, 3, 2] >>> partition_string(\\"aaaaa\\") [5] >>> partition_string(\\"abcabc\\") [1, 1, 1, 1, 1, 1] >>> partition_string(\\"\\") [] >>> partition_string(\\"aabbccddee\\") [2, 2, 2, 2, 2] >>> partition_string(\\"abcdef\\") [1, 1, 1, 1, 1, 1]","solution":"def partition_string(s): Partitions the string into as few substrings as possible such that each substring contains only one unique character. Returns the list of the lengths of the substrings after partitioning. if not s: return [] result = [] current_char = s[0] count = 0 for char in s: if char == current_char: count += 1 else: result.append(count) current_char = char count = 1 # Append the last counted substring result.append(count) return result"},{"question":"def maxLength(arr): Returns the length of the longest string that can be formed by concatenating some of the given strings such that each letter from 'a' to 'z' appears at most once in the concatenated string. >>> maxLength([\\"un\\", \\"iq\\", \\"ue\\"]) == 4 >>> maxLength([\\"cha\\", \\"r\\", \\"act\\", \\"ers\\"]) == 6 >>> maxLength([\\"abcdefghijklmnopqrstuvwxyz\\"]) == 26 >>> maxLength([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\", \\"g\\", \\"h\\", \\"i\\", \\"j\\"]) == 10 >>> maxLength([\\"ab\\", \\"cd\\", \\"ab\\"]) == 4 >>> maxLength([\\"a\\", \\"abc\\", \\"d\\", \\"de\\", \\"def\\"]) == 6","solution":"def maxLength(arr): Returns the length of the longest string that can be formed by concatenating some of the given strings such that each letter from 'a' to 'z' appears at most once in the concatenated string. def is_unique(s): Checks if all characters in the string 's' are unique. return len(s) == len(set(s)) def backtrack(start, current): Backtracks to generate all possible combinations and keep track of the maximum length. max_len = len(current) for i in range(start, len(arr)): new_str = arr[i] if is_unique(new_str) and not set(current) & set(new_str): max_len = max(max_len, backtrack(i + 1, current + new_str)) return max_len return backtrack(0, \\"\\")"},{"question":"def min_distance(s: str, t: str) -> int: Calculates the minimum number of operations required to transform string s into string t. Operations include insertions, deletions, and replacements. >>> min_distance(\\"abc\\", \\"abc\\") == 0 >>> min_distance(\\"abc\\", \\"abcd\\") == 1 >>> min_distance(\\"a\\", \\"ab\\") == 1 >>> min_distance(\\"abcd\\", \\"abc\\") == 1 >>> min_distance(\\"ab\\", \\"a\\") == 1 >>> min_distance(\\"abc\\", \\"abd\\") == 1 >>> min_distance(\\"a\\", \\"b\\") == 1 >>> min_distance(\\"intention\\", \\"execution\\") == 5 >>> min_distance(\\"saturday\\", \\"sunday\\") == 3 >>> min_distance(\\"\\", \\"\\") == 0 >>> min_distance(\\"\\", \\"a\\") == 1 >>> min_distance(\\"a\\", \\"\\") == 1","solution":"def min_distance(s, t): Calculates the minimum number of operations required to transform string s into string t. :param s: Source string :param t: Target string :return: Minimum number of operations m, n = len(s), len(t) # Create a matrix to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # Insert all characters of t elif j == 0: dp[i][j] = i # Remove all characters of s elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"def smallest_missing_positive(nums: List[int]) -> int: Given a list of non-negative integers \`nums\`, find the smallest missing positive integer. >>> smallest_missing_positive([3, 4, -1, 1]) 2 >>> smallest_missing_positive([1, 2, 3]) 4 >>> smallest_missing_positive([1, 2, 0]) 3 >>> smallest_missing_positive([2]) 1 >>> smallest_missing_positive([1]) 2 >>> smallest_missing_positive([]) 1 >>> smallest_missing_positive([100, 200, 300]) 1","solution":"def smallest_missing_positive(nums): Returns the smallest missing positive integer from the list of non-negative integers. nums = set(nums) i = 1 while i in nums: i += 1 return i"},{"question":"def max_sum_submatrix(grid: List[List[int]]) -> int: Returns the maximum sum of any non-empty submatrix by potentially deleting zero or more rows and/or columns from the grid. >>> max_sum_submatrix([[5]]) 5 >>> max_sum_submatrix([[-5]]) -5 >>> max_sum_submatrix([[1, -2, 3, 4, -1]]) 7 >>> max_sum_submatrix([[1], [-2], [3], [4], [-1]]) 7 >>> max_sum_submatrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) 45 >>> max_sum_submatrix([ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ]) -1 >>> max_sum_submatrix([ [1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6] ]) 29 >>> max_sum_submatrix([]) 0 >>> max_sum_submatrix([[]]) 0 >>> max_sum_submatrix([ [-1, -1, -1], [-1, 10, -1], [-1, -1, -1] ]) 10","solution":"def max_sum_submatrix(grid): Returns the maximum sum of any non-empty submatrix by potentially deleting zero or more rows and/or columns from the grid. def max_subarray_sum(nums): max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) max_sum = float('-inf') for left in range(cols): temp = [0] * rows for right in range(left, cols): for i in range(rows): temp[i] += grid[i][right] current_max_sum = max_subarray_sum(temp) max_sum = max(max_sum, current_max_sum) return max_sum"},{"question":"from typing import List def combination_sum2(arr: List[int], target: int) -> List[List[int]]: Given a list of integers \`arr\` and an integer \`target\`, return all unique combinations in \`arr\` where the integers sum to \`target\`. Each number in \`arr\` may only be used once in the combination. The combinations can be returned in any order. The solution set must not contain duplicate combinations. >>> combination_sum2([10, 1, 2, 7, 6, 1, 5], 8) [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]] >>> combination_sum2([2, 4, 6], 5) [] >>> combination_sum2([2, 3, 5, 6], 6) [[6]] >>> combination_sum2([], 3) [] >>> combination_sum2([1, 2, 3, 4], 7) [[1, 2, 4], [3, 4]]","solution":"from typing import List def combination_sum2(arr: List[int], target: int) -> List[List[int]]: arr.sort() result = [] def backtrack(start, target, path): if target == 0: result.append(path) return for i in range(start, len(arr)): if i > start and arr[i] == arr[i-1]: continue if arr[i] > target: break backtrack(i + 1, target - arr[i], path + [arr[i]]) backtrack(0, target, []) return result"},{"question":"from typing import List def min_steps(grid: List[List[str]], startX: int, startY: int, endX: int, endY: int) -> int: Given a grid of size \`m x n\`, an initial starting point \`(startX, startY)\`, and a destination point \`(endX, endY)\`, determine the **minimum** number of steps required to move from the start to the destination. You can move up, down, left, or right, but you cannot move through obstacles represented by the character \`'#'\`. Empty spaces are represented by the character \`'.'\`. If it is not possible to reach the destination, return \`-1\`. >>> grid = [['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.']] >>> min_steps(grid, 0, 0, 2, 2) 4 >>> grid = [['.', '#', '.'], ['.', '#', '.'], ['.', '#', '.']] >>> min_steps(grid, 0, 0, 2, 2) -1 >>> grid = [['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.']] >>> min_steps(grid, 0, 0, 0, 0) 0","solution":"from collections import deque def min_steps(grid, startX, startY, endX, endY): Determines the minimum number of steps required to move from (startX, startY) to (endX, endY). Returns -1 if it is not possible to reach the destination. if not grid or not grid[0] or grid[startX][startY] == '#' or grid[endX][endY] == '#': return -1 m, n = len(grid), len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(startX, startY, 0)]) # (x, y, steps) visited = set((startX, startY)) while queue: x, y, steps = queue.popleft() if x == endX and y == endY: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def numIslands(grid: List[List[str]]) -> int: Return the total number of islands in the given grid. >>> numIslands([ ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"] ... ]) 3 >>> numIslands([ ... [\\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\"] ... ]) 0 >>> numIslands([ ... [\\"1\\", \\"0\\", \\"1\\", \\"0\\", \\"1\\"], ... [\\"0\\", \\"1\\", \\"0\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"0\\", \\"1\\", \\"0\\", \\"1\\"], ... [\\"0\\", \\"1\\", \\"0\\", \\"1\\", \\"0\\"] ... ]) 10 >>> numIslands([ ... [\\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\"] ... ]) 1 >>> numIslands([]) 0 >>> numIslands([ ... [\\"1\\"] ... ]) 1 >>> numIslands([ ... [\\"0\\"] ... ]) 0","solution":"def numIslands(grid): Returns the number of islands in the given grid. if not grid: return 0 def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0': return grid[i][j] = '0' # Mark the cell as visited dfs(grid, i + 1, j) dfs(grid, i - 1, j) dfs(grid, i, j + 1) dfs(grid, i, j - 1) count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': dfs(grid, i, j) count += 1 return count"},{"question":"def remove_duplicate_letters(s: str) -> str: Determine the lexicographically smallest string after removing duplicate letters from the input string. >>> remove_duplicate_letters(\\"bcabc\\") 'abc' >>> remove_duplicate_letters(\\"abcd\\") 'abcd' >>> remove_duplicate_letters(\\"aaaaa\\") 'a' >>> remove_duplicate_letters(\\"cbacdcbc\\") 'acdb' >>> remove_duplicate_letters(\\"cdadabcc\\") 'adbc' >>> remove_duplicate_letters(\\"a\\") 'a' >>> remove_duplicate_letters(\\"\\") '' >>> remove_duplicate_letters(\\"abacb\\") 'abc'","solution":"def remove_duplicate_letters(s): Returns the lexicographically smallest string that can be obtained by removing duplicate letters from the input string. counter = {char: 0 for char in set(s)} for char in s: counter[char] += 1 stack = [] seen = set() for char in s: if char in seen: counter[char] -= 1 continue while stack and char < stack[-1] and counter[stack[-1]] > 0: seen.remove(stack.pop()) stack.append(char) seen.add(char) counter[char] -= 1 return ''.join(stack)"},{"question":"class Node: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root): Given the root of a binary tree, connect each node to its next right node in the same level using a pointer in place. If there is no next right node, the pointer should be set to NULL. Initially, all next right pointers are set to NULL. The binary tree could be a complete binary tree but not necessarily a perfect binary tree. Return the root of the modified tree. >>> root = Node(1) >>> root.left = Node(2) >>> root.right = Node(3) >>> root.left.left = Node(4) >>> root.left.right = Node(5) >>> root.right.right = Node(7) >>> connect(root) >>> root.left.next == root.right True >>> root.left.left.next == root.left.right True >>> root.left.right.next == root.right.right True >>> root.right.next is None True","solution":"class Node: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root): if not root: return root # Start with the root node current_level_start = root while current_level_start: # Set up a dummy node to build the next level connections dummy_head = Node(0) current = dummy_head node = current_level_start while node: if node.left: current.next = node.left current = current.next if node.right: current.next = node.right current = current.next node = node.next # Move to the next level current_level_start = dummy_head.next return root"},{"question":"from typing import List def min_max_diff_path(grid: List[List[int]]) -> int: Finds the minimum possible value of the maximum height difference between adjacent cells of the path from top-left corner to bottom-right corner of the grid. Args: grid: List[List[int]] - The m x n grid filled with non-negative numbers. Returns: int: The minimum possible value of the maximum height difference. pass def test_min_max_diff_path_1(): grid = [ [1, 2, 2], [3, 8, 2], [5, 3, 5] ] assert min_max_diff_path(grid) == 2 def test_min_max_diff_path_2(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert min_max_diff_path(grid) == 3 def test_min_max_diff_path_3(): grid = [ [1, 0, 1], [0, 1, 0], [1, 0, 1] ] assert min_max_diff_path(grid) == 1 def test_min_max_diff_path_single_cell(): grid = [[0]] assert min_max_diff_path(grid) == 0 def test_min_max_diff_path_equal_heights(): grid = [ [3, 3, 3], [3, 3, 3], [3, 3, 3] ] assert min_max_diff_path(grid) == 0","solution":"from heapq import heappush, heappop def min_max_diff_path(grid): Finds the minimum possible value of the maximum height difference between adjacent cells of the path from top-left corner to bottom-right corner of the grid. Args: grid: List[List[int]] - The m x n grid filled with non-negative numbers. Returns: int: The minimum possible value of the maximum height difference. m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < m and 0 <= y < n def dijkstra(): min_heap = [(0, 0, 0)] # (max_diff, x, y) max_diff_grid = [[float('inf')] * n for _ in range(m)] max_diff_grid[0][0] = 0 while min_heap: max_diff, x, y = heappop(min_heap) if x == m - 1 and y == n - 1: return max_diff for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): curr_diff = abs(grid[nx][ny] - grid[x][y]) max_diff_path = max(max_diff, curr_diff) if max_diff_path < max_diff_grid[nx][ny]: max_diff_grid[nx][ny] = max_diff_path heappush(min_heap, (max_diff_path, nx, ny)) return dijkstra()"},{"question":"def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Finds all unique pairs of integers in the list that sum up to the target. Each pair should be represented as a tuple, and each integer in the pair should be sorted in non-decreasing order. Args: nums (List[int]): List of integers. target (int): Target sum. Returns: List[Tuple[int, int]]: A list of unique pairs (tuples) that sum up to the target. >>> find_pairs([1, 2, 3, 4, 3, 2, 1], 4) == [(1, 3), (2, 2)] >>> find_pairs([1, 2, 3, 5, 6], 10) == [] >>> find_pairs([1, 1, 2, 3], 4) == [(1, 3)] >>> find_pairs([0, 0, 0, 0], 0) == [(0, 0)] >>> find_pairs([-1, 1, 0, 2, -2, 3], 1) == [(-2, 3), (-1, 2), (0, 1)] >>> find_pairs([], 5) == [] pass","solution":"def find_pairs(nums, target): Finds all unique pairs of integers in the list nums that sum up to the target. Args: nums (list): List of integers. target (int): Target sum. Returns: list: A list of unique pairs (tuples) that sum up to the target. nums.sort() left, right = 0, len(nums) - 1 seen_pairs = set() result = [] while left < right: current_sum = nums[left] + nums[right] if current_sum == target: pair = (nums[left], nums[right]) if pair not in seen_pairs: seen_pairs.add(pair) result.append(pair) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def closestNode(root: TreeNode, queries: List[int]) -> List[int]: You are given a binary search tree (BST) with distinct values and an array \`queries\`. For each query \`queries[i]\`, find the value in the BST that is closest to \`queries[i]\`. If there are multiple such values, return the smallest one. The function should return an array of integers where the \`i-th\` element is the closest value in the BST to \`queries[i]\`. >>> root = TreeNode(4) >>> root.left = TreeNode(2) >>> root.right = TreeNode(6) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(3) >>> root.right.left = TreeNode(5) >>> root.right.right = TreeNode(7) >>> closestNode(root, [3, 4, 5, 1, 7, 6]) [3, 4, 5, 1, 7, 6] >>> >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.left.left.left = TreeNode(1) >>> root.right.left = TreeNode(7) >>> root.right.left.left = TreeNode(6) >>> root.right.right = TreeNode(10) >>> closestNode(root, [1, 3, 6, 9, 11]) [1, 3, 6, 8, 10]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def closestNode(root, queries): result = [] def search_closest(node, target): closest = node.val while node: if abs(closest - target) > abs(node.val - target): closest = node.val elif abs(closest - target) == abs(node.val - target): closest = min(closest, node.val) if target < node.val: node = node.left elif target > node.val: node = node.right else: break return closest for query in queries: result.append(search_closest(root, query)) return result"},{"question":"def min_operations_to_reduce_points(nums: List[int], k: int) -> int: Calculate the minimum number of operations required to reduce the array to \`k\` points or less. In one operation, you can remove a point or you can merge two consecutive points into a single point with a value equal to their sum. Parameters: nums (List[int]): The list of integers. k (int): The target number of points. Returns: int: The minimum number of operations needed. >>> min_operations_to_reduce_points([1, 2, 3], 3) 0 >>> min_operations_to_reduce_points([1, 2, 3], 2) 1 >>> min_operations_to_reduce_points([1, 2, 3, 4], 1) 3 >>> min_operations_to_reduce_points([1], 1) 0 >>> min_operations_to_reduce_points(list(range(100)), 10) 90","solution":"def min_operations_to_reduce_points(nums, k): This function calculates the minimum number of operations required to reduce the array to \`k\` points or less. In one operation, you can remove a point or you can merge two consecutive points into a single point equal to their sum. Parameters: nums (List[int]): The list of integers. k (int): The target number of points. Returns: int: The minimum number of operations needed. n = len(nums) if k >= n: return 0 # Merging \`n - k\` times will reduce the array to size \`k\` operations = n - k return operations"},{"question":"def min_length_subarray(nums: List[int], target: int) -> List[int]: Finds the minimum length subarray with sum equal to target. >>> min_length_subarray([1, 1, 2, 3, 1, 1, 1, 2], 6) in [[1, 2, 3], [3, 1, 1, 1]] >>> min_length_subarray([5, 1, 3, 5, 10, 7, 4, 9, 2, 8], 15) == [5, 10] >>> min_length_subarray([1, 1, 1, 1], 5) == [] >>> min_length_subarray([2, 4, 6, 8], 17) == [] >>> min_length_subarray([1, 2, 3, 4, 5], 7) in [[3, 4], [2, 3, 2], [4, 3]] >>> min_length_subarray([5], 5) == [5] >>> min_length_subarray([1], 2) == []","solution":"def min_length_subarray(nums, target): Finds minimum length subarray with sum equal to target. min_length = float('inf') subarray = [] for start in range(len(nums)): current_sum = 0 for end in range(start, len(nums)): current_sum += nums[end] if current_sum == target: if end - start + 1 < min_length: min_length = end - start + 1 subarray = nums[start:end+1] break return subarray"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestConsecutive(root: TreeNode) -> int: Given a binary tree, find the length of the longest consecutive sequence path. >>> root = TreeNode(1) >>> root.right = TreeNode(3) >>> root.right.left = TreeNode(2) >>> root.right.right = TreeNode(4) >>> root.right.right.right = TreeNode(5) >>> longestConsecutive(root) 3 >>> root = TreeNode(1) >>> longestConsecutive(root) 1 >>> root = TreeNode(1) >>> root.left = TreeNode(3) >>> root.right = TreeNode(4) >>> longestConsecutive(root) 1 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> longestConsecutive(root) 4 >>> root = TreeNode(2) >>> root.left = TreeNode(3) >>> root.left.left = TreeNode(2) >>> root.left.left.left = TreeNode(1) >>> longestConsecutive(root) 2 >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(20) >>> root.right.right = TreeNode(21) >>> root.right.right.right = TreeNode(22) >>> longestConsecutive(root) 3","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestConsecutive(root: TreeNode) -> int: def dfs(node, parent_val, length): if not node: return length current_len = length + 1 if node.val == parent_val + 1 else 1 left_len = dfs(node.left, node.val, current_len) right_len = dfs(node.right, node.val, current_len) return max(current_len, left_len, right_len) return dfs(root, root.val - 1, 0) if root else 0"},{"question":"from typing import List def min_operations_to_uniform(s: str) -> int: Returns the minimum number of operations required to make all characters in the string s the same. Parameters: s (str): A string consisting only of characters 'a', 'b', and 'c'. Returns: int: The minimum number of operations needed to make all characters the same. Example: >>> min_operations_to_uniform('aaa') 0 >>> min_operations_to_uniform('abc') 2 >>> min_operations_to_uniform('aab') 1 # Implement the function here # Unit Tests def test_all_same_characters(): assert min_operations_to_uniform('aaa') == 0 assert min_operations_to_uniform('bbb') == 0 assert min_operations_to_uniform('ccc') == 0 def test_mixed_characters(): assert min_operations_to_uniform('abc') == 2 assert min_operations_to_uniform('aab') == 1 assert min_operations_to_uniform('bca') == 2 assert min_operations_to_uniform('abab') == 2 assert min_operations_to_uniform('aabbcc') == 4 def test_single_character(): assert min_operations_to_uniform('a') == 0 assert min_operations_to_uniform('b') == 0 assert min_operations_to_uniform('c') == 0 def test_two_characters(): assert min_operations_to_uniform('ab') == 1 assert min_operations_to_uniform('bc') == 1 assert min_operations_to_uniform('aa') == 0 assert min_operations_to_uniform('bb') == 0 assert min_operations_to_uniform('cc') == 0","solution":"def min_operations_to_uniform(s): Returns the minimum number of operations required to make all characters in the string s the same. count_a = s.count('a') count_b = s.count('b') count_c = s.count('c') max_count = max(count_a, count_b, count_c) return len(s) - max_count"},{"question":"def valid_path(edges: List[List[int]], source: int, destination: int) -> bool: Determines if there is a valid path from source to destination in a directed graph. >>> valid_path([[0, 1], [1, 2], [2, 3]], 0, 3) == True >>> valid_path([[0, 1], [1, 2], [3, 4]], 0, 4) == False >>> valid_path([[0, 1], [1, 2], [2, 0]], 0, 2) == True >>> valid_path([], 0, 0) == True >>> valid_path([[0, 1], [2, 3]], 0, 3) == False","solution":"def valid_path(edges, source, destination): Determines if there is a valid path from source to destination in a directed graph. from collections import defaultdict, deque # Create adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) # BFS to check for path from source to destination to_visit = deque([source]) visited = set() while to_visit: current = to_visit.popleft() if current == destination: return True if current not in visited: visited.add(current) for neighbor in graph[current]: if neighbor not in visited: to_visit.append(neighbor) return False"},{"question":"def rearrange_string(s: str) -> str: Rearrange the given string by grouping all vowels together followed by consonants. Preserves the relative order of vowels and consonants as in the original string. >>> rearrange_string(\\"hello\\") == \\"eohll\\" >>> rearrange_string(\\"aeiou\\") == \\"aeiou\\" >>> rearrange_string(\\"bcdfg\\") == \\"bcdfg\\" >>> rearrange_string(\\"banker\\") == \\"aebnkr\\" >>> rearrange_string(\\"\\") == \\"\\" >>> rearrange_string(\\"abcdefghijklmnopqrstuvwxyz\\") == \\"aeioubcdfghjklmnpqrstvwxyz\\"","solution":"def rearrange_string(s): Rearranges the given string by grouping all vowels together followed by consonants. Preserves the relative order of vowels and consonants as in the original string. :param s: Input string consisting of lowercase English letters :return: Rearranged string with vowels first followed by consonants vowels = \\"aeiou\\" vowel_part = ''.join([char for char in s if char in vowels]) consonant_part = ''.join([char for char in s if char not in vowels]) return vowel_part + consonant_part"},{"question":"def reorder_log_entries(logs: List[str]) -> List[str]: Reorder log entries so that all letter-logs come before any digit-logs. The letter-logs are ordered lexicographically by their content; if their contents are the same, then order them lexicographically by their identifiers. Digit-logs should remain in the same relative order they were given. Args: logs (List[str]): List of log entries. Returns: List[str]: The reordered list of log entries. >>> reorder_log_entries([\\"log1 9 2 3 1\\", \\"let1 art can\\", \\"dig1 8 1 5 1\\", \\"let2 own kit dig\\", \\"let3 art zero\\"]) [\\"let1 art can\\", \\"let3 art zero\\", \\"let2 own kit dig\\", \\"log1 9 2 3 1\\", \\"dig1 8 1 5 1\\"] >>> reorder_log_entries([\\"let1 abc def\\", \\"let2 abc def\\", \\"let3 ghi jkl\\", \\"dig1 0 1 2\\", \\"dig2 3 4 5\\"]) [\\"let1 abc def\\", \\"let2 abc def\\", \\"let3 ghi jkl\\", \\"dig1 0 1 2\\", \\"dig2 3 4 5\\"] >>> reorder_log_entries([]) [] >>> reorder_log_entries([\\"let1 abc def\\"]) [\\"let1 abc def\\"] >>> reorder_log_entries([\\"dig1 8 1 5 1\\"]) [\\"dig1 8 1 5 1\\"]","solution":"def reorder_log_entries(logs): Reorder log entries so that all letter-logs come before any digit-logs. The letter-logs are ordered lexicographically by their content; if their contents are the same, then order them lexicographically by their identifiers. Digit-logs should remain in the same relative order they were given. Args: logs (List[str]): List of log entries. Returns: List[str]: The reordered list of log entries. def get_key(log): identifier, rest = log.split(\\" \\", 1) if rest[0].isdigit(): return (1,) else: return (0, rest, identifier) logs.sort(key=get_key) return logs"},{"question":"from typing import List def maxGold(grid: List[List[int]]) -> int: You are given a grid of size \`m x n\` filled with non-negative numbers representing gold quantities. You start at the top-left cell (0,0) and your goal is to collect as much gold as possible and reach the bottom-right cell (m-1,n-1). However, you can only move either right or down at any point in time. Args: grid (List[List[int]]): The grid representing gold quantities. Returns: int: The maximum amount of gold collected. Examples: >>> maxGold([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> maxGold([[1, 2], [1, 1]]) 4 >>> maxGold([[1]]) 1 pass","solution":"from typing import List def maxGold(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"def longest_anagram_length(s1: str, s2: str) -> int: Returns the length of the longest anagram that can be formed by deleting characters from both strings. >>> longest_anagram_length('abc', 'bcd') == 2 >>> longest_anagram_length('abc', 'def') == 0 >>> longest_anagram_length('abcd', 'abcd') == 4 >>> longest_anagram_length('aabbcc', 'abccba') == 6 >>> longest_anagram_length('aabbcc', 'ab') == 2 >>> longest_anagram_length('', 'aabbcc') == 0 >>> longest_anagram_length('aabbcc', '') == 0 >>> longest_anagram_length('', '') == 0","solution":"def longest_anagram_length(s1, s2): Returns the length of the longest anagram that can be formed by deleting characters from both strings. from collections import Counter # Count the frequency of each character in both strings counter1 = Counter(s1) counter2 = Counter(s2) # Find the total length of the common characters length = sum(min(counter1[char], counter2[char]) for char in counter1 if char in counter2) return length"},{"question":"def min_operations(arr, x, k): Returns the minimum number of operations needed to ensure every pair of consecutive elements in \`arr\` has a difference of at most \`k\`. If it is impossible to achieve such a configuration, return -1. An operation involves selecting an element of the list and replacing it with the absolute difference between that element and \`x\`. >>> min_operations([1, 3, 7], 5, 3) == 1 >>> min_operations([1, 10, 4], 6, 5) == 2 >>> min_operations([1, 2, 3, 4], 2, 1) == 0 >>> min_operations([1, 100, 200], 50, 20) == -1 >>> min_operations([4, 8, 12], 6, 4) == 0 pass","solution":"def min_operations(arr, x, k): Returns the minimum number of operations needed to ensure every pair of consecutive elements in \`arr\` has a difference of at most \`k\`. If it is impossible to achieve such a configuration, return -1. An operation involves selecting an element of the list and replacing it with the absolute difference between that element and \`x\`. def can_be_converted(a, b, x, k): Helper function to check if two elements can be made k-close via operations return abs(a - x) <= k or abs(b - x) <= k operations = 0 for i in range(len(arr) - 1): if abs(arr[i] - arr[i + 1]) > k: if can_be_converted(arr[i], arr[i + 1], x, k): operations += 1 else: return -1 return operations"},{"question":"from typing import List def longest_subarray_with_k_distinct(arr: List[int], k: int) -> int: Find the length of the longest subarray with at most k distinct elements. >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3], 2) 4 >>> longest_subarray_with_k_distinct([1, 2, 1, 3, 4], 3) 4 >>> longest_subarray_with_k_distinct([1, 2, 1, 3, 4], 0) 0 >>> longest_subarray_with_k_distinct([1, 1, 1, 1], 1) 4 >>> longest_subarray_with_k_distinct([1, 2, 3, 4], 4) 4 >>> longest_subarray_with_k_distinct([1, 2, 3, 4], 2) 2 >>> longest_subarray_with_k_distinct([], 1) 0 >>> longest_subarray_with_k_distinct([1, 2, 3], 5) 3 >>> longest_subarray_with_k_distinct([5], 1) 1 >>> longest_subarray_with_k_distinct([5], 2) 1 >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 1, 2, 3], 2) 6","solution":"from typing import List from collections import defaultdict def longest_subarray_with_k_distinct(arr: List[int], k: int) -> int: Find the length of the longest subarray with at most k distinct elements. n = len(arr) if n == 0 or k == 0: return 0 freq = defaultdict(int) left = 0 max_length = 0 distinct_count = 0 for right in range(n): if freq[arr[right]] == 0: distinct_count += 1 freq[arr[right]] += 1 while distinct_count > k: freq[arr[left]] -= 1 if freq[arr[left]] == 0: distinct_count -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def max_subarray_sum(nums): Returns the maximum possible sum of the elements of any contiguous subarray of nums. >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([5]) == 5 >>> max_subarray_sum([-5]) == -5 >>> max_subarray_sum([-1, -2, -3, -4]) == -1 >>> max_subarray_sum([0, -3, 5, -2, 0, 3, -1]) == 6 >>> max_subarray_sum([]) == 0 >>> max_subarray_sum([10, 20, -5, 30, -10, 40]) == 85","solution":"def max_subarray_sum(nums): Returns the maximum possible sum of the elements of any contiguous subarray of nums. if not nums: return 0 max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def rob(nums: List[int]) -> int: Calculate the maximum amount of money you can rob tonight without alerting police. You cannot rob two adjacent houses. >>> rob([]) == 0 >>> rob([5]) == 5 >>> rob([2, 3]) == 3 >>> rob([1, 2, 3, 1]) == 4 >>> rob([2, 7, 9, 3, 1]) == 12 >>> rob([5, 5, 5, 5, 5]) == 15 >>> rob([100, 1, 1, 100]) == 200 >>> rob([10, 20, 30, 40, 50]) == 90 :param nums: List[int], amounts of money in various houses along the street. :return: int, maximum amount of money that can be robbed.","solution":"def rob(nums): Calculate the maximum amount of money you can rob tonight without alerting police. You cannot rob two adjacent houses. :param nums: List[int], amounts of money in various houses along the street. :return: int, maximum amount of money that can be robbed. if not nums: return 0 if len(nums) == 1: return nums[0] # Initialize the maximum money at the first two houses prev1 = max(nums[0], nums[1]) if len(nums) > 1 else nums[0] prev2 = nums[0] for i in range(2, len(nums)): current = max(prev1, prev2 + nums[i]) prev2 = prev1 prev1 = current return prev1"},{"question":"class NumArray: def __init__(self, nums: List[int]): Initializes the object with the integer array nums. def update(self, index: int, value: int) -> None: Updates the element at index to value. def sumRange(self, left: int, right: int) -> int: Returns the sum of the elements between indices left and right inclusive. # Test cases: def test_sumRange_no_update(): arr = NumArray([1, 3, 5]) assert arr.sumRange(0, 2) == 9 assert arr.sumRange(1, 2) == 8 assert arr.sumRange(0, 1) == 4 def test_sumRange_after_update(): arr = NumArray([1, 3, 5]) arr.update(1, 2) # [1, 2, 5] assert arr.sumRange(0, 2) == 8 assert arr.sumRange(1, 2) == 7 assert arr.sumRange(0, 1) == 3 def test_update_updates_prefix_sum(): arr = NumArray([7, 2, 7, 2, 0]) arr.update(4, 6) # [7, 2, 7, 2, 6] arr.update(0, 2) # [2, 2, 7, 2, 6] assert arr.sumRange(0, 4) == 19 assert arr.sumRange(1, 3) == 11 arr.update(3, 9) # [2, 2, 7, 9, 6] assert arr.sumRange(2, 4) == 22","solution":"class NumArray: def __init__(self, nums): Initializes the object with the integer array nums. self.nums = nums self.prefix_sum = self._build_prefix_sum(nums) def _build_prefix_sum(self, nums): Builds the prefix sum array for the given nums array. prefix_sum = [0] * (len(nums) + 1) for i in range(len(nums)): prefix_sum[i + 1] = prefix_sum[i] + nums[i] return prefix_sum def update(self, index, value): Updates the element at index to value. diff = value - self.nums[index] self.nums[index] = value for i in range(index + 1, len(self.prefix_sum)): self.prefix_sum[i] += diff def sumRange(self, left, right): Returns the sum of the elements between indices left and right inclusive. return self.prefix_sum[right + 1] - self.prefix_sum[left]"},{"question":"from typing import List def maxProfit(prices: List[int]) -> int: Returns the maximum profit that can be achieved from a list of stock prices by performing at most one transaction. >>> maxProfit([7, 1, 5, 3, 6, 4]) 5 >>> maxProfit([7, 6, 4, 3, 1]) 0 >>> maxProfit([7]) 0 >>> maxProfit([]) 0 >>> maxProfit([1, 2, 3, 4, 5, 6]) 5 >>> maxProfit([3, 3, 3, 3, 3]) 0 >>> maxProfit([3, 1, 4, 8, 7, 2, 5]) 7","solution":"from typing import List def maxProfit(prices: List[int]) -> int: Returns the maximum profit that can be achieved from a list of stock prices by performing at most one transaction. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def min_cities_to_provide_resources(nums: List[int], limit: int) -> int: Returns the minimum number of cities whose total population is equal to or closest to (but does not exceed) the limit. >>> min_cities_to_provide_resources([10, 20, 30, 40], 50) == 2 >>> min_cities_to_provide_resources([10, 20, 30, 40], 45) == 1 >>> min_cities_to_provide_resources([100, 300, 200, 400], 700) == 2 >>> min_cities_to_provide_resources([5, 5, 5, 5], 15) == 3 >>> min_cities_to_provide_resources([50], 100) == 1","solution":"def min_cities_to_provide_resources(nums, limit): Returns the minimum number of cities whose total population is equal to or closest to (but does not exceed) the limit. # Sort the population list in descending order nums.sort(reverse=True) # Initialize variables to track the total population and city count total_population = 0 city_count = 0 # Iterate over the sorted list for population in nums: if total_population + population <= limit: total_population += population city_count += 1 # If adding the current city's population exceeds the limit, move to the next city else: continue return city_count"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): Reverses nodes in the k-group chunks in the linked list. :param head: ListNode, the head of the linked list :param k: int, the size of the group to reverse :return: ListNode, the modified head of the linked list >>> head = array_to_list([1, 2, 3, 4, 5]) >>> list_to_array(reverseKGroup(head, 2)) == [2, 1, 4, 3, 5] >>> head = array_to_list([1, 2, 3, 4, 5, 6]) >>> list_to_array(reverseKGroup(head, 3)) == [3, 2, 1, 6, 5, 4] >>> head = array_to_list([1, 2, 3, 4, 5]) >>> list_to_array(reverseKGroup(head, 1)) == [1, 2, 3, 4, 5] >>> head = array_to_list([1, 2]) >>> list_to_array(reverseKGroup(head, 3)) == [1, 2] >>> head = array_to_list([1]) >>> list_to_array(reverseKGroup(head, 2)) == [1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): Reverses nodes in the k-group chunks in the linked list. :param head: ListNode, the head of the linked list :param k: int, the size of the group to reverse :return: ListNode, the modified head of the linked list if not head or k == 1: return head dummy = ListNode(0) dummy.next = head curr, curr_dummy = head, dummy length = 0 while curr: next_curr = curr.next length += 1 if length % k == 0: next_dummy = curr_dummy.next reverse(curr_dummy, curr.next) curr_dummy = next_dummy curr = next_curr return dummy.next def reverse(start, end): curr, prev = start.next, start first = curr while curr != end: temp = curr.next curr.next = prev prev = curr curr = temp start.next = prev first.next = curr"},{"question":"def three_consecutive_odds(arr: List[int]) -> bool: Given an array of integers \`arr\`, return true if there are three consecutive odd numbers in the array. Otherwise, return false. >>> three_consecutive_odds([2, 4, 6, 8, 10]) False >>> three_consecutive_odds([1, 3, 5, 7]) True","solution":"def three_consecutive_odds(arr): Returns True if there are three consecutive odd numbers in the array, otherwise False. count = 0 for num in arr: if num % 2 != 0: count += 1 if count == 3: return True else: count = 0 return False"},{"question":"def can_form_palindrome(s: str, queries: List[Tuple[int, int, int]]) -> List[bool]: Determines if it's possible to rearrange the substrings of s to form a palindrome after at most k replacements. Args: - s (str): The input string. - queries (List[Tuple[int, int, int]]): A list of queries where each query is a tuple (left, right, k). Returns: - List[bool]: A list of boolean values, each representing the result of the corresponding query. Examples: >>> can_form_palindrome(\\"abcccba\\", [(0, 6, 1)]) [True] >>> can_form_palindrome(\\"abacabad\\", [(0, 3, 1), (0, 3, 0), (0, 7, 2), (0, 7, 0)]) [True, False, True, False] >>> can_form_palindrome(\\"racecar\\", [(0, 6, 0)]) [True] >>> can_form_palindrome(\\"abcdefgh\\", [(0, 7, 4)]) [True] >>> can_form_palindrome(\\"abcdefg\\", [(0, 6, 0)]) [False] >>> can_form_palindrome(\\"\\", [(0, 0, 0)]) [True] >>> can_form_palindrome(\\"aabbcc\\", [(0, 5, 0)]) [True]","solution":"def can_form_palindrome(s, queries): Determines if it's possible to rearrange the substrings of s to form a palindrome after at most k replacements. Args: - s (str): The input string. - queries (List[Tuple[int, int, int]]): A list of queries where each query is a tuple (left, right, k). Returns: - List[bool]: A list of boolean values, each representing the result of the corresponding query. def is_palindrome_possible(substring, k): from collections import Counter # Count the frequency of each character in the substring count = Counter(substring) # Find the number of characters with an odd frequency odd_count = sum(1 for key in count if count[key] % 2 != 0) # We can make at most \`k\` replacements to turn odd frequencies even # A palindrome allows at most one character with an odd count return (odd_count // 2) <= k result = [] for left, right, k in queries: substring = s[left:right + 1] result.append(is_palindrome_possible(substring, k)) return result"},{"question":"def can_transform(s: str, t: str) -> bool: Determines if string s can be transformed into string t by swapping any two characters in s, with each character of s being swapped at most once. >>> can_transform(\\"ab\\", \\"ba\\") == True >>> can_transform(\\"abc\\", \\"acb\\") == True >>> can_transform(\\"abc\\", \\"abcd\\") == False >>> can_transform(\\"abcd\\", \\"badc\\") == False >>> can_transform(\\"aaaa\\", \\"aaaa\\") == True >>> can_transform(\\"abcdefgh\\", \\"hgfedcba\\") == False","solution":"def can_transform(s, t): Determines if string s can be transformed into string t by swapping any two characters in s, with each character of s being swapped at most once. Returns True if transformable, False otherwise. from collections import Counter # Both strings must have the same characters with the same frequencies if Counter(s) != Counter(t): return False # Find the indices where the strings differ differences = [(i, s[i], t[i]) for i in range(len(s)) if s[i] != t[i]] # If there are no differences, transformation is possible without swaps if len(differences) == 0: return True # If there are exactly two differences, swap should be possible if len(differences) == 2: i1, s1, t1 = differences[0] i2, s2, t2 = differences[1] # Check if swapping these will match the characters if s1 == t2 and s2 == t1: return True # Otherwise, it's not possible to transform by a single swap return False"},{"question":"from typing import List from collections import Counter def replace_with_mode(nums: List[int]) -> List[int]: Replace every integer in nums with the mode of the array. If there is a tie for the mode, the smaller integer among the tied values is chosen. >>> replace_with_mode([1]) == [1] >>> replace_with_mode([2, 2, 2]) == [2, 2, 2] >>> replace_with_mode([1, 2, 3]) == [1, 1, 1] >>> replace_with_mode([1, 1, 2, 2]) == [1, 1, 1, 1] >>> replace_with_mode([2, 2, 3, 3, 1, 1]) == [1, 1, 1, 1, 1, 1] >>> replace_with_mode([]) == [] >>> replace_with_mode([10**9, 10**9, 10**8, 10**8, 10**7]) == [10**8, 10**8, 10**8, 10**8, 10**8]","solution":"from collections import Counter def replace_with_mode(nums): Replace every integer in nums with the mode of the array. If there is a tie for the mode, the smaller integer among the tied values is chosen. if not nums: return [] # Count the frequency of each number in the array counter = Counter(nums) # Determine the mode - smallest number with the highest frequency mode = min(counter.keys(), key=lambda x: (-counter[x], x)) # Replace every number in the array with the mode return [mode] * len(nums)"},{"question":"def count_lowland_cells(grid: List[List[int]]) -> int: Count the number of lowland cells in a grid. >>> count_lowland_cells([]) 0 >>> count_lowland_cells([[1]]) 0 >>> count_lowland_cells([[1, 1, 1, 1]]) 0 >>> count_lowland_cells([[1], [1], [1]]) 0 >>> count_lowland_cells([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> count_lowland_cells([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) 0 >>> count_lowland_cells([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 1 >>> count_lowland_cells([[0, 1, 0], [1, 1, 1], [0, 1, 0]]) 1 >>> count_lowland_cells([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) 4","solution":"def count_lowland_cells(grid): Counts the number of lowland cells in the grid. if not grid or not grid[0]: return 0 rows = len(grid) columns = len(grid[0]) lowland_count = 0 for i in range(rows): for j in range(columns): if grid[i][j] == 1: # Check all neighboring cells # Up up = grid[i-1][j] if i > 0 else 0 # Down down = grid[i+1][j] if i < rows - 1 else 0 # Left left = grid[i][j-1] if j > 0 else 0 # Right right = grid[i][j+1] if j < columns - 1 else 0 # If all neighboring cells are land cells if up == 1 and down == 1 and left == 1 and right == 1: lowland_count += 1 return lowland_count"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Reverses a singly linked list. Args: head (ListNode): The head of the singly linked list. Returns: ListNode: The head of the reversed linked list. # Implementation here","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head): Reverses a singly linked list. Args: head (ListNode): The head of the singly linked list. Returns: ListNode: The head of the reversed linked list. prev = None curr = head while curr: next_node = curr.next # temporary store the next node curr.next = prev # reverse the current node's pointer prev = curr # move the prev and curr pointers one step forward curr = next_node return prev # prev will be the new head of the reversed list"},{"question":"def can_frog_reach_last_stone(stones: List[int], k: int) -> bool: Determines if the frog can reach the last stone given the jumping constraint k. :param stones: List[int] - List of stone weights. :param k: int - Maximum allowed absolute difference in weight for a jump. :return: bool - True if the frog can reach the last stone, False otherwise. >>> can_frog_reach_last_stone([5], 10) True >>> can_frog_reach_last_stone([1, 2, 3, 4, 5], 1) True >>> can_frog_reach_last_stone([1, 3, 6, 10], 1) False >>> can_frog_reach_last_stone([5, 3, 1], 2) True >>> can_frog_reach_last_stone([1, 3, 6, 10], 10) True >>> can_frog_reach_last_stone([1, 2, 8], 5) False >>> can_frog_reach_last_stone([1, 5, 2, 6, 3, 7], 4) True pass","solution":"def can_frog_reach_last_stone(stones, k): Determines if the frog can reach the last stone given the jumping constraint k. :param stones: List[int] - List of stone weights. :param k: int - Maximum allowed absolute difference in weight for a jump. :return: bool - True if the frog can reach the last stone, False otherwise. n = len(stones) if n == 1: return True reachable = [False] * n reachable[0] = True for i in range(n): if reachable[i]: for j in range(i + 1, n): if abs(stones[j] - stones[i]) <= k: reachable[j] = True if j == n - 1: return True else: break return reachable[-1]"},{"question":"def longest_consecutive(nums: List[int]) -> int: Returns the length of the longest consecutive elements sequence in nums. The algorithm runs in O(n) time complexity. >>> longest_consecutive([]) == 0 >>> longest_consecutive([1]) == 1 >>> longest_consecutive([10, 100, 1000]) == 1 >>> longest_consecutive([4, 2, 1, 3]) == 4 >>> longest_consecutive([100, 4, 200, 1, 3, 2]) == 4 >>> longest_consecutive([6, 4, 5, 3, 7, 8, 13]) == 6 >>> longest_consecutive([1, 2, 0, 1, 3]) == 4","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence in nums. The algorithm runs in O(n) time complexity. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # Look for the starting point of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 # Count the length of the sequence while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def count_valleys(steps: List[str]) -> int: Returns the total number of valleys walked through given a list of steps. Parameters: steps (list of str): A list representing steps where 'U' is up and 'D' is down. Returns: int: Number of valleys. >>> count_valleys(['U', 'U', 'D', 'D', 'U', 'U', 'D']) == 0 >>> count_valleys(['D', 'D', 'U', 'U']) == 1 >>> count_valleys(['U', 'D', 'D', 'U', 'D', 'U', 'U', 'D', 'U']) == 2 >>> count_valleys([]) == 0 >>> count_valleys(['U', 'U', 'U', 'U']) == 0 >>> count_valleys(['D', 'D', 'D', 'D']) == 0 >>> count_valleys(['D', 'U', 'U', 'D']) == 1 >>> count_valleys(['D', 'U', 'D', 'U']) == 2","solution":"def count_valleys(steps): Returns the total number of valleys walked through given a list of steps. Parameters: steps (list of str): A list representing steps where 'U' is up and 'D' is down. Returns: int: Number of valleys. sea_level = 0 current_level = 0 valleys = 0 in_valley = False for step in steps: if step == 'U': current_level += 1 elif step == 'D': current_level -= 1 if not in_valley and current_level < sea_level: # Entering a valley in_valley = True if in_valley and current_level == sea_level: # Exiting the valley valleys += 1 in_valley = False return valleys"},{"question":"def maxWaterStored(heights: List[int]) -> int: Returns the maximum number of water units the billboard can hold. :param heights: List[int] - heights of each position on the billboard. :return: int - maximum units of water stored. >>> maxWaterStored([1,8,6,2,5,4,8,3,7]) 49 >>> maxWaterStored([1,2,4,3]) 4 >>> maxWaterStored([3,3,3,3]) 9 >>> maxWaterStored([6,4,3,2,1]) 6 >>> maxWaterStored([1,2,3,4,5,6]) 9 >>> maxWaterStored([1,3,2,5,2,4]) 12","solution":"def maxWaterStored(heights): Returns the maximum number of water units the billboard can hold. :param heights: List[int] - heights of each position on the billboard. :return: int - maximum units of water stored. n = len(heights) max_water = 0 left, right = 0, n - 1 while left < right: current_water = min(heights[left], heights[right]) * (right - left) max_water = max(max_water, current_water) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"def min_ladder_positions(height: List[int], ladderHeight: int) -> int: Returns the minimum number of positions the washer needs to place the ladder to clean all the buildings. Parameters: height (list): A list of integers representing the height of buildings. ladderHeight (int): The maximum height the ladder can reach. Returns: int: The minimum number of positions required for the ladder. >>> min_ladder_positions([1, 2, 3], 3) == 1 >>> min_ladder_positions([4, 2, 5, 1, 6], 5) == 2 >>> min_ladder_positions([], 4) == 0 >>> min_ladder_positions([3], 10) == 1 >>> min_ladder_positions([15], 10) == 2 >>> min_ladder_positions([2, 4, 6, 8], 8) == 1 >>> min_ladder_positions([1, 10, 20, 30, 5, 40], 10) == 4","solution":"def min_ladder_positions(height, ladderHeight): Returns the minimum number of positions the washer needs to place the ladder to clean all the buildings. Parameters: height (list): A list of integers representing the height of buildings. ladderHeight (int): The maximum height the ladder can reach. Returns: int: The minimum number of positions required for the ladder. if not height: return 0 positions = 1 current_max_height = ladderHeight for h in height: if h > current_max_height: positions += 1 current_max_height += ladderHeight return positions"},{"question":"def are_isomorphic(s1: str, s2: str) -> bool: Determines if two strings s1 and s2 are isomorphic. Two strings s1 and s2 are isomorphic if the characters in s1 can be replaced to get s2. >>> are_isomorphic(\\"egg\\", \\"add\\") True >>> are_isomorphic(\\"foo\\", \\"bar\\") False >>> are_isomorphic(\\"abc\\", \\"de\\") False >>> are_isomorphic(\\"paper\\", \\"title\\") True >>> are_isomorphic(\\"ab\\", \\"aa\\") False >>> are_isomorphic(\\"bbbbb\\", \\"aaaaa\\") True >>> are_isomorphic(\\"a\\", \\"b\\") True >>> are_isomorphic(\\"a\\", \\"a\\") True","solution":"def are_isomorphic(s1, s2): Determines if two strings s1 and s2 are isomorphic. Parameters: - s1 (str): The first string. - s2 (str): The second string. Returns: - bool: True if strings are isomorphic, False otherwise. if len(s1) != len(s2): return False mapping_s1_to_s2 = {} mapping_s2_to_s1 = {} for char1, char2 in zip(s1, s2): if char1 in mapping_s1_to_s2: if mapping_s1_to_s2[char1] != char2: return False if char2 in mapping_s2_to_s1: if mapping_s2_to_s1[char2] != char1: return False mapping_s1_to_s2[char1] = char2 mapping_s2_to_s1[char2] = char1 return True"},{"question":"def min_segments_to_form_words(s: str, wordDict: List[str]) -> int: Returns the minimum number of segments needed to segment the string such that each segment is a valid word in the wordDict. If it's not possible, returns -1. >>> min_segments_to_form_words(\\"leetcode\\", [\\"leet\\", \\"code\\"]) == 2 >>> min_segments_to_form_words(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == -1 >>> min_segments_to_form_words(\\"apple\\", [\\"apple\\"]) == 1 >>> min_segments_to_form_words(\\"\\", [\\"any\\", \\"word\\"]) == 0 >>> min_segments_to_form_words(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) == 3 >>> min_segments_to_form_words(\\"aaaaaaa\\", [\\"aaaa\\", \\"aaa\\"]) == 2 >>> min_segments_to_form_words(\\"abcdef\\", [\\"a\\", \\"bc\\", \\"de\\"]) == -1","solution":"def min_segments_to_form_words(s, wordDict): Returns the minimum number of segments needed to segment the string such that each segment is a valid word in the wordDict. If it's not possible, returns -1. word_set = set(wordDict) n = len(s) # dp[i] will hold the minimum number of segments to segment s[0:i] dp = [float('inf')] * (n + 1) dp[0] = 0 # No segments needed for an empty string for i in range(1, n + 1): for j in range(i): if s[j:i] in word_set: dp[i] = min(dp[i], dp[j] + 1) return dp[n] if dp[n] != float('inf') else -1"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def maxPathSum(root): Calculate the maximum path sum in the binary tree. Args: root (TreeNode): The root of the binary tree. Returns: int: The maximum sum of values from a path in the tree. pass # Unit tests def test_single_node(): root = TreeNode(1) assert maxPathSum(root) == 1 def test_two_nodes(): root = TreeNode(1, TreeNode(2)) assert maxPathSum(root) == 3 def test_three_nodes(): root = TreeNode(1, TreeNode(2), TreeNode(3)) assert maxPathSum(root) == 6 def test_complex_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) assert maxPathSum(root) == 18 # The path is 4 -> 2 -> 1 -> 3 -> 6 -> 7 def test_tree_with_negative_values(): root = TreeNode(-10) root.left = TreeNode(9) root.right = TreeNode(20, TreeNode(15), TreeNode(7)) assert maxPathSum(root) == 42 # The path is 15 -> 20 -> 7","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def maxPathSum(root): Calculate the maximum path sum in the binary tree. Args: root (TreeNode): The root of the binary tree. Returns: int: The maximum sum of values from a path in the tree. def max_gain(node, visited): nonlocal max_sum if not node or node in visited: return 0 visited.add(node) left_gain = max(0, max_gain(node.left, visited)) right_gain = max(0, max_gain(node.right, visited)) current_sum = node.value + left_gain + right_gain max_sum = max(max_sum, current_sum) visited.remove(node) return node.value + max(left_gain, right_gain) max_sum = float('-inf') max_gain(root, set()) return max_sum"},{"question":"def is_palindrome(x: int) -> bool: Check if a given number x is a palindrome. pass def is_super_palindrome(n: int) -> bool: Determines whether a given positive integer n is a super palindrome. A super palindrome is an integer whose square is a palindrome. >>> is_super_palindrome(5) False >>> is_super_palindrome(9) False >>> is_super_palindrome(11) True >>> is_super_palindrome(22) True >>> is_super_palindrome(26) True >>> is_super_palindrome(1) True >>> is_super_palindrome(2) True >>> is_super_palindrome(3) True pass","solution":"def is_palindrome(x): Check if a given number x is a palindrome. return str(x) == str(x)[::-1] def is_super_palindrome(n): Determines whether a given positive integer n is a super palindrome. A super palindrome is an integer whose square is a palindrome. if n < 1: return False square = n * n return is_palindrome(square)"},{"question":"def spiral_order(matrix): Given a 2D integer array \`matrix\` of size \`m x n\`, return a list of the matrix's spiral order traversal starting from the top-left corner. >>> spiral_order([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiral_order([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12] ... ]) [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] >>> spiral_order([[1, 2, 3, 4]]) [1, 2, 3, 4] >>> spiral_order([[1], [2], [3], [4]]) [1, 2, 3, 4] >>> spiral_order([]) [] >>> spiral_order([ ... [1, 2, 3], ... [4, 5, 6] ... ]) [1, 2, 3, 6, 5, 4]","solution":"def spiral_order(matrix): Returns the spiral order traversal of a 2D matrix. res = [] if not matrix: return res top, bottom = 0, len(matrix) - 1 left, right = 0, len(matrix[0]) - 1 while top <= bottom and left <= right: for col in range(left, right + 1): res.append(matrix[top][col]) top += 1 for row in range(top, bottom + 1): res.append(matrix[row][right]) right -= 1 if top <= bottom: for col in range(right, left - 1, -1): res.append(matrix[bottom][col]) bottom -= 1 if left <= right: for row in range(bottom, top - 1, -1): res.append(matrix[row][left]) left += 1 return res"},{"question":"def fibonacci_sequence(n: int) -> List[int]: Returns the first n numbers in the Fibonacci sequence as a list. >>> fibonacci_sequence(0) == [] >>> fibonacci_sequence(1) == [0] >>> fibonacci_sequence(2) == [0, 1] >>> fibonacci_sequence(3) == [0, 1, 1] >>> fibonacci_sequence(5) == [0, 1, 1, 2, 3] >>> fibonacci_sequence(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci_sequence(n): Returns the first n numbers in the Fibonacci sequence as a list. if n <= 0: return [] elif n == 1: return [0] fib_sequence = [0, 1] while len(fib_sequence) < n: next_fib = fib_sequence[-1] + fib_sequence[-2] fib_sequence.append(next_fib) return fib_sequence"},{"question":"def can_complete_circuit(nums, cost): Determines if you can travel around the circular array once in the clockwise direction. Returns the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise returns -1. If there exists a solution, it is guaranteed to be unique. >>> can_complete_circuit([1,2,3,4,5], [3,4,5,1,2]) == 3 >>> can_complete_circuit([2,3,4], [3,4,3]) == -1 >>> can_complete_circuit([5,5,5], [1,1,1]) == 0 >>> can_complete_circuit([1,2,3,4], [0,0,0,5]) == 0 >>> can_complete_circuit([3], [2]) == 0 >>> can_complete_circuit([1], [5]) == -1 >>> can_complete_circuit([4,6,7,4], [6,5,3,5]) == 1","solution":"def can_complete_circuit(nums, cost): Determines if you can travel around the circular array once. Returns the starting gas station's index or -1 if not possible. total_tank = 0 curr_tank = 0 starting_station = 0 for i in range(len(nums)): total_tank += nums[i] - cost[i] curr_tank += nums[i] - cost[i] # If one station fails, reset the start position and the current tank if curr_tank < 0: starting_station = i + 1 curr_tank = 0 return starting_station if total_tank >= 0 else -1"},{"question":"def sort_heights_stable(heights: List[int]) -> None: You are given an integer array \`heights\` representing the heights of students in a class. The students will be arranged in non-decreasing order of their heights, but with an additional constraint: students with the same height should remain in their original relative order. Write a function that modifies the array \`heights\` to reflect the new order while maintaining this constraint. You must do this in-place, with O(1) additional space, and within O(n log n) time complexity. >>> heights = [4, 1, 3, 2, 5] >>> sort_heights_stable(heights) >>> heights [1, 2, 3, 4, 5] >>> heights = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] >>> sort_heights_stable(heights) >>> heights [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] >>> heights = [] >>> sort_heights_stable(heights) >>> heights []","solution":"def sort_heights_stable(heights): Sort the heights array in non-decreasing order while maintaining the relative order of students with the same height. # Using Timsort which is a stable sort and works in O(n log n) time complexity. heights.sort()"},{"question":"def simplify_path(s: str) -> str: Simplifies the given Unix-style file path to its canonical form. >>> simplify_path('/home/') '/home' >>> simplify_path('/../') '/' >>> simplify_path('/home//foo/') '/home/foo' >>> simplify_path('/a/./b/../../c/') '/c' >>> simplify_path('/') '/' >>> simplify_path('/home//../usr//bin/./') '/usr/bin' >>> simplify_path('///a//b////c/d//././/..') '/a/b/c' >>> simplify_path('') '/' >>> simplify_path('/a/b/c/') '/a/b/c' >>> simplify_path('/a/b/c////') '/a/b/c' >>> simplify_path('/..') '/' >>> simplify_path('/home/./././') '/home' >>> simplify_path('/home/../..') '/' >>> simplify_path('/.hidden') '/.hidden'","solution":"def simplify_path(s): Simplifies the given Unix-style file path to its canonical form. :param s: str : Unix-style file path :return: str : Simplified canonical path components = s.split('/') stack = [] for component in components: if component == '' or component == '.': continue elif component == '..': if stack: stack.pop() else: stack.append(component) return '/' + '/'.join(stack)"},{"question":"from typing import List def max_possible_sum(nums: List[int]) -> int: Determines the maximum possible sum after one subarray deletion and append operation. Parameters: nums (List[int]): A list of non-negative integers. Returns: int: The maximum possible sum of the array after the operation. >>> max_possible_sum([1, 2, 3, 4, 5]) 15 >>> max_possible_sum([]) 0 >>> max_possible_sum([0, 0, 0]) 0 >>> max_possible_sum([10]) 10 >>> max_possible_sum([100, 200, 300, 400]) 1000","solution":"def max_possible_sum(nums): Determines the maximum possible sum after one subarray deletion and append operation. Parameters: nums (List[int]): A list of non-negative integers. Returns: int: The maximum possible sum of the array after the operation. if not nums: return 0 return sum(nums)"},{"question":"def numSpecial(mat: List[List[int]]) -> int: Returns the number of special cells in the matrix 'mat'. A cell is considered special if its value is \`1\` and it is the only \`1\` in its row and column. :param mat: List[List[int]] - 2D list representing a matrix with values 0 or 1. :return: int - number of special cells pass # Test cases def test_example_case_1(): mat = [ [1, 0, 0], [0, 0, 1], [1, 0, 0] ] assert numSpecial(mat) == 1 def test_example_case_2(): mat = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] assert numSpecial(mat) == 3 def test_no_special_cells(): mat = [ [1, 0, 0], [0, 1, 1], [1, 0, 1] ] assert numSpecial(mat) == 0 def test_all_zeros(): mat = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert numSpecial(mat) == 0 def test_multiple_rows_and_columns(): mat = [ [1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1] ] assert numSpecial(mat) == 4","solution":"def numSpecial(mat): Returns the number of special cells in the matrix 'mat'. A cell is considered special if its value is \`1\` and it is the only \`1\` in its row and column. :param mat: List[List[int]] - 2D list representing a matrix with values 0 or 1. :return: int - number of special cells m = len(mat) n = len(mat[0]) row_counts = [sum(row) for row in mat] col_counts = [sum(col) for col in zip(*mat)] count_special = 0 for i in range(m): for j in range(n): if mat[i][j] == 1 and row_counts[i] == 1 and col_counts[j] == 1: count_special += 1 return count_special"},{"question":"def min_flips_to_avoid_consecutive_ones(s: str) -> int: Returns the minimum number of flips required to make the binary string have no consecutive '1's. >>> min_flips_to_avoid_consecutive_ones(\\"0101010\\") == 0 >>> min_flips_to_avoid_consecutive_ones(\\"011010\\") == 1 >>> min_flips_to_avoid_consecutive_ones(\\"1110011\\") == 3 >>> min_flips_to_avoid_consecutive_ones(\\"0000000\\") == 0 >>> min_flips_to_avoid_consecutive_ones(\\"1111\\") == 3 >>> min_flips_to_avoid_consecutive_ones(\\"0\\") == 0 >>> min_flips_to_avoid_consecutive_ones(\\"1\\") == 0","solution":"def min_flips_to_avoid_consecutive_ones(s): Returns the minimum number of flips required to make the binary string have no consecutive '1's. n = len(s) if n <= 1: return 0 # Count consecutive '1's consecutive_ones_count = 0 for i in range(1, n): if s[i] == '1' and s[i-1] == '1': consecutive_ones_count += 1 # The result is the number of consecutive '1's blocks found return consecutive_ones_count"},{"question":"def transform_string(s: str) -> str: Replaces every digit in \`s\` with its corresponding English word, and converts all letters in \`s\` to uppercase. >>> transform_string(\\"abc\\") 'ABC' >>> transform_string(\\"xyz\\") 'XYZ' >>> transform_string(\\"123\\") 'onetwothree' >>> transform_string(\\"908\\") 'ninezeroeight' >>> transform_string(\\"a1b2c3\\") 'AoneBtwoCthree' >>> transform_string(\\"h3ll0\\") 'HthreeLLzero' >>> transform_string(\\"\\") '' >>> transform_string(\\"a1b2c3d4e5f6g7h8i9j0\\") 'AoneBtwoCthreeDfourEfiveFsixGsevenHeightInineJzero' # your code here","solution":"def transform_string(s): Replaces every digit in \`s\` with its corresponding English word, and converts all letters in \`s\` to uppercase. digit_map = { '0': 'zero', '1': 'one', '2': 'two', '3': 'three', '4': 'four', '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine' } transformed = [] for char in s: if char.isdigit(): transformed.append(digit_map[char]) else: transformed.append(char.upper()) return ''.join(transformed)"},{"question":"def trap(height: List[int]) -> int: Computes the total amount of water that is trapped after raining. Parameters: height (List[int]): The heights of the buildings. Returns: int: Total amount of water trapped. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap([2, 0, 2]) == 2 >>> trap([3, 2, 1]) == 0 >>> trap([1, 2, 3]) == 0 >>> trap([4, 2, 0, 3, 2, 5]) == 9 >>> trap([0]) == 0 >>> trap([5, 5, 5, 5]) == 0 >>> trap([]) == 0","solution":"def trap(height): Computes the total amount of water that is trapped after raining. Parameters: height (List[int]): The heights of the buildings. Returns: int: Total amount of water trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"from typing import List def eventual_safe_nodes(n: int, edges: List[List[int]]) -> List[int]: Determine the list of vertices that can be considered as \\"safe\\" in a directed acyclic graph. >>> eventual_safe_nodes(4, [[0, 1], [1, 2], [2, 3], [3, 0]]) [] >>> eventual_safe_nodes(5, [[0, 1], [1, 2], [2, 3], [3, 0], [3, 4]]) [4] >>> eventual_safe_nodes(7, [[0, 1], [0, 2], [1, 3], [3, 4], [4, 1], [2, 5], [5, 6], [6, 2]]) [] >>> eventual_safe_nodes(1, []) [0] >>> eventual_safe_nodes(6, [[0, 1], [2, 3], [4, 5]]) [0, 1, 2, 3, 4, 5]","solution":"def eventual_safe_nodes(n, edges): from collections import defaultdict, deque # Create a graph and reverse graph representation graph = defaultdict(list) reverse_graph = defaultdict(list) outdegree = [0] * n # Out-degree of each node # Build the graph and reverse graph for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) outdegree[u] += 1 # Create a queue to store nodes with out-degree 0 (terminal nodes) queue = deque([i for i in range(n) if outdegree[i] == 0]) safe = [False] * n # Process the queue while queue: node = queue.popleft() safe[node] = True # Mark this node as safe for neigh in reverse_graph[node]: outdegree[neigh] -= 1 if outdegree[neigh] == 0: queue.append(neigh) # Collect all safe nodes and sort them safe_nodes = [i for i in range(n) if safe[i]] safe_nodes.sort() return safe_nodes"},{"question":"def reverse_parentheses(s: str) -> str: Reverses the strings in each pair of matching parentheses, starting from the innermost one. Parameters: s (str): The input string containing lowercase letters and parentheses. Returns: str: The modified string with reversed sections from parentheses. Examples: >>> reverse_parentheses(\\"(ab)\\") 'ba' >>> reverse_parentheses(\\"(u(love)i)\\") 'iloveu' >>> reverse_parentheses(\\"a(bcdefghijkl(mno)p)q\\") 'apmnolkjihgfedcbq'","solution":"def reverse_parentheses(s): Reverses the strings in each pair of matching parentheses, starting from the innermost one. Parameters: s (str): The input string containing lowercase letters and parentheses. Returns: str: The modified string with reversed sections from parentheses. stack = [] for ch in s: if ch == ')': temp = [] while stack and stack[-1] != '(': temp.append(stack.pop()) # pop the '(' from the stack stack.pop() # extend the stack with the reversed content from temp stack.extend(temp) else: stack.append(ch) return ''.join(stack)"},{"question":"def trap(heights: List[int]) -> int: Returns the maximum amount of water that can be trapped between buildings. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([1, 2, 3, 4, 5]) 0","solution":"def trap(heights): Returns the maximum amount of water that can be trapped between buildings. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def shortest_valid_substring(s: str) -> int: Return the length of the shortest valid substring in s that contains equal number of 'a', 'b', and 'c'. >>> shortest_valid_substring('abcabcaa') 3 >>> shortest_valid_substring('bbbb') -1 >>> shortest_valid_substring('aaa') -1 >>> shortest_valid_substring('aabbccabcabcabc') 3 >>> shortest_valid_substring('aabbccbbaaccabc') 3 >>> shortest_valid_substring('bbbbcbacbacbaac') 3 >>> shortest_valid_substring('aaabbbcccabcabcabc') 3 >>> shortest_valid_substring('abcabcbbcaabcaabac') 3","solution":"def shortest_valid_substring(s): n = len(s) min_length = float('inf') for left in range(n): count = {'a': 0, 'b': 0, 'c': 0} for right in range(left, n): if s[right] in count: count[s[right]] += 1 if count['a'] == count['b'] == count['c'] and count['a'] > 0: min_length = min(min_length, right - left + 1) return min_length if min_length != float('inf') else -1"},{"question":"def longest_bitonic_subarray(nums): Given an integer array nums, return the length of the longest bitonic subarray. A bitonic subarray is a subarray that is first increasing and then decreasing. A strictly increasing or strictly decreasing subarray is also considered bitonic. >>> longest_bitonic_subarray([1, 2, 3, 4, 5]) == 5 >>> longest_bitonic_subarray([5, 4, 3, 2, 1]) == 5 >>> longest_bitonic_subarray([1, 2, 3, 4, 2, 1, 5, 6, 3, 2]) == 6 >>> longest_bitonic_subarray([10, 20, 30, 25, 20, 19, 18]) == 7 >>> longest_bitonic_subarray([12, 4, 78, 90, 45, 23]) == 5 >>> longest_bitonic_subarray([5, 4, 3, 2, 1, 0]) == 6 >>> longest_bitonic_subarray([]) == 0 >>> longest_bitonic_subarray([7]) == 1","solution":"def longest_bitonic_subarray(nums): n = len(nums) if n == 0: return 0 # Arrays to store the longest increasing and decreasing subarray lengths inc = [1] * n dec = [1] * n # Fill increasing subarray length array for i in range(1, n): if nums[i] > nums[i - 1]: inc[i] = inc[i - 1] + 1 # Fill decreasing subarray length array for j in range(n - 2, -1, -1): if nums[j] > nums[j + 1]: dec[j] = dec[j + 1] + 1 # Find the length of the maximum length bitonic subarray max_len = 0 for i in range(n): max_len = max(max_len, inc[i] + dec[i] - 1) return max_len"},{"question":"def find_participant_never_lost(n: int, results: List[List[int]]) -> List[int]: Determine the number of participants who have taken part in at least one competition and have never lost any round. Return the list of participants' IDs sorted in ascending order. Parameters: n (int): The number of participants. results (List[List[int]]): A list of lists where each sublist contains two integers [winner, loser], indicating that 'winner' defeated 'loser' in that round. Returns: List[int]: List of participant IDs in ascending order who have never lost any round. Example Usage: >>> find_participant_never_lost(3, []) [1, 2, 3] >>> find_participant_never_lost(3, [[1, 2], [2, 3], [3, 1]]) [] >>> find_participant_never_lost(4, [[1, 2], [3, 4], [1, 3]]) [1] >>> find_participant_never_lost(5, [[2, 1], [3, 4], [5, 2], [3, 5]]) [3] >>> find_participant_never_lost(2, []) [1, 2] >>> find_participant_never_lost(2, [[1, 2]]) [1]","solution":"def find_participant_never_lost(n, results): Returns the list of participant IDs who never lost any round. Parameters: n (int): The number of participants. results (List[List[int]]): A list of lists where each sublist contains two integers [winner, loser], indicating that \`winner\` defeated \`loser\` in that round. Returns: List[int]: List of participant IDs in ascending order who have never lost any round. all_participants = set(range(1, n + 1)) losers = {loser for winner, loser in results} never_lost = all_participants - losers return sorted(list(never_lost))"},{"question":"from typing import List def rotate_image(matrix: List[List[int]]) -> List[List[int]]: Given a 2D integer array \`matrix\` of size \`n x n\` representing an image, rotate the image by 90 degrees (clockwise). The function modifies the input 2D array directly and returns the rotated image as the final output. Parameters: matrix (List[List[int]]): The input 2D integer array to be rotated. Returns: List[List[int]]: The rotated 2D array. >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> rotate_image(matrix) [[3, 1], [4, 2]] >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_image(matrix) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] def test_rotate_image_2x2(): matrix = [ [1, 2], [3, 4] ] expected_result = [ [3, 1], [4, 2] ] assert rotate_image(matrix) == expected_result def test_rotate_image_3x3(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected_result = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_image(matrix) == expected_result def test_rotate_image_4x4(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected_result = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotate_image(matrix) == expected_result def test_rotate_image_single_element(): matrix = [[1]] expected_result = [[1]] assert rotate_image(matrix) == expected_result","solution":"def rotate_image(matrix): Rotates the given n x n 2D matrix 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"def maxSumSubarray(arr: List[int], k: int) -> int: Returns the maximum sum of a subarray of length k in arr. If the length of array is less than k, return -1. >>> maxSumSubarray([1, 2, 3, 4, 5], 2) == 9 >>> maxSumSubarray([1, 2, 3, 4, 5], 3) == 12 >>> maxSumSubarray([5, 2, -1, 2, 3, 4], 2) == 7 >>> maxSumSubarray([5, 2, -1, 2, 3, 4], 3) == 9 >>> maxSumSubarray([1, 2, 3, 4, 5], 6) == -1 >>> maxSumSubarray([], 1) == -1 >>> maxSumSubarray([1], 1) == 1 >>> maxSumSubarray([1, 2, 3], 3) == 6 >>> maxSumSubarray([-1, -2, -3, -4, -5], 2) == -3 pass","solution":"from typing import List def maxSumSubarray(arr: List[int], k: int) -> int: Returns the maximum sum of a subarray of length k in arr. If the length of array is less than k, return -1. n = len(arr) if n < k: return -1 # Initial window sum current_sum = sum(arr[:k]) max_sum = current_sum # Slide the window for i in range(k, n): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def length_of_longest_unique_subsequence(arr: List[int]) -> int: Returns the length of the longest subsequence that consists of only unique elements. >>> length_of_longest_unique_subsequence([1, 2, 3, 4, 5]) == 5 >>> length_of_longest_unique_subsequence([1, 1, 1, 1, 1]) == 1 >>> length_of_longest_unique_subsequence([1, 2, 2, 3, 4, 4, 5]) == 5 >>> length_of_longest_unique_subsequence([1]) == 1 >>> length_of_longest_unique_subsequence([]) == 0 >>> length_of_longest_unique_subsequence([i % 10 for i in range(1000)]) == 10","solution":"def length_of_longest_unique_subsequence(arr): Returns the length of the longest subsequence that consists of only unique elements. if not arr: return 0 unique_elements = set(arr) return len(unique_elements)"},{"question":"def max_profit_with_two_transactions(prices: List[int]) -> int: Calculate the maximum profit with at most two transactions. >>> max_profit_with_two_transactions([]) == 0 >>> max_profit_with_two_transactions([5]) == 0 >>> max_profit_with_two_transactions([7, 1]) == 0 >>> max_profit_with_two_transactions([1, 7]) == 6 >>> max_profit_with_two_transactions([7, 1, 5, 3, 6, 4]) == 7 >>> max_profit_with_two_transactions([3, 3, 5, 0, 0, 3, 1, 4]) == 6 >>> max_profit_with_two_transactions([1, 2, 3, 4, 5]) == 4 >>> max_profit_with_two_transactions([7, 6, 4, 3, 1]) == 0 >>> max_profit_with_two_transactions([1, 2, 4, 2, 5, 7, 2, 4, 9, 0]) == 13","solution":"def max_profit_with_two_transactions(prices): if not prices: return 0 n = len(prices) max_profit = 0 # Initialize profit arrays profit_one_transaction = [0] * n profit_two_transactions = [0] * n # Max profit if only one transaction is allowed min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) profit_one_transaction[i] = max(profit_one_transaction[i-1], prices[i] - min_price) # Max profit with at most two transactions max_price = prices[-1] for i in range(n-2, -1, -1): max_price = max(max_price, prices[i]) profit_two_transactions[i] = max(profit_two_transactions[i+1], max_price - prices[i] + profit_one_transaction[i]) max_profit = max(profit_two_transactions) return max_profit"},{"question":"def minSwapsToPalindrome(s: str) -> int: Determine the minimum number of adjacent swaps required to make s a palindrome. If it is impossible to form a palindrome, return -1. >>> minSwapsToPalindrome(\\"mamad\\") 3 >>> minSwapsToPalindrome(\\"asflkj\\") -1 >>> minSwapsToPalindrome(\\"aabb\\") 2 >>> minSwapsToPalindrome(\\"ntiin\\") 1 >>> minSwapsToPalindrome(\\"abcdef\\") -1 >>> minSwapsToPalindrome(\\"radar\\") 0 >>> minSwapsToPalindrome(\\"a\\") 0 >>> minSwapsToPalindrome(\\"abca\\") -1 >>> minSwapsToPalindrome(\\"aa\\") 0 >>> minSwapsToPalindrome(\\"abcdcba\\") 0","solution":"def minSwapsToPalindrome(s: str) -> int: from collections import Counter def is_palindrome_possible(s: str) -> bool: counts = Counter(s) odd_count = sum(1 for count in counts.values() if count % 2 != 0) return odd_count <= 1 def min_swaps_to_make_palindrome(s: str) -> int: s = list(s) n = len(s) swaps = 0 for i in range(n // 2): left = i right = n - left - 1 while left < right: if s[left] == s[right]: break right -= 1 if left == right: s[left], s[left+1] = s[left+1], s[left] swaps += 1 left -= 1 continue for j in range(right, n-left-1): s[j], s[j+1] = s[j+1], s[j] swaps += 1 return swaps if not is_palindrome_possible(s): return -1 return min_swaps_to_make_palindrome(s)"},{"question":"def min_string_value(s: str) -> int: Computes the minimum possible value by repeatedly multiplying adjacent digits. :param s: Input string composed of digits :return: Minimum possible value as an integer >>> min_string_value(\\"5\\") 5 >>> min_string_value(\\"12\\") 2 >>> min_string_value(\\"123\\") 6 >>> min_string_value(\\"12345\\") 120 >>> min_string_value(\\"1111\\") 1 >>> min_string_value(\\"9876\\") 3024 >>> min_string_value(\\"999999\\") 531441 >>> min_string_value(\\"102\\") 0","solution":"def min_string_value(s): Computes the minimum possible value by repeatedly multiplying adjacent digits. :param s: Input string composed of digits :return: Minimum possible value as an integer # If the string is already of length 1 if len(s) == 1: return int(s) # Convert the string to a list of integers numbers = list(map(int, s)) # Initialize result with the first number result = numbers[0] for num in numbers[1:]: result *= num return result"},{"question":"class RangeSum: def __init__(self, nums): Initializes the object with the given array \`nums\`. def update(self, index, val): Updates the value of \`nums\` at the specified index to be \`val\`. def sumRange(self, left, right): Returns the sum of the elements of \`nums\` between indices \`left\` and \`right\` inclusive (i.e., nums[left] + nums[left + 1] + ... + nums[right]). >>> rs = RangeSum([1, 3, 5]) >>> rs.sumRange(0, 2) 9 >>> rs.update(1, 2) >>> rs.sumRange(0, 2) 8 >>> rs.sumRange(1, 2) 7 from solution import RangeSum def test_range_sum_initialization(): nums = [1, 3, 5] rs = RangeSum(nums) assert rs.sumRange(0, 2) == 9 # 1 + 3 + 5 = 9 def test_range_sum_update(): nums = [1, 3, 5] rs = RangeSum(nums) rs.update(1, 2) # nums becomes [1, 2, 5] assert rs.sumRange(0, 2) == 8 # 1 + 2 + 5 = 8 def test_range_sum_partial(): nums = [1, 3, 5] rs = RangeSum(nums) assert rs.sumRange(1, 2) == 8 # 3 + 5 = 8 def test_multiple_updates(): nums = [1, 3, 5] rs = RangeSum(nums) rs.update(1, 2) # nums becomes [1, 2, 5] rs.update(2, 6) # nums becomes [1, 2, 6] assert rs.sumRange(0, 2) == 9 # 1 + 2 + 6 = 9 assert rs.sumRange(1, 2) == 8 # 2 + 6 = 8 assert rs.sumRange(0, 1) == 3 # 1 + 2 = 3","solution":"class RangeSum: def __init__(self, nums): self.nums = nums self.n = len(nums) self.tree = [0] * (self.n + 1) for i in range(self.n): self.add(i + 1, nums[i]) def add(self, index, val): while index <= self.n: self.tree[index] += val index += index & -index def update(self, index, val): delta = val - self.nums[index] self.nums[index] = val self.add(index + 1, delta) def sumRange(self, left, right): return self.prefixSum(right + 1) - self.prefixSum(left) def prefixSum(self, index): sum_ = 0 while index > 0: sum_ += self.tree[index] index -= index & -index return sum_"},{"question":"def subarray_sum(nums, k): Determines if there exists a continuous subarray whose sum is exactly k. :param nums: List[int] - A list of integers. :param k: int - The target sum. :return: bool - True if such a subarray exists, False otherwise. >>> subarray_sum([1, 2, 3], 5) == True >>> subarray_sum([1, -1, 5, -2, 3], 3) == True >>> subarray_sum([1, 2, 3], 10) == False >>> subarray_sum([1, 2, -1, 1, 2], 0) == True >>> subarray_sum([-1, -2, -3, 4, 5, 6, -7, 8, 9], 15) == True >>> subarray_sum([-1, -2, -3, -4], -10) == True >>> subarray_sum([-1, -2, -3, -4], -5) == True >>> subarray_sum([-1, -2, -3, -4], -15) == False >>> subarray_sum([4], 4) == True >>> subarray_sum([5], 4) == False","solution":"def subarray_sum(nums, k): Determines if there exists a continuous subarray whose sum is exactly k. :param nums: List[int] - A list of integers. :param k: int - The target sum. :return: bool - True if such a subarray exists, False otherwise. current_sum = 0 sum_dict = {0: 1} for num in nums: current_sum += num if current_sum - k in sum_dict: return True if current_sum not in sum_dict: sum_dict[current_sum] = 1 else: sum_dict[current_sum] += 1 return False"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detectCycle(head: ListNode) -> ListNode: This function detects the node where the cycle begins in a linked list. If there is no cycle, it returns None. >>> head = ListNode(1, ListNode(2, ListNode(3, ListNode(4)))) >>> detectCycle(head) is None True >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(3) >>> node4 = ListNode(4) >>> node1.next = node2 >>> node2.next = node3 >>> node3.next = node4 >>> node4.next = node2 >>> detectCycle(node1) == node2 True >>> node1 = ListNode(1) >>> detectCycle(node1) is None True >>> node1.next = node1 >>> detectCycle(node1) == node1 True >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node1.next = node2 >>> node2.next = node1 >>> detectCycle(node1) == node1 True","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detectCycle(head): This function detects the node where the cycle begins in a linked list. If there is no cycle, it returns None. if head is None or head.next is None: return None slow = fast = head # First, determine if there is a cycle. while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # If there is no cycle, return None. if not fast or not fast.next: return None # Find the start of the cycle. slow = head while slow != fast: slow = slow.next fast = fast.next return slow # slow (or fast) points to the start of the cycle."},{"question":"from typing import List def topKFrequent(nums: List[int], k: int) -> List[int]: Find the k most frequent elements in the integer array nums. Return the answer in any order. You may assume that k is always valid: 1  k  number of unique elements in the array. Args: nums (List[int]): The list of integers. k (int): The number of most frequent elements to return. Returns: List[int]: The list of k most frequent elements. Example: >>> topKFrequent([1,1,1,2,2,3], 2) [1, 2] >>> topKFrequent([1], 1) [1]","solution":"from typing import List from collections import Counter def topKFrequent(nums: List[int], k: int) -> List[int]: Returns the k most frequent elements in the array nums. count = Counter(nums) return [item for item, freq in count.most_common(k)]"},{"question":"from typing import List def numDistinctBlocks(grid: List[List[int]]) -> int: Return the number of distinct blocks (connected houses marked by a \`1\`) present in the grid. Parameters: - grid: List[List[int]]: A 2D grid of size \`m x n\` where each cell contains exactly one house (\`1\`) or is empty (\`0\`). Returns: - int: Number of distinct blocks. Examples: >>> numDistinctBlocks([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 1 >>> numDistinctBlocks([ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ]) 5 >>> numDistinctBlocks([ ... [1, 0, 0], ... [1, 1, 0], ... [0, 1, 0] ... ]) 1 >>> numDistinctBlocks([ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ]) 2","solution":"def numDistinctBlocks(grid): def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1: return grid[i][j] = -1 # Mark this house as visited dfs(grid, i+1, j) dfs(grid, i-1, j) dfs(grid, i, j+1) dfs(grid, i, j-1) if not grid: return 0 num_blocks = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: dfs(grid, i, j) num_blocks += 1 return num_blocks"},{"question":"def longest_substring_with_k_distinct(s: str, k: int) -> int: Finds the length of the longest substring with at most k distinct characters. >>> longest_substring_with_k_distinct(\\"araaci\\", 2) 4 >>> longest_substring_with_k_distinct(\\"aaaaa\\", 1) 5 >>> longest_substring_with_k_distinct(\\"\\", 2) 0 >>> longest_substring_with_k_distinct(\\"abc\\", 0) 0 >>> longest_substring_with_k_distinct(\\"abc\\", 3) 3 >>> longest_substring_with_k_distinct(\\"eceba\\", 2) 3 >>> longest_substring_with_k_distinct(\\"abcdef\\", 10) 6","solution":"def longest_substring_with_k_distinct(s, k): Finds the length of the longest substring with at most k distinct characters. Parameters: s (str): the input string. k (int): the maximum number of distinct characters. Returns: int: length of the longest substring with at most k distinct characters. if k == 0 or not s: return 0 left = 0 right = 0 max_len = 0 char_map = {} while right < len(s): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len # Solution Time Complexity # The time complexity of this solution is O(n), where n is the length of the string \`s\`. # This is because each character is processed at most twice (once added to the window and once removed)."},{"question":"def max_width_below_threshold(height: List[int], h: int) -> int: Returns the maximum width of a rectangular subarray in which each building has a height greater than or equal to h. >>> max_width_below_threshold([1, 3, 2, 4, 3], 3) 2 >>> max_width_below_threshold([1, 2, 1, 1], 3) 0 >>> max_width_below_threshold([4, 5, 6], 3) 3 >>> max_width_below_threshold([1, 2, 3, 3, 2, 4], 2) 5 >>> max_width_below_threshold([3], 3) 1 >>> max_width_below_threshold([1], 3) 0 >>> max_width_below_threshold([], 3) 0","solution":"def max_width_below_threshold(height, h): Returns the maximum width of a rectangular subarray in which each building has a height greater than or equal to h. max_width = 0 current_width = 0 for ht in height: if ht >= h: current_width += 1 max_width = max(max_width, current_width) else: current_width = 0 return max_width"},{"question":"import random class RandomizedStringCollection: A data structure that supports insert, delete, search, and getRandom operations for a list of strings. >>> collection = RandomizedStringCollection() >>> collection.insert(\\"apple\\") >>> collection.search(\\"apple\\") True >>> collection.delete(\\"apple\\") >>> collection.search(\\"apple\\") False >>> collection.getRandom() None def __init__(self): Initialize your data structure here. def insert(self, s): Insert the string \`s\` into the list. def delete(self, s): Delete one occurrence of the string \`s\` from the list. If the string \`s\` is not in the list, do nothing. def search(self, s): Return \`true\` if the string \`s\` is present in the list, otherwise return \`false\`. def getRandom(self): Return a random string from the list. Each string in the list should have an equal probability of being returned. If the list is empty, return \`null\`. # Test cases def test_insert_and_search(): collection = RandomizedStringCollection() collection.insert(\\"apple\\") assert collection.search(\\"apple\\") == True assert collection.search(\\"banana\\") == False def test_delete(): collection = RandomizedStringCollection() collection.insert(\\"apple\\") collection.delete(\\"apple\\") assert collection.search(\\"apple\\") == False def test_delete_nonexistent(): collection = RandomizedStringCollection() collection.insert(\\"apple\\") collection.delete(\\"banana\\") assert collection.search(\\"apple\\") == True def test_get_random(): collection = RandomizedStringCollection() strings = [\\"apple\\", \\"banana\\", \\"cherry\\"] for s in strings: collection.insert(s) random_string = collection.getRandom() assert random_string in strings def test_get_random_empty(): collection = RandomizedStringCollection() assert collection.getRandom() == None def test_insert_duplicates(): collection = RandomizedStringCollection() collection.insert(\\"apple\\") collection.insert(\\"apple\\") collection.delete(\\"apple\\") assert collection.search(\\"apple\\") == False","solution":"import random class RandomizedStringCollection: def __init__(self): self.string_list = [] self.string_map = {} def insert(self, s): Insert the string \`s\` into the list. if s in self.string_map: return self.string_list.append(s) self.string_map[s] = len(self.string_list) - 1 def delete(self, s): Delete one occurrence of the string \`s\` from the list. If the string \`s\` is not in the list, do nothing. if s not in self.string_map: return index = self.string_map[s] last_string = self.string_list[-1] self.string_list[index] = last_string self.string_map[last_string] = index self.string_list.pop() del self.string_map[s] def search(self, s): Return \`true\` if the string \`s\` is present in the list, otherwise return \`false\`. return s in self.string_map def getRandom(self): Return a random string from the list. Each string in the list should have an equal probability of being returned. If the list is empty, return \`null\`. if not self.string_list: return None return random.choice(self.string_list)"},{"question":"from typing import List def longest_harmonious_subsequence(arr: List[int], difference: int) -> int: Returns the length of the longest harmonious subsequence with the given difference. :param arr: List[int] - Array of integers :param difference: int - The difference between consecutive elements in the subsequence :return: int - Length of the longest harmonious subsequence >>> longest_harmonious_subsequence([1, 2, 3, 4], 1) 4 >>> longest_harmonious_subsequence([1, 3, 5, 7], 2) 4 >>> longest_harmonious_subsequence([1, 5, 9, 13], 4) 4 >>> longest_harmonious_subsequence([1, 2, 3, 5, 6, 7], 1) 3 >>> longest_harmonious_subsequence([1, 3, 2, 4, 6, 8], 2) 4 >>> longest_harmonious_subsequence([1, 5, 7, 8, 5], 2) 2 >>> longest_harmonious_subsequence([], 1) 0 >>> longest_harmonious_subsequence([1, 1, 1, 1, 1], 0) 5 >>> longest_harmonious_subsequence([3, 6, 9, 12], 3) 4 >>> longest_harmonious_subsequence([5, 10, 15, 20], 5) 4","solution":"def longest_harmonious_subsequence(arr, difference): Returns the length of the longest harmonious subsequence with the given difference. :param arr: List[int] - Array of integers :param difference: int - The difference between consecutive elements in the subsequence :return: int - Length of the longest harmonious subsequence if not arr: return 0 dp = {} max_length = 0 for num in arr: prev_length = dp.get(num - difference, 0) dp[num] = prev_length + 1 max_length = max(max_length, dp[num]) return max_length"},{"question":"def longest_repeating_substring(s: str) -> int: Returns the length of the longest substring that occurs at least twice in the string \`s\`. >>> longest_repeating_substring(\\"abcdefg\\") 0 >>> longest_repeating_substring(\\"abcabc\\") 3 >>> longest_repeating_substring(\\"aaaa\\") 3 >>> longest_repeating_substring(\\"abcdeabc\\") 3 >>> longest_repeating_substring(\\"aabcaabdaab\\") 3 >>> longest_repeating_substring(\\"aabbaabb\\") 4","solution":"def longest_repeating_substring(s): Returns the length of the longest substring that occurs at least twice in the string \`s\`. def has_repeating_substring_of_length(length): seen = set() for i in range(len(s) - length + 1): substring = s[i:i + length] if substring in seen: return True seen.add(substring) return False left, right = 1, len(s) result = 0 while left <= right: mid = (left + right) // 2 if has_repeating_substring_of_length(mid): result = mid left = mid + 1 else: right = mid - 1 return result"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1, l2): Merge two sorted linked lists and return it as a sorted linked list. The merged linked list should be made by splicing together the nodes of the original two linked lists. >>> linkedlist_to_list(mergeTwoLists(list_to_linkedlist([1, 2, 4]), list_to_linkedlist([1, 3, 4]))) [1, 1, 2, 3, 4, 4] >>> linkedlist_to_list(mergeTwoLists(list_to_linkedlist([1, 3, 4]), list_to_linkedlist([]))) [1, 3, 4] >>> linkedlist_to_list(mergeTwoLists(list_to_linkedlist([]), list_to_linkedlist([]))) [] >>> linkedlist_to_list(mergeTwoLists(list_to_linkedlist([2]), list_to_linkedlist([1]))) [1, 2] >>> linkedlist_to_list(mergeTwoLists(list_to_linkedlist([1, 2, 2]), list_to_linkedlist([2, 3, 4]))) [1, 2, 2, 2, 3, 4]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1, l2): Merge two sorted linked lists and return it as a sorted linked list. The merged linked list should be made by splicing together the nodes of the original two linked lists. prehead = ListNode(-1) prev = prehead while l1 and l2: if l1.val <= l2.val: prev.next = l1 l1 = l1.next else: prev.next = l2 l2 = l2.next prev = prev.next prev.next = l1 if l1 is not None else l2 return prehead.next"},{"question":"class WordDictionary: def __init__(self): Initializes the object. pass def addWord(self, word): Adds a word to the data structure. pass def search(self, word): Returns true if there is any string in the data structure that matches word or false otherwise. A word could contain the dot character '.' to represent any one letter. pass","solution":"class WordDictionary: def __init__(self): Initializes the object. self.words = [] def addWord(self, word): Adds a word to the data structure. self.words.append(word) def search(self, word): Returns true if there is any string in the data structure that matches word or false otherwise. A word could contain the dot character '.' to represent any one letter. import re pattern = re.compile(\\"^\\" + word.replace(\\".\\", \\"[a-z]\\") + \\"\\") for w in self.words: if pattern.match(w): return True return False"},{"question":"def max_length_with_flip(nums: List[int], target: int) -> int: Returns the maximum length of a contiguous subarray that contains \`target\` ones after a single flip. >>> max_length_with_flip([1,0,1,1,0], 4) == 4 >>> max_length_with_flip([1,1,0,1], 3) == 3 >>> max_length_with_flip([1,1,1,1], 4) == 4 >>> max_length_with_flip([0], 1) == 1 >>> max_length_with_flip([0, 0], 2) == 1 >>> max_length_with_flip([1, 0, 1, 0, 1], 3) == 3 >>> max_length_with_flip([1, 1, 0, 0, 1, 1], 3) == 3 >>> max_length_with_flip([0, 1, 0, 1, 0], 2) == 2","solution":"def max_length_with_flip(nums, target): Returns the maximum length of a contiguous subarray that contains \`target\` ones after a single flip. n = len(nums) max_len = 0 left = 0 zeros_flipped = 0 for right in range(n): if nums[right] == 0: zeros_flipped += 1 while zeros_flipped > 1: if nums[left] == 0: zeros_flipped -= 1 left += 1 max_len = max(max_len, right - left + 1) return min(max_len, target)"},{"question":"def can_be_non_decreasing_by_removing_one(arr: List[int]) -> bool: Given an array of integers \`arr\`, you are allowed to remove one integer from the array such that the remaining array is in non-decreasing order. Return \`true\` if it is possible to make the array non-decreasing by removing exactly one integer, otherwise return \`false\`. >>> can_be_non_decreasing_by_removing_one([1, 2, 3, 4]) True >>> can_be_non_decreasing_by_removing_one([3, 4, 2, 4, 5]) True >>> can_be_non_decreasing_by_removing_one([1, 2, 3, 4, 2, 1]) False >>> can_be_non_decreasing_by_removing_one([10]) True >>> can_be_non_decreasing_by_removing_one([2, 1]) True >>> can_be_non_decreasing_by_removing_one([1, 2]) True >>> can_be_non_decreasing_by_removing_one([1, 2, 2, 2, 3]) True","solution":"def can_be_non_decreasing_by_removing_one(arr): Given an array of integers \`arr\`, determines if it is possible to make the array non-decreasing by removing exactly one integer. def is_non_decreasing(a): return all(x <= y for x, y in zip(a, a[1:])) n = len(arr) for i in range(n): if is_non_decreasing(arr[:i] + arr[i+1:]): return True return False"},{"question":"def longestUniqueSubstr(s: str) -> int: Write a function that receives a string and returns the length of the longest substring without repeating characters. The function should efficiently handle cases where the string is very long or contains a mix of different types of characters, ensuring the solution runs in linear time. >>> longestUniqueSubstr(\\"abcabcbb\\") 3 >>> longestUniqueSubstr(\\"abcdef\\") 6 >>> longestUniqueSubstr(\\"\\") 0 >>> longestUniqueSubstr(\\"aaaa\\") 1 >>> longestUniqueSubstr(\\"pwwkew\\") 3 >>> longestUniqueSubstr(\\"1234567890\\") 10 >>> longestUniqueSubstr(\\"aAabBb\\") 4 >>> longestUniqueSubstr(\\"!@#%^&*()\\") 10 >>> longestUniqueSubstr(\\"a\\" * 1000 + \\"b\\" * 1000) 2","solution":"def longestUniqueSubstr(s): Returns the length of the longest substring without repeating characters. Parameters: s (str): The input string. Returns: int: The length of the longest substring without repeating characters. n = len(s) char_index = {} max_length = 0 start = 0 for i in range(n): if s[i] in char_index and char_index[s[i]] >= start: start = char_index[s[i]] + 1 char_index[s[i]] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"def min_operations(arr): Returns the minimum number of operations required to make the array non-decreasing or non-increasing segments. >>> min_operations([1, 2, 3, 4, 5]) == 0 >>> min_operations([5, 4, 3, 2, 1]) == 0 >>> min_operations([3, 1, 4, 2, 5]) == 2 >>> min_operations([1]) == 0 >>> min_operations([1, 2]) == 0 >>> min_operations([2, 1]) == 0 >>> min_operations([2, 2, 2]) == 0 >>> min_operations([1, 3, 2, 4]) == 1","solution":"def min_operations(arr): Returns the minimum number of operations required to make the array non-decreasing or non-increasing segments. n = len(arr) # Edge cases if n <= 1: return 0 # Calculate the minimum number of operations to make the array non-decreasing def min_ops_non_decreasing(arr): ops = 0 for i in range(1, len(arr)): if arr[i] < arr[i - 1]: ops += 1 arr[i] = arr[i - 1] return ops # Calculate the minimum number of operations to make the array non-increasing def min_ops_non_increasing(arr): ops = 0 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: ops += 1 arr[i] = arr[i - 1] return ops # Take the minimum of non-decreasing and non-increasing operations non_decreasing_ops = min_ops_non_decreasing(arr[:]) non_increasing_ops = min_ops_non_increasing(arr[:]) return min(non_decreasing_ops, non_increasing_ops)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_levels(root): Inverts the order of nodes at every depth level of the binary tree. Args: root (TreeNode): The root of the binary tree. Returns: TreeNode: The root of the binary tree after inversion of levels. >>> def tree_to_levels(root): ... if not root: ... return [] ... levels = [] ... current_level = [root] ... while current_level: ... levels.append([node.val for node in current_level]) ... next_level = [] ... for node in current_level: ... if node.left: ... next_level.append(node.left) ... if node.right: ... next_level.append(node.right) ... current_level = next_level ... return levels >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> inverted_root = invert_levels(root) >>> tree_to_levels(inverted_root) [[1], [3, 2]] >>> root = TreeNode(1, ... TreeNode(2, TreeNode(4), TreeNode(5)), ... TreeNode(3, TreeNode(6), TreeNode(7))) >>> inverted_root = invert_levels(root) >>> tree_to_levels(inverted_root) [[1], [3, 2], [7, 6, 5, 4]]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_levels(root): Inverts the order of nodes at every depth level of the binary tree. if not root: return None current_level = [root] while current_level: # Reverse values at the current level values = [node.val for node in current_level] for i, node in enumerate(current_level): node.val = values[~i] # Prepare for the next level next_level = [] for node in current_level: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) current_level = next_level return root"},{"question":"def max_height(grid: List[List[int]]) -> int: Returns the maximum height h such that all buildings in the matrix can be maintained or increased to height h by only performing increments on rows or columns. >>> max_height([[3]]) == 3 >>> max_height([[1, 2], [2, 3]]) == 2 >>> max_height([[1, 2], [3, 4]]) == 2 >>> max_height([[1, 4, 3], [3, 1, 2], [4, 4, 4]]) == 3 >>> max_height([[2, 2], [2, 2]]) == 2","solution":"def max_height(grid): Returns the maximum height h such that all buildings in the matrix can be maintained or increased to height h by only performing increments on rows or columns. m, n = len(grid), len(grid[0]) row_max_values = [max(row) for row in grid] col_max_values = [max(grid[i][j] for i in range(m)) for j in range(n)] max_h = float('inf') for i in range(m): for j in range(n): max_h = min(max_h, row_max_values[i], col_max_values[j]) return max_h"},{"question":"def can_construct(s: str, t: str) -> bool: Determine if you can construct \`t\` by rearranging the letters of \`s\` and optionally appending any number (including zero) of additional letters to \`s\`. Return \`true\` if it is possible, otherwise, return \`false\`. >>> can_construct('abc', 'ab') True >>> can_construct('abc', 'abcd') False >>> can_construct('aabbc', 'abc') True >>> can_construct('a', 'a') True >>> can_construct('a', 'b') False >>> can_construct('', '') True >>> can_construct('a', '') True >>> can_construct('', 'a') False >>> can_construct('aabbcc', 'abcabc') True >>> can_construct('aabbcc', 'aaa') False >>> can_construct('abcdefg', 'fgabc') True >>> can_construct('abcdefg', 'gfedcba') True >>> can_construct('aabb', 'aaab') False","solution":"def can_construct(s, t): Returns True if t can be constructed by rearranging the letters of s and optionally appending any number of additional letters to s. from collections import Counter counter_s = Counter(s) counter_t = Counter(t) for char in counter_t: if counter_t[char] > counter_s.get(char, 0): return False return True"},{"question":"from typing import List def top_k_frequent_characters(s: str, k: int) -> List[str]: Finds the k most frequent characters in the string \`s\`. If there are multiple characters with the same frequency, return them in lexicographical order. Return the resulting characters as a list. Args: s (str): The input string containing only lowercase English letters. k (int): The number of most frequent characters to return. Returns: List[str]: A list of the k most frequent characters. >>> top_k_frequent_characters(\\"abbccc\\", 2) ['c', 'b'] >>> top_k_frequent_characters(\\"\\", 1) [] from solution import top_k_frequent_characters def test_single_character(): assert top_k_frequent_characters(\\"a\\", 1) == [\\"a\\"] def test_multiple_frequencies(): assert top_k_frequent_characters(\\"aabbcc\\", 2) == [\\"a\\", \\"b\\"] def test_lexicographical_order(): assert top_k_frequent_characters(\\"abbccc\\", 2) == [\\"c\\", \\"b\\"] def test_same_frequency(): assert top_k_frequent_characters(\\"abac\\", 2) == [\\"a\\", \\"b\\"] def test_large_k_value(): assert top_k_frequent_characters(\\"abc\\", 10) == [\\"a\\", \\"b\\", \\"c\\"] def test_empty_string(): assert top_k_frequent_characters(\\"\\", 1) == [] def test_all_unique_characters(): assert top_k_frequent_characters(\\"abcdef\\", 3) == [\\"a\\", \\"b\\", \\"c\\"] def test_tie_in_frequencies(): assert top_k_frequent_characters(\\"aabbccdd\\", 4) == [\\"a\\", \\"b\\", \\"c\\", \\"d\\"]","solution":"from collections import Counter def top_k_frequent_characters(s, k): Finds the k most frequent characters in the string \`s\`. If there are multiple characters with the same frequency, returns them in lexicographical order. Args: s (str): The input string containing only lowercase English letters. k (int): The number of most frequent characters to return. Returns: List[str]: A list of the k most frequent characters. # Count the frequency of each character in the string frequency = Counter(s) # Get a list of characters sorted by frequency (descending) and then lexicographically sorted_characters = sorted(frequency, key=lambda x: (-frequency[x], x)) # Return the top k characters return sorted_characters[:k]"},{"question":"from collections import Counter class SubstringFinder: def __init__(self, s, words): Initializes the object with the string s and the string array words. pass def containsPermutation(self, target): Checks if any permutation of target is a substring of s. For example: >>> sf = SubstringFinder(\\"eidbaooo\\", [\\"ab\\", \\"eb\\"]) >>> sf.containsPermutation(\\"ab\\") True >>> sf.containsPermutation(\\"ac\\") False >>> sf.containsPermutation(\\"b\\") True pass","solution":"from collections import Counter class SubstringFinder: def __init__(self, s, words): Initializes the object with the string s and the string array words. self.s = s self.words = words self.words_counter = Counter(''.join(words)) def containsPermutation(self, target): Checks if any permutation of target is a substring of s. target_counter = Counter(target) len_t, len_s = len(target), len(self.s) for i in range(len_s - len_t + 1): if target_counter == Counter(self.s[i:i + len_t]): return True return False"},{"question":"def max_non_overlapping_keys(s: str, t: List[str]) -> int: Return the maximum number of keys that can be matched in the string s without overlap. Args: s: A string where keys are to be matched. t: An array of equal-length strings to be matched as keys in s. Returns: The maximum number of non-overlapping keys that can be matched in s. >>> max_non_overlapping_keys(\\"ababab\\", [\\"ab\\", \\"ba\\"]) 3 >>> max_non_overlapping_keys(\\"abababab\\", [\\"ab\\"]) 4 >>> max_non_overlapping_keys(\\"abcabcabc\\", [\\"abc\\"]) 3 >>> max_non_overlapping_keys(\\"abcdef\\", [\\"gh\\"]) 0 >>> max_non_overlapping_keys(\\"abababab\\", [\\"ab\\", \\"abab\\"]) 4 >>> max_non_overlapping_keys(\\"ccc\\", [\\"c\\"]) 3 >>> max_non_overlapping_keys(\\"aaa\\", [\\"aa\\"]) 1","solution":"def max_non_overlapping_keys(s, t): max_keys = 0 substr_lens = len(t[0]) seen_indices = set() for key in t: start = 0 while start <= len(s) - substr_lens: idx = s.find(key, start) if idx == -1: break if all(i not in seen_indices for i in range(idx, idx + substr_lens)): max_keys += 1 seen_indices.update(range(idx, idx + substr_lens)) start = idx + substr_lens else: start = idx + 1 return max_keys"},{"question":"def min_time_to_complete_tasks(s: str, k: int) -> int: Returns the minimum time required to complete all tasks in the given order, including any necessary idle time. :param s: string representing a series of tasks :param k: positive integer representing the cool down period for identical tasks :return: minimum time required to complete all tasks >>> min_time_to_complete_tasks(\\"AAA\\", 0) 3 >>> min_time_to_complete_tasks(\\"AAA\\", 2) 7 >>> min_time_to_complete_tasks(\\"ABCDE\\", 0) 5 >>> min_time_to_complete_tasks(\\"AABACA\\", 2) 10 >>> min_time_to_complete_tasks(\\"A\\", 5) 1 >>> min_time_to_complete_tasks(\\"AA\\", 5) 7","solution":"def min_time_to_complete_tasks(s: str, k: int) -> int: Returns the minimum time required to complete all tasks in the given order, including any necessary idle time. :param s: string representing a series of tasks :param k: positive integer representing the cool down period for identical tasks :return: minimum time required to complete all tasks last_occurrence = {} time = 0 for task in s: if task in last_occurrence and time - last_occurrence[task] <= k: time = last_occurrence[task] + k + 1 else: time += 1 last_occurrence[task] = time return time"},{"question":"def single_number(nums): Find the single integer that appears only once in the list where every other integer appears either twice or three times. Arguments: nums -- a list of integers Returns: The single integer that appears only once. from solution import single_number def test_single_number_with_mixed_appearances(): assert single_number([2, 2, 3, 2]) == 3 assert single_number([0, 1, 0, 1, 0, 1, 99]) == 99 def test_single_number_with_all_duplicates(): assert single_number([4, 4, 4, 5, 5, 5, 7]) == 7 def test_single_number_with_negative_numbers(): assert single_number([-2, -2, -3, -2]) == -3 def test_single_number_with_single_element(): assert single_number([1]) == 1","solution":"def single_number(nums): Find the single integer that appears only once in the list where every other integer appears either twice or three times. Arguments: nums -- a list of integers Returns: The single integer that appears only once. ones, twos = 0, 0 for num in nums: twos |= ones & num ones ^= num common_bits = ~(ones & twos) ones &= common_bits twos &= common_bits return ones"},{"question":"def index_mapping(nums1, nums2): Returns an index mapping array such that the ith element in nums1 appears in nums2 at index j. :param nums1: List[int] - First list of integers :param nums2: List[int] - Second list of integers which is a permutation of nums1 :return: List[int] - Index mapping array >>> index_mapping([12, 28, 46, 32, 50], [50, 12, 32, 46, 28]) [1, 4, 3, 2, 0] >>> index_mapping([5, 3, 1], [5, 3, 1]) [0, 1, 2] >>> index_mapping([1, 2, 3], [3, 2, 1]) [2, 1, 0] >>> index_mapping([42], [42]) [0] >>> index_mapping(list(range(1000)), list(range(999, -1, -1))) list(range(999, -1, -1))","solution":"def index_mapping(nums1, nums2): Returns an index mapping array such that the ith element in nums1 appears in nums2 at index j. :param nums1: List[int] - First list of integers :param nums2: List[int] - Second list of integers which is a permutation of nums1 :return: List[int] - Index mapping array position_map = {num: idx for idx, num in enumerate(nums2)} mapping = [position_map[num] for num in nums1] return mapping"},{"question":"def min_students_to_remove(heights): Returns the minimum number of students that must be removed so that the remaining students are standing in non-decreasing order of height. >>> min_students_to_remove([1, 2, 3, 4, 5]) == 0 >>> min_students_to_remove([5, 3, 4, 2, 1]) == 3 >>> min_students_to_remove([10, 20, 10, 30, 40, 50]) == 1 >>> min_students_to_remove([5, 4, 3, 2, 1]) == 4 >>> min_students_to_remove([1]) == 0 >>> min_students_to_remove([]) == 0 >>> min_students_to_remove([3, 3, 3, 3, 3]) == 0 >>> min_students_to_remove([4, 3, 8, 9, 1, 2, 3, 5]) == 4","solution":"def min_students_to_remove(heights): Returns the minimum number of students that must be removed so that the remaining students are standing in non-decreasing order of height. n = len(heights) # Let's use dynamic programming to find the length of the longest increasing subsequence (LIS) if n == 0: return 0 # DP array to store the length of the longest increasing subsequence ending at each element dp = [1] * n # Every element is an LIS of length 1 by itself # Calculate the length of the LIS for each element for i in range(1, n): for j in range(i): if heights[i] >= heights[j] and dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 # The length of the LIS is the maximum value in the dp array lis_length = max(dp) # The minimum number of students to remove return n - lis_length"},{"question":"def find_kth_element(arr1, arr2, k): Merge two sorted arrays and return the k-th smallest element in the merged sorted array. If k is greater than the total number of elements, return -1. >>> find_kth_element([1, 3, 5], [2, 4, 6, 7], 5) 5 >>> find_kth_element([1, 3, 5], [2, 4, 6, 7], 10) -1 >>> find_kth_element([1, 3, 5], [2, 4, 6, 7], 7) 7 >>> find_kth_element([], [2, 4, 6, 7], 3) 6 >>> find_kth_element([1, 3, 5], [], 2) 3 >>> find_kth_element([], [], 1) -1 >>> find_kth_element([1, 3, 5], [2, 4, 6, 7], 1) 1 >>> find_kth_element([1, 1, 1], [1, 1, 1, 1], 5) 1 >>> find_kth_element([1, 3, 5], [2, 4, 6, 7], 0) -1 >>> find_kth_element([1, 3, 5], [2, 4, 6, 7], -1) -1","solution":"def find_kth_element(arr1, arr2, k): Returns the k-th smallest element in the merged sorted array of arr1 and arr2. If k is greater than the total number of elements, return -1. # Merging the two sorted arrays merged_array = [] i = 0 j = 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Append remaining elements (if any) while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 # Check if k is within the bounds of the array if k > len(merged_array) or k <= 0: return -1 # The k-th element means index k-1 (0-based indexing) return merged_array[k-1]"},{"question":"def is_alien_sorted(words, order): Determines if the given list of words is sorted lexicographically according to the provided alien order. :param words: List of strings representing the words. :param order: String representing the alphabetical order in an alien language. :return: True if the list of words is sorted according to the alien order, False otherwise. >>> is_alien_sorted([\\"hello\\", \\"leetcode\\"], \\"hlabcdefgijkmnopqrstuvwxyz\\") True >>> is_alien_sorted([\\"word\\", \\"world\\", \\"row\\"], \\"worldabcefghijkmnpqstuvxyz\\") False >>> is_alien_sorted([\\"apple\\", \\"app\\"], \\"abcdefghijklmnopqrstuvwxyz\\") False >>> is_alien_sorted([\\"same\\", \\"same\\"], \\"abcdefghijklmnopqrstuvwxyz\\") True >>> is_alien_sorted([], \\"abcdefghijklmnopqrstuvwxyz\\") True >>> is_alien_sorted([\\"single\\"], \\"abcdefghijklmnopqrstuvwxyz\\") True >>> is_alien_sorted([\\"apple\\", \\"apply\\", \\"app\\"], \\"abcdefghijklmnopqrstuvwxyz\\") False","solution":"def is_alien_sorted(words, order): Determines if the given list of words is sorted lexicographically according to the provided alien order. :param words: List of strings representing the words. :param order: String representing the alphabetical order in an alien language. :return: True if the list of words is sorted according to the alien order, False otherwise. order_index = {char: index for index, char in enumerate(order)} def compare_words(word1, word2): for c1, c2 in zip(word1, word2): if order_index[c1] < order_index[c2]: return True elif order_index[c1] > order_index[c2]: return False return len(word1) <= len(word2) for i in range(len(words) - 1): if not compare_words(words[i], words[i + 1]): return False return True"},{"question":"def can_reverse_subarray_to_sum_k(arr: List[int], k: int) -> bool: Returns true if there is a subarray in arr which, when reversed, has a sum equal to k. The subarray must have at least two elements. >>> can_reverse_subarray_to_sum_k([1, 2, 3], 10) False >>> can_reverse_subarray_to_sum_k([1, 2, 3, 4], 5) True >>> can_reverse_subarray_to_sum_k([5, 5], 10) True >>> can_reverse_subarray_to_sum_k([1, 2, 1, 2, 1], 4) True >>> can_reverse_subarray_to_sum_k([], 0) False >>> can_reverse_subarray_to_sum_k([5], 5) False >>> can_reverse_subarray_to_sum_k([-1, -2, -3, -4], -5) True pass","solution":"def can_reverse_subarray_to_sum_k(arr, k): Returns true if there is a subarray in arr which, when reversed, has a sum equal to k. n = len(arr) for i in range(n - 1): subarray_sum = 0 for j in range(i, n): subarray_sum += arr[j] if subarray_sum == k and (j - i + 1) >= 2: return True return False"},{"question":"def max_projects(projects: List[List[int]], d: int) -> int: Returns the maximum number of distinct projects that can be completed within given days. Parameters: projects (List[List[int]]): List of projects where each project is represented as [projectId, deadline] d (int): Total number of available days Returns: int: Maximum number of distinct projects that can be completed","solution":"def max_projects(projects, d): Returns the maximum number of distinct projects that can be completed within given days. Parameters: projects (List[List[int]]): List of projects where each project is represented as [projectId, deadline] d (int): Total number of available days Returns: int: Maximum number of distinct projects that can be completed # Sort the projects by their deadline projects.sort(key=lambda x: x[1]) count = 0 days_used = 0 # Iterate through the sorted projects for project in projects: if days_used < d: count += 1 days_used += 1 else: break return count"},{"question":"def string_addition(s1: str, s2: str) -> str: Given two strings s1 and s2 representing two non-negative integers, return their sum as a string. The input strings may contain leading zeros, and the result should not contain leading zeros unless the result is zero. >>> string_addition(\\"123\\", \\"456\\") '579' >>> string_addition(\\"0012\\", \\"003\\") '15' >>> string_addition(\\"0000\\", \\"0000\\") '0' >>> string_addition(\\"0000\\", \\"001\\") '1' >>> string_addition(\\"070\\", \\"030\\") '100' >>> string_addition(\\"100000000000000000\\", \\"200000000000000000\\") '300000000000000000' >>> string_addition(\\"0\\", \\"0\\") '0' >>> string_addition(\\"0\\", \\"123\\") '123' >>> string_addition(\\"123\\", \\"0\\") '123'","solution":"def string_addition(s1: str, s2: str) -> str: Returns the sum of two non-negative integers represented as strings, without leading zeros. # convert the strings to integers, add them, and then convert the result back to a string result = str(int(s1) + int(s2)) return result"},{"question":"from typing import List def rob(nums: List[int]) -> int: Returns the maximum amount of money you can rob without alerting the police. You cannot rob two directly adjacent houses. >>> rob([]) == 0 >>> rob([5]) == 5 >>> rob([2, 7, 9, 3, 1]) == 12 >>> rob([1, 2, 3, 1]) == 4 >>> rob([2, 1, 1, 2]) == 4 >>> rob([5, 3, 4, 11, 2]) == 16 >>> rob([1, 2, 3, 4, 5]) == 9 >>> rob([4, 4, 4, 4, 4]) == 12 >>> rob([6, 7, 1, 30, 8, 2, 4]) == 41","solution":"def rob(nums): Returns the maximum amount of money you can rob without alerting the police. You cannot rob two directly adjacent houses. if not nums: return 0 if len(nums) == 1: return nums[0] previous = 0 current = 0 for amount in nums: new_current = max(current, previous + amount) previous = current current = new_current return current"},{"question":"from typing import List def pacific_atlantic(matrix: List[List[int]]) -> List[List[int]]: Determine the number of cells that can reach both the Pacific and Atlantic oceans. The Pacific Ocean touches the left and top edges of the matrix, whereas the Atlantic Ocean touches the right and bottom edges. Water can flow from a cell to its neighboring cells with lower or equal height. Args: matrix: List of lists representing the heights of the terrain cells. Returns: A list of coordinates where water can flow to both Pacific and Atlantic oceans. >>> pacific_atlantic([[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]]) [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] >>> pacific_atlantic([[10, 10, 10], [10, 1, 10], [10, 10, 10]]) [[0, 0], [0, 1], [0, 2], [1, 0], [1, 2], [2, 0], [2, 1], [2, 2]] >>> pacific_atlantic([[5]]) [[0, 0]] >>> pacific_atlantic([]) [] >>> pacific_atlantic([[2, 2], [2, 2]]) [[0, 0], [0, 1], [1, 0], [1, 1]] # Your code here","solution":"def pacific_atlantic(matrix): if not matrix: return [] def dfs(matrix, visited, i, j): visited[i][j] = True for di, dj in ((0, 1), (1, 0), (0, -1), (-1, 0)): ni, nj = i + di, j + dj if 0 <= ni < len(matrix) and 0 <= nj < len(matrix[0]) and not visited[ni][nj] and matrix[ni][nj] >= matrix[i][j]: dfs(matrix, visited, ni, nj) m, n = len(matrix), len(matrix[0]) p_visited = [[False] * n for _ in range(m)] a_visited = [[False] * n for _ in range(m)] for i in range(m): dfs(matrix, p_visited, i, 0) dfs(matrix, a_visited, i, n - 1) for j in range(n): dfs(matrix, p_visited, 0, j) dfs(matrix, a_visited, m - 1, j) result = [] for i in range(m): for j in range(n): if p_visited[i][j] and a_visited[i][j]: result.append([i, j]) return result"},{"question":"def findKthNumber(n: int, k: int) -> int: Write a function that takes two integers n and k and returns the k-th integer in lexicographical order among all integers from 1 to n. >>> findKthNumber(13, 2) 10 >>> findKthNumber(100, 10) 17 >>> findKthNumber(50, 1) 1 >>> findKthNumber(19, 19) 9 >>> findKthNumber(9, 4) 4 >>> findKthNumber(10, 10) 9","solution":"def findKthNumber(n, k): def count_steps(curr, n): steps = 0 first = curr last = curr + 1 while first <= n: steps += min(last, n + 1) - first first *= 10 last *= 10 return steps curr = 1 k -= 1 while k: steps = count_steps(curr, n) if steps <= k: k -= steps curr += 1 else: curr *= 10 k -= 1 return curr"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def searchBST(root: TreeNode, val: int) -> TreeNode: Search for a node with the given value in a binary search tree. Args: root (TreeNode): The root node of the BST. val (int): The value to search for. Returns: TreeNode: The node containing the value, or None if the value is not present. pass import pytest from solution import TreeNode, searchBST def test_search_existing_value(): root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(7) root.left.left = TreeNode(1) root.left.right = TreeNode(3) assert searchBST(root, 2) == root.left assert searchBST(root, 3) == root.left.right def test_search_non_existing_value(): root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(7) root.left.left = TreeNode(1) root.left.right = TreeNode(3) assert searchBST(root, 5) == None def test_search_on_empty_tree(): assert searchBST(None, 5) == None def test_search_root_value(): root = TreeNode(4) assert searchBST(root, 4) == root def test_search_leftmost_value(): root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(7) root.left.left = TreeNode(1) root.left.right = TreeNode(3) assert searchBST(root, 1) == root.left.left def test_search_rightmost_value(): root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(7) root.left.left = TreeNode(1) root.left.right = TreeNode(3) assert searchBST(root, 7) == root.right","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def searchBST(root: TreeNode, val: int) -> TreeNode: Search for a node with the given value in a binary search tree. Args: root (TreeNode): The root node of the BST. val (int): The value to search for. Returns: TreeNode: The node containing the value, or None if the value is not present. if not root: return None if root.val == val: return root elif val < root.val: return searchBST(root.left, val) else: return searchBST(root.right, val)"},{"question":"def max_rainfall(nums: List[int], k: int) -> int: Finds the k-length subarray that contains the maximum total rainfall. Returns the maximum total rainfall possible for such a subarray. If the length of nums is less than k, returns 0. >>> max_rainfall([2, 3, 4, 2, 5], 3) == 11 >>> max_rainfall([1, 2], 3) == 0 >>> max_rainfall([7, 2, 8, 1, 5], 1) == 8 >>> max_rainfall([4, 4, 4, 4], 2) == 8 >>> max_rainfall([-1, 4, -2, 5, 3], 2) == 8 >>> max_rainfall([], 3) == 0 >>> max_rainfall([1, 2, 3, 4, 5], 5) == 15","solution":"def max_rainfall(nums, k): Finds the k-length subarray that contains the maximum total rainfall. Returns the maximum total rainfall possible for such a subarray. If the length of nums is less than k, returns 0. if len(nums) < k: return 0 max_sum = current_sum = sum(nums[:k]) for i in range(k, len(nums)): current_sum = current_sum - nums[i - k] + nums[i] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def max_median_sum(arr: List[int]) -> int: Returns the maximum possible sum of the median elements from all contiguous subarrays of length 3. >>> max_median_sum([1, 3, 2, 5, 4]) 4 >>> max_median_sum([1, 2]) 0 >>> max_median_sum([5, 5, 5, 5]) 5 >>> max_median_sum([1, 2, 3, 4, 5]) 4 >>> max_median_sum([5, 4, 3, 2, 1]) 4 >>> max_median_sum([1, 9, 3, 7, 5]) 7","solution":"def max_median_sum(arr): Returns the maximum possible sum of the median elements from all contiguous subarrays of length 3. :param arr: List[int] :return: int n = len(arr) if n < 3: return 0 # There cannot be any subarrays of length 3 if the size of the array is less than 3 max_sum = float('-inf') for i in range(n - 2): # Take the current 3 elements subarray = arr[i:i+3] # Sort the subarray to find the median subarray.sort() # The middle element is the median in a sorted array of length 3 median = subarray[1] # Update the maximum sum if the current median is greater current_sum = median if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def can_form_words(s: str, words: List[str]) -> bool: Determines if all words can be formed using consecutive characters in \`s\` without rearranging the characters. Parameters: s (str): The string consisting of lowercase English letters. words (list): The list of words to be formed from \`s\`. Returns: bool: True if possible to form all the words using substrings of s, otherwise False. >>> can_form_words(\\"abcdefghij\\", [\\"abc\\", \\"def\\"]) == True >>> can_form_words(\\"abcdabcd\\", [\\"abcd\\", \\"abcd\\"]) == True >>> can_form_words(\\"abcdegfh\\", [\\"abc\\", \\"def\\"]) == False >>> can_form_words(\\"abcdef\\", [\\"abc\\", \\"fgh\\"]) == False >>> can_form_words(\\"abcdefghij\\", [\\"abc\\", \\"cde\\"]) == False >>> can_form_words(\\"aabbcc\\", [\\"ab\\", \\"bc\\"]) == True >>> can_form_words(\\"aabbcc\\", [\\"ab\\", \\"cd\\"]) == False >>> can_form_words(\\"\\", [\\"a\\"]) == False >>> can_form_words(\\"abcdefghij\\", []) == True >>> can_form_words(\\"aaaaa\\", [\\"a\\", \\"a\\", \\"a\\"]) == True >>> can_form_words(\\"aabac\\", [\\"a\\", \\"b\\", \\"a\\", \\"c\\"]) == True >>> can_form_words(\\"aabac\\", [\\"a\\", \\"a\\", \\"b\\", \\"c\\"]) == True >>> can_form_words(\\"a\\", [\\"b\\"]) == False","solution":"def can_form_words(s, words): Determines if all words can be formed using consecutive characters in \`s\` without rearranging the characters. Parameters: s (str): The string consisting of lowercase English letters. words (list): The list of words to be formed from \`s\`. Returns: bool: True if possible to form all the words using substrings of s, otherwise False. current_index = 0 for word in words: index = s.find(word, current_index) if index == -1: return False current_index = index + len(word) return True"},{"question":"from typing import List def min_path_sum(matrix: List[List[int]]) -> int: Returns the minimum sum of a path from the top-left corner to the bottom-right corner, moving only down or right. If it's impossible to have a path that ends with a positive value in the bottom-right cell, return -1. >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 True >>> min_path_sum([ ... [1, 2, 3], ... [4, 5, 6] ... ]) == 12 True >>> min_path_sum([ ... [1, -2, 3], ... [2, -3, -1], ... [-1, -2, 5] ... ]) == -1 True >>> min_path_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, -9] ... ]) == -1 True >>> min_path_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 21 True >>> min_path_sum([[5]]) == 5 True >>> min_path_sum([[-1]]) == -1 True","solution":"def min_path_sum(matrix): Returns the minimum sum of a path from the top-left corner to the bottom-right corner, moving only down or right. If it's impossible to have a path that ends with a positive value in the bottom-right cell, return -1. if not matrix or not matrix[0] or matrix[-1][-1] <= 0: return -1 m, n = len(matrix), len(matrix[0]) dp = [[float('inf')] * n for _ in range(m)] dp[0][0] = matrix[0][0] for i in range(m): for j in range(n): if i > 0: dp[i][j] = min(dp[i][j], dp[i-1][j] + matrix[i][j]) if j > 0: dp[i][j] = min(dp[i][j], dp[i][j-1] + matrix[i][j]) result = dp[-1][-1] return result if result > 0 else -1"},{"question":"from typing import List def min_steps_to_spread_info(edges: List[List[int]], start: int) -> int: Returns the minimum number of steps required for information to reach all nodes in the network. If information cannot reach all nodes, returns -1. >>> min_steps_to_spread_info([[0, 1], [0, 2], [1, 2], [2, 3]], 0) == 2 >>> min_steps_to_spread_info([[0, 1], [2, 3]], 0) == -1 >>> min_steps_to_spread_info([], 0) == 0 >>> min_steps_to_spread_info([[0, 1]], 0) == 1 >>> min_steps_to_spread_info([[0, 1], [1, 2], [2, 0], [1, 3]], 0) == 2 >>> min_steps_to_spread_info([[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]], 0) == 5 >>> min_steps_to_spread_info([[i, i+1] for i in range(5)], 0) == 5","solution":"from collections import deque, defaultdict def min_steps_to_spread_info(edges, start): Returns the minimum number of steps required for information to reach all nodes in the network. If information cannot reach all nodes, returns -1. graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = set() queue = deque([(start, 0)]) visited.add(start) max_steps = 0 while queue: node, steps = queue.popleft() max_steps = max(max_steps, steps) for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, steps + 1)) # Check if all nodes are visited all_nodes = set(node for edge in edges for node in edge) all_nodes.add(start) if visited >= all_nodes: return max_steps else: return -1"},{"question":"from typing import List from collections import Counter from heapq import heappop, heappush, heapify def rearrange_string(s: str, k: int) -> str: You are given a string \`s\` consisting of lowercase English letters and an integer \`k\`. Determine if it is possible to rearrange the characters in \`s\` such that every two adjacent characters are different. If it is possible, return the rearranged string, otherwise, return an empty string. The string may have multiple valid rearrangements; return any of them. >>> rearrange_string(\\"aabbcc\\", 2) \\"abacbc\\" # Example output, real output can vary >>> rearrange_string(\\"aaabc\\", 3) \\"\\"","solution":"from collections import Counter from heapq import heappop, heappush, heapify def rearrange_string(s, k): if k == 0: return s # If k is 0, no need to rearrange # Count frequency of each character counter = Counter(s) # Create a max heap (negative count for max heap) max_heap = [(-count, char) for char, count in counter.items()] heapify(max_heap) result = [] wait_queue = [] while max_heap: count, char = heappop(max_heap) result.append(char) wait_queue.append((count + 1, char)) # increment count to mark usage if len(wait_queue) < k: continue # Re-enable the use of character once k distance is passed ready_count, ready_char = wait_queue.pop(0) if ready_count < 0: heappush(max_heap, (ready_count, ready_char)) return \\"\\".join(result) if len(result) == len(s) else \\"\\""},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root: TreeNode) -> int: Given a binary tree, return the sum of the values of its deepest leaves. The deepest leaves are defined as the nodes that are at the maximum depth from the root of the tree. >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> deepestLeavesSum(root) 5 >>> root = None >>> deepestLeavesSum(root) 0 >>> root = TreeNode(1, TreeNode(2, TreeNode(4, TreeNode(7))), TreeNode(3, right=TreeNode(6, right=TreeNode(8)))) >>> deepestLeavesSum(root) 15 >>> root = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4, TreeNode(5))))) >>> deepestLeavesSum(root) 5 >>> root = TreeNode(1, right=TreeNode(2, right=TreeNode(3, right=TreeNode(4, right=TreeNode(5))))) >>> deepestLeavesSum(root) 5","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root): Returns the sum of the values of the deepest leaves in a binary tree. if not root: return 0 from collections import deque max_depth = 0 level_sum = 0 queue = deque([(root, 0)]) while queue: node, depth = queue.popleft() if depth > max_depth: max_depth = depth level_sum = node.val elif depth == max_depth: level_sum += node.val if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return level_sum"},{"question":"def check_distances(s: str, distance: List[int]) -> bool: Checks if the string \`s\` meets all the distance requirements described in the array \`distance\`. >>> check_distances(\\"abac\\", [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == True >>> check_distances(\\"abac\\", [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == False >>> check_distances(\\"abcabc\\", [2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == True >>> check_distances(\\"a\\", [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == True >>> check_distances(\\"abcdefg\\", [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == True","solution":"def check_distances(s, distance): Checks if the string \`s\` meets all the distance requirements described in the array \`distance\`. character_positions = {} for i, char in enumerate(s): if char in character_positions: required_distance = distance[ord(char) - ord('a')] actual_distance = i - character_positions[char] - 1 if actual_distance != required_distance: return False character_positions[char] = i return True"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(nums): Constructs a binary tree from a level order traversal array where -1 indicates null node. Returns the root of the binary tree. >>> build_tree([1, 2, 3, -1, -1, 4, 5]) TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))) >>> build_tree([]) None >>> build_tree([1]) TreeNode(1) >>> build_tree([1, 2, 3, 4, 5, 6, 7]) TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7)))","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(nums): Constructs a binary tree from a level order traversal array where -1 indicates null node. Returns the root of the binary tree. if not nums: return None root = TreeNode(nums[0]) queue = [root] i = 1 while i < len(nums): current = queue.pop(0) if current: if nums[i] != -1: current.left = TreeNode(nums[i]) queue.append(current.left) i += 1 if i < len(nums) and nums[i] != -1: current.right = TreeNode(nums[i]) queue.append(current.right) i += 1 return root"},{"question":"def max_covered_positions(nums: List[int], m: int, length: int) -> int: Returns the maximum number of unique positions that can be covered by m carpets each with length. >>> max_covered_positions([1, 4, 6], 1, 3) 2 >>> max_covered_positions([1, 4, 6], 2, 3) 3 >>> max_covered_positions([1, 2, 3, 4, 5, 6], 2, 2) 4 >>> max_covered_positions([10, 3, 7, 7, 4, 1], 2, 3) 3 >>> max_covered_positions([1, 2, 8, 10], 2, 2) 3 >>> max_covered_positions([3, 1, 5, 6], 3, 2) 4 >>> max_covered_positions([], 2, 3) 0 >>> max_covered_positions([1, 4, 6], 1, 5) 2 >>> max_covered_positions([1, 2, 3], 1, 3) 3 >>> max_covered_positions([1], 1, 10) 1 >>> max_covered_positions([1, 5, 10], 1, 1) 1","solution":"def max_covered_positions(nums, m, length): Returns the maximum number of unique positions that can be covered by m carpets each with length. nums = sorted(set(nums)) # Remove duplicates and sort the positions n = len(nums) # The total number of unique positions after placing \`i\` carpets covering \`len\` each. dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for k in range(1, m + 1): j = i - 1 while j >= 0 and nums[j] >= nums[i - 1] - length + 1: j -= 1 dp[i][k] = max(dp[i - 1][k], dp[j + 1][k - 1] + i - j - 1) return dp[n][m]"},{"question":"def num_rolls_to_target(n: int, target: int) -> int: Compute the number of ways to roll \`n\` six-sided dice so that the sum is exactly \`target\`. >>> num_rolls_to_target(0, 0) 1 >>> num_rolls_to_target(1, 1) 1 >>> num_rolls_to_target(1, 6) 1 >>> num_rolls_to_target(1, 7) 0 >>> num_rolls_to_target(2, 7) 6 >>> num_rolls_to_target(2, 12) 1 >>> num_rolls_to_target(2, 1) 0 >>> num_rolls_to_target(3, 3) 1 >>> num_rolls_to_target(3, 18) 1","solution":"def num_rolls_to_target(n, target): Compute the number of ways to roll \`n\` six-sided dice so that the sum is exactly \`target\`. :param n: Number of dice :param target: Target sum :return: Number of ways to get the target sum with \`n\` dice # Initialize DP table where dp[i][j] represents the number of ways to get sum j with i dice dp = [[0] * (target + 1) for _ in range(n + 1)] # Base case: There's one way to get sum 0 with 0 dice, which is not rolling any dice. dp[0][0] = 1 # Fill DP table for i in range(1, n + 1): for j in range(1, target + 1): for face in range(1, 7): if j - face >= 0: dp[i][j] += dp[i - 1][j - face] return dp[n][target]"},{"question":"import math from typing import List, Tuple def distance(point1: Tuple[int, int], point2: Tuple[int, int]) -> float: Returns the Euclidean distance between two points. return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2) def max_length_line_segment(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Returns the pair of points that form the line segment with the maximum length. Parameters: points (list of tuples): List of n points where each point is represented as a tuple (x, y). Returns: list of tuples: The pair of points that form the line segment with the maximum length. # Your implementation here def test_distance(): assert distance((0, 0), (3, 4)) == ind2: continue dist = distance(points[ind1], points[ind2]) if dist > max_length: max_length = dist point1, point2 = points[ind1], points[ind2] return [point1, point2]","solution":"import math def distance(point1, point2): Returns the Euclidean distance between two points. return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2) def max_length_line_segment(points): Returns the pair of points that form the line segment with the maximum length. Parameters: points (list of tuples): List of n points where each point is represented as a tuple (x, y). Returns: list of tuples: The pair of points that form the line segment with the maximum length. if not points or len(points) < 2: return [] max_length = 0 point1 = point2 = None n = len(points) for i in range(n): for j in range(i + 1, n): dist = distance(points[i], points[j]) if dist > max_length: max_length = dist point1, point2 = points[i], points[j] return [point1, point2]"},{"question":"def calculate(s: str) -> int: Evaluate a basic arithmetic expression string \`s\` that may contain non-negative integers, '+', '-', '*', '/', and empty spaces. The function should respect standard operator precedence and integer division should truncate towards zero. Examples: >>> calculate(\\"3+2\\") 5 >>> calculate(\\"10 - 3\\") 7 >>> calculate(\\"2*3\\") 6 >>> calculate(\\"8/4\\") 2 >>> calculate(\\"3+5 / 2\\") 5 >>> calculate(\\"3+5 - 2\\") 6 >>> calculate(\\" 3 + 2 * 2 \\") 7 >>> calculate(\\" 32 / 8 * 2 \\") 8 >>> calculate(\\"3+2*2-4/2\\") 5 >>> calculate(\\"14-3/2\\") 13","solution":"def calculate(s): This function evaluates a basic arithmetic expression string \`s\` that may contain non-negative integers, '+', '-', '*', '/', and empty spaces. The function respects standard operator precedence and integer division truncates toward zero. :param s: String containing the arithmetic expression :return: Evaluated integer result of the expression def operate(op, b, a): if op == '+': return a + b elif op == '-': return a - b elif op == '*': return a * b elif op == '/': return int(a / b) # Ensure truncation towards zero num = 0 # Current number being processed stack = [] # Stack to keep numbers and intermediate results sign = '+' # Previous operation s = s.replace(' ', '') # Remove spaces for i, char in enumerate(s): if char.isdigit(): num = num * 10 + int(char) if char in '+-*/' or i == len(s) - 1: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign in '*/': top = stack.pop() stack.append(operate(sign, num, top)) sign = char num = 0 return sum(stack)"},{"question":"def longest_unique_substring_length(s: str) -> int: Returns the length of the longest substring with all unique characters. :param s: A string containing only lowercase alphabets :return: An integer representing the length of the longest substring with all unique characters >>> longest_unique_substring_length(\\"\\") == 0 >>> longest_unique_substring_length(\\"abcdef\\") == 6 >>> longest_unique_substring_length(\\"abcabcbb\\") == 3 >>> longest_unique_substring_length(\\"bbbbb\\") == 1 >>> longest_unique_substring_length(\\"pwwkew\\") == 3 >>> longest_unique_substring_length(\\"dvdf\\") == 3 >>> longest_unique_substring_length(\\"abcaabcd\\") == 4 >>> longest_unique_substring_length(\\"a\\") == 1 >>> longest_unique_substring_length(\\"bbbbbbb\\") == 1 >>> longest_unique_substring_length(\\"aab\\") == 2 >>> longest_unique_substring_length(\\"abacabb\\") == 3","solution":"def longest_unique_substring_length(s): Returns the length of the longest substring with all unique characters. :param s: A string containing only lowercase alphabets :return: An integer representing the length of the longest substring with all unique characters max_len = 0 start = 0 char_index_map = {} for end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"def min_days_to_equal_height(heights): Returns the minimum number of days required to make all the buildings the same height if possible. If it is not possible to make all the buildings the same height, returns -1. >>> min_days_to_equal_height([5, 5, 5, 5]) 0 >>> min_days_to_equal_height([5, 7, 9]) 6 >>> min_days_to_equal_height([]) 0 >>> min_days_to_equal_height([1, 2, 3, 4, 5]) 10 >>> min_days_to_equal_height([100, 1000, 10000]) 10800 pass","solution":"def min_days_to_equal_height(heights): Returns the minimum number of days required to make all the buildings the same height if possible. If it is not possible to make all the buildings the same height, returns -1. if not heights: return 0 min_height = min(heights) total_days = sum(height - min_height for height in heights) return total_days"},{"question":"def is_palindrome(s: str) -> bool: Check if the given string s is a palindrome considering only alphanumeric characters and ignoring cases. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\" \\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"1231\\") False >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") True >>> is_palindrome(\\"Random string\\") False >>> is_palindrome(\\"Hello, World!\\") False","solution":"def is_palindrome(s): Check if the given string s is a palindrome considering only alphanumeric characters and ignoring cases. # Sanitize the input string: Remove non-alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the sanitized string is equal to its reverse return filtered_chars == filtered_chars[::-1]"},{"question":"from typing import List def min_jumps_to_end(arr: List[int], jumps: List[int]) -> int: Determine the minimum number of jumps required to reach the last index of the array. >>> min_jumps_to_end([2, 3, 1, 1, 4], [2, 3, 1, 1, 4]) 2 >>> min_jumps_to_end([1], [1]) 0 >>> min_jumps_to_end([1, 2, 1, 0, 4], [1, 2, 1, 0, 4]) -1 >>> min_jumps_to_end([1, 3, 2, 1, 2, 1], [1, 3, 2, 1, 2, 1]) 3 >>> min_jumps_to_end([2, 3, 1, 1, 4], [100, 3, 1, 1, 4]) 1 def test_min_jumps_to_end(): assert min_jumps_to_end([2, 3, 1, 1, 4], [2, 3, 1, 1, 4]) == 2 assert min_jumps_to_end([1], [1]) == 0 assert min_jumps_to_end([1, 2, 1, 0, 4], [1, 2, 1, 0, 4]) == -1 assert min_jumps_to_end([1, 3, 2, 1, 2, 1], [1, 3, 2, 1, 2, 1]) == 3 assert min_jumps_to_end([2, 3, 1, 1, 4], [100, 3, 1, 1, 4]) == 1","solution":"def min_jumps_to_end(arr, jumps): n = len(arr) if n == 0 or jumps[0] == 0: return -1 max_reach = 0 step = 0 end = 0 jumps_count = 0 for i in range(n): if i > max_reach: return -1 max_reach = max(max_reach, i + jumps[i]) if i == end: if i == n - 1: break end = max_reach jumps_count += 1 if end >= n - 1: break return jumps_count if max_reach >= n - 1 else -1"},{"question":"from typing import List def max_water_trapped(heights: List[int]) -> int: Determines the maximum area of water that can be trapped after a rain. Args: heights (List[int]): List of integers representing the heights of blocks. Returns: int: The maximum area of water that can be trapped. >>> max_water_trapped([4, 2, 3, 4]) 12 >>> max_water_trapped([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_water_trapped([5, 4, 3, 2, 1]) 6 pass","solution":"def max_water_trapped(heights): Returns the maximum amount of water that can be trapped between the blocks. if not heights or len(heights) < 2: return 0 left, right = 0, len(heights) - 1 max_area = 0 while left < right: height = min(heights[left], heights[right]) width = right - left current_area = height * width max_area = max(max_area, current_area) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"def reconstruct_sentence(s: str) -> str: Reconstructs the original sentence from the shuffled sentence where each word is concatenated with a number representing its position in the original sentence. Parameters: - s: str, shuffled sentence where each word has a number at the end. Returns: - str, the original sentence without the numbers. Examples: >>> reconstruct_sentence(\\"is2 sentence4 This1 a3\\") \\"This is a sentence\\" >>> reconstruct_sentence(\\"hello1\\") \\"hello\\" >>> reconstruct_sentence(\\"world2 hello1\\") \\"hello world\\" >>> reconstruct_sentence(\\"apple3 red1 delicious2\\") \\"red delicious apple\\" >>> reconstruct_sentence(\\"a4 sentence2 is3 This1\\") \\"This sentence is a\\" >>> reconstruct_sentence(\\"word3 another2 some1\\") \\"some another word\\"","solution":"def reconstruct_sentence(s): Reconstructs the original sentence from the shuffled sentence where each word is concatenated with a number representing its position in the original sentence. Parameters: - s: str, shuffled sentence where each word has a number at the end. Returns: - str, the original sentence without the numbers. words = s.split() sorted_words = [\\"\\" for _ in range(len(words))] for word in words: position = int(word[-1]) - 1 # Get the position index (0-based) sorted_words[position] = word[:-1] # Remove the last character (number) return \\" \\".join(sorted_words)"},{"question":"def find_pair_with_sum(nums: List[int], target: int) -> Optional[Tuple[int, int]]: Returns a tuple of indices (i, j) such that nums[i] + nums[j] == target, or None if no such pair exists. >>> find_pair_with_sum([1, 2, 3, 4], 5) (0, 3) >>> find_pair_with_sum([1, -2, 3, -4, 5], 1) (1, 2) >>> find_pair_with_sum([1, 2, 3, 4], 10) None >>> find_pair_with_sum([], 5) None >>> find_pair_with_sum([1], 2) None >>> find_pair_with_sum([1, 1, 1, 1], 2) (0, 1)","solution":"def find_pair_with_sum(nums, target): Returns a tuple of indices (i, j) such that nums[i] + nums[j] == target, or None if no such pair exists. index_map = {} for i, num in enumerate(nums): diff = target - num if diff in index_map: return (index_map[diff], i) index_map[num] = i return None"},{"question":"def max_length_equal_ones_negones(arr: List[int]) -> int: Given a list of \`n\` integers, each integer being either \`1\` or \`-1\`, determines the maximum length of contiguous subarray with an equal number of \`1\`s and \`-1\`s. >>> max_length_equal_ones_negones([]) == 0 >>> max_length_equal_ones_negones([1, 1, 1]) == 0 >>> max_length_equal_ones_negones([-1, -1, -1]) == 0 >>> max_length_equal_ones_negones([1, -1]) == 2 >>> max_length_equal_ones_negones([1, -1, 1, -1]) == 4 >>> max_length_equal_ones_negones([1, -1, 1, -1, 1]) == 4 >>> max_length_equal_ones_negones([1, -1, 1, 1, -1, -1, 1, -1]) == 8 >>> max_length_equal_ones_negones([1, 1, -1, -1, 1, -1, 1, -1, -1, 1]) == 10 >>> max_length_equal_ones_negones([1, 1, -1, -1, 1, -1, 1]) == 6","solution":"def max_length_equal_ones_negones(arr): Returns the maximum length of contiguous subarray with an equal number of 1s and -1s. if not arr: return 0 # Dictionary to store the first occurrence of cumulative sums sum_dict = {0: -1} max_length, cum_sum = 0, 0 for i, num in enumerate(arr): cum_sum += 1 if num == 1 else -1 if cum_sum in sum_dict: max_length = max(max_length, i - sum_dict[cum_sum]) else: sum_dict[cum_sum] = i return max_length"},{"question":"def countSmoothSubarrays(nums: List[int], k: int) -> int: Return the number of distinct smooth subarrays modulo 10^9 + 7. A smooth subarray has the difference between the maximum and minimum elements in the subarray less than or equal to k. >>> countSmoothSubarrays([1, 2, 3], 1) 5 >>> countSmoothSubarrays([1], 0) 1 >>> countSmoothSubarrays([1, 1, 2], 1) 5 >>> countSmoothSubarrays([4, 2, 3, 1], 5) 10 >>> countSmoothSubarrays([4, 2, 3, 1], 0) 4 from typing import List def test_count_smooth_subarrays_basic(): assert countSmoothSubarrays([1, 2, 3], 1) == 5 def test_count_smooth_subarrays_single_element(): assert countSmoothSubarrays([1], 0) == 1 def test_count_smooth_subarrays_with_duplicates(): assert countSmoothSubarrays([1, 1, 2], 1) == 5 def test_count_smooth_subarrays_large_k(): assert countSmoothSubarrays([4, 2, 3, 1], 5) == 10 def test_count_smooth_subarrays_no_smooth_subarray(): assert countSmoothSubarrays([4, 2, 3, 1], 0) == 4 def test_count_smooth_subarrays_large_input(): nums = list(range(1000)) k = 10 result = countSmoothSubarrays(nums, k) assert result > 0 # should just ensure it finishes and returns a valid integer within MOD.","solution":"def countSmoothSubarrays(nums, k): MOD = 10**9 + 7 n = len(nums) count = 0 distinct_subarrays = set() for i in range(n): min_elem = float('inf') max_elem = float('-inf') current_subarray = [] for j in range(i, n): min_elem = min(min_elem, nums[j]) max_elem = max(max_elem, nums[j]) current_subarray.append(nums[j]) if max_elem - min_elem <= k: distinct_subarrays.add(tuple(current_subarray)) else: break count = len(distinct_subarrays) return count % MOD"},{"question":"from typing import List def count_sentences(sentences: List[str], k: int) -> int: Counts the number of sentences that can be formed with exactly \`k\` unique words. :param sentences: List of strings, each string is a sentence consisting of words separated by spaces :param k: Integer, number of unique words in each generated sentence :return: Integer, count of possible sentences with exactly \`k\` unique words >>> count_sentences([\\"apple banana mango\\", \\"apple grape banana\\", \\"mango grape\\"], 3) 4 >>> count_sentences([\\"cat dog\\", \\"cat mouse dog\\", \\"dog elephant\\"], 2) 6 >>> count_sentences([\\"one two\\", \\"three four\\", \\"five\\"], 6) 0 >>> count_sentences([\\"alpha beta\\", \\"gamma delta\\", \\"epsilon\\"], 5) 1 >>> count_sentences([\\"empty sentence\\", \\"another empty sentence\\"], 0) 1 >>> count_sentences([\\"repeat repeat\\", \\"repeat\\"], 1) 1","solution":"from itertools import combinations def count_sentences(sentences, k): Counts the number of sentences that can be formed with exactly \`k\` unique words. :param sentences: List of strings, each string is a sentence consisting of words separated by spaces :param k: Integer, number of unique words in each generated sentence :return: Integer, count of possible sentences with exactly \`k\` unique words # Extract all unique words from the sentences unique_words = set() for sentence in sentences: unique_words.update(sentence.split()) # Count the number of combinations of these words taken k at a time if k > len(unique_words): return 0 return len(list(combinations(unique_words, k)))"},{"question":"def trap(height: List[int]) -> int: Compute the total amount of trapped water given the heights of the blocks. >>> trap([]) == 0 >>> trap([1, 1, 1, 1]) == 0 >>> trap([0, 1, 2, 3, 4]) == 0 >>> trap([1, 0, 2]) == 1 >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap([4, 2, 0, 3, 2, 5]) == 9 >>> trap([2, 0, 2]) == 2 >>> trap([7, 6, 5, 4, 3, 2, 1]) == 0","solution":"def trap(height): Returns the total amount of trapped water given the heights of the blocks. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def can_be_palindrome_with_k_changes(s: str, k: int) -> bool: Returns True if the string s can be modified to a palindrome with at most k changes, otherwise False. >>> can_be_palindrome_with_k_changes(\\"abcba\\", 1) == True >>> can_be_palindrome_with_k_changes(\\"abccba\\", 1) == True >>> can_be_palindrome_with_k_changes(\\"abccbx\\", 2) == True >>> can_be_palindrome_with_k_changes(\\"abcd\\", 1) == False >>> can_be_palindrome_with_k_changes(\\"abc\\", 0) == False >>> can_be_palindrome_with_k_changes(\\"a\\", 0) == True >>> can_be_palindrome_with_k_changes(\\"aa\\", 0) == True >>> can_be_palindrome_with_k_changes(\\"aba\\", 0) == True >>> can_be_palindrome_with_k_changes(\\"\\", 0) == True >>> can_be_palindrome_with_k_changes(\\"a\\", 0) == True >>> can_be_palindrome_with_k_changes(\\"ab\\", 1) == True >>> can_be_palindrome_with_k_changes(\\"ab\\", 0) == False >>> can_be_palindrome_with_k_changes(\\"abcdefg\\", 3) == True >>> can_be_palindrome_with_k_changes(\\"abcdefg\\", 2) == False","solution":"def can_be_palindrome_with_k_changes(s, k): Returns True if the string s can be modified to a palindrome with at most k changes, otherwise False. n = len(s) left = 0 right = n - 1 changes_needed = 0 # Count the number of changes required to make the string a palindrome while left < right: if s[left] != s[right]: changes_needed += 1 left += 1 right -= 1 # If the number of changes needed is less than or equal to k, return True return changes_needed <= k"},{"question":"def longest_bitonic_subsequence(nums: List[int]) -> int: You are given a list of integers nums representing a sequence of elements. Your task is to find the longest subsequence that is bitonic. A subsequence is considered bitonic if it is initially monotonically increasing and then monotonically decreasing. A purely increasing or purely decreasing subsequence is also considered bitonic. Return the length of the longest bitonic subsequence. >>> longest_bitonic_subsequence([]) == 0 >>> longest_bitonic_subsequence([1]) == 1 >>> longest_bitonic_subsequence([1, 2]) == 2 >>> longest_bitonic_subsequence([2, 1]) == 2 >>> longest_bitonic_subsequence([1, 2, 3, 4, 3, 2, 1]) == 7 >>> longest_bitonic_subsequence([1, 3, 5, 7, 8, 6, 4, 2]) == 8 >>> longest_bitonic_subsequence([2, 3, 4, 5, 6]) == 5 >>> longest_bitonic_subsequence([1, 11, 2, 10, 4, 5, 2, 1]) == 6","solution":"def longest_bitonic_subsequence(nums): if not nums: return 0 n = len(nums) # Increasing subsequence length ending at each index increase_seq = [1] * n for i in range(1, n): for j in range(i): if nums[i] > nums[j]: increase_seq[i] = max(increase_seq[i], increase_seq[j] + 1) # Decreasing subsequence length starting from each index decrease_seq = [1] * n for i in range(n-2, -1, -1): for j in range(i+1, n): if nums[i] > nums[j]: decrease_seq[i] = max(decrease_seq[i], decrease_seq[j] + 1) # Combine the results of increasing and decreasing subsequences max_length = 0 for i in range(n): max_length = max(max_length, increase_seq[i] + decrease_seq[i] - 1) return max_length"},{"question":"import heapq from collections import Counter from typing import List def rearrange_string(s: str, d: int) -> str: Rearranges the string such that the same characters are at least distance d from each other. Returns an empty string if not possible. >>> rearrange_string(\\"aabb\\", 2) in [\\"abab\\", \\"baba\\"] True >>> rearrange_string(\\"aaabc\\", 1) 'aaabc' >>> rearrange_string(\\"aaabc\\", 3) '' >>> rearrange_string(\\"a\\", 2) 'a' >>> rearrange_string(\\"\\", 2) '' >>> rearrange_string(\\"aabb\\", 0) 'aabb' >>> rearrange_string(\\"abcdef\\", 2) 'abcdef' >>> rearrange_string(\\"aaabbbccc\\", 3) in [\\"abcabcabc\\", \\"acbacbacb\\"] True","solution":"from collections import Counter import heapq def rearrange_string(s, d): Rearranges the string such that the same characters are at least distance d from each other. Returns an empty string if not possible. if d == 0: return s counter = Counter(s) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) result = [] wait_queue = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) wait_queue.append((count+1, char)) if len(wait_queue) < d: continue next_count, next_char = wait_queue.pop(0) if next_count < 0: heapq.heappush(max_heap, (next_count, next_char)) return ''.join(result) if len(result) == len(s) else \\"\\""},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def range_sum_bst(root, L, R): Returns the sum of all nodes with a value between L and R (inclusive) in a binary search tree. import pytest from solution import TreeNode, range_sum_bst def test_range_sum_bst_all_within_range(): root = TreeNode(10, TreeNode(5, TreeNode(3), TreeNode(7)), TreeNode(15, None, TreeNode(18))) assert range_sum_bst(root, 7, 15) == 32 def test_range_sum_bst_lower_bound(): root = TreeNode(10, TreeNode(5, TreeNode(3), TreeNode(7)), TreeNode(15, None, TreeNode(18))) assert range_sum_bst(root, 5, 10) == 22 def test_range_sum_bst_upper_bound(): root = TreeNode(10, TreeNode(5, TreeNode(3), TreeNode(7)), TreeNode(15, None, TreeNode(18))) assert range_sum_bst(root, 15, 20) == 33 def test_range_sum_bst_range_covers_all(): root = TreeNode(10, TreeNode(5, TreeNode(3), TreeNode(7)), TreeNode(15, None, TreeNode(18))) assert range_sum_bst(root, 0, 20) == 58 def test_range_sum_bst_empty_tree(): assert range_sum_bst(None, 1, 10) == 0 def test_range_sum_bst_no_nodes_within_range(): root = TreeNode(10, TreeNode(5, TreeNode(3), TreeNode(7)), TreeNode(15, None, TreeNode(18))) assert range_sum_bst(root, 1, 2) == 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def range_sum_bst(root, L, R): Returns the sum of all nodes with a value between L and R (inclusive) in a binary search tree. if not root: return 0 sum = 0 if L <= root.val <= R: sum += root.val if root.val > L: sum += range_sum_bst(root.left, L, R) if root.val < R: sum += range_sum_bst(root.right, L, R) return sum"},{"question":"def min_changes_to_avoid_consecutive(s: str) -> int: Returns the minimum number of changes required to eliminate consecutive identical characters in the string \`s\`. >>> min_changes_to_avoid_consecutive(\\"ABABAB\\") == 0 >>> min_changes_to_avoid_consecutive(\\"AAAA\\") == 2 >>> min_changes_to_avoid_consecutive(\\"BBBB\\") == 2 >>> min_changes_to_avoid_consecutive(\\"AABB\\") == 2 >>> min_changes_to_avoid_consecutive(\\"BBAA\\") == 2 >>> min_changes_to_avoid_consecutive(\\"A\\") == 0 >>> min_changes_to_avoid_consecutive(\\"B\\") == 0 >>> min_changes_to_avoid_consecutive(\\"AAAABBBB\\") == 4 >>> min_changes_to_avoid_consecutive(\\"ABABABABB\\") == 1 >>> min_changes_to_avoid_consecutive(\\"\\") == 0","solution":"def min_changes_to_avoid_consecutive(s): Returns the minimum number of changes required to eliminate consecutive identical characters in the string \`s\`. n = len(s) if n < 2: return 0 changes = 0 for i in range(1, n): if s[i] == s[i-1]: changes += 1 s = s[:i] + ('B' if s[i] == 'A' else 'A') + s[i+1:] return changes"},{"question":"def num_of_qualifying_subarrays(scores: List[int], k: int, threshold: int) -> int: Returns the number of qualifying subarrays in the array scores. A subarray is considered qualifying if its length is exactly k and the average of its scores is greater than or equal to threshold. >>> num_of_qualifying_subarrays([1, 2, 3, 4], 3, 4) == 0 >>> num_of_qualifying_subarrays([5, 5, 5, 5], 2, 5) == 3 >>> num_of_qualifying_subarrays([1, 2, 3, 4, 5, 6], 3, 3) == 3 >>> num_of_qualifying_subarrays([5, 1, 2, 3, 5], 1, 4) == 2 >>> num_of_qualifying_subarrays([2, 3, 4, 1, 5, 6, 2, 8, 9], 4, 5) == 2 >>> num_of_qualifying_subarrays([], 3, 3) == 0 pass","solution":"def num_of_qualifying_subarrays(scores, k, threshold): Returns the number of qualifying subarrays in the array scores. n = len(scores) qualifying_count = 0 threshold_sum = k * threshold current_sum = sum(scores[:k]) if current_sum >= threshold_sum: qualifying_count += 1 for i in range(k, n): current_sum += scores[i] - scores[i - k] if current_sum >= threshold_sum: qualifying_count += 1 return qualifying_count"},{"question":"def max_apples(grid): Return the maximum number of apples the robot can collect while moving only down or right. >>> max_apples([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 29 >>> max_apples([[1, 2, 3, 4]]) 10 >>> max_apples([[1], [2], [3], [4]]) 10 >>> max_apples([[5]]) 5 >>> max_apples([]) 0 >>> max_apples([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0","solution":"def max_apples(grid): Return the maximum number of apples the robot can collect while moving only down or right. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a dp table to store the maximum apples collected till each cell dp = [[0] * n for _ in range(m)] # Initialize the starting position dp[0][0] = grid[0][0] # Fill in the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill in the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[m - 1][n - 1]"},{"question":"def isMatch(s: str, p: str) -> bool: Returns true if the input string s matches the pattern p. '?' matches any single character. '*' matches any sequence of characters (including an empty sequence). >>> isMatch(\\"abc\\", \\"abc\\") True >>> isMatch(\\"abc\\", \\"a?c\\") True >>> isMatch(\\"abc\\", \\"a*a\\") False >>> isMatch(\\"abc\\", \\"a*c\\") True >>> isMatch(\\"abc\\", \\"*b*\\") True >>> isMatch(\\"abc\\", \\"*\\") True >>> isMatch(\\"abc\\", \\"a*b*c\\") True >>> isMatch(\\"abc\\", \\"a**b**c**\\") True >>> isMatch(\\"abc\\", \\"a*bd*c\\") False >>> isMatch(\\"abcd\\", \\"a*d\\") True >>> isMatch(\\"abcd\\", \\"a*?d\\") True >>> isMatch(\\"abcd\\", \\"a*c?d\\") False >>> isMatch(\\"abcde\\", \\"a?*c*?e\\") True >>> isMatch(\\"\\", \\"\\") True >>> isMatch(\\"\\", \\"*\\") True >>> isMatch(\\"\\", \\"a\\") False","solution":"def isMatch(s, p): Returns true if the input string s matches the pattern p. '?' matches any single character. '*' matches any sequence of characters (including an empty sequence). # Initialize the DP table dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True # Handle patterns with '*' at the beginning for j in range(1, len(p) + 1): if p[j - 1] == '*': dp[0][j] = dp[0][j - 1] # Fill the table for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == '*': dp[i][j] = dp[i - 1][j] or dp[i][j - 1] elif p[j - 1] == '?' or s[i - 1] == p[j - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[len(s)][len(p)]"},{"question":"from typing import List def max_operations(nums: List[int], k: int) -> int: You are given an integer array \`nums\` and an integer \`k\`. An operation involves picking two indices \`i\` and \`j\` such that \`i < j\` and \`nums[i] + nums[j]\` is divisible by \`k\`, then removing the corresponding elements \`nums[i]\` and \`nums[j]\`. Return the maximum number of operations you can perform on the array. >>> max_operations([1, 2, 3, 4], 5) 2 >>> max_operations([3, 1, 3, 4, 3], 6) 1 >>> max_operations([], 5) 0 >>> max_operations([2, 2, 2, 2], 4) 2 >>> max_operations([1, 1, 1, 1], 3) 0 >>> max_operations([1, 3, 5, 7], 2) 0 >>> max_operations([2, 4, 6, 8], 6) 1 >>> max_operations([5, 3, 7, 1, 9], 10) 2","solution":"def max_operations(nums, k): from collections import Counter count = Counter(nums) operations = 0 for num in list(count.keys()): target = k - num if target in count: if num == target: operations += count[num] // 2 else: min_count = min(count[num], count[target]) operations += min_count count[num] -= min_count count[target] -= min_count return operations"},{"question":"from typing import List def min_remaining_sum(nums: List[int], x: int) -> int: Return the minimum sum of the remaining elements after performing exactly x operations, where in each operation you can remove either the leftmost or rightmost element of the array \`nums\`. Return -1 if it is not possible to remove exactly x elements. >>> min_remaining_sum([1, 2, 3, 4, 5], 1) 10 >>> min_remaining_sum([1, 2, 3, 4, 5], 2) 6 >>> min_remaining_sum([1, 2, 3, 4, 5], 3) 3 >>> min_remaining_sum([1], 1) 0 >>> min_remaining_sum([1, 2], 3) -1 >>> min_remaining_sum([], 1) -1 >>> min_remaining_sum([10, 10, 10, 10], 2) 20","solution":"def min_remaining_sum(nums, x): n = len(nums) if x > n: return -1 # Calculate the initial sum of the array total_sum = sum(nums) # Calculate the sum of the first x elements left_sum = sum(nums[:x]) min_sum = total_sum - left_sum # Calculate the sum of the last x elements right_sum = 0 for i in range(x): left_sum -= nums[x-i-1] right_sum += nums[n-i-1] min_sum = min(min_sum, total_sum - left_sum - right_sum) return min_sum"},{"question":"from typing import List def add_operators(num: str, target: int) -> List[str]: Given a string \`num\` that contains only digits '0' through '9' and a target value \`target\`, return all possible ways to add the binary operators \`'+'\`, \`'-'\`, or \`'*'\` between the digits of \`num\` so that the resultant expression evaluates to the \`target\` value. >>> add_operators(\\"123\\", 6) [\\"1+2+3\\", \\"1*2*3\\"] >>> add_operators(\\"232\\", 8) [\\"2*3+2\\", \\"2+3*2\\"] >>> add_operators(\\"105\\", 5) [\\"1*0+5\\", \\"10-5\\"] >>> add_operators(\\"00\\", 0) [\\"0+0\\", \\"0-0\\", \\"0*0\\"] >>> add_operators(\\"3456237490\\", 9191) []","solution":"def add_operators(num, target): def backtrack(index, path, value, last): if index == len(num): if value == target: results.append(path) return for i in range(index, len(num)): if i != index and num[index] == '0': # skip leading zeroes break current_str = num[index:i + 1] current_num = int(current_str) if index == 0: backtrack(i + 1, current_str, current_num, current_num) else: backtrack(i + 1, path + \\"+\\" + current_str, value + current_num, current_num) backtrack(i + 1, path + \\"-\\" + current_str, value - current_num, -current_num) backtrack(i + 1, path + \\"*\\" + current_str, value - last + last * current_num, last * current_num) results = [] backtrack(0, \\"\\", 0, 0) return results"},{"question":"from collections import Counter def min_swaps_to_equal(s1: str, s2: str) -> int: Check if s1 can be converted to s2 by swapping characters and determine the minimum number of swaps required. If not possible, return -1. >>> min_swaps_to_equal(\\"abcd\\", \\"dcba\\") == 2 >>> min_swaps_to_equal(\\"abcd\\", \\"abdc\\") == 1 >>> min_swaps_to_equal(\\"abcd\\", \\"abce\\") == -1 >>> min_swaps_to_equal(\\"abcd\\", \\"abcc\\") == -1 >>> min_swaps_to_equal(\\"abcd\\", \\"abcd\\") == 0 >>> min_swaps_to_equal(\\"abcd\\", \\"abcde\\") == -1 >>> min_swaps_to_equal(\\"aabbccdd\\", \\"ddccbbaa\\") == 4 >>> min_swaps_to_equal(\\"a\\" * 100000, \\"a\\" * 100000) == 0","solution":"from collections import Counter def min_swaps_to_equal(s1, s2): Check if s1 can be converted to s2 by swapping characters and determine the minimum number of swaps required. If not possible, return -1. if len(s1) != len(s2): return -1 if Counter(s1) != Counter(s2): return -1 # Character frequency match, proceed with Minimum Swaps calculation swaps = 0 s1_list = list(s1) for i in range(len(s1)): if s1_list[i] != s2[i]: # Find correct character from the remaining part of the list for j in range(i + 1, len(s1)): if s1_list[j] == s2[i]: s1_list[i], s1_list[j] = s1_list[j], s1_list[i] swaps += 1 break return swaps"},{"question":"def can_form_target(words: List[str], target: str) -> bool: Determines if the target string can be formed by concatenating any permutation of strings in the words list. A word may be used multiple times. >>> can_form_target([\\"ab\\", \\"bc\\", \\"cd\\"], \\"abcd\\") True >>> can_form_target([\\"ab\\", \\"bc\\", \\"cd\\"], \\"ababc\\") False >>> can_form_target([\\"a\\", \\"b\\", \\"c\\", \\"d\\"], \\"abcd\\") True >>> can_form_target([\\"a\\", \\"a\\", \\"b\\", \\"b\\"], \\"aab\\") True >>> can_form_target([\\"a\\", \\"b\\"], \\"abcd\\") False >>> can_form_target([\\"ab\\", \\"c\\"], \\"abc\\") True >>> can_form_target([\\"a\\", \\"aa\\", \\"aaa\\"], \\"aaaaa\\") True >>> can_form_target([\\"a\\", \\"aa\\", \\"aaa\\"], \\"aaaaaaa\\") False >>> can_form_target([], \\"target\\") False >>> can_form_target([\\"\\"], \\"target\\") False >>> can_form_target([\\"a\\", \\"aa\\", \\"aaa\\"], \\"\\") True >>> can_form_target([\\"target\\"], \\"target\\") True >>> can_form_target([\\"tar\\", \\"get\\"], \\"target\\") True","solution":"def can_form_target(words, target): Determines if the target string can be formed by concatenating any permutation of strings in the words list. A word may be used multiple times. Args: words (list of str): List of strings. target (str): The target string to form. Returns: bool: True if the target can be formed, False otherwise. from collections import Counter def can_form_recursively(tgt, counter): if tgt == \\"\\": return True for word in counter: if tgt.startswith(word) and counter[word] > 0: counter[word] -= 1 if can_form_recursively(tgt[len(word):], counter): return True counter[word] += 1 return False word_counter = Counter(words) return can_form_recursively(target, word_counter)"},{"question":"class UniversityRecords: Manage university records of students' scores in various courses. Methods: - addScore(course, score): Adds a student's score to the specified course. - getAverageScore(course): Returns the average score of the specified course. - getCoursesAboveThreshold(threshold): Returns a list of course names with average scores above the specified threshold. >>> ur = UniversityRecords() >>> ur.addScore(\\"Math\\", 90) >>> ur.addScore(\\"Math\\", 80) >>> ur.getAverageScore(\\"Math\\") 85.0 >>> ur.getCoursesAboveThreshold(80) ['Math'] def __init__(self): # Initialize the records dictionary pass def addScore(self, course, score): # Add the score to the course's list of scores pass def getAverageScore(self, course): # Return the average score of the specified course pass def getCoursesAboveThreshold(self, threshold): # Return a list of courses with an average score above the threshold pass","solution":"class UniversityRecords: def __init__(self): # Initialize the records dictionary self.records = {} def addScore(self, course, score): # Add the score to the course's list of scores if course not in self.records: self.records[course] = [] self.records[course].append(score) def getAverageScore(self, course): # Return the average score of the specified course if course not in self.records or len(self.records[course]) == 0: return 0 return sum(self.records[course]) / len(self.records[course]) def getCoursesAboveThreshold(self, threshold): # Return a list of courses with an average score above the threshold result = [] for course in self.records: if len(self.records[course]) > 0 and self.getAverageScore(course) > threshold: result.append(course) return result"},{"question":"def max_money(days: List[int]) -> int: Returns the maximum money that can be earned within given conditions. Args: days (list): List of integers where each value represents money you can earn on that day. Returns: int: Maximum amount of money that can be earned. >>> max_money([0, 0, 0, 0, 0]) == 0 >>> max_money([50]) == 50 >>> max_money([50, 100]) == 100 >>> max_money([50, 10, 50, 10, 50]) == 150 >>> max_money([10, 20, 30, 40, 50]) == 90 >>> max_money([50, 40, 30, 20, 10]) == 90 >>> max_money([3, 2, 5, 10, 7]) == 15 >>> max_money([1]*1000) == 500 >>> max_money([]) == 0","solution":"def max_money(days): Returns the maximum money that can be earned within given conditions. Args: days (list): List of integers where each value represents money you can earn on that day. Returns: int: Maximum amount of money that can be earned. if not days: return 0 n = len(days) if n == 1: return days[0] dp = [0] * n dp[0] = days[0] if n >= 2: dp[1] = max(days[0], days[1]) for i in range(2, n): dp[i] = max(dp[i-1], days[i] + dp[i-2]) return dp[-1] # Example usage: # days = [3, 2, 5, 10, 7] # Output would be 15, because the optimal days to work are days 1, 3, and 5."},{"question":"def can_add_building(heights: List[int], newHeight: int) -> bool: Determines if a new building of \`newHeight\` can be added to the skyline without disrupting the silhouette. :param heights: List[int] - List of building heights. :param newHeight: int - Height of the new building to be added. :return: bool - True if the building can be added without disrupting the silhouette, False otherwise. >>> can_add_building([], 5) True >>> can_add_building([3, 3, 3], 3) True >>> can_add_building([1, 2, 3], 1) True >>> can_add_building([1, 2, 3], 3) True >>> can_add_building([1, 2, 2, 3], 2) True >>> can_add_building([4, 1, 1, 5], 1) True >>> can_add_building([1, 2, 3, 4], 2) False >>> can_add_building([1, 2, 3], 4) False >>> can_add_building([1, 3, 5], 2) False >>> can_add_building([2, 2, 2, 2, 2], 2) True >>> can_add_building([2, 2, 3, 3, 2, 2], 3) True >>> can_add_building([2, 3, 3, 3, 2], 3) True >>> can_add_building([2, 2, 2, 2, 3, 3, 3, 2, 2, 2, 2], 3) True","solution":"def can_add_building(heights, newHeight): Determines if a new building of \`newHeight\` can be added to the skyline without disrupting the silhouette. :param heights: List[int] - List of building heights. :param newHeight: int - Height of the new building to be added. :return: bool - True if the building can be added without disrupting the silhouette, False otherwise. n = len(heights) # Check if can place the new building at the start or end to maintain silhouette if (n == 0) or (newHeight == heights[0]) or (newHeight == heights[-1]): return True # Check for placing the new building between two heights of the same value for i in range(1, n): if heights[i] == newHeight and heights[i-1] == newHeight: return True return False"},{"question":"def max_distance(heights: List[int]) -> int: Returns the maximum distance the ball can travel when placed on any building. >>> max_distance([3, 2, 1]) == 3 >>> max_distance([1, 2, 3]) == 1 >>> max_distance([3, 1, 4, 2]) == 2 >>> max_distance([5]) == 1 >>> max_distance([10, 9, 8, 7]) == 4 >>> max_distance([2, 2, 2]) == 1 >>> max_distance([3, 1, 5, 1, 4, 1]) == 2","solution":"def max_distance(heights): Returns the maximum distance the ball can travel when placed on any building. max_dist = 1 # At least one building is always there for i in range(len(heights)): dist = 1 for j in range(i + 1, len(heights)): if heights[j] < heights[j - 1]: dist += 1 else: break max_dist = max(max_dist, dist) return max_dist"},{"question":"def lexicographically_smallest_string(s: str) -> str: Determine the lexicographically smallest string that can be obtained after performing any number of operations where any character can be moved to the end. >>> lexicographically_smallest_string(\\"cba\\") \\"abc\\" >>> lexicographically_smallest_string(\\"baaca\\") \\"aaabc\\" >>> lexicographically_smallest_string(\\"abc\\") \\"abc\\" >>> lexicographically_smallest_string(\\"zxy\\") \\"xyz\\" >>> lexicographically_smallest_string(\\"a\\") \\"a\\" >>> lexicographically_smallest_string(\\"\\") \\"\\" >>> lexicographically_smallest_string(\\"bbaaa\\") \\"aaabb\\" >>> lexicographically_smallest_string(\\"bbbaaaccc\\") \\"aaabbbccc\\"","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be obtained by performing operations where any character can be moved to the end. # We create a sorted list of characters from the string sorted_chars = sorted(s) # We join the sorted characters back into a string return ''.join(sorted_chars)"},{"question":"def check_possibility(arr: List[int]) -> bool: Determines if by changing at most one element in the array, it can be made non-decreasing. A non-decreasing array is an array where arr[i] <= arr[i + 1] for every 0 <= i < n - 1. >>> check_possibility([1, 1, 1, 1]) True >>> check_possibility([1, 2, 3, 4]) True >>> check_possibility([4, 2, 3]) True >>> check_possibility([4, 2, 1]) False >>> check_possibility([3, 4, 2, 3]) False >>> check_possibility([1, 5, 4, 6, 7, 10]) True >>> check_possibility([3, 1, 2, 3]) True >>> check_possibility([]) True >>> check_possibility([1]) True >>> check_possibility([1, 0]) True","solution":"def check_possibility(arr): n = len(arr) if n <= 1: return True count = 0 for i in range(1, n): if arr[i] < arr[i - 1]: if count == 1: return False count += 1 if i == 1 or arr[i] >= arr[i - 2]: arr[i - 1] = arr[i] else: arr[i] = arr[i - 1] return count <= 1"},{"question":"from collections import defaultdict from typing import List def group_anagrams(strs: List[str]) -> List[List[str]]: Given a list of 'n' strings, group the anagrams together. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. For example, the words 'listen' and 'silent' are anagrams of each other, as are 'elbow' and 'below'. Parameters: strs (list): List of strings. Returns: list: A list of lists of strings, where each sublist contains anagrams. Example: >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] anagrams = defaultdict(list) for word in strs: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values()) def test_group_anagrams_example(): assert group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) == [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] def test_group_anagrams_empty_input(): assert group_anagrams([]) == [] def test_group_anagrams_no_anagrams(): assert group_anagrams([\\"abc\\", \\"def\\", \\"ghi\\"]) == [[\\"abc\\"], [\\"def\\"], [\\"ghi\\"]] def test_group_anagrams_single_word(): assert group_anagrams([\\"word\\"]) == [[\\"word\\"]] def test_group_anagrams_all_anagrams(): assert group_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\"]) == [[\\"listen\\", \\"silent\\", \\"enlist\\"]]","solution":"from collections import defaultdict def group_anagrams(strs): Groups anagrams together from the input list of strings. Parameters: strs (list): List of strings. Returns: list: A list of lists of strings, where each sublist contains anagrams. anagrams = defaultdict(list) for word in strs: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"def shortestUniqueSubsequence(s: str) -> str: Given a string \`s\` which consists of lowercase letters, create a new string \`t\` such that each character in \`t\` appears exactly once and the length of \`t\` is as short as possible. The relative order of characters in \`s\` should be preserved in \`t\`. >>> shortestUniqueSubsequence('aabcc') 'abc' >>> shortestUniqueSubsequence('abc') 'abc' >>> shortestUniqueSubsequence('aaaa') 'a' >>> shortestUniqueSubsequence('') '' >>> shortestUniqueSubsequence('abacb') 'abc' >>> shortestUniqueSubsequence('bcabc') 'bca' >>> shortestUniqueSubsequence('cbacdcbc') 'cbad'","solution":"def shortestUniqueSubsequence(s): Returns the shortest unique subsequence of s with each character appearing exactly once while preserving the relative order of characters in s. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"def getMaxHeight(grid): Given a 2D grid representing heights, calculate the maximum height the ball can have at its stopping point in the last row of the grid. Parameters: grid (list of list of int): A 2D list with integer heights. Returns: int: The maximum height in the last row the ball can achieve following the rules. from solution import getMaxHeight def test_getMaxHeight_single_cell(): grid = [[1]] assert getMaxHeight(grid) == 1 def test_getMaxHeight_row(): grid = [[1, 2, 3]] assert getMaxHeight(grid) == 3 def test_getMaxHeight_col(): grid = [ [1], [2], [3] ] assert getMaxHeight(grid) == 3 def test_getMaxHeight_multiple_rows(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert getMaxHeight(grid) == 9 def test_getMaxHeight_decreasing_columns(): grid = [ [3, 2, 1], [2, 1, 0], [1, 0, 0] ] assert getMaxHeight(grid) == 3 def test_getMaxHeight_mixed(): grid = [ [1, 2, 3, 4], [4, 3, 2, 1], [1, 2, 4, 3], [4, 2, 1, 3] ] assert getMaxHeight(grid) == 4 def test_getMaxHeight_invalid(): grid = [[]] assert getMaxHeight(grid) == 0","solution":"def getMaxHeight(grid): Given a 2D grid representing heights, calculate the maximum height the ball can have at its stopping point in the last row of the grid. Parameters: grid (list of list of int): A 2D list with integer heights. Returns: int: The maximum height in the last row the ball can achieve following the rules. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize DP table with the first row heights dp = grid[0] # Process each row from the second to the last for i in range(1, m): new_dp = [0] * n for j in range(n): # Start with a large negative value since we are looking for max max_height = float('-inf') # Check top if dp[j] >= grid[i][j]: max_height = max(max_height, dp[j]) # Check top-left if within bounds if j > 0 and dp[j-1] >= grid[i][j]: max_height = max(max_height, dp[j-1]) # Check top-right if within bounds if j < n-1 and dp[j+1] >= grid[i][j]: max_height = max(max_height, dp[j+1]) new_dp[j] = max_height if max_height != float('-inf') else grid[i][j] dp = new_dp return max(dp)"},{"question":"def isPathExist(grid: List[List[int]]) -> bool: This function checks if there is a path from the top-left corner to the bottom-right corner in a maze represented by a 2D grid, where 0 signifies an empty cell and 1 signifies a wall. >>> isPathExist([[0, 0, 1], [1, 0, 1], [1, 0, 0]]) True >>> isPathExist([[0, 1], [1, 0]]) False >>> isPathExist([[0]]) True >>> isPathExist([[1]]) False >>> isPathExist([[0, 0, 0, 0, 1], [1, 1, 1, 0, 1], [0, 0, 0, 0, 1], [0, 1, 1, 1, 1], [0, 0, 0, 0, 0]]) True >>> isPathExist([[0, 1, 0, 0, 1], [1, 1, 1, 0, 1], [0, 0, 0, 1, 1], [0, 1, 1, 1, 1], [0, 0, 0, 0, 0]]) False","solution":"from collections import deque def isPathExist(grid): This function checks if there is a path from the top-left corner to the bottom-right corner in a maze represented by a 2D grid. Parameters: grid (list of list of int): The 2D grid representing the maze, where 0 signifies an empty cell and 1 signifies a wall. Returns: bool: Returns True if there is a path from [0][0] to [m-1][n-1], else False. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return False m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) grid[0][0] = 1 # Mark as visited while queue: x, y = queue.popleft() if x == m - 1 and y == n - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0: queue.append((nx, ny)) grid[nx][ny] = 1 # Mark as visited return False"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def construct_tree(nums): Construct a binary tree from a list of integers representing a level-order traversal where -1 represents a null node. >>> nums = [1] >>> root = construct_tree(nums) >>> root.val == 1 True >>> root.left is None True >>> root.right is None True >>> nums = [1, 2, 3, 4, 5, -1, 7] >>> root = construct_tree(nums) >>> root.val == 1 True >>> root.left.val == 2 True >>> root.right.val == 3 True >>> root.left.left.val == 4 True >>> root.left.right.val == 5 True >>> root.right.left is None True >>> root.right.right.val == 7 True def deepest_leaves_sum(root): Calculate the sum of all the values of the deepest leaves in the binary tree. >>> nums = [1, 2, 3, 4, 5, -1, 7] >>> root = construct_tree(nums) >>> deepest_leaves_sum(root) 16 # The deepest leaves are 4, 5, and 7 >>> nums = [1] >>> root = construct_tree(nums) >>> deepest_leaves_sum(root) 1 >>> nums = [] >>> root = construct_tree(nums) >>> deepest_leaves_sum(root) 0 >>> nums = [1, 2, 3, -1, -1, 4, 5] >>> root = construct_tree(nums) >>> deepest_leaves_sum(root) 9 # The deepest leaves are 4 and 5","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def construct_tree(nums): if not nums or nums[0] == -1: return None from collections import deque root = TreeNode(nums[0]) queue = deque([root]) index = 1 while queue: node = queue.popleft() if index < len(nums) and nums[index] != -1: node.left = TreeNode(nums[index]) queue.append(node.left) index += 1 if index < len(nums) and nums[index] != -1: node.right = TreeNode(nums[index]) queue.append(node.right) index += 1 return root def deepest_leaves_sum(root): if not root: return 0 from collections import deque queue = deque([root]) current_level_sum = 0 while queue: current_level_sum = 0 level_length = len(queue) for _ in range(level_length): node = queue.popleft() current_level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return current_level_sum"},{"question":"def minCostClimbingStairs(cost: List[int]) -> int: Given an array of integers 'cost' where cost[i] is the cost of step i, returns the minimum cost to reach the last step. >>> minCostClimbingStairs([10, 15, 20]) 15 >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1]) 6 >>> minCostClimbingStairs([5]) 5 >>> minCostClimbingStairs([1, 100]) 1 >>> minCostClimbingStairs([]) 0","solution":"def minCostClimbingStairs(cost): Given an array of integers 'cost' where cost[i] is the cost of step i, this function returns the minimum cost to reach the last step. n = len(cost) if n == 0: return 0 if n == 1: return cost[0] dp = [0] * (n+1) dp[0] = 0 dp[1] = 0 # Starting at step 0 or 1 incurs no initial cost for i in range(2, n+1): dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]) return dp[n]"},{"question":"def min_operations_to_sort(nums, k): Returns the minimum number of operations needed to sort the entire array nums in non-decreasing order by reversing any subarray of length k. Examples: >>> min_operations_to_sort([1, 2, 3, 4, 5], 3) 0 >>> min_operations_to_sort([5, 4, 3, 2, 1], 5) 1 >>> min_operations_to_sort([4, 3, 2, 1, 5], 2) 2 >>> min_operations_to_sort([4, 3, 1, 2, 5], 3) 1 >>> min_operations_to_sort([4, 3, 2, 5, 1], 3) 2 def test_sorted_array(): assert min_operations_to_sort([1, 2, 3, 4, 5], 3) == 0 def test_k_equals_n(): assert min_operations_to_sort([5, 4, 3, 2, 1], 5) == 1 # since one reversal of the whole array sorts it def test_min_operations_required(): assert min_operations_to_sort([4, 3, 2, 1, 5], 2) == 2 assert min_operations_to_sort([4, 3, 1, 2, 5], 3) == 1 assert min_operations_to_sort([4, 3, 2, 5, 1], 3) == 2 def test_single_element_array(): assert min_operations_to_sort([1], 1) == 0 # Already sorted def test_k_equals_1(): assert min_operations_to_sort([3, 2, 1], 1) == -1 # Impossible to sort def test_already_sorted_but_subarrays(): assert min_operations_to_sort([1, 2, 3, 4, 5], 2) == 0 # Already sorted def test_unsorted_blocks(): assert min_operations_to_sort([3, 1, 2, 4, 5], 3) == 1 def test_large_unsorted_array(): assert min_operations_to_sort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 5) == 2","solution":"def min_operations_to_sort(nums, k): Returns the minimum number of operations needed to sort the entire array nums in non-decreasing order by reversing any subarray of length k. n = len(nums) sorted_nums = sorted(nums) # Edge case: if array is already sorted if nums == sorted_nums: return 0 # Special cases if k == 1: return -1 # Impossible to sort (only individual elements can be swapped) if k == n: return 1 if nums != sorted_nums else 0 # One operation is sufficient if it sorts the array entirely # To keep track of contiguous blocks of increasing elements increasing_blocks = 1 for i in range(1, n): if nums[i] < nums[i - 1]: increasing_blocks += 1 return (increasing_blocks + (k - 1)) // k # Number of operations needed"},{"question":"from typing import List def maxProfit(prices: List[int]) -> int: You are given a list of integers representing the stock prices of a company in chronological order. You are allowed to complete at most two transactions to maximize your profit (i.e., buy one and sell one share of the stock, then buy and sell another share later). Design an algorithm to find the maximum profit you can achieve under these constraints. Note that you cannot engage in multiple transactions simultaneously (you must sell the stock before you buy again). Args: prices (List[int]): List of stock prices Returns: int: The maximum profit Example: >>> maxProfit([3, 3, 5, 0, 0, 3, 1, 4]) 6 >>> maxProfit([1, 2, 3, 4, 5]) 4 >>> maxProfit([7, 6, 4, 3, 1]) 0 >>> maxProfit([1, 2, 4, 2, 5, 7, 2, 4, 9, 0]) 13 def test_example1(): prices = [3, 3, 5, 0, 0, 3, 1, 4] assert maxProfit(prices) == 6 def test_example2(): prices = [1, 2, 3, 4, 5] assert maxProfit(prices) == 4 def test_example3(): prices = [7, 6, 4, 3, 1] assert maxProfit(prices) == 0 def test_example4(): prices = [1, 2, 4, 2, 5, 7, 2, 4, 9, 0] assert maxProfit(prices) == 13 def test_empty_prices(): prices = [] assert maxProfit(prices) == 0 def test_single_day(): prices = [5] assert maxProfit(prices) == 0 def test_two_days_increase(): prices = [1, 5] assert maxProfit(prices) == 4 def test_two_days_decrease(): prices = [5, 1] assert maxProfit(prices) == 0 def test_multiple_transactions(): prices = [1, 2, 3, 4, 5, 6, 7, 1, 1, 2, 3, 4, 5, 6, 7] assert maxProfit(prices) == 12","solution":"def maxProfit(prices): if not prices: return 0 # Initialize the variables t1_cost, t2_cost = float('inf'), float('inf') t1_profit, t2_profit = 0, 0 for price in prices: # The maximum profit achievable after the first buy t1_cost = min(t1_cost, price) t1_profit = max(t1_profit, price - t1_cost) # Reinvest the profit gained from the first transaction into the second transaction t2_cost = min(t2_cost, price - t1_profit) t2_profit = max(t2_profit, price - t2_cost) return t2_profit"},{"question":"def minimizeMaxSum(arr: List[int], k: int) -> int: Split the array into k contiguous subarrays such that the sum of the maximum sums of these subarrays is minimized. >>> minimizeMaxSum([1, 2, 3, 4, 5], 2) 9 >>> minimizeMaxSum([1, 2, 3, 4, 5], 1) 15 >>> minimizeMaxSum([1, 2, 3, 4, 5], 5) 5 >>> minimizeMaxSum([1, 2, 3, 1000000, 2, 3], 2) 1000005 >>> minimizeMaxSum([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) 17 >>> minimizeMaxSum([1, 3, 1, 5, 1, 2, 6, 8, 3, 2], 4) 10","solution":"def minimizeMaxSum(arr, k): def is_valid(mid): current_sum = 0 count = 1 for num in arr: if current_sum + num > mid: count += 1 current_sum = num if count > k: return False else: current_sum += num return True left, right = max(arr), sum(arr) result = right while left <= right: mid = (left + right) // 2 if is_valid(mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxSumLeafToLeaf(root): Computes the maximum sum of values along any path from one leaf node to another leaf node in a binary tree. Returns 0 if the tree does not contain at least two leaf nodes. >>> root = TreeNode(1) >>> maxSumLeafToLeaf(root) 0 >>> root = TreeNode(1, TreeNode(2)) >>> maxSumLeafToLeaf(root) 0 >>> root = TreeNode(1, None, TreeNode(3)) >>> maxSumLeafToLeaf(root) 0 >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> maxSumLeafToLeaf(root) 6 >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) >>> maxSumLeafToLeaf(root) 11 >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) >>> maxSumLeafToLeaf(root) 18","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxSumLeafToLeaf(root): def helper(node): if not node: return (float('-inf'), float('-inf')) if not node.left and not node.right: return (node.val, float('-inf')) left_single_path, left_max = helper(node.left) right_single_path, right_max = helper(node.right) if node.left and node.right: max_sum = max(left_max, right_max, left_single_path + right_single_path + node.val) return (max(left_single_path, right_single_path) + node.val, max_sum) elif node.left: return (left_single_path + node.val, left_max) else: return (right_single_path + node.val, right_max) result = helper(root) return result[1] if result[1] != float('-inf') else 0"},{"question":"def maximalRectangle(matrix: List[List[int]]) -> int: Given an integer matrix mat, find the largest rectangle containing only 1's and return its area. >>> maximalRectangle([]) 0 >>> maximalRectangle([[0]]) 0 >>> maximalRectangle([[1]]) 1 >>> maximalRectangle([[0, 0], [0, 0]]) 0 >>> maximalRectangle([[1, 1], [1, 1]]) 4 >>> maximalRectangle([[0, 1, 1, 0], [1, 1, 1, 0], [0, 1, 1, 1], [1, 0, 0, 1]]) 6 >>> maximalRectangle([[1, 0, 1, 1, 1]]) 3 >>> maximalRectangle([[1], [1], [0], [1], [1]]) 2","solution":"def maximalRectangle(matrix): if not matrix or not matrix[0]: return 0 def largestRectangleArea(heights): stack = [] max_area = 0 heights.append(0) # Add a zero-height to ensure we process all buildings for i in range(len(heights)): while stack and heights[stack[-1]] > heights[i]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area max_rectangle = 0 heights = [0] * len(matrix[0]) for row in matrix: for i in range(len(row)): if row[i] == 0: heights[i] = 0 else: heights[i] += row[i] max_rectangle = max(max_rectangle, largestRectangleArea(heights)) return max_rectangle"},{"question":"def isPalindrome(x: int) -> bool: Check whether a given integer is a palindrome. >>> isPalindrome(121) True >>> isPalindrome(-121) False >>> isPalindrome(10) False >>> isPalindrome(7) True >>> isPalindrome(1234321) True >>> isPalindrome(123456789) False >>> isPalindrome(0) True","solution":"def isPalindrome(x: int) -> bool: if x < 0: return False original = x reversed_number = 0 while x > 0: digit = x % 10 reversed_number = reversed_number * 10 + digit x = x // 10 return original == reversed_number"},{"question":"def canPartitionKSubsets(arr: List[int], k: int) -> bool: Rearrange the array such that it's split into \`k\` non-empty subsets with equal sums. Returns \`true\` if such an arrangement is possible, otherwise returns \`false. >>> canPartitionKSubsets([4, 3, 2, 3, 5, 2, 1], 4) == True >>> canPartitionKSubsets([1, 2, 3, 4], 3) == False >>> canPartitionKSubsets([2, 2, 2, 2], 2) == True >>> canPartitionKSubsets([2, 1, 4, 3, 6], 5) == False >>> canPartitionKSubsets([1, 1, 1], 4) == False","solution":"def canPartitionKSubsets(arr, k): def can_partition(start, k, current_sum, subset_sum, used): if k == 0: return True if current_sum == subset_sum: return can_partition(0, k - 1, 0, subset_sum, used) for i in range(start, len(arr)): if not used[i] and current_sum + arr[i] <= subset_sum: used[i] = True if can_partition(i + 1, k, current_sum + arr[i], subset_sum, used): return True used[i] = False return False total_sum = sum(arr) if total_sum % k != 0: return False subset_sum = total_sum // k used = [False] * len(arr) arr.sort(reverse=True) # optimization step to try larger numbers first return can_partition(0, k, 0, subset_sum, used)"},{"question":"def min_replacements_to_k_distinct(s: str, k: int) -> int: Given a string s and an integer k, this function returns the minimum number of replacements needed to create k distinct characters in the final string. >>> min_replacements_to_k_distinct(\\"aabbcc\\", 2) 0 >>> min_replacements_to_k_distinct(\\"aabbcc\\", 4) 1 >>> min_replacements_to_k_distinct(\\"aaaaaa\\", 2) 1 >>> min_replacements_to_k_distinct(\\"aabb\\", 3) 1 >>> min_replacements_to_k_distinct(\\"aabbcc\\", 3) 0 >>> min_replacements_to_k_distinct(\\"abcde\\", 5) 0 >>> min_replacements_to_k_distinct(\\"\\", 1) 1 >>> min_replacements_to_k_distinct(\\"\\", 0) 0 >>> min_replacements_to_k_distinct(\\"a\\", 1) 0 >>> min_replacements_to_k_distinct(\\"aaaa\\", 4) 3","solution":"def min_replacements_to_k_distinct(s: str, k: int) -> int: Given a string s and an integer k, this function returns the minimum number of replacements needed to create k distinct characters in the final string. if k <= 0: return 0 distinct_chars = set(s) if len(distinct_chars) >= k: return 0 return k - len(distinct_chars)"},{"question":"def longest_increasing_subarray(arr: List[int]) -> int: Given an array of integers \`arr\`, finds the length of the longest contiguous subarray such that every element in the subarray is strictly greater than the previous element. >>> longest_increasing_subarray([1, 2, 3, 4, 5]) == 5 >>> longest_increasing_subarray([5, 4, 3, 2, 1]) == -1 >>> longest_increasing_subarray([1, 2, 1, 2, 3, 1, 4, 5, 6]) == 4 >>> longest_increasing_subarray([1]) == -1 >>> longest_increasing_subarray([1, 2, 2, 3, 4, 5, 1, 2, 3]) == 4 >>> longest_increasing_subarray([]) == -1 >>> longest_increasing_subarray([2, 2, 2, 2]) == -1 pass","solution":"def longest_increasing_subarray(arr): Finds the length of the longest contiguous subarray such that every element in the subarray is strictly greater than the previous element. if not arr: return -1 max_length = 0 current_length = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 max_length = max(max_length, current_length) return max_length if max_length > 1 else -1"},{"question":"def is_palindrome(x: int) -> bool: Determines if a given integer x is a palindrome. :param x: Integer to be checked :return: True if x is a palindrome, False otherwise >>> is_palindrome(121) True >>> is_palindrome(123) False >>> is_palindrome(-121) False >>> is_palindrome(12321) True >>> is_palindrome(10) False >>> is_palindrome(0) True >>> is_palindrome(-1) False >>> is_palindrome(1) True >>> is_palindrome(123454321) True >>> is_palindrome(123456789987654321) True >>> is_palindrome(123456789) False","solution":"def is_palindrome(x): Determines if a given integer x is a palindrome. :param x: Integer to be checked :return: True if x is a palindrome, False otherwise # Convert integer to string str_x = str(x) # Compare the string with its reverse return str_x == str_x[::-1]"},{"question":"def shuffle_string(s: str, indices: List[int]) -> str: Reorders the characters in the string s based on the given list indices. :param s: A string consisting of only lowercase English letters. :param indices: A list of integers indicating the new positions for each character in s. :return: A new reordered string after shuffling based on indices. >>> shuffle_string(\\"abc\\", [2, 1, 0]) \\"cba\\" >>> shuffle_string(\\"aiohn\\", [3, 1, 4, 2, 0]) \\"nihao\\"","solution":"def shuffle_string(s, indices): Reorders the characters in the string s based on the given list indices. :param s: A string consisting of only lowercase English letters. :param indices: A list of integers indicating the new positions for each character in s. :return: A new reordered string after shuffling based on indices. shuffled = [''] * len(s) for i, index in enumerate(indices): shuffled[index] = s[i] return ''.join(shuffled)"},{"question":"def split_string_into_k_parts(s: str, k: int) -> int: Given a string \`s\` and an integer \`k\`, split the string into \`k\` contiguous substrings such that the maximum length of these substrings is minimized. Return the minimized maximum length. If it is not possible to split the string according to the given \`k\`, return \`-1\`. >>> split_string_into_k_parts(\\"abcdefghij\\", 2) 5 >>> split_string_into_k_parts(\\"abcdefghij\\", 3) 4 >>> split_string_into_k_parts(\\"abcdefghij\\", 1) 10 >>> split_string_into_k_parts(\\"abcdefghij\\", 10) 1 >>> split_string_into_k_parts(\\"abc\\", 4) -1 >>> split_string_into_k_parts(\\"aabbcc\\", 3) 2 >>> split_string_into_k_parts(\\"aabbcc\\", 2) 3","solution":"def split_string_into_k_parts(s, k): if len(s) < k: return -1 # Not possible to split into more parts than the length of the string def can_split_with_max_len(max_len): parts, current_part_len = 1, 0 for char in s: if current_part_len + 1 > max_len: parts += 1 current_part_len = 0 if parts > k: return False current_part_len += 1 return True low, high = 1, len(s) while low < high: mid = (low + high) // 2 if can_split_with_max_len(mid): high = mid else: low = mid + 1 return low"},{"question":"def max_distinct_elements_after_k_operations(nums: List[int], k: int) -> int: Returns the maximum number of distinct integers in the array after performing exactly k operations. :param nums: List[int], an array of integers :param k: int, the number of operations allowed :return: int, the maximum number of distinct integers after k operations >>> max_distinct_elements_after_k_operations([1, 2, 3, 4], 0) 4 >>> max_distinct_elements_after_k_operations([1, 1, 1, 2, 2, 3], 1) 3 >>> max_distinct_elements_after_k_operations([1, 1, 1, 2, 2, 3], 2) 3 >>> max_distinct_elements_after_k_operations([1, 1, 1, 2, 2, 3], 3) 3 >>> max_distinct_elements_after_k_operations([1, 1, 1, 2, 2, 3], 4) 4 >>> max_distinct_elements_after_k_operations([1, 1, 1, 2, 2, 3], 5) 5 >>> max_distinct_elements_after_k_operations([1, 2, 3, 4], 3) 7 >>> max_distinct_elements_after_k_operations([], 0) 0 >>> max_distinct_elements_after_k_operations([], 10) 10","solution":"from collections import Counter def max_distinct_elements_after_k_operations(nums, k): Returns the maximum number of distinct integers in the array after performing exactly k operations. :param nums: List[int], an array of integers :param k: int, the number of operations allowed :return: int, the maximum number of distinct integers after k operations freq = Counter(nums) unique_elements = len(freq) duplicates = len(nums) - unique_elements if k <= duplicates: return unique_elements # We can only remove 'k' duplicates at most, but all unique elements remain else: new_elements = k - duplicates # We use remaining 'k' to add new elements to reach maximum distinct return unique_elements + new_elements"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root: TreeNode) -> int: You are given a binary tree where each node contains a value of 0 or 1. Each root-to-leaf path represents a binary number with the most significant bit at the root. For example, if the path is 0 -> 1 -> 1 -> 0, it represents the binary number 0110, which is 6 in decimal. Write a function to sum all root-to-leaf binary numbers. The answer should be returned as an integer representing the total sum of all root-to-leaf binary numbers in the tree. You may assume that the tree has at least one node. >>> root = TreeNode(1) >>> root.left = TreeNode(0) >>> root.right = TreeNode(1) >>> assert sumRootToLeaf(root) == 6 >>> root = TreeNode(1) >>> root.left = TreeNode(0) >>> root.left.left = TreeNode(1) >>> assert sumRootToLeaf(root) == 4 pass def test_single_node_tree(): root = TreeNode(1) assert sumRootToLeaf(root) == 1 def test_complete_binary_tree(): root = TreeNode(1) root.left = TreeNode(0) root.right = TreeNode(1) root.left.left = TreeNode(0) root.left.right = TreeNode(1) root.right.left = TreeNode(0) root.right.right = TreeNode(1) assert sumRootToLeaf(root) == 22 # Paths: 100 + 101 + 110 + 111 = 4 + 5 + 6 + 7 = 22 def test_left_skewed_tree(): root = TreeNode(1) root.left = TreeNode(0) root.left.left = TreeNode(1) root.left.left.left = TreeNode(1) assert sumRootToLeaf(root) == 11 # Path: 1011 in binary is 11 in decimal def test_right_skewed_tree(): root = TreeNode(1) root.right = TreeNode(0) root.right.right = TreeNode(1) root.right.right.right = TreeNode(1) assert sumRootToLeaf(root) == 11 # Path: 1011 in binary is 11 in decimal def test_mixed_tree(): root = TreeNode(1) root.left = TreeNode(0) root.right = TreeNode(1) root.right.left = TreeNode(0) assert sumRootToLeaf(root) == 8 # Paths: 10 + 1010 = 2 + 8 = 10 (Note: only complete root-to-leaf paths are considered)","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root): def dfs(node, current_num): if not node: return 0 current_num = (current_num << 1) | node.val if not node.left and not node.right: return current_num return dfs(node.left, current_num) + dfs(node.right, current_num) return dfs(root, 0)"},{"question":"import heapq from collections import defaultdict def find_cheapest_price(n, flights, src, dst, k): Finds the minimum travel cost from \`src\` to \`dst\` with at most \`k\` stops. :param n: int, number of cities numbered from 0 to n-1 :param flights: List[List[int]], list of flights where each flight is represented as [u, v, w] :param src: int, starting city :param dst: int, destination city :param k: int, maximum number of stops allowed :return: int, the minimum travel cost from \`src\` to \`dst\` with at most \`k\` stops. If there is no such route, return -1. >>> flights = [[0, 1, 100], [1, 2, 100], [0, 2, 500]] >>> find_cheapest_price(3, flights, 0, 2, 1) 200 >>> find_cheapest_price(3, flights, 0, 2, 0) 500 >>> flights = [[0, 1, 100], [1, 2, 50], [2, 3, 25], [0, 3, 300]] >>> find_cheapest_price(4, flights, 0, 3, 2) 175 >>> flights = [[1, 2, 100], [2, 1, 100]] >>> find_cheapest_price(3, flights, 0, 2, 1) -1 # Your code here","solution":"import heapq from collections import defaultdict, deque def find_cheapest_price(n, flights, src, dst, k): Finds the minimum travel cost from \`src\` to \`dst\` with at most \`k\` stops. :param n: int, number of cities numbered from 0 to n-1 :param flights: List[List[int]], list of flights where each flight is represented as [u, v, w] :param src: int, starting city :param dst: int, destination city :param k: int, maximum number of stops allowed :return: int, the minimum travel cost from \`src\` to \`dst\` with at most \`k\` stops. If there is no such route, return -1. graph = defaultdict(list) for u, v, w in flights: graph[u].append((v, w)) # (cost, current_city, stops) heap = [(0, src, 0)] while heap: cost, current_city, stops = heapq.heappop(heap) if current_city == dst: return cost if stops <= k: for neighbor, weight in graph[current_city]: heapq.heappush(heap, (cost + weight, neighbor, stops + 1)) return -1"},{"question":"def rearrange_queue(heights): Rearranges the queue such that people are sorted in descending order of their height. If two people have the same height, the person with the smaller index in the original array stands in front. Parameters: heights (list of int): List representing the heights of people in a queue. Returns: list of int: Rearranged heights. >>> rearrange_queue([150, 160, 170, 180, 190]) == [190, 180, 170, 160, 150] >>> rearrange_queue([150, 160, 150, 190, 170]) == [190, 170, 160, 150, 150] >>> rearrange_queue([150, 150, 150, 150, 150]) == [150, 150, 150, 150, 150] >>> rearrange_queue([]) == [] >>> rearrange_queue([150]) == [150] >>> rearrange_queue([190, 150, 180, 160, 170]) == [190, 180, 170, 160, 150] >>> rearrange_queue([150, 150, 150, 150, 150]) == [150, 150, 150, 150, 150] >>> rearrange_queue([150, 150, 150, 150, 160, 170, 160]) == [170, 160, 160, 150, 150, 150, 150]","solution":"def rearrange_queue(heights): Rearranges the queue such that people are sorted in descending order of their height. If two people have the same height, the person with the smaller index in the original array stands in front. Parameters: heights (list of int): List representing the heights of people in a queue. Returns: list of int: Rearranged heights. indexed_heights = list(enumerate(heights)) indexed_heights.sort(key=lambda x: (-x[1], x[0])) return [height for index, height in indexed_heights]"},{"question":"def find_unique_numbers(nums): Returns a list of integers that occur exactly once in the input list, sorted in ascending order. >>> find_unique_numbers([4, 3, 2, 7, 8, 2, 3, 1]) [1, 4, 7, 8] >>> find_unique_numbers([1, 1, 2, 2, 3, 3]) [] >>> find_unique_numbers([5, 3, 1, 2, 6, 4]) [1, 2, 3, 4, 5, 6] >>> find_unique_numbers([10, 9, 10, 8, 7, 7, 6]) [6, 8, 9] >>> find_unique_numbers([1]) [1] >>> find_unique_numbers([]) []","solution":"def find_unique_numbers(nums): Returns a list of integers that occur exactly once in the input list, sorted in ascending order. from collections import Counter count = Counter(nums) return sorted([num for num in count if count[num] == 1])"},{"question":"from typing import List def min_time_to_complete_tasks(tasks: List[int], k: int) -> int: Given a list of non-negative integers representing the amount of time each task takes, and an integer \`k\` representing the maximum number of parallel tasks that can be performed at any time, return the minimum amount of time required to complete all tasks. Each task must be assigned to one of the \`k\` workers and a worker can only work on one task at a time. >>> min_time_to_complete_tasks([], 3) 0 >>> min_time_to_complete_tasks([5], 1) 5 >>> min_time_to_complete_tasks([5, 10, 3], 1) 18 >>> min_time_to_complete_tasks([2, 2, 3, 3], 4) 3 >>> min_time_to_complete_tasks([4, 2, 5, 8, 1, 3], 3) 10 >>> min_time_to_complete_tasks([3, 3, 3, 3], 4) 3 >>> min_time_to_complete_tasks([7, 2, 1, 4], 4) 7 >>> min_time_to_complete_tasks([1, 2, 3, 4, 5, 6, 7, 8], 2) 20","solution":"def min_time_to_complete_tasks(tasks, k): Finds the minimum amount of time required to complete all tasks when we have k workers available. :param tasks: List of integers where each integer represents the time required to complete a task. :param k: Integer representing the number of available workers. :return: Minimum amount of time to complete all tasks. if not tasks: return 0 # Using a greedy approach with a priority queue (min-heap) to always assign tasks # to the worker that gets free the earliest. from heapq import heappush, heappop # Initialize the heap with k workers, all starting at time 0 heap = [0] * k for time in tasks: # Pop the worker who will be free the earliest earliest_worker = heappop(heap) # Assign the current task to this worker and push back the new free time heappush(heap, earliest_worker + time) # The minimum time to complete all tasks will be the maximum value in the heap return max(heap)"},{"question":"def construct_array(n: int, k: int) -> List[int]: Construct an array of length n with no more than k distinct integers, such that the number of distinct integers between any two occurrences of the same integer is minimized and the array is lexicographically smallest. >>> construct_array(3, 2) [1, 2, 1] >>> construct_array(5, 5) [1, 2, 3, 4, 5] >>> construct_array(3, 5) [] >>> construct_array(4, 4) [1, 2, 3, 4] >>> construct_array(7, 3) [1, 2, 3, 1, 2, 3, 1] >>> construct_array(1, 1) [1] >>> construct_array(6, 2) [1, 2, 1, 2, 1, 2]","solution":"def construct_array(n, k): Construct an array of length n with no more than k distinct integers, such that the number of distinct integers between any two occurrences of the same integer is minimized and the array is lexicographically smallest. if k > n: return [] result = [] for i in range(n): result.append((i % k) + 1) return result"},{"question":"from typing import List def longest_subarray(arr: List[int]) -> int: Given a list of unique positive integers \`arr\`, find the length of the longest subarray where the absolute difference between any two elements is less than or equal to \`1\`. >>> longest_subarray([1, 3, 2, 2, 5, 2, 3, 7]) 5 >>> longest_subarray([10]) 1 >>> longest_subarray([10, 20, 30]) 1 >>> longest_subarray([4, 4, 4, 4]) 4 >>> longest_subarray([2, 3]) 2 >>> longest_subarray([1, 2, 2, 1, 1, 2, 2, 2]) 8 >>> longest_subarray([]) 0 >>> longest_subarray([100000000, 100000001]) 2","solution":"from typing import List from collections import Counter def longest_subarray(arr: List[int]) -> int: if not arr: return 0 freq = Counter(arr) max_len = 0 for num in freq: current_len = freq[num] if num + 1 in freq: current_len += freq[num + 1] max_len = max(max_len, current_len) max_len = max(max_len, freq[num]) return max_len"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers in the given list that add up to the target. Parameters: nums (List[int]): List of integers. target (int): The target integer. Returns: List[int]: Indices of the two numbers that add up to the target or an empty list if no such numbers exist. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([1, 2, 3, 4], 8) [] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([-3, 4, 3, 90], 0) [0, 2] >>> two_sum([1000000000, 500000000, 500000000], 1000000000) [1, 2] pass","solution":"def two_sum(nums, target): Returns the indices of the two numbers in the given list that add up to the target. Parameters: nums (List[int]): List of integers. target (int): The target integer. Returns: List[int]: Indices of the two numbers that add up to the target or an empty list if no such numbers exist. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"def is_balanced(s: str) -> bool: Determines if the string of brackets is balanced. Args: s (str): The string of brackets to be checked. Returns: bool: True if the string is balanced, False otherwise. >>> is_balanced(\\"()\\") True >>> is_balanced(\\"()[]{}\\") True >>> is_balanced(\\"({[})\\") False >>> is_balanced(\\"{[\\") False >>> is_balanced(\\"\\") True >>> is_balanced(\\"a(b)c\\") False","solution":"def is_balanced(s): Determines if the string of brackets is balanced. Args: s (str): The string of brackets to be checked. Returns: bool: True if the string is balanced, False otherwise. stack = [] bracket_pairs = { ')': '(', '}': '{', ']': '[' } for char in s: if char in bracket_pairs.values(): stack.append(char) elif char in bracket_pairs.keys(): if stack == [] or stack.pop() != bracket_pairs[char]: return False else: return False return stack == []"},{"question":"class Solution: A class used to find the smallest perimeter of the land in the given grid. Attributes ---------- grid : List[List[int]] A 2D matrix representing the island map where 1 represents land and 0 represents water. Methods ------- minPerimeter() -> int: Returns the smallest possible perimeter of the land in the grid. Example Usage ------------- >>> grid = [ >>> [0, 0, 0], >>> [0, 1, 0], >>> [0, 0, 0] >>> ] >>> sol = Solution(grid) >>> sol.minPerimeter() 4 def __init__(self, grid): self.grid = grid self.rows = len(grid) self.cols = len(grid[0]) if self.rows > 0 else 0 def minPerimeter(self) -> int: Returns the smallest possible perimeter of the land in the grid.","solution":"class Solution: def __init__(self, grid): self.grid = grid self.rows = len(grid) self.cols = len(grid[0]) if self.rows > 0 else 0 def minPerimeter(self): def getCellPerimeter(i, j): perimeter = 0 # Check top if i == 0 or self.grid[i-1][j] == 0: perimeter += 1 # Check bottom if i == self.rows - 1 or self.grid[i+1][j] == 0: perimeter += 1 # Check left if j == 0 or self.grid[i][j-1] == 0: perimeter += 1 # Check right if j == self.cols - 1 or self.grid[i][j+1] == 0: perimeter += 1 return perimeter min_perimeter = float('inf') for i in range(self.rows): for j in range(self.cols): if self.grid[i][j] == 1: min_perimeter = min(min_perimeter, getCellPerimeter(i, j)) return min_perimeter"},{"question":"from typing import List def max_particles_annihilated(elements: List[int], target_sum: int) -> int: Returns the maximum number of particles that can be annihilated given the list of particle IDs and the target sum for annihilation. >>> max_particles_annihilated([1, 2, 3, 4], 5) == 4 >>> max_particles_annihilated([1, 2, 3, 4], 10) == 0 >>> max_particles_annihilated([1, 3, 2, 3, 4, 1, 2, 4], 4) == 6 >>> max_particles_annihilated([1, 1, 2, 2, 3, 3, 4, 4], 5) == 8 >>> max_particles_annihilated([1, 1, 1, 1], 2) == 4 >>> max_particles_annihilated([0, 0, 0, 0], 0) == 4","solution":"from collections import Counter def max_particles_annihilated(elements, target_sum): Returns the maximum number of particles that can be annihilated given the list of particle IDs and the target sum for annihilation. counts = Counter(elements) max_annihilations = 0 for element in list(counts.keys()): complement = target_sum - element if complement in counts: if element == complement: # Special case where the element and its complement are the same pairs = counts[element] // 2 else: pairs = min(counts[element], counts[complement]) max_annihilations += pairs counts[element] -= pairs counts[complement] -= pairs # Remove elements with zero count to avoid redundant checks if counts[element] == 0: del counts[element] if counts[complement] == 0: del counts[complement] return max_annihilations * 2"},{"question":"def reachable_nodes_within_k_steps(n, edges, start, k): Returns a list of nodes that are reachable from \`start\` within exactly \`k\` steps. The nodes in the returned list are sorted in ascending order. >>> reachable_nodes_within_k_steps(5, [], 0, 2) == [] >>> reachable_nodes_within_k_steps(4, [[0, 1], [1, 2], [2, 3]], 0, 1) == [1] >>> reachable_nodes_within_k_steps(4, [[0, 1], [1, 2], [2, 3]], 0, 2) == [2] >>> reachable_nodes_within_k_steps(4, [[0, 1], [1, 2], [2, 3]], 0, 3) == [3] >>> reachable_nodes_within_k_steps(4, [[0, 1], [1, 2], [2, 3]], 0, 4) == [] >>> reachable_nodes_within_k_steps(5, [[0, 1], [0, 2], [1, 3], [2, 3], [3, 4]], 0, 2) == [3]","solution":"def reachable_nodes_within_k_steps(n, edges, start, k): Returns a list of nodes that are reachable from \`start\` within exactly \`k\` steps. The nodes in the returned list are sorted in ascending order. from collections import defaultdict, deque # Create adjacency list representation of the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Use a queue to perform BFS queue = deque([(start, 0)]) reachable_nodes = set() while queue: node, steps = queue.popleft() if steps == k: reachable_nodes.add(node) elif steps < k: for neighbor in graph[node]: queue.append((neighbor, steps + 1)) return sorted(reachable_nodes)"},{"question":"from typing import List def diff_ways_to_evaluate_expression(expression: str) -> List[int]: Compute the different possible results from evaluating all the possible ways to group the numbers and operators in the given expression. >>> set(diff_ways_to_evaluate_expression(\\"2*3+4\\")) == {10, 14} >>> set(diff_ways_to_evaluate_expression(\\"2+3*4\\")) == {14, 20} >>> set(diff_ways_to_evaluate_expression(\\"5+6*7\\")) == {77, 47} >>> set(diff_ways_to_evaluate_expression(\\"3\\")) == {3} >>> set(diff_ways_to_evaluate_expression(\\"1234\\")) == {1234}","solution":"from typing import List def diff_ways_to_evaluate_expression(expression: str) -> List[int]: def ways(expr): if expr.isdigit(): return [int(expr)] result = [] for index in range(len(expr)): if expr[index] in '+*': left_ways = ways(expr[:index]) right_ways = ways(expr[index + 1:]) for left in left_ways: for right in right_ways: if expr[index] == '+': result.append(left + right) elif expr[index] == '*': result.append(left * right) return result return list(set(ways(expression)))"},{"question":"def find_triplets(arr, x): Finds all unique triplets in the array which sum up to x. Args: arr: List of integers. x: Integer target sum. Returns: A list of lists, where each list contains three integers that sum up to x. Example: >>> find_triplets([1, 2, 3, 4, 5, 6], 10) [[1, 3, 6], [1, 4, 5], [2, 3, 5]] >>> find_triplets([1, 1, 1, 1], 10) [] >>> find_triplets([1, 2, 2, 3, 4, 5], 9) [[1, 3, 5], [2, 2, 5], [2, 3, 4]] >>> find_triplets([-1, 0, 1, 2, -1, -4], 0) [[-1, -1, 2], [-1, 0, 1]] >>> find_triplets([2, 2, 2, 2, 2], 6) [[2, 2, 2]] >>> find_triplets([], 0) [] >>> find_triplets([1], 1) [] >>> find_triplets([1, 2], 3) []","solution":"def find_triplets(arr, x): Finds all unique triplets in the array which sum up to x. Args: arr: List of integers. x: Integer target sum. Returns: A list of lists, where each list contains three integers that sum up to x. arr.sort() triplets = [] n = len(arr) for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue # Skip duplicate values to avoid duplicate triplets left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == x: triplets.append([arr[i], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 # Skip duplicate values while left < right and arr[right] == arr[right - 1]: right -= 1 # Skip duplicate values left += 1 right -= 1 elif current_sum < x: left += 1 else: right -= 1 return triplets"},{"question":"class MedianFinder: Design and implement a class MedianFinder that supports the following operations: - addNum(int num): Adds an integer number from the data stream to the data structure. - findMedian(): Returns the median of all elements so far. If the number of elements is odd, return the middle element; if the number of elements is even, return the average of the two middle elements. >>> mf = MedianFinder() >>> mf.addNum(1) >>> mf.findMedian() 1 >>> mf.addNum(2) >>> mf.findMedian() 1.5 >>> mf.addNum(3) >>> mf.findMedian() 2 def __init__(self): Initialize your data structure here. def addNum(self, num: int) -> None: Adds an integer number from the data stream to the data structure. def findMedian(self) -> float: Returns the median of all elements so far.","solution":"import heapq class MedianFinder: def __init__(self): Initialize your data structure here using two heaps. One max-heap for the lower half and one min-heap for the upper half. self.lower_half = [] # max-heap (inverted min-heap) self.upper_half = [] # min-heap def addNum(self, num: int) -> None: Adds an integer number from the data stream to the data structure. # Add to max heap (lower_half) heapq.heappush(self.lower_half, -num) # Ensure the max-heap property and min-heap property if (self.lower_half and self.upper_half and (-self.lower_half[0] > self.upper_half[0])): heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) # Balance the sizes if len(self.lower_half) > len(self.upper_half) + 1: heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) if len(self.upper_half) > len(self.lower_half): heapq.heappush(self.lower_half, -heapq.heappop(self.upper_half)) def findMedian(self) -> float: Returns the median of all elements so far. If the number of elements is odd, return the middle element; if the number of elements is even, return the average of the two middle elements. # Handle the case where the number of elements is odd if len(self.lower_half) > len(self.upper_half): return -self.lower_half[0] return (-self.lower_half[0] + self.upper_half[0]) / 2"},{"question":"import random from typing import Optional class RandomizedCollection: Data structure that supports inserting, removing, and getting a random element from a collection of numbers. Each operation should run in average O(1) time. def __init__(self): Initialize your data structure here. def insert(self, val: int) -> None: Inserts a value into the collection. def remove(self, val: int) -> bool: Removes a value from the collection if it exists. If multiple instances of the value exist, remove just one. Returns: bool: True if the value was removed, False otherwise. def getRandom(self) -> Optional[int]: Get a random element from the collection. Returns: Optional[int]: A random value or None if the collection is empty. # Example Usage: # collection = RandomizedCollection() # collection.insert(1) # collection.insert(1) # collection.insert(2) # collection.remove(1) # print(collection.getRandom()) def test_insert(): collection = RandomizedCollection() collection.insert(1) assert collection.data == [1] collection.insert(1) assert collection.data == [1, 1] collection.insert(2) assert collection.data == [1, 1, 2] def test_remove(): collection = RandomizedCollection() collection.insert(1) collection.insert(1) collection.insert(2) assert collection.remove(1) == True assert (collection.data == [2, 1] or collection.data == [1, 2]) assert collection.remove(1) == True assert collection.data == [2] assert collection.remove(1) == False assert collection.data == [2] assert collection.remove(2) == True assert collection.data == [] def test_getRandom(): collection = RandomizedCollection() assert collection.getRandom() == None collection.insert(1) assert collection.getRandom() == 1 collection.insert(2) collection.insert(3) assert collection.getRandom() in [1, 2, 3] def test_mixed_operations(): collection = RandomizedCollection() collection.insert(1) collection.insert(2) collection.remove(1) collection.insert(3) assert collection.getRandom() in [2, 3] collection.insert(4) collection.remove(3) assert collection.getRandom() in [2, 4]","solution":"import random class RandomizedCollection: def __init__(self): Initialize the data structure here. self.data = [] self.val_index_map = {} def insert(self, val: int) -> None: Inserts a value into the collection. self.data.append(val) if val in self.val_index_map: self.val_index_map[val].append(len(self.data) - 1) else: self.val_index_map[val] = [len(self.data) - 1] def remove(self, val: int) -> bool: Removes a value from the collection if it exists. If multiple instances of the value exist, remove just one. Returns true if the collection contained the specified element, false otherwise. if val not in self.val_index_map or not self.val_index_map[val]: return False remove_idx = self.val_index_map[val].pop() last_val = self.data[-1] self.data[remove_idx] = last_val if self.val_index_map[last_val]: self.val_index_map[last_val].remove(len(self.data) - 1) self.val_index_map[last_val].append(remove_idx) self.data.pop() if not self.val_index_map[val]: del self.val_index_map[val] return True def getRandom(self) -> int: Get a random element from the collection. if not self.data: return None return random.choice(self.data)"},{"question":"def min_operations_to_subsequence(s: str, t: str) -> int: Returns the minimum number of operations needed to make \`t\` a subsequence of \`s\`. In one operation, you can choose any character of \`t\` and replace it with another character. >>> min_operations_to_subsequence(\\"abcde\\", \\"ace\\") == 0 >>> min_operations_to_subsequence(\\"abcde\\", \\"acf\\") == 1 >>> min_operations_to_subsequence(\\"abc\\", \\"def\\") == 3 >>> min_operations_to_subsequence(\\"abcde\\", \\"abcde\\") == 0 >>> min_operations_to_subsequence(\\"abcde\\", \\"\\") == 0 >>> min_operations_to_subsequence(\\"\\", \\"abc\\") == 3 >>> min_operations_to_subsequence(\\"ababab\\", \\"bbb\\") == 0 >>> min_operations_to_subsequence(\\"xyz\\", \\"wvu\\") == 3","solution":"def min_operations_to_subsequence(s, t): Returns the minimum number of operations needed to make \`t\` a subsequence of \`s\`. In one operation, you can choose any character of \`t\` and replace it with another character. m, n = len(s), len(t) # If t is already empty, zero operations are needed if n == 0: return 0 # dp[i][j] will be True if t[0:j] is a subsequence of s[0:i] dp = [[False] * (n + 1) for _ in range(m + 1)] # An empty t is a subsequence of any prefix of s for i in range(m + 1): dp[i][0] = True # Fill dp array for i in range(1, m + 1): for j in range(1, n + 1): # Carry forward the result from previous row dp[i][j] = dp[i - 1][j] # If chars match, check for shorter subsequences if s[i - 1] == t[j - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j - 1] # Find the length of the longest valid subsequence t' that can be part of s max_len = 0 for j in range(n + 1): if dp[m][j]: max_len = j # The minimum number of operations is the number of changes required return n - max_len"},{"question":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def zigzagLevelOrder(root): Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between). >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> zigzagLevelOrder(root) [[1], [3, 2]]","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def zigzagLevelOrder(root): Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between). if not root: return [] results = [] current_level = deque([root]) left_to_right = True while current_level: level_result = [] next_level = deque() while current_level: node = current_level.popleft() level_result.append(node.val) if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) if not left_to_right: level_result.reverse() results.append(level_result) current_level = next_level left_to_right = not left_to_right return results"},{"question":"def unique_subarrays(arr: List[int], k: int) -> List[List[int]]: Return all the unique subarrays of size k that have distinct elements. >>> unique_subarrays([1, 2, 3, 4], 2) [[1, 2], [2, 3], [3, 4]] >>> unique_subarrays([1, 2, 2, 3, 4], 2) [[1, 2], [2, 3], [3, 4]] >>> unique_subarrays([1, 2, 3], 5) [] >>> unique_subarrays([1, 1, 1, 1], 2) [] >>> unique_subarrays([], 2) [] >>> unique_subarrays([1, 2, 3, 4], 1) [[1], [2], [3], [4]] >>> unique_subarrays([1, 2, 3, 4, 5, 6, 7, 8], 3) [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8]]","solution":"def unique_subarrays(arr, k): Returns all the unique subarrays of size k that have distinct elements. Parameters: arr (list of int): An input array. k (int): Size of the subarray. Returns: list of list of int: List of unique subarrays of size k with distinct elements. n = len(arr) if k > n: return [] result = [] for start in range(n - k + 1): subarray = arr[start:start + k] if len(set(subarray)) == k: result.append(subarray) return result"},{"question":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[int]: Returns the level order traversal of a binary tree's nodes' values. :param root: TreeNode, the root of the binary tree :return: List of integers representing the level order traversal >>> root = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))) >>> level_order_traversal(root) [3, 9, 20, 15, 7] >>> root = TreeNode(1) >>> level_order_traversal(root) [1] >>> level_order_traversal(None) []","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): Returns the level order traversal of a binary tree's nodes' values. :param root: TreeNode, the root of the binary tree :return: List of integers representing the level order traversal if not root: return [] queue = deque([root]) result = [] while queue: node = queue.popleft() result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"def min_replacements_to_avoid_repeats(s: str) -> int: Returns the minimum number of character replacements needed to make sure no two adjacent characters are the same in the given string \`s\`. >>> min_replacements_to_avoid_repeats(\\"abc\\") == 0 >>> min_replacements_to_avoid_repeats(\\"a\\") == 0 >>> min_replacements_to_avoid_repeats(\\"aaaaa\\") == 2 >>> min_replacements_to_avoid_repeats(\\"bb\\") == 1 >>> min_replacements_to_avoid_repeats(\\"aabb\\") == 2 >>> min_replacements_to_avoid_repeats(\\"abba\\") == 1 >>> min_replacements_to_avoid_repeats(\\"aaabccddd\\") == 3 >>> min_replacements_to_avoid_repeats(\\"\\") == 0 >>> min_replacements_to_avoid_repeats(\\"z\\") == 0","solution":"def min_replacements_to_avoid_repeats(s): Returns the minimum number of character replacements needed to make sure no two adjacent characters are the same in the given string \`s\`. n = len(s) if n < 2: return 0 replacements = 0 # Iterate through the string and check for adjacent characters that are the same for i in range(1, n): if s[i] == s[i-1]: replacements += 1 # Choose a character different from the previous and the next characters for c in 'abcdefghijklmnopqrstuvwxyz': if (i+1 < n and c != s[i+1]) and c != s[i-1]: s = s[:i] + c + s[i+1:] break return replacements"},{"question":"def can_convert(s: str, t: str, k: int) -> bool: Returns True if you can convert string s to string t using exactly k operations, otherwise False. >>> can_convert(\\"abcdef\\", \\"abcfed\\", 4) True >>> can_convert(\\"abcdef\\", \\"fedcba\\", 3) False >>> can_convert(\\"abc\\", \\"bbc\\", 1) True >>> can_convert(\\"abc\\", \\"bbc\\", 2) False >>> can_convert(\\"abc\\", \\"bbc\\", 2) False >>> can_convert(\\"abc\\", \\"bbc\\", 1) True >>> can_convert(\\"abc\\", \\"abd\\", 5) True >>> can_convert(\\"abc\\", \\"abcd\\", 1) False >>> can_convert(\\"abc\\", \\"abc\\", 2) True","solution":"def can_convert(s, t, k): Returns True if you can convert string s to string t using exactly k operations, otherwise False. if len(s) != len(t): return False # Calculate the number of differing characters between s and t differing_chars = sum(1 for a, b in zip(s, t) if a != b) # We need exactly k operations: they need to either exactly match the differing characters, or there should be enough additional operations to allow extra changes back and forth return differing_chars <= k and (k - differing_chars) % 2 == 0"},{"question":"def findSmallestMissingPositive(nums: List[int]) -> int: Given an array \`nums\` of n integers, where each integer is between 1 and n, inclusive, compute the smallest missing positive integer. The algorithm should run in O(n) time and use O(1) extra space. >>> findSmallestMissingPositive([3, 4, -1, 1]) 2 >>> findSmallestMissingPositive([1, 2, 3, 4, 5, 6]) 7 >>> findSmallestMissingPositive([2, 3, 7, 6, 8, -1, -10, 15]) 1 >>> findSmallestMissingPositive([1, 1, 1, 1]) 2 >>> findSmallestMissingPositive([]) 1 >>> findSmallestMissingPositive([20, 21, 22, -1, -2]) 1 >>> findSmallestMissingPositive([1, 2, 0]) 3 >>> findSmallestMissingPositive([7, 8, 9, 11, 12]) 1 >>> findSmallestMissingPositive([1, 2, 3, 10, 5, 6, 4, 8, 9]) 7 # Your code here","solution":"def findSmallestMissingPositive(nums): n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"from typing import List def longest_ones(nums: List[int]) -> int: Given a binary array \`nums\`, find the maximum number of consecutive \`1\`s in the array if you can flip at most one \`0\` to a \`1\`. >>> longest_ones([1, 1, 1, 1, 1]) == 5 >>> longest_ones([1, 0, 1, 1, 1]) == 5 >>> longest_ones([0, 1, 1, 1, 1]) == 5 >>> longest_ones([1, 1, 1, 1, 0]) == 5 >>> longest_ones([1, 0, 1, 0, 1, 1]) == 4 >>> longest_ones([0, 0, 0, 0, 0]) == 1 >>> longest_ones([1, 0, 1, 0, 1]) == 3 >>> longest_ones([1]) == 1 >>> longest_ones([0]) == 1","solution":"from typing import List def longest_ones(nums: List[int]) -> int: left = 0 max_ones = 0 zero_count = 0 for right in range(len(nums)): if nums[right] == 0: zero_count += 1 while zero_count > 1: if nums[left] == 0: zero_count -= 1 left += 1 max_ones = max(max_ones, right - left + 1) return max_ones"},{"question":"def subarray_sum(nums: List[int], k: int) -> int: Return the number of subarrays whose elements sum up to \`k\`. Args: nums (list of int): List of integers. k (int): The target sum. Returns: int: Number of subarrays whose sum is k. Examples: >>> subarray_sum([1, 2, 3], 3) 2 >>> subarray_sum([1, -1, 1], 1) 3 >>> subarray_sum([1, 2, -1, 2, -1], 100) 0 >>> subarray_sum([3], 3) 1 >>> subarray_sum([3], 1) 0 >>> subarray_sum([1, 2, 1, 2, 1], 3) 4 >>> subarray_sum([1, 1, 1, 1], 2) 3","solution":"def subarray_sum(nums, k): Returns the number of subarrays whose sum is equal to k. Args: nums (list of int): List of integers. k (int): The target sum. Returns: int: Number of subarrays whose sum is k. count = 0 current_sum = 0 prefix_sums = {0: 1} # Initialize with 0 sum having one occurrence. for num in nums: current_sum += num if (current_sum - k) in prefix_sums: count += prefix_sums[current_sum - k] # Add the number of times the (current_sum - k) has occurred. if current_sum in prefix_sums: prefix_sums[current_sum] += 1 else: prefix_sums[current_sum] = 1 return count"},{"question":"[Completion Task in Python] def is_unique(s: str) -> bool: Returns True if the string has all unique characters, False otherwise. >>> is_unique(\\"abcdef\\") True >>> is_unique(\\"\\") True >>> is_unique(\\"aabbcc\\") False >>> is_unique(\\"abcdea\\") False >>> is_unique(\\"AaBbCc\\") True >>> is_unique(\\"AaBbCcAa\\") False >>> is_unique(\\"!@# %^&*()\\") True >>> is_unique(\\"!@# %^&*()!)\\") False","solution":"def is_unique(s: str) -> bool: Returns True if the string has all unique characters, False otherwise. return len(set(s)) == len(s)"},{"question":"from typing import List def getCombinations(arr: List[int], targetSum: int) -> List[List[int]]: Returns all unique combinations of numbers from arr that sum up to targetSum. Each number in arr can be used multiple times in any combination. The combinations should be returned as a list of lists, and can be in any order. >>> getCombinations([2, 3, 6, 7], 7) == [[2, 2, 3], [7]] >>> getCombinations([2, 3, 5], 8) == [[2, 2, 2, 2], [2, 3, 3], [3, 5]] >>> getCombinations([2, 4, 6], 1) == [] >>> getCombinations([3], 9) == [[3, 3, 3]] >>> getCombinations([3, 2, 5], 8) == [[2, 2, 2, 2], [2, 3, 3], [3, 5]] >>> getCombinations([1, 2], 4) == [[1, 1, 1, 1], [1, 1, 2], [2, 2]]","solution":"def getCombinations(arr, targetSum): Returns all unique combinations of numbers from arr that sum up to targetSum. Each number in arr can be used multiple times in any combination. Combinations are returned as a list of lists. def backtrack(start, target, path, result): if target == 0: result.append(list(path)) return if target < 0: return for i in range(start, len(arr)): path.append(arr[i]) backtrack(i, target - arr[i], path, result) path.pop() result = [] arr.sort() backtrack(0, targetSum, [], result) return result"},{"question":"def count_chars(words: List[str], chars: str) -> int: Returns the sum of lengths of all formable strings in words. A string is considered formable if it can be formed by characters from chars, using each character at most once. >>> count_chars([\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"], \\"atach\\") == 6 >>> count_chars([\\"hello\\", \\"world\\"], \\"abc\\") == 0 >>> count_chars([\\"a\\", \\"aa\\", \\"aaa\\"], \\"aaaaaa\\") == 6 >>> count_chars([\\"dog\\", \\"cat\\", \\"bat\\"], \\"dagbocadtb\\") == 9 >>> count_chars([], \\"abc\\") == 0 >>> count_chars([\\"abc\\", \\"def\\"], \\"\\") == 0 >>> count_chars([\\"aa\\", \\"bb\\", \\"cc\\"], \\"aabbc\\") == 4","solution":"def count_chars(words, chars): Returns the sum of lengths of all formable strings in words. A string is considered formable if it can be formed by characters from chars, using each character at most once. from collections import Counter chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) if all(word_count[char] <= chars_count[char] for char in word_count): total_length += len(word) return total_length"},{"question":"def min_deletions(s: str) -> int: Returns the minimum number of operations required to delete all characters from the string. Each operation consists of choosing a character from the string and deleting all occurrences of it. Parameters: s (str): The input string containing only lowercase English letters. Returns: int: The minimum number of operations required. >>> min_deletions('abcdef') == 6 >>> min_deletions('aaaa') == 1 >>> min_deletions('ababcd') == 4 >>> min_deletions('') == 0 >>> min_deletions('abcabcabc') == 3 >>> min_deletions('xyzxyzxyz') == 3","solution":"def min_deletions(s): Returns the minimum number of operations required to delete all characters from the string. Each operation consists of choosing a character from the string and deleting all occurrences of it. Parameters: s (str): The input string containing only lowercase English letters. Returns: int: The minimum number of operations required. # Convert the string into a set to count the unique characters unique_characters = set(s) # The number of unique characters is the minimum number of operations required return len(unique_characters)"},{"question":"def minimize_absolute_differences(nums: List[int]) -> List[int]: Rearrange the array 'nums' such that the sum of the absolute differences between every two consecutive elements is minimized. >>> minimize_absolute_differences([1, 3, 2, 4]) [4, 1, 3, 2] >>> minimize_absolute_differences([1, 3, 2]) [3, 1, 2] >>> minimize_absolute_differences([2, 2, 2]) [2, 2, 2] >>> minimize_absolute_differences([5]) [5] >>> minimize_absolute_differences([3, 8]) [8, 3] >>> minimize_absolute_differences([1, 2, 3, 4, 5]) [5, 1, 4, 2, 3]","solution":"def minimize_absolute_differences(nums): Rearranges the array 'nums' such that the sum of the absolute differences between every two consecutive elements is minimized. nums.sort() n = len(nums) result = [] for i in range(n // 2): result.append(nums[n-1-i]) result.append(nums[i]) if n % 2 != 0: result.append(nums[n//2]) return result if len(result) == n else result[::-1] # handle even lengths reversal"},{"question":"def count_shorter_students(heights): Given a list of \`heights\` representing the height of each student standing in a line, return a list of integers where each integer denotes the number of students in front of that student who are shorter than them. The list of integers should be returned in the same order as the initial list of \`heights\`. >>> count_shorter_students([5, 3, 4, 6, 2]) [0, 0, 1, 3, 0] >>> count_shorter_students([3, 3, 3, 3]) [0, 0, 0, 0] >>> count_shorter_students([1, 2, 3, 4, 5]) [0, 1, 2, 3, 4] >>> count_shorter_students([5, 4, 3, 2, 1]) [0, 0, 0, 0, 0] >>> count_shorter_students([2, 5, 1, 3, 4]) [0, 1, 0, 2, 3] >>> count_shorter_students([1]) [0] >>> count_shorter_students([2, 1]) [0, 0] >>> count_shorter_students([1, 2]) [0, 1]","solution":"def count_shorter_students(heights): Returns a list of integers where each integer denotes the number of students in front of that student who are shorter than them. :param heights: List[int] :return: List[int] result = [] for i in range(len(heights)): count = 0 for j in range(0, i): if heights[j] < heights[i]: count += 1 result.append(count) return result"},{"question":"def calculate(s: str) -> int: Evaluate the arithmetic expression given in string form and return the result as an integer. >>> calculate(\\"1+2\\") == 3 >>> calculate(\\" 3 + 2 \\") == 5 >>> calculate(\\"3+2*2\\") == 7 >>> calculate(\\"6/3\\") == 2 >>> calculate(\\" 3/2 \\") == 1 >>> calculate(\\" 3+5 / 2 \\") == 5 >>> calculate(\\" 2+3*4/2-1 \\") == 7 >>> calculate(\\" 5-10/2 \\") == 0","solution":"def calculate(s: str) -> int: Evaluate the arithmetic expression given in string form and return the result as an integer. s = s.replace(' ', '') def evaluate(tokens): stack = [] num = 0 sign = '+' for i, token in enumerate(tokens): if token.isdigit(): num = num * 10 + int(token) if token in '+-*/' or i == len(tokens) - 1: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack.append(stack.pop() * num) elif sign == '/': stack.append(int(stack.pop() / num)) # use int() to truncate toward zero sign = token num = 0 return sum(stack) return evaluate(s)"},{"question":"from typing import List from collections import Counter def check_inclusion(s: str, p: str) -> bool: Determine if s contains a substring that is an anagram of p. >>> check_inclusion(\\"cbaebabacd\\", \\"abc\\") True >>> check_inclusion(\\"abcdefg\\", \\"hij\\") False pass def test_example_case(): assert check_inclusion(\\"cbaebabacd\\", \\"abc\\") == True def test_no_anagram_present(): assert check_inclusion(\\"abcdefg\\", \\"hij\\") == False def test_anagram_at_start(): assert check_inclusion(\\"abccba\\", \\"abc\\") == True def test_anagram_at_end(): assert check_inclusion(\\"cbacbab\\", \\"abc\\") == True def test_anagram_in_middle(): assert check_inclusion(\\"xyzabccbaabc\\", \\"abc\\") == True def test_empty_string_s(): assert check_inclusion(\\"\\", \\"abc\\") == False def test_empty_string_p(): assert check_inclusion(\\"abc\\", \\"\\") == True def test_both_empty_strings(): assert check_inclusion(\\"\\", \\"\\") == True def test_same_length_no_anagram(): assert check_inclusion(\\"abcd\\", \\"bcde\\") == False def test_same_length_with_anagram(): assert check_inclusion(\\"abcd\\", \\"dcba\\") == True","solution":"from collections import Counter def check_inclusion(s, p): Check if any permutation of p is a substring in s. len_s, len_p = len(s), len(p) if len_p > len_s: return False p_counter = Counter(p) s_counter = Counter(s[:len_p]) if s_counter == p_counter: return True for i in range(len_p, len_s): s_counter[s[i]] += 1 start_char = s[i - len_p] s_counter[start_char] -= 1 if s_counter[start_char] == 0: del s_counter[start_char] if s_counter == p_counter: return True return False"},{"question":"def max_profit(arr): Returns the maximum profit that can be achieved by buying and selling the stock only once. >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([5, 4, 3, 2, 1]) 0 >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([]) 0 >>> max_profit([7]) 0 >>> max_profit([9, 7, 5, 3, 1]) 0 >>> max_profit([3, 10, 9, 1, 6]) 7","solution":"def max_profit(arr): Returns the maximum profit that can be achieved by buying and selling the stock only once. if not arr or len(arr) < 2: return 0 min_price = arr[0] max_profit = 0 for price in arr[1:]: if price < min_price: min_price = price else: max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"def binary_to_int(binary_str: str) -> int: Convert a binary string to an integer. >>> binary_to_int(\\"1101\\") == 13 >>> binary_to_int(\\"0100\\") == 4 # Implementation here def max_xor_of_two_binaries(binaries: List[str]) -> int: Finds the maximum XOR value between any two binary numbers from the list. >>> max_xor_of_two_binaries([\\"1010\\", \\"0101\\"]) == 15 >>> max_xor_of_two_binaries([\\"0000\\", \\"1111\\", \\"0101\\"]) == 15 >>> max_xor_of_two_binaries([\\"1111\\", \\"1111\\", \\"0000\\"]) == 15 >>> max_xor_of_two_binaries([\\"0000\\", \\"0110\\", \\"0011\\", \\"1001\\"]) == 15 >>> max_xor_of_two_binaries([\\"0000\\", \\"0000\\"]) == 0 >>> max_xor_of_two_binaries([\\"001\\", \\"111\\"]) == 6 >>> max_xor_of_two_binaries([\\"1101\\", \\"0100\\", \\"1001\\"]) == 13 # Implementation here","solution":"def binary_to_int(binary_str): Convert a binary string to an integer. return int(binary_str, 2) def max_xor_of_two_binaries(binaries): Finds the maximum XOR value between any two binary numbers from the list. max_xor = 0 num_ints = [binary_to_int(b) for b in binaries] for i in range(len(num_ints)): for j in range(i + 1, len(num_ints)): current_xor = num_ints[i] ^ num_ints[j] if current_xor > max_xor: max_xor = current_xor return max_xor"},{"question":"from heapq import heappush, heappop from collections import Counter def reorganize_string(s: str) -> str: Determine if you can reorder the characters in \`s\` to form a string where no two adjacent characters are the same. If possible, return the new reorganized string. If not possible, return an empty string. >>> reorganize_string(\\"aab\\") in [\\"aba\\"] True >>> reorganize_string(\\"aaab\\") '' >>> reorganize_string(\\"a\\") 'a' >>> reorganize_string(\\"aaaa\\") '' >>> output = reorganize_string(\\"aaabbc\\") >>> len(output) == len(\\"aaabbc\\") True >>> all(output[i] != output[i-1] for i in range(1, len(output))) True >>> reorganize_string(\\"\\") == \\"\\" True >>> reorganize_string(\\"ab\\") in [\\"ab\\", \\"ba\\"] True >>> reorganize_string(\\"aa\\") ''","solution":"from collections import Counter import heapq def reorganize_string(s): Determine if you can reorder the characters in \`s\` to form a string where no two adjacent characters are the same. If possible, return the new reorganized string. If not possible, return an empty string. # Step 1: Count the frequency of each character char_count = Counter(s) # Step 2: Create a max heap based on the character frequency max_heap = [(-freq, char) for char, freq in char_count.items()] heapq.heapify(max_heap) # Step 3: Try to build the result string result = [] prev_freq, prev_char = 0, '' while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) # If there was a previous character, add it back if it still has a remaining count if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Update prev_freq and prev_char for the next round prev_freq, prev_char = freq + 1, char result_str = ''.join(result) # If the reorganized string length is equal to the original string length, return it if len(result_str) == len(s): return result_str else: return \\"\\""},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTreeIterator: def __init__(self, root: TreeNode): Initializes the iterator with the root of the binary tree. def next(self) -> int: Returns the next smallest number in the tree. def hasNext(self) -> bool: Returns true if there are still nodes to traverse, otherwise returns false. # Unit Test def test_binary_tree_iterator(): # Constructing the tree: # 7 # / # 3 15 # / # 9 20 root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) iterator = BinaryTreeIterator(root) assert iterator.hasNext() == True assert iterator.next() == 3 assert iterator.hasNext() == True assert iterator.next() == 7 assert iterator.hasNext() == True assert iterator.next() == 9 assert iterator.hasNext() == True assert iterator.next() == 15 assert iterator.hasNext() == True assert iterator.next() == 20 assert iterator.hasNext() == False def test_single_node(): root = TreeNode(1) iterator = BinaryTreeIterator(root) assert iterator.hasNext() == True assert iterator.next() == 1 assert iterator.hasNext() == False def test_empty_tree(): iterator = BinaryTreeIterator(None) assert iterator.hasNext() == False def test_right_skewed_tree(): # Constructing the tree: # 1 # # 2 # # 3 root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) iterator = BinaryTreeIterator(root) assert iterator.hasNext() == True assert iterator.next() == 1 assert iterator.hasNext() == True assert iterator.next() == 2 assert iterator.hasNext() == True assert iterator.next() == 3 assert iterator.hasNext() == False def test_left_skewed_tree(): # Constructing the tree: # 3 # / # 2 #/ #1 root = TreeNode(3) root.left = TreeNode(2) root.left.left = TreeNode(1) iterator = BinaryTreeIterator(root) assert iterator.hasNext() == True assert iterator.next() == 1 assert iterator.hasNext() == True assert iterator.next() == 2 assert iterator.hasNext() == True assert iterator.next() == 3 assert iterator.hasNext() == False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTreeIterator: def __init__(self, root: TreeNode): self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def next(self) -> int: # Pop the top element from the stack topmost_node = self.stack.pop() # If the node has a right child, we push all the nodes from the right child's left subtree onto the stack if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val def hasNext(self) -> bool: return len(self.stack) > 0"},{"question":"def search_matrix(matrix: List[List[int]], target: int) -> bool: Determines if \`target\` is in \`matrix\`. >>> search_matrix([ ... [1, 3, 5, 7], ... [10, 11, 16, 20], ... [23, 30, 34, 60] ... ], 3) == True >>> search_matrix([ ... [1, 3, 5, 7], ... [10, 11, 16, 20], ... [23, 30, 34, 60] ... ], 8) == False >>> search_matrix([], 1) == False >>> search_matrix([[5]], 5) == True >>> search_matrix([[5]], 1) == False","solution":"def search_matrix(matrix, target): Determines if the target is present in the given matrix. :param matrix: List[List[int]] - 2D matrix of integers :param target: int - the target number to search for :return: bool - True if target is found, False otherwise if not matrix or not matrix[0]: return False m, n = len(matrix), len(matrix[0]) left, right = 0, m * n - 1 while left <= right: mid = (left + right) // 2 mid_value = matrix[mid // n][mid % n] if mid_value == target: return True elif mid_value < target: left = mid + 1 else: right = mid - 1 return False"},{"question":"def is_valid_code_snippet(s: str) -> bool: Given a string \`s\` representing a code snippet, decide if it contains valid usage of parentheses, brackets, and braces. Open brackets must be closed in the correct order. Each close bracket must match the type of the most recent unmatched open bracket of the same type. Return \`true\` if the string contains valid bracket usage and \`false\` otherwise. Note that an empty string is considered valid. >>> is_valid_code_snippet(\\"\\") == True >>> is_valid_code_snippet(\\"()\\") == True >>> is_valid_code_snippet(\\"[]\\") == True >>> is_valid_code_snippet(\\"{}\\") == True >>> is_valid_code_snippet(\\"(\\") == False >>> is_valid_code_snippet(\\")\\") == False >>> is_valid_code_snippet(\\"[\\") == False >>> is_valid_code_snippet(\\"]\\") == False >>> is_valid_code_snippet(\\"{\\") == False >>> is_valid_code_snippet(\\"}\\") == False >>> is_valid_code_snippet(\\"({[]})\\") == True >>> is_valid_code_snippet(\\"({[}])\\") == False >>> is_valid_code_snippet(\\"({[]})}\\") == False >>> is_valid_code_snippet(\\"{[()]}\\") == True >>> is_valid_code_snippet(\\"{[()({})]}\\") == True >>> is_valid_code_snippet(\\"{[(])}\\") == False >>> is_valid_code_snippet(\\"(a + b) * {c / [d - e]}\\") == True >>> is_valid_code_snippet(\\"function call(arg1, arg2) { return [1, 2, 3]; }\\") == True >>> is_valid_code_snippet(\\"(a + b) * {c / [d - e]\\") == False","solution":"def is_valid_code_snippet(s): Checks if the given code snippet (string) has valid usage of parentheses, brackets, and braces. Args: s (str): Code snippet to check. Returns: bool: True if the code snippet is valid, False otherwise. stack = [] matching_brackets = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_brackets.values(): stack.append(char) elif char in matching_brackets.keys(): if stack == [] or matching_brackets[char] != stack.pop(): return False return stack == []"},{"question":"from typing import List def findOrder(numCourses: int, prerequisites: List[List[int]]) -> List[int]: Returns the ordering of courses you should take to finish all courses. If it is impossible to finish all courses, return an empty array. def test_valid_schedule_1(): assert findOrder(2, [[1, 0]]) == [0, 1] def test_valid_schedule_2(): order = findOrder(4, [[1, 0], [2, 0], [3, 1], [3, 2]]) assert order == [0, 1, 2, 3] or order == [0, 2, 1, 3] def test_no_prerequisites(): assert findOrder(3, []) == [0, 1, 2] or findOrder(3, []) == [0, 2, 1] or findOrder(3, []) == [1, 0, 2] or findOrder(3, []) == [1, 2, 0] or findOrder(3, []) == [2, 0, 1] or findOrder(3, []) == [2, 1, 0] def test_invalid_schedule_1(): assert findOrder(2, [[1, 0], [0, 1]]) == [] def test_invalid_schedule_2(): assert findOrder(3, [[0, 1], [1, 2], [2, 0]]) == [] def test_multiple_valid_schedules(): order = findOrder(3, [[1, 0], [2, 0]]) assert order == [0, 1, 2] or order == [0, 2, 1] def test_single_course(): assert findOrder(1, []) == [0]","solution":"from collections import defaultdict, deque def findOrder(numCourses, prerequisites): Returns the ordering of courses you should take to finish all courses. If it is impossible to finish all courses, return an empty array. # Create a graph and a degree array graph = defaultdict(list) indegree = [0] * numCourses # Build the graph and populate the indegree array for dest, src in prerequisites: graph[src].append(dest) indegree[dest] += 1 # Find all the starting nodes with no dependencies (indegree 0) queue = deque([i for i in range(numCourses) if indegree[i] == 0]) topo_order = [] # Process the nodes while queue: node = queue.popleft() topo_order.append(node) # Decrease the indegree of each neighbor for neighbor in graph[node]: indegree[neighbor] -= 1 # If the indegree becomes 0, add it to the queue if indegree[neighbor] == 0: queue.append(neighbor) # If topological order contains all the courses, return it if len(topo_order) == numCourses: return topo_order else: return []"},{"question":"def subarray_sum(arr: List[int], sum: int) -> int: Given an integer array \`arr\` and an integer \`sum\`, find the total number of continuous subarrays whose elements sum up to \`sum\`. :param arr: List[int] - The input array of integers :param sum: int - The target sum for the subarrays :return: int - The count of continuous subarrays summing up to sum >>> subarray_sum([1, 2, 3], 10) == 0 >>> subarray_sum([5], 5) == 1 >>> subarray_sum([5], 10) == 0 >>> subarray_sum([1, 1, 1], 2) == 2 >>> subarray_sum([1, 2, 3], 6) == 1 >>> subarray_sum([1, -1, 1, -1], 0) == 4 >>> subarray_sum([3, 4, -7, 1, 3, 3, 1, -4], 7) == 4 >>> subarray_sum([1] * 1000, 2) == 999","solution":"def subarray_sum(arr, target): Finds the total number of continuous subarrays whose elements sum up to target. :param arr: List[int] - The input array of integers :param target: int - The target sum for the subarrays :return: int - The count of continuous subarrays summing up to target count = 0 current_sum = 0 prefix_sum = {0: 1} # Prefix sum dictionary to store sum frequencies for num in arr: current_sum += num if (current_sum - target) in prefix_sum: count += prefix_sum[current_sum - target] if current_sum in prefix_sum: prefix_sum[current_sum] += 1 else: prefix_sum[current_sum] = 1 return count"},{"question":"def min_removals_to_non_decreasing_heights(heights: List[int]) -> int: Returns the minimum number of students who need to be removed so that the remaining students' heights form a non-decreasing sequence. Args: heights (list of int): List of students' heights. Returns: int: Minimum number of removals required. pass # Unit tests def test_min_removals_to_non_decreasing_heights(): assert min_removals_to_non_decreasing_heights([1, 3, 2, 4, 5]) == 1 assert min_removals_to_non_decreasing_heights([5, 4, 3, 2, 1]) == 4 assert min_removals_to_non_decreasing_heights([1, 2, 3, 4, 5]) == 0 assert min_removals_to_non_decreasing_heights([2, 2, 2, 2, 2]) == 0 assert min_removals_to_non_decreasing_heights([5, 1, 3, 2, 4]) == 2 assert min_removals_to_non_decreasing_heights([7, 8, 9, 1, 2, 3]) == 3 assert min_removals_to_non_decreasing_heights([5]) == 0 assert min_removals_to_non_decreasing_heights([]) == 0","solution":"def min_removals_to_non_decreasing_heights(heights): Returns the minimum number of students who need to be removed so that the remaining students' heights form a non-decreasing sequence. Args: heights (list of int): List of students' heights. Returns: int: Minimum number of removals required. if not heights: return 0 n = len(heights) # Length of the longest increasing subsequence (LIS) lis = [1] * n for i in range(1, n): for j in range(0, i): if heights[i] >= heights[j]: lis[i] = max(lis[i], lis[j] + 1) # The minimum removals needed is the total number of students minus # the length of the longest increasing subsequence return n - max(lis)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): Given a linked list, reverse the linked list in groups of \`k\` and return the modified list. \`k\` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes in the last group is less than \`k\`, leave them as it is. >>> head = list_to_linked_list([1, 2, 3, 4, 5, 6, 7, 8]) >>> k = 3 >>> result = reverseKGroup(head, k) >>> linked_list_to_list(result) [3, 2, 1, 6, 5, 4, 7, 8] >>> head = list_to_linked_list([1, 2, 3, 4, 5]) >>> k = 2 >>> result = reverseKGroup(head, k) >>> linked_list_to_list(result) [2, 1, 4, 3, 5]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverseLinkedList(head, k): new_head, ptr = None, head while k > 0: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head count = 0 ptr = head while count < k and ptr: ptr = ptr.next count += 1 if count == k: reversed_head = reverseLinkedList(head, k) head.next = reverseKGroup(ptr, k) return reversed_head return head"},{"question":"def longest_palindromic_subarray_length(arr: List[int]) -> int: Returns the length of the longest palindromic subarray. A subarray is defined as a segment of consecutive elements. A subarray is palindromic if it reads the same forward and backward. If there are multiple palindromic subarrays of the same length, return the length of the first one that appears. >>> longest_palindromic_subarray_length([1, 2, 3, 2, 1, 6, 7, 6]) 5 >>> longest_palindromic_subarray_length([1]) 1 >>> longest_palindromic_subarray_length([]) 0 >>> longest_palindromic_subarray_length([1, 2, 3, 4, 5]) 1 >>> longest_palindromic_subarray_length([1, 2, 3, 3, 2, 1]) 6","solution":"def longest_palindromic_subarray_length(arr): Returns the length of the longest palindromic subarray. n = len(arr) if n == 0: return 0 max_length = 1 # Minimum length of a palindrome subarray is 1 (single element) start = 0 for i in range(n): # Odd length palindromes centered at arr[i] low, high = i, i while low >= 0 and high < n and arr[low] == arr[high]: current_length = high - low + 1 if current_length > max_length: max_length = current_length start = low low -= 1 high += 1 # Even length palindromes centered at arr[i] and arr[i+1] low, high = i, i + 1 while low >= 0 and high < n and arr[low] == arr[high]: current_length = high - low + 1 if current_length > max_length: max_length = current_length start = low low -= 1 high += 1 return max_length"},{"question":"def rotateString(s: str, goal: str) -> bool: Returns True if and only if \`s\` can become \`goal\` after some number of shifts on \`s\`. >>> rotateString(\\"abcde\\", \\"abcde\\") == True >>> rotateString(\\"abcde\\", \\"bcdea\\") == True >>> rotateString(\\"abcde\\", \\"cdeab\\") == True >>> rotateString(\\"abcde\\", \\"abced\\") == False >>> rotateString(\\"abcde\\", \\"abcd\\") == False >>> rotateString(\\"\\", \\"\\") == True >>> rotateString(\\"\\", \\"a\\") == False >>> rotateString(\\"a\\", \\"\\") == False >>> rotateString(\\"aab\\", \\"baa\\") == True >>> rotateString(\\"abcabcabcabc\\", \\"bcabcabcabca\\") == True >>> rotateString(\\"abcabcabcabc\\", \\"cbabcabcabca\\") == False pass","solution":"def rotateString(s, goal): Returns True if and only if \`s\` can become \`goal\` after some number of shifts on \`s\`. return len(s) == len(goal) and goal in (s + s)"},{"question":"from typing import List def minimum_effort_path(grid: List[List[int]]) -> int: Returns the minimum effort required to navigate from the top-left to the bottom-right corner of the grid ensuring the maximum allowed absolute difference in altitude between two consecutive points in the path is minimized. >>> minimum_effort_path([[1,2,2],[3,8,2],[5,3,5]]) == 2 >>> minimum_effort_path([[1,2,3,4,5]]) == 1 >>> minimum_effort_path([[1,1,1],[1,1,1],[1,1,1]]) == 0 >>> minimum_effort_path([[7]]) == 0 >>> minimum_effort_path([[1,2,3],[3,8,4],[5,3,5]]) == 1","solution":"from heapq import heappush, heappop def minimum_effort_path(grid): Returns the minimum effort required to navigate from the top-left to the bottom-right corner of the grid ensuring the maximum allowed absolute difference in altitude between two consecutive points in the path is minimized. rows, cols = len(grid), len(grid[0]) efforts = [[float('inf')] * cols for _ in range(rows)] efforts[0][0] = 0 min_heap = [(0, 0, 0)] # (effort, x, y) # Directions for right, down, left, and up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while min_heap: current_effort, x, y = heappop(min_heap) if x == rows - 1 and y == cols - 1: return current_effort for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols: new_effort = max(current_effort, abs(grid[nx][ny] - grid[x][y])) if new_effort < efforts[nx][ny]: efforts[nx][ny] = new_effort heappush(min_heap, (new_effort, nx, ny))"},{"question":"from typing import List def trap(height: List[int]) -> int: Given an array of integers representing the height of rainwater bars, calculate the maximum amount of water that can be trapped after raining. The array's elements represent the height of the bars. Water can only be trapped between bars, and each bar must be able to hold water on top of it. The amount of water trapped between the bars is determined by the smaller of the two heights on either side of the bar, minus the height of the bar itself. Return the maximum amount of water that can be trapped among the bars. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([]) 0 >>> trap([2,1]) 0 >>> trap([3,3,3,3]) 0 >>> trap([1,2,3,4,5]) 0 >>> trap([5,4,3,2,1]) 0 >>> trap([4,2,0,3,2,5]) 9","solution":"def trap(height): Given an array of integers representing the height of rainwater bars, calculate the maximum amount of water that can be trapped after raining. :param height: List[int], array of non-negative integers representing the heights of the bars. :return: int, the maximum amount of water that can be trapped. if not height or len(height) < 3: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] trapped_water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) trapped_water += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) trapped_water += max(0, right_max - height[right]) return trapped_water"},{"question":"def tallest_candles(candles: List[int]) -> int: Returns the number of the tallest candles. >>> tallest_candles([1, 2, 3, 4]) 1 >>> tallest_candles([4, 4, 1, 3]) 2 >>> tallest_candles([5]) 1 >>> tallest_candles([3, 3, 3, 3]) 4 >>> tallest_candles([3, 1, 2, 3, 2, 1, 3]) 3 >>> tallest_candles([]) 0","solution":"def tallest_candles(candles): Returns the number of the tallest candles. if not candles: return 0 tallest_height = max(candles) tallest_count = candles.count(tallest_height) return tallest_count"},{"question":"def minCoins(coins, amount): Returns the minimum number of coins required to make up the given amount. If it's not possible to make up the amount with the given coins, returns -1. Parameters: coins (List[int]): A list of integers representing the coins. amount (int): An integer representing the total amount of money. Returns: int: The minimum number of coins needed to make up the given amount, or -1 if not possible. Examples: >>> minCoins([1, 2, 5], 11) 3 >>> minCoins([2], 3) -1","solution":"def minCoins(coins, amount): Returns the minimum number of coins required to make up the given amount. If it's not possible to make up the amount with the given coins, returns -1. # Initialize the DP array with amount + 1 (a value impossible to reach) dp = [float('inf')] * (amount + 1) dp[0] = 0 # Update the DP array based on the coins available for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) # If dp[amount] has not been updated, return -1 return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"import heapq def last_stone_weight(weights): Compute the weight of the last remaining stone after smashing the two heaviest stones repeatedly. >>> last_stone_weight([5]) 5 >>> last_stone_weight([]) 0 >>> last_stone_weight([2, 2]) 0 >>> last_stone_weight([2, 7, 4, 1, 8, 1]) 1 >>> last_stone_weight([1, 1, 1, 1]) 0 >>> last_stone_weight([10, 4, 2, 10]) 2","solution":"import heapq def last_stone_weight(weights): This function computes the weight of the last remaining stone after smashing the two heaviest stones repeatedly until one or zero stones are left. Args: weights : List[int] : A list containing the weight of the stones. Returns: int : The weight of the last remaining stone or 0 if no stones are left. # Convert all weights to negative to use the min heap property of heapq as max heap. max_heap = [-weight for weight in weights] heapq.heapify(max_heap) while len(max_heap) > 1: # Take out the two largest stones first = -heapq.heappop(max_heap) second = -heapq.heappop(max_heap) if first != second: # If they are not the same, push the difference back into the heap heapq.heappush(max_heap, -(first - second)) return -max_heap[0] if max_heap else 0"},{"question":"from typing import List def canTransform(s: str, t: str, allowedChanges: List[List[str]]) -> bool: Determines if string s can be transformed into string t using the allowed character changes. :param s: Initial string to be transformed :param t: Target string after transformation :param allowedChanges: 2D list of allowed character changes :return: True if s can be transformed into t, else False >>> canTransform(\\"abc\\", \\"abc\\", []) == True >>> canTransform(\\"abc\\", \\"def\\", [['a','d'], ['b','e'], ['c','f']]) == True >>> canTransform(\\"abc\\", \\"def\\", [['a','d'], ['b','e']]) == False >>> canTransform(\\"abc\\", \\"abd\\", [['a','d'], ['b','e'], ['c','d']]) == True >>> canTransform(\\"aaaa\\", \\"bbbb\\", [['a','b']]) == True >>> canTransform(\\"abcd\\", \\"dbca\\", [['a','b'], ['b','c'], ['c','d'], ['d','a']]) == False >>> canTransform(\\"abcd\\", \\"abcd\\", [['a','b'], ['b','c'], ['c','a'], ['c','d']]) == True >>> canTransform(\\"\\", \\"\\", []) == True >>> canTransform(\\"a\\", \\"b\\", [['a', 'b']]) == True >>> canTransform(\\"a\\", \\"b\\", []) == False >>> canTransform(\\"abc\\", \\"def\\", [['a','d'], ['b','e'], ['c','f'], ['d','a'], ['e','b'], ['f','c']]) == True pass","solution":"def canTransform(s, t, allowedChanges): Determines if string s can be transformed into string t using the allowed character changes. :param s: Initial string to be transformed :param t: Target string after transformation :param allowedChanges: 2D list of allowed character changes :return: True if s can be transformed into t, else False # Convert allowedChanges to a dictionary for quick lookup allowed_dict = {} for a, b in allowedChanges: if a not in allowed_dict: allowed_dict[a] = set() allowed_dict[a].add(b) # Check each character in s can be transformed to the corresponding character in t for sc, tc in zip(s, t): if sc != tc and (sc not in allowed_dict or tc not in allowed_dict[sc]): return False return True"},{"question":"from typing import List def combinationSum(nums: List[int], target: int) -> int: Returns the total number of unique combinations from the given list that add up to the target. >>> combinationSum([2, 3, 6, 7], 7) 2 >>> combinationSum([2, 3, 5], 8) 3 >>> combinationSum([3], 9) 1 >>> combinationSum([1, 2, 3], 0) 1 >>> combinationSum([2, 4, 6, 8], 8) 5 >>> combinationSum([5, 10], 3) 0 >>> combinationSum([1], 2) 1","solution":"def combinationSum(nums, target): Returns the total number of unique combinations from the given list that add up to the target. def backtrack(start, remaining): if remaining == 0: return 1 if remaining < 0: return 0 total_combinations = 0 for i in range(start, len(nums)): total_combinations += backtrack(i, remaining - nums[i]) return total_combinations nums.sort() # Sort the numbers to handle duplicates return backtrack(0, target)"},{"question":"def count_substrings_with_n_unique_chars(s: str, n: int) -> int: Given a string \`s\` consisting of lowercase letters and the \`target\` length \`n\`, return the number of substrings of \`s\` that have exactly \`n\` unique characters. If there are no such substrings, return \`0\`. :param s: str: Input string consisting of lowercase letters :param n: int: Target number of unique characters in substrings :return: int: Number of substrings with exactly \`n\` unique characters >>> count_substrings_with_n_unique_chars(\\"\\", 2) == 0 >>> count_substrings_with_n_unique_chars(\\"aaaa\\", 2) == 0 >>> count_substrings_with_n_unique_chars(\\"a\\", 1) == 1 >>> count_substrings_with_n_unique_chars(\\"abac\\", 2) == 4 >>> count_substrings_with_n_unique_chars(\\"abc\\", 3) == 1 >>> count_substrings_with_n_unique_chars(\\"abcdef\\", 10) == 0 >>> count_substrings_with_n_unique_chars(\\"abcdef\\", 1) == 6 >>> count_substrings_with_n_unique_chars(\\"abacad\\", 3) == 6","solution":"def count_substrings_with_n_unique_chars(s, n): Returns the number of substrings of \`s\` that have exactly \`n\` unique characters. :param s: str: Input string consisting of lowercase letters :param n: int: Target number of unique characters in substrings :return: int: Number of substrings with exactly \`n\` unique characters from collections import defaultdict def unique_char_count_in_window(window): return len(set(window)) total_substrings = 0 for start in range(len(s)): char_count = defaultdict(int) unique_chars = 0 for end in range(start, len(s)): char = s[end] if char_count[char] == 0: unique_chars += 1 char_count[char] += 1 if unique_chars == n: total_substrings += 1 elif unique_chars > n: break return total_substrings"},{"question":"def max_complete_towers(heights, k, m): Determine the maximum number of complete towers that remain after removing a total of \`m\` height units from the towers. Each removal reduces the height of a tower by \`k\` units. Parameters: heights (list of ints): Heights of the towers. k (int): Height of blocks that can be removed each time. m (int): Total height units to remove. Returns: int: The maximum number of complete towers remaining. pass # Unit tests def test_max_complete_towers_basic(): assert max_complete_towers([10, 15, 20], 5, 10) == 3 def test_max_complete_towers_empty(): assert max_complete_towers([], 5, 10) == 0 def test_max_complete_towers_all_reduce_completely(): assert max_complete_towers([5, 5, 5], 5, 15) == 0 def test_max_complete_towers_no_removals(): assert max_complete_towers([10, 15, 20], 5, 0) == 3 def test_max_complete_towers_partial_removal(): assert max_complete_towers([18, 22, 10], 7, 14) == 3 def test_max_complete_towers_zero_height_towers(): assert max_complete_towers([0, 10, 10], 5, 5) == 2 def test_max_complete_towers_partial_heights(): assert max_complete_towers([15, 22, 10], 4, 18) == 3 def test_max_complete_towers_all_removed(): assert max_complete_towers([4, 8, 12], 4, 24) == 0","solution":"def max_complete_towers(heights, k, m): Determine the maximum number of complete towers that remain after removing a total of \`m\` height units from the towers. Each removal reduces the height of a tower by \`k\` units. Parameters: heights (list of ints): Heights of the towers. k (int): Height of blocks that can be removed each time. m (int): Total height units to remove. Returns: int: The maximum number of complete towers remaining. heights.sort(reverse=True) # Sorting to maximize the number of full towers kept for i in range(len(heights)): while m >= k and heights[i] >= k: heights[i] -= k m -= k return sum(1 for height in heights if height > 0)"},{"question":"def count_brick_patterns(wall: str, k: int) -> int: Returns the maximum number of non-overlapping perfectly aligned brick patterns of length \`k\` that can fit into the wall string. Parameters: wall (str): A string consisting of 'B' and '.'. k (int): The length of the brick pattern. Returns: int: Maximum number of non-overlapping brick patterns of length \`k\`. >>> count_brick_patterns(\\"BBBBB\\", 2) == 2 >>> count_brick_patterns(\\"BBBBBBB\\", 3) == 2 >>> count_brick_patterns(\\"B.B.B.B.B\\", 1) == 5 >>> count_brick_patterns(\\"B...BB.B.\\", 2) == 1 >>> count_brick_patterns(\\"B.B.\\", 2) == 0 >>> count_brick_patterns(\\"....\\", 1) == 0 >>> count_brick_patterns(\\"BBB.BBB.BBB\\", 3) == 3 >>> count_brick_patterns(\\"BB.BB.BB\\", 2) == 3 >>> count_brick_patterns(\\"\\", 1) == 0 >>> count_brick_patterns(\\"B\\", 1) == 1 >>> count_brick_patterns(\\"BB\\", 2) == 1 >>> count_brick_patterns(\\"B.\\", 1) == 1 >>> count_brick_patterns(\\".B\\", 1) == 1","solution":"def count_brick_patterns(wall, k): Returns the maximum number of non-overlapping perfectly aligned brick patterns of length \`k\` that can fit into the wall string. Parameters: wall (str): A string consisting of 'B' and '.'. k (int): The length of the brick pattern. Returns: int: Maximum number of non-overlapping brick patterns of length \`k\`. count = 0 i = 0 while i <= len(wall) - k: if wall[i:i+k] == 'B' * k: count += 1 i += k # Skip past this pattern to avoid overlap else: i += 1 return count"},{"question":"def max_gold(nums, k): Returns the maximum sum of gold collected from exactly k mines. Parameters: nums (List[int]): List of integers representing the amount of gold in each mine. k (int): The number of contiguous mines to visit. Returns: int: The maximum sum of gold collected from exactly k mines. Examples: >>> max_gold([1, 2, 3, 4, 5], 3) == 12 >>> max_gold([1, -2, 3, 4, -1, 2, 1, -5, 4], 4) == 8 >>> max_gold([-1, -2, -3, -4, -5], 2) == -3 >>> max_gold([5], 1) == 5 >>> max_gold([1, 2, 3, 4, 5], 5) == 15 >>> max_gold([1, 2, 3], 5) == 0 >>> max_gold([0, 0, 0, 0], 2) == 0 >>> max_gold([0, 1, 2, 3, 4], 3) == 9","solution":"def max_gold(nums, k): Returns the maximum sum of gold collected from exactly k mines. Parameters: nums (List[int]): List of integers representing the amount of gold in each mine. k (int): The number of contiguous mines to visit. Returns: int: The maximum sum of gold collected from exactly k mines. n = len(nums) if n < k: return 0 # Compute sum of the first k elements max_sum = current_sum = sum(nums[:k]) # Use sliding window technique to find the maximum sum of any k contiguous elements for i in range(k, n): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def findUnique(arr: List[int]) -> int: Returns the element that appears only once in the array. Args: arr (list): List of integers where every element appears twice except one element which appears once. Returns: int: The unique element. >>> findUnique([1, 2, 2, 3, 1]) 3 >>> findUnique([4, 1, 2, 1, 2]) 4 >>> findUnique([-1, -2, -2, -3, -1]) -3 >>> findUnique([1000000, 500000, 1000000, 500000, 999999]) 999999 >>> findUnique([10, 20, 20, 30, 10, 40, 50, 40, 50]) 30","solution":"def findUnique(arr): Returns the element that appears only once in the array. Args: arr (list): List of integers where every element appears twice except one element which appears once. Returns: int: The unique element. # Utilizing XOR property: n ^ n = 0 and n ^ 0 = n unique = 0 for num in arr: unique ^= num return unique"},{"question":"from typing import List def visible_buildings(height: List[int]) -> List[List[int]]: Returns a list of lists where the i-th list contains the indices of all buildings that the i-th building can see, ordered by distance from the i-th building. Args: height (List[int]): A list of integers representing the heights of buildings. Returns: List[List[int]]: A list of lists where the i-th list contains the indices of all buildings that the i-th building can see. Example: >>> visible_buildings([3, 3, 3]) [[], [], []] >>> visible_buildings([1, 2, 3]) [[1, 2], [2], []] >>> visible_buildings([3, 2, 1]) [[], [], []] >>> visible_buildings([2, 1, 3, 4, 2]) [[2, 3], [2, 3], [3], [], []] >>> visible_buildings([1, 2, 1, 4, 3]) [[1, 3], [3], [3], [], []] >>> visible_buildings([]) [] >>> visible_buildings([1]) [[]] >>> visible_buildings([1, 3, 2, 4, 3, 5]) [[1, 3, 5], [3, 5], [3, 5], [5], [5], []]","solution":"def visible_buildings(height): Returns a list of lists where the i-th list contains the indices of all buildings that the i-th building can see, ordered by distance from the i-th building. result = [] n = len(height) for i in range(n): can_see = [] max_height = -1 for j in range(i + 1, n): if height[j] > height[i] and height[j] > max_height: can_see.append(j) max_height = height[j] result.append(can_see) return result"},{"question":"def smallest_valid_substring(s: str, x: int) -> int: Returns the length of the smallest valid substring that contains at least x distinct characters. If no valid substring exists, return -1. >>> smallest_valid_substring(\\"abcde\\", 3) 3 >>> smallest_valid_substring(\\"aaabbb\\", 3) -1 >>> smallest_valid_substring(\\"abcdef\\", 6) 6 >>> smallest_valid_substring(\\"a\\", 1) 1 >>> smallest_valid_substring(\\"abc\\", 5) -1 >>> smallest_valid_substring(\\"abaccc\\", 2) 2 >>> smallest_valid_substring(\\"aaaa\\", 1) 1","solution":"def smallest_valid_substring(s, x): Returns the length of the smallest valid substring that contains at least x distinct characters. If no valid substring exists, return -1. if x > len(s): return -1 n = len(s) min_length = float('inf') for i in range(n): distinct_chars = set() for j in range(i, n): distinct_chars.add(s[j]) if len(distinct_chars) >= x: min_length = min(min_length, j - i + 1) break return -1 if min_length == float('inf') else min_length"},{"question":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root: Optional[TreeNode]) -> List[List[int]]: Given the root of a binary tree, return a list of lists where each inner list represents a level in the tree with the values of nodes at that level from left to right. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> levelOrder(root) [[1], [2, 3]] >>> root = None >>> levelOrder(root) []","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root): Returns a list of levels with values of nodes at each level from left to right. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"def split_array_min_diff(nums: List[int], k: int) -> int: Split the list into k consecutive subarrays such that the difference between the maximum sum of any subarray and the minimum sum of any subarray is minimized. Return the minimum possible difference. >>> split_array_min_diff([1, 2, 3, 4, 5], 2) 9 >>> split_array_min_diff([7, 2, 5, 10, 8], 2) 18 >>> split_array_min_diff([1, 1, 1, 1, 1], 3) 2 >>> split_array_min_diff([1, 1, 1, 1, 1], 5) 1 >>> split_array_min_diff([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) 17 >>> split_array_min_diff([5], 1) 5","solution":"def split_array_min_diff(nums, k): from itertools import accumulate import math def can_split(max_sum): subarray_count, current_sum = 1, 0 for num in nums: if current_sum + num > max_sum: subarray_count += 1 current_sum = num if subarray_count > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) result = right while left <= right: mid = (left + right) // 2 if can_split(mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"from typing import List def k_most_frequent_words(words: List[str], k: int) -> List[str]: Returns the k most frequent words in descending order of frequency. If multiple words have the same frequency, returns them in lexicographical order. :param words: List of words :param k: Number of most frequent words to return :return: List of k most frequent words >>> k_most_frequent_words([\\"banana\\", \\"apple\\", \\"apple\\", \\"banana\\", \\"orange\\", \\"banana\\"], 2) [\\"banana\\", \\"apple\\"] >>> k_most_frequent_words([\\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\", \\"orange\\"], 2) [\\"apple\\", \\"banana\\"] >>> k_most_frequent_words([\\"banana\\", \\"apple\\", \\"orange\\"], 2) [\\"apple\\", \\"banana\\"] >>> k_most_frequent_words([\\"banana\\", \\"apple\\", \\"banana\\", \\"apple\\", \\"banana\\", \\"orange\\", \\"kiwi\\", \\"apple\\"], 3) [\\"apple\\", \\"banana\\", \\"kiwi\\"] >>> k_most_frequent_words([\\"banana\\", \\"apple\\", \\"banana\\", \\"orange\\", \\"apple\\", \\"banana\\"], 2) [\\"banana\\", \\"apple\\"]","solution":"from collections import Counter def k_most_frequent_words(words, k): Returns the k most frequent words in descending order of frequency. If multiple words have the same frequency, returns them in lexicographical order. :param words: List of words :param k: Number of most frequent words to return :return: List of k most frequent words count = Counter(words) sorted_words = sorted(count.items(), key=lambda item: (-item[1], item[0])) return [word for word, freq in sorted_words[:k]]"},{"question":"def is_balanced(expression: str) -> bool: Checks if the parentheses in the given expression are balanced. >>> is_balanced(\\"1 + (2 - (3 + 4))\\") True >>> is_balanced(\\"1 + (2 - (3 + 4)\\") False >>> is_balanced(\\"1 + 2) - (3 + 4\\") False >>> is_balanced(\\"\\") True >>> is_balanced(\\"123+456-789\\") True >>> is_balanced(\\"(1 + (2 + (3 + (4 + 5))\\") False >>> is_balanced(\\"((1 + 2) * (3 + 4))\\") True >>> is_balanced(\\"1 + 2) - (3 + 4\\") False","solution":"def is_balanced(expression): Checks if the parentheses in the given expression are balanced. Parameters: expression (str): The input string containing mathematical expressions with parentheses. Returns: bool: True if the parentheses are balanced, False otherwise. stack = [] for char in expression: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"def max_sum_subarray_with_m_distinct(nums, m): Finds the maximum sum of a subarray that contains at most 'm' distinct integers. >>> max_sum_subarray_with_m_distinct([1, 2, 1, 2, 3], 2) 6 >>> max_sum_subarray_with_m_distinct([1, 2, 1, 2, 3], 1) 3 >>> max_sum_subarray_with_m_distinct([1, 2, 1, 2, 3], 3) 9 >>> max_sum_subarray_with_m_distinct([4, 2, 5, 2, 2, 2], 2) 13 >>> max_sum_subarray_with_m_distinct([4], 2) 4 >>> max_sum_subarray_with_m_distinct([], 2) 0 >>> max_sum_subarray_with_m_distinct([1, 2, 3, 4, 5], 0) 0","solution":"def max_sum_subarray_with_m_distinct(nums, m): Finds the maximum sum of a subarray that contains at most 'm' distinct integers. if not nums or m <= 0: return 0 left = 0 current_sum = 0 max_sum = 0 distinct_count = {} for right, num in enumerate(nums): current_sum += num if num in distinct_count: distinct_count[num] += 1 else: distinct_count[num] = 1 while len(distinct_count) > m: current_sum -= nums[left] distinct_count[nums[left]] -= 1 if distinct_count[nums[left]] == 0: del distinct_count[nums[left]] left += 1 max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from collections import deque from typing import List class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_max_at_each_level(root: TreeNode) -> List[int]: Find the maximum value at each level of the binary tree. :param root: TreeNode, the root of the binary tree :return: List[int], a list of maximum values at each level >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> find_max_at_each_level(root) [1, 3] >>> root = None >>> find_max_at_each_level(root) []","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_max_at_each_level(root): Find the maximum value at each level of the binary tree. :param root: TreeNode, the root of the binary tree :return: List[int], a list of maximum values at each level if not root: return [] queue = deque([root]) result = [] while queue: level_size = len(queue) max_value = float('-inf') for _ in range(level_size): node = queue.popleft() max_value = max(max_value, node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(max_value) return result"},{"question":"def split_array_into_subsets(arr, k): Split the integer array into exactly \`k\` non-empty subsets such that the maximum sum of any subset is as small as possible. Return the minimum possible value of the maximum sum of the \`k\` subsets. >>> split_array_into_subsets([1, 2, 3, 4], 3) == 4 >>> split_array_into_subsets([10], 1) == 10 >>> split_array_into_subsets([1, 1, 1, 1], 2) == 2 >>> split_array_into_subsets([3, 1, 4, 2, 2], 3) == 4 >>> split_array_into_subsets([7, 2, 5, 10, 8], 1) == 32 >>> split_array_into_subsets([7, 2, 5, 10, 8], 5) == 10","solution":"def can_partition(nums, k, max_sum): subset_sums = [0] * k return backtrack(0, nums, subset_sums, k, max_sum) def backtrack(index, nums, subset_sums, k, max_sum): if index == len(nums): return True for i in range(k): if subset_sums[i] + nums[index] <= max_sum: subset_sums[i] += nums[index] if backtrack(index + 1, nums, subset_sums, k, max_sum): return True subset_sums[i] -= nums[index] if subset_sums[i] == 0: break return False def split_array_into_subsets(arr, k): left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_partition(arr, k, mid): right = mid else: left = mid + 1 return left"},{"question":"def longest_mountain(arr): Returns the length of the longest subarray that forms a mountain sequence. A mountain sequence has at least one peak such that it strictly increases until the peak and then strictly decreases. :param arr: List of positive integers. :return: Length of the longest mountain sequence. If there is no mountain sequence, return 0. >>> longest_mountain([2, 1, 4, 7, 3, 2, 5]) == 5 >>> longest_mountain([2, 2, 2]) == 0 >>> longest_mountain([0, 2, 0, 2, 0]) == 3 >>> longest_mountain([1, 3, 2, 2, 2, 1, 0]) == 3 >>> longest_mountain([1]) == 0 >>> longest_mountain([]) == 0 >>> longest_mountain([1, 2, 3, 4, 5, 4, 3, 2]) == 8 >>> longest_mountain([1, 2, 3, 4, 5]) == 0 >>> longest_mountain([5, 4, 3, 2, 1]) == 0 >>> longest_mountain([1, 1, 1, 1, 1]) == 0 >>> longest_mountain([2, 1]) == 0 >>> longest_mountain([1, 2, 3]) == 0 >>> longest_mountain([3, 2, 1]) == 0","solution":"def longest_mountain(arr): Returns the length of the longest subarray that forms a mountain sequence. A mountain sequence has at least one peak such that it strictly increases until the peak and then strictly decreases. :param arr: List of positive integers. :return: Length of the longest mountain sequence. If there is no mountain sequence, return 0. n = len(arr) if n < 3: return 0 max_length = 0 for i in range(1, n - 1): if arr[i - 1] < arr[i] > arr[i + 1]: # Found a mountain peak left = i - 1 right = i + 1 # Expand to the left while left > 0 and arr[left - 1] < arr[left]: left -= 1 # Expand to the right while right < n - 1 and arr[right + 1] < arr[right]: right += 1 # Calculate current mountain length current_length = right - left + 1 max_length = max(max_length, current_length) return max_length"},{"question":"def can_see_buildings(heights): Returns the indices of buildings that can be seen from the rightmost end of the street. Args: heights (list of int): A list of integers representing the heights of buildings. Returns: list of int: A list of indices of buildings that can be seen from rightmost to leftmost.","solution":"def can_see_buildings(heights): Returns the indices of buildings that can be seen from the rightmost end of the street. Args: heights (list of int): A list of integers representing the heights of buildings. Returns: list of int: A list of indices of buildings that can be seen from rightmost to leftmost. if not heights: return [] visible_indices = [] max_height_so_far = -1 for i in range(len(heights) - 1, -1, -1): if heights[i] > max_height_so_far: visible_indices.append(i) max_height_so_far = heights[i] return visible_indices[::-1]"},{"question":"def can_avoid_aba(s: str) -> bool: Determines if it is possible to replace '?' in such a way that the resulting string does not contain the substring 'aba'. >>> can_avoid_aba(\\"ab\\") True >>> can_avoid_aba(\\"abab\\") False >>> can_avoid_aba(\\"?\\") True >>> can_avoid_aba(\\"??\\") True >>> can_avoid_aba(\\"???\\") True >>> can_avoid_aba(\\"a?b\\") True >>> can_avoid_aba(\\"a??b\\") True >>> can_avoid_aba(\\"a??ba\\") False >>> can_avoid_aba(\\"a??bab\\") False >>> can_avoid_aba(\\"b?ab?b?a\\") True >>> can_avoid_aba(\\"???a??b?a?b???\\") True >>> can_avoid_aba(\\"\\") True >>> can_avoid_aba(\\"?a?b?a?b?\\") True","solution":"def can_avoid_aba(s): Determines if it is possible to replace '?' in such a way that the resulting string does not contain the substring 'aba'. s = list(s) # Convert the string to a list for easier manipulation for i in range(len(s)): if s[i] == '?': if (i > 1 and s[i-2:i] == ['a', 'b']): s[i] = 'b' # Avoid forming 'aba' else: s[i] = 'a' # Check if the final string contains 'aba' final_string = ''.join(s) return 'aba' not in final_string"},{"question":"def min_operations_to_equalize_path_sums(grid): Calculate the minimum number of operations required to make all (0, 0) -> (m-1, n-1) paths in the grid have the same sum. Args: grid (List[List[int]]): The input grid of non-negative integers. Returns: int: The minimum number of operations needed. >>> min_operations_to_equalize_path_sums([[0]]) 0 >>> min_operations_to_equalize_path_sums([[5]]) 0 >>> min_operations_to_equalize_path_sums([[1, 3], [2, 4]]) 0 >>> min_operations_to_equalize_path_sums([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 0 >>> min_operations_to_equalize_path_sums([[1, 2, 3], [4, 8, 2], [1, 5, 3]]) 0","solution":"from collections import defaultdict from itertools import combinations def min_operations_to_equalize_path_sums(grid): Calculate the minimum number of operations required to make all (0, 0) -> (m-1, n-1) paths in the grid have the same sum. m, n = len(grid), len(grid[0]) path_sums = defaultdict(list) def dfs(x, y, current_sum): Depth-first search to find all path sums. if x == m - 1 and y == n - 1: path_sums[current_sum].append((x, y)) return if x + 1 < m: dfs(x + 1, y, current_sum + grid[x + 1][y]) if y + 1 < n: dfs(x, y + 1, current_sum + grid[x][y + 1]) dfs(0, 0, grid[0][0]) min_operations = float('inf') for sum1, sum2 in combinations(path_sums.keys(), 2): operation_count = 0 for path1 in path_sums[sum1]: for path2 in path_sums[sum2]: if path1 != path2: operation_count += abs(sum1 - sum2) min_operations = min(min_operations, operation_count) return min_operations if min_operations != float('inf') else 0"},{"question":"def can_see_sunset(heights: List[int]) -> List[bool]: Determines which buildings can see the sunset. Args: heights (list of int): List of building heights. Returns: list of bool: List indicating if the building at each index can see the sunset. >>> can_see_sunset([1, 2, 3, 4, 5]) [False, False, False, False, True] >>> can_see_sunset([5, 4, 3, 2, 1]) [True, True, True, True, True] >>> can_see_sunset([3, 5, 4, 3, 2, 6]) [False, False, False, False, False, True] >>> can_see_sunset([3, 3, 3, 3, 3]) [False, False, False, False, True] >>> can_see_sunset([5]) [True] >>> can_see_sunset([1, 3, 2, 3, 4, 1]) [False, False, False, False, True, True] >>> can_see_sunset([]) []","solution":"def can_see_sunset(heights): Determines which buildings can see the sunset. Args: heights (list of int): List of building heights. Returns: list of bool: List indicating if the building at each index can see the sunset. n = len(heights) answer = [False] * n max_height = 0 # Traverse from right to left for i in range(n-1, -1, -1): if heights[i] > max_height: answer[i] = True max_height = heights[i] return answer"},{"question":"from typing import List def largest_number(nums: List[int]) -> str: Arrange a list of non-negative integers such that they form the largest possible number. Args: nums (list): List of non-negative integers. Returns: str: The largest number formed by the integers in the list. >>> largest_number([10, 2]) '210' >>> largest_number([3, 30, 34, 5, 9]) '9534330' >>> largest_number([1, 1, 1, 1]) '1111' >>> largest_number([0, 0]) '0' >>> largest_number([0, 1]) '10' >>> largest_number([0, 0, 1]) '100' >>> largest_number([824, 938, 1399, 5607, 6973, 5703, 9609, 4398, 8247]) '9609938824824769735703560743981399' >>> largest_number([0]) '0' >>> largest_number([9]) '9' >>> largest_number([]) ''","solution":"from functools import cmp_to_key def largest_number(nums): Arrange a list of non-negative integers such that they form the largest possible number. Args: nums (list): List of non-negative integers. Returns: str: The largest number formed by the integers in the list. if not nums: return \\"\\" # Custom comparator to decide which concatenated pair is greater. def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert integers to strings for easy comparison. nums = list(map(str, nums)) # Sort array with custom comparator. nums.sort(key=cmp_to_key(compare)) # Join sorted numbers into a single string. result = ''.join(nums) # Edge case to handle leading zeros. if result[0] == '0': return '0' else: return result"},{"question":"from typing import List def trapRainWater(grid: List[List[int]]) -> int: Given a grid containing an \`m x n\` matrix with integers, where each integer represents the height of a terrain, calculate the amount of trapped rainwater after it rains. >>> trapRainWater([[1, 4, 3, 1, 3, 2], [3, 2, 1, 3, 2, 4], [2, 3, 3, 2, 3, 1]]) 4 >>> trapRainWater([]) 0 >>> trapRainWater([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) 0 >>> trapRainWater([[12, 13, 1, 12], [13, 4, 13, 12], [13, 8, 10, 12], [12, 13, 12, 12], [13, 13, 13, 13]]) 14 >>> trapRainWater([[1, 2, 3, 4]]) 0 >>> trapRainWater([[1], [2], [3], [4]]) 0 pass","solution":"from heapq import heappush, heappop def trapRainWater(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] heap = [] # Push all the boundary cells into the heap and mark them as visited for i in range(m): for j in range(n): if i == 0 or i == m-1 or j == 0 or j == n-1: heappush(heap, (grid[i][j], i, j)) visited[i][j] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] water_trapped = 0 while heap: current_height, x, y = heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: water_trapped += max(0, current_height - grid[nx][ny]) heappush(heap, (max(current_height, grid[nx][ny]), nx, ny)) visited[nx][ny] = True return water_trapped"},{"question":"def timeToMeet(n: int, startA: int, startB: int, k: int) -> int: Returns the minimum time in seconds for two racers to meet on a circular track, or -1 if they cannot meet. Parameters: n (int): The length of the circular track startA (int): The starting position of the first racer (0-indexed) startB (int): The starting position of the second racer (0-indexed) k (int): The number of steps each racer takes per second Returns: int: The minimum time in seconds for both racers to meet, or -1 if they cannot meet >>> timeToMeet(10, 2, 3, 2) -1 >>> timeToMeet(10, 0, 1, 2) -1 >>> timeToMeet(12, 3, 10, 4) -1 >>> timeToMeet(10, 0, 0, 1) 0 >>> timeToMeet(10, 0, 2, 2) 1 >>> timeToMeet(12, 3, 6, 3) 1","solution":"def timeToMeet(n, startA, startB, k): Returns the minimum time in seconds for two racers to meet on a circular track, or -1 if they cannot meet. Parameters: n (int): The length of the circular track startA (int): The starting position of the first racer (0-indexed) startB (int): The starting position of the second racer (0-indexed) k (int): The number of steps each racer takes per second Returns: int: The minimum time in seconds for both racers to meet, or -1 if they cannot meet # If the distance between their starting positions is not a multiple of their speed, they cannot meet if (startB - startA) % k != 0: return -1 # Calculate the number of seconds it will take for their meeting point distance = (startB - startA) % n return distance // k"},{"question":"from typing import List def can_partition(nums: List[int]) -> bool: Determines if it is possible to partition the array into two subsets such that the sum of the elements in both subsets is the same. >>> can_partition([1, 5, 11, 5]) # True (5+5+11 = 1+11) True >>> can_partition([1, 2, 3, 4]) # True (1+4 = 3+2) True >>> can_partition([1, 2, 3, 5]) # False (cannot be partitioned into two equal subsets) False >>> can_partition([1, 1, 1, 2, 3, 5]) # False (cannot be partitioned into two equal subsets) False >>> can_partition([]) # True (empty array can be considered as two empty subsets with sum 0) True >>> can_partition([1]) # False (single element cannot be partitioned into two equal subsets) False >>> can_partition([1, 1]) # True (1+1) True >>> can_partition([1, 2, 5, 2, 1, 5]) # True (1+2+2+1 = 5+5) True","solution":"def can_partition(nums): Determines if it is possible to partition the array into two subsets such that the sum of the elements in both subsets is the same. total_sum = sum(nums) # If total sum is odd, it cannot be partitioned into two equal subsets if total_sum % 2 != 0: return False # Target sum for each subset target = total_sum // 2 n = len(nums) # dp[i] will be True if a subset with sum i can be formed with the elements in the array dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"def max_profit(prices): Returns the maximum profit that can be achieved by buying and then selling one car. If no profit is possible, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([]) 0 >>> max_profit([5]) 0 >>> max_profit([5, 5, 5, 5, 5]) 0 >>> max_profit([1, 5]) 4 >>> max_profit([3, 1, 4, 8, 7, 2, 6, 1, 9]) 8 >>> max_profit([2, 1, 5, 0, 3, 4, 6, 7, 1, 5, 3, 6, 4]) 7","solution":"def max_profit(prices): Returns the maximum profit that can be achieved by buying and then selling one car. If no profit is possible, returns 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def has_exactly_one_square_submatrix(mat): Determines if the matrix contains exactly one square submatrix of 1's. :param mat: List[List[int]] - a binary matrix :return: bool - True if there is exactly one square submatrix of 1's, False otherwise >>> mat1 = [ >>> [1, 0, 0, 1], >>> [1, 1, 0, 1], >>> [0, 1, 1, 1], >>> [1, 0, 1, 1] >>> ] >>> has_exactly_one_square_submatrix(mat1) True >>> mat2 = [ >>> [1, 1, 1, 0], >>> [1, 1, 1, 0], >>> [1, 1, 1, 0] >>> ] >>> has_exactly_one_square_submatrix(mat2) False >>> mat3 = [ >>> [1, 0, 0, 0], >>> [0, 1, 1, 0], >>> [0, 1, 1, 0], >>> [0, 0, 0, 1] >>> ] >>> has_exactly_one_square_submatrix(mat3) True","solution":"def has_exactly_one_square_submatrix(mat): Determines if the matrix contains exactly one square submatrix of 1's. :param mat: List[List[int]] - a binary matrix :return: bool - True if there is exactly one square submatrix of 1's, False otherwise if not mat or not mat[0]: return False m, n = len(mat), len(mat[0]) dp = [[0] * n for _ in range(m)] count = 0 for i in range(m): for j in range(n): if mat[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 if dp[i][j] > 1: count += 1 if count > 1: return False return count == 1"},{"question":"def min_meeting_rooms(arrival, departure): Returns the minimum number of rooms required to accommodate all meetings. Parameters: arrival (list of int): List of arrival times. departure (list of int): List of departure times. Returns: int: Minimum number of rooms required. pass def test_min_meeting_rooms_no_meetings(): assert min_meeting_rooms([], []) == 0 def test_min_meeting_rooms_single_meeting(): assert min_meeting_rooms([1], [2]) == 1 def test_min_meeting_rooms_multiple_non_overlapping(): assert min_meeting_rooms([1, 3, 5], [2, 4, 6]) == 1 def test_min_meeting_rooms_multiple_overlapping(): assert min_meeting_rooms([1, 2, 3], [4, 5, 6]) == 3 def test_min_meeting_rooms_some_overlapping(): assert min_meeting_rooms([1, 2, 3, 4], [2, 3, 6, 5]) == 2 def test_min_meeting_rooms_all_same_time(): assert min_meeting_rooms([1, 1, 1, 1], [2, 2, 2, 2]) == 4 def test_min_meeting_rooms_complex_case(): assert min_meeting_rooms([1, 3, 5, 7, 9], [2, 8, 6, 10, 11]) == 2","solution":"def min_meeting_rooms(arrival, departure): Returns the minimum number of rooms required to accommodate all meetings. Parameters: arrival (list of int): List of arrival times. departure (list of int): List of departure times. Returns: int: Minimum number of rooms required. if not arrival or not departure or len(arrival) != len(departure): return 0 events = [] for i in range(len(arrival)): events.append((arrival[i], 'arr')) events.append((departure[i], 'dep')) events.sort(key=lambda x: (x[0], x[1])) max_rooms = 0 current_rooms = 0 for event in events: if event[1] == 'arr': current_rooms += 1 max_rooms = max(max_rooms, current_rooms) else: current_rooms -= 1 return max_rooms"},{"question":"from typing import List def max_two_non_overlapping_subarrays(arr: List[int]) -> List[int]: Given a list of integers \`arr\`, find two non-overlapping subarrays, each of which has the maximum possible sum. Return an array of these two sums in any order. Args: arr (List[int]): List of integers. Returns: List[int]: List of two integers representing the sums of the two subarrays. >>> max_two_non_overlapping_subarrays([1, 2, 3, 4, 5, 6]) # [15, 6] or [6, 15] >>> max_two_non_overlapping_subarrays([-1, -2, -3, -4, -5]) # [-1, -2] or [-2, -1] >>> max_two_non_overlapping_subarrays([0, 0, 0, 0, 0, 1]) # [0, 1] or [1, 0] >>> max_two_non_overlapping_subarrays([0, 6, -3, 4, -1, 2, 1, -5, 4]) # [10, 4] or [4, 10] >>> max_two_non_overlapping_subarrays([]) # [] >>> max_two_non_overlapping_subarrays([10]) # [] >>> max_two_non_overlapping_subarrays([1, 2]) # [2, 1] or [1, 2] >>> max_two_non_overlapping_subarrays([-1, 3, 4, -5, 9, 10]) # [7, 19] or [19, 7]","solution":"def max_two_non_overlapping_subarrays(arr): Finds two non-overlapping subarrays with the maximum possible sum. Args: arr (list): List of integers. Returns: list: List of two integers representing the sums of the two subarrays. n = len(arr) # Corner case: if the list contains less than 2 elements, return empty list if n < 2: return [] # Helper function to find the maximum subarray sum using Kadane's algorithm def max_subarray_sum(arr): max_sum = curr_sum = arr[0] for num in arr[1:]: curr_sum = max(num, curr_sum + num) max_sum = max(max_sum, curr_sum) return max_sum # First, find the maximum sum from 0 to i max_end_here = [0] * n curr_sum = max_end_here[0] = arr[0] for i in range(1, n): curr_sum = max(arr[i], curr_sum + arr[i]) max_end_here[i] = max(max_end_here[i-1], curr_sum) # Second, find the maximum sum from i to n-1 max_start_here = [0] * n curr_sum = max_start_here[-1] = arr[-1] for i in range(n-2, -1, -1): curr_sum = max(arr[i], curr_sum + arr[i]) max_start_here[i] = max(max_start_here[i+1], curr_sum) max_sum = float('-inf') for i in range(n-1): max_sum = max(max_sum, max_end_here[i] + max_start_here[i+1]) results = [0, 0] for i in range(n-1): if max_end_here[i] + max_start_here[i+1] == max_sum: results[0] = max_end_here[i] results[1] = max_start_here[i+1] break return results"},{"question":"def movies_with_more_than_25_percent_votes(arr: List[int]) -> List[int]: You are given an array \`arr\` of integers where each integer represents a vote for a particular movie. Return a list of integers representing the IDs of the movies that have received more than 25% of the total votes. The list should be sorted in ascending order. If no movie meets the criteria, return an empty list. >>> movies_with_more_than_25_percent_votes([]) == [] >>> movies_with_more_than_25_percent_votes([1, 1, 1, 1]) == [1] >>> movies_with_more_than_25_percent_votes([1, 1, 1, 2, 2, 2, 3, 3, 4]) == [1, 2] >>> movies_with_more_than_25_percent_votes([1, 2, 3, 4]) == [] >>> movies_with_more_than_25_percent_votes([1, 2, 3, 4, 1, 2, 3, 1, 2]) == [1, 2] >>> movies_with_more_than_25_percent_votes([1, 1, 1, 1, 1, 1, 1, 1]) == [1]","solution":"def movies_with_more_than_25_percent_votes(arr): from collections import Counter n = len(arr) vote_threshold = n // 4 movie_votes = Counter(arr) result = [movie for movie, votes in movie_votes.items() if votes > vote_threshold] return sorted(result)"},{"question":"def min_drones(packages, capacity): Returns the minimum number of drones required to deliver all packages. :param packages: List of integers where each integer denotes the weight of a package. :param capacity: Integer denoting the weight capacity of each drone. :return: Integer denoting the minimum number of drones required. >>> min_drones([2, 3, 5, 7], 10) == 2 >>> min_drones([2, 3, 5], 10) == 1 >>> min_drones([15], 10) == 1 >>> min_drones([2, 4, 8, 1, 3, 5, 7], 10) == 3 >>> min_drones([], 10) == 0 >>> min_drones([2, 3, 5], 0) == 3 >>> min_drones([5, 5, 5, 5, 5, 5, 5, 5, 5, 5], 15) == 4","solution":"def min_drones(packages, capacity): Returns the minimum number of drones required to deliver all packages. :param packages: List of integers where each integer denotes the weight of a package. :param capacity: Integer denoting the weight capacity of each drone. :return: Integer denoting the minimum number of drones required. packages.sort(reverse=True) drones = [] for package in packages: placed = False for i in range(len(drones)): if drones[i] + package <= capacity: drones[i] += package placed = True break if not placed: drones.append(package) return len(drones)"},{"question":"def maxEnvelopes(envelopes: List[List[int]]) -> int: Returns the maximum number of envelopes you can Russian doll (i.e., put one inside the other). >>> maxEnvelopes([[1, 1]]) 1 >>> maxEnvelopes([[5, 4], [6, 7]]) 2 >>> maxEnvelopes([[5, 4], [6, 3]]) 1 >>> maxEnvelopes([[5, 4], [6, 4], [6, 7], [2, 3]]) 3 >>> maxEnvelopes([]) 0 >>> maxEnvelopes([[2, 3], [2, 3], [2, 3]]) 1 >>> maxEnvelopes([[1, 1], [2, 2], [3, 3]]) 3 >>> maxEnvelopes([[6, 7], [5, 4], [2, 3]]) 3","solution":"def maxEnvelopes(envelopes): from bisect import bisect_left # Sort the envelopes first by width (ascending) and then by height (descending) envelopes.sort(key=lambda x: (x[0], -x[1])) heights = [envelope[1] for envelope in envelopes] # This list will store the longest increasing subsequence of heights dp = [] for h in heights: # Find the position to replace or extend the subsequence pos = bisect_left(dp, h) if pos < len(dp): dp[pos] = h else: dp.append(h) return len(dp)"},{"question":"def find_pairs(nums: List[int], target: int) -> List[List[int]]: Returns a list of all unique pairs [a, b] from the given nums such that a + b = target. Each pair [a, b] should be sorted such that a <= b and the list of pairs should be sorted in ascending order based on the first element of each pair. >>> find_pairs([1, 2, 3, 4], 5) [[1, 4], [2, 3]] >>> find_pairs([1, 2, 3, 4], 10) [] >>> find_pairs([-1, -2, -3, -4, -5], -8) [[-5, -3]] >>> find_pairs([-1, 1, 2, -2, 3, -3, 4], 0) [[-3, 3], [-2, 2], [-1, 1]] >>> find_pairs([2, 4, 3, 5, 3, 4, 6], 7) [[2, 5], [3, 4]] >>> find_pairs([], 1) [] >>> find_pairs([1], 2) []","solution":"def find_pairs(nums, target): Returns a list of unique pairs [a, b] from the given nums such that a + b = target. Each pair [a, b] is sorted such that a <= b, and the list of pairs is sorted in ascending order based on the first element of each pair. nums.sort() pairs = [] seen = set() for num in nums: complement = target - num if complement in seen: pair = sorted([num, complement]) if pair not in pairs: pairs.append(pair) seen.add(num) pairs.sort() return pairs"},{"question":"def peak_index_in_mountain_array(arr: List[int]) -> int: Given a list of integers \`arr\` representing a mountain array, return the index \`i\` such that \`arr[0] < arr[1] < ... < arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1]\`. Must solve in O(log(n)) time complexity. >>> peak_index_in_mountain_array([0, 1, 0]) 1 >>> peak_index_in_mountain_array([0, 2, 1, 0]) 1 >>> peak_index_in_mountain_array([0, 10, 5, 2]) 1 >>> peak_index_in_mountain_array([3, 4, 5, 1]) 2 >>> peak_index_in_mountain_array([24, 69, 100, 99, 79, 78]) 2 >>> peak_index_in_mountain_array([1, 3, 1, 0]) 1 >>> peak_index_in_mountain_array([1, 3, 5, 6, 7, 8, 9, 10, 2, 1, 0]) 7","solution":"def peak_index_in_mountain_array(arr): Returns the index of the peak element in a mountain array. Uses binary search to achieve O(log(n)) time complexity. left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] < arr[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"import heapq from typing import List def k_largest_elements(arr: List[int], k: int) -> List[int]: Given an array of non-negative integers \`arr\` and an integer \`k\`, find the \`k\` largest elements in the array and return them in ascending order. You can assume that \`k\` is always less than or equal to the length of the array. Parameters: arr (list of int): List of non-negative integers. k (int): Number of largest elements to return. Returns: list of int: k largest elements in ascending order. >>> k_largest_elements([3, 2, 1, 5, 6, 4], 2) [5, 6] >>> k_largest_elements([3, 2, 1, 5, 6, 4], 6) [1, 2, 3, 4, 5, 6] >>> k_largest_elements([3, 2, 1, 5, 6, 4], 1) [6] >>> k_largest_elements([1, 1, 1, 1, 1, 1], 3) [1, 1, 1] >>> k_largest_elements(list(range(1000)), 5) [995, 996, 997, 998, 999] >>> k_largest_elements([], 3) [] >>> k_largest_elements([3, 2, 1], 0) []","solution":"import heapq def k_largest_elements(arr, k): Returns the k largest elements in the array in ascending order. Parameters: arr (list of int): List of non-negative integers. k (int): Number of largest elements to return. Returns: list of int: k largest elements in ascending order. if k <= 0 or not arr: return [] # Use a min-heap of size k min_heap = arr[:k] heapq.heapify(min_heap) for num in arr[k:]: if num > min_heap[0]: heapq.heapreplace(min_heap, num) # The heap contains the k largest elements, sort them before returning return sorted(min_heap)"},{"question":"def min_max_deploy_time(deployTimes: List[int], k: int) -> int: Optimize the deployment process of an application by dividing the features into \`k\` non-empty contiguous subarrays. Return the minimum possible value of the maximum deployment time among the \`k\` subarrays. >>> min_max_deploy_time([10], 1) == 10 >>> min_max_deploy_time([2,3,1,5], 1) == 11 >>> min_max_deploy_time([2,3,1,5], 4) == 5 >>> min_max_deploy_time([7,2,5,10,8], 2) == 18 >>> min_max_deploy_time([7,2,5,10,8], 3) == 14 >>> min_max_deploy_time([1,2,3,4,5], 2) == 9 >>> min_max_deploy_time([1,2,3,4,5], 3) == 6 >>> min_max_deploy_time([1,2,3,1,1], 4) == 3 >>> min_max_deploy_time([1,4,4], 3) == 4 >>> min_max_deploy_time([1,4,4,5], 2) == 9","solution":"def min_max_deploy_time(deployTimes, k): def can_split(max_time): current_sum = 0 needed_splits = 1 for time in deployTimes: if current_sum + time > max_time: current_sum = time needed_splits += 1 if needed_splits > k: return False else: current_sum += time return True left, right = max(deployTimes), sum(deployTimes) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"def max_water_caught(heights: List[int]) -> int: Returns the maximum amount of water that can be caught between any two towers. Parameters: heights (list): A list of integers representing the height of towers. Returns: int: The maximum amount of water that can be caught between any two towers. Examples: >>> max_water_caught([4, 1, 3, 2]) 3 >>> max_water_caught([1, 2, 3, 4]) 0 >>> max_water_caught([3, 3, 3, 3]) 0 >>> max_water_caught([5]) 0 >>> max_water_caught([2, 4]) 0 >>> max_water_caught([5, 2]) 3 >>> max_water_caught([i for i in range(1000, 0, -1)]) 1 >>> max_water_caught([5, 3, 6, 7, 2, 8, 4]) 5","solution":"def max_water_caught(heights): Returns the maximum amount of water that can be caught between any two towers. Parameters: heights (list): A list of integers representing the height of towers. Returns: int: The maximum amount of water that can be caught between any two towers. max_water = 0 for i in range(len(heights) - 1): diff = heights[i] - heights[i + 1] if diff > 0: max_water = max(max_water, diff) return max_water"},{"question":"def longest_subsequence_with_diff(nums: List[int], k: int) -> int: Returns the length of the longest subsequence with an exact absolute difference k. >>> longest_subsequence_with_diff([1, 5, 3, 4, 2], 2) 2 >>> longest_subsequence_with_diff([1, 2, 3, 4], 1) 4 >>> longest_subsequence_with_diff([1, 2, 3, 4], 10) 1 >>> longest_subsequence_with_diff([10, 7, 8, 2, 4, 3, 5], 3) 3 >>> longest_subsequence_with_diff([1, 1, 1, 1], 0) 4 >>> longest_subsequence_with_diff([1, 2, 1, 2, 1, 2], 1) 6","solution":"def longest_subsequence_with_diff(nums, k): from collections import defaultdict subseq_len = defaultdict(int) longest_length = 0 for num in nums: subseq_len_up = subseq_len[num - k] + 1 subseq_len_down = subseq_len[num + k] + 1 subseq_len[num] = max(subseq_len[num], subseq_len_up, subseq_len_down) longest_length = max(longest_length, subseq_len[num]) return longest_length"},{"question":"from typing import List def trap(height: List[int]) -> int: Computes the total amount of trapped rainwater given a list of heights. :param height: List of integers representing elevation map where the width of each bar is 1. :return: The total amount of trapped rainwater. def test_trap_example(): assert trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 def test_trap_no_water(): assert trap([1,1,1,1]) == 0 assert trap([2,1,2]) == 1 def test_trap_single_peak(): assert trap([0,2,0]) == 0 def test_trap_multiple_levels(): assert trap([4,2,0,3,2,5]) == 9 def test_trap_empty(): assert trap([]) == 0 def test_trap_descending(): assert trap([5,4,3,2,1]) == 0","solution":"from typing import List def trap(height: List[int]) -> int: Computes the total amount of trapped rainwater given a list of heights. :param height: List of integers representing elevation map where the width of each bar is 1. :return: The total amount of trapped rainwater. if not height: return 0 left_max = [0] * len(height) right_max = [0] * len(height) left_max[0] = height[0] for i in range(1, len(height)): left_max[i] = max(left_max[i - 1], height[i]) right_max[len(height) - 1] = height[len(height) - 1] for i in range(len(height) - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(len(height)): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"from typing import List, Tuple def unique_permutations(a: List[int]) -> List[Tuple[int]]: Returns all unique permutations of the array \`a\` in lexicographic order. Parameters: a (list): A list of integers which may contain duplicates. Returns: list: A list of tuples, where each tuple is a unique permutation of \`a\` sorted in lexicographic order. >>> unique_permutations([1, 2, 3]) [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)] >>> unique_permutations([1, 1, 2]) [(1, 1, 2), (1, 2, 1), (2, 1, 1)] >>> unique_permutations([1, 1, 1]) [(1, 1, 1)] >>> unique_permutations([]) [()] >>> unique_permutations([1]) [(1,)]","solution":"from itertools import permutations def unique_permutations(a): Returns all unique permutations of the array \`a\` in lexicographic order. Parameters: a (list): A list of integers which may contain duplicates. Returns: list: A list of lists, where each sublist is a unique permutation of \`a\` sorted in lexicographic order. return sorted(set(permutations(a)))"},{"question":"def exists_path_with_k_nodes(edges, n, k): Determine if there exists a path from the root to any leaf that contains exactly k nodes in a given binary tree. Args: edges (List[List[int]]): The list of edges representing the tree. n (int): The number of nodes in the tree. k (int): The target path length. Returns: bool: True if such a path exists, False otherwise. >>> exists_path_with_k_nodes([[0, 1], [0, 2], [1, 3], [1, 4], [2, 5]], 6, 3) True >>> exists_path_with_k_nodes([[0, 1], [0, 2], [1, 3], [1, 4], [2, 5]], 6, 4) False >>> exists_path_with_k_nodes([], 1, 1) True >>> exists_path_with_k_nodes([[0, 1]], 2, 2) True >>> exists_path_with_k_nodes([[0, 1], [1, 2], [2, 3], [3, 4]], 5, 6) False >>> exists_path_with_k_nodes([[0, 1], [1, 2], [1, 3]], 4, 3) True >>> exists_path_with_k_nodes([[0, 1], [0, 2], [1, 3]], 4, 0) False","solution":"def exists_path_with_k_nodes(edges, n, k): from collections import defaultdict # Build the adjacency list representation of the tree tree = defaultdict(list) for parent, child in edges: tree[parent].append(child) # Function to find the depth of the tree using DFS def dfs(node, depth): # If the node is a leaf node and depth equals k, return True if not tree[node]: return depth == k # Recur for all the children for child in tree[node]: if dfs(child, depth + 1): return True return False # Start DFS from the root node (0) with initial depth 1 return dfs(0, 1)"},{"question":"def min_subsequence(nums): Returns a subsequence such that its sum is at least half of the total sum of the array nums with the minimum number of elements, sorted in ascending order. Args: nums: List[int] - The array of integers Returns: List[int] - The resulting subsequence in ascending order >>> min_subsequence([4, 3, 10, 9, 8]) == [9, 10] >>> min_subsequence([4, 4, 7, 6, 7]) == [7, 7] >>> min_subsequence([2, 3]) == [3] >>> min_subsequence([1, 1, 1, 1]) == [1, 1] >>> min_subsequence([10]) == [10]","solution":"def min_subsequence(nums): Returns a subsequence such that its sum is at least half of the total sum of the array nums with the minimum number of elements, sorted in ascending order. Args: nums: List[int] - The array of integers Returns: List[int] - The resulting subsequence in ascending order # Find the total sum of the array total_sum = sum(nums) # Sort the array in descending order to pick larger elements first nums.sort(reverse=True) subsequence = [] subseq_sum = 0 # Collect elements to form the subsequence for num in nums: subsequence.append(num) subseq_sum += num if subseq_sum >= total_sum / 2: break # Return the subsequence sorted in ascending order return sorted(subsequence)"},{"question":"def can_attend_all_projects(projects: List[List[int]]) -> bool: Determines if it is possible to attend all projects without any overlap. Arguments: projects -- list of lists, where each inner list contains two integers representing the start and end time of a project. Returns: bool -- True if it's possible to attend all projects without overlap, False otherwise. >>> can_attend_all_projects([[1, 3], [3, 5], [5, 7]]) == True >>> can_attend_all_projects([[1, 4], [2, 5], [6, 8]]) == False >>> can_attend_all_projects([[1, 4], [1, 4], [1, 4]]) == False >>> can_attend_all_projects([]) == True >>> can_attend_all_projects([[1, 4]]) == True >>> can_attend_all_projects([[1, 3], [3, 6], [6, 8]]) == True >>> can_attend_all_projects([[1, 4], [4, 10], [10, 15]]) == True","solution":"def can_attend_all_projects(projects): Determines if it is possible to attend all projects without any overlap. Arguments: projects -- list of lists, where each inner list contains two integers representing the start and end time of a project. Returns: boolean -- True if it's possible to attend all projects without overlap, False otherwise. # Sort the projects by their start times projects.sort(key=lambda x: x[0]) for i in range(1, len(projects)): # If the current project starts before the previous one ends, return False if projects[i][0] < projects[i - 1][1]: return False return True"},{"question":"def rotate_string(word: str, k: int) -> str: Rotates the given string \`word\` to the right \`k\` times. Parameters: word (str): The string to be rotated. k (int): The number of times to rotate the string to the right. Returns: str: The rotated string. >>> rotate_string(\\"coding\\", 2) 'ngcodi' >>> rotate_string(\\"hello\\", 0) 'hello' >>> rotate_string(\\"world\\", 7) 'ldwor' >>> rotate_string(\\"\\", 5) '' >>> rotate_string(\\"a\\", 10) 'a'","solution":"def rotate_string(word, k): Rotates the given string \`word\` to the right \`k\` times. Parameters: word (str): The string to be rotated. k (int): The number of times to rotate the string to the right. Returns: str: The rotated string. if not word: return word k = k % len(word) return word[-k:] + word[:-k] # Example: # word = \\"coding\\", k = 2 # Output: \\"ngcodi\\""},{"question":"def can_select_pairs_with_sum(arr, k, s): Determine if it is possible to select exactly k distinct pairs (i, j) with i != j such that the sum of arr[i] and arr[j] for each pair is equal to s. :param arr: List of integers :param k: The number of pairs to select :param s: The target sum for each pair :return: True if such a selection is possible, False otherwise >>> can_select_pairs_with_sum([1, 2, 3, 4], 2, 5) True >>> can_select_pairs_with_sum([1, 1, 1, 1], 2, 2) True >>> can_select_pairs_with_sum([1, 2, 3, 4], 1, 8) False >>> can_select_pairs_with_sum([1, 2, 3, 4], 2, 6) False >>> can_select_pairs_with_sum([], 1, 1) False >>> can_select_pairs_with_sum([2], 1, 2) False >>> can_select_pairs_with_sum([1, 1, 1, 1, 1, 1], 3, 2) True >>> can_select_pairs_with_sum([0, 0, 0, 0, 0], 2, 0) True >>> can_select_pairs_with_sum([1, 5, 7, -1, 5], 1, 6) True >>> can_select_pairs_with_sum([-1, -2, -3, -4, 5, 6], 1, 1) True","solution":"def can_select_pairs_with_sum(arr, k, s): Determine if it is possible to select exactly k distinct pairs (i, j) with i != j such that the sum of arr[i] and arr[j] for each pair is equal to s. :param arr: List of integers :param k: The number of pairs to select :param s: The target sum for each pair :return: True if such a selection is possible, False otherwise # Handle edge cases n = len(arr) if n < 2 or k <= 0: return False # Dictionary to count occurrences of complements complement_count = {} for num in arr: complement = s - num if complement in complement_count and complement_count[complement] > 0: complement_count[complement] -= 1 k -= 1 else: complement_count[num] = complement_count.get(num, 0) + 1 if k == 0: return True return False"},{"question":"def min_operations_to_empty_string(s: str) -> int: Returns the minimum number of operations needed to empty the string \`s\`. An operation is defined as removing all occurrences of a particular character. >>> min_operations_to_empty_string('a') == 1 >>> min_operations_to_empty_string('abcdef') == 6 >>> min_operations_to_empty_string('aaabbb') == 2 >>> min_operations_to_empty_string('abbccc') == 3 >>> min_operations_to_empty_string('') == 0 >>> min_operations_to_empty_string('aaaaa') == 1","solution":"def min_operations_to_empty_string(s): Returns the minimum number of operations needed to empty the string \`s\`. An operation is defined as removing all occurrences of a particular character. return len(set(s))"},{"question":"def diagonal_traversal(mat: List[List[int]]) -> List[int]: Given a 2D matrix mat of integers, return the matrixs diagonal traversal as a flattened array. >>> diagonal_traversal([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [1, 4, 2, 7, 5, 3, 8, 6, 9] >>> diagonal_traversal([ ... [1, 2], ... [3, 4] ... ]) [1, 3, 2, 4] >>> diagonal_traversal([ ... [1] ... ]) [1] >>> diagonal_traversal([]) [] >>> diagonal_traversal([ ... [1, 2], ... [3, 4], ... [5, 6] ... ]) [1, 3, 2, 5, 4, 6] >>> diagonal_traversal([ ... [1, 2, 3], ... [4, 5, 6] ... ]) [1, 4, 2, 5, 3, 6]","solution":"def diagonal_traversal(mat): Returns the diagonal traversal as a flattened array. Args: mat (list of list of int): 2D matrix of integers Returns: list of int: Diagonal traversal of the matrix if not mat: return [] rows, cols = len(mat), len(mat[0]) result = [] for diag in range(rows + cols - 1): row = min(diag, rows - 1) # start from the row closest to bottom col = max(0, diag - rows + 1) # start from the col closest to left while row >= 0 and col < cols: result.append(mat[row][col]) row -= 1 col += 1 return result"},{"question":"def min_path_sum(mat: List[List[int]]) -> int: Finds the minimum sum of the path from the top-left to the bottom-right corner of the matrix moving only down or right. Parameters: mat (list of list of int): The input matrix containing non-negative integers. Returns: int: The minimum sum of the values along the path. >>> min_path_sum([[5]]) 5 >>> min_path_sum([[1, 2], [1, 1]]) 3 >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_path_sum([[1, 2, 3]]) 6 >>> min_path_sum([[1], [2], [3]]) 6 >>> min_path_sum([ ... [1, 2, 5], ... [3, 2, 1], ... [4, 1, 1] ... ]) 7 >>> min_path_sum([]) 0 >>> min_path_sum([[]]) 0","solution":"def min_path_sum(mat): Finds the minimum sum of the path from the top-left to the bottom-right corner of the matrix moving only down or right. Parameters: mat (list of list of int): The input matrix containing non-negative integers. Returns: int: The minimum sum of the values along the path. if not mat or not mat[0]: return 0 m, n = len(mat), len(mat[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = mat[0][0] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + mat[i][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + mat[0][j] # Populate the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + mat[i][j] return dp[m-1][n-1]"},{"question":"def trap(heights: List[int]) -> int: Calculate the total amount of water that can be trapped between the buildings. :param heights: List of integers representing the heights of the buildings :type heights: list[int] :return: Maximum amount of trapped water :rtype: int >>> trap([4, 2, 0, 3, 2, 5]) 9 >>> trap([]) 0 >>> trap([1, 1, 1, 1, 1]) 0 >>> trap([1, 2, 3]) 0 >>> trap([3, 2, 1]) 0 >>> trap([5, 4, 1, 2]) 1 >>> trap([3, 0, 2, 0, 4]) 7 >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6","solution":"def trap(heights): Calculate the total amount of water that can be trapped between the buildings. :param heights: List of integers representing the heights of the buildings :type heights: list[int] :return: Maximum amount of trapped water :rtype: int if not heights: return 0 n = len(heights) left, right = 0, n - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if heights[left] < heights[right]: if heights[left] >= left_max: left_max = heights[left] else: water_trapped += left_max - heights[left] left += 1 else: if heights[right] >= right_max: right_max = heights[right] else: water_trapped += right_max - heights[right] right -= 1 return water_trapped"},{"question":"def intersection(nums1: List[int], nums2: List[int]) -> List[int]: Returns the intersection of nums1 and nums2 arrays. Each element in the result is unique, and the order does not matter. >>> intersection([1, 2, 2, 1], [2, 2]) == [2] >>> intersection([4, 9, 5], [9, 4, 9, 8, 4]) == [4, 9] >>> intersection([1, 2, 3], [4, 5, 6]) == [] >>> intersection([], []) == [] >>> intersection([1, 2, 3], []) == [] >>> intersection([], [1, 2, 3]) == [] >>> intersection([1, 1, 2, 2, 3, 3], [2, 2, 3, 3, 4, 4]) == [2, 3]","solution":"def intersection(nums1, nums2): Returns the intersection of nums1 and nums2 arrays. Each element in the result is unique, and the order does not matter. set1 = set(nums1) set2 = set(nums2) return list(set1 & set2)"},{"question":"def min_swaps_to_sort(heights: List[int], k: int) -> List[int]: Returns the array sorted in non-decreasing order using at most k swaps. heights: List[int] - The list of heights of the people in the queue k: int - The maximum number of swaps allowed return: List[int] - The array sorted in non-decreasing order >>> min_swaps_to_sort([1, 2, 3, 4, 5], 3) [1, 2, 3, 4, 5] >>> min_swaps_to_sort([3, 2, 1], 1) [1, 2, 3] >>> min_swaps_to_sort([4, 2, 3, 1], 2) [1, 2, 3, 4] >>> min_swaps_to_sort([4, 3, 1, 2], 3) [1, 2, 3, 4] >>> min_swaps_to_sort([4, 3, 1, 2], 2) [4, 3, 1, 2] >>> min_swaps_to_sort([4, 3, 1, 2], 0) [4, 3, 1, 2] >>> min_swaps_to_sort([1], 0) [1] >>> min_swaps_to_sort([7, 1, 3, 2, 4, 5, 6], 10) [1, 2, 3, 4, 5, 6, 7] >>> min_swaps_to_sort([2, 3, 4, 1], 10) [1, 2, 3, 4]","solution":"def min_swaps_to_sort(heights, k): Returns the array sorted in non-decreasing order using at most k swaps. heights: List[int] - The list of heights of the people in the queue k: int - The maximum number of swaps allowed return: List[int] - The array sorted in non-decreasing order n = len(heights) if n <= 1: return heights # Create a list of the original indices of the elements indexed_heights = list(enumerate(heights)) # Sort the list based on heights indexed_heights.sort(key=lambda x: x[1]) # Create a boolean array to keep track of visited elements visited = [False] * n swaps = 0 for i in range(n): # If element is already visited or is already at the correct position, skip if visited[i] or indexed_heights[i][0] == i: continue # Calculate the number of nodes in this cycle cycle_length = 0 j = i while not visited[j]: visited[j] = True j = indexed_heights[j][0] cycle_length += 1 # Add the number of swaps needed for this cycle if cycle_length > 0: swaps += (cycle_length - 1) # If the number of swaps exceeds k, return original array if swaps > k: return heights # Result array after potentially swapping result = [0] * n for i, (orig_idx, height) in enumerate(indexed_heights): result[i] = height return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def hasPathSum(root: TreeNode, sum: int) -> bool: Determine if there exists a root-to-leaf path such that adding up all the values along the path equals a given sum. >>> hasPathSum(TreeNode(5, TreeNode(4, TreeNode(11, TreeNode(7), TreeNode(2))), TreeNode(8, TreeNode(13), TreeNode(4, None, TreeNode(1)))), 22) True >>> hasPathSum(TreeNode(1, TreeNode(2), TreeNode(3)), 5) False >>> hasPathSum(TreeNode(1), 1) True >>> hasPathSum(TreeNode(1), 2) False >>> hasPathSum(TreeNode(1, TreeNode(2), TreeNode(3)), 100) False >>> hasPathSum(None, 0) False >>> hasPathSum(None, 5) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def hasPathSum(root: TreeNode, sum: int) -> bool: if not root: return False sum -= root.val if not root.left and not root.right: return sum == 0 return hasPathSum(root.left, sum) or hasPathSum(root.right, sum)"},{"question":"def furthest_building(heights: List[int], bricks: int, ladders: int) -> int: Return the farthest building index (0-based) you can reach if you start at building 0. >>> furthest_building([4, 2, 7, 6, 9, 14, 12], 5, 1) == 4 >>> furthest_building([4, 12, 2, 7, 3, 18, 20, 3, 19], 10, 2) == 7 >>> furthest_building([1, 2], 0, 1) == 1 >>> furthest_building([1, 2], 1, 0) == 1 >>> furthest_building([5, 4, 3, 2, 1], 0, 0) == 4 >>> furthest_building([1, 2, 3, 4], 0, 2) == 2 >>> furthest_building([2, 3, 4, 5, 6], 10, 10) == 4 >>> furthest_building([1, 5, 1, 2, 3, 4, 100], 10, 2) == 6","solution":"import heapq def furthest_building(heights, bricks, ladders): max_heap = [] n = len(heights) for i in range(n - 1): diff = heights[i + 1] - heights[i] if diff > 0: heapq.heappush(max_heap, diff) if len(max_heap) > ladders: bricks -= heapq.heappop(max_heap) if bricks < 0: return i return n - 1"},{"question":"def count_isolated_cars(parking_lot): Count the number of isolated cars in the parking lot grid. An isolated car is one that is not adjacent to any other car. :param parking_lot: List of lists where each element is 0 (empty) or 1 (occupied). :return: Integer count of isolated cars. >>> count_isolated_cars([[0, 0], [0, 0]]) == 0 >>> count_isolated_cars([[0, 0], [0, 1]]) == 1 >>> count_isolated_cars([[1, 1], [1, 1]]) == 0 >>> count_isolated_cars([[1, 0], [0, 1]]) == 2 >>> count_isolated_cars([[1, 1], [0, 0], [1, 0]]) == 1 >>> count_isolated_cars([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) == 5","solution":"def count_isolated_cars(parking_lot): Counts the number of isolated cars in the parking lot grid. An isolated car is one that is not adjacent to any other car. :param parking_lot: List of lists where each element is 0 (empty) or 1 (occupied). :return: Integer count of isolated cars. n = len(parking_lot) m = len(parking_lot[0]) if n > 0 else 0 isolated_cars = 0 for i in range(n): for j in range(m): if parking_lot[i][j] == 1: # Check adjacent cells if (i > 0 and parking_lot[i-1][j] == 1) or (i < n-1 and parking_lot[i+1][j] == 1) or (j > 0 and parking_lot[i][j-1] == 1) or (j < m-1 and parking_lot[i][j+1] == 1): continue isolated_cars += 1 return isolated_cars"},{"question":"from typing import List class Solution: def __init__(self, matrix: List[List[int]], target: int): Initializes the object with the 2D matrix and the target integer. self.matrix = matrix self.target = target def searchTarget(self) -> bool: Returns true if the target integer is in the matrix, and false otherwise. >>> sol1 = Solution([[1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]], 5) >>> sol1.searchTarget() True >>> sol2 = Solution([[1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]], 20) >>> sol2.searchTarget() False >>> sol3 = Solution([[1, 4, 7, 11, 15]], 11) >>> sol3.searchTarget() True >>> sol4 = Solution([[1, 4, 7, 11, 15]], 20) >>> sol4.searchTarget() False >>> sol5 = Solution([[1], [2], [3]], 2) >>> sol5.searchTarget() True >>> sol6 = Solution([[5]], 3) >>> sol6.searchTarget() False >>> sol7 = Solution([], 1) >>> sol7.searchTarget() False","solution":"class Solution: def __init__(self, matrix, target): self.matrix = matrix self.target = target def searchTarget(self): if not self.matrix or not self.matrix[0]: return False rows = len(self.matrix) cols = len(self.matrix[0]) # Start from the top-right corner row = 0 col = cols - 1 while row < rows and col >= 0: if self.matrix[row][col] == self.target: return True elif self.matrix[row][col] < self.target: row += 1 else: col -= 1 return False"},{"question":"from typing import List def maxMovies(movies: List[List[int]]) -> int: Schedule the maximum number of non-overlapping movies to watch completely. >>> maxMovies([[1, 4], [2, 5], [3, 6], [7, 9], [8, 10]]) 2 >>> maxMovies([[1, 2]]) 1 >>> maxMovies([]) 0 >>> maxMovies([[1, 2], [3, 4], [5, 6]]) 3 >>> maxMovies([[1, 4], [2, 4], [3, 4]]) 1 >>> maxMovies([[1, 2], [2, 3], [3, 4], [4, 5]]) 4 >>> maxMovies([[1, 3], [1, 3], [1, 3]]) 1","solution":"def maxMovies(movies): # First, sort movies by their end times movies.sort(key=lambda x: x[1]) end_time = float('-inf') count = 0 for movie in movies: if movie[0] >= end_time: count += 1 end_time = movie[1] return count"},{"question":"from typing import List def find_kth_largest(arr: List[int], k: int) -> int: Finds and returns the k-th largest element in the list using a min-heap. >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([1], 1) 1 >>> find_kth_largest([2, 2, 2, 2, 2, 2], 3) 2 >>> find_kth_largest([7, 10, 4, 3, 20, 15], 4) 7 >>> find_kth_largest([5, 3, 1, 6, 4, 2], 3) 4 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4","solution":"from typing import List import heapq def find_kth_largest(arr: List[int], k: int) -> int: Finds and returns the k-th largest element in the list using a min-heap. if not arr or k <= 0 or k > len(arr): raise ValueError(\\"Invalid input parameters\\") # Initialize a min-heap with the first k elements of the list min_heap = arr[:k] heapq.heapify(min_heap) # O(k) # Traverse through the remaining elements for num in arr[k:]: if num > min_heap[0]: # Compare with the smallest element in the min-heap heapq.heapreplace(min_heap, num) # O(log k) # The root of the heap is the k-th largest element return min_heap[0]"},{"question":"def can_complete_circuit(gas, cost): Returns the starting gas station index if a circular trip is possible. If no such trip is possible, returns -1. :param gas: List[int] - Amount of fuel at each gas station. :param cost: List[int] - Fuel needed to travel to the next station. :return: int - Index of the starting gas station, or -1 if no such index exists.","solution":"def can_complete_circuit(gas, cost): Returns the starting gas station index if a circular trip is possible. If no such trip is possible, returns -1. :param gas: List[int] - Amount of fuel at each gas station. :param cost: List[int] - Fuel needed to travel to the next station. :return: int - Index of the starting gas station, or -1 if no such index exists. total_tank, curr_tank = 0, 0 start_station = 0 for i in range(len(gas)): total_tank += gas[i] - cost[i] curr_tank += gas[i] - cost[i] # If one cannot start from start_station to current i if curr_tank < 0: start_station = i + 1 curr_tank = 0 return start_station if total_tank >= 0 else -1"},{"question":"class BinaryTree: def __init__(self, edges: List[List[int]], root: int): Initializes the object with the edges array representing the connections between nodes and the root value specifying the root of the tree. Parameters: edges (List[List[int]]): array representing the connections between nodes root (int): value specifying the root of the tree. def findLCA(self, node1: int, node2: int) -> int: Returns the lowest common ancestor (LCA) of the two nodes node1 and node2. The LCA of two nodes node1 and node2 is the lowest node that has both node1 and node2 as descendants (where we allow a node to be a descendant of itself). Parameters: node1 (int): First node's value node2 (int): Second node's value Returns: int: The value of the lowest common ancestor Examples: >>> bt = BinaryTree([[1, 2], [1, 3], [2, 4], [2, 5]], 1) >>> bt.findLCA(4, 5) 2 >>> bt.findLCA(4, 3) 1 # Unit test cases def test_lca_same_parent(): bt = BinaryTree([[1, 2], [1, 3], [2, 4], [2, 5]], 1) assert bt.findLCA(4, 5) == 2 def test_lca_different_parents(): bt = BinaryTree([[1, 2], [1, 3], [2, 4], [2, 5]], 1) assert bt.findLCA(4, 3) == 1 def test_lca_with_node_itself(): bt = BinaryTree([[1, 2], [1, 3], [2, 4], [2, 5]], 1) assert bt.findLCA(4, 4) == 4 def test_lca_direct_child_parent(): bt = BinaryTree([[1, 2], [1, 3], [2, 4], [2, 5]], 1) assert bt.findLCA(2, 4) == 2 assert bt.findLCA(4, 2) == 2 def test_lca_root(): bt = BinaryTree([[1, 2], [1, 3], [2, 4], [2, 5]], 1) assert bt.findLCA(1, 4) == 1","solution":"class TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None class BinaryTree: def __init__(self, edges, root): self.nodes = {} for edge in edges: parent, child = edge if parent not in self.nodes: self.nodes[parent] = TreeNode(parent) if child not in self.nodes: self.nodes[child] = TreeNode(child) self.add_child(self.nodes[parent], self.nodes[child]) self.root = self.nodes[root] def add_child(self, parent, child): if not parent.left: parent.left = child else: parent.right = child def findLCAUtil(self, root, node1, node2): if root is None: return None if root.val == node1 or root.val == node2: return root left_lca = self.findLCAUtil(root.left, node1, node2) right_lca = self.findLCAUtil(root.right, node1, node2) if left_lca and right_lca: return root return left_lca if left_lca else right_lca def findLCA(self, node1, node2): lca = self.findLCAUtil(self.root, node1, node2) return lca.val if lca else -1"},{"question":"from collections import Counter import heapq def rearrange_string(s: str, k: int) -> str: Given a string s and an integer k, determine if it is possible to rearrange the characters in the string such that no two adjacent characters are the same. If possible, return one possible rearranged string. Otherwise, return an empty string. >>> rearrange_string(\\"aabb\\", 2) in [\\"abab\\", \\"baba\\"] True >>> rearrange_string(\\"aaab\\", 2) '' >>> rearrange_string(\\"\\", 1) '' >>> rearrange_string(\\"abc\\", 0) 'abc' >>> rearrange_string(\\"a\\", 2) 'a' >>> rearrange_string(\\"aaaa\\", 2) '' >>> rearrange_string(\\"aaaa\\", 0) 'aaaa'","solution":"from collections import Counter import heapq def rearrange_string(s, k): Rearrange the characters of the string such that no two adjacent characters are the same. If not possible, return an empty string. if k == 0: return s count = Counter(s) max_heap = [(-val, key) for key, val in count.items()] heapq.heapify(max_heap) result = [] wait_queue = [] while max_heap: current_count, current_char = heapq.heappop(max_heap) result.append(current_char) wait_queue.append((current_count + 1, current_char)) if len(wait_queue) < k: continue next_count, next_char = wait_queue.pop(0) if next_count < 0: heapq.heappush(max_heap, (next_count, next_char)) if len(result) != len(s): return \\"\\" return ''.join(result)"},{"question":"def max_final_card_value(numbers): Returns the maximum possible score for the final card's value if the players choose optimally to maximize it by summing pairs of card values. >>> max_final_card_value([1, 2, 3, 4, 5]) == 15 >>> max_final_card_value([10]) == 10 >>> max_final_card_value([2, 3]) == 5 >>> max_final_card_value([-1, 2, -3, 4, -5]) == -3 >>> max_final_card_value([0, 0, 0, 0, 0]) == 0 >>> max_final_card_value([1000000, 2000000, 3000000]) == 6000000","solution":"def max_final_card_value(numbers): Returns the maximum possible score for the final card's value if the players choose optimally to maximize it by summing pairs of card values. total_score = sum(numbers) return total_score"},{"question":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root: Optional[TreeNode]) -> List[List[int]]: Returns the zigzag level order traversal of a binary tree. Args: root (TreeNode): The root of the binary tree. Returns: List[List[int]]: The zigzag level order traversal of the tree. pass def test_zigzag_level_order_empty_tree(): assert zigzagLevelOrder(None) == [] def test_zigzag_level_order_single_node(): root = TreeNode(1) assert zigzagLevelOrder(root) == [[1]] def test_zigzag_level_order_two_levels(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) assert zigzagLevelOrder(root) == [[1], [3, 2]] def test_zigzag_level_order_three_levels(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) assert zigzagLevelOrder(root) == [[1], [3, 2], [4, 5, 6, 7]] def test_zigzag_level_order_unequal_subtrees(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.right = TreeNode(7) assert zigzagLevelOrder(root) == [[1], [3, 2], [4, 5, 7]]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root): Returns the zigzag level order traversal of a binary tree. Args: root (TreeNode): The root of the binary tree. Returns: List[List[int]]: The zigzag level order traversal of the tree. if not root: return [] result = [] current_level = deque([root]) left_to_right = True while current_level: level_size = len(current_level) current_vals = deque() for _ in range(level_size): node = current_level.popleft() if left_to_right: current_vals.append(node.val) else: current_vals.appendleft(node.val) if node.left: current_level.append(node.left) if node.right: current_level.append(node.right) result.append(list(current_vals)) left_to_right = not left_to_right return result"},{"question":"def min_cost_to_make_equal(nums): Given a list of integers, return the minimum cost to make all elements equal. The cost of changing any element by 1 is 1. >>> min_cost_to_make_equal([5, 5, 5, 5]) 0 >>> min_cost_to_make_equal([10]) 0 >>> min_cost_to_make_equal([1, 2, 3]) 2 >>> min_cost_to_make_equal([1, 10, 2, 9, 3, 8, 4, 7, 5, 6]) 25 >>> min_cost_to_make_equal([-1, -2, -3, -4]) 4 >>> min_cost_to_make_equal([-1, 0, 1, 2]) 4 >>> min_cost_to_make_equal([8, 1, 2, 4]) 9 >>> min_cost_to_make_equal([5, 5, 5, 5, 10]) 5","solution":"def min_cost_to_make_equal(nums): Given a list of integers, return the minimum cost to make all elements equal. The cost of changing any element by 1 is 1. nums.sort() median = nums[len(nums)//2] return sum(abs(num - median) for num in nums)"},{"question":"def subset_sum(nums, targetSum): Determine if there exists a subset of the list of unique positive integers \`nums\` whose sum is equal to \`targetSum\`. If such a subset exists, return a list containing the subset's integers. Otherwise, return an empty list. >>> subset_sum([2, 3, 7, 8, 10], 11) # Possible outputs: [3, 8] or [2, 3, 7] [3, 8] >>> subset_sum([1, 2, 3, 4, 5], 20) [] >>> subset_sum([5], 5) [5] >>> subset_sum([1, 2, 3], 0) [] >>> subset_sum([], 7) [] >>> subset_sum([10, 20, 30, 40, 50], 90) # Possible outputs: [20, 30, 40] or other valid combinations [20, 30, 40]","solution":"def subset_sum(nums, targetSum): Determine if there exists a subset of the list of unique positive integers \`nums\` whose sum is equal to \`targetSum\`. If such a subset exists, return a list containing the subset's integers. Otherwise, return an empty list. def dfs(index, current_sum, path): if current_sum == targetSum: return path if index >= len(nums) or current_sum > targetSum: return [] # Explore the path including nums[index] include_result = dfs(index + 1, current_sum + nums[index], path + [nums[index]]) if include_result: return include_result # Explore the path excluding nums[index] exclude_result = dfs(index + 1, current_sum, path) return exclude_result return dfs(0, 0, [])"},{"question":"def has_subarray_with_sum(arr: List[int], x: int) -> bool: Determines if there is a continuous subarray in \`arr\` whose sum is equal to \`x\`. Parameters: arr (list of int): The array to check. x (int): The target sum. Returns: bool: True if such subarray exists, False otherwise. Examples: >>> has_subarray_with_sum([1, 2, 3, 7, 5], 12) True >>> has_subarray_with_sum([1, 2, 3, 7, 5], 15) True >>> has_subarray_with_sum([1, 2, 3, 7, 5], 100) False >>> has_subarray_with_sum([3, 4, 7, -1, 3], 7) True >>> has_subarray_with_sum([1, -1, 3, 2, 5, -5, 3], 0) True","solution":"def has_subarray_with_sum(arr, x): Determines if there is a continuous subarray in \`arr\` whose sum is equal to \`x\`. Parameters: arr (list of int): The array to check. x (int): The target sum. Returns: bool: True if such subarray exists, False otherwise. current_sum = 0 sums_dict = {} for i, num in enumerate(arr): current_sum += num if current_sum == x: return True if (current_sum - x) in sums_dict: return True sums_dict[current_sum] = i return False"},{"question":"from typing import List def maximumProduct(nums: List[int]) -> int: Returns the maximum product of any three numbers in the given list \`nums\`. >>> maximumProduct([1, 2, 3]) == 6 >>> maximumProduct([1, 2, 3, 4]) == 24 >>> maximumProduct([-1, -2, -3]) == -6 >>> maximumProduct([-1, -2, -3, 1]) == 6 >>> maximumProduct([-10, -10, 5, 2]) == 500 >>> maximumProduct([1, -4, 3, -6, 7, 0]) == 168 >>> maximumProduct([0, -1, 3, 100, 70, 50]) == 350000 >>> maximumProduct([-10, -10, -1, 2, 3, 4]) == 400 >>> maximumProduct([-10, -10, 5, 5, 2]) == 500","solution":"from typing import List def maximumProduct(nums: List[int]) -> int: Returns the maximum product of any three numbers in the given list \`nums\`. nums.sort() # The maximum product of any three numbers could be either from # the last three numbers (max1) or the product of the two smallest # and the largest number (max2) max1 = nums[-1] * nums[-2] * nums[-3] max2 = nums[0] * nums[1] * nums[-1] return max(max1, max2)"},{"question":"from typing import List from collections import Counter def min_deletions(s: str, k: int) -> int: Determine the minimum number of deletions required so that every character in the string s occurs at most k times. :param s: A string of lowercase English letters :param k: An integer :return: Minimum number of deletions required >>> min_deletions(\\"aabbcc\\", 2) 0 >>> min_deletions(\\"aaabbbcc\\", 2) 2 >>> min_deletions(\\"aaaaa\\", 3) 2 >>> min_deletions(\\"\\", 3) 0 >>> min_deletions(\\"abcdef\\", 10) 0 >>> min_deletions(\\"aabbbccc\\", 1) 5","solution":"from collections import Counter def min_deletions(s, k): Determine the minimum number of deletions required so that every character in the string s occurs at most k times. :param s: A string of lowercase English letters :param k: An integer :return: Minimum number of deletions frequency = Counter(s) deletions = 0 for char, freq in frequency.items(): if freq > k: deletions += freq - k return deletions"},{"question":"def max_non_overlapping_intervals(intervals: List[List[int]]) -> int: Given a list of integer intervals \`intervals\`, where each interval \`intervals[i] = [starti, endi]\` represents a range of integers from \`starti\` to \`endi\` (inclusive), determine the maximum number of non-overlapping intervals from the list. An interval is non-overlapping if it does not share any numbers with another interval in the selected subset. Return the maximum number of non-overlapping intervals that can be selected. >>> max_non_overlapping_intervals([]) 0 >>> max_non_overlapping_intervals([[1, 2]]) 1 >>> max_non_overlapping_intervals([[1, 2], [3, 4], [5, 6]]) 3 >>> max_non_overlapping_intervals([[1, 3], [2, 4], [3, 5], [6, 7]]) 2 >>> max_non_overlapping_intervals([[1, 5], [2, 6], [3, 7], [4, 8]]) 1 >>> max_non_overlapping_intervals([[1, 2], [2, 3], [3, 4], [1, 4]]) 2 >>> max_non_overlapping_intervals([[1, 3], [2, 3], [3, 3]]) 1 >>> max_non_overlapping_intervals([[1, 2], [1, 3], [1, 4]]) 1","solution":"def max_non_overlapping_intervals(intervals): Returns the maximum number of non-overlapping intervals. :param intervals: List[List[int]], a list of integer intervals :return: int, the maximum number of non-overlapping intervals if not intervals: return 0 # Sort intervals by their ending times intervals.sort(key=lambda x: x[1]) max_count = 0 end_time = float('-inf') for interval in intervals: if interval[0] > end_time: max_count += 1 end_time = interval[1] return max_count"},{"question":"class LabyrinthPathFinder: def __init__(self, matrix): Initializes the object with a 2D matrix representing the labyrinth. pass def isPathPossible(self): Returns \`true\` if there is a path from the top-left cell to the bottom-right cell, otherwise returns \`false\`. pass import pytest from solution import LabyrinthPathFinder def test_path_exists(): matrix = [ [0, 0, 1], [0, 0, 1], [1, 0, 0] ] labyrinth = LabyrinthPathFinder(matrix) assert labyrinth.isPathPossible() == True def test_no_path_due_to_block(): matrix = [ [0, 1, 1], [1, 1, 0], [1, 0, 0] ] labyrinth = LabyrinthPathFinder(matrix) assert labyrinth.isPathPossible() == False def test_no_path_due_to_start_blocked(): matrix = [ [1, 0, 0], [0, 0, 0], [0, 0, 0] ] labyrinth = LabyrinthPathFinder(matrix) assert labyrinth.isPathPossible() == False def test_no_path_due_to_end_blocked(): matrix = [ [0, 0, 0], [0, 0, 0], [0, 0, 1] ] labyrinth = LabyrinthPathFinder(matrix) assert labyrinth.isPathPossible() == False def test_small_matrix_no_path(): matrix = [ [0, 1], [1, 0] ] labyrinth = LabyrinthPathFinder(matrix) assert labyrinth.isPathPossible() == False def test_all_open_path(): matrix = [ [0, 0], [0, 0] ] labyrinth = LabyrinthPathFinder(matrix) assert labyrinth.isPathPossible() == True def test_large_open_path(): matrix = [ [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0] ] labyrinth = LabyrinthPathFinder(matrix) assert labyrinth.isPathPossible() == True def test_large_mixed(): matrix = [ [0, 1, 1, 0, 0], [0, 0, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 0, 0, 1], [0, 0, 0, 0, 0] ] labyrinth = LabyrinthPathFinder(matrix) assert labyrinth.isPathPossible() == True","solution":"class LabyrinthPathFinder: def __init__(self, matrix): self.matrix = matrix self.m = len(matrix) self.n = len(matrix[0]) self.visited = [[False for _ in range(self.n)] for _ in range(self.m)] def isPathPossible(self): if self.matrix[0][0] == 1 or self.matrix[self.m - 1][self.n - 1] == 1: return False return self.dfs(0, 0) def dfs(self, x, y): if x == self.m - 1 and y == self.n - 1: return True self.visited[x][y] = True directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < self.m and 0 <= ny < self.n and not self.visited[nx][ny] and self.matrix[nx][ny] == 0: if self.dfs(nx, ny): return True return False"},{"question":"def filterLogs(logs: List[str], start: int, end: int) -> List[str]: Filters the logs to only include those within the specified time range. Parameters: logs (list): List of log entries where each log is a string in the format \\"id timestamp event\\". start (int): Start of the time range (inclusive). end (int): End of the time range (inclusive). Returns: list: List of logs within the specified time range. >>> filterLogs([], 0, 86399) [] >>> filterLogs([\\"id1 3600 event1\\", \\"id2 7200 event2\\", \\"id3 10800 event3\\"], 0, 86399) [\\"id1 3600 event1\\", \\"id2 7200 event2\\", \\"id3 10800 event3\\"] >>> filterLogs([\\"id1 3600 event1\\", \\"id2 7200 event2\\", \\"id3 10800 event3\\"], 20000, 30000) [] >>> filterLogs([\\"id1 1000 event1\\", \\"id2 5000 event2\\", \\"id3 25000 event3\\"], 1000, 10000) [\\"id1 1000 event1\\", \\"id2 5000 event2\\"] >>> filterLogs([\\"id1 0 event1\\", \\"id2 86399 event2\\"], 0, 86399) [\\"id1 0 event1\\", \\"id2 86399 event2\\"]","solution":"def filterLogs(logs, start, end): Filters the logs to only include those within the specified time range. Parameters: logs (list): List of log entries where each log is a string in the format \\"id timestamp event\\". start (int): Start of the time range (inclusive). end (int): End of the time range (inclusive). Returns: list: List of logs within the specified time range. filtered_logs = [] for log in logs: parts = log.split() timestamp = int(parts[1]) if start <= timestamp <= end: filtered_logs.append(log) return filtered_logs"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: You have a list of strings \`words\` and you want to group the anagrams together. Each list of anagrams must be sorted in lexicographical order and the list of lists should be sorted in ascending order based on the first string of each group. For example, given the list \`words = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]\`, the function should return \`[[\\"ate\\", \\"eat\\", \\"tea\\"], [\\"bat\\"], [\\"nat\\", \\"tan\\"]]\`. >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\\"ate\\", \\"eat\\", \\"tea\\"], [\\"bat\\"], [\\"nat\\", \\"tan\\"]] >>> group_anagrams([\\"hello\\"]) [[\\"hello\\"]] >>> group_anagrams([\\"cat\\", \\"dog\\", \\"bird\\"]) [[\\"bird\\"], [\\"cat\\"], [\\"dog\\"]] >>> group_anagrams([\\"bat\\", \\"tab\\", \\"BAT\\"]) [[\\"BAT\\"], [\\"bat\\", \\"tab\\"]] >>> group_anagrams([]) [] >>> group_anagrams([\\"foo\\", \\"foo\\", \\"oof\\", \\"oof\\"]) [[\\"foo\\", \\"foo\\", \\"oof\\", \\"oof\\"]]","solution":"def group_anagrams(words): from collections import defaultdict anagrams = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) result = [] for key in anagrams: result.append(sorted(anagrams[key])) return sorted(result, key=lambda x: x[0])"},{"question":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kthSmallest(root: Optional[TreeNode], k: int) -> int: Find the k-th smallest element in a binary search tree (BST). >>> root = TreeNode(3) >>> root.left = TreeNode(1) >>> root.right = TreeNode(4) >>> root.left.right = TreeNode(2) >>> kthSmallest(root, 1) 1 >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(6) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.left.left.left = TreeNode(1) >>> kthSmallest(root, 3) 3","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kthSmallest(root: Optional[TreeNode], k: int) -> int: # In-order traversal of BST yields elements in a sorted order stack = [] current = root count = 0 while True: while current: stack.append(current) current = current.left current = stack.pop() count += 1 if count == k: return current.val current = current.right"},{"question":"def rearrange_array(arr: List[int], pivot: int) -> List[int]: Rearranges the array such that: - All elements less than the pivot appear before all elements equal to the pivot, - All elements equal to the pivot appear before all elements greater than the pivot. The relative order of the elements in each of the three partitions is preserved. Parameters: arr (list of int): The list of integers to be rearranged. pivot (int): The pivot integer. Returns: list of int: The rearranged list. pass from solution import rearrange_array def test_rearrange_array(): arr = [7, 4, 3, 9, 3, 5, 1] pivot = 4 expected = [3, 3, 1, 4, 7, 9, 5] assert rearrange_array(arr, pivot) == expected def test_rearrange_array_duplicate_elements(): arr = [1, 2, 2, 3, 4] pivot = 2 expected = [1, 2, 2, 3, 4] assert rearrange_array(arr, pivot) == expected def test_rearrange_array_no_less_than_pivot(): arr = [7, 8, 9, 4] pivot = 4 expected = [4, 7, 8, 9] assert rearrange_array(arr, pivot) == expected def test_rearrange_array_no_greater_than_pivot(): arr = [1, 2, 3, 4] pivot = 4 expected = [1, 2, 3, 4] assert rearrange_array(arr, pivot) == expected def test_rearrange_array_no_equal_to_pivot(): arr = [1, 3, 5, 6] pivot = 4 expected = [1, 3, 5, 6] assert rearrange_array(arr, pivot) == expected def test_rearrange_array_mixed_elements(): arr = [4, 5, 6, 1, 2, 3] pivot = 5 expected = [4, 1, 2, 3, 5, 6] assert rearrange_array(arr, pivot) == expected","solution":"def rearrange_array(arr, pivot): Rearranges the array such that: - All elements less than the pivot appear before all elements equal to the pivot, - All elements equal to the pivot appear before all elements greater than the pivot. The relative order of the elements in each of the three partitions is preserved. Parameters: arr (list of int): The list of integers to be rearranged. pivot (int): The pivot integer. Returns: list of int: The rearranged list. less_than_pivot = [] equal_to_pivot = [] greater_than_pivot = [] for num in arr: if num < pivot: less_than_pivot.append(num) elif num == pivot: equal_to_pivot.append(num) else: greater_than_pivot.append(num) return less_than_pivot + equal_to_pivot + greater_than_pivot"},{"question":"def min_replacements_to_palindrome(s: str) -> int: Given a string 's' consisting of lowercase letters, return the minimum number of characters needed to be replaced to make 's' a palindrome. >>> min_replacements_to_palindrome(\\"abcd\\") == 2 >>> min_replacements_to_palindrome(\\"abccba\\") == 0 >>> min_replacements_to_palindrome(\\"racecar\\") == 0 >>> min_replacements_to_palindrome(\\"a\\") == 0 >>> min_replacements_to_palindrome(\\"aa\\") == 0 >>> min_replacements_to_palindrome(\\"ab\\") == 1 >>> min_replacements_to_palindrome(\\"abc\\") == 1 >>> min_replacements_to_palindrome(\\"abca\\") == 1 >>> min_replacements_to_palindrome(\\"aaabaaa\\") == 0 >>> min_replacements_to_palindrome(\\"abcdcba\\") == 0","solution":"def min_replacements_to_palindrome(s): Returns the minimum number of characters required to replace to make the string a palindrome. n = len(s) replacements = 0 # Compare characters from the beginning and the end of the string moving towards the center for i in range(n // 2): if s[i] != s[n - i - 1]: replacements += 1 return replacements"},{"question":"def maxTreePathSum(values, edges): Computes the maximum sum of values from any tree path. A tree path is a sequence of nodes such that there is an edge between any two consecutive nodes in the path. Args: values (List[int]): An integer array of size n where each element represents the value of the corresponding node. edges (List[List[int]]): A 2D integer array of size n-1 where each element is a pair [u, v] that represents an edge between nodes u and v. Returns: int: The maximum sum of values from any valid tree path. >>> values = [4, 2, 7, 1, 3] >>> edges = [[1, 2], [1, 3], [2, 4], [2, 5]] >>> maxTreePathSum(values, edges) 16 >>> values = [10] >>> edges = [] >>> maxTreePathSum(values, edges) 10 >>> values = [3, 2] >>> edges = [[1, 2]] >>> maxTreePathSum(values, edges) 5 >>> values = [1, 2, 3, 4, 5] >>> edges = [[1, 2], [2, 3], [3, 4], [4, 5]] >>> maxTreePathSum(values, edges) 15 >>> values = [1, 2, 3, 4, 5, 6, 7] >>> edges = [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7]] >>> maxTreePathSum(values, edges) 18 >>> values = [-10, 20, -30, 40, 50] >>> edges = [[1, 2], [1, 3], [2, 4], [2, 5]] >>> maxTreePathSum(values, edges) 110","solution":"def maxTreePathSum(values, edges): from collections import defaultdict def dfs(node, parent): max1, max2 = 0, 0 current_max_path = values[node - 1] for neighbor in graph[node]: if neighbor != parent: subtree_sum = dfs(neighbor, node) if subtree_sum > max1: max2 = max1 max1 = subtree_sum elif subtree_sum > max2: max2 = subtree_sum # Update the global maximum path sum using the sum through this node. global_max[0] = max(global_max[0], current_max_path + max1 + max2) return current_max_path + max1 graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) n = len(values) # Edge case for a single node tree if n == 1: return values[0] global_max = [-float('inf')] dfs(1, -1) return global_max[0]"},{"question":"def rob(nums: List[int]) -> int: Returns the maximum amount of money you can rob tonight without alerting the police. You cannot rob two adjacent houses. >>> rob([1, 2, 3, 1]) 4 >>> rob([2]) 2 >>> rob([2, 3]) 3 >>> rob([0, 0, 0, 0]) 0 >>> rob([2, 1, 1, 2]) 4 >>> rob([5, 1, 1, 5]) 10 >>> rob([]) 0 >>> rob([1]*100) 50","solution":"from typing import List def rob(nums: List[int]) -> int: Returns the maximum amount of money you can rob tonight without alerting the police. You cannot rob two adjacent houses. if not nums: return 0 if len(nums) == 1: return nums[0] rob1, rob2 = 0, 0 for n in nums: new_rob = max(rob1 + n, rob2) rob1 = rob2 rob2 = new_rob return rob2"},{"question":"from typing import List, Tuple def sort_courses(courses: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts courses primarily by difficulty level in ascending order. When two courses have the same difficulty level, they are further sorted lexicographically by their names. >>> sort_courses([(\\"Math\\", 3), (\\"History\\", 1), (\\"Biology\\", 2), (\\"Computer Science\\", 3)]) [(\\"History\\", 1), (\\"Biology\\", 2), (\\"Computer Science\\", 3), (\\"Math\\", 3)] >>> sort_courses([(\\"Math\\", 3), (\\"Art\\", 3), (\\"History\\", 1), (\\"Biology\\", 2)]) [(\\"History\\", 1), (\\"Biology\\", 2), (\\"Art\\", 3), (\\"Math\\", 3)] >>> sort_courses([(\\"Math\\", 3), (\\"Art\\", 3), (\\"History\\", 3), (\\"Biology\\", 3)]) [(\\"Art\\", 3), (\\"Biology\\", 3), (\\"History\\", 3), (\\"Math\\", 3)] >>> sort_courses([]) [] >>> sort_courses([(\\"Math\\", 3)]) [(\\"Math\\", 3)] >>> sort_courses([(\\"Math\\", 3), (\\"math\\", 2), (\\"History\\", 1), (\\"history\\", 1)]) [(\\"History\\", 1), (\\"history\\", 1), (\\"math\\", 2), (\\"Math\\", 3)]","solution":"from typing import List, Tuple def sort_courses(courses: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts courses primarily by difficulty level in ascending order. When two courses have the same difficulty level, they are further sorted lexicographically by their names. Parameters: courses (List[Tuple[str, int]]): A list of tuples where each tuple contains the course name and its difficulty level. Returns: List[Tuple[str, int]]: A list of sorted courses based on the specified criteria. return sorted(courses, key=lambda course: (course[1], course[0]))"},{"question":"def min_operations(a: int, b: int) -> int: Given two non-negative integers \`a\` and \`b\`, find the minimum number of operations required to make \`a\` equal to \`b\`. In one operation, you can either increment \`a\` by 1, decrement \`a\` by 1, or double the value of \`a\`. Return the minimum number of operations needed to transform \`a\` to \`b\`. >>> min_operations(5, 5) 0 >>> min_operations(3, 5) 2 >>> min_operations(5, 3) 2 >>> min_operations(2, 7) 3 >>> min_operations(3, 8) 2 >>> min_operations(4, 21) 4 # Implementation here","solution":"from collections import deque def min_operations(a, b): Returns the minimum number of operations to transform a into b. if a == b: return 0 # Use a queue for BFS queue = deque([(a, 0)]) # each element is a tuple (current_value, steps) visited = set([a]) while queue: current, steps = queue.popleft() # Possible operations: increment, decrement, double next_values = [current + 1, current - 1, current * 2] for next_value in next_values: if next_value == b: return steps + 1 if next_value not in visited and next_value >= 0: visited.add(next_value) queue.append((next_value, steps + 1)) return -1 # Should never reach here as b is eventually reachable"},{"question":"def can_rearrange_to_match(s1: str, s2: str) -> bool: Determine if it is possible to make the two strings equal by rearranging the letters of s1. >>> can_rearrange_to_match(\\"abc\\", \\"bca\\") True >>> can_rearrange_to_match(\\"aab\\", \\"abc\\") False","solution":"def can_rearrange_to_match(s1, s2): Returns True if s1 can be rearranged to match s2, otherwise False. return sorted(s1) == sorted(s2)"},{"question":"from typing import List def can_visit_all_nodes(n: int, edges: List[List[int]]) -> bool: Determines if all nodes can be visited starting from node 0. Parameters: n (int): Number of nodes. edges (List[List[int]]): Directed edges of the graph. Returns: bool: True if all nodes are reachable from node 0, otherwise False. pass def test_single_node(): assert can_visit_all_nodes(1, []) == True def test_all_nodes_connected_sequentially(): assert can_visit_all_nodes(4, [[0, 1], [1, 2], [2, 3]]) == True def test_single_disconnected_node(): assert can_visit_all_nodes(4, [[0, 1], [1, 2]]) == False def test_all_nodes_interconnected(): assert can_visit_all_nodes(4, [[0, 1], [1, 2], [2, 3], [3, 0], [1, 3], [0, 2]]) == True def test_disconnected_graph(): assert can_visit_all_nodes(5, [[0, 1], [1, 2], [3, 4]]) == False def test_cycle_graph(): assert can_visit_all_nodes(3, [[0, 1], [1, 2], [2, 0]]) == True def test_back_edges(): assert can_visit_all_nodes(4, [[0, 1], [1, 2], [2, 0], [2, 3]]) == True","solution":"def can_visit_all_nodes(n, edges): Determines if all nodes can be visited starting from node 0. Parameters: n (int): Number of nodes. edges (List[List[int]]): Directed edges of the graph. Returns: bool: True if all nodes are reachable from node 0, otherwise False. from collections import defaultdict, deque graph = defaultdict(list) for a, b in edges: graph[a].append(b) visited = set() def bfs(start): queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: queue.append(neighbor) bfs(0) return len(visited) == n"},{"question":"def find_buildings_with_ocean_view(nums): Returns the list of indices of buildings that can see the ocean. Example: >>> find_buildings_with_ocean_view([4, 2, 3, 1]) == [0, 2, 3] >>> find_buildings_with_ocean_view([4, 3, 2, 1]) == [0]","solution":"def find_buildings_with_ocean_view(nums): Returns the list of indices of buildings that can see the ocean. n = len(nums) ocean_view_indices = [] max_height_so_far = -1 for i in range(n - 1, -1, -1): if nums[i] > max_height_so_far: ocean_view_indices.append(i) max_height_so_far = nums[i] return sorted(ocean_view_indices)"},{"question":"def reorder_logs(logs: List[str]) -> List[str]: Reorder the log entries such that: 1. The letter-logs come before all digit-logs. 2. The letter-logs are sorted lexicographically by their content. If their contents are identical, sort them by their identifiers. 3. The digit-logs remain in the same order in which they were received. >>> reorder_logs([\\"a1 9 2 3 1\\", \\"g1 act car\\", \\"zo4 4 7\\", \\"ab1 off key dog\\", \\"a8 act zoo\\"]) [\\"g1 act car\\", \\"a8 act zoo\\", \\"ab1 off key dog\\", \\"a1 9 2 3 1\\", \\"zo4 4 7\\"] pass","solution":"def reorder_logs(logs): Reorders the logs such that the letter-logs come before all digit-logs. The letter-logs are sorted lexicographically by their content. If their contents are identical, sort them by their identifiers. The digit-logs remain in the same order in which they were received. def get_key(log): id_, rest = log.split(\\" \\", 1) return (0, rest, id_) if rest[0].isalpha() else (1,) return sorted(logs, key=get_key)"},{"question":"def balancedStringSplit(s: str) -> int: Returns the maximum number of balanced strings that can be obtained from the given string. A balanced string is a string that has the same number of uppercase and lowercase letters. >>> balancedStringSplit(\\"Aa\\") == 1 >>> balancedStringSplit(\\"AaBb\\") == 2 >>> balancedStringSplit(\\"AaB\\") == 1 >>> balancedStringSplit(\\"AaBbCcDdEe\\") == 5 >>> balancedStringSplit(\\"AAAAaaa\\") == 0","solution":"def balancedStringSplit(s): Returns the maximum number of balanced strings that can be obtained from the given string. balance_count = 0 max_balanced_strings = 0 for char in s: if char.isupper(): balance_count += 1 else: balance_count -= 1 if balance_count == 0: max_balanced_strings += 1 return max_balanced_strings"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generateTrees(n: int) -> List[Optional[TreeNode]]: Given an integer \`n\`, generate all structurally unique BSTs (binary search trees) that store values 1 ... n. Return a list of all possible BSTs represented by their root node. >>> generateTrees(0) == [] >>> result = generateTrees(1) >>> len(result) == 1 and result[0].val == 1 and result[0].left == None and result[0].right == None True >>> result = generateTrees(2) >>> len(result) == 2 True >>> vals = [(tree.val, tree.left.val if tree.left else None, tree.right.val if tree.right else None) for tree in result] >>> expected_vals = [(1, None, 2), (2, 1, None)] >>> sorted(vals) == sorted(expected_vals) True >>> result = generateTrees(3) >>> len(result) == 5 True >>> structures = set() >>> def preorder(node): ... if not node: ... return None ... return (node.val, preorder(node.left), preorder(node.right)) >>> for tree in result: ... structures.add(preorder(tree)) >>> expected_structures = { ... (1, None, (2, None, (3, None, None))), ... (1, None, (3, (2, None, None), None)), ... (2, (1, None, None), (3, None, None)), ... (3, (1, None, (2, None, None)), None), ... (3, (2, (1, None, None), None), None) ... } >>> structures == expected_structures True","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generateTrees(n: int) -> List[Optional[TreeNode]]: if n == 0: return [] def generate(start, end): if start > end: return [None] all_trees = [] for i in range(start, end + 1): # Generate all left subtrees left_trees = generate(start, i - 1) # Generate all right subtrees right_trees = generate(i + 1, end) # Connect left and right subtrees to the root i for l in left_trees: for r in right_trees: current_tree = TreeNode(i) current_tree.left = l current_tree.right = r all_trees.append(current_tree) return all_trees return generate(1, n)"},{"question":"def pacific_atlantic(matrix: List[List[int]]) -> List[List[int]]: Determine the set of all grid cells where water can flow to both the left and top oceans. >>> pacific_atlantic([]) [] >>> pacific_atlantic([[1]]) [[0, 0]] >>> pacific_atlantic([ [1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 64 .'; echo BudgetCalculator::calculateAverageCostDescription(description);","solution":"def pacific_atlantic(matrix): if not matrix or not matrix[0]: return [] def dfs(matrix, visited, height, x, y): m, n = len(matrix), len(matrix[0]) if (x < 0 or x >= m or y < 0 or y >= n or visited[x][y] or matrix[x][y] < height): return visited[x][y] = True for dx, dy in [(-1,0), (1,0), (0,-1), (0,1)]: dfs(matrix, visited, matrix[x][y], x+dx, y+dy) m, n = len(matrix), len(matrix[0]) pacific_visited = [[False]*n for _ in range(m)] atlantic_visited = [[False]*n for _ in range(m)] for i in range(m): dfs(matrix, pacific_visited, float('-inf'), i, 0) dfs(matrix, atlantic_visited, float('-inf'), i, n-1) for j in range(n): dfs(matrix, pacific_visited, float('-inf'), 0, j) dfs(matrix, atlantic_visited, float('-inf'), m-1, j) result = [] for i in range(m): for j in range(n): if pacific_visited[i][j] and atlantic_visited[i][j]: result.append([i, j]) return result"},{"question":"from typing import List import heapq def rearrange_array(nums: List[int], k: int) -> List[int]: Rearranges the array such that the difference between consecutive elements is minimized, and no element is moved more than k positions away from its original position. >>> rearrange_array([4, 3, 2, 1], 1) == [3, 2, 1, 4] >>> rearrange_array([3, 1, 2], 2) == [1, 2, 3] >>> rearrange_array([1, 2, 3], 0) == [1, 2, 3] >>> rearrange_array([1, 2, 3, 4], 1) == [1, 2, 3, 4] >>> rearrange_array([1, 3, 2, 4], 2) == [1, 2, 3, 4] >>> rearrange_array([4, 1, 3, 2], 3) == [1, 2, 3, 4] >>> rearrange_array([10, 20, 15, 30, 25], 4) == [10, 15, 20, 25, 30] >>> rearrange_array([1, 1, 1, 1], 1) == [1, 1, 1, 1] >>> rearrange_array([2, 2, 2, 2], 2) == [2, 2, 2, 2]","solution":"import heapq def rearrange_array(nums, k): Rearranges the array such that the difference between consecutive elements is minimized, and no element is moved more than k positions away from its original position. # Use a min-heap to keep track of the smallest elements within the window of size min(len(nums), k+1) if k == 0: return nums n = len(nums) result = [] min_heap = [] for i in range(n): heapq.heappush(min_heap, nums[i]) if i >= k: result.append(heapq.heappop(min_heap)) if i == n - 1: while min_heap: result.append(heapq.heappop(min_heap)) return result"},{"question":"def minimum_number_of_buildings(heights: List[int]) -> int: Returns the minimum number of buildings that remains after merging all possible buildings. >>> minimum_number_of_buildings([10]) == 1 >>> minimum_number_of_buildings([3, 3, 3, 3]) == 1 >>> minimum_number_of_buildings([1, 2, 3, 4, 5]) == 5 >>> minimum_number_of_buildings([5, 4, 3, 2, 1]) == 1 >>> minimum_number_of_buildings([2, 3, 1, 2, 5, 4]) == 4 >>> minimum_number_of_buildings([]) == 0","solution":"def minimum_number_of_buildings(heights): Returns the minimum number of buildings that remains after merging all possible buildings. if not heights: return 0 n = len(heights) min_buildings = 1 for i in range(1, n): if heights[i] > heights[i - 1]: min_buildings += 1 return min_buildings"},{"question":"def rearrangeArray(arr: List[int]) -> Union[List[int], str]: Rearrange the elements in such a way that the difference between every consecutive pair of elements is not the same throughout the array. If such a rearrangement is not possible, return the string \\"Not possible\\". >>> rearrangeArray([3, 1, 4, 1]) [1, 4, 1, 3] >>> rearrangeArray([1, 2, 3, 4]) \\"Not possible\\" >>> rearrangeArray([1, 2]) [1, 2] >>> rearrangeArray([2, 2, 2, 2]) \\"Not possible\\" >>> rearrangeArray(list(range(1, 100))) (A possible valid rearrangement)","solution":"def rearrangeArray(arr): def has_equal_differences(arr): if len(arr) < 3: return False diffs = set() for i in range(1, len(arr)): diffs.add(arr[i] - arr[i - 1]) return len(diffs) == 1 arr.sort() # Try to create a non-arithmetic progression arrangement # by starting from ends, taking from the start one time, then from the end. n = len(arr) res = [] left, right = 0, n - 1 while left <= right: if left != right: res.append(arr[left]) res.append(arr[right]) else: res.append(arr[left]) left += 1 right -= 1 if has_equal_differences(res): return \\"Not possible\\" return res"},{"question":"def max_area_after_cuts(h, w, horizontalCuts, verticalCuts): Returns the maximum area of a piece of cake after making cuts provided in horizontalCuts and verticalCuts arrays. >>> max_area_after_cuts(5, 4, [1, 2, 4], [1, 3]) == 4 >>> max_area_after_cuts(5, 4, [3, 1], [1]) == 6 >>> max_area_after_cuts(5, 4, [3], [3]) == 9 >>> max_area_after_cuts(10, 10, [2, 6, 5], [3, 7, 5]) == 12 >>> max_area_after_cuts(10, 10, [], []) == 100 >>> max_area_after_cuts(1, 1, [0], [0]) == 1 >>> max_area_after_cuts(1, 1, [], [0]) == 1 >>> max_area_after_cuts(1, 1, [0], []) == 1 >>> max_area_after_cuts(1000000000, 1000000000, [500000000], [500000000]) == 250000000000000000 pass","solution":"def max_area_after_cuts(h, w, horizontalCuts, verticalCuts): Returns the maximum area of a piece of cake after making cuts provided in horizontalCuts and verticalCuts arrays. # Append edges of the cake to the cuts horizontalCuts = sorted(horizontalCuts + [0, h]) verticalCuts = sorted(verticalCuts + [0, w]) # Find the maximum consecutive distances in horizontal cuts max_h_gap = max(horizontalCuts[i+1] - horizontalCuts[i] for i in range(len(horizontalCuts)-1)) # Find the maximum consecutive distances in vertical cuts max_w_gap = max(verticalCuts[i+1] - verticalCuts[i] for i in range(len(verticalCuts)-1)) # Maximum area will be the product of maximum gaps return max_h_gap * max_w_gap"},{"question":"from typing import List class GridPath: def __init__(self, mat: List[List[int]]): Initializes the grid with the given matrix \`mat\`. Args: mat (List[List[int]]): A 2D list where each cell is either 0 or 1. pass def minPath(self) -> int: Returns the minimum number of steps to reach (n-1, n-1) from (0, 0), or -1 if no such path exists. Returns: int: The minimum number of steps or -1 if no path exists. >>> gp = GridPath([ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) >>> gp.minPath() 4 >>> gp = GridPath([ ... [1, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) >>> gp.minPath() -1 pass","solution":"from collections import deque class GridPath: def __init__(self, mat): self.mat = mat self.n = len(mat) self.directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] def is_valid(self, x, y): return 0 <= x < self.n and 0 <= y < self.n and self.mat[x][y] == 0 def minPath(self): if self.mat[0][0] == 1 or self.mat[self.n-1][self.n-1] == 1: return -1 queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == self.n - 1 and y == self.n - 1: return steps for dx, dy in self.directions: nx, ny = x + dx, y + dy if self.is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def longest_unique_subarray_length(nums: List[int]) -> int: Returns the length of the longest contiguous subarray containing only unique elements. >>> longest_unique_subarray_length([1, 2, 3, 1, 2, 3, 4, 5]) == 5 >>> longest_unique_subarray_length([1, 2, 3, 4, 5]) == 5 >>> longest_unique_subarray_length([1, 1, 1, 1]) == 1 >>> longest_unique_subarray_length([1, 2, 3, 4, 1, 2, 3, 4, 5]) == 5 >>> longest_unique_subarray_length([]) == 0 >>> longest_unique_subarray_length([1]) == 1 >>> longest_unique_subarray_length([1, 2, 2, 3, 4, 3, 5, 6]) == 4 >>> longest_unique_subarray_length([1, 2, 3, 4, 2, 3, 4, 5, 6]) == 5 >>> longest_unique_subarray_length([4, 4, 4, 4, 4, 4]) == 1 >>> longest_unique_subarray_length([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) == 10","solution":"def longest_unique_subarray_length(nums): Returns the length of the longest contiguous subarray containing only unique elements. :param nums: List[int] - The input list of integers. :return: int - The length of the longest subarray with all unique elements. max_length = 0 start = 0 seen = {} for end, value in enumerate(nums): if value in seen and seen[value] >= start: start = seen[value] + 1 seen[value] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def min_operations_to_equal_height(trees: List[int]) -> int: Returns the minimum number of operations needed to make all trees the same height. Args: trees (list of int): list of heights of trees. Returns: int: minimum number of operations. pass def test_equal_height_already(): assert min_operations_to_equal_height([5, 5, 5, 5]) == 0 def test_single_element(): assert min_operations_to_equal_height([7]) == 0 def test_two_element(): assert min_operations_to_equal_height([5, 9]) == 4 def test_general_case(): assert min_operations_to_equal_height([5, 7, 5, 9]) == 6 def test_empty_array(): assert min_operations_to_equal_height([]) == 0 def test_all_different(): assert min_operations_to_equal_height([1, 2, 3, 4, 5]) == 6","solution":"def min_operations_to_equal_height(trees): Returns the minimum number of operations needed to make all trees the same height. Args: trees (list of int): list of heights of trees. Returns: int: minimum number of operations. if not trees: return 0 target_height = round(sum(trees) / len(trees)) operations = 0 for height in trees: operations += abs(height - target_height) return operations"},{"question":"def three_sum_closest(nums: List[int], target: int) -> int: Determine if there are three distinct integers in \`nums\` whose sum is closest to \`target\`. Return the sum of the three integers. >>> three_sum_closest([-1, 2, 1, -4], 1) 2 >>> three_sum_closest([1, 1, 1, 0], 2) 2 >>> three_sum_closest([-1, -2, -3, -4], -6) -6 >>> three_sum_closest([1, 2, 5, 10, 11], 12) 13 >>> three_sum_closest([0, 1, 2], 3) 3","solution":"def three_sum_closest(nums, target): Returns the sum of the three integers closest to the target. nums.sort() closest_sum = float('inf') for i in range(len(nums) - 2): left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return current_sum return closest_sum"},{"question":"from itertools import permutations from typing import List def is_subsequence(s: str, t: str) -> bool: Check if string s is a subsequence of string t. >>> is_subsequence(\\"abc\\", \\"aebdc\\") True >>> is_subsequence(\\"abc\\", \\"acb\\") False def find_shortest_supersequence(words: List[str]) -> str: Given a set of strings \`words\`, find the shortest string that contains all the strings in \`words\` as subsequences. If there are multiple strings of the same shortest length, return the lexicographically smallest one. >>> find_shortest_supersequence([\\"apple\\"]) \\"apple\\" >>> find_shortest_supersequence([\\"abc\\", \\"abcd\\"]) \\"abcd\\" >>> find_shortest_supersequence([\\"ab\\", \\"bc\\", \\"cd\\"]) \\"abcd\\" >>> find_shortest_supersequence([\\"abc\\", \\"bca\\"]) \\"abca\\" or \\"bcab\\" >>> find_shortest_supersequence([\\"a\\", \\"b\\", \\"c\\"]) \\"abc\\" >>> find_shortest_supersequence([\\"abc\\", \\"ac\\", \\"cb\\"]) \\"abcb\\"","solution":"def is_subsequence(s, t): it = iter(t) return all(char in it for char in s) def find_shortest_supersequence(words): from itertools import permutations min_length = float('inf') best_supersequence = None for perm in permutations(words): supersequence_candidate = perm[0] for next_word in perm[1:]: # Merge supersequence_candidate with next_word merged = \\"\\" it = iter(supersequence_candidate) for char in next_word: if char in it: merged += char else: break supersequence_candidate += next_word[len(merged):] if len(supersequence_candidate) < min_length or (len(supersequence_candidate) == min_length and supersequence_candidate < best_supersequence): min_length = len(supersequence_candidate) best_supersequence = supersequence_candidate return best_supersequence"},{"question":"def longestIncreasingPath(matrix: List[List[int]]) -> int: Given an integer matrix \`matrix\`, find the length of the longest increasing path in the matrix. From each cell, you can either move to four possible directions  left, right, up, or down and you may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed). Two cells are said to be connected if and only if they contain values which increase sequentially from one cell to another. >>> longestIncreasingPath([ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ]) == 4 >>> longestIncreasingPath([[1]]) == 1 >>> longestIncreasingPath([]) == 0 >>> longestIncreasingPath([ ... [1, 2, 3, 4, 5] ... ]) == 5 >>> longestIncreasingPath([ ... [1], ... [2], ... [3], ... [4], ... [5] ... ]) == 5 >>> longestIncreasingPath([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 1","solution":"def longestIncreasingPath(matrix): if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) cache = [[-1] * cols for _ in range(rows)] def dfs(x, y): if cache[x][y] != -1: return cache[x][y] max_path = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and matrix[nx][ny] > matrix[x][y]: max_path = max(max_path, 1 + dfs(nx, ny)) cache[x][y] = max_path return max_path longest_path = 0 for i in range(rows): for j in range(cols): longest_path = max(longest_path, dfs(i, j)) return longest_path"},{"question":"def calculate(s: str) -> int: Given a string s which represents an expression, evaluate this expression and return its value. The integer division should truncate toward zero. The expression string may contain open \`(\` and closing parentheses \`)\`, the plus \`+\` or minus sign \`-\`, non-negative integers and empty spaces \` \`. You may assume that the given expression is always valid. All intermediate results will be in the range of [-2^31, 2^31 - 1]. The division operator \`/\` should be used assuming integer division. >>> calculate(\\"3 + 2\\") == 5 >>> calculate(\\"5 - 3\\") == 2 >>> calculate(\\"3 + 5 - 2\\") == 6 >>> calculate(\\"3 + (2 - 1)\\") == 4 >>> calculate(\\"(1 + (2 - 3)) + 4\\") == 4 >>> calculate(\\"((2 + 3) + (4 - 1))\\") == 8 >>> calculate(\\" 2- 1 + 2 \\") == 3 >>> calculate(\\"10 + (2 + 3 - (1 + 2))\\") == 12","solution":"def calculate(s: str) -> int: def helper(it): stack = [] num = 0 sign = 1 for char in it: if char.isdigit(): num = num * 10 + int(char) elif char in '+-': stack.append(sign * num) num = 0 sign = 1 if char == '+' else -1 elif char == '(': num = helper(it) elif char == ')': break stack.append(sign * num) return sum(stack) return helper(iter(s))"},{"question":"from typing import List def can_make_unique(nums: List[int]) -> bool: Determine if it is possible to make all elements of nums unique by modifying at most one element. >>> can_make_unique([1, 2, 3, 4, 5]) True >>> can_make_unique([1, 2, 2, 3, 4]) True >>> can_make_unique([1, 2, 2, 3, 3]) False >>> can_make_unique([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10]) True >>> can_make_unique([1, 1, 1, 1, 1, 1]) False >>> can_make_unique([1]) True","solution":"def can_make_unique(nums): from collections import Counter count = Counter(nums) duplicates = [k for k,v in count.items() if v > 1] if len(duplicates) == 0: return True if len(duplicates) == 1 and count[duplicates[0]] == 2: return True return False"},{"question":"[Completion Task in Python] def replace_asterisks(s: str) -> str: Replace '*' in the string with 'a' or 'b' such that there are no consecutive identical characters. Return any such valid string or an empty string if not possible. >>> replace_asterisks('ababa') 'ababa' >>> replace_asterisks('babab') 'babab' >>> replace_asterisks('a*') ('aa', 'ab') >>> replace_asterisks('*b') ('ab', 'bb') >>> replace_asterisks('a*ba*b') is not '' and all(result[i] != result[i + 1] for i in range(len(result) - 1)) >>> replace_asterisks('*a*b*') is not '' and all(result[i] != result[i + 1] for i in range(len(result) - 1)) >>> replace_asterisks('*******') is not '' and all(result[i] != result[i + 1] for i in range(len(result) - 1)) >>> replace_asterisks('aa*aa') '' >>> replace_asterisks('*') ('a', 'b') >>> replace_asterisks('*'*100) is not '' and of length 100 with no consecutive 'a' or 'b'","solution":"def replace_asterisks(s): Replace '*' in the string with 'a' or 'b' such that there are no consecutive identical characters. Return any such valid string or an empty string if not possible. s = list(s) # Convert string to list for mutability for i in range(len(s)): if s[i] == '*': for char in 'ab': if (i == 0 or s[i - 1] != char) and (i == len(s) - 1 or s[i + 1] != char): s[i] = char break # Checking if we successfully replaced all '*' s = ''.join(s) for i in range(len(s) - 1): if s[i] == s[i + 1]: return \\"\\" return s"},{"question":"from typing import List def find_line_with_most_points(points: List[List[int]]) -> List[float]: Given a list of points in a 2D plane, find the equation of the straight line that passes through the most number of points. Return the coefficients m and b as an array [m, b], representing the line y = mx + b. >>> find_line_with_most_points([[1, 2], [2, 3], [3, 4], [5, 6]]) [1.0, 1.0] >>> find_line_with_most_points([]) [0.0, 0.0] >>> find_line_with_most_points([[1, 2]]) [0.0, 0.0] >>> find_line_with_most_points([[1, 2], [2, 3]]) [1.0, 1.0] >>> find_line_with_most_points([[1, 2], [2, 4], [3, 6], [1, -1], [2, -2], [3, -3]]) [2.0, 0.0] or [-1.0, 0.0] >>> find_line_with_most_points([[1, 2], [2, 2], [3, 2], [4, 2]]) [0.0, 2.0]","solution":"from collections import defaultdict from fractions import Fraction from itertools import combinations def find_line_with_most_points(points): def get_line_parameters(p1, p2): if p1[0] == p2[0]: raise ValueError(\\"Vertical lines not allowed\\") # Calculate the slope (m) and intercept (b) m = Fraction(p2[1] - p1[1], p2[0] - p1[0]) b = Fraction(p1[1]) - m * p1[0] return m, b lines = defaultdict(int) # Dictionary to count occurrences of each line max_points = 0 best_line = (0, 0) for p1, p2 in combinations(points, 2): try: m, b = get_line_parameters(p1, p2) lines[(m, b)] += 1 if lines[(m, b)] > max_points: max_points = lines[(m, b)] best_line = (m, b) except ValueError: pass # Skip vertical lines return [float(best_line[0]), float(best_line[1])]"},{"question":"def longest_arith_seq_length(arr: List[int]) -> int: Given an array of integers \`arr\`, return the length of the longest subarray that forms a contiguous arithmetic progression. An arithmetic progression is defined as a sequence of numbers in which the difference between consecutive elements is constant. You need to solve the problem in \`O(n)\` time complexity. >>> longest_arith_seq_length([5, 5, 5, 5, 5]) == 5 >>> longest_arith_seq_length([1, 3, 5, 7, 9]) == 5 >>> longest_arith_seq_length([1, 2, 4, 7]) == 2 >>> longest_arith_seq_length([3, 6, 9, 12, 15, 10, 11, 12]) == 5 >>> longest_arith_seq_length([]) == 0 >>> longest_arith_seq_length([10]) == 1 >>> longest_arith_seq_length([5, 10]) == 2","solution":"def longest_arith_seq_length(arr): if len(arr) < 2: return len(arr) max_length = 1 current_length = 1 current_diff = None for i in range(1, len(arr)): diff = arr[i] - arr[i - 1] if diff == current_diff: current_length += 1 else: current_diff = diff current_length = 2 max_length = max(max_length, current_length) return max_length"},{"question":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths from the top-left to the bottom-right of an m x n grid. The robot can only move either down or right at any point in time. >>> unique_paths(3, 3) 6 >>> unique_paths(1, 1) 1 >>> unique_paths(2, 2) 2 >>> unique_paths(3, 2) 3 >>> unique_paths(2, 3) 3 >>> unique_paths(4, 4) 20 >>> unique_paths(5, 5) 70","solution":"def unique_paths(m, n): Calculate the number of unique paths from the top-left to the bottom-right of an m x n grid. The robot can only move either down or right at any point in time. # Create a 2D array dp where dp[i][j] represents the number of unique paths to reach cell (i, j) dp = [[1] * n for _ in range(m)] # Fill the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def max_depth_binary_tree(tree): Returns the maximum depth of the binary tree represented by the array \`tree\`. >>> max_depth_binary_tree([1]) 0 # Only the root node >>> max_depth_binary_tree([None]) -1 # No valid root node, empty tree case >>> max_depth_binary_tree([1, 2, 3, 4, 5, 6, 7]) 2 # Balanced tree with 3 levels >>> max_depth_binary_tree([1, 2, None, 3, None, None, None]) 2 # Left skewed tree >>> max_depth_binary_tree([1, None, 2, None, None, None, 3]) 2 # Right skewed tree >>> max_depth_binary_tree([1, 2, 3, None, 5, 6, None, None, None, None, 7]) 3 # Unbalanced tree with mixed children >>> max_depth_binary_tree([]) -1 # Empty tree case","solution":"def max_depth_binary_tree(tree): Returns the maximum depth of the binary tree represented by the array \`tree\`. def dfs(index): if index >= len(tree) or tree[index] is None: return -1 # Returning -1 because we're counting edges, not nodes left_depth = dfs(2 * index + 1) right_depth = dfs(2 * index + 2) return max(left_depth, right_depth) + 1 return dfs(0)"},{"question":"def findAllTopologicalOrders(edges): Returns all possible topological orderings of the directed acyclic graph represented by a list of edges. :param edges: List of edges where edges[i] = [from_i, to_i] :return: List of all topological orderings >>> findAllTopologicalOrders([]) [[]] >>> findAllTopologicalOrders([[1, 2]]) [[1, 2]] >>> findAllTopologicalOrders([[1, 2], [2, 3]]) [[1, 2, 3]] >>> findAllTopologicalOrders([[1, 2], [1, 3]]) [[1, 2, 3], [1, 3, 2]] >>> findAllTopologicalOrders([[1, 2], [1, 3], [3, 4], [2, 4]]) [[1, 2, 3, 4], [1, 3, 2, 4]]","solution":"from collections import defaultdict, deque def findAllTopologicalOrders(edges): Returns all possible topological orderings of the directed acyclic graph represented by a list of edges. :param edges: List of edges where edges[i] = [from_i, to_i] :return: List of all topological orderings # Build graph and in-degrees of nodes graph = defaultdict(list) in_degree = defaultdict(int) nodes = set() for u, v in edges: graph[u].append(v) in_degree[v] += 1 nodes.add(u) nodes.add(v) # Identify nodes with no incoming edges zero_in_degree = deque([node for node in nodes if in_degree[node] == 0]) def backtrack(path, visited_nodes): if len(path) == len(nodes): result.append(path[:]) return for node in list(zero_in_degree): zero_in_degree.remove(node) path.append(node) visited_nodes.add(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree.append(neighbor) backtrack(path, visited_nodes) for neighbor in graph[node]: if in_degree[neighbor] == 0: zero_in_degree.pop() in_degree[neighbor] += 1 visited_nodes.remove(node) path.pop() zero_in_degree.appendleft(node) result = [] backtrack([], set()) return result"},{"question":"def is_possible_sort_within_k_swaps(heights: List[int], k: int) -> int: Determine if the array can be sorted within k adjacent swaps. >>> is_possible_sort_within_k_swaps([4, 3, 2, 1], 3) == -1 >>> is_possible_sort_within_k_swaps([4, 3, 2, 1], 6) == 6 >>> is_possible_sort_within_k_swaps([1, 2, 3, 4], 0) == 0 >>> is_possible_sort_within_k_swaps([2, 1, 3, 4], 1) == 1 >>> is_possible_sort_within_k_swaps([1], 5) == 0 >>> is_possible_sort_within_k_swaps([4, 2, 3, 1], 2) == -1","solution":"def is_possible_sort_within_k_swaps(heights, k): Determine if the array can be sorted within k adjacent swaps. # Calculate the minimum number of adjacent swaps needed using bubble sort concept n = len(heights) swaps_needed = 0 aux_list = heights[:] for i in range(n): for j in range(n-1-i): if aux_list[j] > aux_list[j+1]: # swap elements aux_list[j], aux_list[j+1] = aux_list[j+1], aux_list[j] swaps_needed += 1 # If the swaps needed exceed k, return -1, else return swaps_needed return swaps_needed if swaps_needed <= k else -1"},{"question":"def most_frequent_element(arr: List[int]) -> int: Given a list of integers \`arr\`, return the most frequent element. If there is a tie for the most frequent element, return the smallest element among them. The input list will always have at least one integer. >>> most_frequent_element([1]) == 1 >>> most_frequent_element([1, 2, 3, 4]) == 1 >>> most_frequent_element([5, 5, 5, 5]) == 5 >>> most_frequent_element([1, 2, 2, 3, 3, 4]) == 2 # 2 and 3 are most frequent, smallest is 2 >>> most_frequent_element([7, 8, 8, 7, 9, 10, 7, 8]) == 7 >>> most_frequent_element([-1, -1, -2, -2, -1]) == -1","solution":"def most_frequent_element(arr): Returns the most frequent element in the list \`arr\`. If there is a tie, returns the smallest element among the most frequent ones. from collections import Counter counter = Counter(arr) max_freq = max(counter.values()) most_frequent = [key for key, value in counter.items() if value == max_freq] return min(most_frequent)"},{"question":"class LibrarySystem: A class to represent a Library Management System. def __init__(self): Initializes the library management system. pass def addBook(self, id, title, author, copies): Adds a new book to the library's collection. Args: id (int): The unique identifier for the book. title (str): The title of the book. author (str): The author of the book. copies (int): The total number of copies available. pass def borrowBook(self, id): Borrows a book from the library if available. Args: id (int): The unique identifier for the book. Returns: bool: True if the book was successfully borrowed, False otherwise. pass def returnBook(self, id): Returns a borrowed book to the library. Args: id (int): The unique identifier for the book. pass def search(self, keyword): Searches for books by the keyword in either title or author. Args: keyword (str): The keyword to search for. Returns: List[int]: A list of book IDs that match the keyword search. pass","solution":"class LibrarySystem: def __init__(self): self.books = {} def addBook(self, id, title, author, copies): self.books[id] = { 'title': title, 'author': author, 'total_copies': copies, 'available_copies': copies } def borrowBook(self, id): if id in self.books and self.books[id]['available_copies'] > 0: self.books[id]['available_copies'] -= 1 return True return False def returnBook(self, id): if id in self.books: if self.books[id]['available_copies'] < self.books[id]['total_copies']: self.books[id]['available_copies'] += 1 def search(self, keyword): keyword = keyword.lower() result = [] for book_id, details in self.books.items(): if keyword in details['title'].lower() or keyword in details['author'].lower(): result.append(book_id) return result"},{"question":"def max_non_overlapping_sessions(sessions): Returns the maximum number of non-overlapping sessions that can be attended. Parameters: sessions (list of tuples): A list where each tuple represents the start and end time of a session. Returns: int: The maximum number of non-overlapping sessions. pass def test_single_session(): assert max_non_overlapping_sessions([(1, 2)]) == 1 def test_no_sessions(): assert max_non_overlapping_sessions([]) == 0 def test_non_overlapping_sessions(): assert max_non_overlapping_sessions([(1, 2), (2, 3), (3, 4)]) == 3 def test_overlapping_sessions(): assert max_non_overlapping_sessions([(1, 3), (2, 4), (3, 5)]) == 2 def test_mixed_sessions(): assert max_non_overlapping_sessions([(1, 3), (2, 5), (4, 6)]) == 2 def test_ending_before_next_starting(): assert max_non_overlapping_sessions([(1, 5), (5, 6), (6, 7)]) == 3 def test_different_lengths(): assert max_non_overlapping_sessions([(1, 10), (2, 3), (4, 8)]) == 2","solution":"def max_non_overlapping_sessions(sessions): Returns the maximum number of non-overlapping sessions that can be attended. Parameters: sessions (list of tuples): A list where each tuple represents the start and end time of a session. Returns: int: The maximum number of non-overlapping sessions. # Sort the sessions based on their end time sessions.sort(key=lambda x: x[1]) max_sessions = 0 last_end_time = float('-inf') for start, end in sessions: if start >= last_end_time: max_sessions += 1 last_end_time = end return max_sessions"},{"question":"from typing import List def check_subarray_sum(nums: List[int], k: int) -> bool: Determine if there exists a continuous subarray of size at least 2 that sums up to a multiple of k. If k is zero, check if there exists a subarray of size at least 2 whose sum is zero. >>> check_subarray_sum([23, 2, 4, 6, 7], 6) True >>> check_subarray_sum([23, 2, 6, 4, 7], 6) True >>> check_subarray_sum([23, 2, 6, 4, 7], 13) False >>> check_subarray_sum([0, 0], 0) True >>> check_subarray_sum([0, 1, 0], 0) False >>> check_subarray_sum([1, 2, 3], 5) True >>> check_subarray_sum([], 1) False >>> check_subarray_sum([1], 1) False","solution":"def check_subarray_sum(nums, k): Check if there exists a continuous subarray of size at least 2 that sums up to a multiple of k. if k == 0: # Special case when k is zero for i in range(len(nums) - 1): if nums[i] == 0 and nums[i + 1] == 0: return True return False prefix_sum = 0 prefix_sums = {0: -1} # Store prefix sums and their indices for i, num in enumerate(nums): prefix_sum += num if k != 0: prefix_sum %= k if prefix_sum in prefix_sums: if i - prefix_sums[prefix_sum] > 1: return True else: prefix_sums[prefix_sum] = i return False"},{"question":"def is_valid_parentheses(s: str) -> bool: Determine if the input string s is a valid parentheses string. >>> is_valid_parentheses(\\"()[]{}\\") # True >>> is_valid_parentheses(\\"(]\\") # False >>> is_valid_parentheses(\\"([{}])\\") # True >>> is_valid_parentheses(\\"([)]\\") # False >>> is_valid_parentheses(\\"{[()]}\\") # True >>> is_valid_parentheses(\\"\\") # True >>> is_valid_parentheses(\\"(\\") # False >>> is_valid_parentheses(\\"]\\") # False >>> is_valid_parentheses(\\"([{}]\\") # False >>> is_valid_parentheses(\\"a(b)c\\") # False >>> is_valid_parentheses(\\"[a+b](c*d)\\") # False","solution":"def is_valid_parentheses(s): Determine if the input string s is a valid parentheses string. stack = [] matching_parentheses = {')': '(', ']': '[', '}': '{'} for char in s: if char in matching_parentheses.values(): stack.append(char) elif char in matching_parentheses.keys(): if stack == [] or matching_parentheses[char] != stack.pop(): return False else: return False return stack == []"},{"question":"def can_split_into_palindromes(s: str) -> bool: Determines if a given string can be split into two or more non-empty substrings such that each substring is a palindrome. Return true if it is possible, otherwise return false. A string is a palindrome if it reads the same backward as forward. >>> can_split_into_palindromes(\\"aab\\") True >>> can_split_into_palindromes(\\"abc\\") False","solution":"def can_split_into_palindromes(s): Determines if the given string can be split into two or more non-empty substrings where each substring is a palindrome. :param s: Input string :return: True if possible, otherwise False def is_palindrome(sub): return sub == sub[::-1] n = len(s) if n < 2: return False for i in range(1, n): if is_palindrome(s[:i]) and is_palindrome(s[i:]): return True return False"},{"question":"import heapq def shortest_path(n: int, edges: List[List[int]], src: int, dst: int) -> int: Returns the shortest path distance from source node \`src\` to target node \`dst\` in a directed weighted graph. If there is no path, return -1. >>> shortest_path(3, [[0, 1, 1], [1, 2, 2], [0, 2, 4]], 0, 2) 3 >>> shortest_path(3, [[0, 1, 1], [1, 2, 2]], 2, 0) -1 >>> shortest_path(3, [[0, 1, 3], [1, 2, 2], [0, 2, 5]], 0, 1) 3 >>> shortest_path(3, [], 0, 2) -1 >>> shortest_path(4, [[0, 1, 1], [0, 2, 4], [1, 2, 2], [1, 3, 6], [2, 3, 1]], 0, 3) 4 >>> shortest_path(1, [], 0, 0) 0","solution":"import heapq def shortest_path(n, edges, src, dst): Returns the shortest path distance from source node \`src\` to target node \`dst\` in a directed weighted graph. If there is no path, return -1. # Create adjacency list graph = {i: [] for i in range(n)} for u, v, w in edges: graph[u].append((v, w)) # Priority queue to hold (distance, node) tuples pq = [(0, src)] # Distance array initialized with infinity dist = {i: float('inf') for i in range(n)} dist[src] = 0 while pq: current_dist, current_node = heapq.heappop(pq) if current_node == dst: return current_dist if current_dist > dist[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1 if dist[dst] == float('inf') else dist[dst]"},{"question":"def pacificAtlantic(matrix): Return a list of grid coordinates where water can flow to both the Pacific and Atlantic oceans. >>> pacificAtlantic([ [1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4] ]) [(0, 4), (1, 3), (1, 4), (2, 2), (3, 0), (3, 1), (4, 0)] >>> pacificAtlantic([ [1, 1], [1, 1], [1, 1] ]) [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)] >>> pacificAtlantic([ [10, 10, 10], [10, 1, 10], [10, 10, 10] ]) [(0, 0), (0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)] >>> pacificAtlantic([[1]]) [(0, 0)] >>> pacificAtlantic([]) []","solution":"def pacificAtlantic(matrix): if not matrix or not matrix[0]: return [] def dfs(x, y, visited, prev_height): if (x, y) in visited or x < 0 or y < 0 or x >= m or y >= n or matrix[x][y] < prev_height: return visited.add((x, y)) for direction in directions: new_x, new_y = x + direction[0], y + direction[1] dfs(new_x, new_y, visited, matrix[x][y]) m, n = len(matrix), len(matrix[0]) pacific_visited = set() atlantic_visited = set() directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for i in range(m): dfs(i, 0, pacific_visited, matrix[i][0]) dfs(i, n - 1, atlantic_visited, matrix[i][n - 1]) for j in range(n): dfs(0, j, pacific_visited, matrix[0][j]) dfs(m - 1, j, atlantic_visited, matrix[m - 1][j]) return list(pacific_visited & atlantic_visited)"},{"question":"def remove_min_chars_to_unique(s: str) -> str: Given a string \`s\` consisting of lowercase alphabets, remove the minimum number of characters from it so that all the remaining characters in \`s\` are unique. Return the resulting string with all distinct characters in their original order. If there are multiple possible results, return any of them. >>> remove_min_chars_to_unique(\\"abcdef\\") == \\"abcdef\\" >>> remove_min_chars_to_unique(\\"aaaaa\\") == \\"a\\" >>> remove_min_chars_to_unique(\\"aabbcc\\") == \\"abc\\" >>> remove_min_chars_to_unique(\\"abacbade\\") == \\"abcde\\" >>> remove_min_chars_to_unique(\\"\\") == \\"\\" >>> remove_min_chars_to_unique(\\"x\\") == \\"x\\"","solution":"def remove_min_chars_to_unique(s): Remove the minimum number of characters from the string s so that all the remaining characters are unique. Returns a resulting string with all distinct characters in their original order. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"class TimeMap: def __init__(self): Initialize the data structure. self.store = {} def set(self, key: str, value: str, timestamp: int) -> None: Store the key with the value along with the timestamp. def get(self, key: str, timestamp: int) -> str: Get the largest value such that it was set at some earlier time <= timestamp. If no earlier time is found, return an empty string. def _search(self, values, timestamp): Binary search to find the right most value less than or equal to the given timestamp. # Unit tests def test_timemap_set_and_get(): kv = TimeMap() kv.set(\\"foo\\", \\"bar\\", 1) assert kv.get(\\"foo\\", 1) == \\"bar\\" assert kv.get(\\"foo\\", 3) == \\"bar\\" kv.set(\\"foo\\", \\"bar2\\", 4) assert kv.get(\\"foo\\", 4) == \\"bar2\\" assert kv.get(\\"foo\\", 5) == \\"bar2\\" def test_timemap_edge_cases(): kv = TimeMap() kv.set(\\"foo\\", \\"bar\\", 1) assert kv.get(\\"foo\\", 0) == \\"\\" assert kv.get(\\"foo\\", 1) == \\"bar\\" assert kv.get(\\"foo\\", 2) == \\"bar\\" kv.set(\\"foo\\", \\"bar2\\", 2) assert kv.get(\\"foo\\", 1) == \\"bar\\" assert kv.get(\\"foo\\", 2) == \\"bar2\\" assert kv.get(\\"foo\\", 3) == \\"bar2\\" def test_timemap_different_keys(): kv = TimeMap() kv.set(\\"foo\\", \\"bar\\", 1) kv.set(\\"baz\\", \\"qux\\", 2) assert kv.get(\\"foo\\", 1) == \\"bar\\" assert kv.get(\\"baz\\", 2) == \\"qux\\" assert kv.get(\\"foo\\", 2) == \\"bar\\" assert kv.get(\\"baz\\", 3) == \\"qux\\" def test_timemap_no_values(): kv = TimeMap() assert kv.get(\\"foo\\", 1) == \\"\\" assert kv.get(\\"bar\\", 0) == \\"\\"","solution":"class TimeMap: def __init__(self): Initialize the data structure. self.store = {} def set(self, key: str, value: str, timestamp: int) -> None: Store the key with the value along with the timestamp. if key not in self.store: self.store[key] = [] self.store[key].append((timestamp, value)) def get(self, key: str, timestamp: int) -> str: Get the largest value such that it was set at some earlier time <= timestamp. If no earlier time is found, return an empty string. if key not in self.store or not self.store[key]: return \\"\\" values = self.store[key] i = self._search(values, timestamp) return values[i][1] if i != -1 else \\"\\" def _search(self, values, timestamp): Binary search to find the right most value less than or equal to the given timestamp. low, high = 0, len(values) - 1 result = -1 while low <= high: mid = (low + high) // 2 if values[mid][0] <= timestamp: result = mid low = mid + 1 else: high = mid - 1 return result"},{"question":"from typing import List def findLength(arr1: List[int], arr2: List[int]) -> int: Returns the maximum length of a subarray that appears in both arr1 and arr2. >>> findLength([1, 2, 3], [4, 5, 6]) 0 >>> findLength([1, 2, 3], [1, 2, 3]) 3 >>> findLength([1, 2, 3, 2, 1], [3, 2, 1, 4, 7]) 3 >>> findLength([1, 2, 3], [3, 4, 5]) 1 >>> findLength([1, 2, 3], []) 0 >>> findLength([], [1, 2, 3]) 0 >>> findLength([], []) 0 >>> findLength([1, 2, 3, 4, 5, 6], [3, 4, 5, 6, 7, 8]) 4","solution":"def findLength(arr1, arr2): Returns the maximum length of a subarray that appears in both arr1 and arr2. len1, len2 = len(arr1), len(arr2) dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] max_len = 0 for i in range(len1): for j in range(len2): if arr1[i] == arr2[j]: dp[i + 1][j + 1] = dp[i][j] + 1 max_len = max(max_len, dp[i + 1][j + 1]) return max_len"},{"question":"def three_sum_closest(nums: List[int], target: int) -> int: Finds three integers in the array whose sum is closest to the target. Returns the sum of these three integers. >>> three_sum_closest([-1, 2, 1, -4], 1) 2 >>> three_sum_closest([0, 2, 1, -3], 1) 0 >>> three_sum_closest([1, 1, 1, 0], -100) 2 >>> three_sum_closest([1, 2, 5, 10, 11], 12) 13 >>> three_sum_closest([-1, 2, 1, -4, 2, 5], 3) 3","solution":"def three_sum_closest(nums, target): Finds three integers in nums whose sum is closest to target. Returns the sum of these three integers. nums.sort() n = len(nums) closest_sum = float('inf') for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return closest_sum return closest_sum"},{"question":"class Bank: A bank transaction system that can handle transfers, deposits, and withdrawals. - Initializes the bank system with an initial balance for each account. - Transfers money from one account to another. - Deposits money into an account. - Withdraws money from an account. >>> bank = Bank([100, 200, 300]) >>> assert bank.transfer(1, 2, 50) == True >>> assert bank.balance == [50, 250, 300] >>> assert bank.transfer(1, 2, 150) == False >>> assert bank.balance == [50, 250, 300] >>> assert bank.transfer(1, 4, 50) == False >>> assert bank.balance == [50, 250, 300] >>> assert bank.deposit(1, 50) == True >>> assert bank.balance == [100, 250, 300] >>> assert bank.deposit(4, 50) == False >>> assert bank.balance == [100, 250, 300] >>> assert bank.withdraw(1, 50) == True >>> assert bank.balance == [50, 250, 300] >>> assert bank.withdraw(1, 150) == False >>> assert bank.balance == [50, 250, 300] >>> assert bank.withdraw(4, 50) == False >>> assert bank.balance == [50, 250, 300] def __init__(self, balance): pass def transfer(self, account1, account2, money): pass def deposit(self, account, money): pass def withdraw(self, account, money): pass","solution":"class Bank: def __init__(self, balance): self.balance = balance def transfer(self, account1, account2, money): if not (1 <= account1 <= len(self.balance)) or not (1 <= account2 <= len(self.balance)): return False if self.balance[account1 - 1] < money: return False self.balance[account1 - 1] -= money self.balance[account2 - 1] += money return True def deposit(self, account, money): if not (1 <= account <= len(self.balance)): return False self.balance[account - 1] += money return True def withdraw(self, account, money): if not (1 <= account <= len(self.balance)): return False if self.balance[account - 1] < money: return False self.balance[account - 1] -= money return True"},{"question":"def num_distinct(s: str, t: str) -> int: Return the number of distinct subsequences of s which equal t. >>> num_distinct(\\"rabbbit\\", \\"rabbit\\") 3 >>> num_distinct(\\"babgbag\\", \\"bag\\") 5 >>> num_distinct(\\"abc\\", \\"def\\") 0 >>> num_distinct(\\"abc\\", \\"\\") 1 >>> num_distinct(\\"\\", \\"a\\") 0 >>> num_distinct(\\"\\", \\"\\") 1 >>> num_distinct(\\"abc\\", \\"abc\\") 1 >>> num_distinct(\\"aaa\\", \\"a\\") 3","solution":"def num_distinct(s, t): Returns the number of distinct subsequences of s which equals t. m, n = len(s), len(t) # If t is an empty string, there is exactly one subsequence of s which is \\"\\" if n == 0: return 1 # If s is an empty string but t is not, there can be no subsequences leading to t if m == 0: return 0 # dp[i][j] will store the number of subsequences of s[:i] which equals t[:j] dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): dp[i][0] = 1 # An empty t can always be matched by selecting no characters from s for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] return dp[m][n]"},{"question":"def number_of_unblocked_buildings(heights): Given an array of building heights, return the number of buildings that are not blocked from view when looking from left to right. >>> number_of_unblocked_buildings([]) == 0 >>> number_of_unblocked_buildings([3, 3, 3, 3]) == 1 >>> number_of_unblocked_buildings([1, 2, 3, 4, 5]) == 5 >>> number_of_unblocked_buildings([5, 4, 3, 2, 1]) == 1 >>> number_of_unblocked_buildings([3, 1, 4, 2, 5]) == 3 >>> number_of_unblocked_buildings([10]) == 1","solution":"def number_of_unblocked_buildings(heights): Given an array of building heights, return the number of buildings that are not blocked from view when looking from left to right. if not heights: return 0 unblocked_count = 1 # the first building is always unblocked max_height = heights[0] for height in heights[1:]: if height > max_height: unblocked_count += 1 max_height = height return unblocked_count"},{"question":"def count_active_events_on_day(events: List[Tuple[int, int]], query_day: int) -> int: Returns the number of events that are active on the given query_day. >>> count_active_events_on_day([], 10) == 0 >>> count_active_events_on_day([(1, 5), (6, 9)], 10) == 0 >>> count_active_events_on_day([(1, 10), (5, 15), (10, 20)], 10) == 3 >>> count_active_events_on_day([(1, 10), (5, 15), (20, 25)], 12) == 1 >>> count_active_events_on_day([(5, 10)], 3) == 0 >>> count_active_events_on_day([(5, 10)], 12) == 0 >>> count_active_events_on_day([(5, 10)], 5) == 1 >>> count_active_events_on_day([(5, 10)], 10) == 1","solution":"def count_active_events_on_day(events, query_day): Returns the number of events that are active on the given query_day. count = 0 for start_day, end_day in events: if start_day <= query_day <= end_day: count += 1 return count"},{"question":"def replace_words_with_lengths(s: str) -> str: Takes a string of words separated by spaces and returns a new string where each word is replaced by its length. Maintains original spaces and handles multiple spaces correctly. >>> replace_words_with_lengths(\\"hello\\") \\"5\\" >>> replace_words_with_lengths(\\"hello world\\") \\"5 5\\" >>> replace_words_with_lengths(\\"this is a test\\") \\"4 2 1 4\\" >>> replace_words_with_lengths(\\" hello world \\") \\" 5 5 \\" >>> replace_words_with_lengths(\\"hello world\\") \\"5 5\\" >>> replace_words_with_lengths(\\" \\") \\" \\" >>> replace_words_with_lengths(\\"\\") \\"\\" >>> replace_words_with_lengths(\\"Hello World\\") \\"5 5\\"","solution":"def replace_words_with_lengths(s): Takes a string of words separated by spaces and returns a new string where each word is replaced by its length. Maintains original spaces and handles multiple spaces correctly. # Split the string by spaces to get all parts, including empty strings for multiple spaces parts = s.split(' ') # Replace each word with its length, keep empty strings for spaces lengths = [str(len(word)) if word else '' for word in parts] # Join the parts back together with spaces return ' '.join(lengths)"},{"question":"def longestIdealSubarray(nums: List[int], k: int) -> int: Return the length of the longest subarray containing exactly k distinct elements. If no such subarray exists, return 0. >>> longestIdealSubarray([1, 2, 3], 4) == 0 >>> longestIdealSubarray([1, 1, 1, 1], 1) == 4 >>> longestIdealSubarray([1, 2, 1, 2, 3], 2) == 4 >>> longestIdealSubarray([1, 2, 3, 4], 3) == 3 >>> longestIdealSubarray([1, 2, 1, 2, 3, 4, 5], 3) == 5 >>> longestIdealSubarray([], 1) == 0 >>> longestIdealSubarray([1], 1) == 1 >>> longestIdealSubarray([1, 1, 1, 1], 2) == 0 >>> longestIdealSubarray([1, 2, 3, 4, 5, 6, 7, 8, 9], 5) == 5","solution":"def longestIdealSubarray(nums, k): Returns the length of the longest subarray containing exactly k distinct elements. If no such subarray exists, returns 0. from collections import defaultdict start = 0 max_length = 0 freq_map = defaultdict(int) for end, num in enumerate(nums): freq_map[num] += 1 while len(freq_map) > k: freq_map[nums[start]] -= 1 if freq_map[nums[start]] == 0: del freq_map[nums[start]] start += 1 if len(freq_map) == k: max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List def can_form_palindrome(s: str) -> bool: Determines whether the string can be rearranged to form a palindrome. :param s: Input string :return: True if the string can be rearranged to form a palindrome, otherwise False. >>> can_form_palindrome(\\"aabb\\") == True >>> can_form_palindrome(\\"aabbc\\") == True >>> can_form_palindrome(\\"abc\\") == False >>> can_form_palindrome(\\"a\\") == True >>> can_form_palindrome(\\"\\") == True >>> can_form_palindrome(\\"aaaa\\") == True >>> can_form_palindrome(\\"abcabc\\") == True >>> can_form_palindrome(\\"abcabd\\") == False","solution":"def can_form_palindrome(s): Determines whether the string can be rearranged to form a palindrome. :param s: Input string :return: True if the string can be rearranged to form a palindrome, otherwise False. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count the number of characters with odd frequencies odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # If more than one character has an odd count, it can't form a palindrome if odd_count > 1: return False return True"},{"question":"from typing import List def minCost(ropes: List[int]) -> int: Returns the minimum cost to connect all ropes into one single rope. Args: ropes (List[int]): List of positive integers representing the lengths of the ropes. Returns: int: The minimum cost to connect all the ropes. Examples: >>> minCost([1, 2, 3, 4, 5]) 33 >>> minCost([10]) 0 >>> minCost([1, 2]) 3 >>> minCost([5, 5, 5, 5]) 40 >>> minCost([4000, 3000, 2000, 1000]) 19000 >>> minCost([]) 0 >>> minCost([1, 8, 3, 5]) 30 >>> minCost([4, 3, 2, 6]) 29","solution":"def minCost(ropes): Returns the minimum cost to connect all ropes into one single rope. import heapq # Create a min-heap from the list of rope lengths heapq.heapify(ropes) total_cost = 0 # While there is more than one rope to connect while len(ropes) > 1: # Extract the two smallest ropes first = heapq.heappop(ropes) second = heapq.heappop(ropes) # Connect them cost = first + second total_cost += cost # Push the connected rope back into the min-heap heapq.heappush(ropes, cost) return total_cost"},{"question":"from math import comb def minimum_problems(n: int) -> int: Determine the minimum number of problems required to ensure each participant receives a unique set of problems. :param n: The number of participants. :type n: int :return: The minimum number of problems. :rtype: int pass def test_minimum_problems_for_1_participant(): assert minimum_problems(1) == 1 def test_minimum_problems_for_2_participants(): assert minimum_problems(2) == 2 def test_minimum_problems_for_3_participants(): assert minimum_problems(3) == 2 def test_minimum_problems_for_4_participants(): assert minimum_problems(4) == 3 def test_minimum_problems_for_7_participants(): assert minimum_problems(7) == 3 def test_minimum_problems_for_8_participants(): assert minimum_problems(8) == 4","solution":"from math import comb def minimum_problems(n): Determine the minimum number of problems required to ensure each participant receives a unique set of problems. :param n: The number of participants. :type n: int :return: The minimum number of problems. :rtype: int problems = 1 while True: total_combinations = sum(comb(problems, i) for i in range(1, problems + 1)) if total_combinations >= n: return problems problems += 1"},{"question":"def max_sum_no_adjacent(nums: List[int], k: int) -> int: Return the maximum possible sum you can obtain by choosing k integers from the list such that no two chosen integers are adjacent in the original list. >>> max_sum_no_adjacent([3, 2, 5, 10, 7], 2) 13 >>> max_sum_no_adjacent([3], 1) 3 >>> max_sum_no_adjacent([3, 4], 1) 4 >>> max_sum_no_adjacent([3, 2, 5, 10, 7], 3) 15 >>> max_sum_no_adjacent([3], 2) 0 >>> max_sum_no_adjacent([4, -1, 2, 3, 6], 2) 10 >>> max_sum_no_adjacent([5, 1, 2, 10], 2) 15 >>> max_sum_no_adjacent([1, 5, 1, 5, 20], 2) 25 pass","solution":"def max_sum_no_adjacent(nums, k): def helper(nums, k, start, cache): if k == 0: return 0 if start >= len(nums): return float('-inf') if (start, k) in cache: return cache[(start, k)] include = nums[start] + helper(nums, k - 1, start + 2, cache) exclude = helper(nums, k, start + 1, cache) cache[(start, k)] = max(include, exclude) return cache[(start, k)] cache = {} result = helper(nums, k, 0, cache) return result if result != float('-inf') else 0"},{"question":"def minMaxSplitScore(nums: List[int], k: int) -> int: Split the array into k non-empty continuous subarrays and return the minimum possible score. The score of a split is the sum of the maximum elements of these k subarrays. >>> minMaxSplitScore([7, 2, 5, 10, 8], 2) -> 18 >>> minMaxSplitScore([5], 1) -> 5 >>> minMaxSplitScore([5, 5, 5, 5], 2) -> 10 >>> minMaxSplitScore([1, 2, 3, 4, 5], 2) -> 9 >>> minMaxSplitScore([100, 200, 300], 2) -> 300 >>> minMaxSplitScore([3, 1, 4, 1, 5, 9], 6) -> 9","solution":"def minMaxSplitScore(nums, k): def canSplit(maxSum): current_sum = 0 parts = 1 for num in nums: if current_sum + num > maxSum: parts += 1 current_sum = num if parts > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if canSplit(mid): right = mid else: left = mid + 1 return left"},{"question":"def lexicographically_smallest_string(s: str, k: int) -> str: Returns the lexicographically smallest string that can be obtained after exactly k transformations, where each transformation consists of choosing any substring and moving it to the beginning. >>> lexicographically_smallest_string(\\"cba\\", 1) == \\"acb\\" >>> lexicographically_smallest_string(\\"ba\\", 1) == \\"ab\\" >>> lexicographically_smallest_string(\\"abc\\", 1) == \\"abc\\" >>> lexicographically_smallest_string(\\"cba\\", 2) == \\"abc\\" >>> lexicographically_smallest_string(\\"ba\\", 2) == \\"ab\\" >>> lexicographically_smallest_string(\\"cbad\\", 2) == \\"abcd\\" >>> lexicographically_smallest_string(\\"dcab\\", 2) == \\"abcd\\" >>> lexicographically_smallest_string(\\"a\\", 1) == \\"a\\" >>> lexicographically_smallest_string(\\"\\", 1) == \\"\\" >>> lexicographically_smallest_string(\\"zebra\\", 5) == \\"aberz\\" >>> lexicographically_smallest_string(\\"leetcode\\", 1) == \\"codeleet\\" >>> lexicographically_smallest_string(\\"leetcode\\", 2) == \\"cdeeelot\\"","solution":"def lexicographically_smallest_string(s: str, k: int) -> str: Returns the lexicographically smallest string that can be obtained after exactly k transformations, where each transformation consists of choosing any substring and moving it to the beginning. if k == 1: # Find the smallest rotation by trying all rotations smallest = s for i in range(len(s)): rotated = s[i:] + s[:i] if rotated < smallest: smallest = rotated return smallest else: # If k >= 2, we can use sorting to get the smallest string return ''.join(sorted(s))"},{"question":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring that contains at least one character from each of the alphabets present in the string \`s\` exactly once. >>> longest_unique_substring(\\"aAbBcC\\") 6 >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"abcde\\") 5 >>> longest_unique_substring(\\"aaaaaaa\\") 1 >>> longest_unique_substring(\\"AaBbCcAaBbCc\\") 6 >>> longest_unique_substring(\\"\\") 0","solution":"def longest_unique_substring(s): Returns the length of the longest substring that contains at least one character from each of the alphabets present in the string \`s\` exactly once. unique_chars = set(s) required_char_count = len(unique_chars) n = len(s) char_count = {} left = 0 max_len = 0 for right in range(n): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) == required_char_count: max_len = max(max_len, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 return max_len"},{"question":"def remove_duplicates(nums): Removes duplicates from the sorted array nums and fills the remaining elements with -1. Returns the new length of the array after duplicates have been removed. >>> nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] >>> remove_duplicates(nums) 5 >>> nums [0, 1, 2, 3, 4, -1, -1, -1, -1, -1] >>> nums = [1] >>> remove_duplicates(nums) 1 >>> nums [1] >>> nums = [1, 2, 3, 4, 5] >>> remove_duplicates(nums) 5 >>> nums [1, 2, 3, 4, 5] >>> nums = [2, 2, 2, 2, 2, 2, 2] >>> remove_duplicates(nums) 1 >>> nums [2, -1, -1, -1, -1, -1, -1] >>> nums = [] >>> remove_duplicates(nums) 0 >>> nums [] >>> nums = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5] >>> remove_duplicates(nums) 5 >>> nums [1, 2, 3, 4, 5, -1, -1, -1, -1, -1]","solution":"def remove_duplicates(nums): Removes duplicates from the sorted array nums and fills the remaining elements with -1. Returns the new length of the array after duplicates have been removed. if not nums: return 0 write_index = 1 # Index to write new unique values for read_index in range(1, len(nums)): if nums[read_index] != nums[read_index - 1]: nums[write_index] = nums[read_index] write_index += 1 # Fill the remaining indices with -1 for i in range(write_index, len(nums)): nums[i] = -1 return write_index"},{"question":"from typing import List def majorityElement(votes: List[int]) -> int: This function returns the candidate ID that received more than half of the votes. If no such candidate exists, it returns -1. :param votes: List[int] - List of votes where each element is a candidate ID :return: int - Candidate ID who received more than half the votes, or -1 if no such candidate exists. pass def test_majority_exists(): assert majorityElement([1, 2, 3, 2, 2]) == 2 assert majorityElement([4, 4, 4, 4, 2, 2, 4]) == 4 def test_no_majority(): assert majorityElement([1, 1, 2, 2, 3, 3]) == -1 assert majorityElement([]) == -1 def test_single_element(): assert majorityElement([5]) == 5 assert majorityElement([0]) == 0 def test_two_elements(): assert majorityElement([2, 2]) == 2 assert majorityElement([1, 2]) == -1 def test_multipe_candidates(): assert majorityElement([7, 7, 6, 6, 7, 6, 7]) == 7 assert majorityElement([3, 3, 4, 4, 4, 4, 4, 4, 3, 3]) == 4","solution":"def majorityElement(votes): This function returns the candidate ID that received more than half of the votes. If no such candidate exists, it returns -1. :param votes: List[int] - List of votes where each element is a candidate ID :return: int - Candidate ID who received more than half the votes, or -1 if no such candidate exists. candidate_count = {} n = len(votes) for vote in votes: if vote in candidate_count: candidate_count[vote] += 1 else: candidate_count[vote] = 1 if candidate_count[vote] > n / 2: return vote return -1"},{"question":"def max_sum_after_single_swap(arr: List[int], k: int) -> int: Given an array of integers \`arr\` and an integer \`k\`, determine the maximum possible sum of a subarray of length \`k\` that can be obtained by making at most one swap between any two elements (not necessarily in the subarray). Return the maximum possible sum of the subarray after the swap. >>> max_sum_after_single_swap([1, 2, 3, 4, 5], 3) == 12 >>> max_sum_after_single_swap([-1, -2, -3, -4, -5], 2) == -3 >>> max_sum_after_single_swap([1, 2, 3, 4, 5], 1) == 5 >>> max_sum_after_single_swap([1, 2, 3, 9, 5], 3) == 17 >>> max_sum_after_single_swap([1, 2, 3, 4, 5], 5) == 15","solution":"def max_sum_after_single_swap(arr, k): n = len(arr) if n < k: return None # Not enough elements to form a subarray of length k max_sum = -float('inf') current_sum = sum(arr[:k]) for i in range(n - k + 1): current_sum = sum(arr[i:i + k]) max_sum = max(max_sum, current_sum) for i in range(n): for j in range(i + 1, n): arr[i], arr[j] = arr[j], arr[i] for start in range(n - k + 1): current_sum = sum(arr[start:start + k]) max_sum = max(max_sum, current_sum) arr[i], arr[j] = arr[j], arr[i] return max_sum"},{"question":"def longest_substring_with_k_repeats(s: str, k: int) -> int: Returns the length of the longest substring such that every character in the substring appears at least k times. >>> longest_substring_with_k_repeats(\\"aaabb\\", 3) == 3 >>> longest_substring_with_k_repeats(\\"ababbc\\", 2) == 5 >>> longest_substring_with_k_repeats(\\"aaaa\\", 1) == 4 >>> longest_substring_with_k_repeats(\\"aaaa\\", 5) == 0 >>> longest_substring_with_k_repeats(\\"abcde\\", 2) == 0 >>> longest_substring_with_k_repeats(\\"aaabbb\\", 3) == 6 >>> longest_substring_with_k_repeats(\\"\\", 1) == 0 >>> longest_substring_with_k_repeats(\\"a\\", 2) == 0","solution":"def longest_substring_with_k_repeats(s, k): Returns the length of the longest substring such that every character in the substring appears at least k times. def helper(sub_s, k): if not sub_s or k > len(sub_s): return 0 char_count = {c: sub_s.count(c) for c in set(sub_s)} for idx, ch in enumerate(sub_s): if char_count[ch] < k: return max(helper(sub_s[:idx], k), helper(sub_s[idx + 1:], k)) return len(sub_s) return helper(s, k)"},{"question":"from typing import Optional class TreeNode: def __init__(self, value: int = 0, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None): self.value = value self.left = left self.right = right def find_deepest_node(root: Optional[TreeNode]) -> Optional[int]: Identify and return the value of the deepest node in the tree. If there is a tie, return the smallest value among those nodes. >>> tree = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3, None, TreeNode(5))) >>> find_deepest_node(tree) 4 >>> tree = TreeNode(1, None, None) >>> find_deepest_node(tree) 1 >>> find_deepest_node(None) None","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_deepest_node(root): if not root: return None queue = deque([(root, 0)]) # store node, depth current_depth = -1 smallest_value_at_deepest = float('inf') while queue: node, depth = queue.popleft() if depth > current_depth: current_depth = depth smallest_value_at_deepest = node.value elif depth == current_depth: smallest_value_at_deepest = min(smallest_value_at_deepest, node.value) if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return smallest_value_at_deepest"},{"question":"from typing import List def longest_substring_without_repeating_characters(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> longest_substring_without_repeating_characters(\\"abcdef\\") == 6 >>> longest_substring_without_repeating_characters(\\"abcabcbb\\") == 3 >>> longest_substring_without_repeating_characters(\\"bbbb\\") == 1 >>> longest_substring_without_repeating_characters(\\"\\") == 0 >>> longest_substring_without_repeating_characters(\\"pwwkew\\") == 3 >>> longest_substring_without_repeating_characters(\\"aab\\") == 2 >>> longest_substring_without_repeating_characters(\\"abcdefghijklmnopqrstuvwxyz\\" * 1000) == 26","solution":"def longest_substring_without_repeating_characters(s): Returns the length of the longest substring without repeating characters. char_index_map = {} max_length = start = 0 for i, char in enumerate(s): if char in char_index_map and start <= char_index_map[char]: start = char_index_map[char] + 1 else: max_length = max(max_length, i - start + 1) char_index_map[char] = i return max_length"},{"question":"def exist(board: List[List[str]], word: str) -> bool: Given an m x n grid of characters \`board\` and a string \`word\`, return True if \`word\` exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. >>> exist([ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ], \\"ABCCED\\") True >>> exist([ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ], \\"ABCB\\") False >>> exist([ ['A'] ], \\"A\\") True >>> exist([ ['A'] ], \\"B\\") False >>> exist([ ['C','A','A'], ['A','A','A'], ['B','C','D'] ], \\"AAB\\") True","solution":"def exist(board, word): def backtrack(r, c, word): if len(word) == 0: # All characters are checked return True if r < 0 or r >= len(board) or c < 0 or c >= len(board[0]) or board[r][c] != word[0]: return False ret = False board[r][c] = '#' # mark the cell as visited for row_offset, col_offset in [(0, 1), (1, 0), (0, -1), (-1, 0)]: ret = backtrack(r + row_offset, c + col_offset, word[1:]) if ret: break board[r][c] = word[0] # unmark the cell return ret for r in range(len(board)): for c in range(len(board[0])): if backtrack(r, c, word): return True return False"},{"question":"from typing import List def min_moves(grid: List[List[int]]) -> int: Finds the minimum number of moves required to traverse from the top-left corner of the grid to the bottom-right corner with given movement constraints. >>> min_moves([[1, 2, 2], [3, 8, 2], [5, 3, 3]]) 4 >>> min_moves([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -1 >>> min_moves([[1]]) 0 >>> min_moves([[1, 4], [4, 1]]) -1 >>> min_moves([[1, 1, 1], [1, 2, 1], [1, 1, 1]]) 4","solution":"from collections import deque def min_moves(grid): Finds the minimum number of moves required to traverse from the top-left corner of the grid to the bottom-right corner with given movement constraints. if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] start = (0, 0) end = (rows - 1, cols - 1) if start == end: return 0 queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set() visited.add((0, 0)) while queue: row, col, dist = queue.popleft() for dr, dc in directions: nr, nc = row + dr, col + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited: if grid[nr][nc] <= grid[row][col] + 1: if (nr, nc) == end: return dist + 1 queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) return -1"},{"question":"def search_matrix(mat: List[List[int]], target: int) -> bool: Searches for a target value in a sorted matrix. Parameters: mat (List[List[int]]): 2D matrix where each row and each column is sorted in ascending order. target (int): The target value to search for. Returns: bool: True if the target is found, otherwise False. >>> search_matrix([ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ], 5) True >>> search_matrix([ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ], 20) False # Your code here","solution":"def search_matrix(mat, target): Searches for a target value in a sorted matrix. Parameters: mat (List[List[int]]): 2D matrix where each row and each column is sorted in ascending order. target (int): The target value to search for. Returns: bool: True if the target is found, otherwise False. if not mat: return False rows = len(mat) cols = len(mat[0]) row = 0 col = cols - 1 while row < rows and col >= 0: if mat[row][col] == target: return True elif mat[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"from typing import List from collections import deque def shortest_path_binary_matrix(grid: List[List[int]], startRow: int, startCol: int, endRow: int, endCol: int) -> int: Returns the length of the shortest path in a binary maze from start to end, avoiding walls. Returns -1 if no path exists. >>> shortest_path_binary_matrix([[0, 0, 1], [0, 0, 1], [1, 0, 0]], 0, 0, 2, 2) == 4 >>> shortest_path_binary_matrix([[0, 1, 1], [1, 0, 1], [1, 0, 0]], 0, 0, 2, 2) == -1 >>> shortest_path_binary_matrix([[1, 0, 0], [0, 0, 0], [0, 0, 0]], 0, 0, 2, 2) == -1 >>> shortest_path_binary_matrix([[0, 0, 0], [0, 0, 0], [0, 0, 1]], 0, 0, 2, 2) == -1 >>> shortest_path_binary_matrix([[0, 1], [1, 0]], 0, 0, 0, 0) == 0 >>> shortest_path_binary_matrix([[0, 0], [1, 1]], 0, 0, 0, 1) == 1 >>> shortest_path_binary_matrix([[0, 1], [0, 0]], 0, 0, 1, 0) == 1","solution":"from collections import deque def shortest_path_binary_matrix(grid, startRow, startCol, endRow, endCol): Returns the length of the shortest path in a binary maze from start to end, avoiding walls. Returns -1 if no path exists. if grid[startRow][startCol] == 1 or grid[endRow][endCol] == 1: return -1 rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # four possible movements queue = deque([(startRow, startCol, 0)]) visited = set() visited.add((startRow, startCol)) while queue: row, col, distance = queue.popleft() if (row, col) == (endRow, endCol): return distance for dr, dc in directions: newRow, newCol = row + dr, col + dc if 0 <= newRow < rows and 0 <= newCol < cols and grid[newRow][newCol] == 0 and (newRow, newCol) not in visited: queue.append((newRow, newCol, distance + 1)) visited.add((newRow, newCol)) return -1"},{"question":"def kth_largest_unique(arr, k): Returns the k-th largest element in the array after removing all elements that occur more than once. If there are fewer than k unique elements remaining, returns \\"Not enough unique elements\\". >>> kth_largest_unique([1, 3, 1, 5, 7, 3, 7], 1) 5 >>> kth_largest_unique([1, 2, 2, 3, 4, 4, 5], 2) 3 >>> kth_largest_unique([1, 2, 2, 3, 4, 4, 5], 1) 5 >>> kth_largest_unique([1, 2, 2, 3, 3, 4], 1) 4 >>> kth_largest_unique([4, 5, 6, 7, 8], 3) 6 >>> kth_largest_unique([1, 2, 3, 4, 5], 5) 1 >>> kth_largest_unique([1, 2, 2], 2) \\"Not enough unique elements\\" >>> kth_largest_unique([1, 1, 1, 1], 1) \\"Not enough unique elements\\" >>> kth_largest_unique([4, 1, 3, 2], 2) 3 >>> kth_largest_unique([], 1) \\"Not enough unique elements\\"","solution":"def kth_largest_unique(arr, k): Returns the k-th largest element in the array after removing all elements that occur more than once. If there are fewer than k unique elements remaining, returns \\"Not enough unique elements\\". from collections import Counter # Count the occurrences of each element count = Counter(arr) # Filter elements with exactly one occurrence unique_elements = [num for num in arr if count[num] == 1] # If there are fewer than k unique elements, return the error message if len(unique_elements) < k: return \\"Not enough unique elements\\" # Sort unique elements in descending order unique_elements.sort(reverse=True) # Return the k-th largest element return unique_elements[k - 1]"},{"question":"from typing import List, Tuple def is_balanced(edges: List[Tuple[int, int]], n: int) -> bool: Determines whether the binary tree represented by edges is balanced. A binary tree is defined to be balanced if, for any node, the height difference between its left and right subtrees is at most 1. >>> is_balanced([(1, 2), (1, 3), (2, 4), (2, 5)], 5) True >>> is_balanced([(1, 2), (1, 3), (2, 4), (4, 5)], 5) False >>> is_balanced([], 1) True >>> is_balanced([], 0) True >>> is_balanced([(1, 2), (1, 3), (3, 4), (3, 5), (5, 6)], 6) False >>> is_balanced([(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], 7) True pass","solution":"from collections import defaultdict class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def build_tree(edges, n): if n == 0: return None nodes = {i: TreeNode(i) for i in range(1, n + 1)} children = defaultdict(list) for u, v in edges: children[u].append(v) children[v].append(u) def assign_children(node_val, parent_val): node = nodes[node_val] child_nodes = [ch for ch in children[node_val] if ch != parent_val] if child_nodes: node.left = nodes[child_nodes[0]] assign_children(child_nodes[0], node_val) if len(child_nodes) > 1: node.right = nodes[child_nodes[1]] assign_children(child_nodes[1], node_val) root_val = 1 assign_children(root_val, None) return nodes[root_val] def is_balanced_tree(root): def check_balance(node): if not node: return True, 0 is_left_balanced, left_height = check_balance(node.left) is_right_balanced, right_height = check_balance(node.right) if not is_left_balanced or not is_right_balanced: return False, 0 if abs(left_height - right_height) > 1: return False, 0 return True, max(left_height, right_height) + 1 balanced, _ = check_balance(root) return balanced def is_balanced(edges, n): root = build_tree(edges, n) return is_balanced_tree(root)"},{"question":"def is_anagram(s1: str, s2: str) -> bool: Determines if s2 is an anagram of s1. >>> is_anagram(\\"listen\\", \\"silent\\") True >>> is_anagram(\\"triangle\\", \\"integral\\") True >>> is_anagram(\\"apple\\", \\"papel\\") True >>> is_anagram(\\"abc\\", \\"def\\") False >>> is_anagram(\\"abcd\\", \\"abcc\\") False >>> is_anagram(\\"abc\\", \\"ab\\") False >>> is_anagram(\\"a\\", \\"aa\\") False >>> is_anagram(\\"\\", \\"\\") True >>> is_anagram(\\"\\", \\"\\") True >>> is_anagram(\\"\\", \\"\\") False","solution":"def is_anagram(s1, s2): Determines if s2 is an anagram of s1. :param s1: First string :param s2: Second string :return: True if s2 is an anagram of s1, False otherwise # Early termination if the lengths are not equal if len(s1) != len(s2): return False # Use a dictionary to count the frequency of each character in s1 char_count = {} for char in s1: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Decrease the frequency while iterating through s2 for char in s2: if char in char_count: char_count[char] -= 1 if char_count[char] < 0: return False else: return False return True"},{"question":"def wordBreak(s: str, wordDict: List[str]) -> List[str]: Given a string s and a list of words wordDict, return all possible sentences that can be formed by breaking s into a sequence of one or more dictionary words. :param s: The input string to be segmented. :param wordDict: The list of valid words. :return: A list of all possible sentences. >>> wordBreak(\\"apple\\", [\\"apple\\"]) [\\"apple\\"] >>> wordBreak(\\"penpineapple\\", [\\"pen\\", \\"pineapple\\", \\"pine\\", \\"apple\\"]) [\\"pen pineapple\\", \\"pen pine apple\\"] >>> wordBreak(\\"catsanddog\\", [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]) [\\"cat sand dog\\", \\"cats and dog\\"] >>> wordBreak(\\"catsandog\\", [\\"cats\\", \\"and\\", \\"dog\\"]) [] >>> wordBreak(\\"catsandbananaanddog\\", [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\", \\"banana\\"]) [\\"cat sand banana and dog\\", \\"cats and banana and dog\\"]","solution":"def wordBreak(s, wordDict): Given a string s and a list of words wordDict, return all possible sentences that can be formed by breaking s into a sequence of one or more dictionary words. :param s: The input string to be segmented. :param wordDict: The list of valid words. :return: A list of all possible sentences. def backtrack(index, path): if index == len(s): result.append(' '.join(path)) return for end in range(index + 1, len(s) + 1): word = s[index:end] if word in wordDict: path.append(word) backtrack(end, path) path.pop() result = [] backtrack(0, []) return result"},{"question":"def reachableNodes(n: int, edges: List[List[int]]) -> List[int]: You are given a directed graph represented by an integer \`n\` (the number of nodes) and a 2D integer array \`edges\` where each \`edges[i] = [ui, vi]\` represents a directed edge from node \`ui\` to node \`vi\`. The graph may contain cycles. Return an array of integers \`result\` of length \`n\` where \`result[i]\` is the number of nodes reachable from node \`i\` including itself. If a node does not have any outgoing edges, it can only reach itself. >>> reachableNodes(4, [[0, 1], [1, 2], [2, 3]]) [4, 3, 2, 1] >>> reachableNodes(3, [[0, 1], [1, 2], [2, 0]]) [3, 3, 3] >>> reachableNodes(5, [[0, 1], [1, 2], [3, 4]]) [3, 2, 1, 2, 1] >>> reachableNodes(4, []) [1, 1, 1, 1] >>> reachableNodes(1, [[0, 0]]) [1] >>> reachableNodes(6, [[0, 1], [1, 2], [3, 4]]) [3, 2, 1, 2, 1, 1] >>> reachableNodes(3, [[0, 1], [0, 2], [1, 2]]) [3, 2, 1] >>> reachableNodes(5, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 0]]) [5, 5, 5, 5, 5]","solution":"def reachableNodes(n, edges): from collections import defaultdict, deque # Create a graph representation using adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) def bfs(start_node): # Perform a breadth-first search to find all reachable nodes from start_node reachable = set() queue = deque([start_node]) while queue: node = queue.popleft() if node not in reachable: reachable.add(node) for neighbor in graph[node]: if neighbor not in reachable: queue.append(neighbor) return len(reachable) result = [] for i in range(n): result.append(bfs(i)) return result"},{"question":"def subset_sum(prices: List[int], budget: int) -> bool: Given a list of integers representing the prices of different items in a store, and an integer budget, determine if there exists a subset of items whose total price is exactly equal to the budget. Return \`true\` if such a subset exists, otherwise return \`false\`. >>> subset_sum([1, 2, 3, 4, 5], 9) True >>> subset_sum([1, 2, 5], 4) False >>> subset_sum([1, 2, 5], 0) True >>> subset_sum([3], 3) True >>> subset_sum([3], 1) False >>> subset_sum([1, 2, 3, 4, 5], 15) True >>> subset_sum([1, 2, 3], 8) False >>> subset_sum([3, 3, 3], 6) True >>> subset_sum([3, 3, 3], 9) True >>> subset_sum([3, 3, 3], 7) False","solution":"def subset_sum(prices, budget): Returns True if there exists a subset of prices that sum up to the budget, otherwise False. n = len(prices) dp = [False] * (budget + 1) dp[0] = True # There's always a subset with sum 0 for price in prices: for i in range(budget, price-1, -1): if dp[i - price]: dp[i] = True return dp[budget]"},{"question":"def two_sum_closest(arr, target): Finds two distinct integers in the array such that their sum is closest to the given target. :param arr: List of integers. :param target: The target integer. :return: A tuple of the indices of the two integers. from solution import two_sum_closest def test_two_sum_closest(): arr = [1, 3, 4, 2, 6] target = 7 result = two_sum_closest(arr, target) val1, val2 = arr[result[0]], arr[result[1]] assert (val1 + val2) == 7 def test_two_sum_closest_negative(): arr = [-1, 2, 1, -4] target = 1 result = two_sum_closest(arr, target) val1, val2 = arr[result[0]], arr[result[1]] assert abs(val1 + val2 - target) == 0 def test_two_sum_closest_large_numbers(): arr = [100000, 200000, 300000, 400000, 500000] target = 450000 result = two_sum_closest(arr, target) val1, val2 = arr[result[0]], arr[result[1]] assert abs(val1 + val2 - target) == 50000 def test_two_sum_closest_single_possible_solution(): arr = [1, 2] target = 4 result = two_sum_closest(arr, target) val1, val2 = arr[result[0]], arr[result[1]] assert abs(val1 + val2 - target) == 1 def test_two_sum_closest_nearest_pair(): arr = [10, 22, 28, 29, 30, 40] target = 54 result = two_sum_closest(arr, target) val1, val2 = arr[result[0]], arr[result[1]] assert val1 + val2 == 52","solution":"def two_sum_closest(arr, target): Finds two distinct integers in the array such that their sum is closest to the given target. :param arr: List of integers. :param target: The target integer. :return: A tuple of the indices of the two integers. n = len(arr) if n < 2: raise ValueError(\\"Array must contain at least two elements.\\") # Sorting the array while keeping track of original indices indexed_arr = list(enumerate(arr)) indexed_arr.sort(key=lambda x: x[1]) i, j = 0, len(arr) - 1 closest_sum = float('inf') best_pair = (None, None) while i < j: idx1, val1 = indexed_arr[i] idx2, val2 = indexed_arr[j] current_sum = val1 + val2 if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum best_pair = (idx1, idx2) if current_sum < target: i += 1 else: j -= 1 return best_pair"},{"question":"from typing import List, Tuple def find_subarray_with_product(arr: List[int], target: int) -> Tuple[int, int]: Find a contiguous subarray whose product of elements equals the target. Return the positions of the first and last element of this subarray in the form of a tuple. If no such subarray exists, return (-1, -1). >>> find_subarray_with_product([2, 3, 4, 5], 12) (1, 2) >>> find_subarray_with_product([2, 3, 4, 5], 50) (-1, -1) >>> find_subarray_with_product([2, 3, 4, 5], 4) (2, 2) >>> find_subarray_with_product([2, 2, 2, 2], 4) (0, 1) OR (1, 2) OR (2, 3) >>> find_subarray_with_product([1, 2, 3, 4, 5], 120) (0, 4) >>> find_subarray_with_product([1, 1, 1, 1], 1) (0, 0)","solution":"def find_subarray_with_product(arr, target): This function finds the starting and ending indices of a contiguous subarray whose product of elements equals the target. If no such subarray exists, it returns (-1, -1). product = 1 start = 0 for end in range(len(arr)): product *= arr[end] while product > target and start <= end: product //= arr[start] start += 1 if product == target: return (start, end) return (-1, -1)"},{"question":"def search_matrix(matrix: List[List[int]], target: int) -> bool: Searches for a target value in a 2D grid of integers where each row and each column are sorted in ascending order. Returns True if the target is found, and False otherwise. >>> matrix = [ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ] >>> search_matrix(matrix, 5) True >>> search_matrix(matrix, 20) False","solution":"def search_matrix(matrix, target): Searches for a target value in a 2D grid of integers where each row and each column are sorted in ascending order. Returns True if the target is found, and False otherwise. if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 # Start from the top-right corner while row < rows and col >= 0: if matrix[row][col] == target: return True elif target < matrix[row][col]: col -= 1 # Move left else: row += 1 # Move down return False"},{"question":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_values_in_each_row(root: Optional[TreeNode]) -> List[int]: You are given a binary tree in which each node has a random integer value. Your task is to find the largest value in each row of the tree and return it as an array. Implement a function that, given the root of the binary tree, returns an array of the largest values in each respective row of the tree. The tree has at most 10^4 nodes and values can range from -10^9 to 10^9. >>> largest_values_in_each_row(None) [] >>> root = TreeNode(42) >>> largest_values_in_each_row(root) [42] >>> root = TreeNode(1) >>> root.left = TreeNode(3) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(3) >>> root.right.right = TreeNode(9) >>> largest_values_in_each_row(root) [1, 3, 9] >>> root = TreeNode(-10) >>> root.left = TreeNode(-20) >>> root.right = TreeNode(-30) >>> root.left.left = TreeNode(-40) >>> root.left.right = TreeNode(-50) >>> root.right.right = TreeNode(-60) >>> largest_values_in_each_row(root) [-10, -20, -40] >>> root = TreeNode(5) >>> root.left = TreeNode(2) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(7) >>> root.right.left = TreeNode(4) >>> root.right.right = TreeNode(10) >>> largest_values_in_each_row(root) [5, 8, 10]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_values_in_each_row(root): if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) max_value = -float('inf') for _ in range(level_length): node = queue.popleft() max_value = max(max_value, node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(max_value) return result"},{"question":"def has_pair_with_sum(arr: list[int], x: int) -> bool: Determines if there exist two distinct elements in the array such that their sum is equal to x. >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) True >>> has_pair_with_sum([1, 2, 3, 4, 5, 3], 6) True >>> has_pair_with_sum([-1, -2, -3, -4, -5], -8) True >>> has_pair_with_sum([-1, 2, 3, -4, 5], 1) True >>> has_pair_with_sum([-1, 1, 2, 3, -2], 0) True >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([1], 5) False","solution":"def has_pair_with_sum(arr, x): Determines if there exist two distinct elements in the array such that their sum is equal to x. Parameters: arr (list of int): List of integers. x (int): Target sum. Returns: bool: True if such a pair exists, False otherwise. seen = set() for num in arr: if x - num in seen: return True seen.add(num) return False"},{"question":"def min_operations_to_unique_substrings(s: str) -> int: Given a string s containing lowercase letters, return the minimum number of operations required to make all of its substrings composed of distinct characters. >>> min_operations_to_unique_substrings(\\"abc\\") 0 >>> min_operations_to_unique_substrings(\\"a\\") 0 >>> min_operations_to_unique_substrings(\\"aabbcc\\") 3 >>> min_operations_to_unique_substrings(\\"abac\\") 1 >>> min_operations_to_unique_substrings(\\"\\") 0","solution":"def min_operations_to_unique_substrings(s): Given a string s, return the minimum number of operations needed to make all substrings of s composed of distinct characters. if not s: return 0 # Create a frequency dictionary for the characters in the string char_freq = {} for char in s: if char in char_freq: char_freq[char] += 1 else: char_freq[char] = 1 # The number of operations is the number of characters that appear more than once operations = 0 for freq in char_freq.values(): if freq > 1: operations += freq - 1 return operations"},{"question":"def nextClosestTime(time: str) -> str: Given a string \`time\` representing the current time in the HH:MM 24-hour format, return the next closest time that can be generated by reusing the digits currently present in \`time\`. The result should also be in the HH:MM format. >>> nextClosestTime(\\"19:34\\") \\"19:39\\" >>> nextClosestTime(\\"23:59\\") \\"22:22\\" >>> nextClosestTime(\\"00:00\\") \\"00:00\\" >>> nextClosestTime(\\"13:55\\") \\"15:11\\" >>> nextClosestTime(\\"14:29\\") \\"14:41\\"","solution":"def nextClosestTime(time: str) -> str: Given a string time representing the current time in the HH:MM 24-hour format, returns the next closest time that can be generated by reusing the digits currently present in time hours, minutes = map(int, time.split(':')) digits = sorted(set(time.replace(':', ''))) while True: if minutes < 59: minutes += 1 else: minutes = 0 if hours < 23: hours += 1 else: hours = 0 next_time = f\\"{hours:02}:{minutes:02}\\" if all(char in digits for char in next_time.replace(':', '')): return next_time"},{"question":"def kth_smallest_unique(nums: List[int], k: int) -> int: Return the k-th smallest unique integer in the array, or -1 if it does not exist. >>> kth_smallest_unique([4, 3, 1, 1, 2, 5, 4, 3], 1) 2 >>> kth_smallest_unique([4, 3, 1, 1, 2, 5, 4, 3], 2) 5 >>> kth_smallest_unique([4, 3, 1, 1, 2, 5, 4, 3], 3) -1 >>> kth_smallest_unique([], 1) -1 >>> kth_smallest_unique([1, 2, 3, 4, 5], 1) 1 >>> kth_smallest_unique([1, 1, 1, 1, 1], 1) -1 >>> kth_smallest_unique([1], 1) 1 >>> kth_smallest_unique([4, 4, 4, 5, 5, 6], 1) 6 >>> kth_smallest_unique([7, 8, 7, 8, 9], 1) 9","solution":"def kth_smallest_unique(nums, k): Return the k-th smallest unique integer in the array, or -1 if it does not exist. from collections import Counter count = Counter(nums) unique_nums = sorted(num for num, freq in count.items() if freq == 1) if k <= len(unique_nums): return unique_nums[k-1] else: return -1"},{"question":"from typing import List def min_moves_to_k_frequencies(s: str, k: int) -> int: Determine the minimum number of moves required to make all the characters in the string appear at least \`k\` times. In one move, you can choose any character and replace it with another character. >>> min_moves_to_k_frequencies(\\"aabbc\\", 1) == 0 >>> min_moves_to_k_frequencies(\\"aabbcc\\", 2) == 0 >>> min_moves_to_k_frequencies(\\"abc\\", 2) == 3 >>> min_moves_to_k_frequencies(\\"abcdefghijklmnopqrstuvwxyz\\", 1) == 0 >>> min_moves_to_k_frequencies(\\"aabbc\\", 2) == 1 >>> min_moves_to_k_frequencies(\\"aabb\\", 3) == 2 >>> min_moves_to_k_frequencies(\\"aaaa\\", 4) == 0 >>> min_moves_to_k_frequencies(\\"aaaa\\", 5) == 1 >>> min_moves_to_k_frequencies(\\"\\", 1) == 0","solution":"def min_moves_to_k_frequencies(s, k): from collections import Counter char_count = Counter(s) moves = 0 for count in char_count.values(): if count < k: moves += (k - count) return moves"},{"question":"class InventoryManager: A warehouse management system needs to track inventories and process orders efficiently. Implement the \`InventoryManager\` class with the following methods: - \`InventoryManager()\` Initializes the inventory manager with an empty inventory. - \`addItem(itemName, quantity)\` Adds \`quantity\` of \`itemName\` to the inventory. If \`itemName\` already exists, increase its quantity by the given amount. - \`removeItem(itemName, quantity)\` Removes \`quantity\` of \`itemName\` from the inventory. If the remaining quantity of \`itemName\` becomes zero or negative, remove \`itemName\` from the inventory. - \`checkStock(itemName)\` Returns the current quantity of \`itemName\` in the inventory. If \`itemName\` does not exist, return \`0\`. pass # Unit Tests def test_initial_inventory(): im = InventoryManager() assert im.checkStock(\\"item1\\") == 0 def test_add_item(): im = InventoryManager() im.addItem(\\"item1\\", 10) assert im.checkStock(\\"item1\\") == 10 def test_add_existing_item(): im = InventoryManager() im.addItem(\\"item1\\", 10) im.addItem(\\"item1\\", 5) assert im.checkStock(\\"item1\\") == 15 def test_remove_item(): im = InventoryManager() im.addItem(\\"item1\\", 10) im.removeItem(\\"item1\\", 5) assert im.checkStock(\\"item1\\") == 5 def test_remove_item_completely(): im = InventoryManager() im.addItem(\\"item1\\", 10) im.removeItem(\\"item1\\", 10) assert im.checkStock(\\"item1\\") == 0 def test_remove_item_more_than_exists(): im = InventoryManager() im.addItem(\\"item1\\", 10) im.removeItem(\\"item1\\", 15) assert im.checkStock(\\"item1\\") == 0","solution":"class InventoryManager: def __init__(self): self.inventory = {} def addItem(self, itemName, quantity): if itemName in self.inventory: self.inventory[itemName] += quantity else: self.inventory[itemName] = quantity def removeItem(self, itemName, quantity): if itemName in self.inventory: self.inventory[itemName] -= quantity if self.inventory[itemName] <= 0: del self.inventory[itemName] def checkStock(self, itemName): return self.inventory.get(itemName, 0)"},{"question":"import heapq from typing import List def kthSmallestPairSum(nums1: List[int], nums2: List[int], k: int) -> int: Returns the kth smallest sum of pairs formed by taking one element from nums1 and one element from nums2. >>> kthSmallestPairSum([1, 7, 11], [2, 4, 6], 3) 7 >>> kthSmallestPairSum([1, 1, 2], [1, 2, 3], 2) 2 >>> kthSmallestPairSum([1, 2], [3, 4], 1) 4 >>> kthSmallestPairSum([1, 2], [1, 2, 3, 4, 5], 8) 6 >>> kthSmallestPairSum([1, 1, 1], [1, 1, 1], 5) 2 >>> kthSmallestPairSum([1], [1], 1) 2","solution":"import heapq def kthSmallestPairSum(nums1, nums2, k): Returns the kth smallest sum of pairs formed by taking one element from nums1 and one element from nums2. min_heap = [] for i in range(len(nums1)): heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0)) count = 0 while min_heap: sum_val, i, j = heapq.heappop(min_heap) count += 1 if count == k: return sum_val if j + 1 < len(nums2): heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))"},{"question":"import math from typing import List def euclidean_distance(p1, p2): Calculate the Euclidean distance between two points p1 and p2. return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def k_th_smallest_distance(points: List[List[int]], k: int) -> float: Find the k-th smallest distance from a point to its nearest neighbor in the polygon. Parameters: points (List[List[int]]): Array containing the coordinates of points on a 2D plane. k (int): The k-th order statistic to find. Returns: float: The k-th smallest distance, rounded to 4 decimal places. Return -1 if impossible. >>> k_th_smallest_distance([[0,0], [0,1], [1,1], [1,0]], 2) 1.0 >>> k_th_smallest_distance([[0,0], [0,1], [1,1]], 4) -1 >>> k_th_smallest_distance([[1,1], [2,2], [3,1], [2,0]], 1) 1.4142","solution":"import math def euclidean_distance(p1, p2): Calculate the Euclidean distance between two points p1 and p2. return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def k_th_smallest_distance(points, k): Find the k-th smallest distance from a point to its nearest neighbor in the polygon. n = len(points) if k > n: return -1 distances = [] for i in range(n): next_i = (i + 1) % n distance = euclidean_distance(points[i], points[next_i]) distances.append(distance) distances.sort() return round(distances[k-1], 4)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partitionList(head, x): Partitions the linked list around value x. :param head: ListNode, the head of the input linked list :param x: int, the partition value :return: ListNode, the head of the partitioned linked list Example: >>> head = build_linked_list([1, 4, 3, 2, 5, 2]) >>> x = 3 >>> result_head = partitionList(head, x) >>> result = linked_list_to_list(result_head) >>> result == [1, 2, 2, 4, 3, 5] True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partitionList(head, x): Partitions the linked list around value x. :param head: ListNode, the head of the input linked list :param x: int, the partition value :return: ListNode, the head of the partitioned linked list if not head: return None less_head = ListNode(0) # dummy head for less than partition greater_head = ListNode(0) # dummy head for greater than or equal partition less = less_head greater = greater_head current = head while current: if current.val < x: less.next = current less = less.next else: greater.next = current greater = greater.next current = current.next greater.next = None # finalize greater partition less.next = greater_head.next # combine partitions return less_head.next"},{"question":"def merge_sorted_arrays(nums1: List[int], nums2: List[int]) -> List[int]: Merge two sorted arrays into a new sorted array. Args: nums1 (List[int]): First sorted array. nums2 (List[int]): Second sorted array. Returns: List[int]: A new sorted array. >>> merge_sorted_arrays([], []) [] >>> merge_sorted_arrays([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_arrays([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_arrays([1, 2, 3], [4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 2, 2, 5], [2, 3, 5]) [1, 2, 2, 2, 3, 5, 5] >>> merge_sorted_arrays([1, 2, 3], [1, 2, 3]) [1, 1, 2, 2, 3, 3]","solution":"def merge_sorted_arrays(nums1, nums2): Merge two sorted arrays into a new sorted array. Args: nums1 (List[int]): First sorted array. nums2 (List[int]): Second sorted array. Returns: List[int]: A new sorted array. i, j = 0, 0 merged_array = [] while i < len(nums1) and j < len(nums2): if nums1[i] < nums2[j]: merged_array.append(nums1[i]) i += 1 else: merged_array.append(nums2[j]) j += 1 while i < len(nums1): merged_array.append(nums1[i]) i += 1 while j < len(nums2): merged_array.append(nums2[j]) j += 1 return merged_array"},{"question":"def maxProfit(prices): Returns the maximum profit achievable with as many transactions as needed. :param prices: List[int] where prices[i] is the price of a given stock on the ith day. :return: int - Maximum profit. >>> maxProfit([1, 2, 3, 4, 5]) 4 >>> maxProfit([5, 4, 3, 2, 1]) 0 >>> maxProfit([7, 1, 5, 3, 6, 4]) 7 >>> maxProfit([7, 6, 4, 3, 1]) 0 >>> maxProfit([1]) 0 >>> maxProfit([]) 0","solution":"def maxProfit(prices): Returns the maximum profit achievable with as many transactions as needed. :param prices: List[int] where prices[i] is the price of a given stock on the ith day. :return: int - Maximum profit. max_profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit"},{"question":"def min_cost_to_paint_houses(costs) -> int: Given a costs matrix where costs[i][j] is the cost of painting the i-th house with color j, returns the minimum cost to paint all the houses such that no two adjacent houses have the same color. >>> min_cost_to_paint_houses([ ... [17, 2, 17], ... [16, 16, 5], ... [14, 3, 19] ... ]) 10 >>> min_cost_to_paint_houses([[3, 5, 3]]) 3 >>> min_cost_to_paint_houses([[1, 2, 3]]) 1 >>> min_cost_to_paint_houses([ ... [1, 50, 50], ... [50, 10, 50] ... ]) 11 >>> min_cost_to_paint_houses([]) 0 >>> min_cost_to_paint_houses([ ... [10, 10, 10], ... [10, 10, 10], ... [10, 10, 10] ... ]) 30 >>> min_cost_to_paint_houses([ ... [3, 2, 4], ... [1, 2, 3], ... [2, 2, 1], ... [3, 2, 1] ... ]) 6","solution":"def min_cost_to_paint_houses(costs): Given a costs matrix where costs[i][j] is the cost of painting the i-th house with color j, returns the minimum cost to paint all the houses such that no two adjacent houses have the same color. if not costs: return 0 n = len(costs) dp = costs[0][:] for i in range(1, n): previous_dp = dp[:] dp[0] = costs[i][0] + min(previous_dp[1], previous_dp[2]) dp[1] = costs[i][1] + min(previous_dp[0], previous_dp[2]) dp[2] = costs[i][2] + min(previous_dp[0], previous_dp[1]) return min(dp) # Example usage: # costs = [ # [17, 2, 17], # [16, 16, 5], # [14, 3, 19] # ] # print(min_cost_to_paint_houses(costs)) # Output: 10"},{"question":"def longest_increasing_subsequence_with_max_difference(arr: List[int], d: int) -> int: Find the length of the longest increasing subsequence in \`arr\` such that the absolute difference between any two consecutive elements in the subsequence is less than or equal to \`d\`. >>> longest_increasing_subsequence_with_max_difference([1, 2, 3, 4, 5], 1) == 5 >>> longest_increasing_subsequence_with_max_difference([10, 12, 15, 23, 24, 25], 5) == 3 >>> longest_increasing_subsequence_with_max_difference([1, 100, 200], 50) == 1 >>> longest_increasing_subsequence_with_max_difference([9, 8, 7, 6, 5], 2) == 1 >>> longest_increasing_subsequence_with_max_difference([4, 2, 3, 6, 10], 3) == 3 >>> longest_increasing_subsequence_with_max_difference([1, 5, 2, 6, 3, 7, 4], 2) == 4 >>> longest_increasing_subsequence_with_max_difference([], 1) == 0 >>> longest_increasing_subsequence_with_max_difference([4], 1) == 1 >>> longest_increasing_subsequence_with_max_difference([1, 3, 5, 7, 9], 6) == 5","solution":"def longest_increasing_subsequence_with_max_difference(arr, d): n = len(arr) if n == 0: return 0 # dp[i] will store the length of the longest increasing subsequence ending with arr[i] dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j] and arr[i] - arr[j] <= d: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def most_stable_temperature_city(cities: List[str], temperatures: List[List[int]]) -> str: Returns the name of the city with the most stable temperature. Args: cities (list): List of city names. temperatures (list): List of Lists of temperatures for each city. Returns: str: Name of the most stable temperature city. pass if __name__ == \\"__main__\\": from typing import List def test_single_city(): assert most_stable_temperature_city([\\"CityA\\"], [[30, 30, 30, 30, 30, 30, 30]]) == \\"CityA\\" def test_two_cities(): assert most_stable_temperature_city([\\"CityA\\", \\"CityB\\"], [[30, 40, 35, 20, 25, 30, 40], [25, 25, 25, 25, 25, 25, 25]]) == \\"CityB\\" def test_multiple_cities(): cities = [\\"CityA\\", \\"CityB\\", \\"CityC\\"] temperatures = [[30, 40, 50, 60, 35, 45, 55], [35, 35, 35, 35, 35, 35, 35], [20, 30, 25, 30, 25, 30, 25]] assert most_stable_temperature_city(cities, temperatures) == \\"CityB\\" def test_stability_tiebreaker(): cities = [\\"CityB\\", \\"CityA\\", \\"CityC\\"] temperatures = [[30, 30, 30, 30, 30, 30, 30], [30, 30, 30, 30, 30, 30, 30], [50, 50, 50, 50, 50, 50, 50]] assert most_stable_temperature_city(cities, temperatures) == \\"CityA\\" def test_varying_temp_ranges(): cities = [\\"CityD\\", \\"CityA\\", \\"CityC\\", \\"CityB\\"] temperatures = [[30, 40, 50, 60, 70, 80, 90], [10, 20, 30, 40, 50, 60, 70], [15, 15, 15, 15, 15, 15, 20], [25, 35, 45, 55, 65, 75, 85]] assert most_stable_temperature_city(cities, temperatures) == \\"CityC\\" test_single_city() test_two_cities() test_multiple_cities() test_stability_tiebreaker() test_varying_temp_ranges()","solution":"def most_stable_temperature_city(cities, temperatures): Returns the name of the city with the most stable temperature. Args: cities (list): List of city names. temperatures (list): List of Lists of temperatures for each city. Returns: str: Name of the most stable temperature city. min_range = float('inf') stable_city = \\"\\" for i, temp in enumerate(temperatures): temp_range = max(temp) - min(temp) if temp_range < min_range or (temp_range == min_range and cities[i] < stable_city): min_range = temp_range stable_city = cities[i] return stable_city"},{"question":"def calculate_time_spent(logs): Processes logs of user actions and calculates total time spent logged in for each user. Args: logs (list): List of lists where each inner list is of the form [userID, timestamp, action] Returns: list: List of tuples where each tuple contains a userID and the total time spent logged in for that user, sorted by userID in ascending order. pass # Example test cases def test_calculate_time_spent_simple_case(): logs = [ [1, 1, \\"login\\"], [1, 5, \\"logout\\"], [2, 2, \\"login\\"], [2, 7, \\"logout\\"] ] assert calculate_time_spent(logs) == [(1, 4), (2, 5)] def test_calculate_time_spent_multiple_sessions(): logs = [ [1, 1, \\"login\\"], [1, 4, \\"logout\\"], [1, 5, \\"login\\"], [1, 8, \\"logout\\"] ] assert calculate_time_spent(logs) == [(1, 6)] def test_calculate_time_spent_unordered_users(): logs = [ [2, 2, \\"login\\"], [1, 1, \\"login\\"], [1, 3, \\"logout\\"], [2, 7, \\"logout\\"] ] assert calculate_time_spent(logs) == [(1, 2), (2, 5)] def test_calculate_time_spent_incomplete_logout(): # User 3 does not logout logs = [ [1, 1, \\"login\\"], [1, 3, \\"logout\\"], [2, 2, \\"login\\"], [2, 5, \\"logout\\"], [3, 6, \\"login\\"] ] assert calculate_time_spent(logs) == [(1, 2), (2, 3)] def test_calculate_time_spent_no_logs(): logs = [] assert calculate_time_spent(logs) == [] if __name__ == \\"__main__\\": test_calculate_time_spent_simple_case() test_calculate_time_spent_multiple_sessions() test_calculate_time_spent_unordered_users() test_calculate_time_spent_incomplete_logout() test_calculate_time_spent_no_logs() print(\\"All tests passed.\\")","solution":"def calculate_time_spent(logs): Processes logs of user actions and calculates total time spent logged in for each user. Args: logs (list): List of lists where each inner list is of the form [userID, timestamp, action] Returns: list: List of tuples where each tuple contains a userID and the total time spent logged in for that user, sorted by userID in ascending order. from collections import defaultdict time_spent = defaultdict(int) login_times = {} for log in logs: user_id, timestamp, action = log if action == \\"login\\": login_times[user_id] = timestamp elif action == \\"logout\\": if user_id in login_times: time_spent[user_id] += timestamp - login_times[user_id] del login_times[user_id] # Remove the user from login_times once they log out # Convert the defaultdict to a sorted list of tuples result = sorted(time_spent.items()) return result"},{"question":"def count_distinct_characters(s: str, queries: List[List[int]]) -> List[int]: Given a string \`s\` and an array of queries, each query contains two indices \`li\` and \`ri\`. For each query, count the distinct characters in the substring \`s[li...ri]\`. Parameters: s (str): The input string consisting of lowercase English letters. queries (List[List[int]]): The array of queries, each containing two integers \`li\` and \`ri\`. Returns: List[int]: An array containing the number of distinct characters for each query.","solution":"def count_distinct_characters(s, queries): Given a string \`s\` and an array of queries, each query contains two indices \`li\` and \`ri\`. For each query, count the distinct characters in the substring \`s[li...ri]\`. Parameters: s (str): The input string consisting of lowercase English letters. queries (List[List[int]]): The array of queries, each containing two integers \`li\` and \`ri\`. Returns: List[int]: An array containing the number of distinct characters for each query. answer = [] for query in queries: li, ri = query substring = s[li:ri+1] distinct_chars = set(substring) answer.append(len(distinct_chars)) return answer"},{"question":"from typing import List def min_diff_partition(arr: List[int]) -> int: Distribute the files into two folders such that the absolute difference between the total sizes of the files in the two folders is minimized. Return the minimum possible absolute difference. >>> min_diff_partition([1, 6, 11, 5]) 1 >>> min_diff_partition([10, 20, 15, 5, 25]) 5","solution":"def min_diff_partition(arr): total_sum = sum(arr) n = len(arr) # Using dynamic programming to solve partition problem dp = [False] * (total_sum + 1) dp[0] = True for num in arr: for j in range(total_sum, num-1, -1): if dp[j - num]: dp[j] = True min_diff = float('inf') # Find the largest j such that dp[j] is True and j <= total_sum//2 for j in range(total_sum // 2, -1, -1): if dp[j]: min_diff = total_sum - 2 * j break return min_diff"},{"question":"def max_length_subarray(arr, k): Returns the maximum length of a contiguous subarray that contains at most k different integers. Parameters: arr (list): List of integers k (int): Maximum number of unique integers allowed Returns: int: Maximum length of subarray >>> max_length_subarray([1, 2, 1, 2, 3], 2) 4 >>> max_length_subarray([1, 2, 3, 4, 5], 1) 1 >>> max_length_subarray([1, 1, 1, 1], 1) 4 >>> max_length_subarray([1, 2, 1, 3, 4], 2) 3 >>> max_length_subarray([1, 2, 3, 4], 0) 0 >>> max_length_subarray([1, 2, 1, 3, 3, 4, 5, 5], 3) 5","solution":"def max_length_subarray(arr, k): Returns the maximum length of a contiguous subarray that contains at most k different integers. Parameters: arr (list): List of integers k (int): Maximum number of unique integers allowed Returns: int: Maximum length of subarray from collections import defaultdict if k == 0: return 0 left = 0 right = 0 max_length = 0 freq_map = defaultdict(int) while right < len(arr): freq_map[arr[right]] += 1 while len(freq_map) > k: freq_map[arr[left]] -= 1 if freq_map[arr[left]] == 0: del freq_map[arr[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def can_rearrange_heights(heights: List[int], k: int) -> bool: Determines if it is possible to rearrange the people in the line such that the difference in height between any two adjacent people is at most k. :param heights: List[int] - a list of integers representing the heights of people :param k: int - the allowable difference in height between two adjacent people :return: bool - True if such a rearrangement is possible, False otherwise >>> can_rearrange_heights([1, 3, 5], 2) True >>> can_rearrange_heights([5, 1, 3], 2) True >>> can_rearrange_heights([7, 11, 9], 4) True >>> can_rearrange_heights([1, 6, 3], 2) False >>> can_rearrange_heights([4, 5, 8], 1) False >>> can_rearrange_heights([10, 20, 30], 5) False >>> can_rearrange_heights([5], 0) True >>> can_rearrange_heights([100], 50) True >>> can_rearrange_heights([-1, -3, -2], 2) True >>> can_rearrange_heights([-10, -20, -15], 5) True >>> can_rearrange_heights([-5, 0, 10], 7) False >>> can_rearrange_heights([5, 5, 5, 5], 0) True >>> can_rearrange_heights([5, 5, 5, 5], 1) True pass","solution":"def can_rearrange_heights(heights, k): Determines if it is possible to rearrange the people in the line such that the difference in height between any two adjacent people is at most k. :param heights: List[int] - a list of integers representing the heights of people :param k: int - the allowable difference in height between two adjacent people :return: bool - True if such a rearrangement is possible, False otherwise # Sort heights in ascending order heights.sort() # Check the differences between each adjacent height for i in range(len(heights) - 1): if abs(heights[i] - heights[i + 1]) > k: return False return True"},{"question":"def can_partition_k_subsets(arr: List[int], k: int) -> bool: Determine if you can partition the list into exactly \`k\` non-empty subsets such that the sum of the elements in each subset is the same. >>> can_partition_k_subsets([4, 3, 2, 3, 5, 2, 1], 4) == True >>> can_partition_k_subsets([1], 1) == True >>> can_partition_k_subsets([1, 2, 3, 4], 3) == False >>> can_partition_k_subsets([2, 2, 2, 2, 3, 4, 5], 3) == False >>> can_partition_k_subsets([4, 4, 4, 4, 5, 5, 5, 5, 3, 3, 3, 3, 2, 2, 2, 2], 4) == True","solution":"def can_partition_k_subsets(arr, k): total_sum = sum(arr) if total_sum % k != 0: return False target_sum = total_sum // k arr.sort(reverse=True) used = [False] * len(arr) def backtrack(start, k, current_sum): if k == 1: return True if current_sum == target_sum: return backtrack(0, k - 1, 0) for i in range(start, len(arr)): if not used[i] and current_sum + arr[i] <= target_sum: used[i] = True if backtrack(i + 1, k, current_sum + arr[i]): return True used[i] = False return False return backtrack(0, k, 0)"},{"question":"from typing import List def maxProducts(prices: List[List[int]], budget: int) -> int: Determine the maximum number of different products you can buy without exceeding your budget. You must purchase exactly one item from each store. If it's not possible to buy one product from each store within the given budget, return -1. prices: List of lists containing the prices of products from different stores. budget: Total budget available. >>> maxProducts([[3, 5, 7], [10, 12, 20], [1, 2, 10]], 15) 3 >>> maxProducts([[5, 9], [6, 12], [1, 3]], 10) -1 def test_max_products_example1(): assert maxProducts([[3, 5, 7], [10, 12, 20], [1, 2, 10]], 15) == 3 def test_max_products_example2(): assert maxProducts([[5, 9], [6, 12], [1, 3]], 10) == -1 def test_max_products_exact_budget(): assert maxProducts([[2, 4, 6], [1, 5, 8], [3, 7, 9]], 6) == 3 def test_max_products_over_budget(): assert maxProducts([[2, 4], [3, 6], [1, 5]], 4) == -1 def test_max_products_large_budget(): assert maxProducts([[2, 4], [3, 6], [1, 5]], )): pass","solution":"from typing import List def maxProducts(prices: List[List[int]], budget: int) -> int: min_prices = [min(store) for store in prices] total_min_cost = sum(min_prices) if total_min_cost > budget: return -1 return len(prices)"},{"question":"def max_distinct_categories(tasks): Returns the maximum number of distinct categories from which the user completes at least one task. :param tasks: List of tuples (task_id, category_id). :return: Maximum number of distinct categories. >>> max_distinct_categories([]) 0 >>> max_distinct_categories([(1, 'A')]) 1 >>> max_distinct_categories([(1, 'A'), (2, 'A'), (3, 'A')]) 1 >>> max_distinct_categories([(1, 'A'), (2, 'B'), (3, 'C')]) 3 >>> max_distinct_categories([(1, 'A'), (2, 'A'), (3, 'B'), (4, 'C'), (5, 'B')]) 3 >>> max_distinct_categories([(1, 'X'), (2, 'Y'), (3, 'X'), (4, 'Z'), (5, 'Y'), (6, 'V')]) 4","solution":"def max_distinct_categories(tasks): Returns the maximum number of distinct categories from which the user completes at least one task. :param tasks: List of tuples (task_id, category_id). :return: Maximum number of distinct categories. if not tasks: return 0 category_set = set() for task in tasks: _, category_id = task category_set.add(category_id) return len(category_set)"},{"question":"from typing import List def shortest_path_maze(grid: List[List[int]]) -> int: Returns the shortest path from the start to the exit in terms of the number of cells in a given 2D grid maze, or -1 if there is no path. >>> shortest_path_maze([[0, 1], [0, 0]]) 3 >>> shortest_path_maze([[0, 1], [1, 0]]) -1 >>> shortest_path_maze([[0, 0, 0], [1, 1, 0], [0, 0, 0]]) 5 >>> shortest_path_maze([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 5 >>> shortest_path_maze([[0, 1, 1, 0, 1], [0, 0, 1, 0, 0], [1, 0, 1, 1, 0], [1, 0, 0, 0, 0], [1, 1, 1, 1, 0]]) 9 >>> shortest_path_maze([[1, 0], [0, 0]]) -1 >>> shortest_path_maze([[0, 0], [0, 1]]) -1 >>> shortest_path_maze([[0, 0, 1], [1, 0, 1], [1, 0, 0]]) 5","solution":"from collections import deque def shortest_path_maze(grid): Returns the shortest path from the start to the exit in terms of the number of cells in a given 2D grid maze, or -1 if there is no path. if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, 1)]) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == m - 1 and y == n - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def count_subsequences(nums: List[int], S: int) -> int: Returns the number of subsequences that sum to the given target value S. >>> count_subsequences([1, 2, 3], 3) 2 >>> count_subsequences([1, 1, 1, 1], 2) 6 >>> count_subsequences([1, 2, 3], 7) 0 >>> count_subsequences([5], 5) 1 >>> count_subsequences([], 0) 1 >>> count_subsequences([1, -1, 2, -2], 0) 4","solution":"def count_subsequences(nums, S): Returns the number of subsequences that sum to the given target value S. nums: List[int] - List of integers S: int - target sum value return: int - number of subsequences summing to S from collections import defaultdict # This will store the number of subsequences that achieve each possible sum dp = defaultdict(int) dp[0] = 1 # There's one subsequence (empty subsequence) that has a sum of 0 for num in nums: # We should iterate in reverse to avoid counting each number more than once for subsum in list(dp.keys())[::-1]: dp[subsum + num] += dp[subsum] return dp[S]"},{"question":"from typing import List, Tuple from collections import defaultdict from itertools import combinations def count_valid_teams(n: int, relations: List[Tuple[int, int]], k: int) -> int: Determine the number of ways to form teams such that each team consists of exactly \`k\` employees who can work well together. >>> count_valid_teams(3, [[0, 1], [1, 2], [0, 2]], 3) 1 >>> count_valid_teams(4, [[0, 1], [1, 2], [2, 3]], 3) 0 >>> count_valid_teams(5, [[0, 1], [1, 2], [2, 3], [3, 4], [0, 2]], 3) 1 >>> count_valid_teams(4, [[0, 1], [1, 2], [2, 3], [3, 0]], 1) 4 >>> count_valid_teams(4, [[0, 1], [1, 2], [2, 3], [3, 0]], 5) 0","solution":"from collections import defaultdict from itertools import combinations def count_valid_teams(n, relations, k): # Create an adjacency list for relations adj_list = defaultdict(set) for a, b in relations: adj_list[a].add(b) adj_list[b].add(a) def is_clique(team): # Check if every pair in the team works well together for u, v in combinations(team, 2): if v not in adj_list[u]: return False return True if k > n: return 0 employees = list(range(n)) valid_teams = 0 # Find all combinations of k employees for team in combinations(employees, k): if is_clique(team): valid_teams += 1 return valid_teams"},{"question":"def next_higher_permutation(num: int) -> int: Write a function that takes in a non-negative integer \`num\` and returns its next higher permutation. A permutation of a number is just a rearrangement of its digits. The next higher permutation of a number is the smallest number that is greater than \`num\` that can be formed by rearranging its digits. If no such permutation exists, return \`-1\`. >>> next_higher_permutation(1234) == 1243 >>> next_higher_permutation(4321) == -1 >>> next_higher_permutation(5) == -1 >>> next_higher_permutation(1111) == -1 >>> next_higher_permutation(120) == 201 >>> next_higher_permutation(115) == 151","solution":"def next_higher_permutation(num): Given a non-negative integer, returns its next higher permutation. If no such permutation exists, returns -1. # Convert the number to a list of digits digits = list(str(num)) # Find the pivot, the point (from right) where the digit decreases pivot = -1 for i in range(len(digits) - 2, -1, -1): if digits[i] < digits[i + 1]: pivot = i break if pivot == -1: return -1 # No higher permutation possible # Find the smallest digit on the right side of the pivot which is larger than digits[pivot] for j in range(len(digits) - 1, pivot, -1): if digits[j] > digits[pivot]: # Swap digits[j] and digits[pivot] digits[j], digits[pivot] = digits[pivot], digits[j] break # Reverse the digits to the right of the pivot next_perm = digits[:pivot + 1] + digits[pivot + 1:][::-1] return int(\\"\\".join(next_perm))"},{"question":"def total_cost(prices, discounts): Calculate the total cost of the books after applying the discounts appropriately. Parameters: prices (list of int): List of book prices. discounts (list of int): List of discounts corresponding to each book. Returns: int: The total cost after applying the discounts. >>> total_cost([10, 15, 20], [6, 8, 12]) 45 >>> total_cost([10, 15, 20], [2, 5, 8]) 30 >>> total_cost([10, 15, 20], [2, 10, 8]) 35 >>> total_cost([10, 20, 30], [0, 0, 0]) 60 >>> total_cost([], []) 0 >>> total_cost([10], [2]) 8 >>> total_cost([4], [2]) 2","solution":"def total_cost(prices, discounts): This function calculates the total cost of books after applying the discounts appropriately. Parameters: prices (list of int): List of book prices. discounts (list of int): List of discounts corresponding to each book. Returns: int: The total cost after applying the discounts. total = 0 for price, discount in zip(prices, discounts): if price >= 2 * discount: total += price - discount else: total += price return total"},{"question":"from typing import List def shortestPathBinaryMaze(grid: List[List[int]]) -> int: Finds the shortest path in a binary maze avoiding obstacles. :param grid: List[List[int]] A binary matrix where 0 is an empty cell and 1 is an obstacle. :return: Integer The length of the shortest path from the top-left to the bottom-right avoiding obstacles, or -1 if there is no such path. >>> grid = [ ... [0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [0, 1, 1, 1, 0], ... [0, 0, 0, 0, 0] ... ] >>> shortestPathBinaryMaze(grid) 9 >>> grid = [ ... [0, 1, 0], ... [1, 1, 0], ... [0, 1, 0] ... ] >>> shortestPathBinaryMaze(grid) -1 >>> grid = [[0]] >>> shortestPathBinaryMaze(grid) 1","solution":"from collections import deque def shortestPathBinaryMaze(grid): Finds the shortest path in a binary maze avoiding obstacles. :param grid: List[List[int]] A binary matrix where 0 is an empty cell and 1 is an obstacle. :return: Integer The length of the shortest path from the top-left to the bottom-right avoiding obstacles, or -1 if there is no such path. if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == m - 1 and y == n - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"def find_target_indices(nums: List[int], target: int) -> List[int]: Returns the first and last indices of the target in the sorted list of nums. If target is not found, return [-1, -1]. >>> find_target_indices([1, 2, 2, 3, 4], 2) [1, 2] >>> find_target_indices([1, 3, 5, 7], 2) [-1, -1] >>> find_target_indices([2, 2, 3, 4, 5], 2) [0, 1]","solution":"def find_target_indices(nums, target): Returns the first and last indices of the target in the sorted list of nums. If target is not found, return [-1, -1] if not nums: return [-1, -1] first_occurrence = -1 last_occurrence = -1 # Find first occurrence for i in range(len(nums)): if nums[i] == target: first_occurrence = i break # If target is not found, return [-1, -1] if first_occurrence == -1: return [-1, -1] # Find last occurrence for j in range(len(nums) - 1, -1, -1): if nums[j] == target: last_occurrence = j break return [first_occurrence, last_occurrence]"},{"question":"from typing import List def count_domino_pairs(arr: List[int]) -> int: Returns the number of unique domino pairs in the array such that both integers in the pair have the same digits in some order. :param arr: List of integers :return: Number of unique domino pairs >>> count_domino_pairs([123, 456, 789]) 0 >>> count_domino_pairs([123, 321]) 1 >>> count_domino_pairs([123, 321, 132, 213, 231]) 10 >>> count_domino_pairs([123, 456, 321, 654, 789]) 2 >>> count_domino_pairs([111, 111, 111]) 3 >>> count_domino_pairs([123456, 654321, 321456, 654123]) 6","solution":"from collections import defaultdict def count_domino_pairs(arr): Returns the number of unique domino pairs in the array such that both integers in the pair have the same digits in some order. :param arr: List of integers :return: Number of unique domino pairs def get_canonical_form(num): Return the canonical form of a number by sorting its digits. return ''.join(sorted(str(num))) # Dictionary to count occurrences of each canonical form canonical_count = defaultdict(int) # Count occurrences of each canonical form for num in arr: canonical_form = get_canonical_form(num) canonical_count[canonical_form] += 1 # Calculate the number of unique domino pairs pairs_count = 0 for count in canonical_count.values(): if count > 1: pairs_count += count * (count - 1) // 2 return pairs_count"},{"question":"def min_cost_path(cost): Returns the minimum cost required for the robot to reach the bottom-right corner from the top-left corner. The robot can only move either down or right at any point in time. Args: cost: List of List of ints, representing the cost grid. Returns: int, the minimum cost to reach the bottom-right corner. from solution import min_cost_path def test_min_cost_path_1(): cost = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_cost_path(cost) == 7 def test_min_cost_path_2(): cost = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert min_cost_path(cost) == 21 def test_min_cost_path_single_element(): cost = [ [5] ] assert min_cost_path(cost) == 5 def test_min_cost_path_single_row(): cost = [ [1, 2, 3, 4, 5] ] assert min_cost_path(cost) == 15 def test_min_cost_path_single_column(): cost = [ [1], [2], [3], [4], [5] ] assert min_cost_path(cost) == 15 def test_min_cost_path_empty_grid(): cost = [] assert min_cost_path(cost) == 0 def test_min_cost_path_empty_inner_lists(): cost = [[]] assert min_cost_path(cost) == 0","solution":"def min_cost_path(cost): Returns the minimum cost required for the robot to reach the bottom-right corner from the top-left corner. The robot can only move either down or right at any point in time. Args: cost: List of List of ints, representing the cost grid. Returns: int, the minimum cost to reach the bottom-right corner. if not cost or not cost[0]: return 0 m, n = len(cost), len(cost[0]) dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = cost[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + cost[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + cost[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost[i][j] return dp[m-1][n-1]"},{"question":"def daily_temperatures(temperatures: List[int]) -> List[int]: Returns an array where each element is the number of days one would have to wait until a warmer temperature. If there is no future day for which this is possible, the element is 0. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([30, 40, 50, 60]) [1, 1, 1, 0] >>> daily_temperatures([30, 30, 30, 30]) [0, 0, 0, 0] >>> daily_temperatures([30]) [0] >>> daily_temperatures([60, 50, 40, 30]) [0, 0, 0, 0] >>> daily_temperatures([30, 40, 50, 40, 30]) [1, 1, 0, 0, 0]","solution":"def daily_temperatures(temperatures): Returns an array where each element is the number of days one would have to wait until a warmer temperature. If there is no future day for which this is possible, the element is 0. n = len(temperatures) answer = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: previous_day = stack.pop() answer[previous_day] = i - previous_day stack.append(i) return answer"},{"question":"def min_pairs(s: str) -> int: Returns the minimum number of 'xy' or 'yx' pairs that can be formed by swapping any two characters in the string at most once. >>> min_pairs('') == 0 >>> min_pairs('xxxx') == 0 >>> min_pairs('yyyy') == 0 >>> min_pairs('xy') == 1 >>> min_pairs('yx') == 1 >>> min_pairs('xxyy') == 2 >>> min_pairs('yxxy') == 2 >>> min_pairs('xyxy') == 2 >>> min_pairs('xxyyxxy') == 3 >>> min_pairs('x') == 0 >>> min_pairs('y') == 0","solution":"def min_pairs(s): Returns the minimum number of 'xy' or 'yx' pairs that can be formed by swapping any two characters in the string at most once. x_count = s.count('x') y_count = s.count('y') # In case both counts are zero, no pairs can be formed if x_count == 0 or y_count == 0: return 0 # The minimum number of pairs is the smaller count of 'x' or 'y' pairs = min(x_count, y_count) return pairs"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def countGoodSubtrees(root, val): Returns the number of good subtrees in the binary tree. A good subtree is defined as one in which all the nodes have the same value. :param root: The root of the binary tree. :param val: List of node values indexed by node labels. :return: Number of good subtrees. >>> val = [0, 1] >>> root = TreeNode(1) >>> countGoodSubtrees(root, val) 1 >>> val = [0, 1, 1] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> countGoodSubtrees(root, val) 2 >>> val = [0, 1, 2] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> countGoodSubtrees(root, val) 1 >>> val = [0, 1, 1, 1, 1, 1, 1, 1] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> countGoodSubtrees(root, val) 7 >>> val = [0, 1, 1, 2, 2, 3, 3, 3] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> countGoodSubtrees(root, val) 4","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def countGoodSubtrees(root, val): Returns the number of good subtrees in the binary tree. A good subtree is defined as one in which all the nodes have the same value. :param root: The root of the binary tree. :param val: List of node values indexed by node labels. :return: Number of good subtrees. def dfs(node): if not node: return 0, True left_count, is_left_good = dfs(node.left) right_count, is_right_good = dfs(node.right) is_good = is_left_good and is_right_good if node.left and val[node.left.val] != val[node.val]: is_good = False if node.right and val[node.right.val] != val[node.val]: is_good = False total_count = left_count + right_count if is_good: total_count += 1 return total_count, is_good total_good_subtrees, _ = dfs(root) return total_good_subtrees"},{"question":"from typing import List def game_of_life(mat: List[List[int]]) -> List[List[int]]: Returns the resulting matrix after one generation. The function takes a matrix mat of size m x n where mat[i][j] is 0 (dead) or 1 (alive). Based on the game's rules, returns the matrix after one generation. The rules for the next generation are: - Any live cell with fewer than two live neighbors dies, as if caused by under-population. - Any live cell with two or three live neighbors lives on to the next generation. - Any live cell with more than three live neighbors dies, as if by over-population. - Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. >>> game_of_life([ ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0] ... ]) [[0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]] >>> game_of_life([ ... [0, 0, 0, 0, 0], ... [0, 0, 1, 0, 0], ... [0, 0, 1, 0, 0], ... [0, 0, 1, 0, 0], ... [0, 0, 0, 0, 0] ... ]) [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]","solution":"def game_of_life(mat): Returns the resulting matrix after one generation. def count_live_neighbors(mat, x, y, m, n): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] count = 0 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: count += mat[nx][ny] return count m, n = len(mat), len(mat[0]) new_mat = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): live_neighbors = count_live_neighbors(mat, i, j, m, n) if mat[i][j] == 1 and (live_neighbors < 2 or live_neighbors > 3): new_mat[i][j] = 0 elif mat[i][j] == 1 and (live_neighbors == 2 or live_neighbors == 3): new_mat[i][j] = 1 elif mat[i][j] == 0 and live_neighbors == 3: new_mat[i][j] = 1 return new_mat"},{"question":"def min_diff_chocolates(chocolates: List[int], k: int) -> int: Given a list of chocolates and an integer k, returns the minimum possible difference between the group with the highest number of chocolates and the group with the lowest number of chocolates after dividing the chocolates into k groups. Parameters: chocolates (List[int]): A list of integers representing the number of chocolates in each box. k (int): The number of groups to divide the chocolates into. Returns: int: The minimum possible difference between the largest and the smallest group. >>> min_diff_chocolates([12, 34, 7, 8, 9, 13, 24], 3) 2 >>> min_diff_chocolates([1, 2, 3, 4, 5], 1) 0 >>> min_diff_chocolates([5, 5, 5, 5, 5], 3) 0 >>> min_diff_chocolates([1, 3, 6, 7, 8, 10], 5) 7 >>> min_diff_chocolates([10, 20, 30, 12, 15], 2) 2","solution":"def min_diff_chocolates(chocolates, k): Given a list of chocolates and an integer k, returns the minimum possible difference between the group with the highest number of chocolates and the group with the lowest number of chocolates after dividing the chocolates into k groups. # Sort the list first chocolates.sort() # The initial solution can be the difference between the highest and the lowest in the subarray min_diff = float('inf') # We iterate through the sorted list to check for possible groupings of size k for i in range(len(chocolates) - k + 1): current_diff = chocolates[i + k - 1] - chocolates[i] if current_diff < min_diff: min_diff = current_diff return min_diff"},{"question":"def find_similar_word_sets(words: List[str]) -> int: Determine the number of distinct sets of similar words in the given list. A set of \\"similar\\" words is defined as a group of words where each word is similar to at least one other word in the group. Two words are considered to be \\"similar\\" if they can be made identical by swapping at most two characters within one word. >>> find_similar_word_sets([\\"abc\\", \\"acb\\", \\"bac\\", \\"xyz\\", \\"xzy\\"]) 2 >>> find_similar_word_sets([\\"abc\\", \\"def\\", \\"ghi\\"]) 3 >>> find_similar_word_sets([\\"abc\\", \\"abc\\", \\"abc\\"]) 1 >>> find_similar_word_sets([\\"abcd\\", \\"acbd\\", \\"abdc\\", \\"xyz\\", \\"xzy\\", \\"yxz\\"]) 2 >>> find_similar_word_sets([\\"abc\\", \\"cba\\", \\"bca\\", \\"cab\\", \\"bac\\", \\"acb\\"]) 1 >>> find_similar_word_sets([]) 0 >>> find_similar_word_sets([\\"word\\"]) 1","solution":"def are_similar(word1, word2): Check if two words are similar by swapping at most two characters. if word1 == word2: return True if len(word1) != len(word2): return False # Finding the positions where the characters differ different_chars = [(w1, w2) for w1, w2 in zip(word1, word2) if w1 != w2] # If there are exactly 2 positions where the characters differ, # check if they can be swapped to make the words identical. if len(different_chars) == 2 and different_chars[0] == different_chars[1][::-1]: return True return False def find_similar_word_sets(words): Determine the number of distinct sets of similar words in the given list. from collections import defaultdict similar_sets = [] for word in words: added = False # Compare the current word with all sets for s in similar_sets: if any(are_similar(word, w) for w in s): s.add(word) added = True break if not added: similar_sets.append({word}) return len(similar_sets)"},{"question":"def longest_subsequence(words: List[str], m: int) -> int: Determines the length of the longest subsequence where the length of each word is less than or equal to m. Args: words (list): List of strings. m (int): The maximum allowed length of the words in the subsequence. Returns: int: The length of the longest subsequence. >>> longest_subsequence([\\"apple\\", \\"dog\\", \\"cat\\", \\"fish\\"], 5) 4 >>> longest_subsequence([\\"apple\\", \\"dog\\", \\"elephant\\", \\"cat\\", \\"fish\\"], 5) 4 >>> longest_subsequence([\\"pineapple\\", \\"elephant\\", \\"giraffe\\"], 5) 0 >>> longest_subsequence([], 5) 0 >>> longest_subsequence([\\"pineapple\\", \\"dog\\"], 3) 1","solution":"def longest_subsequence(words, m): Determines the length of the longest subsequence where the length of each word is less than or equal to m. Args: words (list): List of strings. m (int): The maximum allowed length of the words in the subsequence. Returns: int: The length of the longest subsequence. # Initialize the subsequence length counter length = 0 for word in words: if len(word) <= m: length += 1 return length"},{"question":"from typing import List def shortest_subarray_with_all_distinct_elements(arr: List[int]) -> int: Given a 0-indexed integer array \`arr\` of size \`n\`, return the length of the shortest subarray containing at least one instance of each distinct element in \`arr\`. >>> shortest_subarray_with_all_distinct_elements([1]) == 1 >>> shortest_subarray_with_all_distinct_elements([1, 2]) == 2 >>> shortest_subarray_with_all_distinct_elements([1, 1, 1, 1]) == 1 >>> shortest_subarray_with_all_distinct_elements([2, 1, 2, 2, 3, 1]) == 3 >>> shortest_subarray_with_all_distinct_elements([1, 2, 3, 1, 2, 3, 4, 5]) == 5 >>> shortest_subarray_with_all_distinct_elements([1, 2, 3, 4, 5, 6]) == 6 >>> shortest_subarray_with_all_distinct_elements([5, 1, 5]) == 2 # Implement the function to return the length of the shortest subarray containing all distinct elements","solution":"def shortest_subarray_with_all_distinct_elements(arr): Returns the length of the shortest subarray containing at least one instance of each distinct element in the array. from collections import defaultdict # Get the set of all distinct elements distinct_elements = set(arr) num_distinct = len(distinct_elements) n = len(arr) # Dictionary to store the count of each element in the current window current_counts = defaultdict(int) left = 0 shortest_length = n # Number of distinct elements in the current window distinct_in_window = 0 # Expand the window with right pointer for right in range(n): current_counts[arr[right]] += 1 if current_counts[arr[right]] == 1: distinct_in_window += 1 # If the current window contains all distinct elements, contract the window from the left while distinct_in_window == num_distinct: shortest_length = min(shortest_length, right - left + 1) current_counts[arr[left]] -= 1 if current_counts[arr[left]] == 0: distinct_in_window -= 1 left += 1 return shortest_length"},{"question":"def largest_palindrome_less_than(num): Returns the largest palindrome less than the given num. If no such palindrome exists, it returns -1. >>> largest_palindrome_less_than(100) 99 >>> largest_palindrome_less_than(50) 44 >>> largest_palindrome_less_than(24) 22 >>> largest_palindrome_less_than(11) -1 >>> largest_palindrome_less_than(9) -1 >>> largest_palindrome_less_than(121) 111","solution":"def largest_palindrome_less_than(num): Returns the largest palindrome less than the given num. If no such palindrome exists, it returns -1. if num <= 10: # The smallest 2-digit palindrome is 11, hence num should be > 10 return -1 def is_palindrome(x): s = str(x) return s == s[::-1] for candidate in range(num - 1, 9, -1): if is_palindrome(candidate): return candidate return -1"},{"question":"def determine_winner(points): You are given an array \`points\` where \`points[i]\` represents the number of points scored by player \`i\` in a series of games. Alice always scores in even-indexed games (0, 2, 4, ...) and Bob always scores in odd-indexed games (1, 3, 5, ...). Determine the winner by returning the name of the player with the higher total score. If both players have the same score, return \\"Tie\\". >>> determine_winner([10, 5, 20, 5, 30]) \\"Alice\\" >>> determine_winner([5, 15, 10, 25]) \\"Bob\\" >>> determine_winner([10, 10, 20, 20, 30, 30]) \\"Tie\\" >>> determine_winner([10]) \\"Alice\\" >>> determine_winner([0, 10]) \\"Bob\\" >>> determine_winner([]) \\"Tie\\" >>> determine_winner([0, 0, 0, 0]) \\"Tie\\"","solution":"def determine_winner(points): alice_score = sum(points[i] for i in range(0, len(points), 2)) bob_score = sum(points[i] for i in range(1, len(points), 2)) if alice_score > bob_score: return \\"Alice\\" elif bob_score > alice_score: return \\"Bob\\" else: return \\"Tie\\""},{"question":"def min_time(jobs: List[int], k: int) -> int: Return the minimum possible time needed for the last worker to complete their assigned jobs. >>> min_time([10, 20, 30, 40], 1) 100 >>> min_time([10, 10, 10, 10], 2) 20 >>> min_time([7, 2, 5, 10, 8], 2) 18 >>> min_time([6, 4, 15, 10], 3) 15 >>> min_time([1, 2, 3], 5) 3 >>> min_time([50], 3) 50","solution":"def min_time(jobs, k): def is_feasible(time_limit): worker_count = 1 current_time = 0 for job in jobs: if current_time + job <= time_limit: current_time += job else: worker_count += 1 current_time = job if worker_count > k: return False return True left, right = max(jobs), sum(jobs) while left < right: mid = (left + right) // 2 if is_feasible(mid): right = mid else: left = mid + 1 return left"},{"question":"def longest_mountain(arr: List[int]) -> int: Return the length of the longest mountain subarray. A mountain subarray is a subarray that includes at least three elements and satisfies the following conditions: - There exists some index \`k\` with \`0 < k < length of subarray - 1\` such that: * arr[k] > arr[k-1] * arr[k] > arr[k+1] * arr[i] < arr[i+1] for all \`0 <= i < k\` * arr[j] > arr[j+1] for all \`k <= j < length of subarray - 1\` Args: arr (List[int]): A list of integers. Returns: int: The length of the longest mountain subarray, or 0 if there is no mountain subarray. >>> longest_mountain([2, 1, 4, 7, 3, 2, 5]) == 5 >>> longest_mountain([2, 2, 2]) == 0 >>> longest_mountain([2, 3, 3, 3, 2]) == 0 >>> longest_mountain([1, 2, 3, 4, 5, 4, 3, 2, 1]) == 9","solution":"def longest_mountain(arr): if len(arr) < 3: return 0 longest = 0 n = len(arr) for i in range(1, n - 1): if arr[i-1] < arr[i] > arr[i+1]: left = i - 1 right = i + 1 while left > 0 and arr[left-1] < arr[left]: left -= 1 while right < n - 1 and arr[right+1] < arr[right]: right += 1 longest = max(longest, right - left + 1) return longest"},{"question":"def common_free_time(schedules): Find the common free time slots across all candidates for scheduling a meeting. A free time slot is defined as a time period that is common to all candidates and during which at least one hour is available. Return a list of all common free time slots sorted by the start time. Args: schedules (List[List[List[int]]]): A 2D array where schedules[i] is the list of availability pairs for candidate i. Returns: List[List[int]]: A list of common free time slots represented as a list of integer pairs [startTime, endTime]. Examples: >>> common_free_time([[[1, 3], [6, 7]], [[2, 4]], [[2, 3], [9, 12]]]) [[4, 6], [7, 9]] >>> common_free_time([[[1, 2], [5, 6]], [[1, 3]], [[4, 10]]]) [[3, 4]] >>> common_free_time([[[1, 5], [6, 10]], [[2, 6], [8, 8]]]) [] >>> common_free_time([[[1, 3], [4, 5]], [[2, 3], [6, 8]], [[1, 3], [4, 6]]]) [[3, 4]]","solution":"def common_free_time(schedules): from heapq import merge # Merge all availability slots across all candidates into one list merged_schedules = list(merge(*schedules, key=lambda x: x[0])) # Consolidate overlapping intervals from the merged list consolidated_intervals = [] for interval in merged_schedules: if not consolidated_intervals or consolidated_intervals[-1][1] < interval[0]: consolidated_intervals.append(interval) else: consolidated_intervals[-1][1] = max(consolidated_intervals[-1][1], interval[1]) # Find common free time slots from the consolidated intervals common_free_intervals = [] for i in range(1, len(consolidated_intervals)): if consolidated_intervals[i][0] - consolidated_intervals[i-1][1] >= 1: common_free_intervals.append([consolidated_intervals[i-1][1], consolidated_intervals[i][0]]) return common_free_intervals"},{"question":"def minimumCardPickup(cards): Returns the minimum distance between pairs of indices (i, j) such that cards[i] == cards[j]. If no such pairs exist, returns -1. from solution import minimumCardPickup def test_minimumCardPickup_example_cases(): assert minimumCardPickup([3, 4, 2, 3, 4, 7]) == 3 assert minimumCardPickup([1, 0, 5, 3]) == -1 def test_minimumCardPickup_no_pairs(): assert minimumCardPickup([1, 2, 3, 4, 5]) == -1 def test_minimumCardPickup_immediate_pairs(): assert minimumCardPickup([1, 1, 2, 3]) == 1 assert minimumCardPickup([5, 6, 6, 7, 5]) == 1 def test_minimumCardPickup_multiple_pairs(): assert minimumCardPickup([1, 2, 1, 2, 1]) == 2 assert minimumCardPickup([4, 4, 4, 4]) == 1 def test_minimumCardPickup_large_input(): assert minimumCardPickup([6] * 10**5) == 1 def test_minimumCardPickup_edge_cases(): assert minimumCardPickup([]) == -1 assert minimumCardPickup([2]) == -1 assert minimumCardPickup([3, 3]) == 1","solution":"def minimumCardPickup(cards): Returns the minimum distance between pairs of indices (i, j) such that cards[i] == cards[j]. If no such pairs exist, returns -1. last_seen = {} min_distance = float('inf') for i, card in enumerate(cards): if card in last_seen: min_distance = min(min_distance, i - last_seen[card]) last_seen[card] = i return min_distance if min_distance != float('inf') else -1"},{"question":"def longest_even_frequency_substring(s: str) -> int: Finds the length of the longest substring where the frequency of each character is even. Args: s (str): The input string consisting of lowercase alphabets. Returns: int: The length of the longest substring with each character's frequency even. >>> longest_even_frequency_substring(\\"aabb\\") 4 >>> longest_even_frequency_substring(\\"abbacc\\") 6 >>> longest_even_frequency_substring(\\"xyz\\") 0 >>> longest_even_frequency_substring(\\"\\") 0 >>> longest_even_frequency_substring(\\"a\\") 0 >>> longest_even_frequency_substring(\\"aa\\") 2 >>> longest_even_frequency_substring(\\"ab\\") 0 >>> longest_even_frequency_substring(\\"aabbccddeeff\\") 12 >>> longest_even_frequency_substring(\\"aabbcc\\") 6 >>> longest_even_frequency_substring(\\"aaaabbbbcccc\\") 12","solution":"def longest_even_frequency_substring(s): Finds the length of the longest substring where the frequency of each character is even. Args: s (str): The input string consisting of lowercase alphabets. Returns: int: The length of the longest substring with each character's frequency even. def is_even_frequency(substring): Checks if all characters in the substring have even frequencies. Args: substring (str): The input substring. Returns: bool: True if all characters have even frequencies, False otherwise. from collections import Counter counter = Counter(substring) for count in counter.values(): if count % 2 != 0: return False return True n = len(s) max_length = 0 for i in range(n): for j in range(i + 1, n + 1): if is_even_frequency(s[i:j]): max_length = max(max_length, j - i) return max_length"},{"question":"class Intervals: This class represents a collection of intervals and provides a method to check if a point is within any of these intervals. Methods: - __init__(self, intervals: List[List[int]]): Initializes the object with the given 2D integer array intervals. - query(self, point: int) -> bool: Returns true if the given point is within any of the intervals in intervals (inclusive), otherwise returns false. def __init__(self, intervals: List[List[int]]): Initializes the object with the given 2D integer array intervals. pass def query(self, point: int) -> bool: Returns true if the given point is within any of the intervals (inclusive), otherwise returns false. >>> intervals = Intervals([[1, 3], [5, 8]]) >>> intervals.query(2) True >>> intervals.query(4) False >>> intervals.query(5) True >>> intervals.query(8) True pass def test_query_point_in_interval(): intervals = Intervals([[1, 3], [5, 8]]) assert intervals.query(2) == True def test_query_point_on_start_boundary(): intervals = Intervals([[1, 3], [5, 8]]) assert intervals.query(1) == True def test_query_point_on_end_boundary(): intervals = Intervals([[1, 3], [5, 8]]) assert intervals.query(3) == True def test_query_point_not_in_intervals(): intervals = Intervals([[1, 3], [5, 8]]) assert intervals.query(4) == False def test_query_point_in_gap_between_intervals(): intervals = Intervals([[1, 3], [5, 8]]) assert intervals.query(4) == False def test_query_point_in_second_interval(): intervals = Intervals([[1, 3], [5, 8]]) assert intervals.query(6) == True def test_query_point_only_interval(): intervals = Intervals([[1, 3]]) assert intervals.query(1) == True assert intervals.query(2) == True assert intervals.query(3) == True assert intervals.query(4) == False def test_query_empty_intervals(): intervals = Intervals([]) assert intervals.query(1) == False","solution":"class Intervals: def __init__(self, intervals): Initializes the object with the given 2D integer array intervals. self.intervals = intervals def query(self, point): Returns true if the given point is within any of the intervals in intervals (inclusive), otherwise returns false. for start, end in self.intervals: if start <= point <= end: return True return False"},{"question":"def is_valid(s: str) -> bool: Determine if the input string s consisting of brackets is valid. :param s: A string consisting of characters '(', ')', '{', '}', '[' and ']' :return: True if the string is valid, False otherwise >>> is_valid(\\"()\\") True >>> is_valid(\\"()[]{}\\") True >>> is_valid(\\"(]\\") False >>> is_valid(\\"([)]\\") False >>> is_valid(\\"{[]}\\") True >>> is_valid(\\"\\") True >>> is_valid(\\"(\\") False >>> is_valid(\\")\\") False >>> is_valid(\\"(((\\") False >>> is_valid(\\")))\\") False","solution":"def is_valid(s): Determine if the input string s consisting of brackets is valid. :param s: A string consisting of characters '(', ')', '{', '}', '[' and ']' :return: True if the string is valid, False otherwise stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def find_pairs(numbers: List[int], target: int) -> List[Tuple[int, int]]: Find all unique pairs of integers in the list \`numbers\` that sum up to the \`target\`. Each pair should be ordered such that the smaller number appears first, and the list of tuples itself should be sorted in lexicographical order. >>> find_pairs([2, 4, 3, 5, 7, 1, -1, 0], 6) [(-1, 7), (1, 5), (2, 4)] >>> find_pairs([1, 2, 3], 7) [] >>> find_pairs([-2, -1, 0, 1, 2, 3], 1) [(-2, 3), (-1, 2), (0, 1)]","solution":"def find_pairs(numbers, target): Returns a list of tuples where each tuple contains pairs of numbers that add up to the target. Each pair is sorted in ascending order and the list of pairs is sorted lexicographically. found_pairs = set() numbers_set = set(numbers) for num in numbers: complement = target - num if complement in numbers_set: pair = tuple(sorted((num, complement))) if pair[0] != pair[1]: found_pairs.add(pair) return sorted(found_pairs)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head): Removes duplicates from the linked list, keeping only the last occurrence of each number. Returns the new head of the modified linked list. def linked_list_to_list(head): result = [] current = head while current: result.append(current.val) current = current.next return result def test_remove_duplicates_no_duplicates(): head = ListNode(1, ListNode(2, ListNode(3))) new_head = remove_duplicates(head) assert linked_list_to_list(new_head) == [1, 2, 3] def test_remove_duplicates_all_duplicates(): head = ListNode(1, ListNode(1, ListNode(1))) new_head = remove_duplicates(head) assert linked_list_to_list(new_head) == [1] def test_remove_duplicates_mixed(): head = ListNode(1, ListNode(2, ListNode(1, ListNode(3, ListNode(2, ListNode(4)))))) new_head = remove_duplicates(head) assert linked_list_to_list(new_head) == [1, 3, 2, 4] def test_remove_duplicates_empty_list(): head = None new_head = remove_duplicates(head) assert new_head == None def test_remove_duplicates_single_element(): head = ListNode(1) new_head = remove_duplicates(head) assert linked_list_to_list(new_head) == [1] def test_remove_duplicates_complex(): head = ListNode(1, ListNode(2, ListNode(1, ListNode(3, ListNode(2, ListNode(4, ListNode(4, ListNode(5)))))))) new_head = remove_duplicates(head) assert linked_list_to_list(new_head) == [1, 3, 2, 4, 5]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head): Removes duplicates from the linked list, keeping only the last occurrence of each number. Returns the new head of the modified linked list. if not head: return None # Use a dictionary to remember the last occurrence of each value last_occurrence = {} current = head while current: last_occurrence[current.val] = current current = current.next # Create a dummy node to handle the edge case of head removal dummy = ListNode(0) dummy.next = head prev = dummy current = head while current: if current == last_occurrence[current.val]: prev = current else: prev.next = current.next current = current.next return dummy.next"},{"question":"def can_frog_reach_destination(k: int, d: int) -> bool: Determines if the frog can reach the destination \`d\` with jumps of \`k\` units. Parameters: k (int): The unit length of each jump d (int): The destination point on the number line Returns: bool: True if the frog can reach the destination, False otherwise. >>> can_frog_reach_destination(3, 9) == True >>> can_frog_reach_destination(5, 7) == False >>> can_frog_reach_destination(3, 0) == True >>> can_frog_reach_destination(5, 0) == True >>> can_frog_reach_destination(1, 10) == True >>> can_frog_reach_destination(1, -7) == True >>> can_frog_reach_destination(2, 8) == True >>> can_frog_reach_destination(2, -8) == True >>> can_frog_reach_destination(4, 9) == False >>> can_frog_reach_destination(4, 12) == True >>> can_frog_reach_destination(3, 10) == False >>> can_frog_reach_destination(6, 18) == True pass","solution":"def can_frog_reach_destination(k, d): Determines if the frog can reach the destination \`d\` with jumps of \`k\` units. Parameters: k (int): The unit length of each jump d (int): The destination point on the number line Returns: bool: True if the frog can reach the destination, False otherwise # If the distance to the destination is a multiple of k, the frog can reach it return d % k == 0"},{"question":"def maximize_min_sum(nums: List[int], k: int) -> int: Given a list of \`n\` integers, divide the list into exactly \`k\` contiguous subarrays so as to maximize the minimum sum among these subarrays. >>> maximize_min_sum([7, 2, 5, 10, 8], 2) 18 >>> maximize_min_sum([1, 2, 3, 4, 5], 2) 9 >>> maximize_min_sum([1, 4, 4], 3) 4 >>> maximize_min_sum([5,1,3,2,2], 3) 5 >>> maximize_min_sum([1,1,1,1,1], 2) 3","solution":"def maximize_min_sum(nums, k): def is_possible(mid): current_sum, cnt = 0, 1 for num in nums: if current_sum + num > mid: cnt += 1 current_sum = 0 if cnt > k: return False current_sum += num return True low, high = max(nums), sum(nums) while low < high: mid = (low + high) // 2 if is_possible(mid): high = mid else: low = mid + 1 return low"},{"question":"from typing import List def max_sum_rectangle(grid: List[List[int]]) -> int: Given a 2D integer matrix 'grid', find the maximum sum of a rectangle in the matrix. A rectangle is defined as any group of contiguous cells in the grid that forms a rectangle. The selection of cells must form a proper rectangular shape with sides parallel to the grid. Args: grid (List[List[int]]): 2D list representing the input grid. Returns: int: The maximum sum of any rectangle in the grid. >>> max_sum_rectangle([]) 0 >>> max_sum_rectangle([[5]]) 5 >>> max_sum_rectangle([[1, 2, -1, 3, -2]]) 5 >>> max_sum_rectangle([[1], [-2], [3], [4], [-1]]) 7 >>> max_sum_rectangle([[1, 2], [3, 4]]) 10 >>> grid = [[1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6]] >>> max_sum_rectangle(grid) 29 pass","solution":"def max_sum_rectangle(grid): Returns the maximum sum of any rectangular subarray within a 2D integer matrix \`grid\`. if not grid: return 0 rows, cols = len(grid), len(grid[0]) max_sum = float('-inf') # Iterate over all pairs of rows for top in range(rows): row_sum = [0] * cols for bottom in range(top, rows): for col in range(cols): row_sum[col] += grid[bottom][col] # Apply Kadane's algorithm on the row_sum array to find the # maximum sum subarray which will represent the maximum # sum rectangle for the current pair of rows current_sum = 0 max_current_sum = float('-inf') for value in row_sum: current_sum = max(value, current_sum + value) max_current_sum = max(max_current_sum, current_sum) max_sum = max(max_sum, max_current_sum) return max_sum"},{"question":"def min_distance(s1: str, s2: str) -> int: Returns the minimum number of operations required to transform s1 into s2. The operations are insert, remove, or replace a character. >>> min_distance(\\"kitten\\", \\"kitten\\") == 0 >>> min_distance(\\"kitten\\", \\"kittens\\") == 1 >>> min_distance(\\"kitten\\", \\"kittn\\") == 1 >>> min_distance(\\"kitten\\", \\"sitten\\") == 1 >>> min_distance(\\"kitten\\", \\"sitting\\") == 3 >>> min_distance(\\"\\", \\"abc\\") == 3 >>> min_distance(\\"abc\\", \\"\\") == 3 >>> min_distance(\\"\\", \\"\\") == 0 >>> min_distance(\\"intention\\", \\"execution\\") == 5","solution":"def min_distance(s1, s2): Returns the minimum number of operations required to transform s1 into s2. The operations are insert, remove, or replace a character. m = len(s1) n = len(s2) # Create a DP table to memoize the results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table with base cases for i in range(m + 1): for j in range(n + 1): if i == 0: # Transform empty string to s2[:j] requires j insertions dp[i][j] = j elif j == 0: # Transform s1[:i] to empty string requires i deletions dp[i][j] = i elif s1[i - 1] == s2[j - 1]: # No operation needed if characters match dp[i][j] = dp[i - 1][j - 1] else: # Calculate minimum edit distance if characters don't match insert_op = dp[i][j - 1] remove_op = dp[i - 1][j] replace_op = dp[i - 1][j - 1] dp[i][j] = 1 + min(insert_op, remove_op, replace_op) return dp[m][n]"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Counts the number of unique paths from the top-left corner to the bottom-right corner of a 2D grid consisting of 0s (empty space) and 1s (obstacles). You can only move either down or right at any point in time and cannot move through obstacles. If there is no valid path, returns 0. >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 6 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[0, 1], [1, 0]]) 0 >>> unique_paths_with_obstacles([[0]]) 1 >>> unique_paths_with_obstacles([[1]]) 0 >>> unique_paths_with_obstacles([]) 0","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from top-left to bottom-right of the grid. You can only move either down or right at any point in time and cannot move through obstacles. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] return dp[-1][-1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: Implement a BSTIterator class that iterates through the elements of a BST in ascending order. Methods: - BSTIterator(TreeNode root): Initializes an object of the BSTIterator class with the root node of the binary search tree. - next() -> int: Returns the next smallest number in the BST. - hasNext() -> bool: Returns true if there exists a next number in the BST, otherwise returns false. >>> # Create BST >>> root = TreeNode(7) >>> root.left = TreeNode(3) >>> root.right = TreeNode(15) >>> root.right.left = TreeNode(9) >>> root.right.right = TreeNode(20) >>> >>> # Initialize BSTIterator >>> iterator = BSTIterator(root) >>> >>> # Test hasNext and next >>> iterator.hasNext() True >>> iterator.next() 3 >>> iterator.hasNext() True >>> iterator.next() 7 >>> iterator.hasNext() True >>> iterator.next() 9 >>> iterator.hasNext() True >>> iterator.next() 15 >>> iterator.hasNext() True >>> iterator.next() 20 >>> iterator.hasNext() False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def next(self) -> int: topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val def hasNext(self) -> bool: return len(self.stack) > 0"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Reverses the linked list and returns the new head of the reversed list. >>> head = create_linked_list([1, 2, 3, 4, 5]) >>> new_head = reverse_linked_list(head) >>> linked_list_to_list(new_head) [5, 4, 3, 2, 1] >>> head = create_linked_list([1]) >>> new_head = reverse_linked_list(head) >>> linked_list_to_list(new_head) [1] >>> head = create_linked_list([1, 2]) >>> new_head = reverse_linked_list(head) >>> linked_list_to_list(new_head) [2, 1] >>> head = create_linked_list([]) >>> new_head = reverse_linked_list(head) >>> linked_list_to_list(new_head) [] >>> head = create_linked_list([1, 2, 2, 3, 3]) >>> new_head = reverse_linked_list(head) >>> linked_list_to_list(new_head) [3, 3, 2, 2, 1]","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_linked_list(head): Reverses the linked list and returns the new head of the reversed list. previous = None current = head while current: next_node = current.next current.next = previous previous = current current = next_node return previous"},{"question":"def longest_consecutive_sequence(arr: List[int]) -> int: Returns the length of the longest consecutive elements sequence. Example: >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([10, 40, 30, 20, 1, 2, 3]) 3 >>> longest_consecutive_sequence([1, 2, 3, 4, 5, 6, 7, 8, 9]) 9 from solution import longest_consecutive_sequence def test_longest_consecutive_sequence(): assert longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) == 4 def test_only_one_element(): assert longest_consecutive_sequence([1]) == 1 def test_no_elements(): assert longest_consecutive_sequence([]) == 0 def test_disjoint_sequences(): assert longest_consecutive_sequence([10, 40, 30, 20, 1, 2, 3]) == 3 def test_all_consecutive(): assert longest_consecutive_sequence([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 9 def test_single_sequence_and_disjoint_elements(): assert longest_consecutive_sequence([1, 9, 3, 10, 4, 20, 2, 11]) == 4 def test_with_negative_numbers(): assert longest_consecutive_sequence([-1, 0, 1, 2, -2, -3]) == 6","solution":"def longest_consecutive_sequence(arr): Returns the length of the longest consecutive elements sequence. if not arr: return 0 num_set = set(arr) max_length = 0 for num in arr: if num - 1 not in num_set: current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"def can_return_to_origin(commands: str, k: int) -> bool: Determines if the robot can return to the origin considering possible misinterpretations of up to k moves. Params: commands: str : a string representing sequence of directions ('U', 'D', 'L', 'R') k: int : maximum number of moves that can be misinterpreted Returns: bool : True if the robot can return to the origin, False otherwise >>> can_return_to_origin(\\"UD\\", 0) True >>> can_return_to_origin(\\"LL\\", 0) False >>> can_return_to_origin(\\"UUDDLLRR\\", 0) True","solution":"def can_return_to_origin(commands, k): Determines if the robot can return to the origin considering possible misinterpretations of up to k moves. Params: commands: str : a string representing sequence of directions ('U', 'D', 'L', 'R') k: int : maximum number of moves that can be misinterpreted Returns: bool : True if the robot can return to the origin, False otherwise x, y = 0, 0 # Process the commands to calculate the final position for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 # Calculate the distance from the origin distance = abs(x) + abs(y) # Check if the distance can be adjusted to zero with k misinterpretations if distance <= k: return True return False"},{"question":"def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given m x n matrix by 90 degrees clockwise in-place. :param matrix: List[List[int]], a 2D list representing the matrix to be rotated :return: List[List[int]], the rotated matrix >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ] >>> rotate_matrix([ ... [ 5, 1, 9, 11], ... [ 2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ]) == [ ... [15, 13, 2, 5], ... [14, 3, 4, 1], ... [12, 6, 8, 9], ... [16, 7, 10, 11] ... ] >>> rotate_matrix([ ... [1] ... ]) == [ ... [1] ... ] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) == [ ... [3, 1], ... [4, 2] ... ]","solution":"def rotate_matrix(matrix): Rotates the given m x n matrix by 90 degrees clockwise in-place. :param matrix: List[List[int]], a 2D list representing the matrix to be rotated :return: List[List[int]], the rotated matrix n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"def nextPermutation(arr): Modifies the input array to its next lexicographical permutation or sorts it if no such permutation exists. >>> nextPermutation([1, 2, 3]) [1, 3, 2] >>> nextPermutation([3, 2, 1]) [1, 2, 3] >>> nextPermutation([1, 1, 5]) [1, 5, 1] >>> nextPermutation([1]) [1] >>> nextPermutation([1, 3, 2, 4, 5]) [1, 3, 2, 5, 4] >>> nextPermutation([1, 5, 3, 2, 1, 0]) [2, 0, 1, 1, 3, 5]","solution":"def nextPermutation(arr): Modifies the input array to its next lexicographical permutation or sorts it if no such permutation exists. n = len(arr) if n <= 1: return arr # Step 1: Find the largest index k such that arr[k] < arr[k + 1] k = n - 2 while k >= 0 and arr[k] >= arr[k + 1]: k -= 1 if k == -1: # Step 4: If no such k exists, reverse the array to get the smallest permutation arr[:] = arr[::-1] return arr # Step 2: Find the largest index l greater than k such that arr[k] < arr[l] l = n - 1 while arr[k] >= arr[l]: l -= 1 # Step 3: Swap the value of arr[k] with that of arr[l] arr[k], arr[l] = arr[l], arr[k] # Step 4: Reverse the sequence from arr[k + 1] to the end arr[k + 1:] = reversed(arr[k + 1:]) return arr"},{"question":"def max_distance_reachable(stations: List[int], k: int) -> int: Returns the maximum distance that can be reached given the stations and maximum distance k. Parameters: - stations: List[int] : a list of non-negative integers representing the power of each station. - k: int : the maximum distance that can be traveled between stops to recharge. Returns: - int : the farthest position that can be reached. >>> max_distance_reachable([1, 2, 3, 4], 2) == 3 >>> max_distance_reachable([1, 0, 0, 4], 3) == 3 >>> max_distance_reachable([1, 0, 0, 0, 4], 3) == 4 >>> max_distance_reachable([0, 0, 0, 0], 2) == 0 >>> max_distance_reachable([3], 1) == 0 >>> max_distance_reachable([1, 1, 1, 1, 1], 5) == 4","solution":"def max_distance_reachable(stations, k): Returns the maximum distance that can be reached given the stations and maximum distance k. Parameters: - stations: List[int] : a list of non-negative integers representing the power of each station. - k: int : the maximum distance that can be traveled between stops to recharge. Returns: - int : the farthest position that can be reached. max_distance = 0 for i in range(len(stations)): if stations[i] > 0: max_distance = max(max_distance, i + k) return min(max_distance, len(stations) - 1)"},{"question":"def search_matrix(matrix, target): Determine if the target is present in the matrix. Each row and column is sorted in ascending order. Args: matrix: List[List[int]], the 2D matrix. target: int, the target number to search for. Returns: bool: True if target is found, otherwise False. >>> search_matrix([ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ], 5) True >>> search_matrix([ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ], 20) False","solution":"def search_matrix(matrix, target): if not matrix: return False num_rows = len(matrix) num_cols = len(matrix[0]) row = 0 col = num_cols - 1 while row < num_rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"from typing import List def maxActiveJobs(logs: List[List[int]]) -> int: Determine the maximum number of simultaneously active jobs at any time. Args: logs: List of log entries where each entry is represented as [start, end]. Returns: The maximum number of active jobs during the construction period. Examples: >>> maxActiveJobs([]) 0 >>> maxActiveJobs([[1, 2]]) 1 >>> maxActiveJobs([[1, 2], [3, 4], [5, 6]]) 1 >>> maxActiveJobs([[1, 10], [2, 9], [3, 8]]) 3 >>> maxActiveJobs([[1, 5], [4, 8], [6, 10]]) 2 >>> maxActiveJobs([[1, 4], [4, 6]]) 1 >>> maxActiveJobs([[1, 3], [2, 5], [4, 6], [7, 9], [8, 10]]) 2","solution":"def maxActiveJobs(logs): Returns the maximum number of active jobs at any time. :param logs: A list of log entries where each entry is represented as [start, end] denoting the inclusive start and end times of a job. :type logs: List[List[int]] :return: The maximum number of active jobs at any time. :rtype: int # Create a list of all events (start and end) events = [] for log in logs: start, end = log events.append((start, 'start')) events.append((end, 'end')) # Sort events first by time; if times are the same, prioritize 'end' over 'start' events.sort(key=lambda x: (x[0], x[1] == 'start')) max_active_jobs = 0 current_active_jobs = 0 # Traverse through events for time, event in events: if event == 'start': current_active_jobs += 1 max_active_jobs = max(max_active_jobs, current_active_jobs) else: current_active_jobs -= 1 return max_active_jobs"},{"question":"def has_cycle(graph: dict) -> bool: Detect if a cycle exists in the directed graph. Parameters: graph (dict): The directed graph represented as an adjacency list. Returns: bool: True if a cycle exists, False otherwise. from solution import has_cycle def test_no_cycle(): graph = { 0: [1], 1: [2], 2: [3], 3: [] } assert not has_cycle(graph) def test_simple_cycle(): graph = { 0: [1], 1: [2], 2: [0] } assert has_cycle(graph) def test_complex_cycle(): graph = { 0: [1, 2], 1: [2], 2: [0, 3], 3: [3] } assert has_cycle(graph) def test_disconnected_components(): graph = { 0: [1], 1: [2], 2: [3], 3: [], 4: [5], 5: [6], 6: [4] } assert has_cycle(graph) def test_no_edges(): graph = { 0: [], 1: [], 2: [] } assert not has_cycle(graph) def test_self_loop(): graph = { 0: [1], 1: [1] } assert has_cycle(graph)","solution":"def has_cycle(graph): Detect if a cycle exists in the directed graph. Parameters: graph (dict): The directed graph represented as an adjacency list. Returns: bool: True if a cycle exists, False otherwise. def dfs(node, visited, rec_stack): visited.add(node) rec_stack.add(node) for neighbour in graph.get(node, []): if neighbour not in visited: if dfs(neighbour, visited, rec_stack): return True elif neighbour in rec_stack: return True rec_stack.remove(node) return False visited = set() rec_stack = set() for node in graph: if node not in visited: if dfs(node, visited, rec_stack): return True return False"},{"question":"def min_operations_to_make_k_increasing(arr: List[int], k: int) -> int: You are given a 0-indexed array of integers \`arr\` and an integer \`k\`. The array is called k-increasing if \`arr[i] <= arr[i+k]\` holds for every index \`i\` such that \`i + k < n\`, where \`n\` is the length of the array. Return the minimum number of operations required to make the array k-increasing. In one operation, you can replace any element of the array with any integer. >>> min_operations_to_make_k_increasing([5,4,3,2,1], 1) 4 >>> min_operations_to_make_k_increasing([4,1,6,5], 2) 0 >>> min_operations_to_make_k_increasing([4,1,7], 3) 0 >>> min_operations_to_make_k_increasing([12,6,18,18,24,6,40], 3) 1 >>> min_operations_to_make_k_increasing([4,1,7,2], 10) 0 >>> min_operations_to_make_k_increasing([4,4,4,4,4], 2) 0","solution":"def min_operations_to_make_k_increasing(arr, k): def length_of_lis(seq): # This function calculates the length of the Longest Increasing Subsequence (LIS) in 'seq' lis = [] for element in seq: if len(lis) == 0 or element >= lis[-1]: lis.append(element) else: left, right = 0, len(lis)-1 while left < right: mid = (left + right) // 2 if lis[mid] <= element: left = mid + 1 else: right = mid lis[left] = element return len(lis) n = len(arr) total_operations = 0 for start in range(k): subsequence = [] for i in range(start, n, k): subsequence.append(arr[i]) length_of_subsequence = len(subsequence) length_of_lis_subsequence = length_of_lis(subsequence) total_operations += (length_of_subsequence - length_of_lis_subsequence) return total_operations"},{"question":"def invalid_transactions(transactions: List[str]) -> List[str]: Returns a list of invalid transactions. A transaction is considered invalid if: 1. The amount exceeds 1000, or 2. There are multiple transactions within 60 minutes from two different cities for the same person. Parameters: transactions (List[str]): A list of transactions in the format \\"name,city,time,amount\\". Returns: List[str]: A list of invalid transactions. >>> invalid_transactions([\\"alice,mtv,20,800\\", \\"alice,mtv,50,1200\\"]) [\\"alice,mtv,50,1200\\"] >>> invalid_transactions([\\"alice,mtv,20,800\\", \\"alice,beijing,50,800\\"]) [\\"alice,mtv,20,800\\", \\"alice,beijing,50,800\\"] >>> invalid_transactions([\\"alice,mtv,20,800\\", \\"bob,mtv,50,800\\"]) [] >>> invalid_transactions([\\"alice,mtv,20,800\\", \\"alice,mtv,50,1200\\", \\"bob,mtv,10,500\\", \\"bob,beijing,30,500\\"]) [\\"alice,mtv,50,1200\\", \\"bob,mtv,10,500\\", \\"bob,beijing,30,500\\"] >>> invalid_transactions([]) [] >>> invalid_transactions([\\"alice,mtv,20,1001\\"]) [\\"alice,mtv,20,1001\\"]","solution":"def invalid_transactions(transactions): Returns a list of invalid transactions. A transaction is considered invalid if: 1. The amount exceeds 1000, or 2. There are multiple transactions within 60 minutes from two different cities for the same person. invalid = set() transactions_info = [] for transaction in transactions: name, city, time, amount = transaction.split(',') time = int(time) amount = int(amount) transactions_info.append((name, city, time, amount, transaction)) for i, (name1, city1, time1, amount1, transaction1) in enumerate(transactions_info): if amount1 > 1000: invalid.add(transaction1) for j, (name2, city2, time2, amount2, transaction2) in enumerate(transactions_info): if i != j and name1 == name2 and city1 != city2 and abs(time1 - time2) <= 60: invalid.add(transaction1) invalid.add(transaction2) return list(invalid)"},{"question":"from typing import List def knapsack_max_value(values: List[int], weights: List[int], W: int) -> int: Given a list of values and corresponding weights, along with the maximum capacity of the knapsack, find the maximum value that can be accommodated in the knapsack without exceeding the capacity. >>> knapsack_max_value([60, 100, 120], [10, 20, 30], 50) 220 >>> knapsack_max_value([10, 20, 30], [1, 2, 3], 0) 0 >>> knapsack_max_value([100], [50], 50) 100 >>> knapsack_max_value([100], [51], 50) 0 >>> knapsack_max_value([10, 20, 30], [1, 2, 3], 6) 60 >>> knapsack_max_value([1, 2, 5, 6], [2, 3, 4, 5], 8) 8 >>> knapsack_max_value([10, 40, 30, 50], [5, 4, 6, 3], 10) 90","solution":"def knapsack_max_value(values, weights, W): n = len(values) # Initialize a DP array where dp[i][w] represents the maximum value # achievable with the first i items and a maximum weight limit w dp = [[0] * (W + 1) for _ in range(n + 1)] # Build the DP array for i in range(1, n + 1): for w in range(W + 1): # If we don't take the item i-1 dp[i][w] = dp[i-1][w] # If we take the item i-1, provided its weight is not more than the current capacity if weights[i-1] <= w: dp[i][w] = max(dp[i][w], dp[i-1][w - weights[i-1]] + values[i-1]) # The maximum value that fits within the given knapsack capacity return dp[n][W]"},{"question":"def three_sum(nums: List[int], target: int) -> bool: Check if there exist three integers in the array whose sum is equal to target. >>> three_sum([2, 1, 4, 5, 6], 10) == True >>> three_sum([1, 2, 3, 4, 5], 20) == False >>> three_sum([-1, -2, -3, -4, -5, 0], -6) == True >>> three_sum([1, -2, 3, 5, -4], 4) == True >>> three_sum([10**6, 10**7, -10**6, 2 * 10**7], 3 * 10**6) == False >>> three_sum([1, 1, 1, 2, 2], 4) == True >>> three_sum([5, 5, 5], 15) == True >>> three_sum([], 0) == False >>> three_sum([1], 1) == False >>> three_sum([1, 2], 3) == False","solution":"def three_sum(nums, target): Returns True if there exist three integers in nums whose sum equals target, otherwise False. nums.sort() n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"def maxProductSubarray(arr): Returns the maximum product of any subarray within \`arr\`. >>> maxProductSubarray([2, 3, -2, 4]) == 6 >>> maxProductSubarray([-2, -3, 0, -2, -40]) == 80 >>> maxProductSubarray([0, 2, -3, 4, 0]) == 4 >>> maxProductSubarray([0, -2, 0, -3, 0, 4]) == 4 >>> maxProductSubarray([2, -5, -2, -4, 3]) == 24 >>> maxProductSubarray([-1, 2, 3, -4, 5, -6]) == 720 >>> maxProductSubarray([-1, -2, -3, 0, 1, 2, 3]) == 6 >>> maxProductSubarray([-2, 0, -1]) == 0","solution":"def maxProductSubarray(arr): Returns the maximum product of any subarray within \`arr\`. if not arr: return 0 max_product = min_product = result = arr[0] for num in arr[1:]: if num < 0: max_product, min_product = min_product, max_product max_product = max(num, max_product * num) min_product = min(num, min_product * num) result = max(result, max_product) return result"},{"question":"def trap(height: List[int]) -> int: Given a list of non-negative integers representing the elevation map, calculates the total amount of water that can be trapped after raining. Parameters: height (List[int]): A list of non-negative integers representing heights. Returns: int: The total amount of trapped water. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap([3, 0, 0, 2, 0, 4]) == 10 from solution import trap def test_trap_no_elevation(): assert trap([]) == 0 assert trap([0]) == 0 def test_trap_no_water_trapped(): assert trap([1, 1, 1, 1]) == 0 assert trap([1, 2, 3, 4, 5]) == 0 def test_trap_basic(): assert trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 def test_trap_single_peak(): assert trap([3, 0, 0, 2, 0, 4]) == 10 def test_trap_double_peak(): assert trap([1, 2, 1, 2, 1]) == 1 def test_trap_multiple_peaks(): assert trap([4, 2, 3]) == 1 def test_trap_large_numbers(): assert trap([1000,0,1000]) == 1000","solution":"def trap(height): Given a list of non-negative integers representing the elevation map, calculates the total amount of water that can be trapped after raining. Parameters: height (List[int]): A list of non-negative integers representing heights. Returns: int: The total amount of trapped water. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"}]`),A={name:"App",components:{PoemCard:j},data(){return{searchQuery:"",visibleCount:4,poemsData:F,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},C={class:"search-container"},S={class:"card-container"},z={key:0,class:"empty-state"},I=["disabled"],P={key:0},D={key:1};function M(i,e,l,c,s,a){const _=g("PoemCard");return r(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"prompts chat")])],-1)),t("div",C,[e[3]||(e[3]=t("span",{class:"search-icon"},"",-1)),p(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[b,s.searchQuery]]),s.searchQuery?(r(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")},"  ")):u("",!0)]),t("div",S,[(r(!0),n(x,null,v(a.displayedPoems,(o,f)=>(r(),y(_,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(r(),n("div",z,' No results found for "'+m(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(r(),n("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(r(),n("span",D,"Loading...")):(r(),n("span",P,"See more"))],8,I)):u("",!0)])}const B=h(A,[["render",M],["__scopeId","data-v-30f85fe1"]]),G=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/21.md","filePath":"library/21.md"}'),E={name:"library/21.md"},W=Object.assign(E,{setup(i){return(e,l)=>(r(),n("div",null,[w(B)]))}});export{G as __pageData,W as default};
