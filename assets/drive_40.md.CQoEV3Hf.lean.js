import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},A={class:"review-content"};function E(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",A,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const N=c(k,[["render",E],["__scopeId","data-v-78f1fc41"]]),S=JSON.parse('[{"question":"# Coding Assessment Question **Scenario**: You are a software engineer tasked with analyzing the transactions of an e-commerce platform. One key metric is the average transaction value during a given day. Given a list of transactions that include timestamps and values, you must compute the average transaction value for transactions that occurred within a specified range of time on that day. **Task**: Implement a Python function `average_transaction_value` that computes the average value of transactions occurring within a specified time window on a given day. **Function Signature**: ```python from typing import List, Tuple def average_transaction_value( transactions: List[Tuple[str, float]], start_time: str, end_time: str ) -> float: Compute the average value of transactions within a specified time range. Parameters: - transactions (List[Tuple[str, float]]): A list of tuples where each tuple consists of a timestamp and a transaction value. Timestamp is formatted as \'HH:MM\' (24-hour format). - start_time (str): Start of the time range in \'HH:MM\' format. - end_time (str): End of the time range in \'HH:MM\' format. Returns: - float: The average transaction value within the specified time range. Exceptions: - Raise ValueError if start_time or end_time is not in the \'HH:MM\' format. - Raise ValueError if start_time is after end_time. - Return 0.0 if there are no transactions in the specified time range. pass ``` **Constraints**: - Ensure that `start_time` and `end_time` follow the \'HH:MM\' format and valid time values. - The list of transactions can have a length up to 10^6. - Each transaction value is a positive float. - The transaction timestamps are ordered, and all transactions are from the same day. **Performance Requirements**: - The function should run in O(n) time, where n is the length of the transactions list. **Examples**: ```python >>> transactions = [(\\"09:15\\", 150.0), (\\"10:30\\", 200.0), (\\"11:45\\", 50.0), (\\"13:00\\", 100.0)] >>> start_time = \\"10:00\\" >>> end_time = \\"12:00\\" >>> average_transaction_value(transactions, start_time, end_time) 125.0 >>> transactions = [(\\"08:00\\", 80.0), (\\"08:30\\", 120.0), (\\"09:00\\", 50.0)] >>> start_time = \\"07:00\\" >>> end_time = \\"08:30\\" >>> average_transaction_value(transactions, start_time, end_time) 100.0 >>> transactions = [(\\"09:00\\", 75.0), (\\"10:00\\", 50.0), (\\"11:00\\", 30.0)] >>> start_time = \\"12:00\\" >>> end_time = \\"13:00\\" >>> average_transaction_value(transactions, start_time, end_time) 0.0 >>> transactions = [(\\"09:00\\", 75.0), (\\"10:00\\", 50.0), (\\"11:00\\", 30.0)] >>> start_time = \\"11:00\\" >>> end_time = \\"10:00\\" >>> average_transaction_value(transactions, start_time, end_time) Traceback (most recent call last): ... ValueError: start_time must be before end_time ```","solution":"from typing import List, Tuple def average_transaction_value( transactions: List[Tuple[str, float]], start_time: str, end_time: str ) -> float: Compute the average value of transactions within a specified time range. Parameters: - transactions (List[Tuple[str, float]]): A list of tuples where each tuple consists of a timestamp and a transaction value. Timestamp is formatted as \'HH:MM\' (24-hour format). - start_time (str): Start of the time range in \'HH:MM\' format. - end_time (str): End of the time range in \'HH:MM\' format. Returns: - float: The average transaction value within the specified time range. Exceptions: - Raise ValueError if start_time or end_time is not in the \'HH:MM\' format. - Raise ValueError if start_time is after end_time. - Return 0.0 if there are no transactions in the specified time range. import re # Validate time format time_pattern = re.compile(r\\"^d{2}:d{2}\\") if not (time_pattern.match(start_time) and time_pattern.match(end_time)): raise ValueError(\\"start_time and end_time must be in \'HH:MM\' format\\") start_hour, start_minute = map(int, start_time.split(\':\')) end_hour, end_minute = map(int, end_time.split(\':\')) # Validate time range if (start_hour, start_minute) > (end_hour, end_minute): raise ValueError(\\"start_time must be before end_time\\") # Function to convert time string to minutes since midnight def time_to_minutes(time_str: str) -> int: hour, minute = map(int, time_str.split(\':\')) return hour * 60 + minute start_minutes = time_to_minutes(start_time) end_minutes = time_to_minutes(end_time) # Filter transactions within the specified time range total_value = 0.0 count = 0 for timestamp, value in transactions: transaction_minutes = time_to_minutes(timestamp) if start_minutes <= transaction_minutes <= end_minutes: total_value += value count += 1 if count == 0: return 0.0 return total_value / count"},{"question":"# Coding Assessment Question Problem Statement You have been given a `2d` list of integers representing different elevations on a map. Your task is to write a function that finds the highest peak and the lowest valley in the map, then returns the absolute difference between them. Requirements * **Function Signature**: ```python def elevation_difference(elevation_map: list[list[int]]) -> int: ``` * **Input**: * A `2d` list of integers `elevation_map` where 1 <= len(elevation_map) <= 100 and 1 <= len(elevation_map[0]) <= 100, and -10^3 <= elevation_map[i][j] <= 10^3. * **Output**: * An integer representing the absolute difference between the highest peak and the lowest valley. Constraints * The function should find the highest peak and the lowest valley in the `2d` list. * You must traverse the entire `2d` list to ensure all elevations are considered. Example ```python >>> elevation_difference([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 8 >>> elevation_difference([[10, -1, 2], [3, 0, 5], [-2, 8, 7]]) 12 >>> elevation_difference([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 ``` Explanation 1. Iterate through the `2d` list to find the highest and lowest values. 2. Calculate the absolute difference between these two values. 3. Return the computed absolute difference. Edge Cases to Consider 1. A `2d` list with a single element. 2. A `2d` list where all elements are the same. 3. A `2d` list with maximum values of all positive or negative numbers. Implement the function `elevation_difference` according to the specifications above and ensure it passes all the given test cases.","solution":"def elevation_difference(elevation_map: list[list[int]]) -> int: This function takes a 2D list of integers representing elevations on a map, and returns the absolute difference between the highest peak and the lowest valley. # Initialize the highest and lowest values with extreme opposites highest_peak = float(\'-inf\') lowest_valley = float(\'inf\') # Traverse the entire 2D list to find the highest peak and lowest valley for row in elevation_map: for elevation in row: if elevation > highest_peak: highest_peak = elevation if elevation < lowest_valley: lowest_valley = elevation # Calculate the absolute difference difference = abs(highest_peak - lowest_valley) return difference"},{"question":"# Problem Statement Given a matrix of integers where each row is sorted in non-decreasing order, and an integer target, implement a function to determine if the target integer exists in the matrix. If the target integer is found, return its position as a tuple (row index, column index); otherwise, return (-1, -1). # Function Signature ```python def search_matrix(matrix: list[list[int]], target: int) -> tuple[int, int]: ``` # Input 1. `matrix` (list of list of int): A 2D list where each row is sorted in non-decreasing order. 2. `target` (int): The target integer to search for. # Output * `tuple[int, int]`: A tuple containing the row and column indices of the target integer in the matrix, or (-1, -1) if the target is not found. # Constraints * The number of rows ((R)) and columns ((C)) in the matrix can be up to (10^3). * The value of each integer in the matrix will be between (-10^6) and (10^6). * The matrix is guaranteed to have at least one row and one column. # Requirements * Your solution should have a time complexity of (O(R + C)), where (R) is the number of rows and (C) is the number of columns. * The space complexity should be (O(1)). # Example ```python matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] assert search_matrix(matrix, 5) == (1, 1) assert search_matrix(matrix, 20) == (-1, -1) assert search_matrix(matrix, 15) == (0, 4) assert search_matrix(matrix, 1) == (0, 0) assert search_matrix(matrix, 30) == (4, 4) ``` Consider carefully edge cases such as the target being the first or last element in the matrix. Optimize performance to handle the maximum constraints efficiently. # Hints * Start searching from the top-right corner of the matrix. * Use the properties of the sorted rows and columns to eliminate half of the search space with each step.","solution":"def search_matrix(matrix, target): Search the matrix for the target value. Parameters: matrix (list of list of int): A 2D list where each row is sorted in non-decreasing order. target (int): The target integer to search for. Returns: tuple (int, int): The position of the target as a tuple (row index, column index) or (-1, -1) if the target is not found. if not matrix: return -1, -1 rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return row, col elif matrix[row][col] > target: col -= 1 else: row += 1 return -1, -1"},{"question":"Find the Shortest Subarray with Sum at Least K Context Given an integer array, sometimes it is necessary to find the shortest subarray whose sum is at least a given integer value K. This has applications in multiple domains like finance, where one might need to track the shortest period within which a certain profit threshold is achieved. Task You are to write a function `shortest_subarray_with_sum_at_least_k(arr: List[int], k: int) -> int`, which computes the length of the shortest subarray that has a sum at least `k`. If there is no such subarray, return -1. Function Signature ```python from typing import List def shortest_subarray_with_sum_at_least_k(arr: List[int], k: int) -> int: ... ``` Input 1. `arr` (List[int]): A list of integers. 2. `k` (int): The required subarray sum threshold. Output An integer representing the length of the shortest subarray with a sum of at least `k`. Return -1 if no such subarray exists. Constraints 1. The length of the array `0 <= len(arr) <= 10^5` 2. The elements of the array are integers, and their absolute value does not exceed 10000. 3. `1 <= k <= 10^9` Examples ```python # A straightforward case where the subarray of sufficient sum is easily found print(shortest_subarray_with_sum_at_least_k([2, 3, 1, 2, 4, 3], 7)) # 2 (subarray [4, 3]) # Subarray exists at the start print(shortest_subarray_with_sum_at_least_k([1, 1, 1, 1, 1, 10], 10)) # 1 (subarray [10]) # The entire array sums to less than k print(shortest_subarray_with_sum_at_least_k([1, 2, 3], 7)) # -1 # A case where there are multiple valid subarrays print(shortest_subarray_with_sum_at_least_k([1, 2, 3, 4], 6)) # 2 (subarray [2, 4] or [3, 3]) # Large k with sporadic elements print(shortest_subarray_with_sum_at_least_k([1000, -1, 2, -1, 1000, -1000], 1001)) # 3 (subarray [1000, -1, 2]) ```","solution":"from typing import List import collections def shortest_subarray_with_sum_at_least_k(arr: List[int], k: int) -> int: n = len(arr) prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + arr[i] deq = collections.deque() min_len = float(\'inf\') for i in range(n + 1): while deq and prefix_sum[i] - prefix_sum[deq[0]] >= k: min_len = min(min_len, i - deq.popleft()) while deq and prefix_sum[i] <= prefix_sum[deq[-1]]: deq.pop() deq.append(i) return min_len if min_len != float(\'inf\') else -1"},{"question":"# Question: Implement a Recursive Sum of Nested Lists Given a nested list of integers, your task is to write a function that computes the sum of all the integers, handling any level of nesting. The function must use recursion to navigate through the nested structure. Non-integer elements (such as other lists) should be traversed, and only integer elements should be considered for the sum. # Function Signature ```python def nested_sum(nested_list: list) -> int: Arguments: nested_list: A list, which may contain integers and/or other lists of integers. Returns: An integer representing the sum of all integers in the nested list. ``` # Expected Input and Output * **Input**: * `nested_list`: A list which may include nested lists of integers. * **Output**: * An integer, which is the sum of all integers in the nested structure. * **Constraints**: * The depth of nesting will be up to 10^3. * The nested lists and integers combined will not exceed a total length/count of 10^6. # Example ```python >>> nested_list = [1, [2, [3, 4, [5, 6]]]] >>> nested_sum(nested_list) 21 >>> nested_list = [10, [20, [30]], [40, 50]] >>> nested_sum(nested_list) 150 >>> nested_list = [1, [1, [1, [1, [1, [1, [1, [1, [1, [1]]]]]]]]]] >>> nested_sum(nested_list) 10 ``` # Performance Your implementation should efficiently handle deeply nested structures within the provided constraints. # Notes * Describe the recursive approach in your function. * Ensure your implementation correctly handles edge cases, such as empty lists and varying levels of nesting.","solution":"def nested_sum(nested_list): Recursively computes the sum of all integers in a nested list. Arguments: nested_list: A list which may contain integers and/or other lists. Returns: An integer representing the sum of all integers in the nested list. total = 0 for element in nested_list: if isinstance(element, list): total += nested_sum(element) elif isinstance(element, int): total += element return total"},{"question":"# Coding Question: Tracking Unique Path Sequences Scenario: You are working on a navigation system that records the unique paths between landmarks in a city. Given a direct graph representing the city\'s roads and landmarks, your task is to determine the number of unique paths from a starting landmark to a destination landmark. Task: Implement a function `count_unique_paths` that calculates the number of unique sequences of roads that connect the starting landmark to the destination landmark without revisiting any landmark within the same path. Function Signature: ```python def count_unique_paths(n: int, roads: List[Tuple[int, int]], start: int, destination: int) -> int: pass ``` Input: * `n` (int): The number of landmarks in the city, labeled from `0` to `n-1`. * `roads` (list of tuples): A list of pairs `(u, v)` indicating a direct road from landmark `u` to landmark `v`. * `start` (int): The starting landmark. * `destination` (int): The destination landmark. Output: * Return the number of unique paths from `start` to `destination`. Constraints: * You may assume that `1 ≤ n ≤ 10^4`. * There can be zero or more roads between any two landmarks. * The graph does not contain cycles. Example: ```python >>> count_unique_paths(5, [(0, 1), (0, 2), (1, 3), (2, 3), (3, 4)], 0, 4) 2 # There are two unique paths: 0 -> 1 -> 3 -> 4 and 0 -> 2 -> 3 -> 4. >>> count_unique_paths(4, [(0, 1), (1, 2), (2, 3)], 0, 3) 1 # There is only one unique path: 0 -> 1 -> 2 -> 3. ``` Additional Information: Consider utilizing depth-first search (DFS) or breadth-first search (BFS) to explore all possible paths. Ensure the solution is optimized to handle the upper range of input sizes efficiently.","solution":"from typing import List, Tuple def count_unique_paths(n: int, roads: List[Tuple[int, int]], start: int, destination: int) -> int: from collections import defaultdict def dfs(current, destination, graph, visited): if current == destination: return 1 visited[current] = True path_count = 0 for neighbor in graph[current]: if not visited[neighbor]: path_count += dfs(neighbor, destination, graph, visited) visited[current] = False return path_count graph = defaultdict(list) for u, v in roads: graph[u].append(v) visited = [False] * n return dfs(start, destination, graph, visited)"},{"question":"# Question: Grid-Based Pathfinding Visualization **Scenario**: You are tasked with implementing a simple pathfinding algorithm to navigate a two-dimensional grid. The goal is to move from the top-left corner to the bottom-right corner, avoiding obstacles, and to visualize the path found by the algorithm. Problem Statement Write a function `find_and_visualize_path` that takes a grid and uses Breadth-First Search (BFS) to find the shortest path from the top-left (0, 0) to the bottom-right (n-1, n-1) corner. The function should return a greyscale image representing the grid, with the path traced in a different color. Function Signature ```python from PIL import Image def find_and_visualize_path(grid: list[list[int]]) -> Image.Image: pass ``` Input - `grid`: A list of lists where each inner list represents a row of the grid and each element is either 0 (walkable cell) or 1 (obstacle). The grid will have at least 2 rows and 2 columns. Output - Returns a `PIL.Image.Image` object that visually represents the grid. Walkable cells (0) should be white, obstacles (1) should be black, and the path found should be in a different color (e.g., red). Constraints - The grid dimensions are at least 2x2. - The start (0,0) and end (n-1,n-1) cells are always walkable (0). Example ```python grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] img = find_and_visualize_path(grid) img.show() # This should display the grid with the path highlighted ``` Requirements - Implement BFS to find the shortest path from the start to the end. - Ensure the path is correctly traced and visualized in the returned image. - If no path exists, return an image showing the original grid without modifications.","solution":"from PIL import Image from collections import deque def find_and_visualize_path(grid: list[list[int]]) -> Image.Image: # Dimensions of the grid rows, cols = len(grid), len(grid[0]) # Directions for moving in the grid (right, down, left, up) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS initialization queue = deque([(0, 0)]) parent = {} parent[(0, 0)] = None # Perform BFS while queue: current = queue.popleft() if current == (rows - 1, cols - 1): break # Path found for direction in directions: new_row, new_col = current[0] + direction[0], current[1] + direction[1] if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 0 and (new_row, new_col) not in parent: queue.append((new_row, new_col)) parent[(new_row, new_col)] = current # Generate an empty image img = Image.new(\'RGB\', (cols, rows), \\"white\\") pixels = img.load() # Draw the obstacles and the path for row in range(rows): for col in range(cols): if grid[row][col] == 1: pixels[col, row] = (0, 0, 0) # black for obstacles # If a path is found, trace back from end to start if (rows - 1, cols - 1) in parent: current = (rows - 1, cols - 1) while current: pixels[current[1], current[0]] = (255, 0, 0) # red for the path current = parent[current] return img"},{"question":"# Coding Assessment Question **Rotate Matrix by 90 Degrees** Write a program to rotate a given `n x n` matrix by 90 degrees clockwise. Function Signature ```python def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n matrix by 90 degrees clockwise and returns the rotated matrix. :param matrix: A list of lists of integers representing the n x n matrix. :return: A list of lists of integers representing the rotated matrix. ``` Input * `matrix` - A list of `n` lists, each containing `n` integers written as `matrix[i][j]` (with `1 <= n <= 1000`). Output * The function should return a new matrix which is the 90 degrees clockwise rotation of the input matrix. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(rotate_matrix(matrix)) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] matrix = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] print(rotate_matrix(matrix)) # Output: # [ # [15, 13, 2, 5], # [14, 3, 4, 1], # [12, 6, 8, 9], # [16, 7, 10, 11] # ] ``` Constraints * You can assume the input contains an n x n matrix, meaning the number of rows equals the number of columns. * Aim to solve the problem with efficient time and space complexity considering the given constraints. Performance Requirements * The implementation should complete within a reasonable time frame for the upper limit value of (1000 times 1000) matrix.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n matrix by 90 degrees clockwise and returns the rotated matrix. :param matrix: A list of lists of integers representing the n x n matrix. :return: A list of lists of integers representing the rotated matrix. # Determine the size of the matrix n = len(matrix) # Create a new matrix for the rotated result rotated_matrix = [[0] * n for _ in range(n)] # Perform the rotation for i in range(n): for j in range(n): rotated_matrix[j][n-1-i] = matrix[i][j] return rotated_matrix"},{"question":"# Coding Assessment Question Implement an algorithm to perform operations on a circular deque. The operations to be supported are: 1. **Initialization**: Create an empty circular deque with a specified capacity. 2. **Insertion**: - Insert elements to the front or rear of the deque. - If the deque is full, reject the insertion. 3. **Deletion**: - Remove elements from the front or rear of the deque. - If the deque is empty, return an error or indication of failure. 4. **Peek**: - Peek the front and rear elements without removing them from the deque. 5. **Size Checking**: - Check if the deque is empty or full. - Return the current number of elements in the deque. 6. **Visualization**: Display the current state of the deque\'s elements in a list format. # Function Signature: ```python class CircularDeque: def __init__(self, k: int) -> None: pass def insertFront(self, value: int) -> bool: pass def insertLast(self, value: int) -> bool: pass def deleteFront(self) -> bool: pass def deleteLast(self) -> bool: pass def getFront(self) -> int: pass def getRear(self) -> int: pass def isEmpty(self) -> bool: pass def isFull(self) -> bool: pass def display(self) -> List[int]: pass ``` Your Task: Implement the `CircularDeque` class to handle the operations described above. Ensure that the insertion, deletion, and peeking operations adhere to circular deque properties. Use wrap-around indexing techniques when necessary to handle the circular nature of the deque. Constraints: - Deque capacity: 1 <= k <= 1000 - Element values: -10<sup>6</sup> <= value <= 10<sup>6</sup> Given this setup, verify correctness by: - Ensuring proper handling of edge cases such as empty and full deque scenarios. - Checking that insertions and deletions are performed at the correct ends. - Confirming that the circular nature of the deque is maintained through wrap-around indexing. # Example: ```python cq = CircularDeque(3) cq.insertLast(1) # returns True cq.insertLast(2) # returns True cq.insertFront(3) # returns True cq.insertFront(4) # returns False as deque is full cq.display() # returns [3, 1, 2] cq.getRear() # returns 2 cq.isFull() # returns True cq.deleteLast() # returns True cq.insertFront(4) # returns True cq.display() # returns [4, 3, 1] ```","solution":"class CircularDeque: def __init__(self, k: int) -> None: self.k = k self.queue = [None] * k self.front = -1 self.rear = -1 self.size = 0 def insertFront(self, value: int) -> bool: if self.isFull(): return False if self.isEmpty(): self.front = self.rear = 0 else: self.front = (self.front - 1) % self.k self.queue[self.front] = value self.size += 1 return True def insertLast(self, value: int) -> bool: if self.isFull(): return False if self.isEmpty(): self.front = self.rear = 0 else: self.rear = (self.rear + 1) % self.k self.queue[self.rear] = value self.size += 1 return True def deleteFront(self) -> bool: if self.isEmpty(): return False if self.front == self.rear: self.front = self.rear = -1 else: self.front = (self.front + 1) % self.k self.size -= 1 return True def deleteLast(self) -> bool: if self.isEmpty(): return False if self.front == self.rear: self.front = self.rear = -1 else: self.rear = (self.rear - 1) % self.k self.size -= 1 return True def getFront(self) -> int: if self.isEmpty(): return -1 return self.queue[self.front] def getRear(self) -> int: if self.isEmpty(): return -1 return self.queue[self.rear] def isEmpty(self) -> bool: return self.size == 0 def isFull(self) -> bool: return self.size == self.k def display(self) -> list: if self.isEmpty(): return [] result = [] i = self.front while True: result.append(self.queue[i]) if i == self.rear: break i = (i + 1) % self.k return result"},{"question":"# Minimum Edit Distance Given two strings, the goal is to find the minimum number of operations required to convert the first string into the second string. The operations allowed are insert, delete, or replace a character. This is a classic problem known as the \\"Edit Distance\\" or \\"Levenshtein Distance\\". Input - Two strings `word1` and `word2`. Output - The function should return an integer, representing the minimum number of operations to transform `word1` into `word2`. Constraints - Both input strings `word1` and `word2` can have a maximum length of 1000. Performance Requirements - The implementation should have a time complexity of O(m * n) and a space complexity of O(m * n), where m and n are the lengths of `word1` and `word2` respectively. Example ```python def min_edit_distance(word1: str, word2: str) -> int: pass # Example Test Cases assert min_edit_distance(\\"intention\\", \\"execution\\") == 5 # Replace \'i\' with \'e\', replace \'n\' with \'x\', add \'c\', replace \'t\' with \'u\', and add \'n\' assert min_edit_distance(\\"kitten\\", \\"sitting\\") == 3 # Replace \'k\' with \'s\', add \'i\', and replace \'e\' with \'i\' assert min_edit_distance(\\"flaw\\", \\"lawn\\") == 2 # Remove \'f\', replace \'a\' with \'l\' assert min_edit_distance(\\"\\", \\"abc\\") == 3 # Add \'a\', \'b\', and \'c\' assert min_edit_distance(\\"abc\\", \\"abc\\") == 0 # No changes needed ``` Implementation Notes: 1. Define a 2D array `dp` of size (m+1) x (n+1) to store the minimum edit distance between the substrings `word1[0...i-1]` and `word2[0...j-1]`. 2. Initialize `dp[i][0]` to `i` and `dp[0][j]` to `j` for all `i` and `j` as the minimum edit distance between a substring and an empty string is the length of the substring. 3. Fill the `dp` array using the following relations: - If `word1[i-1] == word2[j-1]`, then `dp[i][j] = dp[i-1][j-1]`. - Otherwise, `dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])` for insert, delete, and replace operations respectively. 4. The final value `dp[m][n]` will be the minimum edit distance to transform `word1` into `word2`.","solution":"def min_edit_distance(word1: str, word2: str) -> int: Computes the minimum edit distance between two strings. m, n = len(word1), len(word2) # Create a 2D array to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize dp array for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If first string is empty, insert all characters of second string elif j == 0: dp[i][j] = i # If second string is empty, remove all characters of first string elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If characters are same, ignore them and move on else: dp[i][j] = 1 + min(dp[i - 1][j], # Insert dp[i][j - 1], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"# Problem Statement: Project Deadline Tracking System Context: A project management tool tracks various tasks within a project by maintaining a list of deadlines. Each task has an associated deadline, given as a date string in the format `YYYY-MM-DD`. To enhance productivity, the system should be able to notify users of upcoming deadlines within a specific number of days and allow adding new tasks or modifying existing ones efficiently. Task: 1. Implement the `get_upcoming_tasks(tasks, days)` function to return a list of tasks with deadlines within the next `days` days. 2. Implement the `add_or_modify_task(tasks, task_name, new_deadline)` function to add or modify a task\'s deadline in the task list. Function Signature: ```python def get_upcoming_tasks(tasks: dict, days: int) -> list def add_or_modify_task(tasks: dict, task_name: str, new_deadline: str) ``` Input Formats: - `get_upcoming_tasks(tasks, days)`: A dictionary of tasks where keys are task names (strings) and values are deadlines (strings in `YYYY-MM-DD` format). An integer `days`. - `add_or_modify_task(tasks, task_name, new_deadline)`: A dictionary of tasks where keys are task names (strings) and values are deadlines (strings in `YYYY-MM-DD` format). A task name (string) and a new deadline (string in `YYYY-MM-DD` format). Output Formats: - `get_upcoming_tasks(tasks, days)`: Returns a list of task names with deadlines within the next `days` days. - `add_or_modify_task(tasks, task_name, new_deadline)`: Returns nothing. Modifies the `tasks` dictionary in place. Constraints: - The input dictionary `tasks` contains up to 1000 tasks. - Task names are unique and strings of length up to 100 characters. - Dates are valid strings in the format `YYYY-MM-DD`. - The `days` parameter is a non-negative integer. Example: ```python # Example inputs for get_upcoming_tasks tasks = { \\"Task1\\": \\"2023-09-25\\", \\"Task2\\": \\"2023-10-10\\", \\"Task3\\": \\"2023-10-05\\" } print(get_upcoming_tasks(tasks, 7)) # Assume today is 2023-09-28 -> [] print(get_upcoming_tasks(tasks, 20)) # Assume today is 2023-09-28 -> [\\"Task3\\"] # Example inputs for add_or_modify_task add_or_modify_task(tasks, \\"Task4\\", \\"2023-11-15\\") print(tasks) # {\\"Task1\\": \\"2023-09-25\\", \\"Task2\\": \\"2023-10-10\\", \\"Task3\\": \\"2023-10-05\\", \\"Task4\\": \\"2023-11-15\\"} add_or_modify_task(tasks, \\"Task2\\", \\"2023-09-30\\") print(tasks) # {\\"Task1\\": \\"2023-09-25\\", \\"Task2\\": \\"2023-09-30\\", \\"Task3\\": \\"2023-10-05\\", \\"Task4\\": \\"2023-11-15\\"} ``` Notes: - Date comparison can be efficiently handled using Python\'s `datetime` library. - Ensure the functions handle edge cases such as empty task lists or modification of non-existing tasks.","solution":"from datetime import datetime, timedelta def get_upcoming_tasks(tasks, days): Returns a list of tasks with deadlines within the next `days` days. # Get today\'s date today = datetime.today().date() upcoming_tasks = [] # Calculate the end date for the upcoming period end_date = today + timedelta(days=days) # Find tasks with deadlines within the next `days` days for task, deadline in tasks.items(): deadline_date = datetime.strptime(deadline, \\"%Y-%m-%d\\").date() if today <= deadline_date <= end_date: upcoming_tasks.append(task) return upcoming_tasks def add_or_modify_task(tasks, task_name, new_deadline): Adds a new task or modifies an existing task\'s deadline in the task list. tasks[task_name] = new_deadline"},{"question":"# Genetic Algorithm for Knapsack Problem Implement a genetic algorithm to solve the 0/1 knapsack problem. The task involves finding the optimal subset of items to include in the knapsack such that their total weight does not exceed the given capacity and their total value is maximized. # Function Descriptions 1. **initialize_population(pop_size: int, num_items: int) -> np.ndarray** * This function initializes a population of potential solutions, where each solution is represented as a binary array of length `num_items`. 2. **fitness(solution: np.ndarray, item_weights: np.ndarray, item_values: np.ndarray, capacity: int) -> float** * This function evaluates the fitness of a given solution, taking into account the total weight constraint and the total value of the selected items. 3. **selection(population: np.ndarray, fitnesses: np.ndarray, num_parents: int) -> np.ndarray** * This function selects a subset of solutions from the population to be parents based on their fitness values. 4. **crossover(parents: np.ndarray, num_offspring: int) -> np.ndarray** * This function generates new offspring solutions by crossing over pairs of parent solutions. 5. **mutation(offspring: np.ndarray, mutation_rate: float) -> np.ndarray** * This function applies random mutations to the offspring solutions to maintain genetic diversity. 6. **genetic_algorithm(knapsack_capacity: int, item_weights: np.ndarray, item_values: np.ndarray, pop_size: int, num_generations: int, mutation_rate: float) -> np.ndarray** * This function orchestrates the genetic algorithm to evolve the population over a number of generations and return the best solution found. # Requirements * Implement the `initialize_population`, `fitness`, `selection`, `crossover`, `mutation`, and `genetic_algorithm` functions as described. * The `item_weights` and `item_values` inputs are 1D numpy arrays of equal length, where each element corresponds to the weight and value of an item, respectively. * The `capacity` input is an integer representing the maximum weight capacity of the knapsack. * The `pop_size`, `num_generations`, and `mutation_rate` inputs control the parameters of the genetic algorithm. # Constraints * Assume that `item_weights` and `item_values` have consistent dimensions. * Ensure the genetic algorithm can handle up to 100 items and find a suitable solution within a reasonable time frame. # Example ```python import numpy as np # Implement the functions def initialize_population(pop_size: int, num_items: int) -> np.ndarray: return np.random.randint(0, 2, (pop_size, num_items)) def fitness(solution: np.ndarray, item_weights: np.ndarray, item_values: np.ndarray, capacity: int) -> float: total_weight = np.sum(solution * item_weights) if total_weight > capacity: return 0 return np.sum(solution * item_values) def selection(population: np.ndarray, fitnesses: np.ndarray, num_parents: int) -> np.ndarray: parents_index = np.argsort(fitnesses)[-num_parents:] return population[parents_index] def crossover(parents: np.ndarray, num_offspring: int) -> np.ndarray: offspring = np.empty((num_offspring, parents.shape[1]), dtype=int) crossover_point = np.uint8(parents.shape[1] / 2) for k in range(num_offspring): parent1_idx = k % parents.shape[0] parent2_idx = (k + 1) % parents.shape[0] offspring[k, :crossover_point] = parents[parent1_idx, :crossover_point] offspring[k, crossover_point:] = parents[parent2_idx, crossover_point:] return offspring def mutation(offspring: np.ndarray, mutation_rate: float) -> np.ndarray: for idx in range(offspring.shape[0]): if np.random.rand() < mutation_rate: mutation_index = np.random.randint(offspring.shape[1]) offspring[idx, mutation_index] = 1 - offspring[idx, mutation_index] return offspring def genetic_algorithm(knapsack_capacity: int, item_weights: np.ndarray, item_values: np.ndarray, pop_size: int, num_generations: int, mutation_rate: float) -> np.ndarray: num_items = len(item_weights) population = initialize_population(pop_size, num_items) for generation in range(num_generations): fitnesses = np.array([fitness(sol, item_weights, item_values, knapsack_capacity) for sol in population]) parents = selection(population, fitnesses, pop_size // 2) offspring = crossover(parents, pop_size - parents.shape[0]) offspring = mutation(offspring, mutation_rate) population = np.vstack((parents, offspring)) best_fitness_index = np.argmax([fitness(sol, item_weights, item_values, knapsack_capacity) for sol in population]) return population[best_fitness_index] # Test the implementation with provided data item_weights = np.array([2, 3, 4, 5]) item_values = np.array([3, 4, 5, 6]) knapsack_capacity = 5 pop_size = 10 num_generations = 20 mutation_rate = 0.01 best_solution = genetic_algorithm(knapsack_capacity, item_weights, item_values, pop_size, num_generations, mutation_rate) print(best_solution) # Expected Output: A binary array indicating the indices of the items to include in the knapsack ``` Your solution should pass the above test case and any additional edge cases derived from the context of the problem.","solution":"import numpy as np def initialize_population(pop_size: int, num_items: int) -> np.ndarray: return np.random.randint(0, 2, (pop_size, num_items)) def fitness(solution: np.ndarray, item_weights: np.ndarray, item_values: np.ndarray, capacity: int) -> float: total_weight = np.sum(solution * item_weights) if total_weight > capacity: return 0 return np.sum(solution * item_values) def selection(population: np.ndarray, fitnesses: np.ndarray, num_parents: int) -> np.ndarray: parents_index = np.argsort(fitnesses)[-num_parents:] return population[parents_index] def crossover(parents: np.ndarray, num_offspring: int) -> np.ndarray: offspring = np.empty((num_offspring, parents.shape[1]), dtype=int) crossover_point = np.uint8(parents.shape[1] / 2) for k in range(num_offspring): parent1_idx = k % parents.shape[0] parent2_idx = (k + 1) % parents.shape[0] offspring[k, :crossover_point] = parents[parent1_idx, :crossover_point] offspring[k, crossover_point:] = parents[parent2_idx, crossover_point:] return offspring def mutation(offspring: np.ndarray, mutation_rate: float) -> np.ndarray: for idx in range(offspring.shape[0]): if np.random.rand() < mutation_rate: mutation_index = np.random.randint(offspring.shape[1]) offspring[idx, mutation_index] = 1 - offspring[idx, mutation_index] return offspring def genetic_algorithm(knapsack_capacity: int, item_weights: np.ndarray, item_values: np.ndarray, pop_size: int, num_generations: int, mutation_rate: float) -> np.ndarray: num_items = len(item_weights) population = initialize_population(pop_size, num_items) for generation in range(num_generations): fitnesses = np.array([fitness(sol, item_weights, item_values, knapsack_capacity) for sol in population]) parents = selection(population, fitnesses, pop_size // 2) offspring = crossover(parents, pop_size - parents.shape[0]) offspring = mutation(offspring, mutation_rate) population = np.vstack((parents, offspring)) best_fitness_index = np.argmax([fitness(sol, item_weights, item_values, knapsack_capacity) for sol in population]) return population[best_fitness_index]"},{"question":"# Find K-th Smallest Element in a Stream You are given a stream of integers that are being continuously read one by one. You need to find the k-th smallest element in the stream at any point in time. Implement a class `KthSmallest` which supports the following operations: 1. `__init__(self, k: int, nums: List[int])`: Initializes the object with the integer `k` and the list `nums` containing initial elements of the stream. 2. `add(self, val: int) -> int`: Appends the integer `val` to the stream and returns the k-th smallest element in the stream. # Constraints: - The length of `nums` will be between 0 and (10^4). - All elements of `nums` and all `val` values added through `add` will be integers between -(10^4) and (10^4). - 1 <= `k` <= (10^4) - The `add` method will be called at most (10^4) times. # Example: ```python # Example Usage: kth_smallest = KthSmallest(3, [4, 5, 8, 2]) print(kth_smallest.add(3)) # returns 4 print(kth_smallest.add(5)) # returns 5 print(kth_smallest.add(10)) # returns 5 print(kth_smallest.add(9)) # returns 8 print(kth_smallest.add(4)) # returns 8 ``` # Explanation: After initializing the object, the stream is represented as [4, 5, 8, 2, 3]. After adding 3, the k-th (3rd) smallest element is 4. After adding 5, the stream becomes [4, 5, 8, 2, 3, 5]. The 3rd smallest element remains 5. After adding 10, the stream becomes [4, 5, 8, 2, 3, 5, 10]. The 3rd smallest element remains 5. After adding 9, the stream becomes [4, 5, 8, 2, 3, 5, 10, 9]. The 3rd smallest element remains 8. After adding 4, the stream becomes [4, 5, 8, 2, 3, 5, 10, 9, 4]. The 3rd smallest element remains 8. # Additional Information: - You can use a min-heap or other appropriate data structures to maintain the k smallest elements efficiently. - Make sure the operations are optimized to handle the maximum constraints. Implement the class `KthSmallest` with the above constraints and methods to solve the problem efficiently.","solution":"import heapq class KthSmallest: def __init__(self, k: int, nums: list[int]): Initializes the object with the integer k and the list nums containing initial elements of the stream. self.k = k self.min_heap = nums heapq.heapify(self.min_heap) # Reduce heap_size to k if necessary while len(self.min_heap) > self.k: heapq.heappop(self.min_heap) def add(self, val: int) -> int: Appends the integer val to the stream and returns the k-th smallest element in the stream. heapq.heappush(self.min_heap, val) if len(self.min_heap) > self.k: heapq.heappop(self.min_heap) return self.min_heap[0]"},{"question":"# Longest Common Subsequence with Constraints You are given two strings `s1` and `s2` and an integer `k`. Your task is to find the longest common subsequence (LCS) of these two strings such that the LCS contains at least `k` unique characters. If no such LCS exists, return an empty string. **Function Signature:** ```python def constrained_lcs(s1: str, s2: str, k: int) -> str: Find the longest common subsequence (LCS) of two strings that contains at least k unique characters. Parameters: s1: First input string. s2: Second input string. k: Minimum number of unique characters the LCS should contain. Returns: The longest common subsequence containing at least k unique characters. If no such subsequence exists, return an empty string. Example: >>> constrained_lcs(\\"abacbdab\\", \\"bdcaba\\", 3) \'bdab\' >>> constrained_lcs(\\"abacbdab\\", \\"bdcaba\\", 4) \'\' # Implement the function here. pass ``` **Input:** * `s1`: A string of length `n` where `1 <= n <= 1000`. * `s2`: A string of length `m` where `1 <= m <= 1000`. * `k`: An integer representing the minimum number of unique characters in the LCS, where `1 <= k <= min(n, m)`. **Output:** * A string representing the longest common subsequence of `s1` and `s2` that contains at least `k` unique characters. If no such subsequence exists, return an empty string. **Constraints:** * The input strings will contain only lowercase English letters. Example Scenarios 1. **Basic Case with Required Unique Characters** * **Input:** `\\"abacbdab\\"`, `\\"bdcaba\\"`, `3` * **Output:** `\\"bdab\\"` 2. **No Sufficient Unique Characters** * **Input:** `\\"abacbdab\\"`, `\\"bdcaba\\"`, `4` * **Output:** `\\"\\"` Be sure to handle edge cases such as strings with no common subsequence, strings of minimal length, and cases where the required number of unique characters is more than those present in the input strings\' potential LCS.","solution":"def constrained_lcs(s1: str, s2: str, k: int) -> str: Find the longest common subsequence (LCS) of two strings that contains at least k unique characters. Parameters: s1: First input string. s2: Second input string. k: Minimum number of unique characters the LCS should contain. Returns: The longest common subsequence containing at least k unique characters. If no such subsequence exists, return an empty string. # Calculate the length of the two strings n, m = len(s1), len(s2) # Initialize the DP table dp = [[\'\'] * (m + 1) for _ in range(n + 1)] # Fill the DP table for i in range(n): for j in range(m): if s1[i] == s2[j]: dp[i+1][j+1] = dp[i][j] + s1[i] else: dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1], key=len) # Find the LCS lcs = dp[n][m] # Check the number of unique characters in the LCS if len(set(lcs)) >= k: return lcs else: return \'\'"},{"question":"# AVL Tree Insertion and Rotation Background: AVL trees are a type of self-balancing binary search tree where the height difference between the left and right subtrees of any node is at most one. To maintain this property during insertions, AVL trees perform rotations to rebalance the tree. Task: You need to implement functions to insert nodes into an AVL tree and perform the necessary rotations to maintain the AVL property. Each node contains an integer value, and no duplicate values will be added. Function Definitions and Requirements: 1. `insert(root: Optional[AVLTreeNode], value: int) -> AVLTreeNode`: * **Input**: The root of the AVL tree (or `None` if the tree is empty) and an integer value to be inserted. * **Output**: The new root of the AVL tree after the insertion. * **Constraints**: * The tree must remain balanced after the insertion. * The function should handle all necessary rotations to maintain the AVL property. 2. `rotate_left(node: AVLTreeNode) -> AVLTreeNode`: * **Input**: The root of the subtree. * **Output**: The new root of the subtree after a left rotation. 3. `rotate_right(node: AVLTreeNode) -> AVLTreeNode`: * **Input**: The root of the subtree. * **Output**: The new root of the subtree after a right rotation. Example Usage: ```python # Definition for an AVL tree node. class AVLTreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None self.height = 1 # Example Insertion and Verification root = None root = insert(root, 10) root = insert(root, 20) root = insert(root, 30) root = insert(root, 40) # The tree should remain balanced after each insertion. # After these insertions, the tree should perform the necessary rotations to maintain the AVL property. assert root.value == 30 assert root.left.value == 20 assert root.right.value == 40 assert root.left.left.value == 10 ``` # Guidelines: * Focus on correct implementation of tree insertions and rotations. * Ensure your implementation handles various edge cases, such as inserting into an empty tree, handling single and double rotations, and recalculating node heights. * Use standard libraries and functions where appropriate to simplify your implementation. This question builds on the understanding of tree data structures, self-balancing mechanisms, and algorithms for maintaining invariants, and integrates seamlessly with the previous coding assessments in terms of style, complexity, and scope.","solution":"class AVLTreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None self.height = 1 def get_height(node: AVLTreeNode) -> int: return node.height if node else 0 def get_balance(node: AVLTreeNode) -> int: return get_height(node.left) - get_height(node.right) if node else 0 def update_height(node: AVLTreeNode): node.height = 1 + max(get_height(node.left), get_height(node.right)) def rotate_left(z: AVLTreeNode) -> AVLTreeNode: y = z.right T2 = y.left y.left = z z.right = T2 update_height(z) update_height(y) return y def rotate_right(z: AVLTreeNode) -> AVLTreeNode: y = z.left T3 = y.right y.right = z z.left = T3 update_height(z) update_height(y) return y def insert(root: AVLTreeNode, value: int) -> AVLTreeNode: if not root: return AVLTreeNode(value) if value < root.value: root.left = insert(root.left, value) else: root.right = insert(root.right, value) update_height(root) balance = get_balance(root) # Left Left Case if balance > 1 and value < root.left.value: return rotate_right(root) # Right Right Case if balance < -1 and value > root.right.value: return rotate_left(root) # Left Right Case if balance > 1 and value > root.left.value: root.left = rotate_left(root.left) return rotate_right(root) # Right Left Case if balance < -1 and value < root.right.value: root.right = rotate_right(root.right) return rotate_left(root) return root"},{"question":"**Question: Bank Transaction System with Concurrent Processing** You are required to implement a simplified bank transaction system that supports concurrent processing of multiple accounts. Each account has a balance, and various transactions (deposits and withdrawals) need to be processed in a way that ensures data consistency and avoids race conditions. # Task 1. **Implement the `Account` class**: Create an account class to handle deposits and withdrawals while ensuring thread-safety. 2. **Develop the `Bank` class**: This class should manage multiple accounts and process transactions concurrently. 3. **Refine the `process_transactions` function**: Efficiently process a list of transactions using multiple threads, and make sure the operations are thread-safe. # Requirements: - Implement thread-safe operations for each account. - Ensure that the total balance across all accounts remains consistent. - Utilize thread pools or appropriate concurrency mechanisms to handle simultaneous transactions. # Input: - `number_of_accounts` (int): The number of accounts in the bank. - `initial_balances` (list[int]): Initial balances of the accounts. - `transactions` (list[tuple[int, str, int]]): A list of transactions where each transaction is a tuple containing the account index, transaction type (\'deposit\' or \'withdraw\'), and the amount. # Output: - The final balances of all accounts after processing all transactions. # Function Signature: ```python def process_bank_transactions(number_of_accounts: int, initial_balances: list[int], transactions: list[tuple[int, str, int]]) -> list[int]: pass ``` # Example: ```python >>> process_bank_transactions(2, [100, 200], [(0, \'deposit\', 50), (1, \'withdraw\', 30), (0, \'withdraw\', 20), (1, \'deposit\', 70)]) [130, 240] ``` **Note**: - Make sure to handle insufficient funds gracefully for withdrawal transactions. - Assume that transactions can be processed in any order, but ensure that the final balances reflect all transactions correctly. - Use appropriate synchronization mechanisms to manage concurrent access to account balances. **Hint**: - To manage concurrency in this task, consider using `threading` in Python and explore `Lock` to synchronize access to shared resources. # Example Implementation Sketch: ```python from threading import Lock, Thread class Account: def __init__(self, balance): self.balance = balance self.lock = Lock() def deposit(self, amount): with self.lock: self.balance += amount def withdraw(self, amount): with self.lock: if self.balance >= amount: self.balance -= amount return True else: return False class Bank: def __init__(self, accounts): self.accounts = accounts def process_transaction(self, account_index, transaction_type, amount): if transaction_type == \'deposit\': self.accounts[account_index].deposit(amount) elif transaction_type == \'withdraw\': self.accounts[account_index].withdraw(amount) def process_bank_transactions(number_of_accounts, initial_balances, transactions): accounts = [Account(balance) for balance in initial_balances] bank = Bank(accounts) threads = [] for transaction in transactions: t = Thread(target=bank.process_transaction, args=(transaction[0], transaction[1], transaction[2])) threads.append(t) t.start() for t in threads: t.join() return [account.balance for account in accounts] ``` - Implement additional necessary functions and classes as required.","solution":"from threading import Lock, Thread class Account: def __init__(self, balance): self.balance = balance self.lock = Lock() def deposit(self, amount): with self.lock: self.balance += amount def withdraw(self, amount): with self.lock: if self.balance >= amount: self.balance -= amount return True else: return False class Bank: def __init__(self, accounts): self.accounts = accounts def process_transaction(self, account_index, transaction_type, amount): if transaction_type == \'deposit\': self.accounts[account_index].deposit(amount) elif transaction_type == \'withdraw\': self.accounts[account_index].withdraw(amount) def process_bank_transactions(number_of_accounts, initial_balances, transactions): accounts = [Account(balance) for balance in initial_balances] bank = Bank(accounts) threads = [] for transaction in transactions: t = Thread(target=bank.process_transaction, args=(transaction[0], transaction[1], transaction[2])) threads.append(t) t.start() for t in threads: t.join() return [account.balance for account in accounts]"},{"question":"# Coding Assessment Task Scenario You are developing a software for a logistics company that needs to compute the shortest route for delivery trucks. To keep track of their delivery routes, the system needs to inspect specific aspects of the travel paths, such as whether a route is feasible given a set of road conditions. One of their common tasks involves checking if a sequence of coordinates (representing delivery points) forms a valid simple path without any cycles. Question Write a function `is_simple_path(points: List[Tuple[int, int]]) -> bool` that takes a list of tuples containing coordinates of the delivery points and determines if they form a simple path. A simple path is an unbroken sequence of distinct points with no point repeated. Input * A list `points` of tuples, where each tuple `(x_i, y_i)` represents a point\'s coordinates on a 2D plane. The length of `points` is between 2 and 10^5. Output * A boolean value `True` if the sequence of points forms a simple path, otherwise `False`. Constraints 1. Each coordinate point `(x_i, y_i)` is an integer (0 <= x_i, y_i <= 10^6). 2. No two delivery points in the sequence can be identical for it to qualify as a simple path. 3. The function should be efficient and handle large inputs within acceptable time limits. Examples ```python assert is_simple_path([(0, 0), (1, 1), (2, 2), (3, 3)]) == True assert is_simple_path([(0, 0), (1, 1), (1, 1), (2, 2)]) == False assert is_simple_path([(0, 1), (1, 2), (2, 3), (3, 1), (4, 0)]) == True assert is_simple_path([(1, 2), (3, 4), (5, 6), (3, 4)]) == False assert is_simple_path([(5, 5), (5, 6)]) == True ```","solution":"from typing import List, Tuple def is_simple_path(points: List[Tuple[int, int]]) -> bool: Determines if the sequence of points forms a simple path, meaning no point is visited more than once. Args: - points (List[Tuple[int, int]]): List of tuples representing points in a 2D plane. Returns: - bool: True if the points form a simple path, False otherwise. seen = set() for point in points: if point in seen: return False seen.add(point) return True"},{"question":"# Context: You are a software developer working on a project that involves analyzing and processing large text documents. Your task is to implement a function that efficiently calculates the similarity between two documents using cosine similarity. Cosine similarity is a common metric used to measure the similarity between two non-zero vectors in an inner product space. # Problem Statement: Implement the function `cosine_similarity` using the given skeleton code. The function should take as input two strings representing the text of two documents, and return a float indicating their cosine similarity. # Function Signature: ```python def cosine_similarity(doc1: str, doc2: str) -> float: ``` # Input: * **doc1**: A string representing the first document. * **doc2**: A string representing the second document. # Output: * **similarity**: A float representing the cosine similarity between the two documents. The result should be between 0 and 1. # Constraints: * The documents are case-insensitive and should be treated as such. * Ignore punctuation and consider only alphanumeric characters. * Efficient handling of large text documents is required. # Example: ```python # Sample documents doc1 = \\"The quick brown fox jumps over the lazy dog.\\" doc2 = \\"The quick brown dog jumps over the lazy fox.\\" # Calculating cosine similarity similarity = cosine_similarity(doc1, doc2) # The output `similarity` should be a float between 0 and 1 print(similarity) ``` # Notes: 1. Tokenize the text documents into words, eliminating punctuation and converting to lowercase. 2. Compute the term frequency (TF) vector for each document. 3. Use these vectors to compute the cosine similarity: [ text{cosine_similarity}(A, B) = frac{A cdot B}{|A| |B|} ] 4. Ensure numerical stability by handling edge cases where any document might be empty or have zero term frequency for all terms. # Hints: 1. Utilize the `collections.Counter` for efficient term frequency computation. 2. Use numpy for vector operations to simplify and speed up the calculations. # Evaluation Criteria: * **Correctness**: The function should correctly implement the cosine similarity calculation. * **Efficiency**: The implementation should handle large documents efficiently. * **Edge Handling**: Correctly handle edge cases such as empty documents. * **Code Quality**: The solution should be clean, readable, and properly commented.","solution":"import re from collections import Counter import numpy as np def cosine_similarity(doc1: str, doc2: str) -> float: # Helper function to tokenize and preprocess the document def preprocess(doc): # Convert to lowercase and remove non-alphanumeric characters doc = re.sub(r\'W+\', \' \', doc.lower()) # Tokenize the document into words return doc.split() # Preprocess both documents words1 = preprocess(doc1) words2 = preprocess(doc2) # Get term frequency vectors tf1 = Counter(words1) tf2 = Counter(words2) # Union of all words all_words = set(tf1.keys()).union(tf2.keys()) # Create vector representations vector1 = np.array([tf1[word] for word in all_words]) vector2 = np.array([tf2[word] for word in all_words]) # Compute cosine similarity dot_product = np.dot(vector1, vector2) norm1 = np.linalg.norm(vector1) norm2 = np.linalg.norm(vector2) if norm1 == 0 or norm2 == 0: # If either vector is zero, similarity is 0 return 0.0 return dot_product / (norm1 * norm2)"},{"question":"**Context**: As part of a data processing pipeline, you need to manage the operations on a large matrix efficiently. One critical operation is to rotate the matrix by 90 degrees clockwise, which is frequently required for data alignment processes. **Task**: Implement a function `rotate_matrix_90_clockwise` that takes a square matrix of integers as input and rotates it by 90 degrees clockwise in place. # Function Signature ```python def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> None: Given a square matrix, rotate the matrix by 90 degrees clockwise in place. Args: matrix (List[List[int]]): A 2D square matrix of integers. Returns: None: The function should modify the matrix in place. ``` # Input * `matrix` (List[List[int]]): A 2D list representing a square matrix (1 <= len(matrix) <= 1000), where each element is an integer (-10000 <= element <= 10000). # Output * The function returns `None`, but the input matrix should be modified to reflect the 90 degrees clockwise rotation. # Example Example 1: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix_90_clockwise(matrix) print(matrix) ``` Output: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` Example 2: ```python matrix = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_matrix_90_clockwise(matrix) print(matrix) ``` Output: ``` [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] ``` # Constraints * Ensure that the rotation is done in place to minimize the space complexity. * The algorithm should handle large matrices efficiently. * Make sure to thoroughly test edge cases, such as 1x1 matrices and matrices with all identical elements. Write your implementation to address all requirements and ensure correctness, efficiency, and robustness.","solution":"from typing import List def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> None: n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Question: Implement Optimized Trie for Autocompletion A Trie (pronounced as \\"try\\") is a tree-like data structure that is used for storing a dynamic set or associative array where the keys are usually strings. One of the common applications of a Trie is to implement an efficient autocompletion system. Your task is to implement an optimized Trie data structure that supports insertion of words and autocompletion query. Input * Multiple strings to be added into the Trie. * A prefix string for the autocompletion query. Output * A list of strings that represent the words in the Trie that start with the given prefix. # Constraints * The number of strings added into the Trie will not exceed 10,000. * The total length of all strings added together will not exceed 1,000,000 characters. * `prefix` string length will not exceed 100 characters. * Trie insert operations and autocompletion queries should be optimized for performance. # Requirements * Implement the Trie data structure. * Ensure the autocompletion function returns results quickly even for large datasets. * Handle edge cases like empty prefix or no matching words. # Function Signature ```python class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: pass def autocomplete(self, prefix: str) -> list: pass ``` # Example ```python >>> trie = Trie() >>> trie.insert(\\"hello\\") >>> trie.insert(\\"hell\\") >>> trie.insert(\\"helicopter\\") >>> trie.insert(\\"helicopters\\") >>> trie.insert(\\"helix\\") >>> trie.insert(\\"help\\") >>> trie.insert(\\"helper\\") >>> trie.insert(\\"helm\\") >>> trie.insert(\\"amazing\\") >>> trie.insert(\\"amaze\\") >>> trie.insert(\\"amazon\\") >>> trie.autocomplete(\\"hel\\") [\'hello\', \'hell\', \'helicopter\', \'helicopters\', \'helix\', \'help\', \'helper\', \'helm\'] >>> trie.autocomplete(\\"ama\\") [\'amazing\', \'amaze\', \'amazon\'] >>> trie.autocomplete(\\"xyz\\") [] >>> trie.autocomplete(\\"\\") [\'hello\', \'hell\', \'helicopter\', \'helicopters\', \'helix\', \'help\', \'helper\', \'helm\', \'amazing\', \'amaze\', \'amazon\'] ``` Make sure to consider both time and space efficiency in your implementation. Optimize the Trie structure to handle large datasets effectively.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def _dfs(self, node: TrieNode, prefix: str) -> list: results = [] if node.is_end_of_word: results.append(prefix) for char, child in node.children.items(): results.extend(self._dfs(child, prefix + char)) return results def autocomplete(self, prefix: str) -> list: node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] return self._dfs(node, prefix)"},{"question":"# Coding Assessment Question Question: You are tasked with implementing a class to represent a directed graph and performing a Depth-First Search (DFS) traversal on it. The class should include methods to add nodes, add edges, and perform DFS traversal from a given starting node. 1. **Input**: - A list of strings `nodes`, where each string represents a unique node identifier. - A list of tuples `edges`, where each tuple `(u, v)` indicates a directed edge from node `u` to node `v`. - A string `start_node` indicating the node from which the DFS traversal should begin. 2. **Output**: - A list of strings representing the order in which nodes are visited in the DFS traversal. 3. **Constraints**: - Each node identifier in `nodes` is unique and consists of alphanumeric characters. - `1 <= len(nodes) <= 1000` - `0 <= len(edges) <= 10000` - `start_node` is guaranteed to be one of the nodes in the graph. 4. **Performance Requirements**: - Optimize the DFS traversal to handle a large number of nodes and edges efficiently. - Ensure that the traversal order is the same as that of a typical recursive DFS traversal. Implementation: Write a Python class `Graph` that includes the necessary methods as described. Use `depth_first_search` as the main method to perform the traversal. Class signature: ```python class Graph: def __init__(self): # Initialize your class pass def add_node(self, node: str): # Add node to the graph pass def add_edge(self, u: str, v: str): # Add directed edge to the graph pass def depth_first_search(self, start_node: str) -> List[str]: # Perform DFS traversal pass ``` Example: ```python # Create graph g = Graph() nodes = [\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\"] edges = [(\\"A\\", \\"B\\"), (\\"A\\", \\"C\\"), (\\"B\\", \\"D\\"), (\\"C\\", \\"E\\"), (\\"E\\", \\"D\\")] # Add nodes for node in nodes: g.add_node(node) # Add edges for u, v in edges: g.add_edge(u, v) # Perform DFS start_node = \\"A\\" print(g.depth_first_search(start_node)) ``` Expected Output: ```python [\'A\', \'B\', \'D\', \'C\', \'E\'] ``` Description: Implement the `Graph` class with methods to construct the graph and perform a DFS traversal. When initializing the graph, there should be no nodes or edges. The `add_node` method should add nodes to the graph, the `add_edge` method should add directed edges, and the `depth_first_search` method should return the order of nodes visited during the DFS traversal starting from the specified node. Use a recursive approach to ensure the output order matches a typical DFS traversal.","solution":"class Graph: def __init__(self): self.graph = {} def add_node(self, node: str): if node not in self.graph: self.graph[node] = [] def add_edge(self, u: str, v: str): if u in self.graph: self.graph[u].append(v) def depth_first_search(self, start_node: str) -> list: visited = set() traversal_order = [] def dfs(node): if node not in visited: visited.add(node) traversal_order.append(node) for neighbor in self.graph.get(node, []): dfs(neighbor) dfs(start_node) return traversal_order"},{"question":"# File Processing with Log Data In this task, you will process log files containing server access information. Your goal is to write functions that parse log data, compute various statistics, and extract records based on specific criteria. Requirements 1. **Log Parsing**: - Implement the `parse_log` function to read a log file and extract essential information such as timestamps, HTTP methods, status codes, and response times. - Ensure to handle potential errors, such as missing or malformed entries. 2. **Status Code Count**: - Implement the `status_code_count` function to count the occurrences of each HTTP status code in the log data. - Handle cases where the log might be empty. 3. **Average Response Time**: - Implement the `average_response_time` function to calculate the average response time of all log entries. - Ensure to validate that the response times are positive numbers. 4. **Filter by Status Code**: - Implement the `filter_by_status_code` function to extract log entries for a specific HTTP status code. - Ensure the output is correctly formatted and handles cases where no matching entries are found. Function Signatures ```python def parse_log(log_content: str) -> list: pass def status_code_count(log_entries: list) -> dict: pass def average_response_time(log_entries: list) -> float: pass def filter_by_status_code(log_entries: list, status_code: int) -> list: pass ``` Input and Output Formats - **parse_log**: - **Input**: `log_content` (str) - multiline string containing log entries - **Output**: `list` of tuples, each representing a log entry: `(timestamp, method, status_code, response_time)` - **status_code_count**: - **Input**: `log_entries` (list) - list of log entries - **Output**: `dict` with status codes as keys and their respective counts as values - **average_response_time**: - **Input**: `log_entries` (list) - list of log entries - **Output**: `float` representing the average response time - **filter_by_status_code**: - **Input**: `log_entries` (list) - list of log entries, `status_code` (int) - status code to filter by - **Output**: `list` of tuples representing the filtered log entries Constraints - Ensure the input log content follows a specific format, e.g., `timestamp method status_code response_time`. - Status codes and response times must be valid integers and non-negative. Raise a ValueError for invalid data. - Handle large log files efficiently without compromising performance. Performance Requirements The functions should be efficient in terms of time complexity. Log parsing should be O(N), status code counting should be O(N), average response time calculation should be O(N), and filtering by status code should be O(N), where N is the number of log entries. Example Usage ```python log_content = 2023-03-10T12:00:00 GET 200 120 2023-03-10T12:00:01 POST 404 250 2023-03-10T12:00:02 GET 200 110 2023-03-10T12:00:03 PUT 500 300 2023-03-10T12:00:04 GET 200 90 log_entries = parse_log(log_content) print(status_code_count(log_entries)) # Output: {200: 3, 404: 1, 500: 1} print(average_response_time(log_entries)) # Output: 174.0 print(filter_by_status_code(log_entries, 200)) # Output: [(\'2023-03-10T12:00:00\', \'GET\', 200, 120), # (\'2023-03-10T12:00:02\', \'GET\', 200, 110), # (\'2023-03-10T12:00:04\', \'GET\', 200, 90)] ``` Implement the given functions based on these details while adhering to the input-output formats, constraints, and performance requirements.","solution":"import re def parse_log(log_content: str) -> list: Parses the given log content and returns a list of log entries. Each log entry is a tuple: (timestamp, method, status_code, response_time). log_entries = [] lines = log_content.strip().split(\\"n\\") for line in lines: match = re.match(r\\"^(S+) (S+) (d{3}) (d+)\\", line) if match: timestamp, method, status_code, response_time = match.groups() log_entries.append((timestamp, method, int(status_code), int(response_time))) else: raise ValueError(f\\"Malformed log entry: {line}\\") return log_entries def status_code_count(log_entries: list) -> dict: Returns a dictionary with the count of each status code from the list of logs. status_count = {} for _, _, status_code, _ in log_entries: if status_code in status_count: status_count[status_code] += 1 else: status_count[status_code] = 1 return status_count def average_response_time(log_entries: list) -> float: Returns the average response time from the list of logs. if not log_entries: return 0.0 total_time = sum(response_time for _, _, _, response_time in log_entries) return total_time / len(log_entries) def filter_by_status_code(log_entries: list, status_code: int) -> list: Returns a list of log entries that match the given status code. return [entry for entry in log_entries if entry[2] == status_code]"},{"question":"# Problem Statement Develop a Python program that simulates a basic ticket booking system for a movie theater. The system should support the following functionalities: 1. **Check Available Seats**: - Display the available seats in a given row. 2. **Book a Seat**: - Book a specified seat if it is available. 3. **Cancel a Booking**: - Cancel a booking for a specified seat. # Method Signatures ```python class MovieTheater: def __init__(self, rows: int, seats_per_row: int): Initialize the MovieTheater with the given number of rows and seats per row. All seats should be initially available. Args: - rows (int): The number of rows in the theater. - seats_per_row (int): The number of seats in each row. pass def check_available_seats(self, row: int) -> list[int]: Check and return the list of available seat numbers in the given row. Args: - row (int): The row number to check seats. Returns: - list[int]: A list of available seat numbers in the specified row. pass def book_seat(self, row: int, seat_number: int) -> bool: Book a seat if it is available. Args: - row (int): The row number of the seat to book. - seat_number (int): The seat number to book. Returns: - bool: True if the seat was successfully booked, False otherwise. pass def cancel_booking(self, row: int, seat_number: int) -> bool: Cancel a booking if the seat is currently booked. Args: - row (int): The row number of the booking to cancel. - seat_number (int): The seat number to cancel. Returns: - bool: True if the booking was successfully canceled, False otherwise. pass ``` # Constraints - Assume rows and seats per row are positive integers. - Seat numbers in each row start from 1. - Return an empty list if the row number is invalid. - Return False if trying to book or cancel a non-existent or an already booked seat. # Example Usage ```python # Initialize a movie theater with 3 rows and 5 seats per row theater = MovieTheater(3, 5) # Check available seats in row 1 assert theater.check_available_seats(1) == [1, 2, 3, 4, 5] # Book seat 3 in row 1 assert theater.book_seat(1, 3) is True # returns True, as the seat was available # Check available seats in row 1 again assert theater.check_available_seats(1) == [1, 2, 4, 5] # Attempt to book seat 3 in row 1 again assert theater.book_seat(1, 3) is False # returns False, as the seat is already booked # Cancel the booking of seat 3 in row 1 assert theater.cancel_booking(1, 3) is True # returns True, as the booking was canceled # Check available seats in row 1 again assert theater.check_available_seats(1) == [1, 2, 3, 4, 5] # Attempt to cancel a non-booked seat assert theater.cancel_booking(1, 2) is False # returns False, as the seat was not booked ``` **Your task is to complete the implementation of the `MovieTheater` class as specified above. Ensure to manage bookings and cancellations accurately.**","solution":"class MovieTheater: def __init__(self, rows: int, seats_per_row: int): Initialize the MovieTheater with the given number of rows and seats per row. All seats should be initially available. self.rows = rows self.seats_per_row = seats_per_row self.seats = {row: [True] * seats_per_row for row in range(1, rows + 1)} def check_available_seats(self, row: int) -> list[int]: Check and return the list of available seat numbers in the given row. if row not in self.seats: return [] return [seat_number + 1 for seat_number, available in enumerate(self.seats[row]) if available] def book_seat(self, row: int, seat_number: int) -> bool: Book a seat if it is available. Return True if successful, False otherwise. if row in self.seats and 1 <= seat_number <= self.seats_per_row and self.seats[row][seat_number - 1]: self.seats[row][seat_number - 1] = False return True return False def cancel_booking(self, row: int, seat_number: int) -> bool: Cancel a booking if the seat is currently booked. Return True if successful, False otherwise. if row in self.seats and 1 <= seat_number <= self.seats_per_row and not self.seats[row][seat_number - 1]: self.seats[row][seat_number - 1] = True return True return False"},{"question":"# Problem Statement Implement a simple URL shortener system that includes the following methods: 1. **Shorten URL**: The method, `shorten_url`, should convert a long URL into a short URL. 2. **Retrieve Long URL**: The method, `retrieve_long_url`, should take a short URL and return the original long URL. 3. **Delete URL**: The method, `delete_url`, should take a short URL and remove its mapping to the long URL. 4. **Get Stats**: The method, `get_stats`, should return the total number of URLs shortened and the total number of URLs accessed (for retrieval). Input Format - The `shorten_url` method will receive a string representing the long URL. - The `retrieve_long_url` and `delete_url` methods will receive a string representing the short URL. - The `get_stats` method does not receive any input. Output Format - The `shorten_url` method should return a string representing the short URL. - The `retrieve_long_url` method should return a string representing the original long URL. - The `delete_url` method should return a boolean indicating whether the deletion was successful. - The `get_stats` method should return a tuple with two integers: the total number of URLs shortened and the total number of URLs accessed. Constraints - The long URL input for `shorten_url` will have a length between 1 and 2048 characters. - Methods `retrieve_long_url` and `delete_url` will receive valid short URLs that were provided by `shorten_url`. - The implementation should handle at most 10^5 URLs. - Each URL will be composed of ASCII characters. Functions to Implement ```python class URLShortener: def shorten_url(self, long_url: str) -> str: pass def retrieve_long_url(self, short_url: str) -> str: pass def delete_url(self, short_url: str) -> bool: pass def get_stats(self) -> Tuple[int, int]: pass ``` Example ```python # Initialize the URL shortener url_shortener = URLShortener() # Shorten URL operation short_url = url_shortener.shorten_url(\\"https://www.example.com/some/long/path\\") print(short_url) # Output: (example short URL, e.g., \\"http://short.ly/abc123\\") # Retrieve long URL operation long_url = url_shortener.retrieve_long_url(short_url) print(long_url) # Output: \\"https://www.example.com/some/long/path\\" # Delete URL operation delete_status = url_shortener.delete_url(short_url) print(delete_status) # Output: True # Get stats operation stats = url_shortener.get_stats() print(stats) # Output: (1, 1) ``` Note: The exact short URL format may vary based on the implementation details.","solution":"import hashlib from typing import Tuple class URLShortener: def __init__(self): self.url_map = {} self.reverse_url_map = {} self.access_count = 0 def shorten_url(self, long_url: str) -> str: short_url = self._generate_short_url(long_url) self.url_map[short_url] = long_url self.reverse_url_map[long_url] = short_url return short_url def retrieve_long_url(self, short_url: str) -> str: self.access_count += 1 return self.url_map.get(short_url, \'\') def delete_url(self, short_url: str) -> bool: if short_url in self.url_map: long_url = self.url_map.pop(short_url) if long_url: self.reverse_url_map.pop(long_url, None) return True return False def get_stats(self) -> Tuple[int, int]: return len(self.url_map), self.access_count def _generate_short_url(self, long_url: str) -> str: hash_object = hashlib.md5(long_url.encode()) return \'http://short.ly/\' + hash_object.hexdigest()[:6]"},{"question":"# Question: Advanced Number Analysis with Sequences **Context:** You are enhancing a mathematical library focused on number sequences. The library already includes basic operations such as generating arithmetic and geometric sequences. Your task is to extend this functionality to handle more advanced operations involving sequences. **Objective:** Implement the following functions for advanced sequence analysis, ensuring to consider edge cases, performance optimizations, and precise handling of different input types: 1. **Nth Fibonacci Number**: Calculate the nth Fibonacci number using a non-recursive approach. 2. **Sum of Arithmetic Sequence**: Compute the sum of the first n terms of an arithmetic sequence given the first term and the common difference. 3. **Sum of Geometric Sequence**: Compute the sum of the first n terms of a geometric sequence given the first term and the common ratio. **Function Signatures:** ```python def nth_fibonacci(n: int) -> int: pass def sum_arithmetic_sequence(first_term: int, common_difference: int, n: int) -> int: pass def sum_geometric_sequence(first_term: int, common_ratio: float, n: int) -> float: pass ``` **Expected Input and Output**: ```python assert nth_fibonacci(10) == 55 assert sum_arithmetic_sequence(1, 2, 5) == 25 assert sum_geometric_sequence(1, 0.5, 3) == 1.75 ``` **Constraints:** - The inputs for all functions will be non-negative integers for `nth_fibonacci` and `sum_arithmetic_sequence`. - The first term and common ratio for `sum_geometric_sequence` will be positive numbers. - Performance should be optimized for large input values, especially for nth Fibonacci calculation. **Detailed Requirements:** 1. **Nth Fibonacci Number**: - **Input:** A non-negative integer, n. - **Output:** An integer representing the nth Fibonacci number. - Use an iterative approach to ensure efficient computation for large n. 2. **Sum of Arithmetic Sequence**: - **Input:** Three integers: the first term of the sequence, the common difference, and the number of terms (n). - **Output:** An integer representing the sum of the first n terms. - Apply the arithmetic sequence sum formula ( S_n = frac{n}{2} cdot (2a + (n-1)d) ) for efficiency. 3. **Sum of Geometric Sequence**: - **Input:** Three parameters: the first term (float), the common ratio (float), and the number of terms (n, an integer). - **Output:** A float representing the sum of the first n terms. - Use the geometric sequence sum formula ( S_n = a cdot frac{1-r^n}{1-r} ) for ( r neq 1 ). **Edge Cases to Consider**: - Minimal Input: For example, nth_fibonacci(0) should return 0, and sum_arithmetic_sequence with n = 0 should return 0. - Large Values: Ensure performance does not degrade for large values, especially for Fibonacci calculation. - Geometric Sequence with ( r = 1 ): Handle this particular case where the sum simplifies. Consider every constraint and requirement to ensure the functions perform accurately and efficiently.","solution":"def nth_fibonacci(n: int) -> int: if n <= 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b def sum_arithmetic_sequence(first_term: int, common_difference: int, n: int) -> int: if n <= 0: return 0 return n * (2 * first_term + (n - 1) * common_difference) // 2 def sum_geometric_sequence(first_term: float, common_ratio: float, n: int) -> float: if n <= 0: return 0.0 if common_ratio == 1: return first_term * n return first_term * (1 - common_ratio ** n) / (1 - common_ratio)"},{"question":"# Question: Implement an Enhanced Polynomial Regression Model You are tasked with enhancing a given Polynomial Regression implementation to include additional functionality and edge case handling. Problem Statement Extend a Polynomial Regression class to handle cases where input features can be sparse or where there are missing values. Specifically, implement methods to impute missing data and efficiently handle sparse input arrays. Requirements 1. **Impute Missing Values**: - Implement a method `impute_missing` in the `PolynomialRegression` class that fills missing values (e.g., NaN) with the mean of respective features. - Ensure this method can be called before fitting the model. 2. **Handle Sparse Inputs**: - Update the `fit` and `predict` methods to accept and process sparse matrices efficiently. - Use appropriate sparse matrix operations to avoid performance bottlenecks. Input and Output - The `impute_missing` method should take an array (numpy array or scipy sparse matrix) with missing values and return an array of the same type with missing values imputed. - The `fit` method should accept sparse matrices and dense matrices with imputed values. - The `predict` method should output predictions based on the input features, handling sparse or dense matrices accordingly. Constraints - Consider edge cases where the input arrays can have a significant proportion of missing values. - Ensure the model\'s performance and accuracy are not significantly degraded by the modifications. - Perform necessary validations to ensure users are informed when imputations are conducted. Testing and Performance - Ensure the imputation method correctly fills missing values without introducing artifacts. - Validate that the `fit` method works seamlessly with both dense and sparse arrays. - Add test cases to demonstrate the correct handling of sparse inputs and missing values. Example ```python import numpy as np import scipy.sparse as sp class PolynomialRegression: def __init__(self, degree=2): self.degree = degree self.coefs = None def impute_missing(self, X): # Implement missing value imputation here pass def fit(self, X, y): # Implement fitting procedure here, considering sparse input pass def predict(self, X): # Implement predict procedure here, considering sparse input pass # Example Usage X_dense = np.array([[1, 2], [3, np.nan], [5, 6]]) X_sparse = sp.csr_matrix([[1, 0, 3], [4, 0, 6], [0, 5, 0]]) y = np.array([1, 2, 3]) model = PolynomialRegression(degree=2) X_dense_imputed = model.impute_missing(X_dense) model.fit(X_dense_imputed, y) predictions_dense = model.predict(X_dense) model.fit(X_sparse, y) predictions_sparse = model.predict(X_sparse) ``` Output: ```plaintext predictions_dense: expected to be computed without issues related to missing values predictions_sparse: expected to be computed efficiently with sparse input ``` Implement the above solution and validate using test cases to handle scenarios with missing data and sparse input formats.","solution":"import numpy as np import scipy.sparse as sp from sklearn.preprocessing import PolynomialFeatures from sklearn.linear_model import LinearRegression class PolynomialRegression: def __init__(self, degree=2): self.degree = degree self.model = LinearRegression() self.poly = PolynomialFeatures(degree) def impute_missing(self, X): if sp.issparse(X): X = X.toarray() col_mean = np.nanmean(X, axis=0) inds = np.where(np.isnan(X)) X[inds] = np.take(col_mean, inds[1]) return X def fit(self, X, y): if sp.issparse(X): X = X.toarray() X = self.impute_missing(X) X_poly = self.poly.fit_transform(X) self.model.fit(X_poly, y) def predict(self, X): if sp.issparse(X): X = X.toarray() X = self.impute_missing(X) X_poly = self.poly.transform(X) return self.model.predict(X_poly)"},{"question":"# Scenario You have been given a list of integers and a series of commands to perform either updates or prefix sum queries on the list. Your task is to implement a data structure that efficiently handles these operations. # Problem Statement Your task is to implement two functions: 1. `update(fenwick_tree: list[int], index: int, value: int) -> None`: This function updates the element at the specified index to the new value using a Fenwick Tree (Binary Indexed Tree). 2. `prefix_sum(fenwick_tree: list[int], index: int) -> int`: This function returns the sum of the elements from the beginning of the list up to the specified index. # Input and Output Formats **Function 1: `update`** - **Input**: - `fenwick_tree` (list of integers): The Fenwick Tree representation of the list. - `index` (integer): The index of the element in the Fenwick Tree to update. - `value` (integer): The new value to set at the specified index. - **Output**: - None. **Function 2: `prefix_sum`** - **Input**: - `fenwick_tree` (list of integers): The Fenwick Tree representation of the list. - `index` (integer): The index up to which the prefix sum is to be computed. - **Output**: - An integer representing the sum of the elements from the beginning up to the specified index. # Constraints - The number of operations (updates and queries combined) is such that ( 1 leq text{number of operations} leq 10^6 ). - The values of elements in the list can be any integers within the range of what can be represented by 32-bit signed integers. - ( 0 leq text{index} < n ), where ( n ) is the size of the list. # Performance Requirements - The function `update` should have a time complexity of ( O(log n) ). - The function `prefix_sum` should have a time complexity of ( O(log n) ). # Example ```python def build_fenwick_tree(arr: list[int]) -> list[int]: n = len(arr) fenwick_tree = [0] * (n + 1) for i in range(n): update(fenwick_tree, i, arr[i]) return fenwick_tree def update(fenwick_tree: list[int], index: int, value: int) -> None: index += 1 while index < len(fenwick_tree): fenwick_tree[index] += value index += index & -index def prefix_sum(fenwick_tree: list[int], index: int) -> int: sum_ = 0 index += 1 while index > 0: sum_ += fenwick_tree[index] index -= index & -index return sum_ number_list = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3] fenwick_tree = build_fenwick_tree(number_list) prefix_sum(fenwick_tree, 4) # should return 15 update(fenwick_tree, 3, 3) # Update value at index 3 to 3 prefix_sum(fenwick_tree, 4) # should return 12 ``` # Explanation For the given list `[3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3]`, we build a Fenwick Tree and perform prefix sum queries and updates. Initially, the prefix sum up to index 4 is 15 (sum of the first 5 elements). After updating the value at index 3 from 6 to 3, the new prefix sum up to index 4 is 12.","solution":"def update(fenwick_tree: list[int], index: int, value: int) -> None: index += 1 # Fenwick Tree uses 1-based indexing while index < len(fenwick_tree): fenwick_tree[index] += value index += index & -index def prefix_sum(fenwick_tree: list[int], index: int) -> int: sum_ = 0 index += 1 # Fenwick Tree uses 1-based indexing while index > 0: sum_ += fenwick_tree[index] index -= index & -index return sum_ def build_fenwick_tree(arr: list[int]) -> list[int]: n = len(arr) fenwick_tree = [0] * (n + 1) for i in range(n): update(fenwick_tree, i, arr[i]) return fenwick_tree"},{"question":"# Coding Assessment Question Scenario: You have been tasked with implementing a custom data structure that efficiently supports a series of operations on a collection of intervals. This data structure should allow merging of overlapping intervals and quick lookup for interval containment. Task: Write a class named `IntervalManager` that supports inserting intervals, querying for interval containment, and merging overlapping intervals. Class Structure: ```python class IntervalManager: def __init__(self): Initialize your data structure here. def add_interval(self, start: int, end: int) -> None: Add a new interval [start, end] to the collection. Parameters: start (int): The start of the interval. end (int): The end of the interval. def query_interval(self, point: int) -> bool: Check if a specific point is contained within any of the intervals in the collection. Parameters: point (int): The point to check. Returns: bool: True if the point is within any interval, otherwise False. def merge_intervals(self) -> List[Tuple[int, int]]: Merge all overlapping intervals in the collection and return the list of merged intervals. Returns: List[Tuple[int, int]]: A list of merged intervals. ``` Constraints: - `start` and `end` for `add_interval` should not be negative and `start` <= `end`. - The intervals should be non-decreasing after merging. - Assume input contains non-negative integers. Example Usage: 1. Initialize the manager and add intervals: ```python manager = IntervalManager() manager.add_interval(1, 5) manager.add_interval(10, 15) manager.add_interval(4, 8) ``` 2. Query if certain points are contained within any intervals: ```python print(manager.query_interval(3)) # Should return True (within interval [1, 5]) print(manager.query_interval(9)) # Should return False (no interval contains 9) ``` 3. Merge overlapping intervals and retrieve the list of merged intervals: ```python merged_intervals = manager.merge_intervals() print(merged_intervals) # Should return [(1, 8), (10, 15)] due to merging overlaps ``` Testing: - Ensure the `add_interval` method correctly handles the insertion of intervals, including edge cases of single-point intervals. - Validate that `query_interval` properly identifies if a point lies within any of the managed intervals. - Check the correctness of `merge_intervals` in consolidating overlapping intervals into minimal, non-overlapping intervals. By completing this class, you will provide a custom interval management tool that is efficient and robust for various operations involving intervals.","solution":"from typing import List, Tuple class IntervalManager: def __init__(self): Initialize your data structure here. self.intervals = [] def add_interval(self, start: int, end: int) -> None: Add a new interval [start, end] to the collection. Parameters: start (int): The start of the interval. end (int): The end of the interval. if start > end or start < 0 or end < 0: raise ValueError(\\"Invalid interval\\") self.intervals.append((start, end)) def query_interval(self, point: int) -> bool: Check if a specific point is contained within any of the intervals in the collection. Parameters: point (int): The point to check. Returns: bool: True if the point is within any interval, otherwise False. for start, end in self.intervals: if start <= point <= end: return True return False def merge_intervals(self) -> List[Tuple[int, int]]: Merge all overlapping intervals in the collection. Returns: List[Tuple[int, int]]: A list of merged intervals. if not self.intervals: return [] # Sort intervals by start time self.intervals.sort() merged = [self.intervals[0]] for current_start, current_end in self.intervals[1:]: last_start, last_end = merged[-1] if current_start <= last_end: # Overlapping intervals merged[-1] = (last_start, max(last_end, current_end)) # Merge else: merged.append((current_start, current_end)) return merged"},{"question":"# Scenario You are developing a system that needs to efficiently manage and query a dynamic array of integers where frequent insertions and deletions occur. Additionally, you need to answer multiple range sum queries over the array in a fast manner. # Problem Statement Your task is to implement two classes: 1. `DynamicArray`: This class should support efficient insertion, deletion, and summation operations. 2. `SegmentTree`: This class helps in precomputing and querying the sum over a range efficiently. `DynamicArray` class should support the following methods: - `insert(value: int) -> None`: Inserts an integer value at the end of the array. - `delete(index: int) -> None`: Deletes the element at the specified index from the array. - `sum_range(left_bound: int, right_bound: int) -> int`: Returns the sum of integer values in the array between the specified indices. `SegmentTree` class should support the following method: - `__init__(data: list[int]) -> None`: Initializes the segment tree with the given list of integers. - `update(index: int, value: int) -> None`: Updates the element at the specified index to the new value in the segment tree. - `query(left_bound: int, right_bound: int) -> int`: Returns the sum of integer values in the range [left_bound, right_bound] within the segment tree. # Input and Output Formats **Class 1: `DynamicArray`** - **Methods**: - `insert(value: int)`: Inserts an integer at the end of the array. - `delete(index: int)`: Deletes the element at the specified index from the array. - `sum_range(left_bound: int, right_bound: int)`: Returns the sum of the array elements between the specified indices. **Class 2: `SegmentTree`** - **Methods**: - `__init__(data: list[int])`: Initializes the segment tree with the given list of integers. - `update(index: int, value: int)`: Updates the element at the specified index to the new value. - `query(left_bound: int, right_bound: int)`: Returns the sum of the elements within the specified range. # Constraints - The number of elements in the list, ( n ), is such that ( 1 leq n leq 10^5 ). - The elements in the list and the inserted elements can be any integers within the range of what can be represented by 32-bit signed integers. - ( 0 leq text{left_bound} leq text{right_bound} < n ). # Performance Requirements - The class `SegmentTree` should handle range sum queries and updates in ( O(log n) ) time. - The class `DynamicArray` should handle insertions and deletions in ( O(log n) ) time on average, considering underlying segment tree updates. # Example ```python # Initializing DynamicArray dyn_array = DynamicArray() dyn_array.insert(3) dyn_array.insert(7) dyn_array.insert(1) dyn_array.insert(5) # Sum range queries print(dyn_array.sum_range(1, 3)) # should return 13 (7 + 1 + 5) print(dyn_array.sum_range(0, 2)) # should return 11 (3 + 7 + 1) # Deleting an element dyn_array.delete(2) # Sum range queries after deletion print(dyn_array.sum_range(0, 2)) # should return 15 (3 + 7 + 5) ``` # Explanation In this example, you initialize a dynamic array and perform multiple insertions. You can then efficiently query the sum of specified ranges using the segment tree. When an element is deleted, the segment tree is updated to reflect this change, and subsequent range queries reflect the updated state of the array.","solution":"class SegmentTree: def __init__(self, data): self.data = data n = len(data) self.tree = [0] * (2 * n) self.build_tree(data) def build_tree(self, data): n = len(data) for i in range(n): self.tree[n + i] = data[i] for i in range(n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, index, value): n = len(self.data) pos = n + index self.tree[pos] = value pos //= 2 while pos >= 1: self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] pos //= 2 def query(self, left_bound, right_bound): n = len(self.data) left = n + left_bound right = n + right_bound s = 0 while left <= right: if left % 2 == 1: s += self.tree[left] left += 1 if right % 2 == 0: s += self.tree[right] right -= 1 left //= 2 right //= 2 return s class DynamicArray: def __init__(self): self.data = [] self.segment_tree = SegmentTree(self.data) def insert(self, value): self.data.append(value) self.segment_tree = SegmentTree(self.data) def delete(self, index): if 0 <= index < len(self.data): self.data.pop(index) self.segment_tree = SegmentTree(self.data) def sum_range(self, left_bound, right_bound): return self.segment_tree.query(left_bound, right_bound)"},{"question":"# Coding Assessment Question: **Problem Description**: You are required to design and implement a simplified version of the Random Forest Classifier from scratch. The purpose of this exercise is to verify your understanding of ensemble methods, particularly bagging, and your ability to implement essential machine learning components effectively. Your task involves using multiple decision trees (weak learners) to create a robust composite classifier. **Requirements**: Implement the `CustomRandomForestClassifier` class to achieve efficient and accurate binary classification using the random forest technique. The implementation should include the following methods: 1. **Constructor `__init__(self, n_estimators: int = 100, max_features: int = None)`** - Initialize the classifier with `n_estimators` decision trees and `max_features` specifying the number of features to consider when looking for the best split. 2. **Method `fit(self, features: np.ndarray, target: np.ndarray) -> None`** - Train the random forest classifier using the training data. 3. **Method `predict(self, features: np.ndarray) -> np.ndarray`** - Predict the labels for the input features. 4. **Method `bootstrap_sample(self, features: np.ndarray, target: np.ndarray) -> Tuple[np.ndarray, np.ndarray]** - Generate a bootstrap sample from the training dataset. **Input/Output**: 1. **Constructor Parameters**: - `n_estimators` (int): Number of decision trees to train. - `max_features` (int): Number of features to consider for the best split; if None, use the square root of the total number of features. 2. **Method Parameters for `fit`**: - `features` (np.ndarray): Training feature matrix of shape (N, M), where N is the number of samples and M is the number of features. - `target` (np.ndarray): Training target labels of shape (N,). 3. **Method Parameters for `predict`**: - `features` (np.ndarray): Test feature matrix of shape (N, M). 4. **Method Output for `predict`**: - Returns (np.ndarray): Array of predicted labels of shape (N,). 5. **Constraints**: - Assume binary classification (0 and 1 as labels). - Use decision trees of maximum depth 5 as base estimators. - Handle edge cases and ensure efficient computation. **Performance Requirements**: - Optimize for both time and space complexities. **Example**: ```python import numpy as np from sklearn.datasets import load_breast_cancer from sklearn.model_selection import train_test_split from sklearn.metrics import accuracy_score class CustomRandomForestClassifier: # Implement the class following the specifications above pass if __name__ == \\"__main__\\": # Load dataset data = load_breast_cancer() X, y = data.data, data.target # Split dataset X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Initialize and train the classifier clf = CustomRandomForestClassifier(n_estimators=100, max_features=4) clf.fit(X_train, y_train) # Predict and evaluate accuracy y_pred = clf.predict(X_test) accuracy = accuracy_score(y_test, y_pred) print(f\\"Accuracy: {accuracy:.2f}\\") ``` **Objective**: Demonstrate your understanding of random forest classification by implementing the algorithm to effectively address real-world binary classification tasks.","solution":"import numpy as np from sklearn.tree import DecisionTreeClassifier from typing import Tuple class CustomRandomForestClassifier: def __init__(self, n_estimators: int = 100, max_features: int = None): self.n_estimators = n_estimators self.max_features = max_features self.trees = [] def fit(self, features: np.ndarray, target: np.ndarray) -> None: n_samples, n_features = features.shape if self.max_features is None: self.max_features = int(np.sqrt(n_features)) else: self.max_features = min(self.max_features, n_features) self.max_features = max(1, self.max_features) # Ensure at least one feature is considered self.trees = [] for _ in range(self.n_estimators): tree = DecisionTreeClassifier(max_depth=5) sample_features, sample_target = self.bootstrap_sample(features, target) tree.fit(sample_features, sample_target) self.trees.append(tree) def predict(self, features: np.ndarray) -> np.ndarray: tree_preds = np.array([tree.predict(features) for tree in self.trees]) majority_vote = np.apply_along_axis(lambda x: np.bincount(x, minlength=2).argmax(), axis=0, arr=tree_preds) return majority_vote def bootstrap_sample(self, features: np.ndarray, target: np.ndarray) -> Tuple[np.ndarray, np.ndarray]: n_samples = features.shape[0] indices = np.random.choice(n_samples, n_samples, replace=True) return features[indices], target[indices]"},{"question":"# Twitter Data Fetcher You are tasked with creating a utility that fetches data from a given Twitter account using Twitter\'s API and processes the results to return specific fields requested by the user. This function should help in retrieving data relevant to specific needs (such as tweet text, creation date, or number of likes) from the most recent tweets of a specified Twitter account. # Function Signature ```python def get_twitter_data(user_handle: str, limit: int = 3, tweet_type: str = \\"recent\\", wanted_data: list | None = None) -> dict: ... ``` # Input Descriptions - `user_handle` (str): The Twitter handle of the user to query (e.g., \\"python_tip\\"). - `limit` (int, optional): The number of tweets to fetch. Default is 3. - `tweet_type` (str, optional): The type of tweets to fetch. It could be one of [\\"recent\\", \\"popular\\"]. Default is \\"recent\\". - `wanted_data` (list, optional): A list of specific fields to fetch from each tweet. If not provided, all data for each tweet will be returned. Possible values are: * \\"created_at\\", \\"id\\", \\"id_str\\", \\"text\\", \\"truncated\\", \\"entities\\", * \\"source\\", \\"in_reply_to_status_id\\", \\"in_reply_to_status_id_str\\", * \\"in_reply_to_user_id\\", \\"in_reply_to_user_id_str\\", \\"in_reply_to_screen_name\\", * \\"user\\", \\"geo\\", \\"coordinates\\", \\"place\\", \\"contributors\\", \\"is_quote_status\\", * \\"retweet_count\\", \\"favorite_count\\", \\"favorited\\", \\"retweeted\\", \\"possibly_sensitive\\", \\"lang\\". # Output Description The function should return a dictionary with the requested data fields for each tweet. The dictionary keys are the tweet indices (0 to `limit - 1`), and the values are dictionaries containing the available requested fields. # Constraints 1. If `wanted_data` contains fields not listed in the provided possible values, the function should raise a `ValueError` with an appropriate message. 2. In case of rate limiting or other network issues, the function should raise a `requests.HTTPError` with the response details. # Example ```python # Fetch 2 recent tweets from the \\"python_tip\\" account, requesting text, creation date, and number of likes result = get_twitter_data(\\"python_tip\\", limit=2, wanted_data=[\\"text\\", \\"created_at\\", \\"favorite_count\\"]) print(result) ``` # Expected Result: ```python { 0: { \'text\': \'Tweet text 1\', \'created_at\': \'Wed Aug 27 13:08:45 +0000 2008\', \'favorite_count\': 10 }, 1: { \'text\': \'Tweet text 2\', \'created_at\': \'Wed Aug 28 14:09:35 +0000 2008\', \'favorite_count\': 15 } } ``` # Additional Information Ensure the function has robust error handling for scenarios such as network failures, invalid user handles, and rate-limited responses. Validate the fields requested by the user against the provided list of possible values before making the API call.","solution":"import requests # Define the possible fields that can be fetched from a tweet POSSIBLE_FIELDS = [ \\"created_at\\", \\"id\\", \\"id_str\\", \\"text\\", \\"truncated\\", \\"entities\\", \\"source\\", \\"in_reply_to_status_id\\", \\"in_reply_to_status_id_str\\", \\"in_reply_to_user_id\\", \\"in_reply_to_user_id_str\\", \\"in_reply_to_screen_name\\", \\"user\\", \\"geo\\", \\"coordinates\\", \\"place\\", \\"contributors\\", \\"is_quote_status\\", \\"retweet_count\\", \\"favorite_count\\", \\"favorited\\", \\"retweeted\\", \\"possibly_sensitive\\", \\"lang\\" ] def get_twitter_data(user_handle: str, limit: int = 3, tweet_type: str = \\"recent\\", wanted_data: list = None) -> dict: Fetches and processes tweets from a specific Twitter account. :param user_handle: Twitter handle of the user to query. :param limit: Number of tweets to fetch. :param tweet_type: Type of tweets to fetch, \\"recent\\" or \\"popular\\". :param wanted_data: A list of specific fields to fetch from each tweet. :return: A dictionary with requested data fields for each tweet. if wanted_data: for field in wanted_data: if field not in POSSIBLE_FIELDS: raise ValueError(f\\"The field \'{field}\' is not a valid field to fetch.\\") url = f\\"https://api.twitter.com/2/tweets?screen_name={user_handle}&count={limit}&tweet_mode=extended\\" headers = { \\"Authorization\\": \\"Bearer YOUR_ACCESS_TOKEN\\" } response = requests.get(url, headers=headers) if response.status_code != 200: raise requests.HTTPError(f\\"Failed to fetch data: {response.status_code}, {response.text}\\") tweets = response.json() result = {} for i, tweet in enumerate(tweets): extracted_data = {field: tweet[field] for field in wanted_data} if wanted_data else tweet result[i] = extracted_data return result"},{"question":"# Question: Develop a Merge Sort Implementation with Additional Contextual Features Scenario As part of a larger data processing application, you are tasked with implementing a robust and efficient sorting algorithm. You choose to implement the merge sort algorithm due to its predictable O(n log n) performance. Beyond just sorting, the application needs to log key milestones of the process for audit purposes and provide insight into the depth of recursion and the number of merges performed. Task 1. Implement a class `MergeSortLogger` that performs merge sort. 2. The class should maintain and log the following: - The depth of each recursive call. - The number of merges that have occurred. - The snapshot of the array at specific milestones: after every merge. 3. Implement methods: - `sort(arr: List[int], depth: int = 0) -> List[int]`: Sorts the array `arr` and logs the required information. - `get_logs() -> Dict[str, Any]`: Returns the logged information (recursion depth, number of merges, and array snapshots). Input and Output Formats - **Input**: - `sort` method: A list of integers `arr` to sort and an optional `depth` parameter (used internally for logging recursion depth). - **Output**: - `sort` method: A sorted list of integers. - `get_logs` method: A dictionary containing: - `max_depth`: The maximum recursion depth reached. - `merge_count`: The total number of merges performed. - `snapshots`: A list of array snapshots taken after each merge. Constraints: - The list `arr` contains at most 10,000 integers. - Each integer in the list is between -10^5 and 10^5. - Ensure that the logging mechanism does not significantly degrade the performance of the sorting process. Implementation Hints: - Leverage a helper function for merging and logging states. - Use a recursive function call to handle the merge sort implementation. - Utilize appropriate data structures to store and retrieve log information. Requirements: - Implement error-checking where applicable. - Provide clear documentation and comments on the structure and flow of the algorithm. ```python from typing import List, Dict, Any class MergeSortLogger: def __init__(self): self.max_depth = 0 self.merge_count = 0 self.snapshots = [] def merge(self, left: List[int], right: List[int], depth: int) -> List[int]: merged = [] left_idx, right_idx = 0, 0 while left_idx < len(left) and right_idx < len(right): if left[left_idx] <= right[right_idx]: merged.append(left[left_idx]) left_idx += 1 else: merged.append(right[right_idx]) right_idx += 1 merged.extend(left[left_idx:]) merged.extend(right[right_idx:]) # Logging self.merge_count += 1 self.snapshots.append(list(merged)) return merged def sort(self, arr: List[int], depth: int = 0) -> List[int]: if depth > self.max_depth: self.max_depth = depth if len(arr) <= 1: return arr mid = len(arr) // 2 left_sorted = self.sort(arr[:mid], depth + 1) right_sorted = self.sort(arr[mid:], depth + 1) return self.merge(left_sorted, right_sorted, depth) def get_logs(self) -> Dict[str, Any]: return { \\"max_depth\\": self.max_depth, \\"merge_count\\": self.merge_count, \\"snapshots\\": self.snapshots } # Sample usage: # sorter = MergeSortLogger() # sorted_array = sorter.sort([5, 2, 9, 1, 5, 6, 7]) # logs = sorter.get_logs() # print(f\\"Sorted array: {sorted_array}\\") # print(f\\"Logs: {logs}\\") ``` **Note**: - Ensure that the output of your code matches the expected format. - Document any assumptions or decisions made during your implementation.","solution":"from typing import List, Dict, Any class MergeSortLogger: def __init__(self): self.max_depth = 0 self.merge_count = 0 self.snapshots = [] def merge(self, left: List[int], right: List[int], depth: int) -> List[int]: merged = [] left_idx, right_idx = 0, 0 while left_idx < len(left) and right_idx < len(right): if left[left_idx] <= right[right_idx]: merged.append(left[left_idx]) left_idx += 1 else: merged.append(right[right_idx]) right_idx += 1 merged.extend(left[left_idx:]) merged.extend(right[right_idx:]) # Logging self.merge_count += 1 self.snapshots.append(list(merged)) return merged def sort(self, arr: List[int], depth: int = 0) -> List[int]: if depth > self.max_depth: self.max_depth = depth if len(arr) <= 1: return arr mid = len(arr) // 2 left_sorted = self.sort(arr[:mid], depth + 1) right_sorted = self.sort(arr[mid:], depth + 1) return self.merge(left_sorted, right_sorted, depth) def get_logs(self) -> Dict[str, Any]: return { \\"max_depth\\": self.max_depth, \\"merge_count\\": self.merge_count, \\"snapshots\\": self.snapshots } # Sample usage: # sorter = MergeSortLogger() # sorted_array = sorter.sort([5, 2, 9, 1, 5, 6, 7]) # logs = sorter.get_logs() # print(f\\"Sorted array: {sorted_array}\\") # print(f\\"Logs: {logs}\\")"},{"question":"# Coding Assessment Question: Implementing a Custom LSTM Cell Context You are developing a recurrent neural network (RNN) for text generation tasks. To enhance the network\'s performance and flexibility, you decide to implement a custom Long Short-Term Memory (LSTM) cell. Objective Write a Python class to implement a basic LSTM cell and integrate it into a simple RNN for text generation. Requirements 1. **Class Name**: `CustomLSTMCell` 2. **Methods**: - `__init__(self, input_dim, hidden_dim)`: Initializes the LSTM cell parameters. - `forward(self, x, h_prev, c_prev)`: Computes the output and new cell state. 3. **Inputs**: - `x`: A numpy array of shape (batch_size, input_dim) representing the current input. - `h_prev`: A numpy array of shape (batch_size, hidden_dim) representing the previous hidden state. - `c_prev`: A numpy array of shape (batch_size, hidden_dim) representing the previous cell state. 4. **Outputs**: - `h_next`: A numpy array of shape (batch_size, hidden_dim) representing the next hidden state. - `c_next`: A numpy array of shape (batch_size, hidden_dim) representing the next cell state. Constraints * Do not use any libraries that abstract away the LSTM implementation (e.g., TensorFlow, PyTorch). * You may use numpy for matrix operations and basic math functions. * Assume input values will be in a reasonable range to avoid overflow errors. Performance Requirements * Ensure your implementation is efficient and leverages numpy\'s vectorized operations. * The space complexity should be O(batch_size * hidden_dim). Example ```python import numpy as np class CustomLSTMCell: def __init__(self, input_dim, hidden_dim): self.input_dim = input_dim self.hidden_dim = hidden_dim self.W_f = np.random.randn(input_dim + hidden_dim, hidden_dim) self.b_f = np.zeros((1, hidden_dim)) self.W_i = np.random.randn(input_dim + hidden_dim, hidden_dim) self.b_i = np.zeros((1, hidden_dim)) self.W_c = np.random.randn(input_dim + hidden_dim, hidden_dim) self.b_c = np.zeros((1, hidden_dim)) self.W_o = np.random.randn(input_dim + hidden_dim, hidden_dim) self.b_o = np.zeros((1, hidden_dim)) def forward(self, x, h_prev, c_prev): concat = np.concatenate((x, h_prev), axis=1) f_t = self.sigmoid(np.dot(concat, self.W_f) + self.b_f) i_t = self.sigmoid(np.dot(concat, self.W_i) + self.b_i) c_tilde = np.tanh(np.dot(concat, self.W_c) + self.b_c) c_next = f_t * c_prev + i_t * c_tilde o_t = self.sigmoid(np.dot(concat, self.W_o) + self.b_o) h_next = o_t * np.tanh(c_next) return h_next, c_next def sigmoid(self, x): return 1 / (1 + np.exp(-x)) input_dim = 5 hidden_dim = 10 batch_size = 3 x = np.random.randn(batch_size, input_dim) h_prev = np.random.randn(batch_size, hidden_dim) c_prev = np.random.randn(batch_size, hidden_dim) lstm_cell = CustomLSTMCell(input_dim, hidden_dim) h_next, c_next = lstm_cell.forward(x, h_prev, c_prev) print(\\"Next hidden state:\\", h_next) print(\\"Next cell state:\\", c_next) ``` Additional Task Integrate your custom LSTM cell into a simple RNN to generate text. The network should consist of: * An embedding layer converting text input to a suitable numeric format. * One LSTM layer using your `CustomLSTMCell`. * An output layer generating a probability distribution over the available characters. Document your code and provide a short summary (not more than 200 words) of the advantages of using LSTM cells over traditional RNN cells in text generation tasks.","solution":"import numpy as np class CustomLSTMCell: def __init__(self, input_dim, hidden_dim): self.input_dim = input_dim self.hidden_dim = hidden_dim self.W_f = np.random.randn(input_dim + hidden_dim, hidden_dim) self.b_f = np.zeros((1, hidden_dim)) self.W_i = np.random.randn(input_dim + hidden_dim, hidden_dim) self.b_i = np.zeros((1, hidden_dim)) self.W_c = np.random.randn(input_dim + hidden_dim, hidden_dim) self.b_c = np.zeros((1, hidden_dim)) self.W_o = np.random.randn(input_dim + hidden_dim, hidden_dim) self.b_o = np.zeros((1, hidden_dim)) def forward(self, x, h_prev, c_prev): concat = np.concatenate((x, h_prev), axis=1) f_t = self.sigmoid(np.dot(concat, self.W_f) + self.b_f) i_t = self.sigmoid(np.dot(concat, self.W_i) + self.b_i) c_tilde = np.tanh(np.dot(concat, self.W_c) + self.b_c) c_next = f_t * c_prev + i_t * c_tilde o_t = self.sigmoid(np.dot(concat, self.W_o) + self.b_o) h_next = o_t * np.tanh(c_next) return h_next, c_next def sigmoid(self, x): return 1 / (1 + np.exp(-x)) def create_lstm_rnn(text, char_to_idx, idx_to_char, lstm_cell, initial_hidden_state, initial_cell_state, num_chars_to_generate): hidden_state = initial_hidden_state cell_state = initial_cell_state x = np.zeros((1, len(char_to_idx))) generated_text = \\"\\" for _ in range(num_chars_to_generate): h_next, c_next = lstm_cell.forward(x, hidden_state, cell_state) hidden_state, cell_state = h_next, c_next predicted_char_idx = np.argmax(h_next.flatten()) generated_text += idx_to_char[predicted_char_idx] x = np.zeros((1, len(char_to_idx))) x[0, predicted_char_idx] = 1 return generated_text # Example of text generation setup chars = list(\\"abcdefghijklmnopqrstuvwxyz \\") char_to_idx = {char: idx for idx, char in enumerate(chars)} idx_to_char = {idx: char for idx, char in enumerate(chars)} input_dim = len(chars) hidden_dim = 10 batch_size = 1 # For simplicity, we\'ll use batch_size of 1 in this example x = np.random.randn(batch_size, input_dim) h_prev = np.zeros((batch_size, hidden_dim)) c_prev = np.zeros((batch_size, hidden_dim)) lstm_cell = CustomLSTMCell(input_dim, hidden_dim) num_chars_to_generate = 100 generated_text = create_lstm_rnn(\\"a quick brown fox\\", char_to_idx, idx_to_char, lstm_cell, h_prev, c_prev, num_chars_to_generate) print(\\"Generated text:\\", generated_text)"},{"question":"# Question Context Data structures are essential for managing and organizing data efficiently. Trees, in particular, provide hierarchical relationships between elements, which is useful in many applications such as parsers, file systems, and databases. Problem Statement You are tasked with implementing a binary search tree (BST) and a few basic operations on it. The BST should support insertion, searching, and finding the minimum and maximum values. # Function Signatures ```python class Node: Node represents a single element in the binary search tree. Attributes: value (int): The value of the node. left (Node): Pointer to the left child node. right (Node): Pointer to the right child node. def __init__(self, value: int): self.value = value self.left = None self.right = None class BinarySearchTree: BinarySearchTree supports insertion, searching, and finding minimum and maximum values. Attributes: root (Node): The root node of the binary search tree. def __init__(self): self.root = None def insert(self, value: int): Inserts a value into the binary search tree. :param value: The value to be inserted. if self.root is None: self.root = Node(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node: Node, value: int): Helper function to insert a value into the binary search tree recursively. :param node: The current node. :param value: The value to be inserted. if value < node.value: if node.left is None: node.left = Node(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = Node(value) else: self._insert_recursive(node.right, value) def search(self, value: int) -> bool: Searches for a value in the binary search tree. :param value: The value to search for. :return: True if the value is found, else False. return self._search_recursive(self.root, value) def _search_recursive(self, node: Node, value: int) -> bool: Helper function to search for a value in the binary search tree recursively. :param node: The current node. :param value: The value to search for. :return: True if the value is found, else False. if node is None: return False if value == node.value: return True elif value < node.value: return self._search_recursive(node.left, value) else: return self._search_recursive(node.right, value) def find_min(self) -> int: Finds the minimum value in the binary search tree. :return: The minimum value. if self.root is None: raise ValueError(\\"The tree is empty\\") return self._find_min_recursive(self.root) def _find_min_recursive(self, node: Node) -> int: Helper function to find the minimum value in the binary search tree recursively. :param node: The current node. :return: The minimum value. if node.left is None: return node.value else: return self._find_min_recursive(node.left) def find_max(self) -> int: Finds the maximum value in the binary search tree. :return: The maximum value. if self.root is None: raise ValueError(\\"The tree is empty\\") return self._find_max_recursive(self.root) def _find_max_recursive(self, node: Node) -> int: Helper function to find the maximum value in the binary search tree recursively. :param node: The current node. :return: The maximum value. if node.right is None: return node.value else: return self._find_max_recursive(node.right) ``` # Requirements: 1. **Class Implementation:** Correct implementation of BST including methods for insertion, searching, finding minimum, and maximum values. 2. **Edge Case Handling:** Proper handling of an empty tree when attempting to find the minimum or maximum values. 3. **Correct Recursion:** Proper use of recursion for insertion, searching, and finding min/max values. # Example: ```python # Example usage: bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) assert bst.search(10) == True assert bst.search(7) == False assert bst.find_min() == 3 assert bst.find_max() == 15 ``` # Additional Notes: * Ensure to handle the base cases for recursive methods correctly. * Implement the Node and BinarySearchTree classes based on the provided structure. * Testing is important. Add various test cases to ensure your implementations are robust.","solution":"class Node: Node represents a single element in the binary search tree. Attributes: value (int): The value of the node. left (Node): Pointer to the left child node. right (Node): Pointer to the right child node. def __init__(self, value: int): self.value = value self.left = None self.right = None class BinarySearchTree: BinarySearchTree supports insertion, searching, and finding minimum and maximum values. Attributes: root (Node): The root node of the binary search tree. def __init__(self): self.root = None def insert(self, value: int): Inserts a value into the binary search tree. :param value: The value to be inserted. if self.root is None: self.root = Node(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node: Node, value: int): Helper function to insert a value into the binary search tree recursively. :param node: The current node. :param value: The value to be inserted. if value < node.value: if node.left is None: node.left = Node(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = Node(value) else: self._insert_recursive(node.right, value) def search(self, value: int) -> bool: Searches for a value in the binary search tree. :param value: The value to search for. :return: True if the value is found, else False. return self._search_recursive(self.root, value) def _search_recursive(self, node: Node, value: int) -> bool: Helper function to search for a value in the binary search tree recursively. :param node: The current node. :param value: The value to search for. :return: True if the value is found, else False. if node is None: return False if value == node.value: return True elif value < node.value: return self._search_recursive(node.left, value) else: return self._search_recursive(node.right, value) def find_min(self) -> int: Finds the minimum value in the binary search tree. :return: The minimum value. if self.root is None: raise ValueError(\\"The tree is empty\\") return self._find_min_recursive(self.root) def _find_min_recursive(self, node: Node) -> int: Helper function to find the minimum value in the binary search tree recursively. :param node: The current node. :return: The minimum value. if node.left is None: return node.value else: return self._find_min_recursive(node.left) def find_max(self) -> int: Finds the maximum value in the binary search tree. :return: The maximum value. if self.root is None: raise ValueError(\\"The tree is empty\\") return self._find_max_recursive(self.root) def _find_max_recursive(self, node: Node) -> int: Helper function to find the maximum value in the binary search tree recursively. :param node: The current node. :return: The maximum value. if node.right is None: return node.value else: return self._find_max_recursive(node.right)"},{"question":"AVL Tree Deletion **Context**: You are tasked with improving the performance of a database indexing system by implementing a self-balancing binary search tree, specifically an AVL tree. AVL trees maintain their balance using rotations during insertions and deletions to ensure that the tree remains balanced, leading to faster query performance. **Task**: Implement the deletion method for an AVL tree. The method should remove a specified value from the tree while ensuring the AVL tree properties (balance factors and height balancing) are preserved. **Instructions**: 1. Complete the `delete` method for the `AVLTree` class. 2. Your method should handle various cases of deletion including nodes with no children, one child, and two children. 3. Implement necessary rotations (single and double) to maintain the AVL tree balance during deletion. **Input Format**: - An integer representing the value to be deleted. **Output Format**: - An AVL tree with the specified value removed, maintaining balanced properties. **Constraints**: - Values in the tree are unique. - The value to be deleted is guaranteed to be in the tree. ```python class AVLNode: def __init__(self, value): self.value = value self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def delete(self, root, value): Delete a value from the AVL tree and maintain balance. :param root: The root node of the AVL tree. :param value: The value to be deleted. :return: The new root of the AVL tree after deletion. # Find and delete the node if not root: return root if value < root.value: root.left = self.delete(root.left, value) elif value > root.value: root.right = self.delete(root.right, value) else: # Node with only one child or no child if root.left is None: temp = root.right root = None return temp elif root.right is None: temp = root.left root = None return temp # Node with two children: Get the inorder successor temp = self.get_min_value_node(root.right) root.value = temp.value root.right = self.delete(root.right, temp.value) # If the tree had only one node, return if root is None: return root # Update the height of the current node root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) # Get the balance factor balance = self.get_balance(root) # If the node becomes unbalanced, then there are 4 cases # Left Left Case if balance > 1 and self.get_balance(root.left) >= 0: return self.right_rotate(root) # Left Right Case if balance > 1 and self.get_balance(root.left) < 0: root.left = self.left_rotate(root.left) return self.right_rotate(root) # Right Right Case if balance < -1 and self.get_balance(root.right) <= 0: return self.left_rotate(root) # Right Left Case if balance < -1 and self.get_balance(root.right) > 0: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def get_min_value_node(self, node): current = node while current.left is not None: current = current.left return current def get_height(self, node): if not node: return 0 return node.height def get_balance(self, node): if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y # Example Usage: # avl = AVLTree() # root = None # values_to_insert = [10, 20, 30, 40, 50, 25] # for value in values_to_insert: # root = avl.insert(root, value) # root = avl.delete(root, 10) ``` # Output should maintain the AVL properties after each insertion and deletion.","solution":"class AVLNode: def __init__(self, value): self.value = value self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def delete(self, root, value): Delete a value from the AVL tree and maintain balance. :param root: The root node of the AVL tree. :param value: The value to be deleted. :return: The new root of the AVL tree after deletion. # Find and delete the node if not root: return root if value < root.value: root.left = self.delete(root.left, value) elif value > root.value: root.right = self.delete(root.right, value) else: # Node with only one child or no child if root.left is None: temp = root.right root = None return temp elif root.right is None: temp = root.left root = None return temp # Node with two children: Get the inorder successor temp = self.get_min_value_node(root.right) root.value = temp.value root.right = self.delete(root.right, temp.value) # If the tree had only one node, return if root is None: return root # Update the height of the current node root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) # Get the balance factor balance = self.get_balance(root) # If the node becomes unbalanced, then there are 4 cases # Left Left Case if balance > 1 and self.get_balance(root.left) >= 0: return self.right_rotate(root) # Left Right Case if balance > 1 and self.get_balance(root.left) < 0: root.left = self.left_rotate(root.left) return self.right_rotate(root) # Right Right Case if balance < -1 and self.get_balance(root.right) <= 0: return self.left_rotate(root) # Right Left Case if balance < -1 and self.get_balance(root.right) > 0: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def get_min_value_node(self, node): current = node while current.left is not None: current = current.left return current def get_height(self, node): if not node: return 0 return node.height def get_balance(self, node): if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def insert(self, root, key): Recursive insert method for the AVL Tree. :param root: The root node of the AVL tree. :param key: The value to be inserted. :return: The new root of the AVL tree after insertion. if not root: return AVLNode(key) if key < root.value: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) # Update the height of the ancestor node root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) # Get the balance factor balance = self.get_balance(root) # If the node becomes unbalanced, then there are 4 cases # Left Left Case if balance > 1 and key < root.left.value: return self.right_rotate(root) # Right Right Case if balance < -1 and key > root.right.value: return self.left_rotate(root) # Left Right Case if balance > 1 and key > root.left.value: root.left = self.left_rotate(root.left) return self.right_rotate(root) # Right Left Case if balance < -1 and key < root.right.value: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root"},{"question":"# Question: Neural Network Implementation for Binary Classification Context You are required to implement a simple feedforward neural network for binary classification task. The dataset contains two features and one binary target. Task Implement a class `SimpleNN` that performs binary classification. The network should have a single hidden layer. Then, use this network to fit the given training data and make predictions on new data points. Classes and Methods 1. **SimpleNN** - **Constructor**: - `__init__(self, input_dim: int, hidden_dim: int) -> None`: Initializes the network with the provided dimensions for the input and hidden layers. The weights should be initialized using a uniform distribution, and biases should be initialized to zero. - **Sigmoid Activation**: - `_sigmoid(self, z: np.ndarray) -> np.ndarray`: Computes the sigmoid activation of z. - **Forward Pass**: - `forward(self, X: np.ndarray) -> np.ndarray`: Performs a forward pass through the network to compute the output probabilities. - **Fit Model**: - `fit(self, X_train: np.ndarray, y_train: np.ndarray, epochs: int, learning_rate: float) -> None`: Trains the network using gradient descent. - **Predict Classes**: - `predict(self, X: np.ndarray) -> np.ndarray`: Predicts binary class labels for the input data. - **Compute Accuracy**: - `accuracy(self, X: np.ndarray, y: np.ndarray) -> float`: Computes the accuracy of the model on given data. Input and Output Format - **Method: `__init__`** - **Input**: - `input_dim`: Integer representing the number of input features. - `hidden_dim`: Integer representing the number of neurons in the hidden layer. - **Method: `fit`** - **Input**: - `X_train`: 2D `np.ndarray` of shape `(n_samples, n_features)` representing the input training data. - `y_train`: 1D `np.ndarray` of shape `(n_samples,)` representing the binary target values. - `epochs`: Integer representing the number of training epochs. - `learning_rate`: Float representing the learning rate for gradient descent. - **Method: `predict`** - **Input**: - `X`: 2D `np.ndarray` of shape `(n_samples, n_features)` representing the input data for predictions. - **Output**: - Returns a 1D `np.ndarray` of binary class predictions. - **Method: `accuracy`** - **Input**: - `X`: 2D `np.ndarray` of shape `(n_samples, n_features)` representing the input data. - `y`: 1D `np.ndarray` of shape `(n_samples,)` representing the binary target values. - **Output**: - Returns a float representing the classification accuracy. Example Usage ```python import numpy as np class SimpleNN: def __init__(self, input_dim, hidden_dim): self.input_dim = input_dim self.hidden_dim = hidden_dim self.W1 = np.random.uniform(-1, 1, (input_dim, hidden_dim)) self.b1 = np.zeros(hidden_dim) self.W2 = np.random.uniform(-1, 1, hidden_dim) self.b2 = 0 def _sigmoid(self, z): return 1 / (1 + np.exp(-z)) def forward(self, X): self.z1 = np.dot(X, self.W1) + self.b1 self.a1 = self._sigmoid(self.z1) self.z2 = np.dot(self.a1, self.W2) + self.b2 output = self._sigmoid(self.z2) return output def fit(self, X_train, y_train, epochs, learning_rate): for _ in range(epochs): output = self.forward(X_train) dz2 = output - y_train dW2 = np.dot(self.a1.T, dz2) / X_train.shape[0] db2 = np.sum(dz2) / X_train.shape[0] da1 = np.dot(dz2, self.W2.T) * (self.a1 * (1 - self.a1)) dW1 = np.dot(X_train.T, da1) / X_train.shape[0] db1 = np.sum(da1, axis=0) / X_train.shape[0] self.W2 -= learning_rate * dW2 self.b2 -= learning_rate * db2 self.W1 -= learning_rate * dW1 self.b1 -= learning_rate * db1 def predict(self, X): output = self.forward(X) return (output >= 0.5).astype(int) def accuracy(self, X, y): predictions = self.predict(X) return np.mean(predictions == y) # Example Data X_train = np.array([[0, 0], [0, 1], [1, 0], [1, 1]]) y_train = np.array([0, 1, 1, 0]) # Train model model = SimpleNN(input_dim=2, hidden_dim=2) model.fit(X_train, y_train, epochs=10000, learning_rate=0.1) # Predictions X_test = np.array([[0, 0], [0, 1], [1, 0], [1, 1]]) predictions = model.predict(X_test) accuracy = model.accuracy(X_test, y_train) print(predictions) # Output: [0, 1, 1, 0] print(accuracy) # Output: 1.0 ``` Constraints - Ensure input data `X_train`, `y_train`, and `X_test` are numpy arrays. - Number of epochs and learning rate must be positive values.","solution":"import numpy as np class SimpleNN: def __init__(self, input_dim, hidden_dim): self.input_dim = input_dim self.hidden_dim = hidden_dim self.W1 = np.random.uniform(-1, 1, (input_dim, hidden_dim)) self.b1 = np.zeros((1, hidden_dim)) self.W2 = np.random.uniform(-1, 1, (hidden_dim, 1)) self.b2 = np.zeros((1, 1)) def _sigmoid(self, z): return 1 / (1 + np.exp(-z)) def forward(self, X): self.z1 = np.dot(X, self.W1) + self.b1 self.a1 = self._sigmoid(self.z1) self.z2 = np.dot(self.a1, self.W2) + self.b2 output = self._sigmoid(self.z2) return output def fit(self, X_train, y_train, epochs, learning_rate): y_train = y_train.reshape(-1, 1) for _ in range(epochs): output = self.forward(X_train) dz2 = output - y_train dW2 = np.dot(self.a1.T, dz2) / X_train.shape[0] db2 = np.sum(dz2, axis=0, keepdims=True) / X_train.shape[0] da1 = np.dot(dz2, self.W2.T) * (self.a1 * (1 - self.a1)) dW1 = np.dot(X_train.T, da1) / X_train.shape[0] db1 = np.sum(da1, axis=0, keepdims=True) / X_train.shape[0] self.W2 -= learning_rate * dW2 self.b2 -= learning_rate * db2 self.W1 -= learning_rate * dW1 self.b1 -= learning_rate * db1 def predict(self, X): output = self.forward(X) return (output >= 0.5).astype(int) def accuracy(self, X, y): predictions = self.predict(X) return np.mean(predictions.flatten() == y) # Example Data X_train = np.array([[0, 0], [0, 1], [1, 0], [1, 1]]) y_train = np.array([0, 1, 1, 0]) # Train model model = SimpleNN(input_dim=2, hidden_dim=2) model.fit(X_train, y_train, epochs=10000, learning_rate=0.1) # Predictions X_test = np.array([[0, 0], [0, 1], [1, 0], [1, 1]]) predictions = model.predict(X_test) accuracy = model.accuracy(X_test, y_train) print(predictions.flatten()) # Output: [0, 1, 1, 0] print(accuracy) # Output: 1.0"},{"question":"# String Reversal Challenge Given different methods for reversing a string, implement four functions in Python to reverse a given string `s` using: 1. A recursive approach. 2. An iterative approach. 3. Python\'s `reversed()` function. 4. Python slicing. Each function should follow these specifications: - **Input**: A string `s` with length (0 leq |s| leq 10^6). - **Output**: The reversed string. Function Signatures ```python def reverse_recursive(s: str) -> str: pass def reverse_iterative(s: str) -> str: pass def reverse_pythonic(s: str) -> str: pass def reverse_ultra_pythonic(s: str) -> str: pass ``` Constraints - Ensure your methods handle empty strings and strings containing special characters or spaces appropriately. - Aim for optimal time and space complexity. Example ```python reverse_recursive(\\"hello\\") -> \\"olleh\\" reverse_iterative(\\"world\\") -> \\"dlrow\\" reverse_pythonic(\\"Python\\") -> \\"nohtyP\\" reverse_ultra_pythonic(\\"Reverse\\") -> \\"esreveR\\" ``` Context You are tasked with reversing strings in a text processing application. Depending on different scenarios, you may need to use different strategies for reversing strings. Optimize the function to balance readability, performance, and memory use per the outlined constraints.","solution":"def reverse_recursive(s: str) -> str: Reverse a string using a recursive approach. if len(s) == 0: return s return reverse_recursive(s[1:]) + s[0] def reverse_iterative(s: str) -> str: Reverse a string using an iterative approach. reversed_str = [] for char in s: reversed_str.insert(0, char) return \'\'.join(reversed_str) def reverse_pythonic(s: str) -> str: Reverse a string using Python\'s reversed() function. return \'\'.join(reversed(s)) def reverse_ultra_pythonic(s: str) -> str: Reverse a string using Python slicing. return s[::-1]"},{"question":"Context A trie (pronounced as \\"try\\") is an efficient information retrieval data structure that is used for searching words in a dictionary with a given prefix. In this task, you will implement core operations for a trie data structure to solidify your understanding of how these structures work and can be utilized. Problem Statement You are to implement a trie from scratch. The trie should support three primary operations: `insert`, `search`, and `starts_with`. Function Signatures Implement a class `Trie` with the following methods: 1. **insert(word: str) -> None**: Inserts the string `word` into the trie. 2. **search(word: str) -> bool**: Returns `True` if the string `word` is in the trie (i.e., was inserted before), and `False` otherwise. 3. **starts_with(prefix: str) -> bool**: Returns `True` if there is any string in the trie that starts with the given `prefix`, and `False` otherwise. Constraints 1. All inputs are lowercase English letters (`a`-`z`). 2. 1 <= word length <= 100. 3. At most 10⁴ calls will be made to `insert`, `search`, and `starts_with` combined. Examples ```python # Example usage: trie = Trie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # Returns True print(trie.search(\\"app\\")) # Returns False print(trie.starts_with(\\"app\\")) # Returns True trie.insert(\\"app\\") print(trie.search(\\"app\\")) # Returns True ``` **Notes**: * It\'s important not to confuse the `search` method with `starts_with`. The `search` method checks if an entire word is present in the Trie, whereas `starts_with` checks if any word starts with a given prefix. * Handle edge cases such as inserting empty strings gracefully (though in the constraints, we\'re guaranteed non-empty strings). **Requirements**: * Define a class `TrieNode` for trie nodes with appropriate data structures for children and an end-of-word mark. * Define a class `Trie` with methods for `insert`, `search`, and `starts_with`, adhering to the expected time complexities for optimal performance.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"# Full Path to Validated Absolute Path Context You are implementing a file management tool that takes user-provided file paths and performs various operations on these files. Before performing any operations, you need to ensure that the path provided is valid and absolute. Task Description Write a function `validated_full_path(file_path)` that takes a single string argument `file_path`, representing a file path. The function should follow these steps: 1. Expand user short-cuts like `~` to the actual path. 2. Convert relative paths to absolute paths. 3. Validate that the path refers to an existing file or directory. The function should `return` the absolute path if it\'s valid. If the path does not exist, raise a `ValueError` with the message `\\"The path does not exist\\"`. Input and Output Formats - **Input**: - A single string `file_path`, which can be a relative path, absolute path, or a path with user shorthand `~`. - **Output**: - A single string representing the validated absolute path. - If the path does not exist, raise a `ValueError`. Example ```python validated_full_path(\\"~/documents/example.txt\\") # Returns: \'/home/user/documents/example.txt\' (or similar absolute path based on user\'s home directory) validated_full_path(\\"./main.py\\") # Returns: \'/absolute/path/to/current/directory/main.py\' validated_full_path(\\"/etc/hosts\\") # Returns: \'/etc/hosts\' validated_full_path(\\"/nonexistent/path/file.txt\\") # Raises ValueError: The path does not exist ``` Constraints - You can assume the input is always a non-empty string. - The function should work on both UNIX-like systems and Windows.","solution":"import os def validated_full_path(file_path): Expands and validates the given file path. Parameters: file_path (str): The file path to validate and expand. Returns: str: The validated absolute path. Raises: ValueError: If the path does not exist. # Expand user shorthand and convert to absolute path expanded_path = os.path.expanduser(file_path) absolute_path = os.path.abspath(expanded_path) # Check if the path exists if not os.path.exists(absolute_path): raise ValueError(\\"The path does not exist\\") return absolute_path"},{"question":"# Question Title: Advanced Run-Length Encoding and Decoding with Validations Description: Implement an enhanced version of the Run-Length Encoding (RLE) and Decoding functions. In addition to encoding and decoding, your implementation needs to handle edge cases gracefully and include a validation mechanism to verify the encoded string before decoding. Function Signatures: ```python def enhanced_encode_rle(input: str) -> str: pass def enhanced_decode_rle(input: str) -> str: pass def validate_encoded_rle(input: str) -> bool: Validates the encoded RLE string format. :param input: The encoded RLE string to be validated. :return: True if the encoded string is valid RLE format, False otherwise. pass ``` Functionality: 1. `enhanced_encode_rle(input: str) -> str`: Encodes the input string using RLE, with handling for edge cases such as empty inputs. 2. `enhanced_decode_rle(input: str) -> str`: Decodes the RLE string back to its original form, provided the string is in a valid encoded format. 3. `validate_encoded_rle(input: str) -> bool`: Validates if the provided encoded string conforms to acceptable RLE format. Input: - `enhanced_encode_rle` and `enhanced_decode_rle`: - `input`: A string containing the data to be encoded or decoded. - `validate_encoded_rle`: - `input`: An RLE encoded string. Output: - `enhanced_encode_rle` and `enhanced_decode_rle`: - Returns a string that represents either the encoded or decoded data. - `validate_encoded_rle`: - Returns `True` if the input string is a valid encoded RLE format, `False` otherwise. Constraints: - Assume input strings will contain only alphanumeric characters. - Handle both upper-case and lower-case characters distinctly. Example: ```python # Encode print(enhanced_encode_rle(\\"aaabbbcccaaa\\")) # Output: \\"3a3b3c3a\\" # Decode print(enhanced_decode_rle(\\"3a3b3c3a\\")) # Output: \\"aaabbbcccaaa\\" # Validate print(validate_encoded_rle(\\"3a3b3c3a\\")) # Output: True print(validate_encoded_rle(\\"3a3b3ca\\")) # Output: False ``` # Additional Notes: - Proper error handling is crucial. For example, `enhanced_decode_rle` should validate the input format using `validate_encoded_rle` before attempting to decode it and return an appropriate message or handle the error gracefully if the format is invalid. - Consider edge cases and document any assumptions or limitations in your code comments.","solution":"def enhanced_encode_rle(input: str) -> str: if not input: return \\"\\" encoded_str = [] i = 0 while i < len(input): count = 1 while i + 1 < len(input) and input[i] == input[i + 1]: i += 1 count += 1 encoded_str.append(f\\"{count}{input[i]}\\") i += 1 return \'\'.join(encoded_str) def enhanced_decode_rle(input: str) -> str: if not validate_encoded_rle(input): raise ValueError(\\"Invalid encoded RLE string format\\") decoded_str = [] i = 0 while i < len(input): j = i while j < len(input) and input[j].isdigit(): j += 1 count = int(input[i:j]) decoded_str.append(input[j] * count) i = j + 1 return \'\'.join(decoded_str) def validate_encoded_rle(input: str) -> bool: if not input: return True i = 0 while i < len(input): if not input[i].isdigit(): return False j = i while j < len(input) and input[j].isdigit(): j += 1 if j == i: return False if j >= len(input) or not input[j].isalpha(): return False i = j + 1 return True"},{"question":"You are provided with two implementations of post-order traversal of a binary tree: recursive and iterative. Your task is to enhance the iterative implementation to avoid the use of an additional list for storing intermediate results. Also, to deepen your understanding, you need to implement another function to check if two binary trees are identical. # Function 1: Enhanced Iterative Post-order Traversal Implement an optimized version of the `postorder` function by avoiding the usage of the `res_temp` list. The function signature is: ```python def enhanced_postorder(root: Node) -> list[int]: # Your code here ``` # Function 2: Check Identical Trees Implement a function to determine if two binary trees are identical. Two binary trees are considered identical if they have the same structure and node values. The function signature is: ```python def is_identical(tree1: Node, tree2: Node) -> bool: # Your code here ``` **Input and Output**: - For `enhanced_postorder`, the input is the root node of the binary tree, and the output is a list of integers in post-order traversal. - For `is_identical`, the inputs are the roots of two binary trees, and the output is a boolean indicating whether the two trees are identical. **Constraints**: - The number of nodes in the binary tree is in the range [0, 1000]. - Node values are integers and can be negative. ```python # Example Usage: # Construct trees as necessary and test both functions root1 = Node(1, Node(2), Node(3)) root2 = Node(1, Node(2), Node(3)) print(enhanced_postorder(root1)) # Output: [2, 3, 1] print(is_identical(root1, root2)) # Output: True root3 = Node(1, Node(2)) print(is_identical(root1, root3)) # Output: False ```","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def enhanced_postorder(root: Node) -> list[int]: if not root: return [] result = [] stack = [(root, False)] while stack: node, visited = stack.pop() if node: if visited: # Add to result if visited result.append(node.value) else: # Post-order: Push current node back with visited flag as True stack.append((node, True)) # Now push right and left children to be visited first if node.right: stack.append((node.right, False)) if node.left: stack.append((node.left, False)) return result def is_identical(tree1: Node, tree2: Node) -> bool: if not tree1 and not tree2: return True if tree1 and tree2: return (tree1.value == tree2.value and is_identical(tree1.left, tree2.left) and is_identical(tree1.right, tree2.right)) return False"},{"question":"**Problem Statement:** You are given a list of integers. Your task is to construct a Binary Search Tree (BST) from the integers and implement a function to perform an in-order traversal of the BST. The traversal should be printed as a list of integers in ascending order. **Function Signature:** ```python def create_bst(nums: List[int]) -> TreeNode: # Create the BST from the list of integers pass def inorder_traversal(root: TreeNode) -> List[int]: # Traverse the BST in-order and return the sorted elements pass ``` **Input:** - `nums`: A list of integers `nums`, where `1 <= len(nums) <= 1000` and each integer `-10^9 <= nums[i] <= 10^9`. **Output:** - The `inorder_traversal` function should return a list of integers representing the BST elements in ascending order. **Constraints:** - The tree should not include duplicates. - The solution should be efficient, with average insertion and traversal operations running in O(log n) and O(n) time complexities respectively. **Scenario:** You are building an application that manages a large set of numerical data entries. To ensure fast data retrieval, an efficient data structure such as BST is needed. Your task includes implementing the BST construction and in-order traversal to maintain and utilize sorted data effectively. **Examples:** ```python # Example 1: nums = [8, 3, 10, 1, 6, 14, 4, 7, 13] root = create_bst(nums) assert inorder_traversal(root) == [1, 3, 4, 6, 7, 8, 10, 13, 14] # Example 2: nums = [20, 5, 25, 3, 8, 30] root = create_bst(nums) assert inorder_traversal(root) == [3, 5, 8, 20, 25, 30] ``` Note: - Ensure your solution optimizes insertion to avoid unbalanced tree situations. - Focus on handling edge cases appropriately. **Hint:** Consider using a helper function to perform the insertion in the BST and ensure that the recursion depth is managed efficiently.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root, val): if root is None: return TreeNode(val) if val < root.val: root.left = insert_into_bst(root.left, val) elif val > root.val: root.right = insert_into_bst(root.right, val) return root def create_bst(nums): root = None for num in nums: root = insert_into_bst(root, num) return root def inorder_traversal(root): result = [] def traverse(node): if not node: return traverse(node.left) result.append(node.val) traverse(node.right) traverse(root) return result"},{"question":"# Scenario: You are developing a text editor that supports an undo feature. You decided to use a Doubly Linked List for storing the sequence of operations. Your task is to implement a function to insert text at a specific position and another to undo the last operation. # Task: **Implement the following functions in Python:** 1. `insert_text(dll, position, text)`: * **Input**: A doubly linked list `dll`, an integer `position`, and a string `text`. * **Output**: Modify the doubly linked list by inserting a new node with value `text` at the specified position. The position is 0-based. * **Constraints**: * If position is out of bounds, raise an `IndexError`. * Time complexity should be optimal for insertion (i.e., O(1) if the position is known). 2. `undo_last_operation(dll)`: * **Input**: A doubly linked list `dll`. * **Output**: Remove the last inserted node in the doubly linked list. * **Constraints**: * If the list is empty, raise a `ValueError`. * Time complexity should be O(1). # Examples: ```python # Example 1: dll = DoublyLinkedList() insert_text(dll, 0, \\"Hello\\") # Now dll contains: \\"Hello\\" # Example 2: insert_text(dll, 1, \\"World\\") # Now dll contains: \\"Hello\\" -> \\"World\\" # Example 3: undo_last_operation(dll) # Now dll contains: \\"Hello\\" ``` # Notes: 1. You need to define the `DoublyLinkedList` class and methods `insert_text` and `undo_last_operation`. 2. Consider edge cases such as inserting at the head or tail, and an empty list. 3. Ensure efficient handling and error reporting for out-of-bound positions and empty list scenarios.","solution":"class Node: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None self.length = 0 def insert_text(self, position, text): if position < 0 or position > self.length: raise IndexError(\\"Position out of bounds\\") new_node = Node(text) if self.length == 0: self.head = self.tail = new_node elif position == 0: new_node.next = self.head self.head.prev = new_node self.head = new_node elif position == self.length: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node else: current = self.head for _ in range(position): current = current.next new_node.prev = current.prev new_node.next = current current.prev.next = new_node current.prev = new_node self.length += 1 def undo_last_operation(self): if self.length == 0: raise ValueError(\\"No operations to undo\\") if self.length == 1: self.head = self.tail = None else: self.tail = self.tail.prev self.tail.next = None self.length -= 1 def to_list(self): values = [] current = self.head while current: values.append(current.value) current = current.next return values"},{"question":"Implement a function `longest_palindrome(s: str) -> str` that takes a string `s` and returns its longest palindromic substring. Your solution should use Manacher\'s Algorithm to achieve an optimal runtime of O(n). Input - `s`: A string of length `n` (0 <= n <= 10^4) containing lowercase and/or uppercase letters. Output - A string representing the longest palindromic substring within the input string. Constraints - When there are multiple palindromic substrings of the same maximum length, return the one that appears first. Example ```python assert longest_palindrome(\\"babad\\") in [\\"bab\\", \\"aba\\"] assert longest_palindrome(\\"cbbd\\") == \\"bb\\" assert longest_palindrome(\\"a\\") == \\"a\\" assert longest_palindrome(\\"\\") == \\"\\" ``` # Instructions 1. Your function should achieve linear runtime using Manacher\'s Algorithm. 2. Carefully handle edge cases such as empty strings or single-character strings. 3. Use Python and ensure your solution is efficient.","solution":"def longest_palindrome(s: str) -> str: if not s: return \\"\\" # Preprocess the string to insert boundaries # For example, \'abba\' -> \'@#a#b#b#a#\' (with @ and as sentinels) t = \'@#\' + \'#\'.join(s) + \'#\' n = len(t) p = [0] * n center = right = 0 for i in range(1, n-1): if i < right: p[i] = min(right - i, p[2*center - i]) while t[i + p[i] + 1] == t[i - p[i] - 1]: p[i] += 1 if i + p[i] > right: center, right = i, i + p[i] # Find the maximum element in p max_len = max(p) center_index = p.index(max_len) start = (center_index - max_len) // 2 return s[start:start + max_len]"},{"question":"You are given a Markov Chain defined as described below. Implement two functions: 1. `generate_sequence(chain, start_state, iterations)`: - **Input**: - `chain`: A dictionary representing the Markov chain where keys are states and values are dictionaries of next state probabilities. - `start_state`: The starting state in the Markov Chain. - `iterations`: The number of transitions to generate. - **Output**: A list of states representing the sequence of states visited starting from the `start_state` up to the given number of iterations. 2. `is_valid_chain(chain)`: - **Input**: - `chain`: A dictionary representing the Markov chain. - **Output**: A boolean value indicating whether the chain is valid. A valid chain: - Has non-negative probabilities. - All states must lead to other states, including themselves. - The sum of probabilities from each state must be 1. # Example: ```python chain = { \'A\': {\'A\': 0.6, \'B\': 0.4}, \'B\': {\'A\': 0.7, \'B\': 0.3} } # Example usage: sequence = generate_sequence(chain, \'A\', 5) # Possible output: [\'B\', \'A\', \'A\', \'B\', \'A\'] valid = is_valid_chain(chain) # Output: True invalid_chain = { \'A\': {\'A\': 0.5, \'B\': 0.4}, \'B\': {\'A\': 0.7, \'B\': 0.4} } valid = is_valid_chain(invalid_chain) # Output: False, because the sum of probabilities from \'A\' is not equal to 1 (0.5 + 0.4 = 0.9) ``` **Constraints**: * The states in the chain are assumed to be unique strings. * The number of states and transitions can be up to 1000. * The probability values will be given as floats.","solution":"import random def generate_sequence(chain, start_state, iterations): Generates a sequence of states in a Markov Chain. :param chain: Dictionary, the Markov chain. :param start_state: The starting state. :param iterations: Number of transitions to generate. :return: List of states visited in sequence. current_state = start_state sequence = [current_state] for _ in range(iterations): next_state = _get_next_state(chain[current_state]) sequence.append(next_state) current_state = next_state return sequence def _get_next_state(probabilities): Helper function to determine the next state based on probabilities. :param probabilities: Dictionary of state probabilities. :return: The next state. states = list(probabilities.keys()) probs = list(probabilities.values()) next_state = random.choices(states, weights=probs, k=1)[0] return next_state def is_valid_chain(chain): Validates whether the given Markov chain is valid. :param chain: Dictionary, the Markov chain. :return: Boolean, True if the chain is valid, False otherwise. for state, transitions in chain.items(): total_prob = sum(transitions.values()) if not (abs(total_prob - 1.0) < 1e-9): # Floating point precision check return False for probability in transitions.values(): if probability < 0: return False return True"},{"question":"**Context**: You are required to manage the dynamic connectivity of a set of elements represented on a 2D grid. Each element can either be land or water. An island is defined as a maximal set of connected land elements (connected horizontally or vertically). Initially, all cells of the grid contain water. When a position is added, it turns into land. After each addition, you need to determine the number of islands in the grid. **Problem**: Implement a function `num_islands` that takes a list of positions where land is added one at a time and returns a list of the number of islands after each addition. **Function Signature**: ```python def num_islands(positions: List[Tuple[int, int]]) -> List[int]: ``` **Input**: - `positions`: A list of tuples, where each tuple contains two integers representing the coordinates (row, column) on the grid where land is added sequentially. Each tuple represents an `addLand` operation. **Output**: - Returns a list of integers. Each integer represents the number of islands after the corresponding `addLand` operation. **Constraints**: - The grid coordinates are non-negative integers. - Grid size is not fixed and can increase dynamically based on the positions added. - Assume each addLand operation adds a position unique for that moment. **Performance Requirement**: - Optimized for a potentially large number of positions. Aim to achieve near constant time complexity per operation using efficient data structures. # Examples: Example 1: ```python positions = [(0, 0), (0, 1), (1, 2), (2, 1)] print(num_islands(positions)) # Output: [1, 1, 2, 3] ``` Explanation: - Initially, all grid cells are water. - After (0, 0), number of islands = 1. - After (0, 1), it connects with (0, 0), so number of islands = 1. - After (1, 2), it is isolated, so number of islands = 2. - After (2, 1), it is also isolated, so number of islands = 3. **Implementation Note**: You are encouraged to use the Union-Find (Disjoint Set) data structure to efficiently manage the dynamic connectivity of the grid elements.","solution":"from typing import List, Tuple class UnionFind: def __init__(self): self.parent = {} self.rank = {} self.count = 0 # Number of connected components (islands) def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def add(self, x): if x not in self.parent: self.parent[x] = x self.rank[x] = 0 self.count += 1 def num_islands(positions: List[Tuple[int, int]]) -> List[int]: def get_neighbors(x, y): return [(x-1, y), (x+1, y), (x, y-1), (x, y+1)] uf = UnionFind() result = [] land_positions = set() for x, y in positions: if (x, y) in land_positions: result.append(uf.count) continue land_positions.add((x, y)) uf.add((x, y)) for nx, ny in get_neighbors(x, y): if (nx, ny) in land_positions: uf.union((x, y), (nx, ny)) result.append(uf.count) return result"},{"question":"# Matrix Manipulation Assessment **Objective**: Implement optimized matrix transformations that rotate a matrix 90 degrees either clockwise or counterclockwise, and invert it from top-left or bottom-left, ensuring efficiency and correctness. # Task Write a Python function for each of the following transformations: 1. **rotate_clockwise(matrix)**: Rotates the given matrix 90 degrees clockwise. 2. **rotate_counterclockwise(matrix)**: Rotates the given matrix 90 degrees counterclockwise. 3. **top_left_invert(matrix)**: Inverts the given matrix relative to the top-left to bottom-right diagonal. 4. **bottom_left_invert(matrix)**: Inverts the given matrix relative to the bottom-left to top-right diagonal. # Requirements - Each function should accept a square matrix (a list of lists where each sublist has the same length as the number of sublists) and return the transformed matrix. - Assume the input matrix is always valid and square. - Optimize your implementation for efficiency in terms of both time and space. # Input - A square matrix `matrix` of dimensions `n x n` where `1 <= n <= 100`. # Output - The transformed matrix according to the specified rotation or inversion operation. # Constraints 1. **rotate_clockwise(matrix)**: - Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_clockwise(matrix) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` 2. **rotate_counterclockwise(matrix)**: - Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_counterclockwise(matrix) # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] ``` 3. **top_left_invert(matrix)**: - Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] top_left_invert(matrix) # Output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] ``` 4. **bottom_left_invert(matrix)**: - Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] bottom_left_invert(matrix) # Output: # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1] # ] ```","solution":"def rotate_clockwise(matrix): n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def rotate_counterclockwise(matrix): n = len(matrix) return [[matrix[j][n - i - 1] for j in range(n)] for i in range(n)] def top_left_invert(matrix): n = len(matrix) return [[matrix[j][i] for j in range(n)] for i in range(n)] def bottom_left_invert(matrix): n = len(matrix) return [[matrix[n - j - 1][n - i - 1] for j in range(n)] for i in range(n)]"},{"question":"# Single-Row Keyboard Typing You are given a list of words. Your task is to write a function that returns the words that can be typed using letters from only one row on an American QWERTY keyboard. Input * A list of words, where each word consists of only alphabetic characters (both uppercase and lowercase) and has length 1 to 100. * You may assume that each word is a valid non-empty string. Output * A list of words that can be typed using letters of the alphabet on only one row of an American QWERTY keyboard. * Words should maintain their original casing in the output list. Example ```python Input: [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] Output: [\\"Alaska\\", \\"Dad\\"] ``` Constraints * All input will be valid and fit within typical memory and time limitations for competitive programming. * Performance requirements are secondary to correctness but strive for efficiency. Context This problem is used to test your understanding of filtering and set operations. It\'s essential to normalize the case of the letters in the words, thoroughly check inclusion in sets, and handle edge cases like mixed-case letters effectively. Function Signature ```python def find_keyboard_row(words: list[str]) -> list[str]: pass ``` **Note**: Do not use any imported libraries outside of those available in standard Python without explicit permission.","solution":"def find_keyboard_row(words): Given a list of words, return the words that can be typed using letters from only one row on an American QWERTY keyboard. rows = [ set(\\"qwertyuiop\\"), set(\\"asdfghjkl\\"), set(\\"zxcvbnm\\"), ] def can_be_typed_on_one_row(word): lowercase_word = word.lower() return any(set(lowercase_word).issubset(row) for row in rows) return [word for word in words if can_be_typed_on_one_row(word)]"},{"question":"# Find the nth Digit in a Continuous Sequence Scenario Suppose you have a giant digit sequence formed by concatenating all positive integers in order: \\"12345678910111213...\\". You are required to find the nth digit of this sequence. Problem Statement Implement a function `find_nth_digit(n)` that will take a single integer `n` and return the nth digit in this sequence. Input - A single integer `n`. (1 ≤ n ≤ 2*10^9) Output - A single integer representing the nth digit in the concatenated sequence of all positive integers. Constraints - The input value `n` will be positive and within the range `1 ≤ n ≤ 2*10^9`. - Floating point arithmetic should be handled carefully to avoid precision errors. Performance Requirements - The solution should be efficient in terms of both time and space complexity, considering the upper limit of `n`. Example Cases # Example 1 Input: ```plaintext 3 ``` Output: ```plaintext 3 ``` # Example 2 Input: ```plaintext 11 ``` Output: ```plaintext 0 ``` # Example 3 Input: ```plaintext 15 ``` Output: ```plaintext 2 ``` Implementation Details 1. **Length Computation**: Identify the number length where the digit is located. 2. **Number Identification**: Determine the actual number containing the nth digit. 3. **Digit Extraction**: Extract and return the desired digit. Explanation of Example 2 For `n = 11`, the sequence goes as \\"12345678910...\\" - the 11th digit is the second \'0\' in \'10\'. Implement the function accordingly. ```python def find_nth_digit(n): find the nth digit of given number. 1. find the length of the number where the nth digit is from. 2. find the actual number where the nth digit is from 3. find the nth digit and return length = 1 count = 9 start = 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n-1) // length s = str(start) return int(s[(n-1) % length]) ```","solution":"def find_nth_digit(n): Find the nth digit in the sequence of concatenated positive integers. length = 1 count = 9 start = 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"# Question Scenario A student has recently learned about strobogrammatic numbers and the intriguing properties of certain numbers that retain their appearance even when flipped 180 degrees. To test their understanding, you design a problem to validate if numbers are strobogrammatic. Problem Statement Write a function `is_strobogrammatic_number(number)` that takes a string representation of a number and returns `True` if it is strobogrammatic, or `False` otherwise. # Function Signature ```python def is_strobogrammatic_number(number: str) -> bool: pass ``` # Input - A string `number` of length `1 <= len(number) <= 10^5` representing the number you need to check. # Output - Return `True` if the number is strobogrammatic, else return `False`. # Constraints - The number will only contain digits (`0-9`). # Examples ```python assert is_strobogrammatic_number(\\"69\\") == True assert is_strobogrammatic_number(\\"88\\") == True assert is_strobogrammatic_number(\\"962\\") == False assert is_strobogrammatic_number(\\"818\\") == True assert is_strobogrammatic_number(\\"1\\") == True assert is_strobogrammatic_number(\\"3\\") == False ``` Additional Notes - Ensure to handle large inputs efficiently. - Consider edge cases such as single-digit numbers and numbers containing non-strobogrammatic digits.","solution":"def is_strobogrammatic_number(number: str) -> bool: This function takes a string representation of a number and returns True if it is strobogrammatic, otherwise False. # Define the mappings of strobogrammatic digits strobogrammatic_pairs = {\'0\': \'0\', \'1\': \'1\', \'6\': \'9\', \'8\': \'8\', \'9\': \'6\'} left, right = 0, len(number) - 1 while left <= right: if number[left] not in strobogrammatic_pairs or strobogrammatic_pairs[number[left]] != number[right]: return False left += 1 right -= 1 return True"},{"question":"# Problem Scenario You are working as a software engineer, and you are required to implement a sorting algorithm in a system where understanding the sorting process is crucial for debugging purposes. Thus, instead of just sorting the array, you need to provide a step-by-step visualization of the sorting process. # Task Implement the `visual_bubble_sort` function, which is a variation of bubble sort that outputs the state of the array at each iteration. This will help in visualizing the sorting process. # Specifications * **Function Name**: `visual_bubble_sort` * **Input**: * `arr` (List[int]): A list of integers to be sorted. * `simulation` (bool): If set to `True`, prints the array at each step of the sorting process. * **Output**: A sorted list of integers. * **Constraints**: * 0 <= len(arr) <= 1000 * -10^6 <= arr[i] <= 10^6 for any valid index `i` * **Performance Requirement**: While the function should be able to handle the upper constraint limit efficiently, the emphasis is on correct visualization of the sorting process rather than on performance optimization. # Example ```python arr = [5, 4, 3, 2, 1] visual_bubble_sort(arr, simulation=True) # Expected Output: # iteration 0 : 5 4 3 2 1 # iteration 1 : 4 5 3 2 1 # iteration 2 : 4 3 5 2 1 # iteration 3 : 4 3 2 5 1 # iteration 4 : 4 3 2 1 5 # ... # iteration x : 1 2 3 4 5 ``` # Notes 1. Ensure the function manages edge cases effectively. 2. Handle large input sizes adequately within practical runtime limits. 3. Maintain the function\'s stability as a bubble sort, meaning equal elements should retain their initial relative order post-sorting. Your implementation should demonstrate a clear understanding of the bubble sort algorithm, as well as effective handling of corner cases and the sorting process visualization.","solution":"def visual_bubble_sort(arr, simulation=False): n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if simulation: print(f\\"iteration {i*n + j} : {\' \'.join(map(str, arr))}\\") if not swapped: break return arr"},{"question":"# In-Order Traversal Analysis and Implementation Context In computer science, trees are hierarchical structures that store data in nodes, with each node potentially having child nodes. A common binary tree traversal method is the in-order traversal, which visits nodes in the following order: left subtree, root node, right subtree. This yields nodes in non-decreasing order for binary search trees (BST). Task You are provided with a binary tree implemented using the `Node` class. Implement a method to perform an iterative in-order traversal of the tree. The method should return a list of node values in in-order sequence. # Function Signature ```python def iterative_inorder(root: Node) -> List[int]: pass ``` # Input - `root`: The root node of the binary tree. # Output - A list containing the node values in in-order sequence. # Constraints - Nodes contain integer values. - The tree can be empty (i.e., the root can be `None`). # Requirements - The implementation should have a time complexity of O(n), where n is the number of nodes. - Space complexity should be O(h), where h is the height of the tree. # Example Given the binary tree as follows: ``` 100 / 50 150 / / 25 75 125 175 ``` Function Call: ```python root = Node(100, Node(50, Node(25), Node(75)), Node(150, Node(125), Node(175))) print(iterative_inorder(root)) ``` Expected Output: ``` [25, 50, 75, 100, 125, 150, 175] ``` # Explanation The output list reflects the in-order traversal of the given binary tree. Note - Ensure that your implementation correctly handles edge cases, such as empty trees, and trees with only left or right children.","solution":"class Node: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right def iterative_inorder(root: Node) -> list: Performs an iterative in-order traversal of a binary tree. Args: root (Node): The root of the binary tree. Returns: List[int]: A list of node values in in-order sequence. stack = [] result = [] current = root while stack or current: # Reach the leftmost Node of the current Node while current: stack.append(current) current = current.left # Current must be None at this point current = stack.pop() result.append(current.value) # We have visited the node and its left subtree. # Now, it\'s right subtree\'s turn current = current.right return result"},{"question":"Implement Bucket Sort with Enhanced Insertion Sort Given a list of integers, implement the bucket sort algorithm. Your implementation should handle edge cases effectively and optimize for performance by incorporating any improvements you consider necessary. # Input - A list of integers `arr` where `1 <= len(arr) <= 10^5`. - The integers in `arr` are in the range of `0` to `10^6`. # Output - A sorted list of integers. # Constraints - You must use bucket sort. - You should optimize the performance of the sorting inside each bucket. Insertion sort is provided as a reference implementation, but you can choose to use another efficient sorting method for larger lists. - Pay attention to edge cases mentioned in the analysis. # Example Input: ``` arr = [19, 3, 15, 4, 6, 1, 13, 122, 47, 91] ``` Output: ``` [1, 3, 4, 6, 13, 15, 19, 47, 91, 122] ``` # Your Task 1. Implement the `bucket_sort` function to sort the given list using bucket sort. 2. Implement a highly optimized sorting function for sorting elements within each bucket (you can modify or replace `next_sort` as needed). **Note**: You can assume that inputs are always valid and within the given constraints.","solution":"def insertion_sort(arr): A simple insertion sort. Effective for small arrays. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def bucket_sort(arr, bucket_size=10): Bucket sort function which distributes elements into buckets, sorts each bucket with a preferable sorting algorithm and finally combines all the sorted buckets. if len(arr) == 0: return arr # Find minimum and maximum values in the array min_value, max_value = min(arr), max(arr) # Initialize buckets bucket_count = (max_value - min_value) // bucket_size + 1 buckets = [[] for _ in range(bucket_count)] # Distribute input array values into buckets for i in arr: buckets[(i - min_value) // bucket_size].append(i) # Sort each bucket and collect them together sorted_array = [] for bucket in buckets: if len(bucket) > 0: # Only sort non-empty buckets if len(bucket) == 1: sorted_array.extend(bucket) else: sorted_array.extend(insertion_sort(bucket)) return sorted_array"},{"question":"# Intersection of Two Linked Lists You are tasked with finding the intersection node of two singly linked lists. The intersection is defined based on reference, not value. Create a function `find_intersection` which takes the heads of two such linked lists and returns the intersecting node. If there\'s no intersection, it should return `None`. Input Format * Two node pointer inputs representing the head nodes of the linked lists. Output Format * A single node pointer representing the intersecting node, or `None` if no intersection exists. # Constraints * The linked lists must be singly and non-cyclic. * The solution should efficiently find the intersection, ideally in linear time. * You are not allowed to use additional data structures like hash sets. * The lists may vary in lengths. # Function Signature ```python class Node: def __init__(self, val): self.val = val self.next = None def find_intersection(head1: Node, head2: Node) -> Node: pass ``` # Example ```python # Creating the linked lists # List 1: 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # List 2: 2 -> 4 -> 6 n1 = Node(1) n3 = Node(3) n5 = Node(5) n7 = Node(7) n9 = Node(9) n11 = Node(11) n2 = Node(2) n4 = Node(4) n6 = Node(6) # Linking nodes n1.next = n3 n3.next = n5 n5.next = n7 n7.next = n9 n9.next = n11 n2.next = n4 n4.next = n6 n6.next = n7 # Intersection Node Test print(find_intersection(n1, n2).val) # Output: 7 ``` # Hints 1. Use a two-pointer approach. 2. Consider traversing both lists entirely to get their lengths first.","solution":"class Node: def __init__(self, val): self.val = val self.next = None def get_length(head): length = 0 current = head while current: length += 1 current = current.next return length def find_intersection(head1, head2): # Get lengths of both lists len1 = get_length(head1) len2 = get_length(head2) # Align the starts of both lists if len1 > len2: for _ in range(len1 - len2): head1 = head1.next else: for _ in range(len2 - len1): head2 = head2.next # Move both pointers until they meet at the intersection while head1 and head2: if head1 == head2: return head1 head1 = head1.next head2 = head2.next return None"},{"question":"# Cycle Sort Implementation Given an unsorted list of integers, implement the Cycle Sort algorithm to sort the list in non-decreasing order. Ensure that your implementation minimizes the number of write operations as described in the cycle sort algorithm. # Input * A list of integers `arr` (1 ≤ len(arr) ≤ 10^4, -10^6 ≤ arr[i] ≤ 10^6) # Output * The sorted list in non-decreasing order # Example Input ``` arr = [3, 1, 4, 1, 5] ``` Output ``` [1, 1, 3, 4, 5] ``` # Constraints * Minimize the number of write operations used during sorting. * Ensure the sorting is done in-place. # Notes * Cycle Sort is not a stable sort; hence the relative order of elements with the same value does not have to be preserved. * Use of additional data structures or extra memory beyond O(1) space is not allowed. Implement the `cycle_sort` function to achieve the above sorting as follows: ```python def cycle_sort(arr): Sort the array using Cycle Sort algorithm :param arr: List[int], a list of integers to be sorted :return: List[int], the sorted list of integers len_arr = len(arr) # Finding cycle to rotate. for cur in range(len_arr - 1): item = arr[cur] # Finding an index to put items in. index = cur for i in range(cur + 1, len_arr): if arr[i] < item: index += 1 # Case of there is not a cycle if index == cur: continue # Putting the item immediately right after the duplicate item or on the right. while item == arr[index]: index += 1 arr[index], item = item, arr[index] # Rotating the remaining cycle. while index != cur: # Finding where to put the item. index = cur for i in range(cur + 1, len_arr): if arr[i] < item: index += 1 # After item is duplicated, put it in place or put it there. while item == arr[index]: index += 1 arr[index], item = item, arr[index] return arr # Implement your function here. ```","solution":"def cycle_sort(arr): Sort the array using Cycle Sort algorithm :param arr: List[int], a list of integers to be sorted :return: List[int], the sorted list of integers len_arr = len(arr) for start in range(len_arr - 1): item = arr[start] # Find position where we put the element pos = start for i in range(start + 1, len_arr): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == start: continue # Otherwise, put the item to the correct position while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != start: pos = start for i in range(start + 1, len_arr): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"Extended Run-Length Encoding Context Run-Length Encoding (RLE) is a simple yet effective form of data compression where consecutive sequences of the same data value are stored as a single data value and its count. This technique is particularly effective for data with many repeated values. Problem Statement Implement two functions `encode_rle(input: str) -> str` and `decode_rle(input: str) -> str` such that: - `encode_rle` compresses the input string using run-length encoding. - `decode_rle` decompresses the previously run-length encoded string. Functional Requirements: 1. **encode_rle** - Input: A string `input` containing any sequence of characters. - Output: A run-length encoded string. Example: ```python assert encode_rle(\\"aaaabbbbcc\\") == \\"4a4b2c\\" assert encode_rle(\\"abc\\") == \\"1a1b1c\\" ``` 2. **decode_rle** - Input: A string `input` containing a run-length encoded sequence. - Output: The original string before encoding. Example: ```python assert decode_rle(\\"4a4b2c\\") == \\"aaaabbbbcc\\" assert decode_rle(\\"1a1b1c\\") == \\"abc\\" ``` Constraints: - The input strings for `encode_rle` and `decode_rle` will always be valid. - The encoded string will follow the format where numeric count is always followed by a character. - Consider efficiency for strings up to 10^6 characters.","solution":"def encode_rle(input: str) -> str: Compresses the input string using run-length encoding. if not input: return \\"\\" encoded_str = [] count = 1 current_char = input[0] for char in input[1:]: if char == current_char: count += 1 else: encoded_str.append(f\\"{count}{current_char}\\") current_char = char count = 1 encoded_str.append(f\\"{count}{current_char}\\") return \'\'.join(encoded_str) def decode_rle(input: str) -> str: Decompresses the run-length encoded input string. decoded_str = [] i = 0 while i < len(input): j = i while j < len(input) and input[j].isdigit(): j += 1 count = int(input[i:j]) char = input[j] decoded_str.append(char * count) i = j + 1 return \'\'.join(decoded_str)"},{"question":"You are tasked to enhance the provided Binary Search Tree (BST) implementation with additional functionalities. Your objective is to implement the following new methods: 1. **Delete**: Implement a method `delete(data)` that removes a node with the specified data from the BST. Ensure the tree maintains its BST properties after deletion. 2. **Find Minimum**: Implement a method `find_min()` that returns the smallest element in the BST. 3. **Find Maximum**: Implement a method `find_max()` that returns the largest element in the BST. # Additional Instructions 1. **Deletion Rules**: * If the node to be deleted is a leaf node, simply remove it. * If the node has one child, replace the node with its child. * If the node has two children, replace the node’s value with its in-order successor’s value, and then delete the in-order successor. 2. **Method Definitions**: ```python def delete(self, data): # Implement deletion in BST def find_min(self): # Implement method to find the minimum value in BST def find_max(self): # Implement method to find the maximum value in BST ``` # Input and Output - **Input**: - `delete(data)`: An integer `data` representing the value to delete from BST. - `find_min()`: No input. - `find_max()`: No input. - **Output**: - `delete(data)`: No return value. Tree should be updated. - `find_min()`: Returns an integer representing the smallest value in BST. - `find_max()`: Returns an integer representing the largest value in BST. # Constraints - Each value in the BST is unique. - The BST can store positive and negative integers. # Performance Requirements - Ensure the operations are efficient, ideally maintaining O(log N) time complexity for balanced trees. # Example ```python # Assuming the tree is set up as shown in the initial problem statement... bst = BST() bst.insert(10) bst.insert(15) # ... More inserts # Example operations: print(bst.find_min()) # Should print minimal value (4 from the given tree example) print(bst.find_max()) # Should print maximal value (30 from the given tree example) bst.delete(15) # Should delete the node with value 15 from the tree ``` Implement the required methods to pass the example test cases.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = Node(key) else: self._insert(node.right, key) def delete(self, data): self.root = self._delete(self.root, data) def _delete(self, node, key): if node is None: return node if key < node.val: node.left = self._delete(node.left, key) elif key > node.val: node.right = self._delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left min_larger_node = self._find_min(node.right) node.val = min_larger_node.val node.right = self._delete(node.right, min_larger_node.val) return node def find_min(self): return self._find_min(self.root).val if self.root else None def _find_min(self, node): current = node while current.left is not None: current = current.left return current def find_max(self): return self._find_max(self.root).val if self.root else None def _find_max(self, node): current = node while current.right is not None: current = current.right return current"},{"question":"Context: You are working as a software engineer implementing a library for various Binary Tree utilities. One of the fundamental utilities required in many tree-based algorithms is the ability to determine the height of the tree. The height is defined as the number of levels in the tree. Task: Write a function `height` that computes the height of a given binary tree. The tree is represented by the root node of the Binary Tree, where each node contains at minimum: - An integer value. - References to its left and right child nodes. Input: - The input will be the root node of the binary tree. ```python class Node: def __init__(self, key): self.left = None self.right = None self.val = key ``` Output: - The function should return an integer representing the height of the tree. Constraints: 1. The maximum number of nodes in the tree is `10^4`. 2. The tree can be completely unbalanced (i.e., all nodes are either left children or right children). Requirements: 1. Ensure the function operates within the time complexity O(N) where N is the number of nodes. 2. Ensure space complexity is managed appropriately (prefer non-recursive solutions unless handled virtually). Example: Consider the following binary tree: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` The function should return: ``` 4 ``` Function Signature: ```python def height(root: Node) -> int: pass ``` Test Cases: ```python import unittest class TestHeightFunction(unittest.TestCase): def setUp(self): # Setting up a sample BST self.tree = Node(9) self.tree.left = Node(6) self.tree.right = Node(12) self.tree.left.left = Node(3) self.tree.left.right = Node(8) self.tree.right.left = Node(10) self.tree.right.right = Node(15) self.tree.left.right.left = Node(7) self.tree.right.right.right = Node(18) def test_height(self): self.assertEqual(height(self.tree), 4) def test_empty_tree(self): self.assertEqual(height(None), 0) def test_single_node_tree(self): single_node_tree = Node(1) self.assertEqual(height(single_node_tree), 1) def test_unbalanced_left_tree(self): root = Node(1) root.left = Node(2) root.left.left = Node(3) self.assertEqual(height(root), 3) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def height(root: Node) -> int: Computes the height of a binary tree. Parameters: root (Node): Root node of the binary tree. Returns: int: Height of the binary tree. if not root: return 0 left_height = height(root.left) right_height = height(root.right) return max(left_height, right_height) + 1"},{"question":"# Question: Implement and Analyze Diffie-Hellman Key Exchange with Optimized Primality Testing Description Alice and Bob want to securely share data over an insecure channel using the Diffie-Hellman key exchange algorithm. Your task is to implement this key exchange mechanism, including optimized routines for primality testing and primitive root finding. Ensure that your implementation correctly handles edge cases and maximizes efficiency. Components 1. **Optimized Primality Test (Miller-Rabin)** 2. **Optimized Euler\'s Totient Function** 3. **Order Finding Algorithm** 4. **Primitive Root Finding Algorithm** 5. **Full Diffie-Hellman Key Exchange Procedure** Functions to Implement - **is_prime_miller_rabin(n, k=5)**: Determines if n is prime using the Miller-Rabin test with k iterations. - **Input**: Integer n, Integer k (number of test iterations, default: 5) - **Output**: Boolean (True if n is prime, False otherwise) - **euler_totient_optimized(n)**: Computes the count of coprime integers to n. - **Input**: Integer n - **Output**: Integer φ(n) - **find_order_optimized(a, n)**: Finds the order of a modulo n. - **Input**: Integer a, Integer n - **Output**: Integer k (order) or -1 if it doesn’t exist - **find_primitive_root_optimized(n)**: Finds all primitive roots of n. - **Input**: Integer n - **Output**: List of Integers (all primitive roots of n) - **diffie_hellman_key_exchange_optimized(a, p)**: Performs the Diffie-Hellman key exchange. - **Input**: Integer a (possible primitive root), Integer p (large prime) - **Output**: Boolean (True if computed shared keys match) Requirements - The primality test should efficiently confirm primality for large primes using probabilistic checks. - Euler\'s Totient function and order-finding implementations should handle large numbers efficiently. - The overall procedure should confirm the computed shared keys between Alice and Bob match to ensure secure key exchange. - Error handling for non-prime `p` and invalid root `a`. Constraints - `a` must be a primitive root of `p`. - `p` is a large prime number (typically hundreds of digits). Example ```python p = 23 a = 5 # ensure 5 is a valid primitive root of 23 # Call optimized Diffie-Hellman key exchange success = diffie_hellman_key_exchange_optimized(a, p) assert success == True # Expected True since both shared keys should match ```","solution":"import random def is_prime_miller_rabin(n, k=5): Determine if n is a prime using Miller-Rabin Primality Test. if n in (2, 3): return True if n <= 1 or n % 2 == 0: return False # Write n-1 as 2^r * d r, d = 0, n - 1 while d % 2 == 0: r += 1 d //= 2 def miller_test(a): x = pow(a, d, n) if x == 1 or x == n - 1: return True for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return True return False for _ in range(k): a = random.randint(2, n - 2) if not miller_test(a): return False return True def euler_totient_optimized(n): Calculate Euler\'s Totient function using optimized approach. result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def find_order_optimized(a, n): Find the order of a mod n. if gcd(a, n) != 1: return -1 order = 1 k = a % n while k != 1: k = (k * a) % n order += 1 return order def gcd(a, b): Compute the greatest common divisor using Euclid\'s algorithm. while b: a, b = b, a % b return a def find_primitive_root_optimized(n): Find a primitive root modulo n. if not is_prime_miller_rabin(n): return -1 phi = euler_totient_optimized(n) factors = prime_factors(phi) roots = [] for r in range(2, n): flag = True for factor in factors: if pow(r, phi // factor, n) == 1: flag = False break if flag: roots.append(r) return roots def prime_factors(n): Return the prime factors of n. i = 2 factors = set() while i * i <= n: if n % i: i += 1 else: n //= i factors.add(i) if n > 1: factors.add(n) return factors def diffie_hellman_key_exchange_optimized(a, p): Perform the Diffie-Hellman key exchange. if not is_prime_miller_rabin(p): return False if a not in find_primitive_root_optimized(p): return False # Private keys alice_private = random.randint(2, p - 2) bob_private = random.randint(2, p - 2) # Public keys alice_public = pow(a, alice_private, p) bob_public = pow(a, bob_private, p) # Shared secrets alice_secret = pow(bob_public, alice_private, p) bob_secret = pow(alice_public, bob_private, p) return alice_secret == bob_secret"},{"question":"You are tasked with implementing a coding solution for encoding and decoding a list of strings for effective data transmission over the network. Your goal is to create two functions, `encode` and `decode`, that will correctly serialize and deserialize a list of strings. Function Definitions 1. **encode** ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str ``` 2. **decode** ```python def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] ``` Input and Output Requirements 1. **encode Function** - Input: `strs` - A list of strings (`List[str]`). - Output: A single encoded string (`str`) which concatenates representations of all strings in `strs`. 2. **decode Function** - Input: `s` - A single encoded string (`str`). - Output: A list of original strings (`List[str]`) that were encoded. Constraints * The length of each string will be non-negative and within the standard range of string lengths supported by Python. * The encoded string should handle delimiter and length representation correctly to allow accurate decoding. Example ```python # Example usage original_strings = [\\"hello\\", \\"world\\"] encoded_string = encode(original_strings) print(encoded_string) # Expected format \\"5:hello5:world\\" decoded_strings = decode(encoded_string) print(decoded_strings) # Expected output [\\"hello\\", \\"world\\"] ``` Edge Cases 1. The list can be empty (`[]`). 2. Strings can be empty (`[\\"\\", \\"test\\"]`). 3. Consider the handling of strings containing the separator character (`\\":\\"`). Your task is to implement the `encode` and `decode` functions to pass all these cases effectively and efficiently.","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str encoded_string = \'\' for s in strs: encoded_string += f\'{len(s)}:{s}\' return encoded_string def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] decoded_strings = [] i = 0 while i < len(s): j = s.find(\':\', i) length = int(s[i:j]) decoded_strings.append(s[j+1:j+1+length]) i = j + 1 + length return decoded_strings"},{"question":"# Coding Challenge: Optimized Two Sum Solution Context You are given an array of integers `nums` and an integer `target`. You need to write a function to return the indices of the two numbers such that they add up to the `target`. The constraints ensure that there is exactly one solution, and you cannot use the same element twice. Function Signature ```python def optimized_two_sum(array: list[int], target: int) -> tuple[int, int]: ``` Input * `array`: List of integers (1 <= len(array) <= 10^5, -10^9 <= array[i] <= 10^9) * `target`: An integer (-10^9 <= target <= 10^9) Output * A tuple of two integers representing the indices of the two numbers that add up to the target. Constraints * Each array element is unique, and the list contains exactly one solution. * Elements of the array can be any integer within a given range. * Your solution should aim for the best possible time complexity. Example ```python >>> optimized_two_sum([2, 7, 11, 15], 9) (0, 1) >>> optimized_two_sum([3, 2, 4], 6) (1, 2) ``` Notes * Ensure to handle edge cases such as the smallest and largest possible values for the `target` and array elements. * Consider performance aspects and aim for solutions better than the quadratic time complexity. Scoring Rubric * **Accuracy**: The correctness of the result returned (60 points). * **Performance**: Efficient use of time and space (30 points). * **Edge Cases Handling**: Proper handling of edge cases (10 points).","solution":"def optimized_two_sum(nums: list[int], target: int) -> tuple[int, int]: Function to find the indices of two numbers in a list that add up to a given target. This function assumes that there is exactly one solution and no element can be used twice. It uses a hash map to track the indices of the elements. num_to_index = {} for i, num in enumerate(nums): # Calculate the complement of the current number complement = target - num # Check if the complement is already in the hashmap if complement in num_to_index: return (num_to_index[complement], i) # Add the number and its index to the hashmap num_to_index[num] = i # In case there is no solution, just to have a return although constraints dictate there is exactly one solution # But since the return type has to be of tuple[int, int], to avoid type errors: return (-1, -1)"},{"question":"# Context You are working as a data engineer responsible for cleaning and preprocessing large datasets. As part of your task, you\'re asked to limit redundant information in a list of events by ensuring that no event type exceeds a certain number of occurrences while maintaining their original order. # Task Write a function `delete_nth(array, n)` that takes in a list of integers `array` and an integer `n`, and returns a new list where each integer appears at most `n` times, preserving the order of their first occurrences. # Function Signature ```python def delete_nth(array, n): :param array: List[int] - List of integers :param n: int - Maximum allowed occurrences for any integer :return: List[int] - Filtered list with elements appearing at most \'n\' times ``` # Input and Output Format - **Input**: - `array`: A list of integers where each integer represents an event - `n`: A non-negative integer representing the maximum allowed occurrences for each integer - **Output**: - A new list of integers where any integer appears at most `n` times, with their order preserved from the original list # Performance Requirements - Your solution should have a time complexity of (O(n)) and space complexity of (O(n)). # Constraints - The elements in `array` are integers, and `n` is a non-negative integer. - The function should handle edge cases, such as an empty input list or `n` equal to 0. # Example ```python # Example 1 input_list = [1, 2, 3, 1, 2, 1, 2, 3] n = 2 # The function should return [1, 2, 3, 1, 2, 3] print(delete_nth(input_list, n)) # Example 2 input_list = [1, 1, 1, 1, 1] n = 1 # The function should return [1] print(delete_nth(input_list, n)) ```","solution":"def delete_nth(array, n): Returns a new list where each integer appears at most \'n\' times, preserving their original order. :param array: List[int] - List of integers :param n: int - Maximum allowed occurrences for any integer :return: List[int] - Filtered list with elements appearing at most \'n\' times result = [] counts = {} for item in array: if counts.get(item, 0) < n: result.append(item) counts[item] = counts.get(item, 0) + 1 return result"},{"question":"# Stooge Sort Modification Challenge **Background**: Stooge Sort is an inefficient but interesting recursive sorting algorithm. It\'s primarily used for educational purposes to illustrate recursive concepts in sorting algorithms. This challenge requires you to modify the provided Stooge Sort algorithm to handle an additional constraint: sort the given array in descending order. **Problem Statement**: Write a function `stoogesort_descending(arr: list, l: int, h: int) -> None` that sorts the array `arr` in descending order from index `l` to `h` using a modified Stooge Sort algorithm. **Function Signature**: ```python def stoogesort_descending(arr: list, l: int, h: int) -> None: ``` **Input**: - `arr` (list): A list of integers to sort. - `l` (int): The starting index of the sublist to sort. - `h` (int): The ending index of the sublist to sort. **Output**: - The function sorts the array in place; it doesn\'t return anything. **Constraints**: - `0 <= l <= h < len(arr)`, ensuring valid indices. - The array can contain negative numbers and duplicates. - The implementation should modify the array directly without using extra space for another list. **Examples**: ```python # Example 1 arr = [2, 3, 1, 4, 6, 5] stoogesort_descending(arr, 0, len(arr) - 1) print(arr) # Expected output: [6, 5, 4, 3, 2, 1] # Example 2 arr = [10, 10, 5, -1, 7, 7] stoogesort_descending(arr, 0, len(arr) - 1) print(arr) # Expected output: [10, 10, 7, 7, 5, -1] ``` **Edge Cases to Consider**: - An empty array should remain unchanged. - A single-element array should remain unchanged. - Arrays with all identical elements should remain unchanged. **Hints**: - Modify the comparison operations to ensure the array is sorted in descending order. - Carefully handle the recursive calls to ensure correct indexes are passed.","solution":"def stoogesort_descending(arr, l, h): if l >= h: return # If the element at l is smaller than the element at h, swap them if arr[l] < arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the array part to be sorted if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort_descending(arr, l, h - t) stoogesort_descending(arr, l + t, h) stoogesort_descending(arr, l, h - t)"},{"question":"Context: Shell Sort is a comparison-based sorting algorithm that allows the exchange of items that are far apart. The basic idea of shell sort is to first sort elements that are far apart from each other and progressively reduce the gap between them. With this approach, the array elements are first divided into several smaller subarrays and each subarray is independently sorted. The algorithm continues to reduce the gap between elements to be compared and goes through the list multiple times until the gap is 1. Task: Implement the function `optimized_shell_sort(arr: List[int], gap_sequence: Tuple[int]) -> List[int]` with the following specifications: 1. **Functionality**: - The function should take an array of integers and a tuple representing the gap sequence as inputs. - It should sort the given array using the specified gap sequence in the Shell Sort algorithm. - Return the sorted array. 2. **Input**: - `arr`: A list of integers (not necessarily sorted). - `gap_sequence`: A tuple of integers representing the gap sequence to be used. 3. **Output**: - A list of integers sorted in non-decreasing order. 4. **Constraints**: - The length of `arr` will be between 0 and 10^3. - The elements of `arr` will be integers between -10^3 and 10^3. - The `gap_sequence` provided will be valid and follow non-increasing order relative to the array size. 5. **Performance Requirements**: - The function should provide an efficient sorting process considering the given gap sequence. Example: ```python def optimized_shell_sort(arr, gap_sequence): # Write your code here pass # Example Usage arr = [23, 12, 1, 8, 34, 54, 2, 3] gap_sequence = (5, 3, 1) print(optimized_shell_sort(arr, gap_sequence)) # Output: [1, 2, 3, 8, 12, 23, 34, 54] ``` **Note**: Make sure to handle edge cases such as an empty array or an array already in sorted order.","solution":"from typing import List, Tuple def optimized_shell_sort(arr: List[int], gap_sequence: Tuple[int]) -> List[int]: n = len(arr) # Perform Shell Sort using the given gap sequence. for gap in gap_sequence: # Do a gapped insertion sort for this gap size. # The first gap elements arr[0..gap-1] are already in gapped order for i in range(gap, n): temp = arr[i] j = i # shift earlier gap-sorted elements up until the correct location for arr[i] is found while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap # put temp (the original arr[i]) in its correct location arr[j] = temp return arr"},{"question":"# Question: Decode A Nested Encoded String Description You are given an encoded string where the encoding rule is as follows: k[encoded_string]. The encoded_string inside the square brackets is being repeated exactly k times. Your task is to write a function that decodes this string. Input * The input string `s` is guaranteed to be always valid; no extra white spaces, and all square brackets are well-formed. * The original data (before encoding) does not contain any digits and digits are only for those repeat numbers, k. Output * The function should return the decoded string. Constraints * 1 <= s.length <= 30,000. * The input string consists of lowercase English letters, digits, and square brackets. Examples: 1. Example 1: * Input: s = \\"3[a]2[bc]\\" * Output: \\"aaabcbc\\" 2. Example 2: * Input: s = \\"3[a2[c]]\\" * Output: \\"accaccacc\\" 3. Example 3: * Input: s = \\"2[abc]3[cd]ef\\" * Output: \\"abcabccdcdcdef\\" 4. Example 4: * Input: s = \\"100[a]\\" * Output: \\"a\\" repeated 100 times. Function Signature ```python def decode_string(s: str) -> str: pass ``` Requirements: * Your solution should handle deeply nested structures efficiently. * Ensure that your function does not run into stack overflow for large inputs.","solution":"def decode_string(s: str) -> str: Decodes the encoded string as per the given encoding rule. stack = [] current_string = \'\' current_num = 0 for ch in s: if ch.isdigit(): current_num = current_num * 10 + int(ch) elif ch == \'[\': stack.append((current_string, current_num)) current_string = \'\' current_num = 0 elif ch == \']\': last_string, num = stack.pop() current_string = last_string + num * current_string else: current_string += ch return current_string"},{"question":"# Task: Implement a Depth Tracker for Nested Arrays You are given multidimensional nested arrays, which can contain any levels of nested sub-arrays. Your task is to implement a function that will not only flatten these arrays but also keep track of the maximum depth encountered during the flattening process. Implement two separate functions: 1. A function `flatten_and_track(arr)` that returns a tuple of (flattened_array, max_depth) 2. A generator-based function `flatten_and_track_iter(iterable)` that returns (flattened_element, max_depth) for each element. # Function Specifications flatten_and_track(arr) # Input: - `arr`: A multi-dimensional list (nested arrays). # Output: - Returns a tuple `(flattened_list, max_depth)`: - `flattened_list`: A single list containing all elements from the nested arrays in a flattened structure. - `max_depth`: An integer representing the maximum depth encountered during the flattening process. # Example: ```python flatten_and_track([1, [2, [3, 4], 5], 6]) # Output: ([1, 2, 3, 4, 5, 6], 3) flatten_and_track([1, [2, [3], [4, [5]]]]) # Output: ([1, 2, 3, 4, 5], 4) ``` flatten_and_track_iter(iterable) # Input: - `iterable`: A multi-dimensional iterable (nested arrays). # Output: - Returns a generator that yields tuples `(flattened_element, current_depth)` for each element: - `flattened_element` is an element from the nested iterable. - `current_depth` is the integer depth at which that element was found. # Example: ```python list(flatten_and_track_iter([1, [2, [3, 4], 5], 6])) # Output: [(1, 1), (2, 2), (3, 3), (4, 3), (5, 2), (6, 1)] list(flatten_and_track_iter([1, [2, [3], [4, [5]]]])) # Output: [(1, 1), (2, 2), (3, 3), (4, 3), (5, 4)] ``` # Constraints: - The functions should handle arrays with varying levels of nested structures. - Python\'s recursion limits may apply, so consider iterative solutions where appropriate. - Max depth should be carefully tracked and updated as the function processes nested structures. # Notes: - Attributes like memory usage and recursion depth must be kept in check to prevent overflows for highly nested arrays. - Efficiency and elegant handling of depth tracking are critical.","solution":"def flatten_and_track(arr): Flattens a nested list and tracks the maximum depth. :param arr: multi-dimensional list :return: tuple (flattened_list, max_depth) flat_list = [] max_depth = 0 def _flatten(sub_arr, depth): nonlocal max_depth max_depth = max(max_depth, depth) for item in sub_arr: if isinstance(item, list): _flatten(item, depth + 1) else: flat_list.append(item) _flatten(arr, 1) return flat_list, max_depth def flatten_and_track_iter(iterable): A generator function that flattens a nested iterable and yields each element with its depth. :param iterable: multi-dimensional iterable :return: generator yielding tuples (element, current_depth) stack = [(iterable, 1)] while stack: current, depth = stack.pop() if isinstance(current, list): for item in reversed(current): stack.append((item, depth + 1 if isinstance(item, list) else depth)) else: yield current, depth"},{"question":"# Sorting Array of Tuples by Multiple Keys You are given a list of tuples where each tuple consists of two elements: a string and an integer. Your task is to write a function that sorts this list primarily by the string values in ascending order, and in case of ties, by the integer values in descending order. For example, given input `[(\\"apple\\", 3), (\\"banana\\", 1), (\\"apple\\", 2), (\\"cherry\\", 5)]`, the sorted output should be `[(\\"apple\\", 3), (\\"apple\\", 2), (\\"banana\\", 1), (\\"cherry\\", 5)]`. # Function Signature ```python def sort_tuples(arr: List[Tuple[str, int]]) -> List[Tuple[str, int]]: ``` # Input * `arr`: List of tuples, where each tuple contains a string and an integer, e.g., `[(\\"apple\\", 3), (\\"banana\\", 1), (\\"apple\\", 2), (\\"cherry\\", 5)]`. The list can have `0 <= len(arr) <= 10^4`. # Output * The function should return a list of tuples sorted as described above. # Constraints * The length of the list will be within the range `[0, 10000]`. * Each tuple will contain a lowercase string and a non-negative integer. * Strings are limited to lowercase English letters and their length doesn\'t exceed 100 characters. * Integers are within the range `[0, 100000]`. # Performance Requirements * The solution should be efficient for the upper constraint limits of the input list size and tuple string length. # Example ```python input = [(\\"apple\\", 3), (\\"banana\\", 1), (\\"apple\\", 2), (\\"cherry\\", 5)] output = [(\\"apple\\", 3), (\\"apple\\", 2), (\\"banana\\", 1), (\\"cherry\\", 5)] ``` # Notes * Use Python\'s built-in sorting capabilities, and consider providing a multi-key sorting solution to achieve the desired order. * Ensure your implementation is robust against all mentioned edge cases and performs within constraints effectively.","solution":"from typing import List, Tuple def sort_tuples(arr: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts a list of tuples primarily by the string values in ascending order, and in case of ties, by the integer values in descending order. # Implementing sorting by using a lambda function as key return sorted(arr, key=lambda x: (x[0], -x[1]))"},{"question":"# Binary Tree to Doubly Linked List Conversion You are given a binary tree with the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Your task is to write a function `bin_tree_to_list(root: TreeNode) -> TreeNode` to convert the binary tree rooted at `root` into a sorted doubly linked list in-place. The doubly linked list should have the properties: - Each node\'s left pointer should point to the previous node in the list. - Each node\'s right pointer should point to the next node in the list. - The nodes should follow the in-order sequence of the binary tree. Constraints: - The input binary tree can have up to 10,000 nodes. Example: ```python # Example usage: root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(3) head = bin_tree_to_list(root) # The resulting doubly linked list should be: # 1 <-> 2 <-> 3 <-> 4 <-> 5 current = head while current is not None: print(current.val) # Output should be 1, 2, 3, 4, 5 current = current.right ``` Notes: - Do not use additional memory structures (like lists or arrays) to hold tree nodes. Perform the conversion in-place. - You may define and use helper functions as needed.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bin_tree_to_list(root: TreeNode) -> TreeNode: if not root: return None def inorder_traverse(node): nonlocal last, head if not node: return # Traverse the left subtree inorder_traverse(node.left) # Process the current node if last: last.right = node node.left = last else: head = node last = node # Traverse the right subtree inorder_traverse(node.right) last, head = None, None inorder_traverse(root) return head"},{"question":"# Question: Implementing and Simulating Selection Sort Problem Statement You are given an array of integers. Your task is to implement the Selection Sort algorithm to sort this array in ascending order. Additionally, you need to provide a simulation of each iteration to understand how the array changes over time. Function Signature ```python def selection_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts the array in ascending order using selection sort. If simulation is True, print the array at every iteration. Parameters: arr (List[int]): The array to be sorted. simulation (bool): If True, prints the state of the array after each iteration. Returns: List[int]: The sorted array. ``` Input * `arr`: A list of integers (e.g., [64, 25, 12, 22, 11]). * `simulation`: A boolean indicating whether to print the array state after each iteration (default is `False`). Output * The function should return the sorted list. * If `simulation` is `True`, print the state of the array after each iteration in the format: `iteration <iteration_number>: <space-separated array elements>`. Constraints * The list should have at most 1000 elements. * Each element in the array is an integer within the range of -1000 to 1000. Example ```python selection_sort([64, 25, 12, 22, 11], simulation=True) ``` Output: ``` iteration 0: 11 25 12 22 64 iteration 1: 11 12 25 22 64 iteration 2: 11 12 22 25 64 iteration 3: 11 12 22 25 64 iteration 4: 11 12 22 25 64 ``` Write the `selection_sort` function that adheres to the function signature and meets the requirements detailed above.","solution":"def selection_sort(arr, simulation=False): Sorts the array in ascending order using selection sort. If simulation is True, print the array at every iteration. Parameters: arr (List[int]): The array to be sorted. simulation (bool): If True, prints the state of the array after each iteration. Returns: List[int]: The sorted array. n = len(arr) for i in range(n): # Find the minimum element in remaining unsorted array min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j # Swap the found minimum element with the first element arr[i], arr[min_idx] = arr[min_idx], arr[i] # Print the array if simulation is True if simulation: print(f\\"iteration {i}: {\' \'.join(map(str, arr))}\\") return arr"},{"question":"# Context You are given a signal represented by an array of complex numbers. To analyze the frequency components of this signal, you need to compute its discrete Fourier transform (DFT) using the Cooley-Tukey FFT algorithm. # Task Implement the function `fft(x)` that transforms the input array `x` using the Cooley-Tukey FFT algorithm. The input will always be a list of complex numbers with a size that is a power of 2. # Example ```python Input: [2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j] Output: [8+8j, 2j, 2-2j, -2+0j] ``` # Constraints 1. The length of the input list (`N`) will always be a power of 2. 2. The list will contain complex numbers. 3. Use the recursive Cooley-Tukey algorithm as described in the analysis. # Function Signature ```python def fft(x: List[complex]) -> List[complex]: # Your code here ``` # Detailed Requirements 1. **Input**: A list `x` of size `N` (where `N` is a power of 2) containing complex numbers. 2. **Output**: A list of complex numbers which is the discrete Fourier transform of the input list. Ensure that your function handles the given constraints and edge cases properly.","solution":"import cmath def fft(x): Compute the discrete Fourier transform of the 1D array x using the recursive Cooley-Tukey FFT algorithm. N = len(x) if N <= 1: return x even = fft(x[0::2]) odd = fft(x[1::2]) T = [cmath.exp(-2j * cmath.pi * k / N) * odd[k] for k in range(N // 2)] return [even[k] + T[k] for k in range(N // 2)] + [even[k] - T[k] for k in range(N // 2)]"},{"question":"# Question: Graph Maze Solver You are given a maze represented as a grid where each cell can be either a `0` (an open cell) or a `1` (a wall). The start of the maze is at the top-left corner (0, 0) and the exit is at the bottom-right corner (rows-1, cols-1). Your task is to implement two functions: one using Depth First Search (DFS) and another using Breadth First Search (BFS) to find a path from the start to the exit. If a path exists, return the path as a list of coordinates. If no path exists, return an empty list. # Function Signatures ```python def dfs_maze_solver(maze: List[List[int]]) -> List[Tuple[int, int]]: pass def bfs_maze_solver(maze: List[List[int]]) -> List[Tuple[int, int]]: pass ``` # Input - **maze**: A 2D list of integers where `maze[i][j]` can be either `0` (open cell) or `1` (wall). # Output - A list of tuples where each tuple represents the coordinates `(row, col)` forming a valid path from the start to the exit. If no path exists, return an empty list. # Constraints - The maze will have at least one cell. - The maze can have up to 1000 cells. - The start (0, 0) and exit (rows-1, cols-1) will always be `0` (open). # Example ```python maze = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 0, 0] ] # Example of a valid path (one of the possible paths) expected_dfs_output = [(0, 0), (1, 0), (2, 0), (3, 0), (3, 1), (3, 2), (4, 2), (4, 3), (4, 4)] expected_bfs_output = [(0, 0), (1, 0), (2, 0), (3, 0), (3, 1), (3, 2), (4, 2), (4, 3), (4, 4)] assert dfs_maze_solver(maze) == expected_dfs_output assert bfs_maze_solver(maze) == expected_bfs_output ``` # Notes 1. The path can move in either of the four directions: up, down, left, right. 2. Ensure your algorithm handles large mazes efficiently. 3. Consider all edge cases such as mazes full of walls except the start and exit.","solution":"from typing import List, Tuple def dfs_maze_solver(maze: List[List[int]]) -> List[Tuple[int, int]]: def dfs(x, y, path): if not (0 <= x < rows and 0 <= y < cols) or maze[x][y] == 1 or (x, y) in visited: return False path.append((x, y)) visited.add((x, y)) if (x, y) == (rows-1, cols-1): return True if (dfs(x+1, y, path) or dfs(x-1, y, path) or dfs(x, y+1, path) or dfs(x, y-1, path)): return True path.pop() return False rows, cols = len(maze), len(maze[0]) visited = set() path = [] if dfs(0, 0, path): return path return [] def bfs_maze_solver(maze: List[List[int]]) -> List[Tuple[int, int]]: from collections import deque rows, cols = len(maze), len(maze[0]) queue = deque([(0, 0, [(0, 0)])]) visited = set((0, 0)) while queue: x, y, path = queue.popleft() if (x, y) == (rows-1, cols-1): return path for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, path + [(nx, ny)])) return []"},{"question":"# Rotated String Verification **Scenario/Context**: You are tasked with ensuring data integrity in a cyclical data processing system. You need to verify if a data segment received after transmission is a rotated version of the original segment. To achieve this, you will write a function to determine if one string is a rotated version of another. **Function Signature**: ```python def is_rotated(s1: str, s2: str) -> bool: ``` # Input * `s1`: A string consisting of lowercase letters, representing the original data segment. * `s2`: A string consisting of lowercase letters, representing the received data segment. # Output * Return `True` if `s2` is a rotated version of `s1`. * Return `False` otherwise. # Constraints * Both `s1` and `s2` will have lengths between 0 and 10^4. * You must achieve a solution with a time complexity of O(N) and space complexity of O(N). # Example ```python assert is_rotated(\\"hello\\", \\"llohe\\") == True assert is_rotated(\\"hello\\", \\"elolh\\") == False assert is_rotated(\\"abcde\\", \\"cdeab\\") == True assert is_rotated(\\"abcde\\", \\"abced\\") == False ``` # Additional Notes * Ensure that your code is robust against edge cases where either or both strings are empty. * Efficiency is key; avoid using solutions with a time complexity greater than O(N).","solution":"def is_rotated(s1: str, s2: str) -> bool: Returns True if s2 is a rotated version of s1, else False. # Check if lengths are different if len(s1) != len(s2): return False # Check if s2 is in s1 concatenated with itself concatenated = s1 + s1 return s2 in concatenated"},{"question":"Scenario You are working as a network designer for a telecommunications company. You are tasked with designing a network link layout that minimizes the total cost of connecting all cities serviced by the company. However, you noticed that the system you are using does not handle disconnected cities well. Your task is to enhance the implementation to detect and handle such cases gracefully. Task Implement and optimize a function to find the weight of the minimum spanning tree (MST) of a connected, undirected graph, and handle cases where the graph is disconnected. The function should return `-1` if the graph is disconnected. Function Signature ```python def optimized_prims_minimum_spanning(graph: dict) -> int: Finds the weight of the minimum spanning tree (MST) of a connected graph and returns -1 if the graph is disconnected. Parameters: graph (dict): A dictionary representing an undirected graph where the keys are node identifiers and values are lists of tuples representing the edges and their weights. Returns: int: The total weight of the MST or -1 if the graph is disconnected. ``` Input Format * `graph`: A dictionary where: * Keys are unique node identifiers (could be strings or integers). * Values are lists of tuples/lists, each containing: * The weight of the edge. * The identifier of the adjacent node. Output Format * Return the total weight of the MST if the graph is connected. * Return `-1` if the graph is disconnected. Constraints * Graph will have at least one node and potentially multiple connected or disconnected components. * Edge weights will be positive integers. Example ```python graph1 = { \'a\': [[3, \'b\'], [8, \'c\']], \'b\': [[3, \'a\'], [5, \'d\']], \'c\': [[8, \'a\'], [2, \'d\'], [4, \'e\']], \'d\': [[5, \'b\'], [2, \'c\'], [6, \'e\']], \'e\': [[4, \'c\'], [6, \'d\']] } graph2 = { \'a\': [[3, \'b\']], \'b\': [[3, \'a\']], \'c\': [[2, \'d\']], \'d\': [[2, \'c\']] } assert optimized_prims_minimum_spanning(graph1) == 14 # The MST weight of connected graph1 assert optimized_prims_minimum_spanning(graph2) == -1 # Graph2 is disconnected ```","solution":"import heapq def optimized_prims_minimum_spanning(graph: dict) -> int: Finds the weight of the minimum spanning tree (MST) of a connected graph and returns -1 if the graph is disconnected. Parameters: graph (dict): A dictionary representing an undirected graph where the keys are node identifiers and values are lists of tuples representing the edges and their weights. Returns: int: The total weight of the MST or -1 if the graph is disconnected. if not graph: return 0 # Start with an arbitrary node (here, we start with the first node in the graph keys) start_node = next(iter(graph)) # Priority queue to select the edge with the smallest weight min_heap = [] for weight, adjacent in graph[start_node]: heapq.heappush(min_heap, (weight, start_node, adjacent)) # Set to keep track of visited nodes visited = set(start_node) total_weight = 0 while min_heap: weight, src, dest = heapq.heappop(min_heap) if dest not in visited: visited.add(dest) total_weight += weight for next_weight, next_dest in graph[dest]: if next_dest not in visited: heapq.heappush(min_heap, (next_weight, dest, next_dest)) if len(visited) == len(graph): return total_weight else: return -1"},{"question":"You are given the task of implementing a set of utility functions to convert numbers between different bases. The functions should handle both positive and negative numbers and work for bases ranging between 2 and 36. Function 1: `custom_int_to_base(num, base)` Implement the function `custom_int_to_base` that converts a given integer number (in decimal) to a specified base. - **Input**: - `num` (int): The integer number to be converted. - `base` (int): The base to convert the number to (between 2 and 36 inclusive). - **Output**: - A string representing the number in the specified base. Function 2: `custom_base_to_int(str_num, base)` Implement the function `custom_base_to_int` that converts a number from a specified base to a decimal integer. - **Input**: - `str_num` (str): The string representing the number in the given base. - `base` (int): The base of the number given as a string. - **Output**: - An integer representing the number in decimal. Constraints: - Both functions should handle bases ranging from 2 to 36. - The character set for bases includes digits (0-9) and uppercase alphabets (A-Z). - You may assume all inputs are valid for the given base. Examples: ```python # Example usage and output print(custom_int_to_base(5, 2)) # Output: \\"101\\" print(custom_int_to_base(-31, 16)) # Output: \\"-1F\\" print(custom_base_to_int(\'101\', 2)) # Output: 5 print(custom_base_to_int(\'1F\', 16)) # Output: 31 ``` # Notes: - You can use Python\'s built-in `int` function in `custom_base_to_int`, but avoid using it for practice purposes. - Negative numbers should be handled correctly by adding a \'-\' sign in the output for `custom_int_to_base` and interpreting it correctly in `custom_base_to_int`. Make sure your implementation is clean, efficient and handles edge cases effectively.","solution":"def custom_int_to_base(num, base): Convert an integer to a specified base, handling both positive and negative numbers. Parameters: - num (int): The integer number to be converted. - base (int): The base to convert the number to (between 2 and 36 inclusive). Returns: - str: The string representation of the number in the specified base. if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" sign = \\"-\\" if num < 0 else \\"\\" num = abs(num) result = [] while num: result.append(digits[num % base]) num //= base return sign + \'\'.join(reversed(result)) def custom_base_to_int(str_num, base): Convert a number from a specified base to a decimal integer, handling both positive and negative numbers. Parameters: - str_num (str): The string representing the number in the given base. - base (int): The base of the number given as a string. Returns: - int: The integer representation of the number in decimal. digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" value_map = {digits[i]: i for i in range(36)} sign = -1 if str_num[0] == \'-\' else 1 if str_num[0] in \\"-+\\": str_num = str_num[1:] result = 0 for char in str_num: result = result * base + value_map[char] return sign * result"},{"question":"# Matrix Multiplication Given two two-dimensional matrices `multiplicand` and `multiplier`, your task is to implement a function that returns the product of these two matrices. The two matrices provided will always contain integer values. Function Signature ```python def multiply(multiplicand: list, multiplier: list) -> list: ``` Input * `multiplicand` (List[List[int]]): A 2D list representing the first matrix. * `multiplier` (List[List[int]]): A 2D list representing the second matrix. Output * A 2D list representing the result of the matrix multiplication. Constraints * The number of columns of the multiplicand must equal the number of rows of the multiplier. * Both matrices can contain positive or negative integers or zeros. * Matrices dimensions will not exceed 100x100 for purposes of this assessment. Example ```python multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] result = multiply(multiplicand, multiplier) # result should be: # [ # [58, 64], # [139, 154] # ] ``` Scenario In a graphics rendering application, transforming vector coordinates often involves multiplying matrices that represent different transformations (scaling, rotation, translation). Implementing efficient and correct matrix multiplication is crucial for ensuring accurate graphical transformations. Requirements * Ensure your solution validates the compatibility of the matrices first before attempting multiplication. * Consider edge cases related to matrix dimensions and ensure exceptions are appropriately raised.","solution":"def multiply(multiplicand, multiplier): Multiplies two matrices and returns the resulting matrix. Args: multiplicand (List[List[int]]): The first matrix. multiplier (List[List[int]]): The second matrix. Returns: List[List[int]]: The product of the two matrices. if not multiplicand or not multiplier: raise ValueError(\\"Matrices cannot be empty\\") rows_multiplicand = len(multiplicand) cols_multiplicand = len(multiplicand[0]) rows_multiplier = len(multiplier) cols_multiplier = len(multiplier[0]) if cols_multiplicand != rows_multiplier: raise ValueError(\\"Number of columns of the multiplicand must equal the number of rows of the multiplier\\") # Create result matrix with all zeros. result = [[0 for _ in range(cols_multiplier)] for _ in range(rows_multiplicand)] # Perform matrix multiplication for i in range(rows_multiplicand): for j in range(cols_multiplier): for k in range(cols_multiplicand): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Element Frequency Limiter Given a list `lst` of integers and a number `N`, write a function `limit_occurrences(lst, N)` that returns a new list containing each number of the list at most `N` times without changing the order of the original list. Your implementation should be efficient in terms of both time and space complexity. Input - `lst` : A list of integers [a1, a2, ..., am] (0 <= m <= 10^6; -10^6 <= ai <= 10^6) - `N` : An integer (0 <= N <= 10^6) Output - A list of integers containing each number of `lst` at most `N` times. Constraints - Do not change the order of elements in the returned list. - Aim for an O(n) time complexity with n being the length of `lst`. Examples ```python # Example 1: lst = [1, 2, 3, 1, 2, 1, 2, 3] N = 2 print(limit_occurrences(lst, N)) # Output: [1, 2, 3, 1, 2, 3] # Example 2: lst = [20, 37, 20, 21] N = 1 print(limit_occurrences(lst, N)) # Output: [20, 37, 21] ``` Note Ensure your solution is optimized for large lists and handles edge cases effectively.","solution":"def limit_occurrences(lst, N): Returns a new list containing each number of the original list at most N times. if N == 0: return [] from collections import defaultdict result = [] occurrence_count = defaultdict(int) for num in lst: if occurrence_count[num] < N: result.append(num) occurrence_count[num] += 1 return result"},{"question":"You are tasked with processing a string to remove any recurring characters and return a new string that contains only the first occurrences of each character in their original order. This means each character in the resulting string should appear only once, and should appear in the same order as their first occurrence in the input string. Function Signature ```python def delete_reoccurring_characters(string: str) -> str: ``` # Input * `string` (str): A string consisting of lowercase and uppercase alphabetical characters. # Output * Returns a new string with all recurring characters removed. # Constraints * The maximum possible length of the input string is 10^5 characters. # Performance Requirements * Time complexity should be O(n), where n is the length of the string. * Space complexity should be O(n), considering the additional memory used for tracking characters. # Examples Example 1 **Input**: \\"google\\" **Output**: \\"gole\\" **Explanation**: The characters \'g\' and \'o\' at positions 1 and 2 reoccur, hence only their first appearances and other characters \'l\' and \'e\' are included in the output. Example 2 **Input**: \\"alphabet\\" **Output**: \\"alphbet\\" **Explanation**: The characters \'a\' and \'l\' occur more than once, thus only their first appearances along with other unique characters are included in the output. Example 3 **Input**: \\"aabbcc\\" **Output**: \\"abc\\" **Explanation**: Each character reoccurs, so only their first occurrences are retained. # Edge Cases * An empty string should return an empty string. Remember to handle these cases. The provided algorithm should maintain linear time complexity and use an additional set structure for the deduplication process.","solution":"def delete_reoccurring_characters(string: str) -> str: This function removes recurring characters from the input string and returns a new string containing only the first occurrences of each character in their original order. :param string: A string consisting of lowercase and uppercase alphabetical characters. :return: A new string with recurring characters removed. seen = set() result = [] for char in string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"Union-Find in Practice You are given a grid of `n x m` initially filled with water (represented by 0). You will be given a list of positions where land (represented by 1) is added sequentially. Your task is to implement a function that after each new land addition, returns the number of distinct islands. An island is a group of adjacent lands connected horizontally or vertically. **Function Signature**: ```python def num_islands(n: int, m: int, positions: List[List[int]]) -> List[int]: pass ``` Input - `n` (1 <= n <= 1000): An integer representing the number of rows in the grid. - `m` (1 <= m <= 1000): An integer representing the number of columns in the grid. - `positions` (1 <= len(positions) <= 1000): A list of integer lists, each represents a position where a new land is added. Output - Returns a list of integers, where the `i`-th integer is the number of islands after the `i`-th addLand operation. Constraints - Initially, every cell in the grid is water. - Each position in the input list is a valid position in the grid. - Positions may contain duplicates. For a position already containing land, no change should occur, and the number of islands should remain the same. Example ```python assert num_islands(3, 3, [[0,0], [0,1], [1,2], [2,1]]) == [1, 1, 2, 3] assert num_islands(3, 3, [[0,0], [0,1], [1,2], [1,2], [2,1]]) == [1, 1, 2, 2, 3] ``` Requirements 1. Implement the Union-Find data structure with path compression and union by rank/size. 2. Track the number of distinct islands after each addLand operation. 3. Handle the case where the position already contains land by keeping the count unchanged. Tips - Make use of the Union-Find for dynamic connectivity. - Ensure path compression and union by rank/size to optimize the operations.","solution":"from typing import List class UnionFind: def __init__(self, size: int): self.parent = list(range(size)) self.rank = [1] * size self.count = 0 def find(self, x: int) -> int: if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) # Path compression return self.parent[x] def union(self, x: int, y: int) -> bool: root_x = self.find(x) root_y = self.find(y) if root_x != root_y: if self.rank[root_x] > self.rank[root_y]: self.parent[root_y] = root_x elif self.rank[root_x] < self.rank[root_y]: self.parent[root_x] = root_y else: self.parent[root_y] = root_x self.rank[root_x] += 1 self.count -= 1 return True return False def set_count(self, num: int): self.count = num def increase_count(self): self.count += 1 def get_count(self) -> int: return self.count def num_islands(n: int, m: int, positions: List[List[int]]) -> List[int]: if not positions: return [] uf = UnionFind(n * m) grid = [[0] * m for _ in range(n)] result = [] for r, c in positions: if grid[r][c] == 1: result.append(uf.get_count()) continue grid[r][c] = 1 uf.increase_count() current = r * m + c for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)): nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and grid[nr][nc] == 1: neighbor = nr * m + nc uf.union(current, neighbor) result.append(uf.get_count()) return result"},{"question":"**Problem Statement:** You are a part of a team developing a recommendation system for a text-based application. Your task is to implement a function that calculates the cosine similarity between two input vectors. This measure will help in determining the similarity between user preferences, allowing the system to recommend relevant content. # Task: Implement the function `cosine_similarity()` that computes the cosine similarity between two equal-length vectors. # Function Signature: ```python def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: pass ``` # Input: - `vec1`: A list of floats representing the first vector (1 ≤ len(vec1) ≤ 10^5) - `vec2`: A list of floats representing the second vector. It is guaranteed that `vec1` and `vec2` are of the same length. # Output: - A single float representing the cosine similarity between the input vectors. # Constraints: - Vectors will have at least one element. - Ensure your implementation handles edge cases such as vectors containing zeros appropriately to avoid division by zero errors. # Examples: ```python >>> cosine_similarity([1, 1, 1], [1, 2, -1]) 0.47140452079103173 >>> cosine_similarity([0, 0, 0], [0, 0, 0]) Traceback (most recent call last): ... ZeroDivisionError: float division by zero >>> cosine_similarity([1, 0], [0, 1]) 0.0 ``` # Notes: - Raise a `ValueError` if the input vectors do not have the same length. - If either vector has a zero norm, handle it appropriately to avoid division by zero errors. Return `0.0` for zero-norm vectors. - Pay attention to the performance of your function to ensure it can handle the upper limits of input sizes efficiently.","solution":"from typing import List import math def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: Compute the cosine similarity between two equal-length vectors. Args: vec1: A list of floats representing the first vector vec2: A list of floats representing the second vector Returns: A single float representing the cosine similarity between the input vectors. Raises: ValueError: If the input vectors do not have the same length ZeroDivisionError: If the norm of any vector is zero if len(vec1) != len(vec2): raise ValueError(\\"Input vectors must have the same length\\") dot_product = sum(a * b for a, b in zip(vec1, vec2)) norm_vec1 = math.sqrt(sum(a * a for a in vec1)) norm_vec2 = math.sqrt(sum(b * b for b in vec2)) if norm_vec1 == 0.0 or norm_vec2 == 0.0: return 0.0 # Avoid division by zero for zero-vector norms return dot_product / (norm_vec1 * norm_vec2)"},{"question":"Implement a function that matches a string against a pattern containing the special characters \'.\' and \'*\'. * \'.\' matches any single character. * \'*\' matches zero or more of the preceding element. The function should return `True` if the string matches the pattern completely, and `False` otherwise. # Function Signature ```python def is_match(s: str, p: str) -> bool: ``` # Input * `s`: A non-empty string of length n (1 ≤ n ≤ 1000). * `p`: A non-empty string of length m (1 ≤ m ≤ 1000), containing lowercase letters along with the characters \'.\' and \'*\'. # Output * Return `True` if `s` matches the pattern `p`, `False` otherwise. # Constraint * The matching should cover the entire input string (not partial). Here\'s how some standard cases should behave: * `is_match(\\"aa\\", \\"a\\")` should return `False`. * `is_match(\\"aa\\", \\"aa\\")` should return `True`. * `is_match(\\"aaa\\", \\"aa\\")` should return `False`. * `is_match(\\"aa\\", \\"a*\\")` should return `True`. * `is_match(\\"aa\\", \\".*\\")` should return `True`. * `is_match(\\"ab\\", \\".*\\")` should return `True`. * `is_match(\\"aab\\", \\"c*a*b\\")` should return `True`. # Example ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"aa\\") == True assert is_match(\\"aaa\\", \\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` Constraints * Implement this function keeping both time and space efficiency in mind. * Ensure all possible edge cases are considered.","solution":"def is_match(s: str, p: str) -> bool: Returns True if the string s matches the pattern p, otherwise returns False. The pattern p may contain \'.\' which matches any single character, and \'*\' which matches zero or more of the preceding element. # Dynamic programming table dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True # Both s and p are empty # Handle patterns like a*, a*b*, a*b*c* etc. for j in range(2, len(p) + 1): if p[j-1] == \'*\': dp[0][j] = dp[0][j-2] for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j-1] == s[i-1] or p[j-1] == \'.\': dp[i][j] = dp[i-1][j-1] elif p[j-1] == \'*\': dp[i][j] = dp[i][j-2] # Match zero occurrences of the preceding element if p[j-2] == s[i-1] or p[j-2] == \'.\': dp[i][j] = dp[i][j] or dp[i-1][j] # Match one or more occurrences of the preceding element return dp[len(s)][len(p)]"},{"question":"# Symmetric Binary Tree Check Given a binary tree, write two functions `is_symmetric_recursive` and `is_symmetric_iterative` to check whether it is a mirror of itself (i.e., symmetric around its center). Definitions - **Symmetric Tree**: A binary tree is symmetric if the left subtree is a mirror reflection of the right subtree. Expected Input and Output - **Input**: - A binary tree node `root`, represented as an object with attributes `val`, `left`, and `right`. - **Output**: - A boolean value: `True` if the tree is symmetric, `False` otherwise. Constraints - The number of nodes in the tree is in the range `[1, 10^4]`. - -100 <= Node.val <= 100 Performance Requirements - The time complexity for both solutions should be O(n). - The space complexity for the recursive solution should be O(h) (h is the tree height), and for the iterative solution should be O(n). Scenario Context Suppose you have a tree structure and you need to determine if it\'s symmetric to ensure data consistency in a distributed system where each node mirrors its sibling node. Use the following class definition for the binary tree nodes: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Functions Implement the following functions: ```python def is_symmetric_recursive(root): # Your code here def is_symmetric_iterative(root): # Your code here ``` Example For a symmetric tree: ``` 1 / 2 2 / / 3 4 4 3 ``` `is_symmetric_recursive(root)` and `is_symmetric_iterative(root)` should return `True`. For a non-symmetric tree: ``` 1 / 2 2 3 3 ``` `is_symmetric_recursive(root)` and `is_symmetric_iterative(root)` should return `False`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric_recursive(root): def is_mirror(t1, t2): if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val) and is_mirror(t1.right, t2.left) and is_mirror(t1.left, t2.right) if not root: return True return is_mirror(root.left, root.right) def is_symmetric_iterative(root): if not root: return True queue = [(root.left, root.right)] while queue: t1, t2 = queue.pop(0) if not t1 and not t2: continue if not t1 or not t2: return False if t1.val != t2.val: return False queue.append((t1.left, t2.right)) queue.append((t1.right, t2.left)) return True"},{"question":"# Markov Chain Simulator **Scenario**: You have been hired to build a simulation tool for weather prediction based on a Markov Chain model. The states in this model represent different weather conditions (e.g., Sunny, Rainy, Cloudy), with predefined transition probabilities for moving from one weather condition to another. **Problem**: Implement a function `weather_simulation(chain, start_state, steps)` that simulates the weather over a specified number of steps, given a transition chain and an initial state. **Function Signature**: ```python def weather_simulation(chain: dict, start_state: str, steps: int) -> list: ``` **Input**: - `chain`: A dictionary representing the Markov Chain transition probabilities. For example: ```python { \'Sunny\': {\'Sunny\': 0.7, \'Rainy\': 0.2, \'Cloudy\': 0.1}, \'Rainy\': {\'Sunny\': 0.3, \'Rainy\': 0.4, \'Cloudy\': 0.3}, \'Cloudy\': {\'Sunny\': 0.4, \'Rainy\': 0.4, \'Cloudy\': 0.2} } ``` - `start_state`: A string representing the initial weather condition. - `steps`: An integer indicating the number of simulation steps. **Output**: - A list of strings representing the sequence of weather states from the simulation. **Constraints**: - The transition probabilities for each state sum to 1. - `start_state` is a valid state within the chain. - `steps` is a positive integer. **Performance Requirements**: - The implementation should efficiently handle a Markov Chain with up to 100 different states and 100 steps. # Example: ```python chain = { \'Sunny\': {\'Sunny\': 0.7, \'Rainy\': 0.2, \'Cloudy\': 0.1}, \'Rainy\': {\'Sunny\': 0.3, \'Rainy\': 0.4, \'Cloudy\': 0.3}, \'Cloudy\': {\'Sunny\': 0.4, \'Rainy\': 0.4, \'Cloudy\': 0.2} } start_state = \'Sunny\' steps = 5 # Example Output # [\'Sunny\', \'Sunny\', \'Rainy\', \'Cloudy\', \'Sunny\'] ``` Write your function implementation below: ```python import random def __choose_state(state_map): choice = random.random() probability_reached = 0 for state, probability in state_map.items(): probability_reached += probability if probability_reached > choice: return state return None def next_state(chain, current_state): next_state_map = chain.get(current_state) return __choose_state(next_state_map) def weather_simulation(chain, start_state, steps): state = start_state result = [state] for _ in range(steps): state = next_state(chain, state) result.append(state) return result ```","solution":"import random def __choose_state(state_map): choice = random.random() probability_reached = 0 for state, probability in state_map.items(): probability_reached += probability if probability_reached > choice: return state return None def next_state(chain, current_state): next_state_map = chain.get(current_state) return __choose_state(next_state_map) def weather_simulation(chain, start_state, steps): Simulates the weather based on a Markov Chain model. Parameters: - chain (dict): Dictionary representing the transition probabilities. - start_state (str): Initial weather condition. - steps (int): Number of simulation steps. Returns: - list: Sequence of weather states. state = start_state result = [state] for _ in range(steps): state = next_state(chain, state) result.append(state) return result"},{"question":"# Problem Description You are tasked with implementing a specialized queue designed to handle restocking operations in a warehouse. The warehouse operates in a FIFO manner where the oldest items restocked should be moved out first. This queue can dynamically adjust its size, and you must ensure efficient operations in terms of both time and space complexity. # Task Implement the `WarehouseRestockQueue`, including the following methods: 1. `enqueue(item)` - Adds an item to the rear of the queue. 2. `dequeue()` - Removes and returns the item from the front of the queue. 3. `is_empty()` - Checks if the queue is empty. 4. `size()` - Returns the number of items in the queue. 5. `peek()` - Returns the item at the front without removing it. This implementation should handle edge cases and be optimized for performance. # Input & Output Formats * The `enqueue(item)` method will take a single element, `item`, to be added. * The `dequeue()` method will return the item removed from the front. * The `is_empty()` method will return a boolean indicating if the queue is empty. * The `size()` method will return an integer representing the number of items in the queue. * The `peek()` method will return the item at the front without removing it. # Constraints * Ensure operations handle cases where the queue might be empty. * Optimize memory usage where possible. # Example ```python queue = WarehouseRestockQueue() queue.enqueue(\'item1\') queue.enqueue(\'item2\') print(queue.peek()) # Output: \'item1\' print(queue.size()) # Output: 2 print(queue.dequeue()) # Output: \'item1\' print(queue.is_empty()) # Output: False print(queue.dequeue()) # Output: \'item2\' print(queue.is_empty()) # Output: True ``` # Guidance on Implementation You may leverage either array-based or linked list-based queue approaches based on their strengths. Here\'s a suggestion: * Use dynamic arrays with careful management of capacity to avoid frequent expansions. * Ensure that the implementation is robust and handles edge cases effectively, such as empty queues.","solution":"class WarehouseRestockQueue: def __init__(self): self.queue = [] def enqueue(self, item): self.queue.append(item) def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from an empty queue\\") return self.queue.pop(0) def is_empty(self): return len(self.queue) == 0 def size(self): return len(self.queue) def peek(self): if self.is_empty(): raise IndexError(\\"peek from an empty queue\\") return self.queue[0]"},{"question":"You are tasked with developing a function that finds all unique n-tuplets in a list of numbers, such that they sum up to a given target. To accommodate various scenarios, you will implement a recursive function with customizable sum, comparison, and equality check mechanisms through closures. # Function Signature ```python def n_sum(n: int, nums: List[int], target: int, sum_closure: Callable[[int, int], int] = None, compare_closure: Callable[[int, int], int] = None, same_closure: Callable[[int, int], bool] = None ) -> List[List[int]]: pass ``` # Input * `n` (int): the number of elements in each tuple. * `nums` (List[int]): a list of integers. * `target` (int): the target sum for the n-tuplets. * `sum_closure` (Callable[[int, int], int], optional): A function to summarize two elements of `nums`. Defaults to addition. * `compare_closure` (Callable[[int, int], int], optional): A function to compare the summation result with the target. It returns -1 if less than, 0 if equal to, and 1 if greater than the target. Defaults to comparison. * `same_closure` (Callable[[int, int], bool], optional): A function to check for equality between two numbers. Defaults to equality comparison. # Output * Returns a list of unique lists where each list contains `n` integers, which sum to the `target`. # Example Example 1: ```python n = 4 nums = [1, 0, -1, 0, -2, 2] target = 0 n_sum_closure = lambda a, b: a + b compare_closure = lambda num, target: (num > target) - (num < target) same_closure = lambda a, b: a == b output = n_sum(n, nums, target, n_sum_closure, compare_closure, same_closure) print(output) # Expected Output: [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] ``` Example 2: ```python n = 2 nums = [[-3, 0], [-2, 1], [2, 2], [3, 3], [8, 4], [-9, 5]] target = -5 n_sum_closure = lambda a, b: [a[0] + b[1], a[1] + b[0]] compare_closure = lambda num, target: (num[0] > target) - (num[0] < target) same_closure = lambda a, b: a == b output = n_sum(n, nums, target, n_sum_closure, compare_closure, same_closure) print(output) # Expected Output: [[[-9, 5], [8, 4]] ``` # Constraints * All numbers in nums are integers. * The length of nums is between 1 and 2000. * The value of n is between 2 and 10. * The target can be any integer. # Notes * You may assume the input list will only contain integers and the list will not be empty. * The implementation should handle custom closures accurately and fall back to defaults if not provided. * Consider edge cases such as no possible combination or input lists too small to form any valid n-tuplet.","solution":"from typing import List, Callable def n_sum(n: int, nums: List[int], target: int, sum_closure: Callable[[int, int], int] = None, compare_closure: Callable[[int, int], int] = None, same_closure: Callable[[int, int], bool] = None ) -> List[List[int]]: if sum_closure is None: sum_closure = lambda a, b: a + b if compare_closure is None: compare_closure = lambda num, target: (num > target) - (num < target) if same_closure is None: same_closure = lambda a, b: a == b def find_n_sum(path, start, target, n): if n == 2: left, right = start, len(nums) - 1 while left < right: current_sum = sum_closure(nums[left], nums[right]) comparison = compare_closure(current_sum, target) if comparison == 0: result.append(path + [nums[left], nums[right]]) left += 1 right -= 1 while left < right and same_closure(nums[left], nums[left - 1]): left += 1 while left < right and same_closure(nums[right], nums[right + 1]): right -= 1 elif comparison < 0: left += 1 else: right -= 1 else: for i in range(start, len(nums) - n + 1): if i > start and same_closure(nums[i], nums[i - 1]): continue find_n_sum(path + [nums[i]], i + 1, target - nums[i], n - 1) nums.sort() result = [] find_n_sum([], 0, target, n) return result"},{"question":"You are provided with an implementation of a resizable hash table. The `ResizableHashTable` class extends the base `HashTable` class and adds dynamic resizing when the hash table becomes more than two-thirds full. It uses linear probing for collision resolution and employs a simple modulo-based hash function. The resizing algorithm doubles the size of the hash table and rehashes all existing entries when the load factor exceeds the predefined threshold. A hash table is a common data structure that provides efficient O(1) average-time complexity for lookup, insertion, and deletion operations. However, implementing it efficiently, especially with dynamic resizing and proper handling of collisions, can be challenging. Your task is to implement a function that queries this hash table and returns a list of key-value pairs in the current hash table in the following format: `[(key1, value1), (key2, value2), ...]`. Function Signature ```python def get_all_items(ht: ResizableHashTable) -> list: pass ``` # Input * `ht (ResizableHashTable)`: An instance of the `ResizableHashTable`. # Output * `list`: A list of tuples, each consisting of a key and its corresponding value in the hash table. # Constraints * The key-value pairs should be listed in the order they appear in the hash table (based on their probing sequence). * Do not include deleted entries (‘_deleted’) in the output. Example ```python ht = ResizableHashTable() ht.put(1, \'a\') ht.put(2, \'b\') ht.put(3, \'c\') ht.put(4, \'d\') print(get_all_items(ht)) # Output: [(1, \'a\'), (2, \'b\'), (3, \'c\')] ht.del_(2) print(get_all_items(ht)) # Output: [(1, \'a\'), (3, \'c\')] ht.put(5, \'e\') print(get_all_items(ht)) # Output: [(1, \'a\'), (3, \'c\'), (5, \'e\')] ``` # Performance Consideration Ensure your function operates in O(n) time complexity, where n is the number of slots in the hash table. Avoiding unnecessary operations and handling the edge cases, like deleted markers, correctly is crucial for the performance and correctness of your solution.","solution":"class ResizableHashTable: A simple implementation of a dynamically resizable hash table with linear probing. def __init__(self): self.size = 8 self.count = 0 self.table = [None] * self.size self.deleted = \\"_deleted\\" def _hash(self, key): return key % self.size def put(self, key, value): if self.count / self.size > 2/3: self._resize() idx = self._hash(key) while self.table[idx] is not None and self.table[idx] != self.deleted: idx = (idx + 1) % self.size if self.table[idx] is None: self.count += 1 self.table[idx] = (key, value) def get(self, key): idx = self._hash(key) while self.table[idx] is not None: if self.table[idx] != self.deleted and self.table[idx][0] == key: return self.table[idx][1] idx = (idx + 1) % self.size return None def del_(self, key): idx = self._hash(key) while self.table[idx] is not None: if self.table[idx] != self.deleted and self.table[idx][0] == key: self.table[idx] = self.deleted self.count -= 1 return True idx = (idx + 1) % self.size return False def _resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.count = 0 for item in old_table: if item is not None and item != self.deleted: self.put(item[0], item[1]) def get_all_items(ht: ResizableHashTable) -> list: Returns a list of key-value pairs in the current hash table. items = [] for entry in ht.table: if entry is not None and entry != ht.deleted: items.append(entry) return items"},{"question":"# Abbreviation Generator Challenge **Context**: You are working on a text processing tool that needs to generate all unique abbreviations of a given word. An abbreviation of a word is defined as replacing one or more characters with their count of consecutive occurrences. **Task**: Implement a function `generate_abbreviations(word)` which takes a single string input `word` and returns a list of all possible abbreviations. **Function Signature**: ```python def generate_abbreviations(word: str) -> list: pass ``` # Input - `word`: A string (0 <= len(word) <= 20). # Output - A list of strings, each representing a unique abbreviation of the input word. # Constraints - The length of the input string will be between 0 and 20 inclusive. - The output list should include all possible abbreviations. # Example: ```python print(generate_abbreviations(\\"word\\")) # Output: [\'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\'] ``` # Requirements: - Your solution should demonstrate an understanding of recursive algorithms and backtracking. - Pay attention to the handling of edge cases such as empty strings. # Edge Cases: 1. Empty string should return `[\\"\\"]`. 2. Single character string like `\\"a\\"` should return `[\\"a\\", \\"1\\"]`. Good luck, and make sure to thoroughly test your implementation to cover all mentioned edge cases!","solution":"def generate_abbreviations(word: str) -> list: def backtrack(pos, current, count): if pos == len(word): if count > 0: current += str(count) result.append(current) else: # Option 1: Abbreviate the current character backtrack(pos + 1, current, count + 1) # Option 2: Keep the current character if count > 0: current += str(count) backtrack(pos + 1, current + word[pos], 0) result = [] backtrack(0, \\"\\", 0) return result"},{"question":"Problem: Spiral Matrix Traversal You are given a matrix of integers with `m` rows and `n` columns. Your task is to write a function that traverses this matrix in spiral order and returns all the elements in a single list. # Function Signature ```python def spiral_traversal(matrix: List[List[int]]) -> List[int]: pass ``` # Input * `matrix`: A list of lists of integers representing an `m x n` matrix (where `m` is the number of rows and `n` is the number of columns). # Output * Return a list of integers representing the elements of the matrix traversed in spiral order. # Constraints * `0 <= m, n <= 100` * `-10^9 <= matrix[i][j] <= 10^9` for `0 <= i < m` and `0 <= j < n` # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(spiral_traversal(matrix)) # Output: [1, 2, 3, 6, 9, 8, 7, 4, 5] ``` # Scenario Consider a robotic arm on a conveyor belt that is programmed to pick items arranged in a grid pattern. The arm needs to pick up each item in a clockwise spiral order. Your function helps determine the sequence of pick-up points for the robotic arm. # Notes - Ensure to handle special cases such as an empty matrix, a matrix with a single row, or a matrix with a single column. - Implement the solution with optimal performance considering the time and space complexities.","solution":"from typing import List def spiral_traversal(matrix: List[List[int]]) -> List[int]: if not matrix or not matrix[0]: return [] result = [] top, bottom = 0, len(matrix) - 1 left, right = 0, len(matrix[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right for col in range(left, right + 1): result.append(matrix[top][col]) top += 1 # Traverse downwards for row in range(top, bottom + 1): result.append(matrix[row][right]) right -= 1 if top <= bottom: # Traverse from right to left for col in range(right, left - 1, -1): result.append(matrix[bottom][col]) bottom -= 1 if left <= right: # Traverse upwards for row in range(bottom, top - 1, -1): result.append(matrix[row][left]) left += 1 return result"},{"question":"Given an encoded message containing digits from \'0\' to \'9\', each digit or combination of two digits represent an alphabet character as follows: ``` \'A\' -> 1 \'B\' -> 2 ... \'Z\' -> 26 ``` Your task is to determine the total number of ways to decode a given encoded message `enc_mes`. # Objectives 1. Implement a function `num_decodings(enc_mes: str) -> int` that returns the total number of ways to decode the given encoded message. 2. Optimize your solution in terms of time and space complexity. # Constraints 1. The input string `enc_mes` has a length between 1 and 1000. 2. The encoded message contains only digits and does not begin with \'0\'. # Input - An encoded message as a string `enc_mes`. # Output - Return an integer representing the total number of ways to decode the message. # Examples Example 1: ```python enc_mes = \\"12\\" # Explanation: It could be decoded as \\"AB\\" (1 2) or \\"L\\" (12). # Output: 2 ``` Example 2: ```python enc_mes = \\"226\\" # Explanation: It could be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6). # Output: 3 ``` Example 3: ```python enc_mes = \\"10\\" # Explanation: It could be decoded as \\"J\\" (10), but cannot be \\"A0\\" (1 0). # Output: 1 ``` # Guidelines - Ensure your solution handles edge cases such as strings with \'0\'s as well as large input sizes efficiently. - Aim to achieve a solution with O(n) time complexity and O(1) auxiliary space complexity.","solution":"def num_decodings(enc_mes: str) -> int: Returns the total number of ways to decode the given encoded message. if not enc_mes or enc_mes[0] == \'0\': return 0 n = len(enc_mes) dp = [0] * (n + 1) # Base case initialization dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): # Check single digit decode possibility if enc_mes[i-1] != \'0\': dp[i] += dp[i-1] # Check double digit decode possibility if 10 <= int(enc_mes[i-2:i]) <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"# Question: Two Sum Problem **Context**: You are given an array of integers sorted in ascending order. Your task is to find two distinct integers in the array such that their sum equals a given target number. Each input will have exactly one solution, and you may not use the same element twice. **Function Signature**: ```python def two_sum_custom(numbers: List[int], target: int) -> List[int]: pass ``` **Requirements**: - Implement the function `two_sum_custom` that finds the indices of the two distinct integers that add up to the target. - Ensure that the smaller index is returned first in the output list. - Input array is 1-indexed (the first element is index 1). **Input**: - `numbers` - A list of n integers, sorted in ascending order. - `target` - Integer target sum. **Output**: - A list of two integers representing the indices (1-indexed) of the two numbers that add up to the target. **Constraints**: - The list will have at least two integer elements and at most 100,000 elements. - Each input would have exactly one solution. - The list only contains integer values. **Examples**: 1. Input: `numbers = [2, 7, 11, 15]`, `target = 9` Output: `[1, 2]` 2. Input: `numbers = [1, 2, 3, 4, 4, 9, 56, 90]`, `target = 8` Output: `[4, 5]` 3. Input: `numbers = [5, 25, 75]`, `target = 100` Output: `[2, 3]` **Performance Note**: The function should be optimized for both time and space complexity. Choose an algorithm that balances these factors effectively, given the constraints of the problem. **Additional Information**: - Ensure to handle edge cases effectively. - Validate that the input array is sorted and non-empty. - The order of returned indices should be ascending.","solution":"from typing import List def two_sum_custom(numbers: List[int], target: int) -> List[int]: Finds two distinct integers in the sorted array numbers that add up to the target. Returns a list containing the 1-indexed positions of these numbers. left = 0 right = len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1 return []"},{"question":"# Bogo Sort Implementation and Analysis Context: Bogo Sort is often considered a joke among computer scientists due to its exceptionally poor performance characteristics and is rarely used in practice. However, it serves as an excellent didactic tool to highlight the importance of algorithmic efficiency and feasibility. Your task is to improve a given implementation of Bogo Sort while analyzing and reflecting on its performance potential and limitations. Task: 1. **Implementation**: - Write a function `bogo_sort_improved` that sorts a list using the Bogo Sort paradigm. Enhance the basic implementation to handle common edge cases. - Ensure your function is capable of limiting the maximum number of iterations to avoid infinite loops on large datasets. - Add functionality to log the number of iterations taken to sort the array. 2. **Analysis**: - Describe the pros and cons of the Bogo Sort algorithm in your own words. - Compare Bogo Sort with more efficient sorting algorithms like Quick Sort and Merge Sort. - Analyze under which conditions the Bogo Sort might be preferable to use, if any. Function Signature: ```python def bogo_sort_improved(arr: list, max_iterations: int = 100000) -> (list, int): Sorts the array using Bogo Sort with an iteration limit :param arr: List of integers to be sorted :param max_iterations: Maximum number of iterations allowed to prevent infinite loops :return: Tuple containing the sorted list and the number of iterations used ``` Input: - `arr`: List of integers to be sorted. - Example: `[3, 1, 4, 1, 5]` - `max_iterations`: Maximum number of iterations (default = 100000). Output: - A tuple where the first element is the sorted list, and the second element is the number of iterations taken to sort the array. - Example: `([1, 1, 3, 4, 5], 500)` Constraints: - The list can have a maximum of 10 elements due to the typical inefficiency of the Bogo Sort algorithm. - Values in the list are integers ranging from (-10^6) to (10^6). Performance Requirements: - The function should not exceed the defined maximum number of iterations. - The function should handle empty and single element list efficiently. Good luck, and remember to include your analysis in the comments or as a separate function docstring!","solution":"import random def is_sorted(arr): Helper function to check if the array is sorted. return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) def bogo_sort_improved(arr, max_iterations=100000): Sorts the array using Bogo Sort with an iteration limit. :param arr: List of integers to be sorted :param max_iterations: Maximum number of iterations allowed to prevent infinite loops :return: Tuple containing the sorted list and the number of iterations used iterations = 0 while not is_sorted(arr) and iterations < max_iterations: random.shuffle(arr) iterations += 1 return arr, iterations # Analysis: Pros: - Conceptually simple and easy to understand. - Useful for educational purposes to illustrate the importance of algorithmic efficiency. Cons: - Extremely inefficient with a factorial time complexity of O(n!). - Impractical for even moderately sized lists. Comparison with Quick Sort and Merge Sort: - Both Quick Sort and Merge Sort have much better performance characteristics with O(n log n) average time complexity. - Quick Sort is often faster in practice due to efficient cache performance. - Merge Sort has a predictable O(n log n) time complexity and is stable, meaning it maintains the relative order of equal elements. When to prefer Bogo Sort: - Only in academic or entertainment contexts, like demonstrating algorithmic inefficiencies. - Never in practical applications due to its unpredictable and often unbounded execution time."},{"question":"Scenario You have been tasked with writing a function for cleaning up a list of products by eliminating all duplicates while maintaining the original order. This function is crucial for preprocessing product lists before performing further analysis. Task Write a function `remove_reoccurring_characters(string)` that takes a single string as input and returns a new string with all recurring characters removed. The function should maintain the order of the first occurrence of each character. Specifications: - **Function Name**: `remove_reoccurring_characters` - **Input**: A string `string` of length `n` (1 ≤ n ≤ 10^5). - **Output**: A string containing only the first occurrence of each character from the input string in their original order. Constraints: - Each character in the string will be an ASCII character. Examples: ```python remove_reoccurring_characters(\\"google\\") # Expected output: \\"gole\\" remove_reoccurring_characters(\\"programming\\") # Expected output: \\"progamin\\" remove_reoccurring_characters(\\"aabbcc\\") # Expected output: \\"abc\\" ``` Notes: - Ensure the function is efficient with respect to both time and space complexity. - Consider common edge cases such as an empty string and strings with non-repeating characters.","solution":"def remove_reoccurring_characters(string): Takes a single string as input and returns a new string with all recurring characters removed. Maintains the order of the first occurrence of each character. seen = set() result = [] for char in string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"You are tasked with implementing a function that rearranges an input list by moving all zero elements to the end of the list, while preserving the order of the other elements. This task involves straight-forward list manipulation but requires careful management of different data types and edge cases. # Function Signature ```python def move_zeros(array: list) -> list: ``` # Input * `array` (list): A list of elements which can include integers, booleans, strings, etc. # Output * Returns a list with all zeros moved to the end, preserving the order of the other elements. # Constraints * Do not use additional libraries. * Aim for a time complexity of O(n). * Make sure to handle boolean values correctly (`False` should not be treated as `0`). # Examples 1. ```python move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"]) # returns [False, 1, 1, 2, 1, 3, \'a\', 0, 0] ``` 2. ```python move_zeros([0, 0, 0, 1, 2, 3]) # returns [1, 2, 3, 0, 0, 0] ``` 3. ```python move_zeros([\'a\', \'b\', \'c\']) # returns [\'a\', \'b\', \'c\'] ``` # Edge Cases * Empty list should return an empty list. * List with no zeros should return the original list. * List with only zeros should return the original list with all zeros at the end. **Your task is to implement the `move_zeros` function according to the above specifications.**","solution":"def move_zeros(array: list) -> list: Moves all zeros to the end of the list while preserving the order of non-zero elements. non_zeros = [x for x in array if x != 0 or isinstance(x, bool)] zeros = [x for x in array if x == 0 and not isinstance(x, bool)] return non_zeros + zeros"},{"question":"# Rotate Linked List Right by k Places Problem Description Given a singly linked list, rotate the list to the right by `k` places, where `k` is a non-negative integer. Your function should modify the input linked list in-place and return the new head of the list. Function Signature ```python def rotate_right(head: ListNode, k: int) -> ListNode: pass ``` Input - `head` (ListNode): The head of the singly linked list. - `k` (int): The number of places to rotate the list. Output - (ListNode): The new head of the rotated list. Constraints - The number of nodes in the list is in the range [0, 500]. - `-10^4 <= Node.val <= 10^4` - `0 <= k <= 10^5` Example ```plaintext Input: 1->2->3->4->5->NULL, k = 2 Output: 4->5->1->2->3->NULL ``` Explanation After rotating the list to the right by 2 places, the new list starts with the 4th element and continues to the end, looping back to the start. Notes - If the list is empty, the function should return `None`. - If `k` is greater than the length of the list, perform the rotation `k % length` times, as rotating the list length times results in the same list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotate_right(head: ListNode, k: int) -> ListNode: if not head or k == 0: return head # Determine the length of the linked list length = 1 current = head while current.next: current = current.next length += 1 # If k is greater than the length of the list, reduce k k = k % length if k == 0: return head # Link the end of the list to the head to form a circle current.next = head # Find the new end of the rotated list steps_to_new_end = length - k new_end = head for _ in range(steps_to_new_end - 1): new_end = new_end.next # Define the new head new_head = new_end.next # Break the link to unloop the circle new_end.next = None return new_head"},{"question":"# Question You are tasked with implementing a function that computes the Greatest Common Divisor (GCD) of two non-negative integers using a bitwise algorithm. Additionally, you need to integrate error handling to ensure robustness similar to the classical Euclidean approach. **Function Signature**: ```python def gcd_bit_robust(a: int, b: int) -> int: pass ``` # Requirements 1. **Inputs**: - `a` and `b`: Non-negative integers. - Input constraints: `0 <= a, b <= 10^9` 2. **Output**: - The GCD of the two input integers. - If either input is zero, return an appropriate error message \\"Inputs must be positive integers\\". 3. **Constraints**: - You must use bitwise operations to solve the problem. - Ensure error handling for invalid cases (e.g., zero or non-integer inputs). - Optimize for performance. 4. **Example**: ```python gcd_bit_robust(48, 18) # Output: 6 ``` 5. **Explanation**: - The function should calculate the GCD using a bitwise technique. - It should handle edge cases where inputs might be zero by returning an error message, ensuring no computation is done for those cases. # Implementation Constraints: - Performance should be efficient with time complexity O(log(min(a, b))) and space complexity O(1). Implement the function `gcd_bit_robust` that meets the above criteria.","solution":"def gcd_bit_robust(a: int, b: int) -> int: Compute the GCD of two non-negative integers using a bitwise algorithm. This function includes error handling for non-positive integer inputs. Parameters: a (int): First non-negative integer b (int): Second non-negative integer Returns: int: GCD of the two integers or error message if inputs are invalid. # Verify inputs are non-negative integers if a < 0 or b < 0 or not isinstance(a, int) or not isinstance(b, int): return \\"Inputs must be positive integers\\" # GCD of 0 with any number is the number itself if a == 0: return b if b == 0: return a # Using bitwise algorithm to compute GCD shift = 0 # Find the greatest power of 2 that divides both a and b while ((a | b) & 1) == 0: a >>= 1 b >>= 1 shift += 1 # Make a odd while (a & 1) == 0: a >>= 1 while b != 0: # Make b odd while (b & 1) == 0: b >>= 1 # Ensure a <= b to always subtract the smaller number if a > b: a, b = b, a # Subtract the smaller number (a) from the larger number (b) b -= a return a << shift"},{"question":"You are given three different implementations for computing the n-th Fibonacci number. Each of these has its advantages and drawbacks. Given this context, design an optimized solution that computes the n-th Fibonacci number efficiently considering the constraints provided below. Requirements: 1. Function Name: `fib_optimized` 2. Input: An integer `n` (0 <= n <= 10^6) 3. Output: Returns the n-th Fibonacci number 4. Performance: Your solution should execute in O(log n) time complexity using O(1) space complexity. 5. Constraints: Space and time efficiency are critical to handling very large inputs up to the maximum constraint. # Sample Input and Output: | n | Output| |---|-------| |0 | 0 | |1 | 1 | |10 | 55 | |100| 354224848179261915075 | |500000 | <a large number, not fully displayed for brevity>| Hints: - Consider the matrix exponentiation method to achieve O(log n) time complexity.","solution":"def fib_optimized(n): Computes the n-th Fibonacci number using matrix exponentiation. def matrix_mult(A, B): # Multiplies two 2x2 matrices A and B return [ [ A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1] ], [ A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1] ] ] def matrix_pow(A, p): # Raise matrix A to the power of p result = [[1, 0], [0, 1]] # Identity matrix base = A while p: if p % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) p //= 2 return result if n == 0: return 0 elif n == 1: return 1 F = [[1, 1], [1, 0]] result_matrix = matrix_pow(F, n - 1) return result_matrix[0][0]"},{"question":"You are tasked with simulating the movement of a robotic vacuum cleaner on a 2D plane. The vacuum starts at the origin point (0,0) and can make moves based on a sequence of instructions provided as a string. Each instruction in the sequence is represented by one of the characters \'R\' (Right), \'L\' (Left), \'U\' (Up), and \'D\' (Down). You need to determine if the vacuum cleaner returns to its starting position after executing all the moves in the sequence. **Input and Output Formats** * **Input**: A single string `moves` consisting of the characters \'R\', \'L\', \'U\', and \'D\' which describe the sequence of moves made by the vacuum cleaner. * **Output**: A boolean value `True` if the vacuum cleaner returns to the origin, `False` otherwise. **Constraints** * The length of `moves` can range from 0 to 10000. * Input will only consist of the characters \'R\', \'L\', \'U\', \'D\'. **Examples** * Example 1: * Input: `\\"UD\\"` * Output: `True` * Example 2: * Input: `\\"LL\\"` * Output: `False` **Task** Implement the function `def judge_return(moves: str) -> bool:` that takes a string `moves` and returns a boolean indicating whether the vacuum returns to the origin. **Performance Requirements** * Optimize the function to run with O(n) time complexity and O(1) space complexity. **Hints** * Consider how the net effect of opposite moves (i.e., U vs D and L vs R) may bring the vacuum back to the origin. * Utilize counting or simulation approach without additional memory overhead. ```python # Example implementation structure def judge_return(moves: str) -> bool: dict_moves = { \'U\' : 0, \'D\' : 0, \'R\' : 0, \'L\' : 0 } for char in moves: dict_moves[char] = dict_moves[char] + 1 return dict_moves[\'L\'] == dict_moves[\'R\'] and dict_moves[\'U\'] == dict_moves[\'D\'] ``` Implement and test your function within the given constraints to ensure it handles all standard cases correctly.","solution":"def judge_return(moves: str) -> bool: Determine if the vacuum cleaner returns to the starting origin (0,0) after completing the given sequence of moves. Parameters: moves (str): A string containing the moves \'R\', \'L\', \'U\', and \'D\' Returns: bool: True if the vacuum cleaner returns to the origin, False otherwise. x, y = 0, 0 # Starting position at the origin (0,0) for move in moves: if move == \'R\': x += 1 elif move == \'L\': x -= 1 elif move == \'U\': y += 1 elif move == \'D\': y -= 1 # Vacuum returns to the origin if both x and y are zero return x == 0 and y == 0"},{"question":"Given an MxN matrix where each row and each column is sorted in non-decreasing order, write a function `search_in_matrix(mat, key)` that searches for a given key in this matrix. If the key is found, return a tuple of its position in the form (row_index, col_index). If the key is not found, return `None`. # Function Signature: ```python def search_in_matrix(mat: List[List[int]], key: int) -> Optional[Tuple[int, int]]: ``` # Input * `mat` (list of list of int): The MxN matrix of integers. * You may assume that all rows in the matrix have the same number of columns. * `key` (int): The integer value to search for. # Output * A tuple (row_index, col_index) representing the position of the key in the matrix if found, or `None` if the key is not present in the matrix. # Constraints * 1 <= M, N <= 1000 * -10^9 <= matrix[i][j], key <= 10^9 # Example ```python mat = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 print(search_in_matrix(mat, key)) # Output: (1, 2) key = 10 print(search_in_matrix(mat, key)) # Output: None ``` # Scenario Imagine you are developing a search functionality for a spreadsheet application. The cells of the spreadsheet are arranged such that both the rows and columns are sorted in non-decreasing order. Users can use this search feature to quickly locate specific values in the spreadsheet. # Performance Requirements Ensure your solution has a time complexity of O(M + N) for it to scale effectively with larger datasets.","solution":"from typing import List, Optional, Tuple def search_in_matrix(mat: List[List[int]], key: int) -> Optional[Tuple[int, int]]: Searches for a given key in a MxN matrix where each row and each column is sorted in non-decreasing order. If the key is found, returns a tuple of its position in the form (row_index, col_index). If the key is not found, returns None. if not mat or not mat[0]: return None rows, cols = len(mat), len(mat[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if mat[row][col] == key: return (row, col) elif mat[row][col] > key: col -= 1 else: row += 1 return None"},{"question":"Optimal Stack Sorting Checker Implement a function `is_sorted(stack)` that checks whether a given stack is sorted in ascending order from bottom to top. The function should return `True` if the elements are sorted and `False` otherwise. **Function Signature**: ```python def is_sorted(stack: list) -> bool: pass ``` **Input**: * `stack`: A list of integers representing a stack, where the first element in the list is the bottom of the stack and the last element is the top. **Output**: * Returns a boolean value: `True` if the stack is sorted in ascending order from bottom to top, otherwise `False`. **Constraints**: 1. You cannot use any additional data structures such as lists or stacks except for temporary variables (optional to store a couple of elements). 2. You should aim to minimize the use of additional space. **Example**: ```python assert is_sorted([6, 3, 5, 1, 2, 4]) == False assert is_sorted([1, 2, 3, 4, 5, 6]) == True assert is_sorted([1, 1, 1, 1]) == True assert is_sorted([5]) == True assert is_sorted([]) == True ``` **Requirements**: - The solution should handle edge cases gracefully. - The primary goal is to achieve the result using O(1) additional space if possible (i.e., no additional data structures like other lists or stacks).","solution":"def is_sorted(stack): Checks whether the given stack is sorted in ascending order from bottom to top. Parameters: stack (list): A list of integers where the first element is the bottom of the stack and the last element is the top. Returns: bool: True if the stack is sorted in ascending order, False otherwise. n = len(stack) for i in range(n - 1): if stack[i] > stack[i + 1]: return False return True"},{"question":"# Stutter the Stack You are given a stack of integers. Your task is to write a function, `stutter_stack`, that doubles the presence of each element in the stack, maintaining the original order from bottom to top. # Detailed Specifications * You are required to implement the function `stutter_stack(stack: list) -> list`. * The input parameter `stack` will be a list of integers where the end of the list represents the top of the stack. * At the end of the function, the stack should have each of its elements appear twice in the original order. # Constraints * The stack will have at most (10^5) elements. * Each element in the stack will be an integer between (-10^9) and (10^9). # Example Input ```python stack = [3, 7, 1, 14, 9] ``` Output ```python [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` # Performance Requirements * The time complexity of your solution should be O(n). * The space complexity should be O(n). # Notes * You may use either an additional stack (list) or a queue to help you in this task.","solution":"def stutter_stack(stack): Doubles the presence of each element in the stack, maintaining the original order from bottom to top. :param stack: List of integers where the end of the list is the top of the stack :return: Modified list with each element doubled maintaining the original order result = [] for item in stack: result.append(item) result.append(item) return result"},{"question":"# Path Splitting Function You are tasked with implementing a utility function that splits a given file path or URL into two parts: the directory path and the file name. # Requirements - The function must handle both URLs and file system paths. - It should work correctly regardless of the operating system (Linux, Windows, etc.). - If the input string does not contain any separator, consider the entire string as the file name, with the directory path being an empty string. - If the path ends with a separator, consider the last part as an empty file name and handle the directory path accordingly. # Input - A string `path` representing either a file path or a URL. # Output - A list of two strings `[part[0], part[1]]`, where `part[0]` is the directory path and `part[1]` is the file name. # Constraints - The function should handle platform-specific path separators. - Avoid using built-in path manipulation libraries directly for this exercise to assess basic string operations skills. # Example ```python Input: \\"https://algorithms/unix/test.py\\" Output: [\\"https://algorithms/unix\\", \\"test.py\\"] Input: \\"algorithms/unix/test.py\\" Output: [\\"algorithms/unix\\", \\"test.py\\"] Input: \\"C:UsersAliceDocumentsreport.docx\\" Output: [\\"C:UsersAliceDocuments\\", \\"report.docx\\"] Input: \\"report.docx\\" Output: [\\"\\", \\"report.docx\\"] Input: \\"C:UsersAliceDocuments\\" Output: [\\"C:UsersAliceDocuments\\", \\"\\"] ``` # Implementation Implement the function `split(path: str) -> list` that meets the above requirements.","solution":"def split(path): Splits the given file path or URL into directory path and file name. Parameters: - path: str : The input path as a string. Returns: - list of two strings [directory path, file name] # Determine the separator based on the content of the path if \\"\\" in path: sep = \\"\\" else: sep = \\"/\\" # Checking if the path ends with a separator if path.endswith(sep): # Strip the trailing separator and mark file name as empty return [path.rstrip(sep), \\"\\"] # Split the path parts = path.rsplit(sep, 1) # If the path does not contain any separator, it means it is just a file name if len(parts) == 1: return [\\"\\", parts[0]] return parts"},{"question":"# Context You are developing a task scheduling system where tasks need to be executed based on their priority. Your task is to create a priority queue that can efficiently manage insertion and extraction based on task priorities. # Task Implement a `BinaryHeapPriorityQueue` class that mimics a priority queue using a binary heap. Your implementation should include methods to insert an element, check the size of the queue, and remove the element with the highest priority (i.e., replacing the current `pop` method). # Requirements 1. **Class Definition**: `BinaryHeapPriorityQueue` 2. **Methods**: - `__init__(self, items=None, priorities=None)`: Initialize an empty priority queue or from provided items and priorities. - `size(self)`: Return the number of items in the queue. - `push(self, item, priority)`: Add an item to the priority queue with the given priority. - `pop(self)`: Remove and return the item with the highest priority. 3. **Helper Functions**: - Implement necessary helper methods to maintain the heap property during insertion and extraction. # Constraints - The time complexity for both `push` and `pop` should be O(log n). - Handle edge cases such as attempting to pop from an empty queue gracefully. # Input/Output Format - **`__init__`**: * Input: `items` (list of items, optional), `priorities` (list of corresponding priorities, optional) * Output: None - **`size`**: * Input: None * Output: Integer representing the number of elements in the queue. - **`push`**: * Input: `item` and `priority` * Output: None - **`pop`**: * Input: None * Output: The item with the highest priority. # Example ```python pq = BinaryHeapPriorityQueue() pq.push(\'task1\', 1) pq.push(\'task2\', 2) pq.push(\'task3\', 3) print(pq.size()) # Output: 3 print(pq.pop()) # Output: task3 print(pq.size()) # Output: 2 ``` Implement the `BinaryHeapPriorityQueue` class in Python.","solution":"class BinaryHeapPriorityQueue: def __init__(self, items=None, priorities=None): # If both items and priorities are provided, initialize the heap with them if items and priorities and len(items) == len(priorities): self.heap = [(priority, item) for item, priority in zip(priorities, items)] for i in range(len(self.heap) // 2, -1, -1): self._heapify_down(i) else: self.heap = [] def size(self): return len(self.heap) def push(self, item, priority): self.heap.append((priority, item)) self._heapify_up(len(self.heap) - 1) def pop(self): if not self.heap: return None if len(self.heap) == 1: return self.heap.pop()[1] top_priority, top_item = self.heap[0] self.heap[0] = self.heap.pop() self._heapify_down(0) return top_item def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index][0] > self.heap[parent_index][0]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index) def _heapify_down(self, index): left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 largest = index if left_child_index < len(self.heap) and self.heap[left_child_index][0] > self.heap[largest][0]: largest = left_child_index if right_child_index < len(self.heap) and self.heap[right_child_index][0] > self.heap[largest][0]: largest = right_child_index if largest != index: self.heap[largest], self.heap[index] = self.heap[index], self.heap[largest] self._heapify_down(largest)"},{"question":"# Scenario Your company is implementing a task management system that uses a queue to manage tasks dynamically. The behavior of tasks being processed in a First-In-First-Out (FIFO) style is central to your company\'s needs. # Problem Statement Array-Based Queue Implementation Design and implement a `RotatingArrayQueue` class inheriting from the given `AbstractQueue`. Unlike traditional arrays, this queue will efficiently use the concept of a circular buffer to avoid memory expansion until absolutely necessary. # Key Functionalities: * `RotatingArrayQueue` should support standard queue operations. 1. `enqueue(value)` - Add a new item to the rear of the queue. 2. `dequeue()` - Remove and return the front item from the queue. 3. `peek()` - Return the front element without removing it. 4. `is_empty()` - Check if the queue is empty. 5. `__len__()` - Return the number of items in the queue. # Expected Input and Output Formats: 1. `enqueue(value:int) -> None` 2. `dequeue() -> int` 3. `peek() -> int` 4. `is_empty() -> bool` 5. `__len__() -> int` # Constraints: * The queue should initially have a fixed size (say 5 for simplicity). * When the queue is full, it should automatically expand the array size by doubling its previous capacity. # Example Usage: ```python q = RotatingArrayQueue(5) q.enqueue(1) q.enqueue(2) q.enqueue(3) print(q.dequeue()) # Output: 1 print(q.peek()) # Output: 2 print(len(q)) # Output: 2 print(q.is_empty()) # Output: False q.enqueue(4) q.enqueue(5) q.enqueue(6) # Triggers capacity expansion print(len(q)) # Output: 5 ``` # Performance Requirements: Ensure that all operations adhere to their expected time complexities.","solution":"class RotatingArrayQueue: def __init__(self, capacity=5): self.capacity = capacity self.queue = [None] * self.capacity self.front = 0 self.size = 0 def enqueue(self, value): if self.size == self.capacity: self._expand_capacity() end = (self.front + self.size) % self.capacity self.queue[end] = value self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def is_empty(self): return self.size == 0 def __len__(self): return self.size def _expand_capacity(self): new_capacity = self.capacity * 2 new_queue = [None] * new_capacity for i in range(self.size): new_queue[i] = self.queue[(self.front + i) % self.capacity] self.queue = new_queue self.front = 0 self.capacity = new_capacity"},{"question":"# Question You are tasked to implement a function that sorts a list of non-negative integers using the Radix Sort algorithm. Your implementation should maintain stability and efficiently handle lists with varying integer sizes. Description Write a function `radix_sort(arr)` that sorts a given list of non-negative integers using Radix Sort. The function should return a sorted list in ascending order. Input - A list of non-negative integers (0 ≤ integer ≤ 10^6). - The list can have up to 10^5 integers. Output - A sorted list in ascending order. Function Signature ```python def radix_sort(arr: List[int]) -> List[int]: ``` Constraints 1. The integers in the input list will be in the range from 0 to 10^6. 2. The list can have up to 10^5 integers. Performance Requirements - The solution should execute within a reasonable time for the given constraint on modern hardware. - Aim to keep the additional space used to a minimum. Example ```python # Input: arr = [170, 45, 75, 90, 802, 24, 2, 66] # Output: [2, 24, 45, 66, 75, 90, 170, 802] ``` # Scenario Consider the situation where you are building an application that needs to process and sort large lists of telephone numbers rapidly. These numbers are always non-negative integers and can be fairly large. You need to ensure the numbers are always processed in ascending order with minimal delay. The stability of the sorting algorithm is crucial. If two numbers have the same digits in a particular position, they must retain their relative positions from the original list in the sorted output. Implement the `radix_sort` function to meet the above requirements.","solution":"from typing import List def counting_sort(arr: List[int], exp: int) -> List[int]: n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 for i in range(n): arr[i] = output[i] return arr def radix_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return arr max1 = max(arr) exp = 1 while max1 // exp > 0: arr = counting_sort(arr, exp) exp *= 10 return arr"},{"question":"Context You’re given a task in a system where you need to find permutations of numerical sequences. Specifically, you need to identify the next lexicographical permutation of a given number composed of digits. Objective Implement a function `next_bigger(num: int) -> int` that takes an integer `num` as input and returns the next bigger number that can be formed using the exact same digits. If no such number exists (i.e., the digits are in descending order), return `-1`. Function Signature ```python def next_bigger(num: int) -> int: pass ``` Input * An integer `num` with no leading zeros. Output * An integer representing the next number with the same digits in ascending order or `-1` if no such permutation exists. Constraints * The input number will always be a positive integer. * The input number will not exceed 10^18, ensuring it fits within Python\'s integer handling capabilities. Example ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(54321) == -1 assert next_bigger(99999) == -1 ``` Description 1. Convert the number into a list of digits. 2. Traverse from the end of the list to find the first decreasing element. 3. Find the smallest element to the right that is larger than this element. 4. Swap these two elements. 5. Reverse the part of the list to the right of the initial element found in step 2. 6. Convert the list back to an integer and return it. Ensure your implementation handles edge cases, and consider performance aspects to execute efficiently for larger input sizes.","solution":"def next_bigger(num: int) -> int: # Convert the number to a list of its digits digits = list(str(num)) # Find the rightmost element that is smaller than its next element i = len(digits) - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If no such element is found, return -1 if i == -1: return -1 # Find the smallest element to the right of digits[i] that is larger than digits[i] j = len(digits) - 1 while digits[j] <= digits[i]: j -= 1 # Swap these two numbers digits[i], digits[j] = digits[j], digits[i] # Reverse the part of the list to the right of i digits = digits[:i + 1] + digits[i + 1:][::-1] # Convert the list back to an integer and return it return int(\\"\\".join(digits))"},{"question":"Question: Extended FizzBuzz You are tasked with extending the traditional FizzBuzz problem to include additional custom replacements besides the default ones for multiples of 3 and 5. Write a function `custom_fizzbuzz(n, replacements)` that generates a list of numbers from 1 to n with the following rules: 1. Each number in the list should be replaced by a corresponding string based on the given replacements. 2. Each replacement rule is a dictionary with two keys: * `\\"divisor\\"`: an integer which dictates the number to divide by. * `\\"string\\"`: a string which will replace the number if divisible by the `\\"divisor\\"`. 3. Replacement rules should be applied in the order they appear in the list. If a number matches multiple replacement rules, concatenate all applicable strings. 4. If a number doesn\'t match any replacement rule, keep the number itself. # Input - `n`: An integer (1 ≤ n ≤ 10^4). - `replacements`: A list of dictionaries where each dictionary has the structure `{\\"divisor\\": int, \\"string\\": str}`. # Output - A list of numbers or strings based on the described replacement rules. # Constraints - The length of `replacements` list will not exceed 100. - Each divisor in the replacements will be a positive integer. - n will always be a positive integer. # Example: ```python print(custom_fizzbuzz(15, [ {\\"divisor\\": 3, \\"string\\": \\"Fizz\\"}, {\\"divisor\\": 5, \\"string\\": \\"Buzz\\"} ])) # Should return: # [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] print(custom_fizzbuzz(10, [ {\\"divisor\\": 2, \\"string\\": \\"Even\\"}, {\\"divisor\\": 3, \\"string\\": \\"Three\\"} ])) # Should return: # [1, \'Even\', \'Three\', \'Even\', 5, \'EvenThree\', 7, \'Even\', \'Three\', \'Even\'] ``` # Note: - Ensure your function handles incorrect values gracefully. - Think of performance when designing your solution.","solution":"def custom_fizzbuzz(n, replacements): Generates a list of numbers from 1 to n with custom replacements. Args: n (int): The upper limit of the list. replacements (list): A list of dictionaries with \\"divisor\\" and \\"string\\" keys. Returns: list: A list where numbers are replaced according to the given rules. result = [] for i in range(1, n + 1): replacement_str = \\"\\" for rule in replacements: if i % rule[\\"divisor\\"] == 0: replacement_str += rule[\\"string\\"] if replacement_str: result.append(replacement_str) else: result.append(i) return result"},{"question":"You are asked to implement a queue using a dynamic resizing array. Your implementation should allow enqueue and dequeue operations in amortized constant time using a circular buffer to maintain the array\'s structure. # Requirements Specifically, implement a class `DynamicArrayQueue` with the following methods: 1. **`__init__(self, capacity=10)`**: Initialize with an optional initial capacity. 2. **`enqueue(self, value)`**: Add `value` to the rear of the queue. 3. **`dequeue(self)`**: Remove and return the front element of the queue. 4. **`is_empty(self)`**: Return `True` if the queue is empty, otherwise `False`. 5. **`peek(self)`**: Return the front element of the queue without removing it. 6. **`__len__(self)`**: Return the current number of elements in the queue. # Input and Output format Function signatures and their expected behavior: - `__init__(self, capacity=10)` - **Input**: Initializes the queue with an optional capacity (default is 10). - `enqueue(self, value)` - **Input**: A value to be added to the queue. - **Output**: It doesn\'t return a value. - `dequeue(self)` - **Input**: None. - **Output**: Returns the value at the front of the queue. Raises `IndexError` if the queue is empty. - `is_empty(self)` - **Input**: None - **Output**: Returns `True` if the queue is empty, otherwise `False`. - `peek(self)` - **Input**: None - **Output**: Returns the value at the front of the queue. Raises `IndexError` if the queue is empty. - `__len__(self)` - **Input**: None - **Output**: Returns the number of elements in the queue. # Constraints - The number of operations (enqueue and dequeue) will be at most `10^5`. - The values inserted in the queue are integers. # Example ```python q = DynamicArrayQueue() q.enqueue(1) q.enqueue(2) print(q.dequeue()) # Output: 1 print(q.peek()) # Output: 2 print(len(q)) # Output: 1 print(q.is_empty()) # Output: False q.dequeue() print(q.is_empty()) # Output: True ``` # Implementation Notes Ensure efficient handling of array resizing, and necessary adjustments to front and rear pointers to maintain a circular buffer nature of your array queue.","solution":"class DynamicArrayQueue: def __init__(self, capacity=10): self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = 0 self.size = 0 def enqueue(self, value): if self.size == self.capacity: self._resize() self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from an empty queue\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return value def is_empty(self): return self.size == 0 def peek(self): if self.is_empty(): raise IndexError(\\"peek from an empty queue\\") return self.queue[self.front] def __len__(self): return self.size def _resize(self): new_capacity = self.capacity * 2 new_queue = [None] * new_capacity for i in range(self.size): new_queue[i] = self.queue[(self.front + i) % self.capacity] self.queue = new_queue self.front = 0 self.rear = self.size self.capacity = new_capacity"},{"question":"# Question: Last Occurrence of a Number in a Sorted Array Given a sorted array of integers in increasing order, write a function `last_occurrence(array: List[int], query: int) -> int` that returns the index of the last occurrence of a given number in the array. If the number is not found in the array, return `-1`. The function should use a binary search to achieve O(log n) time complexity. Input: * `array` - a list of integers sorted in increasing order (1 <= len(array) <= 10^5) * `query` - an integer whose last occurrence in the array needs to be found. Output: * Return the index of the last occurrence of the `query` in the array. If the element is not present, return `-1`. Constraints: * The array will only contain integers, and it will be sorted in increasing order. * Do not use linear search methods (i.e., avoid O(n) complexity). Example: * Input: `array = [1, 2, 3, 3, 3, 4, 5, 6]`, `query = 3` * Output: `4` * Input: `array = [1, 2, 3, 3, 3, 4, 5, 6]`, `query = 7` * Output: `-1` Explanation: * In the first example, the number `3` appears at positions 2, 3, and 4. The last occurrence is at index 4. * In the second example, the number `7` does not appear in the array, so the return value is `-1`. Implement the function according to the specifications. Ensure to handle edge cases such as when the array is empty, or the query does not exist in the array.","solution":"from typing import List def last_occurrence(array: List[int], query: int) -> int: Returns the index of the last occurrence of the query in the sorted array. If the query is not found, returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: result = mid # record current position left = mid + 1 # keep searching to the right elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"**Problem Statement:** You have been tasked with creating a text encryption tool using the Atbash cipher, a symmetric substitution cipher that maps each letter in the alphabet to its reverse, case-sensitive (e.g., \'A\' ↔ \'Z\' and \'a\' ↔ \'z\'). **Function Requirements:** Implement a function `atbash_cipher` that takes a single input string `s` and returns its Atbash-encoded counterpart. **Function Signature:** ```python def atbash_cipher(s: str) -> str: pass ``` **Parameters:** - `s` (string): The text to be encoded. Can contain upper and lowercase letters, digits, spaces, and punctuation. **Returns:** - `string`: The Atbash encrypted version of `s`. **Example:** ```python assert atbash_cipher(\\"Attack at dawn\\") == \\"Zggzxp zg wzdm\\" assert atbash_cipher(\\"Hello, World!\\") == \\"Svool, Dliow!\\" assert atbash_cipher(\\"Python3.8\\") == \\"Kbgslm3.8\\" ``` **Constraints:** * The length of `s` will be between 0 and 1000. * The performance should be able to handle the upper constraint efficiently. **Additional Information:** Please account for all characters—alphabetic characters (both uppercase and lowercase) should be encoded, while all other characters (numbers, punctuation, spaces) should remain unchanged. Ensure your implementation adheres to the O(n) time complexity.","solution":"def atbash_cipher(s: str) -> str: Encodes the given string s using the Atbash cipher. result = [] for char in s: if \'A\' <= char <= \'Z\': result.append(chr(90 - (ord(char) - 65))) elif \'a\' <= char <= \'z\': result.append(chr(122 - (ord(char) - 97))) else: result.append(char) return \'\'.join(result)"},{"question":"Problem Statement You are required to implement a class `BitManipulator` that uses bit manipulation methods to handle individual bit operations on integers. # Function Description: **Class**: `BitManipulator` **Methods**: 1. `get_bit(num: int, i: int) -> bool`: Return whether the bit at position `i` in the integer `num` is 1. 2. `set_bit(num: int, i: int) -> int`: Return an integer where the bit at position `i` in the integer `num` is set to 1. 3. `clear_bit(num: int, i: int) -> int`: Return an integer where the bit at position `i` in the integer `num` is cleared to 0. 4. `update_bit(num: int, i: int, bit: int) -> int`: Return an integer where the bit at position `i` in the integer `num` is updated to the value of `bit` (0 or 1). # Input Format: * `num` (int): An integer on which bit operations will be performed. * `i` (int): The bit index (0-based) to operate on. * `bit` (int): The bit value (0 or 1). # Output Format: * Return either a boolean value (in the case of `get_bit`) or an integer (in the case of `set_bit`, `clear_bit`, and `update_bit`). # Constraints: * 0 <= i < 32 (assuming 32-bit integers) * num is a non-negative integer. # Example: ```python # Example usage bit_manipulator = BitManipulator() # Get bit example print(bit_manipulator.get_bit(5, 0)) # Output: True (binary 101) # Set bit example print(bit_manipulator.set_bit(5, 1)) # Output: 7 (binary 111) # Clear bit example print(bit_manipulator.clear_bit(5, 2)) # Output: 1 (binary 001) # Update bit example print(bit_manipulator.update_bit(5, 1, 0)) # Output: 5 -> 101 becomes 100, so Output: 4 ``` # Implementation Notes: 1. Make sure to handle the case where `i` is out-of-bounds. 2. `update_bit` should verify that the `bit` value is either 0 or 1.","solution":"class BitManipulator: @staticmethod def get_bit(num: int, i: int) -> bool: Return whether the bit at position `i` in the integer `num` is 1. if i < 0 or i >= 32: raise ValueError(\\"Bit index out of bounds\\") return (num & (1 << i)) != 0 @staticmethod def set_bit(num: int, i: int) -> int: Return an integer where the bit at position `i` in the integer `num` is set to 1. if i < 0 or i >= 32: raise ValueError(\\"Bit index out of bounds\\") return num | (1 << i) @staticmethod def clear_bit(num: int, i: int) -> int: Return an integer where the bit at position `i` in the integer `num` is cleared to 0. if i < 0 or i >= 32: raise ValueError(\\"Bit index out of bounds\\") return num & ~(1 << i) @staticmethod def update_bit(num: int, i: int, bit: int) -> int: Return an integer where the bit at position `i` in the integer `num` is updated to the value of `bit` (0 or 1). if i < 0 or i >= 32: raise ValueError(\\"Bit index out of bounds\\") if bit not in (0, 1): raise ValueError(\\"Bit value must be 0 or 1\\") num = BitManipulator.clear_bit(num, i) return num | (bit << i)"},{"question":"**Question**: Bucket Sort Enhancement **Scenario**: A software development company is optimizing their data processing pipeline. One part of the pipeline involves sorting numeric data that is mostly uniformly distributed but occasionally has clustered values. Your task is to implement an enhanced version of the given bucket sort algorithm to handle these scenarios more efficiently. **Requirement**: 1. Implement the bucket sort algorithm with an enhanced sorting function that efficiently handles both small and large bucket sizes. 2. Optimize the bucket index distribution to ensure better performance for non-uniformly distributed data. Your function signature should be: ```python def enhanced_bucket_sort(arr: List[float]) -> List[float]: pass ``` **Input**: * `arr` - a list of floating-point numbers `[x1, x2, ..., xn]` where ( 0 leq xi < 1 ) * The length of `arr` can be up to ( 10^6 ). **Output**: * A sorted list of floating-point numbers in ascending order. **Constraints**: * Solve the problem with a performance-efficient approach. * Properly handle edge cases such as empty lists and uniformly distributed values. **Example**: ```python assert enhanced_bucket_sort([0.25, 0.36, 0.58, 0.41, 0.47, 0.68, 0.72]) == [0.25, 0.36, 0.41, 0.47, 0.58, 0.68, 0.72] assert enhanced_bucket_sort([0.9, 0.1, 0.5]) == [0.1, 0.5, 0.9] assert enhanced_bucket_sort([]) == [] ``` Implement `enhanced_bucket_sort` by incorporating the necessary improvements to handle varying bucket sizes efficiently and optimizing bucket distribution.","solution":"from typing import List import math def enhanced_bucket_sort(arr: List[float]) -> List[float]: if not arr: return arr # Size of the array n = len(arr) # Create n empty buckets buckets = [[] for _ in range(n)] # Put array elements in different buckets for num in arr: index = math.floor(n * num) # Index in buckets buckets[index].append(num) # Sort individual buckets using an efficient algorithm for bucket in buckets: bucket.sort() # Concatenate all buckets into the result sorted_array = [] for bucket in buckets: sorted_array.extend(bucket) return sorted_array"},{"question":"# Absolute Path Resolver Objective Implement the function `resolve_absolute_path` that converts a given file path to its absolute path. The input can be a relative path, a path including the user directory shortcut (`~`), or an absolute path. The function should ensure the output is a valid absolute path. Function Signature ```python def resolve_absolute_path(file_path: str) -> str: pass ``` Input * `file_path` (str): A string representing the path of the file. It can be a relative path, an absolute path, or a path containing the user directory shortcut (`~`). Output * (str): The absolute path corresponding to the input file path. Constraints * The function should handle paths up to 4096 characters in length. * Users can assume a valid path string is provided as input. Performance Requirements * The function should run in O(N) time complexity where N is the length of the file path string. * The function should use O(N) space complexity. Example Usage ```python resolve_absolute_path(\\"~/documents/project\\") # This should return the absolute path of \\"documents/project\\" under the home directory, e.g., \\"/home/user/documents/project\\". resolve_absolute_path(\\"../configs/settings.ini\\") # This should return the absolute path considering the relative path from the current directory. ``` Scenario In many applications involving file handling, it\'s important to work with absolute paths to avoid ambiguities associated with relative paths. Implementing the `resolve_absolute_path` function will help ensure that file paths are consistently interpreted, improving reliability in file management operations.","solution":"import os def resolve_absolute_path(file_path: str) -> str: Converts a given file path to its absolute path. Parameters: - file_path (str): A string representing the path of the file. Returns: - str: The absolute path corresponding to the input file path. return os.path.abspath(os.path.expanduser(file_path))"},{"question":"# Fibonacci Sequence Generator You have been tasked with implementing a function to efficiently compute the n-th Fibonacci number. There are multiple strategies to achieve this, each with its own trade-offs. Your goal is to implement the function using an iterative approach to minimize space usage while maintaining optimal time complexity. Function Signature ```python def efficient_fib(n: int) -> int: ``` Input * An integer `n` (0 ≤ n ≤ 10^6), which represents the index in the Fibonacci sequence. Output * Returns the n-th Fibonacci number. Constraints * The function must run efficiently for large values of n up to 10^6. * Make sure to handle edge cases, such as n = 0 and n = 1. * The implementation should adhere to O(n) time complexity and O(1) space complexity. Examples ```python assert efficient_fib(0) == 0 assert efficient_fib(1) == 1 assert efficient_fib(2) == 1 assert efficient_fib(3) == 2 assert efficient_fib(10) == 55 assert efficient_fib(50) == 12586269025 ``` Details The primary challenge of this exercise is to ensure that the solution works within the given constraints efficiently. Your iterative approach should rely on constant space (O(1) space) using only a few variables to keep track of the previous values in the sequence. You may refer to mathematical properties of the Fibonacci sequence but ensure no unnecessary data structures are utilized that could increase the space complexity. Implementation Note Do not use recursion or lists/arrays for this implementation. Instead, use an iterative method that maintains a small number of variables.","solution":"def efficient_fib(n: int) -> int: Returns the n-th Fibonacci number using an iterative approach. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"Substring Search with Optimization Objective Given two strings, `haystack` and `needle`, write an efficient function `strStrOptimized(haystack, needle)` to return the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. If `needle` is an empty string, return 0 by definition. Aim to implement the function using an optimized algorithm like the Knuth-Morris-Pratt (KMP) algorithm to improve search efficiency. Detailed Description: - **Function Name**: `strStrOptimized` - **Input**: - `haystack`: A string representing the main text. - `needle`: A string representing the substring to search for. - **Output**: - An integer representing the start index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not present. - **Constraints**: - Both `haystack` and `needle` consist of only lowercase English characters. - The length of `haystack` and `needle` will be in the range [0, 5 * 10^4]. Example Scenarios: 1. **Example 1**: - **Input**: `haystack = \\"hello\\"`, `needle = \\"ll\\"` - **Output**: `2` 2. **Example 2**: - **Input**: `haystack = \\"aaaaa\\"`, `needle = \\"bba\\"` - **Output**: `-1` 3. **Example 3**: - **Input**: `haystack = \\"\\"`, `needle = \\"\\"` - **Output**: `0` Performance Expectations: Implement the search in sub-linear or optimal linear time complexity to handle large strings efficiently. Edge Cases to Consider: - When the `needle` is an empty string. - When the `needle` is longer than the `haystack`. - Large inputs where efficiency becomes more critical. **Hint**: Use the Knuth-Morris-Pratt (KMP) algorithm for an efficient solution. Here is the function signature to get you started: ```python def strStrOptimized(haystack, needle): pass ```","solution":"def strStrOptimized(haystack, needle): Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Uses Knuth-Morris-Pratt algorithm for efficient searching. if not needle: return 0 # KMP Algorithm Helper Function: build LPS array def buildLPS(pattern): length = 0 i = 1 lps = [0] * len(pattern) while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps m, n = len(haystack), len(needle) lps = buildLPS(needle) i = j = 0 while i < m: if needle[j] == haystack[i]: i += 1 j += 1 if j == n: return i - j elif i < m and needle[j] != haystack[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"# Fenwick Tree / Binary Indexed Tree Implementation Problem Statement You are required to implement a Fenwick Tree (Binary Indexed Tree) for an integer array to efficiently perform the following operations: 1. Compute prefix sum up to a given index. 2. Update an element in the array. Function Signatures 1. `def construct(freq: List[int]) -> List[int]` 2. `def get_sum(bit_tree: List[int], i: int) -> int` 3. `def update_bit(bit_tree: List[int], i: int, v: int) -> None` Detailed Description 1. **construct(freq: List[int]) -> List[int]** * Function to initialize the Fenwick Tree based on input array `freq`. * **Input**: - `freq`: A list of integers representing the input array. * **Output**: - Returns the BIT represented as a list of integers. * **Constraints**: - 1 ≤ len(freq) ≤ 10^4 - -10^4 ≤ freq[i] ≤ 10^4 2. **get_sum(bit_tree: List[int], i: int) -> int** * Function to compute the prefix sum from the start of the array up to index `i`. * **Input**: - `bit_tree`: The Fenwick Tree list. - `i`: The index up to which the sum is required (0-based index). * **Output**: - Returns the sum of elements from the start to the given index. * **Constraints**: - 0 ≤ i < len(bit_tree)-1 (since bit_tree is 1-based indexed). 3. **update_bit(bit_tree: List[int], i: int, v: int) -> None** * Function to update the Fenwick Tree when a value in the original array changes. * **Input**: - `bit_tree`: The Fenwick Tree list. - `i`: The index of the element to update (0-based index). - `v`: The value to add to the element at index `i`. * **Output**: - This function does not return any value. It updates the BIT in place. * **Constraints**: - 0 ≤ i < len(bit_tree)-1. Example Usage: ```python # Given input frequency array freq = [1, 2, 3, 4, 5] # Construct the BIT bit_tree = construct(freq) # Get the sum of first 3 elements (i.e., 1+2+3) assert get_sum(bit_tree, 2) == 6 # Update index 2 (element 3) by adding 6 (3 -> 9) update_bit(bit_tree, 2, 6) # Now get the sum of first 3 elements (i.e., 1+2+9) assert get_sum(bit_tree, 2) == 12 ``` Notes: - Fenwick Tree uses a 1-based indexing internally while interacting with a standard 0-based input array. - Adequately handle edge cases and ensure efficiency in execution.","solution":"from typing import List def construct(freq: List[int]) -> List[int]: Initializes a Fenwick Tree (Binary Indexed Tree) based on input frequency array. Parameters: freq (List[int]): The input list of integers representing the frequency array. Returns: List[int]: The BIT (Fenwick Tree) represented as a list. n = len(freq) bit_tree = [0] * (n + 1) for i in range(n): update_bit(bit_tree, i, freq[i]) return bit_tree def get_sum(bit_tree: List[int], i: int) -> int: Computes the prefix sum from the start of the array up to index i using the BIT. Parameters: bit_tree (List[int]): The BIT (Fenwick Tree) list. i (int): The index up to which the sum is required (0-based index). Returns: int: The sum of elements from the start to the given index. i += 1 # Convert 0-based index to 1-based index sum_val = 0 while i > 0: sum_val += bit_tree[i] i -= i & -i return sum_val def update_bit(bit_tree: List[int], i: int, v: int) -> None: Updates the BIT when a value in the original array changes. Parameters: bit_tree (List[int]): The BIT (Fenwick Tree) list. i (int): The index of the element to update (0-based index). v (int): The value to add to the element at index i. Returns: None: This function updates the BIT in place. i += 1 # Convert 0-based index to 1-based index while i < len(bit_tree): bit_tree[i] += v i += i & -i"},{"question":"# Problem Description You are tasked with calculating the number of unique paths in a grid where you can only move either horizontally to the right or vertically downwards at each step, starting from the top-left corner and ending at the bottom-right corner. The grid dimensions are given as m (number of rows) and n (number of columns). # Function Specification Implement the function `calculate_unique_paths(m, n)`: ```python def calculate_unique_paths(m, n): # Your code here ``` # Input - An integer `m` (1 ≤ m ≤ 100) representing the number of rows. - An integer `n` (1 ≤ n ≤ 100) representing the number of columns. # Output Return an integer representing the count of unique paths from the top-left corner (0,0) to the bottom-right corner (m-1,n-1). # Constraints - The grid does not have any obstacles. - The movement is restricted to right or down directions. - Both `m` and `n` are positive integers. # Examples 1. Input: `m = 3, n = 3` Output: `6` Explanation: The grid is a 3x3 matrix, and the number of unique paths to traverse from top-left to bottom-right is 6. 2. Input: `m = 1, n = 5` Output: `1` Explanation: The grid is a 1x5 matrix, so there is only one way to traverse it by moving right. 3. Input: `m = 4, n = 4` Output: `20` Explanation: The grid is a 4x4 matrix, and the number of unique paths is 20. # Notes - The grid size will not exceed 100x100 for performance reasons. - Think about optimizing space complexity. # Implementation Hint Consider using dynamic programming to store the intermediate results in either a 2D matrix or optimizing it to use less additional space.","solution":"def calculate_unique_paths(m, n): Calculates the number of unique paths in a m x n grid from the top-left corner to the bottom-right corner. # Initialize a 2D array with all 1s dp = [[1] * n for _ in range(m)] # Fill the dp array with the number of ways to reach each cell for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner will hold the result return dp[m-1][n-1]"},{"question":"You are given a weighted, directed graph described by an **n x n** adjacency matrix `adjacency_matrix` where `adjacency_matrix[i][j]` represents the weight of the edge from node `i` to node `j`. If there is no edge between the nodes, the corresponding cell will contain a very large number (representing infinity). The graph may also include self-loops, where `adjacency_matrix[i][i] = 0` for all nodes `i`. Implement the function `floyd_warshall(adjacency_matrix)`, which uses the Floyd-Warshall algorithm to find the shortest path distances between every pair of nodes. Return a new **n x n** matrix `shortest_paths` where `shortest_paths[i][j]` is the shortest distance from node `i` to node `j`. # Input - An integer `n`, the number of nodes in the graph. - A list of lists `adjacency_matrix` representing the edge weights between respective nodes, of dimensions `n x n`. # Output - A list of lists `shortest_paths` containing the shortest distance between each pair of nodes, of dimensions `n x n`. # Constraints - `1 <= n <= 100` (represents the vertex count; relatively small due to O(V^3) time complexity). - Edge weights will be non-negative integers or a large number representing infinity for no direct path. # Example ```python adjacency_matrix = [ [0, 3, float(\'inf\'), 5], [2, 0, float(\'inf\'), 4], [float(\'inf\'), 1, 0, float(\'inf\')], [float(\'inf\'), float(\'inf\'), 2, 0] ] result = floyd_warshall(adjacency_matrix) ``` The `result` should be: ```python [ [0, 3, 7, 5], [2, 0, 6, 4], [3, 1, 0, 5], [5, 3, 2, 0] ] ``` # Notes 1. Utilize a copy of the original adjacency matrix to avoid modifying the input data. 2. Handle `float(\'inf\')` correctly to represent infinity. 3. Ensure the performance is optimized based on the algorithm\'s complexity.","solution":"def floyd_warshall(adjacency_matrix): Uses the Floyd-Warshall algorithm to find the shortest path distances between every pair of nodes in a weighted, directed graph. :param adjacency_matrix: List of lists representing the edge weights between nodes. :return: List of lists containing the shortest path distances between each pair of nodes. n = len(adjacency_matrix) # Initialize the shortest_paths matrix with a deep copy of the adjacency_matrix. shortest_paths = [row[:] for row in adjacency_matrix] # Execute the Floyd-Warshall algorithm. for k in range(n): for i in range(n): for j in range(n): if shortest_paths[i][j] > shortest_paths[i][k] + shortest_paths[k][j]: shortest_paths[i][j] = shortest_paths[i][k] + shortest_paths[k][j] return shortest_paths"},{"question":"A message containing letters from A-Z is encoded to numbers using the following mapping: ``` \'A\' -> 1 \'B\' -> 2 ... \'Z\' -> 26 ``` Given an encoded message containing digits, determine the total number of ways to decode it. # Requirement: Write a function `count_decodings` that takes a single input: - `encoded_message` (a string): The string of digits representing the encoded message. The function should return an integer representing the total number of ways to decode the message. If an invalid input is detected (e.g., a \'0\' at the beginning or invalid sequences), the function should return 0. # Example: ```python def count_decodings(encoded_message): # Your implementation here # Test cases print(count_decodings(\\"12\\")) # Output: 2 (could be \\"AB\\" or \\"L\\") print(count_decodings(\\"226\\")) # Output: 3 (\\"BZ\\", \\"VF\\", \\"BBF\\") print(count_decodings(\\"0\\")) # Output: 0 (Invalid) print(count_decodings(\\"10\\")) # Output: 1 (\\"J\\") ``` # Constraints: - The input string will only contain digits and will have a maximum length of 100. # Performance Requirements: - Aim for a time complexity of O(n) and space complexity of O(1). # Scenario: Imagine you\'re working with a software that automatically converts encrypted messages into human-readable formats, and one crucial step is to determine if a given encrypted string can be decoded into one or more valid text messages. Building a reliable decoder function is essential for ensuring the accuracy of the decryption process.","solution":"def count_decodings(encoded_message): if not encoded_message or encoded_message[0] == \'0\': return 0 n = len(encoded_message) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): single_digit = int(encoded_message[i - 1]) double_digit = int(encoded_message[i - 2:i]) if 1 <= single_digit <= 9: dp[i] += dp[i - 1] if 10 <= double_digit <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"# Longest Common Prefix Implementation Challenge You are provided with three different implementations of finding the longest common prefix (LCP) among an array of strings. Your task is to write a new function that uses a more efficient data structure, specifically a Trie, to determine the LCP. A Trie or Prefix Tree is a special type of tree used to store associative data structures. A Trie is used to store a dynamic set or associative array where the keys are usually strings. # Requirements: 1. Implement the Trie data structure. 2. Use the Trie to find the longest common prefix of an array of strings. # Input: * An array of strings `strs`, where 0 <= strs.length <= 200 and 0 <= strs[i].length <= 200. # Output: * Return the longest common prefix string. If there is no common prefix, return an empty string(\\"\\"). # Constraints: * The input strings consist of only lowercase English letters. # Example: ``` Input: [\\"flower\\",\\"flow\\",\\"flight\\"] Output: \\"fl\\" Input: [\\"dog\\",\\"racecar\\",\\"car\\"] Output: \\"\\" ``` # Performance Requirements: The function should handle the worst-case time complexity for large datasets effectively. # Function Signature: ```python def longest_common_prefix_trie(strs: List[str]) -> str: pass ``` # Context: You are developing an autocomplete feature for a search engine where users often input incomplete queries. To provide useful suggestions, you need to determine the longest common prefix among a list of potential queries. The Trie data structure can help manage and search these prefixes efficiently.","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def longest_common_prefix(self) -> str: prefix = [] node = self.root while node: if len(node.children) == 1 and not node.is_end_of_word: char = next(iter(node.children)) prefix.append(char) node = node.children[char] else: break return \'\'.join(prefix) def longest_common_prefix_trie(strs: List[str]) -> str: if not strs: return \\"\\" trie = Trie() for word in strs: trie.insert(word) return trie.longest_common_prefix()"},{"question":"You need to implement two functions for array flattening: 1. `flatten_recursive(input_list) -> List` 2. `flatten_iterative(input_list) -> Iterator` **Objective**: Transform a given nested array into a single-dimensional array. # Function Descriptions: **flatten_recursive(input_list)**: - **Input**: A nested list of arbitrary depth containing integers, lists, and possibly other iterables. - **Output**: A flat list containing all elements in their original order. - **Requirements**: * Use recursion to achieve the flattening. * Handle any depth of nested lists. **flatten_iterative(input_list)**: - **Input**: A nested list of arbitrary depth containing integers, lists, and possibly other iterables. - **Output**: An iterator yielding flattened elements in their original order. - **Requirements**: * Use iteration (not recursion) to achieve flattening. * This function should use a stack or queue to handle nested iterables. # Constraints: * The input list may contain integers, lists, tuples, or sets. * The functions should handle edge cases such as empty lists or iterables that are not nested. # Examples: - `flatten_recursive([1, [2, [3, 4], 5], 6])` -> `[1, 2, 3, 4, 5, 6]` - `list(flatten_iterative([1, [2, [3, 4], 5], 6]))` -> `[1, 2, 3, 4, 5, 6]` - `flatten_recursive([[], 4, 5, [[[6, 7]]]])` -> `[4, 5, 6, 7]` - `list(flatten_iterative([[], 4, 5, [[[6, 7]]]]))` -> `[4, 5, 6, 7]` # Notes: * You should avoid using Python\'s built-in flattening utilities. * Include detailed comments and properly handle edge cases. Submission: Please implement your solution in Python and ensure your code is efficient and free from unnecessary complexity.","solution":"from typing import List, Iterator, Any def flatten_recursive(input_list: List[Any]) -> List[Any]: Flattens a nested list using recursion. :param input_list: A nested list of arbitrary depth. :return: A flat list. result = [] for item in input_list: if isinstance(item, list): result.extend(flatten_recursive(item)) else: result.append(item) return result def flatten_iterative(input_list: List[Any]) -> Iterator[Any]: Flattens a nested list using iteration. :param input_list: A nested list of arbitrary depth. :return: An iterator yielding flattened elements. stack = [iter(input_list)] while stack: try: item = next(stack[-1]) if isinstance(item, list): stack.append(iter(item)) else: yield item except StopIteration: stack.pop()"},{"question":"# Minimum Spanning Tree Construction Using Kruskal\'s Algorithm Objective You are given a connected, undirected graph with weighted edges. Your task is to implement Kruskal\'s algorithm to find the minimum spanning tree of the graph and return the sum of the weights of the MST edges. Input You are provided integers `n` and `m`, where `n` is the number of vertices and `m` is the number of edges. Following this, you are given `m` lines, each containing three integers `u`, `v`, and `w`, which describe an edge between vertex `u` and vertex `v` with weight `w`. Output Return the sum of the weights of the edges in the minimum spanning tree (MST). Constraints * 1 ≤ n ≤ 1000 (number of vertices) * 0 ≤ m ≤ 100000 (number of edges) * 1 ≤ u, v ≤ n * 1 ≤ w ≤ 1000 Performance Requirements * The algorithm should efficiently handle the upper time and space constraints mentioned above. * Time Complexity: O(E log E) * Space Complexity: O(V) Implementation Details 1. Use a union-find data structure to manage the connected components. 2. Ensure union-find operations (find and union) are optimized with path compression and union by rank. 3. Sort the edges by weight before processing them. 4. Ensure edge cases, such as graphs with multiple edges of the same weight, are handled correctly. Implement the following function: ```python def kruskal_minimum_spanning_tree(n, m, edges): Args: n (int): number of vertices m (int): number of edges edges (list of tuple): each tuple contains three integers (u, v, w) Returns: int: sum of weights of MST # Your code here pass ``` Example: ```python n = 5 m = 6 edges = [(1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6)] print(kruskal_minimum_spanning_tree(n, m, edges)) # Output: 14 ```","solution":"class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def kruskal_minimum_spanning_tree(n, m, edges): edges.sort(key=lambda edge: edge[2]) uf = UnionFind(n) mst_weight = 0 for u, v, w in edges: u -= 1 v -= 1 if uf.find(u) != uf.find(v): uf.union(u, v) mst_weight += w return mst_weight"},{"question":"**Context**: You are tasked with developing a function to find the most frequently occurring element(s) in a dataset. This function will be useful in various domains, such as determining the most common words in text analysis or the most frequent errors logged in system diagnostics. **Task**: Write a function `find_modes(array)` that takes a single list of integers as input and returns a list of integers representing the most frequently occurring value(s) in the input list. If multiple values have the same highest frequency, the function should return all such values. **Input Format**: - A list of integers, `array`. **Output Format**: - A list of integers representing the most frequently occurring value(s). **Constraints**: - The input list can contain up to 10^5 elements. - The integers in the list range from -10^6 to 10^6. **Example**: ```python find_modes([1, 1, 2, 2, 3, 4]) # Output: [1, 2] find_modes([4, 4, 4, 1, 2, 2, 3, 3, 3]) # Output: [4] find_modes([]) # Output: [] ``` **Performance Requirements**: - The function should have a time complexity of O(n) and a space complexity of O(k), where n is the number of elements in the input array and k is the number of unique elements.","solution":"def find_modes(array): Returns a list of the most frequently occurring value(s) in the array. If multiple values have the same highest frequency, return all such values. if not array: return [] # Dictionary to store frequencies of elements frequency_dict = {} for num in array: if num in frequency_dict: frequency_dict[num] += 1 else: frequency_dict[num] = 1 # Find the maximum frequency max_frequency = max(frequency_dict.values()) # Collect all elements with the maximum frequency modes = [num for num, freq in frequency_dict.items() if freq == max_frequency] return modes"},{"question":"# Question: Convert Integer to Roman Numeral Extension You are given the task to extend the integer to Roman numeral conversion function. The previous function assumes an input range between 1 and 3999. Your goal is to adapt and improve the function to handle edge cases and ensure robustness for a broader set of requirements. Write a function `safe_int_to_roman` that converts an integer to a Roman numeral, handling inputs that are out of the typical range (1 to 3999) by returning a special string message. Function Signature ```python def safe_int_to_roman(num: int) -> str: pass ``` Input * An integer `num` representing the number to convert. It is guaranteed to be within the range from `0` to `5000`. Output * The Roman numeral representation of the input integer as a string, or an appropriate message. Constraints * If the input is `0`, return `\\"Invalid input: Zero has no Roman numeral representation.\\"` * If the input is greater than `3999` but less than or equal to `5000`, extend the standard Roman numeral system by appending apostrophus marks for every 1000 units beyond the range. * E.g., 4000 should be represented as \\"MMMM\\" or \\"IV̅\\". * For inputs greater than `5000`, return `\\"Invalid input: Value too large.\\"` Examples ```python assert safe_int_to_roman(0) == \\"Invalid input: Zero has no Roman numeral representation.\\" assert safe_int_to_roman(3000) == \\"MMM\\" assert safe_int_to_roman(4000) == \\"MMMM\\" assert safe_int_to_roman(4500) == \\"MMMMD\\" assert safe_int_to_roman(5001) == \\"Invalid input: Value too large.\\" ```","solution":"def safe_int_to_roman(num: int) -> str: if num == 0: return \\"Invalid input: Zero has no Roman numeral representation.\\" if num > 5000: return \\"Invalid input: Value too large.\\" roman_numerals = { 1000: \'M\', 900: \'CM\', 500: \'D\', 400: \'CD\', 100: \'C\', 90: \'XC\', 50: \'L\', 40: \'XL\', 10: \'X\', 9: \'IX\', 5: \'V\', 4: \'IV\', 1: \'I\' } result = \\"\\" for value in sorted(roman_numerals.keys(), reverse=True): while num >= value: result += roman_numerals[value] num -= value return result"},{"question":"# Reverse Words with Special Considerations **Objective**: Given a string, reverse the words while maintaining the relative lengths of spaces between them, as well as preserving the punctuation immediately adjacent to words. # Description You are tasked with writing a function that reverses the words in an input string, but with the requirement to maintain the exact spacing between the words and punctuation attached to the words. For example, multiple spaces between words should be preserved, and punctuation marks like commas or periods attached to words should not be altered. # Function Signature ```python def reverse_words_preserve_formatting(input_string: str) -> str: ``` # Input * A single string `input_string` which may contain alphabets, spaces, and punctuation marks. * The length of `input_string` will be in the range [1, 10^6]. # Output * The function should return a single string with the words reversed maintaining the relative spacing and punctuation formatting. # Constraints - The input string will not contain any newlines or tabs. - Each word will be considered a sequence of non-space characters bordered by space characters or string boundaries. # Examples ```python print(reverse_words_preserve_formatting(\\"Hello, world! How are you?\\")) # Output: \\"you? are How world! Hello,\\" print(reverse_words_preserve_formatting(\\" This is an example! \\")) # Output: \\" example! an is This \\" ``` # Explanation - In the first example, reversing the words \\"Hello, world! How are you?\\" should result in \\"you? are How world! Hello,\\" while maintaining the exact number of spaces between the words. - In the second example, despite the varying amounts of spaces and the punctuation, these features must be preserved in the reversed string.","solution":"def reverse_words_preserve_formatting(input_string: str) -> str: Given a string, reverse the words while maintaining the relative lengths of spaces, as well as preserving punctuation adjacent to the words. import re # Split the input string into words and spaces words_and_spaces = re.findall(r\'S+|s+\', input_string) # Extract words and spaces separately words = [segment for segment in words_and_spaces if not segment.isspace()] spaces = [segment for segment in words_and_spaces if segment.isspace()] # Reverse the list of words words.reverse() # Build the resulting string preserving the order of spaces and words result = [] words_index, spaces_index = 0, 0 for segment in words_and_spaces: if segment.isspace(): result.append(spaces[spaces_index]) spaces_index += 1 else: result.append(words[words_index]) words_index += 1 return \'\'.join(result)"},{"question":"Reversing a Singly Linked List Context You are a software developer for a new productivity app. One of the features allows users to list their tasks in reverse order. Internally, the tasks are stored in a singly linked list. Your task is to implement two methods to reverse this linked list: one iteratively and one recursively. Problem Statement Given a singly linked list, write two functions to reverse the linked list. * **Function 1: `reverse_list(head: ListNode) -> ListNode`** * **Function 2: `reverse_list_recursive(head: ListNode) -> ListNode`** Input * The input `head` is the head node of a singly linked list. Output * Both functions should return the head node of the reversed linked list. Constraints * The linked list node structure is: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` * The list contains at most (10^4) nodes. * The values in the list nodes are integers. Example 1. **Iterative Solution Example:** * Input: `1 -> 2 -> 3 -> 4` * Output: `4 -> 3 -> 2 -> 1` 2. **Recursive Solution Example:** * Input: `1 -> 2 -> 3 -> 4` * Output: `4 -> 3 -> 2 -> 1` Performance Requirements * The iterative solution should use (O(1)) additional space. * The recursive solution should leverage the call stack and is (O(n)) in space. Implement both methods with the given class structure: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head: ListNode) -> ListNode: # Your code here def reverse_list_recursive(head: ListNode) -> ListNode: # Your code here ``` You should test your solution with the given examples and additional edge cases. Edge Cases to Handle * Empty linked list (`head` is `None`). * Single node linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head: ListNode) -> ListNode: Reverses the singly linked list iteratively. prev = None current = head while current is not None: next_node = current.next current.next = prev prev = current current = next_node return prev def reverse_list_recursive(head: ListNode) -> ListNode: Reverses the singly linked list recursively. if head is None or head.next is None: return head new_head = reverse_list_recursive(head.next) head.next.next = head head.next = None return new_head"},{"question":"# Palindrome with Additional Conditions Implement a function `conditional_palindrome` that: 1. Takes a string `s` and an integer `k`. 2. Returns `True` if the given string `s` can be made into a palindrome by removing at most `k` characters. Otherwise, return `False`. Input: - `s`: A string (1 <= len(s) <= 10^5), which may contain alphanumeric characters and punctuation. - `k`: An integer (0 <= k <= len(s)) Output: - Returns a boolean indicating whether the string can be transformed into a palindrome by removing at most `k` characters. Constraints: - Case-insensitive comparison. - Ignore non-alphanumeric characters. Example: Input: `s = \\"A man, a plan, a canal, Panama\\"`, `k = 1` Output: `True` Input: `s = \\"race a car\\"`, `k = 1` Output: `True` Input: `s = \\"abcba\\"`, `k = 0` Output: `True` Input: `s = \\"abcdef\\"`, `k = 1` Output: `False` Explanation: 1. **First Example**: Removing one character \' \' or \',\' can make the string a palindrome. 2. **Second Example**: Removing the character \' \' can potentially make the string a palindrome. 3. **Third Example**: The string is already a palindrome. 4. **Fourth Example**: Removing one character cannot make it a palindrome.","solution":"import re def conditional_palindrome(s, k): # Filter out non-alphanumeric characters and convert to lower case filtered_s = re.sub(r\'[^a-zA-Z0-9]\', \'\', s).lower() def is_palindrome_range(l, r, deletes): if deletes < 0: return False while l < r: if filtered_s[l] != filtered_s[r]: return is_palindrome_range(l+1, r, deletes-1) or is_palindrome_range(l, r-1, deletes-1) l, r = l+1, r-1 return True return is_palindrome_range(0, len(filtered_s) - 1, k)"},{"question":"# Postorder Traversal of a Binary Tree Given a binary tree, your task is to implement two different methods to perform a postorder traversal of the tree. The postorder traversal should visit nodes in the order: left child, right child, root. Input - A binary tree represented as an instance of the `Node` class. ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` Output - A list of integers representing the values of the nodes visited in postorder traversal. Method 1: Iterative Approach Write a function `postorder_iterative` that performs an iterative postorder traversal and returns the resulting list. Method 2: Recursive Approach Write a function `postorder_recursive` that performs a recursive postorder traversal and returns the resulting list. Constraints - The number of nodes in the tree is between 0 and 10^4. - Node values are unique. Example ```python # Assuming the tree is constructed as follows: # 1 # # 2 # / # 3 root = Node(1, None, Node(2, Node(3), None)) # For the iterative method assert postorder_iterative(root) == [3, 2, 1] # For the recursive method assert postorder_recursive(root) == [3, 2, 1] ``` Implementation Implement your solution below: ```python def postorder_iterative(root: Node) -> list: # Your code here pass def postorder_recursive(root: Node) -> list: # Your code here pass ```","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def postorder_iterative(root: Node) -> list: if root is None: return [] stack = [root] output = [] while stack: node = stack.pop() output.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return output[::-1] def postorder_recursive(root: Node) -> list: def recur(node): if node is None: return [] return recur(node.left) + recur(node.right) + [node.val] return recur(root)"},{"question":"You are provided with a `SegmentTree` class that supports efficient range queries and updates. Your task is to implement a new function within this class: **Function to Implement**: You are required to add a `range_update` method to the SegmentTree class. This method will perform range updates, incrementing all elements within a specified range by a given value. **Function Signature**: ```python def range_update(self, l: int, r: int, value: int): # Implementation goes here ``` # Inputs: * **l** (`int`): Starting index of the range (inclusive). * **r** (`int`): Ending index of the range (inclusive). * **value** (`int`): The value by which each element in the range needs to be incremented. # Constrains: * `0 <= l <= r < N` (N is the size of the initial array) * The function must be implemented in O(log N) time complexity for range updates. # Output: The method does not return any value. It should update the segment tree in place. # Example: Consider a segment tree created from the array [2, 4, 5, 3, 4] with a sum function. ```python mytree = SegmentTree([2, 4, 5, 3, 4], lambda a, b: a + b) mytree.range_update(1, 3, 5) print(mytree.query(0, 3)) # Expected output should reflect updated range ``` Here, the `range_update` should add 5 to each element in the index range [1, 3], so the updated array should be [2, 9, 10, 8, 4]. # Additional Information: Ensure to modify existing functions if necessary to accommodate the range update functionality while maintaining the overall integrity and efficiency of the segment tree.","solution":"class SegmentTree: def __init__(self, data, func): self.n = len(data) self.tree = [0] * (2 * self.n) self.lazy = [0] * (2 * self.n) self.func = func # Building the segment tree for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[i * 2], self.tree[i * 2 + 1]) def range_update(self, l, r, value): l += self.n r += self.n + 1 l0, r0 = l, r while l < r: if l & 1: self.lazy[l] += value self.apply(l) l += 1 if r & 1: r -= 1 self.lazy[r] += value self.apply(r) l >>= 1 r >>= 1 # Rebuild affected segment self.build(l0) self.build(r0 - 1) def apply(self, pos): self.tree[pos] += self.lazy[pos] if pos < self.n: self.lazy[pos * 2] += self.lazy[pos] self.lazy[pos * 2 + 1] += self.lazy[pos] self.lazy[pos] = 0 def build(self, pos): while pos > 1: pos //= 2 self.tree[pos] = self.func(self.tree[2 * pos] + self.lazy[2 * pos], self.tree[2 * pos + 1] + self.lazy[2 * pos + 1]) def query(self, l, r): l += self.n r += self.n + 1 res = 0 l_apply = [] r_apply = [] while l < r: if l & 1: l_apply.append(l) res = self.func(res, self.tree[l] + self.lazy[l]) l += 1 if r & 1: r -= 1 r_apply.append(r) res = self.func(res, self.tree[r] + self.lazy[r]) l >>= 1 r >>= 1 for i in l_apply + r_apply: self.apply(i) return res"},{"question":"# Problem: Optimized Selection Sort Context: You are tasked with writing an optimized version of the selection sort algorithm. This version should reduce the time complexity under certain conditions and be well suited for competitive programming scenarios where performance is critical. Task: Implement the function `optimized_selection_sort` that sorts a list of integers in ascending order using an optimized version of the selection sort algorithm. In this version, integrate an early exit mechanism to check if the list is already sorted after each pass and stop further iterations if no swaps were made in a full traverse. Function Signature: ```python def optimized_selection_sort(arr: List[int]) -> List[int]: pass ``` Input: - A list of integers `arr`. Output: - A new list of integers sorted in ascending order. Constraints: - The list length will be between 0 and 10^3. - Elements of the list will be integers ranging between -10^3 and 10^3. Example: ```python assert optimized_selection_sort([4, 2, 5, 1, 3]) == [1, 2, 3, 4, 5] assert optimized_selection_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert optimized_selection_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] assert optimized_selection_sort([]) == [] assert optimized_selection_sort([3]) == [3] ``` Note: - Implement a mechanism that allows the function to exit early if the list is detected to be sorted during the sorting process.","solution":"from typing import List def optimized_selection_sort(arr: List[int]) -> List[int]: n = len(arr) for i in range(n - 1): min_index = i sorted_flag = True for j in range(i + 1, n): if arr[j] < arr[min_index]: min_index = j if arr[j - 1] > arr[j]: sorted_flag = False if sorted_flag: # If no swaps were made, list is already sorted break # Swap the found minimum element with the first element of the unsorted portion arr[i], arr[min_index] = arr[min_index], arr[i] return arr"},{"question":"Your task is to implement functions to encode a list of strings into a single string and decode a single string back into the list of strings. # Function Signatures ```python def encode(strs: List[str]) -> str: pass def decode(s: str) -> List[str]: pass ``` # Requirements 1. **Encoding** - Converts a list of strings into a single string such that each string is prefixed by its length and a delimiter. - For example: `encode([\\"hello\\", \\"world\\"])` should return `\\"5:hello5:world\\"`. 2. **Decoding** - Converts an encoded string back into the original list of strings. - For example: `decode(\\"5:hello5:world\\")` should return `[\\"hello\\", \\"world\\"]`. # Constraints - The input list for `encode` will have length between 0 and 1000. - Each string in the input list will have length between 0 and 1000. - Assume no string will contain the colon character (`:`), used as a length delimiter. # Example ```python assert encode([\\"hello\\", \\"world\\"]) == \\"5:hello5:world\\" assert decode(\\"5:hello5:world\\") == [\\"hello\\", \\"world\\"] assert encode([\\"\\"]) == \\"0:\\" assert decode(\\"0:\\") == [\\"\\"] ``` Design and implement the `encode` and `decode` functions to pass the above constraints and examples. Ensure your solution is efficient and handles various edge cases appropriately.","solution":"from typing import List def encode(strs: List[str]) -> str: Encode a list of strings into a single string. Args: strs: List[str] - List of strings to be encoded Returns: str - The encoded single string encoded_str = \\"\\" for string in strs: encoded_str += f\\"{len(string)}:{string}\\" return encoded_str def decode(s: str) -> List[str]: Decode a single string back into a list of strings. Args: s: str - The encoded string to be decoded Returns: List[str] - The original list of strings decoded_list = [] i = 0 while i < len(s): j = s.find(\':\', i) length = int(s[i:j]) i = j + 1 decoded_list.append(s[i:i + length]) i += length return decoded_list"},{"question":"Given a positive integer ( n ), write a function to find the number of ways to decompose ( n ) into sums of positive integers, where the order of addends does not matter. This problem involves partitioning the integer into non-negative integer partitions. # Input - An integer ( n ) (1 ≤ ( n ) ≤ 100) # Output - An integer representing the number of ways to partition ( n ). # Function Signature ```python def integer_partition(n: int) -> int: ``` # Constraints - The input integer ( n ) will be in the range ( 1 ) to ( 100 ). # Example - **Example 1:** - Input: `4` - Output: `5` - Explanation: ``` 4 = 4 4 = 3 + 1 4 = 2 + 2 4 = 2 + 1 + 1 4 = 1 + 1 + 1 + 1 ``` - **Example 2:** - Input: `7` - Output: `15` - Explanation: ``` 7 = 7 7 = 6 + 1 7 = 5 + 2 7 = 5 + 1 + 1 7 = 4 + 3 7 = 4 + 2 + 1 7 = 4 + 1 + 1 + 1 7 = 3 + 3 + 1 7 = 3 + 2 + 2 7 = 3 + 2 + 1 + 1 7 = 3 + 1 + 1 + 1 + 1 7 = 2 + 2 + 2 + 1 7 = 2 + 2 + 1 + 1 + 1 7 = 2 + 1 + 1 + 1 + 1 + 1 7 = 1 + 1 + 1 + 1 + 1 + 1 + 1 ``` # Notes - Ensure your solution runs efficiently for the maximum constraint. - Consider edge cases such as very small input values. - Aim for a readable and efficient implementation.","solution":"def integer_partition(n: int) -> int: This function returns the number of ways to partition the integer n into sums of positive integers where the order of addends does not matter. # Initialize a list for storing the counts partition_count = [0] * (n + 1) # There\'s 1 way to partition the number 0 partition_count[0] = 1 # Loop to calculate the partition counts for all numbers up to n for i in range(1, n + 1): for j in range(i, n + 1): partition_count[j] += partition_count[j - i] return partition_count[n]"},{"question":"You are given a stack of integers. Your task is to transform this stack so that every element in the stack is replaced by two consecutive occurrences of that element. You need to implement two functions to achieve this: - `first_stutter(stack)` which uses a stack as auxiliary storage. - `second_stutter(stack)` which uses a queue as auxiliary storage. Both functions should transform the given stack such that every element appears twice consecutively. # Input Format - The input is a list `stack` where the end of the list represents the top of the stack. # Output Format - Return the modified stack where each element appears twice consecutively. # Constraints - Elements in the stack are integers. - The number of elements in the stack is between 0 and 1000 (inclusive). # Performance Requirements - Time Complexity: O(n) where n is the number of elements in the stack. - Space Complexity: O(n) auxiliary space for the respective auxiliary data structures. # Example ```python stack = [3, 7, 1, 14, 9] assert first_stutter(stack) == [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] stack = [3, 7, 1, 14, 9] assert second_stutter(stack) == [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` # Function Signatures ```python def first_stutter(stack: List[int]) -> List[int]: # Implement the function using a stack for auxiliary storage pass def second_stutter(stack: List[int]) -> List[int]: # Implement the function using a queue for auxiliary storage pass ``` Ensure that both implementations precisely follow the requirements and handle the edge cases appropriately.","solution":"def first_stutter(stack): Transforms the stack such that every element appears twice consecutively using another stack. aux_stack = [] while stack: aux_stack.append(stack.pop()) while aux_stack: element = aux_stack.pop() stack.append(element) stack.append(element) return stack def second_stutter(stack): Transforms the stack such that every element appears twice consecutively using a queue. from collections import deque queue = deque() while stack: queue.append(stack.pop()) while queue: element = queue.popleft() stack.append(element) stack.append(element) stack.reverse() # Since elements are added to the stack in reverse order return stack"},{"question":"You are tasked to implement a class that extends the provided `BTree` class to include a function that finds the k-th smallest element in the B-tree. # Requirements - Implement a method `find_kth_smallest(k)` within the `BTree` class. - The method should take an integer `k` and return the k-th smallest element in the B-tree. - Ensure to handle cases where `k` is out of bounds (either less than 1 or greater than the total number of elements). # Input * `k` - an integer representing the k-th position (1-based index). # Output * Returns the k-th smallest element if `k` is within bounds, otherwise should raise an appropriate exception. # Constraints * The B-tree elements can be of any integer value. * The B-tree will not contain duplicate elements. * Assume the B-tree is already balanced. # Example ```python # Create a B-tree btree = BTree(t_val=3) elements_to_insert = [10, 20, 5, 6, 12, 30, 7, 17] for elem in elements_to_insert: btree.insert_key(elem) # Find the k-th smallest element print(btree.find_kth_smallest(3)) # Output should be 7 ``` # Performance Requirements * Ensure the solution runs efficiently with O(log n) operations where n is the number of elements in the B-tree. * Consider space optimization: the function should not use additional memory proportional to the number of elements in the tree. # Function Signature ```python class BTree: # other methods ... def find_kth_smallest(self, k: int) -> int: # implementation goes here ``` # Additional Notes * Be sure to handle edge cases where `k` is out of bounds, and raise an exception with an appropriate error message. * Consider writing helper functions if needed to keep the code modular and understandable.","solution":"class Node: def __init__(self, leaf=False): self.leaf = leaf self.keys = [] self.children = [] class BTree: def __init__(self, t): self.root = Node(leaf=True) self.t = t # Minimum degree def insert_key(self, k): # Simplified B-Tree insert to make sure tree contains the elements root = self.root if len(root.keys) == (2 * self.t) - 1: new_root = Node() new_root.children.append(self.root) self._split_child(new_root, 0) self.root = new_root self._insert_non_full(self.root, k) def _split_child(self, parent, i): t = self.t new_node = Node(parent.children[i].leaf) y = parent.children[i] parent.children.insert(i + 1, new_node) parent.keys.insert(i, y.keys[t-1]) new_node.keys = y.keys[t:(2*t-1)] y.keys = y.keys[0:(t-1)] if not y.leaf: new_node.children = y.children[t:(2*t)] y.children = y.children[0:t] def _insert_non_full(self, node, k): i = len(node.keys) - 1 if node.leaf: node.keys.append(None) while i >= 0 and k < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = k else: while i >= 0 and k < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * self.t) - 1: self._split_child(node, i) if k > node.keys[i]: i += 1 self._insert_non_full(node.children[i], k) def find_kth_smallest(self, k): def _inorder_traverse(node): if node.leaf: return node.keys result = [] for i in range(len(node.keys)): result.extend(_inorder_traverse(node.children[i])) result.append(node.keys[i]) result.extend(_inorder_traverse(node.children[len(node.keys)])) return result if k < 1: raise ValueError(\\"k is out of bounds\\") elements = _inorder_traverse(self.root) if k > len(elements): raise ValueError(\\"k is out of bounds\\") return elements[k-1]"},{"question":"# Regular Expression Matching You have to implement a function that matches a string against a regular expression pattern. The pattern includes two special characters: - `\'.\'` which matches any single character. - `\'*\'` which matches zero or more occurrences of the character immediately before it. You need to implement the following function signature: ```python def is_match(s: str, p: str) -> bool: # implement your solution here ``` Input: - `s` (string): The string to be matched. (1 <= len(s) <= 30) - `p` (string): The pattern containing `.` and `*` characters as well as lowercase alphabets. (1 <= len(p) <= 30) Output: - Returns `True` if the string `s` matches the pattern `p` entirely, otherwise returns `False`. Constraints: - The string `s` may be empty and contains only lowercase alphabets. - The pattern `p` may be empty and contains only lowercase alphabets, `.` and `*`. Examples: ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"aa\\") == True assert is_match(\\"aaa\\", \\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` # Explanation: 1. `is_match(\\"aa\\", \\"a\\")` returns `False` because \'a\' does not match multiple \'a\'s. 2. `is_match(\\"aa\\", \\"aa\\")` returns `True` because both strings are exactly the same. 3. `is_match(\\"aaa\\", \\"aa\\")` returns `False` because the pattern \'aa\' does not match \'aaa\'. 4. `is_match(\\"aa\\", \\"a*\\")` returns `True` because \'*\' allows \'a\' to be repeated. 5. `is_match(\\"aa\\", \\".*\\")` returns `True` because \'.\' matches any character and \'*\' allows it to repeat. 6. `is_match(\\"ab\\", \\".*\\")` returns `True` because \'.*\' matches any sequence of characters. 7. `is_match(\\"aab\\", \\"c*a*b\\")` returns `True` because \'c*\' can be ignored (matches 0 \'c\'), \'a*\' matches \'aa\' and \'b\' matches \'b\'. **Implementation Notes:** Your solution should handle edge cases such as empty strings and patterns, and patterns that include multiple consecutive special characters. You should ensure that the solution is efficient within the provided constraints.","solution":"def is_match(s: str, p: str) -> bool: # Base case: if the pattern is empty, the string should also be empty if not p: return not s # Check if the first character of the string matches the first character of the pattern first_match = bool(s) and p[0] in {s[0], \'.\'} # If the pattern contains \'*\', check for zero or more occurrences of the preceding character if len(p) >= 2 and p[1] == \'*\': # \'is_match(s, p[2:])\' checks for zero occurrence of the preceding char # \'is_match(s[1:], p)\' checks for one or more occurrence of the preceding char return is_match(s, p[2:]) or (first_match and is_match(s[1:], p)) else: # Proceed with the next character in both the string and the pattern return first_match and is_match(s[1:], p[1:])"},{"question":"You are given a directed graph represented by a list of edges. Your task is to implement a function to determine if there exists a path between two given nodes `source` and `target`. # Function Signature ```python def is_path_exists(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: pass ``` # Input 1. **vertex_count** (int): The number of vertices in the graph. 2. **edges** (List[Tuple[int, int]]): A list of directed edges where each edge is represented as a tuple `(source, target)`. 3. **source** (int): The starting node for the path search. 4. **target** (int): The destination node for the path search. # Output * (bool): Return `True` if there is a path from `source` to `target`, otherwise return `False`. # Examples ```python assert is_path_exists(4, [(0, 1), (1, 2), (2, 3)], 0, 3) == True assert is_path_exists(4, [(0, 1), (1, 2), (3, 0)], 0, 3) == False assert is_path_exists(5, [(0, 1), (1, 2), (2, 3), (3, 4)], 2, 4) == True assert is_path_exists(5, [(0, 1), (1, 2), (3, 4)], 0, 4) == False ``` # Constraints * `0 <= vertex_count <= 1000` * `0 <= edges <= 1000` * `0 <= source, target < vertex_count` # Notes * You may assume that the graph does not contain multiple edges from one node to another. # Explanation The task is designed to assess your understanding of graph traversal using depth-first search (DFS). To solve the problem, you should: 1. Build the graph from the given list of edges. 2. Use the DFS algorithm to determine if there\'s a path from the given `source` node to the `target` node. 3. Ensure your code handles edge cases like unreachable nodes and graphs with cycles efficiently.","solution":"from typing import List, Tuple def is_path_exists(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: # Creating the adjacency list for the graph graph = {i: [] for i in range(vertex_count)} for (u, v) in edges: graph[u].append(v) # Helper function to perform DFS def dfs(node: int, visited: set) -> bool: if node == target: return True visited.add(node) for neighbor in graph[node]: if neighbor not in visited: if dfs(neighbor, visited): return True return False # Perform DFS from the source node visited = set() return dfs(source, visited)"},{"question":"# Question: Implement a Balanced Binary Search Tree (AVL Tree) Background Given the `TreeNode` class provided, implement an **AVL Tree** that ensures the tree remains balanced after each insertion or deletion. An AVL Tree is a type of Binary Search Tree that maintains its balance with rotations during insertion and deletion operations to ensure O(log n) search time performance. Requirements 1. **Insertion**: Implement the `insert` method to add a value to the AVL Tree. 2. **Deletion**: Implement the `delete` method to remove a value from the AVL Tree. 3. **Balancing**: Ensure that after every insert or delete operation, the tree remains balanced. 4. **Traversal**: Implement a `print_inorder` method to print the tree in ascending order. Function Signature ```python class AVLTree: def __init__(self): self.root = None def insert(self, root: TreeNode, val: int) -> TreeNode: pass def delete(self, root: TreeNode, val: int) -> TreeNode: pass def print_inorder(self, root: TreeNode) -> None: pass ``` Input - For `insert` and `delete`: an integer value `val` to insert or delete. - For `print_inorder`: the root node of the AVL Tree. Output - For `insert` and `delete`: the root node of the updated AVL Tree. - For `print_inorder`: print the values in the tree in ascending order. Constraints - Values inserted will always be integers. - The class will handle multiple insertions and deletions. Example ```python tree = AVLTree() root = None root = tree.insert(root, 10) root = tree.insert(root, 20) root = tree.insert(root, 30) root = tree.print_inorder(root) # Expected Output: 10 20 30 root = tree.delete(root, 20) root = tree.print_inorder(root) # Expected Output: 10 30 ``` Implement the insert, delete and print_inorder functions for the AVL Tree to fulfill the requirements.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, root: TreeNode, key: int) -> TreeNode: if not root: return TreeNode(key) elif key < root.val: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) # Left Left Case if balance > 1 and key < root.left.val: return self.right_rotate(root) # Right Right Case if balance < -1 and key > root.right.val: return self.left_rotate(root) # Left Right Case if balance > 1 and key > root.left.val: root.left = self.left_rotate(root.left) return self.right_rotate(root) # Right Left Case if balance < -1 and key < root.right.val: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def delete(self, root: TreeNode, key: int) -> TreeNode: if not root: return root elif key < root.val: root.left = self.delete(root.left, key) elif key > root.val: root.right = self.delete(root.right, key) else: if root.left is None: temp = root.right root = None return temp elif root.right is None: temp = root.left root = None return temp temp = self.get_min_value_node(root.right) root.val = temp.val root.right = self.delete(root.right, temp.val) if root is None: return root root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) # Left Left Case if balance > 1 and self.get_balance(root.left) >= 0: return self.right_rotate(root) # Left Right Case if balance > 1 and self.get_balance(root.left) < 0: root.left = self.left_rotate(root.left) return self.right_rotate(root) # Right Right Case if balance < -1 and self.get_balance(root.right) <= 0: return self.left_rotate(root) # Right Left Case if balance < -1 and self.get_balance(root.right) > 0: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def print_inorder(self, root: TreeNode) -> None: if root: self.print_inorder(root.left) print(root.val, end=\' \') self.print_inorder(root.right) def left_rotate(self, z: TreeNode) -> TreeNode: y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def right_rotate(self, z: TreeNode) -> TreeNode: y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def get_height(self, root: TreeNode) -> int: if not root: return 0 return root.height def get_balance(self, root: TreeNode) -> int: if not root: return 0 return self.get_height(root.left) - self.get_height(root.right) def get_min_value_node(self, root: TreeNode) -> TreeNode: current = root while current.left is not None: current = current.left return current # Helper function to print the inorder traversal def print_tree_inorder(root: TreeNode): if root: print_tree_inorder(root.left) print(root.val, end=\' \') print_tree_inorder(root.right)"},{"question":"Write a function `delete_reoccurring_characters` that takes a string `s` as input and returns a new string with all reoccurring characters removed. Only the first occurrence of each character should be kept in the result. Function Signature ```python def delete_reoccurring_characters(s: str) -> str: ``` Input - `s`: a string containing any ASCII characters (0 <= len(s) <= 10^6) Output - A string with all reoccurring characters removed, maintaining the order of their first appearance. Constraints - Characters in the string should be treated as case-sensitive. Examples ```python delete_reoccurring_characters(\\"aabbcc\\") # should return \\"abc\\" delete_reoccurring_characters(\\"google\\") # should return \\"gole\\" delete_reoccurring_characters(\\"aabbccaa\\") # should return \\"abc\\" delete_reoccurring_characters(\\"123345\\") # should return \\"12345\\" delete_reoccurring_characters(\\"\\") # should return \\"\\" ``` Requirements - The solution should have a time complexity of O(n) and space complexity of O(n), where n is the length of the string. - Handle edge cases where the input string may be empty or contain no repeating characters. Scenario Imagine you are designing a unique identifier generator for user input where each character in the identifier must be unique. Users often input user names with repeated characters, and you need a system to clean these inputs by removing any repeated characters. Implement the function to clean up the inputs efficiently.","solution":"def delete_reoccurring_characters(s: str) -> str: Removes all reoccurring characters from the string `s`, keeping only the first occurrence of each character. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"You are given a singly linked list. Write a function `remove_duplicates(head, use_set=True)` to remove duplicate values from this list. * If `use_set` is True, use a HashSet to track seen values and remove duplicates efficiently. * If `use_set` is False, remove duplicates without using extra space, but maintain the same order of elements. # Function Signature: ```python def remove_duplicates(head: Node, use_set: bool = True) -> None: pass ``` # Input: * `head` - Head node of the singly linked list. * `use_set` - Boolean flag to decide the approach. # Output: * The function should modify the linked list in-place and should not return anything. # Constraints: * The linked list contains at most 10^4 nodes. * Node values are strings with at most 10 characters. # Example: Input: ``` A -> A -> B -> C -> D -> C -> F -> G ``` Execution: ```python a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g remove_duplicates(a1, use_set=True) # Using the HashSet approach # Result: A -> B -> C -> D -> F -> G remove_duplicates(a1, use_set=False) # Using the in-place approach # Result: A -> B -> C -> D -> F -> G ``` # Note: * Ensure your solution handles all edge cases effectively. * Remember to maintain the order of the linked list elements during duplicate removal.","solution":"class Node: def __init__(self, val: str): self.val = val self.next = None def remove_duplicates(head: Node, use_set: bool = True) -> None: if use_set: # Use a set to track seen values seen = set() current = head prev = None while current: if current.val in seen: prev.next = current.next else: seen.add(current.val) prev = current current = current.next else: # Remove duplicates without extra space current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# File Path Utility Function Context In many programming scenarios, especially in file handling, it is crucial to manage paths reliably. Paths can be relative or absolute. Without proper path normalization, your programs can run into issues when accessing or storing files. Your task is to write a function that converts any given file path into an absolute path. This is particularly useful for ensuring that any file paths used within your scripts or applications are fully qualified and consistent. Challenge Implement a function `normalize_path` that takes a single string argument representing a file path and returns its absolute path. It should handle the following: 1. Convert relative paths to absolute paths. 2. Substitute the `~` symbol at the start of the path with the user\'s home directory. 3. Resolve dot notations (e.g., `.` and `..`). # Function Signature ```python def normalize_path(file: str) -> str: ``` # Input - **file**: a string representing the file path. Constraints: - The path may be empty. - The path may start with `~`, representing the user\'s home directory. - The path may contain dot notations (`.` representing the current directory and `..` representing the parent directory). # Output - A string representing the absolute path of the given file. # Example ```python # Example 1: file = \\"~/Documents/Project\\" print(normalize_path(file)) # Output: \'/home/user/Documents/Project\' (output may vary depending on the user\'s home directory) # Example 2: file = \\"../Desktop/file.txt\\" print(normalize_path(file)) # Output: \'/home/user/Desktop/file.txt\' (output may vary depending on the current directory) ``` # Constraints - Your function should not assume that any given file paths exist. - You are encouraged to use Python\'s built-in libraries `os.path.expanduser` and `os.path.abspath`. # Performance - Aim for efficiency both in terms of time and space. Additional Information You do not need to handle invalid path formats, assume valid input paths.","solution":"import os def normalize_path(file: str) -> str: Converts a relative file path to an absolute file path, substitutes the \'~\' with the user\'s home directory, and resolves any \'.\' or \'..\' notations. # Expand the user \\"~\\" symbol to the user\'s home directory expanded_path = os.path.expanduser(file) # Convert the path to an absolute path absolute_path = os.path.abspath(expanded_path) return absolute_path"},{"question":"You are given an unsorted array of integers. Your task is to implement the `cocktail_shaker_sort` method in Python, which sorts the array in non-decreasing order using the Cocktail Shaker Sort algorithm. # Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: pass ``` # Input - `arr`: A list of integers, where (0 leq text{len(arr)} leq 10^4). # Output - Returns a sorted list of integers in non-decreasing order. # Constraints - You must sort the array in-place, and the function should return the sorted array. - Optimize the code to minimize unnecessary comparisons. # Example ```python assert cocktail_shaker_sort([3, 2, 1]) == [1, 2, 3] assert cocktail_shaker_sort([5, 1, 4, 2, 8]) == [1, 2, 4, 5, 8] assert cocktail_shaker_sort([]) == [] assert cocktail_shaker_sort([1]) == [1] assert cocktail_shaker_sort([2, 1, 2, 1, 2]) == [1, 1, 2, 2, 2] ``` # Explanation The function should correctly sort the input array both when the elements are completely unsorted and when already sorted or nearly sorted. Pay attention to edge cases such as empty arrays or arrays with just one element. # Tips - Be mindful of array indices to prevent any `IndexErrors`. - Ensure to terminate early if the array becomes sorted before all passes are completed.","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts the given list of integers using the Cocktail Shaker Sort algorithm. Parameters: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list of integers in non-decreasing order. if not arr: return [] n = len(arr) start = 0 end = n - 1 while start <= end: swapped = False # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If nothing was swapped, then the list is sorted if not swapped: break # Last element is in its correct position end -= 1 swapped = False # Backward pass for i in range(end, start, -1): if arr[i - 1] > arr[i]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True # If nothing was swapped, then the list is sorted if not swapped: break # First element is in its correct position start += 1 return arr"},{"question":"# Problem: Generalized n-Sum Problem Introduction You are given an array of integers and a target sum. Your task is to find all unique n-tuples in the array that sum up to the target. To make the problem more interesting, you will be provided functions to compute custom sums and compare the summation results. Requirements Implement the function `generalized_n_sum` that follows the signature: ```python def generalized_n_sum(n: int, nums: List[int], target: int, sum_func: Callable[[Any, Any], Any] = None, compare_func: Callable[[Any, int], int] = None) -> List[List[int]]: pass ``` Inputs 1. `n` (int): The number of elements in each tuple. 2. `nums` (List[int]): The list of integers. 3. `target` (int): The target sum that each n-tuple should reach. 4. `sum_func` (Optional[Callable[[Any, Any], Any]]): A custom function that takes two elements of `nums` and returns their sum. Default should be the standard addition. 5. `compare_func` (Optional[Callable[[Any, int], int]]): A custom comparator function that takes the sum result and the target, returning -1 if less than target, 1 if greater, and 0 if equal. Defaults should be a standard comparison. Outputs * A list of lists, with each inner list containing a unique n-tuple of integers that sum up to the target. Constraints * 1 ≤ n ≤ 30 * -10^9 ≤ nums[i], target ≤ 10^9 * The input list, `nums`, can contain duplicates. Examples **Example 1:** ```python n = 4 nums = [1, 0, -1, 0, -2, 2] target = 0 print(generalized_n_sum(n, nums, target)) # Expected output: [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] ``` **Example 2:** ```python n = 2 nums = [[-3, 0], [-2, 1], [2, 2], [3, 3], [8, 4], [-9, 5]] target = -5 def sum_custom(a, b): return [a[0] + b[1], a[1] + b[0]] def compare_custom(num, target): if num[0] < target: return -1 elif num[0] > target: return 1 else: return 0 print(generalized_n_sum(n, nums, target, sum_func=sum_custom, compare_func=compare_custom)) # Expected output: [[-9, 5], [8, 4]] ``` Hints * Consider using sorting and the two-pointer technique. * Handle duplicates carefully by ignoring repeated elements. * The solution\'s efficiency can be improved by memoization or optimizing recursive calls.","solution":"from typing import List, Any, Callable def generalized_n_sum(n: int, nums: List[int], target: int, sum_func: Callable[[Any, Any], Any] = None, compare_func: Callable[[Any, int], int] = None) -> List[List[int]]: if not sum_func: sum_func = lambda a, b: a + b if not compare_func: compare_func = lambda num, target: (num > target) - (num < target) # Returns -1, 0, or 1 def find_n_sum(nums, target, n, path, results): if len(nums) < n or n < 2: # Not enough numbers to form n-tuple return if n == 2: # Two-pointer approach for 2-sum problem left, right = 0, len(nums) - 1 while left < right: current_sum = sum_func(nums[left], nums[right]) comparison = compare_func(current_sum, target) if comparison == 0: results.append(path + [nums[left], nums[right]]) left += 1 right -= 1 while left < right and nums[left] == nums[left - 1]: left += 1 while left < right and nums[right] == nums[right + 1]: right -= 1 elif comparison < 0: left += 1 else: right -= 1 else: for i in range(len(nums) - n + 1): if i == 0 or nums[i] != nums[i - 1]: # Avoid duplicates find_n_sum(nums[i + 1:], target - nums[i], n - 1, path + [nums[i]], results) nums.sort() results = [] find_n_sum(nums, target, n, [], results) return results"},{"question":"Context You are tasked with developing a system to monitor and track the formation of islands in a grid-based ocean map. Each cell in the grid can either be water (\'0\') or land (\'1\'). An island is defined as a group of horizontally or vertically connected lands. Problem Statement Implement a function `num_islands(grid)` that takes a 2D grid of characters representing \'land\' and \'water\', and returns the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. Assume all four edges of the grid are surrounded by water. Input * `grid` (List[List[str]]): A 2D list representing the grid, where \'1\' represents land and \'0\' represents water. Valid grid dimensions are `0 <= len(grid) <= 1000` and `0 <= len(grid[0]) <= 1000`. Output * `int`: The number of islands. Constraints * Your solution should be optimized for both time and space complexity. * You cannot modify the original grid. * Avoid recursive solutions to prevent stack overflow on large grids. Examples ```python # Example 1 grid = [ [\'1\', \'1\', \'1\', \'1\', \'0\'], [\'1\', \'1\', \'0\', \'1\', \'0\'], [\'1\', \'1\', \'0\', \'0\', \'0\'], [\'0\', \'0\', \'0\', \'0\', \'0\'] ] assert num_islands(grid) == 1 # Example 2 grid = [ [\'1\', \'1\', \'0\', \'0\', \'0\'], [\'1\', \'1\', \'0\', \'0\', \'0\'], [\'0\', \'0\', \'1\', \'0\', \'0\'], [\'0\', \'0\', \'0\', \'1\', \'1\'] ] assert num_islands(grid) == 3 ```","solution":"def num_islands(grid): Returns the number of islands in a given grid. Parameters: grid (List[List[str]]): A 2D list representing the grid, where \'1\' represents land and \'0\' represents water. Returns: int: The number of islands. if not grid: return 0 def bfs(grid, visited, start_row, start_col): queue = [(start_row, start_col)] visited[start_row][start_col] = True while queue: row, col = queue.pop(0) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and not visited[r][c] and grid[r][c] == \'1\': queue.append((r, c)) visited[r][c] = True visited = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))] island_count = 0 for row in range(len(grid)): for col in range(len(grid[0])): if grid[row][col] == \'1\' and not visited[row][col]: bfs(grid, visited, row, col) island_count += 1 return island_count"},{"question":"# Problem: Rotate Matrix You are given an n x n 2D matrix `mat` representing an image. Write a function `rotate(mat)` that rotates the image by 90 degrees clockwise. **Function Signature** ```python def rotate(mat: List[List[int]]) -> None: ``` **Input** - `mat`: A list of n lists each containing n integers, where 1 <= n <= 1000. **Output** - The function should modify the matrix `mat` in-place. Do not return anything. **Example** ```python mat = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] rotate(mat) # After rotation, mat should be: # [ # [ 7, 4, 1 ], # [ 8, 5, 2 ], # [ 9, 6, 3 ] # ] ``` **Constraints** - The matrix `mat` is guaranteed to be an n x n 2D array. **Performance requirements** - The solution should run in O(n^2) time complexity. - The solution should use O(1) additional space complexity. **Scenario/Context** This function is used to rotate images and grids (such as those used in pixel-based images or game boards) efficiently in-place, minimizing the memory footprint and maintaining performance.","solution":"from typing import List def rotate(mat: List[List[int]]) -> None: Rotates the matrix by 90 degrees clockwise in place. n = len(mat) # Transpose the matrix for i in range(n): for j in range(i, n): mat[i][j], mat[j][i] = mat[j][i], mat[i][j] # Reverse each row for i in range(n): mat[i].reverse()"},{"question":"You are given two strings (s) and (t). String (t) is generated by random shuffling string (s) and then adding one more letter at a random position. Your task is to write a function `find_added_letter(s: str, t: str) -> str` that finds and returns the letter that was added in (t). Input * (s): a string of lowercase English letters, (1 leq text{len}(s) leq 10^4) * (t): a string of lowercase English letters, (text{len}(t) = text{len}(s) + 1) Output * A single character representing the letter added to string (t). Example ```plaintext Input: s = \\"abcd\\" t = \\"abecd\\" Output: \'e\' ``` # Constraints * Both strings consist of only lowercase letters. * String (t) is assured to be created by shuffling string (s) and adding exactly one additional letter. # Performance Requirements Your solution should run in (O(n)) time complexity and use (O(1)) extra space. # Implementation Requirements You must implement the `find_added_letter` function. Utilize the properties of the XOR operation to achieve the desired result within the specified constraints. # Hint Use the characteristic properties of XOR to deduce the added character.","solution":"def find_added_letter(s: str, t: str) -> str: Finds the letter that was added to string t. result = 0 for char in s: result ^= ord(char) for char in t: result ^= ord(char) return chr(result)"},{"question":"# Generating Abbreviations for a Word Problem Description You need to write a function that generates all possible abbreviations for a given word, where each abbreviation is a combination of literal characters and counts representing consecutive characters skipped. For example, the word \\"word\\" can be abbreviated in the following ways: * \\"word\\" * \\"wor1\\" * \\"wo1d\\" * \\"wo2\\" * \\"w1rd\\" * \\"w1r1\\" * \\"w2d\\" * \\"w3\\" * \\"1ord\\" * \\"1or1\\" * \\"1o1d\\" * \\"1o2\\" * \\"2rd\\" * \\"2r1\\" * \\"3d\\" * \\"4\\" Input * **word (str)**: A non-empty string consisting of lowercase English letters. Output * **List of Strings**: A list containing all possible abbreviations for the input word. Example Input: ```python word = \\"word\\" ``` Output: ```python [\\"word\\", \\"wor1\\", \\"wo1d\\", \\"wo2\\", \\"w1rd\\", \\"w1r1\\", \\"w2d\\", \\"w3\\", \\"1ord\\", \\"1or1\\", \\"1o1d\\", \\"1o2\\", \\"2rd\\", \\"2r1\\", \\"3d\\", \\"4\\"] ``` Constraints * The length of `word` will be between 1 and 15, inclusive. * The resulting abbreviations should be unique and sorted in no particular order. Performance Requirements * Your solution should be efficient enough to handle the upper boundary within a reasonable time frame considering the exponential number of abbreviations. Implementation Guidelines Implement the function `generate_abbreviations(word: str) -> List[str]`. Your implementation should explore all possible ways to abbreviate the word by either including each character or counting it as part of the abbreviation. Skeleton Code Here is a skeleton you can start with: ```python def generate_abbreviations(word): # Your code here return [] # Test the function with the example word = \\"word\\" print(generate_abbreviations(word)) ```","solution":"def generate_abbreviations(word): def helper(pos, current, count): if pos == len(word): result.append(current + (str(count) if count > 0 else \'\')) else: # Option 1: Skip the current character and count it helper(pos + 1, current, count + 1) # Option 2: Include the current character helper(pos + 1, current + (str(count) if count > 0 else \'\') + word[pos], 0) result = [] helper(0, \\"\\", 0) return result"},{"question":"Scenario You are developing a file management system that needs to handle various file path formats from user inputs. Paths may include relative paths, user home directory shortcuts (`~`), or references to parent directories (`..`). Your task is to write a function that normalizes these paths into their absolute formats, ensuring they are ready for file operations. Task Implement the function `normalize_path(path: str) -> str`. This function should take a file path as input and return its absolute path. Input * `path`: A string representing the file path. It may be relative, include a home directory shortcut (`~`), or reference parent directories (`..`). Output * A string representing the absolute path of the file. Constraints * The input path string will have at most 1024 characters. * The function should be compatible across multiple operating systems (Windows, macOS, Linux). Function Signature ```python def normalize_path(path: str) -> str: ``` Example ```python assert normalize_path(\'~/myfolder/myfile.txt\') == \'/home/user/myfolder/myfile.txt\' # Assuming the user home directory is /home/user assert normalize_path(\'../myfolder/myfile.txt\') == \'/home/user/myfolder/myfile.txt\' # Assuming current working directory is /home/user assert normalize_path(\'/absolute/path/to/file\') == \'/absolute/path/to/file\' assert normalize_path(\'relative/path/to/file\') == \'/home/user/relative/path/to/file\' # Assuming current working directory is /home/user ``` Notes * Use the `os.path` module for manipulating the paths. * Ensure your function handles edge cases, including empty strings and paths already in absolute form.","solution":"import os def normalize_path(path: str) -> str: Normalizes a given file path into its absolute format. :param path: A string representing the file path. :return: A string representing the absolute path of the file. return os.path.abspath(os.path.expanduser(path))"},{"question":"# Question Implement a function that determines the minimum cost to connect all nodes in a weighted, undirected graph represented as an adjacency list using Prim\'s Algorithm. The graph is always connected and has at least one node. Input * `graph`: A dictionary representing the graph where keys are the nodes and values are lists of tuples, each containing: * The weight of the edge as an integer. * The adjacent node as a string or number. Output * An integer representing the total weight of the minimum spanning tree. Constraints * The number of nodes ( V ) is between 1 and 1000. * The number of edges ( E ) is between ( V-1 ) and ( V(V-1)/2 ). * Edge weights are non-negative integers. Example ```python graph = { \'a\': [ (3, \'b\'), (8, \'c\') ], \'b\': [ (3, \'a\'), (5, \'d\') ], \'c\': [ (8, \'a\'), (2, \'d\'), (4, \'e\') ], \'d\': [ (5, \'b\'), (2, \'c\'), (6, \'e\') ], \'e\': [ (4, \'c\'), (6, \'d\') ] } print(prims_minimum_spanning(graph)) ``` Expected Output: ``` 14 ```","solution":"import heapq def prims_minimum_spanning(graph): Returns the minimum cost to connect all nodes in a graph using Prim\'s Algorithm. if not graph: return 0 # Initialize the minimum spanning tree (MST) cost and visited set mst_cost = 0 visited = set() # Start with any node, in this case, the first key in the dictionary start_node = list(graph.keys())[0] min_heap = [(0, start_node)] # (weight, node) while min_heap: weight, node = heapq.heappop(min_heap) if node in visited: continue # Add the node to the visited set and accumulate the cost visited.add(node) mst_cost += weight # Add all edges from the current node to the heap if the adjacent node is not visited for edge_weight, adjacent in graph[node]: if adjacent not in visited: heapq.heappush(min_heap, (edge_weight, adjacent)) return mst_cost"},{"question":"# Problem Description Given a string `s`, write a function `unique_chars` to remove any reoccurring characters and return the new string. The resultant string should only include the first appearance of each character, and maintain the order of their first occurrence. # Input * A single string `s` with length between 0 and 10^6. * The string consists of ASCII characters. # Output * A string with all reoccurring characters removed, preserving the order of first appearance. # Example Example 1 * **Input**: `\\"abacabad\\"` * **Output**: `\\"abcd\\"` Example 2 * **Input**: `\\"banana\\"` * **Output**: `\\"ban\\"` # Constraints * The function should have a time complexity of O(n) and a space complexity of O(n). * Handle edge cases like an empty string or strings with all identical characters. # Scenarios Imagine using this in text analysis to retain only the first occurrence of each character in a stream of text or data cleanup tasks where duplicates need to be removed. # Function Signature ```python def unique_chars(s: str) -> str: pass ``` # Notes * Any appropriate and efficient method to solve this problem is acceptable. * You should not import any libraries; use Python\'s built-in functionality. * Extra points for code readability and proper handling of edge cases.","solution":"def unique_chars(s: str) -> str: Removes reoccurring characters from the string s and returns a string with unique characters while preserving the first occurrence order. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"Given a linked list, write a function that returns the node at the start of the cycle, if there is a cycle present in the list. If there is no cycle, the function should return `None`. # Function Signature ```python class Node: def __init__(self, x): self.val = x self.next = None def find_cycle_start(head: Node) -> Node: pass ``` # Input - A linked list represented by its head node, `head`. # Output - The node at the start of the cycle, if a cycle exists. - `None` if no cycle is present in the linked list. # Constraints - The linked list might contain up to 10^5 nodes. - The values of the nodes are not unique. # Example ```python # Example 1: # Input: head = [3,2,0,-4] (tail connects to node index 1) # Output: Node with value 2 (reference is sufficient) node1 = Node(3) node2 = Node(2) node3 = Node(0) node4 = Node(-4) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node2 # Creates cycle here assert find_cycle_start(node1) == node2 # Example 2: # Input: head = [1,2] (no cycle) # Output: None node1 = Node(1) node2 = Node(2) node1.next = node2 assert find_cycle_start(node1) == None ``` # Notes - You can assume that you don\'t need to check for the initial structure validity (e.g., whether it forms a valid linked list). - Optimal O(n) solution is expected.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def find_cycle_start(head: Node) -> Node: if not head or not head.next: return None slow = fast = head # First, determine if there is a cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected, now find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow return None"},{"question":"# Scenario: A data analyst frequently processes large datasets and often encounters situations where they need to remove duplicate entries. The analyst wants a more efficient solution that maintains the order of first occurrences but handles large arrays quickly. # Problem: Write a function `optimized_remove_duplicates` that removes duplicates from a list efficiently. You should use a data structure that allows for faster duplicate checking to achieve better performance. # Function Signature: ```python def optimized_remove_duplicates(array: list) -> list: pass ``` # Input: - A list `array` containing elements (could be integers, strings, booleans, etc.). # Output: - A list with duplicates removed, preserving the order of first occurrences. # Constraints: - Do not use the original `remove_duplicates` function from the code snippet. - The function should handle large arrays efficiently. # Requirements: - The implementation should have O(n) time complexity. - Do not use additional libraries or packages. # Example: ```python assert optimized_remove_duplicates([1, 1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True]) == [1, 2, 3, 4, \'hey\', \'hello\', True] assert optimized_remove_duplicates([]) == [] assert optimized_remove_duplicates([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] ```","solution":"def optimized_remove_duplicates(array: list) -> list: Removes duplicates from a list while preserving the order of first occurrences. :param array: A list containing elements (could be integers, strings, booleans, etc.) :return: A list with duplicates removed. seen = set() result = [] for item in array: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"Scenario You are implementing an integer permutation algorithm where you need to find the next higher permutation of a given integer. This new permutation must be the closest higher integer formed by rearranging the digits of the original number. Task Write a function `next_bigger(num: int) -> int` that takes an integer and returns the next higher number that can be formed using the same digits. If no such permutation exists, return -1. Implementation Details * **Input**: An integer `num` representing the original number. * **Output**: An integer representing the next higher permutation or -1 if no such permutation exists. * **Constraints**: * 1 ≤ num ≤ 10^9 * The function should execute efficiently. Examples ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(1528452) == 1528524 assert next_bigger(138654) == 143568 assert next_bigger(54321) == -1 assert next_bigger(999) == -1 assert next_bigger(5) == -1 ``` Notes * Consider edge cases where no permutation is possible. * Ensure correct handling of the reversal of the suffix for accuracy in the next permutation generation.","solution":"def next_bigger(num: int) -> int: Returns the next higher number that can be formed using the same digits of the given number num. If no such permutation exists, returns -1. digits = list(str(num)) n = len(digits) # Find the first digit that is smaller than the digit next to it, from the right side i = n - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If no such digit is found, that means the digits are sorted in descending order if i == -1: return -1 # Find the smallest digit on the right side of i which is larger than digits[i] j = n - 1 while digits[j] <= digits[i]: j -= 1 # Swap the above found smallest digit with digits[i] digits[i], digits[j] = digits[j], digits[i] # Reverse the digits after position i digits = digits[:i + 1] + digits[i + 1:][::-1] next_bigger_num = int(\\"\\".join(digits)) return next_bigger_num"},{"question":"# Scenario In this question, you will implement a version of Bogo Sort, notoriously known for its inefficiency. While this algorithm is not suitable for actual sorting tasks, it serves as an excellent exercise to demonstrate understanding of random permutations and algorithm design. # Problem Description Write a function `custom_bogo_sort(arr)` in Python that mutates the list `arr` such that it becomes sorted in ascending order using the Bogo Sort algorithm. The function should not return any values, just sort the array in-place. # Constraints 1. The input array `arr` may contain any integers, including negative values. 2. The length of `arr` (denoted as `n`) is between 0 and 10 (inclusive). 3. The function should handle all cases including: * Empty arrays. * Already sorted arrays. * Arrays containing the same elements. # Performance Requirement Due to the nature of Bogo Sort, there are no performance requirements on time complexity beyond correctness for this task. # Input * A list `arr` of integers with length `n`, where 0 ≤ n ≤ 10. # Output * The function should sort the input list `arr` in-place without returning any output. # Function Signature ```python def custom_bogo_sort(arr: List[int]) -> None: pass ``` # Example ```python # Example 1 arr = [3, 1, 2] custom_bogo_sort(arr) print(arr) # The output could be [1, 2, 3] # Example 2 arr = [5, 4, 3, 2, 1] custom_bogo_sort(arr) print(arr) # The output could be [1, 2, 3, 4, 5] ``` # Notes * Your implementation should consist of a method to check if the array is sorted and repeatedly shuffle the array until it is sorted. * No need to focus on the performance optimization as Bogo Sort inherently will not be performant for any realistic input size.","solution":"import random from typing import List def is_sorted(arr: List[int]) -> bool: Helper function to check if the array is sorted in ascending order. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def custom_bogo_sort(arr: List[int]) -> None: Sorts the array `arr` in-place using the Bogo Sort algorithm. while not is_sorted(arr): random.shuffle(arr)"},{"question":"# Array Range Filtering You are given an array of numerical values. Your task is to implement a function that filters out the numbers outside a specified range. Function Signature `def limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]:` Input and Output Format - **Input**: * `arr` - A list of integers. * `min_lim` - An optional integer representing the minimum limit. If not provided, consider the minimum value in the array as `min_lim`. * `max_lim` - An optional integer representing the maximum limit. If not provided, consider the maximum value in the array as `max_lim`. - **Output**: * Return a list of integers containing only the numbers that are between `min_lim` and `max_lim` (inclusive). Constraints - The array can be empty, in which case the output should also be an empty array. - The elements of the array and the optional limits `min_lim` and `max_lim` will be within the range `-10^6` to `10^6`. Example Input and Output ```python # Example 1: arr = [1, 2, 3, 4, 5] min_lim = None max_lim = 3 # Output: [1, 2, 3] # Example 2: arr = [10, 20, -5, 0, 7, 3] min_lim = -5 max_lim = 10 # Output: [10, -5, 0, 7, 3] # Example 3: arr = [] min_lim = 5 max_lim = 10 # Output: [] # Example 4: arr = [5, 7, 9, 3, 2] min_lim = 6 max_lim = 8 # Output: [7] ``` Notes * Ensure your function handles edge cases gracefully, such as empty arrays and when no elements fall within the specified limits. * Consider the efficiency of your implementation, especially concerning the time complexity.","solution":"from typing import List, Optional def limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [num for num in arr if min_lim <= num <= max_lim]"},{"question":"Scenario You\'re a software engineer working on a text-editor autocomplete feature. Given a dictionary of sorted letters and a user\'s current typed letter, you need to help them by returning the smallest letter in the dictionary that is larger than the typed character. If no such letter exists, the list should wrap around. Task Implement a function `next_greatest_letter` that takes two parameters: - `letters` (a list of sorted lowercase characters). - `target` (a single lowercase character). Your function should return the smallest letter in the list that is greater than the given target letter. If the target is larger than or equal to all characters in the list, it should wrap around and return the first letter of the list. Function Signature ```python def next_greatest_letter(letters: List[str], target: str) -> str: ``` Input - `letters`: A list of lowercase characters sorted in increasing order. - `target`: A single lowercase character. Output - A single lowercase character that is the smallest letter greater than the target. Constraints - All the characters in `letters` are in the range `[\'a\', \'z\']`. - `letters` is a sorted list and contains at least 2 elements. - `target` is a single character. Examples ```python assert next_greatest_letter([\\"c\\", \\"f\\", \\"j\\"], \\"a\\") == \\"c\\" assert next_greatest_letter([\\"c\\", \\"f\\", \\"j\\"], \\"c\\") == \\"f\\" assert next_greatest_letter([\\"c\\", \\"f\\", \\"j\\"], \\"d\\") == \\"f\\" assert next_greatest_letter([\\"c\\", \\"f\\", \\"j\\"], \\"j\\") == \\"c\\" assert next_greatest_letter([\\"a\\"], \\"a\\") == \\"a\\" ``` Consider performance and edge cases while implementing your solution. **Note**: Do not use the `bisect` module for this implementation.","solution":"from typing import List def next_greatest_letter(letters: List[str], target: str) -> str: for letter in letters: if letter > target: return letter return letters[0]"},{"question":"# Connected Components in a Directed Graph Using Kosaraju\'s Algorithm Objective Implement a function to find the number of strongly connected components in a given directed graph using Kosaraju\'s algorithm. The function should demonstrate an understanding of graph traversal, stack operations, and graph transposition. Function Signature ```python def find_strongly_connected_components(V: int, edges: List[Tuple[int, int]]) -> int: pass ``` Input * An integer `V` representing the number of vertices in the graph. * A list of tuples `edges`, where each tuple `(u, v)` represents a directed edge from vertex `u` to vertex `v`. Output * An integer representing the number of strongly connected components in the graph. Constraints * `1 <= V <= 10^5` * `0 <= u, v < V` * Each edge is directional `(u -> v)` Performance Requirements * The solution should be efficient, targeting a time complexity of O(V + E), where E is the number of edges. Example ```python V = 6 edges = [ (0, 2), (1, 0), (2, 3), (3, 1), (3, 4), (4, 5), (5, 4) ] assert find_strongly_connected_components(V, edges) == 2 ``` Additional Notes 1. Ensure your implementation accounts for edge cases like isolated nodes or completely connected components. 2. Utilize data structures that provide efficient push and pop operations for handling the DFS finish times. 3. Remember to transpose the graph by reversing the direction of all edges properly.","solution":"from typing import List, Tuple def find_strongly_connected_components(V: int, edges: List[Tuple[int, int]]) -> int: def dfs(graph, vertex, visited, stack): visited[vertex] = True for neighbor in graph[vertex]: if not visited[neighbor]: dfs(graph, neighbor, visited, stack) stack.append(vertex) def reverse_graph(graph): reversed_graph = [[] for _ in range(V)] for vertex in range(V): for neighbor in graph[vertex]: reversed_graph[neighbor].append(vertex) return reversed_graph def fill_order(graph): visited = [False] * V stack = [] for vertex in range(V): if not visited[vertex]: dfs(graph, vertex, visited, stack) return stack def dfs_util(graph, vertex, visited): visited[vertex] = True for neighbor in graph[vertex]: if not visited[neighbor]: dfs_util(graph, neighbor, visited) # Create the graph graph = [[] for _ in range(V)] for (u, v) in edges: graph[u].append(v) # Step 1: Order vertices by finish time in decreasing order stack = fill_order(graph) # Step 2: Reverse the graph reversed_graph = reverse_graph(graph) # Step 3: Process all vertices in decreasing order of finish time visited = [False] * V strongly_connected_components = 0 while stack: vertex = stack.pop() if not visited[vertex]: dfs_util(reversed_graph, vertex, visited) strongly_connected_components += 1 return strongly_connected_components"},{"question":"# Binary Tree Max Depth Calculation Scenario A forest ranger is analyzing the height of trees in a forest. Each tree can be represented as a binary tree where nodes represent the individual branches. The ranger needs to determine the maximum depth of these trees for a proper assessment of the forest ecosystem. Task Using the given binary tree structure, implement a function to find the maximum depth of a binary tree. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Function Signature ```python def max_depth(root: TreeNode) -> int: Calculates the maximum depth of a binary tree. :param root: TreeNode :return: int ``` Expected Input and Output Formats - **Input**: A binary tree node (root) with integer values. - **Output**: An integer representing the maximum depth of the binary tree. Constraints - The number of nodes in the tree is between 1 and 10,000. - Tree node values are within the range of -1000 to 1000. Example Input: ``` 1 / 2 3 / 4 5 ``` Output: 3 Performance Requirements Your solution should have a time complexity of O(n) where n is the number of nodes in the tree, and a space complexity of O(h) where h is the height of the tree. Note Ensure to cover edge cases like single-node trees and newly planted trees (empty).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root: TreeNode) -> int: if not root: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Isomorphic Strings Given two strings `s` and `t`, write a Python function `is_isomorphic(s, t)` that checks if the two strings are isomorphic. Two strings are considered isomorphic if the characters in `s` can be replaced to get `t` while preserving the order of characters, ensuring that no two characters map to the same character unless they map to themselves. # Function Signature ```python def is_isomorphic(s: str, t: str) -> bool: ``` # Input - `s` (string): A string containing only basic Latin characters (a-z). The length of `s` will be at most 100. - `t` (string): A string containing only basic Latin characters (a-z). The length of `t` will be at most 100. # Output - Returns a boolean value: `True` if the strings are isomorphic, `False` otherwise. # Constraints - The length of `s` and `t` should be the same for them to be considered isomorphic. # Example 1. Input: `s = \\"egg\\"`, `t = \\"add\\"` - Output: `True` 2. Input: `s = \\"foo\\"`, `t = \\"bar\\"` - Output: `False` 3. Input: `s = \\"paper\\"`, `t = \\"title\\"` - Output: `True` # Edge Cases - Strings of different lengths should immediately return `False`. - Strings with no repetitive characters should be handled to ensure correct mapping. Implement the function `is_isomorphic(s, t)` to assess the understanding and proficiency in string processing and mapping concepts.","solution":"def is_isomorphic(s: str, t: str) -> bool: Determines if two strings s and t are isomorphic. if len(s) != len(t): return False mapping_s_to_t = {} mapping_t_to_s = {} for char_s, char_t in zip(s, t): if char_s in mapping_s_to_t: if mapping_s_to_t[char_s] != char_t: return False else: mapping_s_to_t[char_s] = char_t if char_t in mapping_t_to_s: if mapping_t_to_s[char_t] != char_s: return False else: mapping_t_to_s[char_t] = char_s return True"},{"question":"# Question: Pangram Checker Redux Design a function `is_pangram_redux` that determines whether a given string is a pangram or not, but this time optimize for performance and cover edge cases as much as possible. Your function should follow these guidelines: * **Input**: A single string `s` containing lowercase and/or uppercase alphabetic characters, spaces, punctuation, and digits. * **Output**: Return `True` if the string is a pangram, otherwise return `False`. Constraints * Input string will have at most length `10^6`. * Characters apart from alphabetic ones should be ignored. Performance Requirements * Your solution must handle the input size within reasonable time limits, leveraging efficient data structures if necessary. Example: ```python assert is_pangram_redux(\\"The quick brown fox jumps over the lazy dog!\\") == True assert is_pangram_redux(\\"Hello World\\") == False assert is_pangram_redux(\\"\\") == False assert is_pangram_redux(\\"Pack my box with five dozen liquor jugs\\") == True ``` Write the function `is_pangram_redux(s)`:","solution":"def is_pangram_redux(s): Determines if a given string is a pangram which means it contains every letter in the English alphabet at least once ignoring non-alphabetic characters. Parameters: - s (str): Input string containing alphabetic characters, spaces, punctuation, and digits. Returns: - bool: True if the string is a pangram, otherwise False. # Create a set to track the unique alphabetic characters found in string s found_letters = set() # Iterate through the string for char in s.lower(): # Check if the character is an alphabet if \'a\' <= char <= \'z\': found_letters.add(char) # Early exit if all 26 letters are found if len(found_letters) == 26: return True # If the set contains all 26 letters, it\'s a pangram return len(found_letters) == 26"},{"question":"Scenario You are working on a data preprocessing pipeline for a machine learning project. The project requires filtering datasets to remove noise by only keeping values within a certain range. You must write a function that accomplishes this requirement. Task Write a function `filter_values(data, min_val=None, max_val=None)` that takes an array `data` of integers and/or floats and optional parameters `min_val` and `max_val`. This function should return a new array containing only the values within the range `[min_val, max_val]`, inclusive. If `min_val` is `None`, consider it as negative infinity (include all values less than or equal to `max_val`). If `max_val` is `None`, consider it as positive infinity (include all values greater than or equal to `min_val`). If both are `None`, return the original array. Input and Output Specifications * **Input**: * `data`: List of integers and/or floats. * `min_val`: A number or `None`. * `max_val`: A number or `None`. * **Output**: * List of integers and/or floats, filtered as per above specifications. Constraints * If `data` is empty, return an empty list. * Values in `data` can be both positive and negative. * If both `min_val` and `max_val` are `None`, return the original list. * Avoid using built-in functions like `min` or `max` on an empty list. Example 1. `filter_values([1, 2, 3, 4, 5], None, 3)` should return `[1, 2, 3]`. 2. `filter_values([5, 10, 15, 20, 25], 10, 20)` should return `[10, 15, 20]`. 3. `filter_values([1, 2, 3, 4, 5], 3, None)` should return `[3, 4, 5]`. 4. `filter_values([], 0, 10)` should return `[]`. Performance Requirements The function should be efficient with a time complexity of O(n) and space complexity of O(n), where n is the number of elements in the input list `data`.","solution":"def filter_values(data, min_val=None, max_val=None): Filters an array of numbers to keep values within the given range [min_val, max_val]. Parameters: - data: List of integers and/or floats. - min_val: A number or None. If None, consider it as no minimum limit. - max_val: A number or None. If None, consider it as no maximum limit. Returns: - A list containing values within the range [min_val, max_val]. if min_val is None and max_val is None: return data filtered_data = [] for value in data: if (min_val is None or value >= min_val) and (max_val is None or value <= max_val): filtered_data.append(value) return filtered_data"},{"question":"# Next Higher Permutation You are given a number, and your task is to find the next higher number which contains the exact same set of digits as the original number. If no such number exists, return -1. Implement a function that meets the following requirements: **Function Signature:** ```python def next_higher_permutation(num: int) -> int: pass ``` # Input * An integer `num` where `1 <= num <= 10^9` # Output * Return an integer representing the next higher permutation of the digits in `num`. If no such permutation exists, return -1. # Examples ```python print(next_higher_permutation(38276)) # Output: 38627 print(next_higher_permutation(12345)) # Output: 12354 print(next_higher_permutation(54321)) # Output: -1 ``` # Constraints * You cannot use any in-built Python functions for permutations. * You must achieve an efficient solution in linear time complexity O(n), where n is the number of digits in the input number. # Requirements 1. Identify the rightmost pair of consecutive digits where the first is smaller than the second. 2. Swap that digit with the smallest digit to its right which is greater than it. 3. Reverse the sequence to the right of the first digit swapped to get the next smallest lexicographical order. 4. Carefully handle edge cases such as single-digit numbers, numbers where digits are non-increasing, or numbers with all identical digits. # Performance The algorithm must run in linear time, O(n), with space complexity also of O(n), given the constraints. # Write your solution in the function `next_higher_permutation`.","solution":"def next_higher_permutation(num: int) -> int: digits = list(map(int, str(num))) length = len(digits) # Step 1: Find the rightmost pair of consecutive digits a[i] and a[i+1] such that a[i] < a[i+1] i = length - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 if i == -1: # No such pair found, number is in non-increasing order return -1 # Step 2: Find the smallest digit to the right of a[i] that is greater than a[i] j = length - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap a[i] and a[j] digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the part of the array to the right of a[i] digits = digits[:i+1] + digits[i+1:][::-1] # Convert list of digits back to a number next_permutation = int(\'\'.join(map(str, digits))) return next_permutation"},{"question":"# Linear Search with Boundary Conditions **Context:** A company uses a software system to manage inventory. Each inventory item has a unique identifier. However, they noticed some inefficiencies and bugs when searching for items based on these identifiers. Your task is to modify the existing linear search algorithm to handle edge cases more robustly. **Problem Statement:** Write a function `enhanced_linear_search(array, query)` that implements a linear search to find the index of the first occurrence of the query value in an array. However, this version should also handle the following edge cases: 1. The array is empty. 2. The target element does not exist in the array. 3. Multiple occurrences of the target element. 4. The target element is present at the beginning or the end of the array. **Input:** - `array`: List of integers (may be empty). Example: `[10, 3, 7, 10, 23]` - `query`: An integer to search for in the array. Example: `10` **Output:** - Return the index of the first occurrence of `query` in `array`. If the `query` is not found, return `-1`. **Constraints:** - The length of `array` will be in the range [0, 10^6]. - The integer values in `array` and `query` can be any valid integer within the range of a 32-bit signed integer. **Performance Requirements:** - Optimally handle arrays with a size up to 1 million elements. - Be mindful of edge cases, ensuring all are managed correctly. **Function Signature:** ```python def enhanced_linear_search(array, query): Finds the index of the first occurrence of the query in the array. Parameters: array (list of int): The list of integers to search through. query (int): The integer value to search for. Returns: int: The index of the first occurrence of query, or -1 if query is not found. ``` Example Test Cases: 1. `enhanced_linear_search([10, 22, -1, 5], 5)` should return `3`. 2. `enhanced_linear_search([], 5)` should return `-1`. 3. `enhanced_linear_search([10, 10, 10, 10, 10], 10)` should return `0`. 4. `enhanced_linear_search([1, 2, 3, 4, 5], 6)` should return `-1`.","solution":"def enhanced_linear_search(array, query): Finds the index of the first occurrence of the query in the array. Parameters: array (list of int): The list of integers to search through. query (int): The integer value to search for. Returns: int: The index of the first occurrence of query, or -1 if query is not found. for index, value in enumerate(array): if value == query: return index return -1"},{"question":"You are given a function `insert_one_bit(num, bit, i)` that inserts a single bit into a given position of a binary number and a function `insert_mult_bits(num, bits, len, i)` that inserts multiple bits into a given position of a binary number. Task Implement a new function `change_bit(num, bit, pos, length)`, which can: 1. Insert a bit or multiple bits. 2. Toggle the state of bits within the specified range. Your function: - `change_bit(num, bit, pos, length)`: - **Parameters**: - `num` (int): A given number - `bit` (int): The bit or bits to be inserted - `pos` (int): Position where the bits/bit should be modified. - `length` (int): Length of bits to be modified. - If `length` is 1, only one bit is inserted/toggled. - If `length` is greater than 1, the specified bits will be inserted/toggled. - **Expected Output**: - The modified number as an integer. - **Constraints**: - `0 <= num <= 2^31 - 1` - `0 <= pos < 32` - `0 <= length <= 32` - Assume `bit` is already in the correct binary form. Implement the function in Python: ```python def change_bit(num, bit, pos, length): # Your code here return modified_num ``` **Example:** ```python assert change_bit(21, 1, 2, 1) == 45 # Insert single bit assert change_bit(5, 7, 1, 3) == 47 # Insert multiple bits assert change_bit(5, 1, 2, 0) == 1 # Toggle bits (assuming toggle case) ``` **Special Notes**: - You must handle edge cases like inserting at the beginning or end of the number. - Ensure that the operation is efficient and does not use excessive space.","solution":"def change_bit(num, bit, pos, length): Modifies the bits of a number by either inserting or toggling. Parameters: - num (int): A given number - bit (int): The bit or bits to be inserted - pos (int): Position where the bits/bit should be modified. - length (int): Length of bits to be modified. Returns: - int: The modified number if length == 1: # Insert a single bit if bit == 1: # Set the bit at position pos return num | (1 << pos) else: # Clear the bit at position pos return num & ~(1 << pos) elif length > 1: # Insert multiple bits # Clear the positions before setting them mask = ((1 << length) - 1) << pos num = num & ~mask num = num | (bit << pos) return num else: # Assuming length of 0 means toggle bits return num ^ (1 << pos) return num"},{"question":"# Coding Challenge: Enhanced GCD and LCM with Edge Case Handling Objective Write a Python function to calculate both the GCD and the LCM of two non-negative integers with enhanced edge case handling and optimized performance. Problem Statement Given two non-negative integers `a` and `b`, implement two functions: 1. `enhanced_gcd(a, b)`: Calculate the greatest common divisor (GCD) using an optimized method that minimizes error handling and accounts for edge cases effectively. 2. `enhanced_lcm(a, b)`: Calculate the least common multiple (LCM) using the GCD function above while considering all edge cases. Function Signatures ```python def enhanced_gcd(a: int, b: int) -> int: # Your implementation goes here pass def enhanced_lcm(a: int, b: int) -> int: # Your implementation goes here pass ``` Input & Output Formats * **Input**: Two non-negative integers `a` and `b`. * **Output**: * `enhanced_gcd(a, b)` returns the GCD of `a` and `b`. * `enhanced_lcm(a, b)` returns the LCM of `a` and `b`. Constraints * `0 <= a, b <= 10^9` Performance Requirements * Ensure the time complexity is efficient enough to handle large inputs effectively. * Ensure both functions handle edge cases such as zero inputs and large integers. Example ```python assert enhanced_gcd(0, 0) == 0 assert enhanced_gcd(10, 0) == 10 assert enhanced_lcm(0, 0) == 0 assert enhanced_lcm(10, 0) == 0 assert enhanced_gcd(54, 24) == 6 assert enhanced_lcm(54, 24) == 216 ``` # Additional Guideline: Your solution should minimize use of exception-based control flow and prefer logical checks, where applicable. Strive for both readability and efficiency in your implementation.","solution":"import math def enhanced_gcd(a: int, b: int) -> int: Calculate the greatest common divisor (GCD) of two non-negative integers a and b. if a == 0: return b if b == 0: return a return math.gcd(a, b) def enhanced_lcm(a: int, b: int) -> int: Calculate the least common multiple (LCM) of two non-negative integers a and b. Using the property LCM(a, b) * GCD(a, b) = a * b if a == 0 or b == 0: return 0 gcd = enhanced_gcd(a, b) return abs(a * b) // gcd"},{"question":"**Question: Implement a function to determine the number of digits in an integer according to a customizable base** You are given a function `num_digits(n)` that calculates the number of digits in a number `n` in constant time (O(1)). Your task is to extend this functionality by implementing a function `num_digits_base(n, base)` that determines the number of digits of a number `n` in any given base. # Function Signature ```python def num_digits_base(n: int, base: int) -> int: pass ``` # Input - `n` (int): An integer, which can be positive, zero, or negative. - `base` (int): The base for numerical representation, which is an integer greater than 1. # Output - Return an integer representing the number of digits in the base representation of `n`. # Constraints - The base must be greater than 1. - The input number `n` can be any integer (from negative infinity to positive infinity). - Do not use any functionality that directly computes the number of digits in any base other than base 10. # Examples ```python print(num_digits_base(100, 10)) # Output: 3 print(num_digits_base(255, 16)) # Output: 2 print(num_digits_base(-255, 16)) # Output: 2 print(num_digits_base(0, 2)) # Output: 1 print(num_digits_base(1024, 2)) # Output: 11 ``` # Additional Notes - Consider edge cases such as zero or negative numbers. - Make sure your implementation handles very large or very small values of `n` efficiently. # Performance Requirements - Your solution should run in constant time (O(1)) for the provided input sizes.","solution":"import math def num_digits_base(n: int, base: int) -> int: Returns the number of digits in the base representation of the integer n. if base <= 1: raise ValueError(\\"Base must be greater than 1.\\") if n == 0: return 1 n = abs(n) return math.floor(math.log(n, base)) + 1"},{"question":"# Priority Task Management System You are tasked with implementing a priority task management system. This system should allow tasks to be added with a specific priority and enable quick retrieval of the task with the lowest priority. You will utilize a linear array-based priority queue for this task. Function Descriptions 1. **`class PriorityQueueNode`**: - **`__init__(self, data, priority)`**: Initializes a node with the given data and priority. - **`__repr__(self)`**: Returns a string representation of the node. 2. **`class PriorityQueue`**: - **`__init__(self, items=None, priorities=None)`**: Initializes a priority queue. - **`__repr__(self)`**: Returns a string representation of the priority queue. - **`size(self)`**: Returns the current size of the priority queue. - **`push(self, item, priority=None)`**: Adds an item to the priority queue. If priority is not provided, it is set to the value of the item. - **`pop(self)`**: Removes and returns the item with the lowest priority from the priority queue. Task Implement the following class methods for the `PriorityQueue`: 1. **`push`**: This method should insert a new task into the priority queue based on its priority. 2. **`pop`**: This method should remove and return the task with the lowest priority. Input & Output Format - **`push(item, priority=None)`**: - **Input**: - item: An integer representing the task. - priority: An integer representing the task\'s priority (default is the item\'s value). - **Output**: Nothing. - **`pop()`**: - **Input**: None. - **Output**: Return the task with the lowest priority. Constraints - Priority will be a non-negative integer. - The method `pop` will only be called when there are elements in the queue. Example ```python pq = PriorityQueue() pq.push(10, 2) pq.push(5, 1) pq.push(7) print(pq.size()) # Output: 3 print(pq.pop()) # Output: 5 print(pq.pop()) # Output: 10 print(pq.pop()) # Output: 7 ``` In the example, tasks are added to the priority queue with their respective priorities. The `pop` method retrieves and removes tasks based on the priority order, starting from the lowest priority. # Note Students should handle the edge cases such as adding elements when the priority queue is empty and managing elements with the same priority efficiently.","solution":"class PriorityQueueNode: def __init__(self, data, priority): self.data = data self.priority = priority def __repr__(self): return f\\"({self.data}, {self.priority})\\" class PriorityQueue: def __init__(self): self.queue = [] def __repr__(self): return \\" \\".join([str(node) for node in self.queue]) def size(self): return len(self.queue) def push(self, item, priority=None): if priority is None: priority = item node = PriorityQueueNode(item, priority) self.queue.append(node) # Sort to keep the lowest priority at the beginning self.queue.sort(key=lambda x: x.priority) def pop(self): if self.size() == 0: return None return self.queue.pop(0).data"},{"question":"# Bubble Sort Algorithm Enhancement You are a software engineer working on optimizing sorting algorithms for educational purposes. Your task is to enhance a given Bubble Sort algorithm by implementing a reversed version that sorts the array in descending order. **Requirements:** 1. Implement a function `reverse_bubble_sort(arr: list, simulation: bool = False) -> list` that sorts the input list `arr` in descending order using the Bubble Sort technique. 2. Provide an optional `simulation` parameter. If set to `True`, your function should print detailed steps of each iteration, showing the state of the list after each swap operation. 3. Ensure the function adheres to the best practices of Bubble Sort, including an early exit mechanism if no swaps were made in a full pass. 4. Consider edge cases such as: - Empty list - List with one element - List with all identical elements **Function Signature:** ```python def reverse_bubble_sort(arr: list, simulation: bool = False) -> list: ``` # Example **Input:** ```python reverse_bubble_sort([64, 34, 25, 12, 22, 11, 90]) ``` **Output:** ```python [90, 64, 34, 25, 22, 12, 11] ``` **Input with Simulation:** ```python reverse_bubble_sort([5, 3, 8, 6, 2], True) ``` **Output:** ``` iteration 0 : 5 3 8 6 2 iteration 1 : 5 8 3 6 2 iteration 2 : 5 8 6 3 2 iteration 3 : 8 5 6 3 2 iteration 4 : 8 6 5 3 2 iteration 5 : 8 6 5 3 2 [8, 6, 5, 3, 2] ``` **Input (Edge Cases):** ```python reverse_bubble_sort([]) reverse_bubble_sort([1]) reverse_bubble_sort([42, 42, 42, 42]) ``` **Output:** ```python [] [1] [42, 42, 42, 42] ``` **Constraints:** - The input list may contain integers only. - The function should run efficiently for lists of reasonable length (up to 10^3 elements).","solution":"def reverse_bubble_sort(arr: list, simulation: bool = False) -> list: Sorts the input list `arr` in descending order using the Bubble Sort technique. Parameters: arr (list): The list to be sorted. simulation (bool): If True, prints detailed steps of each iteration. Returns: list: The sorted list in descending order. n = len(arr) for i in range(n): # Track if any swap happened swapped = False for j in range(0, n - i - 1): if arr[j] < arr[j + 1]: # Swap the elements arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if simulation: # Print each swap operation if simulation is True print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") if not swapped: # No swaps done, array is sorted break return arr"},{"question":"# Linked List Cycle Detection and Retrieval You are given a linked list where each node contains an integer value. You are to implement a function to detect if there is a cycle in the linked list. If a cycle exists, return the value of the first node of the cycle; otherwise, return None. # Specifications Implement the function `find_cycle_start(head)`: ```python class Node: def __init__(self, x): self.val = x self.next = None def find_cycle_start(head: Node) -> Optional[int]: # Your code goes here ``` # Input * `head` - The head node of the linked list (type: `Node`) # Output * An integer representing the value of the first node of the cycle, or `None` if no cycle exists. # Constraints * The linked list can have a mixture of unique and duplicate values. * The number of nodes in the linked list is at most 10^4. * Node values are within the range [-10^6, 10^6]. # Example ```python # Example 1: # Given linked list: 3 -> 2 -> 0 -> -4 -> 2 (Cycle starts at node with value 2) head = Node(3) second = Node(2) third = Node(0) fourth = Node(-4) head.next = second second.next = third third.next = fourth fourth.next = second result = find_cycle_start(head) # Expected output: 2 # Example 2: # Given linked list: 1 -> 2 -> 1 (Cycle starts at node with value 1) head = Node(1) second = Node(2) head.next = second second.next = head result = find_cycle_start(head) # Expected output: 1 # Example 3: # Given linked list: 1 -> 2 -> NULL (No cycle) head = Node(1) second = Node(2) head.next = second result = find_cycle_start(head) # Expected output: None ``` # Note You can assume the lists provided are valid and correctly constructed without circular references other than actual cycles.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def find_cycle_start(head: Node) -> int: Detect if a cycle exists in the linked list and return the value of the first node of the cycle; otherwise, return None. if not head: return None slow = fast = head # Detect cycle using Floyd’s Cycle-Finding Algorithm (Tortoise and Hare) while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: return None # No cycle found # Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow.val"},{"question":"# Permutation Challenge with Duplicates You are tasked with implementing a function that generates all possible unique permutations of a given list of numbers, which may contain duplicates. The goal is to produce each unique permutation exactly once. Input: - A list of integers, `nums`, where 0 <= len(nums) <= 9, and elements can have any integer value (potentially with duplicates). Output: - A list of lists, where each inner list is a unique permutation of the input list. # Function Signature ```python def permute_unique(nums: List[int]) -> List[List[int]]: pass ``` # Constraints: - The input list can have up to 9 elements, which should consider factorial time complexity. - Output permutations should be unique and include all possible distinct rearrangements of the input list. # Examples: 1. For nums = [1,1,2], your function should return: ```python [ [1, 1, 2], [1, 2, 1], [2, 1, 1] ] ``` 2. For nums = [1,2,3], your function should return: ```python [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] ``` # Instructions 1. Implement the function `permute_unique`. 2. Do not use any built-in library/functions that directly solve permutations. 3. Make sure to handle edge cases such as an empty input list or a list with all identical elements efficiently. 4. Ensure your function runs within the constraints and performs deduplication correctly to avoid redundant permutations.","solution":"from typing import List def permute_unique(nums: List[int]) -> List[List[int]]: def backtrack(path, remaining): if not remaining: result.add(tuple(path)) return for i in range(len(remaining)): if i > 0 and remaining[i] == remaining[i - 1]: continue backtrack(path + [remaining[i]], remaining[:i] + remaining[i+1:]) result = set() nums.sort() # Ensure that we can skip duplicates backtrack([], nums) return [list(permutation) for permutation in result]"},{"question":"# Sum of All Submatrices in a 2D Matrix You are given a 2D matrix of integers of size n x n and a positive integer k. Your task is to write a function that calculates the sum of all possible k x k submatrices in this n x n matrix. The function should return a 2D list of integers where each element represents the sum of a k x k submatrix in the n x n matrix starting from the respective (i, j) position. # Function Signature ```python def sum_sub_squares(matrix: List[List[int]], k: int) -> List[List[int]]: pass ``` # Input * `matrix` - a list of lists of integers representing an n x n matrix (1 <= n <= 1000). * `k` - a positive integer (1 <= k <= n). # Output * A list of lists of integers where each entry represents the sum of the k x k submatrix starting at that position. # Constraints * The value of `k` will never be greater than `n`. * Each submatrix should be considered independently. # Example Example 1 Input: ```python matrix = [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] k = 2 ``` Output: ```python [ [4, 4, 4], [4, 4, 4], [4, 4, 4] ] ``` Explanation: Each 2x2 submatrix consists of all 1\'s, so the sum for each submatrix is 4. Example 2 Input: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] k = 2 ``` Output: ```python [ [12, 16], [24, 28] ] ``` Explanation: - The top-left 2x2 submatrix sum is 1+2+4+5 = 12. - The submatrix starting at (0,1) is 2+3+5+6 = 16. - The submatrix starting at (1,0) is 4+5+7+8 = 24. - The submatrix starting at (1,1) is 5+6+8+9 = 28. # Notes 1. Ensure that you handle edge cases appropriately. 2. Think about possible optimizations to reduce redundant computations.","solution":"from typing import List def sum_sub_squares(matrix: List[List[int]], k: int) -> List[List[int]]: n = len(matrix) result = [[0] * (n - k + 1) for _ in range(n - k + 1)] # Calculate prefix sums for the matrix prefix_sum = [[0] * (n + 1) for _ in range(n + 1)] for i in range(n): for j in range(n): prefix_sum[i + 1][j + 1] = matrix[i][j] + prefix_sum[i][j + 1] + prefix_sum[i + 1][j] - prefix_sum[i][j] # Calculate the sum of each k x k submatrix using the prefix sums for i in range(n - k + 1): for j in range(n - k + 1): result[i][j] = (prefix_sum[i + k][j + k] - prefix_sum[i][j + k] - prefix_sum[i + k][j] + prefix_sum[i][j]) return result"},{"question":"Context RSA encryption is widely used for securing sensitive data by encrypting it with a public key and decrypting it with a private key. The security relies on the computational difficulty of factoring large numbers that are products of two primes. To ensure a good understanding of RSA, you will implement the key generation, encryption, and decryption parts of the RSA algorithm. Problem Statement You are required to implement RSA key generation, encryption, and decryption functions. The core functionality should revolve around creating a secure and efficient key generation and encryption/decryption mechanism using modular arithmetic. Function Signature ```python def generate_key(k: int, seed: Optional[int] = None) -> Tuple[int, int, int]: pass def encrypt(data: int, e: int, n: int) -> int: pass def decrypt(data: int, d: int, n: int) -> int: pass ``` Input and Output Formats 1. **generate_key(k: int, seed: Optional[int] = None) -> Tuple[int, int, int]** - Input: - `k` (int): Number of bits in `n`. - `seed` (int, optional): Seed for random number generation (default is None). - Output: - Tuple of three integers `(n, e, d)`, where `n` is the modulus, `e` is the encryption exponent, and `d` is the decryption exponent. 2. **encrypt(data: int, e: int, n: int) -> int** - Input: - `data` (int): The number to be encrypted. - `e` (int): The encryption exponent. - `n` (int): The modulus. - Output: - Encrypted integer data. 3. **decrypt(data: int, d: int, n: int) -> int** - Input: - `data` (int): The encrypted number. - `d` (int): The decryption exponent. - `n` (int): The modulus. - Output: - The original integer data before encryption. Constraints - You can assume `k` is always large enough to find suitable `p` and `q` primes. - You should use efficient algorithms for prime generation and modular arithmetic to avoid performance bottlenecks. - Ensure that encryption and decryption operations are correctly reciprocal. Requirements 1. Ensure the correctness of modular inverse computation. 2. Optimize the prime generation process. 3. Handle potential edge cases where prime generation or modular arithmetic might fail. Example ```python n, e, d = generate_key(16, seed=123) data = 42 encrypted_data = encrypt(data, e, n) decrypted_data = decrypt(encrypted_data, d, n) assert decrypted_data == data # True ``` **Note**: Testing should include various bit sizes and seed values to verify the robustness of the algorithm.","solution":"import random from typing import Tuple, Optional from sympy import isprime, mod_inverse def generate_key(k: int, seed: Optional[int] = None) -> Tuple[int, int, int]: if seed is not None: random.seed(seed) def generate_prime(bits): while True: num = random.getrandbits(bits) if isprime(num): return num e = 65537 # Commonly used prime exponent in RSA # Generate two distinct primes p and q each of approximately k/2 bits p = generate_prime(k // 2) q = generate_prime(k // 2) while q == p: q = generate_prime(k // 2) n = p * q phi_n = (p - 1) * (q - 1) d = mod_inverse(e, phi_n) return n, e, d def encrypt(data: int, e: int, n: int) -> int: return pow(data, e, n) def decrypt(data: int, d: int, n: int) -> int: return pow(data, d, n)"},{"question":"Design and implement the function `level_order_traversal(root)` that performs a level order traversal on a given binary tree and returns the nodes\' values level by level from left to right. This exercise tests your understanding of tree traversal algorithms and queue-based data processing. # Input - The root of a binary tree, where each node has the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output - A list of lists, where each inner list contains the values of the nodes at that level in the order they appear from left to right. # Constraints - The number of nodes in the tree will be in the range [0, 2000]. - Node values should be in the range [-1000, 1000]. # Example **Input**: ```python 3 / 9 20 / 15 7 ``` **Output**: ```python [ [3], [9,20], [15,7] ] ``` # Instructions 1. Define the function `level_order_traversal(root)` which takes a `TreeNode` as an input. 2. Implement the level order traversal algorithm described. 3. The method should handle all edge cases such as empty trees and unbalanced trees appropriately. # Notes - You may define additional helper functions if necessary. - Use a queue to help manage the traversal process as you proceed through each level.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): if not root: return [] result = [] queue = deque([root]) while queue: level = [] level_length = len(queue) for i in range(level_length): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"# Question **Bitwise Reversal of Arbitrary-Length Unsigned Integer** You are provided with a function to reverse the bits of a 32-bit unsigned integer. Now, extend this functionality to work for any arbitrary-length unsigned integer represented as a string of binary digits. # Instructions 1. Create a function `reverse_bits_arbitrary_length(binary_string: str) -> str` that takes a string representing an unsigned integer in binary format and returns the binary string with its bits reversed. 2. The input string `binary_string` can have arbitrary lengths, ranging from a single bit to millions of bits. # Input - `binary_string` (str): A string consisting solely of \'0\'s and \'1\'s which represents an unsigned integer in binary format. # Output - Returns `str`: The input `binary_string` with its bits reversed. # Constraints - The input string will contain only \'0\'s and \'1\'s. - Length of the input string `len(binary_string)` can range from 1 to (10^7). # Example ```python assert reverse_bits_arbitrary_length(\\"00000010100101000001111010011100\\") == \\"00111001011110000010100101000000\\" assert reverse_bits_arbitrary_length(\\"1\\") == \\"1\\" assert reverse_bits_arbitrary_length(\\"1111100000\\") == \\"0000011111\\" ``` Optimize your solution considering the edge cases and performance bottlenecks mentioned in the analysis.","solution":"def reverse_bits_arbitrary_length(binary_string: str) -> str: Takes a binary string and returns the string with its bits reversed. return binary_string[::-1]"},{"question":"Context You are tasked to find the position of a specific value in a sorted array of integers. For this purpose, you will implement the Interpolation Search Algorithm, which is particularly efficient when the array contains uniformly distributed values. Task Implement a function `interpolation_search` that takes a sorted list of integers and an integer `search_key`, and returns the index of `search_key` in the list if found, otherwise returns -1. Function Signature ```python def interpolation_search(array: List[int], search_key: int) -> int: pass ``` # Requirements * **Input**: - `array`: A list of sorted integers `array` (0 ≤ len(array) ≤ 10^6). - `search_key`: An integer value to search within the list. * **Output**: - An integer representing the index of `search_key` within the array, or -1 if `search_key` is not present. * **Constraints**: - The list may be empty or contain up to 1,000,000 integers. - Each integer in the list and `search_key` are within the range of -10^9 to 10^9. * **Performance**: - Your solution should aim to be efficient and work within a reasonable time for large inputs. # Example ```python >>> interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) 2 >>> interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) -1 >>> interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) -1 >>> interpolation_search([], 1) -1 ``` # Notes - Make sure to handle edge cases such as an empty array or the search key being out of the array\'s range. - Test your implementation thoroughly to ensure correctness and efficiency.","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: low, high = 0, len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 pos = low + ((high - low) // (array[high] - array[low])) * (search_key - array[low]) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"You are given an array of distinct integers, and you need to implement a function to sort this array using the Cycle Sort algorithm. The method should sort the array in place and return it. Due to Cycle Sort\'s nature of minimizing the number of writes, it should be particularly useful for scenarios involving memory types with limited write cycles (like flash memory). # Function Signature ```python def cycle_sort(arr): Sorts the array using Cycle Sort algorithm. Parameters: arr (List[int]): A list of distinct integers to sort. Returns: List[int]: The sorted array. ``` # Example ```python >>> cycle_sort([1, 8, 3, 9, 10, 10, 2, 4]) # Example with duplicate elements [1, 2, 3, 4, 8, 9, 10, 10] >>> cycle_sort([10, 7, 4, 3, 1]) [1, 3, 4, 7, 10] >>> cycle_sort([1]) [1] >>> cycle_sort([]) [] ``` # Constraints * The input array length `n` is such that (1 leq n leq 10^6). * The elements of the array are distinct integers, each in the range ([-10^6, 10^6]). # Performance Requirements * The solution is expected to have O(n²) time complexity in worst case. * Given the large constraints, ensure space complexity is strictly O(1). # Hints * Ensure you handle edge cases like empty array and single-element array. * Focus on understanding the mechanism of detecting and moving cycles to minimize writes.","solution":"def cycle_sort(arr): Sorts the array using Cycle Sort algorithm. Parameters: arr (List[int]): A list of distinct integers to sort. Returns: List[int]: The sorted array. n = len(arr) for cycle_start in range(0, n - 1): item = arr[cycle_start] # Find where to put the item pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Skip duplicate item while item == arr[pos]: pos += 1 # Swap item to the correct position arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"# Array Value Filtering Algorithm You are given an array of numeric values and you need to implement a function to filter this array based on given minimum and maximum limits. Write a function `value_filtering(arr, min_lim=None, max_lim=None)` that accepts an array of numbers `arr`, an optional minimum limit `min_lim`, and an optional maximum limit `max_lim`. The function should return a new array containing only those elements of `arr` which are greater than or equal to `min_lim` and less than or equal to `max_lim`. Input - **arr**: A list of numeric values. Example: `[1, 2, 3, 4, 5]`. - **min_lim** (Optional): A numeric value representing the minimum limit. If not provided, use the smallest value in `arr`. Example: `2`. - **max_lim** (Optional): A numeric value representing the maximum limit. If not provided, use the largest value in `arr`. Example: `4`. Output - A list of numeric values filtered from `arr` based on the given `min_lim` and `max_lim`. Constraints - The array `arr` will have at most (10^5) elements. - If `min_lim` or `max_lim` is not provided, consider the minimum or maximum of the array, respectively, to be the effective limits. Example Usage ```python # Example 1 arr = [1, 2, 3, 4, 5] min_lim = 2 max_lim = 4 assert(value_filtering(arr, min_lim, max_lim) == [2, 3, 4]) # Example 2 arr = [1, 2, 3, 4, 5] min_lim = None max_lim = 3 assert(value_filtering(arr, min_lim, max_lim) == [1, 2, 3]) # Example 3 arr = [1, 2, 3, 4, 5] min_lim = 3 max_lim = None assert(value_filtering(arr, min_lim, max_lim) == [3, 4, 5]) # Example 4 arr = [1, 2, 3, 4, 5] min_lim = None max_lim = None assert(value_filtering(arr, min_lim, max_lim) == [1, 2, 3, 4, 5]) ``` Notes - Ensure the function handles edge cases like empty arrays, and arrays with elements out of range properly. - Consider usability and clarity for non-provided limits. - Your implementation should run efficiently for large arrays up to (10^5) elements.","solution":"def value_filtering(arr, min_lim=None, max_lim=None): Filters the array `arr` and returns a new list with elements that are within the `min_lim` and `max_lim` boundaries (inclusive). If `min_lim` is not specified, it is set to the minimum value present in `arr`. If `max_lim` is not specified, it is set to the maximum value present in `arr`. if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"**Problem Statement:** You are given an array of integers where every element appears exactly three times except for one, which appears exactly once. Your task is to write a function `single_number` that finds and returns the element that appears only once. The solution must have a linear runtime complexity and use constant extra space. **Function Signature:** ```python def single_number(nums: List[int]) -> int: pass ``` **Input:** * `nums` (List[int]): A non-empty list of integers. **Output:** * Returns the single integer that does not appear three times. **Constraints:** * The input list satisfies the condition that all elements appear exactly three times except for one. * The size of the list is in the range `[4, 3 * 10^4]`. **Examples:** ```python assert single_number([2, 2, 3, 2]) == 3 assert single_number([0, 1, 0, 1, 0, 1, 99]) == 99 ``` **Explanation:** 1. In the first example, `2` appears three times and `3` appears once, so the result is `3`. 2. In the second example, `0` and `1` each appear three times, and `99` appears once, so the result is `99`. **Notes:** * Aim for a solution that leverages bitwise operations as outlined in the analysis. This will ensure both efficiency and adherence to space constraints. * Carefully consider edge cases such as arrays where the unique element is at different positions - beginning, middle, or end.","solution":"from typing import List def single_number(nums: List[int]) -> int: Function to find the element that appears only once in an array where all other elements appear exactly three times. ones, twos = 0, 0 for num in nums: # Add `num` to `twos` if it is already in `ones` twos |= ones & num # XOR `num` with `ones` ones ^= num # Clear `num` from `ones` and `twos` if it is present in both common_bit_mask = ~(ones & twos) ones &= common_bit_mask twos &= common_bit_mask return ones"},{"question":"You are participating in an advanced robotics competition where you\'ve been tasked to calibrate the drop test for fragile internal components. Each component can break when dropped from a certain height. The task is to minimize the number of drops required to determine this critical height with the following constraints: 1. You have `K` identical components (eggs). 2. You have a building with `N` floors. 3. The components break if dropped from a floor above a critical floor `F` (0 <= F <= N). 4. A broken component cannot be dropped again. Given these constraints, write a function `min_egg_drops(K, N)` that returns the minimum number of egg drops required to determine the critical floor `F` in the worst case. # Constraints - `1 <= K <= 50` - `1 <= N <= 10^3` Input - `K`: An integer representing the number of identical components (eggs). - `N`: An integer representing the number of floors in the building. Output - An integer representing the minimum number of drops required in the worst-case scenario to find the critical floor `F`. # Examples Example 1: Input: ``` K = 1 N = 2 ``` Output: ``` 2 ``` Example 2: Input: ``` K = 2 N = 6 ``` Output: ``` 3 ``` Example 3: Input: ``` K = 3 N = 14 ``` Output: ``` 4 ``` # Function Signature ```python def min_egg_drops(K: int, N: int) -> int: # Your code here ``` # Note 1. Your function should efficiently handle the constraints specified. 2. Ensure to consider edge cases and validate your solution with multiple test cases. 3. Optimize your solution to handle large inputs within reasonable runtime limits.","solution":"def min_egg_drops(K: int, N: int) -> int: # dp[i][j] will represent the minimum number of trials needed for i eggs and j floors. dp = [[0] * (N + 1) for _ in range(K + 1)] # With 1 egg, we need j trials for j floors. for j in range(1, N + 1): dp[1][j] = j # Process all floors from 2 to N and for all eggs from 2 to K. for i in range(2, K + 1): x = 1 # Initialize the position from where we started for j in range(1, N + 1): # Binary search to find the critical floor or the exact while x < j and dp[i][j-x] > dp[i-1][x-1]: x += 1 dp[i][j] = 1 + dp[i-1][x-1] return dp[K][N]"},{"question":"# Exchange Sort - Advanced Version Context: You are working on improving a basic sorting algorithm for a small embedded system with very limited resources. You have identified that the Exchange Sort algorithm is simple enough to implement within the constraints. Nevertheless, you know that for performance reasons, you will need to apply optimizations and consider edge cases effectively. Task: Write an optimized version of the Exchange Sort function that can handle various edge cases efficiently while still keeping within the constraints of a small memory footprint. Requirements: 1. Implement the function `optimized_exchange_sort(arr: List[int]) -> List[int]` which sorts a list of integers using the Exchange Sort approach. 2. Handle the following edge cases properly: - Empty list. - List with one element. - List with all elements the same. - List with negative and positive integers. 3. Provide a clear explanation of any additional checks or improvements you made over the basic Exchange Sort. 4. Your final implementation should still be an in-place sort. Input: - A list `arr` of integers, where `0 <= len(arr) <= 1000`. Output: - A sorted list of integers. Constraints: - Try to minimize the number of swaps made during the sorting. - Ensure your implementation is robust enough to handle edge cases described. Example: ```python assert optimized_exchange_sort([4, 2, 7, 1, -3, 2]) == [-3, 1, 2, 2, 4, 7] assert optimized_exchange_sort([]) == [] assert optimized_exchange_sort([1]) == [1] assert optimized_exchange_sort([2, 2, 2]) == [2, 2, 2] assert optimized_exchange_sort([-1, -4, 0, 5, -3]) == [-4, -3, -1, 0, 5] ``` Note: - Explain any improvements made in comments within your code.","solution":"def optimized_exchange_sort(arr): Sorts a list of integers using an optimized version of the Exchange Sort. This function handles various edge cases efficiently and reduces unnecessary swaps. n = len(arr) if n <= 1: # No need to sort if list is empty or has one element. return arr for i in range(n-1): swapped = False for j in range(i+1, n): if arr[i] > arr[j]: # Swap the elements if they are in the wrong order arr[i], arr[j] = arr[j], arr[i] swapped = True if not swapped: # If no swaps occurred in the inner loop, array is sorted break return arr"},{"question":"# Markov Chain Text Generation You are tasked with creating a character-level text generator using Markov Chains. The generator should read an input string and build a Markov Chain based on character transitions. Given an initial character, the generator should produce a sequence of characters of a given length. Function Signature ```python def build_chain(text: str) -> dict: pass def generate_text(chain: dict, initial_char: str, length: int) -> str: pass ``` Input * `text`: A string that the Markov Chain is built from. * `chain`: A dictionary representing the Markov Chain. * `initial_char`: The initial character to start the text generation. * `length`: The desired length of the generated text. Output * Generated text sequence of `length` characters starting from `initial_char`. Constraints * Assume the input text is non-empty and contains only printable ASCII characters. * The length of generated text will not be more than 1000 characters. * The initial character should be present in the chain. Example Input: ```python input_text = \\"hello world\\" initial_char = \'h\' length = 10 ``` Output: ```python \\"hello world...\\" ``` (Note: The output might vary based on random choices in the Markov Chain.) # Steps 1. **Build Chain**: Implement `build_chain` function which constructs a Markov Chain from the input text (characters as states). 2. **Generate Text**: Implement `generate_text` function which uses the Markov Chain to generate text starting from `initial_char`. 3. Ensure to handle edge cases and validate that transition probabilities in each state sum to 1. # Additional Notes 1. For the `build_chain` function, each state should keep a dictionary of next possible characters and their frequencies. 2. Normalize frequencies to probabilities for ruling out the next state.","solution":"import random from collections import defaultdict def build_chain(text: str) -> dict: Build a Markov chain from the input text. Parameters: text (str): The input text to build the Markov chain from. Returns: dict: The Markov chain represented as a dictionary. chain = defaultdict(lambda: defaultdict(int)) for i in range(len(text) - 1): current_char = text[i] next_char = text[i + 1] chain[current_char][next_char] += 1 # Convert frequencies to probabilities for current_char, transitions in chain.items(): total = sum(transitions.values()) for next_char in transitions: transitions[next_char] /= total return chain def generate_text(chain: dict, initial_char: str, length: int) -> str: Generate text using the Markov chain. Parameters: chain (dict): The Markov chain. initial_char (str): The initial character to start the text generation. length (int): The desired length of the generated text. Returns: str: The generated text. current_char = initial_char generated = [current_char] for _ in range(length - 1): if current_char in chain: next_char = random.choices( list(chain[current_char].keys()), list(chain[current_char].values()) )[0] generated.append(next_char) current_char = next_char else: break return \'\'.join(generated)"},{"question":"You are given a flow network represented by a capacity matrix, a source vertex, and a sink vertex. Your task is to implement a function to compute the maximum flow from the source to the sink using the **Edmonds-Karp** algorithm, which is an implementation of the Ford-Fulkerson method using BFS. # Function Signature ```python def maximum_flow(capacity: List[List[int]], source: int, sink: int) -> int: pass ``` # Input * `capacity`: A 2D list representing the capacity matrix of the graph, where `capacity[i][j]` is the capacity of the edge from vertex `i` to vertex `j`. If there is no edge, `capacity[i][j]` is `0`. * `source`: An integer representing the starting vertex (source). * `sink`: An integer representing the ending vertex (sink). # Output * An integer representing the maximum flow from the source to the sink. # Constraints * The number of vertices `V` is between 1 and 1000. * The values in the capacity matrix are between 0 and 10^6. * The source and sink vertices are valid vertices of the graph. # Context The function should use the BFS method to find the shortest augmenting paths from the source to the sink and incrementally build up the flow until no more augmenting paths can be found from the source to the sink. # Example ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 print(maximum_flow(capacity, source, sink)) # Output: 23 ``` # Requirements * Implement the function to accurately calculate the maximum flow. * Ensure the solution handles edge cases such as no path from source to sink and large capacity values. * Optimize for performance within the given constraints. Good luck, and demonstrate your grasp of graph algorithms thoroughly!","solution":"from collections import deque from typing import List def bfs(capacity: List[List[int]], source: int, sink: int, parent: List[int]) -> bool: visited = [False] * len(capacity) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v in range(len(capacity)): if visited[v] is False and capacity[u][v] > 0: # not visited and there is available capacity parent[v] = u visited[v] = True queue.append(v) if v == sink: return True return False def maximum_flow(capacity: List[List[int]], source: int, sink: int) -> int: parent = [-1] * len(capacity) max_flow = 0 while bfs(capacity, source, sink, parent): # Find the path flow (minimum capacity in the path filled by BFS) path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, capacity[parent[s]][s]) s = parent[s] # update capacities of the edges and reverse edges along the path v = sink while v != source: u = parent[v] capacity[u][v] -= path_flow capacity[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Pairwise Swap in Stack **Objective**: You are required to implement a function that swaps successive pairs of numbers starting at the bottom of a given stack. Your task is to create two versions of the function: one that utilizes an auxiliary stack for storage and another that uses an auxiliary queue (deque). If the stack contains an odd number of elements, the element at the top of the stack should remain in its position. **Function Signatures**: 1. `def first_switch_pairs(stack: List[int]) -> List[int]:` 2. `def second_switch_pairs(stack: List[int]) -> List[int]:` **Input**: - `stack`: A list of integers representing the stack, where the last element of the list is the top of the stack and the first element is the bottom of the stack. **Output**: - The stack with successive pairs of numbers swapped. **Constraints**: - The stack can contain up to `10^5` elements. - Each element in the stack is guaranteed to be an integer. - You are not allowed to use any standard library functions apart from those necessary for stack and queue operations. **Examples**: 1. Example 1: - Input: stack = [3, 8, 17, 9, 1, 10] - Output: - `first_switch_pairs`: [8, 3, 9, 17, 10, 1] - `second_switch_pairs`: [8, 3, 9, 17, 10, 1] 2. Example 2: - Input: stack = [3, 8, 17, 9, 1] - Output: - `first_switch_pairs`: [8, 3, 9, 17, 1] - `second_switch_pairs`: [8, 3, 9, 17, 1] **Performance Requirements**: - The time complexity should be (O(n)). - The space complexity should be (O(n)). **Implementation Notes**: - Focus on maintaining the integrity of the stack during the swap operations. - Pay attention to edge cases such as empty stacks or stacks with an odd number of elements. - Your solution should handle large inputs efficiently.","solution":"from collections import deque from typing import List def first_switch_pairs(stack: List[int]) -> List[int]: aux_stack = [] while stack: aux_stack.append(stack.pop()) while aux_stack: if len(aux_stack) > 1: first = aux_stack.pop() second = aux_stack.pop() stack.append(second) stack.append(first) else: stack.append(aux_stack.pop()) return stack def second_switch_pairs(stack: List[int]) -> List[int]: aux_queue = deque() while stack: aux_queue.appendleft(stack.pop()) while aux_queue: if len(aux_queue) > 1: first = aux_queue.popleft() second = aux_queue.popleft() stack.append(second) stack.append(first) else: stack.append(aux_queue.popleft()) return stack"},{"question":"You are given the lengths of any two sides of a right-angled triangle, and you need to find the length of the third side. Implement a function `find_third_side` that takes three arguments: `opposite`, `adjacent`, and `hypotenuse`, where one of these will be a string `\\"?\\"` representing the unknown side. The function should calculate and return the length of the unknown side. # Input - `opposite`: a positive float representing the length of the side opposite the right angle, or the string `\\"?\\"`. - `adjacent`: a positive float representing the length of the side adjacent to the right angle, or the string `\\"?\\"`. - `hypotenuse`: a positive float representing the length of the hypotenuse, or the string `\\"?\\"`. # Constraints - Only one parameter will be `\\"?\\"`. - The lengths of the given sides will be valid and will form a right-angled triangle. - The lengths will be in the range `(0, 1000)`. - Floating-point precision up to two decimal places is acceptable. # Output The function should return a string describing the unknown side and its length rounded to two decimal places, e.g., `\\"Opposite = 3.00\\"`, `\\"Adjacent = 4.24\\"`, or `\\"Hypotenuse = 5.83\\"`. # Example ```python assert find_third_side(\\"?\\", 4.0, 5.0) == \\"Opposite = 3.00\\" assert find_third_side(3.0, \\"?\\", 5.0) == \\"Adjacent = 4.00\\" assert find_third_side(3.0, 4.0, \\"?\\") == \\"Hypotenuse = 5.00\\" ``` # Notes - Implement the function in Python using basic arithmetic operations. - Handle invalid inputs by raising a `ValueError` with the message \\"invalid argument(s) were given.\\" # Requirements - You must not use any external libraries.","solution":"import math def find_third_side(opposite, adjacent, hypotenuse): Given two sides of a right-angled triangle, find the third side. Parameters: opposite (float or str): the length of the side opposite the right angle, or \'?\'. adjacent (float or str): the length of the side adjacent to the right angle, or \'?\'. hypotenuse (float or str): the length of the hypotenuse, or \'?\'. Returns: str: the unknown side and its length rounded to two decimal places. if opposite == \\"?\\": if isinstance(adjacent, (int, float)) and isinstance(hypotenuse, (int, float)): opposite = math.sqrt(hypotenuse**2 - adjacent**2) return f\\"Opposite = {opposite:.2f}\\" elif adjacent == \\"?\\": if isinstance(opposite, (int, float)) and isinstance(hypotenuse, (int, float)): adjacent = math.sqrt(hypotenuse**2 - opposite**2) return f\\"Adjacent = {adjacent:.2f}\\" elif hypotenuse == \\"?\\": if isinstance(opposite, (int, float)) and isinstance(adjacent, (int, float)): hypotenuse = math.sqrt(opposite**2 + adjacent**2) return f\\"Hypotenuse = {hypotenuse:.2f}\\" else: raise ValueError(\\"invalid argument(s) were given.\\")"},{"question":"**Separate Chaining Hash Table Implementation with Resizing** In this exercise, you will enhance the existing `SeparateChainingHashTable` class with a resizing mechanism. The hash table should dynamically resize itself when the number of elements exceeds a certain load factor. This will help to maintain efficient average-case time complexity for `put`, `get`, and `delete` operations even as the number of elements grows. **Task**: 1. Implement the `resize` method to handle resizing the hash table. 2. Modify the `put` method to call the `resize` method when the load factor exceeds 0.75. 3. Ensure the new implementation properly rehashes and redistributes the elements into the new table. **Input and Output**: - The hash table supports the following operations: ```python table = SeparateChainingHashTable() table.put(key, value) value = table.get(key) del table[key] len_ = len(table) table[key] = value # equivalent to table.put(key, value) ``` - `key`: an immutable object (e.g., string, integer) - `value`: any object - Return and print values as needed. **Constraints**: - The implementation should handle up to 10,000 key-value pairs efficiently. - Resize the hash table by doubling its current size when the load factor exceeds 0.75. **Testing**: - Initialize an empty hash table. - Add elements and test if resizing occurs. - Verify all elements are correctly rehashed and redistributed. **Example**: ```python table = SeparateChainingHashTable() for i in range(1000): table.put(f\'key{i}\', f\'value{i}\') assert len(table) == 1000 assert table.get(\'key999\') == \'value999\' assert table.get(\'non_existent_key\') is None ``` **Additional Requirements** (Optional): - Implement a method to shrink the table size when the load factor drops below a certain threshold (e.g., 0.25). - Implement a custom hash function that optimizes the distribution of keys.","solution":"class SeparateChainingHashTable: def __init__(self, initial_capacity=8): self.capacity = initial_capacity self.size = 0 self.buckets = [[] for _ in range(self.capacity)] self.load_factor = 0.75 def _hash(self, key): return hash(key) % self.capacity def put(self, key, value): if self.size / self.capacity > self.load_factor: self._resize() bucket_index = self._hash(key) bucket = self.buckets[bucket_index] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.size += 1 def get(self, key): bucket_index = self._hash(key) bucket = self.buckets[bucket_index] for k, v in bucket: if k == key: return v return None def __delitem__(self, key): bucket_index = self._hash(key) bucket = self.buckets[bucket_index] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self.size -= 1 return def __len__(self): return self.size def __setitem__(self, key, value): self.put(key, value) def _resize(self): new_capacity = self.capacity * 2 new_buckets = [[] for _ in range(new_capacity)] for bucket in self.buckets: for key, value in bucket: new_bucket_index = hash(key) % new_capacity new_buckets[new_bucket_index].append((key, value)) self.capacity = new_capacity self.buckets = new_buckets"},{"question":"Context You are given an array containing mixed data types, including integers, floating-point numbers, strings, and boolean values. Your task is to write a function to remove duplicate elements from the given array and return a new array containing only unique elements. Task Write a function `remove_duplicates_optimized` that removes duplicates from the input array more efficiently than the provided code snippet. Function Signature ```python def remove_duplicates_optimized(array: list) -> list: pass ``` Input * `array` (list): A list of elements that can contain integers, strings, floats, and boolean values. Output * (list): A list of elements containing only unique elements from the input array in the original order. Constraints * Elements in the array can be of different data types. * Try to optimize the function to run with a time complexity better than O(n^2). Examples ```python assert remove_duplicates_optimized([1, 1 ,1 ,2 ,2 ,3 ,4 ,4 ,\'hey\', \'hey\', \'hello\', True, True]) == [1, 2, 3, 4, \'hey\', \'hello\'] assert remove_duplicates_optimized([]) == [] assert remove_duplicates_optimized([\'a\', \'a\', \'b\', \'b\', \'c\']) == [\'a\', \'b\', \'c\'] assert remove_duplicates_optimized([1, 1.0, \'1\', True]) == [1, \'1\'] ``` Note: * In the final example, `1` and `1.0` are considered duplicates, and `True` is considered a duplicate of `1`. Clarification If you want to distinguish between boolean and integer types, or other specifics, you need to adjust the `in` check accordingly.","solution":"def remove_duplicates_optimized(array: list) -> list: Removes duplicate elements from the input array and returns a new list containing only unique elements. Maintains the original order of elements. seen = set() result = [] for item in array: if item not in seen: result.append(item) seen.add(item) return result"},{"question":"# Hierarchical Data Display You are given a tree-like hierarchical structure in the form of a dictionary. The dictionary contains keys representing primary categories, and each key maps to a list of elements representing sub-categories or associated values. Implement a function `enhanced_tree_print(tree)` that prints the tree structure in a specified tabular format. The format requirements are: - The primary category (key) should be printed first. - Each sub-category or value should be preceded by \\"->\\". - If a sub-category/value is a value of type integer, it should start a newline and indent to signify a deeper level in the hierarchy. Function Signature ```python def enhanced_tree_print(tree: dict) -> None: ``` Input - `tree`: A dictionary representing the hierarchical tree structure where the key is a string and the value is a list of sub-categories (strings or integers). Output - Print the tree structure in a specific format as described. Constraints - Each primary category (key) will have at least one sub-category or value. - Sub-categories/values may be strings or integers. Example Usage ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6, \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } enhanced_tree_print(tree) ``` Expected Output ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` Make sure to account for any edge cases and ensure the function handles different types of sub-categories/values correctly.","solution":"def enhanced_tree_print(tree): Prints the tree structure in the specified tabular format. for key, values in tree.items(): print(key, end=\' -> \') first = True for value in values: if first: print(value, end=\'\') first = False else: print(\' -> \' + str(value), end=\'\') print(\\"n\\")"},{"question":"# Integer and Byte Conversion Challenge You are required to implement two functions to convert integers to bytes and bytes to integers, supporting both **big-endian** and **little-endian** byte orders. This is crucial in scenarios such as data serialization/deserialization and network data processing, where byte ordering often matters. Function Specifications: 1. **Function Name**: `convert_to_bytes(num: int, endian: str) -> bytes` - **Inputs**: - `num` (int): A non-negative integer to convert to byte array. - `endian` (str): A string specifying the byte order, either `\\"big\\"` for big-endian or `\\"little\\"` for little-endian. - **Output**: A byte array representing the integer in the specified byte order. 2. **Function Name**: `convert_to_int(bytestr: bytes, endian: str) -> int` - **Inputs**: - `bytestr` (bytes): A byte array to convert to an integer. - `endian` (str): A string specifying the byte order, either `\\"big\\"` for big-endian or `\\"little\\"` for little-endian. - **Output**: An integer represented by the byte array in the specified byte order. Constraints: - You can assume that `num` will always be a non-negative integer. - The `endian` parameter will always be either `\\"big\\"` or `\\"little\\"`. - You must handle the edge cases such as zero and empty byte arrays correctly. - Your solution should be efficient in both time and space. Performance Requirements: - Your functions should run optimally within O(log(num)) for integer-to-byte conversions and O(n) for byte-to-integer conversions, where `n` is the length of the byte array. Example: ```python # Example usage: print(convert_to_bytes(305419896, \\"big\\")) # Expected output: b\'x12x34x56x78\' print(convert_to_int(b\'x12x34x56x78\', \\"big\\")) # Expected output: 305419896 print(convert_to_bytes(305419896, \\"little\\")) # Expected output: b\'x78x56x34x12\' print(convert_to_int(b\'x78x56x34x12\', \\"little\\")) # Expected output: 305419896 ``` Implement the functions `convert_to_bytes` and `convert_to_int` with the given specifications.","solution":"def convert_to_bytes(num: int, endian: str) -> bytes: Convert an integer to a byte array in the specified byte order. :param num: A non-negative integer to convert to byte array. :param endian: A string specifying the byte order, either \\"big\\" or \\"little\\". :return: A byte array representing the integer in the specified byte order. if num == 0: return b\'x00\' num_bytes = (num.bit_length() + 7) // 8 # Calculate the number of bytes needed if endian not in [\'big\', \'little\']: raise ValueError(\\"endian must be either \'big\' or \'little\'\\") return num.to_bytes(num_bytes, byteorder=endian) def convert_to_int(bytestr: bytes, endian: str) -> int: Convert a byte array to an integer in the specified byte order. :param bytestr: A byte array to convert to an integer. :param endian: A string specifying the byte order, either \\"big\\" or \\"little\\". :return: An integer represented by the byte array in the specified byte order. if endian not in [\'big\', \'little\']: raise ValueError(\\"endian must be either \'big\' or \'little\'\\") return int.from_bytes(bytestr, byteorder=endian)"},{"question":"# Task Given two strings containing lowercase English alphabets, write a function to find the length of the Longest Common Subsequence (L.C.S.). # Scenario You are developing a text comparison tool, and you need to implement the core functionality for comparing document versions. Finding the Longest Common Subsequence will help in identifying similar parts between two versions of text. # Function Signature ```python def longest_common_subsequence(s_1: str, s_2: str) -> int: :param s_1: A string consisting of lowercase English alphabets. :param s_2: A string consisting of lowercase English alphabets. :return: Length of the Longest Common Subsequence (L.C.S.). ``` # Input * `s_1`: String, 1 ≤ length of s_1 ≤ 1000 * `s_2`: String, 1 ≤ length of s_2 ≤ 1000 # Output * Integer, the length of the L.C.S. # Constraints * The input strings will contain only lowercase English alphabets. # Example ```python print(longest_common_subsequence(\'abcdgh\', \'aedfhr\')) # Output: 3 print(longest_common_subsequence(\'abc\', \'def\')) # Output: 0 ``` # Notes * Edge cases include scenarios where one or both input strings are empty. * Consider performance trade-offs when designing your solution to ensure it handles the upper limits efficiently.","solution":"def longest_common_subsequence(s_1: str, s_2: str) -> int: Returns the length of the Longest Common Subsequence (L.C.S.) between s_1 and s_2. len_s1, len_s2 = len(s_1), len(s_2) dp = [[0] * (len_s2 + 1) for _ in range(len_s1 + 1)] for i in range(1, len_s1 + 1): for j in range(1, len_s2 + 1): if s_1[i - 1] == s_2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[len_s1][len_s2]"},{"question":"Problem Statement You are given an array of integers that need to be sorted using the Shell Sort algorithm. Implement the Shell Sort function to sort the provided array in ascending order. Function Signature ```python def shell_sort(arr: List[int]) -> List[int]: \'\'\' Sort the array using Shell Sort algorithm. Parameters: - arr (List[int]): The list of integers to be sorted. Returns: - List[int]: The sorted list of integers. \'\'\' ``` Input - `arr` : List of integers where (1 leq text{len}(arr) leq 1000) - Each integer in `arr` is within (-10^6 leq arr[i] leq 10^6). Output - A list of integers sorted in non-decreasing order. Constraints - You should optimize the gap sequence for better performance where possible. - Your implementation should handle all edge cases efficiently, including empty arrays, arrays with one element, arrays with all elements identical, and already sorted arrays. Example ```python # Example 1 input_arr = [12, 34, 54, 2, 3] assert shell_sort(input_arr) == [2, 3, 12, 34, 54] # Example 2 input_arr = [0, -10, 7, 3, 5, 4] assert shell_sort(input_arr) == [-10, 0, 3, 4, 5, 7] ```","solution":"from typing import List def shell_sort(arr: List[int]) -> List[int]: Sort the array using Shell Sort algorithm. Parameters: - arr (List[int]): The list of integers to be sorted. Returns: - List[int]: The sorted list of integers. n = len(arr) gap = n // 2 # Start with a big gap, then reduce the gap while gap > 0: for i in range(gap, n): temp = arr[i] j = i # Perform a gapped insertion sort for this gap size while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 # Reduce the gap for the next step return arr"},{"question":"# Comb Sort Implementation **Objective**: Demonstrate your understanding of sorting algorithms by implementing an alternative version of Comb Sort with the ability to customize the shrink factor. Task: Write a function `custom_comb_sort(arr, shrink)` that sorts an array of integers using the Comb Sort algorithm. The function should take an additional parameter `shrink`, which will determine the shrink factor. **Function Signature**: ```python def custom_comb_sort(arr: List[int], shrink: float) -> List[int]: # Your code here ``` Input: * `arr` - a list of integers to be sorted. Constraints: 1 ≤ len(arr) ≤ 10^5, -10^4 ≤ arr[i] ≤ 10^4. * `shrink` - a float shrink factor (1 < shrink < 2). Typical shrink factor in Comb Sort is 1.3. Output: * Return a list of integers sorted in non-decreasing order. Example: ```python print(custom_comb_sort([34, 2, 78, -1, -56, 0, 24, 12], 1.3)) # Expected output: [-56, -1, 0, 2, 12, 24, 34, 78] ``` Constraints: * Ensure that your solution works efficiently for the given input constraints. * The function should handle edge cases gracefully, such as arrays of size 1 or arrays that are already sorted. Notes: * You can assume that the shrink factor will always be a valid float greater than 1 and less than 2. * Implement the swap logic as a separate helper function to keep the main function clean and modular.","solution":"from typing import List def custom_comb_sort(arr: List[int], shrink: float) -> List[int]: Sorts an array using the Comb Sort algorithm with a customizable shrink factor. def swap(arr, i, j): arr[i], arr[j] = arr[j], arr[i] def get_next_gap(gap): gap = int(gap / shrink) if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap > 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: swap(arr, i, i + gap) swapped = True return arr"},{"question":"# Cycle Sort Implementation Question Cycle sort is a unique sorting algorithm that minimizes the number of writes to the array, making it useful in environments where writing to memory is costly. The algorithm works by identifying cycles and rotating the elements within these cycles to place each element in the correct position. Task Implement the Cycle Sort algorithm based on the provided explanation and detailed specification. Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: ``` Input * A list of integers `arr` which may contain duplicate values. * The length of the array will be in the range of `0` to `10^4`. Output * A sorted list of integers which is the original list sorted in non-decreasing order. Constraints * The algorithm should be implemented in-place to maintain the O(1) space complexity. * The sorting algorithm must handle edge cases efficiently, such as empty arrays and arrays with duplicate elements. * Sorting should be performed with minimal writes to the array. Example ```python # Example 1: arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] cycle_sort(arr) # Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] # Example 2: arr = [10, 5, 3, 8, 6, 9, 2, 1, 4, 7, 5] cycle_sort(arr) # Output: [1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 10] # Example 3: arr = [] cycle_sort(arr) # Output: [] ``` Notes * Ensure your function operates efficiently within the given constraints. * Your code should handle possible edge cases effectively, including cases with duplicates, empty lists, and already sorted input.","solution":"def cycle_sort(arr): writes = 0 # Traverse the array to find the cycles to rotate. for cycleStart in range(0, len(arr) - 1): item = arr[cycleStart] # Find the position where we put the element. pos = cycleStart for i in range(cycleStart + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position. if pos == cycleStart: continue # Otherwise, put the item to the right position. while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle. while pos != cycleStart: pos = cycleStart for i in range(cycleStart + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Segment Tree Implementation and Application **Scenario**: You are given an array of integers and need to frequently perform two types of operations: 1. Range queries to find the maximum value within a specific subarray. 2. Updates to modify values at specific positions in the array. Considering the importance of efficient range query operations, you decide to use a data structure known as the **Segment Tree**. # Task Implement a class `SegmentTree` that supports the following operations: 1. **Initialization**: Initialize the segment tree with a given array and a function to perform range operations. 2. **Update**: Update the value of an array element at a specified position. 3. **Query**: Return the result of the range query for a specified subarray. # Expected Input and Output Formats * **Initialization**: - Input: `SegmentTree(arr, function)` - `arr`: List of integers. - `function`: A commutative function to apply for range queries (e.g., `max`). - Output: None. * **Update**: - Input: `mytree.update(index, value)` - `index`: Integer position in the array to update. - `value`: New integer value to set at the specified index. - Output: None. * **Query**: - Input: `mytree.query(left, right)` - `left`: Starting index of the subarray (inclusive). - `right`: Ending index of the subarray (inclusive). - Output: Return the result of the function applied to the subarray from `left` to `right`. # Constraints - 1 ≤ length of `arr` ≤ 10000 - Value range for `arr` elements and updates: -10^5 to 10^5 - Query and updates: 1 ≤ `left`, `right`, `index` < length of `arr` # Example ```python arr = [2, 4, 5, 3, 4] mytree = SegmentTree(arr, max) # Range query from index 2 to 4 print(mytree.query(2, 4)) # Output: 5 # Update value at index 3 to 6 mytree.update(3, 6) # Range query again from index 0 to 3 print(mytree.query(0, 3)) # Output: 6 ``` Additional Notes: - Carefully handle edge cases such as invalid ranges or positions. - Ensure that the time complexity for updates and queries remains within logarithmic bounds.","solution":"class SegmentTree: def __init__(self, arr, function): Initialize the segment tree with an array and a function for range queries. self.n = len(arr) self.arr = arr self.function = function # Initialize the segment tree with a size sufficient to hold the data self.tree = [0] * (2 * self.n) # Build the tree self.build() def build(self): Build the segment tree. # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = self.arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, pos, value): Update the value at position pos to value. # Change the index to point to the leaf node pos += self.n self.tree[pos] = value # Move upward and update parents while pos > 1: pos //= 2 self.tree[pos] = self.function(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, left, right): Range query from left to right (inclusive). # Change indices to point to the leaf nodes left += self.n right += self.n + 1 res = None while left < right: if left % 2: res = self.tree[left] if res is None else self.function(res, self.tree[left]) left += 1 if right % 2: right -= 1 res = self.tree[right] if res is None else self.function(res, self.tree[right]) left //= 2 right //= 2 return res"},{"question":"You are given a problem where you need to find out the number of distinct ways to reach the top of a staircase. The staircase has `steps` number of steps, and you can either climb 1, 2, 3, ..., up to `k` steps at a time. Your goal is to write an optimized function to determine the number of ways to reach the top. # Task: Implement the function: ```python def climb_stairs_k(steps: int, k: int) -> int: :param steps: int - The total number of steps in the staircase. :param k: int - The maximum steps you can climb at a time. :return: int - The number of distinct ways to reach the top. ``` # Constraints: * `1 <= steps <= 10^5` * `1 <= k <= 100` # Example: ```python print(climb_stairs_k(4, 2)) # Output: 5 print(climb_stairs_k(5, 3)) # Output: 13 ``` # Explanation: * For `climb_stairs_k(4, 2)`: * You can have the following ways to climb: [1]+[1]+[1]+[1], [1]+[2]+[1], [2]+[2], [2]+[1]+[1], [1]+[1]+[2] * For `climb_stairs_k(5, 3)`: * You can have the following ways to climb: [1]+[1]+[1]+[1]+[1], [1]+[2]+[1]+[1], [2]+[2]+[1], [2]+[1]+[1]+[1], [1]+[1]+[1]+[2], [3]+[2], [2]+[3], [1]+[3]+[1], [3]+[1]+[1], [1]+[1]+[3], [2]+[1]+[2], [1]+[2]+[2], [1]+[1]+[1]+[1]+[1] # Note: * Your solution should be optimized for both time and space, and should handle large inputs efficiently.","solution":"def climb_stairs_k(steps: int, k: int) -> int: Returns the number of distinct ways to reach the top of a staircase with the given number of steps when you can climb up to k steps at a time. :param steps: int - The total number of steps in the staircase. :param k: int - The maximum steps you can climb at a time. :return: int - The number of distinct ways to reach the top. if steps == 0: return 1 dp = [0] * (steps + 1) dp[0] = 1 for i in range(1, steps + 1): start = max(0, i - k) dp[i] = sum(dp[start:i]) return dp[steps]"},{"question":"Design algorithms to encode a list of strings into a single encoded string and decode the encoded string back to the original list of strings. Function Signatures ```python def encode(strs: List[str]) -> str: pass def decode(s: str) -> List[str]: pass ``` # Input and Output Formats 1. **encode Function**: * **Input**: A list of strings `strs`. * **Output**: A single encoded string. 2. **decode Function**: * **Input**: A single encoded string `s`. * **Output**: A list of original strings. # Example Encoding ```python encode([\\"hello\\", \\"world\\"]) # Output: \\"5:hello5:world\\" ``` Decoding ```python decode(\\"5:hello5:world\\") # Output: [\\"hello\\", \\"world\\"] ``` # Constraints * Each string within the list of strings will only contain printable ASCII characters. * Strings may include spaces and special characters. * The encoded format should be robust enough to handle any edge cases, including empty strings. # Performance Requirements * The algorithms should handle lists containing up to 1,000 strings efficiently. * Focus on ensuring the decoding process correctly reconstructs the original list of strings with accurate delimiters. # Challenge Scenario Suppose you are building a messaging application where messages (lists of strings) need to be sent efficiently over a network. To do so, you decide to encode the list of messages into a single string before sending and, upon receipt, decode it back into the original list of messages. Implement the `encode` and `decode` functions to achieve this efficiently.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings into a single encoded string. Each string is prefixed with its length followed by a \':\' encoded_str = \'\'.join(f\\"{len(s)}:{s}\\" for s in strs) return encoded_str def decode(s: str) -> List[str]: Decodes a single encoded string back into a list of the original strings. decoded_list = [] i = 0 while i < len(s): # Find the position of the delimiter \':\' delimiter_pos = s.find(\':\', i) # The length of the string is before the \':\' str_len = int(s[i:delimiter_pos]) # Extract the string using the length found decoded_list.append(s[delimiter_pos + 1: delimiter_pos + 1 + str_len]) # Move the index to the next position after the extracted string i = delimiter_pos + 1 + str_len return decoded_list"},{"question":"# Sparse Vector Dot Product Given the provided context and code analysis, you need to implement a class `SparseVector` to encapsulate the behavior and operations on sparse vectors efficiently. # Task 1. **Class Implementation** - Define a class `SparseVector`: - Constructor: Initialize a sparse vector using an index-value list. - `from_dense`: Class method to create a `SparseVector` from a dense vector (normal list). - `dot`: Instance method to compute the dot product with another sparse vector. 2. **Input and Output Specifications** - Input: Two `SparseVector` instances. - Output: The dot product of these two vectors (a single numeric value). 3. **Constraints** - You may assume that both vectors have the same dimension. - Vectors can be extremely large with a very high proportion of zero elements. 4. **Performance** - The implementation should be optimized for time and space complexity. # Example ```python class SparseVector: def __init__(self, index_value_list): # Initialize the SparseVector with index-value list pass @classmethod def from_dense(cls, vector): # Convert a dense vector to SparseVector and return pass def dot(self, other): # Compute and return the dot product of this vector with another SparseVector pass # Usage v1 = SparseVector.from_dense([1., 0., 0., 2.]) v2 = SparseVector.from_dense([0., 3., 0., 1.]) print(v1.dot(v2)) # Output should be 2.0 ``` # Constraints and Notes - Consider edge cases such as vectors containing all zeros. - Ensure the implementation is efficient to handle large datasets.","solution":"class SparseVector: def __init__(self, index_value_list): self.index_value_list = index_value_list # Convert index_value_list to a dictionary for efficient storage and access self.vector = {idx: val for idx, val in index_value_list} @classmethod def from_dense(cls, vector): index_value_list = [(i, val) for i, val in enumerate(vector) if val != 0] return cls(index_value_list) def dot(self, other): if not isinstance(other, SparseVector): raise ValueError(\\"Dot product can only be computed with another SparseVector\\") dot_product = 0.0 for idx, val in self.vector.items(): if idx in other.vector: dot_product += val * other.vector[idx] return dot_product"},{"question":"# Kth Smallest Element in a BST As a software developer, you are tasked with implementing a feature in a database system that efficiently retrieves the k-th smallest element in a binary search tree (BST). The system holds a BST where each node contains an integer value. The data is represented by a `Node` class: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` # Function 1: Iterative Approach Challenge Objective: Implement an iterative function `kth_smallest_iterative` that finds the k-th smallest element in a BST. Use a stack to traverse the tree. Parameters: - `root` (Node): The root of the BST. - `k` (int): The k-th position (1-indexed). Returns: - `int`: The k-th smallest element value. # Function 2: Recursive Approach Challenge Objective: Implement a recursive function `kth_smallest_recursive` that also identifies the k-th smallest element in a BST using inorder traversal. Constraints: - The BST contains unique values. - The value of k is guaranteed to be valid within the total number of nodes in the BST to simplify problem handling. Example: ```python if __name__ == \'__main__\': n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 print(kth_smallest_iterative(n1, 2)) # Output: 50 print(kth_smallest_recursive(n1, 2)) # Output: 50 ```","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest_iterative(root, k): Finds k-th smallest element in a BST using an iterative in-order traversal. stack = [] current = root while True: while current: stack.append(current) current = current.left current = stack.pop() k -= 1 if k == 0: return current.val current = current.right def kth_smallest_recursive(root, k): Finds k-th smallest element in a BST using a recursive in-order traversal. def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) inorder = inorder_traversal(root) return inorder[k - 1]"},{"question":"You are given a sequence of complex numbers, and you need to compute its Discrete Fourier Transform (DFT) efficiently using the Cooley-Tukey FFT algorithm. **Input**: * A list of complex numbers `x` where the length of the list ( N ) is a power of 2 (e.g., 2, 4, 8, 16, etc.). **Output**: * A list of complex numbers representing the DFT of the input sequence. **Constraints**: * The length ( N ) of the input list is guaranteed to be a power of two. * Elements of the input list are complex numbers. **Example**: ```python Input: [2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j] Output: [(8+8j), 2j, (2-2j), (-2+0j)] ``` **Function Signature**: ```python def fft(x: List[complex]) -> List[complex]: pass ``` **Specification**: Implement a function `fft(x: List[complex]) -> List[complex]` that uses the recursive Cooley-Tukey FFT algorithm to compute the DFT of the given input list.","solution":"import cmath def fft(x): N = len(x) if N <= 1: return x else: even = fft(x[0::2]) odd = fft(x[1::2]) T = [cmath.exp(-2j * cmath.pi * k / N) * odd[k] for k in range(N // 2)] return [even[k] + T[k] for k in range(N // 2)] + [even[k] - T[k] for k in range(N // 2)]"},{"question":"Optimized Jump Search Objective Implement an enhanced version of the Jump Search algorithm to find a target element in a sorted array. Additionally, add the capability to handle arrays with duplicate elements by returning all indices where the target is present. Problem Statement Given a sorted array of integers `arr` and an integer `target`, write a function `optimized_jump_search(arr, target)` that returns a list of all indices in the array where the target element is found. If the target is not found, return an empty list. # Input * A sorted list of integers, `arr`, with length `n` (1 ≤ n ≤ 10^6). * An integer `target`. # Output * A list of integer indices where the `target` is found. If not found, return an empty list. # Constraints * The array is guaranteed to be sorted in ascending order. * Do not use built-in search functions. * Optimize the function for maximum efficiency. # Performance Requirements * The implemented function should run as close to O(√n) time complexity as possible while ensuring correct results. # Example ```python assert optimized_jump_search([1, 2, 4, 4, 4, 5, 6, 7, 8], 4) == [2, 3, 4] assert optimized_jump_search([1, 2, 3, 4, 5, 6], 10) == [] assert optimized_jump_search([5, 10, 10, 10, 20], 10) == [1, 2, 3] assert optimized_jump_search([2, 3, 5, 6, 8, 9], 2) == [0] ``` # Function Signature ```python def optimized_jump_search(arr: list[int], target: int) -> list[int]: # Your code here ```","solution":"import math def optimized_jump_search(arr, target): Jump Search algorithm to find a target element in a sorted array and return all indices where the target is found. Parameters: arr (list[int]): The sorted list of integers. target (int): The target integer to find in the array. Returns: list[int]: A list of indices where the target is found, or an empty list if not found. n = len(arr) indices = [] # Finding the block size to be jumped step = int(math.sqrt(n)) # Finding the block where target may be present prev = 0 while prev < n and arr[min(step, n)-1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return indices # Performing linear search in the identified block for i in range(prev, min(step, n)): if arr[i] == target: indices.append(i) # If the target is found previously, linear search for remaining occurrences to the right right = step if step < n else n i = min(step, n) while i < n and arr[i] == target: indices.append(i) i += 1 return indices"},{"question":"**Problem Statement**: You are working on an encoder-decoder system that handles base conversions for various applications. Your task is to write two functions: one to convert a base-10 integer to a specified base (up to base-36), and another to convert a string representation of a number in a specified base back to a base-10 integer. These functions should handle both positive and negative integers. **Function Descriptions**: 1. **int_to_base** - **Input**: - `num` (int): The base-10 integer to be converted. - `base` (int): The base to convert to (2 <= base <= 36). - **Output**: - A string representing the number in the specified base. 2. **base_to_int** - **Input**: - `str_to_convert` (str): The string representation of the number in the specified base. - `base` (int): The base of the number (2 <= base <= 36). - **Output**: - An integer representing the base-10 value of the input string. **Constraints**: - The input number for `int_to_base` will fit within standard integer range (-2^31 to 2^31 - 1). - The input string for `base_to_int` will be a valid representation in the given base. **Examples**: ```python assert int_to_base(5, 2) == \'101\' assert int_to_base(255, 16) == \'FF\' assert int_to_base(-31, 8) == \'-37\' assert base_to_int(\'101\', 2) == 5 assert base_to_int(\'FF\', 16) == 255 assert base_to_int(\'-37\', 8) == -31 ``` Write the functions `int_to_base` and `base_to_int` to solve this problem.","solution":"def int_to_base(num, base): Convert a base-10 integer to a specified base (up to base-36). :param num: The base-10 integer to be converted. :param base: The base to convert to (2 <= base <= 36). :return: A string representing the number in the specified base. if not (2 <= base <= 36): raise ValueError(\\"Base must be between 2 and 36\\") if num == 0: return \'0\' digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" negative = num < 0 num = abs(num) result = [] while num: result.append(digits[num % base]) num //= base if negative: result.append(\'-\') return \'\'.join(reversed(result)) def base_to_int(str_to_convert, base): Convert a string representation of a number in a specified base back to a base-10 integer. :param str_to_convert: The string representation of the number in the specified base. :param base: The base of the number (2 <= base <= 36). :return: An integer representing the base-10 value of the input string. if not (2 <= base <= 36): raise ValueError(\\"Base must be between 2 and 36\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" str_to_convert = str_to_convert.upper() negative = str_to_convert[0] == \'-\' if negative: str_to_convert = str_to_convert[1:] num = 0 for char in str_to_convert: num = num * base + digits.index(char) return -num if negative else num"},{"question":"# Cycle Detection in a Linked List You are provided with the definition of a linked list node and a method to check if the linked list has a cycle. Your task is to implement the function `is_cyclic(head)` which determines if there is a cycle in the linked list that starts from the given node, without using any extra space. Function Signature: ```python def is_cyclic(head: Node) -> bool: ``` Input * `head` (Node): The head node of the linked list. Output * Return `True` if there is a cycle in the linked list. * Return `False` if there is no cycle in the linked list. Constraints * The linked list can have up to 10^4 nodes. * Node values are not unique. * Extra space usage is not allowed, i.e., use of any additional data structures like dictionaries, sets, or lists is not allowed. Example ```python # Helper function to create linked list with a cycle def create_linked_list(vals, cycle_idx): head = Node(vals[0]) current = head cycle_start = None for i in range(1, len(vals)): current.next = Node(vals[i]) current = current.next if i == cycle_idx: cycle_start = current if cycle_start: current.next = cycle_start return head # Example 1 head = create_linked_list([3, 2, 0, -4], 1) print(is_cyclic(head)) # Should return True # Example 2 head = create_linked_list([1, 2], 0) print(is_cyclic(head)) # Should return True # Example 3 head = create_linked_list([1], -1) print(is_cyclic(head)) # Should return False ``` Notes * Ensure to check edge cases such as an empty list (head is None), a single node with no cycle, and a single node with a cycle. * The list elements and the cycle parameters are provided in such a way that it should be possible to determine if a cycle exists or not using the defined function.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def is_cyclic(head: Node) -> bool: Checks if a linked list has a cycle using Floyd\'s Tortoise and Hare algorithm. if not head: return False slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"You are to implement a function in Python that takes a list of file paths and returns a list of their full absolute paths after expanding any user home directory shortcuts (`~`). The function should efficiently handle multiple input paths and correctly convert any relative paths into an absolute form. # Function Signature ```python def resolve_file_paths(file_paths: List[str]) -> List[str]: pass ``` # Input * A list of strings: `file_paths` where each string represents a file path. * Length of list: `1 <= len(file_paths) <= 1000` * Length of each path string: `1 <= len(path) <= 255` # Output * A list of strings where each string is the corresponding absolute path of the input paths after expanding any user home directory shortcuts (`~`). # Constraints * Paths given in the input might not necessarily point to existing files. * The function should not perform checks for file existence or file type. * Paths should be handled in a case-insensitive manner on case-insensitive filesystems, and case-sensitive on case-sensitive filesystems. # Example ```python input_file_paths = [\'~/file.txt\', \'./subdir/file2.txt\', \'/absolute/path/file3.txt\'] output_full_paths = resolve_file_paths(input_file_paths) print(output_full_paths) ``` Possible output when run in a user\'s home directory at `/home/testuser`: ```python [\'/home/testuser/file.txt\', \'/home/testuser/subdir/file2.txt\', \'/absolute/path/file3.txt\'] ``` # Notes * If the input list contains redundant or invalid paths (like empty strings), they should be retained in the output but converted to the corresponding absolute form. # Performance Requirements * Ensure that the function handles up to 1000 paths efficiently.","solution":"import os from typing import List def resolve_file_paths(file_paths: List[str]) -> List[str]: Given a list of file paths, return a list of their full absolute paths after expanding any user home directory shortcuts (`~`). The function also converts relative paths into an absolute form. return [os.path.abspath(os.path.expanduser(path)) for path in file_paths]"},{"question":"# Spiral Matrix Traversal Challenge Problem Statement You are provided with an `m x n` matrix of integers. Your task is to convert this matrix into a single list containing all its elements in spiral order. Definition Write a function `spiral_traversal(matrix: List[List[int]]) -> List[int]` that takes in a 2D list `matrix` and returns a list of integers representing the elements of the matrix traversed in spiral order. # Input - A 2D list `matrix` of integers with dimensions `m x n` (`1 <= m, n <= 1000`) # Output - A list of integers, containing all the matrix elements in spiral order. # Constraints - You may assume all elements in the `matrix` are distinct. - The total elements in the matrix will not exceed 1,000,000. # Examples 1. Given the following matrix: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` The function should return `[1, 2, 3, 6, 9, 8, 7, 4, 5]`. 2. Given the following matrix: ``` [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] ``` The function should return `[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]`. 3. Given the following matrix: ``` [ [2, 5, 8], [4, 0, -1] ] ``` The function should return `[2, 5, 8, -1, 0, 4]`. Instructions 1. Implement the function `spiral_traversal`. 2. Test your function on various edge cases: - An empty matrix. - A single row or a single column matrix. - A square matrix vs a rectangular matrix. 3. Ensure your solution handles the upper constraints by efficiently processing very large matrices. Good luck, and remember to thoroughly test your code!","solution":"from typing import List def spiral_traversal(matrix: List[List[int]]) -> List[int]: Returns a list of matrix elements in spiral order. if not matrix: return [] result = [] top, bottom = 0, len(matrix) - 1 left, right = 0, len(matrix[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right along the top row for col in range(left, right + 1): result.append(matrix[top][col]) top += 1 # Traverse from top to bottom along the right column for row in range(top, bottom + 1): result.append(matrix[row][right]) right -= 1 if top <= bottom: # Traverse from right to left along the bottom row for col in range(right, left - 1, -1): result.append(matrix[bottom][col]) bottom -= 1 if left <= right: # Traverse from bottom to top along the left column for row in range(bottom, top - 1, -1): result.append(matrix[row][left]) left += 1 return result"},{"question":"# Binary Tree In-order Traversal Context: You are given a Binary Tree and tasked with implementing an in-order traversal. This traversal will help in printing the elements of the tree in a sorted manner if the tree is a Binary Search Tree (BST). Task: Write a function, `inorder_traversal`, that takes the root node of a binary tree and returns a list of values in in-order traversal form. Input: - The function will take a single argument: - `root`: The root node of a binary tree. Output: - The function should return a list containing all elements of the tree in in-order traversal order. Constraints: - The number of nodes in the binary tree is in the range `[0, 1000]`. Example: ```python class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: Node) -> list: # TODO: Implement this function. pass if __name__ == \'__main__\': # Example n1 = Node(1) n2 = Node(2, left=n1) n3 = Node(3) n4 = Node(4, left=n2, right=n3) # Tree structure # 4 # / # 2 3 # / # 1 assert inorder_traversal(n4) == [1, 2, 4, 3] ``` Notes: - You should not assume the provided tree is always a BST. However, the in-order traversal will help explore nodes sequentially in-place. - Aim to implement both iterative and recursive solutions for clarity and understanding.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: Node) -> list: Perform in-order traversal of the binary tree. :param root: Node, the root of the binary tree :return: List of node values in in-order traversal if root is None: return [] result = [] def traverse(node): if node.left: traverse(node.left) result.append(node.val) if node.right: traverse(node.right) traverse(root) return result"},{"question":"You are given an array of integers that need to be sorted in non-decreasing order. Implement the `gnome_sort` function to sort the given array in-place using the Gnome Sort algorithm. # Constraints: * The array can contain positive, negative, and zero integers. * The array size (n) is between 0 and 10^4. # Input Format: * A list of integers, `arr`. # Output Format: * The sorted list of integers in non-decreasing order. # Example: 1. Input: `[34, 2, -1, 45, 29, 8, 12]` Output: `[-1, 2, 8, 12, 29, 34, 45]` 2. Input: `[5, 3, 3, 2, 1]` Output: `[1, 2, 3, 3, 5]` 3. Input: `[]` Output: `[]` # Explanation: - In the first example, the array `[34, 2, -1, 45, 29, 8, 12]` is sorted to `[-1, 2, 8, 12, 29, 34, 45]` via Gnome Sort. - In the second example, the array `[5, 3, 3, 2, 1]` is sorted to `[1, 2, 3, 3, 5]`. - In the third example, an empty array remains empty after sorting. ```python def gnome_sort(arr): n = len(arr) index = 0 while index < n: if index == 0 or arr[index] >= arr[index-1]: index = index + 1 else: arr[index], arr[index-1] = arr[index-1], arr[index] index = index - 1 return arr ``` # Your Task: * Complete the function `gnome_sort(arr)` to sort the given list in non-decreasing order. * Ensure that your solution handles edge cases and performs efficiently for arrays within the given constraints.","solution":"def gnome_sort(arr): Sorts the array in non-decreasing order using the Gnome Sort algorithm. :param arr: List[int] - The list of integers to sort. :return: List[int] - The sorted list of integers. n = len(arr) index = 0 while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Prime Number Generation Using Modified Sieve of Eratosthenes Context You\'ve been hired to optimize a scientific computation project. The project requires frequent queries for prime numbers up to large limits, and performance is crucial. Problem Statement Write a function `optimized_sieve(n)` that returns all prime numbers less than a given positive integer `n` using a modified Sieve of Eratosthenes. Specifically, the sieve should be optimized by only considering odd numbers, which reduces processing and memory usage. Function Signature ```python def optimized_sieve(n: int) -> List[int]: ``` Input and Output Format * **Input**: - A single integer `n`, where `0 <= n <= 10^7` * **Output**: - A list of integers containing all prime numbers less than `n`. Constraints * Your solution should handle edge cases such as n being zero or negative appropriately. * Optimize for both time and space complexity as mentioned in the analysis. Sample Input and Output ```python # Example 1 n = 10 # Primes less than 10 are: 2, 3, 5, 7 print(optimized_sieve(10)) # Output: [2, 3, 5, 7] # Example 2 n = 0 # There are no primes less than 0 print(optimized_sieve(0)) # Output: [] # Example 3 n = 30 # Primes less than 30 are: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 print(optimized_sieve(30)) # Output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # Example 4 n = 2 # There are no primes less than 2 print(optimized_sieve(2)) # Output: [] ``` Note Think carefully about the edge cases and how the optimization for only odd numbers can significantly benefit the performance of the sieve.","solution":"from typing import List def optimized_sieve(n: int) -> List[int]: Returns a list of all prime numbers less than n using an optimized Sieve of Eratosthenes that only considers odd numbers. if n <= 2: return [] sieve = [True] * (n // 2) sieve[0] = False # 1 is not a prime number for i in range(3, int(n**0.5) + 1, 2): if sieve[i // 2]: for j in range(i * i, n, 2 * i): sieve[j // 2] = False primes = [2] + [2 * i + 1 for i in range(1, n // 2) if sieve[i]] return primes"},{"question":"# Bubble Sort Optimization Challenge **Context:** Bubble sort is a simple sorting algorithm suitable for small or nearly sorted datasets. However, in its basic form, its performance can be sub-optimal for larger datasets. The standard Bubble Sort algorithm can be improved by minimizing the number of iterations once the array starts becoming partially sorted. **Objective:** Your task is to implement an optimized version of bubble sort which reduces unnecessary comparisons when the array becomes nearly sorted. # Function Signature ```python def optimized_bubble_sort(arr: list, simulation: bool = False) -> list: ``` # Input * `arr`: A list of comparable elements (e.g., integers). * `simulation`: A boolean flag to enable step-by-step output of the sorting process. Default is `False`. # Output * A list of elements sorted in ascending order. # Constraints * `arr` can be of any size (1 <= len(arr) <= 10^5). * Elements in `arr` can be any orderable data type. * The simulation mode must print the state of the array after each swap operation, with iteration count starting from 1. # Requirements: 1. Improve the `bubble_sort` algorithm: - Terminate the iteration early if no swaps have occurred in the current pass. 2. Optimize performance considering the worst-case, best-case, and average-case scenarios. 3. Do not use Python\'s built-in sort function. # Example: ```python # Input arr = [64, 34, 25, 12, 22, 11, 90] print(optimized_bubble_sort(arr)) # Output [11, 12, 22, 25, 34, 64, 90] arr = [5, 1, 4, 2, 8] print(optimized_bubble_sort(arr, True)) # Simulation output iteration 1 : 5 1 4 2 8 iteration 2 : 1 5 4 2 8 iteration 3 : 1 4 5 2 8 iteration 4 : 1 4 2 5 8 iteration 5 : 1 4 2 5 8 iteration 6 : 1 2 4 5 8 # Final output [1, 2, 4, 5, 8] ``` # Note: * Ensure that your implementation efficiently handles large inputs. * In simulation mode, display the iteration number and the array state after each swap.","solution":"def optimized_bubble_sort(arr: list, simulation: bool = False) -> list: Optimized bubble sort function which terminates early when the list becomes sorted. Additionally, prints the state of the array after each swap if simulation is set to True. n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if simulation: print(f\\"iteration {i*(n-1) + j + 1} : {\' \'.join(map(str, arr))}\\") if not swapped: break return arr"},{"question":"**Context**: You are working on a text processing application where it is important to filter out reoccurring characters from strings to create unique identifiers or clean data schema. **Task**: Write a function `delete_reoccurring_characters` that takes a single string input and returns a new string in which any reoccurring character from the input string has been deleted. The order of characters in the new string should reflect the order of their first occurrence in the original string. **Function Signature**: ```python def delete_reoccurring_characters(string: str) -> str: ``` **Input**: - `string`: a string composed of lowercase English letters. (0 ≤ len(string) ≤ 1000) **Output**: - Returns a string with all reoccurring characters removed, preserving only the first occurrence of each character. **Constraints**: - The function should maintain a linear runtime complexity. - Aim for optimal space usage within the given constraints. **Performance Requirements**: - The solution must run efficiently even for the upper limit of the input size. **Examples**: 1. `delete_reoccurring_characters(\\"programming\\")` should return `\\"progamin\\"`. 2. `delete_reoccurring_characters(\\"aabccba\\")` should return `\\"abc\\"`. 3. `delete_reoccurring_characters(\\"\\")` should return `\\"\\"`. 4. `delete_reoccurring_characters(\\"xyz\\")` should return `\\"xyz\\"`. **Additional Notes**: - Consider using data structures that offer optimal time complexity for insertion and look-up operations. - Make sure to handle cases with all unique characters or all the same characters efficiently.","solution":"def delete_reoccurring_characters(string: str) -> str: Returns a new string with any reoccurring character from the input string deleted. Only the first occurrence of each character is preserved. seen = set() result = [] for char in string: if char not in seen: result.append(char) seen.add(char) return \'\'.join(result)"},{"question":"# Word Trie Data Structure and Search with Wildcards Develop a data structure that supports adding words and searching for words with pattern matching using wildcards. The structure should be efficient in both operations — adding words and searching for words, including those with wildcard characters. Implementation Details - You are to implement a class `WordTrie` with the following methods: - `add_word(word: str) -> None`: Add a word to the data structure. - `search(word: str) -> bool`: Return `True` if there is any word in the data structure that matches the given word or pattern. The pattern can include the wildcard character \'.\' which matches any single letter. Example: ```python trie = WordTrie() trie.add_word(\\"bad\\") trie.add_word(\\"dad\\") trie.add_word(\\"mad\\") assert trie.search(\\"pad\\") == False assert trie.search(\\"bad\\") == True assert trie.search(\\".ad\\") == True assert trie.search(\\"b..\\") == True ``` Constraints: - The input words consist of lowercase English letters. - Number of calls to `add_word` and `search` combined will not exceed 3 * 10^4. - Assume the maximum length of a single word does not exceed 100. Scenario: You are building a smart search feature for a dictionary application. Users can add new words to their dictionary and search using exact word matches or patterns (where \'.\' can be any character). Your goal is to implement a solution that efficiently supports adding new words and searching for words with patterns.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordTrie: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: return self._search_recursive(word, 0, self.root) def _search_recursive(self, word, index, node): if index == len(word): return node.is_end_of_word char = word[index] if char == \'.\': for child in node.children.values(): if self._search_recursive(word, index + 1, child): return True return False else: if char in node.children: return self._search_recursive(word, index + 1, node.children[char]) else: return False"},{"question":"# Python Coding Assessment Objective Write a function `is_exactly_one_edit_away` that checks if two given strings are exactly one edit (insert, delete, replace a character) away. Function Signature ```python def is_exactly_one_edit_away(s: str, t: str) -> bool: ``` Input * `s` (str): the first string. * `t` (str): the second string. Output * (bool): Return `True` if the strings are exactly one edit distance apart, otherwise return `False`. Constraints * The length of the strings `s` and `t` will be between 0 and 10^4. * Each string consists of lowercase English alphabets only. Requirements and Assumptions * The function should operate with a time complexity of O(n), where n is the length of the shorter string. * Make sure to handle edge cases like empty strings or strings of differing lengths. Examples ```python assert is_exactly_one_edit_away(\\"abc\\", \\"ab\\") == True assert is_exactly_one_edit_away(\\"abc\\", \\"abcd\\") == True assert is_exactly_one_edit_away(\\"abc\\", \\"adc\\") == True assert is_exactly_one_edit_away(\\"abc\\", \\"a\\") == False assert is_exactly_one_edit_away(\\"abc\\", \\"abc\\") == False assert is_exactly_one_edit_away(\\"\\", \\"a\\") == True assert is_exactly_one_edit_away(\\"\\", \\"\\") == False ``` Hints * There can be three types of edits: insert a character, delete a character, or replace a character. * Process shorter string first and iterate, checking deviation points.","solution":"def is_exactly_one_edit_away(s: str, t: str) -> bool: len_s = len(s) len_t = len(t) # If the length difference is greater than 1, they can\'t be one edit away if abs(len_s - len_t) > 1: return False # Identify shorter and longer string if len_s > len_t: s, t = t, s len_s, len_t = len_t, len_s i = 0 j = 0 found_difference = False # Traverse both strings while i < len_s and j < len_t: if s[i] != t[j]: if found_difference: return False found_difference = True if len_s == len_t: i += 1 else: i += 1 j += 1 return True if found_difference or len_s != len_t else False"},{"question":"# Tree Diameter Calculation **Problem Statement**: Given a binary tree, write a function `diameter(root)` that returns the diameter of the tree. The diameter of a tree is defined as the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. The length of the path between two nodes is represented by the number of edges between them. **Function Signature**: ```python def diameter(root) -> int: ``` **Input**: - The input parameter `root` is the root node of a binary tree. You may assume that the TreeNode class and the utility functions for creating a binary tree are already defined. **Output**: - The function should return an integer representing the diameter of the tree. **Constraints**: - The number of nodes in the tree is in the range [0, 10^4]. - The value of each node is a unique integer within the range [-10^4, 10^4]. **Example**: Below is the structure of a sample tree. Example Tree: ``` 1 / 2 3 / 4 5 ``` - For the tree above, the diameter is 3 (the longest path is 4 -> 2 -> 1 -> 3 or 5 -> 2 -> 1 -> 3). **Example Function Call**: ```python root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) assert diameter(root) == 3 ``` # Requirements: 1. Implement the function `diameter(root)` which calculates the diameter of the given binary tree. 2. Ensure optimal performance both in terms of time and space complexity. # Tips: - You may need to use a helper function to recursively calculate heights and update the diameter. - Try to use a single traversal (O(n) approach) to calculate the diameter efficiently. - Make sure to handle edge cases like empty trees and trees with a single node.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def diameter(root) -> int: Returns the diameter of the binary tree rooted at \'root\'. def height_and_diameter(node): # Helper function that returns a tuple (height, diameter) if not node: return 0, 0 left_height, left_diameter = height_and_diameter(node.left) right_height, right_diameter = height_and_diameter(node.right) current_height = 1 + max(left_height, right_height) current_diameter = max(left_height + right_height, max(left_diameter, right_diameter)) return current_height, current_diameter _, diameter = height_and_diameter(root) return diameter"},{"question":"As a software engineer, you are often required to work with binary representations of numbers for various optimizations and checks. One common problem is determining whether a given number has an alternating bit pattern, i.e., two adjacent bits must always have different values. Objective Write a function `has_alternating_bits(n)` that takes a single positive integer `n` and returns `True` if the binary representation of `n` has alternating bits, otherwise, it returns `False`. Input * An integer `n` (1 ≤ n ≤ 2^{31} − 1). Output * A boolean value (`True` or `False`). Examples 1. Input: `n = 5` - Output: `True` - Explanation: The binary representation of 5 is `101`, which has alternating bits. 2. Input: `n = 7` - Output: `False` - Explanation: The binary representation of 7 is `111`, which does not have alternating bits. 3. Input: `n = 11` - Output: `False` - Explanation: The binary representation of 11 is `1011`, which does not have alternating bits. 4. Input: `n = 10` - Output: `True` - Explanation: The binary representation of 10 is `1010`, which has alternating bits. Constraints 1. Ensure your solution is efficient with respect to both time and space. 2. You may use a helper function if necessary, but avoid any in-built functions that directly solve the problem. Performance Requirements - The solution should ideally be optimized to consider minimal operations proportional to the bit-length of the number. Craft a function that meets these requirements elegantly and correctly. Test against various edge cases and scenarios to verify robustness. ```python def has_alternating_bits(n: int) -> bool: # Implement your solution here pass ```","solution":"def has_alternating_bits(n: int) -> bool: Checks if the binary representation of the given number n has alternating bits. :param n: An integer (1 ≤ n ≤ 2^31 − 1) :return: True if the binary representation has alternating bits, otherwise False # XOR the number with itself right-shifted by 1 xor_n = n ^ (n >> 1) # (xor_n + 1) should be a power of 2 if xor_n has all 1s (binary form) return (xor_n & (xor_n + 1)) == 0"},{"question":"Enhanced Hierarchical Tree Printer Scenario You are tasked with presenting hierarchical data in a more structured and readable format. The organization of a company, which contains multiple levels of employees and their respective areas, needs to be clearly printed. Task Write a function called `enhanced_tree_print` that processes a given dictionary representing a hierarchical tree and prints it in a structured manner. Each node should identify its parent-child relationship clearly with an appropriate indentation to signify depth in the hierarchy. Function Signature ```python def enhanced_tree_print(tree: dict) -> None: pass ``` Input * A dictionary `tree` where keys are strings, and values are lists containing strings, integers, or other dictionaries. Output Format * The function should print the hierarchy starting from the top level with clear indents representing each level of depth. * Example structure: ``` Adam -> Book: 4 -> Computer -> Level 1: 3 -> Level 2: 7 Bill -> Computer -> Level 1: 5 -> Level 2: 6 -> Sports: 1 Jill -> Sports: 3 Quin -> Book: 5 -> TV: 2 ``` Constraints * All keys and sub-elements in the tree are either: * Strings (representing node names or attributes) * Integers (representing attribute values) * Dictionaries (representing nested nodes) Example ```python sample_tree = { \'Adam\': [\'Book: 4\', {\'Computer\': [3, 7]}], \'Bill\': [{\'Computer\': [5, 6]}, \'Sports: 1\'], \'Jill\': [\'Sports: 3\'], \'Quin\': [\'Book: 5\', \'TV: 2\'] } enhanced_tree_print(sample_tree) ``` Expected Output: ``` Adam -> Book: 4 -> Computer -> Level 1: 3 -> Level 2: 7 Bill -> Computer -> Level 1: 5 -> Level 2: 6 -> Sports: 1 Jill -> Sports: 3 Quin -> Book: 5 -> TV: 2 ``` Additional Notes * You may assume that the depth of hierarchy does not exceed 5 levels. * Pay particular attention to ensure clarity and readability of the printed structure.","solution":"def enhanced_tree_print(tree: dict, indent: str = \\"\\") -> None: for key, value in tree.items(): print(f\\"{indent}{key}\\") if isinstance(value, list): for item in value: if isinstance(item, dict): enhanced_tree_print(item, indent + \\" \\") else: print(f\\"{indent} -> {item}\\") # Sample run sample_tree = { \'Adam\': [\'Book: 4\', {\'Computer\': [\'Level 1: 3\', \'Level 2: 7\']}], \'Bill\': [{\'Computer\': [\'Level 1: 5\', \'Level 2: 6\']}, \'Sports: 1\'], \'Jill\': [\'Sports: 3\'], \'Quin\': [\'Book: 5\', \'TV: 2\'] } # Uncomment below to see the output when run directly # enhanced_tree_print(sample_tree)"},{"question":"Given an n x n matrix represented as a 2D list, write a function that computes its inverse. Your function should account for edge cases, such as non-square matrices and singular matrices (matrices with a determinant of zero). If such cases are encountered, your function should handle it gracefully by returning a specific indicator matrix. Function Signature ```python def compute_matrix_inverse(matrix: List[List[float]]) -> List[List[float]]: ``` Input - `matrix`: A list of lists of floats representing an n x n matrix. Output - Returns the inverse of the given matrix if it exists, else returns specific error indicator matrices: - [[-1]] if the input is not a matrix. - [[-2]] if the matrix is not square. - [[-3]] if the matrix is too small to be inverted (0x0 or 1x1). - [[-4]] if the matrix is square but singular (determinant is 0). Constraints - The matrix will contain up to 100 rows and columns. Performance Requirements - Your solution should be efficient enough to handle matrices up to 100 x 100 in a reasonable time. # Example Input ```python matrix = [ [4, 7], [2, 6] ] ``` Output ```python [ [0.6, -0.7], [-0.2, 0.4] ] ``` # Instructions 1. Validate the input matrix. 2. Implement helper functions to compute the determinant, generate minors, cofactors, and the adjugate matrix. 3. Multiply the adjugate matrix by the reciprocal of the determinant. 4. Handle edge cases and error conditions as defined above. # Note You are not allowed to use any external libraries for matrix operations. Implement all necessary computations from scratch.","solution":"from typing import List def determinant(matrix: List[List[float]]) -> float: n = len(matrix) if n == 1: return matrix[0][0] if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(n): det += ((-1) ** c) * matrix[0][c] * determinant(minor(matrix, 0, c)) return det def minor(matrix: List[List[float]], i: int, j: int) -> List[List[float]]: return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def cofactor(matrix: List[List[float]]) -> List[List[float]]: n = len(matrix) cofactors = [] for i in range(n): cofactorRow = [] for j in range(n): minorDet = determinant(minor(matrix, i, j)) cofactorRow.append(((-1) ** (i + j)) * minorDet) cofactors.append(cofactorRow) return cofactors def transpose(matrix: List[List[float]]) -> List[List[float]]: return list(map(list, zip(*matrix))) def inverse(matrix: List[List[float]]) -> List[List[float]]: det = determinant(matrix) if det == 0: return [[-4]] cofactors = cofactor(matrix) adjugate = transpose(cofactors) return [[adjugate[i][j] / det for j in range(len(adjugate))] for i in range(len(adjugate))] def compute_matrix_inverse(matrix: List[List[float]]) -> List[List[float]]: if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): return [[-1]] n = len(matrix) if any(len(row) != n for row in matrix): return [[-2]] if n == 0 or n == 1: return [[-3]] return inverse(matrix)"},{"question":"Given the preorder and postorder traversal arrays of a full binary tree, write a Python function `construct_tree(pre, post)` that reconstructs the binary tree and returns its inorder traversal as a list. # Input - `pre`: A list of integers representing the preorder traversal of a full binary tree. - `post`: A list of integers representing the postorder traversal of the same full binary tree. # Output - Return a list of integers which represents the inorder traversal of the reconstructed binary tree. # Constraints 1. `1 <= len(pre), len(post) <= 1000` 2. Each value in the traversal arrays is unique. 3. The binary tree is a full binary tree. # Example Input ```python pre = [1, 2, 4, 8, 9, 5, 3, 6, 7] post = [8, 9, 4, 5, 2, 6, 7, 3, 1] ``` Output ```python [8, 4, 9, 2, 5, 1, 6, 3, 7] ``` # Note Write an efficient implementation that minimizes unnecessary calculations and adheres to the stated constraints.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def construct_tree_from_pre_post(pre, post): if not pre or not post: return None root = TreeNode(pre[0]) if len(pre) == 1: return root left_root_val = pre[1] L = post.index(left_root_val) + 1 root.left = construct_tree_from_pre_post(pre[1:L+1], post[:L]) root.right = construct_tree_from_pre_post(pre[L+1:], post[L:-1]) return root def inorder_traversal(root): if not root: return [] return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) def construct_tree(pre, post): root = construct_tree_from_pre_post(pre, post) return inorder_traversal(root)"},{"question":"Context You are assigned a task to optimize an inventory allocation system for a delivery service. One of the critical components involves breaking down large orders into the smallest possible shipment sizes, where shipment sizes must be perfect squares (e.g., 1, 4, 9, 16, etc.). To effectively manage inventory and minimize shipping costs, your task requires determining the minimum number of shipment sizes (perfect squares) needed to fulfill an order. Task Write a function named `min_perfect_squares` that takes a single integer `num` (1 ≤ num ≤ 10^6) representing the total size of an order, and returns the minimum number of perfect squares that sum up to `num`. Input - `num`: An integer (1 ≤ num ≤ 10^6) representing the order size. Output - An integer between 1 and 4 representing the minimum number of perfect squares needed to sum to `num`. Constraints - The function must handle the input size efficiently and provide the result in a reasonable time frame. - Solutions should consider performance optimizations for edge cases and large input sizes. Performance Requirements - Time complexity should be approximately O(sqrt(n)) where n is the input number. - Minimize space complexity to constant extra space, O(1). Example ```python >>> min_perfect_squares(9) 1 >>> min_perfect_squares(10) 2 >>> min_perfect_squares(12) 3 >>> min_perfect_squares(31) 4 ``` Your task is to implement the `min_perfect_squares` function correctly and efficiently.","solution":"import math def min_perfect_squares(num): Returns the minimum number of perfect squares that sum up to num. if num <= 0: raise ValueError(\\"Input must be a positive integer.\\") # Fast solution for perfect squares if int(math.sqrt(num)) ** 2 == num: return 1 # Check if the number can be expressed as the sum of two perfect squares for i in range(1, int(math.sqrt(num)) + 1): remainder = num - i * i if int(math.sqrt(remainder)) ** 2 == remainder: return 2 # Check if the number can be expressed as the sum of three perfect squares for i in range(1, int(math.sqrt(num)) + 1): for j in range(1, int(math.sqrt(num - i * i)) + 1): remainder = num - i * i - j * j if int(math.sqrt(remainder)) ** 2 == remainder: return 3 # If not, by the 4-square theorem (Lagrange\'s Four Square Theorem), it must be a sum of four perfect squares return 4"},{"question":"# Context You work for a software company specializing in embedded systems where data serialization and deserialization are crucial for device communication. To ensure that your system handles all edge cases, your task is to improve and extend the provided byte conversion functions. # Task You are required to enhance the existing `int_to_bytes_big_endian`, `bytes_big_endian_to_int`, `int_to_bytes_little_endian`, and `bytes_little_endian_to_int` functions to handle both positive and negative integers efficiently. While doing so, ensure the handling of zero and optimize any potential inefficiencies. # Requirements: 1. **int_to_bytes_big_endian(num: int) -> bytes** * Converts an integer to bytes in big-endian format. * Handles both positive and negative integers. * Should optimize space usage, especially for very small or very large numbers. 2. **bytes_big_endian_to_int(bytestr: bytes) -> int** * Converts a byte sequence in big-endian format back to an integer. * Should handle bytes representing both positive and negative integers. 3. **int_to_bytes_little_endian(num: int) -> bytes** * Converts an integer to bytes in little-endian format. * Handles both positive and negative integers. * Should optimize space usage, especially for very small or very large numbers. 4. **bytes_little_endian_to_int(bytestr: bytes) -> int** * Converts a byte sequence in little-endian format back to an integer. * Should handle bytes representing both positive and negative integers. # Constraints: * Input integers lie in the range of typical 32-bit (4-byte) and 64-bit (8-byte) representations. * Byte sequences must handle typical system limitations and be efficiently processed. * Ensure zero conversion does not produce erroneous empty bytes. # Sample Inputs and Outputs: ```python # Example for big endian: assert int_to_bytes_big_endian(0) == b\'x00\' assert int_to_bytes_big_endian(255) == b\'xff\' assert int_to_bytes_big_endian(-255) == b\'xffx01\' assert bytes_big_endian_to_int(b\'xffx01\') == -255 assert bytes_big_endian_to_int(b\'xff\') == 255 assert bytes_big_endian_to_int(b\'x00\') == 0 # Example for little endian: assert int_to_bytes_little_endian(0) == b\'x00\' assert int_to_bytes_little_endian(255) == b\'xff\' assert int_to_bytes_little_endian(-255) == b\'x01xff\' assert bytes_little_endian_to_int(b\'x01xff\') == -255 assert bytes_little_endian_to_int(b\'xff\') == 255 assert bytes_little_endian_to_int(b\'x00\') == 0 ``` # Hints: * Consider the two’s complement representation for handling negative integers. * Carefully handle zero-byte conversions to avoid empty byte sequences.","solution":"def int_to_bytes_big_endian(num: int) -> bytes: Converts an integer to bytes in big-endian format. if num == 0: return b\'x00\' byte_length = (num.bit_length() + 8) // 8 return num.to_bytes(byte_length, \'big\', signed=True) def bytes_big_endian_to_int(bytestr: bytes) -> int: Converts a byte sequence in big-endian format back to an integer. return int.from_bytes(bytestr, \'big\', signed=True) def int_to_bytes_little_endian(num: int) -> bytes: Converts an integer to bytes in little-endian format. if num == 0: return b\'x00\' byte_length = (num.bit_length() + 8) // 8 return num.to_bytes(byte_length, \'little\', signed=True) def bytes_little_endian_to_int(bytestr: bytes) -> int: Converts a byte sequence in little-endian format back to an integer. return int.from_bytes(bytestr, \'little\', signed=True)"},{"question":"Implement Pigeonhole Sort You are given an array of integers and your task is to implement the Pigeonhole Sort algorithm to sort the array in ascending order. This sorting algorithm is particularly efficient when the number of keys (unique values) is not significantly smaller than the number of elements. Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` Input - `arr`: A list of integers (1 <= len(arr) <= 10^5) Output - Return a sorted list of integers. Constraints - Elements in `arr` can be both positive and negative. - Ideally handle edge cases where the array size is small or all elements are identical. Example ```python assert pigeonhole_sort([8, 3, 2, 7, 4, 6, 8]) == [2, 3, 4, 6, 7, 8, 8] assert pigeonhole_sort([0, -10, 5, 7, -3, 2]) == [-10, -3, 0, 2, 5, 7] assert pigeonhole_sort([1]) == [1] ``` # Context You have been asked to develop a sorting function to process sensor data collected from various points in a temperature monitoring system. These sensors report temperature readings, which need to be sorted to analyze the data accurately. Performance Requirements The solution should aim for an optimal time complexity of O(n + Range) where `n` is the number of elements and `Range` is the difference between the maximum and minimum values.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: if not arr: return [] # Find the minimum and maximum values in the array min_val = min(arr) max_val = max(arr) # Calculate the range size = max_val - min_val + 1 # Create pigeonholes holes = [0] * size # Populate the pigeonholes for num in arr: holes[num - min_val] += 1 # Create sorted array sorted_arr = [] for index in range(size): while holes[index] > 0: sorted_arr.append(index + min_val) holes[index] -= 1 return sorted_arr"},{"question":"# Question: Implement an Optimized Bubble Sort You are required to implement an optimized version of the bubble sort algorithm. The optimization involves reducing the number of iterations once the array is already sorted. This version should continue to check the array but break out of the main loop once no swaps have been made in a full pass through the array, indicating that the array is sorted. Input Format: - A list of integers `arr` (0 <= len(arr) <= 10^6), where each integer lies in the range [-10^6, 10^6]. Output Format: - A list of integers representing the sorted array. Function Signature: ```python def optimized_bubble_sort(arr: List[int]) -> List[int]: ``` Constraints: - You should not use any built-in sorting functions (`sorted()`, `.sort()`, etc.). - Your solution should be able to handle large inputs efficiently. Example: ```python # Example 1 input: [64, 34, 25, 12, 22, 11, 90] output: [11, 12, 22, 25, 34, 64, 90] # Example 2 input: [] output: [] # Example 3 input: [1] output: [1] # Example 4 input: [5, -1, 0, 3, 8, 7] output: [-1, 0, 3, 5, 7, 8] ``` Good luck, and make sure your implementation is efficient for large input sizes!","solution":"from typing import List def optimized_bubble_sort(arr: List[int]) -> List[int]: Perform an optimized bubble sort on the list `arr`. The function reduces the number of iterations once the array is already sorted. n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if not swapped: break return arr"},{"question":"Scenario Factorials are important in various fields including mathematics, computer science, and combinatorics. In this task, you are required to demonstrate your understanding of recursive and iterative approaches to compute factorials along with an optional modulus operation. Task Write two functions: `factorial_iterative(n, mod=None)` and `factorial_recursive(n, mod=None)` that compute the factorial of a given non-negative integer `n`. If `mod` is provided, the result should be the factorial modulo `mod`. Input * An integer `n` (0 leq n leq 10^4). * An optional integer `mod` (1 leq mod leq 10^9). Output * Return the factorial of `n`. If `mod` is provided, return `n! % mod`. Constraints * If `n` is not a non-negative integer, raise a `ValueError` with the message \\"\'n\' must be a non-negative integer.\\" * If `mod` is provided and is not a positive integer, raise a `ValueError` with the message \\"\'mod\' must be a positive integer.\\" Examples ```python assert factorial_iterative(5) == 120 assert factorial_iterative(5, 3) == 0 assert factorial_iterative(0) == 1 assert factorial_recursive(5) == 120 assert factorial_recursive(5, 3) == 0 assert factorial_recursive(0) == 1 ``` You are required to ensure that both your iterative and recursive implementations efficiently handle the factorial computation and correctly apply the optional modulus operation.","solution":"def factorial_iterative(n, mod=None): Compute the factorial of n iteratively. If mod is provided, return n! % mod. if not isinstance(n, int) or n < 0: raise ValueError(\\"\'n\' must be a non-negative integer.\\") if mod is not None and (not isinstance(mod, int) or mod <= 0): raise ValueError(\\"\'mod\' must be a positive integer.\\") result = 1 for i in range(1, n + 1): result *= i if mod: result %= mod return result def factorial_recursive(n, mod=None): Compute the factorial of n recursively. If mod is provided, return n! % mod. if not isinstance(n, int) or n < 0: raise ValueError(\\"\'n\' must be a non-negative integer.\\") if mod is not None and (not isinstance(mod, int) or mod <= 0): raise ValueError(\\"\'mod\' must be a positive integer.\\") def helper(m, mod): if m == 0 or m == 1: return 1 result = m * helper(m - 1, mod) if mod: result %= mod return result return helper(n, mod)"},{"question":"Coding Assessment Question # Context You have been hired to develop a search dictionary system for a typing-assistance software. Users should be able to add their custom words to the dictionary and search them using literal words or patterns that include a \\".\\" character. The `.` character should match any letter. # Task Implement a class `SearchDictionary` that allows users to add words to the dictionary and search them efficiently with or without wildcards. # Requirements 1. Implement the `add_word(self, word: str) -> None` method: - Adds a new word to the dictionary. 2. Implement the `search(self, word: str) -> bool` method: - Searches the dictionary for a given word. - Returns `True` if the word exists; `False` otherwise. - Supports \'.\' character in the search term, where \'.\' can match any letter. # Example Usage ```python dictionary = SearchDictionary() dictionary.add_word(\\"bad\\") dictionary.add_word(\\"dad\\") dictionary.add_word(\\"mad\\") print(dictionary.search(\\"pad\\")) # Output: False print(dictionary.search(\\"bad\\")) # Output: True print(dictionary.search(\\".ad\\")) # Output: True print(dictionary.search(\\"b..\\")) # Output: True print(dictionary.search(\\"b.d\\")) # Output: True print(dictionary.search(\\"z..\\")) # Output: False ``` # Constraints - All words are lowercase containing only letters `\'a\'` to `\'z\'`. - Input string lengths for add and search can be up to 1000. - At most 50000 calls will be made to `add_word` and `search` in total. # Performance Requirements Your implementation should aim for efficient time complexity considering the constraints, attempting to balance between memory usage and search speed.","solution":"import re class SearchDictionary: def __init__(self): self.words = [] def add_word(self, word: str) -> None: self.words.append(word) def search(self, word: str) -> bool: regex = re.compile(\'^\' + word + \'\') for w in self.words: if regex.match(w): return True return False"},{"question":"# Sparse Matrix Multiplication Problem Statement You are given two sparse matrices A and B in the form of lists of lists (2D arrays). Implement a function `sparse_matrix_multiply` which multiplies matrix A with matrix B and returns the resultant matrix. Since the matrices are sparse, focus on optimizing the multiplication process by efficiently handling non-zero elements only. Function Signature ```python def sparse_matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: pass ``` Input * `A` and `B`: Two 2D lists where: - The number of columns in A is equal to the number of rows in B. - Each element `A[i][j]` and `B[p][q]` is an integer. Output * Return a 2D list (matrix) which is the result of the multiplication of A and B. Constraints * 1 ≤ len(A), len(B) ≤ 1000 * 1 ≤ len(A[0]), len(B[0]) ≤ 1000 * -1000 ≤ A[i][j], B[p][q] ≤ 1000 Example ```python A = [ [1, 0, 0], [-1, 0, 3] ] B = [ [7, 0, 0], [0, 0, 0], [0, 0, 1] ] output = sparse_matrix_multiply(A, B) # Output is: # [ # [7, 0, 0], # [-7, 0, 3] # ] ``` Detailed Explanation 1. For each non-zero element in A, find its position. 2. Multiply this element with corresponding non-zero elements in B. 3. Accumulate their products at the appropriate position in the resultant matrix. Notes * Carefully handle non-zero elements to ensure optimized time and space complexity. * Validate dimensions to avoid mismatched multiplication.","solution":"from typing import List def sparse_matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Multiplies two sparse matrices A and B and returns the resultant matrix. # Number of rows and columns in the result matrix result_rows = len(A) result_cols = len(B[0]) B_rows = len(B) # Initialize result matrix with all zeroes result = [[0] * result_cols for _ in range(result_rows)] # For each row in A for i in range(result_rows): for k in range(B_rows): if A[i][k] != 0: for j in range(result_cols): if B[k][j] != 0: result[i][j] += A[i][k] * B[k][j] return result"},{"question":"**Problem Statement**: You are asked to write a function that calculates the number of ways to choose `r` items from `n` items (nCr) using dynamic programming techniques. You need to create an efficient solution that handles large inputs by avoiding redundant calculations. Ensure that your solution is robust and handles edge cases correctly. **Function Signature:** ```python def calculate_combinations(n: int, r: int) -> int: pass ``` **Input:** - `n`: An integer representing the total number of items. (0 ≤ n ≤ 10^5) - `r`: An integer representing the number of items to choose. (0 ≤ r ≤ 10^5) **Output:** - An integer representing the number of combinations (nCr). **Constraints:** - `0 ≤ r ≤ n ≤ 10^5` - The function should run efficiently for large values of `n` and `r`. - Avoid usage of recursion to prevent stack overflow issues and ensure the function runs within feasible time limits. **Example**: ```python print(calculate_combinations(5, 2)) # Output: 10 print(calculate_combinations(10, 3)) # Output: 120 ``` **Requirements**: 1. Implement an efficient solution with dynamic programming. 2. Handle edge cases where `r` is 0 or equal to `n`. 3. Ensure the function works within the constraints without causing memory issues. **Scenario**: Imagine you are developing a feature in a combinatorial analysis software that helps users calculate the number of possible configurations (combinations) of a set of items for given n and r values. Efficiency and accuracy are critical as the software will often handle large inputs.","solution":"def calculate_combinations(n: int, r: int) -> int: Calculate number of ways to choose r items from n items using dynamic programming. if r > n: return 0 if r == 0 or r == n: return 1 # Optimize the value of r r = min(r, n - r) # Create an array to store intermediate results C = [0] * (r + 1) C[0] = 1 # There\'s one way to choose 0 items from n items for i in range(1, n + 1): for j in range(min(i, r), 0, -1): C[j] = C[j] + C[j - 1] return C[r]"},{"question":"# Binary Search Tree Implementation Scenario You are tasked with implementing a Binary Search Tree (BST) for a new data management system. The BST needs to support basic operations such as insertion, search, and in-order traversal, ensuring that the properties of the BST are maintained. Task Implement the following functions for the BST: 1. `insert(node, value)`: Inserts a new value into the BST rooted at `node`. 2. `search(node, value)`: Searches for a value in the BST rooted at `node`. 3. `in_order_traversal(node)`: Returns a list of values representing the in-order traversal of the BST. Input and Output Formats * The `insert(node, value)` function should place the `value` in its correct position in the BST rooted at `node`. * The `search(node, value)` function should return `True` if the value exists in the tree, else `False`. * The `in_order_traversal(node)` function should return a list of values in ascending order. Constraints * Values inserted in the BST are integers. * No duplicate values will be inserted into the BST. Example ```python # Example usage: root = TreeNode(10) insert(root, 5) insert(root, 15) insert(root, 2) insert(root, 7) print(search(root, 7)) # Output: True print(search(root, 3)) # Output: False print(in_order_traversal(root)) # Output: [2, 5, 7, 10, 15] ``` Hint - Use recursion to implement the `insert` and `search` operations correctly while maintaining the BST properties. Implement the BST class and the required functions below: ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def insert(node, value): # Your code here def search(node, value): # Your code here def in_order_traversal(node): # Your code here ```","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def insert(node, value): if node is None: return TreeNode(value) if value < node.val: node.left = insert(node.left, value) else: node.right = insert(node.right, value) return node def search(node, value): if node is None: return False if value == node.val: return True elif value < node.val: return search(node.left, value) else: return search(node.right, value) def in_order_traversal(node): if node is None: return [] return in_order_traversal(node.left) + [node.val] + in_order_traversal(node.right)"},{"question":"You are given a binary search tree (BST) with nodes containing unique integer values. Your task is to determine the lowest common ancestor (LCA) of two given nodes in the BST. The LCA of two nodes p and q in a BST is defined as the lowest node that has both p and q as descendants, where a node can be a descendant of itself. # Function Definition Implement the function `lowest_common_ancestor(root, p, q)`: * **Input**: * `root` (Node): The root node of the BST. * `p` (Node): The first node. * `q` (Node): The second node. * **Output**: * `Node`: The LCA node of the two given nodes. # Example ```markdown Consider a BST with the following structure: _______6______ / ___2__ ___8__ / / 0 _4 7 9 / 3 5 Example 1: Input: root = Node(6), p = Node(2), q = Node(8) Output: Node(6) Explanation: The lowest common ancestor of nodes 2 and 8 is 6. Example 2: Input: root = Node(6), p = Node(2), q = Node(4) Output: Node(2) Explanation: The lowest common ancestor of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. ``` # Constraints 1. All node values are unique. 2. p and q are different and both values will exist in the BST. # Additional Information Consider edge cases like when one node is the root itself, one of the nodes being the ancestor of the other, or trees that are highly unbalanced. Ensure your solution can handle these scenarios efficiently.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lowest_common_ancestor(root, p, q): Determines the lowest common ancestor (LCA) of two given nodes in a BST. Args: root (Node): The root node of the BST. p (Node): The first node. q (Node): The second node. Returns: Node: The LCA node of the two given nodes. # Traverse the tree current = root while current: # If both nodes are smaller than current node, move to the left child if p.val < current.val and q.val < current.val: current = current.left # If both nodes are larger than current node, move to the right child elif p.val > current.val and q.val > current.val: current = current.right else: # We have found the split point (LCA node) return current"},{"question":"You are tasked with identifying the nth digit in an infinitely long sequence of positive integers concatenated together. The sequence looks like this: \\"1234567891011121314...\\" Implement the function `find_nth_digit(n)` that returns the nth digit in the sequence of numbers. # Function Signature ```python def find_nth_digit(n: int) -> int: Returns the nth digit in the infinite sequence of positive integers pass ``` # Input - `n` (1 <= n <= 2 * 10^9): The position in the sequence (1-based index). # Output - An integer representing the nth digit in the sequence. # Example ```python find_nth_digit(3) # Output: 3 find_nth_digit(11) # Output: 0 find_nth_digit(15) # Output: 2 ``` # Explanation 1. In the sequence \\"123456789101112...\\", the 3rd digit is \'3\'. 2. The 11th digit is \'0\', which is the first zero in the number 10. 3. The 15th digit is \'2\', which corresponds to the digit from the number 12. # Constraints and Considerations - Ensure your solution is optimized for very large values of `n`. - Think about the range transitions (e.g., from numbers with one digit to numbers with two digits). - Efficient integer computations and string manipulations are essential to remain within performance requirements.","solution":"def find_nth_digit(n: int) -> int: Returns the nth digit in the infinite sequence of positive integers digit_length = 1 count = 9 start = 1 # Find the range in which the nth digit falls while n > digit_length * count: n -= digit_length * count digit_length += 1 count *= 10 start *= 10 # Find the exact number that contains the nth digit start += (n - 1) // digit_length s = str(start) # Find the exact digit in this number return int(s[(n - 1) % digit_length])"},{"question":"# Coding Assessment Task: Implement a Custom Hash Table with Specific Features You\'ve been tasked with implementing a hash table from scratch with added capabilities. Your hash table should allow for efficient insertions, deletions, and lookups. Additionally, it should support dynamic resizing and handle collisions using linear probing. Requirements & Specifications: 1. **Initialization**: - Create a new, empty hash table with an initial size of 16. - Provide a method that allows for dynamic resizing. 2. **Insertions**: - Implement a method to add or update key-value pairs. This should resize the table if the load factor exceeds 0.75. 3. **Deletions**: - Implement a method to delete key-value pairs by a given key. 4. **Lookups**: - Implement a method to retrieve values by given keys. - If the key is absent, the method should return `None`. 5. **Additional Operations**: - Implement a method to get the number of key-value pairs stored in the table. - Implement methods to check if a key exists in the table. Input/Output Format: - **Insertions**: `put(key, value)` - Adds/Updates `key` with `value`. - **Deletions**: `delete(key)` - Deletes the key-value pair corresponding to `key`. - **Lookups**: `get(key)` - Returns the value associated with `key`, or `None` if the key does not exist. - **Count**: `__len__()` - Returns the number of key-value pairs in the table. - **Existence**: `__contains__(key)` - Returns `True` if `key` is in the table, `False` otherwise. Constraints: - Keys are non-negative integers. - Values can be any type (int, str, float, etc.). # Example: ```python ht = CustomHashTable() ht.put(1, \\"value1\\") ht.put(2, \\"value2\\") print(ht.get(1)) # Output: \\"value1\\" print(ht.get(3)) # Output: None ht.delete(1) print(ht.get(1)) # Output: None print(len(ht)) # Output: 1 print(2 in ht) # Output: True ``` Implement the `CustomHashTable` class using the above specifications and methods: ```python class CustomHashTable: # Implement the required methods here def __init__(self): pass def put(self, key, value): pass def get(self, key): pass def delete(self, key): pass def __len__(self): pass def __contains__(self, key): pass # Example Usage ht = CustomHashTable() ht.put(1, \\"value1\\") ht.put(2, \\"value2\\") print(ht.get(1)) # Output: \\"value1\\" print(ht.get(3)) # Output: None ht.delete(1) print(ht.get(1)) # Output: None print(len(ht)) # Output: 1 print(2 in ht) # Output: True ```","solution":"class CustomHashTable: def __init__(self): self._initial_size = 16 self._load_factor_threshold = 0.75 self._size = 0 self._table = [None] * self._initial_size def _hash(self, key): return key % len(self._table) def _resize(self): old_table = self._table new_capacity = len(old_table) * 2 self._table = [None] * new_capacity self._size = 0 for entry in old_table: if entry is not None: self.put(entry[0], entry[1]) def put(self, key, value): if self._size >= len(self._table) * self._load_factor_threshold: self._resize() idx = self._hash(key) while self._table[idx] is not None and self._table[idx][0] != key: idx = (idx + 1) % len(self._table) if self._table[idx] is None: self._size += 1 self._table[idx] = (key, value) def get(self, key): idx = self._hash(key) start_idx = idx while self._table[idx] is not None: if self._table[idx][0] == key: return self._table[idx][1] idx = (idx + 1) % len(self._table) if idx == start_idx: break return None def delete(self, key): idx = self._hash(key) start_idx = idx while self._table[idx] is not None: if self._table[idx][0] == key: self._table[idx] = None self._size -= 1 subsequent_idx = (idx + 1) % len(self._table) while self._table[subsequent_idx] is not None: k, v = self._table[subsequent_idx] self._table[subsequent_idx] = None self._size -= 1 self.put(k, v) subsequent_idx = (subsequent_idx + 1) % len(self._table) break idx = (idx + 1) % len(self._table) if idx == start_idx: break def __len__(self): return self._size def __contains__(self, key): return self.get(key) is not None"},{"question":"# FizzBuzz Advanced Extension Given the classic FizzBuzz challenge, enhance its functionality to include additional rules and constraints. You are required to write a function `extended_fizzbuzz(n, rules)` that returns a list of strings and integers according to the rules provided. Input: - `n`: An integer (1 ≤ n ≤ 10^6). - `rules`: A list of tuples where each tuple contains two elements: - An integer `k` which indicates the divisor. - A string `replacement` that the number should be replaced with if it is a multiple of `k`. Output: - A list of integers and strings of length `n` according to the following rules: - For each number from 1 to `n`: - For each tuple `(k, replacement)` in the `rules` list, if the number is divisible by `k`, replace it with `replacement`. - If the number is divisible by multiple `k` values in `rules`, concatenate the corresponding `replacement` strings. - If the number is not divisible by any `k` in `rules`, leave it as is. Constraints: - All `k` values in `rules` are unique and between 1 and 100. - The concatenated length of the replacement strings for any number will not exceed 100 characters. Example: ```python # Example rules and invocation rules = [(3, \\"Fizz\\"), (5, \\"Buzz\\"), (7, \\"Bazz\\")] n = 15 print(extended_fizzbuzz(n, rules)) # Expected output: [1, 2, \\"Fizz\\", 4, \\"Buzz\\", \\"Fizz\\", \\"Bazz\\", 8, \\"Fizz\\", \\"Buzz\\", 11, \\"Fizz\\", 13, \\"Bazz\\", \\"FizzBuzz\\"] ``` Function Signature: ```python def extended_fizzbuzz(n: int, rules: list[tuple[int, str]]) -> list: pass ```","solution":"def extended_fizzbuzz(n, rules): Returns a list of integers and strings according to the FizzBuzz rules provided. :param n: An integer specifying the range from 1 to n (inclusive). :param rules: A list of tuples where each tuple contains an integer divisor and a string replacement. :return: A list of integers and strings according to the provided rules. result = [] for i in range(1, n + 1): replacement_str = \'\' for k, replacement in rules: if i % k == 0: replacement_str += replacement if replacement_str: result.append(replacement_str) else: result.append(i) return result"},{"question":"# Intersection of Two Singly Linked Lists **Problem Description**: You need to find the intersection node of two given singly linked lists. The intersection node is defined based on node reference, not node value. Each singly linked list is represented by individual head nodes. Implement a function `find_intersection(head1, head2) -> Node` that finds the intersection (common part) node and returns it. **Function Signature**: ```python class Node: def __init__(self, val=None): self.val = val self.next = None def find_intersection(head1: Node, head2: Node) -> Node: pass ``` **Input**: - `head1`: Node - The head node of the first singly linked list. - `head2`: Node - The head node of the second singly linked list. **Output**: - Returns the intersection Node if it exists, otherwise returns `None`. **Constraints**: - The linked lists must be acyclic. - The linked lists may or may not intersect. - Node values are not unique. **Examples**: 1. Example 1: ```plaintext List 1: 1 -> 2 -> 3 6 -> 7 / List 2: 4 -> 5 ``` Should return the node with value `6`. 2. Example 2: ```plaintext List 1: 1 -> 2 -> 3 List 2: 4 -> 5 -> 6 ``` Should return `None` as there is no intersection. **Edge Cases**: - One or both lists are empty. - Lists of different lengths. - Intersection at the very first node or not at all. # Note: - Avoid changing original lists during the search. - Efficient handling of various conditions is expected. **Solution Requirements**: Write the `find_intersection` function with performance considerations and add test cases to validate your implementation.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def find_intersection(head1, head2): if not head1 or not head2: return None def get_length(head): length = 0 while head: length += 1 head = head.next return length length1 = get_length(head1) length2 = get_length(head2) # Align both heads if length1 > length2: for _ in range(length1 - length2): head1 = head1.next else: for _ in range(length2 - length1): head2 = head2.next # Traverse together to find intersection while head1 and head2: if head1 == head2: return head1 head1 = head1.next head2 = head2.next return None"},{"question":"# Exchange Sort Implementation and Optimization Challenge **Scenario**: You are given an array of integers that represent the grades of students in a class. The grades need to be sorted in ascending order to determine class rankings. The school also wants to minimize the time it takes to sort these grades. **Task**: Implement the Exchange Sort algorithm to sort the array of grades. Then, identify and implement any optimization(s) you believe can improve the sorting process. **Function Signature**: ```python def optimized_exchange_sort(arr: List[int]) -> List[int]: pass ``` **Input**: * `arr`: A list of integers where `0 <= len(arr) <= 10^4` and each integer `0 <= arr[i] <= 100`. **Output**: * A list of integers sorted in ascending order. **Constraints**: * Aim to optimize the sorting algorithm to handle larger data efficiently. * You must keep the core functionality of Exchange Sort but can introduce any optimization (such as early exits in loops) that could improve its performance. **Examples**: 1. Given `[5, 2, 9, 1, 5, 6]`, the output should be `[1, 2, 5, 5, 6, 9]`. 2. Given `[3, 3, 2, 1]`, the output should be `[1, 2, 3, 3]`. **Additional Performance Requirement**: * Your optimized solution should demonstrate clear improvements over the naive quadratic approach, especially on larger datasets.","solution":"from typing import List def optimized_exchange_sort(arr: List[int]) -> List[int]: Sorts an array using an optimized version of Exchange Sort. n = len(arr) for i in range(n-1): swapped = False for j in range(i+1, n): if arr[i] > arr[j]: # Swap elements arr[i], arr[j] = arr[j], arr[i] swapped = True if not swapped: # If no two elements were swapped in the inner loop, array is sorted break return arr"},{"question":"# Problem: Maximum Contiguous Subsequence Sum You are given an array of integers. Your task is to implement a function that finds the maximum sum of any contiguous sub-array within the given array. Function Signature ```python def max_contiguous_subsequence_sum(arr: List[int]) -> int: ``` Input * `arr`: A list of integers, where the length of the list is `n` (0 ≤ n ≤ 10^5) and each integer `-10^4 ≤ arr[i] ≤ 10^4`. Output * Return an integer, the maximum sum of any contiguous sub-array. If the array is empty, return 0. Constraints * The function should run in O(n) time complexity. * The function should use O(1) additional space. Scenario Imagine that you are analyzing daily temperature variations over a long period and you need to identify the period with the most significant positive temperature trend. However, the data includes both positive and negative fluctuations. You need an efficient algorithm to identify this period\'s maximum cumulative temperature increase. Example usage of Kadane’s Algorithm can solve this specific problem by finding the maximum sum of contiguous sub-sequence. Examples ```python # Example 1 arr = [-2, 3, 8, -1, 4] assert max_contiguous_subsequence_sum(arr) == 14 # Explanation: Sum of [3, 8, -1, 4]. # Example 2 arr = [-1, 1, 0] assert max_contiguous_subsequence_sum(arr) == 1 # Explanation: Sum of [1]. # Example 3 arr = [-1, -3, -4] assert max_contiguous_subsequence_sum(arr) == -1 # Explanation: The single largest element. # Example 4 arr = [] assert max_contiguous_subsequence_sum(arr) == 0 # Explanation: The array is empty. ```","solution":"from typing import List def max_contiguous_subsequence_sum(arr: List[int]) -> int: if not arr: # If the array is empty return 0 max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Stooge Sort Implementation **Context**: Stooge Sort is an interesting example of a recursive sorting algorithm. A fun fact is that its time complexity is quite poor compared to more practical algorithms like Quick Sort, Merge Sort, or even Bubble Sort. Despite this inefficiency, it serves as a great exercise in understanding recursion and algorithm analysis. # Task: You are required to implement the Stooge Sort algorithm. The function should sort an array of integers in non-decreasing order. # Function Signature: ```python def stooge_sort(arr: List[int], l: int, h: int) -> None: pass ``` # Input: - `arr`: a list of integers `arr[0...n-1]` where 1 ≤ n ≤ 10^3. - `l`: the starting index of the list portion to be sorted. - `h`: the ending index of the list portion to be sorted. # Output: - Sort the portion of the list `arr` from index `l` to index `h` in place, meaning you should not return a new list. # Constraints: - Do not use any built-in sorting functions (`sort`, `sorted`, etc.). - The function must be implemented recursively. - Assume that all array elements are integers between -10^6 and 10^6 inclusive. # Example: ```python array = [20, -30, 40, 5, 12, 90, 80] stooge_sort(array, 0, len(array) - 1) print(array) ``` Output: [-30, 5, 12, 20, 40, 80, 90] # Notes: Your implementation should follow the structure of the Stooge Sort algorithm provided earlier. Ensure to handle edge cases such as a single element array or array primarily sorted except for one element. Efficiency is not the focus here; understanding the recursive nature and correct implementation is.","solution":"from typing import List def stooge_sort(arr: List[int], l: int, h: int) -> None: if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: third = (h - l + 1) // 3 stooge_sort(arr, l, h - third) stooge_sort(arr, l + third, h) stooge_sort(arr, l, h - third)"},{"question":"# Nearest Neighbor Classification Challenge You are working on a simple recommendation system. Given a user\'s feature vector and a set of known user feature vectors with their associated categories, you need to classify the given user into one of these categories based on the nearest neighbor algorithm using Euclidean distance. Function Signature: ```python def classify_user(new_user: tuple, user_data: dict) -> str: pass ``` Input: - `new_user`: A tuple of numeric values representing the feature vector of the new user. - `user_data`: A dictionary where keys are tuples (numeric values representing known user feature vectors) and values are strings (categories of users). Output: - Returns the category (string) of the nearest neighbor. Constraints: - All feature vectors (tuples) will have the same length. - There will be at least one user in `user_data`. # Example: ```python new_user = (5, 3) user_data = { (1, 2): \\"Category A\\", (7, 8): \\"Category B\\", (4, 2): \\"Category C\\" } assert classify_user(new_user, user_data) == \\"Category C\\" ``` # Explanation: - The Euclidean distances are calculated as follows: - Distance to (1, 2): √((5-1)² + (3-2)²) = √16 + 1 = √17 ≈ 4.12 - Distance to (7, 8): √((5-7)² + (3-8)²) = √4 + 25 = √29 ≈ 5.39 - Distance to (4, 2): √((5-4)² + (3-2)²) = √1 + 1 = √2 ≈ 1.41 - The nearest neighbor is (4, 2) with a distance of approximately 1.41, which belongs to \\"Category C\\". Write the function `classify_user` that meets the given requirements.","solution":"def classify_user(new_user: tuple, user_data: dict) -> str: import math def euclidean_distance(point1, point2): return math.sqrt(sum([(point1[i] - point2[i]) ** 2 for i in range(len(point1))])) closest_user = None min_distance = float(\'inf\') for user, category in user_data.items(): distance = euclidean_distance(new_user, user) if distance < min_distance: min_distance = distance closest_user = category return closest_user"},{"question":"# Scenario You are tasked with implementing a special stack that, in addition to the usual stack operations, supports an extra operation `get_min` that returns the minimum element in the stack in O(1) time. # Problem Statement You must design a class `SpecialStack` that extends `ArrayStack` from the given code snippet and adds the method `get_min`. # Function Signature ```python class SpecialStack(ArrayStack): def get_min(self) -> int: pass ``` # Requirements 1. Implement the `SpecialStack` class with the following methods: * `push(value)`: Push the value onto the stack. * `pop()`: Pop the value from the stack. * `peek()`: Peek the current top value. * `is_empty()`: Check if the stack is empty. * `get_min()`: Return the minimum value in the stack. 2. Ensure that `get_min()` operates in O(1) time. # Input * No direct input to the function. The methods will be called by the testing framework. # Output * Expected output varies based on the method calls: * `push(value)`: No output. * `pop()`: Returns the top value. * `peek()`: Returns the current top value. * `is_empty()`: Returns a boolean. * `get_min()`: Returns the minimum value. # Constraints * The values to be pushed are valid integers. * The stack can contain a large number of elements. # Example Usage ```python s = SpecialStack() s.push(3) s.push(5) print(s.get_min()) # Output: 3 s.push(2) s.push(1) print(s.get_min()) # Output: 1 s.pop() print(s.get_min()) # Output: 2 s.pop() print(s.peek()) # Output: 5 print(s.is_empty()) # Output: False s.pop() s.pop() print(s.is_empty()) # Output: True ``` # Notes * Consider using an additional stack to keep track of the minimum values. * Ensure that your class handles edge cases, such as getting the minimum from an empty stack appropriately.","solution":"class ArrayStack: def __init__(self): self.stack = [] def push(self, value): self.stack.append(value) def pop(self): if not self.is_empty(): return self.stack.pop() else: return None def peek(self): if not self.is_empty(): return self.stack[-1] else: return None def is_empty(self): return len(self.stack) == 0 class SpecialStack(ArrayStack): def __init__(self): super().__init__() self.min_stack = [] def push(self, value): super().push(value) if len(self.min_stack) == 0 or value <= self.get_min(): self.min_stack.append(value) def pop(self): value = super().pop() if value is not None and value == self.get_min(): self.min_stack.pop() return value def get_min(self): if not self.min_stack: return None return self.min_stack[-1]"},{"question":"You are given a number `n` represented as an integer. Your task is to write a function `next_bigger(n)` that finds the next higher number which has the exact same set of digits as `n`. If no such number exists, return `-1`. The input and output for your function are specified as follows: **Function Signature:** ```python def next_bigger(n: int) -> int: ``` # Input - A single integer `n` where `1 <= n <= 10^9`. # Output - Return the next higher integer which has the exact same set of digits as `n`. - If no such number exists, return `-1`. # Constraints - The number of digits in `n` will not exceed 10. - The input number will be a positive integer without leading zeros. # Example Given the following inputs, your function should return: Example 1: ``` Input: 38276 Output: 38627 ``` Example 2: ``` Input: 99999 Output: -1 ``` # Notes: - Think of the problem as transforming `n` into the next highest permutation of its digits. - Consider edge cases such as numbers already in the highest permutation, numbers with multiple identical digits, etc.","solution":"def next_bigger(n: int) -> int: Returns the next higher number which has the exact same set of digits as `n`. If no such number exists, returns `-1`. digits = list(str(n)) length = len(digits) # Step 1: Find the first digit that can be made larger by swapping with a digit to its right for i in range(length - 2, -1, -1): if digits[i] < digits[i + 1]: break else: # If no such digit is found, we are at the highest permutation return -1 # Step 2: Find the smallest digit on the right side of `digits[i]` that is larger than `digits[i]` for j in range(length - 1, i, -1): if digits[j] > digits[i]: break # Step 3: Swap these two digits digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the sequence after position `i` to get the smallest possible permutation digits = digits[:i + 1] + digits[i + 1:][::-1] return int(\\"\\".join(digits))"},{"question":"Write a function `num_digits(n)` that determines the number of digits in the given integer `n`. Input * A single integer `n` where `-10^18 <= n <= 10^18`. Output * A single integer representing the number of digits in `n`. Example ```python assert num_digits(12345) == 5 assert num_digits(0) == 1 assert num_digits(-789) == 3 assert num_digits(1000000000000000000) == 19 ``` Constraints * You must handle negative and zero values correctly. * Time complexity should be O(1). # Notes * The function should use mathematical operations to determine the number of digits. * Avoid solutions based on string conversion due to potential inefficiencies or extra space use. # Implementation Implement `num_digits` using the following template: ```python import math def num_digits(n): # your code here ``` Ensure your solution correctly handles and provides accurate results for all edge cases and adheres to the given constraints.","solution":"def num_digits(n): Returns the number of digits in the given integer n. if n == 0: return 1 elif n < 0: n = -n count = 0 while n: count += 1 n //= 10 return count"},{"question":"Find Unique Numbers in an Array Context You are given an array of integers where exactly two numbers appear only once, and all other numbers appear exactly twice. Your task is to identify these two unique numbers in O(N) time complexity and O(1) space complexity using bitwise operations. Problem Write a function `find_unique_numbers(nums)` that takes an array of integers as input and returns a list containing the two unique numbers. Input - An array `nums` of integers, where `1 <= len(nums) <= 10^6`. Output - A list containing the two unique numbers. The order of the result does not matter. Constraints - The array contains exactly two elements that appear only once. - All other elements in the array appear exactly twice. - The algorithm must run in O(N) time and use O(1) additional space. Example ```python # Example 1 input: [1, 2, 1, 3, 2, 5] output: [3, 5] or [5, 3] # Example 2 input: [4, 6, 7, 4, 7, 8] output: [6, 8] or [8, 6] # Example 3 input: [10, 11, 12, 10, 11, 13] output: [12, 13] or [13, 12] ``` Function Signature ```python def find_unique_numbers(nums): :type nums: List[int] :rtype: List[int] # Your implementation here ```","solution":"def find_unique_numbers(nums): Finds the two unique numbers in an array where all other numbers appear exactly twice. This function uses bitwise operations to solve the problem in O(N) time and O(1) space. Args: nums (List[int]): List of integers. Returns: List[int]: List containing the two unique numbers. # Step 1: XOR all numbers together. The result will be the XOR of the two unique numbers (a ^ b). xor_all = 0 for num in nums: xor_all ^= num # Step 2: Find a rightmost set bit in the xor_all. This will be used to separate the numbers into two groups. rightmost_set_bit = xor_all & -xor_all # Step 3: Initialize the two unique numbers. num1, num2 = 0, 0 # Step 4: Divide all numbers into two groups based on the rightmost_set_bit and XOR within each group. for num in nums: if num & rightmost_set_bit: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"**Diffusion Network Challenge** You are the part of a software engineering team tasked with optimizing the diffusion of a substance through a network of pipes connecting various chambers in a laboratory. Each pipe has a specific capacity, indicating the maximum amount of substance that can flow through it per unit time. Your goal is to determine the maximum amount of substance that can be transported from the source chamber (first node) to the sink chamber (last node) in the network. The network is represented as an adjacency matrix where `graph[i][j]` indicates the capacity of the pipe from chamber `i` to chamber `j`. **Input Format**: - An integer `n`, representing the number of chambers (the size of the adjacency matrix). - A 2D list `graph`, an `n*n` adjacency matrix where `graph[i][j]` represents the capacity from chamber `i` to chamber `j`. **Output Format**: - An integer representing the maximum flow from the source chamber (node 0) to the sink chamber (node `n-1`). **Constraints**: - All values in the graph are non-negative integers. - `1 <= n <= 100`, where `n` is the number of chambers. - There is always exactly one source (chamber 0) and one sink (chamber n-1). **Function Signature**: ```python def max_substance_flow(n: int, graph: List[List[int]]) -> int: pass ``` **Example**: ```python n = 6 graph = [[0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0]] print(max_substance_flow(n, graph)) # Output: 23 ``` **Explanation**: In the provided example: 1. The network consists of 6 chambers connected through pipes with various capacities. 2. Using the Ford-Fulkerson method with DFS, the maximum feasible flow from the source (chamber 0) to the sink (chamber 5) is calculated as `23`. **Implementation Strategy**: 1. Use the provided function to perform DFS and find augmenting paths. 2. Iterate over found paths, update the residual capacities and accumulate the maximum flow. 3. Return the total computed maximum flow.","solution":"def max_substance_flow(n, graph): Determines the maximum amount of substance that can be transported from source to sink in a network. def bfs(source, sink, parent): visited = [False] * n queue = [] queue.append(source) visited[source] = True while queue: u = queue.pop(0) for ind, val in enumerate(graph[u]): if visited[ind] == False and val > 0: if ind == sink: parent[ind] = u return True queue.append(ind) visited[ind] = True parent[ind] = u return False source = 0 sink = n - 1 parent = [-1] * n max_flow = 0 while bfs(source, sink, parent): path_flow = float(\\"Inf\\") s = sink while s != source: path_flow = min(path_flow, graph[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] graph[u][v] -= path_flow graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Zigzag Iterator Extension You are given the `ZigZagIterator` class designed to iterate over two lists in zigzag order. Your task is to extend this functionality to handle `N` lists given as input. Specifically, you need to create a class `ZigZagIteratorN` that initializes with `N` lists and iterates over their elements in a zigzag fashion. # Function Specification ZigZagIteratorN Class 1. `__init__(self, lists: List[List[int]])`: Initializes the data structure with `N` lists. - **Input**: `lists` - a list of `N` lists containing integers. - **Output**: None 2. `next(self) -> int`: Returns the next element in zigzag order. - **Input**: None - **Output**: The next integer in zigzag order. 3. `has_next(self) -> bool`: Returns `True` if there are elements yet to be iterated, `False` otherwise. - **Input**: None - **Output**: A boolean indicating if more elements are available for iteration. Example ```python # Given the following lists l1 = [1, 2, 3] l2 = [4, 5, 6, 7] l3 = [8, 9] # Initialize the iterator with these lists it = ZigZagIteratorN([l1, l2, l3]) # Iterate over elements result = [] while it.has_next(): result.append(it.next()) print(result) # Output should be [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` # Constraints * The number of input lists `N` is between 1 and 100. * The total number of elements across all lists will not exceed 10^4. * List elements will be integers. Provide the implementation for the `ZigZagIteratorN` class.","solution":"from typing import List class ZigZagIteratorN: def __init__(self, lists: List[List[int]]): self.lists = lists self.queue = [] for i, l in enumerate(lists): if l: self.queue.append((i, 0)) # (list_index, element_index) def next(self) -> int: if self.has_next(): list_idx, elem_idx = self.queue.pop(0) result = self.lists[list_idx][elem_idx] if elem_idx + 1 < len(self.lists[list_idx]): self.queue.append((list_idx, elem_idx + 1)) return result raise Exception(\\"No more elements\\") def has_next(self) -> bool: return len(self.queue) > 0"},{"question":"# Context You are working on optimizing storage and computation for very large sparse vectors where most elements are zeros. As part of this task, you need to handle both storage efficiency and quick computation of operations like the dot product. # Task Write a Python function `sparse_vector_dot_product(v1: List[float], v2: List[float]) -> float` that: 1. Converts two input sparse vectors `v1` and `v2` into their respective index-value pair representations. 2. Computes and returns the dot product of these two sparse vectors. # Input Constraints - `v1` and `v2` are lists of floats, both with maximum length up to (10^6). - Values in `v1` and `v2` can be any float, with many being zero. # Output - A single float representing the dot product of the two sparse vectors. # Example ```python assert sparse_vector_dot_product([1., 0., 2.], [0., 3., 2.]) == 4.0 assert sparse_vector_dot_product([0., 0., 0.], [0., 0., 0.]) == 0.0 assert sparse_vector_dot_product([1., 2., 3.], [0., 2., 2.]) == 10.0 ``` # Points to Note - Your function should be optimized for both time and space efficiency. - Handle edge cases like completely zero vectors gracefully. - Ensure correct use of index-value pairs to avoid incorrect results.","solution":"from typing import List def sparse_vector_dot_product(v1: List[float], v2: List[float]) -> float: Computes the dot product of two sparse vectors represented as lists of floats. Converts the vectors into index-value pairs and computes the dot product efficiently. def to_sparse(vector: List[float]): Converts a dense vector to its sparse representation as index-value pairs. return {i: val for i, val in enumerate(vector) if val != 0.0} sparse_v1 = to_sparse(v1) sparse_v2 = to_sparse(v2) # Calculate the dot product using only the common indices dot_product = 0.0 for idx in sparse_v1: if idx in sparse_v2: dot_product += sparse_v1[idx] * sparse_v2[idx] return dot_product"},{"question":"# Scenario: Task Scheduler You are tasked with designing a task scheduling system using a queue data structure. Tasks are continuously added to the system, and the oldest task is processed and removed. You need to implement the scheduling system using both ArrayQueue and LinkedListQueue to evaluate their performance and memory usage in different scenarios. # Problem Statement Implement a task scheduling system using both array-based and linked-list-based queues. # Requirements 1. **TaskScheduler Class**: - **Methods**: - `__init__(self, queue_type: str, capacity: int = 10)`: Initializes the scheduler with either \\"array\\" or \\"linkedlist\\" queue type. - `add_task(self, task_id: int)`: Adds a task with the given task_id to the queue. - `process_task(self) -> int`: Processes and removes the oldest task from the queue. Returns the processed task_id. - `peek_task(self) -> int`: Returns the task_id of the oldest task without removing it from the queue. - `task_list(self) -> list`: Returns a list of all task IDs currently in the queue. # Input and Output Formats * `TaskScheduler.__init__(self, queue_type: str, capacity: int = 10)` * **Input**: - `queue_type`: \\"array\\" or \\"linkedlist\\". - `capacity`: Integer, optional, default is 10. * `TaskScheduler.add_task(self, task_id: int)` * **Input**: - `task_id`: Integer, ID of the task to be added. * `TaskScheduler.process_task(self) -> int` * **Output**: - Returns the processed task ID. * `TaskScheduler.peek_task(self) -> int` * **Output**: - Returns the task ID of the oldest task. * `TaskScheduler.task_list(self) -> list` * **Output**: - Returns a list of task IDs currently in the queue. # Constraints * Task IDs are positive integers. * Assume a reasonable number of tasks for practical memory usage. * The solution should handle edge cases like processing or peeking an empty queue. # Performance Requirements * Implement the system efficiently to handle typical operations under expected use cases for both queue types.","solution":"class ArrayQueue: def __init__(self, capacity): self.queue = [] self.capacity = capacity self.front = 0 self.rear = 0 def is_empty(self): return self.front == self.rear def is_full(self): return self.rear - self.front == self.capacity def enqueue(self, item): if self.is_full(): raise OverflowError(\\"Queue is full\\") self.queue.append(item) self.rear += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") item = self.queue[self.front] self.front += 1 if self.front == self.rear: self.queue = [] self.front = 0 self.rear = 0 return item def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def get_tasks(self): return self.queue[self.front:self.rear] class LinkedListNode: def __init__(self, value=None): self.value = value self.next = None class LinkedListQueue: def __init__(self, capacity): self.front = None self.rear = None self.capacity = capacity self.size = 0 def is_empty(self): return self.size == 0 def is_full(self): return self.size == self.capacity def enqueue(self, item): if self.is_full(): raise OverflowError(\\"Queue is full\\") new_node = LinkedListNode(item) if self.rear is None: self.front = new_node self.rear = new_node else: self.rear.next = new_node self.rear = new_node self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") item = self.front.value self.front = self.front.next if self.front is None: self.rear = None self.size -= 1 return item def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.front.value def get_tasks(self): tasks = [] current = self.front while current: tasks.append(current.value) current = current.next return tasks class TaskScheduler: def __init__(self, queue_type: str, capacity: int = 10): if queue_type.lower() == \\"array\\": self.queue = ArrayQueue(capacity) elif queue_type.lower() == \\"linkedlist\\": self.queue = LinkedListQueue(capacity) else: raise ValueError(\\"Invalid queue type. Use \'array\' or \'linkedlist\'.\\") def add_task(self, task_id: int): self.queue.enqueue(task_id) def process_task(self) -> int: return self.queue.dequeue() def peek_task(self) -> int: return self.queue.peek() def task_list(self) -> list: return self.queue.get_tasks()"},{"question":"You are to implement a Python function that computes the square root of a given positive integer `N` within a specified precision factor `P` using the binary search method. This function should demonstrate your understanding of iterative refinement and handling floating-point precision. Function Signature ```python def compute_square_root(n: int, precision: float) -> float: Calculate the square root of a positive integer n with an absolute error less than the specified precision. :param n: Positive integer whose square root is to be computed. :param precision: A positive float that specifies the maximum allowed absolute error. :return: A float representing the approximate square root of n. ``` Input - `n`: An integer (1 ≤ n ≤ 10^9) -- the number for which to compute the square root. - `precision`: A float (1e-9 ≤ precision ≤ 0.1) -- the maximum allowed absolute error for the approximation. Output - A float representing the approximate square root of `n` with an absolute error less than `precision`. Constraints - Ensure that your implementation does not use any built-in functions like `math.sqrt()`. Example ```python assert 2.235 < compute_square_root(5, 0.001) < 2.237 assert 1.414 < compute_square_root(2, 0.001) < 1.416 ``` # Additional Information - You should handle edge cases like `n = 1` and `n = 0` appropriately. - Consider using an initial guess of `n / 2` for efficiency.","solution":"def compute_square_root(n: int, precision: float) -> float: Calculate the square root of a positive integer n with an absolute error less than the specified precision. :param n: Positive integer whose square root is to be computed. :param precision: A positive float that specifies the maximum allowed absolute error. :return: A float representing the approximate square root of n. if n == 0: return 0.0 if n == 1: return 1.0 low, high = 0, n mid = (low + high) / 2.0 while abs(mid * mid - n) > precision: if mid * mid < n: low = mid else: high = mid mid = (low + high) / 2.0 return mid"},{"question":"# Context The Atbash cipher is a classical cryptographic technique where each letter in a text is mapped to its reverse in the alphabet. This cipher is simple enough to demonstrate basic encryption and decryption principles and provide a foundation for understanding more complex cryptographic algorithms. # Problem Statement Write a function `atbash_cipher` that takes a string and returns its Atbash cipher equivalent. Both uppercase and lowercase letters should be transformed, while non-alphabetic characters should remain unchanged. # Input * A single string `s` (1 ≤ |s| ≤ 10^4), consisting of any mix of uppercase letters, lowercase letters, digits, and punctuation. # Output * A string representing the Atbash cipher equivalent of the input. # Example Input ``` Attack at dawn! ``` Output ``` Zggzxp zg wzdm! ``` # Constraints 1. Only alphabetic characters should be transformed. 2. Non-alphabetic characters should remain the same. 3. Case sensitivity must be preserved (e.g., \'A\' becomes \'Z\' and \'a\' becomes \'z\'). # Performance Requirements The solution should run efficiently for strings up to 10,000 characters long. # Function Signature ```python def atbash_cipher(s: str) -> str: # Your code here ```","solution":"def atbash_cipher(s: str) -> str: Transforms the given string using the Atbash cipher. Args: s (str): The input string to be transformed. Returns: str: The Atbash cipher equivalent of the input string. def transform_char(c): if \'A\' <= c <= \'Z\': return chr(ord(\'A\') + (ord(\'Z\') - ord(c))) elif \'a\' <= c <= \'z\': return chr(ord(\'a\') + (ord(\'z\') - ord(c))) else: return c return \'\'.join(transform_char(c) for c in s)"},{"question":"You are given two strings `s` and `t` which consist of lowercase letters only. The string `t` is generated by shuffling the string `s` and adding one additional letter at a random position. Write a function `find_added_character(s: str, t: str) -> str` that identifies and returns the letter that was added in `t`. # Input: * `s` (string): A string consisting of lowercase letters. * `t` (string): A string formed by shuffling `s` and adding one additional letter. # Output: * Returns a single character that was added to `t`. # Constraints: * Both strings `s` and `t` are non-empty. * String `t` will always be longer than `s` by exactly one character. * Both `s` and `t` consist of only lowercase English letters. # Performance Requirements: Your solution should run in linear time, O(n), relative to the length of the input strings. # Example: ```python assert find_added_character(\\"abcd\\", \\"abecd\\") == \'e\' assert find_added_character(\\"xyz\\", \\"zxyk\\") == \'k\' ``` # Scenario: Suppose you are working on a text comparison tool where you need to identify single character differences between versions of text strings. Your function will be integrated into this tool to help quickly find discrepancies during text editing. Implement the `find_added_character(s: str, t: str) -> str` function that meets the above requirements.","solution":"def find_added_character(s: str, t: str) -> str: Identifies and returns the character that was added to the string t. :param s: Original string. :param t: Modified string with one additional character added. :return: The character added to t that is not present in s. char_count = {} # Count characters in s for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Count characters in t and compare for char in t: if char not in char_count: return char else: char_count[char] -= 1 if char_count[char] < 0: return char"},{"question":"# Problem Scenario You are developing software for a wearable fitness tracker. The device continuously measures the user\'s heart rate and needs to display a smooth, real-time average over the most recent `n` measurements to avoid erratic readings. Implement a class that supports this functionality efficiently. # Task Implement a `MovingAverage` class to calculate a moving average from a stream of integers using a fixed-size window. # Requirements: 1. **Class Initialization**: - The class should be initialized with a single parameter, the window size. 2. **Method**: - `next(val: int) -> float`: Adds a new integer to the data stream and returns the current moving average of the last `size` elements. If fewer than `size` elements are present, compute the average of all available elements. # Input: - `size`: Integer, 1 ≤ `size` ≤ 10^4 (window size for moving average). - `val`: Integer, -10^4 ≤ `val` ≤ 10^4 (a new integer in the data stream). # Output: - The method `next(val)` should return a float representing the moving average of the most recent `size` elements. # Example: ```python m = MovingAverage(3) print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: 5.5 (average of [1, 10]) print(m.next(3)) # Output: 4.67 (average of [1, 10, 3]) print(m.next(5)) # Output: 6.0 (average of [10, 3, 5]) ``` # Constraints: - The implementation should ensure O(1) time complexity for both insertion and average calculation due to potentially high frequency and volume of data. **Note**: If you can optimize using a running sum to avoid recomputation, it will be considered a plus.","solution":"from collections import deque class MovingAverage: def __init__(self, size): Initialize the MovingAverage with a fixed window size. self.size = size self.window = deque(maxlen=size) self.sum = 0 def next(self, val): Adds a new integer to the data stream and returns the current moving average. if len(self.window) == self.size: self.sum -= self.window.popleft() self.window.append(val) self.sum += val return self.sum / len(self.window)"},{"question":"Distance to Nearest Gate Objective Given a 2D grid initialized with `-1`, `0`, and `INF` values: * `-1` represents a wall or an obstacle that cannot be passed. * `0` represents a gate. * `INF` (2^31 - 1) represents an empty room. You need to fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should remain `INF`. Input A 2D grid represented as a list of lists `rooms` where each element is an integer (`-1`, `0`, or `INF`). Output The function should modify the input 2D grid in place, filling each empty room with the distance to the nearest gate. # Constraints * The grid\'s dimensions are not fixed but expect large grids. * You must handle the grid in place without using additional grid-sized data structures. # Scenario Consider an office floor plan represented by the grid, where employees need to know the shortest distance to the nearest emergency exit (gate). Each room or wall is marked, and the goal is to quickly determine the distances for evacuation planning. Example ```python rooms = [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] walls_and_gates(rooms) print(rooms) # Expected Output: # [ # [3, -1, 0, 1], # [2, 2, 1, -1], # [1, -1, 2, -1], # [0, -1, 3, 4] # ] ``` Function Signature ```python def walls_and_gates(rooms): # Your implementation here ``` **Performance Requirements**: Your solution should run in O(m * n) time and use O(1) additional space (excluding the input grid itself).","solution":"from collections import deque def walls_and_gates(rooms): Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should remain INF. :param rooms: List[List[int]], a 2D grid containing -1, 0, and INF. if not rooms or not rooms[0]: return INF = 2147483647 rows, cols = len(rooms), len(rooms[0]) queue = deque() # Initialize queue with all gates\' positions for r in range(rows): for c in range(cols): if rooms[r][c] == 0: queue.append((r, c)) # Perform BFS from all gates simultaneously directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] while queue: x, y = queue.popleft() for dr, dc in directions: r, c = x + dr, y + dc if 0 <= r < rows and 0 <= c < cols and rooms[r][c] == INF: rooms[r][c] = rooms[x][y] + 1 queue.append((r, c))"},{"question":"Scenario You are working with a system that maintains different versions of configuration trees. Each configuration tree is represented as a binary tree, where each node holds a unique configuration value. You need to implement a function to verify if two version trees are structurally identical and hold the same values. Problem Statement Write a function `are_identical_trees` that checks if two binary trees are identical in both structure and node values. Function Signature ```python def are_identical_trees(tree1, tree2) -> bool: pass ``` Input * `tree1` and `tree2`: Root nodes of two binary trees. Each node is an instance of the `TreeNode` class (given below), where: * `TreeNode.val` (int): The value of the node. * `TreeNode.left` (TreeNode or None): The left child node. * `TreeNode.right` (TreeNode or None): The right child node. Output * Return `True` if the trees are structurally identical and hold the same values. * Return `False` otherwise. Example ```python # Define the TreeNode class for the binary tree structure. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example usage tree1_node1 = TreeNode(1) tree1_node2 = TreeNode(2) tree1_node3 = TreeNode(3) tree1_node1.left = tree1_node2 tree1_node1.right = tree1_node3 tree2_node1 = TreeNode(1) tree2_node2 = TreeNode(2) tree2_node3 = TreeNode(3) tree2_node1.left = tree2_node2 tree2_node1.right = tree2_node3 print(are_identical_trees(tree1_node1, tree2_node1)) # Should output: True tree3_node1 = TreeNode(1) tree3_node2 = TreeNode(2) print(are_identical_trees(tree1_node1, tree3_node1)) # Should output: False ``` Constraints and Considerations * A tree node\'s value is an integer. * Trees can be empty. * Consider scenarios where the tree heights are substantially different, or have unbalanced structures. * Ensure the function handles edge cases efficiently and performs within specified complexity limits.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def are_identical_trees(tree1, tree2) -> bool: # Both trees are empty if tree1 is None and tree2 is None: return True # One of the trees is empty, and the other is not if tree1 is None or tree2 is None: return False # The values of the current nodes are different if tree1.val != tree2.val: return False # Recursively compare the left and right subtrees return are_identical_trees(tree1.left, tree2.left) and are_identical_trees(tree1.right, tree2.right)"},{"question":"**Problem Statement: Secure Communication with Diffie-Hellman Key Exchange** Alice and Bob want to establish a secure communication channel by using the Diffie-Hellman key exchange algorithm. Your task is to implement the functions needed to carry out this cryptographic key exchange securely. You are provided with the foundational functions for prime checking, finding orders, calculating Euler\'s totient function, and identifying primitive roots. Based on these, implement a function `perform_diffie_hellman_key_exchange(p: int, g: int) -> bool` that performs the key exchange. 1. Validate that `p` is a prime number. 2. Ensure that `g` is a primitive root of `p`. 3. Generate private keys for both Alice and Bob (randomly chosen). 4. Calculate their public keys using the formula (A equiv g^{a} pmod{p}) and (B equiv g^{b} pmod{p}), where `a` and `b` are private keys of Alice and Bob respectively. 5. Perform the key exchange and compute the shared secret keys for both Alice and Bob. 6. Return `True` if the shared keys match, otherwise `False`. You can use the following function signatures for your implementation: ```python def prime_check(num: int) -> bool: # Returns True if num is a prime number pass def find_order(a: int, n: int) -> int: # Returns the order of a modulo n, or -1 if no order exists pass def euler_totient(n: int) -> int: # Returns the Euler\'s totient function of n pass def find_primitive_root(n: int) -> list[int]: # Returns a list of primitive roots of n pass def perform_diffie_hellman_key_exchange(p: int, g: int) -> bool: # Implements the diffie-hellman key exchange process pass ``` # Input * `p` (1 <= p <= 2^31 - 1): A large prime number. * `g` (1 ≤ g ≤ p-1): A candidate for the primitive root of `p`. # Output * Return a boolean value `True` if the shared keys calculated by Alice and Bob match, otherwise `False`. # Constraints * Use 1 ≤ p, g ≤ 2^31 - 1 as the valid range of integers for inputs `p` and `g`. * Ensure that `p` is actually a prime number and that `g` is a primitive root of `p`. # Example ```python assert perform_diffie_hellman_key_exchange(23, 5) == True # Example with successful key exchange ``` # Notes * Focus on the correctness and efficiency of modular arithmetic operations. * Handle all error scenarios and edge cases properly, including invalid parameters.","solution":"import random def prime_check(num: int) -> bool: Returns True if num is a prime number. if num <= 1: return False for i in range(2, int(num**0.5)+1): if num % i == 0: return False return True def find_order(a: int, n: int) -> int: Returns the order of a modulo n, or -1 if no order exists if a == 0: return 0 order = 1 current = a % n while current != 1: current = (current * a) % n order += 1 return order def euler_totient(n: int) -> int: Returns the Euler\'s totient function of n result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def find_primitive_root(n: int) -> list[int]: Returns a list of primitive roots of n if not prime_check(n): return [] phi_n = euler_totient(n) factors = set() # Finding prime factors of phi_n p = 2 temp_phi = phi_n while p * p <= temp_phi: if temp_phi % p == 0: factors.add(p) while temp_phi % p == 0: temp_phi //= p p += 1 if temp_phi > 1: factors.add(temp_phi) # Searching for primitive roots primitive_roots = [] for r in range(2, n): flag = True for factor in factors: if pow(r, phi_n // factor, n) == 1: flag = False break if flag: primitive_roots.append(r) return primitive_roots def perform_diffie_hellman_key_exchange(p: int, g: int) -> bool: if not prime_check(p): return False primitive_roots = find_primitive_root(p) if g not in primitive_roots: return False private_key_a = random.randint(1, p-2) private_key_b = random.randint(1, p-2) public_key_a = pow(g, private_key_a, p) public_key_b = pow(g, private_key_b, p) shared_secret_a = pow(public_key_b, private_key_a, p) shared_secret_b = pow(public_key_a, private_key_b, p) return shared_secret_a == shared_secret_b"},{"question":"# Graph Traversal Using Depth First Search (DFS) and Breadth First Search (BFS) You are given a graph represented as an adjacency list, and you need to implement two traversal algorithms: Depth First Search (DFS) and Breadth First Search (BFS). Your task is to write two functions: 1. `dfs_traverse_recursive(graph, start)`: This function should implement the DFS traversal in a recursive manner. 2. `bfs_traverse(graph, start)`: This function should implement the BFS traversal. These functions should return a list of nodes in the order they are visited starting from the given start node. Input Format: - `graph`: A dictionary where the keys are node identifiers and the values are lists of adjacent nodes. - `start`: The starting node for the traversal. Output Format: - Both functions should return a list of nodes in the order they are visited by the traversal. Constraints: - The graph is connected (all nodes are reachable from the start node). - Node identifiers are unique. - Assume graph nodes can be represented as integers or strings. - The graph does not have self-loops. Example: Suppose `graph = {0: [1, 2], 1: [0, 3], 2: [0], 3: [1, 4], 4: [3]}` and `start = 0`, Calling `dfs_traverse_recursive(graph, start)` might return `[0, 1, 3, 4, 2]`, Calling `bfs_traverse(graph, start)` might return `[0, 1, 2, 3, 4]`. Function Signature: ```python def dfs_traverse_recursive(graph, start): pass def bfs_traverse(graph, start): pass ``` Implement these two functions.","solution":"def dfs_traverse_recursive(graph, start): Perform depth-first search (DFS) traversal recursively from the start node. :param graph: Dictionary representing the adjacency list of the graph. :param start: The starting node for the traversal. :return: List of nodes in the order they are visited. visited = [] def dfs(node): if node not in visited: visited.append(node) for neighbor in graph[node]: dfs(neighbor) dfs(start) return visited def bfs_traverse(graph, start): Perform breadth-first search (BFS) traversal from the start node. :param graph: Dictionary representing the adjacency list of the graph. :param start: The starting node for the traversal. :return: List of nodes in the order they are visited. visited = [] queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.append(node) queue.extend(graph[node]) return visited"},{"question":"Background: You are tasked with sorting an inventory list at a small warehouse. The inventory turnover is frequent, so the list is usually nearly sorted. Write a Python function to efficiently sort this list using a suitable sorting algorithm that takes advantage of the nearly sorted nature of the data. Task: Implement the Insertion Sort algorithm in Python. Your function should include an additional feature to log the state of the array after each significant step for debugging purposes. Function Signature: ```python def insertion_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` Input: - `arr` (List[int]): A list of integers representing inventory item counts. - `simulation` (bool): A flag indicating whether to log the state of the array during sorting (default is `False`). Output: - A sorted list of integers in non-decreasing order. Constraints: - The input list can have up to 10,000 integers. - Each integer ranges from -10,000 to 10,000. - Ensure the function maintains a time complexity of O(n²) in the worst case. Debug Logs: If `simulation` is `True`, your function should print the state of the list after each insertion operation in the format: ``` iteration <iteration_number>: <list_state> ``` Example: ```python # Example usage array = [5, 3, 8, 6, 2] sorted_array = insertion_sort(array, simulation=True) # Expected output # iteration 0: 5 3 8 6 2 # iteration 1: 3 5 8 6 2 # iteration 2: 3 5 8 6 2 # iteration 3: 3 5 6 8 2 # iteration 4: 2 3 5 6 8 print(sorted_array) # Output should be [2, 3, 5, 6, 8] ``` Carefully consider edge cases, such as an empty list or a list with identical elements, and ensure stability in the sort implementation.","solution":"def insertion_sort(arr, simulation=False): Sorts the list using the Insertion Sort algorithm. Args: arr (List[int]): A list of integers to be sorted. simulation (bool): Flag indicating whether to print array state after each insertion step (default is False). Returns: List[int]: Sorted list of integers. for i in range(1, len(arr)): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, # to one position ahead of their current position while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(f\'iteration {i}: {\\" \\".join(map(str, arr))}\') return arr"},{"question":"# Next Higher Number with Same Digits You are required to implement a function `next_bigger_number(num: int) -> int`. The function should take a single integer as an input and return the next higher number that can be formed using the exact same digits of the original number. If no such number exists, return `-1`. **Input**: - An integer, `num`, where `1 <= num <= 10^18`. **Output**: - An integer representing the next higher number using the same digits as `num`. **Function Signature**: ```python def next_bigger_number(num: int) -> int: # your code here ``` # Constraints: - The input number `num` will always be positive. - Handle edge cases like numbers with repeating digits. # Example Input/Output: 1. Input: `38276` Output: `38627` 2. Input: `99999` Output: `-1` 3. Input: `12345` Output: `12354` 4. Input: `54321` Output: `-1` # Notes: - If the digits of the number are sorted in descending order, it means the number is the highest permutation possible of those digits, and thus, the function should return `-1`. - You may assume that leading zeros are not an issue as the numbers will be treated as integers. Implement the function to correctly find the next higher permutation of digits or determine if it’s not possible.","solution":"def next_bigger_number(num: int) -> int: digits = list(str(num)) n = len(digits) # Step 1: Find the rightmost digit which is smaller than its next digit for i in range(n - 2, -1, -1): if digits[i] < digits[i + 1]: break else: # If no such digit is found, that means the number is the greatest permutation return -1 # Step 2: Find the smallest digit on right side of digits[i] which is greater than digits[i] for j in range(n - 1, i, -1): if digits[j] > digits[i]: break # Step 3: Swap digits[i] and digits[j] digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the sequence after the position i digits = digits[:i + 1] + sorted(digits[i + 1:]) # Convert list back to integer return int(\'\'.join(digits))"},{"question":"Scenario You have been hired by an e-commerce company to build a recommendation module. Your task is to classify products into categories based on their feature vectors by finding the nearest neighbor in a pre-labeled training set. Task Write a function `classify_product` that implements the nearest neighbor algorithm using Euclidean distance. Function Signature ```python def classify_product(product_vector: tuple, training_set: dict) -> str: Classifies the product based on the given feature vector using the nearest neighbor algorithm. Arguments: - product_vector (tuple): A tuple of numerical features representing the product. - training_set (dict): A dictionary where keys are tuples representing feature vectors, and values are strings representing category labels. Returns: - str: The category label of the nearest neighbor. ``` Requirements * **Input**: - `product_vector`: A tuple `(x1, x2, ..., xn)` representing the features of the product to classify. - `training_set`: A dictionary where keys are tuples of numerical features, and values are category labels. * **Output**: A string representing the category label of the nearest product in the training set. Constraints * Training set will have at least one element. * All vectors (both product_vector and keys of training_set) have the same dimensions. * Feature values are non-negative integers. Example ```python product_vector = (3, 5) training_set = { (1, 2): \\"Electronics\\", (8, 9): \\"Groceries\\", (3, 6): \\"Electronics\\" } print(classify_product(product_vector, training_set)) # Expected Output: \\"Electronics\\" ``` Performance The solution should be efficient enough to handle training sets with up to 10^4 product vectors and feature vectors with dimensions up to 10.","solution":"import math def classify_product(product_vector: tuple, training_set: dict) -> str: Classifies the product based on the given feature vector using the nearest neighbor algorithm. Arguments: - product_vector (tuple): A tuple of numerical features representing the product. - training_set (dict): A dictionary where keys are tuples representing feature vectors, and values are strings representing category labels. Returns: - str: The category label of the nearest neighbor. # Initialize the minimum distance and label min_distance = float(\'inf\') nearest_label = None # Iterate through the training set to find the nearest neighbor for train_vector, label in training_set.items(): # Calculate the Euclidean distance distance = math.sqrt(sum((pv - tv) ** 2 for pv, tv in zip(product_vector, train_vector))) # Update the nearest neighbor if a closer one is found if distance < min_distance: min_distance = distance nearest_label = label return nearest_label"},{"question":"# Shell Sort Assessment You are given a list of integers that needs to be sorted using the Shell Sort algorithm. The Shell Sort algorithm provides a generalization of insertion sort by allowing the exchange of items that are far apart. The process involves: 1. Initialize the gap value. Start with a large gap, then reduce the gap until it becomes 1. 2. Perform a gapped insertion sort for the current gap size. 3. Decrease the gap value and repeat the process until the array becomes fully sorted. Task Implement the Shell Sort algorithm with an optimized gap sequence to sort a given list of integers. Function Signature ```python def optimized_shell_sort(arr: List[int]) -> List[int]: pass ``` Input - `arr`: A list of integers to be sorted. (1 ≤ len(arr) ≤ 10^5) Output - Return the sorted list of integers in non-decreasing order. Constraints - You should use optimized gap sequences (such as Hibbard\'s increments) for better performance. - The function should handle the edge cases of empty arrays and single-element arrays gracefully. - Aim for better-than O(n^2) performance over a wide range of input sizes. Example ```python # Example 1 print(optimized_shell_sort([64, 34, 25, 12, 22, 11, 90])) # Output: [11, 12, 22, 25, 34, 64, 90] # Example 2 print(optimized_shell_sort([])) # Output: [] # Example 3 print(optimized_shell_sort([1])) # Output: [1] # Example 4 print(optimized_shell_sort([4, 5, 1, 3, 2, 6])) # Output: [1, 2, 3, 4, 5, 6] ``` Make sure your implementation passes both the provided examples and other edge cases to demonstrate your understanding of the Shell Sort algorithm and its variations in gap sequences.","solution":"from typing import List def optimized_shell_sort(arr: List[int]) -> List[int]: Sorts the given list of integers using the Shell Sort algorithm with optimized gap sequence. n = len(arr) gap = 1 # Using Hibbard\'s increments: gap sequence of the form 1, 3, 7, 15, 31, ... while gap < n // 3: gap = 3 * gap + 1 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 3 return arr"},{"question":"# Question: Shortest Word Transformation Path You are given two words, `begin_word` and `end_word`, and a dictionary of words `word_list`. Write a function `ladder_length` that computes the length of the shortest transformation sequence from `begin_word` to `end_word`. The transformation must adhere to the following constraints: 1. Only one letter can be changed at a time. 2. Each intermediate word must exist in the word list. If the transformation is not possible, return `-1`. **Input:** - `begin_word` (String): The starting word. - `end_word` (String): The target word. - `word_list` (List of Strings): The list of valid transformation words. **Output:** - An integer representing the length of the shortest transformation sequence. **Constraints:** - All words have the same length. - All words contain only lowercase alphabetic characters. - The dictionary\'s word list contains at least one word. **Example:** ```python begin_word = \\"hit\\" end_word = \\"cog\\" word_list = [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"] # Example Function Call print(ladder_length(begin_word, end_word, word_list)) # Output: 5 ``` **Explanation:** One shortest transformation sequence is \\"hit\\" -> \\"hot\\" -> \\"dot\\" -> \\"dog\\" -> \\"cog\\", with an output length of 5. **Additional Notes:** - Return `-1` if there is no such transformation sequence possible. - Aim to implement the solution using bidirectional Breadth-First Search for optimal performance. Here is a template for the function: ```python def ladder_length(begin_word, end_word, word_list): # Your code here ``` Implement the function `ladder_length` that performs the tasks as described in the problem statement effectively handling all edge cases and optimizing for performance.","solution":"from collections import deque def ladder_length(begin_word, end_word, word_list): if end_word not in word_list: return -1 word_set = set(word_list) # To make word lookups faster queue = deque([(begin_word, 1)]) # (current_word, current_level) while queue: current_word, level = queue.popleft() if current_word == end_word: return level for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i+1:] if next_word in word_set: queue.append((next_word, level + 1)) word_set.remove(next_word) return -1"},{"question":"Context You are tasked with writing a function that calculates the number of ways a given positive integer can be decomposed into a sum of non-negative integers. This problem is critical for understanding combinatorial number theory and has applications in fields such as cryptography and resource allocation. Task Write a function named `count_partition_ways` that accepts a single parameter: - `n` — a positive integer (1 ≤ n ≤ 1000) The function should return the number of ways to decompose the given integer `n` into a sum of non-negative integers. Requirements - **Input and Output Format**: - **Input**: A single integer `n`. - **Output**: A single integer representing the number of ways to decompose `n`. - **Constraints**: - You must use dynamic programming to solve this problem. - Your solution should have a time complexity of ( O(n^2) ). Example # Example 1 ```python Input: 4 Output: 5 ``` Explanation: 4 can be decomposed as: - 4 - 3 + 1 - 2 + 2 - 2 + 1 + 1 - 1 + 1 + 1 + 1 # Example 2 ```python Input: 7 Output: 15 ``` Explanation: 7 can be decomposed as: - 7 - 6 + 1 - 5 + 2 - 5 + 1 + 1 - 4 + 3 - 4 + 2 + 1 - 4 + 1 + 1 + 1 - 3 + 3 + 1 - 3 + 2 + 2 - 3 + 2 + 1 + 1 - 3 + 1 + 1 + 1 + 1 - 2 + 2 + 2 + 1 - 2 + 2 + 1 + 1 + 1 - 2 + 1 + 1 + 1 + 1 + 1 - 1 + 1 + 1 + 1 + 1 + 1 + 1 Write the function `count_partition_ways` satisfying the above requirements.","solution":"def count_partition_ways(n): Returns the number of ways to decompose the given integer n into a sum of non-negative integers. Uses dynamic programming to find the number of partitions. # Create a table to store results of subproblems dp = [0] * (n + 1) dp[0] = 1 # Base case: There\'s one way to partition 0 # Iterate over all numbers from 1 to n for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"Binary Tree Path Sum Calculator **Context**: You have a binary tree and need to work with its structure by serializing it to a string and deserializing it back to a tree form. After reconstructing the tree, you need to implement a function that calculates the sum of all root-to-leaf paths in the tree, where each path is treated as a number formed by concatenating node values. # Task: Write a function `tree_path_sum` that: 1. Takes a single string input, the serialized form of a binary tree as serialized by the provided `serialize` function. 2. Deserializes this string back into a binary tree. 3. Computes the sum of all root-to-leaf paths in the tree, treating each path as a number formed by concatenating node values. # Function Definition ```python def tree_path_sum(serialized: str) -> int: pass ``` # Input: * A single string `serialized` representing the serialized form of a binary tree. # Output: * An integer representing the sum of all root-to-leaf paths formed by concatenating node values. # Example ```python # Serialized form of a binary tree serialized = \\"1 2 # # 3 4 # # 5 # #\\" # Deserialized Tree: # 1 # / # 2 3 # / # 4 5 # The root-to-leaf paths are: # 12, 134, 135 # So the result is: 12 + 134 + 135 = 281 assert tree_path_sum(serialized) == 281 ``` # Constraints: * Each node value will be a non-negative integer. * The serialized string will be a valid serialization of a binary tree as per the provided `serialize` function. # Edge Cases to Consider: * The tree might be empty. * Non-balanced trees with nodes only on one side. # Guidelines: 1. Utilize the `deserialize` function to reconstruct the tree. 2. Implement a helper function to traverse the tree and calculate the path sums. 3. Make sure your solution is efficient and handles edge cases properly.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deserialize(data: str) -> TreeNode: def helper(nodes): val = next(nodes) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = helper(nodes) node.right = helper(nodes) return node nodes = iter(data.split()) return helper(nodes) def tree_path_sum(serialized: str) -> int: root = deserialize(serialized) def dfs(node, current_path): if not node: return 0 current_path = current_path * 10 + node.val if not node.left and not node.right: return current_path left_sum = dfs(node.left, current_path) right_sum = dfs(node.right, current_path) return left_sum + right_sum return dfs(root, 0)"},{"question":"Given a sorted array of integers and a target value, implement the Binary Search algorithm to find the index of the target value in the array. If the target value is not present, return -1. # Function Signature ```python def search_in_sorted_array(array: List[int], target: int) -> int: pass ``` # Input 1. `array` (List[int]): A list of integers sorted in ascending order. The list can be empty. 2. `target` (int): The target value to search for. # Output - An integer representing the index of the target value if it\'s in the array; if not, return -1. # Example 1. **Input**: array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target = 5 **Output**: 4 2. **Input**: array = [10, 20, 30, 40, 50], target = 35 **Output**: -1 # Constraints - The array can contain up to (10^5) elements. - Each element in the array is an integer within the range ([-10^9, 10^9]). # Requirements 1. The function should handle both iterative and recursive implementations (as sub-functions of the main function, if applicable). 2. Clearly handle potential edge cases, including but not limited to empty arrays and single-element arrays. 3. Consider optimizing the performance for larger datasets. **Note**: You may assume that the input array will always be sorted in ascending order. # Scenario A tech company wants to embed a search feature in their contact application. Your task is to implement the search mechanism where, given a phone number list (sorted in ascending order) and a phone number to find, the program returns the index of the phone number if found, or -1 if not.","solution":"from typing import List def search_in_sorted_array(array: List[int], target: int) -> int: def binary_search_iterative(array: List[int], target: int) -> int: left, right = 0, len(array) - 1 while left <= right: mid = left + (right - left) // 2 if array[mid] == target: return mid elif array[mid] < target: left = mid + 1 else: right = mid - 1 return -1 return binary_search_iterative(array, target)"},{"question":"# Special Numbers With Consecutive Powers: Coding Challenge Context: A fascinating numerical property relates to certain numbers where each digit raised to consecutive powers equals the number itself. For instance, 89 is such a number because 8^1 + 9^2 = 89. The next number, 135, has the same characteristic with its digits: 1^1 + 3^2 + 5^3 = 135. Objective: Write a function `special_numbers(low, high)` that returns a list of numbers within the given range `[low, high]` which satisfy the noted property. Function Signature: ```python def special_numbers(low: int, high: int) -> List[int]: pass ``` Input: - `low`: An integer indicating the start of the range (inclusive). - `high`: An integer indicating the end of the range (inclusive). Output: - A list of integers within the given range that satisfy the property where each digit raised to consecutive powers equals the number itself. Constraints: 1. `1 <= low <= high <= 10^9`. 2. The function should aim for efficiency within the correct logical bounds. Example: ```python assert special_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert special_numbers(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert special_numbers(50, 150) == [89, 135] ``` # Additional Information: - Assume standard arithmetic capabilities in Python handle number ranges efficiently, but consider optimizing inner loops if possible. - Be mindful of edge cases, such as single-digit numbers or wide ranges that include only very large numbers. Good luck, and may your code be as elegant as the numbers you discover!","solution":"from typing import List def special_numbers(low: int, high: int) -> List[int]: def is_special(num: int) -> bool: digits = [int(d) for d in str(num)] power_sum = sum(d ** (i + 1) for i, d in enumerate(digits)) return power_sum == num result = [] for num in range(low, high + 1): if is_special(num): result.append(num) return result"},{"question":"Unique Pair Finder Problem Description You are given an array of integers `nums`, where exactly two elements appear only once and every other element appears exactly twice. Your task is to find the two elements that appear only once. The algorithm must run in linear time O(N) and use constant space O(1). Input - An array of integers `nums`, where `2 <= nums.length <= 3 * 10^4` and each integer in `nums` is in the range `-3 * 10^4 <= nums[i] <= 3 * 10^4`. Output - A list of two integers `[x, y]` where `x` and `y` are the elements that appear only once. The order of the result is not important, meaning `[y, x]` is also correct. Example ``` Input: nums = [1, 2, 1, 3, 2, 5] Output: [3, 5] or [5, 3] ``` Constraints - Your solution should have a time complexity of O(N). - Your solution should have a space complexity of O(1). Instructions - Implement the function `single_number(nums: List[int]) -> List[int]` that takes the input array and returns the list of the two unique numbers. Function Signature ```python def single_number(nums: List[int]) -> List[int]: pass ```","solution":"from typing import List def single_number(nums: List[int]) -> List[int]: # First pass: XOR all numbers to get xor = a ^ b (where a and b are the unique numbers) xor = 0 for num in nums: xor ^= num # Get rightmost set bit in xor (this will be different between a and b) rightmost_set_bit = xor & -xor # Initialize a and b to zero a, b = 0, 0 # Second pass: Divide the numbers into two groups based on the rightmost set bit # and XOR each group to isolate the two unique numbers for num in nums: if num & rightmost_set_bit: a ^= num else: b ^= num return [a, b]"},{"question":"# Flatten Nested Arrays You are given a nested array (an array that can contain multiple levels of sub-arrays). Your task is to implement two versions of a function that takes this nested array and returns a completely flattened one-dimensional array containing all the elements. Function 1: Return List Implement a function `flatten(arr)` that takes a nested array `arr` of integers and returns a one-dimensional list with all the elements. The function should utilize recursion and handle edge cases properly, such as empty arrays and non-integer, non-iterable elements. **Input** - A nested list `arr` of integers. **Output** - A list containing all the integers from `arr` but flattened out into a single level. **Example** ```python flatten([1, [2, 3], [4, [5, 6]]]) # Output: [1, 2, 3, 4, 5, 6] flatten([[], [1, [2, [3]]], 4]) # Output: [1, 2, 3, 4] ``` Function 2: Return Iterator Implement a function `flatten_iter(arr)` that takes a nested array `arr` of integers and returns an iterator that yields elements of the flattened array one by one, using Python generators. This should help in saving memory when dealing with large arrays by processing elements on-the-fly. **Input** - A nested list `arr` of integers. **Output** - An iterator that yields integers from the array, flattened into a single level. **Example** ```python list(flatten_iter([1, [2, 3], [4, [5, 6]]])) # Output: [1, 2, 3, 4, 5, 6] list(flatten_iter([[], [1, [2, [3]]], 4])) # Output: [1, 2, 3, 4] ``` # Constraints * Elements in the array are guaranteed to be integers, other iterables (except strings), or nested arrays. * The depth of the nested array may vary. * You can assume that the maximum recursion depth won\'t be reached within the constraints of typical test cases.","solution":"def flatten(arr): Flattens a nested list of integers into a single level list. result = [] for element in arr: if isinstance(element, list): result.extend(flatten(element)) else: result.append(element) return result def flatten_iter(arr): Flattens a nested list of integers into a single level list using an iterator. for element in arr: if isinstance(element, list): yield from flatten_iter(element) else: yield element"},{"question":"# Flatten Nested Arrays Background You are tasked with writing a program that flattens a nested array into a single-level array. *You are given the task of flattening a nested array structure to a single-level list. Your function should produce a flat list containing all elements from the original nested structure in the same order.* # Requirements: 1. Write a function `flatten_array` that takes a single argument, a nested list. 2. The function should return a flat list containing all elements of the nested structure. # Constraints: 1. Do not use any libraries or built-in functions that provide flattened functionality directly (e.g., `itertools.chain`). 2. You must handle arrays nested to any depth. 3. Strings should be treated as atomic elements and not be iterated. # Performance Requirements: - **Time Complexity**: O(n), where n is the total number of elements across all levels of nested arrays. - **Space Complexity**: O(n) for the output list. # Function Signature: ```python def flatten_array(nested_list: list) -> list: pass ``` # Input: - A single argument `nested_list` which is a list potentially containing other nested lists or non-iterable elements. # Output: - A single-level list containing all the elements from the `nested_list`, maintaining their order. # Examples: ```python assert flatten_array([1, [2, [3, 4], [5]], 6]]) == [1, 2, 3, 4, 5, 6] assert flatten_array([[\'a\', [\'b\', [\'c\']], \'d\'], \'e\']) == [\'a\', \'b\', \'c\', \'d\', \'e\'] assert flatten_array([[], [[]]]) == [] assert flatten_array([1, \'abc\', [2, [3, \'def\', [4, [[5]]]]]]) == [1, \'abc\', 2, 3, \'def\', 4, 5] ``` **Advanced Requirement (Optional):** - Implement `flatten_array_iter` using a generator to produce a flat list lazily. # Function Signature: ```python def flatten_array_iter(nested_list: list) -> iter: pass ``` **Output for `flatten_array_iter` should be an iterator that yields elements one by one instead of returning a list.**","solution":"def flatten_array(nested_list: list) -> list: Flattens a nested list into a single-level list. def _flatten(arr, result): for item in arr: if isinstance(item, list): _flatten(item, result) else: result.append(item) return result return _flatten(nested_list, []) # Optional: Generator version to produce a flat list lazily def flatten_array_iter(nested_list: list): Flattens a nested list into a single-level iterator. for item in nested_list: if isinstance(item, list): yield from flatten_array_iter(item) else: yield item"},{"question":"Given two strings, write a function `are_anagrams(s1: str, s2: str) -> bool` that determines if the two strings are anagrams of each other. The function should check both for lowercase English alphabets as well as capital letters and special characters. You need to handle edge cases and take care of performance considerations. # Function Signature ```python def are_anagrams(s1: str, s2: str) -> bool: pass ``` # Input * `s1` (string): The first string for comparison. (1 ≤ len(s1) ≤ 10^5) * `s2` (string): The second string for comparison. (1 ≤ len(s2) ≤ 10^5) # Output * Return `True` if strings `s1` and `s2` are anagrams of each other. * Return `False` otherwise. # Constraints * Strings can contain any printable ASCII characters. * The comparison should be case-sensitive. # Example ```python are_anagrams(\\"apple\\", \\"pleap\\") # True are_anagrams(\\"apple\\", \\"cherry\\") # False are_anagrams(\\"Hello!\\", \\"!heloL\\")# True are_anagrams(\\"\\", \\"\\") # True are_anagrams(\\"Apple\\", \\"apple\\") # False (case-sensitive) ``` # Note You should consider: * Checking string length first to immediately rule out non-anagrams. * Counting character frequencies efficiently. * Case sensitivity and special characters in your comparison.","solution":"def are_anagrams(s1: str, s2: str) -> bool: Check if two strings are anagrams. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if the strings are anagrams, False otherwise. if len(s1) != len(s2): return False from collections import Counter return Counter(s1) == Counter(s2)"},{"question":"# Context You are working on a geometry application and need to implement functionality that calculates missing side lengths of a right-angled triangle using the Pythagorean Theorem. # Task Write a function named `calculate_side` to determine the missing side length of a right-angled triangle. # Function Signature ```python def calculate_side(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> str: Determine the length of the missing side of a right-angled triangle. - opposite: Length of the side opposite to the right angle or \'?\' if unknown. - adjacent: Length of the side adjacent to the right angle or \'?\' if unknown. - hypotenuse: Length of the hypotenuse or \'?\' if unknown. Returns a string indicating the missing side\'s length. ``` # Input The function takes three parameters: * `opposite`: either a float representing the opposite side length or \'?\' to indicate it\'s unknown. * `adjacent`: either a float representing the adjacent side length or \'?\' to indicate it\'s unknown. * `hypotenuse`: either a float representing the hypotenuse length or \'?\' to indicate it\'s unknown. # Output The function should return a string in the format of: * \\"Opposite = length\\" * \\"Adjacent = length\\" * \\"Hypotenuse = length\\" # Constraints * Only one of the sides will be the unknown side. * The known side lengths will always be positive real numbers. * The input sides will always be able to form a valid right-angled triangle. * You must handle possible exceptions due to invalid inputs gracefully. # Examples ```python assert calculate_side(\'?\', 3.0, 5.0) == \\"Opposite = 4.0\\" assert calculate_side(4.0, \'?\', 5.0) == \\"Adjacent = 3.0\\" assert calculate_side(3.0, 4.0, \'?\') == \\"Hypotenuse = 5.0\\" ``` # Notes * Make sure to handle invalid or ambiguous inputs by raising appropriate exceptions. * Consider edge cases such as all sides given or no sides given, and ensure your function fails gracefully with descriptive error messages.","solution":"import math from typing import Union def calculate_side(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> str: Determine the length of the missing side of a right-angled triangle. - opposite: Length of the side opposite to the right angle or \'?\' if unknown. - adjacent: Length of the side adjacent to the right angle or \'?\' if unknown. - hypotenuse: Length of the hypotenuse or \'?\' if unknown. Returns a string indicating the missing side\'s length. if opposite == \'?\': # Calculate the opposite side using the Pythagorean theorem: hypotenuse^2 = adjacent^2 + opposite^2 if isinstance(adjacent, (int, float)) and isinstance(hypotenuse, (int, float)): if adjacent >= hypotenuse: raise ValueError(\\"Adjacent side cannot be greater than or equal to the hypotenuse in a right-angled triangle.\\") opposite = math.sqrt(hypotenuse**2 - adjacent**2) return f\\"Opposite = {opposite:.1f}\\" else: raise ValueError(\\"Invalid input: adjacent and hypotenuse must be numbers.\\") elif adjacent == \'?\': if isinstance(opposite, (int, float)) and isinstance(hypotenuse, (int, float)): if opposite >= hypotenuse: raise ValueError(\\"Opposite side cannot be greater than or equal to the hypotenuse in a right-angled triangle.\\") adjacent = math.sqrt(hypotenuse**2 - opposite**2) return f\\"Adjacent = {adjacent:.1f}\\" else: raise ValueError(\\"Invalid input: opposite and hypotenuse must be numbers.\\") elif hypotenuse == \'?\': if isinstance(opposite, (int, float)) and isinstance(adjacent, (int, float)): hypotenuse = math.sqrt(opposite**2 + adjacent**2) return f\\"Hypotenuse = {hypotenuse:.1f}\\" else: raise ValueError(\\"Invalid input: opposite and adjacent must be numbers.\\") else: raise ValueError(\\"Exactly one of the sides must be unknown.\\")"},{"question":"# Reversing a Hybrid Linked List You are given a singly linked list where each node might contain a primary value and a pointer to a sub-linked list. Your task is to reverse the main list and each of the sub-linked lists. For instance: ``` 1 --> 2 --> 3 ↓ ↓ ↓ 4 5→6 7→8→9 ``` After reversal, the list should appear as: ``` 3 --> 2 --> 1 ↓ ↓ ↓ 9→8→7 5→6 4 ``` # Function Signature ```python class ListNode: def __init__(self, val=0, next=None, sublist=None): self.val = val self.next = next self.sublist = sublist def reverse_hybrid_list(head: ListNode) -> ListNode: pass ``` # Input - `head`: A `ListNode` object representing the head of the main linked list. - Each `ListNode` might contain an additional `sublist` which itself is a `ListNode`. # Output - A `ListNode` representing the head of the reversed main linked list, with each sublist also reversed. # Constraints - Sub-lists can be of varying lengths, and can be `None`. - The list and sub-lists contain integers. - The total number of nodes will not exceed 10^6. # Performance Requirements - The overall time complexity should remain within O(n), where n is the total number of nodes in the main list and its sub-lists combined. - The solution should handle up to the maximum input size efficiently. # Example Example Input ```python # Main list: 1 → 2 → 3 # Sub-lists: # 1\'s sub-list: 4 # 2\'s sub-list: 5 → 6 # 3\'s sub-list: 7 → 8 → 9 head = ListNode(1, ListNode(2, ListNode(3))) head.sublist = ListNode(4) head.next.sublist = ListNode(5, ListNode(6)) head.next.next.sublist = ListNode(7, ListNode(8, ListNode(9))) ``` Example Output ```python # Expected new head: points to ListNode(3) # Main list: 3 → 2 → 1 # Sub-lists: # 3\'s sub-list: 9 → 8 → 7 # 2\'s sub-list: 6 → 5 # 1\'s sub-list: 4 # representing the new structure will look like this: new_head = ListNode(3, ListNode(2, ListNode(1))) new_head.sublist = ListNode(9, ListNode(8, ListNode(7))) new_head.next.sublist = ListNode(6, ListNode(5)) new_head.next.next.sublist = ListNode(4) ``` Note: For writing code, ensure that sub-lists are correctly reversed within the constraints and operations provided. Use helper functions as necessary to keep code clean and modular.","solution":"class ListNode: def __init__(self, val=0, next=None, sublist=None): self.val = val self.next = next self.sublist = sublist def reverse_linked_list(head: ListNode) -> ListNode: prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev def reverse_sublist(head: ListNode) -> ListNode: return reverse_linked_list(head) def reverse_hybrid_list(head: ListNode) -> ListNode: # Reverse the main list new_head = reverse_linked_list(head) # Reverse each sublist current = new_head while current: if current.sublist: current.sublist = reverse_sublist(current.sublist) current = current.next return new_head"},{"question":"# Minimum Deletion Steps to Make Two Strings the Same Given two words **word1** and **word2**, you need to find the minimum number of steps required to make **word1** and **word2** the same, where in each step you can delete one character in either string. **Function Signature:** ```python def min_distance(word1: str, word2: str) -> int: pass ``` # Input - Two strings `word1` and `word2` where `1 <= len(word1), len(word2) <= 1000`. # Output - An integer representing the minimum number of steps required. # Example ```python min_distance(\\"sea\\", \\"eat\\") # Output: 2 # Explanation: # You need one step to make \\"sea\\" to \\"ea\\" and another step to make \\"eat\\" to \\"ea\\". ``` # Constraints - You must optimize for both time and space complexity where possible. - Your solution should not exceed O(length1 * length2) in time complexity and should aim to use O(min(length1, length2)) additional space. # Considerations - Consider using dynamic programming techniques to accomplish the task efficiently. - Handle edge cases such as one or both strings being empty. - Ensure your implementation handles the maximum possible input size within a reasonable time. # Scenario You are tasked with comparing DNA sequences where minimal modification is crucial for time and space efficiency, and large sequences are provided as input. Your solution must handle such high-stakes scenarios.","solution":"def min_distance(word1: str, word2: str) -> int: Given two words, compute the minimum number of deletions required to make both words the same. m, n = len(word1), len(word2) # Create a 2D dp array where dp[i][j] will hold the length of the # longest common subsequence of word1[0..i-1] and word2[0..j-1] dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp array for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The length of the longest common subsequence lcs = dp[m][n] # The minimum number of deletions required is the sum of the deletions # required to remove all characters that are not part of the LCS return (m - lcs) + (n - lcs)"},{"question":"# Unique Numbers in Array You are provided with an array of integers called `nums`, where exactly two elements appear only once, and all other elements appear exactly twice. Your task is to write a function that identifies the two elements which appear only once. Function Signature ```python def find_two_unique(nums: List[int]) -> List[int]: pass ``` # Input * A list of integers `nums` (1 <= len(nums) <= 10^5), where exactly two elements appear only once and all other elements appear exactly twice. # Output * Return a list with the two elements that appear only once. The order of the result does not matter. # Example ```python assert sorted(find_two_unique([1, 2, 1, 3, 2, 5])) == [3, 5] assert sorted(find_two_unique([7, 9, 7, 4])) == [4, 9] ``` # Constraints * The time complexity of your implementation should be O(N). * The space complexity of your implementation should be O(1). Notes - The order of the result is not important. - You may leverage the properties of the XOR operator and bit manipulation to find the solution. # Context Such a problem is critical for scenarios where paired data is expected with some singular discrepancies, such as error detection in signals, data corruption identification, or ensuring data integrity in replicated databases.","solution":"from typing import List def find_two_unique(nums: List[int]) -> List[int]: # Initialize xor to find the xor of the two unique elements xor = 0 for num in nums: xor ^= num # Find the rightmost set bit (bit that is 1) in the xor result rightmost_set_bit = xor & -xor # Initialize variables to store the two unique numbers num1 = 0 num2 = 0 # Divide numbers into two groups based on the rightmost set bit for num in nums: if num & rightmost_set_bit: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"# Question Context You are tasked with developing a function for a cybersecurity toolkit that analyzes log files to identify anomalies. Each log entry is supposed to appear twice, indicating it has been processed successfully. However, there might be instances where a log entry appears only once, indicating potential tampering or loss. Task Implement a function `single_number` that receives an array of integers, where every element appears twice except for one. The function should find and return the number that appears only once. Requirements 1. Your algorithm must run in linear time, O(n). 2. You should not use extra memory (constant space). Input Format - A list of integers `nums`. Output Format - An integer representing the single number. If all numbers appear in pairs, return 0. Constraints - The length of the input list is in the range [1, 10^5]. - Each integer in the list can be in the range [−10^9, 10^9]. Example ```python # Example 1 nums = [4, 1, 2, 1, 2] print(single_number(nums)) # Output: 4 # Example 2 nums = [2, 2, 1] print(single_number(nums)) # Output: 1 # Example 3 nums = [1] print(single_number(nums)) # Output: 1 # Example 4 nums = [] print(single_number(nums)) # Output: 0 ``` Edge Cases 1. An empty array should return 0. 2. An array with one element should return the element itself. **Note: Ensure your solution adheres to the specified time and space complexity requirements.**","solution":"def single_number(nums): Finds the single number in the list where every other number appears twice. Args: nums (list): List of integers with one outlier that appears once. Returns: int: The single number that appears once. result = 0 for num in nums: result ^= num return result"},{"question":"You are given an array of integers. Your task is to implement a function that sorts the array using Pigeonhole Sort. # Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` # Input * `arr`(List[int]): An array of integers (both negative and positive values allowed) # Output * Returns a list of integers sorted in non-decreasing order. # Constraints 1. The number of elements in the array, ( n ), is such that ( 1 leq n leq 10^6 ). 2. The integers in the array can range from (-10^6) to (10^6). # Example ```python assert pigeonhole_sort([8, 3, 2, 7, 4]) == [2, 3, 4, 7, 8] assert pigeonhole_sort([1, 4, 1, 2, 7, 5, 2]) == [1, 1, 2, 2, 4, 5, 7] ``` # Explanation 1. You must calculate the range (difference between the maximum and minimum values) in the array. 2. Allocate an auxiliary space large enough to hold all values within this range. 3. Place each value into the corresponding \\"hole\\" (index). 4. Iterate through the list of \\"holes\\" and reassemble the sorted array. Ensure to handle negative values correctly by shifting indices accordingly.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: Sorts an array of integers using Pigeonhole Sort algorithm. if not arr: return [] # Find the minimum and maximum values in the array min_val = min(arr) max_val = max(arr) # Calculate the range of elements size = max_val - min_val + 1 # Create a list of empty lists to act as pigeonholes holes = [[] for _ in range(size)] # Place each element in its respective pigeonhole for num in arr: holes[num - min_val].append(num) # Reconstruct the sorted array sorted_arr = [] for hole in holes: sorted_arr.extend(hole) return sorted_arr"},{"question":"# Coding Task: Optimized Prim\'s Algorithm Implementation Context You are tasked with designing a network for a new city. To minimize the cost, you need to find the minimum spanning tree (MST) in the city\'s communication system, represented as a connected graph. Task Implement an optimized version of Prim\'s Algorithm to calculate the weight of the MST for a given graph. Ensure you handle edge cases and performance optimizations effectively. Function Signature ```python def optimized_prims_minimum_spanning(graph: Dict[str, List[Tuple[int, str]]]) -> int: Calculate the weight of the minimum spanning tree :param graph: A dictionary representing the graph where keys are node names and values are lists of tuples (weight, adjacent_node) :return: The total weight of the minimum spanning tree ``` Input and Output * **Input**: * `graph`: A dictionary where the keys are node identifiers (str) and the values are lists of tuples. Each tuple contains a weight (int) and an adjacent node identifier (str). Example: ```python graph = { \'a\': [(3, \'b\'), (8, \'c\')], \'b\': [(3, \'a\'), (5, \'d\')], \'c\': [(8, \'a\'), (2, \'d\'), (4, \'e\')], \'d\': [(5, \'b\'), (2, \'c\'), (6, \'e\')], \'e\': [(4, \'c\'), (6, \'d\')] } ``` * **Output**: * Returns an integer representing the total weight of the MST. Constraints * The input graph is connected. * Nodes are represented by strings. * Weights are positive integers. Performance Requirements * Your implementation should have a time complexity of O(E log V) and a space complexity of O(V).","solution":"import heapq def optimized_prims_minimum_spanning(graph): Calculate the weight of the minimum spanning tree using an optimized version of Prim\'s Algorithm. :param graph: A dictionary representing the graph where keys are node names and values are lists of tuples (weight, adjacent_node) :return: The total weight of the minimum spanning tree if not graph: return 0 start_node = next(iter(graph)) min_heap = [(0, start_node)] visited = set() total_weight = 0 while min_heap: weight, node = heapq.heappop(min_heap) if node not in visited: visited.add(node) total_weight += weight for edge_weight, adjacent_node in graph[node]: if adjacent_node not in visited: heapq.heappush(min_heap, (edge_weight, adjacent_node)) return total_weight"},{"question":"# Longest Common Prefix Challenge Scenario: You are part of a software team developing an intelligent text prediction tool. One feature you are implementing is a mechanism to identify the longest common prefix in a user\'s previously typed strings to enhance autocomplete suggestions. You need to develop a solution that finds this longest common prefix among a set of strings. Function Signature: ```python def find_longest_common_prefix(strs: List[str]) -> str: pass ``` Expected Input and Output: * **Input**: A list of `n` strings (`1 <= n <= 200`, `0 <= len(strs[i]) <= 200`). * **Output**: A single string representing the longest common prefix shared by all input strings. If there\'s no common prefix, return an empty string. Constraints: * Strings contain only lowercase English letters. Performance Requirements: * Aim to achieve the solution with the considered complexity of O(N*M). Example Case: **Example 1**: ```python Input: [\\"intelligent\\", \\"integral\\", \\"integration\\"] Output: \\"inte\\" ``` **Example 2**: ```python Input: [\\"apple\\", \\"banana\\", \\"carrot\\"] Output: \\"\\" ``` Instructions: 1. Utilize the Divide and Conquer approach detailed in the provided code snippets. 2. Think about handling edge cases like empty lists or strings with no common prefix. 3. Ensure your code is efficient and can handle the upper bounds of input sizes gracefully. Evaluation: Your submission will be evaluated on: * Correctness of output. * Efficiency and scalability with larger datasets. * Handling of edge cases. * Code readability and simplicity. Good luck, and let\'s see how effectively you can harness string manipulations to build reliable features for future intelligent tools!","solution":"def find_longest_common_prefix(strs): Finds the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string. if not strs: return \\"\\" # The longest possible prefix is the first string itself prefix = strs[0] for string in strs[1:]: while prefix and not string.startswith(prefix): # Reduce the prefix by one character at a time prefix = prefix[:-1] if not prefix: break return prefix"},{"question":"You are tasked with creating an enhanced version of the Insertion Sort algorithm. Besides the typical sorting functionality, your implementation will include the following features: 1. A function that allows the user to specify whether they want a simulation of the sorting process that shows the state of the array after each insertion step. 2. Proper handling of edge cases such as an empty list and a list with a single element. 3. An additional feature that checks if the array is already sorted before proceeding with the sorting process. # Function Signature You need to implement the following function: ```python def enhanced_insertion_sort(arr: list, simulation: bool = False) -> list: Sorts the given list using insertion sort algorithm. Args: arr : list : List of integers to sort. simulation : bool : If True, print the array after each iteration to show the sorting simulation. Returns: list : Sorted list of integers. ``` # Input * `arr`: A list of integers. (0 <= len(arr) <= 10^6) * `simulation`: A boolean flag that, if True, prints the array after each iteration to show the sorting simulation. # Output * Returns the sorted list of integers. # Example ```python >>> enhanced_insertion_sort([4, 3, 2, 10, 12, 1, 5, 6], simulation=True) iteration 0 : 4 3 2 10 12 1 5 6 iteration 1 : 3 4 2 10 12 1 5 6 iteration 2 : 2 3 4 10 12 1 5 6 iteration 3 : 2 3 4 10 12 1 5 6 iteration 4 : 2 3 4 10 12 1 5 6 iteration 5 : 1 2 3 4 10 12 5 6 iteration 6 : 1 2 3 4 5 10 12 6 iteration 7 : 1 2 3 4 5 6 10 12 [1, 2, 3, 4, 5, 6, 10, 12] >>> enhanced_insertion_sort([], simulation=False) [] >>> enhanced_insertion_sort([1], simulation=False) [1] >>> enhanced_insertion_sort([1,2,3], simulation=False) Already sorted [1, 2, 3] ``` # Constraints * The solution must have a time complexity of O(n^2) and a space complexity of O(1). * The function should provide verbose simulation output when `simulation` is set to `True`.","solution":"def enhanced_insertion_sort(arr: list, simulation: bool = False) -> list: Sorts the given list using insertion sort algorithm. Args: arr : list : List of integers to sort. simulation : bool : If True, print the array after each iteration to show the sorting simulation. Returns: list : Sorted list of integers. # Edge case: Empty list or list with one element if len(arr) <= 1: return arr # Check if the array is already sorted is_sorted = True for i in range(1, len(arr)): if arr[i] < arr[i-1]: is_sorted = False break if is_sorted: if simulation: print(\\"Already sorted\\") return arr # Insertion Sort Algorithm for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(f\\"iteration {i} :\\", \' \'.join(map(str, arr))) return arr"},{"question":"# Question You are given a singly linked list and an integer `k`. Your task is to implement a function that returns the node at the k-th position from the end of the list. If `k` exceeds the length of the list, the function should raise an appropriate error. Function Signature ```python def kth_to_last(head: Node, k: int) -> Node: pass ``` Input - `head`: The head node of the singly linked list. - `k`: A non-negative integer representing the position from the end. Output - Returns the k-th node from the end of the linked list. Constraints - The linked list will contain between `0` to `10^4` nodes. - `k` will be a non-negative integer. Performance Requirements - Your implementation should strive to operate in O(n) time complexity and O(1) space complexity. Example ```python # Helper node class class Node(): def __init__(self, val=None): self.val = val self.next = None def test_linked_list(): a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Test cases assert kth_to_last(a1, 0).val == \\"G\\" assert kth_to_last(a1, 1).val == \\"F\\" assert kth_to_last(a1, 2).val == \\"C\\" assert kth_to_last(a1, 4).val == \\"D\\" assert kth_to_last(a1, 7).val == \\"A\\" try: kth_to_last(a1, 8) except IndexError: print(\\"Caught IndexError as expected\\") ``` Testing Your Implementation Write test cases to validate that your function works as expected for various cases, including edge cases like an empty list or `k` exceeding the list length.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def kth_to_last(head: Node, k: int) -> Node: Returns the k-th node from the end of the linked list. :param head: The head node of the singly linked list. :param k: A non-negative integer representing the position from the end. :return: The k-th node from the end of the list. :raises: IndexError if k exceeds the length of the list. if not head: raise IndexError(\\"List is empty\\") # Set up two pointers slow = fast = head # Move the fast pointer k steps ahead for _ in range(k): if not fast.next: raise IndexError(\\"k exceeds the length of the list\\") fast = fast.next # Move both pointers until fast reaches the end while fast.next: slow = slow.next fast = fast.next return slow"},{"question":"# Introduction You are developing a simulation for a new gaming platform. The rules for certain game levels stipulate that power-ups only appear if the score is a power of two. As part of this feature, you need to implement a function that checks if a given score is a power of two. # Objective Write a function `is_power_of_two(n)` that determines if a given integer `n` is a power of two. The function should return `True` if `n` is a power of two, and `False` otherwise. # Function Signature ```python def is_power_of_two(n): Determine if n is a power of two. :param n: An integer to check. :type n: int :return: True if n is a power of two, False otherwise. :rtype: bool ``` # Input * An integer `n` where -2^31 ≤ n ≤ 2^31 - 1. # Output * A boolean value: - `True` if `n` is a power of two. - `False` otherwise. # Constraints * The function should run in constant time O(1). # Example ```python >>> is_power_of_two(1) True >>> is_power_of_two(16) True >>> is_power_of_two(18) False >>> is_power_of_two(0) False >>> is_power_of_two(-8) False ``` # Notes - Be sure to handle edge cases such as zero and negative numbers. - Powers of two are numbers like 1, 2, 4, 8, 16, 32, etc.","solution":"def is_power_of_two(n): Determine if n is a power of two. :param n: An integer to check. :type n: int :return: True if n is a power of two, False otherwise. :rtype: bool if n <= 0: return False return (n & (n - 1)) == 0"},{"question":"You are given two singly linked lists that may or may not intersect at some node. Your task is to implement a function that determines the node at which the intersection of two linked lists begins. **Function Signature** ```python def intersection(head1: Node, head2: Node) -> Node: pass ``` # Input - `head1`: The head node of the first singly linked list. - `head2`: The head node of the second singly linked list. # Output - Return the reference to the intersection node if the linked lists intersect. Otherwise, return `None`. # Constraints - The linked lists are non-cyclical. - Nodes contain integer values within realistic data ranges. # Example ```python class Node(object): def __init__(self, value=None): self.value = value self.next = None # Example Construct: # 1 -> 3 -> 5 -> 7 -> 9 -> 11 # # 17 -> 19 # / # 2 -> 4 -> 6--------------- h1 = Node(1) h1.next = Node(3) h1.next.next = Node(5) intersection_node = Node(7) h1.next.next.next = intersection_node h1.next.next.next.next = Node(9) h1.next.next.next.next.next = Node(11) h1.next.next.next.next.next.next = Node(17) h1.next.next.next.next.next.next.next = Node(19) h2 = Node(2) h2.next = Node(4) h2.next.next = Node(6) h2.next.next.next = intersection_node assert intersection(h1, h2).value == 7 assert intersection(h1.next.next, h2).value == 7 assert intersection(h1.next.next.next.next, h2.next.next.next).value == 7 ``` # Explanation In the example given, the intersection starts at node with value `7`. # Considerations - Handle edge cases, such as empty lists where the function should return `None`. - Account for varying lengths of the linked lists and the scenarios where they do not intersect. - Perform thorough tests to validate the correctness and efficiency of your code.","solution":"class Node: def __init__(self, value=None): self.value = value self.next = None def get_length(head: Node) -> int: length = 0 current = head while current: length += 1 current = current.next return length def intersection(head1: Node, head2: Node) -> Node: if not head1 or not head2: return None len1 = get_length(head1) len2 = get_length(head2) current1 = head1 current2 = head2 if len1 > len2: for _ in range(len1 - len2): current1 = current1.next elif len2 > len1: for _ in range(len2 - len1): current2 = current2.next while current1 and current2: if current1 == current2: return current1 current1 = current1.next current2 = current2.next return None"},{"question":"Postorder Traversal of a Binary Tree You are given the root of a binary tree. Implement a function to return the nodes\' values in postorder traversal. # Function Signature ```python def postorder_traversal(root: Optional[Node]) -> List[int]: pass ``` # Input - `root`: A reference to the root node of a binary tree. This can be `None` if the tree is empty. # Output - A list of integers representing the postorder traversal of the binary tree. # Constraints - The number of nodes in the tree is in the range [0, 10^4]. - `-10^5 <= Node.val <= 10^5` # Examples Example 1: ```plaintext Input: root = [1, None, 2, 3] Output: [3, 2, 1] Explanation: 1 2 / 3 The postorder traversal of the given tree is [3, 2, 1] ``` Example 2: ```plaintext Input: root = [] Output: [] Explanation: The tree is empty, so the output list is empty. ``` # Additional Notes - You can use either iterative or recursive approach. - Ensure your implementation efficiently handles all edge cases and performs within the constraints given.","solution":"from typing import Optional, List class Node: def __init__(self, val: int = 0, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.val = val self.left = left self.right = right def postorder_traversal(root: Optional[Node]) -> List[int]: def dfs_postorder(node: Optional[Node], result: List[int]) -> None: if not node: return dfs_postorder(node.left, result) dfs_postorder(node.right, result) result.append(node.val) result = [] dfs_postorder(root, result) return result"},{"question":"**Problem Statement:** You are given an array of integers sorted in ascending order and a target integer. Write a function `find_pair_with_sum` that finds two distinct numbers in the array which add up to the target. The function should return the 1-based indices of these two numbers such that `index1` is less than `index2`. If no such pair exists, return an empty list. Implement this function using an optimal approach with regards to time and space complexity. **Function Signature:** ```python def find_pair_with_sum(numbers: List[int], target: int) -> List[int]: pass ``` **Input:** - `numbers`: A list of `n` integers, sorted in ascending order, where `2 <= n <= 10^4`. - `target`: An integer which is the sum of two distinct elements from `numbers`. **Output:** - A list of two integers representing the 1-based indices of the numbers that add up to the target, or an empty list if no such pair exists. **Constraints:** 1. Each input list will have exactly one solution. 2. You may not use the same element twice. 3. The list is guaranteed to be sorted in ascending order. **Example:** ```python # Example 1 numbers = [2, 7, 11, 15] target = 9 print(find_pair_with_sum(numbers, target)) # Output: [1, 2] # Example 2 numbers = [1, 2, 3, 4, 6] target = 10 print(find_pair_with_sum(numbers, target)) # Output: [4, 5] # Example 3 numbers = [2, 3, 4] target = 6 print(find_pair_with_sum(numbers, target)) # Output: [1, 3] # Example 4 numbers = [-1, 0] target = -1 print(find_pair_with_sum(numbers, target)) # Output: [1, 2] ``` Note: Remember to consider edge cases such as minimal input size and the absence of a valid pair scenario (though guaranteed not to arise per constraints).","solution":"from typing import List def find_pair_with_sum(numbers: List[int], target: int) -> List[int]: Finds two distinct numbers in the sorted array \'numbers\' that add up to \'target\'. Returns the 1-based indices of these two numbers. If no pair is found, returns an empty list. left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] # Return 1-based indices elif current_sum < target: left += 1 else: right -= 1 return []"},{"question":"# Red-Black Tree: Key Deletion **Objective**: Implement the function **delete_key(self, key: int) -> None** for a Red-Black Tree `RBTree` class as described below using the provided skeleton. The function should remove the node with the specified key from the tree. **Input and Output**: - **Input**: An integer key `key` to be deleted from the tree. - **Output**: None (in-place deletion). **Constraints**: 1. The key to be deleted is guaranteed to exist in the tree. 2. The function should maintain all Red-Black Tree properties after deletion. 3. Should handle all necessary rotations and color adjustments. 4. The tree should be updated in-place. **Performance Requirement**: The deletion should be efficient, maintaining the worst-case time complexity of O(log n). # Implementation Steps: 1. Locate the node with the specified key. 2. Perform the standard BST deletion process. 3. Maintain the Red-Black Tree properties through necessary rotations and color changes. ```python class RBNode: def __init__(self, val, is_red, parent=None, left=None, right=None): self.val = val self.parent = parent self.left = left self.right = right self.color = is_red class RBTree: def __init__(self): self.root = None # Existing methods... def delete_key(self, key: int) -> None: Deletes a node with the given key from the Red-Black Tree. :param key: integer key to delete # Your implementation here ``` Your solution must handle all necessary cases for deletion and ensure the tree remains balanced and all properties of the Red-Black Tree are maintained. **Example**: If the tree initially is: 11(B) / 2(R) 14(B) / 1(B) 7(B) 15(R) / 5(R) 8(R) / 4(B) Deleting the key `7` should result in: 11(B) / 2(R) 14(B) / 1(B) 15(R) / 5(R) 8(B) / 4(B) **Test your solution thoroughly to ensure every edge case is handled correctly.**","solution":"class RBNode: def __init__(self, val, is_red, parent=None, left=None, right=None): self.val = val self.parent = parent self.left = left self.right = right self.color = is_red class RBTree: def __init__(self): self.root = None def delete_key(self, key: int) -> None: Deletes a node with the given key from the Red-Black Tree. :param key: integer key to delete # Function to find the node with given key def find_node(node, key): while node is not None and node.val != key: if key < node.val: node = node.left else: node = node.right return node # Helper functions and handling of node deletions and fixes def transplant(u, v): if u.parent is None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v if v is not None: v.parent = u.parent def tree_minimum(node): while node.left is not None: node = node.left return node def delete_fixup(x): while x != self.root and (x is None or not x.color): if x == x.parent.left: w = x.parent.right if w.color: w.color = False x.parent.color = True left_rotate(x.parent) w = x.parent.right if (w.left is None or not w.left.color) and (w.right is None or not w.right.color): w.color = True x = x.parent else: if w.right is None or not w.right.color: if w.left: w.left.color = False w.color = True right_rotate(w) w = x.parent.right w.color = x.parent.color x.parent.color = False if w.right: w.right.color = False left_rotate(x.parent) x = self.root else: w = x.parent.left if w.color: w.color = False x.parent.color = True right_rotate(x.parent) w = x.parent.left if (w.left is None or not w.left.color) and (w.right is None or not w.right.color): w.color = True x = x.parent else: if w.left is None or not w.left.color: if w.right: w.right.color = False w.color = True left_rotate(w) w = x.parent.left w.color = x.parent.color x.parent.color = False if w.left: w.left.color = False right_rotate(x.parent) x = self.root if x: x.color = False def left_rotate(x): y = x.right x.right = y.left if y.left is not None: y.left.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(x): y = x.left x.left = y.right if y.right is not None: y.right.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y node_to_delete = find_node(self.root, key) if node_to_delete is None: return # Node with the key not found, nothing to delete y = node_to_delete y_original_color = y.color if node_to_delete.left is None: x = node_to_delete.right transplant(node_to_delete, node_to_delete.right) elif node_to_delete.right is None: x = node_to_delete.left transplant(node_to_delete, node_to_delete.left) else: y = tree_minimum(node_to_delete.right) y_original_color = y.color x = y.right if y.parent == node_to_delete: if x: # Handle case when x could be None x.parent = y else: transplant(y, y.right) y.right = node_to_delete.right y.right.parent = y transplant(node_to_delete, y) y.left = node_to_delete.left y.left.parent = y y.color = node_to_delete.color if not y_original_color and x is not None: delete_fixup(x) if node_to_delete == self.root and not self.root.right and not self.root.left: self.root = None # tree is empty now"},{"question":"# Context You\'re given an array of integers that needs to be sorted efficiently. Shell Sort, an optimization over insertion sort, can handle this task well for moderately sized arrays due to its gap-based approach. # Problem Statement Implement the Shell Sort algorithm using the specified gaps and ensure that you handle edge cases correctly. Write a function `shell_sort` that takes in a list of integers and returns the sorted list. # Function Signature ```python def shell_sort(arr: List[int]) -> List[int]: pass ``` # Input - `arr`: A list of integers, where ( 1 leq text{len(arr)} leq 10^5 ) * Example: `[12, 34, 54, 2, 3]` # Output - A list of integers sorted in ascending order. * Example: `[2, 3, 12, 34, 54]` # Constraints - You should not use built-in sort functions. - Your implementation should run with a time complexity not exceeding ( O(n^2) ). # Requirements 1. Use the described gap sequence as the initial halve of the array length, reducing the gap on each iteration by half. 2. Ensure that the array is fully sorted by the completion of the algorithm. 3. Handle edge cases such as empty arrays, arrays with one element, and already sorted or completely reverse sorted arrays. # Example ```python >>> arr = [12, 34, 54, 2, 3] >>> shell_sort(arr) [2, 3, 12, 34, 54] ``` # Additional Notes - You may assume input data is always valid (no need to consider invalid inputs). - The function should modify the array in place to adhere to O(1) space complexity in terms of auxiliary data structures.","solution":"from typing import List def shell_sort(arr: List[int]) -> List[int]: n = len(arr) gap = n // 2 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"# Problem Description You are tasked with creating a function to convert a sequence of bytes in both big-endian and little-endian formats back into an integer and vice versa for use in cross-platform data size conversions in network protocols. This will help ensure that data integrity is maintained irrespective of the differing endianness of communicating systems. # Function Signature ```python def int_to_bytes(num: int, endian: str) -> bytes: pass def bytes_to_int(bytestr: bytes, endian: str) -> int: pass ``` # Input 1. For `int_to_bytes`: * An integer `num` (0 <= num <= 2**64 - 1) * A string `endian` which can be either \\"big\\" or \\"little\\" denoting the byte order. 2. For `bytes_to_int`: * A bytes object `bytestr` * A string `endian` which can be either \\"big\\" or \\"little\\" denoting the byte order. # Output 1. For `int_to_bytes`: A bytes object representing the integer in the specified endianness. 2. For `bytes_to_int`: An integer represented by the given bytes object in the specified endianness. # Constraints & Performance Requirements - The solution should handle the integer values up to 64-bit and represent them correctly in both endianness formats. - The solution should handle zero values and large values efficiently. - Assume inputs are well-formed and won\'t contain invalid data for conversions. # Examples ```python assert int_to_bytes(1024, \'big\') == b\'x04x00\' assert int_to_bytes(1024, \'little\') == b\'x00x04\' assert bytes_to_int(b\'x04x00\', \'big\') == 1024 assert bytes_to_int(b\'x00x04\', \'little\') == 1024 ``` # Additional Instructions 1. Ensure that your code is well-documented and handles converting both to and from integers in the specified byte orders. 2. Pay attention to handling edge cases like zero and maximally sized integers. 3. Avoid using any external libraries; your implementations should rely on core Python functionalities.","solution":"def int_to_bytes(num: int, endian: str) -> bytes: Convert an integer to its bytes representation in the specified endian format. Args: num (int): The integer to convert. (0 <= num <= 2**64 - 1) endian (str): The byte order to use. Can be \'big\' or \'little\'. Returns: bytes: The bytes representation of the integer. if not (0 <= num <= (2**64 - 1)): raise ValueError(\\"num must be between 0 and 2**64 - 1\\") if endian not in (\'big\', \'little\'): raise ValueError(\\"endian must be \'big\' or \'little\'\\") return num.to_bytes((num.bit_length() + 7) // 8 or 1, byteorder=endian) def bytes_to_int(bytestr: bytes, endian: str) -> int: Convert a bytes object to its integer representation in the specified endian format. Args: bytestr (bytes): The bytes object to convert. endian (str): The byte order to use. Can be \'big\' or \'little\'. Returns: int: The integer representation of the bytes object. if endian not in (\'big\', \'little\'): raise ValueError(\\"endian must be \'big\' or \'little\'\\") return int.from_bytes(bytestr, byteorder=endian)"},{"question":"Flatten Nested Arrays You are tasked with writing a function `flatten_array` that takes a nested array and returns a single-level flattened array. The function should handle varying levels of nested arrays and different data types within the arrays appropriately. **Function Signature** ```python def flatten_array(input_array: list) -> list: pass ``` # Requirements 1. **Input Format** - A single parameter `input_array` which is a list containing elements that may also be lists (nested to any depth). 2. **Output Format** - A single list that contains all the elements from `input_array` flattened to one level. 3. **Constraints** - The elements within the array can be of any type including integers, strings, or other non-iterable objects. - The nested arrays may be arbitrarily deep. - Preserve the original order of elements as they appear in the nested structure. 4. **Performance Requirements** - The function should efficiently handle large and deeply nested arrays. - Aim for minimal usage of additional space. # Example ```python # Example 1 input_array = [1, [2, [3, [4]], 5], [6, 7], 8] print(flatten_array(input_array)) # Expected Output: [1, 2, 3, 4, 5, 6, 7, 8] # Example 2 input_array = [[1, 2, 3], [4, 5], 6, [[7, 8], 9], 10] print(flatten_array(input_array)) # Expected Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # Example 3 input_array = [] print(flatten_array(input_array)) # Expected Output: [] ``` # Additional Notes 1. Consider edge cases such as: - Empty arrays. - Arrays where some elements are not lists, and some are deeply nested. - Mixed element types and structures within the arrays. 2. Optimize for efficient execution and minimal memory usage where possible.","solution":"def flatten_array(input_array: list) -> list: def _flatten(arr): for el in arr: if isinstance(el, list): yield from _flatten(el) else: yield el return list(_flatten(input_array))"},{"question":"# Question: Efficient Fibonacci Number Calculation You are working on a project that requires frequent computation of Fibonacci numbers for a given input \'n\'. You already have a recursive implementation that works but is too slow for large input values. You decide to implement two other more efficient methods discussed in your algorithm and data structures class. Implement a function `fibonacci(n: int) -> int` that calculates the n-th Fibonacci number using an efficient iterative approach. Your function should adhere to the following constraints and properties: 1. **Input**: - An integer `n` (0 <= n <= 10^5). 2. **Output**: - An integer representing the n-th Fibonacci number. 3. **Constraints**: - Your solution should be able to handle very large `n` efficiently. - Ensure that the solution has O(n) time complexity and O(1) space complexity. - Handle edge cases gracefully (e.g., n = 0, n = 1). Specifications: * **Function**: `fibonacci(n: int) -> int` * **Input**: An integer `n` * **Output**: An integer, the n-th Fibonacci number Example: ```python assert fibonacci(0) == 0 assert fibonacci(1) == 1 assert fibonacci(10) == 55 assert fibonacci(100) == 354224848179261915075 ``` Implement the `fibonacci` function in Python. Please ensure that your function handles edge cases properly and adheres to the provided constraints.","solution":"def fibonacci(n: int) -> int: Returns the n-th Fibonacci number using an iterative approach. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"In a queue at an amusement park, each person is described by a pair of integers (h, k), where: - `h` is the height of the person. - `k` is the number of people standing in front of this person who have a height greater than or equal to `h`. Your task is to write a function, `reconstruct_queue(people)`, that reconstructs and returns the queue in its correct order according to the provided descriptions. # Function Signature ```python def reconstruct_queue(people: List[List[int]]) -> List[List[int]]: ``` # Inputs - `people`: a list of pairs `[h, k]`, where `h` is an integer representing the height and `k` is the number of people standing before the person having a height greater than or equal to `h`. - The length of `people` will be less than 1,100. # Outputs - The function should return a reconstructed list of pairs `[h, k]` that satisfies the given conditions. # Constraints - The queue reconstruction should maintain the relative order of people based on the constraints described by the pairs `[h, k]`. # Example **Input**: ```python [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] ``` **Output**: ```python [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] ``` **Explanation**: - The person with height 5 and k=0 is first in the queue: [5,0] - The person with height 7 and k=0 is second in the queue: [5,0], [7,0] - The person with height 5 and k=2 goes in the 3rd position: [5,0], [7,0], [5,2] - And so on... # Additional Information You must ensure that the solution respects the relationships between heights and k-values. Consider different scenarios like: - Different people having the same height. - Edge case where no people are in the list. - Maximum value for `k`. Good luck and happy coding!","solution":"def reconstruct_queue(people): # Sort people by height in descending order. # If heights are equal, sort by k value in ascending order. people.sort(key=lambda x: (-x[0], x[1])) queue = [] for person in people: queue.insert(person[1], person) return queue"},{"question":"Efficient Set Coverage Context: You are working with a large network of data centers. To ensure service reliability, certain critical tasks must be covered by overlapping responsibilities across different data centers. The goal is to cover all tasks with the minimum operational cost by selecting an optimal subcollection of responsibilities from the data centers. Task: Implement a function `efficient_set_cover` that approximates an optimal set cover using a greedy approach but strives to improve upon simple greedy algorithms by incorporating cost efficiency and minimizing repetitions. Function Signature: `def efficient_set_cover(universe: set, subsets: dict, costs: dict) -> list:` Inputs: 1. `universe` (set): A set of elements representing tasks to be covered. 2. `subsets` (dict): A dictionary where each key is a subset identifier and the value is a set of elements that subset covers. 3. `costs` (dict): A dictionary where each key is a subset identifier, and the value is an integer denoting the cost associated with covering that subset. Outputs: 1. `list`: A list of subset identifiers representing the selected subsets that cover all the tasks in the universe with an approximately minimal cost. Constraints: * Each subset in `subsets` and `costs` will have unique identifiers and valid integer costs. * The `universe` will be non-empty, and it is guaranteed there will be a valid covering set. Performance Requirements: * Aim for a best possible approximation of the optimal solution keeping the runtime within O(m * n) considering the input size constraints. # Example: ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} result = efficient_set_cover(universe, subsets, costs) print(result) # Output might be [\'S3\', \'S2\'] with Cost being 13 or another minimal cost combination ``` Notes: * Thoroughly test the function with various edge cases, such as: - Minimal input sizes. - Large overlapping subsets. - High variation in costs. Hint: * Consider using additional data structures to track uncovered tasks efficiently and utilize heuristic approaches for the greedy selection.","solution":"def efficient_set_cover(universe, subsets, costs): Approximate solution to the Set Cover problem using a cost-effective greedy algorithm. selected_subsets = [] uncovered = universe.copy() while uncovered: # Choose the subset with the best cost per uncovered element ratio best_subset = None best_cost_efficiency = float(\'inf\') for subset_id, subset in subsets.items(): covered_elements = uncovered & subset if covered_elements: cost_efficiency = costs[subset_id] / len(covered_elements) if cost_efficiency < best_cost_efficiency: best_cost_efficiency = cost_efficiency best_subset = subset_id if best_subset is None: raise ValueError(\\"No subset can cover remaining elements.\\") # Add the best subset to the selected list selected_subsets.append(best_subset) # Remove the covered elements from the uncovered set uncovered -= subsets[best_subset] return selected_subsets"},{"question":"# Challenging Coding Assessment Question: Cycle Sort **Objective**: Implement the Cycle Sort algorithm to sort a given list of integers. **Function Signature**: `def cycle_sort(arr: List[int]) -> List[int]:` Input & Output Formats **Input**: * A list of integers `arr` where ( 0 leq text{len(arr)} leq 10^4 ). **Output**: * A sorted list of integers in ascending order, sorted in-place using Cycle Sort algorithm. Constraints 1. If the list contains duplicate elements, your implementation must handle them correctly. 2. The algorithm should minimize the number of write operations. 3. Do not use any built-in sort functions or additional storage beyond a few temporary variables. Performance Requirements * Your solution should target a time complexity of ( O(N^2) ) and space complexity of ( O(1) ). Scenario Consider you are working with a device that has a very limited write cycle for its memory cells, such as an EEPROM or certain flash memories. Each write operation reduces the lifespan of the memory cell. Your task is to sort the data array in place, minimizing the number of write operations to preserve the memory as much as possible. Example ```python # Example 1 input: [3, 5, 2, 1, 4] output: [1, 2, 3, 4, 5] # Example 2 input: [10, -1, 0, 3, 3, 2] output: [-1, 0, 2, 3, 3, 10] # Example 3 input: [] output: [] ``` Implement the `cycle_sort` function based on the requirements above.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: n = len(arr) # Loop through the array to find cycles to rotate. for cycle_start in range(0, n - 1): item = arr[cycle_start] # Find the position where we put the element. pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position. if pos == cycle_start: continue # Otherwise, put the item there or right after any duplicates. while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] # Rotate the rest of the cycle. while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"# Quick Sort Implementation with Custom Pivot Selection Context Quick Sort is a popular and efficient sorting algorithm. However, its performance relies heavily on the choice of the pivot element. The provided implementation always selects the last element as the pivot, which can degrade performance in certain cases. Task Write a function `custom_quick_sort(arr, pivot_strategy=\'last\')` that sorts an array using Quick Sort, allowing for different pivot selection strategies. Instructions 1. Implement the `custom_quick_sort` function which should take the following parameters: - `arr` (list of integers): the array to be sorted. - `pivot_strategy` (string): the pivot selection strategy. It can be \'first\', \'last\', \'median\', or \'random\'. 2. Adjust the partitioning logic to choose the pivot based on the provided `pivot_strategy`. 3. Function signature: ```python def custom_quick_sort(arr, pivot_strategy=\'last\'): # Your code here ``` 4. Return the sorted array. Constraints - The input array may contain duplicate elements. - The input array length will be between 0 and 10^4. - You should aim for an average time complexity of O(n log(n)). Sample Input/Output ```python # Example 1: arr = [3, 6, 8, 10, 1, 2, 1] sorted_arr = custom_quick_sort(arr, pivot_strategy=\'first\') # expected output: [1, 1, 2, 3, 6, 8, 10] # Example 2: arr = [3, 6, 8, 10, 1, 2, 1] sorted_arr = custom_quick_sort(arr, pivot_strategy=\'median\') # expected output: [1, 1, 2, 3, 6, 8, 10] ``` Edge Cases - Test the function with an empty array. - Test with an array that contains all identical elements.","solution":"import random def custom_quick_sort(arr, pivot_strategy=\'last\'): Sorts the array using Quick Sort with a custom pivot selection strategy. Parameters: arr (list of int): The array to be sorted. pivot_strategy (str): The pivot selection strategy. It can be \'first\', \'last\', \'median\', or \'random\'. Returns: list of int: The sorted array. if len(arr) <= 1: return arr pivot_index = select_pivot(arr, pivot_strategy) arr[0], arr[pivot_index] = arr[pivot_index], arr[0] pivot = arr[0] left_part = [x for x in arr[1:] if x < pivot] right_part = [x for x in arr[1:] if x >= pivot] return custom_quick_sort(left_part, pivot_strategy) + [pivot] + custom_quick_sort(right_part, pivot_strategy) def select_pivot(arr, pivot_strategy): Selects the pivot based on the specified strategy. Parameters: arr (list of int): The array to be sorted. pivot_strategy (str): The pivot selection strategy. It can be \'first\', \'last\', \'median\', or \'random\'. Returns: int: The index of the selected pivot. if pivot_strategy == \'first\': return 0 elif pivot_strategy == \'last\': return len(arr) - 1 elif pivot_strategy == \'median\': return len(arr) // 2 elif pivot_strategy == \'random\': return random.randint(0, len(arr) - 1) else: raise ValueError(\\"Invalid pivot strategy\\")"},{"question":"**Problem Statement:** Write a function, `insertion_sort`, that sorts an array of integers using the insertion sort algorithm. To handle the insertion efficiently, utilize a helper function `search_insert` that determines the appropriate index to insert each element. **Function Signature:** ```python def insertion_sort(array: list) -> list: ``` **Input:** * A list of integers `array` where `1 <= len(array) <= 10^4`. **Output:** * A list of integers sorted in non-decreasing order. **Examples:** ```python insertion_sort([4, 2, 7, 1, 3]) -> [1, 2, 3, 4, 7] insertion_sort([1, 2, 3, 4, 5]) -> [1, 2, 3, 4, 5] insertion_sort([5, 4, 3, 2, 1]) -> [1, 2, 3, 4, 5] ``` **Constraints:** * The input list is of moderate size, making insertion sort\'s average performance acceptable. * Perform the insertion step efficiently using a binary search. **Instructions:** 1. Define the `search_insert` function as provided in the initial analysis. 2. Implement the `insertion_sort` function which: * Iterates through the list. * Uses `search_insert` to find the position for each element. * Inserts the element at the correct position. * Maintains the order of previously sorted elements. **Performance Requirements:** * Ensure the implementation handles worst-case time complexity effectively using the helper function for insertion.","solution":"def search_insert(sorted_subarray, val): Binary search helper function to find the insertion index for the value `val` in the sorted portion of array `sorted_subarray`. Args: sorted_subarray (list): The portion of the array that is already sorted. val (int): The value to be inserted. Returns: int: The index where `val` should be inserted. left, right = 0, len(sorted_subarray) while left < right: mid = (left + right) // 2 if sorted_subarray[mid] < val: left = mid + 1 else: right = mid return left def insertion_sort(array): Sorts an array of integers using the insertion sort algorithm with the help of the binary search based insertion index search. Args: array (list): The list of integers to be sorted. Returns: list: A list of integers sorted in non-decreasing order. for i in range(1, len(array)): key = array[i] # Find the position where key should be inserted in the sorted portion of array pos = search_insert(array[:i], key) # Shift elements to the right to make space for the key array = array[:pos] + [key] + array[pos:i] + array[i+1:] return array"},{"question":"Context Cycle Sort is an in-place sorting algorithm that minimizes the number of memory writes. Your task is to implement this algorithm considering various scenarios and constraints. This will test your understanding of in-place sorting mechanisms and handling unique elements. Problem Statement Implement the Cycle Sort algorithm for an array of integers. Your implementation should sort the array in ascending order. Function Signature `def cycle_sort(arr: List[int]) -> List[int]:` Input * `arr`: A list of integers **arr** where 1 ≤ length of arr ≤ 10^4 and `-10^4 ≤ arr[i] ≤ 10^4`. Output * Return a sorted list of integers. Constraints * The function must operate in-place and should not use any additional data structures. * You must handle duplicate elements appropriately. * Minimize the number of writes to the array. Performance Requirements * The function should have a time complexity of O(N^2) in both average and worst-case scenarios. * The space complexity should be O(1) auxiliary space. Example ```python # Example 1 input: arr = [3, 1, 2, 5, 4] output: [1, 2, 3, 4, 5] # Example 2 input: arr = [4, 3, 2, 1, 0] output: [0, 1, 2, 3, 4] # Example 3 input: arr = [10] output: [10] ``` Scenario Consider a small inventory system where items need to be ordered by their IDs. The memory for sorting is limited, making Cycle Sort an appropriate solution. Ensure the IDs are sorted correctly and efficiently in limited memory environments.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: Sorts the input list in-place using Cycle Sort algorithm. :param arr: List of integers to sort. :return: The sorted list of integers. n = len(arr) # Traverse the array to find cycles to rotate. for cycle_start in range(0, n - 1): item = arr[cycle_start] pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 if pos == cycle_start: continue while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"Implementing a Randomized Set You are required to implement a data structure that supports efficient insertion, deletion, and random access operations in average O(1) time. This structure combines the functionalities of both a dynamic array and a hash map. **Requirements**: 1. **Insert**: Add an integer `val` to the set. If the integer is already present, it should not be added again. 2. **Remove**: Remove an integer `val` from the set. If the integer is not present, the operation should do nothing. 3. **Random Access**: Return a random integer from the set, where each element should have an equal probability of being chosen. **Function Signatures**: - `def insert(self, val: int) -> None:` - `def remove(self, val: int) -> None:` - `def random_element(self) -> int:` **Implementation Guidelines**: - Use a list to store the elements and a dictionary to map each element to its corresponding index. - Handle edge cases such as attempts to insert duplicates or remove elements that do not exist in the set. - Ensure that the `random_element` function can handle instances where the set is empty gracefully. **Example**: ``` python # Example of using RandomizedSet class # Initialize an empty set randomized_set = RandomizedSet() # Insert elements randomized_set.insert(1) # Adds 1 to the set. randomized_set.insert(2) # Adds 2 to the set. randomized_set.insert(3) # Adds 3 to the set. # Remove an element randomized_set.remove(2) # Removes 2 from the set. # Randomly access elements print(randomized_set.random_element()) # Should return either 1 or 3 with equal probability print(randomized_set.random_element()) # Should return either 1 or 3 with equal probability # Insert a duplicate element randomized_set.insert(1) # 1 is already present, so the set remains unchanged. randomized_set.insert(4) # Adds 4 to the set. ``` Implement the `RandomizedSet` class as per the provided specifications.","solution":"import random class RandomizedSet: def __init__(self): self.data = [] self.index_map = {} def insert(self, val: int) -> None: if val not in self.index_map: self.index_map[val] = len(self.data) self.data.append(val) def remove(self, val: int) -> None: if val in self.index_map: last_element = self.data[-1] idx_to_replace = self.index_map[val] self.data[idx_to_replace] = last_element self.index_map[last_element] = idx_to_replace self.data.pop() del self.index_map[val] def random_element(self) -> int: if not self.data: return None # Return None when the set is empty for graceful handling. return random.choice(self.data)"},{"question":"# Combination Sum Problem Given a set of candidate numbers (without duplicates) and a target number, write a function to find all unique combinations in the candidate set where the candidate numbers sum to the target. The same repeated number may be chosen from the candidate set an unlimited number of times. Function Signature ```python def combination_sum(candidates: List[int], target: int) -> List[List[int]]: ``` Input * `candidates` (List[int]): A list of positive integers representing the candidate numbers. * `target` (int): A positive integer representing the target sum. Output * List[List[int]]: A list of lists, where each inner list represents a unique combination of candidate numbers summing up to the target. Constraints * All numbers, including the target, will be positive integers. * The list of candidates does not contain any duplicate numbers. * The solution set must not contain duplicate combinations. * You can assume that there will be at least one valid combination for the given candidates and target. Example ```python # Example 1 candidates = [2, 3, 6, 7] target = 7 # Expect: [[7], [2, 2, 3]] # Example 2 candidates = [2, 3, 5] target = 8 # Expect: [[2, 2, 2, 2], [2, 3, 3], [3, 5]] ``` Requirements * Implement the function using DFS and backtracking. * Ensure that all combinations are unique and sorted. Scenario Imagine you are preparing a list of ingredients for a recipe. Each ingredient has a specific quantity (candidate) and you need to find all possible ways to sum up these quantities to reach the exact quantity required by the recipe (target). You can use the same ingredient multiple times but need to ensure there are no duplicate combinaations of ingredients in your list.","solution":"from typing import List def combination_sum(candidates: List[int], target: int) -> List[List[int]]: def backtrack(remain, combo, start): if remain == 0: res.append(list(combo)) return elif remain < 0: return for i in range(start, len(candidates)): combo.append(candidates[i]) backtrack(remain - candidates[i], combo, i) combo.pop() candidates.sort() res = [] backtrack(target, [], 0) return res"},{"question":"**Scenario**: A company has an organizational hierarchy stored as a binary tree. Each node represents an employee and the tree structure represents direct reporting. Given this hierarchical tree, you are asked to find the common manager (LCA) for any two employees. **Task**: Write a function `findLCA` that finds the Lowest Common Ancestor (LCA) of two given nodes in a binary tree. Ensure that your solution handles edge cases, such as missing nodes, and optimizes to handle large trees gracefully. **Function Signature**: ```python def findLCA(root, employee1, employee2): :type root: TreeNode :type employee1: TreeNode :type employee2: TreeNode :rtype: TreeNode ``` **Input**: - `root`: The root node of the binary tree. - `employee1`: The first employee node. - `employee2`: The second employee node. **Output**: - The lowest common ancestor node (LCA) of the two employees in the tree. **Constraints**: - The tree is a binary tree. - You may assume each node value is unique. - Nodes are identified by their values, no two nodes share the same value. **Example**: Given this company structure: ``` _______3______ / ___5__ ___1__ / / 6 _2 0 8 / 7 4 ``` Assume: - `findLCA(root, 5, 1)` returns `3`. - `findLCA(root, 5, 4)` returns `5`. **Hint**: - Consider using a recursive depth-first search (DFS) approach as outlined in the analysis.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def findLCA(root, employee1, employee2): :type root: TreeNode :type employee1: TreeNode :type employee2: TreeNode :rtype: TreeNode if root is None: return None if root == employee1 or root == employee2: return root left_lca = findLCA(root.left, employee1, employee2) right_lca = findLCA(root.right, employee1, employee2) if left_lca and right_lca: return root return left_lca if left_lca else right_lca"},{"question":"# Segment Tree Range Minimum Query **Problem Statement**: You are given an array of integers. Your task is to implement a Segment Tree to efficiently support the following operations: 1. **Build the Segment Tree**: Construct the segment tree from the given array. 2. **Range Minimum Query** (RMQ): Given a range [L, R], return the minimum element in the array within that range, inclusive. **Function Signatures**: ```python class SegmentTree: def __init__(self, arr: List[int]): def merge(x, y): return min(x, y) # Initialize Segment Tree with merge function as min # Your code here def query(self, L: int, R: int) -> int: # Your code here pass ``` **Input/Output**: - `__init__(arr: List[int])`: Initializes the Segment Tree with the given array. - `query(L: int, R: int) -> int`: Returns the minimum element in the range [L, R]. **Example**: ```python tree = SegmentTree([2, 4, 1, 3, 6, -1, 7]) assert tree.query(1, 4) == 1 assert tree.query(2, 5) == -1 assert tree.query(0, 6) == -1 ``` **Constraints**: - The length of the array will not exceed 10^5. - The elements of the array can be any integer within the range of -10^9 to 10^9. - 0 leq L leq R < len(arr). **Notes**: - Consider the Segment Tree implementations\' space complexity. - Handle edge cases correctly, such as empty input arrays, single-element arrays, and invalid query ranges.","solution":"from typing import List class SegmentTree: def __init__(self, arr: List[int]): self.n = len(arr) self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr: List[int]): for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[i * 2], self.tree[i * 2 + 1]) def query(self, L: int, R: int) -> int: L += self.n R += self.n + 1 minimum = float(\'inf\') while L < R: if L % 2: minimum = min(minimum, self.tree[L]) L += 1 if R % 2: R -= 1 minimum = min(minimum, self.tree[R]) L //= 2 R //= 2 return minimum"},{"question":"Fenwick Tree Implementation and Usage Context Imagine you are working with a financial tracking system where you need to frequently add transactions and compute the cumulative sum of transactions up to a certain point. For efficient handling of large transaction datasets, you decide to use a Fenwick Tree (Binary Indexed Tree). Task Implement a Fenwick Tree to manage the following operations: 1. **Add a transaction**: Update the total of transactions at a specific index. 2. **Compute cumulative sum**: Compute the sum of transactions from the start up to a specified index. Specifications * **Input**: - A list of initial transaction amounts (integers). * **Operations**: 1. `update_transaction(index, amount)`: Adds the specified amount to the transaction at the given index. 2. `cumulative_sum(index)`: Returns the cumulative sum of transactions from start up to the given index. Constraints * 0 <= index <= n-1 * Amount can be positive or negative. * For simplicity, assume the number of transactions (n) is within reasonable limits for practical usage (1 <= n <= 10^5). Example ```python # Initial transactions: [10, 20, 30, 40, 50] transactions = [10, 20, 30, 40, 50] ft = FenwickTree(transactions) # Perform a cumulative sum query print(ft.cumulative_sum(3)) # Output: 100 # Update a transaction: add 15 to index 2 ft.update_transaction(2, 15) # Perform another cumulative sum query print(ft.cumulative_sum(3)) # Output: 115 ``` Implementation Implement the `FenwickTree` class with the described operations. Your class should minimally include initialization, update, and query methods.","solution":"class FenwickTree: def __init__(self, transactions): Initializes a Fenwick Tree with the given transactions. self.n = len(transactions) self.tree = [0] * (self.n + 1) for i, val in enumerate(transactions): self.update_transaction(i, val) def update_transaction(self, index, amount): Updates the transaction by adding the specified amount at the given index. index += 1 while index <= self.n: self.tree[index] += amount index += index & -index def cumulative_sum(self, index): Returns the cumulative sum of transactions from start up to the given index. index += 1 total = 0 while index > 0: total += self.tree[index] index -= index & -index return total"},{"question":"# Question Scenario You are implementing a plagiarism detection tool that checks for the occurrence of specific phrases within student-submitted assignments. Before incorporating more sophisticated methods, a reliable and efficient string matching algorithm is needed to detect the presence of an exact substring efficiently. # Task You are asked to implement a function using the provided Rabin-Karp algorithm, which checks for the presence of a pattern within a given text and returns the starting index of the first match. # Function Specification **Function Name**: `find_substring` **Input**: - A string `pattern` that represents the pattern to search for. - A string `text` that represents the text in which to search the pattern. **Output**: - An integer representing the starting index of the first match of the pattern in the text. - Return `-1` if the pattern is not found in the text. **Constraints**: - The lengths of `pattern` and `text` will not exceed (10^6). - The text will consist of lowercase English letters. **Example**: ```python assert find_substring(\\"test\\", \\"this is a test string\\") == 10 assert find_substring(\\"nope\\", \\"this is a test string\\") == -1 ``` # Performance Requirements - The solution should be efficient with an average time complexity of (O(n + m)).","solution":"def find_substring(pattern, text): Returns the starting index of the first match of the pattern in the text. Uses the Rabin-Karp algorithm for efficient string matching. def hash_value(s, prime, alphabet_size): Computes the hash value for a given string s. h = 0 for char in s: h = (h * alphabet_size + ord(char)) % prime return h def recompute_hash(previous_hash, dropped_char, new_char, pattern_length, prime, alphabet_size): Recomputes the hash by sliding the window over the text. new_hash = previous_hash - (ord(dropped_char) * (alphabet_size ** (pattern_length - 1)) % prime) new_hash = new_hash * alphabet_size + ord(new_char) new_hash = new_hash % prime if new_hash < 0: new_hash += prime return new_hash if len(pattern) > len(text): return -1 prime = 101 # A large prime number alphabet_size = 256 # Number of characters in the input alphabet pattern_length = len(pattern) text_length = len(text) pattern_hash = hash_value(pattern, prime, alphabet_size) current_hash = hash_value(text[:pattern_length], prime, alphabet_size) for i in range(text_length - pattern_length + 1): if current_hash == pattern_hash: if text[i:i+pattern_length] == pattern: return i if i < text_length - pattern_length: current_hash = recompute_hash(current_hash, text[i], text[i + pattern_length], pattern_length, prime, alphabet_size) return -1"},{"question":"# Two Sum Challenge Given an array of integers `nums` and an integer `target`, write a function `two_sum` that finds two distinct indices of the numbers in the array such that their sum equals the `target`. You can assume that each input would have exactly one solution. You are not allowed to use the same element twice. Input Format: * `nums`: A list of integers, e.g., [2, 7, 11, 15]. * `target`: A single integer, e.g., 9. Output Format: * A tuple `(i, j)` of two integers, representing the indices (0-based) of the two numbers that add up to the `target`. The order of the indices does not matter. Example: ```python nums = [2, 7, 11, 15] target = 9 # Because nums[0] + nums[1] = 2 + 7 = 9, # the correct output would be (0, 1) ``` Constraints: 1. Each input would have exactly one solution. 2. You may not use the same element twice. 3. Performance requirement: The algorithm should work in linear time, O(n). 4. The function must handle arrays with sizes up to 10^5 elements and integer values can vary widely (negative, positive, large, small). Function Signature: ```python def two_sum(nums: List[int], target: int) -> Tuple[int, int]: # implement your solution here ```","solution":"from typing import List, Tuple def two_sum(nums: List[int], target: int) -> Tuple[int, int]: Finds two distinct indices such that the numbers corresponding to these indices add up to the target value. Parameters: nums (List[int]): A list of integers. target (int): The target sum. Returns: Tuple[int, int]: A tuple containing the indices of the two elements whose sum equals the target. num_indices = {} for i, num in enumerate(nums): complement = target - num if complement in num_indices: return (num_indices[complement], i) num_indices[num] = i return (-1, -1) # If there is no solution, although stated there\'s always exactly one solution"},{"question":"A paint company has categorised paint cans into three colors: red, white, and blue. For the sake of simplicity, these colors are represented by integers: `0` (red), `1` (white), and `2` (blue). Given an unsorted array of paint cans represented by these integers, you are required to write a function that sorts the array such that all cans of the same color are adjacent and the colors are ordered as red, white, and blue. # Requirements: * You cannot use any library\'s built-in sort function. * The algorithm should work in linear time, O(n). * The sorting should be done in-place with O(1) extra space. # Function Signature: ```python def sort_colors(nums: List[int]) -> None: ``` # Parameters: * `nums` (List[int]): An array of integers where each integer is 0 (red), 1 (white), or 2 (blue). # Output: * The function does not return anything. It modifies the input array in place to be sorted. # Example: ```python # Example: nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 2, 2] ``` # Constraints: * The length of the input array is in the range [0, 100000]. * Each element in the array is one of 0, 1, or 2. # Edge Cases: * The input array could be empty. * The input array could contain only one type of element (all 0s, all 1s, or all 2s). # Implementation Tips: 1. Use three pointers: `i` (for red), `j` (for white), and `k` (iterator) to segregate the elements. 2. Traverse the array once, re-arranging elements as per the logic similar to the Dutch National Flag problem.","solution":"def sort_colors(nums): Sorts the array of paint cans in-place such that all cans of the same color are adjacent, in the order of red (0), white (1), and blue (2). red, white, blue = 0, 0, len(nums) - 1 while white <= blue: if nums[white] == 0: nums[red], nums[white] = nums[white], nums[red] red += 1 white += 1 elif nums[white] == 1: white += 1 else: nums[white], nums[blue] = nums[blue], nums[white] blue -= 1"},{"question":"# Bubble Sort Simulation Your task is to implement the Bubble Sort algorithm with an added capability to visualize the sorting process step by step. The function should take a list of integers and return the list sorted in ascending order. Function Signature ```python def bubble_sort_simulation(arr: list, simulation: bool = False) -> list: ``` Input - `arr`: A list of integers, which needs to be sorted (1 ≤ length ≤ 1000). - `simulation`: A boolean flag, defaulted to `False`. When `True`, the function should print the list after each iteration of swaps. Output - The function should return the sorted list in ascending order. - When `simulation` is set to `True`, the list should be printed at the end of each pass through the list, once all possible swaps in that pass have been made. Example Usage ```python >>> bubble_sort_simulation([4, 3, 1, 2], True) iteration 0 : 4 3 1 2 iteration 1 : 3 4 1 2 iteration 2 : 3 1 4 2 iteration 3 : 3 1 2 4 iteration 4 : 1 3 2 4 iteration 5 : 1 2 3 4 [1, 2, 3, 4] >>> bubble_sort_simulation([5, 1, 4, 2, 8], False) [1, 2, 4, 5, 8] ``` Constraints - The length of the input list (`N`) will be between 1 and 1000 inclusive. - The elements of the list will be integers. Notes - If the list contains negative numbers or duplicates, your function should still sort them correctly. - Pay attention to edge cases like empty lists or lists with a single element.","solution":"def bubble_sort_simulation(arr: list, simulation: bool = False) -> list: n = len(arr) for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] if simulation: print(f\\"iteration {i*n + j} : {\' \'.join(map(str, arr))}\\") return arr"},{"question":"You are given a Binary Search Tree (BST) that includes methods for insertion, searching, size calculation, and tree traversal. Although the current BST implementation provides basic functionality, it lacks efficiency when the tree becomes unbalanced. Your task is to implement a self-balancing Binary Search Tree, specifically an AVL Tree, to ensure that the tree remains balanced after insertion. # Task Write a class `AVLTree` that inherits from the provided `BST` class and overrides the `insert` method to maintain the AVL Tree property (balance factor of any node is -1, 0, or 1). You also need to implement rotation methods for balancing the tree. # Method Signatures ```python class AVLTree(BST): def insert(self, data): # Overrides BST insert pass def rotate_left(self, node): # AVL tree left rotation pass def rotate_right(self, node): # AVL tree right rotation pass def get_balance_factor(self, node): # Get the balance factor of the node pass def update_height(self, node): # Update the height of the node pass ``` # Example Given a sequence of insertions [10, 20, 30, 40, 50, 25], the AVL Tree should balance itself at each insertion. 1. Insert 10, AVL tree: ``` 10 ``` 2. Insert 20, AVL tree: ``` 10 20 ``` 3. Insert 30, AVL tree becomes unbalanced and is rotated: ``` 20 / 10 30 ``` 4. Insert 40, AVL tree: ``` 20 / 10 30 40 ``` 5. Insert 50, AVL tree becomes unbalanced and is rotated: ``` 20 / 10 40 / 30 50 ``` 6. Insert 25, AVL tree becomes unbalanced and is rotated: ``` 20 / 10 40 / 30 50 / 25 ``` **Constraints**: - Inserted integer values will be unique. - Expected complexity for insertion should be O(log N). # Function Details - **insert(data)**: Insert the data maintaining the AVL property. - **rotate_left(node)**: Perform left rotation on the given node. - **rotate_right(node)**: Perform right rotation on the given node. - **get_balance_factor(node)**: Return the balance factor of the node. - **update_height(node)**: Update the height attribute of the node based on its children heights. # Testing Your implementation should be tested to ensure that the AVL Tree maintains balance after each insertion. ```python class TestSuite(unittest.TestCase): def setUp(self): self.tree = AVLTree() def test_insert_balancing(self): self.tree.insert(10) self.tree.insert(20) self.tree.insert(30) self.assertEqual(self.tree.get_root().data, 20) self.assertEqual(self.tree.get_root().left.data, 10) self.assertEqual(self.tree.get_root().right.data, 30) def test_avl_balancing_after_multiple_inserts(self): values = [10, 20, 30, 40, 50, 25] for value in values: self.tree.insert(value) self.assertEqual(self.tree.get_root().data, 30) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, data): self.root = self._insert(self.root, data) def _insert(self, node, data): if not node: return Node(data) if data < node.data: node.left = self._insert(node.left, data) else: node.right = self._insert(node.right, data) node.height = 1 + max(self.get_height(node.left), self.get_height(node.right)) balance = self.get_balance_factor(node) # Left Left Case if balance > 1 and data < node.left.data: return self.rotate_right(node) # Right Right Case if balance < -1 and data > node.right.data: return self.rotate_left(node) # Left Right Case if balance > 1 and data > node.left.data: node.left = self.rotate_left(node.left) return self.rotate_right(node) # Right Left Case if balance < -1 and data < node.right.data: node.right = self.rotate_right(node.right) return self.rotate_left(node) return node def rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def get_balance_factor(self, node): if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def get_height(self, node): if not node: return 0 return node.height def get_root(self): return self.root"},{"question":"Scenario You\'ve been hired to work on a software project that involves significant manipulation and querying of binary trees. One of the critical functionalities required is determining all paths in a binary tree where the sum of the nodes in the path equals a specified target value. # Problem Statement Write a Python function `find_paths_with_sum(root, target_sum)` that receives a binary tree\'s root node and a target sum as input. The function should return a list of lists where each list represents a root-to-leaf path such that the sum of the node values in the path equals the target sum. # Function Signature ```python def find_paths_with_sum(root, target_sum): pass ``` # Input * `root`: The root node of a binary tree (an instance of TreeNode or None). * `target_sum`: An integer representing the target sum to be checked against the paths. # Output * A list of lists containing the values of the nodes forming each path that sums up to `target_sum`. Return an empty list if no such paths are found. # Constraints 1. Each node in the binary tree has an integer value. 2. The number of nodes in the tree ranges from `0` to `10^4`. 3. The node values can be negative, and `target_sum` can also be negative. # Performance Requirements * The solution should be efficient and work within the constraints. # Example Consider the binary tree illustrated below: ``` 5 / 4 8 / / 11 13 4 / 7 2 1 ``` * Input: `root` with the above structure, `target_sum = 22`. * Output: `[[5, 4, 11, 2], [5, 8, 4, 5]]`. # Notes 1. Use Depth-First Search (DFS) or Breadth-First Search (BFS) to solve the problem. 2. Ensure your solution considers potential edge cases, such as an empty tree or paths with zero/negative values. # Additional Information You may define any additional helper functions as required. Ensure your code is clean, efficient, and handles all given constraints and edge cases effectively.","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_paths_with_sum(root: TreeNode, target_sum: int) -> List[List[int]]: def dfs(node, current_path, current_sum): if not node: return current_path.append(node.val) current_sum += node.val if not node.left and not node.right and current_sum == target_sum: # Only add the path if it\'s a leaf and sums to target_sum paths.append(list(current_path)) else: if node.left: dfs(node.left, current_path, current_sum) if node.right: dfs(node.right, current_path, current_sum) current_path.pop() paths = [] dfs(root, [], 0) return paths"},{"question":"# Programming Task: You are given a collection of integers and your task is to count the digits of each integer in an efficient manner. You need to implement a function which takes a list of integers as input and returns a list of the same size where each element gives the digit count of the corresponding integer from the input list. # Input: * `nums`: A list of integers. You may assume the size of the list is at most 10^6, and each integer in the list is between -10^9 and 10^9 (inclusive). # Output: * Return a list of integers where each integer represents the digit count of the corresponding integer in the input list. # Constraints: * The solution must work within O(n) time complexity where n is the number of integers in the input list. * The solution must handle negative numbers and zero correctly. # Function Signature: ```python def count_digits(nums: List[int]) -> List[int]: pass ``` # Example: ```python # Example 1 nums = [123, -456, 7890, 0] print(count_digits(nums)) # Output: [3, 3, 4, 1] # Example 2 nums = [1000000000, -1000000000, 5, -5] print(count_digits(nums)) # Output: [10, 10, 1, 1] ``` # Notes: * Ensure that your implementation handles both positive and negative numbers. The sign should not affect the digit count. * Your function should be optimized for large lists of integers to ensure it runs within acceptable limits for time and space complexity.","solution":"def count_digits(nums): Returns a list of digit counts for each integer in the input list nums. def digit_count(n): return len(str(abs(n))) return [digit_count(num) for num in nums]"},{"question":"You are provided with a recursive sorting algorithm named Stooge Sort. Your task is to write a function that sorts an array of integers using the Stooge Sort method. # Function Signature ```python def stooge_sort(arr: List[int]) -> List[int]: pass ``` # Input - A single list `arr` of integers. # Output - A list of integers sorted in non-decreasing order. # Constraints - The list can contain up to (10^4) integers. - Each integer value will be in the range ([-10^9, 10^9]). # Requirements Your implementation must: 1. Correctly sort the provided list using the Stooge Sort algorithm. 2. Be efficient in terms of recursion depth and memory usage to handle the edge cases effectively. 3. Ensure that the array indices are handled correctly to avoid out-of-bounds errors. # Example ```python assert stooge_sort([32, 24, 5, 19, 8, 34, 55]) == [5, 8, 19, 24, 32, 34, 55] assert stooge_sort([1]) == [1] assert stooge_sort([2, 1]) == [1, 2] ``` # Notes - Consider the edge cases involving small arrays and large datasets. - Make sure your code is clean, readable, and well-commented.","solution":"from typing import List def stooge_sort(arr: List[int], l: int = 0, h: int = None) -> List[int]: if h is None: h = len(arr) - 1 # Base case: If there is only one element if l >= h: return arr # If the element at the end is smaller than the element at the start, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than two elements in the array if h - l + 1 > 2: # Find the third of the current segment t = (h - l + 1) // 3 # Recursively sort the first 2/3 of the array stooge_sort(arr, l, h - t) # Recursively sort the last 2/3 of the array stooge_sort(arr, l + t, h) # Recursively sort the first 2/3 of the array again to ensure sorting stooge_sort(arr, l, h - t) return arr"},{"question":"# Binary Search Tree (BST) Range Sum Problem You are given a Binary Search Tree (BST), and you need to implement a method that computes the sum of all values in the BST that lie within a given range [low, high], inclusive. # Problem Statement: Implement the function `range_sum_bst` in the `BST` class, which should efficiently calculate the sum of node values that fall within the range [low, high]. # Requirements: - Method Signature: ```python def range_sum_bst(self, root: Node, low: int, high: int) -> int: ``` - Your function should return the sum of all values `val` in the BST such that `low <= val <= high`. # Input/Output Formats: - **Input**: - `root` - The root node of the BST. - `low` - An integer representing the lower bound of the range. - `high` - An integer representing the upper bound of the range. - **Output**: - An integer representing the sum of values in the specified range. # Constraints: - Assume all node values in the BST are unique. - `low` and `high` will be within the range of node values in the BST. # Example: With the given tree structure and the range [7, 20], the sum of values in this range is 7 (7+9+10+12+15+18+20 = 91). ```python # Example Test tree = BST() tree.insert(10) tree.insert(15) tree.insert(6) tree.insert(4) tree.insert(9) tree.insert(12) tree.insert(24) tree.insert(7) tree.insert(20) tree.insert(30) tree.insert(18) assert tree.range_sum_bst(tree.get_root(), 7, 20) == 91 ``` # Note: - Your implementation should leverage the properties of the BST to avoid unnecessary traversals and achieve an efficient solution.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = Node(key) else: self._insert(node.right, key) def get_root(self): return self.root def range_sum_bst(self, root: Node, low: int, high: int) -> int: def dfs(node): if not node: return 0 if node.val < low: return dfs(node.right) if node.val > high: return dfs(node.left) return node.val + dfs(node.left) + dfs(node.right) return dfs(root)"},{"question":"# Priority Queue Enhancements and Speed Optimization Objective: You are required to implement a more efficient priority queue using a binary heap, also known as a priority heap. A binary heap allows for both insertion and extraction to be done in O(log n) time. Description: 1. Implement a priority queue that efficiently handles both insertion and extraction operations using a binary heap. 2. You should maintain the min-heap property where the parent node is always less than or equal to its children. Expected Methods: 1. **__init__(self, items=None, priorities=None)**: Initialize the priority queue. 2. **size(self)**: Return the number of elements in the priority queue. 3. **push(self, item, priority=None)**: Insert an item with an optional priority. If no priority is provided, treat the item itself as its priority. 4. **pop(self)**: Remove and return the item with the lowest priority. 5. **heapify_down(self, index)**: Ensure the heap property is maintained after an extraction. 6. **heapify_up(self, index)**: Ensure the heap property is maintained after an insertion. Input: * The priority queue should accept any comparable data types as input for both item and priority. * The `push` method should allow an optional priority, which if not provided, uses the value of the item. Output: * The `pop` method should remove and return the item with the lowest priority. Constraints: * You can assume that item and priority are comparable. * Implement proper error handling for popping from an empty queue. Performance: Ensure that both `push` and `pop` operations are optimized to O(log n). # Example: ```python pq = PriorityQueue(items=[4, 8, 6], priorities=[1, 3, 2]) print(pq.pop()) # Output: 4 pq.push(10, 1) print(pq.pop()) # Output: 6 print(pq.size()) # Output: 2 ``` Note: The example illustrates how elements are prioritized based on priorities (lower value has higher priority).","solution":"class PriorityQueue: def __init__(self, items=None, priorities=None): self.heap = [] if items is not None: for i, item in enumerate(items): priority = item if priorities is None else priorities[i] self.push(item, priority) def size(self): return len(self.heap) def push(self, item, priority=None): if priority is None: priority = item self.heap.append((priority, item)) self.heapify_up(self.size() - 1) def pop(self): if self.size() == 0: raise IndexError(\\"pop from an empty priority queue\\") # swap the root with the last element self.heap[0], self.heap[-1] = self.heap[-1], self.heap[0] item = self.heap.pop() self.heapify_down(0) return item[1] def heapify_down(self, index): while True: left = 2 * index + 1 right = 2 * index + 2 smallest = index if left < self.size() and self.heap[left][0] < self.heap[smallest][0]: smallest = left if right < self.size() and self.heap[right][0] < self.heap[smallest][0]: smallest = right if smallest == index: break self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] index = smallest def heapify_up(self, index): parent = (index - 1) // 2 while index > 0 and self.heap[index][0] < self.heap[parent][0]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] index = parent parent = (index - 1) // 2"},{"question":"You are tasked with creating a function that verifies the correctness of integer-to-byte and byte-to-integer conversions, given both big-endian and little-endian formats. The function should handle a list of integers, convert each integer to its byte representation, and back to integer, ensuring the integrity of the original value. Your function should work for non-negative integers. # Function Signature ```python def verify_integer_byte_conversion(integers: List[int]) -> bool: pass ``` # Input * `integers`: A list of non-negative integers to be checked. Constraints: `0 <= integer < 2**32` and the list will contain up to 1000 elements. # Output * The function should return `True` if all integers are correctly converted to bytes and back to integers in both big-endian and little-endian formats, otherwise `False`. # Constraints * The function should handle zero appropriately. * The conversions should maintain consistency regardless of integer size. Example ```python assert verify_integer_byte_conversion([0, 1, 255, 256, 2**16, 2**24, 2**32 - 1]) == True assert verify_integer_byte_conversion([1 << i for i in range(32)]) == True assert verify_integer_byte_conversion([1 << i for i in range(33)]) == False # out of bound ``` Write your function to verify correct integer-byte conversion for both endiannesses.","solution":"from typing import List def verify_integer_byte_conversion(integers: List[int]) -> bool: for integer in integers: if integer < 0 or integer >= 2**32: return False # Convert to bytes using both big-endian and little-endian big_endian_bytes = integer.to_bytes(4, byteorder=\'big\') little_endian_bytes = integer.to_bytes(4, byteorder=\'little\') # Convert back to integers big_endian_int = int.from_bytes(big_endian_bytes, byteorder=\'big\') little_endian_int = int.from_bytes(little_endian_bytes, byteorder=\'little\') # Check if the conversion to bytes and back to integers is consistent if big_endian_int != integer or little_endian_int != integer: return False return True"},{"question":"# Question: Convert Expanded Roman Numeral to Integer Given a Roman numeral string `s` with an expansion for characters representing values from 1 to 3999, write a function to convert this string to its respective integer value. # Detailed Requirements: 1. **Function Signature**: `def expanded_roman_to_int(s: str) -> int` 2. **Input**: * A **string** `s` representing a valid expanded Roman numeral. * The numeral string `s` will always be a valid Roman numeral representing a number from 1 to 3999. 3. **Output**: * An **integer** that represents the integer value of the Roman numeral provided in the input string. # Example ```python assert expanded_roman_to_int(\\"MCMXCIV\\") == 1994 assert expanded_roman_to_int(\\"LVIII\\") == 58 ``` # Constraints * Input is guaranteed to be valid Roman numerals within the range of 1 to 3999. * Expected time complexity is O(n), where n is the length of the string `s`. * You can assume the string length is reasonable for typical processing limits on competitive platforms. # Implementation Notes * Focus on correctly implementing the conversion, mindful of subtractive combinations. * Consider both single character values and subtractive combinations by reading pairs of characters. **Scenario**: You are developing a tool that needs to interface with historical texts and data represented in Roman numerals. Your function will help accurately extract integer values from these representations for further statistical processing.","solution":"def expanded_roman_to_int(s: str) -> int: Convert an expanded Roman numeral string to an integer. # Create a mapping of Roman numerals to their integer values roman_to_int = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } # Initialize the total to 0 total = 0 prev_value = 0 # Traverse the string from right to left for char in reversed(s): curr_value = roman_to_int[char] # If current value is less than the previous value, subtract from total (subtractive combinations) if curr_value < prev_value: total -= curr_value else: total += curr_value prev_value = curr_value return total"},{"question":"# Question You are provided with a list of integers in ascending order and a target sum. Implement the function `find_two_sum` that returns the indices of the two numbers in the list that add up to the target sum. The indices returned should be 1-based (i.e., the first element of the list is considered at index 1). Each input will have exactly one solution, and you may not use the same element twice. Implement this function using the Binary Search method outlined in the analysis. Function Signature ```python def find_two_sum(numbers: [int], target: int) -> [int]: ``` Input - `numbers`: A list of integers sorted in ascending order. (1 ≤ len(numbers) ≤ 10^4, -10^9 ≤ numbers[i] ≤ 10^9) - `target`: An integer target sum. (-10^9 ≤ target ≤ 10^9) Output - A list containing the indices (1-based) of the two numbers such that they add up to the specified target. The first index must be less than the second index. Constraints - There will be exactly one solution. - The same element cannot be used twice. Example ```python # Example 1 numbers = [2, 7, 11, 15] target = 9 find_two_sum(numbers, target) # Output: [1, 2] # Example 2 numbers = [5, 25, 75] target = 100 find_two_sum(numbers, target) # Output: [2, 3] ``` Your task is to implement the function using the Binary Search method. Ensure the code handles all relevant edge cases efficiently.","solution":"def find_two_sum(numbers, target): Finds the indices of the two numbers such that they add up to the target. Indices are 1-based. left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1 return [] # Example usage numbers = [2, 7, 11, 15] target = 9 print(find_two_sum(numbers, target)) # Output: [1, 2]"},{"question":"# Challenge Question: Summarize Ranges in a Sorted Integer Array Context: You are writing a program to process ranges within a sorted list of integers. Given an array of integers that is sorted and contains no duplicates, this program must summarize contiguous ranges efficiently. The primary task is to identify sequences and output ranges in a compressed format. Problem Statement: Write a function `summarize_ranges(array: List[int]) -> List[str]` that takes a sorted list of integers and returns a list of strings representing the contiguous ranges found in the array. Function Signature: ```python def summarize_ranges(array: List[int]) -> List[str]: ``` Input: * `array` (List[int]): A sorted list of unique integers. The list can be empty. Output: * List[str]: A list of strings, each representing a range in the format \\"start-end\\" for ranges with more than one element, or just \\"start\\" if the range consists of a single element. Constraints: * The array will have at most 10^5 elements. * Each element in the array and the range limits will fit within a 32-bit signed integer. Examples: 1. Input: `[0, 1, 2, 4, 5, 7]` Output: `[\\"0-2\\", \\"4-5\\", \\"7\\"]` 2. Input: `[1, 2, 3, 6, 7, 8, 10]` Output: `[\\"1-3\\", \\"6-8\\", \\"10\\"]` 3. Input: `[2]` Output: `[\\"2\\"]` 4. Input: `[]` Output: `[]` Performance Requirements: * Your solution should work with an O(n) time complexity and O(1) extra space complexity (excluding the output). Ensure to handle edge cases such as: * Lists with a single element. * Lists with no contiguous sequences. * Empty lists.","solution":"def summarize_ranges(array): Takes a sorted list of integers and returns a list of strings representing the contiguous ranges found in the array. if not array: return [] result = [] start = array[0] end = array[0] for i in range(1, len(array)): if array[i] == end + 1: end = array[i] else: if start == end: result.append(f\\"{start}\\") else: result.append(f\\"{start}-{end}\\") start = array[i] end = array[i] if start == end: result.append(f\\"{start}\\") else: result.append(f\\"{start}-{end}\\") return result"},{"question":"# Question: You are given a sentence as a string. Your task is to reverse the entire sentence word by word. The words in the output should appear in reverse order as compared to their order in the input sentence. Ensure that spaces only separate words and there are no leading or trailing spaces in the output. Function Signature: ```python def reverse_sentence(sentence: str) -> str: pass ``` Input: * `sentence` (string): A non-empty string consisting of words separated by spaces. Output: * `string`: The input sentence with words in reverse order. Constraints: * The sentence will contain only letters and spaces. * The words are separated by a single space. Example: ```python sentence = \\"I am keon kim and I like pizza\\" reverse_sentence(sentence) -> \\"pizza like I and kim keon am I\\" sentence = \\"hello world\\" reverse_sentence(sentence) -> \\"world hello\\" sentence = \\"a\\" reverse_sentence(sentence) -> \\"a\\" ``` Notes: * Leading and trailing spaces should be trimmed from the output. * Consecutive spaces between words should be reduced to a single space in the output. Provide a complete implementation of the `reverse_sentence` function.","solution":"def reverse_sentence(sentence: str) -> str: Reverses the input sentence word by word. words = sentence.split() reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"# Markov Chain Simulation Challenge Implement a function called `simulate_markov_chain` that simulates the traversal through a Markov Chain. You will be provided with a chain dictionary and a starting state. Your task is to simulate the traversal for a specified number of steps and return the sequence of visited states. Function Signature ```python def simulate_markov_chain(chain: dict, start_state: str, steps: int) -> list: pass ``` Input - `chain` (dict): A dictionary representing the Markov Chain. Each key is a state, and each value is another dictionary where keys are possible next states and values are the probabilities of transitioning to those states. - `start_state` (str): The initial state from which to begin the traversal. - `steps` (int): The number of steps to simulate in the traversal. Output - `list`: A list of states representing the sequence of visited states, including the initial state. Example ```python chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } simulate_markov_chain(chain, \'A\', 5) ``` Possible Output: ``` [\'A\', \'A\', \'E\', \'A\', \'A\', \'E\'] ``` Continuously generate the next state based on the transition probabilities and accumulate the results until the number of steps is reached. Constraints - The probabilities for transitions from any given state will always sum to 1. - The steps value will be a positive integer. - The start state will always be a valid key in the chain dictionary.","solution":"import random def simulate_markov_chain(chain: dict, start_state: str, steps: int) -> list: Simulates the traversal through a Markov Chain. Parameters: chain (dict): A dictionary representing the Markov Chain. start_state (str): The initial state to start the traversal from. steps (int): The number of steps to simulate. Returns: list: A list of visited states including the initial state. current_state = start_state visited_states = [current_state] for _ in range(steps): next_state = random.choices( population=list(chain[current_state].keys()), weights=list(chain[current_state].values()) )[0] visited_states.append(next_state) current_state = next_state return visited_states"},{"question":"# Pancake Sort with Enhanced Constraints Imagine that you are a chef who loves sorting tasks as much as cooking delectable dishes. However, your sorting spatula (used to flip pancakes) is fragile and you can only use it a limited number of times. This introduces an additional constraint to the usual pancake sort algorithm. Problem Statement Write a function `limited_pancake_sort(arr, max_flips)` that sorts an array of integers using the pancake sort technique but with an additional constraint: you can only perform a maximum of `max_flips` flips. If sorting cannot be completed within these flips, return the array as it is after the allowed number of flips. Function Signature ```python def limited_pancake_sort(arr: list[int], max_flips: int) -> list[int]: ``` Input * `arr`: A list of integers which need to be sorted. * `max_flips`: An integer specifying the maximum allowed number of flips. Output * A list of integers, sorted up to the point allowed by `max_flips`. Constraints * `1 <= len(arr) <= 10^3` * `1 <= arr[i] <= 10^4` * `0 <= max_flips <= 10^5` Example ```python print(limited_pancake_sort([3, 2, 4, 1], max_flips=2)) # Output might be something like [3, 2, 1, 4] depending on the flips used print(limited_pancake_sort([3, 2, 4, 1], max_flips=10)) # Expected Output: [1, 2, 3, 4] print(limited_pancake_sort([10, 9, 8, 7], max_flips=5)) # Output might be partially sorted due to flip limit ``` Notes * You must ensure the function is efficient given the constraints. * Think about scenarios where the number of maximum flips is too low to sort the entire array.","solution":"def flip(arr, k): Helper function to reverse the first k elements of array arr. return arr[:k][::-1] + arr[k:] def find_max_index(arr, n): Helper function to find the index of the maximum element in arr upto index n. return max(range(n), key=arr.__getitem__) def limited_pancake_sort(arr, max_flips): Sorts the array using pancake sorting technique but stops when max_flips is reached. n = len(arr) current_flips = 0 for size in range(n, 1, -1): # If we have already used up the allowed flips, return the array as is. if current_flips >= max_flips: return arr # Find the index of the maximum element in array[0..size-1] max_index = find_max_index(arr, size) # If the maximum element is not at its position, we need to flip if max_index != size - 1: # Flip max element to the front, if it\'s not already at the front if max_index != 0: arr = flip(arr, max_index + 1) current_flips += 1 # If we have used the allowed flips, return the array if current_flips >= max_flips: return arr # Flip it into its final position arr = flip(arr, size) current_flips += 1 return arr"},{"question":"You have been assigned to create an algorithm that checks if a given string `s` can be formed by merging two other strings `part1` and `part2`, while maintaining the relative ordering of characters from `part1` and `part2`. Task Write a function called `is_merge` that takes three strings `s`, `part1`, and `part2`, and returns `True` if `s` can be formed by interleaving `part1` and `part2` while preserving the character order. Otherwise, return `False`. Input and Output Formats - Input: - A string `s`: The target string to form. - A string `part1`: The first part of the source string. - A string `part2`: The second part of the source string. - Output: - A boolean value indicating whether `s` can be formed by merging `part1` and `part2`. Constraints - All input strings consist of lowercase alphabets. - The length of each string will not exceed 100. Examples Example 1: ```python s = \'codewars\' part1 = \'cdw\' part2 = \'oears\' print(is_merge(s, part1, part2)) # True ``` Example 2: ```python s = \'codewars\' part1 = \'cod\' part2 = \'wars\' print(is_merge(s, part1, part2)) # False ``` # Requirements 1. Your solution should be optimized to handle typical edge cases and be efficient in terms of time complexity. 2. Clearly handle different lengths and ensure the return is accurate. You may implement the solution iteratively or recursively, but consider performance impacts and space/time complexity when doing so.","solution":"def is_merge(s, part1, part2): Checks if the string `s` can be formed by merging `part1` and `part2` while maintaining the relative ordering of characters from `part1` and `part2`. Args: s (str): The target string to form. part1 (str): The first part of the source string. part2 (str): The second part of the source string. Returns: bool: True if `s` can be formed by merging `part1` and `part2`, otherwise False. m, n = len(part1), len(part2) if len(s) != m + n: return False dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True for i in range(1, m + 1): dp[i][0] = dp[i-1][0] and part1[i-1] == s[i-1] for j in range(1, n + 1): dp[0][j] = dp[0][j-1] and part2[j-1] == s[j-1] for i in range(1, m + 1): for j in range(1, n + 1): dp[i][j] = (dp[i-1][j] and part1[i-1] == s[i+j-1]) or (dp[i][j-1] and part2[j-1] == s[i+j-1]) return dp[m][n]"},{"question":"# Missing Number in Sequence You have been given a sequence of unique integers ranging from 0 to n, where exactly one number is missing from the sequence. Write a function to find the missing number. Given a sequence that is already complete, your function should return the next integer in the sequence. Function Signature ```python def find_missing_number(nums: List[int]) -> int: ``` # Input - `nums`: A list of integers (0 <= nums[i] <= n), where each integer is unique. # Output - A single integer representing the missing number or the next integer if the sequence is already complete. # Constraints - The length of `nums` will be in the range 0 to 10^5. - The sequence will contain unique integers. # Example 1. **Input**: `nums = [3, 0, 1]` **Output**: 2 2. **Input**: `nums = [0, 1, 2, 3, 4]` **Output**: 5 3. **Input**: `nums = [4, 1, 3, 0, 6, 5, 2]` **Output**: 7 # Notes - The function should handle cases where `nums` may be empty or contain a complete sequence. - Consider implementing the function using both methods (XOR-based and Summation-based) internally to validate correctness and robustness. # Solution Outline 1. Calculate the expected sum of the first `n` integers using the formula `n * (n + 1) / 2`. 2. Find the actual sum of elements in the list. 3. The difference between the expected sum and the actual sum is the missing number. 4. Alternatively, use the XOR approach where the expected indices XOR operation cancels out the elements found in the list, isolating the missing number.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Finds the missing number in the sequence or returns the next integer if the sequence is already complete. n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"Given a string as input, write a function `delete_reoccurring_characters` that removes any reoccurring characters and returns the new string. Your function should ensure that the order of the characters in the input string is preserved in the output string, and only the first occurrence of each character is retained. # Function Signature ```python def delete_reoccurring_characters(string: str) -> str: ``` # Input * A single string `string`, where: * `1 <= len(string) <= 10^5` * The string consists of only printable ASCII characters. # Output * A single string that contains only the first occurrence of each character from the input string in the same order. # Constraints * Your solution should have a time complexity of O(n) and a space complexity of O(n), where n is the length of the input string. # Example ```python assert delete_reoccurring_characters(\\"programming\\") == \\"progamin\\" assert delete_reoccurring_characters(\\"mississippi\\") == \\"misp\\" assert delete_reoccurring_characters(\\"abcdefaabb\\") == \\"abcdef\\" assert delete_reoccurring_characters(\\"\\") == \\"\\" ``` # Explanation 1. For \\"programming\\", the characters \'p\', \'r\', \'o\', \'g\', \'a\', \'m\', \'i\', \'n\' are the first occurrences, resulting in \\"progamin\\". 2. For \\"mississippi\\", the characters \'m\', \'i\', \'s\', \'p\' are the first occurrences, resulting in \\"misp\\". 3. For \\"abcdefaabb\\", the characters \'a\', \'b\', \'c\', \'d\', \'e\', \'f\' are the first occurrences, resulting in \\"abcdef\\". 4. For an empty string, the result is an empty string. Using these examples as guidance, implement the function to correctly handle the removal of duplicate characters while maintaining the original order of the first occurrence of each character.","solution":"def delete_reoccurring_characters(string: str) -> str: Removes any reoccurring characters and retains only the first occurrence of each character. Args: string (str): The input string consisting of printable ASCII characters. Returns: str: A new string with only the first occurrence of each character. seen = set() result = [] for char in string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Question: Interval Range Summarization Context You are given a sorted list of unique integers. Your task is to summarize the list into ranges. Each range should represent a contiguous sequence of numbers from the input list. If a number does not belong to any range, it should be listed as an individual element. Objective Write a function `summarize_ranges(array: List[int]) -> List[str]` that, given a sorted list of unique integers, returns a list of strings summarizing the ranges. Input Format - `array`: A sorted list of unique integers (e.g., `[0, 1, 2, 4, 5, 7]`). Output Format - A list of strings where each string represents an interval or a single number. * If the interval contains more than one element, it should be represented as `\\"start-end\\"`. * If it is a single element, it should be represented as `\\"element\\"`. Constraints - The input list can contain between 1 to 10^4 integers. - The integers are guaranteed to be unique and sorted in ascending order. - Each integer in the list can range from -10^6 to 10^6. Example 1. `summarize_ranges([0, 1, 2, 4, 5, 7])` should return `[\\"0-2\\", \\"4-5\\", \\"7\\"]`. 2. `summarize_ranges([3, 4, 5, 10, 11, 12])` should return `[\\"3-5\\", \\"10-12\\"]`. 3. `summarize_ranges([1, 3, 5, 7, 9])` should return `[\\"1\\", \\"3\\", \\"5\\", \\"7\\", \\"9\\"]`. Instructions 1. Implement the function `summarize_ranges` in Python. 2. Ensure your solution is efficient and meets the specified time and space complexity requirements. 3. Handle edge cases, such as lists with only one element or non-contiguous sequences. 4. Validate assumptions made about the input (sorted, unique) where relevant.","solution":"def summarize_ranges(array): Summarize a sorted list of unique integers into ranges. Args: array (List[int]): Sorted list of unique integers. Returns: List[str]: List of ranges in string format. if not array: return [] ranges = [] start = array[0] end = array[0] for num in array[1:]: if num == end + 1: end = num else: if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") start = num end = num if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") return ranges"},{"question":"Implement an enhanced version of the Separate Chaining Hash Table with dynamic resizing. When the load factor (number of entries / table size) exceeds a threshold (e.g., 0.7), the table should automatically resize itself to double the current size and rehash all the existing entries to the new table size. # Function Requirements You need to implement the following methods in the `ResizingSeparateChainingHashTable` class: 1. `put(self, key, value)`: Insert a key-value pair into the hash table. If the key already exists, update its value. 2. `get(self, key)`: Retrieve the value associated with the given key. Return `None` if the key doesn\'t exist. 3. `del_(self, key)`: Remove the key-value pair from the hash table. 4. `resize(self)`: Double the size of the table and rehash all existing entries. # Input and Output Formats * **put(key, value)**: * Input: key can be any hashable type, value can be any type. * Output: None. * **get(key)**: * Input: key can be any hashable type. * Output: value associated with the key or None if not found. * **del_(key)**: * Input: key can be any hashable type. * Output: None. * **__len__()**: * Input: None. * Output: Returns the number of key-value pairs in the hash table. # Constraints * To simplify, assume that all keys provided will be hashable in Python. * Your hash table should start with the default size of 11 and resize by doubling its size when the load factor exceeds 0.7. # Example Usage ```python table = ResizingSeparateChainingHashTable() table.put(\'apple\', 1) table.put(\'banana\', 2) print(table.get(\'apple\')) # Output: 1 print(len(table)) # Output: 2 table.del_(\'apple\') print(table.get(\'apple\')) # Output: None print(len(table)) # Output: 1 ``` # Evaluation Your solution will be evaluated based on: 1. Correctness: Implementation should meet the problem requirements and handle edge cases properly. 2. Efficiency: Solution should efficiently manage operations even after multiple resizes. 3. Code Quality: Code should be well-structured, readable, and maintainable.","solution":"class ResizingSeparateChainingHashTable: def __init__(self, initial_capacity=11, load_factor_threshold=0.7): self.table = [[] for _ in range(initial_capacity)] self.size = 0 self.load_factor_threshold = load_factor_threshold def put(self, key, value): if self.size / len(self.table) > self.load_factor_threshold: self.resize() index = hash(key) % len(self.table) for i, (k, v) in enumerate(self.table[index]): if k == key: self.table[index][i] = (key, value) return self.table[index].append((key, value)) self.size += 1 def get(self, key): index = hash(key) % len(self.table) for k, v in self.table[index]: if k == key: return v return None def del_(self, key): index = hash(key) % len(self.table) for i, (k, v) in enumerate(self.table[index]): if k == key: del self.table[index][i] self.size -= 1 return def resize(self): old_table = self.table new_capacity = len(self.table) * 2 self.table = [[] for _ in range(new_capacity)] self.size = 0 for chain in old_table: for key, value in chain: self.put(key, value) def __len__(self): return self.size"},{"question":"**Problem Statement** Given a list of positive integers `nums` (without duplicates) and an integer `target`, write a function `count_combinations(nums, target)` that returns the number of possible combinations of `nums` that add up to the `target`. The order of elements in the combination does matter. Your implementation should be efficient with both time and space complexities considered. # Input - `nums`: List of positive integers `[num1, num2, ..., numn]` (1 ≤ length ≤ 1000). - `target`: A positive integer (1 ≤ target ≤ 1000). # Output - An integer representing the number of possible combinations that sum up to `target`. # Constraints - All elements in `nums` are positive and distinct. - Handle cases where `nums` can be an empty list or where `target` = 0 correctly. # Example ```python # Example 1: nums = [1, 2, 3] target = 4 count_combinations(nums, target) # Output: 7 # Explanation: # The combinations are: (1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 3), (2, 1, 1), (2, 2), (3, 1). # Note: Different orders are counted as different combinations. # Example 2: nums = [] target = 4 count_combinations(nums, target) # Output: 0 # Explanation: # There are no numbers to form any combination. # Example 3: nums = [1] target = 0 count_combinations(nums, target) # Output: 1 # Explanation: # The only combination is an empty combination that sums to 0. ``` # Follow-up Questions 1. How would the algorithm change if negative numbers are allowed in `nums`? Discuss the implications and potential solutions for handling this scenario. 2. Could you optimize the space complexity of your solution further? If so, how?","solution":"def count_combinations(nums, target): Returns the number of possible combinations that add up to target. :param nums: List of positive integers :param target: positive integer target :return: The number of ways to sum up to the target using numbers from nums dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for num in nums: if i - num >= 0: dp[i] += dp[i - num] return dp[target]"},{"question":"# Level Order Traversal of a Binary Tree Background You are given a binary tree and your task is to perform a level order traversal of its nodes\' values. This type of traversal visits all nodes at each level of the tree before moving on to the nodes at the next level. Write a function `level_order` that returns a list of lists, where each sublist contains the values of the nodes at that level, starting from the root. Function Signature ```python def level_order(root: Optional[TreeNode]) -> List[List[int]]: ``` Input * `root`: The root node of the binary tree (`root` will be an instance of the `TreeNode` class). * The `TreeNode` class is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output * A list of lists, where each inner list contains the values of the nodes at that level of the tree from left to right. Constraints * The number of nodes in the tree is within the range `[0, 2000]`. * Node values are -1000 <= Node.val <= 1000. Example * For a given binary tree: ``` 3 / 9 20 / 15 7 ``` * The function `level_order` should return: ```python [ [3], [9, 20], [15, 7] ] ``` Performance Requirements * The algorithm should run in O(n) time complexity where n is the number of nodes in the tree. * The space complexity should also be O(n) due to the storage required for the queue. Additional Tests Consider testing the following cases: 1. An empty tree should return an empty list. 2. A tree with a single node should return the root value in a single list. 3. Trees with different structures (e.g., skewed left, skewed right, balanced).","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"**Topological Sort Challenge** You are tasked with implementing a function to perform a topological sort on a given Directed Acyclic Graph (DAG). The graph is represented as a dictionary, where each key is a node, and the corresponding value is a list of nodes that the key node points to. # Function Signature ```python def topological_sort(graph: Dict[Any, List[Any]]) -> List[Any]: pass ``` # Input - `graph`: A dictionary where each key is a node, and the corresponding value is a list of nodes indicating the directed edges from the key node. # Output - A list of nodes representing a valid topological order of the graph. # Constraints - The input graph is guaranteed to be a Directed Acyclic Graph (DAG). - The graph can have up to 10^5 vertices and up to 10^6 edges. - Each node is a unique identifier (string or integer). # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'D\'], \'D\': [] } print(topological_sort(graph)) # Output: [\'A\', \'B\', \'C\', \'D\'] or [\'A\', \'C\', \'B\', \'D\'] ``` # Explanation In the given graph, \'A\' must come before \'B\' and \'C\', and both \'B\' and \'C\' must come before \'D\'. Therefore, valid topological orders would include [\'A\', \'B\', \'C\', \'D\'] or [\'A\', \'C\', \'B\', \'D\']. # Notes - You may assume that there are no duplicate values in the graph. - Handle edge cases where the graph might be empty or contain only one vertex. # Requirement Implement the `topological_sort` function to provide the correct topological ordering following the given specification. Ensure your solution is efficient and can handle the upper constraints.","solution":"from typing import List, Dict, Any def topological_sort(graph: Dict[Any, List[Any]]) -> List[Any]: # Helper function to perform Depth-First Search (DFS) def dfs(node): if visited[node] == -1: raise ValueError(\\"Graph is not a DAG\\") if visited[node] == 0: visited[node] = -1 for neighbor in graph.get(node, []): dfs(neighbor) visited[node] = 1 result.append(node) visited = {node: 0 for node in graph} result = [] for node in graph: if visited[node] == 0: dfs(node) result.reverse() return result"},{"question":"# Coding Challenge: Path Normalizer Utility Scenario You are developing a cross-platform application that needs to handle numerous file paths provided by the users. To ensure robustness, you must convert every file path input into an absolute, fully resolved path. Task Implement a function `normalize_path(path: str) -> str` that: * Converts any `~` to the user’s home directory. * Resolves all relative paths to absolute paths. * Ensures the path is in canonical form without symbolic links. Input / Output * **Input**: * `path` (str): A valid file path, which can be absolute or relative. It may include the `~` symbol indicating the user’s home directory. * **Output**: * Returns a string representing the normalized absolute path. Constraints * The path will always be provided as a valid string. * The function should not assume that the path exists. Example ```python # Given examples print(normalize_path(\\"~/docs/file.txt\\")) # -> \\"/home/username/docs/file.txt\\" print(normalize_path(\\"./docs/../../file.txt\\")) # -> \\"/absolute_path_to/file.txt\\" print(normalize_path(\\"/etc/passwd\\")) # -> \\"/etc/passwd\\" ``` Note * Ensure the function handles edge cases gracefully, such as non-existent paths. * Consider possible performance implications though path resolution is generally efficient.","solution":"import os def normalize_path(path: str) -> str: Converts a given file path into an absolute, fully resolved, canonical path. Parameters: path (str): A file path, which can be absolute or relative. It may include \'~\'. Returns: str: The normalized absolute path. # Expand the ~ to the user\'s home directory expanded_path = os.path.expanduser(path) # Resolve the path to an absolute path absolute_path = os.path.abspath(expanded_path) # Resolve the path to a canonical form, resolving any symbolic links canonical_path = os.path.realpath(absolute_path) return canonical_path"},{"question":"# Context: Stacks are fundamental data structures used for maintaining data with Last-In-First-Out (LIFO) access pattern. You are tasked with implementing an efficient stack enabling a mix of stack operations. You will implement a BasicStack class using a list that supports typical stack operations with additional enhanced functionality of tracking the minimum element in constant time. # Task: Implement a BasicStack class which supports the following operations efficiently: 1. **push(x)**: Add an element `x` onto the stack. 2. **pop()**: Remove the element on the top of the stack. 3. **peek()**: Get the top element. 4. **get_min()**: Retrieve the minimum element in the stack in O(1) time. 5. **is_empty()**: Check if the stack is empty. # Constraints: - All stack operations should be performed in O(1) time complexity. - You cannot use any external libraries to maintain the minimum. - Assume only integer values are pushed onto the stack. - Implement exception handling to raise IndexError with a relevant message if `pop`, `peek`, or `get_min` operate on an empty stack. # Input/Output Formats: - **push(x)**: No output, modifies the stack by adding `x`. - **pop()**: Returns the top element and removes it from the stack. - **peek()**: Returns the top element without removing it. - **get_min()**: Returns the minimum element in the stack. - **is_empty()**: Returns `True` if the stack is empty, otherwise `False`. # Example: ```python stack = BasicStack() stack.push(5) stack.push(3) print(stack.get_min()) # Output: 3 stack.push(7) print(stack.peek()) # Output: 7 print(stack.pop()) # Output: 7 print(stack.get_min()) # Output: 3 stack.push(2) print(stack.get_min()) # Output: 2 ```","solution":"class BasicStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, x): self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self): if self.is_empty(): raise IndexError(\\"pop from an empty stack\\") top = self.stack.pop() if top == self.min_stack[-1]: self.min_stack.pop() return top def peek(self): if self.is_empty(): raise IndexError(\\"peek from an empty stack\\") return self.stack[-1] def get_min(self): if self.is_empty(): raise IndexError(\\"get_min from an empty stack\\") return self.min_stack[-1] def is_empty(self): return len(self.stack) == 0"},{"question":"# Interwoven String Verification You have been selected for a coding challenge to determine if a given string `s` can be formed by interweaving two strings `part1` and `part2`. The order of characters in `part1` and `part2` must be preserved in the final result. **Objective**: Write a function `is_merge(s, part1, part2)` that returns `True` if `s` can be formed by merging `part1` and `part2` in such a way that characters in `part1` and `part2` appear in the same order as they do in their respective strings. Otherwise, return `False`. **Function Signature**: ```python def is_merge(s: str, part1: str, part2: str) -> bool: pass ``` **Input**: * `s` (1 <= len(s) <= 100): the target string. * `part1` (0 <= len(part1) <= 100): the first part of the string. * `part2` (0 <= len(part2) <= 100): the second part of the string. **Output**: * Return `True` if `s` can be formed by merging `part1` and `part2` as described. Otherwise, return `False`. **Constraints**: * All strings will contain only lowercase alphabets (a-z). **Performance Requirements**: * Your solution should work efficiently for the input constraints. **Example**: ```python print(is_merge(\\"codewars\\", \\"cdw\\", \\"oears\\")) # Expected output: True print(is_merge(\\"codewars\\", \\"cdw\\", \\"oearz\\")) # Expected output: False print(is_merge(\\"abc\\", \\"a\\", \\"bc\\")) # Expected output: True print(is_merge(\\"abc\\", \\"ab\\", \\"c\\")) # Expected output: True print(is_merge(\\"abc\\", \\"abc\\", \\"\\")) # Expected output: True print(is_merge(\\"abc\\", \\"\\", \\"abc\\")) # Expected output: True print(is_merge(\\"abc\\", \\"\\", \\"abd\\")) # Expected output: False ```","solution":"def is_merge(s, part1, part2): Returns True if the string s can be formed by interweaving part1 and part2 while maintaining the order of characters in part1 and part2. if len(s) != len(part1) + len(part2): return False # Create a 2D DP array to store results of subproblems dp = [[False] * (len(part2) + 1) for _ in range(len(part1) + 1)] # Initialize the DP array dp[0][0] = True # Fill the DP array for i in range(len(part1) + 1): for j in range(len(part2) + 1): if i > 0 and part1[i - 1] == s[i + j - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] if j > 0 and part2[j - 1] == s[i + j - 1]: dp[i][j] = dp[i][j] or dp[i][j - 1] return dp[len(part1)][len(part2)]"},{"question":"# Objective Implement an optimized version of the nearest neighbor algorithm using KD-trees for fast distance computation. Your task is to maintain the core functionality while improving the efficiency. # Problem Statement You are given a set of points in an n-dimensional space. Your task is to implement an optimized nearest neighbor search using KD-trees for a given query point. # Requirements 1. **Function Name**: `nearest_neighbor_kd_tree` 2. **Input Formats**: * `x`: A tuple representing the coordinates of the query point. * `tSet`: A dictionary where the key is a tuple representing the coordinates of a training point, and the value is the label of that training point. 3. **Output Format**: * Return the label of the nearest neighbor from the training set. 4. **Constraints**: * Ensures that vector lengths are consistent. * The KD-tree must be built within an acceptable preprocessing time. * Efficient search time for the nearest neighbor. 5. **Performance Requirements**: * Optimize the querying operation with respect to both time and space. * Handle edge cases effectively. # Example ```python # Sample Input x = (5, 4) tSet = { (2, 3): \\"A\\", (5, 4): \\"B\\", (9, 6): \\"C\\", (4, 7): \\"D\\", (8, 1): \\"E\\", } # Sample Output \\"B\\" ``` # Guidelines 1. Implement a KD-tree to store the training set points. 2. Ensure the nearest neighbor search has optimized average-case complexity.","solution":"from scipy.spatial import KDTree def nearest_neighbor_kd_tree(x, tSet): Returns the label of the nearest neighbor from the training set for a given query point x using a KD-tree. Parameters: x (tuple): Coordinates of the query point. tSet (dict): A dictionary where the key is a tuple representing the coordinates of a training point, and the value is the label of that training point. Returns: str: The label of the nearest neighbor. points = list(tSet.keys()) labels = list(tSet.values()) # Create the KDTree using the training points kdtree = KDTree(points) # Query the nearest neighbor distance, index = kdtree.query(x) # Retrieve the label of the nearest neighbor nearest_label = labels[index] return nearest_label"},{"question":"Problem Statement You are given two sparse matrices A and B, represented as two-dimensional lists. A sparse matrix is a matrix in which most of the elements are zero. You need to write a function to multiply these two matrices and return the result as a new matrix. To optimize the multiplication process, you should take advantage of the sparsity of the matrices to avoid unnecessary calculations with zero values. # Function Signature ```python def multiply_matrices(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: pass ``` # Input - `A`: a list of lists of integers representing matrix A, where the number of columns is equal to the number of rows in matrix B. - `B`: a list of lists of integers representing matrix B, where the number of rows is equal to the number of columns in matrix A. # Output - Return a list of lists of integers representing the multiplied result matrix. # Constraints - Both matrices A and B will have dimensions up to 1000x1000. - Most of the elements in both matrices will be zero. - The elements of matrices will be integers, and their absolute values will not exceed 100. # Example ```python A = [ [1, 0, 0], [-1, 0, 3] ] B = [ [7, 0, 0], [0, 0, 0], [0, 0, 1] ] multiply_matrices(A, B) ``` Expected Output: ```python [ [7, 0, 0], [-7, 0, 3] ] ``` # Detailed Description 1. **Input Validation**: Check if the matrices are valid and compatible for multiplication. 2. **Sparse Matrix Representation**: Utilize a data structure such as a hash map to store non-zero elements of matrices to optimize multiplication. 3. **Matrix Multiplication**: Traverse non-zero elements of the matrices for multiplication and store the results in the resultant matrix. 4. **Resultant Matrix Construction**: Collect the results while maintaining proper dimensions, ensuring most of the operations skip zero elements. # Implementation Hints - You may use dictionaries (hash maps) to store non-zero elements with keys as indexes to quickly lookup during multiplication. - Careful handling of dimensions and indices is crucial to avoid errors.","solution":"from typing import List def multiply_matrices(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: # Check for empty matrices if not A or not B: return [] rows_A, cols_A = len(A), len(A[0]) rows_B, cols_B = len(B), len(B[0]) # Make sure the matrices are compatible for multiplication if cols_A != rows_B: return [] # Result matrix dimensions result = [[0] * cols_B for _ in range(rows_A)] # Store non-zero values of A in a dictionary non_zero_A = {} for i in range(rows_A): for j in range(cols_A): if A[i][j] != 0: if i not in non_zero_A: non_zero_A[i] = [] non_zero_A[i].append((j, A[i][j])) # Store non-zero values of B in a dictionary non_zero_B = {} for i in range(rows_B): for j in range(cols_B): if B[i][j] != 0: if j not in non_zero_B: non_zero_B[j] = [] non_zero_B[j].append((i, B[i][j])) # Perform multiplication based on non-zero values for i in non_zero_A: for (k, a_val) in non_zero_A[i]: if k in non_zero_B: for (j, b_val) in non_zero_B[k]: result[i][j] += a_val * b_val return result"},{"question":"**Scenario**: You are developing a software application that requires frequent manipulation of file paths. One key task is to ensure that all file paths are converted to absolute paths and any user-specific home directory references (e.g., `~` or `~user`) are correctly expanded. This is crucial for avoiding issues in file handling operations across different modules of your application. **Task**: Write a function `convert_to_absolute_path(filepath)` that takes a single argument `filepath` (a string) and returns its full absolute path. This should include expanding any user-specific home directory references using `~` or `~user`. # Function Signature: ```python def convert_to_absolute_path(filepath: str) -> str: ``` # Input: - `filepath` (str): A string representing the file path. # Output: - (str): A string representing the absolute path of the file with any user-specific directories expanded. # Constraints: - `filepath` will be a valid string representing a file path on the system. - The function should work on both Unix-like systems and Windows. # Requirements: - Do not use any external libraries except for the `os` module. - Handle typical edge cases for path expansions and absolute path conversions. - Ensure the solution is efficient in terms of time complexity (O(n)). # Example: ```python # Provided user\'s home directory is /home/user/ on Unix or C:Usersuser on Windows print(convert_to_absolute_path(\\"~/docs/file.txt\\")) # Unix Example: # Output: \\"/home/user/docs/file.txt\\" # Windows Example: # Output: \\"C:Usersuserdocsfile.txt\\" print(convert_to_absolute_path(\\"/etc/config\\")) # Output: \\"/etc/config\\" print(convert_to_absolute_path(\\"../up/folder\\")) # Suppose current directory is /home/user or C:Usersuser # Output: \\"/home/up/folder\\" or \\"C:Usersuserupfolder\\" ```","solution":"import os def convert_to_absolute_path(filepath: str) -> str: Convert a file path to an absolute path, expanding any user-specific home directory references (e.g., ~ or ~user). Args: - filepath (str): A string representing the file path. Returns: - (str): A string representing the absolute path of the file with any user-specific directories expanded. # Expand user-specific references (e.g., ~ or ~user) expanded_path = os.path.expanduser(filepath) # Convert the expanded path to an absolute path absolute_path = os.path.abspath(expanded_path) return absolute_path"},{"question":"You are tasked to implement a simplified version of the RSA encryption algorithm. Only key generation and encryption/decryption functionalities are needed. Specifically, you will write functions: `generate_key()`, `encrypt()`, and `decrypt()`. # Function Descriptions 1. **generate_key(k, seed=None)**: - **Input**: * `k` (int): The number of bits in the modulus `n`. * `seed` (int or None): Optional seed for random number generation to ensure reproducibility during testing. - **Output**: Returns a tuple of three integers `(n, e, d)`, representing the modulus `n`, the encryption exponent `e`, and the decryption exponent `d`. 2. **encrypt(data, e, n)**: - **Input**: * `data` (int): The number to be encrypted. * `e` (int): The public encryption exponent. * `n` (int): The modulus. - **Output**: Returns the encrypted number (int). 3. **decrypt(data, d, n)**: - **Input**: * `data` (int): The encrypted number. * `d` (int): The private decryption exponent. * `n` (int): The modulus. - **Output**: Returns the decrypted number (int). # Constraints - `k` will be between 8 and 1024. - `data` will be a non-negative integer that is less than `n`. # Example ```python # Example usage n, e, d = generate_key(16) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data ``` # Notes - Use the provided `generate_key()` function to implement the RSA key generation. - Utilize the built-in Python function `pow()` for performing modular exponentiation efficiently. - Implement necessary edge-case handling and optimizations as derived from the analysis. Write your implementation below:","solution":"import random from sympy import isprime, mod_inverse, nextprime def generate_key(k, seed=None): if seed is not None: random.seed(seed) # Generate two distinct prime numbers p and q p = nextprime(random.getrandbits(k // 2)) q = nextprime(random.getrandbits(k // 2)) while p == q: q = nextprime(random.getrandbits(k // 2)) # Compute n (the modulus) and the Euler\'s totient function phi(n) n = p * q phi_n = (p - 1) * (q - 1) # Select an encryption exponent e which is coprime with phi(n) e = 3 while gcd(e, phi_n) != 1: e += 2 # Compute the decryption exponent d d = mod_inverse(e, phi_n) return (n, e, d) def encrypt(data, e, n): return pow(data, e, n) def decrypt(data, d, n): return pow(data, d, n) def gcd(a, b): while b: a, b = b, a % b return a"},{"question":"Context You have been asked by a software development company to assess their junior developers\' understanding of sorting algorithms. The scenario provided is that their application frequently handles sorting datasets, and they need solutions that can efficiently handle different array sizes and orders. Problem Statement Implement a Gnome Sort algorithm in Python. The function should accept a list of integers and return the sorted list. Your implementation should focus on understanding the core mechanism of Gnome Sort. Function Signature ```python def gnome_sort(arr: list[int]) -> list[int]: pass ``` # Input and Output * **Input**: * A list of integers, `arr`, where (0 leq len(arr) leq 10^4). * **Output**: * A list of integers sorted in non-decreasing order. # Constraints * The function must sort the array in-place with O(1) additional space. # Example ```python # Example 1 gnome_sort([34, 2, 78, -4, 1, 565, 23]) # Output: [-4, 1, 2, 23, 34, 78, 565] # Example 2 gnome_sort([99, -30, 2]) # Output: [-30, 2, 99] # Example 3 gnome_sort([]) # Output: [] # Example 4 gnome_sort([5]) # Output: [5] ``` # Performance Requirements * Your solution should efficiently handle arrays of sizes up to 10^4. * While the best-case performance should be O(n) for nearly sorted arrays, you should ensure correctness even in the worst-case scenario. # Additional Note Include necessary error checks and handle edge cases as outlined in the analysis. Keep the implementation simple but accurate, ensuring clarity in your code.","solution":"def gnome_sort(arr: list[int]) -> list[int]: Sorts a list of integers using the Gnome Sort algorithm. Gnome sort is similar to insertion sort but relies on a series of swaps to place each element in its proper place. Args: arr (list[int]): A list of integers. Returns: list[int]: The sorted list in non-decreasing order. index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"Circular Queue Implementation Context You are working on optimizing a queue for a system where memory allocation is a critical constraint. A circular queue offers an efficient way to utilize available resources without the need to constantly resize the array. Problem Statement Implement a circular queue (bounded queue) with the following functionalities using lists in Python: 1. **CircularQueue(capacity)**: Constructor to initialize the circular queue with the given capacity. 2. **enqueue(value)**: Adds an item to the rear of the queue. If the queue is already full, it should raise an OverflowError. 3. **dequeue()**: Removes the front item from the queue and returns it. If the queue is empty, it should raise an IndexError. 4. **peek()**: Returns the front item without removing it. If the queue is empty, it should raise an IndexError. 5. **isEmpty()**: Returns True if the queue is empty, otherwise False. 6. **isFull()**: Returns True if the queue is full, otherwise False. 7. **size()**: Returns the number of items in the queue. Constraints * You may assume all input values for enqueue are valid integers. * The capacity provided during the initialization of the queue is a positive integer. Expected Function Signatures ```python class CircularQueue: def __init__(self, capacity: int): pass def enqueue(self, value: int): pass def dequeue(self) -> int: pass def peek(self) -> int: pass def isEmpty(self) -> bool: pass def isFull(self) -> bool: pass def size(self) -> int: pass ``` Example Usage ```python cq = CircularQueue(3) cq.enqueue(1) cq.enqueue(2) print(cq.size()) # Output: 2 print(cq.peek()) # Output: 1 print(cq.dequeue()) # Output: 1 print(cq.isEmpty()) # Output: False cq.enqueue(3) cq.enqueue(4) print(cq.isFull()) # Output: True cq.enqueue(5) # Raises OverflowError: Queue is full ```","solution":"class CircularQueue: def __init__(self, capacity: int): self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = 0 self.count = 0 def enqueue(self, value: int): if self.isFull(): raise OverflowError(\\"Queue is full\\") self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.count += 1 def dequeue(self) -> int: if self.isEmpty(): raise IndexError(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.count -= 1 return value def peek(self) -> int: if self.isEmpty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def isEmpty(self) -> bool: return self.count == 0 def isFull(self) -> bool: return self.count == self.capacity def size(self) -> int: return self.count"},{"question":"Design a function `unique_subsets(nums, n)` that generates all unique subsets of length `n` from the given list of distinct integers `nums`. You are given: - A list of distinct integers `nums` (1 <= len(nums) <= 12, -100 <= nums[i] <= 100). - An integer `n` (0 <= n <= len(nums)) which specifies the length of the subsets to be generated. **Function Signature**: ```python def unique_subsets(nums: List[int], n: int) -> Set[Tuple[int]]: pass ``` **Input**: - `nums`: List of distinct integers. - `n`: Length of the subsets to be generated. **Output**: - A set of tuples where each tuple is a unique subset of length `n`. **Constraints**: - All integers in `nums` are unique. - The solution set must not contain duplicate subsets. - Time complexity should be O(n * 2^m) where m is length of input list, be mindful of efficiency. **Examples**: 1. `unique_subsets([1, 2, 3, 4], 2)` should return `{(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)}` 2. `unique_subsets([5, 7], 1)` should return `{(5,), (7,)}`. 3. `unique_subsets([], 0)` should return `{()}`. **Scenario**: Consider an application where you need to find all combinations of size `n` for a given set of parameters (e.g., in a research experiment, you might need all pairs/triplets/quads of parameters to explore). This function would facilitate generating these combinations efficiently. **Hints**: - Think about how binary representations can help decide which elements to include in each subset. - Remember to consider edge cases like empty input and generating subsets of size zero.","solution":"from typing import List, Set, Tuple from itertools import combinations def unique_subsets(nums: List[int], n: int) -> Set[Tuple[int]]: Generates all unique subsets of length `n` from the given list of distinct integers. Parameters: nums (List[int]): List of distinct integers. n (int): Length of the subsets to be generated. Returns: Set[Tuple[int]]: A set of tuples where each tuple is a unique subset of length `n`. return set(combinations(nums, n))"},{"question":"You are tasked with implementing an improved version of the Stack data structure leveraging both the array-based (`ArrayStack`) and linked list-based (`LinkedListStack`) implementations. Each stack should support the following operations with specified performance: 1. **Push**: Add an element to the top of the stack. 2. **Pop**: Remove the top element from the stack. 3. **Peek**: Retrieve the top element without removing it. 4. **Is_Empty**: Check if the stack is empty. **Your Task:** 1. **Modularize the Stack ADT**: Refactor the provided `ArrayStack` and `LinkedListStack` classes by separating the interface definitions from the concrete implementations. Ensure that both classes adhere to an interface named `StackInterface`. 2. **Error Handling**: Throw an appropriate exception (e.g., `StackEmptyError`, a custom exception) when attempting to pop or peek from an empty stack. 3. **Efficiency Improvement**: Introduce a method `shrink` to the `ArrayStack` that halves the size of the underlying array when the utilized space is less than a quarter of its capacity. 4. **Memory Management Improvement**: Implement a `clear` method for `LinkedListStack` to deallocate nodes when clearing the stack. **Constraints**: - Both stack implementations must adhere to the LIFO principle. - You may assume that the data will always fit into memory. # Input Format There is no explicit input format since this is a class implementation question. However, you should provide a set of example usage scenarios (tests) at the end of your implementation. # Output Format Each stack operation should behave correctly as per LIFO principles. Use assertions in your example test cases to demonstrate the correctness of operations. Example Usage ```python try: array_stack = ArrayStack() array_stack.push(10) array_stack.push(20) assert array_stack.peek() == 20 assert array_stack.pop() == 20 assert array_stack.pop() == 10 assert array_stack.is_empty() except StackEmptyError: print(\\"Stack is empty.\\") linked_stack = LinkedListStack() linked_stack.push(30) linked_stack.push(40) assert linked_stack.peek() == 40 assert linked_stack.pop() == 40 assert linked_stack.pop() == 30 assert linked_stack.is_empty() linked_stack.clear() ``` **Your goal is to refactor the stack code provided and enhance its functionality as described. Ensure all operations work as intended and efficiently.**","solution":"class StackEmptyError(Exception): Exception raised when trying to access an element from an empty stack. pass class StackInterface: def push(self, item): raise NotImplementedError def pop(self): raise NotImplementedError def peek(self): raise NotImplementedError def is_empty(self): raise NotImplementedError class ArrayStack(StackInterface): def __init__(self): self._array = [] self._size = 0 def push(self, item): self._array.append(item) self._size += 1 def pop(self): if self.is_empty(): raise StackEmptyError(\\"The stack is empty.\\") self._size -= 1 item = self._array.pop() self.shrink() return item def peek(self): if self.is_empty(): raise StackEmptyError(\\"The stack is empty.\\") return self._array[-1] def is_empty(self): return self._size == 0 def shrink(self): if self._size < len(self._array) // 4: self._array = self._array[:self._size] class LinkedListStack(StackInterface): class Node: def __init__(self, data=None, next_node=None): self.data = data self.next = next_node def __init__(self): self.head = None def push(self, item): new_node = self.Node(item, self.head) self.head = new_node def pop(self): if self.is_empty(): raise StackEmptyError(\\"The stack is empty.\\") item = self.head.data self.head = self.head.next return item def peek(self): if self.is_empty(): raise StackEmptyError(\\"The stack is empty.\\") return self.head.data def is_empty(self): return self.head is None def clear(self): while not self.is_empty(): self.pop()"},{"question":"# Scenario You are developing a feature for a search engine that indexes and looks up pages based on keywords. The keywords associated with pages are stored in sorted order. Your task is to find the range of indices for pages that are associated with a particular keyword. # Task Given a sorted array of integers `nums` and an integer `target`, write a function `search_range` to find the starting and ending positions of the `target` in the array. If the target does not exist in the array, return `[-1, -1]`. # Function Signature ```python def search_range(nums: List[int], target: int) -> List[int]: pass ``` # Input * `nums`: A list of integers sorted in ascending order `[a_1, a_2, ..., a_n]` where `1 <= n <= 10^5` and `-10^9 <= a_i <= 10^9` * `target`: An integer `t` where `-10^9 <= t <= 10^9` # Output * A list of two integers `[start, end]` representing the starting and ending positions of the `target` in the array. Return `[-1, -1]` if the `target` cannot be found. # Constraints * Optimize for time complexity. Aim for O(log n) searches where possible. # Performance Requirements * Your solution should ideally not exceed O(log n) + O(log n) in terms of time complexity by employing binary search efficiently. # Example Example 1: ```python Input: nums = [5, 7, 7, 8, 8, 8, 10], target = 8 Output: [3, 5] ``` Example 2: ```python Input: nums = [5, 7, 7, 8, 8, 8, 10], target = 11 Output: [-1, -1] ```","solution":"from typing import List def search_range(nums: List[int], target: int) -> List[int]: Finds the starting and ending positions of the target in the sorted array nums. If the target does not exist, returns [-1, -1]. def find_bound(is_first): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: if is_first: # Continue searching in the left half if mid == left or nums[mid - 1] < target: return mid right = mid - 1 else: # Continue searching in the right half if mid == right or nums[mid + 1] > target: return mid left = mid + 1 elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return -1 start = find_bound(True) if start == -1: return [-1, -1] # Target not found end = find_bound(False) return [start, end]"},{"question":"Question: Implement Enhanced Pigeonhole Sort You are required to implement an enhanced version of Pigeonhole Sort that can handle a given array of integers. This version should address and correctly handle edge cases such as empty arrays and arrays with negative values. Your implementation should ensure the correctness of the sorting algorithm. # Input * An array of integers `arr`. # Output * A sorted array of integers in non-decreasing order. # Constraints * The elements in the array can be both positive and negative integers. * The range of integers in the array will not exceed 10^6 in absolute value. * You may assume that the number of elements in the array does not exceed 10^6. # Requirements 1. Your function should be named `enhanced_pigeonhole_sort`. 2. Implement and handle the edge cases within your function. 3. Ensure that your function returns the array sorted in a non-decreasing order. # Example ```python # Input arr = [-5, 3, 0, -2, 4, -1] # Output [-5, -2, -1, 0, 3, 4] ``` ```python def enhanced_pigeonhole_sort(arr): # Add logic to handle edge cases and sort the array using the pigeonhole algorithm pass # Test cases to validate the solution print(enhanced_pigeonhole_sort([-5, 3, 0, -2, 4, -1])) # Expected [-5, -2, -1, 0, 3, 4] print(enhanced_pigeonhole_sort([5, 4, 3, 2, 1])) # Expected [1, 2, 3, 4, 5] print(enhanced_pigeonhole_sort([0, 0, 0, 0])) # Expected [0, 0, 0, 0] print(enhanced_pigeonhole_sort([])) # Expected [] ```","solution":"def enhanced_pigeonhole_sort(arr): Sorts an array of integers using an enhanced version of the pigeonhole sort algorithm that handles both positive and negative integers. if not arr: return arr min_val = min(arr) max_val = max(arr) range_size = max_val - min_val + 1 # Create holes for each value in the range of [min_val, max_val] holes = [0] * range_size # Populate the holes array for number in arr: holes[number - min_val] += 1 # Reconstruct the sorted array sorted_arr = [] for index in range(range_size): while holes[index] > 0: sorted_arr.append(index + min_val) holes[index] -= 1 return sorted_arr"},{"question":"Find Multiple Occurrences **Scenario**: Suppose you are working on a data analysis project where you need to find all occurrences of specific elements in a dataset. Given an array of data points, you are required to search for all indices at which a given query element appears. **Problem Statement**: Implement a function named `find_all_occurrences` that takes two inputs: a list of integers and an integer query. The function should return a list of all indices where the query element appears in the array. If the query element is not found, the function should return an empty list. Function Signature ```python def find_all_occurrences(array: List[int], query: int) -> List[int]: ``` Input Format * `array`: A list of integers `[a1, a2, ..., an]` (0 ≤ n ≤ 10^5), where -10^9 ≤ ai ≤ 10^9. * `query`: An integer `q` where -10^9 ≤ q ≤ 10^9. Output Format * A list of integer indices where the query element appears in the array. * If the query is not found, return an empty list. Constraints * The function should have a time complexity of O(n). * Handle edge cases such as an empty array and non-existing query elements. Example ```python # Example 1 array = [1, 3, 7, 8, 7, 5, 6] query = 7 output = [2, 4] # Example 2 array = [2, 2, 2, 2, 2] query = 2 output = [0, 1, 2, 3, 4] # Example 3 array = [1, 2, 3, 4, 5] query = 6 output = [] ```","solution":"from typing import List def find_all_occurrences(array: List[int], query: int) -> List[int]: This function returns a list of indices where the query element appears in the array. :param array: List of integers where we need to search. :param query: Integer we are looking for in the array. :return: List of indices where query appears in the array. return [i for i, value in enumerate(array) if value == query]"},{"question":"Context: You have been given a list of integers which you need to sort. The requirements are to use an in-place sorting algorithm that minimizes the number of write operations. Flash memories, where this sorting needs to be frequently performed, have limited write cycles, making minimizing writes crucial. Task: Implement the `cycle_sort` function to sort the array by placing every element to its correct position and keeping track of the writes to ensure minimal write operations. Function Signature: ```python def cycle_sort(arr: List[int]) -> List[int]: ``` Input: * `arr` (List[int]): A list of integers that need to be sorted. The list can be of size 0 to 1000. * The list can contain duplicate values. Output: * Returns the sorted list in ascending order. Constraints: * You should not use extra space apart from a few variable values (in-place sorting). * The implementation should aim at minimizing the number of write operations. Example: ```python # Example 1 cycle_sort([3, 1, 4, 1, 5, 9, 2, 6]) # Expected output: [1, 1, 2, 3, 4, 5, 6, 9] # Example 2 cycle_sort([64, 34, 25, 12, 22, 11, 90]) # Expected output: [11, 12, 22, 25, 34, 64, 90] # Example 3 cycle_sort([1, 1, 1, 1, 1, 1]) # Expected output: [1, 1, 1, 1, 1, 1] ``` Notes: * Ensure the function handles edge cases (e.g., empty lists, lists with repeated elements) correctly. * Aim for a solution that aligns with the conceptual principles and time complexities discussed.","solution":"def cycle_sort(arr): writes = 0 # Traverse through the array to place each element at its correct position for cycle_start in range(0, len(arr) - 1): item = arr[cycle_start] # Find the position where we put the element. pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Ignore all duplicate elements. while item == arr[pos]: pos += 1 # Put the item to the correct position if pos != cycle_start: arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 if item != arr[pos]: arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Context You are tasked with implementing a resizable hash table that supports basic operations such as insertion, deletion, and retrieval of key-value pairs. The hash table should dynamically resize itself to maintain efficient operations when it becomes sufficiently full. # Problem Statement Implement a **ResizableHashTable** class that supports the following functionalities: 1. Insert a key-value pair. 2. Retrieve the value for a given key. 3. Delete a key-value pair. 4. Get the number of elements in the hash table. 5. Automatically resize the table when the load factor exceeds 2/3. # Function Specifications **Class:** `ResizableHashTable` Methods 1. `put(key: int, value: any) -> None` - **Description**: Insert the `key` and `value` into the hash table. If the key is already present, overwrite the existing value. If the table reaches a load factor of 2/3, resize the table to double its current size. - **Constraints**: `key` is a non-negative integer. 2. `get(key: int) -> any | None` - **Description**: Return the value associated with `key`. If the key does not exist in the hash table, return `None`. 3. `del_(key: int) -> None` - **Description**: Remove the key-value pair associated with `key` from the hash table. If the key does not exist, do nothing. 4. `__len__() -> int` - **Description**: Return the number of key-value pairs currently stored in the hash table. **Note**: You are required to handle collisions using linear probing, and ensure that the table resizes efficiently when necessary. Here\'s the class initialization: ```python class ResizableHashTable: MIN_SIZE = 8 def __init__(self): super().__init__(self.MIN_SIZE) ``` Implement the necessary methods within this class. # Example ```python hash_table = ResizableHashTable() hash_table.put(1, \'value1\') hash_table.put(2, \'value2\') print(hash_table.get(1)) # Output: \'value1\' print(len(hash_table)) # Output: 2 hash_table.del_(1) print(hash_table.get(1)) # Output: None ``` # Constraints * Assume all keys are non-negative integers. * You may assume that resizing and rehashing do not fail. * Focus on efficiency and correctness in your implementation.","solution":"class ResizableHashTable: MIN_SIZE = 8 def __init__(self): self.table = [None] * self.MIN_SIZE self.count = 0 def _hash(self, key): return key % len(self.table) def _load_factor(self): return self.count / len(self.table) def _resize(self): old_table = self.table new_size = len(self.table) * 2 self.table = [None] * new_size self.count = 0 for entry in old_table: if entry is not None: key, value = entry self.put(key, value) def put(self, key, value): if self._load_factor() > 2/3: self._resize() index = self._hash(key) while self.table[index] is not None and self.table[index][0] != key: index = (index + 1) % len(self.table) if self.table[index] is None: self.count += 1 self.table[index] = (key, value) def get(self, key): index = self._hash(key) while self.table[index] is not None: k, v = self.table[index] if k == key: return v index = (index + 1) % len(self.table) return None def del_(self, key): index = self._hash(key) while self.table[index] is not None: k, _ = self.table[index] if k == key: self.table[index] = None self.count -= 1 next_index = (index + 1) % len(self.table) while self.table[next_index] is not None: move_key, move_value = self.table[next_index] self.table[next_index] = None self.count -= 1 self.put(move_key, move_value) next_index = (next_index + 1) % len(self.table) return index = (index + 1) % len(self.table) def __len__(self): return self.count"},{"question":"# Pathfinding in a Graph You are tasked with implementing pathfinding functions in an undirected graph. Your goal is to write robust code to determine paths between two nodes. Function 1: Single Path Finder Implement a function `find_path(graph: Dict[Any, List[Any]], start: Any, end: Any) -> Optional[List[Any]]` that finds a single path from `start` node to `end` node. * **Input**: * `graph`: A dictionary representing the adjacency list of the graph. * `start`: The starting node. * `end`: The target node. * **Output**: A list representing the path from `start` to `end` if it exists, otherwise `None`. Function 2: All Paths Finder Implement a function `find_all_paths(graph: Dict[Any, List[Any]], start: Any, end: Any) -> List[List[Any]]` that finds all possible paths from `start` node to `end` node. * **Input**: * `graph`: A dictionary representing the adjacency list of the graph. * `start`: The starting node. * `end`: The target node. * **Output**: A list of lists where each inner list represents a path from `start` to `end`. Function 3: Shortest Path Finder Implement a function `find_shortest_path(graph: Dict[Any, List[Any]], start: Any, end: Any) -> Optional[List[Any]]` that finds the shortest path from `start` node to `end` node in terms of number of edges. * **Input**: * `graph`: A dictionary representing the adjacency list of the graph. * `start`: The starting node. * `end`: The target node. * **Output**: A list representing the shortest path from `start` to `end` if it exists, otherwise `None`. **Constraints**: * The nodes in the graph are guaranteed to be hashable. * Assume that the graph is undirected. **Example**: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'C\'], \'C\': [\'A\', \'B\', \'D\'], \'D\': [\'B\', \'C\'] } print(find_path(graph, \'A\', \'D\')) # Example Output: [\'A\', \'B\', \'D\'] or any valid path print(find_all_paths(graph, \'A\', \'D\')) # Example Output: [[\'A\', \'B\', \'D\'], [\'A\', \'C\', \'D\'], ...] print(find_shortest_path(graph, \'A\', \'D\')) # Example Output: [\'A\', \'B\', \'D\'] or [\'A\', \'C\', \'D\'] ``` Make sure to handle edge cases, optimize for performance, and avoid common pitfalls in your implementation.","solution":"from typing import Any, Dict, List, Optional def find_path(graph: Dict[Any, List[Any]], start: Any, end: Any) -> Optional[List[Any]]: Finds a single path from start node to end node. def dfs(current, path): if current == end: return path for neighbor in graph.get(current, []): if neighbor not in path: res = dfs(neighbor, path + [neighbor]) if res: return res return None return dfs(start, [start]) def find_all_paths(graph: Dict[Any, List[Any]], start: Any, end: Any) -> List[List[Any]]: Finds all paths from start node to end node. def dfs(current, path): if current == end: paths.append(path) return for neighbor in graph.get(current, []): if neighbor not in path: dfs(neighbor, path + [neighbor]) paths = [] dfs(start, [start]) return paths def find_shortest_path(graph: Dict[Any, List[Any]], start: Any, end: Any) -> Optional[List[Any]]: Finds the shortest path from start node to end node. from collections import deque queue = deque([(start, [start])]) visited = set() while queue: current, path = queue.popleft() if current == end: return path visited.add(current) for neighbor in graph.get(current, []): if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return None"},{"question":"**Scenario**: You are working on a project that utilizes a priority queue for task scheduling. The priority queue needs to support efficient addition of tasks and quick retrieval of the highest priority task. **Task**: Implement a `MinHeap` class to model this priority queue using a min heap data structure. Your class should support the following functionalities: - **insert(self, val)**: Inserts an element `val` into the heap. - **remove_min(self)**: Removes and returns the minimum element from the heap. - **min(self)**: Returns the minimum element from the heap without removing it. - **size(self)**: Returns the number of elements in the heap. The following methods must be implemented as part of the `MinHeap` class: `perc_up`, `perc_down`, `min_child`. # Input and Output Formats Method Definitions: 1. **insert** - Input: A single integer `val` to be inserted into the heap. - Output: None 2. **remove_min** - Input: None - Output: Returns the minimum integer element from the heap. If the heap is empty, return `None`. 3. **min** - Input: None - Output: Returns the minimum integer element from the heap without removing it. If the heap is empty, return `None`. 4. **size** - Input: None - Output: Returns the number of elements currently in the heap. # Constraints - The heap must be implemented using an array-based approach. - The elements will be non-negative integers. Example ```python # Example usage: heap = MinHeap() heap.insert(10) heap.insert(5) heap.insert(3) print(heap.min()) # Output: 3 print(heap.size()) # Output: 3 print(heap.remove_min()) # Output: 3 print(heap.min()) # Output: 5 ``` # Your implementation should be structured as follows: ```python class MinHeap: def __init__(self): self.heap = [0] self.current_size = 0 def perc_up(self, i): # Your implementation here def insert(self, val): # Your implementation here def min_child(self, i): # Your implementation here def perc_down(self, i): # Your implementation here def remove_min(self): # Your implementation here def min(self): # Your implementation here def size(self): # Your implementation here ```","solution":"class MinHeap: def __init__(self): self.heap = [0] # Placeholder for 0 index self.current_size = 0 def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i //= 2 def insert(self, val): self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def min_child(self, i): if (i * 2 + 1) > self.current_size: return i * 2 else: if self.heap[i * 2] < self.heap[i * 2 + 1]: return i * 2 else: return i * 2 + 1 def perc_down(self, i): while (i * 2) <= self.current_size: mc = self.min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def remove_min(self): if self.current_size == 0: return None min_val = self.heap[1] self.heap[1] = self.heap[self.current_size] self.heap.pop() self.current_size -= 1 self.perc_down(1) return min_val def min(self): if self.current_size == 0: return None return self.heap[1] def size(self): return self.current_size"},{"question":"Given two words `word1` and `word2`, find the minimum number of delete operations required to make `word1` and `word2` the same. You are required to implement this using a dynamic approach rather than a naive recursive approach to ensure optimal performance. # Function Signature ```python def min_distance(word1: str, word2: str) -> int: pass ``` # Input - `word1`: a string of length m (0 <= m <= 1000) - `word2`: a string of length n (0 <= n <= 1000) # Output - An integer representing the minimum number of delete operations required. # Examples Example 1 Input: ``` word1 = \\"sea\\" word2 = \\"eat\\" ``` Output: ``` 2 ``` Explanation: One delete operation can remove \'s\' from \\"sea\\" resulting in \\"ea\\". Another delete operation can remove \'t\' from \\"eat\\" resulting in \\"ea\\". Hence, a total of 2 steps are required to make both strings identical. Example 2 Input: ``` word1 = \\"intention\\" word2 = \\"execution\\" ``` Output: ``` 8 ``` Explanation: The minimum number of delete operations to make the two strings identical by removing characters such that common characters align in both words. # Constraints - The length of word1 and word2 will be in the range [0, 1000]. - Both words consist only of lowercase English letters. # Requirements - Utilize Dynamic Programming for an optimal solution. - Analyze the complexity, ensuring it adheres to O(m*n) time complexity and O(m*n) space complexity. # Notes - You are not allowed to use any external libraries. - Handling both efficiency and correctness is crucial.","solution":"def min_distance(word1: str, word2: str) -> int: Calculates the minimum number of deletions required to make word1 and word2 equal. m, n = len(word1), len(word2) # Create a 2D DP array to store the length of longest common subsequence (LCS) dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp array for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The length of the longest common subsequence lcs = dp[m][n] # Minimum deletions required return (m - lcs) + (n - lcs)"},{"question":"You are given the task to manipulate bits in a series of binary numbers using specific bitwise operations. Your job is to write functions that perform the following tasks reliably: 1. **Get a specified bit** from an integer. 2. **Set a specific bit** to 1 in an integer. 3. **Clear a specific bit** in an integer. 4. **Update a specific bit** to a given value. # Function Signature ```python def get_bit(num: int, i: int) -> bool: pass def set_bit(num: int, i: int) -> int: pass def clear_bit(num: int, i: int) -> int: pass def update_bit(num: int, i: int, bit: int) -> int: pass ``` # Input - `num` (int): An integer which you are manipulating. - `i` (int): The bit position to manipulate. - `bit` (int): The bit value to set (0 or 1) for the `update_bit` function. # Output - `get_bit`: Returns a boolean indicating the value of the bit at position `i`. - `set_bit`: Returns the integer result after setting the bit at position `i`. - `clear_bit`: Returns the integer result after clearing the bit at position `i`. - `update_bit`: Returns the integer result after updating the bit at position `i` to `bit`. # Constraints - 0 ≤ `num` < 2^31 - 0 ≤ `i` < 31 - `bit` is either 0 or 1. # Example ```python # Example for get_bit assert get_bit(5, 0) == True # Binary: 101, 0th bit is 1 assert get_bit(5, 1) == False # Binary: 101, 1st bit is 0 assert get_bit(5, 2) == True # Binary: 101, 2nd bit is 1 # Example for set_bit assert set_bit(5, 1) == 7 # Binary of 5: 101, setting 1st bit gives 111 (7) # Example for clear_bit assert clear_bit(5, 2) == 1 # Binary of 5: 101, clearing 2nd bit gives 001 (1) # Example for update_bit assert update_bit(5, 1, 1) == 7 # Binary of 5: 101, updating 1st bit to 1 gives 111 (7) assert update_bit(5, 2, 0) == 1 # Binary of 5: 101, updating 2nd bit to 0 gives 001 (1) ``` # Notes - Ensure to handle edge cases appropriately, such as negative numbers. - Avoid using direct integer string conversion methods (`bin`, etc.) to manipulate bits. Good luck, and make sure to test your functions with various cases to ensure correctness!","solution":"def get_bit(num: int, i: int) -> bool: Gets the bit value at index i from the integer num. return (num & (1 << i)) != 0 def set_bit(num: int, i: int) -> int: Sets the bit at index i to 1 in the integer num. return num | (1 << i) def clear_bit(num: int, i: int) -> int: Clears the bit at index i from the integer num. return num & ~(1 << i) def update_bit(num: int, i: int, bit: int) -> int: Updates the bit at index i to the given bit value (0 or 1) in the integer num. return (num & ~(1 << i)) | (bit << i)"},{"question":"You are provided with `N` positive integers. For each integer, you need to compute Euler\'s Totient function, which counts the number of integers from 1 to that number that are coprime with it. Implement the function `compute_totients`, which accepts a list of integers and returns a list of their corresponding totient values. Your implementation should be efficient enough to handle numbers as large as ( 10^6 ). # Function Signature: ```python def compute_totients(numbers: List[int]) -> List[int]: ``` # Input: - `numbers`: A list of positive integers (1 ≤ ( numbers[i] ) ≤ ( 10^6 )) # Output: - Returns a list of integers where each integer is the totient value of the corresponding input number. # Examples: ```python assert compute_totients([1, 2, 3, 9]) == [1, 1, 2, 6] assert compute_totients([5, 10, 15, 100]) == [4, 4, 8, 40] assert compute_totients([7, 20, 30, 50]) == [6, 8, 8, 20] ``` # Constraints: - Try to achieve the most optimal computation, taking into account the ( O(sqrt{n}) ) complexity of the totient function. - Ensure your solution can efficiently handle the upper limit of ( n ). # Scenario: Alice is working on her number theory assignment and needs to determine the number of coprime numbers for several given integers. She decides to use Euler\'s Totient function for this purpose. Since these calculations can be intense, she seeks your programming skills to automate this task efficiently. Write the code that Alice can use to compute the totient values for her list of integers.","solution":"def compute_totients(numbers): Computes Euler\'s Totient function for a list of numbers. Args: numbers (list of int): A list of positive integers. Returns: list of int: A list of totient values corresponding to the input list. max_n = max(numbers) phi = list(range(max_n + 1)) for i in range(2, max_n + 1): if phi[i] == i: # i is a prime number for j in range(i, max_n + 1, i): phi[j] = phi[j] * (i - 1) // i return [phi[num] for num in numbers]"},{"question":"# Context You are tasked with implementing a sorting functionality for a large dataset in a high-performance application. You decide to use the Quick Sort algorithm due to its average-case efficiency and in-place nature. However, you need to ensure your implementation can handle large input sizes and includes an optimization for the pivot selection to reduce the chance of worst-case performance. # Task Write a function `optimized_quick_sort` that sorts a list of integers using the Quick Sort algorithm. Your implementation must include an optimization for pivot selection by using the \\"median-of-three\\" method. Additionally, ensure that your function can handle edge cases and large datasets efficiently. # Function Signature ```python def optimized_quick_sort(arr: List[int]) -> List[int]: pass ``` # Input A list of integers `arr` of length `n` (0 ≤ n ≤ 10^6). # Output A list sorted in ascending order. # Constraints * Use the median-of-three method to choose the pivot. * Handle edge cases like empty lists and lists with one element. * Ensure your implementation is robust to handle large datasets within a reasonable time limit. # Example ```python assert optimized_quick_sort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10] assert optimized_quick_sort([1]) == [1] assert optimized_quick_sort([]) == [] assert optimized_quick_sort([4, 5, 3, 7, 2, 1, 8, 6]) == [1, 2, 3, 4, 5, 6, 7, 8] ```","solution":"from typing import List def median_of_three(arr: List[int], low: int, high: int) -> int: mid = (low + high) // 2 if arr[low] > arr[mid]: arr[low], arr[mid] = arr[mid], arr[low] if arr[mid] > arr[high]: arr[mid], arr[high] = arr[high], arr[mid] if arr[low] > arr[mid]: arr[low], arr[mid] = arr[mid], arr[low] return mid def partition(arr: List[int], low: int, high: int) -> int: pivot_index = median_of_three(arr, low, high) pivot_value = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] store_index = low for i in range(low, high): if arr[i] < pivot_value: arr[i], arr[store_index] = arr[store_index], arr[i] store_index += 1 arr[store_index], arr[high] = arr[high], arr[store_index] return store_index def quick_sort_recursive(arr: List[int], low: int, high: int) -> None: if low < high: pivot_index = partition(arr, low, high) quick_sort_recursive(arr, low, pivot_index - 1) quick_sort_recursive(arr, pivot_index + 1, high) def optimized_quick_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr quick_sort_recursive(arr, 0, len(arr) - 1) return arr"},{"question":"**Objective**: Write a function to accurately locate and return the nth digit in an infinitely long sequence of concatenated positive integers. Description Given a positive integer n, the task is to find the nth digit of the sequence formed by concatenating all positive integers: \\"123456789101112...\\" and so on indefinitely. Implement a function `find_nth_digit(n)` that accepts a single integer parameter n and returns the nth digit in this sequence. Function Signature ```python def find_nth_digit(n: int) -> int: ``` Input * An integer `n` where `1 <= n <= 10^9`. Output * An integer representing the nth digit in the concatenated sequence of positive numbers. Example ```python # Example 1 find_nth_digit(3) # Output: 3 # Example 2 find_nth_digit(11) # Output: 0 # Example 3 find_nth_digit(15) # Output: 2 ``` Constraints 1. The values of n can range significantly, and you should handle values up to 1 billion efficiently. 2. Pay careful attention to transitions between numbers of different lengths (e.g., moving from single-digit to double-digit). Performance Requirements 1. The solution should be efficient in terms of both time and space complexity. 2. Ensure that the implementation remains robust and handles potential edge cases, including the smallest and largest possible values for n.","solution":"def find_nth_digit(n: int) -> int: digit_length = 1 count = 9 start = 1 # Identify the length of number where nth digit is while n > digit_length * count: n -= digit_length * count digit_length += 1 count *= 10 start *= 10 # Find the exact number within this range start += (n - 1) // digit_length s = str(start) return int(s[(n - 1) % digit_length])"},{"question":"# Context Amazon is creating a visualization tool for binary trees and wants to show the node values at each tree level in a zigzag manner (i.e., left to right on one level and right to left on the next). You need to implement this feature. # Problem Statement Given the root of a binary tree, implement a function `zigzag_level(root)` that performs a zigzag level order traversal and returns the nodes\' values in this order. # Input * A binary tree represented by its root node. The node structure is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output * A list of lists. Each inner list contains the values of the nodes at each level in zigzag order. # Constraints * The number of nodes in the tree is in the range [0, 2000]. * -100 <= Node.val <= 100 # Requirements * The function should run with a time complexity of O(n), where n is the number of nodes. * The space complexity should also be O(n). # Example Consider the following binary tree: ``` 3 / 9 20 / 15 7 ``` * Example Input: ```python root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20, TreeNode(15), TreeNode(7)) result = zigzag_level(root) ``` * Example Output: ``` [[3], [20, 9], [15, 7]] ``` Implement your function below: ```python def zigzag_level(root): # Implement the function here ```","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_level(root): if not root: return [] results = [] current_level = deque([root]) left_to_right = True while current_level: level_size = len(current_level) level_nodes = [] for _ in range(level_size): if left_to_right: node = current_level.popleft() level_nodes.append(node.val) if node.left: current_level.append(node.left) if node.right: current_level.append(node.right) else: node = current_level.pop() level_nodes.append(node.val) if node.right: current_level.appendleft(node.right) if node.left: current_level.appendleft(node.left) results.append(level_nodes) left_to_right = not left_to_right return results"},{"question":"# Problem: Encode and Decode List of Strings You are given the task to implement two functions - `encode` and `decode` - to encode a list of strings into a single string, and decode that string back to its original list of strings. The encoding should uniquely and correctly serialize different strings, including edge cases like strings containing colons and numbers. Function Signatures: 1. `encode(strs: List[str]) -> str`: This function takes a list of strings and returns a single encoded string. 2. `decode(s: str) -> List[str]`: This function takes an encoded string and returns the original list of strings. Requirements: 1. The encoded string must maintain the order of the original list. 2. The encoded string should be parseable only by the decode function and must correctly handle any valid input strings, including those with colons and digits. 3. The encoding/decoding process should work efficiently for large inputs. Input/Output Format: - **encode** - **Input**: `strs` - A list of strings `[str]`, where each string can be any combination of characters. - **Output**: A single string `str` representing the encoded format. - **decode** - **Input**: `s` - A single encoded string. - **Output**: A list of strings `[str]` which is the original list before encoding. Constraints: - The encoded string will only be processed by the decode function. - Ensure the implementation can handle edge cases such as: - An empty list. - Strings containing colons or numeric characters. - Very large strings and lists. Example: ```python # Example usage: original_strings = [\\"hello\\", \\"world\\", \\"this:is:a:test\\", \\"123\\"] encoded_string = encode(original_strings) print(encoded_string) # Should print an encoded version of the list decoded_strings = decode(encoded_string) print(decoded_strings) # Should print [\'hello\', \'world\', \'this:is:a:test\', \'123\'] ``` Note: Implement these functions efficiently and ensure edge cases are covered. Accurate encoding and decoding will be key criteria for solution evaluation.","solution":"def encode(strs): Encodes a list of strings to a single string. return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s): Decodes a single string back into a list of strings. i, n = 0, len(s) result = [] while i < n: j = i while s[j] != \':\': j += 1 length = int(s[i:j]) result.append(s[j+1:j+1+length]) i = j + 1 + length return result"},{"question":"# Question: Atbash Cipher Implementation **Context:** In ancient times, encryption was used to ensure that messages could only be read by the intended recipient. The Atbash cipher is a simple encryption method where each letter of an input string is replaced with its corresponding letter from the end of the alphabet. This transformation preserves non-alphabet characters as they are. **Task:** Implement a function named `atbash_cipher` that takes a single string `s` as input and returns its Atbash cipher encrypted or decrypted form. The function should handle both uppercase and lowercase letters, and should leave non-alphabetic characters unchanged. Input - A string `s` consisting of printable ASCII characters (0 <= len(s) <= 10^6). Output - A string which is the Atbash cipher equivalent of `s`. Constraints - The input string, `s`, may contain uppercase letters, lowercase letters, numbers, spaces, and punctuation. - The function should handle large strings efficiently within the provided constraints. Example ```python assert atbash_cipher(\\"Attack at dawn\\") == \\"Zggzxp zg wzdm\\" assert atbash_cipher(\\"Hello, World!\\") == \\"Svool, Dliow!\\" assert atbash_cipher(\\"The quick brown fox jumps over the lazy dog.\\") == \\"Gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt.\\" assert atbash_cipher(\\"Gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt.\\") == \\"The quick brown fox jumps over the lazy dog.\\" ``` **Note:** - The same function can be used to both encrypt and decrypt a message because of the symmetry of the Atbash cipher.","solution":"def atbash_cipher(s): Returns the Atbash cipher equivalent of the given string s. Each letter in the input is replaced with the corresponding letter from the end of the alphabet. Non-alphabetic characters are left unchanged. Parameters: s (str): The input string to be converted using the Atbash cipher. Returns: str: The Atbash cipher converted string. def atbash_char(c): if \'a\' <= c <= \'z\': return chr(ord(\'a\') + (ord(\'z\') - ord(c))) elif \'A\' <= c <= \'Z\': return chr(ord(\'A\') + (ord(\'Z\') - ord(c))) else: return c return \'\'.join(atbash_char(c) for c in s)"},{"question":"Objective: Implement an in-place sorting algorithm that sorts an array using the principles of a max heap and min heap. Specifically, you will expand on provided code snippets by writing a function that accepts an array and a boolean flag to select either Max Heap Sort or Min Heap Sort. Problem Statement: You are required to implement a function `heap_sort(arr: list[int], use_max_heap: bool) -> list[int]` that sorts an array in ascending order using heap sort technique. If `use_max_heap` is True, you should use Max Heap Sort; otherwise, use Min Heap Sort. Expected Input and Output Format: * **Input**: * `arr`: A list of integers (1 ≤ len(arr) ≤ 10^5, -10^9 ≤ arr[i] ≤ 10^9) * `use_max_heap`: A boolean flag indicating whether to use Max Heap Sort (True) or Min Heap Sort (False). * **Output**: * A list of integers sorted in ascending order. Constraints: * The array should be sorted in-place, using O(1) additional memory. * The time complexity of the implementation should be O(n log n). Performance Requirements: Ensure that your function can handle arrays with up to 100,000 integers efficiently. Implementation Details: 1. Define the `heap_sort` function. 2. Implement the function to use the provided `max_heap_sort` or `min_heap_sort` based on the `use_max_heap` flag. 3. Ensure the function maintains the in-place sorting property. Sample Input and Output: * Input: `heap_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3], use_max_heap=True)` * Output: `[1, 1, 2, 3, 3, 4, 5, 5, 6, 9]` * Input: `heap_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3], use_max_heap=False)` * Output: `[1, 1, 2, 3, 3, 4, 5, 5, 6, 9]` ```python def heap_sort(arr, use_max_heap): if use_max_heap: max_heap_sort(arr) else: min_heap_sort(arr) ``` Additional Scenarios: * `[1, 2, 3, 4, 5]` with `use_max_heap=True` and `use_max_heap=False` to test already sorted input. * `[5, 4, 3, 2, 1]` with `use_max_heap=True` and `use_max_heap=False` to test reverse sorted input. * `[10, 9, 9, -2, 5, 3]` for duplicates and mixed numbers. Write your solution and thoroughly test your implementation against these scenarios.","solution":"def heap_sort(arr, use_max_heap): def max_heapify(arr, n, i): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[largest] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] max_heapify(arr, n, largest) def min_heapify(arr, n, i): smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[smallest] > arr[left]: smallest = left if right < n and arr[smallest] > arr[right]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] min_heapify(arr, n, smallest) def heap_sort_util(arr, use_max_heap): n = len(arr) if use_max_heap: for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] max_heapify(arr, i, 0) else: for i in range(n // 2 - 1, -1, -1): min_heapify(arr, n, i) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] min_heapify(arr, i, 0) heap_sort_util(arr, use_max_heap) if not use_max_heap: arr.reverse()"},{"question":"# Word Search II Implementation Objective: Implement a function `word_search(board: List[List[str]], words: List[str]) -> List[str]` that finds all the words in the given board. Details: 1. **Function Signature**: ```python def word_search(board: List[List[str]], words: List[str]) -> List[str]: # your implementation here ``` 2. **Input**: - `board` (List[List[str]]): 2D grid of characters. - `words` (List[str]): List of words to be searched in the board. 3. **Output**: - Returns a list of found words from the `words` list that is present in the `board`. Characteristics: - You can move in four directions: up, down, left, and right. - Each letter in the board may only be used once per word. - You have to leverage the Trie data structure for efficient word searching. - The algorithm must handle edge cases such as: * Words longer than the board. * Empty board or empty words list. Performance Requirements: - Your solution should be optimized for both time and space complexity. - Handle large input sizes efficiently. Example: ```python board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] # expected output: [\\"oath\\", \\"eat\\"] print(word_search(board, words)) ``` Constraints: - `1 <= len(board), len(board[0]) <= 12` - `1 <= len(words) <= 3 * 10^4` - `1 <= len(words[i]) <= 10` - `board` and `words[i]` consist of lowercase English letters.","solution":"from typing import List, Tuple, Set class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def word_search(board: List[List[str]], words: List[str]) -> List[str]: def backtrack(row: int, col: int, parent: TrieNode, path: str): letter = board[row][col] curr_node = parent.children[letter] if curr_node.is_end_of_word: result_set.add(path) # Avoid duplicate entries curr_node.is_end_of_word = False # Mark the current letter before the exploration board[row][col] = \'#\' # Explore the neighbor cells in around-clock directions: up, right, down, left for dx, dy in [(-1, 0), (1, 0), (0, 1), (0, -1)]: new_row, new_col = row + dx, col + dy if 0 <= new_row < len(board) and 0 <= new_col < len(board[0]): if board[new_row][new_col] in curr_node.children: backtrack(new_row, new_col, curr_node, path + board[new_row][new_col]) # End of exploration, restore the original letter in the board. board[row][col] = letter # Step 1: Construct the Trie trie = Trie() for word in words: trie.insert(word) result_set = set() # Step 2: Backtracking starting for each cell in the board for row in range(len(board)): for col in range(len(board[0])): if board[row][col] in trie.root.children: backtrack(row, col, trie.root, board[row][col]) return list(result_set)"},{"question":"# Missing Ranges Finder **Scenario:** You are working on a data validation system to ensure data integrity across numerical ranges. Given a set of reported data points, you need to find gaps (missing ranges) within a specified inclusive interval. **Task:** Implement a function `find_missing_ranges(arr, lo, hi)` that returns a list of tuples representing missing ranges between `lo` and `hi` inclusive. Each tuple in the list denotes the start and end of a missing range. You should assume the input array `arr` is sorted in ascending order. If it\'s empty, consider all ranges between `lo` and `hi` as missing. **Function Signature:** ```python def find_missing_ranges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: ``` **Input:** * `arr` (List[int]): A sorted list of distinct integers. * `lo` (int): The lower bound of the interval. * `hi` (int): The upper bound of the interval. **Output:** * List[Tuple[int, int]]: A list of tuples where each tuple represents a missing range [start, end] within the interval `[lo, hi]`. **Constraints:** * `lo` ≤ `hi` * Size of `arr` ≤ 10^6 * Elements in `arr` range from `lo` to `hi` inclusive. **Example:** ```python assert find_missing_ranges([3, 5], 1, 10) == [(1, 2), (4, 4), (6, 10)] assert find_missing_ranges([], 1, 10) == [(1, 10)] assert find_missing_ranges([1, 2, 3, 4, 5], 1, 5) == [] assert find_missing_ranges([1, 2, 8], 1, 10) == [(3, 7), (9, 10)] ``` **Hints:** - Keep track of the current start of the missing range. - Compare each element in `arr` with `start` to decide the end of the current missing range. - Do not forget to account for the possible range after the largest element of `arr`.","solution":"from typing import List, Tuple def find_missing_ranges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: Given a sorted list of integers and an inclusive range [lo, hi], returns a list of tuples representing missing ranges within that interval. Each tuple denotes the start and end of a missing range. missing_ranges = [] start = lo for num in arr: if num > start: missing_ranges.append((start, num - 1)) start = num + 1 if start <= hi: missing_ranges.append((start, hi)) return missing_ranges"},{"question":"# Problem: Fenwick Tree for Range Sum Queries Background: You are given an array `arr[0 . . . n-1]` of integers. Your task is to efficiently perform the following operations using a Fenwick Tree (Binary Indexed Tree): 1. Compute the prefix sum of the first `i` elements. 2. Modify the value of a specified element in the array `arr[i] = x` (0 <= i <= n-1). Requirements: Implement the class `FenwickTree` with the following methods: 1. **`__init__(self, arr: List[int]) -> None`** - Initializes the Fenwick Tree with the given array. 2. **`update(self, index: int, value: int) -> None`** - Updates the value at the specified index to the new `value`. - You can assume 0 <= index < n. 3. **`prefix_sum(self, index: int) -> int`** - Returns the prefix sum of the first `index` elements (0 <= index < n). Input: - The list `arr` on initialization. - For the `update` method, the `index` (int) and `value` (int). - For the `prefix_sum` method, the `index` (int) up to which the sum is required. Output: - The `prefix_sum` method should return an integer value. - The `update` method does not return anything. Constraints: - 1 <= n <= 10^5 - -10^4 <= arr[i] <= 10^4 Example: ```python arr = [1, 2, 3, 4, 5] tree = FenwickTree(arr) print(tree.prefix_sum(3)) # Output: 10 tree.update(3, 10) print(tree.prefix_sum(3)) # Output: 16 ```","solution":"from typing import List class FenwickTree: def __init__(self, arr: List[int]) -> None: self.n = len(arr) self.bit = [0] * (self.n + 1) self.arr = arr[:] for idx, val in enumerate(arr): self._update_internal(idx + 1, val) def _update_internal(self, index: int, value: int) -> None: while index <= self.n: self.bit[index] += value index += index & -index def update(self, index: int, value: int) -> None: delta = value - self.arr[index] self.arr[index] = value self._update_internal(index + 1, delta) def prefix_sum(self, index: int) -> int: index += 1 sum_ = 0 while index > 0: sum_ += self.bit[index] index -= index & -index return sum_"},{"question":"**Unique Binary Search Trees** You are given an integer `n`, which represents the number of nodes in a Binary Search Tree (BST) containing values from 1 to n. Your task is to determine how many structurally unique BSTs can be constructed using these nodes. # Input * An integer `n` (1 <= n <= 19) representing the number of nodes. # Output * Return an integer representing the total number of unique BSTs that can be constructed with values from 1 to n. # Constraints * The input integer `n` will always be between 1 and 19 (inclusive). # Example Input/Output Example 1: * Input: `n = 3` * Output: `5` * Explanation: Given n = 3, below are the possible unique BSTs: ``` 1 3 3 2 1 / / / 3 2 1 1 3 2 / / 2 1 2 3 ``` Example 2: * Input: `n = 1` * Output: `1` # Explanation Use dynamic programming to solve this problem. Create an array `dp` where `dp[i]` represents the number of unique BSTs that can be built with `i` nodes. Initialize `dp[0]` and `dp[1]` to 1, as there\'s only one way to arrange zero or one node. Then, iteratively compute the required number as per the formulation: [ F(n) = F(0) cdot F(n-1) + F(1) cdot F(n-2) + ... + F(n-1) cdot F(0) ] **Function Signature:** ```python def num_trees(n: int) -> int: ... ```","solution":"def num_trees(n: int) -> int: if n == 0 or n == 1: return 1 # Create a dp array to store the number of unique BSTs for each count of nodes dp = [0] * (n + 1) dp[0] = dp[1] = 1 # Compute the number of unique BSTs for each count from 2 to n for i in range(2, n + 1): for j in range(1, i + 1): dp[i] += dp[j - 1] * dp[i - j] return dp[n]"},{"question":"# Interval Merging Challenge Context You are managing a list of appointments for multiple clients. Each appointment is defined by its start and end times. Often, appointments can have overlapping times which need to be merged to create a comprehensive schedule. Your goal is to write a function that merges overlapping intervals to produce a compact list of appointment times. Task Write a function `merge_appointments(appointments)` that takes a list of appointments where each appointment is represented as a tuple `(start, end)` and returns a list of merged appointment intervals. Function Signature ```python def merge_appointments(appointments: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pass ``` Input and Output - **Input**: List of tuples, each tuple `(start, end)` representing appointment times (e.g., `[(1, 3), (2, 6), (8, 10), (15, 18)]`). - **Output**: List of merged intervals in the same format (e.g., `[(1, 6), (8, 10), (15, 18)]`). Constraints - All intervals are closed (i.e., an interval includes both its start and end times). - `start` and `end` are integers with `0 <= start <= end`. - The list may contain overlapping and non-overlapping intervals. Performance Requirements - The function should run in `O(n log n)` time complexity. Examples 1. **Input**: `[(1, 3), (2, 6), (8, 10), (15, 18)]` **Output**: `[(1, 6), (8, 10), (15, 18)]` 2. **Input**: `[(1, 4), (4, 5)]` **Output**: `[(1, 5)]` 3. **Input**: `[]` **Output**: `[]` (an empty list should be handled correctly)","solution":"from typing import List, Tuple def merge_appointments(appointments: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merges a list of overlapping and non-overlapping intervals and returns a list of merged intervals. :param appointments: List of tuples where each tuple contains start and end times of an interval :return: List of merged intervals if not appointments: return [] # Sort the appointments based on start time appointments.sort(key=lambda x: x[0]) merged = [] for interval in appointments: if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: merged[-1] = (merged[-1][0], max(merged[-1][1], interval[1])) return merged"},{"question":"Given a sequence of moves for a robot starting at the origin (0, 0) on a 2D plane, determine if the robot returns to the origin after completing the move sequence. Each move is represented by one of the characters \'U\' (up), \'D\' (down), \'L\' (left), and \'R\' (right). # Function Signature ```python def does_robot_return_to_origin(moves: str) -> bool: pass ``` # Input * `moves`: A string containing the sequence of moves. The string\'s length n will be between 0 and 10,000. # Output * Return `True` if the robot returns to the origin, otherwise return `False`. # Constraints * The input moves will only contain the characters \'U\', \'D\', \'L\', \'R\'. # Examples ```python Example 1: Input: \\"UD\\" Output: True Example 2: Input: \\"LL\\" Output: False ``` # Requirements * Implement the function `does_robot_return_to_origin` to check if the robot returns back to the origin. * Consider edge cases such as an empty string or a string that does not include all move types. * Achieve a time complexity of O(n) and a space complexity of O(1).","solution":"def does_robot_return_to_origin(moves: str) -> bool: This function determines if the robot returns to the origin after completing the move sequence. Each move is represented by one of the characters \'U\' (up), \'D\' (down), \'L\' (left), and \'R\' (right). Args: moves (str): A string containing the sequence of moves. Returns: bool: True if the robot returns to the origin, otherwise False. # Initialize starting coordinates x, y = 0, 0 # Iterate through each move in the sequence for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 # Check if the robot is back at the origin return x == 0 and y == 0"},{"question":"# Coding Challenge: Nth Digit Finder Problem Statement: Write a function `find_nth_digit(n)` that finds the nth digit of an infinite sequence of concatenated natural numbers (\\"1234567891011121314...\\"). Function Signature: ```python def find_nth_digit(n: int) -> int: ``` Input: - An integer `n` (1 ≤ n ≤ 2^31 - 1) representing the position in the concatenated sequence. Output: - Return an integer which is the nth digit of the sequence. Example: ```python assert find_nth_digit(3) == 3 assert find_nth_digit(11) == 0 assert find_nth_digit(12) == 1 ``` # Constraints: 1. The function must handle large values of n efficiently. 2. The approach should be optimized to avoid generating the entire sequence up to the nth digit. # Performance Requirements: - The solution should have a time complexity that ensures the algorithm runs in a reasonable amount of time even for the upper limits of n. Context: Imagine you are tasked with finding a specific digit in an extremely large file that only stores concatenated natural numbers without any delimiters. It\'s crucial to develop an efficient method to locate specific digits within this file, given the constraints on time and memory.","solution":"def find_nth_digit(n: int) -> int: digit_length = 1 count_of_digit_length = 9 while n > digit_length * count_of_digit_length: n -= digit_length * count_of_digit_length digit_length += 1 count_of_digit_length *= 10 start_of_current_range = 10 ** (digit_length - 1) number = start_of_current_range + (n - 1) // digit_length return int(str(number)[(n - 1) % digit_length])"},{"question":"# Stooge Sort: Improving and Applying **Problem Description:** You are given a list of integers and tasked with writing a modified sorting algorithm that incorporates Stooge Sort principles but improves efficiency minimally as a learning exercise. **Task:** 1. Implement a function `optimized_stooge_sort(arr: List[int]) -> List[int]` that sorts a given list of integers using modified Stooge Sort. 2. Optimization requirements: - Reduce unnecessary comparisons and swaps. - Minimize recursive calls where possible without completely abandoning Stooge Sort principles. **Function Signature:** ```python def optimized_stooge_sort(arr: List[int]) -> List[int]: ``` **Input Format:** - A list of integers `arr` with (1 leq |arr| leq 10^3) and (-10^6 leq arr[i] leq 10^6). **Output Format:** - A list of integers sorted in non-decreasing order. **Constraints:** - Your optimized solution should handle edge cases including already sorted lists and lists with all identical elements. - Recursion depth should be managed to avoid stack overflow errors. **Example:** ```python # Example 1 input_array = [5, 2, 9, 1, 5, 6] print(optimized_stooge_sort(input_array)) # Output: [1, 2, 5, 5, 6, 9] # Example 2 input_array = [3, 2, 1] print(optimized_stooge_sort(input_array)) # Output: [1, 2, 3] ``` **Explanation:** - In both examples, the function sorts the input array into non-decreasing order using the optimized Stooge Sort principles.","solution":"def optimized_stooge_sort(arr): Sorts a given list using a modified version of the Stooge Sort algorithm. def stoogesort(arr, l, h): if l >= h: return # If the element at l is greater than the element at h, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the array, perform further sorting if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort the initial 2/3rd part stoogesort(arr, l, h - t) # Recursively sort the final 2/3rd part stoogesort(arr, l + t, h) # Again sort the initial 2/3rd part to confirm stoogesort(arr, l, h - t) stoogesort(arr, 0, len(arr) - 1) return arr"},{"question":"You have been tasked to write a function that sorts a list of integers using a custom sorting algorithm known as Cycle Sort. This algorithm aims to minimize the number of writes to the original list by identifying individual cycles in the permutation and sorting them. # Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: ``` # Input - A list of integers `arr` (1 <= len(arr) <= 10^4, -10^6 <= arr[i] <= 10^6). # Output - Returns the same list sorted in non-decreasing order. # Constraints - The algorithm must work in-place, using O(1) extra space. - Aim to keep the number of writes to the array minimal. # Example ```python print(cycle_sort([3, 5, 2, 1, 4])) # Output: [1, 2, 3, 4, 5] print(cycle_sort([4, 3, 2, 1])) # Output: [1, 2, 3, 4] print(cycle_sort([10, -1, 2, -10, 5])) # Output: [-10, -1, 2, 5, 10] ``` # Explanation 1. **Initialize**: Start from the first element and determine where each element should be placed in an ordered list. 2. **Cycle Detection and Resolution**: - For each element, if it is not in its correct place, find the position where it should be placed. - Place it in the correct position. - Continue this process for other elements that are out of place to fix their cycles. 3. **Output**: The same list will be sorted in non-decreasing order after the function completes. # Edge Cases - Single-element arrays should remain unchanged. - Arrays with all identical elements should remain unchanged. - Handle arrays with negative and positive integers correctly.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: This function sorts the given list of integers using the Cycle Sort algorithm. writes = 0 for cycle_start in range(0, len(arr) - 1): item = arr[cycle_start] pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 if pos == cycle_start: continue while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Question: Sorting Colors with Dutch National Flag Algorithm Scenario You are given an array with n objects colored red, white, or blue. Your task is to sort them in such a way that the colors (represented by integers 0, 1, or 2) appear in the order red (0), white (1), and blue (2), respectively. You are required to implement this sorting algorithm without using the library\'s sort function and must do it in-place to maintain O(1) space complexity. Function Signature ```python def sort_colors(nums: List[int]) -> None: pass ``` Expected Input and Output Formats * **Input**: A list of integers, `nums`, where each integer is either 0, 1, or 2. - Example: `[2, 0, 2, 1, 1, 0]` * **Output**: The function will modify the list `nums` in-place to sort the elements. - The modified list would be: `[0, 0, 1, 1, 2, 2]` Constraints 1. Do not use any sorting functions from standard libraries. 2. Optimize for both time and space complexity. 3. Assume `nums` can contain up to 10^4 elements. # Task Given the function signature and requirements: 1. Implement the `sort_colors` function to sort the input list in the required order. 2. Test and verify your function with multiple test cases, considering edge cases like empty lists, already sorted lists, and lists containing only one type of element. Example ```python >>> nums = [2, 0, 2, 1, 1, 0] >>> sort_colors(nums) >>> print(nums) [0, 0, 1, 1, 2, 2] >>> nums = [2, 2, 2, 1, 1, 1, 0, 0, 0] >>> sort_colors(nums) >>> print(nums) [0, 0, 0, 1, 1, 1, 2, 2, 2] ```","solution":"def sort_colors(nums): Sorts the input list nums in-place such that all 0s come first, followed by all 1s, then all 2s. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[mid], nums[high] = nums[high], nums[mid] high -= 1"},{"question":"# Question You are provided with a binary search tree (BST) and two Integer values (low and high). Your task is to implement a function that returns the sum of values of all the nodes that have a value in the range [low, high] inclusive. Implement the following function: ```python def range_sum_BST(root: Node, low: int, high: int) -> int: :type root: Node :type low: int :type high: int :rtype: int ``` Input - root: the root node of a binary search tree. Each node has value, left and right child nodes. - low: integer, the lower bound of the range. - high: integer, the upper bound of the range. Output - Return one integer which is the sum of values of all nodes with values in the range [low, high]. Constraints - The number of nodes in the tree is in the range [1, 2 * 10^4]. - -10^4 <= Node.val <= 10^4 - -10^4 <= low <= high <= 10^4 - All Node.val are unique. # Example 1 ```python # Constructing the tree: # 10 # / # 5 15 # / # 3 7 18 root = Node(10) root.left = Node(5) root.right = Node(15) root.left.left = Node(3) root.left.right = Node(7) root.right.right = Node(18) print(range_sum_BST(root, 7, 15)) # Output should be 32 ``` # Example 2 ```python # Constructing the tree: # 10 # / # 5 15 # / # 3 7 18 root = Node(10) root.left = Node(5) root.right = Node(15) root.left.left = Node(3) root.left.right = Node(7) root.right.right = Node(18) print(range_sum_BST(root, 6, 10)) # Output should be 23 ``` Performance Requirements Your solution should be both time and space efficient. Aim for a time complexity of O(n) and a space complexity of O(h), where h is the height of the tree, leveraging an iterative approach to handle very deep trees.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def range_sum_BST(root: Node, low: int, high: int) -> int: Computes the sum of all node values within the range [low, high] in a BST. :param root: Node - The root of the binary search tree. :param low: int - The lower bound of the range. :param high: int - The upper bound of the range. :return: int - The sum of node values within the range [low, high]. if not root: return 0 sum_val = 0 stack = [root] while stack: node = stack.pop() if node: if low <= node.val <= high: sum_val += node.val if node.val > low: stack.append(node.left) if node.val < high: stack.append(node.right) return sum_val"},{"question":"You are required to encode a list of strings into a single string for the purpose of efficient transmission and then decode it back to the original list. Implement the `encode` and `decode` functions as described below: Function Signature ```python def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. :param strs: List of strings to encode. :return: Encoded string representing the list of strings. pass def decode(s: str) -> List[str]: Decodes a single string to a list of strings. :param s: Encoded string. :return: Original list of strings that was encoded. pass ``` # Requirements: 1. **Encoding**: * For each string in the list, prepend the length of the string followed by a delimiter character (\':\'), and then append the string itself. * Concatenate all such encoded segments to form the final encoded string. 2. **Decoding**: * Parse the encoded string by reading the length prefix before each delimiter (\':\') to determine the length of the subsequent string. * Extract each string in sequence to reconstruct the original list. # Input/Output: * `encode`: * Input: A list of strings (`List[str]`). * Output: A single encoded string (`str`). * `decode`: * Input: A single encoded string (`str`). * Output: The original list of strings (`List[str]`). # Constraints: * Strings in the list can contain spaces and special characters. * The list of strings can also include empty strings. # Example: ```python assert encode([\\"apple\\", \\"banana\\", \\"cherry\\"]) == \\"5:apple6:banana6:cherry\\" assert decode(\\"5:apple6:banana6:cherry\\") == [\\"apple\\", \\"banana\\", \\"cherry\\"] assert encode([\\"hello\\", \\"\\", \\"world\\"]) == \\"5:hello0:5:world\\" assert decode(\\"5:hello0:5:world\\") == [\\"hello\\", \\"\\", \\"world\\"] ``` # Note: You should not rely on special library functions to serialize/deserialize the data.","solution":"def encode(strs): Encodes a list of strings to a single string. :param strs: List of strings to encode. :return: Encoded string representing the list of strings. return \'\'.join(f\\"{len(s)}:{s}\\" for s in strs) def decode(s): Decodes a single string to a list of strings. :param s: Encoded string. :return: Original list of strings that was encoded. res, i = [], 0 while i < len(s): j = s.find(\':\', i) length = int(s[i:j]) i = j + 1 + length res.append(s[j + 1:i]) return res"},{"question":"# Question: Implement Advanced Segment Tree Operations Scenario: You are given a large dataset representing daily temperatures in a city over several months. You are tasked with processing several queries efficiently. Each query can either request the average temperature over a range of days or update the temperature on a specific day. To efficiently handle these operations, you need to implement a segment tree data structure with the following functionalities. Task: 1. **Initialization**: Implement the segment tree for a given array of temperatures. 2. **Query Average**: Implement a method to compute the average temperature over a specified range of days. 3. **Update Temperature**: Implement a method to update the temperature recorded on a specific day. Input and Output Formats: - **Initialization**: `SegmentTree(temperatures: List[int])` - Initialize the segment tree with a list of temperatures. - **Method 1**: `update(day: int, temperature: int) -> None` - Update the temperature at the specific day (0-indexed). - **Method 2**: `query(l: int, r: int) -> float` - Return the average temperature over the range of days from `l` to `r` inclusive. Constraints: - Temperature values are integers within the range [-100, 100]. - The number of days `n` can be up to 100,000. - Assume valid input where `0 <= l <= r < n` for queries and `0 <= day < n` for updates. Implement the class `TemperatureSegmentTree` with the above functionalities. Example: ```python temperatures = [20, 22, 18, 30, 25, 24, 26] seg_tree = TemperatureSegmentTree(temperatures) # Update temperature on day 3 to 28 seg_tree.update(3, 28) # Query average temperature from day 2 to day 5 print(seg_tree.query(2, 5)) # Output: 23.75 ``` Explanation: 1. After the update, the temperatures array becomes `[20, 22, 18, 28, 25, 24, 26]`. 2. The segment `temperatures[2:6]` is `[18, 28, 25, 24]` with an average of 23.75.","solution":"class TemperatureSegmentTree: def __init__(self, temperatures): self.n = len(temperatures) self.tree = [0] * (2 * self.n) self.build(temperatures) def build(self, temperatures): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = temperatures[i] # Initialize internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, day, temperature): pos = day + self.n self.tree[pos] = temperature # Update internal nodes while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def query(self, l, r): l += self.n r += self.n sum_temp = 0 count = r - l + 1 # Number of elements in the range while l <= r: if l % 2 == 1: sum_temp += self.tree[l] l += 1 if r % 2 == 0: sum_temp += self.tree[r] r -= 1 l //= 2 r //= 2 return sum_temp / count # Return the average temperature"},{"question":"Context You are tasked to implement a function that identifies all the root-to-leaf paths in a binary tree. This can be crucial in scenarios where you need to follow all possible decision paths in a hierarchical decision-making process. Task Implement the function `binary_tree_paths` that takes the root of a binary tree and returns a list of strings, where each string represents a path from the root to a leaf. Function Signature ```python def binary_tree_paths(root: TreeNode) -> List[str]: ``` Input Format * `root`: The root node of the binary tree. `TreeNode` is a class defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output Format * Returns a list of strings, where each string is a path from the root to a leaf node, in the format \\"node1->node2->...->nodeN\\". Constraints * The number of nodes in the tree is in the range [0, 1000]. * -100 <= Node.val <= 100 Examples **Example 1:** ```python # Input # Given binary tree [1, 2, 3, null, 5] # 1 # / # 2 3 # # 5 root = TreeNode(1) root.left = TreeNode(2) root.left.right = TreeNode(5) root.right = TreeNode(3) # Output [\\"1->2->5\\", \\"1->3\\"] ``` **Example 2:** ```python # Input # Given binary tree [] root = None # Output [] ``` Notes * You must ensure that the implemented function handles edge cases such as an empty tree. * Consider managing deep recursion or deep trees efficiently. * Avoid unnecessary string concatenation to optimize performance.","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root: TreeNode) -> List[str]: def construct_paths(node: TreeNode, path: str): if node: path += str(node.val) if not node.left and not node.right: # If it\'s a leaf node paths.append(path) # Add the current path to the list else: path += \\"->\\" construct_paths(node.left, path) construct_paths(node.right, path) if not root: return [] paths = [] construct_paths(root, \\"\\") return paths"},{"question":"**Scenario**: You are tasked with improving and adding functionality to an existing hash table to handle multiple operations efficiently. The current implementation uses a simple linear probing technique for collisions and doubles its size when it becomes two-thirds full. **Task**: Implement the following functions for an enhanced resizable hash table: 1. **`keys`**: Returns a list of all keys currently in the hash table. 2. **`values`**: Returns a list of all values currently in the hash table. **Requirements**: 1. Preserve the existing functionality of inserting (put), retrieving (get), and deleting (del) key-value pairs. 2. Ensure `keys` and `values` methods operate efficiently. 3. Handle edge cases where the hash table may be empty or encounter deletions. **Function Signatures**: ```python class EnhancedResizableHashTable(ResizableHashTable): def keys(self): # return the list of keys pass def values(self): # return the list of values pass ``` **Constraints**: - Use the provided structure and ensure backward compatibility. - Ensure your methods operate efficiently, aiming for average O(1) complexity for fundamental operations in normal use. - You can assume the keys are non-negative integers and values are arbitrary.","solution":"class ResizableHashTable: def __init__(self, initial_size=8): self.table = [None] * initial_size self.count = 0 self.threshold = 2 * initial_size // 3 def put(self, key, value): if self.count >= self.threshold: self._resize() index = self._hash(key) while self.table[index] is not None and self.table[index][0] != key: index = (index + 1) % len(self.table) if self.table[index] is None: self.count += 1 self.table[index] = (key, value) def get(self, key): index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % len(self.table) return None def delete(self, key): index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: value = self.table[index][1] self.table[index] = None self.count -= 1 self._rehash_from(index) return value index = (index + 1) % len(self.table) return None def _resize(self): old_table = self.table self.table = [None] * (2 * len(old_table)) self.count = 0 self.threshold = 2 * len(self.table) // 3 for item in old_table: if item is not None: self.put(*item) def _hash(self, key): return key % len(self.table) def _rehash_from(self, index): next_index = (index + 1) % len(self.table) while self.table[next_index] is not None: key, value = self.table[next_index] self.table[next_index] = None self.count -= 1 self.put(key, value) next_index = (next_index + 1) % len(self.table) class EnhancedResizableHashTable(ResizableHashTable): def keys(self): return [item[0] for item in self.table if item is not None] def values(self): return [item[1] for item in self.table if item is not None]"},{"question":"# Question: Counting Connected Components in a Graph Context You\'re given a set of `n` cities, some of which are connected by roads. Initially, each city is isolated, but roads can be constructed to connect pairs of cities. Each road that connects two cities will merge their sets into a single connected component. We need to determine the number of connected components (independent sets of connected cities) after each road construction. Task Implement a function `count_connected_components` that: 1. Takes an integer `n`, representing the number of cities. 2. Takes a list of tuples `roads`, where each tuple `(a, b)` represents a new road being constructed between city `a` and city `b`. Your function should return a list where each element is the count of connected components after each road construction. Input - `n`: an integer, 1 ≤ n ≤ 10^4, the number of cities. - `roads`: a list of tuples `[(a1, b1), ..., (am, bm)]` where `1 ≤ ai, bi ≤ n`. The length of `roads` can be between 1 and 10^4. Output - A list of integers representing the number of connected components after each road is added. Example ```python def count_connected_components(n, roads): # Your code here # Example usage: print(count_connected_components(5, [(1, 2), (1, 3), (4, 5), (3, 4)])) # Output: [4, 3, 2, 1] ``` Constraints - You must use the Union-Find data structure to efficiently manage the connected components. - Aim for optimal performance with time complexity close to O(m * α(n)), where m is the number of roads and n is the number of cities. Notes - All cities are initially isolated. - Each road is bidirectional and connects exactly two distinct cities. Your task is to define the `count_connected_components` function based on the above guidelines.","solution":"def count_connected_components(n, roads): Returns a list of the number of connected components after each road is constructed. # Union-Find (Disjoint Set Union) implementation parent = list(range(n+1)) rank = [1] * (n+1) components = n def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): nonlocal components rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 components -= 1 result = [] for a, b in roads: union(a, b) result.append(components) return result"},{"question":"# Finding Intersecting Node in Two Singly Linked Lists Objective Given two singly linked lists, write a function that returns the node at which the two lists intersect, if any. Intersection is defined by the node itself, not by the value of the node. Function Signature ```python def find_intersection(h1: Node, h2: Node) -> Node: ``` Input * `h1` (Node): Head node of the first singly linked list. * `h2` (Node): Head node of the second singly linked list. Output * Node: The intersecting node or `None` if there is no intersection. Constraints * The linked lists\' nodes are based on memory addresses. * Assume acyclic arrays. * Optimize for both time and space where possible. Context In a transport network, managers need to determine a common point where two routes intersect to plan a new service hub. Your function will be crucial in detecting this intersection point by analyzing pre-defined routes. Example ```python class Node: def __init__(self, val=None): self.val = val self.next = None # Create two intersecting linked lists # 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # 2 -> 4 -> 6 a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f assert find_intersection(a1, a2).val == 7 ``` Edge Cases * If either list is empty, return `None`. * If the lists do not intersect, return `None`. Write your code in the function below: ```python def find_intersection(h1: Node, h2: Node) -> Node: # Implement the algorithm based on the detailed description. ```","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def find_intersection(h1: Node, h2: Node) -> Node: Returns the node at which two singly linked lists intersect. If there is no intersection, returns None. def get_length(head: Node) -> int: length = 0 while head: length += 1 head = head.next return length # Find lengths of both linked lists len1 = get_length(h1) len2 = get_length(h2) # Find the difference in lengths diff = abs(len1 - len2) # Adjust the starting point of the longer list if len1 > len2: for _ in range(diff): h1 = h1.next else: for _ in range(diff): h2 = h2.next # Traverse both lists together until we find the intersection while h1 and h2: if h1 is h2: return h1 h1 = h1.next h2 = h2.next return None"},{"question":"# Trie Implementation and Augmented Operations **Objective**: You are to implement a trie and enhance its functionalities to include deletion of words and prefix suggestions. **Function Signatures**: 1. `insert(self, word: str) -> None` 2. `search(self, word: str) -> bool` 3. `starts_with(self, prefix: str) -> bool` 4. `delete(self, word: str) -> None` 5. `suggest(self, prefix: str) -> List[str]` **Requirements**: 1. **Insert**: Insert a word into the trie. 2. **Search**: Return True if the word is in the trie. 3. **Starts With**: Return True if there is any word in the trie that starts with the given prefix. 4. **Delete**: Remove a word from the trie. 5. **Suggest**: Return a list of words in the trie that start with the given prefix. # Constraints: * You may assume that all input strings consist of lowercase letters a-z. * The functions `insert`, `search`, `starts_with`, and `delete` should all run in O(n) time where n is the length of the word. * The function `suggest` should run efficiently given the input constraints (typically Aim for O(p + k) where p is the length of the prefix and k is the number of suggestions). # Example: ```python trie = Trie() trie.insert(\\"hello\\") trie.insert(\\"hell\\") trie.insert(\\"helicopter\\") trie.insert(\\"help\\") trie.insert(\\"hero\\") assert trie.search(\\"hello\\") == True assert trie.search(\\"hel\\") == False assert trie.starts_with(\\"he\\") == True trie.delete(\\"hello\\") assert trie.search(\\"hello\\") == False assert trie.search(\\"hell\\") == True assert trie.suggest(\\"he\\") == [\\"hell\\", \\"helicopter\\", \\"help\\", \\"hero\\"] ``` # Notes: * Ensure your `delete` method only deletes the word if it exists and should not affect other stored words or prefixes. * The `suggest` method should return all words that begin with the given prefix, sorted lexicographically.","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: current = self.root for letter in word: if letter not in current.children: current.children[letter] = TrieNode() current = current.children[letter] current.end_of_word = True def search(self, word: str) -> bool: current = self.root for letter in word: if letter not in current.children: return False current = current.children[letter] return current.end_of_word def starts_with(self, prefix: str) -> bool: current = self.root for letter in prefix: if letter not in current.children: return False current = current.children[letter] return True def delete(self, word: str) -> None: def delete_recursively(current, word, index): if index == len(word): if not current.end_of_word: return False # word not found current.end_of_word = False return len(current.children) == 0 # delete this node if it\'s just an end node char = word[index] if char not in current.children: return False # word not found can_delete_child = delete_recursively(current.children[char], word, index + 1) if can_delete_child: del current.children[char] return len(current.children) == 0 return False delete_recursively(self.root, word, 0) def suggest(self, prefix: str): def dfs(current, prefix): words = [] if current.end_of_word: words.append(prefix) for char, node in current.children.items(): words.extend(dfs(node, prefix + char)) return words current = self.root for letter in prefix: if letter not in current.children: return [] # no words with given prefix current = current.children[letter] suggestions = dfs(current, prefix) suggestions.sort() return suggestions"},{"question":"Given a string `num` which contains only digits (0-9) and an integer `target`, write a function `add_operators(num: str, target: int) -> List[str]` that returns all possible ways to add the binary operators \'+\', \'-\', and \'*\' between the digits in the string to achieve the `target` value. # Input * `num`: A non-empty string containing only digits \'0\'-\'9\'. * `target`: An integer value representing the target result of the expression. # Output * A list of strings, each representing a valid expression that evaluates to the `target`. # Constraints * The length of `num` will be between 1 and 10. * The `target` will be given as an integer which can be negative, zero, or positive. # Examples ```python add_operators(\\"123\\", 6) # Output: [\\"1+2+3\\", \\"1*2*3\\"] add_operators(\\"232\\", 8) # Output: [\\"2*3+2\\", \\"2+3*2\\"] add_operators(\\"105\\", 5) # Output: [\\"1*0+5\\", \\"10-5\\"] add_operators(\\"00\\", 0) # Output: [\\"0+0\\", \\"0-0\\", \\"0*0\\"] add_operators(\\"3456237490\\", 9191) # Output: [] ``` # Requirements * Implement the function using Depth-First Search (DFS) with Backtracking to handle the recursive exploration of possible expressions. * Ensure the function handles leading zeros correctly (e.g., \\"05\\" should be considered as \\"5\\"). # Evaluation Criteria * Correctness: Ensure the generated expressions evaluate correctly to the target. * Efficiency: While handling up to 10 digits, ensure that the function completes within reasonable time limits. * Edge Cases: Handle cases like empty input string, input with leading zeroes, and scenarios where no valid expressions are possible.","solution":"from typing import List def add_operators(num: str, target: int) -> List[str]: def backtrack(index, path, value, last): if index == len(num): if value == target: result.append(path) return for i in range(index, len(num)): if i != index and num[index] == \'0\': break current = num[index:i+1] current_val = int(current) if index == 0: backtrack(i+1, current, current_val, current_val) else: backtrack(i+1, path + \\"+\\" + current, value + current_val, current_val) backtrack(i+1, path + \\"-\\" + current, value - current_val, -current_val) backtrack(i+1, path + \\"*\\" + current, value - last + last * current_val, last * current_val) result = [] backtrack(0, \\"\\", 0, 0) return result"},{"question":"You are tasked with implementing a robust averaging function that computes the trimmed mean of a list of numerical values. The trimmed mean is a measure of central tendency that excludes a specified percentage of the highest and lowest values before calculating the mean. # Requirements 1. **Function Definition**: ```python def trimmean(arr: List[float], per: float) -> float: ``` 2. **Inputs**: * `arr` (List[float]): A list of floating-point numbers. * `per` (float): A percentage (0 < `per` < 100) that specifies the total percentage of values to exclude. This percentage is split evenly between the highest and lowest values. 3. **Output**: * Returns a floating-point number representing the trimmed mean of the input list. # Constraints * The input list, `arr`, will have at least one element. * The percentage value, `per`, will always be a positive number less than 100. * In scenarios where removing the specified percentage results in no data, return 0.0. # Example ```python assert trimmean([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 20) == 5.5 assert trimmean([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 30) == 55.0 assert trimmean([1, 2, 3, 4, 5], 40) == 3.0 assert trimmean([5, 5, 5, 5, 5], 10) == 5.0 ``` # Guidelines * Sort the list. * Remove the specified percentage of values from both the high and low ends. * Calculate and return the mean of the remaining values. * Ensure to handle edge cases where removing the specified percentage results in an empty list by returning 0.0. # Performance Considerations * The function should run efficiently with a time complexity of (O(n log n)). * Optimize for both speed and readability where possible. # Notes * Include thorough error checking to handle unexpected input scenarios. * Document any assumptions made during the implementation.","solution":"from typing import List def trimmean(arr: List[float], per: float) -> float: Calculates the trimmed mean of a list of floating-point numbers. Args: arr: List[float] - The list of numbers to trim and average. per: float - The percentage of the total number of elements to exclude from both ends. Returns: float - The trimmed mean of the list. if len(arr) == 0: return 0.0 n = len(arr) k = int(n * per / 100 / 2) if k == 0: return sum(arr) / n sorted_arr = sorted(arr) trimmed_arr = sorted_arr[k:n-k] if not trimmed_arr: return 0.0 return sum(trimmed_arr) / len(trimmed_arr)"},{"question":"Develop a function `improved_selection_sort(arr)`, where `arr` is a list of integers that needs to be sorted in ascending order using an improved version of the traditional Selection Sort algorithm. The improvement should aim to minimize operations where possible while keeping the core sorting method intact. Here\'s the function signature: ```python def improved_selection_sort(arr: List[int]) -> List[int]: pass ``` # Input Format: * A single list of integers `arr` where `0 <= len(arr) <= 10^5`. # Output Format: * The sorted list of integers in ascending order. # Constraints: * You must not use built-in sorting functions. # Performance Requirements: * The solution should aim to run within O(n^2) time complexity and O(1) space complexity. # Additional Requirements: * Consider edge cases such as: * An empty array. * An array with one element. * An array with all identical elements. # Scenario: You have been given a large dataset with up to 100,000 integers that needs to be sorted using an efficient yet simple approach. Given the nature of the task, you\'re asked to ensure minimized operations to enhance the traditional selection sort. Implement the `improved_selection_sort` function to achieve this goal.","solution":"from typing import List def improved_selection_sort(arr: List[int]) -> List[int]: Sorts a list of integers in ascending order using an improved version of the selection sort algorithm. n = len(arr) for i in range(n): min_index = i for j in range(i + 1, n): if arr[j] < arr[min_index]: min_index = j # Swap only if there is a need if min_index != i: arr[i], arr[min_index] = arr[min_index], arr[i] return arr"},{"question":"# Coding Challenge: Delete Middle Node from Singly Linked List Given a node from a singly linked list, write a function `delete_node(node)` which deletes this specific node. The input node will always be non-tail and its value will be unique in the list. Function Signature ```python def delete_node(node) ``` Input - `node`: A node object of class `Node`. This node is guaranteed to be neither `None` nor the tail node. Output - The function does not need to return anything. It should modify the linked list in place to remove the given node. Constraints - You are not given access to the head of the linked list. - The node to be deleted is not the tail node. Example Suppose the linked list is 1 -> 2 -> 3 -> 4 -> 5 and you are given the node with value `3`. After calling `delete_node(node)`, the linked list should become 1 -> 2 -> 4 -> 5. Implementation Notes - Raise a `ValueError` if the provided node is `None` or is the last node in the list. - Optimize for time complexity O(1) and space complexity O(1). Unit Tests Design your solution considering the following unit tests to validate the implementation. The test cases should specifically check the correct handling of node deletion, proper linked list structure post-deletion, and error handling. ```python import unittest class TestSuite(unittest.TestCase): def test_delete_node(self): # Create linked list 1 -> 2 -> 3 -> 4 -> 5 head = Node(1) curr = head for i in range(2, 6): curr.next = Node(i) curr = curr.next # node3 = 3 (node to be deleted) node3 = head.next.next # After delete_node(node3) => 1 -> 2 -> 4 -> 5 delete_node(node3) curr = head self.assertEqual(1, curr.val) curr = curr.next self.assertEqual(2, curr.val) curr = curr.next self.assertEqual(4, curr.val) curr = curr.next self.assertEqual(5, curr.val) tail = curr self.assertIsNone(tail.next) self.assertRaises(ValueError, delete_node, tail) self.assertRaises(ValueError, delete_node, tail.next) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def delete_node(node): Deletes the given node (assumed to be neither None nor the tail) from the singly linked list. if node is None or node.next is None: raise ValueError(\\"Cannot delete this node. It is either None or the tail.\\") node.val = node.next.val node.next = node.next.next"},{"question":"Context You are given a stack of integers where you need to transform the stack by swapping consecutive pairs of elements starting from the bottom of the stack. For instance, given a stack with elements [3, 8, 17, 9, 1, 10], you must alter it to [8, 3, 9, 17, 10, 1] by swapping pairs [3, 8], [17, 9], etc. For stacks with an odd number of elements, the topmost element should remain in place. For example, for a stack [3, 8, 17, 9, 1], after the operation, it should be [8, 3, 9, 17, 1]. Task Implement a function `switch_pairs` which uses an additional stack or queue as auxiliary storage to achieve this transformation. Input * A stack represented as a list of integers (with the top of the stack being the last item in the list). Output * The modified stack after performing the pair-wise swaps. Constraints * Do not use any additional libraries for advanced data structures. * Handle both even and odd number of elements in the stack. * Ensure optimum performance and handle edge cases appropriately. Function Signature ```python def switch_pairs(stack): # Your implementation here pass ``` Examples ```python # Example 1 stack = [3, 8, 17, 9, 1, 10] switch_pairs(stack) # Expected output: [8, 3, 9, 17, 10, 1] # Example 2 stack = [3, 8, 17, 9, 1] switch_pairs(stack) # Expected output: [8, 3, 9, 17, 1] # Example 3 stack = [1] switch_pairs(stack) # Expected output: [1] # Example 4 stack = [] switch_pairs(stack) # Expected output: [] ```","solution":"def switch_pairs(stack): Transforms the stack by swapping consecutive pairs of elements starting from the bottom. For odd number of elements, the topmost element remains in place. if not stack or len(stack) < 2: return stack temp_queue = [] # First move all elements from stack to temp_queue while stack: temp_queue.append(stack.pop()) # Move elements back to stack and swap pairs while len(temp_queue) > 1: first = temp_queue.pop() # Bottom of stack element second = temp_queue.pop() # Next to bottom of stack element stack.append(second) stack.append(first) if temp_queue: stack.append(temp_queue.pop()) # Add the last remaining element if there is an odd number return stack"},{"question":"**Context**: You are tasked with building a data analysis tool that helps users identify the most common categorical data point in their dataset. **Challenge**: Implement a function `find_modes` that takes a list of integers as its input and returns a list of the most frequent integer values in the list. If multiple values have the same highest frequency, all of them should be returned. Function Signature: ```python def find_modes(arr: List[int]) -> List[int]: pass ``` Input: * `arr`: A list of integers `arr` (0 <= len(arr) <= 10^6) Output: * A list of integer(s) that are the most frequent in the input list `arr`. Constraints: * The input list can be empty, in which case the output should be an empty list. * The integers in the input list can range from -10^9 to 10^9. * The output list should be in ascending order. Performance Requirements: * The solution should have a time complexity of O(n) where n is the length of the input list. Example: ```python assert find_modes([1, 1, 2, 2, 3, 4]) == [1, 2] assert find_modes([3, 3, 3, 2, 2, 1]) == [3] assert find_modes([]) == [] assert find_modes([5, 5, 5, 5]) == [5] assert find_modes([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] ```","solution":"from typing import List from collections import Counter def find_modes(arr: List[int]) -> List[int]: if not arr: return [] count = Counter(arr) max_count = max(count.values()) modes = [k for k, v in count.items() if v == max_count] return sorted(modes)"},{"question":"# Lowest Common Ancestor in a Binary Tree Given a binary tree, write a function to find the lowest common ancestor (LCA) of two given nodes in the tree. Function Signature ```python def findLCA(root: Optional[TreeNode], p: int, q: int) -> Optional[TreeNode]: ``` Input * `root`: The root node of the binary tree. * `p`: The value of the first node. * `q`: The value of the second node. Output * The lowest common ancestor (LCA) node of the two given nodes. If any of the node values is not present in the tree, return `None`. Constraints * All values in the binary tree are unique. * Values `p` and `q` will be distinct. * A node is a descendant of itself according to the LCA definition. Performance Requirements * The algorithm should run in O(N) time complexity and use O(H) space complexity. Example ```python # Using the tree: # _______3______ # / # ___5__ ___1__ # / / # 6 _2 0 8 # / # 7 4 # findLCA(root, 5, 1) should return 3 # findLCA(root, 5, 4) should return 5 # findLCA(root, 4, 8) should return 3 # findLCA(root, 10, 8) should return None ``` Scenario Imagine you are developing a tool for genealogical research to help users find the common ancestors of individuals within a family tree. Your task is to implement an algorithm that will take a family tree (binary tree structure) as input and determine the common ancestor for any two family members specified.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findLCA(root, p, q): Find the lowest common ancestor (LCA) of two given nodes in the tree. :param root: TreeNode, the root of the binary tree :param p: int, value of the first node :param q: int, value of the second node :return: TreeNode, the LCA node or None if one or both values are not present in the tree def dfs(node): if not node: return None if node.val == p or node.val == q: return node left = dfs(node.left) right = dfs(node.right) if left and right: return node return left if left else right def findNode(node, value): if not node: return False if node.val == value: return True return findNode(node.left, value) or findNode(node.right, value) if not findNode(root, p) or not findNode(root, q): return None return dfs(root)"},{"question":"# Question You are given an array of integers. Your task is to implement an optimized version of Bubble Sort that minimizes the number of comparisons and swaps while sorting the array in ascending order. Additionally, include a feature to return the number of swaps made during the sorting process. # Function Signature ```python def optimized_bubble_sort(arr: list) -> tuple: Sorts the input array using an optimized bubble sort algorithm and returns the sorted array and number of swaps. Parameters: arr (list): List of integers to be sorted. Returns: tuple: A tuple containing the sorted array and the number of swaps made during the sorting process. ``` # Input - A list of integers, `arr` (1 ≤ len(arr) ≤ 1000). # Output - A tuple containing: 1. The sorted list in ascending order. 2. The number of swaps made during the sorting process. # Constraints - You are expected to minimize the number of comparisons and swaps. - Ensure that your solution handles edge cases, such as an empty list or a list with one element. # Example ```python assert optimized_bubble_sort([64, 34, 25, 12, 22, 11, 90]) == ([11, 12, 22, 25, 34, 64, 90], 14) assert optimized_bubble_sort([1, 2, 3, 4, 5]) == ([1, 2, 3, 4, 5], 0) ``` # Note - In the first example, the array is sorted with a total of 14 swaps. - In the second example, the array is already sorted, hence no swaps are made.","solution":"def optimized_bubble_sort(arr: list) -> tuple: Sorts the input array using an optimized bubble sort algorithm and returns the sorted array and number of swaps. Parameters: arr (list): List of integers to be sorted. Returns: tuple: A tuple containing the sorted array and the number of swaps made during the sorting process. n = len(arr) swaps = 0 for i in range(n): # Track if any swap has occurred in this pass swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: # Swap the elements arr[j], arr[j+1] = arr[j+1], arr[j] swaps += 1 swapped = True # If no elements were swapped, break the loop early if not swapped: break return arr, swaps"},{"question":"You are working on a real-time data stream processing system that ingests a series of records, each containing a number and an operation (either addition or subtraction). Your task is to identify if the stream is 1-sparse. A stream is considered 1-sparse if there is only a unique number left after canceling out pairs of add and subtract operations for other numbers. Specification: Create a function `is_one_sparse(stream: List[Tuple[int, str]]) -> Union[int, None]:` that takes a list of tuples where each tuple consists of a number and a character (\'+\' or \'-\') indicating addition or subtraction. The function should return the unique number if the stream is 1-sparse, otherwise return `None`. Input: * `stream`: `List[Tuple[int, str]]` — a list of tuples where each tuple contains: * `int`: a non-negative integer. * `str`: a character, either \'+\' for addition or \'-\' for subtraction. Output: * `int` if the stream is 1-sparse, otherwise `None`. Example: ```python # Example 1 stream = [(4,\'+\'), (2,\'+\'), (2,\'-\'), (4,\'+\'), (3,\'+\'), (3,\'-\')] print(is_one_sparse(stream)) # Output: 4 # Example 2 stream = [(2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\')] print(is_one_sparse(stream)) # Output: 2 # Example 3 stream = [(2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (1,\'+\')] print(is_one_sparse(stream)) # Output: None ``` Constraints: * The stream contains only non-negative integers and valid operations. * The length of the stream does not exceed 10^5. * Handling edge cases such as the stream being empty or all operations canceling out.","solution":"from typing import List, Tuple, Union def is_one_sparse(stream: List[Tuple[int, str]]) -> Union[int, None]: num_count = {} for number, operation in stream: if operation == \'+\': if number in num_count: num_count[number] += 1 else: num_count[number] = 1 elif operation == \'-\': if number in num_count: num_count[number] -= 1 else: num_count[number] = -1 unique_numbers = [num for num, count in num_count.items() if count != 0] if len(unique_numbers) == 1: return unique_numbers[0] else: return None"},{"question":"# Question Context In data processing, it\'s common to encounter arrays with duplicate entries. Redundant elements can lead to inefficient storage usage and processing delays. Your task is to write an optimized function to remove duplicates from an array while preserving the original order of elements. Task Write a Python function `remove_duplicates_optimized(array)` that removes duplicate elements from an input array and returns a new list with duplicates removed. Requirements: * **Input Format**: A single list `array` containing elements of any data type (integers, strings, booleans, etc.). * **Output Format**: Return a new list with duplicates removed, maintaining the original order of elements. * **Constraints**: - Do not use the `set` built-in type for deduplication directly (like turning the list into a set and back). - The solution should aim for a linear time complexity, i.e., O(n). Function Signature: ```python def remove_duplicates_optimized(array): # Your code here ``` Example ```python # Example 1 input_array = [1, 1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True] output_array = remove_duplicates_optimized(input_array) print(output_array) # Output: [1, 2, 3, 4, \\"hey\\", \\"hello\\", True] # Example 2 input_array = [] output_array = remove_duplicates_optimized(input_array) print(output_array) # Output: [] ```","solution":"def remove_duplicates_optimized(array): Removes duplicate elements from the array while preserving the original order of elements. :param array: List of elements (could be of any data type). :return: A new list with duplicates removed, maintaining the original order of elements. seen = set() result = [] for item in array: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"# Scenario You are given a matrix in which each row and column is sorted in non-decreasing order. Your task is to implement a function to find a target value in this matrix efficiently. If the value is found, the function should return the position (row and column indices) of the value. Otherwise, it should return a message indicating that the value is not found. # Function Signature ```python def search_in_sorted_matrix(matrix, target): Searches for the target value in a row-wise and column-wise sorted matrix. Args: matrix (list of list of int): 2D list where each row and column is sorted in non-decreasing order. target (int): The value to search for. Returns: tuple: (row_index, col_index) if the value is found. str: \'Value not found\' if the value is not found in the matrix. pass ``` # Input * `matrix`: A list of lists where each sub-list represents a row of integers sorted in non-decreasing order. * `1 <= len(matrix) <= 10^4` * `0 <= len(matrix[0]) <= 10^4` * Each integer in the matrix can range between `-10^6` to `10^6`. * `target`: An integer to be searched within the matrix. # Output * Return a tuple of (row_index, col_index) if the value is found where `row_index` and `col_index` are the 0-based indices of the target value in the matrix. * If the target value is not found, return a string \'Value not found\'. # Example ```python matrix = [ [1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16], [10, 13, 14, 17] ] target = 9 # Expected output: (2, 2) print(search_in_sorted_matrix(matrix, target)) target = 15 # Expected output: \'Value not found\' print(search_in_sorted_matrix(matrix, target)) ``` # Constraints * You need to ensure that the function handles empty matrices and values outside the range efficiently. * Performance is critical; your implementation should handle the maximum constraints efficiently.","solution":"def search_in_sorted_matrix(matrix, target): Searches for the target value in a row-wise and column-wise sorted matrix. Args: matrix (list of list of int): 2D list where each row and column is sorted in non-decreasing order. target (int): The value to search for. Returns: tuple: (row_index, col_index) if the value is found. str: \'Value not found\' if the value is not found in the matrix. if not matrix or not matrix[0]: return \'Value not found\' rows = len(matrix) cols = len(matrix[0]) # Start from top right corner row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return (row, col) elif matrix[row][col] > target: col -= 1 else: row += 1 return \'Value not found\'"},{"question":"You are given the root of a binary tree, where each node contains an integer value. You need to implement a function to find the minimum depth of the binary tree. Additionally, implement a function to print the tree nodes in a level-order traversal manner (each level of the tree on a new line). # Function Signature ```python def find_minimum_depth(root: TreeNode) -> int: pass def print_level_order(root: TreeNode) -> None: pass ``` # Input Format The input to `find_minimum_depth` and `print_level_order` is the root node of the binary tree: - `root` (TreeNode): The root of the binary tree. # Output Format * `find_minimum_depth` should return an integer representing the minimum depth of the binary tree. * `print_level_order` should print the tree in a level-order manner, with nodes at each level separated by a space, and levels separated by new lines. # Constraints 1. The number of nodes in the tree will be in the range `[0, 10^4]`. 2. `-1000 <= Node.val <= 1000` # Example Example 1 # Input ``` root = [3,9,20,null,null,15,7] ``` # Output ``` find_minimum_depth(root) => 2 print_level_order(root) 3 9 20 15 7 ``` Explanation The binary tree\'s minimum depth is 2 (from root to node 9). In level-order traversal: * Level 1: 3 * Level 2: 9, 20 * Level 3: 15, 7 Example 2 # Input ``` root = [1,2,3,4,null,null,5] ``` # Output ``` find_minimum_depth(root) => 3 print_level_order(root) 1 2 3 4 5 ``` Explanation The minimum depth is 3 (from root to node 5). In level-order traversal: * Level 1: 1 * Level 2: 2, 3 * Level 3: 4, 5","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_minimum_depth(root: TreeNode) -> int: if not root: return 0 queue = deque([(root, 1)]) while queue: node, depth = queue.popleft() if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) def print_level_order(root: TreeNode) -> None: if not root: return queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(str(node.val)) if node.left: queue.append(node.left) if node.right: queue.append(node.right) print(\\" \\".join(level_nodes))"},{"question":"# Next Permutation Challenge Problem Statement Implement a function `next_permutation(num: int) -> int` that takes a non-negative integer and returns the next higher number containing the exact same set of digits. If no such permutation exists, return -1. Requirements - The function should handle numbers with up to 18 digits. - The function should be optimized for both time and space complexity. - Your function should validate the input to ensure it is a non-negative integer. Input - A single non-negative integer `num`. Output - An integer representing the next higher permutation of the input\'s digits, or `-1` if no such permutation exists. Constraints - The input integer `num` will be between 0 and 10^18. Example ```python next_permutation(38276) # Output: 38627 next_permutation(54321) # Output: -1 next_permutation(12345) # Output: 12354 next_permutation(111) # Output: -1 ``` Notes - You may assume that the input will always be a valid non-negative integer within the specified range. - Avoid using Python\'s built-in permutation functions as they may not be efficient for large inputs. Function Signature ```python def next_permutation(num: int) -> int: pass ``` Testing Make sure your function passes the following test cases: 1. `assert next_permutation(38276) == 38627` 2. `assert next_permutation(54321) == -1` 3. `assert next_permutation(1528452) == 1528524` 4. `assert next_permutation(138654) == 143568` 5. `assert next_permutation(99999) == -1` 6. `assert next_permutation(5) == -1`","solution":"def next_permutation(num: int) -> int: Returns the next higher permutation of the non-negative integer num using the same set of digits. If no such permutation exists, return -1. digits = list(str(num)) n = len(digits) # Step 1: Identify the longest suffix that is non-increasing i = n - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If no such point is found, this means the current permutation is the highest if i == -1: return -1 # Step 2: Identify the smallest digit on the right side of the (i) which is larger than digits[i] j = n - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap these two digits digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the sequence after the original index i digits = digits[:i + 1] + digits[i + 1:][::-1] # Convert the list of digits back to a single integer return int(\'\'.join(digits))"},{"question":"You are tasked with implementing a more efficient and robust version of the Run-Length Encoding algorithm provided. Specifically, you are going to optimize the encoding and decoding functions, handle malformed inputs gracefully, and consider additional edge cases that were not covered in the initial implementation. Function Definitions: - `efficient_encode_rle(input: str) -> str` - `efficient_decode_rle(input: str) -> str` # Input Format: - `efficient_encode_rle`: - `input`: A non-empty string consisting of printable ASCII characters. - `efficient_decode_rle`: - `input`: A non-empty string representing the encoded RLE data. The string will strictly contain digit-character pairs. # Output Format: - `efficient_encode_rle`: returns an RLE compressed string. - `efficient_decode_rle`: returns the original uncompressed string. # Constraints: - Maximum length of `input` string for `efficient_encode_rle` is 10^6 characters. - The count for any character in the `encoded` string should not exceed 10^6. # Scenario: RLE is commonly used in various fields such as simple image compression where areas of the same color pixel are run-length encoded. Consider the example of a simplified monochrome bitmap where the string consists of \'B\' and \'W\' characters representing Black and White pixels respectively. # Examples: ```python print(efficient_encode_rle(\\"AAAABBBCCDAA\\")) # Output: 4A3B2C1D2A print(efficient_decode_rle(\\"4A3B2C1D2A\\")) # Output: AAAABBBCCDAA # Handling edge case with no repeating characters print(efficient_encode_rle(\\"ABCDEFGH\\")) # Output: 1A1B1C1D1E1F1G1H # Handling empty input (Should not occur as per constraints but should fail gracefully if tested) print(efficient_encode_rle(\\"\\")) # Output: \'\' # Malformed input test for decode (Should handle gracefully) print(efficient_decode_rle(\\"12A2\\")) # Output: Error Message or Exception ``` # Detailed Requirements: 1. **Encoding Function (`efficient_encode_rle`)**: - Must handle large inputs efficiently. - Optimize for time and space complexities while ensuring correctness. - Avoid excessive string concatenations. 2. **Decoding Function (`efficient_decode_rle`)**: - Carefully validate input to ensure it follows the expected digit-character pattern. - Provide graceful handling or specific error messages for malformed inputs. - Optimize for performance with large encoded inputs. 3. **Edge Cases**: - Single character strings (e.g., \\"A\\" -> \\"1A\\"). - Long runs (e.g., \\"AAAAA...\\" where count exceeds typical single-digit counts). - Large and small inputs, ensuring they are handled within acceptable time limits.","solution":"def efficient_encode_rle(input: str) -> str: Encodes the input string using Run-Length Encoding (RLE) if not input: return \\"\\" result = [] count = 1 prev_char = input[0] for char in input[1:]: if char == prev_char: count += 1 else: result.append(f\\"{count}{prev_char}\\") count = 1 prev_char = char result.append(f\\"{count}{prev_char}\\") return \\"\\".join(result) def efficient_decode_rle(input: str) -> str: Decodes the RLE encoded string back to the original string if not input: return \\"\\" decoded = [] count = \\"\\" for char in input: if char.isdigit(): count += char else: if not count: raise ValueError(\\"Malformed RLE input: Missing count for character\\") decoded.append(char * int(count)) count = \\"\\" if count: raise ValueError(\\"Malformed RLE input: Trailing digits without character\\") return \\"\\".join(decoded)"},{"question":"**Context**: You are working as a software engineer for a multi-threaded application. The application needs to perform transactions on shared resources, leading to the possibility of deadlocks. In order to prevent deadlocks, you need to detect cycles in a directed graph where each vertex represents a resource, and an edge from A to B indicates that resource A is waiting for resource B. **Task**: Write a function that determines if there is a cycle in a directed graph and abide by the provided constraints and requirements. **Function Signature**: ```python def contains_cycle(graph: Dict[any, List[any]]) -> bool: pass ``` **Input**: * `graph` - A dictionary where keys are nodes and values are lists of nodes representing directed edges. **Output**: * Returns `True` if there is at least one cycle in the graph, `False` otherwise. **Constraints**: * Each node in the graph can be represented by any hashable type (e.g., string, int). * The graph may have any number of nodes and edges, including the possibility of no nodes (empty dictionary). * Nodes with no outgoing edges should be handled correctly. **Performance Requirements**: * The algorithm should run in (O(V + E)) time complexity and use (O(V)) space. **Example**: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(contains_cycle(graph)) # Should output: True graph = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [] } print(contains_cycle(graph)) # Should output: False ``` **Notes**: * Ensure your implementation handles edge cases such as self-loops and graphs with multiple disconnected components. * You are not required to handle invalid input (e.g., malformed graph structures), assume the input graph is well-formed.","solution":"def contains_cycle(graph): def dfs(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True visiting.remove(node) visited.add(node) return False visited = set() visiting = set() for node in graph: if dfs(node): return True return False"},{"question":"Context You\'ve been hired by a large social media platform to develop a feature that flags potential cheating in online word games. Players have been suspected of rearranging letters to form seemingly random words. To detect this, you need to determine whether two given strings are anagrams. Problem Statement Write a function `are_anagrams(s1: str, s2: str) -> bool` that determines whether two strings are anagrams of each other. Two strings are anagrams if they can be rearranged to form the same string. The input strings will only contain lowercase English letters. Input * `s1`: a string containing only lowercase English letters (1 <= len(s1) <= 100). * `s2`: a string containing only lowercase English letters (1 <= len(s2) <= 100). Output * Return `True` if `s1` and `s2` are anagrams. * Return `False` otherwise. Constraints * The function shall work in linear time. Examples ```python are_anagrams(\\"apple\\", \\"pleap\\") -> True are_anagrams(\\"apple\\", \\"cherry\\") -> False are_anagrams(\\"listen\\", \\"silent\\") -> True are_anagrams(\\"hello\\", \\"bello\\") -> False ``` Notes * You should not use inbuilt Python sorting functions. * Pay attention to edge cases such as strings of different lengths.","solution":"def are_anagrams(s1: str, s2: str) -> bool: Determines if two strings are anagrams of each other. :param s1: First string consisting of lowercase English letters. :param s2: Second string consisting of lowercase English letters. :return: True if strings are anagrams of each other, False otherwise. if len(s1) != len(s2): return False char_count = {} for char in s1: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in s2: if char in char_count: char_count[char] -= 1 if char_count[char] == 0: del char_count[char] else: return False return len(char_count) == 0"},{"question":"# Question: Bit Flip Counter Context In digital systems and error-correction codes, it\'s often necessary to determine how many bits differ between two integers. This can be used in assessing the similarity between data, checking for changes or errors, and more. Task Create a function `minimal_bit_flips(a: int, b: int) -> int` to determine the minimal number of bits required to flip in integer `A` to convert it to integer `B`. Input - Two non-negative integers `a` and `b` (0 ≤ a, b ≤ 10^9) Output - A single integer representing the minimum number of bits that need to be flipped to convert `a` to `b`. Constraints - The function should complete within O(1) space complexity. - The function should handle large integers efficiently. Example ```python assert minimal_bit_flips(29, 15) == 2 # binary: 11101 -> 01111 (two bits differ) assert minimal_bit_flips(0, 0) == 0 # binary: 00000 -> 00000 (no bits differ) assert minimal_bit_flips(1, 2) == 2 # binary: 00001 -> 00010 (two bits differ) ``` Performance - The solution must be efficient in both time and space, suitable for the given constraints.","solution":"def minimal_bit_flips(a: int, b: int) -> int: Returns the minimal number of bit flips required to convert integer a to integer b. # XOR a and b to get a number with bits set where a and b differ xor_ab = a ^ b # Count the number of bits set (which are the differing bits) bit_flips = bin(xor_ab).count(\'1\') return bit_flips"},{"question":"You are provided with a partial implementation of a `DirectedGraph` class that supports adding nodes and edges as well as constructing from a dictionary. We need to implement a function to check if there is a path between two nodes in this graph. # Task: Implement the function `exists_path(graph: DirectedGraph, start: str, end: str) -> bool` that determines if there is a path from node `start` to node `end`. The path can traverse multiple directed edges but should follow the directionality. # Input: * `graph`: An instance of the `DirectedGraph` class. * `start`: The starting node name as a string. * `end`: The ending node name as a string. # Output: * Return `True` if there is a path from `start` to `end`, and `False` otherwise. # Constraints: * Consider edge cases like nodes that do not exist, self-loops, and disconnected graphs. * Assume nodes and edges are already populated in the `DirectedGraph` instance. # Example: ```python # Sample graph construction graph_data = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"D\\"], \\"C\\": [], \\"D\\": [\\"C\\"] } graph = DirectedGraph(graph_data) # Function call and expected results assert exists_path(graph, \\"A\\", \\"D\\") == True assert exists_path(graph, \\"A\\", \\"C\\") == True assert exists_path(graph, \\"C\\", \\"A\\") == False assert exists_path(graph, \\"D\\", \\"C\\") == True ``` # Requirements: 1. Do not modify the provided `DirectedGraph` class definition. 2. Your implementation should be efficient for large graphs (consider the most optimal traversal techniques like BFS or DFS).","solution":"class DirectedGraph: def __init__(self, graph_dict=None): Initializes a graph object with an optional graph dictionary. self.graph_dict = graph_dict if graph_dict is not None else {} def add_node(self, node): Adds a node to the graph. if node not in self.graph_dict: self.graph_dict[node] = [] def add_edge(self, node1, node2): Adds a directed edge from node1 to node2. self.add_node(node1) self.add_node(node2) self.graph_dict[node1].append(node2) def exists_path(graph: DirectedGraph, start: str, end: str) -> bool: Determines if there is a path from node \'start\' to node \'end\' in the graph. if start not in graph.graph_dict or end not in graph.graph_dict: return False visited = set() def dfs(node): if node == end: return True visited.add(node) for neighbor in graph.graph_dict[node]: if neighbor not in visited and dfs(neighbor): return True return False return dfs(start)"},{"question":"The task is to implement both encoding and decoding functionalities for run-length encoding. The functions should handle various edge cases and optimize performance for large inputs. Function Signature: ```python def encode_rle(input: str) -> str: def decode_rle(input: str) -> str: ``` Detailed Requirements: 1. **Encoding Function (`encode_rle`)** - Input: A string of characters. - Output: A run-length encoded version of the input string. - Example: ```python encode_rle(\\"aaabbccdd\\") # should return \\"3a2b2c2d\\" encode_rle(\\"a\\") # should return \\"1a\\" encode_rle(\\"\\") # should return \\"\\" ``` - Constraints: * The input string only contains alphanumeric characters. * The length of the input string is between 0 and 10,000. 2. **Decoding Function (`decode_rle`)** - Input: A run-length encoded string. - Output: The original string before encoding. - Example: ```python decode_rle(\\"3a2b2c2d\\") # should return \\"aaabbccdd\\" decode_rle(\\"1a\\") # should return \\"a\\" decode_rle(\\"\\") # should return \\"\\" ``` - Constraints: * The encoded input string is valid and consists of digit-character pairs. Additional Notes: * Ensure that the encoding and decoding processes are robust and can handle edge cases such as empty strings and single character strings. * The solution should be optimised for both time and space complexities where feasible. **Scenario:** Imagine you are working on a simple text compression application where you need to implement run-length encoding which will help to compress repeated sequences within text files. To make this technique useful, you also need to implement the decoder so that the data can be recovered back to its original form. Implement the `encode_rle` and `decode_rle` functions to achieve this.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded_string = [] last_char = input[0] count = 1 for char in input[1:]: if char == last_char: count += 1 else: encoded_string.append(f\\"{count}{last_char}\\") last_char = char count = 1 # Append the final group of characters encoded_string.append(f\\"{count}{last_char}\\") return \'\'.join(encoded_string) def decode_rle(input: str) -> str: if not input: return \\"\\" decoded_string = [] count = \\"\\" for char in input: if char.isdigit(): count += char else: decoded_string.append(char * int(count)) count = \\"\\" return \'\'.join(decoded_string)"},{"question":"**Create and Implement an Enhanced Stack with Min and Max Operations** You are tasked with designing an enhanced version of the stack abstract data type (ADT) that supports not only the standard stack operations (`push`, `pop`, `peek`, `is_empty`), but also two additional operations: 1. `get_min()`: Return the minimum value currently in the stack. 2. `get_max()`: Return the maximum value currently in the stack. **Requirements:** - Implement both an array-based stack (`EnhancedArrayStack`) and a linked-list-based stack (`EnhancedLinkedListStack`). - Ensure that all stack operations, including the new `get_min` and `get_max` methods, operate in O(1) time complexity. **Input and Output Formats:** - Standard stack operations will raise an `IndexError` if attempted on an empty stack. - `get_min()` and `get_max()` should also raise an `IndexError` if the stack is empty. **Constraints:** - The stack should handle integer values. - No external libraries other than those provided in the code snippets may be used. **Performance Requirements:** - All operations (`push`, `pop`, `peek`, `is_empty`, `get_min`, `get_max`) must execute in constant time O(1). **Example:** ```python s = EnhancedArrayStack() s.push(5) s.push(3) s.push(7) s.push(1) print(s.get_min()) # Output: 1 print(s.get_max()) # Output: 7 s.pop() print(s.get_min()) # Output: 3 print(s.get_max()) # Output: 7 s_ll = EnhancedLinkedListStack() s_ll.push(5) s_ll.push(3) s_ll.push(7) s_ll.push(1) print(s_ll.get_min()) # Output: 1 print(s_ll.get_max()) # Output: 7 s_ll.pop() print(s_ll.get_min()) # Output: 3 print(s_ll.get_max()) # Output: 7 ``` Implement the `EnhancedArrayStack` and `EnhancedLinkedListStack` classes, extending from their respective `AbstractStack` base classes.","solution":"class EnhancedArrayStack: def __init__(self): self.stack = [] self.min_stack = [] self.max_stack = [] def push(self, value): self.stack.append(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) if not self.max_stack or value >= self.max_stack[-1]: self.max_stack.append(value) def pop(self): if not self.stack: raise IndexError(\\"pop from an empty stack\\") value = self.stack.pop() if value == self.min_stack[-1]: self.min_stack.pop() if value == self.max_stack[-1]: self.max_stack.pop() return value def peek(self): if not self.stack: raise IndexError(\\"peek from an empty stack\\") return self.stack[-1] def is_empty(self): return len(self.stack) == 0 def get_min(self): if not self.min_stack: raise IndexError(\\"stack is empty\\") return self.min_stack[-1] def get_max(self): if not self.max_stack: raise IndexError(\\"stack is empty\\") return self.max_stack[-1] class Node: def __init__(self, value, next_node=None): self.value = value self.next_node = next_node class EnhancedLinkedListStack: def __init__(self): self.head = None self.min_head = None self.max_head = None def push(self, value): new_node = Node(value, self.head) self.head = new_node if not self.min_head or value <= self.min_head.value: self.min_head = Node(value, self.min_head) if not self.max_head or value >= self.max_head.value: self.max_head = Node(value, self.max_head) def pop(self): if not self.head: raise IndexError(\\"pop from an empty stack\\") value = self.head.value self.head = self.head.next_node if value == self.min_head.value: self.min_head = self.min_head.next_node if value == self.max_head.value: self.max_head = self.max_head.next_node return value def peek(self): if not self.head: raise IndexError(\\"peek from an empty stack\\") return self.head.value def is_empty(self): return self.head is None def get_min(self): if not self.min_head: raise IndexError(\\"stack is empty\\") return self.min_head.value def get_max(self): if not self.max_head: raise IndexError(\\"stack is empty\\") return self.max_head.value"},{"question":"# Scenario You are developing a feature for a text-based game where users enter commands to control a character. Each command is represented by a pattern of actions, defined by a specific sequence of words. You need to verify if a given command input follows the specified pattern for valid execution. # Task Write a function `validate_command(pattern, command_string)` that determines if the `command_string` follows the same pattern described by `pattern`. # Function Signature ```python def validate_command(pattern: str, command_string: str) -> bool: ``` # Input - `pattern` (str): A string pattern consisting of lowercase letters. Each character represents a unique action. - `command_string` (str): A string of commands consisting of lowercase words separated by a single space. # Output - Returns a boolean value `True` if the `command_string` follows the `pattern`, otherwise returns `False`. # Constraints - The `pattern` string will contain only lowercase letters (a-z). - The `command_string` contains lowercase words separated by a single space. # Example **Example 1**: ```python validate_command(\\"abba\\", \\"move jump jump move\\") # Output: True ``` **Example 2**: ```python validate_command(\\"abba\\", \\"move jump jump shoot\\") # Output: False ``` **Example 3**: ```python validate_command(\\"aaaa\\", \\"run run run run\\") # Output: True ``` **Example 4**: ```python validate_command(\\"abcd\\", \\"move jump shoot stand\\") # Output: True ``` **Example 5**: ```python validate_command(\\"abba\\", \\"move move move move\\") # Output: False ``` # Notes You may assume that: - Pattern contains only lowercase letters. - Command contains lowercase words separated by a single space.","solution":"def validate_command(pattern, command_string): Determines if the command_string follows the given pattern. words = command_string.split() if len(pattern) != len(words): return False pattern_to_word = {} word_to_pattern = {} for p, w in zip(pattern, words): if p in pattern_to_word: if pattern_to_word[p] != w: return False else: pattern_to_word[p] = w if w in word_to_pattern: if word_to_pattern[w] != p: return False else: word_to_pattern[w] = p return True"},{"question":"# Question: Strongly Connected Graph Check You are given a directed graph with `V` vertices (`0` to `V-1`) and `E` edges. Determine if this graph is strongly connected. A graph is strongly connected if there is a path between any pair of vertices in both directions. Implement the following method in Python: ```python def is_strongly_connected(V, edges): pass ``` # Input - `V`: An integer representing the number of vertices in the graph. - `edges`: A list of tuples (u, v) representing directed edges from vertex `u` to vertex `v`. # Output - Return `True` if the graph is strongly connected, otherwise return `False`. # Constraints - `1 <= V <= 1000` - `0 <= E <= V*(V-1)` # Example ```python assert is_strongly_connected(5, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]) == True assert is_strongly_connected(5, [(0, 1), (1, 2), (2, 3), (3, 4)]) == False ``` # Notes - Ensure your solution efficiently handles both sparse and dense graph scenarios. - Consider edge cases such as single vertex or no edges.","solution":"def is_strongly_connected(V, edges): from collections import defaultdict, deque def bfs(start, graph): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) queue.extend(graph[node]) return visited if V == 1: return True # Build the graph and its reverse graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) # Check reachability from vertex 0 in the original graph visited_from_first = bfs(0, graph) if len(visited_from_first) != V: return False # Check reachability from vertex 0 in the reverse graph visited_from_first_reverse = bfs(0, reverse_graph) if len(visited_from_first_reverse) != V: return False return True"},{"question":"Longest Common Substring with Distinct Characters Constraint Context Imagine you\'re working on a text analysis tool that needs to quickly identify the longest sequence of characters that two given strings share. Problem Statement You are provided with two strings, `a` and `b`. String `b` contains all distinct characters. Write a function `longest_common_substring_with_distinct_constraint(a: str, b: str) -> str` that finds and returns the longest common substring between `a` and `b`. Your implementation should adhere to the following requirements: - **Input**: - `a`: A string (1 ≤ length of `a` ≤ 10^5). - `b`: A string (1 ≤ length of `b` ≤ 10^5) containing distinct characters. - **Output**: - Return the longest common substring present in both strings. If there are multiple such substrings of the same length, return any one of them. Constraints - The function should handle large inputs efficiently. - Expected time complexity: O(n log n) - Expected space complexity: O(n) **Performance Requirement**: Ensure your solution does not exceed the expected time complexity significantly. Function Signature ```python def longest_common_substring_with_distinct_constraint(a: str, b: str) -> str: # your code here ``` Example *Example 1*: - Input: `a = \\"abcdef\\"`, `b = \\"dezasu\\"` - Output: `\\"de\\"` *Example 2*: - Input: `a = \\"hello\\"`, `b = \\"world\\"` - Output: `\\"o\\"` *Example 3*: - Input: `a = \\"abacabad\\"`, `b = \\"abc\\"` - Output: `\\"ab\\"` Ensure your function accurately identifies the longest common substring as per the provided constraints.","solution":"def longest_common_substring_with_distinct_constraint(a: str, b: str) -> str: Finds and returns the longest common substring between `a` and `b` where `b` contains all distinct characters. def is_common_substring(length): seen = set() for i in range(len(a) - length + 1): seen.add(a[i:i + length]) for j in range(len(b) - length + 1): if b[j:j + length] in seen: return b[j:j + length] return \\"\\" left, right = 0, min(len(a), len(b)) + 1 longest_sub = \\"\\" while left < right: mid = (left + right) // 2 candidate = is_common_substring(mid) if candidate: longest_sub = candidate left = mid + 1 else: right = mid return longest_sub"},{"question":"You are provided with an implementation of the Jump Search algorithm, which is designed to efficiently find an element in a sorted array. Your task is to implement a similar search function for a different context. Problem Statement Create a function `find_book(pages: List[int], target_page: int) -> int` that uses a search strategy similar to Jump Search to locate a given `target_page` in the `pages` list. The `pages` list contains the numbers of the pages in a book, sorted in ascending order. Function Signature ```python def find_book(pages: List[int], target_page: int) -> int: ``` Inputs and Outputs - **Input**: - `pages`: a list of integers where each integer represents a page number in ascending order. (1 <= len(pages) <= 10^5, 1 <= pages[i] <= 10^9 for all valid i) - `target_page`: an integer representing the page number to search for. (1 <= target_page <= 10^9) - **Output**: - Return the index of `target_page` in the list `pages` if it exists, otherwise return `-1`. Constraints - The `pages` list is guaranteed to be sorted in ascending order. - You need to implement the search utilizing a methodology similar to Jump Search. Example ```python # Example 1 pages = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] target_page = 70 find_book(pages, target_page) # Output: 6 # Example 2 pages = [5, 15, 25, 35, 45, 55, 65, 75, 85, 95] target_page = 50 find_book(pages, target_page) # Output: -1 ``` Explanation In the first example, 70 is found at index 6. In the second example, 50 is not in the list, so the function should return `-1`. # Constraints - Ensure your solution is efficient in terms of time complexity, ideally around O(√n). Write your implementation below: ```python def find_book(pages, target_page): # Your code here pass ```","solution":"from math import sqrt from typing import List def find_book(pages: List[int], target_page: int) -> int: Finds the index of the target_page in the pages list using Jump Search. If the target_page is not present, returns -1. Parameters: pages (List[int]): A list of page numbers sorted in ascending order. target_page (int): The page number to search for. Returns: int: The index of the target_page in the list or -1 if not found. n = len(pages) step = int(sqrt(n)) prev = 0 # Finding the block where target_page is present while prev < n and pages[min(n, prev + step) - 1] < target_page: prev += step # Perform linear search in the identified block for i in range(prev, min(n, prev + step)): if pages[i] == target_page: return i # If target_page is not found return -1"},{"question":"# Search and Insert Position in a Sorted Array **Background**: You are given a sorted array of integers. You need to determine the index of a target value in the array. If the target value is not present in the array, you should return the index where it would be if it were inserted in order. **Function Signature**: ```python def search_insert(array: List[int], val: int) -> int: Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. Parameters: array (List[int]): The sorted array of integers. val (int): The target value to search for. Returns: int: The index of the target value if found, or the index where it should be inserted. ``` **Input and Output Requirements**: * Input: A list of integers `array` and an integer `val`. * Output: An integer representing the index of `val` if found, or the index where it should be inserted. **Constraints**: * The array will be sorted in non-decreasing order. * The array length will be between 0 and 10^4. * The values in the array and the value to be inserted are within the range -10^5 to 10^5. **Example**: ```python assert search_insert([1, 3, 5, 6], 5) == 2 assert search_insert([1, 3, 5, 6], 2) == 1 assert search_insert([1, 3, 5, 6], 7) == 4 assert search_insert([1, 3, 5, 6], 0) == 0 assert search_insert([], 5) == 0 ``` **Behavior in Edge Cases**: * Handle empty arrays by returning 0 since any value should be inserted at the start. * Handle cases where the value is smaller/larger than all array elements by returning 0 or len(array) respectively. * Handle arrays of size one to test the basic functioning of the algorithm. **Expected Performance**: * The function should run within O(log n) time complexity. * The function should use O(1) extra space. Write the function `search_insert` that meets the above requirements.","solution":"def search_insert(array, val): Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. Parameters: array (List[int]): The sorted array of integers. val (int): The target value to search for. Returns: int: The index of the target value if found, or the index where it should be inserted. left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == val: return mid elif array[mid] < val: left = mid + 1 else: right = mid - 1 return left"},{"question":"Combination Sum with Dynamic Programming Objective Given an array of positive integers and a positive integer target, write a function to determine the total number of ways the elements of the array can be combined (order matters) to achieve the target sum. Function Signature ```python def combination_sum(nums: List[int], target: int) -> int: ``` Input - `nums`: A list of distinct positive integers. - `target`: A positive integer representing the target sum. Output - An integer representing the number of possible combinations that add up to the target. Constraints - The input list `nums` will have positive integers only. - The length of the list `nums` will not exceed 1000. - The elements of `nums` are distinct. - The target value will be a positive integer less than or equal to 1000. Performance Requirements - The function should run efficiently with a time complexity of O(target * len(nums)). Scenario You are building an application that needs to compute the number of possible combinations to form a given target sum using a set of given integers. For instance, if given the integers [1, 2, 3] and the target 4, there are 7 possible combinations: (1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 3), (2, 1, 1), (2, 2), and (3, 1). Write a function to compute this efficiently using dynamic programming techniques. Additional Considerations - Discuss how the introduction of negative numbers would affect the problem. - Propose any limitations or constraints needed to handle negative numbers. Example ```python nums = [1, 2, 3] target = 4 # Expected output is 7 print(combination_sum(nums, target)) ```","solution":"from typing import List def combination_sum(nums: List[int], target: int) -> int: # Create a list to store the number of combinations for each value up to target dp = [0] * (target + 1) # There is one combination to make a sum of 0, which is to use none of the elements dp[0] = 1 # Iterate through all possible targets from 1 to target for t in range(1, target + 1): for num in nums: if t - num >= 0: dp[t] += dp[t - num] return dp[target]"},{"question":"# Scenario You are designing a part of a financial system that needs to handle very large integers represented as digit arrays. Each integer is split into its individual digits for precise control and computation beyond the standard limits of integer types. Your task is to implement a function that increments such a digit array by one. # Objective Implement a function `increment_digit_array(digits: List[int]) -> List[int]` that takes a list of non-negative integers representing a large number and returns the list representing the number incremented by one. # Requirements - **Input**: A list of integers `digits` where each element is a digit (0-9). The list represents a non-negative integer with the most significant digit in the first position. - **Output**: A list of integers representing the incremented value. # Constraints - The input list is non-empty. - Each element in the list is a single digit (0-9). - The list does not contain leading zeros except for the number zero itself. # Performance - The solution should have O(n) time complexity, where n is the number of digits. - Aim for O(1) extra space if possible, modifying the original list in place. # Function Signature ```python from typing import List def increment_digit_array(digits: List[int]) -> List[int]: pass ``` # Example 1. For `digits = [1, 2, 3]`, the function should return `[1, 2, 4]`. 2. For `digits = [9, 9, 9]`, the function should return `[1, 0, 0, 0]`. 3. For `digits = [4, 3, 2, 1]`, the function should return `[4, 3, 2, 2]`. # Edge Cases 1. Handle overflow situations where multiple nines cause a carry-over. 2. Ensure minimal space usage by modifying the input list in-place where feasible.","solution":"from typing import List def increment_digit_array(digits: List[int]) -> List[int]: Increment the given list of digits by one. n = len(digits) # Start from the last digit and work backwards for i in range(n - 1, -1, -1): if digits[i] == 9: digits[i] = 0 else: digits[i] += 1 return digits # If all digits were 9, we need an additional digit at the start return [1] + digits"},{"question":"# Context: You are developing a reporting tool to analyze media consumption. One insight your team is particularly interested in is identifying the most popular episode of a podcast series from its listening data. Your tool will need to handle large datasets efficiently and account for the possibility of ties in popularity. # Objective: Write a Python function `most_popular_episode` that takes a list of integers as input, where each integer represents a podcast episode ID, and returns a list of the most frequently listened episode ID(s). # Function Signature: ```python def most_popular_episode(episode_list: List[int]) -> List[int]: ``` # Input: - `episode_list` (List[int]): A list of integers representing episode IDs, where each entry corresponds to a listened episode. # Output: - A list of integers representing the episode ID(s) that are the most frequently listened. If there are ties, include all the episode IDs with the highest frequency. The order of IDs in the result does not matter. # Constraints: - The input list can be empty, in which case the function should return an empty list. - The input list can be very large (up to 10^6 elements). - Episode IDs are positive integers. # Example: ```python assert most_popular_episode([3, 4, 3, 2, 4, 4, 3, 5]) == [3, 4] assert most_popular_episode([1, 2, 3, 4]) == [1, 2, 3, 4] assert most_popular_episode([]) == [] ``` # Performance Requirements: - The solution should run in O(n) time complexity, where n is the number of elements in the input list. - The solution should handle up to 10^6 elements efficiently. # Additional Notes: - The result list can be in any order. - Ensure to consider edge cases like an empty list or multiple modes.","solution":"from typing import List from collections import Counter def most_popular_episode(episode_list: List[int]) -> List[int]: Identify the most frequently listened episode ID(s). If input is empty, return an empty list. if not episode_list: return [] episode_counts = Counter(episode_list) max_count = max(episode_counts.values()) return [episode_id for episode_id, count in episode_counts.items() if count == max_count]"},{"question":"# Heap Sort Implementation and Extension In this exercise, you are asked to implement a comprehensive heap sort algorithm and extend it with additional features according to the given specifications. Implement a function `heap_sort(arr, ascending=True, simulation=False)` that sorts an array of integers using the heap sort algorithm. This function should support both ascending and descending order sorting using max heap and min heap respectively, as well as optionally simulate and print the array\'s state at each iteration of the sorting process: Function Signature ```python def heap_sort(arr: List[int], ascending=True, simulation=False) -> List[int]: # Your code here ``` Input 1. `arr`: A list of integers `[a1, a2, ..., an]` where `1 ≤ n ≤ 10^5`. 2. `ascending`: A Boolean flag indicating whether the array should be sorted in ascending order (default is True). 3. `simulation`: A Boolean flag indicating whether to simulate and print the array state at each iteration (default is False). Output The function should return a new sorted list of integers in the specified order. Constraints - If `ascending=True`, use a max heap to sort the array in ascending order. - If `ascending=False`, use a min heap to sort the array in descending order. - For the `simulation=True` flag, the function should print the state of the array at each iteration of the heapify process. Example ```python # Ascending order simulation arr = [5, 3, 8, 4, 2] print(heap_sort(arr, ascending=True, simulation=True)) # Example output (the exact output will represent steps of the heapification process): # iteration 0 : [5, 3, 8, 4, 2] # iteration 1 : [8, 3, 5, 4, 2] # ... # Final sorted output # [2, 3, 4, 5, 8] # Descending order without simulation arr = [5, 3, 8, 4, 2] print(heap_sort(arr, ascending=False, simulation=False)) # Output: [8, 5, 4, 3, 2] ``` Your task is to fill in the function body to satisfy the given requirements. Ensure to handle edge cases and optimize for performance.","solution":"def heap_sort(arr, ascending=True, simulation=False): def heapify(arr, n, i, ascending): largest = i # Initialize largest as root left = 2 * i + 1 # left = 2*i + 1 right = 2 * i + 2 # right = 2*i + 2 if simulation: print(f\\"iteration (before heapify) at index {i}: {arr}\\") if ascending: if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right else: if left < n and arr[left] < arr[largest]: largest = left if right < n and arr[right] < arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap if simulation: print(f\\"iteration (after heapify) at index {i}: {arr}\\") heapify(arr, n, largest, ascending) n = len(arr) for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i, ascending) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap if simulation: print(f\\"iteration (after swap) at index {i}: {arr}\\") heapify(arr, i, 0, ascending) return arr"},{"question":"# Question: Implement an Efficient Multiplication Function Using Bitwise Operators Context Imagine you are developing software for a low-level system where direct use of multiplication operators may not be optimal or allowed due to system constraints. You decide to implement multiplication using only bitwise operations and fundamental arithmetic structures similar to how addition can be performed with bitwise operations. Task Implement a function `multiply_bitwise_operator(a, b)` that multiplies two non-negative integers without using the \'*\' operator. Use bitwise operations and basic arithmetic constructs to achieve this. Input - Two non-negative integers `a` and `b` where ( 0 leq a, b leq 10^9 ). Output - An integer that is the product of `a` and `b`. Examples 1. **Input**: `a = 2`, `b = 3` **Output**: `6` 2. **Input**: `a = 10`, `b = 20` **Output**: `200` 3. **Input**: `a = 15`, `b = 25` **Output**: `375` Constraints - Do not use multiplication operators (\'*\', \'x\'). - Consider edge cases like one of the numbers being zero. Performance Requirements - Aim for an efficient solution with an acceptable time complexity given the constraints. Hint - Consider how you might use bitwise operations like shifting and addition to simulate the multiplication process.","solution":"def multiply_bitwise_operator(a, b): This function multiplies two non-negative integers using bitwise operations. result = 0 while b > 0: if b & 1: # If the current least significant bit of b is 1 result += a # Add the current value of a to the result a <<= 1 # Shift a left by 1 (equivalent to a *= 2) b >>= 1 # Shift b right by 1 (equivalent to b //= 2) return result"},{"question":"# Palindrome Validation with Deque Variation Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. A string is considered a palindrome if it reads the same forward and backward, after ensuring case insensitivity and removing all non-alphanumeric characters. You are required to implement the function `is_palindrome_deque_optimized(s: str) -> bool` using the deque data structure from the `collections` module in Python. Function Signature ```python def is_palindrome_deque_optimized(s: str) -> bool: pass ``` Input * A single string `s` containing the text to be checked. The string may contain any printable ASCII characters. Output * Return `True` if the string is a palindrome, or `False` otherwise. Constraints * The input string can have a maximum length of 10^5 characters. # Examples 1. **Example 1**: * **Input**: `s = \\"A man, a plan, a canal: Panama\\"` * **Output**: `True` 2. **Example 2**: * **Input**: `s = \\"race a car\\"` * **Output**: `False` 3. **Example 3**: * **Input**: `s = \\" \\"` * **Output**: `True` # Requirements * Use the `collections.deque` data structure. * Remove non-alphanumeric characters. * Ignore case while checking for palindrome. * Ensure the function runs in linear time and uses linear space efficiently. # Hints * Use `deque` to efficiently append characters to both ends. * Handle empty strings explicitly as a valid palindrome.","solution":"from collections import deque def is_palindrome_deque_optimized(s: str) -> bool: Returns True if the given string is a palindrome, False otherwise. Only alphanumeric characters are considered, and case is ignored. # Create a deque to hold the alphanumeric characters (ignoring case) dq = deque() for char in s: if char.isalnum(): dq.append(char.lower()) # Check if the deque forms a palindrome while len(dq) > 1: if dq.popleft() != dq.pop(): return False return True"},{"question":"# Huffman Coding Implementation # Objective: Your task is to implement a basic version of Huffman Coding to encode and decode a given text file. You will be provided with the skeleton of the `HuffmanCoding` class. You need to complete the missing methods to make the encoding and decoding functionalities work. # Implementation Details: 1. **Frequency Calculation**: Compute the frequency of each character in the given text. 2. **Building Huffman Tree**: Use the character frequencies to build a Huffman Tree. 3. **Generating Huffman Codes**: Traverse the Huffman Tree to generate binary codes for each character. 4. **Encoding Data**: Replace characters in the text with their corresponding Huffman codes to generate the encoded binary string. 5. **Decoding Data**: Use the Huffman Tree to decode the binary string back to the original text. # Task: Implement the following methods in the `HuffmanCoding` class: - `_get_char_frequency(file) -> dict` - `_create_tree(signs_frequency: dict) -> Node` - `_generate_codes(tree: Node) -> dict` - `_encode_and_write_signs_to_file(file, writer: HuffmanWriter, codes: dict)` - `_decode_and_write_signs_to_file(file, reader: HuffmanReader, tree: Node, additional_bits: int)` # Input: - A text file containing the message to be encoded and decoded (provided as input to methods `encode_file` and `decode_file`). # Output: - An encoded binary file and a decoded text file. # Example: Input Text File: ``` Example input text to be encoded using Huffman Coding. ``` Expected Output Files: - Encoded binary file containing compressed data and Huffman Tree. - Decoded text file identical to the original input text file. # Constraints: - Assume the input file is a plain text file. - Handle all edge cases, such as large files, single unique character files, etc. Note: Additional helper methods and data structures are provided in the `HuffmanCoding` skeleton. Your solution should integrate well with the provided structure. Focus on correctly implementing the core methods mentioned above. ```python # Given HuffmanCoding class with some helper methods class HuffmanCoding: def __init__(self): pass @staticmethod def decode_file(file_in_name, file_out_name): with open(file_in_name, \\"rb\\") as file_in, open(file_out_name, \\"wb\\") as file_out: reader = HuffmanReader(file_in) additional_bits = reader.get_number_of_additional_bits_in_the_last_byte() tree = reader.load_tree() HuffmanCoding._decode_and_write_signs_to_file(file_out, reader, tree, additional_bits) print(\\"File decoded.\\") @staticmethod def _decode_and_write_signs_to_file(file, reader: HuffmanReader, tree: Node, additional_bits: int): # Your implementation here pass @staticmethod def encode_file(file_in_name, file_out_name): with open(file_in_name, \\"rb\\") as file_in, open(file_out_name, mode=\\"wb+\\") as file_out: signs_frequency = HuffmanCoding._get_char_frequency(file_in) file_in.seek(0) tree = HuffmanCoding._create_tree(signs_frequency) codes = HuffmanCoding._generate_codes(tree) writer = HuffmanWriter(file_out) writer.write_bits(\\"000\\") # leave space to save how many bits will be appended to fill the last byte writer.save_tree(tree) HuffmanCoding._encode_and_write_signs_to_file(file_in, writer, codes) writer.close() print(\\"File encoded.\\") @staticmethod def _encode_and_write_signs_to_file(file, writer: HuffmanWriter, codes: dict): # Your implementation here pass @staticmethod def _get_char_frequency(file) -> dict: # Your implementation here pass @staticmethod def _generate_codes(tree: Node) -> dict: # Your implementation here pass @staticmethod def _create_tree(signs_frequency: dict) -> Node: # Your implementation here pass ```","solution":"import heapq from collections import defaultdict, Counter class Node: def __init__(self, char=None, freq=None, left=None, right=None): self.char = char self.freq = freq self.left = left self.right = right # For priority queue def __lt__(self, other): return self.freq < other.freq def build_huffman_tree(frequencies): heap = [Node(char, freq) for char, freq in frequencies.items()] heapq.heapify(heap) while len(heap) > 1: node1 = heapq.heappop(heap) node2 = heapq.heappop(heap) merged = Node(None, node1.freq + node2.freq, node1, node2) heapq.heappush(heap, merged) return heap[0] def generate_codes(node, prefix=\\"\\", codebook=None): if codebook is None: codebook = {} if node is not None: if node.char: codebook[node.char] = prefix generate_codes(node.left, prefix + \'0\', codebook) generate_codes(node.right, prefix + \'1\', codebook) return codebook class HuffmanReader: # Placeholder class to avoid syntax errors def __init__(self, file_in): pass def get_number_of_additional_bits_in_the_last_byte(self): return 0 def load_tree(self): return None class HuffmanWriter: # Placeholder class to avoid syntax errors def __init__(self, file_out): pass def write_bits(self, bits): pass def save_tree(self, tree): pass def close(self): pass class HuffmanCoding: def __init__(self): pass @staticmethod def decode_file(file_in_name, file_out_name): with open(file_in_name, \\"rb\\") as file_in, open(file_out_name, \\"wb\\") as file_out: reader = HuffmanReader(file_in) additional_bits = reader.get_number_of_additional_bits_in_the_last_byte() tree = reader.load_tree() HuffmanCoding._decode_and_write_signs_to_file(file_out, reader, tree, additional_bits) print(\\"File decoded.\\") @staticmethod def _decode_and_write_signs_to_file(file, reader: HuffmanReader, tree: Node, additional_bits: int): # Needs actual implementation pass @staticmethod def encode_file(file_in_name, file_out_name): with open(file_in_name, \\"rb\\") as file_in, open(file_out_name, mode=\\"wb+\\") as file_out: signs_frequency = HuffmanCoding._get_char_frequency(file_in) file_in.seek(0) tree = HuffmanCoding._create_tree(signs_frequency) codes = HuffmanCoding._generate_codes(tree) writer = HuffmanWriter(file_out) writer.write_bits(\\"000\\") # leave space to save how many bits will be appended to fill the last byte writer.save_tree(tree) HuffmanCoding._encode_and_write_signs_to_file(file_in, writer, codes) writer.close() print(\\"File encoded.\\") @staticmethod def _encode_and_write_signs_to_file(file, writer: HuffmanWriter, codes: dict): text = file.read().decode(\'utf-8\') encoded_text = \'\'.join(codes[char] for char in text) while len(encoded_text) % 8 != 0: encoded_text += \'0\' writer.write_bits(encoded_text) @staticmethod def _get_char_frequency(file) -> dict: text = file.read().decode(\'utf-8\') frequency = Counter(text) return frequency @staticmethod def _generate_codes(tree: Node) -> dict: return generate_codes(tree) @staticmethod def _create_tree(signs_frequency: dict) -> Node: return build_huffman_tree(signs_frequency)"},{"question":"# Context You are working on a spell checker program and want to leverage the concept of edit distance to suggest correct spellings. Given two words, you need to determine the minimum number of single-character edits required to transform the first word into the second one. # Task Implement a function `min_edit_distance(word1: str, word2: str) -> int` that calculates the edit distance between two strings `word1` and `word2`. # Input * `word1` (1 <= len(word1) <= 1000): a non-empty string representing the source word. * `word2` (1 <= len(word2) <= 1000): a non-empty string representing the target word. # Output * Return an integer representing the minimum number of operations required to transform `word1` into `word2`. # Constraints * Allowed operations: - Insert a character. - Delete a character. - Substitute a character. * Performance must be efficient enough to handle the upper limits of input sizes reasonably. # Example ```python assert min_edit_distance(\\"kitten\\", \\"sitting\\") == 3 # \\"kitten\\" -> \\"sitten\\" (substitution of \'k\' with \'s\') # \\"sitten\\" -> \\"sittin\\" (substitution of \'e\' with \'i\') # \\"sittin\\" -> \\"sitting\\" (insertion of \'g\') assert min_edit_distance(\\"flaw\\", \\"lawn\\") == 2 # \\"flaw\\" -> \\"law\\" (deletion of \'f\') # \\"law\\" -> \\"lawn\\" (insertion of \'n\') ``` # Notes - Ensure to consider and handle edge cases effectively. - Aim to achieve optimal time and space complexity.","solution":"def min_edit_distance(word1, word2): Calculate the minimum edit distance between two words using dynamic programming. Args: word1 (str): The source word. word2 (str): The target word. Returns: int: The minimum edit distance. m, n = len(word1), len(word2) # Create a table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp[][] in bottom-up manner for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If first string is empty, insert all characters of second string elif j == 0: dp[i][j] = i # If second string is empty, remove all characters of first string elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If last characters are same, ignore last character and recur for remaining string else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"**Scenario**: You are working on a project that involves processing hierarchical data structures represented as binary trees. One of your tasks is to produce a level-by-level representation of the binary tree to allow easier data manipulation and analysis. **Task**: Write a function `level_order` that takes the root of a binary tree and returns a list of lists. Each inner list should contain the values of the nodes at each level of the tree, from left to right. # Function Signature ```python def level_order(root: TreeNode) -> List[List[int]]: ``` # Input - `root`: TreeNode: The root node of the binary tree. # Output - `List[List[int]]`: A list of lists, where each inner list contains the values of the nodes at each level of the tree. # Constraints - The number of nodes in the tree is in the range `[0, 2000]`. - The values of the nodes are unique integer values within a suitable range for practical usage. # Example ```python # Example 1 # Given binary tree [3,9,20,null,null,15,7], # 3 # / # 9 20 # / # 15 7 # Return: # [ # [3], # [9,20], # [15,7] # ] # Example 2 # Given binary tree [1], # 1 # Return: # [ # [1] # ] # Example 3 # Given binary tree [], # Return: # [] ``` # Sample Solution ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order(root: TreeNode) -> List[List[int]]: result = [] if not root: return result level = [root] while level: current = [] new_level = [] for node in level: current.append(node.val) if node.left: new_level.append(node.left) if node.right: new_level.append(node.right) result.append(current) level = new_level return result ```","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order(root: Optional[TreeNode]) -> List[List[int]]: Returns the level order traversal of a binary tree. result = [] if not root: return result queue = [root] while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.pop(0) current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"# Scenario You are tasked with saving and loading game states that are represented as binary trees. Each node of the tree represents an item, and the entire tree structure represents the game state. You need to serialize the tree to save it and deserialize it to reload the game state. # Problem Statement Implement two functions: 1. `serialize(root: TreeNode) -> str`: This function should take the root of a binary tree and return a single string that represents the serialized tree. 2. `deserialize(data: str) -> TreeNode`: This function should take a string representation of the serialized tree and return the root of the binary tree. # Input Format * For `serialize`: * `root`: The root node of a binary tree (can be `None`). * For `deserialize`: * `data`: A string representing the serialized binary tree obtained from the `serialize` function. # Output Format * For `serialize`: * A string representing the tree. * For `deserialize`: * The root node of the reconstructed binary tree. # Constraints * The number of nodes in the tree is in the range [0, 10^4]. * The values of the nodes are integers and might be negative or positive. # Example ```python # Example usage: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) # Serialize the tree serialized_data = serialize(root) print(serialized_data) # Example output: \\"1 2 # # 3 4 # # 5 # #\\" # Deserialize the string back to tree deserialized_root = deserialize(serialized_data) ``` # Notes * Ensure that your implementation handles all edge cases such as empty trees and trees with varied structures appropriately. * Aim for an efficient solution in terms of both time and space.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Serializes a binary tree to a string. def rserialize(node, string): if node is None: string += \'# \' else: string += str(node.val) + \' \' string = rserialize(node.left, string) string = rserialize(node.right, string) return string return rserialize(root, \'\').strip() def deserialize(data): Deserializes a string to a binary tree. def rdeserialize(l): if l[0] == \'#\': l.pop(0) return None root = TreeNode(val=int(l.pop(0))) root.left = rdeserialize(l) root.right = rdeserialize(l) return root data_list = data.split() return rdeserialize(data_list)"},{"question":"# Palindrome Substring Finder Problem Statement You are given a string `s` comprised of alphanumeric characters. Your task is to find the longest palindromic substring within `s`. The palindromic substring should be contiguous and must read the same backward and forward when considering only alphanumeric characters and ignoring cases. Write a function `longest_palindrome_substring(s: str) -> str` that takes a string `s` and returns the longest palindromic substring of `s`. Input and Output Formats * **Input**: A string `s` (1 <= len(s) <= 1000), which may contain alphabets (both uppercase and lowercase) and digits. * **Output**: A string that is the longest palindromic substring. Constraints * If there are multiple substrings with the same length, return the one which appears first in the string. * Assume the input will always have at least one valid palindromic substring (including a single character). Example *Example 1*: ``` Input: \\"babad\\" Output: \\"bab\\" (Note: \\"aba\\" is also a valid answer.) ``` *Example 2*: ``` Input: \\"cbbd\\" Output: \\"bb\\" ``` *Example 3*: ``` Input: \\"A man, a plan, a canal: Panama\\" Output: \\"A man, a plan, a c\\" ``` Considerations * Remember to preprocess the input string to ignore non-alphanumeric characters and consider case insensitivity. * Aim for an efficient solution. An ideal solution has a time complexity of O(n^2). Solution Template ```python def longest_palindrome_substring(s: str) -> str: def preprocess_string(s): return \\"\\".join(char.lower() for char in s if char.isalnum()) def find_longest_palindrome(s): max_len = 0 start = 0 for i in range(len(s)): len1 = expand_around_center(s, i, i) len2 = expand_around_center(s, i, i + 1) curr_len = max(len1, len2) if curr_len > max_len: max_len = curr_len start = i - (curr_len - 1) // 2 return s[start:start + max_len] def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return right - left - 1 processed_string = preprocess_string(s) if not processed_string: return \\"\\" longest_palindrome = find_longest_palindrome(processed_string) return longest_palindrome # Test cases: # assert longest_palindrome_substring(\\"babad\\") == \\"bab\\" # or \\"aba\\" # assert longest_palindrome_substring(\\"cbbd\\") == \\"bb\\" # assert longest_palindrome_substring(\\"A man, a plan, a canal: Panama\\") == \\"amanaplanacanalpanama\\" ```","solution":"def longest_palindrome_substring(s: str) -> str: def preprocess_string(s): return \\"\\".join(char.lower() for char in s if char.isalnum()) def find_longest_palindrome(s): max_len = 0 start = 0 for i in range(len(s)): len1 = expand_around_center(s, i, i) len2 = expand_around_center(s, i, i + 1) curr_len = max(len1, len2) if curr_len > max_len: max_len = curr_len start = i - (curr_len - 1) // 2 return s[start:start + max_len] def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return right - left - 1 if not s: return \\"\\" processed_string = preprocess_string(s) longest_palindrome = find_longest_palindrome(processed_string) return longest_palindrome"},{"question":"# Context You are developing a function for a numerical analysis tool where you frequently need to identify specific digits from an infinitely long sequence of concatenated positive integers. For example, the sequence starts as \\"123456789101112131415...\\", and you might need to find the 15th digit, which is \'2\'. # Task Write a function `find_nth_digit(n)` that finds and returns the nth digit of the infinite sequence of concatenated positive integers. # Input * `n`: An integer (1 ≤ n ≤ 10^18) representing the position of the digit to be found. # Output * Returns an integer which is the nth digit in the sequence. # Constraints * The function should be efficient with a time complexity of O(log(n)). * The function should handle very large values of `n` up to 10^18 efficiently. * Avoid using floating-point arithmetic to prevent precision errors. # Examples 1. `find_nth_digit(3)` should return `3` 2. `find_nth_digit(11)` should return `0` 3. `find_nth_digit(12)` should return `1` 4. `find_nth_digit(15)` should return `2` # Notes * Ensure to consider the transitions when digits span across boundaries of numbers (like from single digit to double digits).","solution":"def find_nth_digit(n): Find and return the nth digit of the infinite sequence of concatenated positive integers. # Initialize digits_length, count and start digits_length = 1 count = 9 start = 1 # Determine the range where \'n\' falls while n > digits_length * count: n -= digits_length * count digits_length += 1 count *= 10 start *= 10 # Determine the exact number and digit within that number start += (n - 1) // digits_length digit_index = (n - 1) % digits_length return int(str(start)[digit_index])"},{"question":"# Question: Zigzag Iterator for Multiple Lists You are tasked with implementing a general-purpose Zigzag Iterator that can handle any number of lists, not just two. The iterator should extract elements in a round-robin fashion from a list of lists, ensuring that each list contributes its elements alternately. Function Signature ```python class ZigzagIterator: def __init__(self, lists): Initialize your data structure here. :param lists: List[List[int]] - A list containing k lists from which to alternate extraction. def next(self): :return: int - The next element in Zigzag order. def has_next(self): :return: bool - True if there are more elements to retrieve, False otherwise. ``` # Input - `lists`: A list containing k sublists, each sublist is a list of integers. # Output - `next()`: Returns the next element in the zigzag order. - `has_next()`: Returns a boolean indicating whether there are more elements to retrieve. # Constraints - The total number of elements across all the lists will be at most `10^4`. - The total number of lists `k` can vary, but will never be more than `10^3`. # Example ```python l1 = [1, 2] l2 = [3, 4, 5, 6] l3 = [7, 8, 9, 10] it = ZigzagIterator([l1, l2, l3]) while it.has_next(): print(it.next()) # Expected Output: # 1, 3, 7, 2, 4, 8, 5, 9, 6, 10 ``` # Requirements - Your solution must handle the lists in such a way that each list alternates contributing its next element in a round-robin fashion. - You should handle edge cases where some lists might be empty or have different lengths. - Write efficient code to ensure prompt response for large numbers of lists and elements.","solution":"from collections import deque class ZigzagIterator: def __init__(self, lists): Initialize your data structure here. :param lists: List[List[int]] - A list containing k lists from which to alternate extraction. self.queue = deque() for lst in lists: if lst: # Append a deque object with the list\'s iterator self.queue.append(deque(lst)) def next(self): :return: int - The next element in Zigzag order. if self.has_next(): # Pop the list at the front of the queue current_list = self.queue.popleft() # Take the next element from it next_element = current_list.popleft() # If there are more elements left in the current list, put it back to the queue if current_list: self.queue.append(current_list) return next_element else: raise StopIteration(\\"No more elements\\") def has_next(self): :return: bool - True if there are more elements to retrieve, False otherwise. return bool(self.queue)"},{"question":"# Scenario: You are tasked with developing an application that will help touch typists practice their skills with specific constraints: they must type words that can be formed using letters from only one row on a standard American keyboard. You need to implement a function to help validate these words based on the given constraints. # Task: Implement a function `validate_keyboard_rows(words)` that receives a list of words and returns only those words that can be typed using letters from a single row on an American keyboard. # Guidelines: 1. Assume all input words contain only alphabetic characters. 2. Case sensitivity should be ignored; handle all input words as if they are lowercase. 3. Return the words that can be fully typed using letters from one row without mixing rows. # Input: - `words` (List[str]): A list of words given as strings. # Output: - (List[str]): A list of words that are valid based on the described criteria. # Example: ```python # Example Input words = [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] # Example Output [\\"Alaska\\", \\"Dad\\"] ``` # Constraints: - The length of `words` list will be between 1 and 100. - Each word will have a length between 1 and 100. # Function Signature: ```python def validate_keyboard_rows(words: List[str]) -> List[str]: # Your code here ```","solution":"def validate_keyboard_rows(words): Returns a list of words that can be typed using letters from one row on a standard American keyboard. # Define the rows on the keyboard row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") def is_single_row(word): word_set = set(word.lower()) return word_set.issubset(row1) or word_set.issubset(row2) or word_set.issubset(row3) return [word for word in words if is_single_row(word)]"},{"question":"# **Queue Implementation and Usage Assessment** Objective: Design and implement an efficient queue using a circular buffer (circular array) approach. Background: Queues are fundamental data structures used to manage elements in a first-in-first-out (FIFO) order. Traditional array-based queues can face issues with resizing and inefficiency in memory usage. Circular buffers utilize a fixed-size array where the end of the array wraps around to the beginning, which can help to optimize performance and space usage. Your task is to implement a `CircularQueue` class to enhance the behavior of a typical array-based queue. Requirements: 1. **Class Name**: `CircularQueue` 2. **Attributes**: * `capacity`: Integer, maximum number of elements the queue can hold. * `array`: List to store queue elements. * `size`: Integer to keep track of the number of elements. * `front`: Integer index representing the front of the queue. * `rear`: Integer index representing the next position to insert element in the queue. 3. **Methods**: - `enqueue(value)`: Adds an element to the rear of the queue. - `dequeue()`: Removes and returns the front element. - `peek()`: Returns the front element without removing it. - `is_empty()`: Checks if the queue is empty. - `is_full()`: Checks if the queue is full. - `__len__()` :Returns the size of the queue. Constraints: - The queue should handle all standard edge cases, including full capacity and empty state. - `enqueue` and `dequeue` operations should both be O(1). - Assume queue only holds integer values. Input: - Sequence of operations to test the queue (e.g., `enqueue` followed by some `enqueue`, `dequeue`, `peek`). Output: - For each `enqueue`, return `Null`. - For each `dequeue` and `peek`, return the appropriate element or raise specific exceptions for underflow conditions. Example Scenario: ```python cq = CircularQueue(3) cq.enqueue(1) # Null cq.enqueue(2) # Null print(cq.dequeue()) # 1 print(cq.peek()) # 2 cq.enqueue(3) # Null cq.enqueue(4) # Null print(cq.is_full()) # True print(cq.is_empty()) # False print(len(cq)) # 3 ``` Implement the `CircularQueue` class in Python.","solution":"class CircularQueue: def __init__(self, capacity): self.capacity = capacity self.array = [None] * capacity self.size = 0 self.front = 0 self.rear = 0 def enqueue(self, value): if self.is_full(): raise OverflowError(\\"Queue is full\\") self.array[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.array[self.front] self.array[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.array[self.front] def is_empty(self): return self.size == 0 def is_full(self): return self.size == self.capacity def __len__(self): return self.size"},{"question":"You are provided with a sorted array of integers (in ascending order). Implement a function using binary search (both iterative and recursive approach) to find and return the index of a target value in the given array. If the target value is not present in the array, the function should return -1. Ensure that your implementation can efficiently handle large input sizes. # Function Signature ```python def binary_search_iterative(array: List[int], target: int) -> int: pass def binary_search_recursive(array: List[int], low: int, high: int, target: int) -> int: pass ``` # Input - The array will be provided as a list of integers, `array`, of size `n` where (`0 <= n <= 10^6`). - The target value will be provided as an integer, `target`. - For the recursive function, `low` and `high` will be provided which denote the starting and ending indices of the array. # Output - An integer representing the index of the target value if found, otherwise -1. # Example ```python print(binary_search_iterative([1, 2, 3, 4, 5, 6, 7, 8, 9], 5)) # Output: 4 print(binary_search_recursive([1, 2, 3, 4, 5, 6, 7, 8, 9], 0, 8, 10)) # Output: -1 ``` # Constraints - The array is guaranteed to be sorted in ascending order. - Handle edge cases such as an empty array or a target not present in the array. - Optimize for both time complexity and space complexity. # Additional Notes - Ensure your algorithm handles the possibility of an empty array gracefully. - Avoid common pitfalls such as integer overflow when calculating the midpoint.","solution":"from typing import List def binary_search_iterative(array: List[int], target: int) -> int: Perform binary search in an iterative manner low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: low = mid + 1 else: high = mid - 1 return -1 def binary_search_recursive(array: List[int], low: int, high: int, target: int) -> int: Perform binary search in a recursive manner if low > high: return -1 mid = (low + high) // 2 if array[mid] == target: return mid elif array[mid] < target: return binary_search_recursive(array, mid + 1, high, target) else: return binary_search_recursive(array, low, mid - 1, target)"},{"question":"Constructing and Printing Inorder Traversal of Full Binary Tree You\'ve been given the preorder and postorder traversal sequences of a full binary tree. Your task is to reconstruct the binary tree from these traversals and then print its inorder traversal. A full binary tree is a binary tree where every node has either zero or two children. **Input**: - An array `pre` representing the preorder traversal of the tree. - An array `post` representing the postorder traversal of the tree. **Output**: - An array representing the inorder traversal of the reconstructed binary tree. # Function Signature ```python def construct_and_print_inorder(pre: List[int], post: List[int]) -> List[int]: pass ``` # Constraints - Each value in the arrays `pre` and `post` is unique and positive. - Node values range between 1 and `10^5`. - The length of the arrays `pre` and `post` are the same, denoted as `n` such that `1 <= n <= 10^3`. # Example ```python # Example 1 pre = [1, 2, 4, 8, 9, 5, 3, 6, 7] post = [8, 9, 4, 5, 2, 6, 7, 3, 1] # Expected Output: [8, 4, 9, 2, 5, 1, 6, 3, 7] # Example 2 pre = [1, 2, 4, 5, 3, 6, 7] post = [4, 5, 2, 6, 7, 3, 1] # Expected Output: [4, 2, 5, 1, 6, 3, 7] ``` # Explanation For example 1: - Given preorder traversal: [1, 2, 4, 8, 9, 5, 3, 6, 7] - Given postorder traversal: [8, 9, 4, 5, 2, 6, 7, 3, 1] - The reconstructed tree would look like: ``` 1 / 2 3 / / 4 5 6 7 / 8 9 ``` - The inorder traversal of this tree is: [8, 4, 9, 2, 5, 1, 6, 3, 7] For this exercise, you will implement `construct_and_print_inorder` to achieve the above functionality.","solution":"def construct_and_print_inorder(pre, post): def build(pre, post): if not pre or not post: return None root = TreeNode(pre[0]) if len(pre) == 1: return root L = post.index(pre[1]) + 1 root.left = build(pre[1:L+1], post[:L]) root.right = build(pre[L+1:], post[L:-1]) return root def inorder_traversal(root): return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) if root else [] class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right tree = build(pre, post) return inorder_traversal(tree)"},{"question":"# Question: Implement the Modified Ternary Search You are required to implement the Ternary Search algorithm. The function should take as input a sorted array of integers, a left index, a right index, and the key to be searched. The function should return the index of the key if found, and -1 otherwise. **Function Signature:** ```python def modified_ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: ``` **Input:** - `arr` (List[int]): A list of integers sorted in ascending order. - `left` (int): The starting index of the array segment being searched. - `right` (int): The ending index of the array segment being searched. - `key` (int): The integer value to search for in the array. **Output:** - Returns the index (int) of the key if found. - Returns -1 if the key is not found. **Constraints:** - The input array will contain at most 10^6 elements. - The values in the array will be between -10^9 and 10^9. **Example:** ```python # Example 1 arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21] left = 0 right = len(arr) - 1 key = 11 print(modified_ternary_search(left, right, key, arr)) # Should return 5 # Example 2 arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] key = 11 print(modified_ternary_search(0, len(arr) - 1, key, arr)) # Should return -1 ``` **Note:** - Avoid indexing out of bounds and ensure the calculations for mid1 and mid2 are correct. - Ensure the array is non-empty.","solution":"from typing import List def modified_ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: while left <= right: third = (right - left) // 3 mid1 = left + third mid2 = right - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"# Task You are tasked with implementing a more efficient sorting algorithm to replace the Bogo Sort algorithm for sorting a list of integers. # Input and Output Formats **Input**: ```python arr: List[int] ``` * A list of integers that needs to be sorted. **Output**: ```python List[int] ``` * The sorted list of integers in ascending order. # Constraints * The list will contain at most 1000 integers. * Each integer in the list will range between -10000 and 10000. # Requirements 1. Implement a sorting algorithm that is more efficient than Bogo Sort. 2. Your implementation should have a time complexity of O(n log n) in the average case. 3. You can choose any efficient sorting algorithm (e.g., Merge Sort, Quick Sort, Heap Sort). # Additional Notes 1. Explain the algorithm you chose to implement and why it is more efficient compared to Bogo Sort. 2. Ensure your implementation handles edge cases like empty arrays, arrays with identical elements, and already sorted arrays. # Function Signature ```python def efficient_sort(arr: List[int]) -> List[int]: pass ``` # Example ```python assert efficient_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] assert efficient_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert efficient_sort([]) == [] ```","solution":"def merge_sort(arr): if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left, right): sorted_list = [] left_pointer = right_pointer = 0 while left_pointer < len(left) and right_pointer < len(right): if left[left_pointer] <= right[right_pointer]: sorted_list.append(left[left_pointer]) left_pointer += 1 else: sorted_list.append(right[right_pointer]) right_pointer += 1 sorted_list.extend(left[left_pointer:]) sorted_list.extend(right[right_pointer:]) return sorted_list def efficient_sort(arr): return merge_sort(arr)"},{"question":"# Question: Implement an Advanced Cycle Sort with Error Handling **Context:** As part of your role as a software engineer, you are often tasked with sorting arrays efficiently. Memory writes in your current environment are costly, so minimizing them is crucial. You need to implement Cycle Sort but with additional constraints and error handling to ensure robustness in various scenarios. **Task:** Write a function `advanced_cycle_sort(arr)` that implements an optimized and robust version of Cycle Sort. Your function should handle duplicates efficiently and prevent infinite loops. Additionally, it should return both the sorted array and the count of writes performed. **Function Signature:** ```python def advanced_cycle_sort(arr: list) -> tuple: Sort the given array using Cycle Sort algorithm and return the sorted array along with the number of writes performed. Args: arr (list): The list of integers to sort. Returns: tuple: A tuple containing the sorted list and the number of writes performed. ``` **Input:** - `arr`: A list of integers, where 1 ≤ len(arr) ≤ 10^4, and -10^5 ≤ arr[i] ≤ 10^5. **Output:** - A tuple containing the sorted list and an integer representing the number of write operations performed. **Constraints:** - The function should handle both unique and duplicate values. - Ensure that the function does not enter into an infinite loop during sorting. - Minimize the number of write operations. **Example:** ```python sample_input = [4, 3, 2, 1] output = advanced_cycle_sort(sample_input) # Expected output: ([1, 2, 3, 4], number_of_writes) ``` Use the provided example to validate the functionality of your solution. The goal is to test both the correctness and the efficiency of your implementation.","solution":"def advanced_cycle_sort(arr): Sort the given array using Cycle Sort algorithm and return the sorted array along with the number of writes performed. Args: arr (list): The list of integers to sort. Returns: tuple: A tuple containing the sorted list and the number of writes performed. writes = 0 for start in range(0, len(arr) - 1): item = arr[start] pos = start for i in range(start + 1, len(arr)): if arr[i] < item: pos += 1 if pos == start: continue while item == arr[pos]: pos += 1 if pos != start: arr[pos], item = item, arr[pos] writes += 1 while pos != start: pos = start for i in range(start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 if item != arr[pos]: arr[pos], item = item, arr[pos] writes += 1 return arr, writes"},{"question":"# Problem Description You are given two singly linked lists that may or may not intersect. Write a function `find_intersection(h1, h2)` that returns the node where the two lists intersect. If the lists do not intersect, return `None`. # Function Signature ```python def find_intersection(h1: Node, h2: Node) -> Optional[Node]: ``` # Input * `h1` and `h2`: The heads of the two singly linked lists. # Output * Return the node where the two linked lists intersect. If they do not intersect, return `None`. # Constraints * Must efficiently handle lists with lengths in the thousands. * Aim for O(N + M) time complexity and O(1) space complexity. * Lists have no cycles. # Example ```python # Example linked lists: # 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # 2 -> 4 -> 6 # The intersection node is Node(7) a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f # Calling the function print(find_intersection(a1, a2).val) # Output: 7 ``` # Notes * The node itself (memory reference) is the unique identifier, not the value of the node. * Handle edge cases like one or both lists being empty, or having no intersection. * Return `None` for lists with no intersection.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def find_intersection(h1: Node, h2: Node) -> Node: Function to find the intersection node of two singly linked lists. If there is no intersection, return None. if h1 is None or h2 is None: return None # Get the lengths of both linked lists def get_length(head: Node) -> int: length = 0 while head: length += 1 head = head.next return length length1 = get_length(h1) length2 = get_length(h2) # Align the start of both linked lists if length1 > length2: for _ in range(length1 - length2): h1 = h1.next else: for _ in range(length2 - length1): h2 = h2.next # Traverse both lists together until we find the intersection or reach the end while h1 and h2: if h1 == h2: return h1 h1 = h1.next h2 = h2.next return None"},{"question":"**Problem Statement:** Given a sentence containing words separated by single spaces, write a function `reverse_word_order_with_case(sentence: str) -> str` that reverses the order of the words such that the first word becomes the last and the last word becomes the first. Moreover, ensure that the capitalization of the first word in the sentence remains unchanged while the rest within the sentence is adjusted accordingly. **Scenario:** Suppose you are working on a text processing system that must ensure headers in documents are reversed while maintaining proper capitalization at the beginning of the sentence. **Function Signature:** ```python def reverse_word_order_with_case(sentence: str) -> str: pass ``` **Input:** - `sentence`: A string `s` containing words separated by single spaces (1 <= len(s) <= 10^4). **Output:** - A string containing the words in reverse order with correct capitalization. **Constraints:** - The input string does not contain leading or trailing spaces. **Performance Requirements:** - The algorithm should run in O(n) time complexity where `n` is the length of the input string. - The space complexity should be O(n). **Examples:** ```python assert reverse_word_order_with_case(\\"Hello world\\") == \\"World hello\\" assert reverse_word_order_with_case(\\"This is a test\\") == \\"Test a is this\\" assert reverse_word_order_with_case(\\"Coding is fun\\") == \\"Fun is coding\\" ```","solution":"def reverse_word_order_with_case(sentence: str) -> str: Reverses the order of words in the sentence while maintaining proper capitalization at the beginning. words = sentence.split() reversed_words = words[::-1] # Capitalize the first word of the reversed sentence reversed_sentence = \' \'.join(reversed_words) reversed_sentence = reversed_sentence.capitalize() return reversed_sentence"},{"question":"# Question Consider an implementation of the Union-Find data structure, also known as Disjoint Set, used to dynamically track a partition of sets and efficiently perform union and find operations. Given a 2D grid where initially all cells are water, you are to determine the number of islands after a series of addLand operations. An island is defined as a group of adjacent lands connected horizontally or vertically. Your task is to implement a function that processes these operations and returns the number of islands formed after each operation. Function Signature ```python def num_islands(positions, rows, cols): ``` Input - **positions** (List[List[int]]): A list of lists where each sublist contains two integers [r, c] representing the cell (r, c) where the addLand operation is performed. - **rows** (int): Number of rows in the grid. - **cols** (int): Number of columns in the grid. Output - **List[int]**: A list of integers representing the number of islands after each operation. Constraints - `1 <= rows, cols <= 1000` - `1 <= len(positions) <= 1000` - `0 <= positions[i][0] < rows` - `0 <= positions[i][1] < cols` Example Input: ```python positions = [[0, 0], [0, 1], [1, 2], [2, 1]] rows = 3 cols = 3 ``` Output: ```python [1, 1, 2, 3] ``` # Explanation - Initially, the grid is: ``` 0 0 0 0 0 0 0 0 0 ``` - After `addLand(0, 0)`: ``` 1 0 0 0 0 0 0 0 0 ``` Number of islands = 1 - After `addLand(0, 1)`: ``` 1 1 0 0 0 0 0 0 0 ``` Number of islands = 1 - After `addLand(1, 2)`: ``` 1 1 0 0 0 1 0 0 0 ``` Number of islands = 2 - After `addLand(2, 1)`: ``` 1 1 0 0 0 1 0 1 0 ``` Number of islands = 3 Implement the function accordingly and ensure to handle edge cases such as redundant addLand operations or out-of-bound inputs properly.","solution":"def num_islands(positions, rows, cols): def find(parent, x): if parent[x] != x: parent[x] = find(parent, parent[x]) return parent[x] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] parent = {} rank = {} count = 0 results = [] for r, c in positions: if (r, c) in parent: results.append(count) continue parent[(r, c)] = (r, c) rank[(r, c)] = 0 count += 1 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) in parent: if find(parent, (r, c)) != find(parent, (nr, nc)): union(parent, rank, (r, c), (nr, nc)) count -= 1 results.append(count) return results"},{"question":"# Question: Enhanced Insertion Sort You are required to implement an optimized version of insertion sort that uses binary search to minimize the number of comparisons during the insertion phase. Your function should sort an array of integers in ascending order. Requirements: 1. **Function Name**: `optimized_insertion_sort` 2. **Input**: A list of integers `arr`. 3. **Output**: A sorted list of integers. 4. **Constraints**: - The list will have at most (10^3) elements. - Element values will be in the range [-10^4, 10^4]. 5. **Performance**: - The optimized version should improve the insertion position finding phase to (O(log n)) using binary search. Example: ```python # Example 1 input = [4, 3, 2, 10, 12, 1, 5, 6] output = [1, 2, 3, 4, 5, 6, 10, 12] # Example 2 input = [] output = [] # Example 3 input = [1] output = [1] ``` # Implementation Details: * **Binary Search Helper Function**: - Implement a helper function to determine the position to insert an element using binary search. * **Main Sort Function**: - Integrate the binary search helper and perform the insertion sort. - Ensure in-place sorting. ```python def optimized_insertion_sort(arr): def binary_search(arr, val, start, end): \'\'\'Helper function to determine the position using binary search\'\'\' while start < end: mid = (start + end) // 2 if arr[mid] < val: start = mid + 1 else: end = mid return start for i in range(1, len(arr)): val = arr[i] j = binary_search(arr, val, 0, i) # Shift elements to make space for the element arr = arr[:j] + [val] + arr[j:i] + arr[i+1:] return arr ```","solution":"def optimized_insertion_sort(arr): Sorts the array using an optimized insertion sort with binary search for insertion point. def binary_search(arr, val, start, end): Binary search helper function to find the insertion index for `val` between `start` and `end` indexes in `arr`. while start < end: mid = (start + end) // 2 if arr[mid] < val: start = mid + 1 else: end = mid return start for i in range(1, len(arr)): val = arr[i] j = binary_search(arr, val, 0, i) # Shift elements to make space for the element # Use slicing to maintain internal list structure arr = arr[:j] + [val] + arr[j:i] + arr[i+1:] return arr"},{"question":"# Question: Insertion Sort with Binary Search To assess your understanding of the insertion sort algorithm and binary search, your task is to implement the insertion sort algorithm with a twist. Use the `search_insert` helper method provided to find the correct position for each element to help reduce the number of comparisons. Function Signature ```python def binary_insertion_sort(arr: List[int]) -> List[int]: Sort an array of integers in ascending order using the insertion sort algorithm with the help of binary search to find the insertion index. Parameters: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list of integers. ``` Input - A list of integers `arr`, where the length n satisfies 0 <= n <= 10^3 and -10^3 <= arr[i] <= 10^3. Output - The input list `arr` sorted in non-decreasing order. Constraints - Do not use built-in sorting functions. - Your solution should leverage the `search_insert` function provided. - Aim for clear and efficient code. Example ```python # Example 1 binary_insertion_sort([4, 2, 5, 1, 3]) # Output: [1, 2, 3, 4, 5] # Example 2 binary_insertion_sort([10, 7, 8, 9, 1, 5]) # Output: [1, 5, 7, 8, 9, 10] # Example 3 binary_insertion_sort([]) # Output: [] ``` Explanation - In Example 1, starting with [4, 2, 5, 1, 3], the algorithm will use `search_insert` to determine the correct position for each element as it iterates, resulting in the sorted sequence [1, 2, 3, 4, 5]. - In Example 2, the array [10, 7, 8, 9, 1, 5] will be slowly built into the sorted array [1, 5, 7, 8, 9, 10]. - Example 3 illustrates handling of an empty list with output as an empty list.","solution":"from typing import List def search_insert(arr: List[int], value: int) -> int: left, right = 0, len(arr) while left < right: mid = (left + right) // 2 if arr[mid] < value: left = mid + 1 else: right = mid return left def binary_insertion_sort(arr: List[int]) -> List[int]: for i in range(1, len(arr)): key = arr[i] insertion_index = search_insert(arr[:i], key) arr = arr[:insertion_index] + [key] + arr[insertion_index:i] + arr[i+1:] return arr"},{"question":"# Question: Finding Primitive Roots for a Cryptographic Application Your task is to implement a function that finds the primitive roots of a given integer n. The function should use Euler\'s Totient function and the order finding methodology to determine all the primitive roots of n. This is a critical task in cryptographic algorithms like Diffie-Hellman key exchange. Function Signature ```python def find_all_primitive_roots(n: int) -> List[int]: Returns a list of all primitive roots of n ``` # Input * `n` (int): A positive integer greater than 1. # Output * A list of integers which are all the primitive roots of n. If `n` has no primitive roots, return an empty list. # Constraints 1. The input integer `n` will be such that `2 <= n <= 10^4`. # Example ```python print(find_all_primitive_roots(10)) # Output: [] print(find_all_primitive_roots(17)) # Output: [3, 5, 6, 7, 10, 11, 12, 14] ``` # Explanation * For `n = 10`, there are no primitive roots, hence an empty list. * For `n = 17`, the integer 17 has primitive roots {3, 5, 6, 7, 10, 11, 12, 14} which you should return. # Notes * You must use the Euler\'s Totient function and order finding function as part of your solution. * Consider the efficiency of your solution carefully given the potential size of `n`.","solution":"from typing import List import math def gcd(a, b): Helper function to return the greatest common divisor of a and b. while b: a, b = b, a % b return a def euler_totient(n): Euler\'s Totient function to calculate the number of integers up to n that are coprime with n. result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def is_primitive_root(g, p): Helper function to check if g is a primitive root of p. if gcd(g, p) != 1: return False order = euler_totient(p) for k in range(1, order): if pow(g, k, p) == 1: return False return True def find_all_primitive_roots(n: int) -> List[int]: Returns a list of all primitive roots of n. if n < 2: return [] if not (n & 1): # If n is even return [] roots = [g for g in range(2, n) if is_primitive_root(g, n)] return roots"},{"question":"# Question: Your task is to implement a `MovingSum` class that maintains the sum of the last `size` elements in a stream of integers. Unlike the original problem that calculates the moving average, your class will return the current sum of the sliding window. This problem will help you understand the core mechanics of maintaining sliding windows with constant-time updates. Requirements: - Implement a class `MovingSum` with the following methods: - `__init__(self, size: int)`: Initializes the data structure with a given window size. - `next(self, val: int) -> int`: Appends the integer `val` to the stream and returns the sum of the last `size` elements. Input and Output: - The `__init__` method takes an integer `size` which is the window size. - The `next` method takes an integer input `val` and returns an integer which is the sum of the last `size` elements in the window. Constraints: - The size of the sliding window (`size`) will be a positive integer. - The input values (`val`) will be integers. Example: ```python if __name__ == \'__main__\': m = MovingSum(3) assert m.next(1) == 1 # [1] -> window sum: 1 assert m.next(10) == 11 # [1, 10] -> window sum: 11 assert m.next(3) == 14 # [1, 10, 3] -> window sum: 14 assert m.next(5) == 18 # [10, 3, 5] -> window sum: 18 (oldest element 1 is evicted) ``` Additional Requirements: - Your solution should be optimized in terms of time complexity for the `next` method.","solution":"from collections import deque class MovingSum: def __init__(self, size: int): Initializes the moving sum data structure with a given window size. self.size = size self.window = deque(maxlen=size) self.current_sum = 0 def next(self, val: int) -> int: Appends the integer val to the stream and returns the sum of the last size elements. if len(self.window) == self.window.maxlen: self.current_sum -= self.window.popleft() self.window.append(val) self.current_sum += val return self.current_sum"},{"question":"**Scenario**: Consider a network of bus stations where the cost of traveling from one station to another is given by a cost matrix. You need to find the minimum cost to travel from the starting station (station 0) to the last station. The matrix is structured such that only upper triangle elements (where the row index is less than the column index) contain valid travel costs. All non-feasible moves are represented by `-1` or `INF` (Infinity), which implies you can only move forward. **Task**: Write a function named `min_cost` that takes a 2D list (cost matrix) as input and returns the minimum travel cost from station 0 to the last station. **Function Signature**: ```python def min_cost(cost: List[List[int]]) -> int: ``` **Input**: * `cost` (List[List[int]]): A 2D list where `cost[i][j]` represents the cost to travel from station `i` to station `j`. Feasible movements are only possible if `i < j`. **Output**: * `int`: The minimum cost to travel from the first station (station 0) to the last station. **Constraints**: * All non-feasible costs (i.e., where `i >= j`) are represented by `-1` or `INF`. * The size of the cost matrix (`n x n`) will be in the range [2, 100]. * The cost values will be non-negative integers. **Example**: ```python cost = [ [0, 15, 80, 90], [-1, 0, 40, 50], [-1, -1, 0, 70], [-1, -1, -1, 0] ] assert min_cost(cost) == 65 # The minimum cost to reach the last station is 65 ``` **Explanation**: * The minimum cost path from station 0 to station 3 is: 0 → 1 → 3 * The cumulative cost for this path is: cost[0][1] + cost[1][3] = 15 + 50 = 65 Consider edge cases like single station matrices or cases where no feasible path exists, ensuring your function handles them appropriately.","solution":"from typing import List def min_cost(cost: List[List[int]]) -> int: n = len(cost) if n == 0 or n == 1: return 0 # Initialize the minimum cost from the first station to all other stations min_costs = [float(\'inf\')] * n min_costs[0] = 0 for i in range(1, n): for j in range(i): if cost[j][i] != -1 and cost[j][i] != float(\'inf\'): min_costs[i] = min(min_costs[i], min_costs[j] + cost[j][i]) return min_costs[-1]"},{"question":"You are given a set of distinct integers. Your task is to write a Python function to generate all possible subsets of the set. **Function Signature**: ```python def generate_subsets(nums: List[int]) -> Set[frozenset]: ``` Input * `nums` (List[int]): A list of distinct integers (0 <= len(nums) <= 16). Output * Return a set of frozensets, where each frozenset represents a subset of the input list. Constraints * The solution must generate all possible subsets, including the empty subset. * The solution set must not contain duplicate subsets. * The order of elements within subsets is irrelevant. Performance Requirements * The function should be optimized to handle the constraints effectively. * Consideration should be given to both time and space complexity. Examples ```python assert generate_subsets([1, 2, 3]) == { frozenset(), frozenset({1}), frozenset({2}), frozenset({3}), frozenset({1, 2}), frozenset({1, 3}), frozenset({2, 3}), frozenset({1, 2, 3}) } assert generate_subsets([]) == {frozenset()} assert generate_subsets([1]) == {frozenset(), frozenset({1})} assert generate_subsets([1, 2]) == { frozenset(), frozenset({1}), frozenset({2}), frozenset({1, 2}) } ``` Scenario A researcher needs to analyze all possible combinations of experimental conditions. Given a list of distinct conditions, they need all possible subsets of conditions for their combinatorial analysis. Your function will assist in generating the required power set efficiently.","solution":"from typing import List, Set from itertools import chain, combinations def generate_subsets(nums: List[int]) -> Set[frozenset]: Generates all possible subsets of a given list of distinct integers. The subsets are represented as frozensets to ensure uniqueness and immutability. Args: nums (List[int]): A list of distinct integers. Returns: Set[frozenset]: A set of frozensets, each representing a subset of the input list. # Create all possible combinations of the elements all_subsets = chain.from_iterable(combinations(nums, r) for r in range(len(nums) + 1)) # Convert each combination to a frozenset and add to the set of subsets return {frozenset(subset) for subset in all_subsets}"},{"question":"# Counting Sort Implementation You are tasked with implementing the Counting Sort algorithm. Refactor the provided structure to conform to the following function specifications: Function Signature ```python def counting_sort(arr: List[int]) -> List[int]: Sorts an array of integers using the Counting Sort algorithm. If the array is empty, returns an empty array. Args: arr (List[int]): The input array of integers to be sorted. Returns: List[int]: The sorted array. ``` Inputs * `arr`: A list of integers. The integers could be negative or positive. Outputs * A new list of integers sorted in non-decreasing order. Constraints 1. The list can contain negative numbers. 2. The list can be empty or have a varying number of elements. 3. Time complexity should ideally remain O(n) considering the constraints. Scenario * Given an array of integers (both positive and negative), sort them using the Counting Sort algorithm. Examples 1. **Input**: `[4, -2, 2, 3, -3, 0, 2]` **Output**: `[-3, -2, 0, 2, 2, 3, 4]` 2. **Input**: `[-5, -10, 0, -3, 8, 5, -1, 10]` **Output**: `[-10, -5, -3, -1, 0, 5, 8, 10]` 3. **Input**: `[]` **Output**: `[]` Considerations 1. Handle the edge cases effectively, particularly if the array contains negative values, all values are the same, or if the array is empty. 2. Focus on minimizing unnecessary space complexity while maintaining stability and correctness of the sort. Make sure to write clean, efficient, and well-commented code. Include edge-case handling in your implementation to avoid common pitfalls.","solution":"from typing import List def counting_sort(arr: List[int]) -> List[int]: Sorts an array of integers using the Counting Sort algorithm. If the array is empty, returns an empty array. Args: arr (List[int]): The input array of integers to be sorted. Returns: List[int]: The sorted array. if not arr: return [] # Find the maximum and minimum values in the array max_val = max(arr) min_val = min(arr) # Range of numbers range_of_numbers = max_val - min_val + 1 # Initialize count array count = [0] * range_of_numbers # Store the count of each number for num in arr: count[num - min_val] += 1 # Store the cumulative count for i in range(1, len(count)): count[i] += count[i - 1] # Output array that will have sorted numbers output = [0] * len(arr) # Build the output array for num in reversed(arr): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"# Counting Sort with Extended Input Handling **Objective**: Implement a modified version of the Counting Sort that handles arrays containing a mix of negative and positive integers and sorts them in non-decreasing order. # Requirements: 1. **Function Name**: `extended_counting_sort` 2. **Inputs**: - `arr`: List of integers, which may contain both positive and negative values. 3. **Outputs**: - Returns a new list of integers sorted in non-decreasing order. # Constraints: - The function should have time complexity of O(n + k), where `n` is the length of the input array and `k` is the range of the numbers in the array. - The solution should efficiently handle arrays with a mix of positive and negative integers. - The function should maintain stability, meaning the relative order of elements with equal values should be preserved. # Examples: **Example 1**: ```python arr = [-5, -10, 0, -3, 8, 5, -1, 10] print(extended_counting_sort(arr)) ``` **Output**: ```python [-10, -5, -3, -1, 0, 5, 8, 10] ``` **Example 2**: ```python arr = [1, 4, 1, 2, 7, 5, 2] print(extended_counting_sort(arr)) ``` **Output**: ```python [1, 1, 2, 2, 4, 5, 7] ``` # Hint: - Consider adjusting all numbers to be non-negative by offsetting, then applying the Counting Sort, and adjusting them back.","solution":"def extended_counting_sort(arr): Sorts an array of integers, including negative values, in non-decreasing order using the Counting Sort algorithm. if not arr: return [] min_val = min(arr) max_val = max(arr) range_val = max_val - min_val + 1 count = [0] * range_val output = [0] * len(arr) for num in arr: count[num - min_val] += 1 for i in range(1, len(count)): count[i] += count[i - 1] for i in range(len(arr) - 1, -1, -1): num = arr[i] output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"# Question: Implement an Improved Search Algorithm Problem Statement Given an unsorted array of integers, implement a search function that not only finds the index of the first occurrence of the target element but also returns the count of how many times the target element appears in the array. Return a tuple with the index of the first occurrence and the count. If the element is not present, return `(-1, 0)`. Function Signature ```python def search_with_count(array: List[int], query: int) -> Tuple[int, int]: ``` Input * `array` : List of integers, where `1 <= len(array) <= 10^5`. * `query` : Integer, the target element to search for in the array. Output * Return a tuple `(int, int)` where: - The first element is the index of the first occurrence of `query` in `array`. If `query` does not exist, it should be `-1`. - The second element is the count of how many times `query` appears in `array`. Constraints * The array can contain negative and positive integers. * Optimize your solution for the given input constraints. Example ```python array = [2, 4, 2, 1, 9, 2, 3] query = 2 output = (0, 3) # 2 first appears at index 0 and occurs 3 times array = [1, 2, 3, 4, 5] query = 6 output = (-1, 0) # 6 is not present in the array ``` Note * Assume that the computation of the results should be efficient enough to handle the upper limits of the input constraints. * Consider edge cases such as empty arrays, single-element arrays, and arrays where all elements are the same.","solution":"from typing import List, Tuple def search_with_count(array: List[int], query: int) -> Tuple[int, int]: Function to search for the index of the first occurrence of the target element and count how many times the target element appears in the array. Parameters: array (List[int]): The list of integers to search within. query (int): The target element to find. Returns: Tuple[int, int]: A tuple containing the index of the first occurrence of the target element and the count of its occurrences in the array. first_index = -1 count = 0 for idx, value in enumerate(array): if value == query: if first_index == -1: first_index = idx count += 1 return (first_index, count)"},{"question":"# Postorder Binary Tree Traversal You have been provided with a binary tree structure and your task is to implement a function to perform postorder traversal of the binary tree. You must write both iterative and recursive functions to perform this traversal. # Task Write two functions `postorder_iterative(root)` and `postorder_recursive(root)` which will return the postorder traversal sequence of the binary tree. # Input - `root`: The root node of the binary tree. A node is defined using the class `Node`. The node contains an integer value and two children (left and right). # Output - A list of integers representing the postorder traversal of the binary tree. # Example Given the binary tree: ``` 1 / 2 3 / 4 5 ``` **postorder_iterative(root)** and **postorder_recursive(root)** should return `[4, 5, 2, 3, 1]`. # Constraints - The number of nodes in the tree can be up to (10^4). - Node values are integers and unique. # Performance Requirements - Time Complexity should be *O(n)* for both implementations, where *n* is the number of nodes. - Space Complexity should be efficient based on the respective approaches. # Class Definition Here is the class definition for Node that you will use: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` # Your Task Implement the following functions: ```python def postorder_iterative(root: Node) -> List[int]: pass def postorder_recursive(root: Node) -> List[int]: pass ```","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def postorder_iterative(root: Node) -> list: if not root: return [] stack, output = [root], [] while stack: node = stack.pop() output.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return output[::-1] def postorder_recursive(root: Node) -> list: def traverse(node): if not node: return traverse(node.left) traverse(node.right) result.append(node.val) result = [] traverse(root) return result"},{"question":"# Question: Determine Meeting Attendance Feasibility **Scenario**: You are managing a conference\'s schedule and need to validate if a single seminar room can accommodate all scheduled talks without any overlaps. Each talk is represented by a start and end time. **Function Specification**: Write a function `can_attend_meetings(intervals)` that takes a list of intervals where each interval is a list containing two integers representing the start and end time of a talk. ```python def can_attend_meetings(intervals): :type intervals: List[List[int]] :rtype: bool # Your code here ``` **Input**: - `intervals`: A list of `n` intervals, where `n` is the number of talks (0 ≤ n ≤ 10^4). - Each interval `[start, end]` is a list of two integers `0 ≤ start < end ≤ 10^6`. **Output**: - Return `True` if a person can attend all meetings without overlap, otherwise return `False`. **Constraints**: - All start times (`start`) and end times (`end`) will be unique positive integers. - You can assume that start < end for each meeting interval. **Example**: ```python # Example 1 intervals = [[0, 30], [5, 10], [15, 20]] print(can_attend_meetings(intervals)) # Output: False # Example 2 intervals = [[7, 10], [2, 4]] print(can_attend_meetings(intervals)) # Output: True ``` **Performance Requirements**: - Your implementation should run in O(n log n) time complexity to handle the upper limit of input size efficiently. **Edge Cases**: - An empty list of intervals should return `True` as there are no meetings to attend. - A list with one interval should return `True` as there are no overlapping meetings.","solution":"def can_attend_meetings(intervals): Determines if one can attend all meetings without overlap. :param intervals: List of intervals where each interval is a list of start and end times. :return: Boolean value indicating whether one can attend all meetings without overlap. intervals.sort(key=lambda x: x[0]) # Sort intervals by start time for i in range(1, len(intervals)): if intervals[i][0] < intervals[i-1][1]: # Check for overlap return False return True"},{"question":"**Context**: Suppose you are a software engineer developing a system that requires matrix operations to solve linear equations. Your task is to write a function that can efficiently compute the inverse of a given (n times n) matrix if it is invertible. # Problem Statement: You need to implement a function `invert_matrix(matrix)` that takes an (n times n) matrix as input and returns its inverse. If the matrix is non-square, singular, or too small to invert (0x0 or 1x1), the function should return appropriate error messages or values. # Input: - **matrix** (List of lists of integers/floats): A list of `n` lists, each containing `n` integers/floats representing an (n times n) matrix. # Output: - Returns the inverse matrix as a list of lists of floats if the matrix is invertible. - Returns specific error matrices for the following conditions: - If the matrix is not square, return `[[-2]]`. - If the matrix is too small to invert (less than `2x2`), return `[[-3]]`. - If the matrix is square but singular (determinant is zero), return `[[-4]]`. # Constraints: - You can assume valid integer or float values for the elements of the matrix. # Examples: ```text Example 1: Input: [[1, 2], [3, 4]] Output: [[-2.0, 1.0], [1.5, -0.5]] Example 2: Input: [[3, 0, 2], [2, 0, -2], [0, 1, 1]] Output: [[0.2, 0.2, 0.0], [-0.2, 0.3, 1.0], [0.2, -0.3, 0.0]] Example 3: Input: [[1, 2], [2, 4]] Output: [[-4]] Example 4: Input: [[1]] Output: [[-3]] ``` # Constraints: - The matrix elements can be integers or floats. - The function should handle large (n times n) matrices efficiently. # Notes: - You may use the helper functions (`get_determinant`, `get_matrix_of_minors`, `transpose_and_multiply`) provided. - Ensure to handle edge cases and errors effectively. **Function Signature**: ```python def invert_matrix(matrix: List[List[Union[int, float]]]) -> List[List[float]]: pass ```","solution":"from typing import List, Union def get_determinant(matrix: List[List[Union[int, float]]]) -> Union[float, int]: Helper function to calculate the determinant of a matrix. n = len(matrix) if n == 1: return matrix[0][0] if n == 2: return matrix[0][0]*matrix[1][1] - matrix[0][1]*matrix[1][0] total = 0 for current_column in range(n): sign = (-1) ** current_column sub_matrix = get_matrix_minor(matrix, 0, current_column) sub_det = get_determinant(sub_matrix) total += sign * matrix[0][current_column] * sub_det return total def get_matrix_minor(matrix: List[List[Union[int, float]]], i: int, j: int) -> List[List[Union[int, float]]]: Helper function to get the minor matrix after removing the i-th row and j-th column. return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def get_matrix_of_minors(matrix: List[List[Union[int, float]]]) -> List[List[Union[int, float]]]: Helper function to calculate the matrix of minors for a given matrix. n = len(matrix) return [[get_determinant(get_matrix_minor(matrix, i, j)) for j in range(n)] for i in range(n)] def transpose_matrix(matrix: List[List[Union[int, float]]]) -> List[List[Union[int, float]]]: Helper function to transpose a matrix. return list(map(list, zip(*matrix))) def invert_matrix(matrix: List[List[Union[int, float]]]) -> List[List[float]]: Returns the inverse of the input n x n matrix. n = len(matrix) if any(len(row) != n for row in matrix): return [[-2]] if n < 2: return [[-3]] det = get_determinant(matrix) if det == 0: return [[-4]] # Matrix of minors minors = get_matrix_of_minors(matrix) # Cofactor matrix cofactors = [[(-1) ** (i + j) * minors[i][j] for j in range(n)] for i in range(n)] # Adjugate matrix (transpose of the cofactor matrix) adjugate = transpose_matrix(cofactors) # Inverse matrix inverse = [[adjugate[i][j] / det for j in range(n)] for i in range(n)] return inverse"},{"question":"You are given a graph represented as an adjacency list where each node has a list of its neighbors. Implement a function `compose_traversal_route(graph, start, method)` which performs graph traversal starting from a specified node using the selected method (`\'dfs\'`, `\'bfs\'`) and returns the ordered list of nodes as they are visited. # Function Signature: ```python def compose_traversal_route(graph: Dict[int, List[int]], start: int, method: str) -> List[int]: pass ``` # Input: - `graph`: A dictionary representing the adjacency list of the graph. Keys are node identifiers (integers), and values are lists of neighboring node identifiers. - `start`: An integer representing the starting node for the traversal. - `method`: A string that specifies the traversal method, either `\'dfs\'` or `\'bfs\'`. # Output: - A list of integers representing the nodes in the order they were visited during traversal. # Constraints: - Each node in the graph is unique and represented by an integer. - The graph can have cycles. - The graph can be disconnected (nodes that cannot be reached from the start node). - `method` will always be either `\'dfs\'` or `\'bfs\'`. # Example: ```python graph = { 1: [2, 3], 2: [4, 5], 3: [], 4: [], 5: [] } start = 1 compose_traversal_route(graph, start, \'dfs\') # Expected Output: [1, 2, 4, 5, 3] compose_traversal_route(graph, start, \'bfs\') # Expected Output: [1, 2, 3, 4, 5] ``` # Notes: - You must use an iterative approach for implementing DFS and BFS. - Handle the case where the graph could be disconnected properly by ensuring visited nodes are not re-visited. - Choose suitable data structures to optimize the performance of your implementation.","solution":"from typing import List, Dict def compose_traversal_route(graph: Dict[int, List[int]], start: int, method: str) -> List[int]: if method == \'dfs\': return dfs_traversal(graph, start) elif method == \'bfs\': return bfs_traversal(graph, start) else: raise ValueError(\\"Method should be either \'dfs\' or \'bfs\'\\") def dfs_traversal(graph: Dict[int, List[int]], start: int) -> List[int]: visited = set() stack = [start] result = [] while stack: node = stack.pop() if node not in visited: visited.add(node) result.append(node) # Add neighbors to stack in reversed order to visit in the correct order for neighbor in reversed(graph.get(node, [])): if neighbor not in visited: stack.append(neighbor) return result def bfs_traversal(graph: Dict[int, List[int]], start: int) -> List[int]: visited = set() queue = [start] result = [] while queue: node = queue.pop(0) if node not in visited: visited.add(node) result.append(node) for neighbor in graph.get(node, []): if neighbor not in visited: queue.append(neighbor) return result"},{"question":"**Max Flow in a Flow Network** You are given a directed graph represented by a capacity matrix. Each cell in the matrix `capacity[i][j]` represents the capacity of the edge from node `i` to node `j`. If there is no edge between nodes `i` and `j`, `capacity[i][j]` is zero. Your task is to implement the max flow algorithms using the Ford-Fulkerson method with Depth-First Search (DFS) and Edmonds-Karp method with Breadth-First Search (BFS). # Function Signature Implement the following functions: ```python def ford_fulkerson(capacity: List[List[int]], source: int, sink: int) -> int: pass def edmonds_karp(capacity: List[List[int]], source: int, sink: int) -> int: pass ``` # Input * `capacity` (List[List[int]]): A 2D list where `capacity[i][j]` denotes the capacity of the edge from node `i` to node `j`. * `source` (int): The index of the source node. * `sink` (int): The index of the sink node. # Output * Returns an integer representing the maximum flow from the source to the sink. # Constraints * Each node will have at most 50 edges connected to it. * `capacity[i][j]` will be between 0 and 10^5 inclusive. * The number of vertices (V) in the graph can be up to 500. # Example ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 # Expected output: maximum flow is 23 print(ford_fulkerson(capacity, source, sink)) # should return 23 print(edmonds_karp(capacity, source, sink)) # should return 23 ``` # Notes * Ensure to handle edge cases, such as when there is no path from the source to the sink. * Perform performance testing for larger graphs within the provided constraints. * Compare the performance of both algorithms in your solution and describe the differences in efficiency.","solution":"from typing import List import collections def ford_fulkerson(capacity: List[List[int]], source: int, sink: int) -> int: def dfs_flow(u, flow): if u == sink: return flow visited.add(u) for v in range(len(capacity)): if v not in visited and residual_graph[u][v] > 0: min_capacity = min(flow, residual_graph[u][v]) result_flow = dfs_flow(v, min_capacity) if result_flow > 0: residual_graph[u][v] -= result_flow residual_graph[v][u] += result_flow return result_flow return 0 residual_graph = [row[:] for row in capacity] max_flow, flow = 0, 0 while True: visited = set() flow = dfs_flow(source, float(\'Inf\')) if flow == 0: break max_flow += flow return max_flow def edmonds_karp(capacity: List[List[int]], source: int, sink: int) -> int: def bfs(): parent = [-1] * len(capacity) visited = set() visited.add(source) queue = collections.deque([source]) while queue: u = queue.popleft() for v in range(len(capacity)): if v not in visited and residual_graph[u][v] > 0: parent[v] = u if v == sink: path_flow = float(\'Inf\') s = v while s != source: path_flow = min(path_flow, residual_graph[parent[s]][s]) s = parent[s] return (path_flow, parent) queue.append(v) visited.add(v) return (0, parent) residual_graph = [row[:] for row in capacity] max_flow = 0 while True: flow, parent = bfs() if flow == 0: break max_flow += flow v = sink while v != source: u = parent[v] residual_graph[u][v] -= flow residual_graph[v][u] += flow v = u return max_flow"},{"question":"# Question: Array Filtering with Range Limits As a data analyst, you frequently need to filter datasets for certain thresholds to perform meaningful analysis. Given this setup, you need to implement a function that filters an array of integers to include only those that fall within a given minimum and maximum limit. Function Specification **Function Name**: `filter_within_range` **Input**: - `arr` (List[int]): A list of integers to be filtered. - `min_lim` (int, optional): The minimum limit. If not provided, the filter considers no lower bound. - `max_lim` (int, optional): The maximum limit. If not provided, the filter considers no upper bound. **Output**: - A list of integers that lie within the specified `min_lim` and `max_lim` bounds. **Constraints**: - The array can have up to 10^5 elements. - Each element in the array can have a value between -10^9 and 10^9. - `min_lim` and `max_lim` can be `None`. **Performance Requirements**: The solution should run in O(n) time complexity. Example Usage ```python # Example 1 # Input: [1, 2, 3, 4, 5], min_lim=None, max_lim=3 # Output: [1, 2, 3] # Example 2 # Input: [10, 20, 30, 40, 50], min_lim=15, max_lim=45 # Output: [20, 30, 40] # Example 3 # Input: [1, 2, 3, 4, 5], min_lim=2, max_lim=None # Output: [2, 3, 4, 5] ``` **Notes**: - If `min_lim` is not provided (`None`), consider that there is no lower bound. - If `max_lim` is not provided (`None`), consider that there is no upper bound. - Ensure to handle the edge case of an empty input array by returning an empty array. Implement the `filter_within_range` function according to the above specification.","solution":"def filter_within_range(arr, min_lim=None, max_lim=None): Filters the input array to include only elements within the specified minimum and maximum limits. :param arr: List[int] - List of integers to filter. :param min_lim: Optional[int] - The minimum limit (inclusive). :param max_lim: Optional[int] - The maximum limit (inclusive). :return: List[int] - Filtered list of integers. if min_lim is None and max_lim is None: return arr if min_lim is None: return [x for x in arr if x <= max_lim] if max_lim is None: return [x for x in arr if x >= min_lim] return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"A robot is initially placed at position (0, 0) on an infinite 2D grid. The robot moves according to a sequence of moves represented by a string, where each character in the string stands for a move. The valid moves are \'R\' (Right), \'L\' (Left), \'U\' (Up), and \'D\' (Down). Write a function `judge_circle(moves: str) -> bool` that determines if the sequence of moves returns the robot to the original position (0, 0). Your function should handle the following: 1. The input string `moves` can have a length between 0 and 10,000, inclusive. 2. The string consists solely of characters from the set {\'R\', \'L\', \'U\', \'D\'}. # Example ```python assert judge_circle(\\"UD\\") == True assert judge_circle(\\"LL\\") == False assert judge_circle(\\"RRDDLLUU\\") == True assert judge_circle(\\"UDLR\\") == True assert judge_circle(\\"\\") == True ``` # Constraints - The function must have a time complexity of O(n), where n is the length of the input string. - The function must use O(1) additional space beyond the input storage. Implement the function `judge_circle` following the problem statement and constraints.","solution":"def judge_circle(moves: str) -> bool: Determines if the sequence of moves returns the robot to the original position (0, 0). Parameters: moves (str): The input string consisting of moves \'R\', \'L\', \'U\', and \'D\'. Returns: bool: True if the robot returns to the original position, False otherwise. x, y = 0, 0 for move in moves: if move == \'R\': x += 1 elif move == \'L\': x -= 1 elif move == \'U\': y += 1 elif move == \'D\': y -= 1 return x == 0 and y == 0"},{"question":"# Coding Problem: Implement a Memory-Efficient Trie A Trie, or prefix tree, is used to store a large set of strings, often in scenarios where we need to efficiently support operations such as word search and autocomplete. You are tasked with implementing a Trie with memory optimizations while supporting the existing methods `insert`, `search`, and `starts_with`. Objectives: 1. Implement the `Trie` class which supports: * `insert(word: str) -> None`: Adds the word to the Trie. * `search(word: str) -> bool`: Returns True if the word is in the Trie, and False otherwise. * `starts_with(prefix: str) -> bool`: Returns True if there is any word in the Trie that starts with the given prefix, otherwise False. 2. Optimize the Trie to use a list instead of a dictionary for storing child nodes. Assume the words only contain lowercase English letters (`a-z`). Input Format: * A series of method calls: 1. `insert(word)` - Inserts a word into the Trie. 2. `search(word)` - Searches a word in the Trie. 3. `starts_with(prefix)` - Searches for the given prefix in the Trie. Output Format: * For `search` and `starts_with` methods, return a boolean value indicating the result. Example: ```python trie = Trie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # returns True print(trie.search(\\"app\\")) # returns False print(trie.starts_with(\\"app\\")) # returns True trie.insert(\\"app\\") print(trie.search(\\"app\\")) # returns True ``` Constraints: * The input strings are non-empty and consist of lowercase English letters (`a-z`). Notes: * Ensure your implementation is efficient in terms of memory usage. * Consider edge cases where searching for a word that is a prefix of another word or inserting/retrieving the same word multiple times.","solution":"class TrieNode: def __init__(self): self.children = [None] * 26 # List of 26 elements representing each letter a to z. self.is_end_of_word = False # To mark the end of a word. class Trie: def __init__(self): self.root = TrieNode() def _char_to_index(self, ch: str) -> int: return ord(ch) - ord(\'a\') def insert(self, word: str) -> None: node = self.root for char in word: index = self._char_to_index(char) if not node.children[index]: node.children[index] = TrieNode() node = node.children[index] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: index = self._char_to_index(char) if not node.children[index]: return False node = node.children[index] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: index = self._char_to_index(char) if not node.children[index]: return False node = node.children[index] return True"},{"question":"# Problem Context You are in charge of maintaining a new employee directory for a rapidly growing tech company. The directory needs to handle frequent additions and lookups efficiently. Given rapid growth, the directory also needs to automatically resize to keep operations fast. # Task Implement a directory system using a resizable hash table. Your hash table should support the following functionalities: - `add_employee(id, name)`: Insert a new employee with the given ID and name. If the ID already exists, replace the name. - `find_employee(id)`: Return the name of the employee with the given ID, or `None` if the employee does not exist. - `remove_employee(id)`: Remove the employee with the given ID from the directory. # Input and Output - Input: Functions will be called with numerical IDs and string names. - Output: Return values as described. # Constraints - Use integer keys (IDs). - Employee names are strings containing alphanumeric characters. - The initial size of the hash table should be 11. - Automatically resize the table by doubling its size when load factor exceeds 2/3. # Function Signatures ```python class EmployeeDirectory: def __init__(self): pass def add_employee(self, id: int, name: str): pass def find_employee(self, id: int) -> str: pass def remove_employee(self, id: int): pass ``` # Example Usage ```python directory = EmployeeDirectory() directory.add_employee(123, \\"Alice\\") directory.add_employee(456, \\"Bob\\") print(directory.find_employee(123)) # Output: \\"Alice\\" directory.remove_employee(123) print(directory.find_employee(123)) # Output: None ``` Implement the `EmployeeDirectory` class by leveraging the principles of hash table and ensure it resizes as required. Consider performance, handling collisions, and edge cases in your solution.","solution":"class EmployeeDirectory: def __init__(self): self.initial_size = 11 self.load_factor = 2/3 self.size = self.initial_size self.count = 0 self.table = [None] * self.size def _hash(self, id): return id % self.size def _resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.count = 0 for item in old_table: if item is not None: for id, name in item: self._insert(id, name) def _insert(self, id, name): index = self._hash(id) if self.table[index] is None: self.table[index] = [(id, name)] else: for i, (existing_id, existing_name) in enumerate(self.table[index]): if existing_id == id: self.table[index][i] = (id, name) return self.table[index].append((id, name)) self.count += 1 if self.count / self.size > self.load_factor: self._resize() def add_employee(self, id, name): self._insert(id, name) def find_employee(self, id): index = self._hash(id) if self.table[index] is not None: for existing_id, existing_name in self.table[index]: if existing_id == id: return existing_name return None def remove_employee(self, id): index = self._hash(id) if self.table[index] is not None: for i, (existing_id, existing_name) in enumerate(self.table[index]): if existing_id == id: del self.table[index][i] self.count -= 1 if len(self.table[index]) == 0: self.table[index] = None return"},{"question":"# Bitonic Sort for Non-Power-of-2 Size Arrays Objective: You are required to implement a variant of the Bitonic Sort algorithm that can handle arrays of arbitrary sizes, not just powers of 2. Problem Statement: Given an array `arr` containing `n` integers, you need to sort the array in increasing order. The bitonic sorting algorithm given in the snippet assumes that the size of the array is a power of 2, but for this task, you need to adapt the algorithm to handle arrays of any size by padding the array with the necessary number of elements. Specifications: * Implement a function `bitonic_sort_general(arr)`, where: * The input, `arr`, is a list of integers. * The function returns a new list which is the sorted version of `arr`. Constraints: * The original size of `arr` is between 1 and 10^5. * The integer values in `arr` range from -10^9 to 10^9. Implementation Details: 1. If the size of `arr` is already a power of 2, sort it directly using the given bitonic_sort function. 2. If the size of `arr` is not a power of 2, pad `arr` with a sufficiently large sentinel value to the next power of two size. 3. After sorting the padded array, remove the sentinel values to get the sorted original input array. Edge Cases: 1. Arrays with size less than 2. 2. Arrays with all identical elements. 3. Large arrays close to the upper boundary of the size constraint. Example: ```python Input: arr = [5, 3, 1, 2, 6, 4, 7] Output: [1, 2, 3, 4, 5, 6, 7] Input: arr = [10] Output: [10] Input: arr = [] Output: [] ``` Function Signature: ```python def bitonic_sort_general(arr): # Your implementation here pass ```","solution":"import math def bitonic_sort_up(arr, start, length): if length > 1: k = length // 2 for i in range(start, start + k): if arr[i] > arr[i + k]: arr[i], arr[i + k] = arr[i + k], arr[i] bitonic_sort_up(arr, start, k) bitonic_sort_up(arr, start + k, k) def bitonic_sort_down(arr, start, length): if length > 1: k = length // 2 for i in range(start, start + k): if arr[i] < arr[i + k]: arr[i], arr[i + k] = arr[i + k], arr[i] bitonic_sort_down(arr, start, k) bitonic_sort_down(arr, start + k, k) def bitonic_merge(arr, start, length, up): if length > 1: k = length // 2 for i in range(start, start + k): if (arr[i] > arr[i + k]) == up: arr[i], arr[i + k] = arr[i + k], arr[i] bitonic_merge(arr, start, k, up) bitonic_merge(arr, start + k, k, up) def bitonic_sort(arr, start, length, up): if length > 1: k = length // 2 bitonic_sort(arr, start, k, True) bitonic_sort(arr, start + k, k, False) bitonic_merge(arr, start, length, up) def bitonic_sort_general(arr): Sort an array of integers using the bitonic sort algorithm, adapted to handle arrays of arbitrary sizes by padding with sentinel values where necessary. n = len(arr) if n < 2: return arr # Find the next power of 2 greater than or equal to n m = 1 while m < n: m <<= 1 # Pad the array with sentinel values sentinel_value = max(arr) + 1 padded_arr = arr + [sentinel_value] * (m - n) # Apply bitonic sort bitonic_sort(padded_arr, 0, m, True) # Remove the sentinel values sorted_arr = [x for x in padded_arr if x != sentinel_value] return sorted_arr"},{"question":"# Coding Task: Next Lexicographical Permutation --- Problem Statement Write a Python function `next_bigger_number(num: int) -> int` that takes a positive integer `num` and returns the next higher number formed with the same set of digits. If no bigger permutation is possible, return `-1`. For instance: - Given `38276`, the function should return `38627`. - Given `99999`, the function should return `-1`. Input * An integer `num`, where `1 <= num <= 10^6`. Output * Return an integer representing the next permutation of digits. Constraints * Input number will always be positive and within the specified range. * Optimize for time complexity and handle edge cases smartly. Example ```python assert next_bigger_number(38276) == 38627 assert next_bigger_number(99999) == -1 assert next_bigger_number(12345) == 12354 ``` Requirements Implement your solution in the following function signature: ```python def next_bigger_number(num: int) -> int: pass ``` Make sure to test your function with the provided test cases and think of additional edge cases. Note - The problem is inspired by permutation generation algorithms and requires knowledge of array manipulation and string conversion techniques. - Efficiently handle scenarios where the input number is already the maximum permutation of its digits.","solution":"def next_bigger_number(num: int) -> int: digits = list(str(num)) n = len(digits) # Step 1: Find the first digit that can be swapped to make the number bigger i = n - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If there\'s no such digit, the number is the largest permutation if i == -1: return -1 # Step 2: Find the smallest digit on the right side that is bigger than digits[i] j = n - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap them digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the digits to the right of index i digits = digits[:i + 1] + digits[i + 1:][::-1] return int(\'\'.join(digits))"},{"question":"# Problem: Enhanced Bucket Sort You are tasked with implementing an enhanced version of the bucket sort algorithm. The new implementation must handle both negative and positive numbers efficiently. Moreover, it should dynamically determine the number of buckets based on the range of input values to prevent inefficient distribution. Additionally, you have to ensure it remains optimal for various data distributions. Function Signature ```python def enhanced_bucket_sort(arr: List[int]) -> List[int]: ``` Input - `arr`: A list of integers which can be both negative and positive. The list can contain up to 10^5 elements. Output - Returns a list of integers sorted in non-decreasing order. Constraints 1. The elements in the array can range between -10^6 and 10^6. 2. You should handle large arrays efficiently. Example ```python assert enhanced_bucket_sort([0, -5, 3, -2, 8, 7]) == [-5, -2, 0, 3, 7, 8] assert enhanced_bucket_sort([20, -4, 3, 15, 0, 5, 10]) == [-4, 0, 3, 5, 10, 15, 20] assert enhanced_bucket_sort([]) == [] assert enhanced_bucket_sort([1]) == [1] ``` **Performance requirements**: Your solution should run in linear time (O(n + k)) where (n) is the number of elements and (k) is the number of buckets, under the assumption of near-uniform distributions. Detailed Instructions 1. Determine the range and the number of buckets dynamically from the input. 2. Allocate the buckets and distribute elements accordingly. 3. Use an efficient internal sorting algorithm within each bucket. 4. Concatenate the results from all buckets to form the final sorted list. 5. Ensure your algorithm handles edge cases properly, including arrays with all negative or all positive values, and arrays of mixed signs.","solution":"from typing import List def enhanced_bucket_sort(arr: List[int]) -> List[int]: if not arr: return arr # Find the minimum and maximum values in the list min_val = min(arr) max_val = max(arr) # Number of buckets to use bucket_count = len(arr) # Initialize buckets buckets = [[] for _ in range(bucket_count)] # Distribute the elements into the buckets range_val = max_val - min_val + 1 # Include both ends in the range for num in arr: # Determine the bucket index for the current element bucket_index = (num - min_val) * (bucket_count - 1) // range_val buckets[bucket_index].append(num) # Sort each bucket and concatenate the results sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorted(bucket)) return sorted_arr"},{"question":"**Context:** You have been given an API that returns an array of words and an array of symbols. Your task is to process these words such that for each word, you find the longest symbol that appears within that word and surrounds that symbol with square brackets. If a word contains multiple symbols, choose the one with the longest length. In case of a tie (symbols of the same length), choose any of them. If no symbol matches in the word, the word should remain unchanged. **Function:** Implement the function `replace_symbols(words, symbols)` that processes the words and symbols as specified. **Input:** - `words`: A list of strings where each string is a word. - `symbols`: A list of strings where each string is a symbol. **Output:** - Return a list of strings where each word has been processed to include the longest matching symbol surrounded with square brackets. **Constraints:** - Words and symbols can only contain alphabetic characters. - All words and symbols are non-empty. - The length of word and symbol lists will not exceed 1000. - The length of each word or symbol will not exceed 100. **Example:** ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] output = replace_symbols(words, symbols) print(output) # [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` **Performance Requirements:** - The solution should efficiently handle the input size within the given constraints. - Use appropriate data structures to ensure optimal performance.","solution":"def replace_symbols(words, symbols): def find_longest_symbol(word): longest_symbol = \\"\\" for symbol in symbols: if symbol in word and len(symbol) > len(longest_symbol): longest_symbol = symbol return longest_symbol processed_words = [] for word in words: longest_symbol = find_longest_symbol(word) if longest_symbol: word = word.replace(longest_symbol, f\\"[{longest_symbol}]\\") processed_words.append(word) return processed_words"},{"question":"# Fenwick Tree Implementation and Usage A Fenwick Tree (Binary Indexed Tree) is a data structure that efficiently computes prefix sums of an array and supports update operations in logarithmic time. Given an array of integers, the Fenwick Tree allows two main operations: 1. **Sum Query**: Compute the sum of the first `i` elements. 2. **Update**: Change the value of an element in the array. # Task Implement a class `FenwickTree` that supports the following methods: 1. **__init__(self, nums: List[int])**: Initializes the Fenwick Tree with the given list of integers `nums`. 2. **update(self, index: int, value: int)**: Updates the element at the given `index` to the specified `value`. 3. **prefix_sum(self, index: int) -> int**: Returns the sum of the elements from the start of the array up to the given `index`. # Input/Output * **Input**: * `__init__`: List of integers `nums` of size `n`. * `update`: An integer `index` and an integer `value`. * `prefix_sum`: An integer `index`. * **Output**: * `prefix_sum`: An integer representing the sum from the start of the array up to the given index. # Constraints * 1 <= n <= 10^5 * -10^4 <= nums[i] <= 10^4 * 0 <= index < n # Example ```python # Initialize ft = FenwickTree([1, 2, 3, 4, 5]) # Compute sum of the first 3 elements: 1 + 2 + 3 = 6 print(ft.prefix_sum(2)) # Output: 6 # Update the value at index 2 to 10 ft.update(2, 10) # Compute the sum of the first 3 elements again: 1 + 2 + 10 = 13 print(ft.prefix_sum(2)) # Output: 13 ``` # Implementation Notes * Ensure that your implementation handles large input sizes efficiently. * Consider edge cases like index out of bounds and initializing with an empty array. * Document your code to make the logic clear and maintainable.","solution":"from typing import List class FenwickTree: def __init__(self, nums: List[int]): Initialize the Fenwick Tree with the given list of integers. self.n = len(nums) self.tree = [0] * (self.n + 1) self.nums = nums[:] for i in range(self.n): self._add(i + 1, nums[i]) def update(self, index: int, value: int): Update the element at the given index to the specified value. current_val = self.nums[index] delta = value - current_val self.nums[index] = value self._add(index + 1, delta) def prefix_sum(self, index: int) -> int: Return the sum of the elements from the start of the array up to the given index. return self._sum(index + 1) def _add(self, index: int, value: int): while index <= self.n: self.tree[index] += value index += index & -index def _sum(self, index: int) -> int: result = 0 while index > 0: result += self.tree[index] index -= index & -index return result"},{"question":"# Sorting a Custom Data Structure Context: You are a software developer at a robotics company, tasked with developing a sorting module for an internal project. The robots generate sensor readings at regular intervals. Each reading is a custom data object containing two attributes: `timestamp` (integer) and `value` (float). The goal is to ensure that sensor readings are sorted in ascending order based on the `timestamp`. Task: Write a function `gnome_sort_sensor_readings` that sorts a list of sensor readings based on their timestamps using Gnome Sort. Function Signature: ```python def gnome_sort_sensor_readings(readings: List[Dict[str, Union[int, float]]]) -> List[Dict[str, Union[int, float]]]: ``` Input: * A list of dictionaries where each dictionary represents a sensor reading with keys: - `timestamp` (int): The timestamp of the reading. - `value` (float): The value of the sensor reading. Output: * A list of dictionaries sorted in ascending order by `timestamp`. Examples: ```python readings = [ {\\"timestamp\\": 3, \\"value\\": 10.5}, {\\"timestamp\\": 1, \\"value\\": 7.2}, {\\"timestamp\\": 2, \\"value\\": 8.1} ] result = gnome_sort_sensor_readings(readings) # Expected output: # [ # {\\"timestamp\\": 1, \\"value\\": 7.2}, # {\\"timestamp\\": 2, \\"value\\": 8.1}, # {\\"timestamp\\": 3, \\"value\\": 10.5} # ] ``` Constraints: 1. The list can be empty. 2. The list can contain one or more elements. 3. All `timestamp` values are unique.","solution":"from typing import List, Dict, Union def gnome_sort_sensor_readings(readings: List[Dict[str, Union[int, float]]]) -> List[Dict[str, Union[int, float]]]: Sorts a list of sensor readings based on the timestamp using Gnome Sort. pos = 0 while pos < len(readings): if pos == 0 or readings[pos][\\"timestamp\\"] >= readings[pos - 1][\\"timestamp\\"]: pos += 1 else: readings[pos], readings[pos - 1] = readings[pos - 1], readings[pos] pos -= 1 return readings"},{"question":"# Question: Secure Communication with Diffie-Hellman You are tasked with implementing an end-to-end Diffie-Hellman key exchange system, ensuring that Alice and Bob can securely establish a shared secret key over an unsecured network. Your implementation should involve the generation of private/public keys, the exchange process, and the ultimate shared key computation as described below: Requirements: 1. **Prime Number Check**: Verify that the selected prime number is indeed prime. Use the provided `prime_check(num)` function. 2. **Primitive Root Check**: Ensure that the chosen base is a valid primitive root of the prime. Implement this using `find_primitive_root(n)` to retrieve the list of primitive roots and validate the given base. 3. **Key Generation**: - Alice and Bob each generate a private key. - Compute corresponding public keys. 4. **Shared Key Calculation**: - Compute the shared secret key using each other\'s public keys. - Validate that both computed shared keys from Alice\'s and Bob\'s perspectives are identical. Implementation Details: - **Function Name**: `secure_diffie_hellman(a: int, p: int) -> bool` - **Input**: - `a` - an integer base (primitive root). - `p` - a large prime number. - **Output**: - Boolean indicating if the shared keys computed by Alice and Bob match. - **Constraints**: - ( 1 leq a < p ) - ( p ) is a prime number. - The function should print the generated keys and the shared key as demonstrated. Example Scenario: ```python def secure_diffie_hellman(a, p) -> bool: # Check if p is a prime number if not prime_check(p): print(f\\"{p} is not a prime number\\") return False # Check if a is a primitive root of p primitive_roots = find_primitive_root(p) if a not in primitive_roots: print(f\\"{a} is not a primitive root of {p}\\") return False # Alice\'s private and public key generation alice_priv = alice_private_key(p) alice_pub = alice_public_key(alice_priv, a, p) # Bob\'s private and public key generation bob_priv = bob_private_key(p) bob_pub = bob_public_key(bob_priv, a, p) print(f\\"Alice\'s Private Key: {alice_priv}\\") print(f\\"Alice\'s Public Key: {alice_pub}\\") print(f\\"Bob\'s Private Key: {bob_priv}\\") print(f\\"Bob\'s Public Key: {bob_pub}\\") # Shared key calculation alice_shared = alice_shared_key(bob_pub, alice_priv, p) bob_shared = bob_shared_key(alice_pub, bob_priv, p) print(f\\"Alice\'s Shared Key: {alice_shared}\\") print(f\\"Bob\'s Shared Key: {bob_shared}\\") return alice_shared == bob_shared ``` Students are expected to implement the `secure_diffie_hellman` function by leveraging the provided support functions and ensuring the secure exchange of keys that leads to a matching shared secret.","solution":"import random from sympy import isprime, primerange def prime_check(num): Verify if the given number is prime. return isprime(num) def find_primitive_root(p): Find all primitive roots of the given prime number p. required_set = {num for num in range(1, p) if gcd(num, p) } for g in range(1, p): actual_set = {pow(g, powers, p) for powers in range(1, p)} if required_set == actual_set: return g return None def gcd(a, b): while b: a, b = b, a % b return a def generate_private_key(p): Generate a private key. return random.randint(1, p-1) def generate_public_key(private_key, base, prime): Generate a public key. return pow(base, private_key, prime) def compute_shared_key(public_key, private_key, prime): Compute the shared secret key. return pow(public_key, private_key, prime) def secure_diffie_hellman(a, p): # Check if p is a prime number if not prime_check(p): print(f\\"{p} is not a prime number\\") return False # Check if a is a primitive root of p primitive_root = find_primitive_root(p) if a != primitive_root: print(f\\"{a} is not a primitive root of {p}\\") return False # Alice\'s private and public key generation alice_priv = generate_private_key(p) alice_pub = generate_public_key(alice_priv, a, p) # Bob\'s private and public key generation bob_priv = generate_private_key(p) bob_pub = generate_public_key(bob_priv, a, p) print(f\\"Alice\'s Private Key: {alice_priv}\\") print(f\\"Alice\'s Public Key: {alice_pub}\\") print(f\\"Bob\'s Private Key: {bob_priv}\\") print(f\\"Bob\'s Public Key: {bob_pub}\\") # Shared key calculation alice_shared = compute_shared_key(bob_pub, alice_priv, p) bob_shared = compute_shared_key(alice_pub, bob_priv, p) print(f\\"Alice\'s Shared Key: {alice_shared}\\") print(f\\"Bob\'s Shared Key: {bob_shared}\\") return alice_shared == bob_shared"},{"question":"**Question**: Design an algorithm to determine the maximum flow from a specified source to a sink in a given flow network. Implement the algorithm using the Ford-Fulkerson method. The function signature should be: ```python def ford_fulkerson(custom_capacity: List[List[int]], custom_source: int, custom_sink: int) -> int: ``` # Constraints: - `custom_capacity`: - A 2D list representing the capacities of the edges in the graph. - `custom_capacity[i][j]` indicates the capacity of the edge from vertex `i` to vertex `j`. - If there is no edge between `i` and `j`, `custom_capacity[i][j]` is `0`. - `custom_source`: An integer representing the source vertex. - `custom_sink`: An integer representing the sink vertex. # Input - `custom_capacity`: 2D list of integers ((1 leq V leq 1000, 0 leq E < 100000)) where (V) is the number of vertices and (E) is the number of edges. - `custom_source`: Integer ((0 leq custom_source < V)). - `custom_sink`: Integer ((0 leq custom_sink < V)). # Output - An integer representing the maximum flow from `custom_source` to `custom_sink`. # Example: ``` custom_capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] custom_source = 0 custom_sink = 5 Output: 23 ``` # Notes - The function should handle edge cases such as no augmenting path present. - Ensure the solution is efficient for the given constraints.","solution":"from collections import deque from typing import List def bfs(residual_capacity, source, sink, parent): visited = [False] * len(residual_capacity) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for ind, val in enumerate(residual_capacity[u]): if visited[ind] is False and val > 0: if ind == sink: parent[ind] = u return True queue.append(ind) visited[ind] = True parent[ind] = u return False def ford_fulkerson(custom_capacity: List[List[int]], custom_source: int, custom_sink: int) -> int: source = custom_source sink = custom_sink # This array is going to store the residual capacity of the graph updated # with each possible flow residual_capacity = [row[:] for row in custom_capacity] parent = [-1] * len(custom_capacity) # This array is filled by BFS to store path max_flow = 0 # There is no flow initially # Augment the flow while tere is path from source to sink while bfs(residual_capacity, source, sink, parent): # Find the maximum flow through the path found by BFS path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_capacity[parent[s]][s]) s = parent[s] # update residual capacities of the edges and reverse edges v = sink while v != source: u = parent[v] residual_capacity[u][v] -= path_flow residual_capacity[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Question: You have been tasked with improving a classic sorting algorithm called Comb Sort. Your goal is to enhance its performance and ensure it handles various edge cases effectively. Write a function `improved_comb_sort(arr)` that: 1. Enhances the traditional Comb Sort by adjusting the gap sequence or shrink factor dynamically. 2. Handles arrays of different lengths, including those with 0 or 1 element. 3. Optimizes for best-case scenarios, ensuring that nearly sorted arrays are processed quickly. 4. Returns the sorted array. Input: * A list of integers `arr` with length `n` (0 ≤ n ≤ 10^5). Output: * A list of integers sorted in ascending order. Constraints: * The array `arr` may contain both positive and negative integers. * Aim for the solution to be as efficient as possible in both time and space. Example: ```python assert improved_comb_sort([3, -1, 2, 10]) == [-1, 2, 3, 10] assert improved_comb_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert improved_comb_sort([5, 3, 4, 1, 2]) == [1, 2, 3, 4, 5] assert improved_comb_sort([]) == [] assert improved_comb_sort([42]) == [42] ```","solution":"def improved_comb_sort(arr): def get_next_gap(gap): gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) if n < 2: return arr gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Scenario You are a software engineer supporting a web analytics platform that tracks the daily number of visits to a website. The data for daily visits is stored in an array where each element represents the number of visits on that day. The platform needs to frequently query the total number of visits over specific periods as well as update the visit count as new data comes in. # Problem Statement Given an initial array of daily visits, you need to implement a system that can efficiently support two operations: 1. **Sum Query**: Calculate the total number of visits from the start of the array up to a given index. 2. **Update**: Update the visit count for a specific day. Implement a class `VisitTracker` with the following methods: ```python class VisitTracker: def __init__(self, visits: List[int]): # Initialize the tracker with the given visits array def query(self, index: int) -> int: # Return the total number of visits from the start up to the given index def update(self, index: int, value: int) -> None: # Update the visit count at a specific index to a new value ``` # Input Format - The constructor `__init__(self, visits: List[int])` initializes the object with the array `visits`. - `query(self, index: int) -> int`: Takes an integer `index` and returns the sum of visits from the start to `index`. - `update(self, index: int, value: int) -> None`: Takes an integer `index` and an integer `value`, updates the visit count at `index`. # Output Format - For `query`, return an integer representing the total visits up to the given index. - For `update`, no return value is required. # Constraints - `1 <= len(visits) <= 10^5` - `0 <= visits[i] <= 10^5` - `0 <= index < len(visits)` - Multiple `query` and `update` operations will be called and should each run efficiently in O(log n) time. # Example ```python # Example usage visits = [5, 3, 7, 3, 2, 1] tracker = VisitTracker(visits) # Query the sum of visits up to index 3 print(tracker.query(3)) # Output: 18 # Update visit count at index 2 to new value 10 tracker.update(2, 10) # Query again after update print(tracker.query(3)) # Output: 21 ``` # Notes - You should use Fenwick Tree (Binary Indexed Tree) for this implementation due to its efficiency. - Ensure proper handling of edge cases mentioned in the analysis above.","solution":"from typing import List class VisitTracker: def __init__(self, visits: List[int]): self.n = len(visits) self.visits = visits self.tree = [0] * (self.n + 1) for i in range(self.n): self._update_tree(i, visits[i]) def _update_tree(self, index: int, value: int): i = index + 1 while i <= self.n: self.tree[i] += value i += i & -i def _query_tree(self, index: int) -> int: sum_ = 0 i = index + 1 while i > 0: sum_ += self.tree[i] i -= i & -i return sum_ def query(self, index: int) -> int: return self._query_tree(index) def update(self, index: int, value: int) -> None: current_value = self.visits[index] delta = value - current_value self.visits[index] = value self._update_tree(index, delta)"},{"question":"You are implementing a secure communication channel using the Diffie-Hellman Key Exchange method. You must write a function that simulates the key exchange process and verifies if both parties derive the same shared secret key. Function Signature ```python def secure_key_exchange(prime: int, root: int, print_steps: bool = False) -> bool: Simulates the Diffie-Hellman key exchange and returns True if both Alice and Bob derive the same shared secret key; otherwise, False. :param prime: A large prime number `p` :param root: A primitive root of the prime number `p` :param print_steps: If True, print each step of the key exchange :return: Boolean indicating if the shared keys match (True) or not (False) ``` Input - An integer `prime` (a large prime number). - An integer `root` (a primitive root of `prime`). - A boolean `print_steps` (optional, default is False). Output - A boolean: `True` if both parties generate the same shared secret key, `False` otherwise. Constraints 1. The function must verify whether `prime` is truly prime. 2. The function must ensure `root` is a primitive root of `prime`. 3. The function should print the intermediate steps if `print_steps` is set to `True`. Requirements 1. Use the User-defined functions already given in the analysis (like prime_check, find_primitive_root, etc.) 2. Ensure reusability and maintainability of the code. Example ```python print(secure_key_exchange(23, 5, print_steps=True)) # Expected Outputs: # Alice\'s private key: [A random number in range 1-22] # Alice\'s public key: [Corresponding public key] # Bob\'s private key: [A random number in range 1-22] # Bob\'s public key: [Corresponding public key] # Shared key calculated by Alice: [Common secret key] # Shared key calculated by Bob: [Common secret key] # True (if shared keys match) ``` Write the function `secure_key_exchange` that adheres to the specifications and requirements mentioned above.","solution":"import random def is_prime(n): Check if n is a prime number if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5)+1, 2): if n % i == 0: return False return True def find_primitive_root(p): Find a primitive root for prime p if not is_prime(p): return None required_set = {num for num in range(1, p) if gcd(num, p) == 1} for g in range(1, p): actual_set = {pow(g, powers, p) for powers in range(1, p)} if required_set == actual_set: return g return None def gcd(a, b): Greatest common divisor while b != 0: a, b = b, a % b return a def secure_key_exchange(prime, root, print_steps=False): Simulates the Diffie-Hellman key exchange and returns True if both Alice and Bob derive the same shared secret key; otherwise, False. :param prime: A large prime number `p` :param root: A primitive root of the prime number `p` :param print_steps: If True, print each step of the key exchange :return: Boolean indicating if the shared keys match (True) or not (False) if not is_prime(prime): raise ValueError(\\"The provided prime is not a valid prime number.\\") if find_primitive_root(prime) != root: raise ValueError(\\"The provided root is not a valid primitive root of the prime.\\") alice_private_key = random.randint(1, prime-1) bob_private_key = random.randint(1, prime-1) alice_public_key = pow(root, alice_private_key, prime) bob_public_key = pow(root, bob_private_key, prime) alice_shared_secret = pow(bob_public_key, alice_private_key, prime) bob_shared_secret = pow(alice_public_key, bob_private_key, prime) if print_steps: print(f\\"Alice\'s private key: {alice_private_key}\\") print(f\\"Alice\'s public key: {alice_public_key}\\") print(f\\"Bob\'s private key: {bob_private_key}\\") print(f\\"Bob\'s public key: {bob_public_key}\\") print(f\\"Shared key calculated by Alice: {alice_shared_secret}\\") print(f\\"Shared key calculated by Bob: {bob_shared_secret}\\") return alice_shared_secret == bob_shared_secret"},{"question":"Context: You are given a square matrix and you need to compute its inverse using the matrix inversion algorithm. The inverse of a matrix (A) is another matrix (B) such that the product of (A) and (B) is the identity matrix. Task: Write a Python function `invert_matrix(matrix)` that takes a square matrix `matrix` and returns its inverse. If the matrix is singular (determinant = 0) or if the matrix is not invertible (not a square matrix), return `None`. Function Signature: ```python def invert_matrix(matrix: List[List[float]]) -> Optional[List[List[float]]]: ``` Input: - `matrix`: A list of lists of floats representing an (n times n) matrix. Output: - A list of lists of floats representing the inverse of the input matrix. - Return `None` if the matrix is singular or not invertible. Constraints: 1. The matrix will be of size (2 leq n leq 10). 2. Elements of the matrix are floats in the range ([-1000, 1000]). Examples: ```python matrix_1 = [ [4, 7], [2, 6] ] invert_matrix(matrix_1) # Output: [[0.6, -0.7], [-0.2, 0.4]] matrix_2 = [ [1, 2, 3], [0, 1, 4], [5, 6, 0] ] invert_matrix(matrix_2) # Output: [[-24, 18, 5], [20, -15, -4], [-5, 4, 1]] matrix_3 = [ [1, 2], [2, 4] ] invert_matrix(matrix_3) # Output: None (Singular matrix) ``` # Notes: - You may not use any external libraries such as `NumPy` for this exercise. - Consider edge cases such as non-square matrices and handle them appropriately. Performance Requirement: Given the constraints, aim to keep the solution efficient and within polynomial time complexity.","solution":"from typing import List, Optional def invert_matrix(matrix: List[List[float]]) -> Optional[List[List[float]]]: def get_matrix_minor(m, i, j): Calculate the minor of the matrix. return [row[:j] + row[j+1:] for row in (m[:i] + m[i+1:])] def get_matrix_determinant(m): Recursive function to calculate the determinant of a matrix. # Base case for 2x2 matrix if len(m) == 2: return m[0][0] * m[1][1] - m[0][1] * m[1][0] determinant = 0 for c in range(len(m)): determinant += ((-1) ** c) * m[0][c] * get_matrix_determinant(get_matrix_minor(m, 0, c)) return determinant def get_matrix_inverse(m): Function to calculate the inverse of a matrix. determinant = get_matrix_determinant(m) if determinant == 0: return None # Special case for 2x2 matrix: if len(m) == 2: return [ [m[1][1] / determinant, -1 * m[0][1] / determinant], [-1 * m[1][0] / determinant, m[0][0] / determinant] ] # Find matrix of cofactors cofactors = [] for r in range(len(m)): cofactor_row = [] for c in range(len(m)): minor = get_matrix_minor(m, r, c) cofactor_row.append(((-1) ** (r + c)) * get_matrix_determinant(minor)) cofactors.append(cofactor_row) # Transpose matrix of cofactors cofactors = list(map(list, zip(*cofactors))) # Divide each element by determinant for r in range(len(cofactors)): for c in range(len(cofactors)): cofactors[r][c] = cofactors[r][c] / determinant return cofactors return get_matrix_inverse(matrix) if len(matrix) == len(matrix[0]) else None"},{"question":"# Conversion of Large Integers with Endianness **Context**: You are working on a data serialization module that needs to manage large integer values for network transmission. Depending on the system, the integers need to be converted either into a big-endian or a little-endian format. Your task is to implement functions that convert positive integers to byte representations and vice versa in both endianness modes. **Task**: Your challenge is to re-implement the functions below more efficiently, focusing on performance and clarity: 1. `int_to_bytes_big_endian_optimized(num: int) -> bytes` 2. `int_to_bytes_little_endian_optimized(num: int) -> bytes` 3. `bytes_big_endian_to_int_optimized(bytestr: bytes) -> int` 4. `bytes_little_endian_to_int_optimized(bytestr: bytes) -> int` **Function Definitions**: 1. `int_to_bytes_big_endian_optimized(num: int) -> bytes`: Converts a positive integer to its big-endian byte representation. 2. `int_to_bytes_little_endian_optimized(num: int) -> bytes`: Converts a positive integer to its little-endian byte representation. 3. `bytes_big_endian_to_int_optimized(bytestr: bytes) -> int`: Converts a big-endian byte representation back to its corresponding integer. 4. `bytes_little_endian_to_int_optimized(bytestr: bytes) -> int`: Converts a little-endian byte representation back to its corresponding integer. **Input/Output Requirements**: - The integer inputs are guaranteed to be non-negative and within typical system limits for integers (up to 64-bit). - The byte array inputs are non-empty sequences representing valid byte orders. - Your implementations should handle large integers efficiently and avoid unnecessary performance overheads. **Constraints**: - **Time Complexity**: Aim for O(n) where n is the number of bytes. - **Space Complexity**: Aim for O(n) auxiliary space in addition to the input/output. - Avoid using external libraries other than standard Python. **Example**: ```python assert int_to_bytes_big_endian_optimized(305419896) == b\'x12x34x56x78\' assert int_to_bytes_little_endian_optimized(305419896) == b\'x78x56x34x12\' assert bytes_big_endian_to_int_optimized(b\'x12x34x56x78\') == 305419896 assert bytes_little_endian_to_int_optimized(b\'x78x56x34x12\') == 305419896 ``` Implement the above functions with a focus on performance and clarity. Ensure to test with a wide range of values, including edge cases like zero and very large integers.","solution":"def int_to_bytes_big_endian_optimized(num: int) -> bytes: if num == 0: return b\'x00\' byte_length = (num.bit_length() + 7) // 8 return num.to_bytes(byte_length, byteorder=\'big\') def int_to_bytes_little_endian_optimized(num: int) -> bytes: if num == 0: return b\'x00\' byte_length = (num.bit_length() + 7) // 8 return num.to_bytes(byte_length, byteorder=\'little\') def bytes_big_endian_to_int_optimized(bytestr: bytes) -> int: return int.from_bytes(bytestr, byteorder=\'big\') def bytes_little_endian_to_int_optimized(bytestr: bytes) -> int: return int.from_bytes(bytestr, byteorder=\'little\')"},{"question":"# Context You are tasked with developing a small part of a software system for a library. The library has an unsorted list of book IDs, and you need to implement a function to locate a specific book by its ID. # Task Implement a function `find_book_index` that performs a linear search to find the index of a specific book ID in the given list. If the book ID is not found, the function should return `-1`. # Function Signature ```python def find_book_index(book_ids: List[int], query_id: int) -> int: pass ``` # Input - `book_ids` (list of integers): A list of book IDs (unsorted). - `query_id` (integer): The ID of the book to search for. # Output - An integer representing the index of the book ID if found, otherwise `-1`. # Constraints - The number of book IDs can be up to 1,000,000. - Each book ID is a unique integer within the range [1, 10^6]. # Example ```python book_ids = [768, 345, 905, 123, 234] query_id = 905 assert find_book_index(book_ids, query_id) == 2 book_ids = [768, 345, 905, 123, 234] query_id = 800 assert find_book_index(book_ids, query_id) == -1 ``` # Performance Requirements The solution should efficiently handle the upper bound constraint of 1,000,000 book IDs.","solution":"from typing import List def find_book_index(book_ids: List[int], query_id: int) -> int: Perform a linear search to find the index of a specific book ID. If the book ID is not found, return -1. for index, book_id in enumerate(book_ids): if book_id == query_id: return index return -1"},{"question":"Given two strings `s` and `t`, write a function `are_isomorphic(s, t)` that determines if they are isomorphic. Two strings are isomorphic if the characters in `s` can be replaced to get `t` without changing the order of characters. No two characters may map to the same character, but a character may map to itself. # Function Signature ```python def are_isomorphic(s: str, t: str) -> bool: ``` # Input: * `s` and `t` are both strings consisting of lowercase letters (1 <= len(s), len(t) <= 10000). # Output: * Return `True` if `s` and `t` are isomorphic and `False` otherwise. # Constraints: * You must consider both the length of the strings and the character mapping constraints. * Ensure that your solution is efficient and runs in O(n) time complexity. # Examples: 1. Input: `s = \\"egg\\"`, `t = \\"add\\"` Output: `True` 2. Input: `s = \\"foo\\"`, `t = \\"bar\\"` Output: `False` 3. Input: `s = \\"paper\\"`, `t = \\"title\\"` Output: `True` # Scenario: Imagine you are working on a new text editor that highlights similar patterns in text. One of the features that needs to be implemented is to ensure that two given patterns are isomorphic. Your task is to create this feature by implementing the `are_isomorphic` function correctly. # Hints: - Use a dictionary to track character mappings from `s` to `t`. - Use a set to keep track of characters already mapped in `t`. - Iterate through the strings once to check for the one-to-one mapping. # Note: Your implementation should not just copy the sample code provided but demonstrate your own understanding of the problem and solution.","solution":"def are_isomorphic(s: str, t: str) -> bool: Determines if the strings s and t are isomorphic. Args: - s: A string consisting of lowercase letters. - t: A string consisting of lowercase letters. Returns: - A boolean indicating whether s and t are isomorphic. if len(s) != len(t): return False mapping_s_to_t = {} mapped_characters_in_t = set() for char_s, char_t in zip(s, t): if char_s in mapping_s_to_t: if mapping_s_to_t[char_s] != char_t: return False else: if char_t in mapped_characters_in_t: return False mapping_s_to_t[char_s] = char_t mapped_characters_in_t.add(char_t) return True"},{"question":"Question: Remove Duplicate Characters from a String # Objective You are given a string. Your task is to delete any reoccurring characters and return a new string composed only of the first occurrence of each character found in the original string. # Input and Output * **Input Format**: A single string `input_string` containing only printable ASCII characters. * **Output Format**: A single string with duplicate characters removed, maintaining the order of their first appearance in the input. # Constraints 1. The length of the input string `n` will be in the range [0, 10^6]. 2. Characters are case-sensitive (\'a\' and \'A\' are different). # Examples ```plaintext Example 1: Input: \\"programming\\" Output: \\"progamin\\" Example 2: Input: \\"industry\\" Output: \\"industry\\" Example 3: Input: \\"aabbcc\\" Output: \\"abc\\" Example 4: Input: \\"\\" Output: \\"\\" ``` # Performance Requirements * The function should execute in O(n) time complexity. * The function should use O(n) additional space. # Function Signature ```python def remove_duplicate_characters(input_string: str) -> str: # Your implementation here pass ``` # Additional Information Ensure your implementation handles edge cases and is efficient with regards to both time and space complexity. Use appropriate data structures to optimize performance.","solution":"def remove_duplicate_characters(input_string: str) -> str: This function removes duplicate characters from the input string and returns a new string with only the first occurrence of each character. seen = set() result = [] for char in input_string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"You work for a delivery company tasked with optimizing delivery routes. To help with this, you need to find potential paths between distribution nodes in a city. Given the complexity of city layouts, various internal network systems are represented as graphs. Write a function `optimized_delivery_path` that enhances the basic pathfinding algorithms provided to include optimizations and handle larger graphs effectively. The function should adhere to the following requirements: Requirements 1. **Function Signature**: `optimized_delivery_path(graph: Dict[str, List[str]], start: str, end: str) -> List[str]` 2. **Graph Representation**: The graph will be provided as a dictionary where keys are node identifiers (strings), and values are lists of adjacent nodes. 3. **Output**: The function should return the shortest path from `start` to `end`. 4. **Constraints**: - If no path is found, return an empty list. - Handle cyclic graphs efficiently to prevent infinite recursion. - The function should performance-optimized to handle graphs with up to 1000 nodes. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } print(optimized_delivery_path(graph, \'A\', \'F\')) # Expected Output: [\'A\', \'C\', \'F\'] ``` Hints - Consider employing breadth-first search (BFS) for shortest path discovery due to its efficiency in unweighted graphs. - Ensure to maintain visited nodes to prevent re-processing and infinite loops. Your solution should demonstrate both understanding of the core pathfinding algorithms and how to optimize them for practical large-scale scenarios.","solution":"from collections import deque from typing import Dict, List def optimized_delivery_path(graph: Dict[str, List[str]], start: str, end: str) -> List[str]: Returns the shortest path from start to end in the given graph using BFS. If no path is found, returns an empty list. :param graph: A dictionary representing the graph where keys are node identifiers and values are lists of adjacent nodes. :param start: The starting node. :param end: The destination node. :return: The shortest path from start to end as a list of nodes. if start == end: return [start] # Queue for BFS: stores tuples of (current_node, path_from_start_to_current) queue = deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() if current_node in visited: continue visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor == end: return path + [neighbor] else: queue.append((neighbor, path + [neighbor])) return [] # Example to test the function graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } print(optimized_delivery_path(graph, \'A\', \'F\')) # Expected Output: [\'A\', \'C\', \'F\']"},{"question":"# Coding Challenge: Enhanced Word Dictionary with Wildcards You are to implement an enhanced word dictionary that supports `add_word` and `search` methods. The dictionary should allow adding words and searching for words, where the search string can contain wildcard characters (\'.\') which can match any letter. To test the students\' understanding of both Trie data structure and efficient searching techniques, implement the `WordDictionary` class with the following requirements: Requirements: 1. **Method 1**: `add_word(word: str) -> None` - Adds `word` to the word dictionary. - **Constraints**: - `word` can consist of only lowercase English letters. - The word can have a maximum length of 100. 2. **Method 2**: `search(word: str) -> bool` - Returns `True` if there is any string in the word dictionary that matches `word` or `False` otherwise. - The search string `word` can contain \'.\' characters which can match any letter. - **Constraints**: - The search string can have a maximum length of 100. **Example**: ```python wd = WordDictionary() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") print(wd.search(\\"pad\\")) # False print(wd.search(\\"bad\\")) # True print(wd.search(\\".ad\\")) # True print(wd.search(\\"b..\\")) # True ``` Constraints & Performance: - Both methods should be optimized for performance. - Consider edge cases such as searching for strings with multiple wildcards or very long strings. - Handle potential performance bottlenecks efficiently. **Note**: Insert thorough comments in your code to explain the implementation steps.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: current_node = self.root for char in word: if char not in current_node.children: current_node.children[char] = TrieNode() current_node = current_node.children[char] current_node.is_word = True def search(self, word: str) -> bool: def dfs(node, index): if index == len(word): return node.is_word if word[index] == \'.\': for child in node.children.values(): if dfs(child, index + 1): return True return False else: char = word[index] if char not in node.children: return False return dfs(node.children[char], index + 1) return dfs(self.root, 0)"},{"question":"Selection Sort with Custom Comparator Scenario: You are given a dataset where elements contain unique information based on various metrics that could change dynamically. These datasets need to be sorted based on different comparator criteria provided at runtime. Your task is to implement a generic selection sort function that can handle custom comparison logic. Requirements: Write a function `custom_selection_sort(arr, cmp)` that sorts an array based on a custom comparator function `cmp`. The comparator function `cmp(a, b)` returns a negative number if `a` should come before `b`, zero if they are equal, and a positive number if `a` should come after `b`. Ensure that the function adheres to the following: Input: - `arr` (list): A list of elements to be sorted. Elements can be of any data type and should be comparable using the provided comparator function `cmp`. - `cmp` (function): A comparator function that defines the order of elements. Output: - Returns the sorted list according to the custom comparator `cmp`. Constraints: * Must handle arrays with each element comparable using `cmp`. * Should be implemented using the selection sort algorithm. * Sorting should be performed in-place, meaning the original array should be modified without using additional data structures. Performance Requirements: * Time Complexity: O(n^2) * Space Complexity: O(1) Function Signature: ```python def custom_selection_sort(arr: list, cmp: callable) -> list: pass ``` Example Usage: ```python def cmp(a, b): return a - b # Example comparator for ascending order arr = [64, 25, 12, 22, 11] print(custom_selection_sort(arr, cmp)) # Output: [11, 12, 22, 25, 64] def string_length_cmp(a, b): return len(a) - len(b) arr = [\\"apple\\", \\"banana\\", \\"kiwi\\", \\"strawberry\\"] print(custom_selection_sort(arr, string_length_cmp)) # Output: [\'kiwi\', \'apple\', \'banana\', \'strawberry\'] ``` Your task is to implement the `custom_selection_sort` function. Note: - Do not use any built-in sorting functions. - Ensure to handle the edge cases mentioned in the analysis section.","solution":"def custom_selection_sort(arr, cmp): Sorts an array using the selection sort algorithm with a custom comparator function. Parameters: arr (list): A list of elements to be sorted. cmp (function): A comparator function that returns a negative number if a should come before b, zero if they are equal, and a positive number if a should come after b. Returns: list: The sorted list according to the custom comparator. n = len(arr) for i in range(n): min_index = i for j in range(i + 1, n): if cmp(arr[j], arr[min_index]) < 0: min_index = j if min_index != i: arr[i], arr[min_index] = arr[min_index], arr[i] return arr"},{"question":"# Cocktail Shaker Sort Implementation Challenge Problem Statement You are tasked with implementing the Cocktail Shaker Sort algorithm. This is a bidirectional variant of the Bubble Sort that helps in efficiently sorting nearly sorted arrays. You need to understand the core principles, edge cases, and properties of this algorithm to correctly implement it. Write a Python function `cocktail_shaker_sort(arr)` that accepts an array of integers and returns it sorted. Input * A list `arr` of integers where (1 leq |arr| leq 10^5) and ( -10^9 leq arr[i] leq 10^9). Output * The function should return a new list with the elements sorted in ascending order. Constraints * The function should efficiently handle the sorting of large arrays. * Consider both nearly sorted and completely unsorted arrays. Example ```python >>> cocktail_shaker_sort([4, 3, 5, 2, 1]) [1, 2, 3, 4, 5] >>> cocktail_shaker_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> cocktail_shaker_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] ``` Notes * Ensure your implementation is robust and handles edge cases such as arrays with identical elements and empty arrays.","solution":"def cocktail_shaker_sort(arr): Sorts an array of integers using the Cocktail Shaker Sort algorithm. :param arr: List[int] - List of integers to sort :return: List[int] - Sorted list of integers if not arr: # If the array is empty, return it as it is. return arr n = len(arr) swapped = True start = 0 end = n - 1 while swapped: swapped = False # Traverse the array from left to right, like bubble sort. for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If no elements were swapped, then the array is sorted. if not swapped: break # Otherwise, reset the swapped flag to proceed with the second pass. swapped = False end -= 1 # Traverse the array from right to left. for i in range(end - 1, start - 1, -1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True start += 1 return arr"},{"question":"# Context Ternary search is a powerful search algorithm that’s similar to binary search but it divides the array into three parts instead of two. This can reduce the number of comparisons in theory, leading to faster searches. # Problem Statement You are given a sorted array of distinct integers and a target value. Implement a function to find the index of the target value using ternary search. If the target value is not present in the array, return -1. # Function Signature ```python def ternary_search(arr: List[int], key: int) -> int: ``` # Input * `arr`—a list of sorted distinct integers (0 <= len(arr) <= 10^5) * `key`—an integer representing the value to search for (-10^9 <= key <= 10^9) # Output * Return the index of `key` in `arr` if it’s present, otherwise return -1. # Constraints 1. The array `arr` is sorted in ascending order. 2. All elements in the array are distinct. 3. Expected time complexity is O(log3(N)) and space complexity is O(1). # Example ```python # Example 1 arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] key = 5 # Expected Output: 4 # Example 2 arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] key = 11 # Expected Output: -1 ``` # Notes * Ensure to handle edge cases such as an empty array or the key not being present in the array. * You need to find the index of the element efficiently to meet the given constraints.","solution":"from typing import List def ternary_search(arr: List[int], key: int) -> int: Implements ternary search to find the key in the sorted array. Returns the index of the key if found, otherwise returns -1. def search(l, r): if r < l: return -1 third_part = (r - l) // 3 mid1 = l + third_part mid2 = r - third_part if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: return search(l, mid1 - 1) elif key > arr[mid2]: return search(mid2 + 1, r) else: return search(mid1 + 1, mid2 - 1) return search(0, len(arr) - 1)"},{"question":"**Binary Heap Scenario** A software system utilizes a task scheduler where each task has a priority, and tasks are executed based on the lowest priority number. To manage the priority of tasks, it uses a min heap. # Problem Statement Implement a `BinaryHeap` class with the following functionalities: 1. **Insert a task**: Takes the priority number of the task as input. 2. **Remove the task with the lowest priority**: Removes and returns the task with the lowest priority. 3. **Peek the task with the lowest priority**: Returns the task with the lowest priority without removing it. # Class Definition Implement the `BinaryHeap` class based on the following skeleton. ```python class BinaryHeap: def __init__(self): # Initialization logic here def perc_up(self, i): # Percolate up to restore heap properties def insert(self, val): # Insert element into the heap and restore heap properties def min_child(self, i): # Return index of the smaller child def perc_down(self, i): # Percolate down to restore heap properties def remove_min(self): # Remove the minimum element from the heap and restore heap properties def peek_min(self): # Peek at the smallest element without removing it ``` # Input/Output definitions - **Insert Operation** - Input: Integer representing the priority of the task. - Output: No output. - **Remove Minimum Operation** - Input: No input. - Output: Integer representing the lowest priority task. - **Peek Minimum Operation** - Input: No input. - Output: Integer representing the task with the lowest priority. # Constraints - All operations should have a time complexity of **O(log N)** except for the peek operation which should be **O(1)**. - Implement the underlying heap as an array. # Example ```python heap = BinaryHeap() heap.insert(4) heap.insert(50) heap.insert(7) heap.insert(55) heap.insert(90) heap.insert(87) print(heap.remove_min()) # Should print 4 heap.insert(2) print(heap.peek_min()) # Should print 2 print(heap.remove_min()) # Should print 2 print(heap.peek_min()) # Should print 7 ``` Implement the required methods to support the above operations on the min heap.","solution":"class BinaryHeap: def __init__(self): self.heap_list = [0] self.current_size = 0 def perc_up(self, i): while i // 2 > 0: if self.heap_list[i] < self.heap_list[i // 2]: self.heap_list[i], self.heap_list[i // 2] = self.heap_list[i // 2], self.heap_list[i] i = i // 2 def insert(self, val): self.heap_list.append(val) self.current_size += 1 self.perc_up(self.current_size) def min_child(self, i): if i * 2 + 1 > self.current_size: return i * 2 else: if self.heap_list[i*2] < self.heap_list[i*2+1]: return i * 2 else: return i * 2 + 1 def perc_down(self, i): while (i * 2) <= self.current_size: mc = self.min_child(i) if self.heap_list[i] > self.heap_list[mc]: self.heap_list[i], self.heap_list[mc] = self.heap_list[mc], self.heap_list[i] i = mc def remove_min(self): if self.current_size == 0: return None root = self.heap_list[1] self.heap_list[1] = self.heap_list[self.current_size] self.current_size -= 1 self.heap_list.pop() self.perc_down(1) return root def peek_min(self): if self.current_size == 0: return None return self.heap_list[1]"},{"question":"# Path Finding in Directed Graphs Objective Implement a function to find the shortest path between two nodes in a weighted, directed graph using Dijkstra\'s algorithm. Description In the provided weighted, directed graph, you need to find the shortest path from a starting node (`start`) to a destination node (`end`). Each edge in the graph has a positive weight. Function Signature ```python def dijkstra_shortest_path(graph: Dict[str, Dict[str, int]], start: str, end: str) -> List[str]: pass ``` Input - `graph`: A dictionary where keys are node names and values are dictionaries with neighboring nodes as keys and edge weights as values. - Example: `graph = {\\"A\\": {\\"B\\": 1, \\"C\\": 4}, \\"B\\": {\\"C\\": 2, \\"D\\": 5}, \\"C\\": {\\"D\\": 1}, \\"D\\": {}}` - `start`: A string representing the starting node. - `end`: A string representing the destination node. Output - A list of node names representing the shortest path from the `start` node to the `end` node (inclusive). Constraints - If no path exists from `start` to `end`, return an empty list. - Ensure all nodes and edges have positive weights. Example ```python graph = { \\"A\\": {\\"B\\": 1, \\"C\\": 4}, \\"B\\": {\\"C\\": 2, \\"D\\": 5}, \\"C\\": {\\"D\\": 1}, \\"D\\": {} } start = \\"A\\" end = \\"D\\" dijkstra_shortest_path(graph, start, end) # Output: [\\"A\\", \\"B\\", \\"C\\", \\"D\\"] ``` Additional Notes - Consider edge cases such as: - The graph is empty. - The start or end node does not exist in the graph. - The start node is the same as the end node. # Performance Requirements - Aim for a time complexity of O((V + E) log V) using a priority queue.","solution":"import heapq from typing import Dict, List, Tuple def dijkstra_shortest_path(graph: Dict[str, Dict[str, int]], start: str, end: str) -> List[str]: # Priority queue to hold (distance, node, path) priority_queue = [(0, start, [start])] # Dictionary to keep the shortest distances to nodes shortest_distances = {start: 0} # Set to track visited nodes visited = set() while priority_queue: (current_distance, current_node, path) = heapq.heappop(priority_queue) if current_node in visited: continue visited.add(current_node) # If we have reached the end node, return the path if current_node == end: return path # Explore neighbors for neighbor, weight in graph.get(current_node, {}).items(): distance = current_distance + weight if distance < shortest_distances.get(neighbor, float(\'inf\')): shortest_distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor, path + [neighbor])) # If we reach here, no path exists return []"},{"question":"# Problem: Digit Counter You are tasked with writing a function `count_digits` that calculates the number of digits of a given integer. Your function should take into account both positive and negative numbers as well as zero. Function Signature ```python def count_digits(n: int) -> int: ``` Input * An integer `n` where `-10^9 <= n <= 10^9`. Output * An integer representing the number of digits in the input number. Example ```python assert count_digits(12345) == 5 assert count_digits(-987654321) == 9 assert count_digits(0) == 1 assert count_digits(1000000000) == 10 assert count_digits(-1000) == 4 ``` Constraints * Your function should run in constant time, (O(1)). * You may not use any string manipulations or loop structures to solve the problem. * Consider edge cases such as 0 and negative numbers.","solution":"def count_digits(n: int) -> int: Returns the number of digits in the given integer, taking into account both positive and negative numbers as well as zero. if n == 0: return 1 if n < 0: n = -n return len(str(n))"},{"question":"<|Analysis Begin|> **Algorithm/Data Structure**: * **Name**: Cholesky Decomposition * **Type**: Matrix Decomposition * **Purpose**: The Cholesky decomposition is used to decompose a Hermitian positive-definite matrix into a product of a lower triangular matrix and its conjugate transpose. **Complexity**: * **Time Complexity**: O(n^3), specifically about (n^3)/3, where n is the order of the matrix. * **Space Complexity**: O(n^2), since we need to store the lower triangular matrix of the same order. **Principles**: * The algorithm iterates through columns, computing each element of the matrix V. * It assures that the matrix A must be Hermitian positive-definite, and verifies that the matrix dimensions match. * Operations involve summing squares for diagonal elements and computing the lower triangular elements accordingly. **Properties**: * The decomposed matrix V is lower triangular. * Hermitian positive-definite matrices are required for the decomposition to work correctly. **Common Use Cases**: * Numerical solution of linear equations Ax = b. * Computations in simulations and optimizations where positive-definiteness is guaranteed, like in finance (covariance matrices) or physics (stiffness matrices in finite element analysis). **Strengths/Limitations**: * **Strengths**: * Efficient and numerically stable for Hermitian positive-definite matrices. * Reduces the problem to solving triangular systems. * **Limitations**: * Not applicable to matrices that are not Hermitian or not positive-definite. * If the matrix is not correctly represented or has rounding issues, the algorithm may fail. **Implementation Challenges**: * **Edge Cases**: Non-matching matrix dimensions, non-positive-definite matrices, round-off errors. * **Performance Bottlenecks**: Operations involving multiple nested loops can slow down execution for large matrices. * **Error Scenarios**: Incorrect identification of positive-definiteness leading to erroneous results. * **Optimization Points**: Better memory management, parallelism for large matrices, and precision handling. <|Analysis End|> <|Question Begin|> Cholesky Decomposition Application You are given a Hermitian positive-definite matrix A. Your task is to implement the Cholesky decomposition for this matrix to find the lower triangular matrix V such that ( V times V^T = A ). # Function Specification **Function Name**: cholesky_decomposition **Input**: - A: A list of lists of floats representing a Hermitian positive-definite matrix. **Output**: - A list of lists of floats representing the lower triangular matrix. - If the input matrix is not Hermitian positive-definite or dimensions do not match, return `None`. # Constraints - The matrix dimensions must be positive and match ( n times n ). - Handle floating-point numbers with precision. # Example ```python # Example 1: Input: A = [[4, 12, -16], [12, 37, -43], [-16, -43, 98]] Output: [[2.0, 0.0, 0.0], [6.0, 1.0, 0.0], [-8.0, 5.0, 3.0]] # Example 2: Input: A = [[25, 15, -5], [15, 18, 0], [-5, 0, 11]] Output: [[5.0, 0.0, 0.0], [3.0, 3.0, 0.0], [-1.0, 1.0, 3.0]] # Edge case: Input: A = [[1, 2], [3, 4]] Output: None # A is not Hermitian positive-definite ``` # Notes - You are expected to handle errors gracefully. - Focus on maintaining floating-point precision for accurate results. - Ensure clear understanding of matrix properties and dimensions. Implement the function based on the format above and verify your results with the provided examples.","solution":"def cholesky_decomposition(A): Performs Cholesky decomposition on a Hermitian positive-definite matrix A. Returns the lower triangular matrix L such that L * L.T = A. If the matrix is not Hermitian positive-definite or dimensions do not match, return None. import math n = len(A) # Check if A is a square matrix for row in A: if len(row) != n: return None # Initialize the lower triangular matrix with zeros L = [[0.0] * n for _ in range(n)] try: for i in range(n): for j in range(i+1): sum_ = sum(L[i][k] * L[j][k] for k in range(j)) if i == j: # Diagonal elements L[i][j] = math.sqrt(A[i][i] - sum_) else: L[i][j] = (A[i][j] - sum_) / L[j][j] return L except ValueError: # If the matrix is not positive-definite, \'math.sqrt\' will raise a ValueError return None"},{"question":"# MovingAverage Evaluation In this task, you will implement an enhanced version of the MovingAverage class. The enhancements will allow the class to not only calculate the moving average but also keep track of the minimum, maximum, and median values within the sliding window. # Objective 1. Implement a `MovingStats` class that will: - Calculate the moving average of the last `n` elements. - Maintain and be able to return the minimum value within the window. - Maintain and be able to return the maximum value within the window. - Maintain and be able to return the median value within the window. 2. You will implement the following methods: - `__init__(self, size)`: Initializes the data structure with a fixed window size. - `next(self, val)`: Processes the next integer in the stream and returns a dictionary with the current `average`, `min`, `max`, and `median` values within the window. # Input and Output - **Input**: - `__init__(self, size)`: `size` (int). - `next(self, val)`: `val` (int). - **Output**: - `next(self, val)`: Dictionary with keys `average`, `min`, `max`, and `median`, where: - `average` (float) is the moving average, - `min` (int) is the minimum value within the window, - `max` (int) is the maximum value within the window, - `median` (float) is the median value within the window. # Constraints - The window size `n` will be a positive integer. - The stream of integers can include both positive and negative numbers. - For the median calculation, if there is an even number of elements, return the average of the two middle elements. # Scenario Imagine you are implementing this in a real-time system processing stock prices. The `MovingStats` class continuously receives new stock prices and calculates the average, minimum, maximum, and median price over the last `n` minutes of data. # Example ```python from moving_stats import MovingStats if __name__ == \'__main__\': stats = MovingStats(3) print(stats.next(1)) # Output: {\'average\': 1.0, \'min\': 1, \'max\': 1, \'median\': 1.0} print(stats.next(10)) # Output: {\'average\': 5.5, \'min\': 1, \'max\': 10, \'median\': 5.5} print(stats.next(3)) # Output: {\'average\': 4.67, \'min\': 1, \'max\': 10, \'median\': 3.0} print(stats.next(5)) # Output: {\'average\': 6.0, \'min\': 3, \'max\': 10, \'median\': 5.0} ``` # Performance Requirements The `next` method should run in `O(log n)` time complexity for insertion and median calculation, where `n` is the size of the window.","solution":"from collections import deque import bisect class MovingStats: def __init__(self, size: int): self.size = size self.window = deque() self.sorted_window = [] def next(self, val: int) -> dict: if len(self.window) == self.size: oldest_val = self.window.popleft() self.sorted_window.remove(oldest_val) self.window.append(val) bisect.insort_left(self.sorted_window, val) average = sum(self.window) / len(self.window) min_val = self.sorted_window[0] max_val = self.sorted_window[-1] n = len(self.sorted_window) if n % 2 == 1: median_val = self.sorted_window[n // 2] else: median_val = (self.sorted_window[n // 2 - 1] + self.sorted_window[n // 2]) / 2 return { \'average\': average, \'min\': min_val, \'max\': max_val, \'median\': median_val }"},{"question":"You are given two words, `word1` and `word2`. Your task is to write a function `find_min_deletions(word1, word2)` that computes the minimum number of steps required to make `word1` and `word2` the same by deleting characters from either string. # Function Signature: ```python def find_min_deletions(word1: str, word2: str) -> int: pass ``` # Input: - `word1`: A string representing the first word (1 ≤ len(word1) ≤ 1000). - `word2`: A string representing the second word (1 ≤ len(word2) ≤ 1000). # Output: - An integer representing the minimum number of deletions needed to make both words the same. # Constraints: - Both `word1` and `word2` consist of lowercase English letters only. # Example: ```python find_min_deletions(\\"sea\\", \\"eat\\") ``` - Output: 2 - Explanation: You need one step to make \\"sea\\" to \\"ea\\" and another step to make \\"eat\\" to \\"ea\\". # Requirements: Implement the function using a dynamic programming approach to achieve O(n*m) time complexity. Optimize space usage where possible without compromising readability. # Scenario: Consider the task of writing a diff tool that identifies the smallest number of edits (deletions in this case) required to convert one document to another, ensuring the two become identical. This can be critical in applications involving version control or collaborative documents. # Instructions: - Implement a dynamic programming solution to solve the problem. - Ensure the function handles edge cases such as empty strings efficiently. - Optimize space complexity where possible.","solution":"def find_min_deletions(word1: str, word2: str) -> int: Finds the minimum number of deletions required to make two words the same. len1, len2 = len(word1), len(word2) # Create a 2D DP array with size (len1+1) x (len2+1) dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] for i in range(1, len1 + 1): for j in range(1, len2 + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Length of longest common subsequence lcs_length = dp[len1][len2] # Minimum deletions needed min_deletions = (len1 - lcs_length) + (len2 - lcs_length) return min_deletions"},{"question":"# Question Problem Statement You are given two arrays representing the preorder and postorder traversals of a full binary tree. Your task is to construct the binary tree from these given traversals and return its inorder traversal. Input Format * `preorder` – A list of integers, representing the preorder traversal of a full binary tree. * `postorder` – A list of integers, representing the postorder traversal of the same full binary tree. Output Format * Return a list of integers representing the inorder traversal of the constructed binary tree. Constraints * Both `preorder` and `postorder` arrays will have the same length. * The length of arrays will not exceed 1000. * Elements in both arrays will be unique. Example ``` Input: preorder = [1, 2, 4, 8, 9, 5, 3, 6, 7] postorder = [8, 9, 4, 5, 2, 6, 7, 3, 1] Output: [8, 4, 9, 2, 5, 1, 6, 3, 7] ``` Your task is to implement the function `construct_and_inorder(preorder: list[int], postorder: list[int]) -> list[int]:` which will take the preorder and postorder traversals as input and return the inorder traversal of the constructed binary tree. Constraints * Your solution should not exceed time complexity of O(n^2). * Handling invalid inputs gracefully is a plus.","solution":"from typing import List class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def construct_and_inorder(preorder: List[int], postorder: List[int]) -> List[int]: if not preorder or not postorder: return [] post_index_map = {val: idx for idx, val in enumerate(postorder)} def build_tree(pre_left, pre_right, post_left, post_right): if pre_left > pre_right or post_left > post_right: return None root_val = preorder[pre_left] root = TreeNode(root_val) if pre_left == pre_right: return root left_subtree_root_val = preorder[pre_left + 1] left_subtree_root_index_in_post = post_index_map[left_subtree_root_val] left_size = left_subtree_root_index_in_post - post_left + 1 root.left = build_tree(pre_left + 1, pre_left + left_size, post_left, left_subtree_root_index_in_post) root.right = build_tree(pre_left + left_size + 1, pre_right, left_subtree_root_index_in_post + 1, post_right - 1) return root def inorder_traversal(root): return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) if root else [] tree_root = build_tree(0, len(preorder) - 1, 0, len(postorder) - 1) return inorder_traversal(tree_root)"},{"question":"You need to implement a function that generates all prime numbers less than a given integer `n` using a modified version of the Sieve of Eratosthenes. This version excludes even numbers from being checked and from the list itself (except for the prime number `2`), hence optimizing the space and reducing the sieving complexity. Function Signature ```python def get_primes(n: int) -> List[int]: ``` Input * An integer `n` (1 ≤ n ≤ 10^7) Output * A list of integers representing all prime numbers less than `n`. Constraints * The input `n` will be a positive integer. * The function should execute with a time complexity of O(n log log n) and space complexity of O(n/2). Example Usage: * `get_primes(10)` should return `[2, 3, 5, 7]`. * `get_primes(15)` should return `[2, 3, 5, 7, 11, 13]`. * `get_primes(1)` should raise a ValueError. # Requirements 1. **Edge Cases**: Be sure to handle edge cases where `n` is 1 or a small number. 2. **Performance**: Ensure that your solution operates efficiently within the constraints. 3. **Validation**: The function should check the validity of the input (e.g., `n` is a positive integer). Here is the starting code template you can use: ```python from typing import List def get_primes(n: int) -> List[int]: # Your implementation here pass ``` The function should then be tested against a suite of test cases to ensure correctness.","solution":"from typing import List def get_primes(n: int) -> List[int]: if n < 2: return [] if n == 2: return [2] sieve = [True] * (n // 2) sieve[0] = False # 1 is not prime for i in range(1, (int(n**0.5) + 1) // 2): if sieve[i]: prime = 2*i + 1 for j in range(prime*prime // 2, len(sieve), prime): sieve[j] = False primes = [2] + [2*i + 1 for i in range(1, len(sieve)) if sieve[i]] return primes"},{"question":"# Coding Challenge You are tasked with generating all possible expressions from a given string of digits that evaluate to a given target value using binary operators `+`, `-`, and `*`. The challenge is to write a function that explores all valid combinations of these operators inserted between the digits and returns the list of those combinations which exactly match the target value after evaluation. Your function should be called `add_operators`, which will take two inputs: 1. `num` (type: str): a string consisting of digits (0-9) only. 2. `target` (type: int): an integer value which is the targeted result of the expression. Your function should return a list of strings, where each string represents a valid combination forming the targeted result. **Constraints**: * The input string will not be empty and will have fewer than 20 digits. * The evaluation should mimic the standard operator precedence (multiplication before addition and subtraction). Input Example ```python num = \\"123\\" target = 6 ``` Output Example ```python [\\"1+2+3\\", \\"1*2*3\\"] ``` **Hint**: Utilize a depth-first search (DFS) approach with backtracking to explore all possible operator placements. Function Signature ```python def add_operators(num: str, target: int) -> List[str]: # implementation here ```","solution":"from typing import List def add_operators(num: str, target: int) -> List[str]: def helper(path: str, index: int, value: int, last: int): if index == len(num): if value == target: result.append(path) return for i in range(index, len(num)): if i != index and num[index] == \'0\': break current_str = num[index:i+1] current_num = int(current_str) if index == 0: # Start of expression helper(current_str, i + 1, current_num, current_num) else: # Addition helper(path + \\"+\\" + current_str, i + 1, value + current_num, current_num) # Subtraction helper(path + \\"-\\" + current_str, i + 1, value - current_num, -current_num) # Multiplication helper(path + \\"*\\" + current_str, i + 1, value - last + last * current_num, last * current_num) result = [] helper(\\"\\", 0, 0, 0) return result"},{"question":"Magic Number Check **Context**: In mystical number theory, some numbers are considered special or \\"magic\\" based on specific properties. One such property is when the sum of a number\'s digits repeatedly reduces to 1. **Objective**: Write a function to determine whether a given number is a \\"magic number.\\" A magic number is defined as a number that, when summing its digits and repeating this process, eventually reduces to the number 1. # Function Specification **Function Name**: `magic_number` **Input**: * `n` (int): A non-negative integer (0 ≤ n ≤ 10^9) **Output**: * Returns: `True` if the number is a magic number, otherwise `False`. # Example ```python assert magic_number(50113) == True # 5+0+1+1+3=10 -> 1+0=1 assert magic_number(1234) == True # 1+2+3+4=10 -> 1+0=1 assert magic_number(199) == True # 1+9+9=19 -> 1+9=10 -> 1+0=1 assert magic_number(111) == False # 1+1+1=3 assert magic_number(0) == False # 0 ``` # Constraints: 1. The number `n` will be a non-negative integer. 2. You can disregard leading zeros as the input is assumed to be in proper integer format. Your task is to implement the `magic_number` function based on the described algorithm and capabilities. Be sure to handle edge cases appropriately and ensure your function runs efficiently for the upper limits of input sizes.","solution":"def sum_of_digits(n): Helper function to calculate the sum of the digits of n. total = 0 while n > 0: total += n % 10 n //= 10 return total def magic_number(n): Determine whether a given number is a magic number. A magic number is defined as a number that, when summing its digits repeatedly, eventually reduces to the number 1. if n == 0: return False while n > 9: n = sum_of_digits(n) return n == 1"},{"question":"You are tasked with implementing a more efficient version of the MovingAverage class for a streaming service that provides real-time data updates. # Scenario: A financial firm uses a sliding window to calculate the moving average of stock prices. Given a stream of stock prices and a fixed window size, your task is to implement a class that computes the moving average in constant time. # Requirements: 1. Implement a **MovingAverage** class with the constructor and a `next` method as described below: - `MovingAverage(size: int)`: Initializes the object with the window size. - `next(val: int) -> float`: Returns the moving average of the last `size` elements after adding `val` to the stream. # Rules: 1. Use a data structure that efficiently manages the sliding window. 2. The `next` method should run in constant O(1) time for calculating the moving average. # Constraints: 1. The window size will always be a positive integer. 2. The `next` method will be called at least once. # Example Workflow: ``` m = MovingAverage(3) m.next(1) # Returns 1.0 (only one element) m.next(10) # Returns 5.5 (average of [1, 10]) m.next(3) # Returns 4.67 (average of [1, 10, 3]) m.next(5) # Returns 6.0 (average of [10, 3, 5]) ``` # Performance Requirements: Optimize the algorithm to ensure that every call to `next` runs in O(1) time. ```python from collections import deque class MovingAverage: def __init__(self, size: int): self.size = size self.queue = deque(maxlen=size) self.current_sum = 0 def next(self, val: int) -> float: if len(self.queue) == self.size: self.current_sum -= self.queue[0] # Adjust the sum by removing the oldest element self.queue.append(val) self.current_sum += val return self.current_sum / len(self.queue) # Demonstrate the functionality with example assertions if __name__ == \'__main__\': m = MovingAverage(3) assert abs(m.next(1) - 1.0) < 1e-5 assert abs(m.next(10) - 5.5) < 1e-5 assert abs(m.next(3) - 4.66667) < 1e-5 assert abs(m.next(5) - 6.0) < 1e-5 ```","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): self.size = size self.queue = deque(maxlen=size) self.current_sum = 0 def next(self, val: int) -> float: if len(self.queue) == self.size: self.current_sum -= self.queue.popleft() self.queue.append(val) self.current_sum += val return self.current_sum / len(self.queue)"},{"question":"You are given an array that may contain nested arrays or other iterable objects (excluding strings which should be treated as atomic elements). Your task is to implement two functions to flatten these structures into a single dimension. 1. **flatten_recursive**: A function that takes a nested array and returns a fully flattened list. 2. **flatten_generator**: A function that takes a nested array and returns a generator that yields elements in a flattened manner. # Function Signatures ```python def flatten_recursive(input_arr): pass def flatten_generator(iterable): pass ``` # Input * The input for both functions will be a multi-dimensional list or other iterable structures consisting of integers, strings, nested lists, or tuples. # Output * `flatten_recursive` should return a single list containing all the nested elements. * `flatten_generator` should return a generator yielding elements one by one, flattened from the nested structure. # Constraints * You may not use any external libraries other than `collections.abc` for checking if an element is iterable. * The input structure can be deeply nested, but consider typical Python recursion limits. * Strings should be treated as atomic elements and not further decomposed. # Examples ```python assert flatten_recursive([1, [2, [3, 4]], 5, (6, 7)]) == [1, 2, 3, 4, 5, 6, 7] assert list(flatten_generator([1, [2, [3, 4]], 5, (6, 7)])) == [1, 2, 3, 4, 5, 6, 7] ``` # Further Context Consider an example usage scenario: You are working with a data pipeline where input data is stored in JSON format with unpredictable nesting. To streamline processing, you need to flatten the structure so that each data element can be processed uniformly. Implementing these functions will allow you to preprocess data efficiently irrespective of how deeply nested it is.","solution":"from collections.abc import Iterable def flatten_recursive(input_arr): Recursively flattens a nested iterable structure into a single flat list. Strings are treated as atomic elements. flattened = [] for element in input_arr: if isinstance(element, Iterable) and not isinstance(element, str): flattened.extend(flatten_recursive(element)) else: flattened.append(element) return flattened def flatten_generator(iterable): Flattens a nested iterable structure into a single flat level using a generator. Strings are treated as atomic elements. for element in iterable: if isinstance(element, Iterable) and not isinstance(element, str): yield from flatten_generator(element) else: yield element"},{"question":"Cosine Similarity Enhancement Suppose you are working on a recommendation system and need to adjust the existing implementation for cosine similarity to handle more complex scenarios efficiently. You are provided the initial implementation of the cosine similarity calculation and are required to enhance it. **Scenario Context:** Your system is expected to process large datasets for finding similarities between items. The given function must be improved to ensure efficiency and robustness. Specifically, extend the functionality to handle matrices of vectors instead of just pairs of vectors. # Task: Implement a function `cosine_similarity_matrix` that: 1. **Input:** * **matrix1**: A list of lists, where each inner list represents a vector. * **matrix2**: A list of lists, where each inner list represents a vector. * Both matrices have the same dimensions, i.e., if `matrix1` has (m times n) dimensions, `matrix2` will also have (m times n) dimensions. 2. **Output:** * A list of lists where each element [i][j] represents the cosine similarity between `matrix1[i]` and `matrix2[j]`. Constraints: * Matrices will have at most (1000) vectors and each vector can have up to (1000) elements. * Handle cases where vectors might have zero length or zero norms. * Optimize the performance considering possible bottlenecks in large data processing. Function Signature: ```python def cosine_similarity_matrix(matrix1: list[list[float]], matrix2: list[list[float]]) -> list[list[float]]: pass ``` Example: ```python matrix1 = [ [1, 1, 1], [2, 2, 2] ] matrix2 = [ [1, 2, -1], [3, 0, 0] ] cosine_similarity_matrix(matrix1, matrix2) # Output: [[0.47140452079103173, 0.5773502691896257], # [0.47140452079103173, 0.5773502691896257]] ``` # Requirements: - Ensure that your solution is optimized for large matrices. - Handle all edge cases appropriately.","solution":"import math def cosine_similarity(v1, v2): Helper function to calculate cosine similarity between two vectors. sumxx, sumxy, sumyy = 0, 0, 0 for i in range(len(v1)): x = v1[i] y = v2[i] sumxx += x * x sumyy += y * y sumxy += x * y if sumxx == 0 or sumyy == 0: return 0 # To handle zero division error return sumxy / math.sqrt(sumxx * sumyy) def cosine_similarity_matrix(matrix1, matrix2): Compute the cosine similarity matrix between two matrices. Parameters: - matrix1: A list of lists, where each inner list represents a vector. - matrix2: A list of lists, where each inner list represents a vector. Both matrices have the same dimensions. Returns: - A list of lists where each element [i][j] represents the cosine similarity between matrix1[i] and matrix2[j]. result = [] for vec1 in matrix1: row = [] for vec2 in matrix2: similarity = cosine_similarity(vec1, vec2) row.append(similarity) result.append(row) return result"},{"question":"You are tasked to help a robot climb a set of stairs. The robot can climb either 1 step or 2 steps at a time. Given a positive integer `steps`, determine the number of distinct ways the robot can reach the top of the staircase. Function Signature ```python def robot_climb_ways(steps: int) -> int: :param steps: An integer representing the number of steps to the top. :return: An integer representing the number of distinct ways to reach the top. ``` Input * `steps` (1 ≤ steps ≤ 10^5): Represents the number of steps to the top. Output * Return an integer representing the number of distinct ways to reach the top. Example ```python assert robot_climb_ways(2) == 2 # There are two ways: (1+1) and (2) assert robot_climb_ways(3) == 3 # There are three ways: (1+1+1), (1+2) and (2+1) assert robot_climb_ways(4) == 5 # There are five ways: (1+1+1+1), (1+1+2), (1+2+1), (2+1+1), and (2+2) ``` Constraints * Optimize your solution to use O(1) additional space.","solution":"def robot_climb_ways(steps: int) -> int: Returns the number of distinct ways the robot can reach the top of the staircase. :param steps: An integer representing the number of steps to the top. :return: An integer representing the number of distinct ways to reach the top. if steps == 1: return 1 elif steps == 2: return 2 # Use variables to store the last two results for O(1) space complexity prev1, prev2 = 1, 2 for i in range(3, steps + 1): current = prev1 + prev2 prev1, prev2 = prev2, current return prev2"},{"question":"Construct a dynamic system to manage a collection of disjoint sets of elements. Implement the Union-Find data structure to support efficient union and find operations, and apply it to solve the problem of counting the number of islands in a grid after each addition of land. # Function Signature Implement the function `num_islands(positions: List[List[int]]) -> List[int]`. # Parameters: * **positions**: A list of lists where each inner list contains two integers [x, y] representing the row and column indices respectively where land is added. # Returns: * Return a list of integers where each integer represents the count of islands after each addLand operation in the given order. # Constraints: * The grid is initially filled with water, represented by 0s. * Positions always lie within the grid bounds and are distinct. * The grid size is defined by the maximum x and y indices present in the positions. # Example: ```python positions = [[0, 0], [0, 1], [1, 2], [2, 1]] print(num_islands(positions)) # Output: [1, 1, 2, 3] ``` # Explanation: Initially, the grid is filled with water: ``` 0 0 0 0 0 0 0 0 0 ``` 1. Operation #1: Adding land at (0, 0) results in: ``` 1 0 0 0 0 0 0 0 0 Number of islands = 1 ``` 2. Operation #2: Adding land at (0, 1) results in: ``` 1 1 0 0 0 0 0 0 0 Number of islands = 1 ``` 3. Operation #3: Adding land at (1, 2) results in: ``` 1 1 0 0 0 1 0 0 0 Number of islands = 2 ``` 4. Operation #4: Adding land at (2, 1) results in: ``` 1 1 0 0 0 1 0 1 0 Number of islands = 3 ```","solution":"from typing import List, Tuple class UnionFind: def __init__(self, n: int): self.parent = list(range(n)) self.rank = [1] * n self.count = 0 def find(self, x: int) -> int: if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x: int, y: int): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def add(self): self.count += 1 def num_islands(positions: List[List[int]]) -> List[int]: if not positions: return [] n = len(positions) rows = max(p[0] for p in positions) + 1 cols = max(p[1] for p in positions) + 1 def get_index(x: int, y: int) -> int: return x * cols + y uf = UnionFind(rows * cols) grid = [[0] * cols for _ in range(rows)] result = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for x, y in positions: if grid[x][y] == 1: result.append(uf.count) continue grid[x][y] = 1 index = get_index(x, y) uf.add() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1: uf.union(index, get_index(nx, ny)) result.append(uf.count) return result"},{"question":"# Context: You are given an array of integers where no particular order is guaranteed. Your task is to implement a search algorithm that can efficiently find the given target number\'s position in the array. # Objective: Write a python function `enhanced_linear_search` that demonstrates comprehension of linear search by optimizing its behavior and introducing a feature to handle multiple occurrences of an element. # Requirements: 1. If the target element is found in the array, return a list of all indices where the element occurs. 2. If the target element is not found, return an empty list. 3. Ensure the function handles edge cases efficiently, such as empty arrays, arrays with repeated elements, and arrays with unique elements only. 4. The function should not use any built-in functions that directly solve the problem. 5. Consider time complexity and aim to keep space complexity at O(1) additional space if possible. # Function Signature: ```python def enhanced_linear_search(array, query): Find all indices of the given element in the array. Parameters: - array (list of int): The array to search through. - query (int): The element to search for. Returns: - list of int: A list of indices where the element occurs, or an empty list if the element is not found. ``` # Input and Output Format: * **Input**: - `array`: A list of integers. Example: `[10, 20, 30, 10, 40, 50, 10]` - `query`: An integer to search for in the array. Example: `10` * **Output**: - A list of indices where the query element appears in the array. Example: `[0, 3, 6]` for the above input. # Constraints: * Optimize the function to handle arrays up to a length of 10^6 efficiently. * Ensure the function works robustly even with python data structures and types. # Test Cases: - `enhanced_linear_search([1, 2, 3, 4, 5], 3)` should return `[2]` - `enhanced_linear_search([5, 5, 5], 5)` should return `[0, 1, 2]` - `enhanced_linear_search([10, 20, 30, 40], 50)` should return `[]` - `enhanced_linear_search([], 1)` should return `[]`","solution":"def enhanced_linear_search(array, query): Find all indices of the given element in the array. Parameters: - array (list of int): The array to search through. - query (int): The element to search for. Returns: - list of int: A list of indices where the element occurs, or an empty list if the element is not found. result = [] # Iterate through the array and collect indices where the element matches the query for index in range(len(array)): if array[index] == query: result.append(index) return result"},{"question":"<|Analysis Begin|> # Algorithm/Data Structure **Algorithm**: Path Simplification Algorithm **Type**: String manipulation and stack-based algorithm **Main Purpose**: To transform a given Unix-style absolute file path to its simplest form by resolving references to the current directory (.), parent directory (..), and ignoring redundant slashes (/). # Complexity **Time Complexity**: O(n), where n is the length of the input path string. This is because each character in the path is processed at most twice (once when split into tokens, and once when processed in the stack). **Space Complexity**: O(n), where n is the length of the input path string. This is due to storing the tokens in a stack. # Principles * **Splitting the Path**: The input path is split into tokens using the \'/\' delimiter. * **Stack Operations**: A stack is used to process the tokens: * **Push token**: If the token is a valid directory name (neither \'.\' nor \'..\'), push it onto the stack. * **Pop token**: If the token is \'..\', pop the top element from the stack (represents moving up one directory). * **Ignore token**: If the token is \'.\' or empty, do nothing. # Characteristics & Applications **Properties**: * Handles edge cases like multiple consecutive slashes and references to current and parent directories. * Ensures the resultant path is absolute and minimal. **Common Use Cases**: * Simplifying file paths in file system navigation tools. * Normalizing paths for storage or comparison in applications dealing with file management. **Strengths/Limitations**: * **Strengths**: * Handles various edge cases effectively. * Simple and efficient, suitable for real-time applications. * **Limitations**: * Limited to Unix-style paths; assumes input paths are well-formed abnormal inputs can lead to undefined behavior. # Implementation Challenges **Edge Cases**: * Input path is a single slash (\\"/\\"), resulting in \\"/\\". * Multiple redundant slashes are ignored. * Handling \\"..\\" when there\'s no previous directory to move up to, e.g., \\"/../\\". **Performance Bottlenecks**: * Processing very deeply nested paths or extremely long strings could be bottlenecked by memory constraints. **Error Scenarios**: * Paths containing invalid characters or formats may not be adequately handled. **Optimization Points**: * The algorithm is already efficient in terms of time and space. Further optimization could include preprocessing to remove unnecessary slashes before tokenization. <|Analysis End|> <|Question Begin|> # Simplify Unix-Style Path Problem Description Your task is to write a function `simplify_path` that takes an absolute path for a file (Unix-style) and returns the simplified canonical path. The algorithm should handle references like `.` (current directory) and `..` (parent directory) and ignore multiple slashes (`/`). Function Signature ```python def simplify_path(path: str) -> str: pass ``` Input * A string `path` representing the absolute path (Unix-style). Output * A string representing the simplified canonical path. Constraints * The path will always begin with a \'/\'. * The path contains only lowercase alphabetical characters and other characters (`/`, `.`, `..`). Examples 1. Given the path `\\"/home/\\"`, the function should return `\\"/home\\"`. 2. Given the path `\\"/a/./b/../../c/\\"`, the function should return `\\"/c\\"`. 3. Given the path `\\"/../\\"`, the function should return `\\"/\\"`. 4. Given the path `\\"/home//foo/\\"`, the function should return `\\"/home/foo\\"`. Note Ensure the function efficiently handles different edge cases, including multiple consecutive slashes, single or double dots (\'.\', \'..\'), and deeply nested directory structures. |Question End|","solution":"def simplify_path(path: str) -> str: Simplifies the given absolute Unix-style path. parts = path.split(\'/\') stack = [] for part in parts: if part == \'.\' or part == \'\': # Ignore \'.\' and empty parts continue elif part == \'..\': # Pop from stack if possible for \'..\' if stack: stack.pop() else: # Valid directory name, push to stack stack.append(part) # Join the stack into a simplified path simplified_path = \'/\' + \'/\'.join(stack) return simplified_path"},{"question":"# Word Square Combinatorics You are tasked with writing a function that takes a list of words and returns all possible word squares that can be formed using those words. Input * A list of words (all unique strings). * Each word contains only lower case English alphabets and all words have the same length. Output * A list of word squares. Each word square is represented as a list of words. Constraints * The list of words will contain at least 1 and at most 1000 words. * All words will have the exact same length. * The length of any word will be at least 1 and at most 5. Example ```python # Example 1 Input: words = [\\"area\\", \\"lead\\", \\"wall\\", \\"lady\\", \\"ball\\"] # Example 1 Output: # [ # [\\"wall\\", \\"area\\", \\"lead\\", \\"lady\\"], # [\\"ball\\", \\"area\\", \\"lead\\", \\"lady\\"], # ] # Example 2 Input: words = [\\"ball\\", \\"area\\", \\"lead\\", \\"lady\\"] # Example 2 Output: # [ # [\\"ball\\", \\"area\\", \\"lead\\", \\"lady\\"] # ] ``` Performance Requirements Given the potentially high number of combinations, an efficient solution is important. Aim for optimal prefix querying and minimize unnecessary computations. Implement the function `word_squares(words)` which returns a list of all word squares possible: ```python def word_squares(words): # function implementation ```","solution":"from collections import defaultdict class TrieNode: def __init__(self): self.children = {} self.words_with_prefix = [] class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.words_with_prefix.append(word) def find_words_with_prefix(self, prefix): node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] return node.words_with_prefix def word_squares(words): def build_trie(words): trie = Trie() for word in words: trie.insert(word) return trie def backtracking(step, word_square): if step == n: squares.append(list(word_square)) return prefix = \'\'.join([word_square[i][step] for i in range(step)]) for next_word in prefix_dict.find_words_with_prefix(prefix): word_square.append(next_word) backtracking(step + 1, word_square) word_square.pop() n = len(words[0]) squares = [] prefix_dict = build_trie(words) for word in words: backtracking(1, [word]) return squares"},{"question":"# Question: Binary Tree to Doubly Linked List Conversion You are given the root of a binary tree. Your task is to write a Python function that converts this binary tree into a doubly linked list in-place. The doubly linked list should be created such that the nodes appear in in-order traversal of the binary tree. Specifically, you should adjust the left and right pointers in each node to act as previous and next pointers in the doubly linked list, respectively. The function should return the head of the doubly linked list. Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def convert_to_doubly_linked_list(root: TreeNode) -> TreeNode: ``` Input - `root`: The root of a binary tree, defined as an instance of the `TreeNode` class. Output - Returns the head of the doubly linked list, which is the leftmost node (in-order) of the original binary tree. Constraints - The number of nodes in the tree is in the range `[0, 10^4]`. - `-10^5 <= Node.val <= 10^5` Performance - The solution should efficiently handle the constraints, maintaining a time complexity of O(n) and space complexity of O(h) where h is the height of the tree. Scenario Consider a binary search tree where the nodes need to be accessed sequentially for a paginated view. Converting the tree into a doubly linked list can simplify the sequential access of the nodes. Example ```plaintext Input: 4 / 2 5 / 1 3 Output Doubly Linked List: 1 <-> 2 <-> 3 <-> 4 <-> 5 ``` ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def convert_to_doubly_linked_list(root: TreeNode) -> TreeNode: def bin_tree_to_list_util(root): if not root: return root if root.left: left = bin_tree_to_list_util(root.left) while left.right: left = left.right left.right = root root.left = left if root.right: right = bin_tree_to_list_util(root.right) while right.left: right = right.left right.left = root root.right = right return root if not root: return root root = bin_tree_to_list_util(root) while root.left: root = root.left return root ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def convert_to_doubly_linked_list(root: TreeNode) -> TreeNode: if not root: return None # Initialize previous pointer as None prev = None # Use a stack for inorder traversal stack = [] current = root head = None while stack or current: # Traverse to the leftmost node while current: stack.append(current) current = current.left current = stack.pop() if prev: prev.right = current current.left = prev else: head = current prev = current current = current.right return head"},{"question":"# Caesar Cipher Decryption **Context**: A data leak incident occurred, and to retrieve the encrypted data, you need to decrypt the text encrypted with a Caesar Cipher. Given the encrypted text and the shift value used during the encryption, your task is to write a function to decrypt the text. **Task**: Write a function `decrypt_caesar_cipher(encrypted_text, shift)` that takes an encrypted string and an integer shift value, and returns the original decrypted string. **Function Signature**: ```python def decrypt_caesar_cipher(encrypted_text: str, shift: int) -> str: # Your code here ``` **Expected Input and Output**: * `encrypted_text` (str): A string consisting of alphabetic characters only, possibly mixed-case (e.g., \\"Khoor Zruog\\"). * `shift` (int): An integer representing the number of positions each letter was shifted to create the `encrypted_text`. **Constraints**: * 1 <= len(encrypted_text) <= 10^3 * 0 <= shift < 26 **Output**: * A string that represents the decrypted original text. **Example**: ```python # Example 1: encrypted_text = \\"Khoor Zruog\\" shift = 3 # Decrypted text should be: \\"Hello World\\" print(decrypt_caesar_cipher(encrypted_text, shift)) # Example 2: encrypted_text = \\"Ebiil Tloia\\" shift = 23 # Decrypted text should be: \\"Hello World\\" print(decrypt_caesar_cipher(encrypted_text, shift)) ``` **Requirements**: * Ensure that the non-alphabetic characters remain unchanged. * Handle both uppercase and lowercase letters appropriately.","solution":"def decrypt_caesar_cipher(encrypted_text: str, shift: int) -> str: Decrypts a given text encrypted by a Caesar Cipher with a specified shift value. Args: encrypted_text (str): The encrypted message. shift (int): The number of positions each letter was shifted during the encryption. Returns: str: The decrypted original text. decrypted_text = [] for char in encrypted_text: if char.isalpha(): # determine if it\'s upper or lower case to handle correct range offset = 65 if char.isupper() else 97 # decrypt character decrypted_char = chr((ord(char) - offset - shift) % 26 + offset) decrypted_text.append(decrypted_char) else: decrypted_text.append(char) return \\"\\".join(decrypted_text)"},{"question":"# Question: You are given a list of integers. Your task is to implement the function `top_1(arr)` which finds and returns the mode(s) of the array. If there are multiple modes, the function should return a list of all these values in any order. Input: * `arr` - a list of integers, possibly empty. Output: * A list of integers which are the mode(s) of the array. The list can be returned in any order. Example: ```python # Example 1: input: [1, 1, 2, 2, 3, 4] output: [1, 2] # Example 2: input: [5, 5, 5, 1, 2, 3, 4] output: [5] # Example 3: input: [] output: [] # Example 4: input: [1, 2, 3, 4, 5] output: [1, 2, 3, 4, 5] ``` Constraints: * The function should handle arrays of length up to 10^6 efficiently. * The elements in the array are within the range of standard 32-bit integers. Additionally, ensure your implementation addresses the following scenarios: * Handling of empty arrays. * Arrays where all elements are unique. * Arrays with multiple elements sharing the highest frequency.","solution":"from collections import Counter def top_1(arr): Finds and returns the mode(s) of the array. If there are multiple modes, the function returns a list of all these values in any order. if not arr: return [] count = Counter(arr) max_frequency = max(count.values()) modes = [num for num, freq in count.items() if freq == max_frequency] return modes"},{"question":"# Binary Heap Implementation and Priority Queue Application You have been provided with an implementation of a min-heap using a binary heap structure. A min-heap ensures that the root of the tree is the smallest element, and each parent node is less than or equal to its child nodes. Your task is twofold: 1. Implement the `get_min` method in the BinaryHeap class which should return the smallest element in the heap without removing it. 2. Design a `PriorityQueue` class utilizing the provided `BinaryHeap` class. The `PriorityQueue` should support the following operations: - `enqueue(element)`: Inserts the element into the priority queue. - `dequeue()`: Removes and returns the element with the highest priority (smallest value). - `peek()`: Returns the element with the highest priority without removing it. - Additionally, a method `is_empty()` should be provided to check if the priority queue is empty. Implement the above by completing the methods in the skeleton code provided below. ```python class BinaryHeap(AbstractHeap): def __init__(self): self.current_size = 0 self.heap = [0] # Initialized with zero to occupy the 0th index def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert(self, val): self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def min_child(self, i): if 2 * i + 1 > self.current_size: return 2 * i return 2 * i + 1 if self.heap[2 * i + 1] < self.heap[2 * i] else 2 * i def perc_down(self, i): while 2 * i <= self.current_size: mc = self.min_child(i) if self.heap[mc] < self.heap[i]: self.heap[mc], self.heap[i] = self.heap[i], self.heap[mc] i = mc def remove_min(self): ret_val = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return ret_val def get_min(self): # Implement this method pass class PriorityQueue: def __init__(self): self.heap = BinaryHeap() def enqueue(self, element): # Implement this method using heap.insert pass def dequeue(self): # Implement this method using heap.remove_min pass def peek(self): # Implement this method using heap.get_min pass def is_empty(self): # Implement this method pass ``` # Constraints: - All elements inserted in the heap and priority queue are integers. - You must handle edge cases such as empty queues appropriately. # Example: ```python pq = PriorityQueue() pq.enqueue(10) pq.enqueue(5) pq.enqueue(20) print(pq.peek()) # Output: 5 print(pq.dequeue()) # Output: 5 print(pq.dequeue()) # Output: 10 print(pq.is_empty()) # Output: False print(pq.dequeue()) # Output: 20 print(pq.is_empty()) # Output: True ``` Utilize the `BinaryHeap` to ensure the best possible efficiency for all operations.","solution":"class BinaryHeap: def __init__(self): self.current_size = 0 self.heap = [0] # Initialized with zero to occupy the 0th index def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert(self, val): self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def min_child(self, i): if 2 * i + 1 > self.current_size: return 2 * i return 2 * i + 1 if self.heap[2 * i + 1] < self.heap[2 * i] else 2 * i def perc_down(self, i): while 2 * i <= self.current_size: mc = self.min_child(i) if self.heap[mc] < self.heap[i]: self.heap[mc], self.heap[i] = self.heap[i], self.heap[mc] i = mc def remove_min(self): ret_val = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return ret_val def get_min(self): if self.current_size == 0: return None return self.heap[1] class PriorityQueue: def __init__(self): self.heap = BinaryHeap() def enqueue(self, element): self.heap.insert(element) def dequeue(self): if self.heap.current_size == 0: return None return self.heap.remove_min() def peek(self): return self.heap.get_min() def is_empty(self): return self.heap.current_size == 0"},{"question":"# Question: Preorder Traversal with Validation and Reporting You are tasked with implementing a function to perform a preorder traversal on a binary tree, but with additional requirements. Specifically, you must validate the tree\'s structure and report nodes\' values as well as their depth level in the traversal process. **Function Signature**: ```python def preorder_with_depth(root: Optional[Node]) -> List[Tuple[int, int]]: pass ``` # Input - A variable `root` of type `Node`, representing the root of the binary tree. # Output - A list of tuples. Each tuple contains two integers: - The first integer is the node value. - The second integer is the depth (or level) of the node in the tree (starting at 0 for the root). # Constraints - Handle edge cases such as an empty tree (i.e., `root` is `None`). - Ensure that the function returns the nodes in the correct preorder sequence (root, left, right). # Performance Requirements - Aim to keep time complexity to O(n), where n is the number of nodes in the tree. - Use an iterative approach to prevent issues with deep recursion stacks. # Example ```python # Tree structure: # 1 # / # 2 3 # / # 4 5 # Creating the tree nodes root = Node(1, Node(2, Node(4), Node(5)), Node(3)) # Expected Output: # [(1, 0), (2, 1), (4, 2), (5, 2), (3, 1)] print(preorder_with_depth(root)) # Output: [(1, 0), (2, 1), (4, 2), (5, 2), (3, 1)] ``` **Note**: Document the implementation process, considering node validation and depth tracking, along with any encountered challenges and edge cases.","solution":"from typing import Optional, List, Tuple class Node: def __init__(self, value: int, left: \'Node\' = None, right: \'Node\' = None): self.value = value self.left = left self.right = right def preorder_with_depth(root: Optional[Node]) -> List[Tuple[int, int]]: if root is None: return [] result = [] stack = [(root, 0)] # stack contains tuples of (node, depth) while stack: node, depth = stack.pop() result.append((node.value, depth)) # Push the right child first to ensure left child is processed first if node.right is not None: stack.append((node.right, depth + 1)) if node.left is not None: stack.append((node.left, depth + 1)) return result"},{"question":"# Stooge Sort Coding Assessment You are tasked with implementing the Stooge Sort algorithm. Stooge Sort is a highly inefficient yet educational sorting algorithm that sorts an array by recursively sorting segments of the array. Given an input array, the Stooge Sort algorithm will sort the array in non-decreasing order. **Function Specification**: * **Function Name**: `stoogesort` * **Parameters**: - `arr` (List[int]): The list of integers to sort. - `l` (int): The starting index of the segment to sort. - `h` (int): The ending index of the segment to sort. * **Output**: The function should sort the segment of the list `arr[l:h+1]` in place. ```python def stoogesort(arr, l, h): # Your code here # Example Usage if __name__ == \\"__main__\\": array = [64, 34, 25, 12, 22, 11, 90] n = len(array) stoogesort(array, 0, n-1) print(\\"Sorted array:\\", array) ``` # Constraints: * You may assume that all elements in the array are integers. * The input array can contain duplicate elements. * The length of the array may range from 0 to 1000. # Requirements: * The function should sort the list in non-decreasing order using the Stooge Sort algorithm. * Your implementation must follow the recursive method described above. * Ensure that the function signature matches the one provided in the prompt. **Examples**: 1. Input: `[5, 3, 2, 4, 1]` Output: `[1, 2, 3, 4, 5]` 2. Input: `[64, 34, 25, 12, 22, 11, 90]` Output: `[11, 12, 22, 25, 34, 64, 90]` 3. Input: `[1, 2, 3, 4, 5]` Output: `[1, 2, 3, 4, 5]` (Already sorted) **Additional Notes**: - Carefully consider the base and recursive cases to avoid infinite recursion. - Pay attention to indices while performing segment swaps and recursive calls.","solution":"def stoogesort(arr, l, h): Sorts the segment of the array from index l to index h using Stooge Sort algorithm. if l >= h: return # If the element at l is greater than the element at h, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort first 2/3 of the array stoogesort(arr, l, h - t) # Recursively sort last 2/3 of the array stoogesort(arr, l + t, h) # Recursively sort first 2/3 of the array again stoogesort(arr, l, h - t) # Example Usage if __name__ == \\"__main__\\": array = [64, 34, 25, 12, 22, 11, 90] n = len(array) stoogesort(array, 0, n-1) print(\\"Sorted array:\\", array)"},{"question":"# Problem Description You are given a square matrix `mat` of dimension `d` and an integer `n`. Write a function `matrix_power(mat: List[List[int]], n: int) -> List[List[int]]` that computes the `n`-th power of the matrix using the strategy of repeated squaring. The function should use helper functions to perform matrix multiplication and to generate the identity matrix as needed. # Function Signature ```python from typing import List def matrix_power(mat: List[List[int]], n: int) -> List[List[int]]: # Your code here ``` # Input * `mat`: A square matrix represented as a list of lists of integers ` [[a11, a12, ..., a1d], [a21, a22, ..., a2d], ..., [ad1, ad2, ..., add]] ` (1 ≤ d ≤ 100) * `n`: A non-negative integer representing the power to which the matrix is to be raised (0 ≤ n ≤ 10^9) # Output * A square matrix resulting from raising `mat` to the power of `n`. # Constraints * The matrix will always be non-empty and square (i.e., number of rows = number of columns). * The elements of the matrix and `n` are integers. # Performance Requirements * The matrix exponentiation should run in `O(d^3 log(n))` time complexity. # Example ```python mat = [ [1, 2], [3, 4] ] n = 2 # Example output: # [[7, 10], # [15, 22]] result = matrix_power(mat, n) # Explanation: # mat^2 = mat * mat ``` # Note Consider edge cases such as: - Exponent 0: The result should be the identity matrix of the same dimension. - Exponent 1: The result should be the matrix itself.","solution":"from typing import List def matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: d = len(A) result = [[0] * d for _ in range(d)] for i in range(d): for j in range(d): for k in range(d): result[i][j] += A[i][k] * B[k][j] return result def identity_matrix(size: int) -> List[List[int]]: return [[1 if i == j else 0 for j in range(size)] for i in range(size)] def matrix_power(mat: List[List[int]], n: int) -> List[List[int]]: if n == 0: return identity_matrix(len(mat)) if n == 1: return mat half_power = matrix_power(mat, n // 2) half_power_squared = matrix_multiply(half_power, half_power) if n % 2 != 0: return matrix_multiply(half_power_squared, mat) else: return half_power_squared"},{"question":"Question: Implement a Post-Order BST Iterator Let\'s extend the concept of the BST iterator to implement a post-order traversal iterator. The goal is to create an iterator that outputs the elements of a given BST in post-order (left, right, root) sequence. # Function Signature You are required to implement a class `BSTPostOrderIterator` with the following methods: - `__init__(self, root)`: Initializes the iterator with the root node of the BST. - `has_next(self) -> bool`: Returns `True` if the iteration has more elements. - `next(self) -> int`: Returns the next element in post-order traversal. # Example ```python # Assuming the definition of TreeNode: class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Sample usage: # Construct a BST # 4 # / # 2 5 # / # 1 3 root = TreeNode(4) root.left = TreeNode(2, TreeNode(1), TreeNode(3)) root.right = TreeNode(5) # Initialize iterator iterator = BSTPostOrderIterator(root) # Collect elements in post-order result = [] while iterator.has_next(): result.append(iterator.next()) # result should be [1, 3, 2, 5, 4] ``` # Constraints - `0 <= Number of Nodes <= 10^4`. - The tree nodes will have integer values, and the tree itself complies with BST properties. # Implementation Notes 1. **Stack Usage**: You will likely still need to utilize a stack to manage traversal, but consider how the order of node processing must change for post-order. 2. **Tree Initialization**: Consider edge cases such as an empty tree. 3. **Traversal Management**: Ensure that each call to `next` runs in an efficient manner.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTPostOrderIterator: def __init__(self, root): self.stack = [] self._organize_stack(root) def _organize_stack(self, node): # This helper function will push nodes onto the stack in the order needed for post-order traversal. if not node: return self.stack.append((node, False)) while self.stack: cur_node, is_visited = self.stack[-1] if is_visited: break else: self.stack.pop() self.stack.append((cur_node, True)) if cur_node.right: self.stack.append((cur_node.right, False)) if cur_node.left: self.stack.append((cur_node.left, False)) def has_next(self): return bool(self.stack) def next(self): if not self.has_next(): raise StopIteration(\\"No more elements in BSTPostOrderIterator\\") next_node, _ = self.stack.pop() return next_node.val"},{"question":"# Problem Description You are tasked to implement a function that performs selection sort. Apart from sorting, your function should count the number of comparisons made while finding the minimum value in each iteration and print the state of the array after each swap operation during the sorting process. # Function Signature ```python def detailed_selection_sort(arr: list[int]) -> tuple[list[int], int]: Perform selection sort on the given list and return a tuple containing: 1. The sorted list. 2. The total number of element comparisons made during sorting. Args: arr (list[int]): An unsorted list of integers. Returns: tuple: A tuple containing the sorted list and the total number of comparisons. pass ``` # Input - A list of integers `arr`. # Output - A tuple: 1. The sorted list. 2. Integer representing the total number of comparisons made. # Example ```python >>> detailed_selection_sort([64, 25, 12, 22, 11]) iteration 1 : 11 25 12 22 64 iteration 2 : 11 12 25 22 64 iteration 3 : 11 12 22 25 64 iteration 4 : 11 12 22 25 64 iteration 5 : 11 12 22 25 64 ([11, 12, 22, 25, 64], 10) ``` # Constraints * The input list can be of any length, including empty. * All values in the input list will be integers within the range of -1000 to 1000. # Performance Requirements - Your function should operate in O(n^2) time complexity. - Space complexity should be O(1) as it performs in-place sorting. # Notes - Consider both typical use and edge cases like empty lists or lists with a single element. - Make sure to return the correct total number of comparisons at the end.","solution":"def detailed_selection_sort(arr: list[int]) -> tuple[list[int], int]: n = len(arr) comparisons = 0 for i in range(n): min_idx = i for j in range(i+1, n): comparisons += 1 if arr[j] < arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] print(f\\"iteration {i+1} :\\", \\" \\".join(map(str, arr))) return arr, comparisons"},{"question":"# Longest Common Prefix Challenge **Objective**: Implement an algorithm to find the longest common prefix string amongst a given array of strings efficiently using the most suitable approach. Your solution should be optimal and handle edge cases effectively. **Problem Statement**: Write a function `longest_common_prefix(arr)` that takes an array of strings `arr` and returns the longest common prefix string among them. If no common prefix exists, return an empty string `\\"\\"`. **Input**: - An array of strings, `arr`, with length `n` (1 <= n <= 10^5). - Each string in `arr` has a length of at most 100 characters. **Output**: - A single string output which is the longest common prefix of the strings in `arr`. **Constraints**: - The strings consist only of lowercase English letters. - Optimize for both time and space efficiency. **Examples**: ``` Example 1: Input: [\\"flower\\",\\"flow\\",\\"flight\\"] Output: \\"fl\\" Example 2: Input: [\\"dog\\",\\"racecar\\",\\"car\\"] Output: \\"\\" Explanation: There is no common prefix among the input strings. Example 3: Input: [\\"interview\\",\\"intermediate\\",\\"internal\\",\\"internet\\"] Output: \\"inter\\" Example 4: Input: [\\"\\", \\"flower\\", \\"flow\\", \\"flight\\"] Output: \\"\\" Explanation: An empty string among the input results in no common prefix. Example 5: Input: [\\"ab\\", \\"ab\\", \\"ab\\", \\"ab\\"] Output: \\"ab\\" ``` **Instructions**: 1. Create a function `longest_common_prefix(arr)` that will implement this functionality. 2. Ensure that your function is efficient in terms of time and space complexity. 3. Handle edge cases such as arrays with single strings, no common prefix, and where one or more strings are empty. 4. You may use either horizontal scanning, vertical scanning, or divide and conquer method or any optimized combination for the best performance. # Submission ***You must provide the working function without any additional libraries or dependencies, ensuring it runs in an optimized manner for the given constraints.***","solution":"def longest_common_prefix(arr): Returns the longest common prefix among the array of strings `arr`. if not arr: return \\"\\" # Start by assuming the whole first string is the common prefix prefix = arr[0] # Iterate through all other strings in the array for string in arr[1:]: # Gradually reduce the prefix length until a common prefix is found while string[:len(prefix)] != prefix and prefix: prefix = prefix[:len(prefix)-1] if not prefix: return \\"\\" return prefix"},{"question":"You are given an array of integers and need to sort it using the Merge Sort algorithm. Your task is to implement the `merge_sort` function and its helper function `merge`, which will recursively sort the input array. Function Signatures ```python def merge_sort(arr: list) -> list: Sorts an array of integers using the merge sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: A sorted list of integers. pass def merge(left: list, right: list, merged: list) -> None: Merges two sorted subarrays into a single sorted array. Parameters: left (list): The left subarray. right (list): The right subarray. merged (list): The array to hold merged output (should be the same as left + right in length). pass ``` Requirements 1. Implement the `merge_sort` function to sort an array of integers. 2. The `merge` function should merge two sorted subarrays into a single sorted array. 3. Ensure your implementation handles edge cases such as empty or single-element arrays. 4. Do not use any built-in sort functions. # Input Constraints - `arr` can have a maximum length of (10^5). - Each element in `arr` is in the range (-10^9) to (10^9). # Example ```python # Example 1 input_array = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] # Expected Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] # Example 2 input_array = [5, 3, 8, 4, 2] # Expected Output: [2, 3, 4, 5, 8] ``` ```python # Function Signature def merge_sort(arr: list) -> list: if len(arr) <= 1: return arr mid = len(arr) // 2 left, right = merge_sort(arr[:mid]), merge_sort(arr[mid:]) merge(left, right, arr) return arr def merge(left: list, right: list, merged: list) -> None: left_cursor, right_cursor = 0, 0 while left_cursor < len(left) and right_cursor < len(right): if left[left_cursor] <= right[right_cursor]: merged[left_cursor+right_cursor] = left[left_cursor] left_cursor += 1 else: merged[left_cursor + right_cursor] = right[right_cursor] right_cursor += 1 for left_cursor in range(left_cursor, len(left)): merged[left_cursor + right_cursor] = left[left_cursor] for right_cursor in range(right_cursor, len(right)): merged[left_cursor + right_cursor] = right[right_cursor] ``` Implement the `merge_sort` function along with its helper `merge` function to meet the requirements specified above.","solution":"def merge_sort(arr: list) -> list: Sorts an array of integers using the merge sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: A sorted list of integers. if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left: list, right: list) -> list: Merges two sorted subarrays into a single sorted array. Parameters: left (list): The left subarray. right (list): The right subarray. Returns: list: A merged sorted array. merged = [] left_cursor, right_cursor = 0, 0 while left_cursor < len(left) and right_cursor < len(right): if left[left_cursor] <= right[right_cursor]: merged.append(left[left_cursor]) left_cursor += 1 else: merged.append(right[right_cursor]) right_cursor += 1 # Append remaining elements if any merged.extend(left[left_cursor:]) merged.extend(right[right_cursor:]) return merged"},{"question":"# Context You are given a singly linked list and need to swap every two adjacent nodes in the list. The goal is to perform the operation in-place using only constant space. # Problem Statement Write a function `swap_pairs(head)` that takes as input the head of a singly linked list and returns the head of the list after swapping every pair of adjacent nodes. # Input - `head`: A `Node` object representing the head of a singly linked list. Each `Node` has two attributes: - `val`: The integer value stored in the node. - `next`: A reference to the next node in the list or `None`. # Output - Returns the `Node` object representing the head of the modified list where every two adjacent nodes are swapped. # Constraints - The algorithm should only use constant extra space. - Only the nodes themselves may be changed and not the values within the nodes. # Example ```python class Node(object): def __init__(self, x): self.val = x self.next = None def print_list(head): while head: print(head.val, end=\\"->\\") head = head.next print(\\"None\\") # Example usage: # Creating a linked list 1->2->3->4 head = Node(1) head.next = Node(2) head.next.next = Node(3) head.next.next.next = Node(4) print(\\"Original list:\\") print_list(head) head = swap_pairs(head) print(\\"Modified list:\\") print_list(head) ``` **Expected Output** ``` Original list: 1->2->3->4->None Modified list: 2->1->4->3->None ``` Write the specified function `swap_pairs(head)` below: ```python def swap_pairs(head): if not head: return head start = Node(0) start.next = head current = start while current.next and current.next.next: first = current.next second = current.next.next first.next = second.next current.next = second current.next.next = first current = current.next.next return start.next ```","solution":"class Node(object): def __init__(self, x): self.val = x self.next = None def swap_pairs(head): if not head: return head start = Node(0) start.next = head current = start while current.next and current.next.next: first = current.next second = current.next.next first.next = second.next current.next = second current.next.next = first current = current.next.next return start.next"},{"question":"# Binary Tree Preorder Traversal Context You are given a binary tree, and your task is to implement a preorder traversal of this tree. Preorder traversal is a type of depth-first traversal where the root node is processed first, followed by the left subtree, and then the right subtree. Objective Write a function `preorder_traversal` that accepts the root of a binary tree and returns a list of values of nodes visited in preorder. # Function Signature ```python def preorder_traversal(root: Node) -> list: pass ``` # Input and Output **Input:** - `root` (Node): The root of the binary tree. **Output:** - Returns a list of integers representing the node values in preorder. # Constraints - The number of nodes in the tree is in the range `[0, 10^4]`. - `-10^4 <= Node.val <= 10^4` # Example ```python # Example tree: # 1 # / # 2 3 # / # 4 5 6 root = Node(1, Node(2, Node(4), Node(5)), Node(3, None, Node(6))) assert preorder_traversal(root) == [1, 2, 4, 5, 3, 6] ``` # Notes - You can assume that the `Node` class is provided with the following structure: ```python class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - Your solution should take into account performance and ensure that it handles large trees efficiently.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def preorder_traversal(root: Node) -> list: Returns the values of the nodes visited in preorder traversal of the binary tree. Preorder traversal: root -> left -> right if root is None: return [] result = [] stack = [root] while stack: node = stack.pop() if node: result.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return result"},{"question":"You are given a binary tree, and the task is to invert it such that the left and right children of all nodes are swapped. # Function Signature ```python def invert_tree(root: TreeNode) -> TreeNode: ``` # Inputs and Outputs **Input**: - `root`: TreeNode, the root of the binary tree. **Output**: - TreeNode, root of the inverted binary tree. # Constraints - The number of nodes in the tree will be in the range [0, 1000]. - The values of the binary tree nodes are within the range [-1000, 1000]. # Example Example 1: ``` Input: 4 / 2 7 / / 1 3 6 9 Output: 4 / 7 2 / / 9 6 3 1 ``` Example 2: ``` Input: 2 / 1 3 Output: 2 / 3 1 ``` # Context You are developing a utility for a graphical editor that manipulates hierarchical structures. Inversion of hierarchical trees is a common requirement to achieve symmetrical layouts. Write robust code to handle such tree manipulations. # Notes - You can assume the input tree is well-formed and follows binary tree properties. - The changes should be done in-place with the original tree structure altered and returned.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_tree(root: TreeNode) -> TreeNode: if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the children invert_tree(root.left) invert_tree(root.right) return root"},{"question":"Implement a function `improved_bitonic_sort` that sorts an array using the Bitonic Sort algorithm. Your function should handle arrays that are not of size power of two by padding them with a high-value sentinel element (e.g., float(\'inf\')) until they reach the next power of two. Additionally, optimize the merge step to run more efficiently in a non-parallel context. # Function Signature ```python def improved_bitonic_sort(arr: list, reverse: bool = False) -> list: pass ``` # Inputs - `arr` (list): A list of elements to be sorted. It can be of any length. - `reverse` (bool): A flag to determine the sorting order. `False` for ascending and `True` for descending order. # Outputs - **Return**: A sorted list in the specified order (ascending if `reverse=False`, descending if `reverse=True`). # Constraints - The elements in the array can be integers or floating-point numbers. - Handle arrays of any length by padding with a high-value sentinel element to make the length a power of two. # Performance Requirements - Optimize the S-bitonic_merge operation to run efficiently without excessive recursion depth or high space complexity. # Example ```python # Example 1 input_array = [3, 7, 2, 5, 1] sorted_array = improved_bitonic_sort(input_array, reverse=False) print(sorted_array) # Output should be a sorted list in ascending: [1, 2, 3, 5, 7] # Example 2 input_array = [3, 7, 2, 5, 1, 9] sorted_array = improved_bitonic_sort(input_array, reverse=True) print(sorted_array) # Output should be a sorted list in descending: [9, 7, 5, 3, 2, 1] ``` # Note Ensure your solution efficiently handles edge cases, optimizes the merge steps, and manages space complexity where possible.","solution":"import math def next_power_of_two(n): Return the next power of two greater than or equal to n. return 1 << (n - 1).bit_length() def bitonic_compare_and_swap(arr, i, j, direction): if (direction == (arr[i] > arr[j])): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 for i in range(low, low + k): bitonic_compare_and_swap(arr, i, i + k, direction) bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 bitonic_sort(arr, low, k, True) bitonic_sort(arr, low + k, k, False) bitonic_merge(arr, low, cnt, direction) def improved_bitonic_sort(arr, reverse=False): n = len(arr) next_pow2 = next_power_of_two(n) sentinel = float(\'inf\') padded_arr = arr + [sentinel] * (next_pow2 - n) bitonic_sort(padded_arr, 0, next_pow2, not reverse) # Remove sentinel values sorted_arr = [x for x in padded_arr if x != sentinel] if reverse: sorted_arr.sort(reverse=True) # Ensure fully sorted in descending order return sorted_arr"},{"question":"# Radix Sort Optimization and Extension Problem Description: You are tasked with enhancing and testing the Radix Sort algorithm by handling negative numbers alongside positive integers. The function should efficiently sort a list containing both non-negative and negative integers. Requirements: 1. **Input**: A list of integers `arr` which can include both positive and negative numbers. 2. **Output**: A sorted list of integers in non-decreasing order. 3. **Constraints**: * The list can have up to (10^6) elements. * Each integer will be in the range ([-10^9, 10^9]). 4. **Performance**: Must run within O(nk) time complexity and O(n + k) space complexity for appropriate performance with constraints. Implementation Steps: 1. Implement `optimized_radix_sort(arr)` which sorts the list. 2. Handle both positive and negative integers correctly and efficiently. # Function Signature ```python def optimized_radix_sort(arr: list[int]) -> list[int]: pass ``` # Example ```python assert optimized_radix_sort([170, 45, 75, -90, -802, 24, 2, 66]) == [-802, -90, 2, 24, 45, 66, 75, 170] assert optimized_radix_sort([]) == [] assert optimized_radix_sort([-5, -2, -1, -7]) == [-7, -5, -2, -1] ```","solution":"def optimized_radix_sort(arr): def counting_sort(arr, exp, base=10): n = len(arr) output = [0] * n count = [0] * base # Count occurrences for i in arr: index = abs(i) // exp count[index % base] += 1 # Change count[i] to be counted as position for i in range(1, base): count[i] += count[i - 1] # Build output array for i in range(n - 1, -1, -1): index = abs(arr[i]) // exp output[count[index % base] - 1] = arr[i] count[index % base] -= 1 # Copy output to original array for i in range(n): arr[i] = output[i] if not arr: return arr max_val = max(abs(num) for num in arr) exp = 1 while max_val // exp > 0: counting_sort(arr, exp) exp *= 10 negatives = [num for num in arr if num < 0] positives = [num for num in arr if num >= 0] return negatives[::-1] + positives"},{"question":"Binary Search for Last Occurrence You are provided with a sorted array of integers and a target integer value. Your task is to write a function `find_last_occurrence` that uses binary search to find the index of the last occurrence of the target value in the array. If the target value is not found, the function should return -1. # Input: * An array of integers `arr` sorted in increasing order. * An integer `target` which represents the number you need to find the last occurrence of. # Output: * Return an integer representing the index of the last occurrence of `target` in the array. If the target is not found, return -1. # Constraints: * The array length ( n ) will be in the range [1, 10^5]. * The elements of the array ( arr[i] ) will be in the range [-10^5, 10^5]. * The array will be sorted in **increasing order**. # Examples: 1. **Input**: `arr = [1, 2, 2, 2, 3, 4, 5]`, `target = 2` **Output**: `3` **Explanation**: The last occurrence of 2 is at index 3. 2. **Input**: `arr = [1, 2, 3, 4, 5]`, `target = 6` **Output**: `-1` **Explanation**: The target 6 is not present in the array, thus return -1. 3. **Input**: `arr = [1, 1, 1, 1, 1]`, `target = 1` **Output**: `4` **Explanation**: The last occurrence of 1 is at index 4. 4. **Input**: `arr = [5, 10, 10, 15, 20]`, `target = 10` **Output**: `2` **Explanation**: The last occurrence of 10 is at index 2. # Function Signature: ```python def find_last_occurrence(arr: list[int], target: int) -> int: # Your code here ``` # Notes: * Ensure to handle edge cases such as when the array is empty or when the target is not present in the array. * Try to maintain the performance efficiency of O(log n) time complexity.","solution":"def find_last_occurrence(arr, target): Uses binary search to find the last occurrence of target in a sorted array. Returns the index of the last occurrence, or -1 if the target is not found. low, high = 0, len(arr) - 1 result = -1 while low <= high: mid = (low + high) // 2 if arr[mid] == target: result = mid low = mid + 1 # Continue searching in right half elif arr[mid] < target: low = mid + 1 else: high = mid - 1 return result"},{"question":"# ZigZag Iterator for Multiple Lists You are required to implement a `ZigzagIterator` class which takes multiple lists as input and allows iteration over these lists in a zigzag fashion. # Detailed Functionality: 1. **Initialization**: - The constructor will initialize with multiple lists and store non-empty lists for the iteration. 2. **next()**: - This method should return the next element in the zigzag sequence from the lists. - If there are no more elements to return, it should raise an appropriate error or return a default value (e.g., `None`). 3. **has_next()**: - This method should return a boolean indicating whether there are any more elements to iterate. # Input: - Constructor: `__init__(*args)` takes variable number of lists `*args`. - `next()`: No input. - `has_next()`: No input. # Output: - `next()`: Returns the next element in the zigzag pattern or raises an error when iteration is complete. - `has_next()`: Returns `True` if there are more elements, otherwise `False`. # Constraints: - There can be up to `1000` lists, and each list can have up to `1000` elements. - Elements of the lists will be integers within the range of `-10^6` to `10^6`. # Example: ```python l1 = [1, 2, 3] l2 = [4, 5, 6] l3 = [7, 8] it = ZigzagIterator(l1, l2, l3) while it.has_next(): print(it.next()) # Expected Output: # 1, 4, 7, 2, 5, 8, 3, 6 ``` Implement the `ZigzagIterator` class with the described functionality.","solution":"from collections import deque class ZigzagIterator: def __init__(self, *args): Initialize with multiple lists and store them in deque for taking turns during iteration. self.queue = deque([deque(lst) for lst in args if lst]) def next(self): Return the next element in the zigzag pattern. If there are no more elements, should raise a StopIteration error. if not self.has_next(): raise StopIteration curr_list = self.queue.popleft() next_elem = curr_list.popleft() if curr_list: self.queue.append(curr_list) return next_elem def has_next(self): Return True if there are more elements, otherwise False. return bool(self.queue)"},{"question":"You are given an array of integers and two optional integer limits, `min_lim` and `max_lim`. Implement a function `limit(arr, min_lim, max_lim)` that filters the elements of the array such that only the elements within the provided range are included in the result. The results should include: - Elements greater than or equal to `min_lim` (if `min_lim` is provided). - Elements less than or equal to `max_lim` (if `max_lim` is provided). If `min_lim` is `None`, the function should treat the minimum limit as the smallest integer in the array. Similarly, if `max_lim` is `None`, the function should treat the maximum limit as the largest integer in the array. If both are `None`, the original array should be returned. Your task is to implement this function and ensure it handles all edge cases effectively. # Function Signature ```python def limit(arr: list[int], min_lim: int = None, max_lim: int = None) -> list[int]: ``` # Input - `arr`: List of integers (1 <= len(arr) <= 10^5) - `min_lim`: Optional integer, setting the minimum value inclusive. - `max_lim`: Optional integer, setting the maximum value inclusive. # Output - A list of integers filtered between `min_lim` and `max_lim`. # Constraints - Minimum and maximum limits (`min_lim`, `max_lim`) are optional. - The integers in arrays are within the range of -10^9 to 10^9. # Example ```python assert limit([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert limit([1, 2, 3, 4, 5], 2, None) == [2, 3, 4, 5] assert limit([1, 2, 3, 4, 5], 2, 3) == [2, 3] assert limit([], None, 3) == [] ``` # Additional Context Your solution should efficiently handle arrays of large sizes and correctly process any provided limits or their absence. Consider edge cases like empty arrays, all elements within or outside the range, and invalid ranges.","solution":"def limit(arr, min_lim=None, max_lim=None): Filters the elements of the array such that only the elements within the provided range are included in the result. Parameters: arr (list of int): List of integers to filter. min_lim (int, optional): Minimum limit (inclusive). Defaults to the smallest integer in the array if not provided. max_lim (int, optional): Maximum limit (inclusive). Defaults to the largest integer in the array if not provided. Returns: list of int: Filtered list of integers within the specified range. if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"# Graph Clone Question **Scenario**: Suppose you are working on a project that involves manipulating various network topologies represented as undirected graphs. You need to create a method to clone an entire undirected graph to work with a separate copy without affecting the original. **Task**: Write a Python function `clone_graph_method(node, method=\\"bfs\\")` to clone the given graph using one of the following methods: - Breadth-First Search (BFS). - Iterative Depth-First Search (DFS). - Recursive Depth-First Search (DFS). Your function should choose the respective traversal method based on the `method` parameter, which defaults to \\"bfs\\". # Function Signature ```python def clone_graph_method(node, method=\\"bfs\\"): pass ``` # Inputs - `node`: An instance of `UndirectedGraphNode` representing the starting node of the graph. - `method`: A string (\\"bfs\\", \\"iterative_dfs\\", or \\"recursive_dfs\\") specifying the type of traversal to use for cloning. # Output - Returns a deep copy of the graph beginning from the given node. # Constraints - All node labels are unique. - Each node can appear at most once in the list of nodes. - The node can have from 0 to multiple neighbors. # Example ```python # Given a graph serialized as {0,1,2#1,2#2,2} and using BFS cloning: node = deserialize_graph(\\"{0,1,2#1,2#2,2}\\") cloned_node = clone_graph_method(node, method=\\"bfs\\") # cloned_node should be a deep copy of the original graph with the same structure. ``` **You may assume the necessary class `UndirectedGraphNode` and helper methods for graph deserialization are provided.**","solution":"class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def clone_graph_method(node, method=\\"bfs\\"): if not node: return None def bfs_clone(node): from collections import deque queue = deque([node]) clones = {node: UndirectedGraphNode(node.label)} while queue: current = queue.popleft() for neighbor in current.neighbors: if neighbor not in clones: clones[neighbor] = UndirectedGraphNode(neighbor.label) queue.append(neighbor) clones[current].neighbors.append(clones[neighbor]) return clones[node] def iterative_dfs_clone(node): stack = [node] clones = {node: UndirectedGraphNode(node.label)} while stack: current = stack.pop() for neighbor in current.neighbors: if neighbor not in clones: clones[neighbor] = UndirectedGraphNode(neighbor.label) stack.append(neighbor) clones[current].neighbors.append(clones[neighbor]) return clones[node] def recursive_dfs_clone(node): clones = {} def dfs(node): if node in clones: return clones[node] clone = UndirectedGraphNode(node.label) clones[node] = clone for neighbor in node.neighbors: clone.neighbors.append(dfs(neighbor)) return clone return dfs(node) if method == \\"bfs\\": return bfs_clone(node) elif method == \\"iterative_dfs\\": return iterative_dfs_clone(node) elif method == \\"recursive_dfs\\": return recursive_dfs_clone(node) else: raise ValueError(\\"Unsupported cloning method: \\" + method)"},{"question":"Context: You are developing a web application that needs to transmit lists of strings between the server and client. To ensure this process is efficient and preserves the original data structure, you need to implement two functions: `encode` and `decode`. The first function will encode a list of strings to a single string suitable for network transmission, and the second function will decode it back to the original list. Task: Write two functions, `encode` and `decode`, following the specified input and output formats below: **encode**: ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str # Implement your encode logic here ``` **decode**: ```python def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] # Implement your decode logic here ``` Requirements: 1. `encode`: * Input: List of strings (`List[str]`). * Output: A single encoded string (`str`). 2. `decode`: * Input: A single encoded string (`str`). * Output: List of strings (`List[str]`). 3. Constraints: * Each string in the input list contains any characters, including the delimiter `:`. * The list can be empty (but not `None`). * Assume the encoded string will be properly formatted according to your encoding logic. 4. Performance: * Efficient handling of lists containing up to 10^5 strings each with a length up to 10^3 characters. Sample Usage: ```python strings = [\\"hello\\", \\"world\\"] encoded_str = encode(strings) # encoded_str should be \\"5:hello5:world\\" decoded_list = decode(encoded_str) # decoded_list should be [\\"hello\\", \\"world\\"] ``` Additional Considerations: Make sure to handle edge cases such as: * An empty list of input strings. * Strings containing the delimiter `:` within them. * Ensure `encode` and `decode` processes are inverses, i.e., `decode(encode(x)) == x`.","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] i, n = 0, len(s) result = [] while i < n: j = s.find(\':\', i) length = int(s[i:j]) i = j + 1 + length result.append(s[j+1:i]) return result"},{"question":"# Unique Subsets Generation **Problem Statement**: Given a collection of integers that might contain duplicates, `nums`, write a function to return all possible unique subsets. The solution set must not contain duplicate subsets. # Function Signature: ```python def unique_subsets(nums: List[int]) -> List[List[int]]: pass ``` # Input: * A list of integers, `nums` (0 ≤ len(nums) ≤ 10), where each integer can range from -10 to 10. * The integers in `nums` may contain duplicates. # Output: * A list of lists containing all unique subsets sorted in ascending order. * Each subset should be sorted in ascending order, and the list of subsets should also be sorted lexicographically. # Performance: * Ensure that your solution avoids generating duplicate subsets. * Aim for a time complexity of O(2^n) where n is the length of the input list. * Minimize memory usage where possible. # Example: ```python Input: nums = [1, 2, 2] Output: [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]] ``` # Constraints: 1. The output should not contain duplicate subsets. 2. Each subset should be sorted in ascending order. 3. The list of subsets should be sorted in lexicographical order. # Scenario: Imagine you are developing a system that needs to generate all possible unique combinations of settings from a given list, potentially with duplicates. This function will help to automate the generation of these combinations ensuring that no combination is repeated.","solution":"from typing import List def unique_subsets(nums: List[int]) -> List[List[int]]: Returns all possible unique subsets of the given list of integers. The solution set must not contain duplicate subsets and both subsets and the list of subsets should be sorted in ascending and lexicographical order respectively. nums.sort() # Sort nums to handle duplicates and ensure sorted subsets result = [[]] for num in nums: new_subsets = [] for subset in result: new_subset = subset + [num] if new_subset not in result: # Check to avoid duplicates new_subsets.append(new_subset) result.extend(new_subsets) # Sorting the final list of subsets lexicographically result = sorted([sorted(subset) for subset in result]) return result"},{"question":"# Question: Implement an Optimized Radix Sort Function You are required to implement an optimized version of the Radix Sort algorithm that can handle sorting a list of integers efficiently. This function should consider edge cases and handle various input scenarios gracefully. Function Signature ```python def optimized_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` Input * `arr`: A list of non-negative integers. * `simulation`: A boolean flag indicating whether to print the intermediate sorting steps. Output * The function should return a sorted list of integers. Constraints * The input list will have at most (10^5) integers. * Each integer will be in the range [0, (10^9)]. Performance Requirements * Your implementation should have a time complexity of (O(nk)) where (n) is the number of integers in the list and (k) is the number of digits in the maximum integer. Example ```python # Example 1: Typical case arr = [170, 45, 75, 90, 802, 24, 2, 66] print(optimized_radix_sort(arr)) # Output: [2, 24, 45, 66, 75, 90, 170, 802] # Example 2: Small list with identical numbers arr = [5, 5, 5, 5] print(optimized_radix_sort(arr)) # Output: [5, 5, 5, 5] # Example 3: Large range of numbers arr = [1000000000, 5, 4321, 789, 1234] print(optimized_radix_sort(arr)) # Output: [5, 789, 1234, 4321, 1000000000] ``` **Note**: Ensure proper handling of edge cases such as empty lists and lists with elements having various digit lengths. The `simulation` parameter, if set to `True`, should print intermediate steps demonstrating the sorting process at each digit iteration.","solution":"from typing import List def optimized_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: if not arr: return [] max_num = max(arr) exp = 1 base = 10 while max_num // exp > 0: count = [0] * base output = [0] * len(arr) for num in arr: index = (num // exp) % base count[index] += 1 for i in range(1, base): count[i] += count[i - 1] for num in reversed(arr): index = (num // exp) % base output[count[index] - 1] = num count[index] -= 1 if simulation: print(f\\"After sorting with exp={exp}: {output}\\") arr = output exp *= base return arr"},{"question":"# Task Implement advanced functions for converting between integers and their byte representations in both big-endian and little-endian formats, ensuring efficient handling of both positive and negative integers. # Background You are given a system dealing with different formats of byte representations. For data interoperability, you need to extend the existing conversion functions to handle negative integers efficiently and ensure no overflow issues occur. # Requirements 1. Write a function `int_to_bytes_big_endian_signed(num: int) -> bytes` that converts an integer to its big-endian byte representation considering both positive and negative integers. 2. Write a function `int_to_bytes_little_endian_signed(num: int) -> bytes` that converts an integer to its little-endian byte representation accounting for positive and negative integers. 3. Implement corresponding functions `bytes_big_endian_to_int_signed(bytestr: bytes) -> int` and `bytes_little_endian_to_int_signed(bytestr: bytes) -> int` to convert back from byte representations to integers. # Detailed Expectations * Both `int_to_bytes_big_endian_signed` and `int_to_bytes_little_endian_signed` should handle: * Positive and negative integers. * Corner cases where integers are zero or within small byte range. * Both `bytes_big_endian_to_int_signed` and `bytes_little_endian_to_int_signed` should: * Correctly interpret the byte order. * Return integers including negative values if encoded in the byte array. # Constraints * Testing will be conducted on 32-bit and 64-bit integers. * Performance optimized for handling large integers up to the system\'s maximum size. # Example ```python assert int_to_bytes_big_endian_signed(-123456) == b\'xffxfexdc@\' assert int_to_bytes_little_endian_signed(-123456) == b\'@xfexffxff\' assert bytes_big_endian_to_int_signed(b\'xffxfexdc@\') == -123456 assert bytes_little_endian_to_int_signed(b\'@xfexffxff\') == -123456 ```","solution":"def int_to_bytes_big_endian_signed(num: int) -> bytes: if num == 0: return b\'x00\' num_bits = (num.bit_length() + 1 + 7) // 8 * 8 # nearest multiple of 8 bits return num.to_bytes(num_bits // 8, byteorder=\'big\', signed=True) def int_to_bytes_little_endian_signed(num: int) -> bytes: if num == 0: return b\'x00\' num_bits = (num.bit_length() + 1 + 7) // 8 * 8 # nearest multiple of 8 bits return num.to_bytes(num_bits // 8, byteorder=\'little\', signed=True) def bytes_big_endian_to_int_signed(bytestr: bytes) -> int: return int.from_bytes(bytestr, byteorder=\'big\', signed=True) def bytes_little_endian_to_int_signed(bytestr: bytes) -> int: return int.from_bytes(bytestr, byteorder=\'little\', signed=True)"},{"question":"<|Analysis Begin|> # Algorithm Analysis: sum_dig_pow Function Core Identification * **Algorithm/Data Structure**: This function involves an algorithm that identifies numbers where the sum of their digits raised to consecutive powers equals the number itself. * **Type**: Number Property Identification * **Purpose**: To find and return a list of numbers within a given range (inclusive) that satisfy a specific mathematical property. Complexity * **Time Complexity**: (O(n cdot d)), where (n) is the number of integers between `low` and `high` and (d) is the number of digits in those numbers. Each number is converted to a string and its digits processed sequentially. * **Space Complexity**: (O(1)) additional space apart from the output list, since the space required for variables and intermediate calculations grows linearly with the input size. Principles * For each number in the given range, the function: 1. Splits the number into its individual digits. 2. Raises each digit to a power corresponding to its position (starting from 1). 3. Sums these powered digits. 4. Checks if this sum equals the original number, and if so, appends the number to the result list. Characteristics & Applications * **Properties**: The function checks a unique mathematical property based on digit positions and powers. * **Common Use Cases**: Identifying numbers with such a property can be useful in mathematical puzzles, recreational programming, and number theory studies. * **Strengths/Limitations**: * Strengths: Simple implementation, direct approach to solve the problem. * Limitations: The algorithm processes each digit individually and sequentially, which can be time-consuming for very large ranges. Implementation Challenges * **Edge Cases**: * Very small ranges (e.g., range of `1`). * Large numbers (handling digit count and potential overflows). * **Performance Bottlenecks**: * Summation of digits as individual operations. * Repeated conversion of numbers to strings can be inefficient for large ranges, leading to increased run time. * **Error Scenarios**: * Incorrect handling of the range bounds (e.g., if `low > high`). * Potential integer overflow for very large numbers (though Python handles large integers natively). * **Optimization Points**: * Pre-compute digit lists or utilize more efficient digit extraction methods. <|Analysis End|> <|Question Begin|> # Digital Powers Summation Problem Statement The number 89 is the first integer with more than one digit whose digits, when raised up to consecutive powers, equal the number itself (e.g., 89 = 8**1 + 9**2). The next number with this property is 135 = 1**1 + 3**2 + 5**3. Write a function `sum_dig_pow(low, high)` that returns a list of all numbers within the range `[low, high]` (inclusive) that satisfy this property. Function Signature ```python def sum_dig_pow(low: int, high: int) -> List[int]: ``` Input * `low` (int): Lower bound of the range (inclusive), (1 leq low leq 10^6). * `high` (int): Upper bound of the range (inclusive), (low leq high leq 10^6). Output * List of integers within the given range that satisfy the property. Constraints * You must handle large ranges efficiently. * The algorithm should return results within reasonable time for maximum constraints. Example ```python assert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert sum_dig_pow(90, 150) == [135] ``` # Detailed Requirements 1. Implement the function according to the provided signature. 2. Ensure the function handles at least the lower edge cases (e.g., `low = 1, high = 1`) and upper edge cases (e.g., `low = 1000000, high = 1000000`). 3. Optimize for both time and space complexity where feasible. Additional Notes * Consider the efficiency of number-to-digit conversions. * Edge cases and error handling should be managed appropriately within the function. * Thoroughly test the function against various ranges and scenarios to ensure correctness.","solution":"from typing import List def sum_dig_pow(low: int, high: int) -> List[int]: Returns a list of numbers between low and high (inclusive) that are equal to the sum of their digits raised to the consecutive powers. def is_eureka_number(n: int) -> bool: digits = list(map(int, str(n))) return n == sum(d**(i+1) for i, d in enumerate(digits)) return [x for x in range(low, high + 1) if is_eureka_number(x)]"},{"question":"# Interactive String Merge Validation In this task, you will implement a function to determine if a given string `s` can be formed by merging characters from two strings `part1` and `part2` such that their characters are in the same order as in `s`. Function Signature ```python def is_merge(s: str, part1: str, part2: str) -> bool: pass ``` Input * `s`: A string of length `n` ( (0 leq n leq 1000) ). * `part1`: A string of length `m` ( (0 leq m leq 500) ) such that ( m leq n ). * `part2`: A string of length `k` ( (0 leq k leq 500) ) such that ( k leq n ). Output Return `True` if `s` can be formed by merging `part1` and `part2` while preserving the character order in both parts. Otherwise, return `False`. Constraints * All characters involved are English lowercase letters. Example ```python assert is_merge(\'codewars\', \'cdw\', \'oears\') == True assert is_merge(\'abc\', \'abc\', \'\') == True assert is_merge(\'abc\', \'\', \'abc\') == True assert is_merge(\'abc\', \'ab\', \'cd\') == False assert is_merge(\'abc\', \'a\', \'bc\') == True ``` Notes * The function `is_merge` should handle both small and large input sizes efficiently. * Think about optimizing the solution to avoid redundant computations. * You can choose to implement this iteratively or recursively. Avoid stack overflow issues in recursion for large inputs by adding memoization techniques if necessary.","solution":"def is_merge(s: str, part1: str, part2: str) -> bool: Determines if the string s can be formed by interleaving part1 and part2 in the same order. # If the combined length of part1 and part2 is not equal to s, return False if len(s) != len(part1) + len(part2): return False # Dynamic programming approach to solve the merging problem dp = [[False] * (len(part2) + 1) for _ in range(len(part1) + 1)] dp[0][0] = True for i in range(len(part1) + 1): for j in range(len(part2) + 1): if i > 0 and s[i + j - 1] == part1[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] if j > 0 and s[i + j - 1] == part2[j - 1]: dp[i][j] = dp[i][j] or dp[i][j - 1] return dp[len(part1)][len(part2)]"},{"question":"Context You are implementing a data preprocessing function for an application that requires cleaning up stack-based data structures. One specific requirement is to remove the smallest value from a given stack while retaining other elements in their original order. Task Write a function `remove_min(stack)` which accepts a list representing a stack and removes the smallest value. Assume the stack follows Last-In-First-Out (LIFO) order where the last element in the list is the top of the stack. The function should modify the stack in place and return it. Input - A list `stack` representing a stack with integers (can be negative). Output - The same list `stack` with the smallest element removed. Constraints - No inbuilt Python functions (like `min()` or `list.remove()`) that directly find and remove elements in the collections. - You are allowed to use additional storage. Performance Requirements - The function should maintain a time complexity of O(n). - The space complexity can be up to O(n). Examples ```python # Example 1: stack = [2, 8, 3, -6, 7, 3] remove_min(stack) # Expected after function call: # stack = [2, 8, 3, 7, 3] # Example 2: stack = [10, 12, 5, 1, 5, 1] remove_min(stack) # Expected after function call: # stack = [10, 12, 5, 5, 1] # Example 3: stack = [] remove_min(stack) # Expected after function call: # stack = [] # Example 4: stack = [1] remove_min(stack) # Expected after function call: # stack = [] ```","solution":"def remove_min(stack): Removes the smallest value from the stack while maintaining the order of other elements. :param stack: list of integers representing the stack (LIFO). :return: Modified stack with the smallest element removed. if not stack: return stack # First, find the minimum value in the stack min_value = stack[0] for item in stack: if item < min_value: min_value = item # Next, we need to remove the first occurrence of this minimum value while maintaining order new_stack = [] min_value_removed = False for item in stack: if item == min_value and not min_value_removed: min_value_removed = True else: new_stack.append(item) # Clear the original stack and repopulate with new_stack elements stack.clear() stack.extend(new_stack) return stack"},{"question":"# Randomized Set Data Structure Implementation Problem Description You are tasked with designing a data structure `RandomizedSet` that supports the following operations: 1. **Insert** `insert(val)`: Inserts a value `val` to the set if it is not already present. 2. **Remove** `remove(val)`: Removes a value `val` from the set if it is present. 3. **Random Element** `random_element()`: Returns a random element from the current set of elements. Each element must have an equal probability of being returned. Requirements - The operations `insert`, `remove`, and `random_element` must all have average O(1) time complexity. - The data structure should handle all typical edge cases gracefully (e.g., inserting an already existing element or removing an element not present in the set). Implementation Details - **Input**: - For `insert`, an integer `val`. - For `remove`, an integer `val`. - For `random_element`, no input. - **Output**: - For `insert` and `remove`, no return value (modify the set in place). - For `random_element`, return an integer that is randomly picked from the set. Constraints - Data elements are guaranteed to be non-negative integers. - The maximum number of elements n is 10^5. # Example: ```python r_set = RandomizedSet() r_set.insert(1) # Inserts 1 to the set r_set.insert(2) # Inserts 2 to the set print(r_set.random_element()) # Randomly outputs either 1 or 2 r_set.remove(1) # Removes 1 from the set print(r_set.random_element()) # Outputs 2 r_set.insert(2) # No effect as 2 is already in the set ``` Implementation Implement the `RandomizedSet` class with `insert`, `remove`, and `random_element` methods in Python. ```python import random class RandomizedSet: def __init__(self): self.elements = [] self.index_map = {} # element -> index def insert(self, val): if val in self.index_map: return self.index_map[val] = len(self.elements) self.elements.append(val) def remove(self, val): if val not in self.index_map: return index = self.index_map[val] last = self.elements.pop() self.index_map.pop(val) if index == len(self.elements): return self.elements[index] = last self.index_map[last] = index def random_element(self): return random.choice(self.elements) ``` Ensure to test your implementation thoroughly, considering all edge cases and constraints.","solution":"import random class RandomizedSet: def __init__(self): self.elements = [] self.index_map = {} # element -> index def insert(self, val): if val in self.index_map: return False # Indicate that the value was already present and not inserted self.index_map[val] = len(self.elements) self.elements.append(val) return True # Indicate successful insertion def remove(self, val): if val not in self.index_map: return False # Indicate that the value was not present and not removed index = self.index_map[val] last = self.elements[-1] self.elements[index] = last self.index_map[last] = index self.elements.pop() del self.index_map[val] return True # Indicate successful removal def random_element(self): return random.choice(self.elements)"},{"question":"# Problem: Arbitrary-Precision Multiplication Context You are given two non-negative integers represented as strings. Your task is to multiply them and return the result as a string, simulating how humans would perform long-hand multiplication but with potentially very large numbers that can\'t be handled directly by converting to integers. Instructions Write a function `multiply(num1: str, num2: str) -> str` that takes two non-negative integers represented as strings (`num1` and `num2`), multiply them, and return the result as a string without converting the input strings directly to integers and without using any built-in `BigInteger` library. You should implement the multiplication manually. Input * `num1`: A string representing a non-negative integer. * `num2`: A string representing a non-negative integer. Output * A string representing the product of `num1` and `num2`. Constraints * The length of both `num1` and `num2` is less than 110. * `num1` and `num2` contain only digits (\'0\'-\'9\'). * `num1` and `num2` do not contain any leading zeros. Example ```python assert multiply(\\"123\\", \\"456\\") == \\"56088\\" assert multiply(\\"0\\", \\"1234\\") == \\"0\\" assert multiply(\\"999\\", \\"999\\") == \\"998001\\" ``` Notes * Be mindful of edge cases such as multiplication with zero and management of positional digits. * Ensure no leading zeros in the output result unless the result itself is zero. # Function Signature ```python def multiply(num1: str, num2: str) -> str: pass ```","solution":"def multiply(num1: str, num2: str) -> str: Multiplies two non-negative integers provided as strings and returns the product as a string. if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" # Initialize result list of zeros result = [0] * (len(num1) + len(num2)) # Reverse the strings to facilitate position-based multiplication num1, num2 = num1[::-1], num2[::-1] # Perform multiplication digit by digit for i in range(len(num1)): for j in range(len(num2)): result[i + j] += int(num1[i]) * int(num2[j]) result[i + j + 1] += result[i + j] // 10 # Carry over the tens result[i + j] %= 10 # Keep only the unit digit # Convert result back to string and remove leading zeros while len(result) > 1 and result[-1] == 0: result.pop() return \'\'.join(map(str, result[::-1]))"},{"question":"# Ternary Search Challenge Context You are given a sorted list of integers, and you need to implement a function to determine the position of a specific key using the Ternary Search algorithm. Your implementation should be efficient and consider edge cases. Function Signature ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: pass ``` Parameters - **left** (`int`): The starting index of the list (generally `0`). - **right** (`int`): The ending index of the list (generally `len(arr) - 1`). - **key** (`int`): The target integer value to search for in the list. - **arr** (`List[int]`): The list of integers sorted in ascending order. Returns - An `int` indicating the index of the `key` in the list. - Returns `-1` if the `key` is not found. Constraints - The array will not be empty. - The `key` to search will be within the possible range of integer values present in the array. - The function should run efficiently with respect to time complexity O(log₃(N)). Example ```python # Given array and key array = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] key = 9 # Calling the function result = ternary_search(0, len(array) - 1, key, array) # Expected output print(result) # Output: 4 ``` # Additional Information - Ensure to handle the edge cases properly, such as: - When `key` is not present in the list. - When the list has one element. - Optimize for performance, ensuring minimal number of comparisons.","solution":"from typing import List def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: if right >= left: mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: return ternary_search(left, mid1 - 1, key, arr) elif key > arr[mid2]: return ternary_search(mid2 + 1, right, key, arr) else: return ternary_search(mid1 + 1, mid2 - 1, key, arr) return -1"},{"question":"You are required to implement a function that computes the greatest common divisor (GCD) of two integers but with an additional twist: you should incorporate detecting efficient edge cases handling that improve the performance specifically focusing on using bitwise operations. Additionally, you need to extend the functionality to compute the least common multiple (LCM) relying on the GCD function you implemented. Given the following code snippets as guiding concepts, design and implement the functions `efficient_gcd` and `efficient_lcm` using bitwise operations and any other techniques as necessary. # Function Signature ```python def efficient_gcd(a: int, b: int) -> int: Computes the greatest common divisor (GCD) of integers \'a\' and \'b\' using efficient methods including bitwise operations. Args: a (int): First integer b (int): Second integer Returns: int: The GCD of \'a\' and \'b\' def efficient_lcm(a: int, b: int) -> int: Computes the least common multiple (LCM) of integers \'a\' and \'b\' using the efficient_gcd function. Args: a (int): First integer b (int): Second integer Returns: int: The LCM of \'a\' and \'b\' ``` # Input * Two non-negative integers `a` and `b`. # Output * Return the GCD for `efficient_gcd` and LCM for `efficient_lcm`. # Constraints * `0 <= a, b <= 10^9` # Example 1. `efficient_gcd(48, 18)` should return 6. 2. `efficient_lcm(48, 18)` should return 144. # Performance Requirements * Implement bitwise operations where effective for improving performance. * Handle large integers efficiently within given constraints. # Note * Consider special edge cases such as one or both integers being zero or negative. * Optimize for large inputs within given constraints. # Tips * Use the `trailing_zero` function concept where applicable. * Utilize Euclidean algorithm principles with bitwise operations for GCD.","solution":"def efficient_gcd(a: int, b: int) -> int: Computes the greatest common divisor (GCD) of integers \'a\' and \'b\' using efficient methods including bitwise operations. Args: a (int): First integer b (int): Second integer Returns: int: The GCD of \'a\' and \'b\' if a == 0: return b if b == 0: return a # Using the binary GCD (Stein\'s Algorithm) shift = 0 # Find the greatest power of two that divides both a and b while ((a | b) & 1) == 0: a >>= 1 b >>= 1 shift += 1 # Divide a by 2 until it becomes odd while (a & 1) == 0: a >>= 1 while b != 0: # Remove all factors of 2 in b while (b & 1) == 0: b >>= 1 # Now both a and b are odd. Swap if necessary if a > b: a, b = b, a # b is now greater or equal to a, # set b = b - a (which is even) b = b - a return a << shift def efficient_lcm(a: int, b: int) -> int: Computes the least common multiple (LCM) of integers \'a\' and \'b\' using the efficient_gcd function. Args: a (int): First integer b (int): Second integer Returns: int: The LCM of \'a\' and \'b\' if a == 0 or b == 0: return 0 gcd_value = efficient_gcd(a, b) return abs(a * b) // gcd_value"},{"question":"# Scenario: Path Normalization Utility In many real-world applications, especially those dealing with file systems, maintaining clean and absolute file paths is crucial. Paths might include user-specific shortcuts, relative paths, and need to consistently resolve to the correct absolute path regardless of variations in the environment or user inputs. # Task Write a function `normalize_path` that takes a string argument representing a file path and returns the fully expanded and absolute version of this path. Your function should: * Expand user home shortcuts (`~`). * Resolve relative paths to absolute paths. # Function Signature ```python def normalize_path(file_path: str) -> str: pass ``` # Input - `file_path` (str): A string representing the file path. It may contain user shortcuts or relative path indicators. # Output - (str): A string representing the absolute path. # Constraints - You should use the `os.path` module to handle path operations. - Do not use external libraries beyond the standard library (`os` module allowed). - Assume the input is always a non-empty string. # Examples Input: ```python normalize_path(\\"~/Documents/file.txt\\") ``` Output: ``` \\"/home/username/Documents/file.txt\\" # The output will depend on the specific user\'s home directory. ``` Input: ```python normalize_path(\\"../folder/file.txt\\") ``` Output: ``` \\"/abs/path/to/parent/folder/file.txt\\" # The output will be the absolute path considering the script\'s current working directory. ``` # Notes - Ensure your function works cross-platform, i.e., it should handle path conventions for both Windows and Unix-like systems. - Handle edge cases such as already absolute paths or invalid user shortcuts.","solution":"import os def normalize_path(file_path: str) -> str: Takes a string argument representing a file path and returns the fully expanded and absolute version of this path. Parameters: file_path (str): A string representing the file path. It may contain user shortcuts or relative path indicators. Returns: str: A string representing the absolute path. # Expand the user home shortcut if present expanded_path = os.path.expanduser(file_path) # Get the absolute path absolute_path = os.path.abspath(expanded_path) return absolute_path"},{"question":"Quick Sort Implementation and Optimization In this exercise, you need to implement the quick sort algorithm but with a focus on optimizing its performance and handling edge cases. Specifically, you are required to: 1. Implement the quick sort algorithm with a randomized pivot selection to mitigate the risk of poor performance on pre-sorted data. 2. Implement a mechanism to switch to insertion sort for small subarrays to improve overall efficiency. 3. Test for and handle edge cases such as empty arrays, arrays with a single element, and arrays with all identical elements. # Function Signature ```python def optimized_quick_sort(arr): Sorts an array using an optimized version of quick sort. pass ``` # Input - `arr`: A list of integers to be sorted. (1 <= len(arr) <= 10^5, -10^9 <= arr[i] <= 10^9) # Output - Returns a list of integers sorted in ascending order. # Constraints - The algorithm must handle large inputs efficiently with an average time complexity of O(n log(n)). - Use in-place operations to achieve optimal space complexity of O(log(n)). # Example ```python >>> optimized_quick_sort([3, 6, 8, 10, 1, 2, 1]) [1, 1, 2, 3, 6, 8, 10] >>> optimized_quick_sort([1, 1, 1, 1]) [1, 1, 1, 1] >>> optimized_quick_sort([]) [] >>> optimized_quick_sort([5]) [5] ``` # Considerations - Ensure that your algorithm correctly handles the base cases and edge cases. - Emphasize robustness and efficiency, particularly in terms of pivot selection and handling small subarrays.","solution":"import random def insertion_sort(arr, left, right): for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def partition(arr, low, high): pivot_index = random.randint(low, high) pivot = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] # Move pivot to the end i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort_recursive(arr, low, high): if low < high: if high - low < 10: # Use insertion sort for small subarrays insertion_sort(arr, low, high) else: pivot_index = partition(arr, low, high) quick_sort_recursive(arr, low, pivot_index - 1) quick_sort_recursive(arr, pivot_index + 1, high) def optimized_quick_sort(arr): if len(arr) <= 1: return arr quick_sort_recursive(arr, 0, len(arr) - 1) return arr"},{"question":"# Atbash Cipher Encryption Background: The Atbash cipher is a classical encryption method. It works by substituting each letter in the plaintext with its \\"mirror\\" counterpart from the end of the alphabet. For example, \'A\' maps to \'Z\', \'B\' to \'Y\', and so on. Non-alphabet characters in the input remain unaffected. Task: Write a function `atbash(s: str) -> str` that implements the Atbash cipher. ```python def atbash(s: str) -> str: pass ``` Requirements: - **Input Format**: - A single string \'s\' consisting of printable ASCII characters. - **Output Format**: - The transformed string after applying the Atbash cipher to each alphabet character. - **Constraints**: - The length of the input string \'s\' will be between 0 to 10000 characters. Examples: 1. **Example 1**: - Input: `\\"Attack at dawn\\"` - Output: `\\"Zggzxp zg wzdm\\"` 2. **Example 2**: - Input: `\\"Hello, World!\\"` - Output: `\\"Svool, Dliow!\\"` 3. **Example 3**: - Input: `\\"12345\\"` - Output: `\\"12345\\"` (Since there are no letters, the output remains unchanged) 4. **Example 4**: - Input: `\\"\\"` - Output: `\\"\\"` (An empty input string should return an empty output string) Explanation: For each letter in the input string, it should be transformed to its corresponding opposite letter in the alphabet while preserving the original case. Non-alphabet characters should remain unchanged. Implement this function maintaining the performance requirement, considering edge cases, and ensuring the validity of resulting ciphertext.","solution":"def atbash(s: str) -> str: Applies the Atbash cipher to the input string. def mirror_char(c): if \'a\' <= c <= \'z\': return chr(ord(\'z\') - (ord(c) - ord(\'a\'))) elif \'A\' <= c <= \'Z\': return chr(ord(\'Z\') - (ord(c) - ord(\'A\'))) else: return c return \'\'.join(mirror_char(c) for c in s)"},{"question":"# Question Context You are tasked with developing a text editor feature that provides quick feedback on whether a user\'s simple typo correction is valid. Specifically, the feedback should determine if two given strings are exactly one edit distance apart (where an edit is either inserting, deleting, or replacing a single character). Function Signature ```python def is_one_edit_distance(s: str, t: str) -> bool: :param s: first input string :param t: second input string :returns: True if they are one edit distance apart, otherwise False ``` Input - `s` (1 ≤ len(s) ≤ 10^4): A non-empty string representing the original text. - `t` (1 ≤ len(t) ≤ 10^4): A non-empty string representing the new text to be compared. Output - Return `True` if `s` and `t` are exactly one edit distance apart. - Return `False` otherwise. Constraints - Consider case sensitivity (\'a\' != \'A\'). Examples ```python assert is_one_edit_distance(\\"abc\\", \\"ab\\") == True assert is_one_edit_distance(\\"abc\\", \\"abcd\\") == True assert is_one_edit_distance(\\"abc\\", \\"abx\\") == True assert is_one_edit_distance(\\"abc\\", \\"abc\\") == False assert is_one_edit_distance(\\"abc\\", \\"abxy\\") == False ``` Performance Requirement - Your solution should run in linear time relative to the length of the shorter string `O(n)`. Task Implement the function `is_one_edit_distance` adhering to the given input/output formats and constraints. Write robust code considering all edge cases and ensure it performs efficiently for the worst-case input size.","solution":"def is_one_edit_distance(s: str, t: str) -> bool: Determines if s and t are exactly one edit distance apart. ns, nt = len(s), len(t) # Ensure that s is the shorter string if ns > nt: return is_one_edit_distance(t, s) # The strings are not one edit distance apart if their lengths differ by more than 1 if nt - ns > 1: return False for i in range(ns): if s[i] != t[i]: # If lengths are same, it must be one replacement if ns == nt: return s[i+1:] == t[i+1:] # If lengths are different, it must be one insertion else: return s[i:] == t[i+1:] # If no differences are found, the only possibility is that s is exactly one character less than t return ns + 1 == nt"},{"question":"# Scenario: You are implementing an arithmetic module for a custom calculator that handles very large numbers. You need to develop a function that can multiply two non-negative integers represented as strings. Since the built-in integer type might not handle these numbers gracefully, you will manually perform the multiplication as if done by hand. # Task: Write a function, `multiply(num1: str, num2: str) -> str`, which multiplies two non-negative integer strings `num1` and `num2`, and returns the result as a string. You must not use any built-in libraries for handling large numbers or directly convert the inputs to integers. # Input: - `num1`: A string representing the first non-negative integer (1 ≤ len(num1) ≤ 109). - `num2`: A string representing the second non-negative integer (1 ≤ len(num2) ≤ 109). # Output: - A string representing the product of `num1` and `num2`. # Examples: ```python assert multiply(\\"123\\", \\"456\\") == \\"56088\\" assert multiply(\\"999\\", \\"0\\") == \\"0\\" assert multiply(\\"1000\\", \\"1000\\") == \\"1000000\\" ``` # Constraints: - Both `num1` and `num2` will contain only digits 0-9. - Both `num1` and `num2` will not contain any leading zeros. # Performance Requirement: - Your implementation should be efficient in terms of both time and space for handling the maximum input size. # Notes: - Think about edge cases, such as multiplication involving zeros or very large numbers. - Ensure to handle carrying over digits correctly during addition of intermediate results. - Optimize the solution to minimize both time and space complexity.","solution":"def multiply(num1: str, num2: str) -> str: if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" len1, len2 = len(num1), len(num2) result = [0] * (len1 + len2) for i in range(len1 - 1, -1, -1): for j in range(len2 - 1, -1, -1): mul = (int(num1[i]) * int(num2[j])) + result[i + j + 1] result[i + j + 1] = mul % 10 result[i + j] += mul // 10 result_str = \'\'.join(map(str, result)) return result_str.lstrip(\'0\')"},{"question":"**Context**: You are building a system where quick insertion, deletion, and random sampling of elements are critical, such as for load balancing, random sampling, or gaming applications. **Problem**: Design a data structure `RandomizedCollection` that supports insert, remove, and get_random operations for a collection where elements can repeat. Each element should have an equal probability of being returned upon the `get_random` operation. **Function Signature**: ```python class RandomizedCollection: def __init__(self): # Initialize your data structure here. pass def insert(self, val: int) -> bool: # Inserts a value to the collection. Returns true if the collection did not already contain the specified element. pass def remove(self, val: int) -> bool: # Removes a value from the collection. Returns true if the collection contained the specified element. pass def get_random(self) -> int: # Get a random element from the collection. pass ``` **Constraints**: * Elements can be repeated, and `insert` should return True if the element was not already in the collection before the insert operation. * `remove` should return True if the element was present and subsequently removed. * All operations need to be, on average, in O(1) time complexity. * You may assume that the `RandomizedCollection` will always contain at least one element when `get_random` is called. **Examples**: ```python # Example operations and expected outcomes rc = RandomizedCollection() print(rc.insert(1)) # Returns True as 1 was not previously present print(rc.insert(1)) # Returns False as 1 is already present print(rc.insert(2)) # Returns True as 2 was not previously present print(rc.insert(2)) # Returns False as 2 is already present print(rc.remove(1)) # Returns True as 1 was present and is removed print(rc.remove(1)) # Returns True as 1 (repeated occurrence) was present and is removed print(rc.remove(1)) # Returns False as 1 is no longer present in the collection print([rc.get_random() for _ in range(5)]) # Output should show random values from the remaining elements ```","solution":"import random from collections import defaultdict class RandomizedCollection: def __init__(self): self.idx_map = defaultdict(set) self.values = [] def insert(self, val: int) -> bool: self.values.append(val) self.idx_map[val].add(len(self.values) - 1) return len(self.idx_map[val]) == 1 def remove(self, val: int) -> bool: if not self.idx_map[val]: return False remove_idx = self.idx_map[val].pop() last_val = self.values[-1] if remove_idx != len(self.values) - 1: self.values[remove_idx] = last_val self.idx_map[last_val].add(remove_idx) self.idx_map[last_val].remove(len(self.values) - 1) self.values.pop() if not self.idx_map[val]: del self.idx_map[val] return True def get_random(self) -> int: return random.choice(self.values)"},{"question":"# Problem Description You are given a string, and your task is to reverse this string without using any built-in reverse functions or slicing operations. Implement a function **reverse_string** that takes a string as input and returns the reversed string. # Function Signature ```python def reverse_string(s: str) -> str: ``` # Input * `s` (1 ≤ len(s) ≤ 10^4) - A non-empty string consisting of printable ASCII characters. # Output * A string that is the reverse of the input string # Constraints * You should not use Python\'s built-in reverse functions or slicing. * Aim for a time complexity of O(n) and space complexity of O(n). # Examples ```python assert reverse_string(\\"hello\\") == \\"olleh\\" assert reverse_string(\\"world\\") == \\"dlrow\\" assert reverse_string(\\"abcd\\") == \\"dcba\\" assert reverse_string(\\"a\\") == \\"a\\" assert reverse_string(\\"\\") == \\"\\" ``` # Explanation 1. Implement the function with an iterative approach. 2. Utilize a list to store the characters as you traverse the string. 3. Reverse the string content by swapping characters from both ends. 4. Capture edge cases such as single-character and empty strings.","solution":"def reverse_string(s: str) -> str: Reverses the given string without using built-in reverse functions or slicing. Parameters: s (str): The string to be reversed. Returns: str: The reversed string. length = len(s) reversed_list = [\'\'] * length for i in range(length): reversed_list[length - 1 - i] = s[i] return \'\'.join(reversed_list)"},{"question":"Implement a PriorityQueue with Advanced Operations Problem Statement You are required to implement an advanced version of the provided `PriorityQueue` class, enhancing it to support additional features and improving performance with a heap-based approach. Your PriorityQueue should support the following operations: 1. **Insertion (`push`)**: Insert an element into the queue with a specific priority. 2. **Removal (`pop`)**: Remove and return the element with the lowest priority. 3. **Peek (`peek`)**: Return the element with the lowest priority without removing it from the queue. 4. **Change Priority (`change_priority`)**: Change the priority of a specific element already in the queue. 5. **Size (`size`)**: Return the current size of the priority queue. 6. **Empty (`is_empty`)**: Return whether the queue is empty or not. Function signatures ```python class PriorityQueue: def __init__(self, items=None, priorities=None): def push(self, item, priority=None): def pop(self): def peek(self): def change_priority(self, item, new_priority): def size(self): def is_empty(self): ``` Input Format * The PriorityQueue will be initialized with an optional list of items and their respective priorities. * The `push` method takes an item and an optional priority (default to item\'s value if not provided). * The `change_priority` method takes an item and the new priority as arguments. Output Format * The `pop` method returns the item with the lowest priority. * The `peek` method returns the item with the lowest priority without removing it. * The `size` method returns the integer size of the priority queue. * The `is_empty` method returns a boolean indicating whether the queue is empty. Constraints * You may assume item priorities are unique for `push` and `change_priority` operations. * You need to handle attempts to change the priority of items not present in the queue gracefully. * Operations should aim to be efficient, particularly `push` which should leverage a heap structure. # Example Scenario ```python pq = PriorityQueue() pq.push(\'task1\', 3) # Insert \'task1\' with priority 3 pq.push(\'task2\', 2) # Insert \'task2\' with priority 2 pq.push(\'task3\', 1) # Insert \'task3\' with priority 1 print(pq.pop()) # Should return \'task3\' because it has the lowest priority value pq.change_priority(\'task2\', 0) # Change the priority of \'task2\' to 0 print(pq.peek()) # Should return \'task2\' because it now has the lowest priority print(pq.size()) # Should return 2 print(pq.is_empty()) # Should return False ```","solution":"import heapq class PriorityQueue: def __init__(self, items=None, priorities=None): self.heap = [] self.entry_finder = {} # mapping of items to entries self.REMOVED = \'<removed-task>\' # placeholder for a removed task self.counter = 0 # unique counter to break ties if items and priorities: for item, priority in zip(items, priorities): self.push(item, priority) def push(self, item, priority=None): Insert an element into the queue with a specific priority. if priority is None: priority = item if item in self.entry_finder: self._remove_item(item) count = self.counter entry = [priority, count, item] self.entry_finder[item] = entry heapq.heappush(self.heap, entry) self.counter += 1 def pop(self): Remove and return the element with the lowest priority. while self.heap: priority, count, item = heapq.heappop(self.heap) if item is not self.REMOVED: del self.entry_finder[item] return item raise KeyError(\'pop from an empty priority queue\') def peek(self): Return the element with the lowest priority without removing it from the queue. while self.heap: priority, count, item = self.heap[0] if item is self.REMOVED: heapq.heappop(self.heap) # remove invalid entry else: return item raise KeyError(\'peek from an empty priority queue\') def change_priority(self, item, new_priority): Change the priority of a specific element already in the queue. if item in self.entry_finder: self._remove_item(item) self.push(item, new_priority) else: raise KeyError(f\'item {item} not found in priority queue\') def size(self): Return the current size of the priority queue. return len(self.entry_finder) def is_empty(self): Return whether the queue is empty or not. return len(self.entry_finder) == 0 def _remove_item(self, item): Mark an existing item as REMOVED. entry = self.entry_finder.pop(item) entry[-1] = self.REMOVED"},{"question":"You are tasked with improving and extending a utility that converts integers between different numeral systems (bases). The utility currently supports base conversions up to base 36 using digits and uppercase letters. Requirements: 1. **Function 1**: Implement a function `int_to_base(num, base)` that: - Converts an integer `num` (base 10) to a string representation in the specified `base`. - Handles bases from 2 to 36 inclusive. - Can handle both positive and negative integers. 2. **Function 2**: Implement a function `base_to_int(str_to_convert, base)` that: - Converts a string `str_to_convert` representing a number in the specified `base` back to an integer (base 10). - Handles bases from 2 to 36 inclusive. Constraints: - `num` will be an integer in the range `-10^9` to `10^9`. - `str_to_convert` will be a valid string representation of a number in the specified `base`. Input and Output Formats: - `int_to_base(num, base)` - **Input**: An integer `num` and an integer `base`. - **Output**: A string representing `num` in the specified `base`. - `base_to_int(str_to_convert, base)` - **Input**: A string `str_to_convert` and an integer `base`. - **Output**: An integer which is the base 10 representation of `str_to_convert`. Example: ```python # Example usage: print(int_to_base(5, 2)) # Output: \'101\' print(int_to_base(-15, 16)) # Output: \'-F\' print(base_to_int(\'101\', 2)) # Output: 5 print(base_to_int(\'-F\', 16)) # Output: -15 ``` Implement these functions considering the above requirements and constraints.","solution":"def int_to_base(num, base): Converts an integer num to a string representation in the specified base. Args: num (int): The integer to convert. base (int): The base to convert to. Returns: str: The string representation of num in the specified base. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") if num == 0: return \'0\' digits = [] negative = num < 0 num = abs(num) while num: digits.append(int_to_char(num % base)) num //= base if negative: digits.append(\'-\') return \'\'.join(reversed(digits)) def int_to_char(val): if 0 <= val <= 9: return str(val) elif 10 <= val <= 35: return chr(ord(\'A\') + val - 10) else: raise ValueError(\\"Value out of supported range\\") def base_to_int(str_to_convert, base): Converts a string str_to_convert representing a number in the specified base back to an integer (base 10). Args: str_to_convert (str): The string representation of the number to convert. base (int): The base of the number. Returns: int: The base 10 representation of str_to_convert. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") if str_to_convert == \'0\': return 0 negative = str_to_convert[0] == \'-\' if negative: str_to_convert = str_to_convert[1:] num = 0 for char in str_to_convert: num = num * base + char_to_int(char) return -num if negative else num def char_to_int(char): if \'0\' <= char <= \'9\': return ord(char) - ord(\'0\') elif \'A\' <= char <= \'Z\': return ord(char) - ord(\'A\') + 10 else: raise ValueError(\\"Character out of supported range\\")"},{"question":"# Question: Given a binary tree, write a function to compute its minimum depth. The minimum depth is defined as the number of nodes along the shortest path from the root node down to the nearest leaf node. You must implement this function in two ways: 1. **Recursively** 2. **Iteratively** using level-order traversal You are provided with the following `TreeNode` class definition: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Specifications: 1. Write a function `min_depth_recursive(root: TreeNode) -> int` that calculates the minimum depth using a recursive approach. 2. Write a function `min_depth_iterative(root: TreeNode) -> int` that calculates the minimum depth using an iterative level-order traversal. Input: - `root` (TreeNode): The root node of the binary tree. Output: - An integer representing the minimum depth of the binary tree. Constraints: - The number of nodes in the tree is between 0 and 1000. - The values of the nodes are unique. Example: Given the binary tree: ``` 3 / 9 20 / 15 7 ``` * `min_depth_recursive(root)` should return `2`. * `min_depth_iterative(root)` should also return `2`. You should implement these functions without relying on any imported libraries beyond the given class definition.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_depth_recursive(root: TreeNode) -> int: if not root: return 0 if not root.left and not root.right: return 1 if not root.left: return min_depth_recursive(root.right) + 1 if not root.right: return min_depth_recursive(root.left) + 1 return min(min_depth_recursive(root.left), min_depth_recursive(root.right)) + 1 def min_depth_iterative(root: TreeNode) -> int: if not root: return 0 from collections import deque queue = deque([(root, 1)]) while queue: node, depth = queue.popleft() if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1))"},{"question":"# Ordered Stack Background Imagine you are working with a stack that needs to maintain its elements in ascending order, even after pushing new elements. Implement this stack such that every push operation ensures the stack remains ordered with the largest element on the top. Task Implement the `push` method for the `OrderedStack` class to maintain the order of elements in the stack. Requirements: * **Input**: The `push` method will receive an integer which you need to insert into the stack while maintaining the order. * **Output**: The `push` method should not return anything but should alter the state of the stack. * **Constraints**: * You can use an auxiliary stack if necessary. * You must handle cases where the stack is empty. * You must raise an `IndexError` if `pop` or `peek` is called on an empty stack. Example: ```python stack = OrderedStack() stack.push(1) # Stack: [1] stack.push(3) # Stack: [1, 3] stack.push(2) # Stack: [1, 2, 3] print(stack.items) # Output: [1, 2, 3] ``` To complete the task, define the `push` method in the `OrderedStack` class. **Note**: Do not modify the class definition outside the `push` method.","solution":"class OrderedStack: def __init__(self): self.items = [] def is_empty(self): return len(self.items) == 0 def push(self, item): aux_stack = [] while not self.is_empty() and self.peek() > item: aux_stack.append(self.pop()) self.items.append(item) while aux_stack: self.items.append(aux_stack.pop()) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.items.pop() def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.items[-1]"},{"question":"# Priority Queue Implementation and Operations **Objective**: Implement a priority queue that supports dynamic updates and efficient priority management. **Scenario**: You have been tasked with managing a task scheduler for a real-time system. Each task has an associated priority and tasks with higher priorities need to be executed first. **Your Task**: 1. Implement a `DynamicPriorityQueue` class that supports priority adjustments for existing items in addition to typical priority queue operations (`push`, `pop`, `size`). 2. The priority queue should be optimized for both efficient insertion and extraction of elements. 3. Ensure that your implementation can handle edge cases such as attempts to adjust the priority of non-existent items and popping from an empty queue. **Requirements**: 1. **Push**: Insert an item with a given priority. 2. **Pop**: Remove and return the item with the highest priority. 3. **Size**: Return the number of items in the queue. 4. **AdjustPriority**: Modify the priority of an existing item. **Function Signatures**: ```python class DynamicPriorityQueue: def __init__(self): pass def push(self, item, priority): pass def pop(self): pass def size(self): pass def adjust_priority(self, item, new_priority): pass ``` **Input Format**: - For `push`: `item` can be any object, `priority` is an integer. - For `pop`: No input. - For `size`: No input. - For `adjust_priority`: `item` is the existing object in the queue, `new_priority` is the new priority value. **Output Format**: - `push`: No return value. - `pop`: Returns the item with the highest priority. - `size`: Returns the size of the queue. - `adjust_priority`: No return value but modifies the priority of an existing item. **Constraints**: - Priority values are integers and can be negative. - Each insertion should guarantee the ordered property of the queue. - Adjusting priority should efficiently handle reordering. **Example**: ```python pq = DynamicPriorityQueue() pq.push(\\"Task1\\", 5) pq.push(\\"Task2\\", 1) pq.push(\\"Task3\\", 3) print(pq.pop()) # Output: \\"Task1\\" print(pq.size()) # Output: 2 pq.adjust_priority(\\"Task3\\", 10) print(pq.pop()) # Output: \\"Task3\\" ``` Ensure that your implementation is optimal and handles all given constraints effectively. Good luck!","solution":"import heapq class DynamicPriorityQueue: def __init__(self): self.heap = [] self.item_finder = {} # map of items to their entries self.REMOVED = \'<removed-item>\' # placeholder for a removed item self.counter = 0 # unique sequence count def push(self, item, priority): if item in self.item_finder: self.adjust_priority(item, priority) else: entry = [priority, self.counter, item] self.item_finder[item] = entry heapq.heappush(self.heap, entry) self.counter += 1 def pop(self): while self.heap: priority, count, item = heapq.heappop(self.heap) if item is not self.REMOVED: del self.item_finder[item] return item raise KeyError(\'pop from an empty priority queue\') def size(self): return len(self.item_finder) def adjust_priority(self, item, new_priority): if item not in self.item_finder: raise KeyError(f\\"Item {item} not found in the priority queue\\") entry = self.item_finder.pop(item) entry[-1] = self.REMOVED new_entry = [new_priority, self.counter, item] self.item_finder[item] = new_entry heapq.heappush(self.heap, new_entry) self.counter += 1"},{"question":"# Question: Implement Cocktail Shaker Sort **Context**: You are a software engineer tasked with developing a sorting feature for a budgeting application that ranks expenses in a list from highest to lowest. Given that users typically manage a relatively small list of expenses, your team has chosen to implement and utilize the Cocktail Shaker Sort due to its simple bi-directional sorting nature. Problem Statement: You need to implement the `cocktail_shaker_sort` function to sort a given list of integers in descending order using the Cocktail Shaker Sort algorithm. Ensure this function can handle edge cases, such as already sorted lists or lists containing duplicate elements. Function Signature: ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` Input: - **arr**: A list of integers `arr` with a length `n` (0 ≤ n ≤ 10^4). Output: - A list of integers sorted in descending order. Constraints: - You are required to implement the sorting in-place, meaning you cannot use additional lists or arrays to store elements during the sorting process. - You may assume that the list can contain negative integers as well. Example: ```python # Example 1: input_arr = [4, 2, 9, 1, 3, 6] # Expected Output: [9, 6, 4, 3, 2, 1] # Example 2: input_arr = [1, 2, 3, 4, 5] # Expected Output: [5, 4, 3, 2, 1] ``` Additional Guidance: - Remember to consider edge cases like handling empty lists or lists with a single element. - You should write and test your own unit tests to ensure the robustness of your implementation.","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts a list of integers in descending order using the Cocktail Shaker Sort algorithm. n = len(arr) if n <= 1: return arr swapped = True start = 0 end = n - 1 while swapped: swapped = False # Traverse from left to right for i in range(start, end): if arr[i] < arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If no elements were swapped, then the list is sorted if not swapped: break swapped = False end -= 1 # Traverse from right to left for i in range(end, start, -1): if arr[i - 1] < arr[i]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True start += 1 return arr"},{"question":"You are given a list of integers representing the initial values in a frequency array. Implement a class `FenwickTree` to support efficient range sum queries and updates to this array. # Requirements: 1. **Initialization**: The `FenwickTree` class should initialize with the frequency array. 2. **Methods**: - `get_sum(i: int) -> int`: Returns the sum of values up to and including index `i`. - `update(i: int, val: int) -> None`: Updates the frequency array by adding `val` to the element at index `i`. 3. **Constraints**: - Index `i` is zero-based for operations. - The length of the array, `n`, should satisfy (1 leq n leq 10^5). - The values in the array and the update value, `val`, are within the range (-10^9 leq text{value} leq 10^9). 4. **Performance**: - Both `get_sum` and `update` should run in O(log n) time. # Implementation of Class: ```python class FenwickTree: def __init__(self, freq: List[int]) -> None: # Initialize Fenwick tree here def get_sum(self, i: int) -> int: # Compute and return prefix sum up to index i def update(self, i: int, val: int) -> None: # Update tree with given value at index i ``` # Example: ```python # Initialize the Fenwick Tree with the frequency array fenwick_tree = FenwickTree([1, 2, 3, 4, 5]) # Perform a sum query print(fenwick_tree.get_sum(3)) # Expected Output: 1 + 2 + 3 + 4 = 10 # Perform an update fenwick_tree.update(1, 2) # Array becomes [1, 4, 3, 4, 5] # Perform another sum query print(fenwick_tree.get_sum(3)) # Expected Output: 1 + 4 + 3 + 4 = 12 ``` Your task is to implement this class to correctly perform the described operations.","solution":"from typing import List class FenwickTree: def __init__(self, freq: List[int]) -> None: self.n = len(freq) self.tree = [0] * (self.n + 1) # Initialize the tree with the frequency array for i in range(self.n): self.update(i, freq[i]) def get_sum(self, i: int) -> int: total = 0 i += 1 # Fenwick Tree is 1-indexed while i > 0: total += self.tree[i] i -= i & -i return total def update(self, i: int, val: int) -> None: i += 1 # Fenwick Tree is 1-indexed while i <= self.n: self.tree[i] += val i += i & -i"},{"question":"# Rabin-Karp Enhanced Implementation In this exercise, you are required to enhance the current implementation of the Rabin-Karp Algorithm. The given implementation only returns the index of the first occurrence of the pattern in the text. You need to modify it to return a list of all occurrences of the pattern within the text. Additionally, handle cases where the text or pattern contain uppercase letters and special characters by ensuring the hash function accounts for the entire ASCII range. Objective: Update the function `rabin_karp` to find **all** occurrences of a given pattern in a text and return their starting indices. # Function Signature: ```python def rabin_karp(word: str, text: str) -> list[int]: ``` # Parameters: * `word` (str): The pattern to search for, a non-empty string. * `text` (str): The text in which to search, a non-empty string with length >= length of `word`. # Returns: * list[int]: List of starting indices where the pattern is found within the text. Return an empty list if no occurrences are found. # Constraints: - The text and pattern strings can contain both uppercase and lowercase letters as well as special characters. - Optimize function for best performance and accuracy. # Example: ```python text = \\"ab#cDeFgABcdefg\\" pattern = \\"cDeFg\\" # Calling the function result = rabin_karp(pattern, text) assert result == [3], f\\"Expected [3], but got {result}\\" ``` # Notes: - Handle cases where patterns are palindromes. - Consider how changes to the base of the hash function might affect collision rates. # Hints: - Consider using a large prime number for the base in hashing functions to reduce collisions. - Update the RollingHash class to handle a wider range of characters efficiently. Good luck!","solution":"def rabin_karp(word: str, text: str) -> list[int]: Uses the Rabin-Karp algorithm to find all occurrences of the pattern in the text. :param word: The word pattern to search for. :param text: The text in which to search for the pattern. :return: List of starting indices where the pattern is found within the text. if not word or not text or len(word) > len(text): return [] # Constants base = 256 # Number of characters in ASCII prime = 101 # A prime number to mod the hash values n = len(text) m = len(word) h_word = 0 # Hash value for the pattern h_text = 0 # Hash value for the current substring in text base_m_1 = 1 # base^m-1 % prime to use in rolling hash # Precompute base^m-1 % prime for i in range(m-1): base_m_1 = (base * base_m_1) % prime # Compute initial hash values for pattern and first window of text for i in range(m): h_word = (base * h_word + ord(word[i])) % prime h_text = (base * h_text + ord(text[i])) % prime indices = [] # Slide the window over text for i in range(n - m + 1): # Check if the hash values match if h_word == h_text: # Verify by checking the actual substrings if text[i:i+m] == word: indices.append(i) # Compute hash value for the next window of text if i < n - m: h_text = (base * (h_text - ord(text[i]) * base_m_1) + ord(text[i + m])) % prime if h_text < 0: h_text += prime return indices"},{"question":"# DFA Pattern Matching You are asked to implement a function to determine if a given string is accepted by a deterministic finite automaton (DFA). A DFA is a theoretical model of computation consisting of a finite number of states, transitions between those states, and one or more final (accepting) states. Given the function signature: ```python def DFA(transitions, start, final, string): ``` Parameters: - `transitions` (dict): A dictionary representing the state transition table. Each key is a state, and the value is another dictionary that maps input symbols to the next state. - `start` (any): The initial state of the DFA. - `final` (list): A list of accepting states. - `string` (str): The input string to be processed. Your task is to implement this function to correctly determine if the input string `string` is accepted by the DFA. Constraints: - The number of states is finite. - The transition table covers all possible transitions for each input symbol; `None` indicates the absence of a transition. - An accepting state is any state in the `final` list. Return: - `True` if the string is accepted by the DFA. - `False` otherwise. Scenario or Context: Imagine you are designing a simple lexical analyzer for a subset of programming language syntax. The DFA will help you recognize valid variable names. Each variable name should consist of letters and digits, starting with a letter. Your DFA function will need to validate such variable names. Example: ```python transitions = { \'q0\': {\'a\': \'q1\', \'b\': \'q1\', \'1\': None}, \'q1\': {\'a\': \'q1\', \'b\': \'q1\', \'1\': \'q1\'} } start = \'q0\' final = [\'q1\'] string = \\"a1\\" print(DFA(transitions, start, final, string)) # Output: True ``` Notes: - Ensure correct handling of edge cases such as empty strings or undefined state transitions. - The input is guaranteed to have valid states and transitions, but your function should handle strings that lead to `None` transitions correctly by returning `False`.","solution":"def DFA(transitions, start, final, string): Determines if the given string is accepted by the DFA described by the transitions, start state, and final states. :param transitions: A dictionary representing the state transition table. :param start: The initial state of the DFA. :param final: A list of accepting states. :param string: The input string to be processed. :return: True if the string is accepted by the DFA, False otherwise. current_state = start for symbol in string: if symbol in transitions[current_state]: next_state = transitions[current_state][symbol] if next_state is None: return False current_state = next_state else: return False return current_state in final"},{"question":"# Question: Write a function `find_order_with_print_steps(a, n)` that finds the order of a positive integer a modulo n as follows: 1. The function takes in two positive integers `a` and `n`. 2. The function should return the smallest positive integer k such that (a^k ≡ 1 mod n). If no such k exists, return -1. 3. In addition to finding the order, print each step of the iteration with the current value of k and (a^k mod n). **Input:** - Two positive integers `a` and `n` such that (1 ≤ a ≤ 10^6) and (1 < n ≤ 10^6). **Output:** - An integer for the order of a modulo n if it exists, otherwise -1. **Constraints:** 1. If `a` and `n` are not coprime (i.e., gcd(a, n) ≠ 1), the function should print an error message \\"a and n should be relative prime!\\" and return -1. 2. Handle the edge case where (a = 1) and (n = 1) by returning 1. **Performance Requirements:** - Time complexity should be O(n log n) due to nested iterations and power function. - Space complexity should be O(1). **Function Signature:** ```python def find_order_with_print_steps(a: int, n: int) -> int: ``` **Example:** ```python find_order_with_print_steps(2, 5) # Output steps followed by 4 find_order_with_print_steps(3, 11) # Output steps followed by 5 find_order_with_print_steps(2, 4) # \\"a and n should be relative prime!\\" followed by -1 ```","solution":"def gcd(x, y): while y: x, y = y, x % y return x def find_order_with_print_steps(a, n): Finds the order of a modulo n and prints each step. Parameters: a (int): The base number. n (int): The modulus. Returns: int: The smallest positive integer k such that a^k ≡ 1 (mod n), or -1 if no such k exists. if gcd(a, n) != 1: print(\\"a and n should be relative prime!\\") return -1 current = 1 for k in range(1, n): current = (current * a) % n print(f\\"Step {k}: a^{k} % n = {current}\\") if current == 1: return k return -1"},{"question":"Demonstrate your understanding of optimized insertion sort by implementing a function that uses binary search to find the correct insertion position. You need to implement the optimized insertion sort algorithm utilizing the provided `search_insert` helper function. # Function Signature ```python def optimized_insertion_sort(arr: list) -> list: Sort an array using an optimized insertion sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: A sorted list of integers. pass ``` # Input * `arr`: A list of integers, where 1 <= len(arr) <= 1000 and -10^4 <= arr[i] <= 10^4. # Output * A sorted list of integers. # Constraints * The input list may contain duplicate entries. # Example ```python assert optimized_insertion_sort([12, 11, 13, 5, 6]) == [5, 6, 11, 12, 13] assert optimized_insertion_sort([4, 2, 7, 1, 3]) == [1, 2, 3, 4, 7] assert optimized_insertion_sort([1]) == [1] ``` # Notes - The function should leverage the `search_insert` function for optimized insertion point search. - Focus on ensuring both time and space complexity are minimized.","solution":"def search_insert(arr, val, start, end): Uses binary search to find the index where \'val\' should be inserted in \'arr\' to maintain sorted order from indices \'start\' to \'end\'. if start == end: if arr[start] > val: return start else: return start + 1 if start > end: return start mid = (start + end) // 2 if arr[mid] < val: return search_insert(arr, val, mid + 1, end) elif arr[mid] > val: return search_insert(arr, val, start, mid - 1) else: return mid def optimized_insertion_sort(arr): Sort an array using an optimized insertion sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: A sorted list of integers. for i in range(1, len(arr)): key = arr[i] # Find the correct position to insert the element using binary search j = search_insert(arr, key, 0, i-1) # Move elements of arr[0..i-1], that are greater than key, to one position ahead arr = arr[:j] + [key] + arr[j:i] + arr[i+1:] return arr"},{"question":"# String Reversal Challenge You are tasked with implementing a function to reverse a given string. You must demonstrate your understanding by implementing three different methods for string reversal: using recursion, iteration, and Pythonic slicing. Function Implementations 1. **Recursive Method**: Implement a function `reverse_recursive(s: str) -> str` that reverses a string using recursion. 2. **Iterative Method**: Implement a function `reverse_iterative(s: str) -> str` that reverses a string using iteration. 3. **Pythonic Method**: Implement a function `reverse_pythonic(s: str) -> str` that reverses a string using Python\'s slicing feature. Input and Output Formats * Input: A single string `s` where `0 <= len(s) <= 10^5` * Output: A single string which is the reversed version of the input string. Constraints and Limitations 1. **Recursive Method**: * Must handle stack overflow for deep recursion within the constraints. 2. **Iterative Method**: * Should manually reverse the string using iteration. 3. **Pythonic Method**: * Must utilize Python\'s slicing capabilities for reversing strings. 4. Performance: * Solutions must efficiently handle the input within the specified constraints. Example ```python # Using the recursive method print(reverse_recursive(\\"hello\\")) # Output: \\"olleh\\" # Using the iterative method print(reverse_iterative(\\"world\\")) # Output: \\"dlrow\\" # Using the Pythonic method print(reverse_pythonic(\\"openai\\")) # Output: \\"ianepo\\" ``` Implement these functions to show mastery of different approaches to solving the string reversal problem.","solution":"def reverse_recursive(s: str) -> str: Reverses a string using recursion. if len(s) == 0: return s return reverse_recursive(s[1:]) + s[0] def reverse_iterative(s: str) -> str: Reverses a string using iteration. reversed_str = \\"\\" for char in s: reversed_str = char + reversed_str return reversed_str def reverse_pythonic(s: str) -> str: Reverses a string using Python\'s slicing feature. return s[::-1]"},{"question":"File Path Normalizer Scenario Imagine you are developing a file organization tool that needs to handle various file paths provided by the user. Inconsistent file paths can lead to numerous issues, such as inaccessible files or incorrect directories. To avoid these problems, your tool should normalize these paths so they are in an absolute, consistent format. Task Write a function `normalize_path(file_path: str) -> str` that takes a string `file_path`, normalizes it by: 1. Expanding any `~` to the user\'s home directory. 2. Converting any relative path to an absolute path. # Function Signature ```python def normalize_path(file_path: str) -> str: ``` # Input * `file_path`: A string representing a file path. It may include `~`, be relative or absolute. # Output * Return a string that is an absolute path with any `~` expanded. # Constraints * The input string will not be longer than 500 characters. * Assume you\'ve all the necessary permissions to access directories involved. * The function should handle empty string inputs by returning an empty string. # Examples 1. `normalize_path(\'~/documents/file.txt\')` returns `\'/home/username/documents/file.txt\'` (assuming `/home/username` is the user\'s home directory). 2. `normalize_path(\'./docs/readme.md\')` returns the absolute path of `docs/readme.md` from the current working directory. 3. `normalize_path(\'/var/logs/system.log\')` returns `\'/var/logs/system.log\'`. 4. `normalize_path(\'\')` returns `\'\'`. Considerations Handle edge cases such as empty strings or strings that consist of only the tilde character properly to avoid unexpected results.","solution":"import os def normalize_path(file_path: str) -> str: Normalizes the given file path by expanding `~` to the user\'s home directory and converting relative paths to absolute paths. Returns an empty string if the input is empty. if not file_path: return \\"\\" expanded_path = os.path.expanduser(file_path) absolute_path = os.path.abspath(expanded_path) return absolute_path"},{"question":"# Background You have learned about various sorting algorithms and their efficiencies. Now, it\'s time to apply this knowledge to implement a specific sorting algorithm named **Stooge Sort**. This algorithm, while educational, is not efficient for large datasets but helps in understanding recursion deeply. # Problem Statement Implement the **Stooge Sort** algorithm to sort an array of integers. Your function should be able to handle edge cases and must follow the stooge sort strategy. # Function Signature ```python def stoogesort(arr: List[int], l: int, h: int) -> None: # Your code here ``` # Input * `arr`: A list of integers to be sorted. * `l`: An integer representing the starting index of the list to be sorted. * `h`: An integer representing the ending index of the list to be sorted. # Output The function should not return anything. Instead, it should sort the array `arr` in place. # Constraints * The array `arr` will have at most 1000 elements. * Each integer in the array will be in the range [-1000, 1000]. # Example ```python arr = [1, 3, 64, 5, 7, 8] stoogesort(arr, 0, len(arr)-1) print(arr) # Output: [1, 3, 5, 7, 8, 64] ``` # Notes * Be careful with index calculations to avoid out-of-bound errors. * Consider the base cases where subarray length is less than or equal to 2.","solution":"def stoogesort(arr, l, h): Sorts the array arr in place using Stooge Sort algorithm between indices l and h. if l >= h: return # If the first element is greater than the last element, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are at least 3 elements in the array if h - l + 1 > 2: # Calculate the third of the current segment length t = (h - l + 1) // 3 # Recursively sort first 2/3 of the segment stoogesort(arr, l, h - t) # Recursively sort last 2/3 of the segment stoogesort(arr, l + t, h) # Recursively sort first 2/3 of the segment again just to ensure stoogesort(arr, l, h - t)"},{"question":"# AVL Tree Operations Implementation Problem Statement: You are required to implement an AVL Tree class in Python that supports insertion, search, and in-order traversal operations. Given the pseudocode and partial implementation provided below, extend the class to include the required methods. Instructions: 1. **Insert Operation**: Implement the insertion method (`insert`) that adds a key to the AVL Tree while maintaining its balanced property. 2. **Search Operation**: Implement a method (`search`) to check whether a given key exists in the tree. 3. **In-order Traversal**: Ensure the `in_order_traverse` method returns a list of keys in sorted order. Class Definition: ```python class TreeNode: def __init__(self, key, left=None, right=None): self.key = key self.left = left self.right = right class AvlTree: def __init__(self): self.node = None self.height = -1 self.balance = 0 def insert(self, key): # Implement the insertion logic here def search(self, key) -> bool: # Implement the search functionality here def in_order_traverse(self) -> list: result = [] if not self.node: return result result.extend(self.node.left.in_order_traverse()) result.append(self.node.key) result.extend(self.node.right.in_order_traverse()) return result def re_balance(self): # Provided self.update_heights(recursive=False) self.update_balances(False) while self.balance < -1 or self.balance > 1: if self.balance > 1: if self.node.left.balance < 0: self.node.left.rotate_left() self.update_heights() self.update_balances() self.rotate_right() self.update_heights() self.update_balances() if self.balance < -1: if self.node.right.balance > 0: self.node.right.rotate_right() self.update_heights() self.update_balances() self.rotate_left() self.update_heights() self.update_balances() def update_heights(self, recursive=True): # Provided if self.node: if recursive: if self.node.left: self.node.left.update_heights() if self.node.right: self.node.right.update_heights() self.height = 1 + max(self.node.left.height, self.node.right.height) else: self.height = -1 def update_balances(self, recursive=True): # Provided if self.node: if recursive: if self.node.left: self.node.left.update_balances() if self.node.right: self.node.right.update_balances() self.balance = self.node.left.height - self.node.right.height else: self.balance = 0 def rotate_right(self): # Provided new_root = self.node.left.node new_left_sub = new_root.right.node old_root = self.node self.node = new_root old_root.left.node = new_left_sub new_root.right.node = old_root def rotate_left(self): # Provided new_root = self.node.right.node new_left_sub = new_root.left.node old_root = self.node self.node = new_root old_root.right.node = new_left_sub new_root.left.node = old_root ``` Constraints: * `key` will be an integer within the range `[-10^5, 10^5]`. * The tree should not allow duplicate keys. Input and Output Formats: * **Insert**: `insert(key)` - Inserts the `key` into the AVL Tree. * **Search**: `search(key) -> bool` - Returns `True` if the `key` exists in the tree, `False` otherwise. * **In-order Traverse**: `in_order_traverse() -> list` - Returns a list of keys in the tree in in-order traversal. Example: ```python avl_tree = AvlTree() avl_tree.insert(10) avl_tree.insert(20) avl_tree.insert(30) # After insertions, the tree in-order traversal should be [10, 20, 30] assert avl_tree.in_order_traverse() == [10, 20, 30] # Testing search operation assert avl_tree.search(20) == True assert avl_tree.search(25) == False avl_tree.insert(25) # After insertion, the tree in-order traversal should be [10, 20, 25, 30] assert avl_tree.in_order_traverse() == [10, 20, 25, 30] print(\\"All tests passed!\\") ```","solution":"class TreeNode: def __init__(self, key, left=None, right=None): self.key = key self.left = left self.right = right class AvlTree: def __init__(self): self.node = None self.height = -1 self.balance = 0 def insert(self, key): if self.node is None: self.node = TreeNode(key) self.node.left = AvlTree() self.node.right = AvlTree() elif key < self.node.key: self.node.left.insert(key) elif key > self.node.key: self.node.right.insert(key) else: return # No duplicates allowed self.re_balance() def search(self, key) -> bool: if self.node is None: return False if key == self.node.key: return True elif key < self.node.key: return self.node.left.search(key) else: return self.node.right.search(key) def in_order_traverse(self) -> list: result = [] if not self.node: return result result.extend(self.node.left.in_order_traverse()) result.append(self.node.key) result.extend(self.node.right.in_order_traverse()) return result def re_balance(self): self.update_heights(recursive=False) self.update_balances(False) while self.balance < -1 or self.balance > 1: if self.balance > 1: if self.node.left.balance < 0: self.node.left.rotate_left() self.update_heights() self.update_balances() self.rotate_right() self.update_heights() self.update_balances() if self.balance < -1: if self.node.right.balance > 0: self.node.right.rotate_right() self.update_heights() self.update_balances() self.rotate_left() self.update_heights() self.update_balances() def update_heights(self, recursive=True): if self.node: if recursive: if self.node.left: self.node.left.update_heights() if self.node.right: self.node.right.update_heights() self.height = 1 + max(self.node.left.height, self.node.right.height) else: self.height = -1 def update_balances(self, recursive=True): if self.node: if recursive: if self.node.left: self.node.left.update_balances() if self.node.right: self.node.right.update_balances() self.balance = self.node.left.height - self.node.right.height else: self.balance = 0 def rotate_right(self): new_root = self.node.left.node new_left_sub = new_root.right.node old_root = self.node self.node = new_root old_root.left.node = new_left_sub new_root.right.node = old_root def rotate_left(self): new_root = self.node.right.node new_left_sub = new_root.left.node old_root = self.node self.node = new_root old_root.right.node = new_left_sub new_root.left.node = old_root"},{"question":"You are given an implementation of a recursive function that calculates the binomial coefficient C(n, k). A binomial coefficient C(n, k) denotes the number of ways to choose `k` elements out of a set of `n` elements. Improve this function to handle larger input values more efficiently by incorporating dynamic programming techniques. # Function Signature ```python def dynamic_binomial_coefficient(n: int, k: int) -> int: pass ``` # Input * `n` (int): The size of the set (0 <= n <= 1000) * `k` (int): The size of the subset (0 <= k <= n) # Output * (int): The binomial coefficient C(n, k). # Constraints * You should optimize the implementation to handle the maximum input values efficiently. * Avoid recursion depth issues by using an iterative or table-based dynamic programming approach. # Example ```python # Example usage: print(dynamic_binomial_coefficient(5, 0)) # Output: 1 print(dynamic_binomial_coefficient(8, 2)) # Output: 28 print(dynamic_binomial_coefficient(10, 5)) # Output: 252 print(dynamic_binomial_coefficient(500, 300)) # Output: Large integer value ``` # Hints: * Utilize a table to store intermediate results to avoid redundant calculations. * Use the property C(n, k) = C(n-1, k) + C(n-1, k-1) for iterative calculation. # Note: The solution should efficiently handle the maximum input size without running into performance bottlenecks or recursion depth limits.","solution":"def dynamic_binomial_coefficient(n: int, k: int) -> int: if k > n: return 0 if k == 0 or k == n: return 1 # Initialize a table to store results of subproblems C = [[0 for _ in range(k+1)] for __ in range(n+1)] # Iterate through all values from 0 to n for i in range(n+1): for j in range(min(i, k) + 1): # Base cases if j == 0 or j == i: C[i][j] = 1 else: C[i][j] = C[i-1][j-1] + C[i-1][j] return C[n][k]"},{"question":"# Bogo Experiment You have learned about the Bogo Sort algorithm and its extreme inefficiency. To further understand the impacts of such inefficient algorithms, you are provided with the following challenge that forces you to think about alternative optimizations or improvements. **Task**: Given the Bogo Sort algorithm, implement a function `improved_sort` that aims to sort a list of integers by leveraging the principle of Bogo Sort but introduces mechanisms to avoid excessive computational waste. Your function should use a similar randomization-based process to begin with but adopt a strategy to significantly improve performance beyond the naive approach. **Function Signature**: ```python def improved_sort(arr: List[int], max_iterations: int = 1000) -> List[int]: Sorts the given list of integers using an optimized understanding of the Bogo Sort algorithm. Parameters: * arr (List[int]): The input list of integers to be sorted. * max_iterations (int): The maximum number of random shuffles allowed. Returns: * List[int]: The sorted list. Raises: * ValueError: If the array cannot be sorted within the given max_iterations. ``` **Input**: - A list of integers `arr` where 1 ≤ len(arr) ≤ 10 (to avoid excessive computation time since high inputs won\'t be handled well by random algorithms). - An optional parameter `max_iterations` which defaults to 1000. **Output**: - A sorted list of integers. **Constraints**: - You must use randomness as part of your sorting strategy. - Implement a check mechanism to break and throw a ValueError if sorting fails within the `max_iterations`. **Scenarios and Edge Cases** to Consider: 1. Sorting already sorted array. 2. Sorting reverse sorted array. 3. Sorting with maximum iterations exceeded. **Example Usage**: ```python arr = [4, 2, 1, 3] print(improved_sort(arr)) # Should print a sorted version such as [1, 2, 3, 4]. arr = [10, 5, 3] print(improved_sort(arr, 50)) # A sorted array or a ValueError based on max iterations. ``` Ensure your function incorporates better-than-basic efficiency by breaking early where possible and avoiding indefinite execution.","solution":"import random from typing import List def improved_sort(arr: List[int], max_iterations: int = 1000) -> List[int]: Sorts the given list of integers using an optimized understanding of the Bogo Sort algorithm. Parameters: * arr (List[int]): The input list of integers to be sorted. * max_iterations (int): The maximum number of random shuffles allowed. Returns: * List[int]: The sorted list. Raises: * ValueError: If the array cannot be sorted within the given max_iterations. def is_sorted(arr): return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) for iteration in range(max_iterations): if is_sorted(arr): return arr random.shuffle(arr) raise ValueError(\\"Array could not be sorted within the given max_iterations\\")"},{"question":"You need to write a function that increments a non-negative integer represented as an array of digits by one. The digits are stored such that the most significant digit is at the head of the list and each element in the array contains a single digit. The function should return the resulting array after the increment. # Expected Function Signature ```python def increment_array(digits: List[int]) -> List[int]: Increments the non-negative integer represented by the digits array by one. :param digits: List[int] - A list of digits representing a non-negative integer. :return: List[int] - The resulting list of digits after incrementing by one. ``` # Input - `digits`: A list of integers, where each integer `0 <= digits[i] <= 9` represents a digit of a non-negative integer. The list length can be up to 10^6. # Output - A list of integers representing the non-negative integer after being incremented by one, with each element being a valid digit (0-9). # Constraints - The input list will not contain any non-digit values. - You are not allowed to use any built-in functions that directly convert the list of digits into a numerical value and back. # Example 1. **Input**: `[1, 2, 3]` **Output**: `[1, 2, 4]` 2. **Input**: `[9, 9, 9]` **Output**: `[1, 0, 0, 0]` 3. **Input**: `[0]` **Output**: `[1]` # Note - Think about how you can efficiently manage carryovers. - Consider edge cases like an array full of 9s or single-element arrays.","solution":"from typing import List def increment_array(digits: List[int]) -> List[int]: Increments the non-negative integer represented by the digits array by one. :param digits: List[int] - A list of digits representing a non-negative integer. :return: List[int] - The resulting list of digits after incrementing by one. n = len(digits) # Start from the end of the list and work backwards for i in range(n - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If all the digits were 9, we must have gone through the entire list return [1] + [0] * n"},{"question":"# Objective Implement a class `AdvancedWordDictionary` to add and search for words efficiently, including support for the wildcard character ‘.’, which can represent any letter. # Requirements 1. Implement the following methods: - `add_word(self, word: str) -> None`: Add a word to the dictionary. - `search(self, word: str) -> bool`: Search for a word, which can include the wildcard character ‘.’. Returns `True` if the word is present or matches any word pattern, `False` otherwise. 2. Optimize for both time and space complexity, utilizing a suitable data structure. # Input and Output Formats - `add_word(word)`: Registers the given word which consists of lower-case English letters. - `search(word)`: Queries the dictionary with the given word pattern. Returns `True` or `False`. # Constraints - Assume words have a maximum length of 50. - Most words added to the dictionary will be different but occasionally may include repeats. - The dictionary can scale up to handle thousands of words efficiently. # Implementation Details - Use a Trie or a Hashmap, as discussed in the `WordDictionary` classes provided. - Ensure your implementation handles edge cases like full wildcard searches (\\"...\\"). # Example Usage ```python # Instantiate the dictionary dictionary = AdvancedWordDictionary() # Add words dictionary.add_word(\\"bad\\") dictionary.add_word(\\"dad\\") dictionary.add_word(\\"mad\\") # Searching for words print(dictionary.search(\\"pad\\")) # Expected output: False print(dictionary.search(\\"bad\\")) # Expected output: True print(dictionary.search(\\".ad\\")) # Expected output: True print(dictionary.search(\\"b..\\")) # Expected output: True ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class AdvancedWordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: return self._search_recursive(word, 0, self.root) def _search_recursive(self, word: str, index: int, node: TrieNode) -> bool: if index == len(word): return node.is_end_of_word char = word[index] if char == \'.\': for child in node.children.values(): if self._search_recursive(word, index + 1, child): return True return False else: if char in node.children: return self._search_recursive(word, index + 1, node.children[char]) else: return False"},{"question":"# Question Consider the problem of counting the number of empty branches in a Binary Search Tree (BST). An empty branch refers to a null pointer for both left and right children of the nodes. The count includes nulls for all non-leaf and leaf nodes. For a completely empty tree, there is 1 empty branch. Implement the Function: ```python def num_empty(root): Count the total number of empty branches (null pointers). Parameters: - root (Node): The root node of the BST. Returns: - int: The total number of empty branches. pass ``` Input: * `root` - The root of the BST, which can be an instance of a `Node` or `None`. Output: * An integer representing the total number of empty branches in the BST. Constraints: * The function should handle large BSTs efficiently. Example: For the following BST: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` The function should return 10 because there are 10 empty branches (null pointers). # Note: 1. A node with no children counts as having two empty branches. 2. If the root is `None`, return 1 (since there\'s one empty branch at the root). Context: This question assesses understanding of tree data structures, recursive thinking, and edge-case handling. It\'s crucial to demonstrate efficient counting of null pointers (empty branches) while ensuring the recursion covers all scenarios of nodes being `None`.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def num_empty(root): Count the total number of empty branches (null pointers). Parameters: - root (Node): The root node of the BST. Returns: - int: The total number of empty branches. if root is None: return 1 left_empty_branches = num_empty(root.left) right_empty_branches = num_empty(root.right) return left_empty_branches + right_empty_branches"},{"question":"**Problem**: Maximal Subarray Finder Implement a function `find_max_subarray(array: list) -> int` using an efficient algorithm to determine the maximum sum of a contiguous subarray within a given one-dimensional array of integers. # Input - `array`: A list of integers where the length (n) is between 1 and 10^5 (inclusive). The integers can be both positive and negative. # Output - Returns an integer representing the maximum sum of a contiguous subarray. # Constraints - Your function should handle all potential edge cases, including arrays with only negative numbers. - The solution should be optimized to run in linear time O(n) and constant space O(1). # Example ```python print(find_max_subarray([1, 2, -3, 4, 5, -7, 23])) # Output: 25 print(find_max_subarray([-1, -2, -3, -4])) # Output: -1 print(find_max_subarray([1, 2, 3, 4, 5])) # Output: 15 print(find_max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4])) # Output: 6 ``` # Performance Requirements - Ensure the function works efficiently for inputs up to the maximum constraint limit of 10^5 elements.","solution":"def find_max_subarray(array): Returns the maximum sum of a contiguous subarray within the given array. if not array: return 0 max_current = max_global = array[0] for num in array[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Challenging Coding Assessment Question Problem Statement Given an array of floating-point numbers in the range [0, 1), implement a sorting function using the Bucket Sort algorithm. Each bucket should be sorted using the Merge Sort algorithm instead of the more straightforward Insertion Sort. This should help improve the performance for a larger number of elements within each bucket. Function Signature ```python def bucket_sort(arr: List[float]) -> List[float]: pass ``` Input Format - `arr`: A list of floating-point numbers in the range [0, 1), where (1 leq |arr| leq 10^5). Output Format - A sorted list of numbers in ascending order. Constraints - The input array only contains floating-point numbers in the range [0, 1). Performance Requirements - The overall time complexity should ideally be (O(n log n)) in the average scenario considering Merge Sort for individual buckets. Example 1. Input: `[0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68]` Output: `[0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94]` 2. Input: `[0.42, 0.32, 0.23, 0.52, 0.3, 0.9]` Output: `[0.23, 0.3, 0.32, 0.42, 0.52, 0.9]` Instructions 1. Create a function named `bucket_sort`. 2. Create ( n ) empty buckets. 3. Distribute the elements of the array into the buckets based on their value. 4. Sort individual buckets using the Merge Sort algorithm. 5. Merge the sorted buckets to form the final sorted array.","solution":"from typing import List def merge_sort(arr: List[float]) -> List[float]: if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left: List[float], right: List[float]) -> List[float]: sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list def bucket_sort(arr: List[float]) -> List[float]: if not arr: return [] n = len(arr) buckets = [[] for _ in range(n)] for num in arr: index = int(num * n) buckets[index].append(num) for i in range(n): buckets[i] = merge_sort(buckets[i]) sorted_arr = [] for bucket in buckets: sorted_arr.extend(bucket) return sorted_arr"},{"question":"# Integer and Byte Conversion Challenge Given your understanding of integer-byte conversions and endianness, implement the following functions for a custom 64-bit signing-capable integer handling: 1. `signed_int_to_bytes(num: int, endian: str) -> bytes`: - Convert a signed 64-bit integer to its byte representation. - Support both `big` and `little` endian formats based on the `endian` parameter. - The function should handle zero and negative integers correctly. - Input Constraints: * `num` is a signed 64-bit integer. * `endian` is a string, either `\\"big\\"` or `\\"little\\"`. 2. `bytes_to_signed_int(bytestr: bytes, endian: str) -> int`: - Convert a byte representation back to a signed 64-bit integer. - Support both `big` and `little` endian formats based on the `endian` parameter. - Input Constraints: * `bytestr` is a byte string up to 8 bytes long. * `endian` is a string, either `\\"big\\"` or `\\"little\\"`. Examples: ```python # Example 1 num = -123456789 endian = \\"big\\" byte_repr = signed_int_to_bytes(num, endian) # Expected Output might be: byte_repr = b\'xffxffxffxf8xa4x1exc7xb3\' restored_num = bytes_to_signed_int(byte_repr, endian) # Expected Output: restored_num = -123456789 # Example 2 num = 987654321 endian = \\"little\\" byte_repr = signed_int_to_bytes(num, endian) # Expected Output might be: byte_repr = b\'xb1x68xde&x00x00x00x00\' restored_num = bytes_to_signed_int(byte_repr, endian) # Expected Output: restored_num = 987654321 ``` Performance: * Aim to implement these functions with optimal time and space complexity. * Consider edge cases for 0, positive and negative integers when testing your implementation.","solution":"def signed_int_to_bytes(num: int, endian: str) -> bytes: Convert a signed 64-bit integer to its byte representation. Parameters: - num: signed 64-bit integer to be converted. - endian: \'big\' or \'little\', indicating the byte order. Returns: - bytes: the byte representation of the integer. return num.to_bytes(8, byteorder=endian, signed=True) def bytes_to_signed_int(bytestr: bytes, endian: str) -> int: Convert a byte representation back to a signed 64-bit integer. Parameters: - bytestr: byte string up to 8 bytes long. - endian: \'big\' or \'little\', indicating the byte order. Returns: - int: the signed 64-bit integer. return int.from_bytes(bytestr, byteorder=endian, signed=True)"},{"question":"# Question You are given a partial implementation of an AVL tree class with various methods to insert and rebalance the tree. Your task is to complete the implementation by writing a method that handles the deletion of a node from an AVL tree. **Function to Implement:** ```python def delete(self, key): Deletes the node with the specified key from the AVL tree. ``` **Expected Input and Output Formats:** - **Input**: The `delete` method takes an integer `key` as input. - **Output**: The method should modify the tree in place to remove the node with the specified key while maintaining the AVL tree properties. **Constraints:** - -10^9 <= key <= 10^9 - Your function should handle all edge cases, such as deleting a node from an empty tree, deleting the root node, etc. - The function should maintain the AVL tree properties after deletion by performing necessary rotations to balance the tree. **Performance Requirements:** - The function should run in O(log n) time complexity for deletion operation. **Scenario:** Consider you are implementing a real-time logging system where log entries are stored in an AVL tree. The AVL tree keeps the log entries sorted based on timestamps. New log entries can be dynamically added, and old log entries can be removed based on their timestamp. Implement the `delete` function to enable efficient removal of log entries based on their timestamp, ensuring the tree remains balanced for efficient future operations. **Example:** ```python avl = AvlTree() avl.insert(10) avl.insert(20) avl.insert(30) avl.delete(20) # After deletion, the tree should remain balanced: # The order of remaining elements (in-order traversal) should be [10, 30] print(avl.in_order_traverse()) # Output: [10, 30] ```","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = TreeNode(key) else: self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._right_rotate(node) if balance < -1 and key > node.right.key: return self._left_rotate(node) if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp_val = self._get_min_value_node(node.right) node.key = temp_val.key node.right = self._delete(node.right, temp_val.key) if not node: return node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and self._get_balance(node.left) >= 0: return self._right_rotate(node) if balance > 1 and self._get_balance(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and self._get_balance(node.right) <= 0: return self._left_rotate(node) if balance < -1 and self._get_balance(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left) def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def in_order_traverse(self): res = [] self._in_order_traverse(self.root, res) return res def _in_order_traverse(self, root, res): if root: self._in_order_traverse(root.left, res) res.append(root.key) self._in_order_traverse(root.right, res)"},{"question":"**Scenario**: You are tasked with building a configuration manager. The manager checks consistency between a configuration pattern and actual configurations read from a file. This ensures that patterns defined for configurations are strictly adhered to. **Problem Statement**: Write a function `is_config_pattern_matching(pattern: str, config_str: str) -> bool` that takes in two parameters: a `pattern` (a string of lowercase letters) and a `config_str` (a string of lowercase words separated by a single space). The function should return `True` if `config_str` follows the same pattern defined by `pattern`, `False` otherwise. # Input * `pattern`: A string consisting of lowercase letters. * `config_str`: A string containing lowercase words, separated by a single space. # Output * Return a boolean value, `True` if `config_str` follows the pattern, `False` otherwise. # Constraints * You may assume `pattern` contains only lowercase letters, and `config_str` contains lowercase words separated by a single space. * The length of `config_str` is less than or equal to 10^4 characters. * The length of `pattern` is less than or equal to 10^4 characters. # Examples ```python assert is_config_pattern_matching(\\"abba\\", \\"dog cat cat dog\\") == True assert is_config_pattern_matching(\\"abba\\", \\"dog cat cat fish\\") == False assert is_config_pattern_matching(\\"aaaa\\", \\"dog cat cat dog\\") == False assert is_config_pattern_matching(\\"abba\\", \\"dog dog dog dog\\") == False ``` # Requirements * The function should be implemented with a time complexity of O(n) and a space complexity of O(m), where n is the length of the config_str and m is the number of unique words or unique letters in the pattern, whichever is larger. * Optimize the function to early exit where possible.","solution":"def is_config_pattern_matching(pattern: str, config_str: str) -> bool: Checks if config_str follows the same pattern defined by pattern. Args: pattern (str): A string consisting of lowercase letters. config_str (str): A string containing lowercase words separated by single space. Returns: bool: True if config_str follows the pattern, False otherwise. words = config_str.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: char_to_word[char] = word if word in word_to_char: if word_to_char[word] != char: return False else: word_to_char[word] = char return True"},{"question":"# RandomizedSet Data Structure Implementation Challenge You are tasked with implementing a data structure `RandomizedSet` that supports the following operations with average time complexity of O(1): 1. **Insert**: Add an element to the set if it is not already present. 2. **Remove**: Remove an element from the set if it is present. 3. **Get Random**: Return a random element from the current set. Implement the following methods within the `RandomizedSet` class: * `__init__(self)`: Initializes the data structure. * `insert(self, val: int) -> bool`: Inserts an integer `val` into the set. Returns `True` if the element was successfully added, `False` if it was already present. * `remove(self, val: int) -> bool`: Removes an integer `val` from the set. Returns `True` if the element was successfully removed, `False` if it was not present. * `get_random(self) -> int`: Returns a random element from the set. If the set is empty, handle the scenario appropriately (consider throwing an exception or returning a specific value). # Input and Output * While using the `insert(val)` method, the function should take a single integer as input and return a boolean value. * Similarly, for `remove(val)`, it should take a single integer as input and return a boolean value indicating success or failure. * For the `get_random()`, the method should return an integer randomly selected from the set. # Constraints * The elements are assumed to be integers and are unique within the set. * The operations can be called in any order and be intermingled frequently. # Example Usage ```python rs = RandomizedSet() print(rs.insert(1)) # Expected output: True print(rs.insert(2)) # Expected output: True print(rs.insert(1)) # Expected output: False print(rs.remove(1)) # Expected output: True print(rs.remove(1)) # Expected output: False print(rs.get_random()) # Expected output: Randomly returns 2 as it’s the only element in the set rs.insert(3) print(rs.get_random()) # Expected output: Randomly returns 2 or 3 ``` # Note Ensure your implementation is efficient and handle edge cases such as empty set operations gracefully.","solution":"import random class RandomizedSet: def __init__(self): Initialize the data structure here. self.val_to_index = {} self.values = [] def insert(self, val: int) -> bool: Inserts a value to the set. Returns true if the set did not already contain the specified element. if val in self.val_to_index: return False self.val_to_index[val] = len(self.values) self.values.append(val) return True def remove(self, val: int) -> bool: Removes a value from the set. Returns true if the set contained the specified element. if val not in self.val_to_index: return False # Move the last element to the spot of the element to remove last_element = self.values[-1] idx_to_remove = self.val_to_index[val] self.values[idx_to_remove] = last_element self.val_to_index[last_element] = idx_to_remove # Remove the last element self.values.pop() del self.val_to_index[val] return True def get_random(self) -> int: Get a random element from the set. if not self.values: raise ValueError(\\"The set is empty.\\") return random.choice(self.values)"},{"question":"# Task You are provided with the code of a Binary Search Tree (BST) that includes a method to compute the height of the tree using recursion. Your task is to write a function `count_left_nodes` which counts the number of nodes in the left subtree of the root node if it exists. # Requirements - The function should be named `count_left_nodes`. - **Input**: Your function will take the root node of the binary search tree as input. - **Output**: The function should return an integer representing the number of nodes in the left subtree. - You may assume that the input BST does not contain duplicate values. # Performance Considerations - Your solution should have an O(n) time complexity where n is the number of nodes in the tree. - Aim for O(h) space complexity considering the recursion stack, where h is the height of the tree. # Constraints - The number of nodes in the binary search tree, n, is in the range [0, (10^4)]. # Example Given the BST: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` For the given tree, the root node is 9, and the count of nodes in the left subtree of 9 is 4 (nodes 6, 3, 8, 7). ```python import unittest from bst import Node from bst import bst def count_left_nodes(root): if root is None or root.left is None: return 0 def count_nodes(node): if node is None: return 0 return 1 + count_nodes(node.left) + count_nodes(node.right) return count_nodes(root.left) class TestSuite(unittest.TestCase): def setUp(self): self.tree = bst() self.tree.insert(9) self.tree.insert(6) self.tree.insert(12) self.tree.insert(3) self.tree.insert(8) self.tree.insert(10) self.tree.insert(15) self.tree.insert(7) self.tree.insert(18) def test_count_left_nodes(self): self.assertEqual(4, count_left_nodes(self.tree.root)) if __name__ == \'__main__\': unittest.main() ``` The function `count_left_nodes` should return `4` when called with the root node of the above tree.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def count_left_nodes(root): if root is None or root.left is None: return 0 def count_nodes(node): if node is None: return 0 return 1 + count_nodes(node.left) + count_nodes(node.right) return count_nodes(root.left)"},{"question":"# Maze Escape Problem **Problem Description:** You are given a 2D grid of integers where each element is either a 0 or a 1. Your task is to determine the minimum number of steps required to move from the top-left corner to the bottom-right corner, only moving through cells containing 1. You can move one step in one of the four cardinal directions (up, down, left, right). If it is not possible to reach the bottom-right corner, return -1. **Function Signature:** ```python def maze_search(maze: List[List[int]]) -> int: # Your implementation here ``` **Input:** * `maze` is a 2D grid represented as a list of lists of integers. * `1 ≤ len(maze), len(maze[0]) ≤ 100` (the grid is non-empty). * Each cell in the maze is either a 0 (BLOCKED) or a 1 (ALLOWED). **Output:** * Return an integer indicating the minimum number of steps needed to get from the top-left corner to the bottom-right corner. * If it is not possible, return -1. **Example:** 1. ```python maze = [[1,0,1,1,1,1], [1,0,1,0,1,0], [1,0,1,0,1,1], [1,1,1,0,1,1]] print(maze_search(maze)) # Output: 14 ``` 2. ```python maze = [[1,0,0], [0,1,1], [0,1,1]] print(maze_search(maze)) # Output: -1 ``` **Constraints:** * The starting cell (top-left corner) and the ending cell (bottom-right corner) will always be either 0 (BLOCKED) or 1 (ALLOWED). **Instructions:** * Implement the `maze_search` function to satisfy the provided requirements. * Make sure to handle edge cases like blocked start or end points and grids with no valid path. * Optimize for time and space complexity within the given constraints.","solution":"from typing import List, Tuple from collections import deque def maze_search(maze: List[List[int]]) -> int: def is_valid(r, c): return 0 <= r < len(maze) and 0 <= c < len(maze[0]) and maze[r][c] == 1 if maze[0][0] == 0 or maze[-1][-1] == 0: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0)]) # store (row, col) positions steps = 0 while queue: for _ in range(len(queue)): r, c = queue.popleft() if r == len(maze) - 1 and c == len(maze[0]) - 1: return steps for dr, dc in directions: rr, cc = r + dr, c + dc if is_valid(rr, cc): maze[rr][cc] = 0 # mark as visited queue.append((rr, cc)) steps += 1 return -1"},{"question":"Implement an Optimized Word Dictionary You are tasked with implementing a Word Dictionary that allows adding words and searching for words with support for regular expression-like searches which include the wildcard character \\".\\" that can represent any letter. Implement the class `AdvancedWordDictionary` that supports adding words and searching using Tries for words up to a certain length and a hash map with lists for longer words for efficiency. Requirements: 1. **Construction**: The dictionary should be instantiated without any initial data. 2. **Add Word**: Method to add a word to the dictionary. 3. **Search Word**: Method to search the dictionary. The search word can contain the wildcard character \\".\\" which can match any single letter. Input and Output: * **addWord(word)**: * **Input**: `word` (string) - the word to be added to the dictionary. * **Output**: None. * **search(word)**: * **Input**: `word` (string) - the word or pattern to search for in the dictionary. * **Output**: Boolean - `True` if the word or pattern exists in the dictionary, otherwise `False`. Constraints: * The length of word input for `addWord` or `search` will be in the range [1, 100]. * All words will be in lowercase letters. Use the following skeleton to complete your implementation: ```python import collections class TrieNode(object): def __init__(self, letter): self.children = {} self.letter = letter self.is_terminal = False class AdvancedWordDictionary(object): def __init__(self): self.trie_root = TrieNode(\\"\\") self.word_dict = collections.defaultdict(list) self.SPLIT_LENGTH = 10 # Chosen split length threshold for optimization def add_word(self, word): if len(word) <= self.SPLIT_LENGTH: cur = self.trie_root for letter in word: if letter not in cur.children: cur.children[letter] = TrieNode(letter) cur = cur.children[letter] cur.is_terminal = True else: self.word_dict[len(word)].append(word) def _search_trie(self, word, node): cur = node for i, letter in enumerate(word): if letter == \\".\\": if i == len(word) - 1: return any(child.is_terminal for child in cur.children.values()) return any(self._search_trie(word[i+1:], child) for child in cur.children.values()) if letter not in cur.children: return False cur = cur.children[letter] return cur.is_terminal def search(self, word): if len(word) <= self.SPLIT_LENGTH: return self._search_trie(word, self.trie_root) else: for v in self.word_dict[len(word)]: if all(ch1 == ch2 or ch1 == \'.\' for ch1, ch2 in zip(word, v)): return True return False ``` # Example Usage: ```python wd = AdvancedWordDictionary() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") print(wd.search(\\"pad\\")) # Output: False print(wd.search(\\"bad\\")) # Output: True print(wd.search(\\".ad\\")) # Output: True print(wd.search(\\"b..\\")) # Output: True ```","solution":"import collections class TrieNode(object): def __init__(self): self.children = {} self.is_terminal = False class AdvancedWordDictionary(object): def __init__(self): self.trie_root = TrieNode() self.word_dict = collections.defaultdict(list) self.SPLIT_LENGTH = 10 # Chosen split length threshold for optimization def add_word(self, word): if len(word) <= self.SPLIT_LENGTH: cur = self.trie_root for letter in word: if letter not in cur.children: cur.children[letter] = TrieNode() cur = cur.children[letter] cur.is_terminal = True else: self.word_dict[len(word)].append(word) def _search_trie(self, word, node): cur = node for i, letter in enumerate(word): if letter == \\".\\": if i == len(word) - 1: return any(child.is_terminal for child in cur.children.values()) return any(self._search_trie(word[i+1:], child) for child in cur.children.values()) if letter not in cur.children: return False cur = cur.children[letter] return cur.is_terminal def search(self, word): if len(word) <= self.SPLIT_LENGTH: return self._search_trie(word, self.trie_root) else: for v in self.word_dict[len(word)]: if all(ch1 == ch2 or ch1 == \'.\' for ch1, ch2 in zip(word, v)): return True return False"},{"question":"# Missing Number in Sequence Problem Statement You are given an array `nums` of unique integers in the range ([0..n]) where (n) is the length of the array. The integers in the array represent a sequence with no duplicates but with one number missing. Write a function `find_missing_number(nums: List[int]) -> int` that returns the missing number from the sequence. If the sequence is already complete, return the next integer in the sequence. Input - A list of integers `nums` containing unique integers in the range [0..n]. Output - An integer representing the missing number in the sequence or the next integer if the sequence is complete. Constraints - `1 <= len(nums) <= 10^5` - `0 <= nums[i] <= len(nums)` Performance Requirements - The solution should have a time complexity of (O(n)) and a space complexity of (O(1)). Example 1. Input: `nums = [4, 1, 3, 0, 6, 5, 2]` - Output: `7` 2. Input: `nums = [0, 1, 2, 3, 4, 5, 7, 8]` - Output: `6` 3. Input: `nums = [0, 1, 2, 3, 5]` - Output: `4` Requirements - Utilize the XOR technique or Arithmetic Sum technique. - Handle edge cases appropriately (e.g., empty array, array with a single element).","solution":"def find_missing_number(nums): Given a list of unique integers nums in the range [0..n], finds the missing number. If the sequence is complete, returns the next integer in the sequence. n = len(nums) # Expected sum of the first n natural numbers (0 to n) expected_sum = n * (n + 1) // 2 # Sum of the given numbers actual_sum = sum(nums) # The missing number is the difference return expected_sum - actual_sum"},{"question":"Context: You are tasked with developing a system that provides users various combinations of features they can select. As part of the feature selection module, you need to implement a function that provides all possible subsets of a given set of features. Problem Statement: Your task is to write a function `generate_subsets(nums)` that generates all possible subsets of a list of distinct integers. The function should return a set of tuples, where each tuple represents a unique subset of the input list. Function Signature: ```python def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: pass ``` Input: - `nums`: A list of distinct integers. Example: `[1, 2, 3]`. Constraints: `0 <= len(nums) <= 10`. Output: - A set of tuples, where each tuple is a subset of the given list. Example: `{(1,), (), (2,), (1, 2), (3,), (1, 3), (2, 3), (1, 2, 3)}`. Constraints: - The solution set must not contain duplicate subsets. Requirements: - Your solution should generate subsets efficiently. - The function should handle all edge cases, including an empty input list. Examples: Input: `[1, 2, 3]`<br> Output: `{(1,), (), (2,), (1, 2), (3,), (1, 3), (2, 3), (1, 2, 3)}` Input: `[1, 2]`<br> Output: `{(1,), (), (2,), (1, 2)}` Input: `[]`<br> Output: `{()}` Notes: - Pay special attention to handling of empty lists. - Ensure that all subsets are unique.","solution":"from typing import List, Set, Tuple from itertools import chain, combinations def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: Generates all possible subsets of a list of distinct integers. # Generate all subsets using itertools.chain and combinations subsets = set(chain.from_iterable(combinations(nums, r) for r in range(len(nums) + 1))) return subsets"},{"question":"Graph Cycle Detection # Context In a modern operating system, processes must frequently interact with each other by requesting and releasing locks/resources. Due to such interdependencies, it\'s crucial to ensure that no cycles are present in the \\"wait-for\\" graph of process dependencies, as this would indicate potential deadlocks. # Task Your task is to implement a function to detect cycles in a directed graph using the Depth-First Search (DFS) approach. # Function Signature ```python def contains_cycle(graph: dict) -> bool: Given a directed graph, determine if it contains a cycle. :param graph: A dictionary representing the adjacency list of the graph. The keys are node identifiers (strings), and the values are lists of strings representing directed edges to other nodes. :return: A boolean value True if there is a cycle, otherwise False. ``` # Input and Output - **Input**: - `graph`: A dictionary where keys represent nodes in the graph and each key has a list of nodes it directs to. - Example: ```python graph = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'] } ``` - **Output**: - The function should return `True` if there is a cycle, otherwise `False`. # Constraints - The graph will contain no more than 10^5 nodes and 10^5 edges. - Node identifiers are alphanumeric strings with a maximum length of 10. # Performance Requirements - The solution should run in linear time relative to the size of the graph (O(V + E)) where V is the number of vertices and E is the number of edges. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(contains_cycle(graph)) # Should output: True ``` # Notes - Pay special attention to disconnected components within the graph. - Consider edge cases such as empty graphs or graphs with self-loops.","solution":"def contains_cycle(graph: dict) -> bool: def dfs(node): if node in stack: return True if node in visited: return False visited.add(node) stack.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True stack.remove(node) return False visited = set() stack = set() for node in graph.keys(): if node not in visited: if dfs(node): return True return False"},{"question":"# Scenario You are provided with an important task of sorting user data. For simplicity and initial steps, you decide to use the Bubble Sort algorithm. The challenge is to ensure that you precisely apply the Bubble Sort methodology and enhance it with a feature to identify when the sorting process completes earlier than the worst-case scenario. # Task Implement a function `enhanced_bubble_sort(arr: list, simulation: bool = False) -> list:` that takes: * `arr`: A list of integers that needs to be sorted. * `simulation`: An optional boolean argument, if set to `True`, should output the intermediate iterations of sorting. # Requirements - The function should sort the list in ascending order. - If `simulation` is `True`, print the list after each swap operation and iteration count in the bubble sort process. - Optimally detect when no swaps are needed in a pass to halt the algorithm early. # Input - `arr`: List of integers, 0 <= length <= 1000, -10^6 <= element value <= 10^6 - `simulation`: Boolean (default is `False`) # Output - Sorted list of integers in ascending order. # Performance - Ensure the algorithm performs efficiently, stopping early if no swaps are needed in a pass. # Examples ```python # Example 1: arr = [64, 34, 25, 12, 22, 11, 90] enhanced_bubble_sort(arr) # Output: [11, 12, 22, 25, 34, 64, 90] # Example 2: arr = [5, 1, 4, 2, 8] enhanced_bubble_sort(arr, simulation=True) # Output should include: # \\"iteration 1: 1 5 4 2 8\\" # \\"iteration 2: 1 4 5 2 8\\" # ... # And final sorted list: [1, 2, 4, 5, 8] ``` # Note - Ensure handling for cases like an empty array, already sorted array, and array with all identical elements. - Optimize performance by halting early if a pass requires no swaps.","solution":"def enhanced_bubble_sort(arr: list, simulation: bool = False) -> list: Sort the list using the Bubble Sort algorithm. Args: arr (list): List of integers to be sorted. simulation (bool): If True, prints the list after each swap operation. Returns: list: Sorted list in ascending order. n = len(arr) for i in range(n): swapped = False for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if simulation: print(f\\"iteration {i+1}: {arr}\\") if not swapped: break return arr"},{"question":"Scenario Imagine you are working as a part of a development team responsible for developing a library of sorting algorithms. One of the fundamental algorithms you need to implement is Insertion Sort. You are provided with a helper function `search_insert` that determines the correct index to insert an element into the sorted part of the array using binary search. Your task is to complete the implementation of the Insertion Sort algorithm using this helper function. Task Write a function `insertion_sort(array)` that takes a list of integers and sorts it in ascending order using the insertion sort algorithm and the provided `search_insert` function. The function should use `search_insert` to find the correct position for each element and move the elements as necessary to keep the array sorted after each insertion. Function Signature ```python def insertion_sort(array: List[int]) -> None: Sorts the array in-place using insertion sort and the provided binary search helper. ``` Input Format - `array`: List of integers to be sorted, where `1 ≤ len(array) ≤ 10^4` and `-10^4 ≤ array[i] ≤ 10^4`. Output Format - The function returns `None`, but the input array should be sorted in ascending order after the function execution. Constraints - Use the `search_insert` function to determine the position where each element should be inserted. Example ```python # Given Helper Function def search_insert(array, val): low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low # Call your insertion_sort function arr = [4, 2, 6, 5, 3, 1] insertion_sort(arr) print(arr) # Output: [1, 2, 3, 4, 5, 6] ```","solution":"def search_insert(array, val): Helper function using binary search to find the index where val should be inserted. low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low def insertion_sort(array): Sorts the array in-place using insertion sort and the provided binary search helper. n = len(array) for i in range(1, n): key = array[i] # Find the position where the key should be inserted j = i - 1 pos = search_insert(array[:i], key) # Move elements of the sorted part to make space for key while j >= pos: array[j + 1] = array[j] j -= 1 array[j + 1] = key"},{"question":"# Queue Data Structure Implementation Your task is to create a queue data structure using a circular array mechanism. The queue should dynamically resize when it becomes full and handle wrap-around using a circular buffer technique to maintain the FIFO order efficiently. Requirements: * Implement the core operations (`enqueue`, `dequeue`, `peek`, `isEmpty`, `size`) robustly. * Ensure the operations handle edge cases such as full and empty queue conditions gracefully. * Your implementation should be space and time-efficient and strive to minimize the reallocation frequency to reduce operation delays. Specifications: - The initial size of the circular buffer should be 5. - Expand the buffer by doubling its size when full. Function Signature: ```python class CircularArrayQueue: def __init__(self): Initializes an empty queue with a capacity of 5. def enqueue(self, value): Adds the value to the rear of the queue. def dequeue(self): Removes and returns the value from the front of the queue. def peek(self): Returns the value from the front of the queue without removing it. def is_empty(self): Returns whether the queue is empty. def size(self): Returns the number of elements in the queue. # Example Usage: # queue = CircularArrayQueue() # queue.enqueue(1) # queue.enqueue(2) # print(queue.dequeue()) # Should output 1 # print(queue.peek()) # Should output 2 # print(queue.size()) # Should output 1 # print(queue.is_empty()) # Should output False ``` Notes: - You should not use Python\'s built-in `collections.deque` or similar high-level abstractions. - Ensure to handle edge cases, such as attempting to dequeue from an empty queue, appropriately. - Aim for O(1) amortized time complexity for all operations.","solution":"class CircularArrayQueue: def __init__(self): self.capacity = 5 self.queue = [None] * self.capacity self.front = 0 self.rear = 0 self.count = 0 def enqueue(self, value): if self.count == self.capacity: self._resize() self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.count += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from an empty queue\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.count -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"peek from an empty queue\\") return self.queue[self.front] def is_empty(self): return self.count == 0 def size(self): return self.count def _resize(self): new_capacity = self.capacity * 2 new_queue = [None] * new_capacity for i in range(self.count): new_queue[i] = self.queue[(self.front + i) % self.capacity] self.queue = new_queue self.front = 0 self.rear = self.count self.capacity = new_capacity"},{"question":"Implement a function `find_mst_weight` that uses Kruskal\'s algorithm to find the Minimum Spanning Tree (MST) of a given connected, weighted, undirected graph and return the total weight of the MST. # Function Signature ```python def find_mst_weight(vertex_count: int, edge_list: List[Tuple[int, int, int]]) -> int: # Your code here ``` # Parameters - `vertex_count` (int): Number of vertices in the graph. - `edge_list` (List[Tuple[int, int, int]]): List of tuples representing the edges, where each tuple is in the form `(u, v, weight)`, describing an edge between vertices `u` and `v` with the corresponding weight. # Returns - `int`: Total weight of the Minimum Spanning Tree. # Constraints - `1 <= vertex_count <= 10^5` - `1 <= len(edge_list) <= 2 * 10^5` - All edges have positive weights. - The graph is connected. # Example ```python vertex_count = 5 edge_list = [(1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6)] assert find_mst_weight(vertex_count, edge_list) == 14 ``` # Scenario Imagine you\'re working for a telecommunications company planning to lay down cables to connect various offices in a city. Your task is to ensure that the total length of cables (represented by weights) used to connect all offices is minimized. You can use Kruskal\'s algorithm to determine the minimum cable length needed to connect all offices, ensuring the network is cost-effective. Implement the function `find_mst_weight` based on the above scenario and constraint to find the Minimum Spanning Tree total weight of the given graph. # Notes - Remember to use a proper Union-Find (Disjoint Set) data structure with path compression and union by rank to achieve efficient performance. - Pay attention to edge cases like single-node graphs or duplicate weights.","solution":"from typing import List, Tuple class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, p): if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) # path compression return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 return True return False def find_mst_weight(vertex_count: int, edge_list: List[Tuple[int, int, int]]) -> int: edge_list.sort(key=lambda x: x[2]) uf = UnionFind(vertex_count) mst_weight = 0 for u, v, weight in edge_list: if uf.union(u - 1, v - 1): mst_weight += weight return mst_weight"},{"question":"Pancake Sort Implementation **Context**: Pancake sorting is a technique of sorting a sequence using only the prefix reversal operation, similar to flipping pancakes in a pan. Although it is not the most efficient sorting method by modern standards, it is a fascinating problem to understand the concepts of in-place sorting and array manipulations. **Task**: Write a function `pancake_sort` that sorts a given list of integers using the pancake sorting algorithm. Given an array, your task is to sort the array using the minimum number of flips (reversals). **Function Signature**: ```python def pancake_sort(arr: List[int]) -> List[int]: pass ``` **Input**: - `arr`: A list of integers, which can be of variable length but will always contain values of integers between -10^6 to 10^6. **Output**: - Returns a list of integers in non-decreasing order. **Constraints**: - All elements in the array are integers. - The length of the array will be between 1 and 10^3. **Example**: ```python assert pancake_sort([3, 2, 4, 1]) == [1, 2, 3, 4] assert pancake_sort([5, 1, 2]) == [1, 2, 5] assert pancake_sort([1]) == [1] assert pancake_sort([]) == [] ``` **Notes**: - You may use a reverse operation for sublists but no other sorting operations or mutations should be used. - Aim to achieve O(N^2) complexity in your solution. **Hint**: - Consider how to bring the maximum element to its correct position and reduce the problem size iteratively.","solution":"def flip(arr, k): Helper function to reverse the first k elements of the array. arr[:k] = arr[:k][::-1] def pancake_sort(arr): Pancake sorting function to sort the input list using pancake sorting algorithm. n = len(arr) for size in range(n, 1, -1): # Find the index of the maximum element in arr[:size] max_index = max(range(size), key=arr.__getitem__) # Flip the maximum element to the front if it\'s not already at the front if max_index != size - 1: flip(arr, max_index + 1) # Flip the maximum to the front flip(arr, size) # Flip the maximum to its correct position at the end of the subarray return arr"},{"question":"# Question You need to implement a function that finds two elements in a given list that appear only once while all other elements appear exactly twice. Utilize an efficient algorithm to ensure your solution has a time complexity of O(N) and a space complexity of O(1). Function Signature ```python def single_number3(nums: List[int]) -> List[int]: pass ``` Input * `nums`: List[int] - List of integers where exactly two elements appear only once, and all other elements appear exactly twice. The list contains at least two elements and the list length does not exceed (10^6). Output * `List[int]` - The two elements that appear only once in the list, in any order. Constraints 1. Your solution must have a time complexity of O(N) and space complexity of O(1). 2. The list contains exactly two numbers that appear once. Example ```python assert single_number3([1, 2, 1, 3, 2, 5]) in ([3, 5], [5, 3]) assert single_number3([4, 4, 7, 6, 6, 9]) in ([7, 9], [9, 7]) ``` Description To solve the problem, you can use the XOR operation which is a powerful tool in finding duplicate numbers. Below is a brief guide to follow: 1. XOR all numbers in the list. The resulting value will be the XOR of the two unique numbers. 2. Find one bit that is different between the two numbers by isolating the right-most set bit in the XOR result. 3. Divide the numbers into two groups based on the isolated bit and XOR elements in each group separately. Each result corresponds to one of the unique numbers. Implement the abstract steps into a concrete code to accomplish the task.","solution":"from typing import List def single_number3(nums: List[int]) -> List[int]: # Step 1: XOR all numbers to get the XOR of the two unique numbers xor = 0 for num in nums: xor ^= num # Step 2: Find the right-most set bit of xor rightmost_set_bit = xor & -xor # Step 3: Divide numbers into two groups and XOR each group num1, num2 = 0, 0 for num in nums: if num & rightmost_set_bit: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"# Coding Problem: Huffman Coding Implementation Objective: Implement an algorithm to compress and decompress a given text file using Huffman coding. Your implementation should efficiently encode the input data and be capable of decoding it back to the original data. Function Signature: ```python def encode_file(input_file: str, encoded_file: str) -> None: pass def decode_file(encoded_file: str, decoded_file: str) -> None: pass ``` Constraints: 1. The input file contains any printable ASCII characters. 2. The size of the input file will not exceed 100 MB. Requirements: * Implement the `encode_file` function that: * Reads the content of the specified `input_file`. * Uses Huffman coding to encode the text and writes the encoded data to `encoded_file`. * Stores additional information to reconstruct the Huffman Tree during decoding. * Implement the `decode_file` function that: * Reads the encoded data from `encoded_file`. * Uses the stored information to reconstruct the Huffman Tree. * Decodes the encoded data and writes the original text to `decoded_file`. * Ensure your solution handles edge cases and performs optimally for large inputs. Example Usage: ```python # Encode a file encode_file(\\"input.txt\\", \\"encoded.bin\\") # Decode the file decode_file(\\"encoded.bin\\", \\"decoded.txt\\") ``` Note: * The encoded data in `encoded_file` must not only include the compressed text but also the necessary metadata to reconstruct the original Huffman Tree during decoding. * Your solution should be able to handle and recover from potential errors, such as incorrect format or corrupted data in the encoded file, in a user-friendly manner.","solution":"import heapq import os import pickle class HuffmanNode: def __init__(self, char=None, freq=None): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq def build_frequency_dict(text): frequency = {} for char in text: if char not in frequency: frequency[char] = 0 frequency[char] += 1 return frequency def build_huffman_tree(frequency): heap = [HuffmanNode(char, freq) for char, freq in frequency.items()] heapq.heapify(heap) while len(heap) > 1: node1 = heapq.heappop(heap) node2 = heapq.heappop(heap) merged = HuffmanNode(freq=node1.freq + node2.freq) merged.left = node1 merged.right = node2 heapq.heappush(heap, merged) return heap[0] def build_codes(node, prefix=\\"\\", codebook={}): if node is not None: if node.left is None and node.right is None: # Leaf node codebook[node.char] = prefix or \\"0\\" build_codes(node.left, prefix + \\"0\\", codebook) build_codes(node.right, prefix + \\"1\\", codebook) return codebook def encode_text(text, codebook): return \'\'.join(codebook[char] for char in text) def pad_encoded_text(encoded_text): extra_padding = 8 - len(encoded_text) % 8 for i in range(extra_padding): encoded_text += \\"0\\" padded_info = \\"{0:08b}\\".format(extra_padding) encoded_text = padded_info + encoded_text return encoded_text def get_byte_array(padded_encoded_text): if(len(padded_encoded_text) % 8 != 0): print(\\"Encoded text not padded properly\\") exit(0) byte_array = bytearray() for i in range(0, len(padded_encoded_text), 8): byte = padded_encoded_text[i:i+8] byte_array.append(int(byte, 2)) return byte_array def encode_file(input_file: str, encoded_file: str) -> None: with open(input_file, \'r\') as file: text = file.read() frequency = build_frequency_dict(text) huffman_tree = build_huffman_tree(frequency) codebook = build_codes(huffman_tree) encoded_text = encode_text(text, codebook) padded_encoded_text = pad_encoded_text(encoded_text) byte_array = get_byte_array(padded_encoded_text) with open(encoded_file, \'wb\') as file: file.write(bytes(byte_array)) with open(encoded_file + \\".tree\\", \'wb\') as file: pickle.dump(huffman_tree, file) def remove_padding(padded_encoded_text): padded_info = padded_encoded_text[:8] extra_padding = int(padded_info, 2) padded_encoded_text = padded_encoded_text[8:] encoded_text = padded_encoded_text[:-extra_padding] return encoded_text def decode_text(encoded_text, huffman_tree): decoded_text = \\"\\" current_node = huffman_tree for bit in encoded_text: if bit == \\"0\\": current_node = current_node.left elif bit == \\"1\\": current_node = current_node.right if current_node.left is None and current_node.right is None: decoded_text += current_node.char current_node = huffman_tree return decoded_text def decode_file(encoded_file: str, decoded_file: str) -> None: with open(encoded_file, \'rb\') as file: bit_string = \\"\\" byte = file.read(1) while byte: byte = ord(byte) bits = bin(byte)[2:].rjust(8, \'0\') bit_string += bits byte = file.read(1) encoded_text = remove_padding(bit_string) with open(encoded_file + \\".tree\\", \'rb\') as file: huffman_tree = pickle.load(file) decoded_text = decode_text(encoded_text, huffman_tree) with open(decoded_file, \'w\') as file: file.write(decoded_text)"},{"question":"# Scenario You are developing a system that sends and receives data over a network. One of the tasks requires efficiently transmitting a list of strings as a single concatenated string. The encoded string must correctly represent the original list of strings so it can be reconstructed later. # Task Implement the following functions: `encode` that converts a list of strings to a single string, and `decode` that converts the encoded string back into the original list of strings. # Function Definitions ```python def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. Args: strs (List[str]): List of strings to be encoded. Returns: str: Encoded string representing the list of strings. pass def decode(encoded_str: str) -> List[str]: Decodes a single string back into a list of strings. Args: encoded_str (str): The encoded string representing the list of strings. Returns: List[str]: The original list of strings decoded from the encoded string. pass ``` # Input and Output Formats * **Input to `encode`**: A list of strings `strs`. * **Output from `encode`**: A single encoded string. * **Input to `decode`**: A single encoded string `encoded_str`. * **Output from `decode`**: The original list of strings represented by `encoded_str`. # Constraints * Each string in the list will have a length of `n` (0 <= `n` <= 100). * The total number of strings in the list will be `m` (0 <= `m` <= 10^4). # Performance Requirements * Both `encode` and `decode` functions should operate efficiently even for the upper limit of constraints. * The solution should take linear time in terms of the total length of input strings and the length of the encoded string. # Example ```python # Example usage: original_strings = [\\"hello\\", \\"world\\", \\"!\\", \\"\\"] encoded_string = encode(original_strings) print(encoded_string) # Expected format \\"5:hello5:world1:!0:\\" decoded_strings = decode(encoded_string) print(decoded_strings) # Should output [\'hello\', \'world\', \'!\', \'\'] ``` Additional Notes Think carefully about edge cases: * An empty string in the list. * The original list being empty. * Strings containing numbers and special characters.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings to a single string. Args: strs (List[str]): List of strings to be encoded. Returns: str: Encoded string representing the list of strings. encoded = \\"\\" for s in strs: encoded += f\\"{len(s)}:{s}\\" return encoded def decode(encoded_str: str) -> List[str]: Decodes a single string back into a list of strings. Args: encoded_str (str): The encoded string representing the list of strings. Returns: List[str]: The original list of strings decoded from the encoded string. decoded = [] i = 0 while i < len(encoded_str): # Find the position of the delimiter \':\' j = encoded_str.find(\':\', i) # Get the length of the next string length = int(encoded_str[i:j]) # Extract the actual string decoded.append(encoded_str[j+1:j+1+length]) # Move index to the start of the next length encoding i = j + 1 + length return decoded"},{"question":"# Josephus Problem Implementation You are tasked with implementing a function that solves the Josephus problem. The problem is defined as follows: A group of people stand in a circle awaiting execution. Counting begins at a specified point in the circle and proceeds around the circle in a fixed direction. Every k-th person is executed and removed from the circle. The procedure is repeated with the remaining people, starting with the next person, until only one person remains, who is then freed. Write a function `solve_josephus(int_list: List[int], k: int) -> List[int]` that takes a list of integers representing people in a circle and an integer k as parameters, and returns a list of integers showing the order in which people are executed. Input and Output Formats: - **Input**: - `int_list`: A list of integers representing people in a circular arrangement. - `k`: An integer representing the k-th person to be executed. - **Output**: - A list of integers showing the order in which people are executed. Constraints: - The `int_list` will contain between 1 to 1000 integers. - The integer `k` will be in the range from 1 to 1000. Example: - **Input**: `solve_josephus([1, 2, 3, 4, 5, 6, 7, 8, 9], 3)` - **Output**: `[3, 6, 9, 4, 8, 5, 2, 7, 1]` Performance Requirements: - The function should efficiently handle lists up to the maximum constraint.","solution":"def solve_josephus(int_list, k): Solves the Josephus problem. Parameters: int_list (List[int]): A list of integers representing people in a circular arrangement. k (int): An integer representing the k-th person to be executed. Returns: List[int]: A list of integers showing the order in which people are executed. execution_order = [] index = 0 while len(int_list) > 0: index = (index + k - 1) % len(int_list) execution_order.append(int_list.pop(index)) return execution_order"},{"question":"# Question: Improved Duplicate Removal Function **Scenario:** You are tasked with improving the efficiency of an algorithm that removes duplicates from an array while maintaining the order of elements as their first occurrence. **Goal:** Implement the function `remove_duplicates_optimized(array)` that takes an array as input and returns a new array with duplicates removed. The new function should be optimized for better performance compared to the original implementation. **Requirements:** 1. Maintain the order of elements from their first occurrence in the input array. 2. Optimize the function to have better time complexity than O(n^2). **Function Signature:** ```python def remove_duplicates_optimized(array: list) -> list: ``` **Input:** - `array`: A list of items of any data type (e.g., integers, strings, booleans). The length of the array is between 0 and 10^6. **Output:** - A new list with duplicates removed, preserving the order of their first occurrence in the input list. **Constraints:** 1. The function should have a time complexity of O(n). 2. Do not use additional libraries (e.g., `collections.OrderedDict`). **Performance Requirements:** - The function should handle large inputs of up to 10^6 items efficiently. **Example:** ```python # Example 1 Input: [1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True] Output: [1, 2, 3, 4, \'hey\', \'hello\', True] # Example 2 Input: [42, 42, \\"data\\", \\"science\\", \\"data\\", True, 42] Output: [42, \'data\', \'science\', True] ``` **Notes:** - Ensure your function is thoroughly tested for various edge cases including but not limited to empty input, mixed data types, and large input sizes.","solution":"def remove_duplicates_optimized(array): Remove duplicates from the array while maintaining order. This function has a time complexity of O(n). seen = set() result = [] for item in array: if item not in seen: result.append(item) seen.add(item) return result"},{"question":"# Problem Description You are given two functions, `dfs_traverse_recursive` and `bfs_traverse`, which perform Depth-First Search (DFS) traversal using recursion and Breadth-First Search (BFS) traversal using a queue, respectively. Both functions are designed to traverse a connected graph starting from a provided start node and return the set of visited nodes. However, this implementation does not account for graphs with multiple disconnected components. Your task is to modify these functions to be able to traverse and return all nodes from disconnected components as well, ensuring that all nodes in the graph are visited. # Input - A dictionary representing an undirected graph where keys are node identifiers and values are lists of adjacent nodes. - Start node identifiers for both DFS and BFS functions. # Output - A set of all visited nodes after performing modified DFS traversal. - A set of all visited nodes after performing modified BFS traversal. # Constraints - The graph is represented as an adjacency list (dictionary). - All nodes are positive integers. - The graph can have zero or more disconnected components. - The start node(s) will exist in the graph. # Example ```python graph = { 1: [2, 3], 2: [1], 3: [1, 4], 4: [3], 5: [6], 6: [5] } start = 1 # Expected output: # dfs_traverse_recursive(graph, start) -> {1, 2, 3, 4, 5, 6} # bfs_traverse(graph, start) -> {1, 2, 3, 4, 5, 6} ``` # Implementation Implement the following functions: ```python def modified_dfs(graph, start): # Your code here pass def modified_bfs(graph, start): # Your code here pass ``` # Notes - Ensure that your DFS implementation avoids recursion limits by using an iterative approach. - Clearly handle the case where the graph has multiple disconnected components.","solution":"def modified_dfs(graph, start): visited = set() stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: stack.append(neighbor) # To ensure all components are visited for node in graph: if node not in visited: stack.append(node) while stack: node = stack.pop() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: stack.append(neighbor) return visited def modified_bfs(graph, start): visited = set() queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) # To ensure all components are visited for node in graph: if node not in visited: queue.append(node) while queue: node = queue.pop(0) if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return visited"}]'),C={name:"App",components:{PoemCard:N},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},z={class:"search-container"},O={class:"card-container"},L={key:0,class:"empty-state"},F=["disabled"],R={key:0},Y={key:1};function j(r,e,l,p,s,a){const f=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",z,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",O,[(n(!0),i(b,null,v(a.displayedPoems,(o,m)=>(n(),w(f,{key:m,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",L,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",Y,"Loading...")):(n(),i("span",R,"See more"))],8,F)):u("",!0)])}const P=c(C,[["render",j],["__scopeId","data-v-ce94e2ad"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/40.md","filePath":"drive/40.md"}'),D={name:"drive/40.md"},H=Object.assign(D,{setup(r){return(e,l)=>(n(),i("div",null,[x(P)]))}});export{M as __pageData,H as default};
